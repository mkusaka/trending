<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-17T01:26:46Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>S3cur3Th1sSh1t/Caro-Kann</title>
    <updated>2023-09-17T01:26:46Z</updated>
    <id>tag:github.com,2023-09-17:/S3cur3Th1sSh1t/Caro-Kann</id>
    <link href="https://github.com/S3cur3Th1sSh1t/Caro-Kann" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Encrypted shellcode Injection to avoid Kernel triggered memory scans&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Caro Kann&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/S3cur3Th1sSh1t/Caro-Kann/raw/main/images/CaroKann.jpg?raw=true&#34; alt=&#34;Caro Kann defense&#34; width=&#34;400&#34; height=&#34;400&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Encrypted shellcode Injection to avoid memory scans triggered from Kernel (ETWti / Kernel Callbacks). Specific combinations of Windows APIs, e.g. for injection into a remote process can lead to a memory scan:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/S3cur3Th1sSh1t/Caro-Kann/raw/main/images/ScanTrigger.png?raw=true&#34; alt=&#34;ScanTrigger&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Typically, the scan can be triggered from Userland via hooks on the execute primitive such as &lt;code&gt;NtCreateThreadEx&lt;/code&gt;. But more and more EDR vendors also tend to trigger scans from Kernel, for example after the Kernel Callback &lt;code&gt;PsSetCreateThreadNotifyRoutine()&lt;/code&gt; a scan could be triggered. But what if there is no executable memory section with known malicious code? Well, no alert for an detection I guess.&lt;/p&gt; &#xA;&lt;p&gt;&lt;ins&gt;The idea is as follows:&lt;/ins&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Inject encrypted &lt;ins&gt;known malicious&lt;/ins&gt; payload into an &lt;code&gt;RW&lt;/code&gt; section&lt;/li&gt; &#xA; &lt;li&gt;Inject custom non &lt;ins&gt;known malicious&lt;/ins&gt; shellcode into an &lt;code&gt;RX&lt;/code&gt; section&lt;/li&gt; &#xA; &lt;li&gt;Create a remote Thread on the second shellcode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/S3cur3Th1sSh1t/Caro-Kann/raw/main/images/Inject.png?raw=true&#34; alt=&#34;Inject&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;ins&gt;The custom shellcode will than:&lt;/ins&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sleep for an amount x (to avoid memory scans triggered by the execute primitive of Thread creation)&lt;/li&gt; &#xA; &lt;li&gt;Decrypt the first &lt;ins&gt;known malicious&lt;/ins&gt; shellcode&lt;/li&gt; &#xA; &lt;li&gt;Protect the section from &lt;code&gt;RW&lt;/code&gt; to &lt;code&gt;RX&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Make a direct &lt;code&gt;JMP&lt;/code&gt; to the known malicious shellcode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/S3cur3Th1sSh1t/Caro-Kann/raw/main/images/Shellcode.png?raw=true&#34; alt=&#34;Shellcode&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;On linux, the PIC-Code was found to be compiled correctly with &lt;code&gt;mingw-w64&lt;/code&gt; version &lt;code&gt;version 10-win32 20220324 (GCC)&lt;/code&gt;. With that version installed, the shellcode can be compiled with a simple &lt;code&gt;make&lt;/code&gt; and extracted from the &lt;code&gt;.text&lt;/code&gt; section via &lt;code&gt;bash extract.sh&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to compile from Windows, you can use the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;as -o adjuststack.o adjuststack_as.asm&#xA;gcc ApiResolve.c -Wall -m64 -ffunction-sections -fno-asynchronous-unwind-tables -nostdlib -fno-ident -O2 -c -o ApiResolve.o -Wl,--no-seh&#xA;gcc DecryptProtect.c -Wall -m64 -masm=intel -ffunction-sections -fno-asynchronous-unwind-tables -nostdlib -fno-ident -O2 -c -o decryptprotect.o -Wl,--no-seh&#xA;ld -s adjuststack.o ApiResolve.o decryptprotect.o -o decryptprotect.exe&#xA;gcc extract.c -o extract.exe&#xA;extract.exe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You also need to have &lt;a href=&#34;https://nim-lang.org/&#34;&gt;Nim&lt;/a&gt; installed for this PoC.&lt;/p&gt; &#xA;&lt;p&gt;&lt;ins&gt;After installation, the dependencies can be installed via the following oneliner:&lt;/ins&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nim&#34;&gt;nimble install winim ptr_math&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;ins&gt;The PoC can than be compiled with:&lt;/ins&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nim&#34;&gt;nim c -d:release -d=mingw -d:noRes CaroKann.nim # Cross compile&#xA;nim c -d:release CaroKann.nim # Windows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any payload can be XOR encrypted with the given &lt;code&gt;encrypt.cpp&lt;/code&gt; code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: encrypter.exe input_file output_file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The encrypted payload can than be embedded in the PoC via the following line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;const shellcode = slurp&#34;&amp;lt;encrypted.bin&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;OPSec improvement ideas&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bypass Userland-Hooks for Injection (although not really needed, but for fun)&lt;/li&gt; &#xA; &lt;li&gt;Back Payload(s) by legitimate DLL (Module Stomping)&lt;/li&gt; &#xA; &lt;li&gt;Load C2-Dlls via the first Shellcode - which can avoid memory scans triggered by module loads&lt;/li&gt; &#xA; &lt;li&gt;Use ThreadlessInject or DLLNotificationInjection instead of Remote Thread Creation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;OPSec considerations for C2-Payloads&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Should use Sleep encryption, otherwise the payload will get flagged later&lt;/li&gt; &#xA; &lt;li&gt;Should use Unhooking first or (in)direct Syscalls&lt;/li&gt; &#xA; &lt;li&gt;Should use Proxy module loading&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>grafana/beyla</title>
    <updated>2023-09-17T01:26:46Z</updated>
    <id>tag:github.com,2023-09-17:/grafana/beyla</id>
    <link href="https://github.com/grafana/beyla" rel="alternate"></link>
    <summary type="html">&lt;p&gt;eBPF-based autoinstrumentation of HTTP and HTTPS services&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/grafana/beyla/main/docs/sources/assets/logo.png&#34; height=&#34;226&#34; alt=&#34;Grafana Beyla logo&#34;&gt; &#xA;&lt;h1&gt;Grafana Beyla&lt;/h1&gt; &#xA;&lt;p&gt;eBPF-based auto-instrumentation of HTTP/HTTPS/GRPC Go services, as well as HTTP/HTTPS services written in other languages (intercepting Kernel-level socket operations as well as OpenSSL invocations).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://drone.grafana.net/grafana/beyla&#34;&gt;&lt;img src=&#34;https://drone.grafana.net/api/badges/grafana/beyla/status.svg?ref=refs/heads/main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;To try out Beyla, you need to run a network service for Beyla to instrument. Beyla supports a wide range of programming languages (Go, Java, .NET, NodeJS, Python, Ruby, Rust, etc.), so if you already have an example service you can use it. If you don&#39;t have an example, you can download and run &lt;code&gt;example-http-service.go&lt;/code&gt; from the &lt;code&gt;examples/&lt;/code&gt; directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -OL https://raw.githubusercontent.com/grafana/beyla/main/examples/example-http-service/example-http-service.go&#xA;go run ./example-http-service.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, generate some traffic. The following command will trigger a GET request to &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt; every two seconds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;watch curl -s http://localhost:8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we have an example running, we are ready to download and run Beyla.&lt;/p&gt; &#xA;&lt;p&gt;First, download and unpack the latest release from the &lt;a href=&#34;https://github.com/grafana/beyla/releases&#34;&gt;Github releases page&lt;/a&gt;. The release should contain the &lt;code&gt;./beyla&lt;/code&gt; executable.&lt;/p&gt; &#xA;&lt;p&gt;Beyla supports multiple ways to find the service to be instrumented (by network port, executable name, process ID), and multiple exposition formats (Prometheus, OpenTelemetry metrics, Single Span traces).&lt;/p&gt; &#xA;&lt;p&gt;For getting started, we&#39;ll tell Beyla to instrument the service running on port 8080 (our example service) and expose metrics in Prometheus format on port 9400.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export BEYLA_PROMETHEUS_PORT=9400&#xA;export OPEN_PORT=8080&#xA;sudo -E ./beyla&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, you should see metrics on &lt;a href=&#34;http://localhost:9400/metrics&#34;&gt;http://localhost:9400/metrics&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://grafana.com/docs/grafana-cloud/monitor-applications/beyla/&#34;&gt;Documentation&lt;/a&gt; and the &lt;a href=&#34;https://raw.githubusercontent.com/grafana/beyla/main/docs/sources/tutorial/index.md&#34;&gt;quickstart tutorial&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux with Kernel 4.18 or higher&lt;/li&gt; &#xA; &lt;li&gt;eBPF enabled in the host&lt;/li&gt; &#xA; &lt;li&gt;For instrumenting Go programs, they must have been compiled with Go 1.17 or higher&lt;/li&gt; &#xA; &lt;li&gt;Administrative access to execute the instrumenter &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Or execute it from a user enabling the &lt;code&gt;SYS_ADMIN&lt;/code&gt; capability.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If you want to instrument HTTP calls at kernel-level (for other languages than Go), your Kernel needs to enable BTF (&lt;a href=&#34;https://www.baeldung.com/linux/kernel-config&#34;&gt;compiled with &lt;code&gt;CONFIG_DEBUG_INFO_BTF&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;Working&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Kernel-level HTTP calls&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OpenSSL library&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Standard &lt;code&gt;net/http&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/gorilla/mux&#34;&gt;Gorilla Mux&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://gin-gonic.com/&#34;&gt;Gin&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/grpc/grpc-go&#34;&gt;gRPC-Go&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Kubernetes&lt;/h2&gt; &#xA;&lt;p&gt;You can just trigger the Kubernetes descriptors in the &lt;code&gt;deployments/&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Provide your Grafana credentials. Use the following &lt;a href=&#34;https://raw.githubusercontent.com/grafana/beyla/main/deployments/01-grafana-credentials.template.yml&#34;&gt;K8s Secret template&lt;/a&gt; to introduce the endpoints, usernames and API keys for Mimir and Tempo:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ cp deployments/01-grafana-credentials.template.yml 01-grafana-credentials.yml&#xA;$ # EDIT the fields&#xA;$ vim 01-grafana-credentials.yml&#xA;$ kubectl apply -f 01-grafana-credentials.yml &#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Deploy the Grafana Agent:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;kubectl apply -f deployments/02-grafana-agent.yml&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Deploy a demo app with the auto-instrumenter as a sidecar. You can use the blog example in the &lt;a href=&#34;https://raw.githubusercontent.com/grafana/beyla/main/deployments/03-instrumented-app.yml&#34;&gt;deployments/03-instrumented-app.yml&lt;/a&gt; file.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ kubectl apply -f ./deployments/03-instrumented-app.yml&#xA;$ kubectl port-forward service/goblog 8443:8443&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You should be able to query traces and metrics in your Grafana board.&lt;/p&gt; &#xA;&lt;h2&gt;Development recipes&lt;/h2&gt; &#xA;&lt;h3&gt;How to regenerate the eBPF Kernel binaries&lt;/h3&gt; &#xA;&lt;p&gt;The eBPF program is embedded into the &lt;code&gt;pkg/internal/ebpf/bpf_*&lt;/code&gt; generated files. This step is generally not needed unless you change the C code in the &lt;code&gt;bpf&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;If you have Docker installed, you just need to run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make docker-generate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you can&#39;t install docker, you should locally install the following required packages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnf install -y kernel-devel make llvm clang glibc-devel.i686&#xA;make generate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tested in Fedora 35, 38 and Red Hat Enterprise Linux 8.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Part of the code is taken from: &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-go-instrumentation&#34;&gt;https://github.com/open-telemetry/opentelemetry-go-instrumentation&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>samtools/htslib</title>
    <updated>2023-09-17T01:26:46Z</updated>
    <id>tag:github.com,2023-09-17:/samtools/htslib</id>
    <link href="https://github.com/samtools/htslib" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C library for high-throughput sequencing data formats&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://api.cirrus-ci.com/github/samtools/htslib&#34;&gt;&lt;img src=&#34;https://api.cirrus-ci.com/github/samtools/htslib.svg?branch=develop&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/samtools/htslib/branch/develop&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/v46hkwyfjp3l8nd3/branch/develop?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/samtools/htslib&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/samtools/htslib/total.svg?sanitize=true&#34; alt=&#34;Github All Releases&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;HTSlib is an implementation of a unified C library for accessing common file formats, such as &lt;a href=&#34;http://samtools.github.io/hts-specs/&#34;&gt;SAM, CRAM and VCF&lt;/a&gt;, used for high-throughput sequencing data, and is the core library used by &lt;a href=&#34;http://github.com/samtools/samtools&#34;&gt;samtools&lt;/a&gt; and &lt;a href=&#34;http://samtools.github.io/bcftools/&#34;&gt;bcftools&lt;/a&gt;. HTSlib only depends on &lt;a href=&#34;http://zlib.net/&#34;&gt;zlib&lt;/a&gt;. It is known to be compatible with gcc, g++ and clang.&lt;/p&gt; &#xA;&lt;p&gt;HTSlib implements a generalized BAM index, with file extension &lt;code&gt;.csi&lt;/code&gt; (coordinate-sorted index). The HTSlib file reader first looks for the new index and then for the old if the new index is absent.&lt;/p&gt; &#xA;&lt;p&gt;This project also includes the popular tabix indexer, which creates both &lt;code&gt;.tbi&lt;/code&gt; and &lt;code&gt;.csi&lt;/code&gt; formats, and the bgzip compression utility.&lt;/p&gt; &#xA;&lt;h3&gt;Building HTSlib&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/samtools/htslib/develop/INSTALL&#34;&gt;INSTALL&lt;/a&gt; for complete details. &lt;a href=&#34;http://www.htslib.org/download/&#34;&gt;Release tarballs&lt;/a&gt; contain generated files that have not been committed to this repository, so building the code from a Git repository requires extra steps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;autoreconf -i  # Build the configure script and install files it uses&#xA;./configure    # Optional but recommended, for choosing extra functionality&#xA;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Citing&lt;/h3&gt; &#xA;&lt;p&gt;Please cite this paper when using HTSlib for your publications.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;HTSlib: C library for reading/writing high-throughput sequencing data &lt;br&gt; James K Bonfield, John Marshall, Petr Danecek, Heng Li, Valeriu Ohan, Andrew Whitwham, Thomas Keane, Robert M Davies &lt;br&gt; &lt;em&gt;GigaScience&lt;/em&gt;, Volume 10, Issue 2, February 2021, giab007, &lt;a href=&#34;https://doi.org/10.1093/gigascience/giab007&#34;&gt;https://doi.org/10.1093/gigascience/giab007&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code&gt;@article{10.1093/gigascience/giab007,&#xA;    author = {Bonfield, James K and Marshall, John and Danecek, Petr and Li, Heng and Ohan, Valeriu and Whitwham, Andrew and Keane, Thomas and Davies, Robert M},&#xA;    title = &#34;{HTSlib: C library for reading/writing high-throughput sequencing data}&#34;,&#xA;    journal = {GigaScience},&#xA;    volume = {10},&#xA;    number = {2},&#xA;    year = {2021},&#xA;    month = {02},&#xA;    abstract = &#34;{Since the original publication of the VCF and SAM formats, an explosion of software tools have been created to process these data files. To facilitate this a library was produced out of the original SAMtools implementation, with a focus on performance and robustness. The file formats themselves have become international standards under the jurisdiction of the Global Alliance for Genomics and Health.We present a software library for providing programmatic access to sequencing alignment and variant formats. It was born out of the widely used SAMtools and BCFtools applications. Considerable improvements have been made to the original code plus many new features including newer access protocols, the addition of the CRAM file format, better indexing and iterators, and better use of threading.Since the original Samtools release, performance has been considerably improved, with a BAM read-write loop running 5 times faster and BAM to SAM conversion 13 times faster (both using 16 threads, compared to Samtools 0.1.19). Widespread adoption has seen HTSlib downloaded \\&amp;amp;gt;1 million times from GitHub and conda. The C library has been used directly by an estimated 900 GitHub projects and has been incorporated into Perl, Python, Rust, and R, significantly expanding the number of uses via other languages. HTSlib is open source and is freely available from htslib.org under MIT/BSD license.}&#34;,&#xA;    issn = {2047-217X},&#xA;    doi = {10.1093/gigascience/giab007},&#xA;    url = {https://doi.org/10.1093/gigascience/giab007},&#xA;    note = {giab007},&#xA;    eprint = {https://academic.oup.com/gigascience/article-pdf/10/2/giab007/36332285/giab007.pdf},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>