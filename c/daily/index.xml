<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-12T01:30:48Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Hirrolot/datatype99</title>
    <updated>2024-05-12T01:30:48Z</updated>
    <id>tag:github.com,2024-05-12:/Hirrolot/datatype99</id>
    <link href="https://github.com/Hirrolot/datatype99" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Algebraic data types for C99&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/examples/binary_tree.c&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/images/preview.png&#34; width=&#34;600&#34;&gt;&lt;/a&gt; &#xA; &lt;h1&gt;Datatype99&lt;/h1&gt; &#xA; &lt;a href=&#34;https://github.com/Hirrolot/datatype99/actions&#34;&gt; &lt;img src=&#34;https://github.com/Hirrolot/datatype99/workflows/C/C++%20CI/badge.svg?sanitize=true&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://lists.sr.ht/~hirrolot/metalang99&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/mailing%20list-lists.sr.ht-orange&#34;&gt; &lt;/a&gt; &#xA; &lt;p&gt;Safe, intuitive &lt;a href=&#34;https://en.wikipedia.org/wiki/Algebraic_data_type&#34;&gt;algebraic data types&lt;/a&gt; with exhaustive pattern matching &amp;amp; compile-time introspection facilities. No external tools required, pure C99.&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Highlights&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Type-safe.&lt;/strong&gt; Such things as improperly typed variants, non-exhaustive pattern matching, and invalid field access are caught at compile-time.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Portable.&lt;/strong&gt; Everything you need is a standard-conforming C99 compiler; neither the standard library, nor compiler/platform-specific functionality or VLA are required.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Predictable.&lt;/strong&gt; Datatype99 comes with formal &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/#semantics&#34;&gt;code generation semantics&lt;/a&gt;, meaning that the generated data layout is guaranteed to always be the same.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Comprehensible errors.&lt;/strong&gt; Datatype99 is &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/#q-what-about-compile-time-errors&#34;&gt;resilient to bad code&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Battle-tested.&lt;/strong&gt; Datatype99 is used at &lt;a href=&#34;https://openipc.org/&#34;&gt;OpenIPC&lt;/a&gt; to develop real-time streaming software for IP cameras; this includes an &lt;a href=&#34;https://github.com/OpenIPC/smolrtsp/&#34;&gt;RTSP 1.0 implementation&lt;/a&gt; along with ~50k lines of private code.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Datatype99 consists of one header file &lt;code&gt;datatype99.h&lt;/code&gt; and one dependency &lt;a href=&#34;https://github.com/Hirrolot/metalang99&#34;&gt;Metalang99&lt;/a&gt;. To use it in your project, you need to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add &lt;code&gt;datatype99&lt;/code&gt; and &lt;code&gt;metalang99/include&lt;/code&gt; to your include directories.&lt;/li&gt; &#xA; &lt;li&gt;Specify &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html&#34;&gt;&lt;code&gt;-ftrack-macro-expansion=0&lt;/code&gt;&lt;/a&gt; (GCC) or &lt;a href=&#34;https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fmacro-backtrace-limit&#34;&gt;&lt;code&gt;-fmacro-backtrace-limit=1&lt;/code&gt;&lt;/a&gt; (Clang) to avoid useless macro expansion errors.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you use CMake, the recommended way is &lt;a href=&#34;https://cmake.org/cmake/help/latest/module/FetchContent.html&#34;&gt;&lt;code&gt;FetchContent&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;include(FetchContent)&#xA;&#xA;FetchContent_Declare(&#xA;    datatype99&#xA;    URL https://github.com/Hirrolot/datatype99/archive/refs/tags/v1.2.3.tar.gz # v1.2.3&#xA;)&#xA;&#xA;FetchContent_MakeAvailable(datatype99)&#xA;&#xA;target_link_libraries(MyProject datatype99)&#xA;&#xA;# Disable full macro expansion backtraces for Metalang99.&#xA;if(CMAKE_C_COMPILER_ID STREQUAL &#34;Clang&#34;)&#xA;  target_compile_options(MyProject PRIVATE -fmacro-backtrace-limit=1)&#xA;elseif(CMAKE_C_COMPILER_ID STREQUAL &#34;GNU&#34;)&#xA;  target_compile_options(MyProject PRIVATE -ftrack-macro-expansion=0)&#xA;endif()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(By default, &lt;code&gt;datatype99/CMakeLists.txt&lt;/code&gt; downloads Metalang99 &lt;a href=&#34;https://github.com/Hirrolot/metalang99/releases/tag/v1.13.2&#34;&gt;v1.13.2&lt;/a&gt; from the GitHub releases; if you want to override this behaviour, you can do so by invoking &lt;a href=&#34;https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_declare&#34;&gt;&lt;code&gt;FetchContent_Declare&lt;/code&gt;&lt;/a&gt; earlier.)&lt;/p&gt; &#xA;&lt;p&gt;Optionally, you can &lt;a href=&#34;https://en.wikipedia.org/wiki/Precompiled_header&#34;&gt;precompile headers&lt;/a&gt; in your project that rely on Datatype99. This will decrease compilation time, because the headers will not be compiled each time they are included.&lt;/p&gt; &#xA;&lt;p&gt;Happy hacking!&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Put simply, Datatype99 is just a syntax sugar over &lt;a href=&#34;https://en.wikipedia.org/wiki/Tagged_union&#34;&gt;tagged unions&lt;/a&gt;; the only difference is that it is more safe and concise. For example, to represent a binary tree, you would normally write something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {&#xA;    struct BinaryTree *lhs;&#xA;    int x;&#xA;    struct BinaryTree *rhs;&#xA;} BinaryTreeNode;&#xA;&#xA;typedef struct {&#xA;    enum { Leaf, Node } tag;&#xA;    union {&#xA;        int leaf;&#xA;        BinaryTreeNode node;&#xA;    } data;&#xA;} BinaryTree;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To avoid this boilerplate, you can use Datatype99:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;datatype(&#xA;    BinaryTree,&#xA;    (Leaf, int),&#xA;    (Node, BinaryTree *, int, BinaryTree *)&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Say you want to sum all nodes and leafs in your binary tree. Then you may write something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sum(const BinaryTree *tree) {&#xA;    switch (tree-&amp;gt;tag) {&#xA;    case Leaf:&#xA;        return tree-&amp;gt;data.leaf;&#xA;    case Node:&#xA;        return sum(tree-&amp;gt;data.node.lhs) + tree-&amp;gt;data.node.x + sum(tree-&amp;gt;data.node.rhs);&#xA;    }&#xA;&#xA;    // Invalid input (no such variant).&#xA;    return -1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... but what if you accidentally access &lt;code&gt;tree-&amp;gt;data.node&lt;/code&gt; after &lt;code&gt;case Leaf:&lt;/code&gt;? Your compiler would not warn you, thus resulting in a business logic bug.&lt;/p&gt; &#xA;&lt;p&gt;With Datatype99, you can rewrite &lt;code&gt;sum&lt;/code&gt; as follows, using a technique called &lt;em&gt;pattern matching&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sum(const BinaryTree *tree) {&#xA;    match(*tree) {&#xA;        of(Leaf, x) return *x;&#xA;        of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);&#xA;    }&#xA;&#xA;    // Invalid input (no such variant).&#xA;    return -1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;of&lt;/code&gt; gives you variables called &lt;em&gt;bindings&lt;/em&gt;: &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;lhs&lt;/code&gt;, or &lt;code&gt;rhs&lt;/code&gt;. This design has a few neat aspects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Compile-time safety.&lt;/strong&gt; The bindings of &lt;code&gt;Node&lt;/code&gt; are invisible after &lt;code&gt;of(Leaf, x)&lt;/code&gt; and vice versa, so compilation will fail to proceed if you access them inappropriately.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Flexibility.&lt;/strong&gt; Bindings have pointer types so that you can mutate them, thereby mutating the whole &lt;code&gt;tree&lt;/code&gt;; in order to obtain a value, you can dereference them, as shown in the example: &lt;code&gt;return *x;&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The last thing unmentioned is how you construct variants. Internally, Datatype99 generates &lt;code&gt;inline static&lt;/code&gt; functions called &lt;em&gt;value constructors&lt;/em&gt;; you can use them as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;BinaryTree leaf5 = Leaf(5);&#xA;BinaryTree leaf7 = Leaf(7);&#xA;BinaryTree node = Node(&amp;amp;leaf5, 123, &amp;amp;leaf7);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, just a few brief notes about pattern matching:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To match the default case, write &lt;code&gt;otherwise { ... }&lt;/code&gt; at the end of &lt;code&gt;match&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To ignore a binding, write &lt;code&gt;_&lt;/code&gt;: &lt;code&gt;of(Foo, a, b, _, d)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Please, &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/#top-level-breakcontinue&#34;&gt;&lt;strong&gt;do not use top-level &lt;code&gt;break&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; inside statements provided to &lt;code&gt;of&lt;/code&gt; and &lt;code&gt;ifLet&lt;/code&gt;; use &lt;code&gt;goto&lt;/code&gt; labels instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Congratulations, this is all you need to know to write most of the stuff! If you feel fancy, you can also introspect your types at compile-time; see &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/examples/derive/&#34;&gt;&lt;code&gt;examples/derive/&lt;/code&gt;&lt;/a&gt; for the examples.&lt;/p&gt; &#xA;&lt;h2&gt;Syntax and semantics&lt;/h2&gt; &#xA;&lt;p&gt;Having a well-defined semantics of the macros, you can write an FFI which is quite common in C.&lt;/p&gt; &#xA;&lt;h3&gt;EBNF syntax&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ebnf&#34;&gt;&amp;lt;datatype&amp;gt;      ::= &#34;datatype(&#34; [ &amp;lt;derive-clause&amp;gt; &#34;,&#34; ] &amp;lt;datatype-name&amp;gt; { &#34;,&#34; &amp;lt;variant&amp;gt; }+ &#34;)&#34; ;&#xA;&amp;lt;record&amp;gt;        ::= &#34;record(&#34;   [ &amp;lt;derive-clause&amp;gt; &#34;,&#34; ] &amp;lt;record-name&amp;gt;   { &#34;,&#34; &amp;lt;field&amp;gt;   }* &#34;)&#34; ;&#xA;&amp;lt;datatype-name&amp;gt; ::= &amp;lt;ident&amp;gt; ;&#xA;&amp;lt;record-name&amp;gt;   ::= &amp;lt;ident&amp;gt; ;&#xA;&#xA;&amp;lt;variant&amp;gt;       ::= &#34;(&#34; &amp;lt;variant-name&amp;gt; { &#34;,&#34; &amp;lt;type&amp;gt; }* &#34;)&#34; ;&#xA;&amp;lt;field&amp;gt;         ::= &#34;(&#34; &amp;lt;type&amp;gt; &#34;,&#34; &amp;lt;field-name&amp;gt; &#34;)&#34; ;&#xA;&amp;lt;variant-name&amp;gt;  ::= &amp;lt;ident&amp;gt; ;&#xA;&amp;lt;field-name&amp;gt;    ::= &amp;lt;ident&amp;gt; ;&#xA;&#xA;&amp;lt;derive-clause&amp;gt; ::= &#34;derive(&#34; &amp;lt;deriver-name&amp;gt; { &#34;,&#34; &amp;lt;deriver-name&amp;gt; }* &#34;)&#34; ;&#xA;&amp;lt;deriver-name&amp;gt;  ::= &amp;lt;ident&amp;gt; ;&#xA;&#xA;&amp;lt;match&amp;gt;         ::= &#34;match(&#34; &amp;lt;lvalue&amp;gt; &#34;) {&#34; { &amp;lt;of&amp;gt; }* [ &amp;lt;otherwise&amp;gt; ] &#34;}&#34; ;&#xA;&amp;lt;matches&amp;gt;       ::= &#34;MATCHES(&#34; &amp;lt;expr&amp;gt; &#34;,&#34; &amp;lt;ident&amp;gt; &#34;)&#34; ;&#xA;&amp;lt;if-let&amp;gt;        ::= &#34;ifLet(&#34; &amp;lt;lvalue&amp;gt; &#34;,&#34; &amp;lt;variant-name&amp;gt; &#34;,&#34; &amp;lt;ident&amp;gt; { &#34;,&#34; &amp;lt;ident&amp;gt; }* &#34;)&#34; &amp;lt;stmt&amp;gt; ;&#xA;&amp;lt;of&amp;gt;            ::= &#34;of(&#34; &amp;lt;variant-name&amp;gt; { &#34;,&#34; &amp;lt;ident&amp;gt; }* &#34;)&#34; &amp;lt;stmt&amp;gt; ;&#xA;&amp;lt;otherwise&amp;gt;     ::= &#34;otherwise&#34; &amp;lt;stmt&amp;gt; ;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Note: shortened vs. postfixed versions&lt;/summary&gt; &#xA; &lt;p&gt;Each listed identifier in the above grammar corresponds to a macro name defined by default -- these are called &lt;em&gt;shortened versions&lt;/em&gt;. On the other hand, there are also &lt;em&gt;postfixed versions&lt;/em&gt; (&lt;code&gt;match99&lt;/code&gt;, &lt;code&gt;of99&lt;/code&gt;, &lt;code&gt;derive99&lt;/code&gt;, etc.), which are defined unconditionally. If you want to avoid name clashes caused by shortened versions, define &lt;code&gt;DATATYPE99_NO_ALIASES&lt;/code&gt; before including &lt;code&gt;datatype99.h&lt;/code&gt;. Library headers are strongly advised to use the postfixed macros, but without resorting to &lt;code&gt;DATATYPE99_NO_ALIASES&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Semantics&lt;/h3&gt; &#xA;&lt;p&gt;(It might be helpful to look at the &lt;a href=&#34;https://godbolt.org/z/rebxMxW43&#34;&gt;generated data layout&lt;/a&gt; of &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/examples/binary_tree.c&#34;&gt;&lt;code&gt;examples/binary_tree.c&lt;/code&gt;&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;datatype&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Before everything, the following type definition is generated:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;typedef struct &amp;lt;datatype-name&amp;gt; &amp;lt;datatype-name&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;For each non-empty variant, the following type definition is generated (the metavariable &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; ranges over a corresponding variant&#39;s types):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;typedef struct &amp;lt;datatype-name&amp;gt;&amp;lt;variant-name&amp;gt; {&#xA;    &amp;lt;type&amp;gt;0 _0;&#xA;    ...&#xA;    &amp;lt;type&amp;gt;N _N;&#xA;} &amp;lt;datatype-name&amp;gt;&amp;lt;variant-name&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;For each non-empty variant, the following type definitions to types of each field of &lt;code&gt;&amp;lt;datatype-name&amp;gt;&amp;lt;variant-name&amp;gt;&lt;/code&gt; are generated:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;typedef &amp;lt;type&amp;gt;0 &amp;lt;variant-name&amp;gt;_0;&#xA;...&#xA;typedef &amp;lt;type&amp;gt;N &amp;lt;variant-name&amp;gt;_N;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;For each variant, the following type definition to a corresponding sum type is generated:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;typedef struct &amp;lt;datatype-name&amp;gt; &amp;lt;variant-name&amp;gt;SumT;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;For each sum type, the following tagged union is generated (inside the union, only fields to structures of non-empty variants are generated):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;typedef enum &amp;lt;datatype-name&amp;gt;Tag {&#xA;    &amp;lt;variant-name&amp;gt;0Tag, ..., &amp;lt;variant-name&amp;gt;NTag&#xA;} &amp;lt;datatype-name&amp;gt;Tag;&#xA;&#xA;typedef union &amp;lt;datatype-name&amp;gt;Variants {&#xA;    char dummy;&#xA;&#xA;    &amp;lt;datatype-name&amp;gt;&amp;lt;variant-name&amp;gt;0 &amp;lt;variant-name&amp;gt;0;&#xA;    ...&#xA;    &amp;lt;datatype-name&amp;gt;&amp;lt;variant-name&amp;gt;N &amp;lt;variant-name&amp;gt;N;&#xA;} &amp;lt;datatype-name&amp;gt;Variants;&#xA;&#xA;struct &amp;lt;datatype-name&amp;gt; {&#xA;    &amp;lt;datatype-name&amp;gt;Tag tag;&#xA;    &amp;lt;datatype-name&amp;gt;Variants data;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Note on char dummy;&lt;/summary&gt; &#xA; &lt;p&gt;&lt;code&gt;char dummy;&lt;/code&gt; is needed to make the union contain at least one item, according to the standard, even if all variants are empty. Such a &lt;code&gt;datatype&lt;/code&gt; would enforce strict type checking unlike plain C &lt;code&gt;enum&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;For each variant, the following function called a &lt;em&gt;value constructor&lt;/em&gt; is generated:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;inline static &amp;lt;datatype-name&amp;gt; &amp;lt;variant-name&amp;gt;(/* ... */) { /* ... */ }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the variant has no parameters, this function will take &lt;code&gt;void&lt;/code&gt; and initialise &lt;code&gt;.data.dummy&lt;/code&gt; to &lt;code&gt;&#39;\0&#39;&lt;/code&gt;; otherwise, it will take the corresponding variant parameters and initialise the result value as expected.&lt;/p&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;Now, when a sum type is fully generated, the derivation process takes place. Each deriver taken from &lt;code&gt;derive(...)&lt;/code&gt; is invoked sequentially, from left to right, as&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;ML99_call(DATATYPE99_DERIVE_##&amp;lt;deriver-name&amp;gt;I, v(&amp;lt;datatype-name&amp;gt;), variants...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;deriver-name&amp;gt;I&lt;/code&gt; corresponds to a &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/#definitions&#34;&gt;Metalang99-compliant&lt;/a&gt; macro of the form &lt;code&gt;#define DATATYPE99_DERIVE_##&amp;lt;deriver-name&amp;gt;I_IMPL(name, variants) /* ... */&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;variants...&lt;/code&gt; is a &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/list.html&#34;&gt;list&lt;/a&gt; of variants represented as two-place &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/tuple.html&#34;&gt;tuples&lt;/a&gt;: &lt;code&gt;(&amp;lt;variant-name&amp;gt;, types...)&lt;/code&gt;, where &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;types...&lt;/code&gt; is a &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/list.html&#34;&gt;list&lt;/a&gt; of types of the corresponding variant.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Put simply, a deriver is meant to generate something global for a sum type, like interface implementations or almost any other stuff. In terms of Rust, you can think of it as of the &lt;a href=&#34;https://doc.rust-lang.org/reference/attributes/derive.html&#34;&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;record&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;record&lt;/code&gt; represents a &lt;em&gt;record type&lt;/em&gt;: it is simply a &lt;code&gt;struct&lt;/code&gt; for which the derivation process is defined.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The following structure is generated:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;typedef struct &amp;lt;record-name&amp;gt; {&#xA;    // Only if &amp;lt;record-name&amp;gt; has no fields:&#xA;    char dummy;&#xA;&#xA;    &amp;lt;type&amp;gt;0 &amp;lt;field-name&amp;gt;0;&#xA;    ...&#xA;    &amp;lt;type&amp;gt;N &amp;lt;field-name&amp;gt;N;&#xA;} &amp;lt;record-name&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Note on char dummy;&lt;/summary&gt; &#xA; &lt;p&gt;&lt;code&gt;char dummy;&lt;/code&gt; is needed to make the structure contain at least one item, according to the standard. Such &lt;code&gt;record(Foo)&lt;/code&gt; can be used to implement interfaces for it (see &lt;a href=&#34;https://github.com/Hirrolot/interface99&#34;&gt;Interface99&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Each deriver taken from &lt;code&gt;derive(...)&lt;/code&gt; is invoked sequentially, from left to right, as&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;ML99_call(DATATYPE99_RECORD_DERIVE_##&amp;lt;deriver-name&amp;gt;I, v(&amp;lt;record-name&amp;gt;), fields...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;deriver-name&amp;gt;I&lt;/code&gt; corresponds to a &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/#definitions&#34;&gt;Metalang99-compliant&lt;/a&gt; macro of the form &lt;code&gt;#define DATATYPE99_RECORD_DERIVE_##&amp;lt;deriver-name&amp;gt;I_IMPL(name, fields) /* ... */&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fields...&lt;/code&gt; is a &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/list.html&#34;&gt;list&lt;/a&gt; of fields represented as two-place &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/tuple.html&#34;&gt;tuples&lt;/a&gt;: &lt;code&gt;(&amp;lt;type&amp;gt;, &amp;lt;field-name&amp;gt;)&lt;/code&gt;. If a record contains no fields, the list would consist only of &lt;code&gt;(char, dummy)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;match&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;match&lt;/code&gt; has the expected semantics: it sequentially tries to match the given instance of a sum type against the given variants, and, if a match has succeeded, it executes the corresponding statement and moves down to the next instruction (&lt;code&gt;match(val) { ... } next-instruction;&lt;/code&gt;). If all the matches have failed, it executes the statement after &lt;code&gt;otherwise&lt;/code&gt; and moves down to the next instruction.&lt;/p&gt; &#xA;&lt;p&gt;A complete &lt;code&gt;match&lt;/code&gt; construct results in a single C statement.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;of&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;of&lt;/code&gt; accepts a matched variant name as a first argument and the rest of arguments comprise a comma-separated list of bindings.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A binding equal to &lt;code&gt;_&lt;/code&gt; is ignored.&lt;/li&gt; &#xA; &lt;li&gt;A binding &lt;strong&gt;not&lt;/strong&gt; equal to &lt;code&gt;_&lt;/code&gt; stands for a pointer to a corresponding data of the variant (e.g., let there be &lt;code&gt;(Foo, T1, T2)&lt;/code&gt; and &lt;code&gt;of(Foo, x, y)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; has the type &lt;code&gt;T1 *&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;T2 *&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There can be more than one &lt;code&gt;_&lt;/code&gt; binding, however, non-&lt;code&gt;_&lt;/code&gt; bindings must be distinct.&lt;/p&gt; &#xA;&lt;p&gt;To match an empty variant, write &lt;code&gt;of(Bar)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;MATCHES&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MATCHES&lt;/code&gt; just tests an instance of a sum type for a given variant. If the given instance corresponds to the given variant, it expands to truthfulness, otherwise it expands to falsehood.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;matches&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;DEPRECATED&lt;/strong&gt;: use &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/#MATCHES&#34;&gt;&lt;code&gt;MATCHES&lt;/code&gt;&lt;/a&gt; instead.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;ifLet&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;ifLet&lt;/code&gt; tries to match the given instance of a sum type against the given variant, and, if a match has succeeded, it executes the corresponding statement.&lt;/p&gt; &#xA;&lt;p&gt;Think of &lt;code&gt;ifLet(&amp;lt;expr&amp;gt;, &amp;lt;variant-name&amp;gt;, vars...) { /* ... */ }&lt;/code&gt; as of an abbreviation of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;match(&amp;lt;expr&amp;gt;) {&#xA;    of(&amp;lt;variant-name&amp;gt;, vars...) { /* ... */ }&#xA;    otherwise {}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A complete &lt;code&gt;ifLet&lt;/code&gt; construct results in a single C statement.&lt;/p&gt; &#xA;&lt;h2&gt;Unit type&lt;/h2&gt; &#xA;&lt;p&gt;The unit type &lt;code&gt;UnitT99&lt;/code&gt; represents the type of a single value, &lt;code&gt;unit_v99&lt;/code&gt; (it should not be assigned to anything else). These are defined as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef char UnitT99;&#xA;static const UnitT99 unit_v99 = &#39;\0&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;DATATYPE99_NO_ALIASES&lt;/code&gt; remains undefined prior to &lt;code&gt;#include &amp;lt;datatype99.h&amp;gt;&lt;/code&gt;, &lt;code&gt;UnitT99&lt;/code&gt; and &lt;code&gt;unit_v99&lt;/code&gt; are also accessible through object-like macros &lt;code&gt;UnitT&lt;/code&gt; &amp;amp; &lt;code&gt;unit_v&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Derive helper attributes&lt;/h2&gt; &#xA;&lt;p&gt;You can pass named arguments to a deriver; these are called &lt;em&gt;derive helper attributes&lt;/em&gt;. They must be specified as object-like macros of the form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#define &amp;lt;variant-name&amp;gt;_&amp;lt;namespace&amp;gt;_&amp;lt;attribute-name&amp;gt; attr(/* attribute value */)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;&amp;lt;namespace&amp;gt;&lt;/code&gt; is either &lt;code&gt;&amp;lt;datatype-name&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;record-name&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;variant-name&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;field-name&amp;gt;&lt;/code&gt; for &lt;code&gt;datatype&lt;/code&gt;/&lt;code&gt;record&lt;/code&gt;-specific and variant/field-specific attributes, respectively.&lt;/p&gt; &#xA;&lt;p&gt;To manipulate derive helper attributes, there are a few predefined macros:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DATATYPE99_attrIsPresent&lt;/code&gt;/&lt;code&gt;DATATYPE99_ATTR_IS_PRESENT&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Accepts an attribute name and checks if it is present or not. It can be used to check the presence of an optional attribute.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DATATYPE99_attrValue&lt;/code&gt;/&lt;code&gt;DATATYPE99_ATTR_VALUE&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Accepts an attribute name extracts its value. A provided attribute &lt;strong&gt;must&lt;/strong&gt; be present.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DATATYPE99_assertAttrIsPresent&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Accepts an attribute name and emits a fatal error if the attribute is not present, otherwise results in emptiness. It can be used for mandatory attributes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(The naming convention here is the same &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/#naming-conventions&#34;&gt;as of Metalang99&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;h2&gt;Miscellaneous&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The macros &lt;code&gt;DATATYPE99_MAJOR&lt;/code&gt;, &lt;code&gt;DATATYPE99_MINOR&lt;/code&gt;, &lt;code&gt;DATATYPE99_PATCH&lt;/code&gt;, &lt;code&gt;DATATYPE99_VERSION_COMPATIBLE(x, y, z)&lt;/code&gt;, and &lt;code&gt;DATATYPE99_VERSION_EQ(x, y, z)&lt;/code&gt; have the &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/#version-manipulation-macros&#34;&gt;same semantics as of Metalang99&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For each macro using &lt;code&gt;ML99_EVAL&lt;/code&gt;, Datatype99 provides its &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/#definitions&#34;&gt;Metalang99-compliant&lt;/a&gt; counterpart which can be used inside derivers and other Metalang99-compliant macros:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Macro&lt;/th&gt; &#xA;   &lt;th&gt;Metalang99-compliant counterpart&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;datatype&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;DATATYPE99_datatype&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;record&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;DATATYPE99_record&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;of&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;DATATYPE99_of&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ifLet&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;DATATYPE99_ifLet&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;(An &lt;a href=&#34;https://hirrolot.gitbook.io/metalang99/partial-application&#34;&gt;arity specifier&lt;/a&gt; and &lt;a href=&#34;https://metalang99.readthedocs.io/en/latest/#definitions&#34;&gt;desugaring macro&lt;/a&gt; are provided for each of the above macros.)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There is a built-in deriver &lt;code&gt;dummy&lt;/code&gt; which generates nothing. It is defined both for record and sum types.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Guidelines&lt;/h2&gt; &#xA;&lt;h3&gt;Clang-Format issues&lt;/h3&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://clang.llvm.org/docs/ClangFormatStyleOptions.html&#34;&gt;Clang-Format&lt;/a&gt;, cancel formatting for a &lt;code&gt;datatype&lt;/code&gt; definition using &lt;code&gt;// clang-format off&lt;/code&gt; &amp;amp; &lt;code&gt;// clang-format on&lt;/code&gt; to make it look prettier, as in the examples.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;#undef&lt;/code&gt; derive helper attributes&lt;/h3&gt; &#xA;&lt;p&gt;Always &lt;code&gt;#undef&lt;/code&gt; derive helper attributes after a corresponding &lt;code&gt;datatype&lt;/code&gt; definition not to pollute your namespace.&lt;/p&gt; &#xA;&lt;h3&gt;Descriptive names&lt;/h3&gt; &#xA;&lt;p&gt;If the meaning of variant parameters is not clear from the context, give them descriptive names. This can be achieved in several ways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 1. Define type aliases to variant parameters.&#xA;typedef double XCoordinate;&#xA;typedef double YCoordinate;&#xA;&#xA;typedef double Width;&#xA;typedef double Height;&#xA;&#xA;datatype(&#xA;    Shape,&#xA;    (Point, XCoordinate, YCoordinate),&#xA;    (Rectangle, Width, Height)&#xA;);&#xA;&#xA;// 2. Define separate structures.&#xA;typedef struct {&#xA;    double x, y;&#xA;} Point;&#xA;&#xA;typedef struct {&#xA;    double width, height;&#xA;} Rectangle;&#xA;&#xA;datatype(&#xA;    Shape,&#xA;    (MkPoint, Point),&#xA;    (MkRectangle, Rectangle)&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Comparison:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The former option has more concise syntax: &lt;code&gt;MkPoint(x, y)&lt;/code&gt; instead of &lt;code&gt;MkPoint((Point){x, y})&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The latter option is more appropriate when the structures are to be used separately from the containing sum type.&lt;/li&gt; &#xA; &lt;li&gt;The latter option allows for more graduate control over the data layout: you can accompain the structures with compiler-specific attributes, alignment properties like &lt;code&gt;__attribute__ ((__packed__))&lt;/code&gt;, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Pitfalls&lt;/h2&gt; &#xA;&lt;h3&gt;Top-level &lt;code&gt;break&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Do &lt;strong&gt;not&lt;/strong&gt; use &lt;code&gt;break&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt; inside a statement provided to &lt;code&gt;of&lt;/code&gt;/&lt;code&gt;ifLet&lt;/code&gt; but outside of any &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops in that statement. For example, this code is fine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;match(x) {&#xA;    of(Foo, a, b, c) {&#xA;        for (int i = 0; i &amp;lt; 10; i++) {&#xA;            continue;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But this code is &lt;strong&gt;not&lt;/strong&gt; fine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for (int i = 0; i &amp;lt; 10; i++) {&#xA;    match(x) {&#xA;        of(Foo, a, b, c) {&#xA;            if (a == 7) { break; }&#xA;            continue;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To make it valid, you can rewrite it as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for (int i = 0; i &amp;lt; 10; i++) {&#xA;    match(x) {&#xA;        of(Foo, a, b, c) {&#xA;            if (a == 7) { goto my_break; }&#xA;            goto my_continue;&#xA;        }&#xA;    }&#xA;&#xA;    // Datatype99 prohibits top-level `break`/`continue`.&#xA;    my_continue:;&#xA;}&#xA;my_break:;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Array as a variant parameter&lt;/h3&gt; &#xA;&lt;p&gt;To specify an array as a variant parameter, you must put it into a separate &lt;code&gt;struct&lt;/code&gt;; see &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/examples/array_in_variant.c&#34;&gt;&lt;code&gt;examples/array_in_variant.c&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Mutable bindings&lt;/h3&gt; &#xA;&lt;p&gt;Bindings introduced by &lt;code&gt;of&lt;/code&gt; are &lt;strong&gt;always&lt;/strong&gt; mutable, so make sure you do &lt;strong&gt;not&lt;/strong&gt; mutate them if the value passed to &lt;code&gt;match&lt;/code&gt; is qualified as &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to Rust and ML for their implementations of sum types.&lt;/p&gt; &#xA;&lt;h2&gt;Publications&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hirrolot.github.io/posts/pretty-printable-enumerations-in-pure-c.html&#34;&gt;&lt;em&gt;Pretty-Printable Enumerations in Pure C&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hirrolot.github.io/posts/whats-the-point-of-the-c-preprocessor-actually.html&#34;&gt;&lt;em&gt;What’s the Point of the C Preprocessor, Actually?&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hirrolot.github.io/posts/macros-on-steroids-or-how-can-pure-c-benefit-from-metaprogramming.html&#34;&gt;&lt;em&gt;Macros on Steroids, Or: How Can Pure C Benefit From Metaprogramming&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hirrolot.github.io/posts/extend-your-language-dont-alter-it.html&#34;&gt;&lt;em&gt;Extend Your Language, Don’t Alter It&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hirrolot.github.io/posts/compiling-algebraic-data-types-in-pure-c99.html&#34;&gt;&lt;em&gt;Compiling Algebraic Data Types in Pure C99&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/ProgrammingLanguages/comments/nc1o18/comparing_algebraic_data_types_rust_and_datatype99/&#34;&gt;&lt;em&gt;Comparing Rust and Datatype99&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hirrolot.github.io/posts/compile-time-introspection-of-sum-types-in-pure-c99.html&#34;&gt;&lt;em&gt;Compile-Time Introspection of Sum Types in Pure C99&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hirrolot.github.io/posts/unleashing-sum-types-in-pure-c99.html&#34;&gt;&lt;em&gt;Unleashing Sum Types in Pure C99&lt;/em&gt;&lt;/a&gt; by Hirrolot.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Release procedure&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Update &lt;code&gt;DATATYPE99_MAJOR&lt;/code&gt;, &lt;code&gt;DATATYPE99_MINOR&lt;/code&gt;, and &lt;code&gt;DATATYPE99_PATCH&lt;/code&gt; in &lt;code&gt;datatype99.h&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Update &lt;code&gt;CHANGELOG.md&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Release the project in &lt;a href=&#34;https://github.com/Hirrolot/datatype99/releases&#34;&gt;GitHub Releases&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Q: Why use C instead of Rust/Zig/whatever else?&lt;/h3&gt; &#xA;&lt;p&gt;A: There is a lot of software written in plain C that can benefit from Datatype99; C is #1 programming language as of 2020, &lt;a href=&#34;https://jaxenter.com/c-programming-may-2020-171598.html&#34;&gt;according to TIOBE&lt;/a&gt;. People use C due to technical and social reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Datatype99 can be seamlessly integrated into existing codebases written in pure C -- just &lt;code&gt;#include &amp;lt;datatype99.h&amp;gt;&lt;/code&gt; and you are ready to go. On the other hand, other languages force you to separate native C files from their sources, which is clearly less convenient.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In some environments, developers strick to pure C for historical reasons (e.g., embedded devices, Linux and other operating systems).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;C has a stable ABI which is vital for some projects (e.g., plugin systems such as &lt;a href=&#34;https://github.com/metacall/core&#34;&gt;MetaCall&lt;/a&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;C is a mature language with a complete specification and a plenitude of libraries. Rust has no complete specification, and &lt;a href=&#34;https://ziglang.org/&#34;&gt;Zig&lt;/a&gt; is not yet production-ready. I know a few stories when these two languages were rejected for new projects, and I can understand this decision.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Historically, C has been targeting nearly all platforms. This is not the case with Rust, which depends on LLVM as for now.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Your company obligates you to use C.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Etc.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See also:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://drewdevault.com/2019/03/25/Rust-is-not-a-good-C-replacement.html&#34;&gt;&lt;em&gt;&#34;Rust is not a good C replacement&#34;&lt;/em&gt;&lt;/a&gt; by Drew DeVault.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Overall, if you can afford a more modern/high-level language, I encourage you to do so instead of using old C. However, many people do not have this possibility (or it would be too costly).&lt;/p&gt; &#xA;&lt;h3&gt;Q: Why not third-party code generators?&lt;/h3&gt; &#xA;&lt;p&gt;A: See &lt;a href=&#34;https://github.com/Hirrolot/metalang99#q-why-not-third-party-code-generators&#34;&gt;Metalang99&#39;s README &amp;gt;&amp;gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Q: How does it work?&lt;/h3&gt; &#xA;&lt;p&gt;A: In short, &lt;code&gt;datatype&lt;/code&gt; expands to a tagged union with value constructors; &lt;code&gt;match&lt;/code&gt; expands to a switch statement. To generate all this stuff, &lt;a href=&#34;https://github.com/Hirrolot/metalang99&#34;&gt;Metalang99&lt;/a&gt; is used, a preprocessor metaprogramming library.&lt;/p&gt; &#xA;&lt;p&gt;More on it in &lt;a href=&#34;https://hirrolot.github.io/posts/compiling-algebraic-data-types-in-pure-c99.html&#34;&gt;&lt;em&gt;&#34;Compiling Algebraic Data Types in Pure C99&#34;&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Q: Does it work on C++?&lt;/h3&gt; &#xA;&lt;p&gt;A: Yes, C++11 and onwards is supported.&lt;/p&gt; &#xA;&lt;h3&gt;Q: What is the difference between Datatype99 and Metalang99?&lt;/h3&gt; &#xA;&lt;p&gt;A: &lt;a href=&#34;https://github.com/Hirrolot/metalang99&#34;&gt;Metalang99&lt;/a&gt; is a functional language for metaprogramming, whereas Datatype99 is an implementation of algebraic data types written in this language.&lt;/p&gt; &#xA;&lt;h3&gt;Q: What about compile-time errors?&lt;/h3&gt; &#xA;&lt;p&gt;A: Some kinds of syntactic errors are detected by the library itself:&lt;/p&gt; &#xA;&lt;h4&gt;Error: &lt;code&gt;Bar(int)&lt;/code&gt; instead of &lt;code&gt;(Bar, int)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;datatype(A, (Foo, int), Bar(int));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0&#xA;playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: Bar(int) must be (x1, ..., xN)&#34;&#xA;    3 | datatype(A, (Foo, int), Bar(int));&#xA;      | ^~~~~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Error: Missing comma&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;datatype(A, (Foo, int) (Bar, int));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0&#xA;playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: (Foo, int) (Bar, int) must be (x1, ..., xN), did you miss a comma?&#34;&#xA;    3 | datatype(A, (Foo, int) (Bar, int));&#xA;      | ^~~~~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Error: Trailing comma is prohibited&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;datatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0&#xA;playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: must be (x1, ..., xN)&#34;&#xA;    3 | datatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);&#xA;      | ^~~~~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(For better diagnostics, use the latest Metalang99.)&lt;/p&gt; &#xA;&lt;p&gt;The others are understandable as well:&lt;/p&gt; &#xA;&lt;h4&gt;Error: unknown type name specified in &lt;code&gt;datatype&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;datatype(Foo, (FooA, NonExistingType));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;playground.c:3:1: error: unknown type name ‘NonExistingType’&#xA;    3 | datatype(&#xA;      | ^~~~~~~~&#xA;playground.c:3:1: error: unknown type name ‘NonExistingType’&#xA;playground.c:3:1: error: unknown type name ‘NonExistingType’&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Error: non-exhaustive &lt;code&gt;match&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;match(*tree) {&#xA;    of(Leaf, x) return *x;&#xA;    // of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;playground.c: In function ‘sum’:&#xA;playground.c:6:5: warning: enumeration value ‘NodeTag’ not handled in switch [-Wswitch]&#xA;    6 |     match(*tree) {&#xA;      |     ^~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Error: excess binders in &lt;code&gt;of&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;match(*tree) {&#xA;    of(Leaf, x, excess) return *x;&#xA;    of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;playground.c: In function ‘sum’:&#xA;playground.c:15:9: error: unknown type name ‘Leaf_1’; did you mean ‘Leaf_0’?&#xA;   15 |         of(Leaf, x, excess) return *x;&#xA;      |         ^~&#xA;      |         Leaf_0&#xA;playground.c:15:9: error: ‘BinaryTreeLeaf’ has no member named ‘_1’; did you mean ‘_0’?&#xA;   15 |         of(Leaf, x, excess) return *x;&#xA;      |         ^~&#xA;      |         _0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Error: improperly typed variant arguments&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;BinaryTree tree = Leaf(&#34;hello world&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;playground.c: In function ‘main’:&#xA;playground.c:18:28: warning: passing argument 1 of ‘Leaf’ makes integer from pointer without a cast [-Wint-conversion]&#xA;   18 |     BinaryTree tree = Leaf(&#34;hello world&#34;);&#xA;      |                            ^~~~~~~~~~~~~&#xA;      |                            |&#xA;      |                            char *&#xA;playground.c:6:1: note: expected ‘int’ but argument is of type ‘char *’&#xA;    6 | datatype(&#xA;      | ^~~~~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Error: an undereferenced binder&lt;/h4&gt; &#xA;&lt;p&gt;[&lt;code&gt;playground.c&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sum(const BinaryTree *tree) {&#xA;    match(*tree) {&#xA;        of(Leaf, x) return x; // x is int *&#xA;        of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;code&gt;/bin/sh&lt;/code&gt;]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;playground.c: In function ‘sum’:&#xA;playground.c:17:28: warning: returning ‘Leaf_0 *’ {aka ‘int *’} from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]&#xA;   17 |         of(Leaf, x) return x; // x is int *&#xA;      |                            ^&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;From my experience, nearly 95% of errors make sense.&lt;/p&gt; &#xA;&lt;p&gt;If an error is not comprehensible at all, try to look at generated code (&lt;code&gt;-E&lt;/code&gt;). Hopefully, the &lt;a href=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/#semantics&#34;&gt;code generation semantics&lt;/a&gt; is formally defined so normally you will not see something unexpected.&lt;/p&gt; &#xA;&lt;h3&gt;Q: What about IDE support?&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Hirrolot/datatype99/master/images/suggestion.png&#34; width=&#34;600px&#34;&gt; &#xA;&lt;p&gt;A: VS Code automatically enables suggestions of generated types but, of course, it does not support macro syntax highlighting.&lt;/p&gt; &#xA;&lt;h3&gt;Q: Which compilers are tested?&lt;/h3&gt; &#xA;&lt;p&gt;A: Datatype99 is known to work on these compilers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GCC&lt;/li&gt; &#xA; &lt;li&gt;Clang&lt;/li&gt; &#xA; &lt;li&gt;MSVC&lt;/li&gt; &#xA; &lt;li&gt;TCC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;warning: control reaches end of non-void function [-Wreturn-type]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This warning happens when you try to return control from within a &lt;code&gt;match&lt;/code&gt; statement, and your compiler thinks that not all hypothetical variants are handled. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;datatype(MyType, (Foo), (Bar));&#xA;&#xA;int handle(MyType val) {&#xA;    match(val) {&#xA;        of(Foo) return 5;&#xA;        of(Bar) return 7;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code may seem perfect at first glance, but in fact, it is not. The reason is this: &lt;code&gt;match(val)&lt;/code&gt; boils down to &lt;code&gt;switch(val.tag)&lt;/code&gt; under the hood, with &lt;code&gt;val.tag&lt;/code&gt; being an ordinary C enumeration consisting of the variants &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;. But what if a caller provides us with neither &lt;code&gt;Foo&lt;/code&gt; nor &lt;code&gt;Bar&lt;/code&gt;, but with something like &lt;code&gt;42&lt;/code&gt; (not a valid variant)? Since &lt;code&gt;enum&lt;/code&gt; is merely another way to give integers names, a compiler would not complain on the &lt;em&gt;caller&lt;/em&gt; site. However, on the &lt;em&gt;callee&lt;/em&gt; site, we would have the warning:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;test.c: In function ‘handle’:&#xA;test.c:10:1: warning: control reaches end of non-void function [-Wreturn-type]&#xA;   10 | }&#xA;      | ^&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The solution is to either panic or return some error-signaling code, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int handle(MyType val) {&#xA;    match(val) {&#xA;        of(Foo) return 5;&#xA;        of(Bar) return 7;&#xA;    }&#xA;&#xA;    // Invalid input (no such variant).&#xA;    return -1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/Hirrolot/datatype99/issues/9&#34;&gt;issue #9&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>B-Dem/PPPwnUI</title>
    <updated>2024-05-12T01:30:48Z</updated>
    <id>tag:github.com,2024-05-12:/B-Dem/PPPwnUI</id>
    <link href="https://github.com/B-Dem/PPPwnUI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PPPwnUI is a program that adds an UI to the exploit PPPwn created by TheFlow.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PPPwnUI&lt;/h1&gt; &#xA;&lt;p&gt;PPPwnUI is a program that adds an UI to the exploit &lt;a href=&#34;https://github.com/TheOfficialFloW/PPPwn/&#34;&gt;PPPwn&lt;/a&gt; created by &lt;a href=&#34;https://github.com/TheOfficialFloW/&#34;&gt;TheFlow&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone the repository:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;git clone https://github.com/B-Dem/PPPwnUI&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the requirements:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Launch the app with&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;python PPPwnUI.py&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Select your Interface using the drop-down menu&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Choose your Firmware (7.50, 7.51, 7.55, 8.00, 8.01, 8.03, 8.50, 8.52, 9.00, 9.03, 9.04, 9.50, 9.51, 9.60, 10.00, 10.01, 10.50, 10.70, 10.71 or 11.00)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Or Choose the Goldhen PPPwn (9.00 &amp;amp; 11.00)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can also add your own custom Payloads.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Click on &lt;strong&gt;Start PPPwn&lt;/strong&gt; to start the Exploit&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;PPPwn Usage&lt;/h2&gt; &#xA;&lt;p&gt;On your PS4:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go to &lt;code&gt;Settings&lt;/code&gt; and then &lt;code&gt;Network&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Select &lt;code&gt;Set Up Internet connection&lt;/code&gt; and choose &lt;code&gt;Use a LAN Cable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Choose &lt;code&gt;Custom&lt;/code&gt; setup and choose &lt;code&gt;PPPoE&lt;/code&gt; for &lt;code&gt;IP Address Settings&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Enter anything for &lt;code&gt;PPPoE User ID&lt;/code&gt; and &lt;code&gt;PPPoE Pasword&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Choose &lt;code&gt;Automatic&lt;/code&gt; for &lt;code&gt;DNS Settings&lt;/code&gt; and &lt;code&gt;MTU Settings&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Choose &lt;code&gt;Do Not Use&lt;/code&gt; for &lt;code&gt;Proxy Server&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click &lt;code&gt;Test Internet Connection&lt;/code&gt; to communicate with your computer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the exploit fails or the PS4 crashes, you can skip the internet setup and simply click on &lt;code&gt;Test Internet Connection&lt;/code&gt;. If the script fail or is stuck waiting for a request/response, abort it and run it again on your computer, and then click on &lt;code&gt;Test Internet Connection&lt;/code&gt; on your PS4.&lt;/p&gt; &#xA;&lt;h3&gt;Goldhen Usage&lt;/h3&gt; &#xA;&lt;p&gt;On your Computer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;goldhen.bin&lt;/code&gt; to the root directory of an exfat/fat32 USB and insert it into your PS4.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Example run&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[+] PPPwn - PlayStation 4 PPPoE RCE by theflow&#xA;[+] args: interface=enp0s3 fw=1100 stage1=stage1/stage1.bin stage2=stage2/stage2.bin&#xA;&#xA;[+] STAGE 0: Initialization&#xA;[*] Waiting for PADI...&#xA;[+] pppoe_softc: 0xffffabd634beba00&#xA;[+] Target MAC: xx:xx:xx:xx:xx:xx&#xA;[+] Source MAC: 07:ba:be:34:d6:ab&#xA;[+] AC cookie length: 0x4e0&#xA;[*] Sending PADO...&#xA;[*] Waiting for PADR...&#xA;[*] Sending PADS...&#xA;[*] Waiting for LCP configure request...&#xA;[*] Sending LCP configure ACK...&#xA;[*] Sending LCP configure request...&#xA;[*] Waiting for LCP configure ACK...&#xA;[*] Waiting for IPCP configure request...&#xA;[*] Sending IPCP configure NAK...&#xA;[*] Waiting for IPCP configure request...&#xA;[*] Sending IPCP configure ACK...&#xA;[*] Sending IPCP configure request...&#xA;[*] Waiting for IPCP configure ACK...&#xA;[*] Waiting for interface to be ready...&#xA;[+] Target IPv6: fe80::2d9:d1ff:febc:83e4&#xA;[+] Heap grooming...done&#xA;&#xA;[+] STAGE 1: Memory corruption&#xA;[+] Pinning to CPU 0...done&#xA;[*] Sending malicious LCP configure request...&#xA;[*] Waiting for LCP configure request...&#xA;[*] Sending LCP configure ACK...&#xA;[*] Sending LCP configure request...&#xA;[*] Waiting for LCP configure ACK...&#xA;[*] Waiting for IPCP configure request...&#xA;[*] Sending IPCP configure NAK...&#xA;[*] Waiting for IPCP configure request...&#xA;[*] Sending IPCP configure ACK...&#xA;[*] Sending IPCP configure request...&#xA;[*] Waiting for IPCP configure ACK...&#xA;[+] Scanning for corrupted object...found fe80::0fdf:4141:4141:4141&#xA;&#xA;[+] STAGE 2: KASLR defeat&#xA;[*] Defeating KASLR...&#xA;[+] pppoe_softc_list: 0xffffffff884de578&#xA;[+] kaslr_offset: 0x3ffc000&#xA;&#xA;[+] STAGE 3: Remote code execution&#xA;[*] Sending LCP terminate request...&#xA;[*] Waiting for PADI...&#xA;[+] pppoe_softc: 0xffffabd634beba00&#xA;[+] Target MAC: xx:xx:xx:xx:xx:xx&#xA;[+] Source MAC: 97:df:ea:86:ff:ff&#xA;[+] AC cookie length: 0x511&#xA;[*] Sending PADO...&#xA;[*] Waiting for PADR...&#xA;[*] Sending PADS...&#xA;[*] Triggering code execution...&#xA;[*] Waiting for stage1 to resume...&#xA;[*] Sending PADT...&#xA;[*] Waiting for PADI...&#xA;[+] pppoe_softc: 0xffffabd634be9200&#xA;[+] Target MAC: xx:xx:xx:xx:xx:xx&#xA;[+] AC cookie length: 0x0&#xA;[*] Sending PADO...&#xA;[*] Waiting for PADR...&#xA;[*] Sending PADS...&#xA;[*] Waiting for LCP configure request...&#xA;[*] Sending LCP configure ACK...&#xA;[*] Sending LCP configure request...&#xA;[*] Waiting for LCP configure ACK...&#xA;[*] Waiting for IPCP configure request...&#xA;[*] Sending IPCP configure NAK...&#xA;[*] Waiting for IPCP configure request...&#xA;[*] Sending IPCP configure ACK...&#xA;[*] Sending IPCP configure request...&#xA;[*] Waiting for IPCP configure ACK...&#xA;&#xA;[+] STAGE 4: Arbitrary payload execution&#xA;[*] Sending stage2 payload...&#xA;[+] Done!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;To do :&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Auto Updater&lt;/li&gt; &#xA; &lt;li&gt;PPPwn Logs in the program directly&lt;/li&gt; &#xA; &lt;li&gt;Code optimisation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This Program was made with ❤️ by &lt;a href=&#34;https://github.com/B-Dem&#34;&gt;Memz&lt;/a&gt; for &lt;a href=&#34;https://sighya.fr&#34;&gt;Sighya&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you find this program helpful, leave a star on the repo!&lt;/p&gt; &#xA;&lt;p&gt;And if you got any feedback, open an issues !&lt;/p&gt;</summary>
  </entry>
</feed>