<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-14T01:30:14Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ggerganov/ggml</title>
    <updated>2023-03-14T01:30:14Z</updated>
    <id>tag:github.com,2023-03-14:/ggerganov/ggml</id>
    <link href="https://github.com/ggerganov/ggml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tensor library for machine learning&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ggml&lt;/h1&gt; &#xA;&lt;p&gt;Tensor library for machine learning&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note that this project is under development and not ready for production use. &lt;br&gt; Some of the development is currently happening in the &lt;a href=&#34;https://github.com/ggerganov/whisper.cpp&#34;&gt;whisper.cpp&lt;/a&gt; repo&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Written in C&lt;/li&gt; &#xA; &lt;li&gt;16-bit float support&lt;/li&gt; &#xA; &lt;li&gt;Automatic differentiation (WIP in progress)&lt;/li&gt; &#xA; &lt;li&gt;ADAM and L-BFGS optimizers&lt;/li&gt; &#xA; &lt;li&gt;Optimized for Apple silicon via NEON intrinsics and Accelerate framework&lt;/li&gt; &#xA; &lt;li&gt;On x86 architectures utilzes AVX intrinsics&lt;/li&gt; &#xA; &lt;li&gt;No third-party dependencies&lt;/li&gt; &#xA; &lt;li&gt;Zero memory allocations during runtime&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Example of GPT-2 inference &lt;a href=&#34;https://github.com/ggerganov/ggml/tree/master/examples/gpt-2&#34;&gt;examples/gpt-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Example of GPT-J inference &lt;a href=&#34;https://github.com/ggerganov/ggml/tree/master/examples/gpt-j&#34;&gt;examples/gpt-j&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Example of Whisper inference &lt;a href=&#34;https://github.com/ggerganov/ggml/tree/master/examples/whisper&#34;&gt;examples/whisper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support 4-bit integer quantization &lt;a href=&#34;https://github.com/ggerganov/ggml/pull/27&#34;&gt;https://github.com/ggerganov/ggml/pull/27&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Example of FLAN-T5 inference &lt;a href=&#34;https://github.com/ggerganov/ggml/pull/12&#34;&gt;https://github.com/ggerganov/ggml/pull/12&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Example of LLaMA inference&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Example of RWKV inference&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Whisper inference (example)&lt;/h2&gt; &#xA;&lt;p&gt;With ggml you can efficiently run &lt;a href=&#34;https://raw.githubusercontent.com/ggerganov/ggml/master/examples/whisper&#34;&gt;Whisper&lt;/a&gt; inference on the CPU.&lt;/p&gt; &#xA;&lt;p&gt;Memory requirements:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Model&lt;/th&gt; &#xA;   &lt;th&gt;Disk&lt;/th&gt; &#xA;   &lt;th&gt;Mem&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tiny&lt;/td&gt; &#xA;   &lt;td&gt;75 MB&lt;/td&gt; &#xA;   &lt;td&gt;~280 MB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;base&lt;/td&gt; &#xA;   &lt;td&gt;142 MB&lt;/td&gt; &#xA;   &lt;td&gt;~430 MB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;small&lt;/td&gt; &#xA;   &lt;td&gt;466 MB&lt;/td&gt; &#xA;   &lt;td&gt;~1.0 GB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;medium&lt;/td&gt; &#xA;   &lt;td&gt;1.5 GB&lt;/td&gt; &#xA;   &lt;td&gt;~2.6 GB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;large&lt;/td&gt; &#xA;   &lt;td&gt;2.9 GB&lt;/td&gt; &#xA;   &lt;td&gt;~4.7 GB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;GPT inference (example)&lt;/h2&gt; &#xA;&lt;p&gt;With ggml you can efficiently run &lt;a href=&#34;https://raw.githubusercontent.com/ggerganov/ggml/master/examples/gpt-2&#34;&gt;GPT-2&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/ggerganov/ggml/master/examples/gpt-j&#34;&gt;GPT-J&lt;/a&gt; inference on the CPU.&lt;/p&gt; &#xA;&lt;p&gt;Here is how to run the example programs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Build ggml + examples&#xA;git clone https://github.com/ggerganov/ggml&#xA;cd ggml&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake ..&#xA;make -j4 gpt-2 gpt-j&#xA;&#xA;# Run the GPT-2 small 117M model&#xA;../examples/gpt-2/download-ggml-model.sh 117M&#xA;./bin/gpt-2 -m models/gpt-2-117M/ggml-model.bin -p &#34;This is an example&#34;&#xA;&#xA;# Run the GPT-J 6B model (requires 12GB disk space and 16GB CPU RAM)&#xA;../examples/gpt-j/download-ggml-model.sh 6B&#xA;./bin/gpt-j -m models/gpt-j-6B/ggml-model.bin -p &#34;This is an example&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The inference speeds that I get for the different models on my 32GB MacBook M1 Pro are as follows:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Model&lt;/th&gt; &#xA;   &lt;th&gt;Size&lt;/th&gt; &#xA;   &lt;th&gt;Time / Token&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GPT-2&lt;/td&gt; &#xA;   &lt;td&gt;117M&lt;/td&gt; &#xA;   &lt;td&gt;5 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GPT-2&lt;/td&gt; &#xA;   &lt;td&gt;345M&lt;/td&gt; &#xA;   &lt;td&gt;12 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GPT-2&lt;/td&gt; &#xA;   &lt;td&gt;774M&lt;/td&gt; &#xA;   &lt;td&gt;23 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GPT-2&lt;/td&gt; &#xA;   &lt;td&gt;1558M&lt;/td&gt; &#xA;   &lt;td&gt;42 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;---&lt;/td&gt; &#xA;   &lt;td&gt;---&lt;/td&gt; &#xA;   &lt;td&gt;---&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GPT-J&lt;/td&gt; &#xA;   &lt;td&gt;6B&lt;/td&gt; &#xA;   &lt;td&gt;125 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For more information, checkout the corresponding programs in the &lt;a href=&#34;https://raw.githubusercontent.com/ggerganov/ggml/master/examples&#34;&gt;examples&lt;/a&gt; folder.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>espressif/esp32-camera</title>
    <updated>2023-03-14T01:30:14Z</updated>
    <id>tag:github.com,2023-03-14:/espressif/esp32-camera</id>
    <link href="https://github.com/espressif/esp32-camera" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ESP32 Camera Driver&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/espressif/esp32-camera/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/espressif/esp32-camera/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build examples&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://components.espressif.com/components/espressif/esp32-camera&#34;&gt;&lt;img src=&#34;https://components.espressif.com/components/espressif/esp32-camera/badge.svg?sanitize=true&#34; alt=&#34;Component Registry&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;General Information&lt;/h2&gt; &#xA;&lt;p&gt;This repository hosts ESP32 series Soc compatible driver for image sensors. Additionally it provides a few tools, which allow converting the captured frame data to the more common BMP and JPEG formats.&lt;/p&gt; &#xA;&lt;h3&gt;Supported Soc&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ESP32&lt;/li&gt; &#xA; &lt;li&gt;ESP32-S2&lt;/li&gt; &#xA; &lt;li&gt;ESP32-S3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Supported Sensor&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;model&lt;/th&gt; &#xA;   &lt;th&gt;max resolution&lt;/th&gt; &#xA;   &lt;th&gt;color type&lt;/th&gt; &#xA;   &lt;th&gt;output format&lt;/th&gt; &#xA;   &lt;th&gt;Len Size&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;1600 x 1200&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV(422/420)/YCbCr422&lt;br&gt;RGB565/555&lt;br&gt;8-bit compressed data&lt;br&gt;8/10-bit Raw RGB data&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV3660&lt;/td&gt; &#xA;   &lt;td&gt;2048 x 1536&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;raw RGB data&lt;br&gt;RGB565/555/444&lt;br&gt;CCIR656&lt;br&gt;YCbCr422&lt;br&gt;compression&lt;/td&gt; &#xA;   &lt;td&gt;1/5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV5640&lt;/td&gt; &#xA;   &lt;td&gt;2592 x 1944&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;RAW RGB&lt;br&gt;RGB565/555/444&lt;br&gt;CCIR656&lt;br&gt;YUV422/420&lt;br&gt;YCbCr422&lt;br&gt;compression&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV7670&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;Raw Bayer RGB&lt;br&gt;Processed Bayer RGB&lt;br&gt;YUV/YCbCr422&lt;br&gt;GRB422&lt;br&gt;RGB565/555&lt;/td&gt; &#xA;   &lt;td&gt;1/6&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV7725&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;Raw RGB&lt;br&gt;GRB 422&lt;br&gt;RGB565/555/444&lt;br&gt;YCbCr 422&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NT99141&lt;/td&gt; &#xA;   &lt;td&gt;1280 x 720&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YCbCr 422&lt;br&gt;RGB565/555/444&lt;br&gt;Raw&lt;br&gt;CCIR656&lt;br&gt;JPEG compression&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GC032A&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;/td&gt; &#xA;   &lt;td&gt;1/10&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GC0308&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;/td&gt; &#xA;   &lt;td&gt;1/6.5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GC2145&lt;/td&gt; &#xA;   &lt;td&gt;1600 x 1200&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;/td&gt; &#xA;   &lt;td&gt;1/5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BF3005&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BF20A6&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;/td&gt; &#xA;   &lt;td&gt;1/10&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SC101IOT&lt;/td&gt; &#xA;   &lt;td&gt;1280 x 720&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;Raw RGB&lt;/td&gt; &#xA;   &lt;td&gt;1/4.2&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SC030IOT&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;/td&gt; &#xA;   &lt;td&gt;1/6.5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SC031GS&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;monochrome&lt;/td&gt; &#xA;   &lt;td&gt;RAW MONO&lt;br&gt;Grayscale&lt;/td&gt; &#xA;   &lt;td&gt;1/6&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Important to Remember&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Except when using CIF or lower resolution with JPEG, the driver requires PSRAM to be installed and activated.&lt;/li&gt; &#xA; &lt;li&gt;Using YUV or RGB puts a lot of strain on the chip because writing to PSRAM is not particularly fast. The result is that image data might be missing. This is particularly true if WiFi is enabled. If you need RGB data, it is recommended that JPEG is captured and then turned into RGB using &lt;code&gt;fmt2rgb888&lt;/code&gt; or &lt;code&gt;fmt2bmp&lt;/code&gt;/&lt;code&gt;frame2bmp&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;When 1 frame buffer is used, the driver will wait for the current frame to finish (VSYNC) and start I2S DMA. After the frame is acquired, I2S will be stopped and the frame buffer returned to the application. This approach gives more control over the system, but results in longer time to get the frame.&lt;/li&gt; &#xA; &lt;li&gt;When 2 or more frame bufers are used, I2S is running in continuous mode and each frame is pushed to a queue that the application can access. This approach puts more strain on the CPU/Memory, but allows for double the frame rate. Please use only with JPEG.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation Instructions&lt;/h2&gt; &#xA;&lt;h3&gt;Using esp-idf&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone or download and extract the repository to the components folder of your ESP-IDF project&lt;/li&gt; &#xA; &lt;li&gt;Enable PSRAM in &lt;code&gt;menuconfig&lt;/code&gt; (also set Flash and PSRAM frequiencies to 80MHz)&lt;/li&gt; &#xA; &lt;li&gt;Include &lt;code&gt;esp_camera.h&lt;/code&gt; in your code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Using PlatformIO&lt;/h3&gt; &#xA;&lt;p&gt;The easy way -- on the &lt;code&gt;env&lt;/code&gt; section of &lt;code&gt;platformio.ini&lt;/code&gt;, add the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[env]&#xA;lib_deps =&#xA;  esp32-camera&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the &lt;code&gt;esp_camera.h&lt;/code&gt; is available to be included:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable PSRAM on &lt;code&gt;menuconfig&lt;/code&gt; or type it direclty on &lt;code&gt;sdkconfig&lt;/code&gt;. Check the &lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-esp32-spiram-support&#34;&gt;official doc&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CONFIG_ESP32_SPIRAM_SUPPORT=y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Arduino&lt;/strong&gt;&lt;/em&gt; The easy-way (content above) only seems to work if you&#39;re using &lt;code&gt;framework=arduino&lt;/code&gt; which seems to take a bunch of the guesswork out (thanks Arduino!) but also suck up a lot more memory and flash, almost crippling the performance. If you plan to use the &lt;code&gt;framework=espidf&lt;/code&gt; then read the sections below carefully!!&lt;/p&gt; &#xA;&lt;h2&gt;Platform.io lib/submodule (for framework=espidf)&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s probably easier to just skip the platform.io library registry version and link the git repo as a submodule. (i.e. using code outside the platform.io library management). In this example we will install this as a submodule inside the platform.io $project/lib folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd $project\lib&#xA;git submodule add -b master https://github.com/espressif/esp32-camera.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in &lt;code&gt;platformio.ini&lt;/code&gt; file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;build_flags =&#xA;   -I../lib/esp32-camera&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that &lt;code&gt;#include &#34;esp_camera.h&#34;&lt;/code&gt; statement will be available. Now the module is included, and you&#39;re hopefully back to the same place as the easy-Arduino way.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning about platform.io/espidf and fresh (not initialized) git repos&lt;/strong&gt; There is a sharp-edge on you&#39;ll discover in the platform.io build process (in espidf v3.3 &amp;amp; 4.0.1) where a project which has only had &lt;code&gt;git init&lt;/code&gt; but nothing committed will crash platform.io build process with highly non-useful output. The cause is due to lack of a version (making you think you did something wrong, when you didn&#39;t at all) - the output is horribly non-descript. Solution: the devs want you to create a file called version.txt with a number in it, or simply commit any file to the projects git repo and use git. This happens because platform.io build process tries to be too clever and determine the build version number from the git repo - it&#39;s a sharp edge you&#39;ll only encounter if you&#39;re experimenting on a new project with no commits .. like wtf is my camera not working let&#39;s try a &#39;clean project&#39;?! &lt;/p&gt; &#xA;&lt;h2&gt;Platform.io Kconfig&lt;/h2&gt; &#xA;&lt;p&gt;Kconfig is used by the platform.io menuconfig (accessed by running: &lt;code&gt;pio run -t menuconfig&lt;/code&gt;) to interactively manage the various #ifdef statements throughout the espidf and supporting libraries (i.e. this repo: esp32-camera and arduino-esp32.git). The menuconfig process generates the &lt;code&gt;sdkconfig&lt;/code&gt; file which is ultimately used behind the scenes by espidf compile+build process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Make sure to append or symlink&lt;/strong&gt; &lt;a href=&#34;https://raw.githubusercontent.com/espressif/esp32-camera/master/Kconfig&#34;&gt;this &lt;code&gt;Kconfig&lt;/code&gt;&lt;/a&gt; content into the &lt;code&gt;Kconfig&lt;/code&gt; of your project.&lt;/p&gt; &#xA;&lt;p&gt;You symlink (or copy) the included Kconfig into your platform.io projects src directory. The file should be named &lt;code&gt;Kconfig.projbuild&lt;/code&gt; in your projects src\ directory or you could also add the library path to a CMakefile.txt and hope the &lt;code&gt;Kconfig&lt;/code&gt; (or &lt;code&gt;Kconfig.projbuild&lt;/code&gt;) gets discovered by the menuconfig process, though this unpredictable for me.&lt;/p&gt; &#xA;&lt;p&gt;The unpredictable wonky behavior in platform.io build process around Kconfig naming (Kconfig vs. Kconfig.projbuild) occurs between espidf versions 3.3 and 4.0 - but if you don&#39;t see &#34;Camera configuration&#34; in your &lt;code&gt;pio run -t menuconfig&lt;/code&gt; then there is no point trying to test camera code (it may compile, but it probably won&#39;t work!) and it seems the platform.io devs (when they built their wrapper around the espidf menuconfig) didn&#39;t implement it properly. You&#39;ve probably already figured out you can&#39;t use the espidf build tools since the files are in totally different locations and also different versions with sometimes different syntax. This is one of those times you might consider changing the &lt;code&gt;platformio.ini&lt;/code&gt; from &lt;code&gt;platform=espressif32&lt;/code&gt; to &lt;code&gt;platform=https://github.com/platformio/platform-espressif32.git#develop&lt;/code&gt; to get a more recent version of the espidf 4.0 tools.&lt;/p&gt; &#xA;&lt;p&gt;However with a bit of patience and experimenting you&#39;ll figure the Kconfig out. Once Kconfig (or Kconfig.projbuild) is working then you will be able to choose the configurations according to your setup or the camera libraries will be compiled. Although you might also need to delete your .pio/build directory before the options appear .. again, the &lt;code&gt;pio run -t menuconfig&lt;/code&gt; doens&#39;t always notice the new Kconfig files!&lt;/p&gt; &#xA;&lt;p&gt;If you miss-skip-ignore this critical step the camera module will compile but camera logic inside the library will be &#39;empty&#39; because the Kconfig sets the proper #ifdef statements during the build process to initialize the selected cameras. It&#39;s very not optional!&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Initialization&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;&#xA;//WROVER-KIT PIN Map&#xA;#define CAM_PIN_PWDN    -1 //power down is not used&#xA;#define CAM_PIN_RESET   -1 //software reset will be performed&#xA;#define CAM_PIN_XCLK    21&#xA;#define CAM_PIN_SIOD    26&#xA;#define CAM_PIN_SIOC    27&#xA;&#xA;#define CAM_PIN_D7      35&#xA;#define CAM_PIN_D6      34&#xA;#define CAM_PIN_D5      39&#xA;#define CAM_PIN_D4      36&#xA;#define CAM_PIN_D3      19&#xA;#define CAM_PIN_D2      18&#xA;#define CAM_PIN_D1       5&#xA;#define CAM_PIN_D0       4&#xA;#define CAM_PIN_VSYNC   25&#xA;#define CAM_PIN_HREF    23&#xA;#define CAM_PIN_PCLK    22&#xA;&#xA;static camera_config_t camera_config = {&#xA;    .pin_pwdn  = CAM_PIN_PWDN,&#xA;    .pin_reset = CAM_PIN_RESET,&#xA;    .pin_xclk = CAM_PIN_XCLK,&#xA;    .pin_sccb_sda = CAM_PIN_SIOD,&#xA;    .pin_sccb_scl = CAM_PIN_SIOC,&#xA;&#xA;    .pin_d7 = CAM_PIN_D7,&#xA;    .pin_d6 = CAM_PIN_D6,&#xA;    .pin_d5 = CAM_PIN_D5,&#xA;    .pin_d4 = CAM_PIN_D4,&#xA;    .pin_d3 = CAM_PIN_D3,&#xA;    .pin_d2 = CAM_PIN_D2,&#xA;    .pin_d1 = CAM_PIN_D1,&#xA;    .pin_d0 = CAM_PIN_D0,&#xA;    .pin_vsync = CAM_PIN_VSYNC,&#xA;    .pin_href = CAM_PIN_HREF,&#xA;    .pin_pclk = CAM_PIN_PCLK,&#xA;&#xA;    .xclk_freq_hz = 20000000,//EXPERIMENTAL: Set to 16MHz on ESP32-S2 or ESP32-S3 to enable EDMA mode&#xA;    .ledc_timer = LEDC_TIMER_0,&#xA;    .ledc_channel = LEDC_CHANNEL_0,&#xA;&#xA;    .pixel_format = PIXFORMAT_JPEG,//YUV422,GRAYSCALE,RGB565,JPEG&#xA;    .frame_size = FRAMESIZE_UXGA,//QQVGA-UXGA, For ESP32, do not use sizes above QVGA when not JPEG. The performance of the ESP32-S series has improved a lot, but JPEG mode always gives better frame rates.&#xA;&#xA;    .jpeg_quality = 12, //0-63, for OV series camera sensors, lower number means higher quality&#xA;    .fb_count = 1, //When jpeg mode is used, if fb_count more than one, the driver will work in continuous mode.&#xA;    .grab_mode = CAMERA_GRAB_WHEN_EMPTY//CAMERA_GRAB_LATEST. Sets when buffers should be filled&#xA;};&#xA;&#xA;esp_err_t camera_init(){&#xA;    //power up the camera if PWDN pin is defined&#xA;    if(CAM_PIN_PWDN != -1){&#xA;        pinMode(CAM_PIN_PWDN, OUTPUT);&#xA;        digitalWrite(CAM_PIN_PWDN, LOW);&#xA;    }&#xA;&#xA;    //initialize the camera&#xA;    esp_err_t err = esp_camera_init(&amp;amp;camera_config);&#xA;    if (err != ESP_OK) {&#xA;        ESP_LOGE(TAG, &#34;Camera Init Failed&#34;);&#xA;        return err;&#xA;    }&#xA;&#xA;    return ESP_OK;&#xA;}&#xA;&#xA;esp_err_t camera_capture(){&#xA;    //acquire a frame&#xA;    camera_fb_t * fb = esp_camera_fb_get();&#xA;    if (!fb) {&#xA;        ESP_LOGE(TAG, &#34;Camera Capture Failed&#34;);&#xA;        return ESP_FAIL;&#xA;    }&#xA;    //replace this with your own function&#xA;    process_image(fb-&amp;gt;width, fb-&amp;gt;height, fb-&amp;gt;format, fb-&amp;gt;buf, fb-&amp;gt;len);&#xA;  &#xA;    //return the frame buffer back to the driver for reuse&#xA;    esp_camera_fb_return(fb);&#xA;    return ESP_OK;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JPEG HTTP Capture&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;#include &#34;esp_http_server.h&#34;&#xA;#include &#34;esp_timer.h&#34;&#xA;&#xA;typedef struct {&#xA;        httpd_req_t *req;&#xA;        size_t len;&#xA;} jpg_chunking_t;&#xA;&#xA;static size_t jpg_encode_stream(void * arg, size_t index, const void* data, size_t len){&#xA;    jpg_chunking_t *j = (jpg_chunking_t *)arg;&#xA;    if(!index){&#xA;        j-&amp;gt;len = 0;&#xA;    }&#xA;    if(httpd_resp_send_chunk(j-&amp;gt;req, (const char *)data, len) != ESP_OK){&#xA;        return 0;&#xA;    }&#xA;    j-&amp;gt;len += len;&#xA;    return len;&#xA;}&#xA;&#xA;esp_err_t jpg_httpd_handler(httpd_req_t *req){&#xA;    camera_fb_t * fb = NULL;&#xA;    esp_err_t res = ESP_OK;&#xA;    size_t fb_len = 0;&#xA;    int64_t fr_start = esp_timer_get_time();&#xA;&#xA;    fb = esp_camera_fb_get();&#xA;    if (!fb) {&#xA;        ESP_LOGE(TAG, &#34;Camera capture failed&#34;);&#xA;        httpd_resp_send_500(req);&#xA;        return ESP_FAIL;&#xA;    }&#xA;    res = httpd_resp_set_type(req, &#34;image/jpeg&#34;);&#xA;    if(res == ESP_OK){&#xA;        res = httpd_resp_set_hdr(req, &#34;Content-Disposition&#34;, &#34;inline; filename=capture.jpg&#34;);&#xA;    }&#xA;&#xA;    if(res == ESP_OK){&#xA;        if(fb-&amp;gt;format == PIXFORMAT_JPEG){&#xA;            fb_len = fb-&amp;gt;len;&#xA;            res = httpd_resp_send(req, (const char *)fb-&amp;gt;buf, fb-&amp;gt;len);&#xA;        } else {&#xA;            jpg_chunking_t jchunk = {req, 0};&#xA;            res = frame2jpg_cb(fb, 80, jpg_encode_stream, &amp;amp;jchunk)?ESP_OK:ESP_FAIL;&#xA;            httpd_resp_send_chunk(req, NULL, 0);&#xA;            fb_len = jchunk.len;&#xA;        }&#xA;    }&#xA;    esp_camera_fb_return(fb);&#xA;    int64_t fr_end = esp_timer_get_time();&#xA;    ESP_LOGI(TAG, &#34;JPG: %uKB %ums&#34;, (uint32_t)(fb_len/1024), (uint32_t)((fr_end - fr_start)/1000));&#xA;    return res;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JPEG HTTP Stream&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;#include &#34;esp_http_server.h&#34;&#xA;#include &#34;esp_timer.h&#34;&#xA;&#xA;#define PART_BOUNDARY &#34;123456789000000000000987654321&#34;&#xA;static const char* _STREAM_CONTENT_TYPE = &#34;multipart/x-mixed-replace;boundary=&#34; PART_BOUNDARY;&#xA;static const char* _STREAM_BOUNDARY = &#34;\r\n--&#34; PART_BOUNDARY &#34;\r\n&#34;;&#xA;static const char* _STREAM_PART = &#34;Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n&#34;;&#xA;&#xA;esp_err_t jpg_stream_httpd_handler(httpd_req_t *req){&#xA;    camera_fb_t * fb = NULL;&#xA;    esp_err_t res = ESP_OK;&#xA;    size_t _jpg_buf_len;&#xA;    uint8_t * _jpg_buf;&#xA;    char * part_buf[64];&#xA;    static int64_t last_frame = 0;&#xA;    if(!last_frame) {&#xA;        last_frame = esp_timer_get_time();&#xA;    }&#xA;&#xA;    res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);&#xA;    if(res != ESP_OK){&#xA;        return res;&#xA;    }&#xA;&#xA;    while(true){&#xA;        fb = esp_camera_fb_get();&#xA;        if (!fb) {&#xA;            ESP_LOGE(TAG, &#34;Camera capture failed&#34;);&#xA;            res = ESP_FAIL;&#xA;            break;&#xA;        }&#xA;        if(fb-&amp;gt;format != PIXFORMAT_JPEG){&#xA;            bool jpeg_converted = frame2jpg(fb, 80, &amp;amp;_jpg_buf, &amp;amp;_jpg_buf_len);&#xA;            if(!jpeg_converted){&#xA;                ESP_LOGE(TAG, &#34;JPEG compression failed&#34;);&#xA;                esp_camera_fb_return(fb);&#xA;                res = ESP_FAIL;&#xA;            }&#xA;        } else {&#xA;            _jpg_buf_len = fb-&amp;gt;len;&#xA;            _jpg_buf = fb-&amp;gt;buf;&#xA;        }&#xA;&#xA;        if(res == ESP_OK){&#xA;            res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));&#xA;        }&#xA;        if(res == ESP_OK){&#xA;            size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);&#xA;&#xA;            res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);&#xA;        }&#xA;        if(res == ESP_OK){&#xA;            res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);&#xA;        }&#xA;        if(fb-&amp;gt;format != PIXFORMAT_JPEG){&#xA;            free(_jpg_buf);&#xA;        }&#xA;        esp_camera_fb_return(fb);&#xA;        if(res != ESP_OK){&#xA;            break;&#xA;        }&#xA;        int64_t fr_end = esp_timer_get_time();&#xA;        int64_t frame_time = fr_end - last_frame;&#xA;        last_frame = fr_end;&#xA;        frame_time /= 1000;&#xA;        ESP_LOGI(TAG, &#34;MJPG: %uKB %ums (%.1ffps)&#34;,&#xA;            (uint32_t)(_jpg_buf_len/1024),&#xA;            (uint32_t)frame_time, 1000.0 / (uint32_t)frame_time);&#xA;    }&#xA;&#xA;    last_frame = 0;&#xA;    return res;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;BMP HTTP Capture&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;#include &#34;esp_http_server.h&#34;&#xA;#include &#34;esp_timer.h&#34;&#xA;&#xA;esp_err_t bmp_httpd_handler(httpd_req_t *req){&#xA;    camera_fb_t * fb = NULL;&#xA;    esp_err_t res = ESP_OK;&#xA;    int64_t fr_start = esp_timer_get_time();&#xA;&#xA;    fb = esp_camera_fb_get();&#xA;    if (!fb) {&#xA;        ESP_LOGE(TAG, &#34;Camera capture failed&#34;);&#xA;        httpd_resp_send_500(req);&#xA;        return ESP_FAIL;&#xA;    }&#xA;&#xA;    uint8_t * buf = NULL;&#xA;    size_t buf_len = 0;&#xA;    bool converted = frame2bmp(fb, &amp;amp;buf, &amp;amp;buf_len);&#xA;    esp_camera_fb_return(fb);&#xA;    if(!converted){&#xA;        ESP_LOGE(TAG, &#34;BMP conversion failed&#34;);&#xA;        httpd_resp_send_500(req);&#xA;        return ESP_FAIL;&#xA;    }&#xA;&#xA;    res = httpd_resp_set_type(req, &#34;image/x-windows-bmp&#34;)&#xA;       || httpd_resp_set_hdr(req, &#34;Content-Disposition&#34;, &#34;inline; filename=capture.bmp&#34;)&#xA;       || httpd_resp_send(req, (const char *)buf, buf_len);&#xA;    free(buf);&#xA;    int64_t fr_end = esp_timer_get_time();&#xA;    ESP_LOGI(TAG, &#34;BMP: %uKB %ums&#34;, (uint32_t)(buf_len/1024), (uint32_t)((fr_end - fr_start)/1000));&#xA;    return res;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>cs50/libcs50</title>
    <updated>2023-03-14T01:30:14Z</updated>
    <id>tag:github.com,2023-03-14:/cs50/libcs50</id>
    <link href="https://github.com/cs50/libcs50" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is CS50&#39;s Library for C.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CS50 Library for C&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/cs50/libcs50&#34;&gt;&lt;img src=&#34;https://travis-ci.org/cs50/libcs50.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;make&lt;/code&gt;: builds dynamic library&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;make deb&lt;/code&gt;: builds source deb&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;make install&lt;/code&gt;: installs the library under &lt;code&gt;/usr/local&lt;/code&gt; by default (set &lt;code&gt;DESTDIR&lt;/code&gt; to change that)&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Ubuntu&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ curl -s https://packagecloud.io/install/repositories/cs50/repo/script.deb.sh | sudo bash&#xA;$ sudo apt-get install libcs50&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fedora&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ curl -s https://packagecloud.io/install/repositories/cs50/repo/script.rpm.sh | sudo bash&#xA;$ yum install libcs50&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;From Source (Linux and Mac)&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the latest release from &lt;a href=&#34;https://github.com/cs50/libcs50/releases&#34;&gt;https://github.com/cs50/libcs50/releases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Extract &lt;code&gt;libcs50-*.*&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd libcs50-*&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sudo make install&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;By default, we install to &lt;code&gt;/usr/local&lt;/code&gt;. If you&#39;d like to change the installation location, run &lt;code&gt;sudo DESTDIR=/path/to/install make install&lt;/code&gt; as desired.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If, when compiling a program, you see &lt;code&gt;/usr/bin/ld: cannot find -lcs50&lt;/code&gt;: Add &lt;code&gt;export LIBRARY_PATH=/usr/local/lib&lt;/code&gt; to your &lt;code&gt;.bashrc&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If, when compiling a program, you see &lt;code&gt;fatal error: &#39;cs50.h&#39; file not found&lt;/code&gt;: Add &lt;code&gt;export C_INCLUDE_PATH=/usr/local/include&lt;/code&gt; to your &lt;code&gt;.bashrc&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If, when executing a program, you see &lt;code&gt;error while loading shared libraries: libcs50.so.8: cannot open shared object file: No such file or directory&lt;/code&gt;: Add &lt;code&gt;export LD_LIBRARY_PATH=/usr/local/lib&lt;/code&gt; to your &lt;code&gt;.bashrc&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Close and reopen any terminal windows.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Link with &lt;code&gt;-lcs50&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;cs50.h&amp;gt;&#xA;&#xA;...&#xA;char c = get_char(&#34;Prompt: &#34;);&#xA;double d = get_double(&#34;Prompt: &#34;);&#xA;float f = get_float(&#34;Prompt: &#34;);&#xA;int i = get_int(&#34;Prompt: &#34;);&#xA;long l = get_long(&#34;Prompt: &#34;);&#xA;string s = get_string(&#34;Prompt: &#34;);&#xA;&#xA;// deprecated as of fall 2017&#xA;long long ll = get_long_long(&#34;Prompt: &#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;code&gt;man get_*&lt;/code&gt; after installation, or &lt;a href=&#34;https://reference.cs50.net/cs50/&#34;&gt;CS50 Reference&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add tests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/crossroads1112&#34;&gt;Chad Sharp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ehzShelter&#34;&gt;Emrul Hasan Zawad&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/IvanJasenov&#34;&gt;Ivan Jasenov&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kzidane&#34;&gt;Kareem Zidane&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>