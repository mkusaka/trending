<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-13T01:30:22Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Crypto-toolbox/HFT-Orderbook</title>
    <updated>2025-07-13T01:30:22Z</updated>
    <id>tag:github.com,2025-07-13:/Crypto-toolbox/HFT-Orderbook</id>
    <link href="https://github.com/Crypto-toolbox/HFT-Orderbook" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Limit Order Book for high-frequency trading (HFT), as described by WK Selph, implemented in Python3 and C&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HFT-Orderbook&lt;/h1&gt; &#xA;&lt;p&gt;Limit Order Book for high-frequency trading (HFT), as described by WK Selph, implemented in C.&lt;/p&gt; &#xA;&lt;p&gt;Based on WK Selph&#39;s Blogpost:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://howtohft.wordpress.com/2011/02/15/how-to-build-a-fast-limit-order-book/&#34;&gt;http://howtohft.wordpress.com/2011/02/15/how-to-build-a-fast-limit-order-book/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Available at Archive.org&#39;s WayBackMachine:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://goo.gl/KF1SRm&#34;&gt;https://goo.gl/KF1SRm&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;There are three main operations that a limit order book (LOB) has to&#xA;implement: add, cancel, and execute.  The goal is to implement these&#xA;operations in O(1) time while making it possible for the trading model to&#xA;efficiently ask questions like “what are the best bid and offer?”, “how much&#xA;volume is there between prices A and B?” or “what is order X’s current&#xA;position in the book?”.&#xA;&#xA;The vast majority of the activity in a book is usually made up of add and&#xA;cancel operations as market makers jockey for position, with executions a&#xA;distant third (in fact I would argue that the bulk of the useful information&#xA;on many stocks, particularly in the morning, is in the pattern of adds and&#xA;cancels, not executions, but that is a topic for another post).  An add&#xA;operation places an order at the end of a list of orders to be executed at&#xA;a particular limit price, a cancel operation removes an order from anywhere&#xA;in the book, and an execution removes an order from the inside of the book&#xA;(the inside of the book is defined as the oldest buy order at the highest&#xA;buying price and the oldest sell order at the lowest selling price).  Each&#xA;of these operations is keyed off an id number (Order.idNumber in the&#xA;pseudo-code below), making a hash table a natural structure for tracking&#xA;them.&#xA;&#xA;Depending on the expected sparsity of the book (sparsity being the&#xA;average distance in cents between limits that have volume, which is&#xA;generally positively correlated with the instrument price), there are a&#xA;number of slightly different implementations I’ve used.  First it will help&#xA;to define a few objects:&#xA;&#xA;    Order&#xA;      int idNumber;&#xA;      bool buyOrSell;&#xA;      int shares; // order size&#xA;      int limit;&#xA;      int entryTime;&#xA;      int eventTime;&#xA;      Order *nextOrder;&#xA;      Order *prevOrder;&#xA;      Limit *parentLimit;&#xA;&#xA;    Limit  // representing a single limit price&#xA;      int limitPrice;&#xA;      int size;&#xA;      int totalVolume;&#xA;      Limit *parent;&#xA;      Limit *leftChild;&#xA;      Limit *rightChild;&#xA;      Order *headOrder;&#xA;      Order *tailOrder;&#xA;&#xA;    Book&#xA;      Limit *buyTree;&#xA;      Limit *sellTree;&#xA;      Limit *lowestSell;&#xA;      Limit *highestBuy;&#xA;&#xA;The idea is to have a binary tree of Limit objects sorted by limitPrice,&#xA;each of which is itself a doubly linked list of Order objects.  Each side&#xA;of the book, the buy Limits and the sell Limits, should be in separate trees&#xA;so that the inside of the book corresponds to the end and beginning of the&#xA;buy Limit tree and sell Limit tree, respectively.  Each order is also an&#xA;entry in a map keyed off idNumber, and each Limit is also an entry in a&#xA;map keyed off limitPrice.&#xA;&#xA;With this structure you can easily implement these key operations with&#xA;good performance:&#xA;&#xA;Add – O(log M) for the first order at a limit, O(1) for all others&#xA;Cancel – O(1)&#xA;Execute – O(1)&#xA;GetVolumeAtLimit – O(1)&#xA;GetBestBid/Offer – O(1)&#xA;&#xA;where M is the number of price Limits (generally &amp;lt;&amp;lt; N the number of orders).&#xA;Some strategy for keeping the limit tree balanced should be used because the&#xA;nature of markets is such that orders will be being removed from one side&#xA;of the tree as they’re being added to the other.  Keep in mind, though,&#xA;that it is important to be able to update Book.lowestSell/highestBuy&#xA;in O(1) time when a limit is deleted (which is why each Limit has a Limit&#xA;*parent) so that GetBestBid/Offer can remain O(1).&#34;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>