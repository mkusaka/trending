<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-23T01:33:00Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xinntao/Real-ESRGAN-ncnn-vulkan</title>
    <updated>2022-11-23T01:33:00Z</updated>
    <id>tag:github.com,2022-11-23:/xinntao/Real-ESRGAN-ncnn-vulkan</id>
    <link href="https://github.com/xinntao/Real-ESRGAN-ncnn-vulkan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NCNN implementation of Real-ESRGAN. Real-ESRGAN aims at developing Practical Algorithms for General Image Restoration.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Real-ESRGAN ncnn Vulkan&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/xinntao/Real-ESRGAN-ncnn-vulkan/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://github.com/xinntao/Real-ESRGAN-ncnn-vulkan/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-blue.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xinntao/Real-ESRGAN-ncnn-vulkan/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues/xinntao/Real-ESRGAN-ncnn-vulkan&#34; alt=&#34;Open issue&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xinntao/Real-ESRGAN-ncnn-vulkan/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues-closed/xinntao/Real-ESRGAN-ncnn-vulkan&#34; alt=&#34;Closed issue&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project is the &lt;a href=&#34;https://github.com/Tencent/ncnn&#34;&gt;ncnn&lt;/a&gt; implementation of &lt;a href=&#34;https://github.com/xinntao/Real-ESRGAN&#34;&gt;&lt;strong&gt;Real-ESRGAN&lt;/strong&gt;&lt;/a&gt;. &lt;em&gt;Real-ESRGAN ncnn Vulkan&lt;/em&gt; heavily borrows from &lt;a href=&#34;https://github.com/nihui/realsr-ncnn-vulkan&#34;&gt;realsr-ncnn-vulkan&lt;/a&gt;. Many thanks to &lt;a href=&#34;https://github.com/nihui&#34;&gt;nihui&lt;/a&gt;, &lt;a href=&#34;https://github.com/Tencent/ncnn&#34;&gt;ncnn&lt;/a&gt; and &lt;a href=&#34;https://github.com/nihui/realsr-ncnn-vulkan&#34;&gt;realsr-ncnn-vulkan&lt;/a&gt; &lt;span&gt;üòÅ&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;Real-ESRGAN aims at developing &lt;strong&gt;Practical Algorithms for General Image Restoration&lt;/strong&gt;. We also optimize it for anime images.&lt;/p&gt; &#xA;&lt;h3&gt;Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xinntao/Real-ESRGAN-ncnn-vulkan/master/#hourglass_flowing_sand-todo-list&#34;&gt;TODO List&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xinntao/Real-ESRGAN-ncnn-vulkan/master/#computer-usages&#34;&gt;Usages&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;If Real-ESRGAN is helpful in your photos/projects, please help to &lt;span&gt;‚≠ê&lt;/span&gt; this repo or recommend it to your friends. Thanks&lt;span&gt;üòä&lt;/span&gt; &lt;br&gt; Other recommended projects:&lt;br&gt; &lt;span&gt;‚ñ∂&lt;/span&gt; &lt;a href=&#34;https://github.com/xinntao/Real-ESRGAN&#34;&gt;Real-ESRGAN&lt;/a&gt;: A practical algorithm for general image restoration&lt;br&gt; &lt;span&gt;‚ñ∂&lt;/span&gt; &lt;a href=&#34;https://github.com/TencentARC/GFPGAN&#34;&gt;GFPGAN&lt;/a&gt;: A practical algorithm for real-world face restoration &lt;br&gt; &lt;span&gt;‚ñ∂&lt;/span&gt; &lt;a href=&#34;https://github.com/xinntao/BasicSR&#34;&gt;BasicSR&lt;/a&gt;: An open-source image and video restoration toolbox&lt;br&gt; &lt;span&gt;‚ñ∂&lt;/span&gt; &lt;a href=&#34;https://github.com/xinntao/facexlib&#34;&gt;facexlib&lt;/a&gt;: A collection that provides useful face-relation functions.&lt;br&gt; &lt;span&gt;‚ñ∂&lt;/span&gt; &lt;a href=&#34;https://github.com/xinntao/HandyView&#34;&gt;HandyView&lt;/a&gt;: A PyQt5-based image viewer that is handy for view and comparison. &lt;br&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;span&gt;üìñ&lt;/span&gt; Real-ESRGAN: Training Real-World Blind Super-Resolution with Pure Synthetic Data&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[&lt;a href=&#34;https://arxiv.org/abs/2107.10833&#34;&gt;Paper&lt;/a&gt;] ‚ÄÉ [Project Page] ‚ÄÉ [Demo] &lt;br&gt; &lt;a href=&#34;https://xinntao.github.io/&#34;&gt;Xintao Wang&lt;/a&gt;, Liangbin Xie, &lt;a href=&#34;https://scholar.google.com.hk/citations?user=OSDCB0UAAAAJ&#34;&gt;Chao Dong&lt;/a&gt;, &lt;a href=&#34;https://scholar.google.com/citations?user=4oXBp9UAAAAJ&amp;amp;hl=en&#34;&gt;Ying Shan&lt;/a&gt; &lt;br&gt; Tencent ARC Lab; Shenzhen Institutes of Advanced Technology, Chinese Academy of Sciences&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/xinntao/Real-ESRGAN/master/assets/teaser.jpg&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/xinntao/public-figures/master/Real-ESRGAN/cmp_realesrgan_anime_1.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;‚è≥&lt;/span&gt; TODO List&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support further cheap arbitrary resize (&lt;em&gt;e.g.&lt;/em&gt;, bicubic, bilinear) for the model outputs&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Bug: Some PCs will output black images&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add the guidance for ncnn model conversion&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support face restoration - GFPGAN&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;span&gt;üíª&lt;/span&gt; Usages&lt;/h2&gt; &#xA;&lt;h3&gt;Example Command&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;realesrgan-ncnn-vulkan.exe -i input.jpg -o output.png -n realesr-animevideov3 -s 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Full Usages&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;Usage: realesrgan-ncnn-vulkan.exe -i infile -o outfile [options]...&#xA;&#xA;  -h                   show this help&#34;&#xA;  -i input-path        input image path (jpg/png/webp) or directory&#34;&#xA;  -o output-path       output image path (jpg/png/webp) or directory&#34;&#xA;  -s scale             upscale ratio (can be 2, 3, 4. default=4)&#34;&#xA;  -t tile-size         tile size (&amp;gt;=32/0=auto, default=0) can be 0,0,0 for multi-gpu&#34;&#xA;  -m model-path        folder path to the pre-trained models. default=models&#34;&#xA;  -n model-name        model name (default=realesr-animevideov3, can be realesr-animevideov3 | realesrgan-x4plus | realesrgan-x4plus-anime | realesrnet-x4plus)&#34;&#xA;  -g gpu-id            gpu device to use (default=auto) can be 0,1,2 for multi-gpu&#34;&#xA;  -j load:proc:save    thread count for load/proc/save (default=1:2:2) can be 1:2,2,2:2 for multi-gpu&#34;&#xA;  -x                   enable tta mode&#34;&#xA;  -f format            output image format (jpg/png/webp, default=ext/png)&#34;&#xA;  -v                   verbose output&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;input-path&lt;/code&gt; and &lt;code&gt;output-path&lt;/code&gt; accept either file path or directory path&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scale&lt;/code&gt; = scale level&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tile-size&lt;/code&gt; = tile size, use smaller value to reduce GPU memory usage, default selects automatically&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;load:proc:save&lt;/code&gt; = thread count for the three stages (image decoding + model upscaling + image encoding), using larger values may increase GPU usage and consume more GPU memory. You can tune this configuration with &#34;4:4:4&#34; for many small-size images, and &#34;2:2:2&#34; for large-size images. The default setting usually works fine for most situations. If you find that your GPU is hungry, try increasing thread count to achieve faster processing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;format&lt;/code&gt; = the format of the image to be output, png is better supported, however webp generally yields smaller file sizes, both are losslessly encoded&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you encounter crash or error, try to upgrade your GPU driver&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel: &lt;a href=&#34;https://downloadcenter.intel.com/product/80939/Graphics-Drivers&#34;&gt;https://downloadcenter.intel.com/product/80939/Graphics-Drivers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;AMD: &lt;a href=&#34;https://www.amd.com/en/support&#34;&gt;https://www.amd.com/en/support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;NVIDIA: &lt;a href=&#34;https://www.nvidia.com/Download/index.aspx&#34;&gt;https://www.nvidia.com/Download/index.aspx&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;span&gt;üåè&lt;/span&gt; Other Open-Source Code Used&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/ncnn&#34;&gt;https://github.com/Tencent/ncnn&lt;/a&gt; for fast neural network inference on ALL PLATFORMS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/webmproject/libwebp&#34;&gt;https://github.com/webmproject/libwebp&lt;/a&gt; for encoding and decoding Webp images on ALL PLATFORMS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nothings/stb&#34;&gt;https://github.com/nothings/stb&lt;/a&gt; for decoding and encoding image on Linux / MacOS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tronkko/dirent&#34;&gt;https://github.com/tronkko/dirent&lt;/a&gt; for listing files in directory on Windows&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;span&gt;üìú&lt;/span&gt; BibTeX&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;@InProceedings{wang2021realesrgan,&#xA;    author    = {Xintao Wang and Liangbin Xie and Chao Dong and Ying Shan},&#xA;    title     = {Real-ESRGAN: Training Real-World Blind Super-Resolution with Pure Synthetic Data},&#xA;    booktitle = {International Conference on Computer Vision Workshops (ICCVW)},&#xA;    date      = {2021}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;span&gt;üìß&lt;/span&gt; Contact&lt;/h2&gt; &#xA;&lt;p&gt;If you have any question, please email &lt;code&gt;xintao.wang@outlook.com&lt;/code&gt; or &lt;code&gt;xintaowang@tencent.com&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>justjake/quickjs-emscripten</title>
    <updated>2022-11-23T01:33:00Z</updated>
    <id>tag:github.com,2022-11-23:/justjake/quickjs-emscripten</id>
    <link href="https://github.com/justjake/quickjs-emscripten" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Javascript/Typescript bindings for QuickJS, a modern Javascript interpreter written in C by Fabrice Bellard.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;quickjs-emscripten&lt;/h1&gt; &#xA;&lt;p&gt;Javascript/Typescript bindings for QuickJS, a modern Javascript interpreter, compiled to WebAssembly.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Safely evaluate untrusted Javascript (up to ES2020).&lt;/li&gt; &#xA; &lt;li&gt;Create and manipulate values inside the QuickJS runtime (&lt;a href=&#34;https://raw.githubusercontent.com/justjake/quickjs-emscripten/main/#interfacing-with-the-interpreter&#34;&gt;more&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Expose host functions to the QuickJS runtime (&lt;a href=&#34;https://raw.githubusercontent.com/justjake/quickjs-emscripten/main/#exposing-apis&#34;&gt;more&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Execute synchronous code that uses asynchronous functions, with &lt;a href=&#34;https://raw.githubusercontent.com/justjake/quickjs-emscripten/main/#asyncify&#34;&gt;asyncify&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/justjake/quickjs-emscripten&#34;&gt;Github&lt;/a&gt; | &lt;a href=&#34;https://www.npmjs.com/package/quickjs-emscripten&#34;&gt;NPM&lt;/a&gt; | &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/modules.md&#34;&gt;API Documentation&lt;/a&gt; | &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/ts/quickjs.test.ts&#34;&gt;Examples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { getQuickJS } from &#34;quickjs-emscripten&#34;&#xA;&#xA;async function main() {&#xA;  const QuickJS = await getQuickJS()&#xA;  const vm = QuickJS.newContext()&#xA;&#xA;  const world = vm.newString(&#34;world&#34;)&#xA;  vm.setProp(vm.global, &#34;NAME&#34;, world)&#xA;  world.dispose()&#xA;&#xA;  const result = vm.evalCode(`&#34;Hello &#34; + NAME + &#34;!&#34;`)&#xA;  if (result.error) {&#xA;    console.log(&#34;Execution failed:&#34;, vm.dump(result.error))&#xA;    result.error.dispose()&#xA;  } else {&#xA;    console.log(&#34;Success:&#34;, vm.dump(result.value))&#xA;    result.value.dispose()&#xA;  }&#xA;&#xA;  vm.dispose()&#xA;}&#xA;&#xA;main()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Install from &lt;code&gt;npm&lt;/code&gt;: &lt;code&gt;npm install --save quickjs-emscripten&lt;/code&gt; or &lt;code&gt;yarn add quickjs-emscripten&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The root entrypoint of this library is the &lt;code&gt;getQuickJS&lt;/code&gt; function, which returns a promise that resolves to a &lt;a href=&#34;https://raw.githubusercontent.com/justjake/quickjs-emscripten/main/doc/classes/quickjs.md&#34;&gt;QuickJS singleton&lt;/a&gt; when the QuickJS WASM module is ready.&lt;/p&gt; &#xA;&lt;p&gt;Once &lt;code&gt;getQuickJS&lt;/code&gt; has been awaited at least once, you also can use the &lt;code&gt;getQuickJSSync&lt;/code&gt; function to directly access the singleton engine in your synchronous code.&lt;/p&gt; &#xA;&lt;h3&gt;Safely evaluate Javascript code&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/classes/quickjs.md#evalcode&#34;&gt;QuickJS.evalCode&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { getQuickJS, shouldInterruptAfterDeadline } from &#34;quickjs-emscripten&#34;&#xA;&#xA;getQuickJS().then((QuickJS) =&amp;gt; {&#xA;  const result = QuickJS.evalCode(&#34;1 + 1&#34;, {&#xA;    shouldInterrupt: shouldInterruptAfterDeadline(Date.now() + 1000),&#xA;    memoryLimitBytes: 1024 * 1024,&#xA;  })&#xA;  console.log(result)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interfacing with the interpreter&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/classes/QuickJSContext.md&#34;&gt;QuickJSContext&lt;/a&gt; to build a scripting environment by modifying globals and exposing functions into the QuickJS interpreter.&lt;/p&gt; &#xA;&lt;p&gt;Each &lt;code&gt;QuickJSContext&lt;/code&gt; instance has its own environment -- globals, built-in classes -- and actions from one context won&#39;t leak into other contexts or runtimes (with one exception, see &lt;a href=&#34;https://raw.githubusercontent.com/justjake/quickjs-emscripten/main/#asyncify&#34;&gt;Asyncify&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Every context is created inside a &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/classes/QuickJSRuntime.md&#34;&gt;QuickJSRuntime&lt;/a&gt;. A runtime represents a Javascript heap, and you can even share values between contexts in the same runtime.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const vm = QuickJS.newContext()&#xA;let state = 0&#xA;&#xA;const fnHandle = vm.newFunction(&#34;nextId&#34;, () =&amp;gt; {&#xA;  return vm.newNumber(++state)&#xA;})&#xA;&#xA;vm.setProp(vm.global, &#34;nextId&#34;, fnHandle)&#xA;fnHandle.dispose()&#xA;&#xA;const nextId = vm.unwrapResult(vm.evalCode(`nextId(); nextId(); nextId()`))&#xA;console.log(&#34;vm result:&#34;, vm.getNumber(nextId), &#34;native state:&#34;, state)&#xA;&#xA;nextId.dispose()&#xA;vm.dispose()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you create a context from a top-level API like in the example above, instead of by calling &lt;code&gt;runtime.newContext()&lt;/code&gt;, a runtime is automatically created for the lifetime of the context, and disposed of when you dispose the context.&lt;/p&gt; &#xA;&lt;h4&gt;Runtime&lt;/h4&gt; &#xA;&lt;p&gt;The runtime has APIs for CPU and memory limits that apply to all contexts within the runtime in aggregate. You can also use the runtime to configure EcmaScript module loading.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const runtime = QuickJS.newRuntime()&#xA;// &#34;Should be enough for everyone&#34; -- attributed to B. Gates&#xA;runtime.setMemoryLimit(1024 * 640)&#xA;// Limit stack size&#xA;runtime.setMaxStackSize(1024 * 320)&#xA;// Interrupt computation after 1024 calls to the interrupt handler&#xA;let interruptCycles = 0&#xA;runtime.setInterruptHandler(() =&amp;gt; ++interruptCycles &amp;gt; 1024)&#xA;// Toy module system that always returns the module name&#xA;// as the default export&#xA;runtime.setModuleLoader((moduleName) =&amp;gt; `export default &#39;${moduleName}&#39;`)&#xA;const context = runtime.newContext()&#xA;const ok = context.evalCode(`&#xA;import fooName from &#39;./foo.js&#39;&#xA;globalThis.result = fooName&#xA;`)&#xA;context.unwrapResult(ok).dispose()&#xA;// logs &#34;foo.js&#34;&#xA;console.log(context.getProp(context.global, &#34;result&#34;).consume(context.dump))&#xA;context.dispose()&#xA;runtime.dispose()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Memory Management&lt;/h3&gt; &#xA;&lt;p&gt;Many methods in this library return handles to memory allocated inside the WebAssembly heap. These types cannot be garbage-collected as usual in Javascript. Instead, you must manually manage their memory by calling a &lt;code&gt;.dispose()&lt;/code&gt; method to free the underlying resources. Once a handle has been disposed, it cannot be used anymore. Note that in the example above, we call &lt;code&gt;.dispose()&lt;/code&gt; on each handle once it is no longer needed.&lt;/p&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;QuickJSContext.dispose()&lt;/code&gt; will throw a RuntimeError if you&#39;ve forgotten to dispose any handles associated with that VM, so it&#39;s good practice to create a new VM instance for each of your tests, and to call &lt;code&gt;vm.dispose()&lt;/code&gt; at the end of every test.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const vm = QuickJS.newContext()&#xA;const numberHandle = vm.newNumber(42)&#xA;// Note: numberHandle not disposed, so it leaks memory.&#xA;vm.dispose()&#xA;// throws RuntimeError: abort(Assertion failed: list_empty(&amp;amp;rt-&amp;gt;gc_obj_list), at: quickjs/quickjs.c,1963,JS_FreeRuntime)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here are some strategies to reduce the toil of calling &lt;code&gt;.dispose()&lt;/code&gt; on each handle you create:&lt;/p&gt; &#xA;&lt;h4&gt;Scope&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/classes/scope.md#class-scope&#34;&gt;&lt;code&gt;Scope&lt;/code&gt;&lt;/a&gt; instance manages a set of disposables and calls their &lt;code&gt;.dispose()&lt;/code&gt; method in the reverse order in which they&#39;re added to the scope. Here&#39;s the &#34;Interfacing with the interpreter&#34; example re-written using &lt;code&gt;Scope&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;Scope.withScope((scope) =&amp;gt; {&#xA;  const vm = scope.manage(QuickJS.newContext())&#xA;  let state = 0&#xA;&#xA;  const fnHandle = scope.manage(&#xA;    vm.newFunction(&#34;nextId&#34;, () =&amp;gt; {&#xA;      return vm.newNumber(++state)&#xA;    })&#xA;  )&#xA;&#xA;  vm.setProp(vm.global, &#34;nextId&#34;, fnHandle)&#xA;&#xA;  const nextId = scope.manage(vm.unwrapResult(vm.evalCode(`nextId(); nextId(); nextId()`)))&#xA;  console.log(&#34;vm result:&#34;, vm.getNumber(nextId), &#34;native state:&#34;, state)&#xA;&#xA;  // When the withScope block exits, it calls scope.dispose(), which in turn calls&#xA;  // the .dispose() methods of all the disposables managed by the scope.&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also create &lt;code&gt;Scope&lt;/code&gt; instances with &lt;code&gt;new Scope()&lt;/code&gt; if you want to manage calling &lt;code&gt;scope.dispose()&lt;/code&gt; yourself.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Lifetime.consume(fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/classes/lifetime.md#consume&#34;&gt;&lt;code&gt;Lifetime.consume&lt;/code&gt;&lt;/a&gt; is sugar for the common pattern of using a handle and then immediately disposing of it. &lt;code&gt;Lifetime.consume&lt;/code&gt; takes a &lt;code&gt;map&lt;/code&gt; function that produces a result of any type. The &lt;code&gt;map&lt;/code&gt; fuction is called with the handle, then the handle is disposed, then the result is returned.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s the &#34;Interfacing with interpreter&#34; example re-written using &lt;code&gt;.consume()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const vm = QuickJS.newContext()&#xA;let state = 0&#xA;&#xA;vm.newFunction(&#34;nextId&#34;, () =&amp;gt; {&#xA;  return vm.newNumber(++state)&#xA;}).consume((fnHandle) =&amp;gt; vm.setProp(vm.global, &#34;nextId&#34;, fnHandle))&#xA;&#xA;vm.unwrapResult(vm.evalCode(`nextId(); nextId(); nextId()`)).consume((nextId) =&amp;gt;&#xA;  console.log(&#34;vm result:&#34;, vm.getNumber(nextId), &#34;native state:&#34;, state)&#xA;)&#xA;&#xA;vm.dispose()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generally working with &lt;code&gt;Scope&lt;/code&gt; leads to more straight-forward code, but &lt;code&gt;Lifetime.consume&lt;/code&gt; can be handy sugar as part of a method call chain.&lt;/p&gt; &#xA;&lt;h3&gt;Exposing APIs&lt;/h3&gt; &#xA;&lt;p&gt;To add APIs inside the QuickJS environment, you&#39;ll need to create objects to define the shape of your API, and add properties and functions to those objects to allow code inside QuickJS to call code on the host.&lt;/p&gt; &#xA;&lt;p&gt;By default, no host functionality is exposed to code running inside QuickJS.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const vm = QuickJS.newContext()&#xA;// `console.log`&#xA;const logHandle = vm.newFunction(&#34;log&#34;, (...args) =&amp;gt; {&#xA;  const nativeArgs = args.map(vm.dump)&#xA;  console.log(&#34;QuickJS:&#34;, ...nativeArgs)&#xA;})&#xA;// Partially implement `console` object&#xA;const consoleHandle = vm.newObject()&#xA;vm.setProp(consoleHandle, &#34;log&#34;, logHandle)&#xA;vm.setProp(vm.global, &#34;console&#34;, consoleHandle)&#xA;consoleHandle.dispose()&#xA;logHandle.dispose()&#xA;&#xA;vm.unwrapResult(vm.evalCode(`console.log(&#34;Hello from QuickJS!&#34;)`)).dispose()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Promises&lt;/h4&gt; &#xA;&lt;p&gt;To expose an asynchronous function that &lt;em&gt;returns a promise&lt;/em&gt; to callers within QuickJS, your function can return the handle of a &lt;code&gt;QuickJSDeferredPromise&lt;/code&gt; created via &lt;code&gt;context.newPromise()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When you resolve a &lt;code&gt;QuickJSDeferredPromise&lt;/code&gt; -- and generally whenever async behavior completes for the VM -- pending listeners inside QuickJS may not execute immediately. Your code needs to explicitly call &lt;code&gt;runtime.executePendingJobs()&lt;/code&gt; to resume execution inside QuickJS. This API gives your code maximum control to &lt;em&gt;schedule&lt;/em&gt; when QuickJS will block the host&#39;s event loop by resuming execution.&lt;/p&gt; &#xA;&lt;p&gt;To work with QuickJS handles that contain a promise inside the environment, you can convert the QuickJSHandle into a native promise using &lt;code&gt;context.resolvePromise()&lt;/code&gt;. Take care with this API to avoid &#39;deadlocks&#39; where the host awaits a guest promise, but the guest cannot make progress until the host calls &lt;code&gt;runtime.executePendingJobs()&lt;/code&gt;. The simplest way to avoid this kind of deadlock is to always schedule &lt;code&gt;executePendingJobs&lt;/code&gt; after any promise is settled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const vm = QuickJS.newContext()&#xA;const fakeFileSystem = new Map([[&#34;example.txt&#34;, &#34;Example file content&#34;]])&#xA;&#xA;// Function that simulates reading data asynchronously&#xA;const readFileHandle = vm.newFunction(&#34;readFile&#34;, (pathHandle) =&amp;gt; {&#xA;  const path = vm.getString(pathHandle)&#xA;  const promise = vm.newPromise()&#xA;  setTimeout(() =&amp;gt; {&#xA;    const content = fakeFileSystem.get(path)&#xA;    promise.resolve(vm.newString(content || &#34;&#34;))&#xA;  }, 100)&#xA;  // IMPORTANT: Once you resolve an async action inside QuickJS,&#xA;  // call runtime.executePendingJobs() to run any code that was&#xA;  // waiting on the promise or callback.&#xA;  promise.settled.then(vm.runtime.executePendingJobs)&#xA;  return promise.handle&#xA;})&#xA;readFileHandle.consume((handle) =&amp;gt; vm.setProp(vm.global, &#34;readFile&#34;, handle))&#xA;&#xA;// Evaluate code that uses `readFile`, which returns a promise&#xA;const result = vm.evalCode(`(async () =&amp;gt; {&#xA;  const content = await readFile(&#39;example.txt&#39;)&#xA;  return content.toUpperCase()&#xA;})()`)&#xA;const promiseHandle = vm.unwrapResult(result)&#xA;&#xA;// Convert the promise handle into a native promise and await it.&#xA;// If code like this deadlocks, make sure you are calling&#xA;// runtime.executePendingJobs appropriately.&#xA;const resolvedResult = await vm.resolvePromise(promiseHandle)&#xA;promiseHandle.dispose()&#xA;const resolvedHandle = vm.unwrapResult(resolvedResult)&#xA;console.log(&#34;Result:&#34;, vm.getString(resolvedHandle))&#xA;resolvedHandle.dispose()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Asyncify&lt;/h4&gt; &#xA;&lt;p&gt;Sometimes, we want to create a function that&#39;s synchronous from the perspective of QuickJS, but prefer to implement that function &lt;em&gt;asynchronously&lt;/em&gt; in your host code. The most obvious use-case is for EcmaScript module loading. The underlying QuickJS C library expects the module loader function to return synchronously, but loading data synchronously in the browser or server is somewhere between &#34;a bad idea&#34; and &#34;impossible&#34;. QuickJS also doesn&#39;t expose an API to &#34;pause&#34; the execution of a runtime, and adding such an API is tricky due to the VM&#39;s implementation.&lt;/p&gt; &#xA;&lt;p&gt;As a work-around, we provide an alternate build of QuickJS processed by Emscripten/Binaryen&#39;s &lt;a href=&#34;https://emscripten.org/docs/porting/asyncify.html&#34;&gt;ASYNCIFY&lt;/a&gt; compiler transform. Here&#39;s how Emscripten&#39;s documentation describes Asyncify:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Asyncify lets synchronous C or C++ code interact with asynchronous [host] JavaScript. This allows things like:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;A synchronous call in C that yields to the event loop, which allows browser events to be handled.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;A synchronous call in C that waits for an asynchronous operation in [host] JS to complete.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Asyncify automatically transforms ... code into a form that can be paused and resumed ..., so that it is asynchronous (hence the name ‚ÄúAsyncify‚Äù) even though [it is written] in a normal synchronous way.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This means we can suspend an &lt;em&gt;entire WebAssembly module&lt;/em&gt; (which could contain multiple runtimes and contexts) while our host Javascript loads data asynchronously, and then resume execution once the data load completes. This is a very handy superpower, but it comes with a couple of major limitations:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;An asyncified WebAssembly module can only suspend to wait for a single asynchronous call at a time&lt;/em&gt;. You may call back into a suspended WebAssembly module eg. to create a QuickJS value to return a result, but the system will crash if this call tries to suspend again. Take a look at Emscripten&#39;s documentation on &lt;a href=&#34;https://emscripten.org/docs/porting/asyncify.html#reentrancy&#34;&gt;reentrancy&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Asyncified code is bigger and runs slower&lt;/em&gt;. The asyncified build of Quickjs-emscripten library is 1M, 2x larger than the 500K of the default version. There may be room for further &lt;a href=&#34;https://emscripten.org/docs/porting/asyncify.html#optimizing&#34;&gt;optimization&lt;/a&gt; Of our build in the future.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To use asyncify features, use the following functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/modules.md#newasyncruntime&#34;&gt;newAsyncRuntime&lt;/a&gt;: create a runtime inside a new WebAssembly module.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/modules.md#newasynccontext&#34;&gt;newAsyncContext&lt;/a&gt;: create runtime and context together inside a new WebAssembly module.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/modules.md#newquickjsasyncwasmmodule&#34;&gt;newQuickJSAsyncWASMModule&lt;/a&gt;: create an empty WebAssembly module.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These functions are asynchronous because they always create a new underlying WebAssembly module so that each instance can suspend and resume independently, and instantiating a WebAssembly module is an async operation. This also adds substantial overhead compared to creating a runtime or context inside an existing module; if you only need to wait for a single async action at a time, you can create a single top-level module and create runtimes or contexts inside of it.&lt;/p&gt; &#xA;&lt;h5&gt;Async module loader&lt;/h5&gt; &#xA;&lt;p&gt;Here&#39;s an example of valuating a script that loads React asynchronously as an ES module. In our example, we&#39;re loading from the filesystem for reproducibility, but you can use this technique to load using &lt;code&gt;fetch&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const module = await newQuickJSAsyncWASMModule()&#xA;const runtime = module.newRuntime()&#xA;const path = await import(&#34;path&#34;)&#xA;const { promises: fs } = await import(&#34;fs&#34;)&#xA;&#xA;const importsPath = path.join(__dirname, &#34;../examples/imports&#34;) + &#34;/&#34;&#xA;// Module loaders can return promises.&#xA;// Execution will suspend until the promise resolves.&#xA;runtime.setModuleLoader((moduleName) =&amp;gt; {&#xA;  const modulePath = path.join(importsPath, moduleName)&#xA;  if (!modulePath.startsWith(importsPath)) {&#xA;    throw new Error(&#34;out of bounds&#34;)&#xA;  }&#xA;  console.log(&#34;loading&#34;, moduleName, &#34;from&#34;, modulePath)&#xA;  return fs.readFile(modulePath, &#34;utf-8&#34;)&#xA;})&#xA;&#xA;// evalCodeAsync is required when execution may suspend.&#xA;const context = runtime.newContext()&#xA;const result = await context.evalCodeAsync(`&#xA;import * as React from &#39;esm.sh/react@17&#39;&#xA;import * as ReactDOMServer from &#39;esm.sh/react-dom@17/server&#39;&#xA;const e = React.createElement&#xA;globalThis.html = ReactDOMServer.renderToStaticMarkup(&#xA;  e(&#39;div&#39;, null, e(&#39;strong&#39;, null, &#39;Hello world!&#39;))&#xA;)&#xA;`)&#xA;context.unwrapResult(result).dispose()&#xA;const html = context.getProp(context.global, &#34;html&#34;).consume(context.getString)&#xA;console.log(html) // &amp;lt;div&amp;gt;&amp;lt;strong&amp;gt;Hello world!&amp;lt;/strong&amp;gt;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Async on host, sync in QuickJS&lt;/h5&gt; &#xA;&lt;p&gt;Here&#39;s an example of turning an async function into a sync function inside the VM.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const context = await newAsyncContext()&#xA;const path = await import(&#34;path&#34;)&#xA;const { promises: fs } = await import(&#34;fs&#34;)&#xA;&#xA;const importsPath = path.join(__dirname, &#34;../examples/imports&#34;) + &#34;/&#34;&#xA;const readFileHandle = context.newAsyncifiedFunction(&#34;readFile&#34;, async (pathHandle) =&amp;gt; {&#xA;  const pathString = path.join(importsPath, context.getString(pathHandle))&#xA;  if (!pathString.startsWith(importsPath)) {&#xA;    throw new Error(&#34;out of bounds&#34;)&#xA;  }&#xA;  const data = await fs.readFile(pathString, &#34;utf-8&#34;)&#xA;  return context.newString(data)&#xA;})&#xA;readFileHandle.consume((fn) =&amp;gt; context.setProp(context.global, &#34;readFile&#34;, fn))&#xA;&#xA;// evalCodeAsync is required when execution may suspend.&#xA;const result = await context.evalCodeAsync(`&#xA;// Not a promise! Sync! vvvvvvvvvvvvvvvvvvvv &#xA;const data = JSON.parse(readFile(&#39;data.json&#39;))&#xA;data.map(x =&amp;gt; x.toUpperCase()).join(&#39; &#39;)&#xA;`)&#xA;const upperCaseData = context.unwrapResult(result).consume(context.getString)&#xA;console.log(upperCaseData) // &#39;VERY USEFUL DATA&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing your code&lt;/h3&gt; &#xA;&lt;p&gt;This library is complicated to use, so please consider automated testing your implementation. We highly writing your test suite to run with both the &#34;release&#34; build variant of quickjs-emscripten, and also the &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/modules.md#debug_sync&#34;&gt;DEBUG_SYNC&lt;/a&gt; build variant. The debug sync build variant has extra instrumentation code for detecting memory leaks.&lt;/p&gt; &#xA;&lt;p&gt;The class &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/classes/TestQuickJSWASMModule.md&#34;&gt;TestQuickJSWASMModule&lt;/a&gt; exposes the memory leak detection API, although this API is only accurate when using &lt;code&gt;DEBUG_SYNC&lt;/code&gt; variant.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// Define your test suite in a function, so that you can test against&#xA;// different module loaders.&#xA;function myTests(moduleLoader: () =&amp;gt; Promise&amp;lt;QuickJSWASMModule&amp;gt;) {&#xA;  let QuickJS: TestQuickJSWASMModule&#xA;  beforeEach(async () =&amp;gt; {&#xA;    // Get a unique TestQuickJSWASMModule instance for each test.&#xA;    const wasmModule = await moduleLoader()&#xA;    QuickJS = new TestQuickJSWASMModule(wasmModule)&#xA;  })&#xA;  afterEach(() =&amp;gt; {&#xA;    // Assert that the test disposed all handles. The DEBUG_SYNC build&#xA;    // variant will show detailed traces for each leak.&#xA;    QuickJS.assertNoMemoryAllocated()&#xA;  })&#xA;&#xA;  it(&#34;works well&#34;, () =&amp;gt; {&#xA;    // TODO: write a test using QuickJS&#xA;    const context = QuickJS.newContext()&#xA;    context.unwrapResult(context.evalCode(&#34;1 + 1&#34;)).dispose()&#xA;    context.dispose()&#xA;  })&#xA;}&#xA;&#xA;// Run the test suite against a matrix of module loaders.&#xA;describe(&#34;Check for memory leaks with QuickJS DEBUG build&#34;, () =&amp;gt; {&#xA;  const moduleLoader = memoizePromiseFactory(() =&amp;gt; newQuickJSWASMModule(DEBUG_SYNC))&#xA;  myTests(moduleLoader)&#xA;})&#xA;&#xA;describe(&#34;Realistic test with QuickJS RELEASE build&#34;, () =&amp;gt; {&#xA;  myTests(getQuickJS)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more testing examples, please explore the typescript source of &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/ts&#34;&gt;quickjs-emscripten&lt;/a&gt; repository.&lt;/p&gt; &#xA;&lt;h3&gt;Debugging&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Switch to a DEBUG build variant of the WebAssembly module to see debug log messages from the C part of this library.&lt;/li&gt; &#xA; &lt;li&gt;Set &lt;code&gt;process.env.QTS_DEBUG&lt;/code&gt; to see debug log messages from the Javascript part of this library.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;More Documentation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/justjake/quickjs-emscripten&#34;&gt;Github&lt;/a&gt; | &lt;a href=&#34;https://www.npmjs.com/package/quickjs-emscripten&#34;&gt;NPM&lt;/a&gt; | &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/doc/modules.md&#34;&gt;API Documentation&lt;/a&gt; | &lt;a href=&#34;https://github.com/justjake/quickjs-emscripten/raw/main/ts/quickjs.test.ts&#34;&gt;Examples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;This was inspired by seeing &lt;a href=&#34;https://github.com/maple3142/duktape-eval&#34;&gt;https://github.com/maple3142/duktape-eval&lt;/a&gt; &lt;a href=&#34;https://news.ycombinator.com/item?id=21946565&#34;&gt;on Hacker News&lt;/a&gt; and Figma&#39;s blogposts about using building a Javascript plugin runtime:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.figma.com/blog/how-we-built-the-figma-plugin-system/&#34;&gt;How Figma built the Figma plugin system&lt;/a&gt;: Describes the LowLevelJavascriptVm interface.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.figma.com/blog/an-update-on-plugin-security/&#34;&gt;An update on plugin security&lt;/a&gt;: Figma switches to QuickJS.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Status &amp;amp; Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Stability&lt;/strong&gt;: Because the version number of this project is below &lt;code&gt;1.0.0&lt;/code&gt;, *expect occasional breaking API changes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Security&lt;/strong&gt;: This project makes every effort to be secure, but has not been audited. Please use with care in production settings.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Roadmap&lt;/strong&gt;: I work on this project in my free time, for fun. Here&#39;s I&#39;m thinking comes next. Last updated 2022-03-18.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Further work on module loading APIs:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Create modules via Javascript, instead of source text.&lt;/li&gt; &#xA;   &lt;li&gt;Scan source text for imports, for ahead of time or concurrent loading. (This is possible with third-party tools, so lower priority.)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Higher-level tools for reading QuickJS values:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Type guard functions: &lt;code&gt;context.isArray(handle)&lt;/code&gt;, &lt;code&gt;context.isPromise(handle)&lt;/code&gt;, etc.&lt;/li&gt; &#xA;   &lt;li&gt;Iteration utilities: &lt;code&gt;context.getIterable(handle)&lt;/code&gt;, &lt;code&gt;context.iterateObjectEntries(handle)&lt;/code&gt;. This better supports user-level code to deserialize complex handle objects.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Higher-level tools for creating QuickJS values:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Devise a way to avoid needing to mess around with handles when setting up the environment.&lt;/li&gt; &#xA;   &lt;li&gt;Consider integrating &lt;a href=&#34;https://github.com/reearth/quickjs-emscripten-sync&#34;&gt;quickjs-emscripten-sync&lt;/a&gt; for automatic translation.&lt;/li&gt; &#xA;   &lt;li&gt;Consider class-based or interface-type-based marshalling.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;EcmaScript Modules / WebAssembly files / Deno support. This requires me to learn a lot of new things, but should be interesting for modern browser usage.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SQLite integration.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Related&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Duktape wrapped in Wasm: &lt;a href=&#34;https://github.com/maple3142/duktape-eval/raw/main/src/Makefile&#34;&gt;https://github.com/maple3142/duktape-eval/blob/main/src/Makefile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;QuickJS wrapped in C++: &lt;a href=&#34;https://github.com/ftk/quickjspp&#34;&gt;https://github.com/ftk/quickjspp&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Developing&lt;/h2&gt; &#xA;&lt;p&gt;This library is implemented in two languages: C (compiled to WASM with Emscripten), and Typescript.&lt;/p&gt; &#xA;&lt;h3&gt;The C parts&lt;/h3&gt; &#xA;&lt;p&gt;The ./c directory contains C code that wraps the QuickJS C library (in ./quickjs). Public functions (those starting with &lt;code&gt;QTS_&lt;/code&gt;) in ./c/interface.c are automatically exported to native code (via a generated header) and to Typescript (via a generated FFI class). See ./generate.ts for how this works.&lt;/p&gt; &#xA;&lt;p&gt;The C code builds as both with &lt;code&gt;emscripten&lt;/code&gt; (using &lt;code&gt;emcc&lt;/code&gt;), to produce WASM (or ASM.js) and with &lt;code&gt;clang&lt;/code&gt;. Build outputs are checked in, so you can iterate on the Javascript parts of the library without setting up the Emscripten toolchain.&lt;/p&gt; &#xA;&lt;p&gt;Intermediate object files from QuickJS end up in ./build/quickjs/.&lt;/p&gt; &#xA;&lt;p&gt;This project uses &lt;code&gt;emscripten 3.1.7&lt;/code&gt; via Docker. You will need a working &lt;code&gt;docker&lt;/code&gt; install to build the Emscripten artifacts.&lt;/p&gt; &#xA;&lt;p&gt;Related NPM scripts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;yarn update-quickjs&lt;/code&gt; will sync the ./quickjs folder with a github repo tracking the upstream QuickJS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;yarn make-debug&lt;/code&gt; will rebuild C outputs into ./build/wrapper&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;yarn make-release&lt;/code&gt; will rebuild C outputs in release mode, which is the mode that should be checked into the repo.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The Typescript parts&lt;/h3&gt; &#xA;&lt;p&gt;The ./ts directory contains Typescript types and wraps the generated Emscripten FFI in a more usable interface.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll need &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; or &lt;code&gt;yarn&lt;/code&gt;. Install dependencies with &lt;code&gt;npm install&lt;/code&gt; or &lt;code&gt;yarn install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;yarn build&lt;/code&gt; produces ./dist.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;yarn test&lt;/code&gt; runs the tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;yarn test --watch&lt;/code&gt; watches for changes and re-runs the tests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Yarn updates&lt;/h3&gt; &#xA;&lt;p&gt;Just run &lt;code&gt;yarn set version from sources&lt;/code&gt; to upgrade the Yarn release.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jart/blink</title>
    <updated>2022-11-23T01:33:00Z</updated>
    <id>tag:github.com,2022-11-23:/jart/blink</id>
    <link href="https://github.com/jart/blink" rel="alternate"></link>
    <summary type="html">&lt;p&gt;tiniest x86-64-linux emulator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;blink&lt;/h1&gt; &#xA;&lt;p&gt;blink is a virtual machine for running x86-64-linux programs on different operating systems and hardware architectures. It&#39;s designed to do the same thing as the &lt;code&gt;qemu-x86_64&lt;/code&gt; command, except rather than being a 10mb binary, blink only has a ~146kb footprint. For further details on the motivations for this tool, please read &lt;a href=&#34;https://justine.lol/ape.html&#34;&gt;https://justine.lol/ape.html&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Caveat Emptor&lt;/h2&gt; &#xA;&lt;p&gt;Welcome everyone from the Hacker News, Lobsters, and Reddit communities! This project is a work in progress. Please don&#39;t use this for production yet. If you try this be sure to calibrate your expectations accordingly.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;You can compile blink on x86-64 Linux, Darwin, FreeBSD, NetBSD, OpenBSD, Apple Silicon, and Raspberry Pi using your operating system&#39;s toolchain.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# for all x86-64 platforms&#xA;$ build/bootstrap/make.com -j8 o//blink/blink&#xA;&#xA;# for apple m1 arm silicon&#xA;# don&#39;t use the ancient version of gnu make that comes with xcode&#xA;$ make -j8 o//blink/blink&#xA;&#xA;# for linux raspberry pi&#xA;$ build/bootstrap/blink-linux-aarch64 build/bootstrap/make.com -j8 o//blink/blink&#xA;&#xA;# run actually portable executable in virtual machine&#xA;$ o//blink/blink third_party/cosmo/hello.com&#xA;hello world&#xA;&#xA;# run static elf binary in virtual machine&#xA;$ o//blink/blink third_party/cosmo/tinyhello.elf&#xA;hello world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s a terminal interface for debugging:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ build/bootstrap/make.com -j8 o///blink/tui&#xA;$ o//blink/tui -t third_party/cosmo/tinyhello.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run our test executables to check your local platform build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com -j8 check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For maximum performance, use &lt;code&gt;MODE=rel&lt;/code&gt; or &lt;code&gt;MODE=opt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com MODE=opt -j8 check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For maximum tinyness, use &lt;code&gt;MODE=tiny&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ build/bootstrap/make.com MODE=tiny -j8 check&#xA;$ strip o/tiny/blink/blink&#xA;$ ls -hal o/tiny/blink/blink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can sanitize using &lt;code&gt;MODE=asan&lt;/code&gt;, &lt;code&gt;MODE=ubsan&lt;/code&gt;, &lt;code&gt;MODE=tsan&lt;/code&gt;, and &lt;code&gt;MODE=msan&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re building your code on an x86-64 Linux machine, then the following command will cross-compile blink for i386, arm, m68k, riscv, mips, s390x. Then it&#39;ll launch all the cross-compiled binaries in qemu to ensure the test programs above work on all architectures.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com -j8 emulates&#xA;$ o/third_party/qemu/qemu-aarch64 o//aarch64/blink/blink third_party/cosmo/hello.com&#xA;hello world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Technical Details&lt;/h2&gt; &#xA;&lt;p&gt;blink is an x86-64 interpreter for POSIX platforms that&#39;s written in ANSI C11 that&#39;s compatible with C++ compilers. Instruction decoding is done using our trimmed-down version of Intel&#39;s disassembler Xed. Blink does &lt;em&gt;some&lt;/em&gt; code generation at runtime, using a just-in-time approach, where functions are generated that thread statically-compiled operation functions together.&lt;/p&gt; &#xA;&lt;p&gt;The prime directive of this project is to act as a virtual machine for userspace binaries compiled by Cosmopolitan Libc. Much of the surface area of the Linux SYSCALL ABI is supported, including fork() and clone(). The SSE2, SSE3, SSSE3, POPCNT, CLMUL, RDTSCP, and RDRND ISAs are supported. x87 currently only supports double (64-bit) precision.&lt;/p&gt; &#xA;&lt;p&gt;Blink supports 32-bit and 16-bit BIOS programs, plus just enough ring0 instructions to test an operating system bootloader. Plus IBM PC Serial UART, CGA, and MDA. However these legacy features might get sprung into a sister project sometime soon.&lt;/p&gt; &#xA;&lt;h2&gt;Flakes&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jart/blink/master/test/flakes.png&#34; alt=&#34;Blink Flakes: The Original and Best Unexplained Errors&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Mutex lock tests sometimes flake in a very specific way after joining threads on qemu-aarch64, qemu-mips, and qemu-s390x:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// this happens on aarch64, mips, and s390x&#xA;error:test/libc/intrin/pthread_mutex_lock2_test.c:95: pthread_mutex_lock_contention(pthread_mutex_lock_recursive) on blink.local pid 22952 tid 22952&#xA;        EXPECT_EQ(THREADS, started)&#xA;                need 16 (or 0x10 or &#39;‚ñ∫&#39;) =&#xA;                 got 15 (or 0xf or &#39;‚òº&#39;)&#xA;        EUNKNOWN/0/No error information&#xA;        third_party/cosmo/pthread_mutex_lock2_test.com @ blink.local&#xA;1 / 284 tests failed&#xA;make: *** [test/test.mk:90: o//mips64/third_party/cosmo/pthread_mutex_lock2_test.com.emulates] Error 1&#xA;&#xA;// instructions in question&#xA;  40d1fe:       f0 83 05 8e c2 06 00 01         lock addl $0x1,0x6c28e(%rip)        # 479494 &amp;lt;started&amp;gt;&#xA;...&#xA;  40d3c2:       4c 63 25 cb c0 06 00    movslq 0x6c0cb(%rip),%r12        # 479494 &amp;lt;started&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*NSYNC unit tests sometimes flake:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;I2022-11-21T00:43:58.774807:blink/throw.c:59: 262144: SEGMENTATION FAULT AT ADDRESS 8&#xA;         PC 41b77f mov %rsi,8(%rcx)&#xA;         AX 00001000802985e8  CX 0000000000000000  DX 00001000802985e8  BX 0000100080252fe0&#xA;         SP 000010008007fcf0  BP 000010008007fcf0  SI 00001000802985e8  DI 0000000000486820&#xA;         R8 0000000000433ca0  R9 0000000000000004 R10 0000000000000000 R11 0000000000000000&#xA;        R12 00001000802985e0 R13 0000000000000004 R14 0000100080252fe8 R15 000000000000001d&#xA;         FS 0000100080040240  GS 0000000000000000 OPS 5555954          JIT 0&#xA;        third_party/cosmo/wait_test.com&#xA;        10008007fcf0 00000041b77f nsync_dll_make_last_in_list_+0x2f 0 bytes&#xA;        10008007fd20 00000040d0c9 counter_enqueue+0x39 48 bytes&#xA;        10008007fe90 00000040e289 nsync_wait_n+0x199 368 bytes&#xA;        10008007ff20 00000040a9c3 test_wait_n+0x3d3 144 bytes&#xA;        10008007ff50 00000040b1ad run_test+0x6d 48 bytes&#xA;        10008007ff70 00000040adbb closure_f0_testing+0x1b 32 bytes&#xA;        10008007ff80 00000040ab0b closure_run_body+0xb 16 bytes&#xA;        10008007ffa0 00000040ac6a body+0x1a 32 bytes&#xA;        10008007fff0 00000040c05c PosixThread+0xac 80 bytes&#xA;        000000000000 00000042f7e3 sys_clone_linux+0x26&#xA;I2022-11-21T00:43:58.774829:blink/syscall.c:195: 262144: halting machine from thread: -4&#xA;make: *** [third_party/cosmo/cosmo.mk:20: o//third_party/cosmo/wait_test.com.ok] Error 252&#xA;&#xA;I2022-11-21T01:28:26.296387:blink/throw.c:59: 262144: SEGMENTATION FAULT AT ADDRESS 3450&#xA;         PC 41b80e mov (%rdi),%rcx&#xA;         AX 000010008007fda8  CX 0000000000000000  DX 000010008007fda8  BX 000010008004bfe0&#xA;         SP 000010008007fcf0  BP 000010008007fcf0  SI 000010008007fda8  DI 0000000000003450&#xA;         R8 0000000000433c40  R9 0000000000000001 R10 0000000000465740 R11 0000000000000000&#xA;        R12 000010008007fda0 R13 0000000000000001 R14 000010008004bfe8 R15 0000000000000001&#xA;         FS 0000100080040240  GS 0000000000000000 OPS 532982           JIT 0&#xA;        third_party/cosmo/once_test.com&#xA;        10008007fcf0 00000041b80e nsync_dll_make_last_in_list_+0x1e 0 bytes&#xA;        10008007fd20 00000040cbe9 counter_enqueue+0x39 48 bytes&#xA;        10008007fe90 00000040d7e9 nsync_wait_n+0x199 368 bytes&#xA;        10008007fee0 00000040cdd1 nsync_counter_wait+0x41 80 bytes&#xA;        10008007ff20 00000040a52c test_once_run+0xec 64 bytes&#xA;        10008007ff50 00000040ad9d run_test+0x6d 48 bytes&#xA;        10008007ff70 00000040a9ab closure_f0_testing+0x1b 32 bytes&#xA;        10008007ff80 00000040a6fb closure_run_body+0xb 16 bytes&#xA;        10008007ffa0 00000040a85a body+0x1a 32 bytes&#xA;        10008007fff0 00000040bc4c PosixThread+0xac 80 bytes&#xA;        000000000000 00000042f7e3 sys_clone_linux+0x26&#xA;I2022-11-21T01:28:26.303859:blink/syscall.c:195: 262144: halting machine from thread: -4&#xA;make: *** [third_party/cosmo/cosmo.mk:21: o/asan/third_party/cosmo/once_test.com.ok] Error 252&#xA;&#xA;I2022-11-21T01:30:50.158305:blink/throw.c:59: 262144: SEGMENTATION FAULT AT ADDRESS 8&#xA;         PC 40e177 mov 8(%rax),%rdx&#xA;         AX 0000000000000000  CX 7fffffffffffffff  DX 0000100080040140  BX 000010008004ef80&#xA;         SP 000010008007fd30  BP 000010008007fe90  SI 000010008007fd1c  DI 0000000000000001&#xA;         R8 000000003b9ac9ff  R9 000000000000000f R10 0000000000000000 R11 0000000000000000&#xA;        R12 0000000000000000 R13 7fffffffffffffff R14 000000000000000e R15 0000000000000000&#xA;         FS 0000100080040240  GS 0000000000000000 OPS 1993605          JIT 0&#xA;        third_party/cosmo/wait_test.com&#xA;        10008007fe90 00000040e177 nsync_wait_n+0x87 352 bytes&#xA;        10008007ff20 00000040a9c3 test_wait_n+0x3d3 144 bytes&#xA;        10008007ff50 00000040b1ad run_test+0x6d 48 bytes&#xA;        10008007ff70 00000040adbb closure_f0_testing+0x1b 32 bytes&#xA;        10008007ff80 00000040ab0b closure_run_body+0xb 16 bytes&#xA;        10008007ffa0 00000040ac6a body+0x1a 32 bytes&#xA;        10008007fff0 00000040c05c PosixThread+0xac 80 bytes&#xA;        000000000000 00000042f7e3 sys_clone_linux+0x26&#xA;I2022-11-21T01:30:50.163956:blink/syscall.c:195: 262144: halting machine from thread: -4&#xA;make: *** [third_party/cosmo/cosmo.mk:20: o/tsan/third_party/cosmo/wait_test.com.ok] Error 252&#xA;&#xA;I2022-11-21T00:05:25.934780:blink/throw.c:59: 262144: SEGMENTATION FAULT AT ADDRESS 0&#xA;         PC 40e180 call (%rdx)&#xA;         AX 00001000803ebe30  CX 0000000000000000  DX 0000000000000000  BX 000010008022bc00&#xA;         SP 000010008007fd30  BP 000010008007fe90  SI 0000000000000000  DI 00001000803e84d0&#xA;         R8 000000003b9ac9ff  R9 000000000000001e R10 0000000000000000 R11 0000000000000000&#xA;        R12 0000000000000002 R13 7fffffffffffffff R14 000000000000001d R15 0000000000000002&#xA;         FS 0000100080040240  GS 0000000000000000 OPS 2347174          JIT 0&#xA;        third_party/cosmo/wait_test.com&#xA;        10008007fe90 00000040e180 nsync_wait_n+0x90 352 bytes&#xA;        10008007ff20 00000040a9c3 test_wait_n+0x3d3 144 bytes&#xA;        10008007ff50 00000040b1ad run_test+0x6d 48 bytes&#xA;        10008007ff70 00000040adbb closure_f0_testing+0x1b 32 bytes&#xA;        10008007ff80 00000040ab0b closure_run_body+0xb 16 bytes&#xA;        10008007ffa0 00000040ac6a body+0x1a 32 bytes&#xA;        10008007fff0 00000040c05c PosixThread+0xac 80 bytes&#xA;        000000000000 00000042f7e3 sys_clone_linux+0x26&#xA;I2022-11-21T00:05:25.934796:blink/syscall.c:195: 262144: halting machine from thread: -4&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>