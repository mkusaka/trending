<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-27T01:30:14Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cyring/CoreFreq</title>
    <updated>2022-12-27T01:30:14Z</updated>
    <id>tag:github.com,2022-12-27:/cyring/CoreFreq</id>
    <link href="https://github.com/cyring/CoreFreq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CoreFreq is a CPU monitoring software designed for the 64-bits Processors.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;em&gt;CoreFreq&lt;/em&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Purpose&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;CoreFreq&lt;/em&gt;, a CPU monitoring software with BIOS like functionalities, is designed for the 64-bits Processors of architecture Intel Atom, Core2, Nehalem, SandyBridge and superiors; AMD Families from 0Fh ... up to 17h (Zen , Zen+ , Zen2), 18h (Hygon Dhyana), 19h (Zen3)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_Top.gif&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq Top&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;CoreFreq&lt;/em&gt; provides a framework to retrieve CPU data with a high degree of precision:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Core frequencies &amp;amp; ratios; SpeedStep (EIST), Turbo Boost, Hyper-Threading (HTT) and Base Clock&lt;/li&gt; &#xA; &lt;li&gt;Performance counters including Time Stamp Counter (TSC), Unhalted Core Cycles (UCC), Unhalted Reference Cycles (URC)&lt;/li&gt; &#xA; &lt;li&gt;Number of instructions per cycle or second, IPS, IPC, or CPI&lt;/li&gt; &#xA; &lt;li&gt;CPU C-States C0 C1 C3 C6 C7 - C1E - Auto/UnDemotion of C1 C3&lt;/li&gt; &#xA; &lt;li&gt;DTS Temperature and Tjunction Max, Thermal Monitoring TM1 TM2 state, Vcore&lt;/li&gt; &#xA; &lt;li&gt;Topology map including Caches for boostrap &amp;amp; application CPU&lt;/li&gt; &#xA; &lt;li&gt;Processor features, brand &amp;amp; architecture strings&lt;/li&gt; &#xA; &lt;li&gt;In progress: Uncore, Memory Controller channels &amp;amp; geometry, DIMM timings,&lt;br&gt; Stress tools, Power &amp;amp; Energy (RAPL, P-State, HWP, TDP), Overclocking, cpuidle &amp;amp; cpufreq driver, ClockSource, Mitigation Mechanisms&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To reach this goal, &lt;em&gt;CoreFreq&lt;/em&gt; implements a Linux Kernel module which employs the followings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;asm code to keep as near as possible the readings of the performance counters;&lt;/li&gt; &#xA; &lt;li&gt;per-CPU, implements slab data memory and high-resolution timer;&lt;/li&gt; &#xA; &lt;li&gt;compliant with suspend / resume and CPU Hot-Plug;&lt;/li&gt; &#xA; &lt;li&gt;a shared memory to protect kernel from the user-space part of the software;&lt;/li&gt; &#xA; &lt;li&gt;atomic synchronization of threads to avoid mutexes and deadlock.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build &amp;amp; Run&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;a-&lt;/strong&gt; &lt;em&gt;Intel only&lt;/em&gt;: For a better accuracy, &lt;em&gt;disable&lt;/em&gt; the Kernel &lt;em&gt;NMI Watchdog&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add the below &lt;a href=&#34;https://github.com/torvalds/linux/raw/master/Documentation/admin-guide/kernel-parameters.txt&#34;&gt;parameter&lt;/a&gt; in the kernel boot loader { &lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub/grub.html#GNU_002fLinux&#34;&gt;Grub&lt;/a&gt;, &lt;a href=&#34;https://wiki.syslinux.org/wiki/index.php?title=Config#APPEND&#34;&gt;SysLinux&lt;/a&gt; } ...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nmi_watchdog=0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... and build with the fixed performance counters&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make MSR_CORE_PERF_UC=MSR_CORE_PERF_FIXED_CTR1 MSR_CORE_PERF_URC=MSR_CORE_PERF_FIXED_CTR2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;b-&lt;/strong&gt; &lt;em&gt;AMD and Intel&lt;/em&gt;: Some Virtualization&lt;/p&gt; &#xA;&lt;p&gt;VMs don&#39;t provide access to the registers that the &lt;em&gt;CoreFreq&lt;/em&gt; driver employs :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed Performance Counters&lt;/li&gt; &#xA; &lt;li&gt;Model Specific Registers&lt;/li&gt; &#xA; &lt;li&gt;PCI Registers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However &lt;em&gt;CoreFreq&lt;/em&gt; is making use of the virtualized performance counter :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;HV_X64_MSR_VP_RUNTIME(0x40000010)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;c-&lt;/strong&gt; Rendering&lt;/p&gt; &#xA;&lt;p&gt;The UI renders best with an ASCII console or a Xterm with VT100 support, ANSI &lt;strong&gt;colors&lt;/strong&gt;; optionally transparency.&lt;br&gt; If &lt;strong&gt;bold&lt;/strong&gt; and &lt;strong&gt;bright&lt;/strong&gt; colors are not rendered then use the following terminal options:&lt;/p&gt; &#xA;&lt;h4&gt;Ubuntu Terminal&lt;/h4&gt; &#xA;&lt;p&gt;In the Preferences - Colors tab, select &lt;code&gt;Show bold text in bright colors&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;alacritty terminal&lt;/h4&gt; &#xA;&lt;p&gt;Uncomment and set &lt;code&gt;draw_bold_text_with_bright_colors: true&lt;/code&gt; in &lt;code&gt;&amp;lt;config-file&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Linux Kernel with a minimum version 3.3&lt;/li&gt; &#xA; &lt;li&gt;The GNU C Library&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Software needed:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GNU C Compiler with GNU extensions&lt;/li&gt; &#xA; &lt;li&gt;GNU Make tool&lt;/li&gt; &#xA; &lt;li&gt;Linux Kernel Header files to build modules &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Mandatory : &lt;code&gt;CONFIG_MODULES, CONFIG_SMP, CONFIG_X86_MSR&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Optionally: &lt;code&gt;CONFIG_HOTPLUG_CPU, CONFIG_CPU_IDLE, CONFIG_CPU_FREQ, CONFIG_PM_SLEEP, CONFIG_DMI, CONFIG_XEN, CONFIG_AMD_NB, CONFIG_SCHED_MUQSS, CONFIG_SCHED_BMQ, CONFIG_SCHED_PDS, CONFIG_SCHED_ALT, CONFIG_SCHED_BORE&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone the source code into a working directory.&lt;br&gt; &lt;code&gt;git clone https://github.com/cyring/CoreFreq.git&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the programs.&lt;br&gt; &lt;code&gt;cd CoreFreq&lt;/code&gt;&lt;br&gt; &lt;code&gt;make&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;cc -Wall -pthread -c corefreqd.c -o corefreqd.o&#xA;cc -Wall -c corefreqm.c -o corefreqm.o&#xA;cc corefreqd.c corefreqm.c -o corefreqd -lpthread -lm -lrt&#xA;cc -Wall -c corefreq-cli.c -o corefreq-cli.o&#xA;cc -Wall -c corefreq-ui.c -o corefreq-ui.o&#xA;cc corefreq-cli.c corefreq-ui.c -o corefreq-cli -lm -lrt&#xA;make -C /lib/modules/x.y.z/build M=/workdir/CoreFreq modules&#xA;make[1]: Entering directory &#39;/usr/lib/modules/x.y.z/build&#39;&#xA;  CC [M]  /workdir/CoreFreq/corefreqk.o&#xA;  Building modules, stage 2.&#xA;  MODPOST 1 modules&#xA;  CC      /workdir/CoreFreq/corefreqk.mod.o&#xA;  LD [M]  /workdir/CoreFreq/corefreqk.ko&#xA;make[1]: Leaving directory &#39;/usr/lib/modules/x.y.z/build&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;(Optionally) Sign the driver If module signature verification is enabled into Kernel, you will have to sign the &lt;code&gt;corefreqk.ko&lt;/code&gt; driver.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;See &lt;a href=&#34;https://github.com/torvalds/linux/raw/master/Documentation/admin-guide/module-signing.rst&#34;&gt;module-signing.rst&lt;/a&gt; from the Kernel documentation&lt;/li&gt; &#xA; &lt;li&gt;See the &lt;a href=&#34;https://wiki.gentoo.org/wiki/Signed_kernel_module_support#Manually_signing_modules&#34;&gt;Gentoo Wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;h4&gt;Manual&lt;/h4&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;Copying &lt;em&gt;CoreFreq&lt;/em&gt; into the binaries directory&lt;br&gt; &lt;code&gt;make install&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Distribution package&lt;/h4&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;Although &lt;em&gt;CoreFreq&lt;/em&gt; is released in the ArchLinux AUR ; other sources of distribution may require to reload the systemd daemons:&lt;br&gt; &lt;code&gt;systemctl daemon-reload&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Start&lt;/h3&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;When built from source code:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Load the kernel module, from current directory, as root.&lt;br&gt; &lt;code&gt;insmod corefreqk.ko&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Start the daemon, as root.&lt;br&gt; &lt;code&gt;corefreqd&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Start the client, as a user (&lt;em&gt;in another terminal or console&lt;/em&gt;).&lt;br&gt; &lt;code&gt;corefreq-cli&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;8&#34;&gt; &#xA; &lt;li&gt;When manually installed or from a distribution package:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Load the kernel module, as root.&lt;br&gt; &lt;code&gt;modprobe corefreqk&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Start the daemon, as root.&lt;br&gt; &lt;code&gt;systemctl start corefreqd&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Start the client, as a user.&lt;br&gt; &lt;code&gt;corefreq-cli&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Stop&lt;/h3&gt; &#xA;&lt;ol start=&#34;9&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Press &lt;kbd&gt;Ctrl+x&lt;/kbd&gt; or &lt;kbd&gt;Ctrl+c&lt;/kbd&gt; to stop the client.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Press &lt;kbd&gt;Ctrl+c&lt;/kbd&gt; to stop the daemon (in foreground) or kill its background job.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Unload the kernel module&lt;br&gt; &lt;code&gt;rmmod corefreqk.ko&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Try&lt;/h3&gt; &#xA;&lt;p&gt;Download the &lt;em&gt;CoreFreq&lt;/em&gt; Live CD from the &lt;a href=&#34;http://github.com/cyring/CoreFreq/wiki/Live-CD&#34;&gt;Wiki&lt;/a&gt;&lt;br&gt; &lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_LiveCD_Step1.png&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq for ArchLinux&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;h3&gt;Linux kernel module&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;lsmod&lt;/code&gt;, &lt;code&gt;dmesg&lt;/code&gt; or &lt;code&gt;journalctl -k&lt;/code&gt; to check if the module is started:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CoreFreq: Processor [06_1A] Architecture [Nehalem/Bloomfield] CPU [8/8]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Daemon&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;CoreFreq Daemon.  Copyright (C) 2015-2022 CYRIL COURTIAT&#xA;&#xA;  Processor [Intel(R) Core(TM) i7 CPU 920 @ 2.67GHz]&#xA;  Architecture [Nehalem/Bloomfield] 8/8 CPU Online.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Client&lt;/h3&gt; &#xA;&lt;p&gt;Without arguments, the corefreq-cli program displays Top Monitoring&lt;br&gt; &lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_Tour_2017-12-06.gif&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq UI&#34;&gt;&lt;br&gt; &lt;em&gt;Remark&lt;/em&gt;: Drawing will stall if the terminal width is lower than 80 columns, or its height is less than required.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;With the option &#39;-c&#39;, the client traces counters. &lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_Counters.gif&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq Counters&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Using option &#39;-m&#39; corefreq-cli shows the CPU topology &lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_Topology.png&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq CPU &amp;amp; caches topology&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;With the option &#39;-i&#39; corefreq-cli traces the number of instructions per second / cycle&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;CPU     IPS            IPC            CPI&#xA;#00     0.000579/s     0.059728/c    16.742698/i&#xA;#01     0.000334/s     0.150569/c     6.641471/i&#xA;#02     0.000598/s     0.161326/c     6.198641/i&#xA;#03     0.000294/s     0.233535/c     4.282013/i&#xA;#04     0.000240/s     0.042931/c    23.293141/i&#xA;#05     0.000284/s     0.158661/c     6.302765/i&#xA;#06     0.000128/s     0.128031/c     7.810631/i&#xA;#07     0.000088/s     0.150406/c     6.648674/i&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use the option &#39;-s&#39; to show the Processor information (BSP)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_SysInfo.png&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq System Info&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ArchLinux&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aur.archlinux.org/pkgbase/corefreq/&#34;&gt;&lt;img src=&#34;https://img.shields.io/aur/version/corefreq-dkms?style=flat-square&#34; alt=&#34;corefreq&#34;&gt;&lt;/a&gt; follows released tags&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aur.archlinux.org/pkgbase/corefreq-git/&#34;&gt;&lt;img src=&#34;https://img.shields.io/aur/version/corefreq-dkms-git?style=flat-square&#34; alt=&#34;corefreq-git&#34;&gt;&lt;/a&gt; follows &lt;code&gt;develop&lt;/code&gt; branch&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Debian, Ubuntu&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installing the DKMS package will pull the Kernel development packages&lt;br&gt; &lt;code&gt;apt-get install dkms&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Or, install selectively the development packages prerequisites.&lt;br&gt; &lt;code&gt;apt-get install libpthread-stubs0-dev&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Red Hat, CentOS&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Development packages prerequisites.&lt;br&gt; &lt;code&gt;yum install kernel-devel&lt;/code&gt;&lt;br&gt; &lt;code&gt;yum group install &#34;Development Tools&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;openSUSE&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://software.opensuse.org/package/CoreFreq&#34;&gt;CoreFreq&lt;/a&gt; official release&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://software.opensuse.org/package/CoreFreq-kmp-default&#34;&gt;CoreFreq-kmp-default&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Unraid&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Plugin&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;corefreq.plg&lt;/code&gt; from &lt;a href=&#34;https://github.com/ich777/unraid-corefreq&#34;&gt;ich777/unraid-corefreq&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Based on latest developments, please contact &lt;a href=&#34;https://github.com/ich777&#34;&gt;ich777&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Q&amp;amp;A&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: How many CPUs are supported by &lt;em&gt;CoreFreq&lt;/em&gt; ?&lt;/p&gt; &lt;p&gt;A: Up to 1024 CPUs can be built using the &lt;code&gt;make&lt;/code&gt; &lt;code&gt;CORE_COUNT&lt;/code&gt; option. 256 as a default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: Turbo Technology is activated however CPUs don&#39;t reach those frequencies ?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The CPU ratio does not go above its minimum value ?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The UI shows erratic counters values !&lt;/p&gt; &lt;p&gt;A: In the kernel boot command argument line, &lt;em&gt;disable the NMI Watchdog&lt;/em&gt;&lt;br&gt; &lt;code&gt;nmi_watchdog=0&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The Processor does not enter the C-States ?&lt;/p&gt; &lt;p&gt;A1: Check if at least one Idle driver is running.&lt;br&gt; Accordingly to the Processor specs, provide a max_cstate value in the kernel argument as below.&lt;br&gt; &lt;code&gt;intel_idle.max_cstate=value&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A2: &lt;em&gt;CoreFreq&lt;/em&gt; can also register itself as a cpuidle driver.&lt;br&gt; This time, any idle driver will have to be blacklisted in the kernel command line; such as:&lt;br&gt; &lt;code&gt;modprobe.blacklist=intel_cstate idle=halt intel_idle.max_cstate=0&lt;/code&gt;&lt;br&gt; Start the &lt;em&gt;CoreFreq&lt;/em&gt; driver with the &lt;code&gt;Register_CPU_Idle&lt;/code&gt; parameter:&lt;br&gt; &lt;code&gt;insmod corefreqk.ko Register_CPU_Idle=1&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The &lt;em&gt;CoreFreq&lt;/em&gt; UI refreshes itself slowly, with a delay after the actual CPUs usage ?&lt;/p&gt; &lt;p&gt;A: The sampling time to read the counters can be reduced or increased using a &lt;em&gt;CoreFreq&lt;/em&gt; module argument:&lt;br&gt; &lt;code&gt;insmod corefreqk.ko SleepInterval=value&lt;/code&gt;&lt;br&gt; where &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is supplied in milliseconds between a minimum of 100 ms and a maximum of 4500 ms. 1000 ms is the default value.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The base clock reports a wrong frequency value ?&lt;/p&gt; &lt;p&gt;A: &lt;em&gt;CoreFreq&lt;/em&gt; uses various algorithms to estimate the base clock.&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;The delta of two TimeStamp counters during a defined interval&lt;/li&gt; &#xA;   &lt;li&gt;The value provided in the Processor brand string divided by the maximum ratio (without Turbo)&lt;/li&gt; &#xA;   &lt;li&gt;A static value advertised by the manufacturer specs.&lt;/li&gt; &#xA;   &lt;li&gt;The MSR_FSB_FREQ bits provided with the Core, Core2 and Atom architectures.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;p&gt;The &lt;em&gt;CoreFreq&lt;/em&gt; module can be started as follow to ignore the first algorithm (frequency estimation):&lt;br&gt; &lt;code&gt;insmod corefreqk.ko AutoClock=0&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;Remark: algorithms # 2, 3 and 4 will not return any under/over-clock frequency.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The CPU temperature is wrong ?&lt;/p&gt; &lt;p&gt;A: &lt;em&gt;CoreFreq&lt;/em&gt; employs two MSR registers to calculate the temperature.&lt;br&gt; &lt;code&gt;MSR_IA32_TEMPERATURE_TARGET - MSR_IA32_THERM_STATUS [DTS]&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;Remark&lt;/em&gt;: if the MSR_IA32_TEMPERATURE_TARGET is not provided by the Processor, a default value of 100 degree Celsius is considered as a target.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The menu option &#34;Memory Controller&#34; does not open any window ?&lt;/p&gt; &lt;p&gt;A: Although Uncore and IMC features are under development, they can be activated with the Experimental driver argument:&lt;br&gt; &lt;code&gt;insmod corefreqk.ko Experimental=1&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The Instructions and PMC0 counters are stuck to zero ?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The Daemon crashes whenever its stress tools are executing !&lt;/p&gt; &lt;p&gt;A: The &lt;code&gt;PCE&lt;/code&gt; bit of control register &lt;code&gt;CR4&lt;/code&gt; allows RDPMC in ring &lt;code&gt;3&lt;/code&gt;&lt;br&gt; &lt;code&gt;echo &#34;2&#34; &amp;gt; /sys/devices/cpu/rdpmc&lt;/code&gt;&lt;br&gt; or using systemd, create file &lt;code&gt;/etc/tmpfiles.d/boot.conf&lt;/code&gt; and add line:&lt;br&gt; &lt;code&gt;w /sys/devices/cpu/rdpmc - - - - 2&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Next, load the driver with the &lt;code&gt;RDPMC_Enable&lt;/code&gt; argument to override the &lt;code&gt;CR4&lt;/code&gt; register:&lt;br&gt; &lt;code&gt;insmod corefreqk.ko RDPMC_Enable=1&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: How to solely control the P-States or the HWP Performance States ?&lt;/p&gt; &lt;p&gt;A1: Without the Kernel &lt;code&gt;cpufreq&lt;/code&gt; framework (aka &lt;code&gt;CONFIG_CPU_FREQ&lt;/code&gt;), &lt;em&gt;CoreFreq&lt;/em&gt; will take the full control over P-States.&lt;br&gt; This allow the User to select a &lt;em&gt;capped&lt;/em&gt; frequency from the UI, either per Core, either for the whole Processor.&lt;/p&gt; &lt;p&gt;A2: With &lt;code&gt;cpufreq&lt;/code&gt; built into Kernel, allow &lt;em&gt;CoreFreq&lt;/em&gt; to register as a cpufreq driver.&lt;br&gt; In the Kernel boot command line, two ways:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;disable &lt;code&gt;cpufreq&lt;/code&gt; with the Kernel &lt;a href=&#34;https://github.com/torvalds/linux/raw/master/Documentation/admin-guide/kernel-parameters.txt&#34;&gt;parameter&lt;/a&gt;&lt;br&gt; &lt;code&gt;cpufreq.off=1&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;blacklist any P-state driver; such as:&lt;br&gt; &lt;code&gt;modprobe.blacklist=acpi_cpufreq,pcc_cpufreq intel_pstate=disable&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;hardware CPPC (MSR registers)&lt;br&gt; &lt;code&gt;initcall_blacklist=amd_pstate_init&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;firmware CPPC (ACPI registers)&lt;br&gt; &lt;code&gt;amd_pstate.shared_mem=0&lt;/code&gt; and/or &lt;code&gt;initcall_blacklist=acpi_cpufreq_init&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;load the &lt;em&gt;CoreFreq&lt;/em&gt; driver with its &lt;code&gt;Register_CPU_Freq&lt;/code&gt; parameter:&lt;br&gt; &lt;code&gt;insmod corefreqk.ko Register_CPU_Freq=1&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: Governor is missing in Kernel window even after a successful registration.&lt;/p&gt; &lt;p&gt;A: When Registrations are done through the UI, they have to be done in the following order:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clock Source&lt;/li&gt; &#xA; &lt;li&gt;Governor driver&lt;/li&gt; &#xA; &lt;li&gt;CPU-FREQ driver&lt;/li&gt; &#xA; &lt;li&gt;CPU-IDLE driver&lt;/li&gt; &#xA; &lt;li&gt;CPU-IDLE route&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: The CPU freezes or the System crashes.&lt;/p&gt; &lt;p&gt;A1: Changing the &lt;code&gt;Max&lt;/code&gt; ratio frequency (aka P0 P-State) makes the Kernel TSC clock source unstable.&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Boot the Kernel with these command line parameters &lt;code&gt;notsc nowatchdog&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Optionally, build the &lt;em&gt;CoreFreq&lt;/em&gt; driver with its &lt;code&gt;udelay()&lt;/code&gt; TSC implementation&lt;br&gt; &lt;code&gt;make DELAY_TSC=1&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Allow &lt;em&gt;CoreFreq&lt;/em&gt; to register a new TSC clock source using driver arguments:&lt;br&gt; &lt;code&gt;insmod corefreqk.ko TurboBoost_Enable=0 Register_ClockSource=1&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Switch the current system clock source to &lt;code&gt;corefreq&lt;/code&gt;&lt;br&gt; &lt;code&gt;echo &#34;corefreq&#34; &amp;gt; /sys/devices/system/clocksource/clocksource0/current_clocksource&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;p&gt;A2: &lt;code&gt;[AMD][Zen]&lt;/code&gt; SMU:&lt;br&gt; &lt;em&gt;CoreFreq&lt;/em&gt; CPU monitoring loops are executed in an interrupt context where any blocking call like Mutex will freeze the kernel.&lt;br&gt; As a recommendation, &lt;strong&gt;make sure no other SMU driver is running&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;A3: This Processor is not or partially implemented in &lt;em&gt;CoreFreq&lt;/em&gt;.&lt;br&gt; Please open an issue in the &lt;a href=&#34;https://github.com/cyring/CoreFreq/wiki/CPU-support&#34;&gt;CPU support&lt;/a&gt; Wiki page.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: No voltage is showing up with Nehalem or Westmere processors ?&lt;/p&gt; &lt;p&gt;A: Build &lt;em&gt;CoreFreq&lt;/em&gt; as below if one of those chips is present:&lt;br&gt; &lt;code&gt;make HWM_CHIPSET=W83627&lt;/code&gt;&lt;br&gt; or&lt;br&gt; &lt;code&gt;make HWM_CHIPSET=IT8720&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: &lt;code&gt;[AMD][Zen]&lt;/code&gt; How to read the idle states ?&lt;/p&gt; &lt;p&gt;A: As a workarround to the missing documentation of the hardware counters, &lt;em&gt;CoreFreq&lt;/em&gt; implements virtual counters based on the TSC&lt;br&gt; Those VPMC are estimated each time the Kernel is entering an idle state level.&lt;br&gt; The prerequisities are:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Boot the Kernel without its idle drivers and no &lt;code&gt;TSC&lt;/code&gt; default clock source set&lt;br&gt; &lt;code&gt;modprobe.blacklist=acpi_cpufreq idle=halt tsc=unstable&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Build &lt;em&gt;CoreFreq&lt;/em&gt; with its &lt;code&gt;TSC&lt;/code&gt; implementation&lt;br&gt; &lt;code&gt;make DELAY_TSC=1&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Load and &lt;strong&gt;register&lt;/strong&gt; the &lt;em&gt;CoreFreq&lt;/em&gt; kernel module as the system handler&lt;br&gt; &lt;code&gt;insmod corefreqk.ko Register_ClockSource=1 Register_Governor=1 Register_CPU_Freq=1 Register_CPU_Idle=1 Idle_Route=1&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Define &lt;em&gt;CoreFreq&lt;/em&gt; as the System clock source&lt;br&gt; &lt;code&gt;echo &#34;corefreq&#34; &amp;gt; /sys/devices/system/clocksource/clocksource0/current_clocksource&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Start the Daemon then the Client&lt;br&gt; &lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_Zen_VPMC.png&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq for AMD Zen&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The registration is confirmed into the &lt;code&gt;Settings&lt;/code&gt; window&lt;/li&gt; &#xA;   &lt;li&gt;The idle limit can be changed at any time in the &lt;code&gt;Kernel&lt;/code&gt; window&lt;br&gt; &lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq_Idle_Limit.png&#34; alt=&#34;alt text&#34; title=&#34;Idle Limit&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: How does &lt;em&gt;CoreFreq&lt;/em&gt; work with &lt;code&gt;cgroups&lt;/code&gt; ?&lt;/p&gt; &lt;p&gt;A: The Daemon and the Client have to run in the &lt;code&gt;root cgroups cpugroup&lt;/code&gt;, by using these commands:&lt;br&gt; ( &lt;em&gt;thanks to Conne Beest @connebeest&lt;/em&gt; )&lt;br&gt; &lt;code&gt;cgexec -g cpuset:/ ./corefreqd&lt;/code&gt;&lt;br&gt; &lt;code&gt;cgexec -g cpuset:/ ./cofrefreq-cli&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: How to enable transparency in the User Interface ?&lt;/p&gt; &lt;p&gt;A: Transparency is a build option invoked by the compilation directive &lt;code&gt;UI_TRANSPARENCY&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Build the project with &lt;code&gt;UI_TRANSPARENCY&lt;/code&gt; enabled&lt;br&gt; &lt;code&gt;make UI_TRANSPARENCY=1&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Start the Client with one of its transparency compatible colors theme&lt;br&gt; &lt;code&gt;corefreq-cli -OE 2 -t&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Or switch to that theme from &lt;code&gt;Menu &amp;gt; Theme&lt;/code&gt;, shortcut [&lt;code&gt;E&lt;/code&gt;]&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: How to screenshot the UI ?&lt;/p&gt; &lt;p&gt;A: Press &lt;code&gt;[Ctrl]+[p]&lt;/code&gt; to save the screen to a rich ascii file. Use the &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;less -R&lt;/code&gt; command to view the file saved with an &lt;code&gt;asc&lt;/code&gt; extension.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: How to record the UI ?&lt;/p&gt; &lt;p&gt;A: Press &lt;code&gt;[Alt]+[p]&lt;/code&gt; to record the screen for the duration set in Settings. A compatible &lt;a href=&#34;https://github.com/asciinema/asciinema&#34;&gt;asciinema&lt;/a&gt; file is saved in the current directory with a &lt;code&gt;cast&lt;/code&gt; extension.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: What are the build options for &lt;em&gt;CoreFreq&lt;/em&gt; ?&lt;/p&gt; &lt;p&gt;A: Enter &lt;code&gt;make help&lt;/code&gt; to display them:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;o---------------------------------------------------------------o&#xA;|  make [all] [clean] [info] [help] [install] [module-install]  |&#xA;|                                                               |&#xA;|  CC=&amp;lt;COMPILER&amp;gt;                                                |&#xA;|    where &amp;lt;COMPILER&amp;gt; is cc, gcc, clang                         |&#xA;|                                                               |&#xA;|  WARNING=&amp;lt;ARG&amp;gt;                                                |&#xA;|    where default argument is -Wall                            |&#xA;|                                                               |&#xA;|  KERNELDIR=&amp;lt;PATH&amp;gt;                                             |&#xA;|    where &amp;lt;PATH&amp;gt; is the Kernel source directory                |&#xA;|                                                               |&#xA;|  CORE_COUNT=&amp;lt;N&amp;gt;                                               |&#xA;|    where &amp;lt;N&amp;gt; is 64, 128, 256, 512 or 1024 builtin CPU         |&#xA;|                                                               |&#xA;|  LEGACY=&amp;lt;L&amp;gt;                                                   |&#xA;|    where level &amp;lt;L&amp;gt;                                            |&#xA;|    1: assembly level restriction such as CMPXCHG16            |&#xA;|                                                               |&#xA;|  UBENCH=&amp;lt;N&amp;gt;                                                   |&#xA;|    where &amp;lt;N&amp;gt; is 0 to disable or 1 to enable micro-benchmark   |&#xA;|                                                               |&#xA;|  TASK_ORDER=&amp;lt;N&amp;gt;                                               |&#xA;|    where &amp;lt;N&amp;gt; is the memory page unit of kernel allocation     |&#xA;|                                                               |&#xA;|  FEAT_DBG=&amp;lt;N&amp;gt;                                                 |&#xA;|    where &amp;lt;N&amp;gt; is 0 or N for FEATURE DEBUG level                |&#xA;|    3: XMM assembly in RING operations                         |&#xA;|                                                               |&#xA;|  DELAY_TSC=&amp;lt;N&amp;gt;                                                |&#xA;|    where &amp;lt;N&amp;gt; is 1 to build a TSC implementation of udelay()   |&#xA;|                                                               |&#xA;|  OPTIM_LVL=&amp;lt;N&amp;gt;                                                |&#xA;|    where &amp;lt;N&amp;gt; is 0, 1, 2 or 3 of the OPTIMIZATION level        |&#xA;|                                                               |&#xA;|  MAX_FREQ_HZ=&amp;lt;freq&amp;gt;                                           |&#xA;|    where &amp;lt;freq&amp;gt; is at least 4850000000 Hz                     |&#xA;|                                                               |&#xA;|  HWM_CHIPSET=&amp;lt;chipset&amp;gt;                                        |&#xA;|    where &amp;lt;chipset&amp;gt; is W83627 or IT8720 or COMPATIBLE          |&#xA;|                                                               |&#xA;|  Performance Counters:                                        |&#xA;|    -------------------------------------------------------    |&#xA;|   |     MSR_CORE_PERF_UCC     |     MSR_CORE_PERF_URC     |   |&#xA;|   |----------- REG -----------|----------- REG -----------|   |&#xA;|   | MSR_IA32_APERF            |  MSR_IA32_MPERF           |   |&#xA;|   | MSR_CORE_PERF_FIXED_CTR1  |  MSR_CORE_PERF_FIXED_CTR2 |   |&#xA;|   | MSR_PPERF                 |  MSR_PPERF                |   |&#xA;|   | MSR_AMD_F17H_APERF        |  MSR_AMD_F17H_MPERF       |   |&#xA;|    -------------------------------------------------------    |&#xA;|                                                               |&#xA;|  Architectural Counters:                                      |&#xA;|    -------------------------------------------------------    |&#xA;|   |           Intel           |            AMD            |   |&#xA;|   |----------- REG -----------|----------- REG -----------|   |&#xA;|   |       ARCH_PMC=PCU        |      ARCH_PMC=L3          |   |&#xA;|   |                           |      ARCH_PMC=PERF        |   |&#xA;|   |                           |      ARCH_PMC=UMC         |   |&#xA;|    -------------------------------------------------------    |&#xA;|                                                               |&#xA;|  User Interface Layout:                                       |&#xA;|    NO_HEADER=&amp;lt;F&amp;gt;  NO_FOOTER=&amp;lt;F&amp;gt;  NO_UPPER=&amp;lt;F&amp;gt;  NO_LOWER=&amp;lt;F&amp;gt;   |&#xA;|      when &amp;lt;F&amp;gt; is 1: don&#39;t build and display this area part    |&#xA;|    UI_TRANSPARENCY=&amp;lt;F&amp;gt;                                        |&#xA;|      when &amp;lt;F&amp;gt; is 1: build with background transparency        |&#xA;|                                                               |&#xA;|  Example:                                                     |&#xA;|    make CC=gcc OPTIM_LVL=3 FEAT_DBG=1 ARCH_PMC=PCU            |&#xA;|         MSR_CORE_PERF_UCC=MSR_CORE_PERF_FIXED_CTR1            |&#xA;|         MSR_CORE_PERF_URC=MSR_CORE_PERF_FIXED_CTR2            |&#xA;|         HWM_CHIPSET=W83627 MAX_FREQ_HZ=5350000000             |&#xA;|         CORE_COUNT=1024 NO_FOOTER=1 NO_UPPER=1                |&#xA;|         clean all                                             |&#xA;o---------------------------------------------------------------o&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Q: What are the parameters of the &lt;em&gt;CoreFreq&lt;/em&gt; driver ?&lt;/p&gt; &lt;p&gt;A: Use the &lt;code&gt;modinfo&lt;/code&gt; command to list them:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ modinfo corefreqk.ko&#xA;parm:           ArchID:Force an architecture (ID) (int)&#xA;parm:           AutoClock:Estimate Clock Frequency 0:Spec; 1:Once; 2:Auto (int)&#xA;parm:           SleepInterval:Timer interval (ms) (uint)&#xA;parm:           TickInterval:System requested interval (ms) (uint)&#xA;parm:           Experimental:Enable features under development (int)&#xA;parm:           CPU_Count&lt;span&gt;👎&lt;/span&gt;Kernel(default); 0:Hardware; &amp;gt;0: User value (int)&#xA;parm:           Target_Ratio_Unlock:1:Target Ratio Unlock; 0:Lock (short)&#xA;parm:           Clock_Ratio_Unlock:1:MinRatio; 2:MaxRatio; 3:Both Unlock (short)&#xA;parm:           Turbo_Ratio_Unlock:1:Turbo Ratio Unlock; 0:Lock (short)&#xA;parm:           Uncore_Ratio_Unlock:1:Uncore Ratio Unlock; 0:Lock (short)&#xA;parm:           ServiceProcessor:Select a CPU to run services with (int)&#xA;parm:           RDPMC_Enable:Enable RDPMC bit in CR4 register (ushort)&#xA;parm:           NMI_Disable:Disable the NMI Handler (ushort)&#xA;parm:           Override_SubCstate:Override Sub C-States (array of ushort)&#xA;parm:           PkgCStateLimit:Package C-State Limit (short)&#xA;parm:           IOMWAIT_Enable:I/O MWAIT Redirection Enable (short)&#xA;parm:           CStateIORedir:Power Mgmt IO Redirection C-State (short)&#xA;parm:           Config_TDP_Level:Config TDP Control Level (short)&#xA;parm:           Custom_TDP_Offset:TDP Limit Offset (watt) (array of short)&#xA;parm:           Activate_TDP_Limit:Activate TDP Limiting (array of short)&#xA;parm:           Activate_TDP_Clamp:Activate TDP Clamping (array of short)&#xA;parm:           Custom_TDC_Offset:TDC Limit Offset (amp) (short)&#xA;parm:           Activate_TDC_Limit:Activate TDC Limiting (short)&#xA;parm:           L1_HW_PREFETCH_Disable:Disable L1 HW Prefetcher (short)&#xA;parm:           L1_HW_IP_PREFETCH_Disable:Disable L1 HW IP Prefetcher (short)&#xA;parm:           L2_HW_PREFETCH_Disable:Disable L2 HW Prefetcher (short)&#xA;parm:           L2_HW_CL_PREFETCH_Disable:Disable L2 HW CL Prefetcher (short)&#xA;parm:           SpeedStep_Enable:Enable SpeedStep (short)&#xA;parm:           C1E_Enable:Enable SpeedStep C1E (short)&#xA;parm:           TurboBoost_Enable:Enable Turbo Boost (array of short)&#xA;parm:           C3A_Enable:Enable C3 Auto Demotion (short)&#xA;parm:           C1A_Enable:Enable C3 Auto Demotion (short)&#xA;parm:           C3U_Enable:Enable C3 UnDemotion (short)&#xA;parm:           C1U_Enable:Enable C1 UnDemotion (short)&#xA;parm:           CC6_Enable:Enable Core C6 State (short)&#xA;parm:           PC6_Enable:Enable Package C6 State (short)&#xA;parm:           ODCM_Enable:Enable On-Demand Clock Modulation (short)&#xA;parm:           ODCM_DutyCycle:ODCM DutyCycle [0-7] | [0-14] (short)&#xA;parm:           PowerMGMT_Unlock:Unlock Power Management (short)&#xA;parm:           PowerPolicy:Power Policy Preference [0-15] (short)&#xA;parm:           Turbo_Activation_Ratio:Turbo Activation Ratio (short)&#xA;parm:           PState_FID:P-State Frequency Id (int)&#xA;parm:           PState_VID:P-State Voltage Id (int)&#xA;parm:           Ratio_Boost:Turbo Boost Frequency ratios (array of int)&#xA;parm:           Ratio_PPC:Target Performance ratio (int)&#xA;parm:           HWP_Enable:Hardware-Controlled Performance States (short)&#xA;parm:           HWP_EPP:Energy Performance Preference (short)&#xA;parm:           Ratio_HWP:Hardware-Controlled Performance ratios (array of int)&#xA;parm:           HDC_Enable:Hardware Duty Cycling (short)&#xA;parm:           EEO_Disable:Disable Energy Efficiency Optimization (short)&#xA;parm:           R2H_Disable:Disable Race to Halt (short)&#xA;parm:           Clear_Events:Clear Thermal and Power Events (ullong)&#xA;parm:           ThermalOffset:Thermal Offset (short)&#xA;parm:           ThermalScope:[0:None; 1:SMT; 2:Core; 3:Package] (int)&#xA;parm:           VoltageScope:[0:None; 1:SMT; 2:Core; 3:Package] (int)&#xA;parm:           PowerScope:[0:None; 1:SMT; 2:Core; 3:Package] (int)&#xA;parm:           Register_CPU_Idle:Register the Kernel cpuidle driver (short)&#xA;parm:           Register_CPU_Freq:Register the Kernel cpufreq driver (short)&#xA;parm:           Register_Governor:Register the Kernel governor (short)&#xA;parm:           Register_ClockSource:Register Clock Source driver (short)&#xA;parm:           Idle_Route:[0:Default; 1:I/O; 2:HALT; 3:MWAIT] (short)&#xA;parm:           Mech_IBRS:Mitigation Mechanism IBRS (short)&#xA;parm:           Mech_STIBP:Mitigation Mechanism STIBP (short)&#xA;parm:           Mech_SSBD:Mitigation Mechanism SSBD (short)&#xA;parm:           Mech_IBPB:Mitigation Mechanism IBPB (short)&#xA;parm:           Mech_L1D_FLUSH:Mitigation Mechanism Cache L1D Flush (short)&#xA;parm:           Mech_PSFD:Mitigation Mechanism PSFD (short)&#xA;parm:           Mech_BTC_NOBR:Mitigation Mechanism BTC-NOBR (short)&#xA;parm:           WDT_Enable:Watchdog Hardware Timer (short)&#xA;parm:           HSMP_Attempt:Attempt the HSMP interface (short)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Algorithm&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://blog.cyring.free.fr/images/CoreFreq-algorithm.png&#34; alt=&#34;alt text&#34; title=&#34;CoreFreq algorithm&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cyring&#34;&gt;CyrIng&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Copyright (C) 2015-2022 CYRIL COURTIAT&lt;/h2&gt;</summary>
  </entry>
</feed>