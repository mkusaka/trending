<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-12T01:31:32Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>s0duku/cve-2022-31705</title>
    <updated>2023-01-12T01:31:32Z</updated>
    <id>tag:github.com,2023-01-12:/s0duku/cve-2022-31705</id>
    <link href="https://github.com/s0duku/cve-2022-31705" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CVE-2022-31705 (Geekpwn 2022 Vmware EHCI OOB) POC&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CVE-2022-31705&lt;/h1&gt; &#xA;&lt;h2&gt;Intro&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.vmware.com/content/vmware/vmware-published-sites/us/security/advisories/VMSA-2022-0033.html.html&#34;&gt;https://www.vmware.com/content/vmware/vmware-published-sites/us/security/advisories/VMSA-2022-0033.html.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Test on windows vmware workstation 16.2.0, with guest os ubuntu server 22&lt;/li&gt; &#xA; &lt;li&gt;At leat one usb device is be attached to guest machine&lt;/li&gt; &#xA; &lt;li&gt;change the &#39;qh-&amp;gt;field4&#39; in the ehci.c code&lt;/li&gt; &#xA; &lt;li&gt;Type &#39;sudo ./run.sh&#39; to compile and run the poc&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use &#39;lsusb&#39; to determine the device id, use the device id to set &#39;qh-&amp;gt;field4&#39;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/13d5dfa5-3376-414e-a89c-819e3b80f0a8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230109%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20230109T074847Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=6140baba04353256cc66500949d17dbf012347e68323574de2670dcfd4682651&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;vmx code will alloc a struct with 0x18 size (the size can be controlled in the code) buffer for reading guest physical memory.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a4486050-9bf2-45da-944d-110847734526/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230109%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20230109T075113Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=bd9b4126e49b1a5d6f8bdb9e703ae96c471f996843245ab28369503c1f7aefd3&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the total size of this struct will be 0x400&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ce3a8ebf-95e8-4918-8e3f-d6690f8561c3/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230109%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20230109T075336Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=59e25c5fdce1e2bc74d8847f2f6a0001faa185f550c96ac06a38d8d2d3c4e6a8&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;address of this struct is 0x26d6caa80d0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a8e6ff74-a8e9-480e-b1fe-6e3681b1697b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230109%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20230109T075523Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=b8509cadf8a3eb9c95855c10a30a94bd53b162c17ec8453fe0624a189671f6a5&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;in the end, vmx will read 0x800 size (can be controlled in the code) of physical memory into 0x2606CAA84C0, which is the last 0x10 byte of 0x26d6caa80d0 (first 0x8 is already readed at the alloc stage)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2ba45b77-d246-48df-b877-97bfb780d78e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230109%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20230109T075805Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=90107fb78f934b9082f520b10b4fd96df27595ca126a21bffbb09b21c8114e75&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;for sure, it will cause a OOB write.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2211aea8-5026-425d-bad0-5a263f6705c8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230109%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20230109T080241Z&amp;amp;X-Amz-Expires=86400&amp;amp;X-Amz-Signature=e2e9d67d5dc4ee3b45e64ea70253345d9098753f37f5c3cd71ce16487aeb44c8&amp;amp;X-Amz-SignedHeaders=host&amp;amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;amp;x-id=GetObject&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vvaltchev/tilck</title>
    <updated>2023-01-12T01:31:32Z</updated>
    <id>tag:github.com,2023-01-12:/vvaltchev/tilck</id>
    <link href="https://github.com/vvaltchev/tilck" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Tiny Linux-Compatible Kernel&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;http://vvaltchev.github.io/tilck_imgs/v2/tilck-logo-v5.png&#34; alt=&#34;Tilck - A Tiny Linux-Compatible Kernel&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://vkvaltchev.visualstudio.com/Tilck/_build/latest?definitionId=1&amp;amp;branchName=master&#34;&gt;&lt;img src=&#34;https://vkvaltchev.visualstudio.com/Tilck/_apis/build/status/Tilck?branchName=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/vvaltchev/tilck&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/vvaltchev/tilck/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/BSD-2-Clause&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-BSD%202--Clause-orange.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;a href=&#34;https://youtu.be/Ce1pMlZO_mI&#34;&gt; &lt;img align=&#34;right&#34; src=&#34;http://vvaltchev.github.io/tilck_imgs/v2/main2-smaller-70p-yt.png&#34; alt=&#34;Tilck&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#overview&#34;&gt;Overview&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#what-is-tilck&#34;&gt;What is Tilck?&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#future-plans&#34;&gt;Future plans&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#what-tilck-is-not-&#34;&gt;What Tilck is NOT ?&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#tilck-vs-linux&#34;&gt;Tilck vs Linux&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#features&#34;&gt;Features&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#hardware-support&#34;&gt;Hardware support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#file-systems&#34;&gt;File systems&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#processes-and-signals&#34;&gt;Processes and signals&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#io&#34;&gt;I/O&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#console&#34;&gt;Console&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#userspace-applications&#34;&gt;Userspace applications&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#screenshots&#34;&gt;Screenshots&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#booting-tilck&#34;&gt;Booting Tilck&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#tilcks-bootloader&#34;&gt;Tilck&#39;s bootloader&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#3rd-party-bootloaders&#34;&gt;3rd-party bootloaders&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#grub-support&#34;&gt;Grub support&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#documentation-and-howtos&#34;&gt;Documentation and HOWTOs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#building-tilck&#34;&gt;Building Tilck&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#testing-tilck&#34;&gt;Testing Tilck&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#debugging-tilck&#34;&gt;Debugging Tilck&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#tilcks-debug-panel&#34;&gt;Tilck&#39;s debug panel&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#contributing-to-tilck&#34;&gt;Contributing to Tilck&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#a-comment-about-user-experience&#34;&gt;A comment about user experience&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;http://vvaltchev.github.io/tilck_imgs/v2/overview.png&#34; border=&#34;0&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;What is Tilck?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Tilck&lt;/code&gt; is an educational &lt;em&gt;monolithic&lt;/em&gt; x86 kernel designed to be Linux-compatible at binary level. Project&#39;s small-scale and simple design makes it the &lt;strong&gt;perfect playground&lt;/strong&gt; for playing in kernel mode while retaining the ability to compare how the &lt;em&gt;very same&lt;/em&gt; &lt;em&gt;usermode bits&lt;/em&gt; run on the Linux kernel as well. That&#39;s a &lt;strong&gt;rare feature&lt;/strong&gt; in the realm of educational kernels. Because of that, building a program for Tilck requires just a &lt;code&gt;i686-musl&lt;/code&gt; toolchain from &lt;a href=&#34;https://toolchains.bootlin.com&#34;&gt;bootlin.com&lt;/a&gt;. Tilck has &lt;strong&gt;no need&lt;/strong&gt; to have its own set of custom written applications, like most educational kernels do. It just runs mainstream Linux programs like the &lt;strong&gt;BusyBox&lt;/strong&gt; suite. While the Linux-compatibility and the monolithic design might seem a limitation from the OS research point of view, on the other side, such design bring the whole project much closer to &lt;em&gt;real-world&lt;/em&gt; applications in the future, compared to the case where some serious (or huge) effort is required to port pre-existing software on it. Also, nothing stops Tilck from implementing custom non-Linux syscalls that aware apps might take advantage of.&lt;/p&gt; &#xA;&lt;h4&gt;Future plans&lt;/h4&gt; &#xA;&lt;p&gt;In the long term, depending on how successful the project will be, &lt;code&gt;Tilck&lt;/code&gt; might become suitable for &lt;strong&gt;embedded systems&lt;/strong&gt; on which a fully deterministic and ultra low-latency system is required. With a fair amount of luck, &lt;code&gt;Tilck&lt;/code&gt; might be able to fill the gap between &lt;em&gt;Embedded Linux&lt;/em&gt; and typical real-time operating systems like &lt;em&gt;FreeRTOS&lt;/em&gt; or &lt;em&gt;Zephyr&lt;/em&gt;. In any case, at some point it will be ported to the &lt;code&gt;ARM&lt;/code&gt; family and it might be adapted to run on MMU-less CPUs as well. Tilck would be a perfect fit for that because consuming a tiny amount of RAM has always been a key point in Tilck&#39;s design. Indeed, the kernel can boot and run on a i686 QEMU machine with just 3 MB of memory &lt;em&gt;today&lt;/em&gt;. Of course, that&#39;s pointless on x86, but on an ARM Cortex-R that won&#39;t be anymore the case.&lt;/p&gt; &#xA;&lt;p&gt;In addition to that, adding a basic support for networking and storage is part of the plans even if details have not been defined yet. Networking support might be limited to UDP + IP (at least at the beginning) and usable on a limited set of network cards. The same applies for storage: not all kinds of block devices will be supported, and a few filesystems (maybe just fat32 and ext2) will implemented in the kernel. The support for FUSE filesystems will be considered.&lt;/p&gt; &#xA;&lt;p&gt;One major milestone for the project will be to support both networking and storage for a specific SoC like Raspberry Pi 3 (or 4) but that could possibly happen only after Tilck has been ported to ARM64.&lt;/p&gt; &#xA;&lt;h3&gt;What Tilck is NOT ?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;An attempt to re-write and/or replace the Linux kernel. Tilck is a completely different kernel that has a &lt;em&gt;partial&lt;/em&gt; compatibility with Linux just in order to take advantage of its programs and toolchains. Also, that helps a lot to validate its correctness: if a program works correctly on Linux, it must work the same way on Tilck as well (minus not-implemented features). &lt;strong&gt;But&lt;/strong&gt;, having a fair amount of Linux programs working on it, is just a &lt;em&gt;starting point&lt;/em&gt;: with time, Tilck will evolve in a different way and it will have its own unique set of features as well.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A kernel suitable for a &lt;em&gt;desktop&lt;/em&gt; operating system. No X server works on Tilck, not only because a considerable amount of extra features will be required for that, but because working in that direction is &lt;em&gt;completely outside&lt;/em&gt; of project&#39;s goals. See also: &lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/81&#34;&gt;https://github.com/vvaltchev/tilck/discussions/81&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Tilck vs Linux&lt;/h4&gt; &#xA;&lt;p&gt;Tilck is fundamentally different from Linux as it &lt;strong&gt;does not&lt;/strong&gt; aim to target multi-user server nor desktop machines, at all because that would be pointless: Linux is &lt;strong&gt;not&lt;/strong&gt; big &amp;amp; complex because of a &lt;em&gt;poor&lt;/em&gt; implementation, but because of the incredible amount of features it offers and the &lt;em&gt;intrinsic&lt;/em&gt; complexity they require. In other words, &lt;strong&gt;Linux is great&lt;/strong&gt; given the problem it solves. Tilck will offer &lt;em&gt;fewer&lt;/em&gt; features in exchange for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;simpler code (by far)&lt;/li&gt; &#xA; &lt;li&gt;smaller binary size&lt;/li&gt; &#xA; &lt;li&gt;extremely deterministic behavior&lt;/li&gt; &#xA; &lt;li&gt;ultra low-latency&lt;/li&gt; &#xA; &lt;li&gt;easier development &amp;amp; testing&lt;/li&gt; &#xA; &lt;li&gt;extra robustness&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In conclusion, while this is still an &lt;em&gt;educational&lt;/em&gt; project at the moment, it has been written keeping in mind those goals and it has a test infrastructure that ambitiously tries to be almost &lt;em&gt;enterprise-level&lt;/em&gt; (see &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/#testing-tilck&#34;&gt;Testing&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Tilck is a preemptable monolithic (but with compile-time modules) *NIX kernel, implementing about ~100 Linux syscalls (both via &lt;code&gt;int 0x80&lt;/code&gt; and &lt;code&gt;sysenter&lt;/code&gt;) on x86. At its core, the kernel is not x86-centric even if it runs only on x86 at the moment. Everything arch-specific is isolated. Because of that, most of kernel&#39;s code can be already compiled for any architecture and can be used in kernel&#39;s unit tests.&lt;/p&gt; &#xA;&lt;h4&gt;Hardware support&lt;/h4&gt; &#xA;&lt;p&gt;While the kernel uses a fair amount of &lt;strong&gt;legacy hardware&lt;/strong&gt; like the 8259 PICs for IRQs, the legacy 8254 PIT for the system timer, the legacy 16550 UART for serial communication, the 8042 kb controller, the 8237 ISA DMA, and the Sound Blaster 16 sound card (QEMU only), it has also support for some &lt;strong&gt;recent hardware&lt;/strong&gt; features like SSE, AVX and AVX2 fpu instructions, PAT, i686 sysenter, enumeration of PCI Express devices (via ECAM) and, above all, &lt;strong&gt;ACPI&lt;/strong&gt; support via ACPICA. ACPI is currently used to receive power-button events, to reboot or power-off the machine, and to read the current parameters of machine&#39;s batteries (when implemented via ACPI control methods).&lt;/p&gt; &#xA;&lt;h5&gt;Comments about physical hardware&lt;/h5&gt; &#xA;&lt;p&gt;The operating system has been regularly tested on physical hardware from its inception by booting it with an USB stick (see the notes below). Test machines include actual i686 machines, older x86_64 machines with BIOS-only firmware, newer x86_64 machines with UEFI+CSM and finally super-recent pure-UEFI machines. For a long time, Tilck&#39;s development strictly complied with the following rule: &lt;em&gt;if you cannot test it on real hardware, do not implement it in Tilck&lt;/em&gt;. Only recently, that rule has been relaxed a little in order to play with SB16. It is possible that, in the future, there might be a few other drivers that would be tested only on virtual machines: their development is justified by the educational value it will bring to the operating system and the infrastructure built for them will be reused for other drivers of the same kind. &lt;strong&gt;But&lt;/strong&gt; that will &lt;em&gt;never&lt;/em&gt; become a common practice. Tilck is designed to work on real hardware, where any kind of weird things happen. Being reliable there is &lt;em&gt;critical&lt;/em&gt; for Tilck&#39;s success.&lt;/p&gt; &#xA;&lt;h4&gt;File systems&lt;/h4&gt; &#xA;&lt;p&gt;Tilck has a simple but full-featured (both soft and hard links, file holes, memory mapping, etc.) &lt;strong&gt;ramfs&lt;/strong&gt; implementation, a minimalistic &lt;strong&gt;devfs&lt;/strong&gt; implementation, read-only support for FAT16 and &lt;strong&gt;FAT32&lt;/strong&gt; (used for initrd) allowing memory-mapping of files, and a &lt;strong&gt;sysfs&lt;/strong&gt; implementation used to provide a full view of &lt;strong&gt;ACPI&#39;s&lt;/strong&gt; &lt;strong&gt;namespace&lt;/strong&gt;, the list of all PCI(e) devices and Tilck&#39;s compile-time configuration. Clearly, in order to work with multiple file systems at once, Tilck has a simple &lt;strong&gt;VFS&lt;/strong&gt; implementation as well. &lt;strong&gt;Note&lt;/strong&gt;: there is no support for block devices in Tilck yet, so everything is in-memory.&lt;/p&gt; &#xA;&lt;h4&gt;Processes and signals&lt;/h4&gt; &#xA;&lt;p&gt;While Tilck uses internally the concept of thread, multi-threading is not currently exposed to userspace (kernel threads exist, of course). Both &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;vfork()&lt;/code&gt; are properly implemented and copy-on-write is used for fork-ed processes. The &lt;code&gt;waitpid()&lt;/code&gt; syscall is fully implemented (which implies process groups etc.). The support for POSIX signals is partial: custom signal handlers are supported using the &lt;code&gt;rt_sigaction()&lt;/code&gt; interface, but most of the SA_* flags are not supported and handlers cannot interrupt each other, yet. &lt;code&gt;rt_sigprocmask()&lt;/code&gt;, &lt;code&gt;sys_rt_sigpending()&lt;/code&gt;, &lt;code&gt;sys_rt_sigsuspend()&lt;/code&gt; work as expected, as well as special signals like SIGSTOP, SIGCONT and SIGCHLD. For more details, see the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/syscalls.md&#34;&gt;syscalls&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;p&gt;One interesting feature in this area deserves a special mention: despite the lack of multi-threading in userspace, Tilck has full support for TLS (thread-local storage) via &lt;code&gt;set_thread_area()&lt;/code&gt;, because &lt;code&gt;libmusl&lt;/code&gt; requires it, even for classic single-threaded processes.&lt;/p&gt; &#xA;&lt;h4&gt;I/O&lt;/h4&gt; &#xA;&lt;p&gt;In addition to the classic &lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; syscalls, Tilck supports vectored I/O via &lt;code&gt;readv()&lt;/code&gt; and &lt;code&gt;writev()&lt;/code&gt; as well. In addition to that, non blocking I/O, &lt;code&gt;select()&lt;/code&gt; and &lt;code&gt;poll()&lt;/code&gt; are supported too. Fortunately, no program so far needed &lt;code&gt;epoll&lt;/code&gt; :-)&lt;/p&gt; &#xA;&lt;h4&gt;Console&lt;/h4&gt; &#xA;&lt;p&gt;Tilck has a console supporting more than 90% of Linux&#39;s console&#39;s features. It works in the same way (using layers of abstraction) both in text mode and in framebuffer mode. The effort to implement such a powerful console was driven by the goal to make &lt;strong&gt;Vim&lt;/strong&gt; work smoothly on Tilck, with syntax highlighting etc. While it&#39;s true that such a thing has a little to do with &#34;proper&#34; kernel development, being able to run a &#34;beast&#34; like Vim on a simple kernel like Tilck, is a great achievement by itself because it shows that Tilck can run correctly programs having a fair amount of complexity.&lt;/p&gt; &#xA;&lt;h4&gt;Userspace applications&lt;/h4&gt; &#xA;&lt;p&gt;Tilck can run a fair amount of console applications like the &lt;strong&gt;BusyBox&lt;/strong&gt; suite, &lt;strong&gt;Vim&lt;/strong&gt;, &lt;strong&gt;TinyCC&lt;/strong&gt;, &lt;strong&gt;Micropython&lt;/strong&gt;, &lt;strong&gt;Lua&lt;/strong&gt;, and framebuffer applications like a port of DOOM for the Linux console called &lt;strong&gt;fbDOOM&lt;/strong&gt;. Check project&#39;s &lt;a href=&#34;https://github.com/vvaltchev/tilck/wiki&#34;&gt;wiki page&lt;/a&gt; for more info about that.&lt;/p&gt; &#xA;&lt;h4&gt;Screenshots&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://vvaltchev.github.io/tilck_imgs/v2/thumbnails.png&#34; alt=&#34;Tilck screenshots&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For full-size screenshots and much more stuff, check Tilck&#39;s &lt;a href=&#34;https://github.com/vvaltchev/tilck/wiki&#34;&gt;wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Booting Tilck&lt;/h2&gt; &#xA;&lt;h3&gt;Tilck&#39;s bootloader&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Tilck&lt;/code&gt; comes with an interactive bootloader working both on legacy BIOS and on UEFI systems as well. The bootloader allows the user to choose the desired video mode, the kernel file itself and to edit kernel&#39;s cmdline.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://vvaltchev.github.io/tilck_imgs/v2/bootloader.png&#34; alt=&#34;Tilck&#39;s bootloader&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;3rd-party bootloaders&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Tilck&lt;/code&gt; can be loaded by any bootloader supporting &lt;code&gt;multiboot 1.0&lt;/code&gt;. For example, qemu&#39;s built-in bootloader works perfectly with &lt;code&gt;Tilck&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;qemu-system-i386 -kernel ./build/tilck -initrd ./build/fatpart&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Actually that way of booting the kernel is used in the system tests. A shortcut for it is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./build/run_multiboot_qemu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Grub support&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Tilck&lt;/code&gt; can be easily booted with GRUB. Just edit your &lt;code&gt;/etc/grub.d/40_custom&lt;/code&gt; file (or create another one) by adding an entry like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;menuentry &#34;Tilck&#34; {&#xA;    multiboot &amp;lt;PATH-TO-TILCK-BUILD-DIR&amp;gt;/tilck&#xA;    module --nounzip &amp;lt;PATH-TO-TILCK-BUILD-DIR&amp;gt;/fatpart&#xA;    boot&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that, just run &lt;code&gt;update-grub&lt;/code&gt; as root and reboot your machine.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation and HOWTOs&lt;/h2&gt; &#xA;&lt;p&gt;Project&#39;s main documentation can be found in the &lt;code&gt;docs/&lt;/code&gt; directory. However, &lt;a href=&#34;https://github.com/vvaltchev/tilck/wiki&#34;&gt;Tilck&#39;s wiki&lt;/a&gt; can be used to navigate through those documention files with the addition of much extra content like screenshots. Here below, instead, there&#39;s a quick &lt;em&gt;starter&lt;/em&gt; guide, focusing on the most common scenarios.&lt;/p&gt; &#xA;&lt;h3&gt;Building Tilck&lt;/h3&gt; &#xA;&lt;p&gt;The project supports a fair amount of build configurations and customizations but building using its default configuration can be described in just a few steps. The &lt;em&gt;only&lt;/em&gt; true requirement for building Tilck is having a Linux x86_64 host system or Microsoft&#39;s &lt;code&gt;WSL&lt;/code&gt;. Steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enter project&#39;s root directory.&lt;/li&gt; &#xA; &lt;li&gt;Build the toolchain (just the first time) with: &lt;code&gt;./scripts/build_toolchain&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Compile the kernel and prepare the bootable image with: &lt;code&gt;make&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At this point, there will be an image file named &lt;code&gt;tilck.img&lt;/code&gt; in the &lt;code&gt;build&lt;/code&gt; directory. The easiest way for actually trying &lt;code&gt;Tilck&lt;/code&gt; at that point is to run: &lt;code&gt;./build/run_qemu&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Running it on physical hardware&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;tilck.img&lt;/code&gt; image is, of course, bootable on physical machines as well, both on UEFI systems and on legacy ones. Just flush the image file with &lt;code&gt;dd&lt;/code&gt; to a usb stick and reboot your machine.&lt;/p&gt; &#xA;&lt;h4&gt;Other configurations&lt;/h4&gt; &#xA;&lt;p&gt;To learn much more about how to build and configure Tilck, check the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/building.md&#34;&gt;building&lt;/a&gt; guide in the &lt;code&gt;docs/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h3&gt;Testing Tilck&lt;/h3&gt; &#xA;&lt;p&gt;Tilck has &lt;strong&gt;unit tests&lt;/strong&gt;, &lt;strong&gt;kernel self-tests&lt;/strong&gt;, &lt;strong&gt;system tests&lt;/strong&gt; (using the syscall interface), and &lt;strong&gt;automated interactive system tests&lt;/strong&gt; (simulating real user input through QEMU&#39;s monitor) all in the same repository, completely integrated with its build system. In addition to that, there&#39;s full code coverage support and useful scripts for generating HTML reports (see the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/coverage.md&#34;&gt;coverage&lt;/a&gt; guide). Finally, Tilck is fully integrated with the &lt;a href=&#34;https://azure.microsoft.com/en-us/services/devops/pipelines&#34;&gt;Azure Pipelines&lt;/a&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;CI&lt;/a&gt;, which validates each pushed branch with builds and test runs in a variety of configurations. Kernel&#39;s coverage data is also uploaded to &lt;a href=&#34;https://codecov.io&#34;&gt;CodeCov&lt;/a&gt;. Below, there are some basic instructions to run most of Tilck&#39;s tests. For the whole story, please read the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/testing.md&#34;&gt;testing&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h4&gt;Running Tilck&#39;s tests&lt;/h4&gt; &#xA;&lt;p&gt;Running Tilck&#39;s tests is extremely simple: it just requires to have &lt;code&gt;python 3&lt;/code&gt; installed on the machine. For the &lt;strong&gt;self-tests&lt;/strong&gt; and the classic &lt;strong&gt;system tests&lt;/strong&gt;, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;BUILD_DIR&amp;gt;/st/run_all_tests -c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the &lt;strong&gt;unit tests&lt;/strong&gt; instead:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the &lt;a href=&#34;https://github.com/google/googletest&#34;&gt;googletest&lt;/a&gt; library (once) with: &lt;code&gt;./scripts/build_toolchain -s build_gtest&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the unit tests with: &lt;code&gt;make gtests&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run them with: &lt;code&gt;&amp;lt;BUILD_DIR&amp;gt;/gtests&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To learn much more about Tilck&#39;s tests in general and to understand how to run its &lt;em&gt;interactive&lt;/em&gt; system tests as well, read the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/testing.md&#34;&gt;testing&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h3&gt;Debugging Tilck&lt;/h3&gt; &#xA;&lt;p&gt;With &lt;code&gt;QEMU&lt;/code&gt;&#39;s integrated &lt;code&gt;GDB&lt;/code&gt; server, it&#39;s possible to debug the Tilck kernel with GDB almost as if it were a regular process. It just gets tricky when context switches happen, but GDB cannot help with that. To debug it with GDB, follow the steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;(Optional) Prepare a debug build of Tilck, for a better debugging experience.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run Tilck&#39;s VM with: &lt;code&gt;./build/run_nokvm_qemu&lt;/code&gt; but, remain at the bootloader stage.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In a different terminal, run: &lt;code&gt;gdb ./build/tilck_unstripped&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In GDB, run: &lt;code&gt;target remote :1234&lt;/code&gt; to connect to QEMU&#39;s gdb server.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set one or more breakpoints using commands like: &lt;code&gt;break kmain&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Type &lt;code&gt;c&lt;/code&gt; to allow execution to continue and boot the OS by pressing ENTER in the bootloader.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In order to make the debugging experience better, Tilck comes with a set of &lt;strong&gt;GDB scripts&lt;/strong&gt; (see &lt;code&gt;other/gdb_scripts&lt;/code&gt;). With them, it&#39;s super-easy to list all the tasks on the system, the handles currently opened by any given process and more. In order to learn how to take advantage of those GDB scripts and anything else related to debugging the Tilck project, check the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/debugging.md&#34;&gt;debugging&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h4&gt;Tilck&#39;s debug panel&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img align=&#34;right&#34; src=&#34;http://vvaltchev.github.io/tilck_imgs/v2/screenshots/dp04.png&#34; alt=&#34;Tilck&#39;s debug panel&#34; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Debugging Tilck with GDB while it&#39;s running inside a VM is very convenient, but in other cases (e.g. Tilck on real hardware) we don&#39;t have GDB support. In addition to that, even when the kernel is running inside a VM, there are some features that are just much more convient to expose directly from the kernel itself rather than through GDB scripts. One way to expose kernel info to userspace is to use &lt;code&gt;sysfs&lt;/code&gt;, but that&#39;s not necessarily the most convenient way for everything (still, Tilck does have &lt;a href=&#34;https://github.com/vvaltchev/tilck/wiki/Tilck&#39;s-sysfs&#34;&gt;sysfs&lt;/a&gt; implementation), especially when &lt;em&gt;interaction&lt;/em&gt; with the kernel itself is needed for debugging purposes. To help in those cases, a &lt;em&gt;debug panel&lt;/em&gt; has been introduced inside Tilck itself. It started as something like Linux&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Magic_SysRq_key&#34;&gt;Magic SysRq&lt;/a&gt; which evolved in a sort of TUI application with debug info plus tracing capabilities for user processes. In the future, it will support some proper debugging features as well. To learn more about it, check the the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/debugging.md&#34;&gt;debugging&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing to Tilck&lt;/h3&gt; &#xA;&lt;p&gt;Contributing to the Tilck project is not only possible, but it&#39;s encouraged. For more about that, check the guidelines in the &lt;a href=&#34;https://raw.githubusercontent.com/vvaltchev/tilck/master/docs/contributing.md&#34;&gt;contributing&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h2&gt;A comment about user experience&lt;/h2&gt; &#xA;&lt;p&gt;Tilck particularly distinguishes itself from many open source projects in one way: it really cares about the &lt;strong&gt;user experience&lt;/strong&gt; (where &#34;user&#34; means &#34;developer&#34;). It&#39;s not the typical super-cool low-level project that&#39;s insanely complex to build and configure; it&#39;s not a project requiring 200 things to be installed on the host machine. Building such projects may require hours or even days of effort (think about special configurations e.g. building with a cross-compiler). Tilck instead, has been designed to be trivial to build and test even by inexperienced people with basic knowledge of Linux. It has a sophisticated script for building its own toolchain that works on all the major Linux distributions and a powerful CMake-based build system. The build of Tilck produces an image ready to be tested with QEMU or written on a USB stick. (To some degree, it&#39;s like what the &lt;code&gt;buildroot&lt;/code&gt; project does for Linux, but it&#39;s much simpler.) Finally, the project includes also scripts for running Tilck on QEMU with various configurations (BIOS boot, UEFI boot, direct (multi-)boot with QEMU&#39;s &lt;code&gt;-kernel&lt;/code&gt; option, etc.).&lt;/p&gt; &#xA;&lt;h4&gt;Motivation&lt;/h4&gt; &#xA;&lt;p&gt;The reason for having the above mentioned features is to offer its users and potential contributors a really &lt;strong&gt;nice&lt;/strong&gt; experience, avoiding any kind of frustration. Hopefully, even the most experienced engineers will enjoy a zero effort experience. But it&#39;s not all about reducing the frustration. It&#39;s also about &lt;em&gt;not scaring&lt;/em&gt; students and junior developers who might be just curious to see what this project is all about and maybe eager to write a simple program for it and/or add a couple of &lt;code&gt;printk()&lt;/code&gt;&#39;s here and there in their fork. Hopefully, some of those people &lt;em&gt;just playing&lt;/em&gt; with Tilck might actually want to contribute to its development.&lt;/p&gt; &#xA;&lt;p&gt;In conclusion, even if some parts of the project itself are be pretty complex, at least building and running its tests &lt;strong&gt;must be&lt;/strong&gt; something anyone can do.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;Here below, there is a list of &lt;em&gt;frequently&lt;/em&gt; asked questions. This list is &lt;em&gt;not&lt;/em&gt; supposed to be exaustive and it will change over time. For the &lt;em&gt;full list&lt;/em&gt; of questions on Tilck, check the &lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/categories/q-a&#34;&gt;Q &amp;amp; A page&lt;/a&gt; in the &lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions&#34;&gt;Discussions&lt;/a&gt; section instead.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/83&#34;&gt;Why Tilck does not have the feature/abstraction XYZ like other kernels do?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/84&#34;&gt;Why Tilck runs only on x86 (ia-32)?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/85&#34;&gt;Why having support for FAT32?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/86&#34;&gt;Why keeping the initrd mounted?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/88&#34;&gt;Why using 3 spaces as indentation?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/89&#34;&gt;Why many commit messages are so short?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/81&#34;&gt;Can a lightweight X server run on Tilck today?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vvaltchev/tilck/discussions/93&#34;&gt;Compiling Tilck with TCC &amp;amp; self-hosting?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>groundcover-com/caretta</title>
    <updated>2023-01-12T01:31:32Z</updated>
    <id>tag:github.com,2023-01-12:/groundcover-com/caretta</id>
    <link href="https://github.com/groundcover-com/caretta" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Instant K8s service dependency map, right to your Grafana.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Caretta&lt;/h1&gt; &#xA; &lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/groundcover-com/caretta/main/images/logo.svg?sanitize=true&#34; width=&#34;25%&#34; alt=&#34;caretta&#34; title=&#34;caretta&#34;&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&#34;https://www.producthunt.com/posts/caretta?utm_source=badge-featured&amp;amp;utm_medium=badge&amp;amp;utm_souce=badge-caretta&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=373791&amp;amp;theme=neutral&#34; alt=&#34;Caretta - Instant K8s service dependency map, right to your Grafana. | Product Hunt&#34; width=&#34;25%&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA; &lt;h2&gt;Instant K8s service dependency map , right to your Grafana.&lt;/h2&gt; &#xA; &lt;h4&gt; made by &lt;a href=&#34;https://www.groundcover.com&#34;&gt;groundcover&lt;/a&gt;&lt;/h4&gt;&#xA; &lt;a href=&#34;https://www.groundcover.com&#34;&gt; &lt;p&gt; &lt;/p&gt;&lt;/a&gt;&#xA; &lt;p&gt;&lt;a href=&#34;https://www.groundcover.com&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://www.groundcover.com/join-slack&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/slack-groundcover-yellowgreen.svg?logo=slack&#34; alt=&#34;slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache_2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/groundcover-com/caretta/main/images/caretta.gif&#34; width=&#34;90%&#34; alt=&#34;caretta-screenshot&#34; title=&#34;caretta-screenshot&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;What is Caretta?&lt;/h2&gt; &#xA;&lt;p&gt;Caretta is a lightweight, standalone tool that instantly creates a visual network map of the services running in your cluster.&lt;/p&gt; &#xA;&lt;p&gt;Carreta leverages eBPF to efficiently map all service network interactions in a K8s cluster, and Grafana to query and visualize the collected data.&lt;/p&gt; &#xA;&lt;p&gt;Carreta is built to be efficient, with a minimal footprint on the system, and does not require any modifications of the cluster.&lt;/p&gt; &#xA;&lt;p&gt;Caretta demonstrates the power of using eBPF for observability solutions, which is our vision at &lt;a href=&#34;https://groundcover.com&#34;&gt;groundcover&lt;/a&gt;. If you&#39;re interested in understanding how Caretta is built, head over to our &lt;a href=&#34;https://www.groundcover.com/blog/caretta&#34;&gt;Caretta blog post!&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installing Caretta &lt;span&gt;⚡&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;As simple as installing a helm chart. It is recommended to install Caretta in a new, unique namespace.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm repo add groundcover https://helm.groundcover.com/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm repo update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm install caretta --namespace caretta --create-namespace groundcover/caretta&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can configure Caretta using helm values. Useful values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;tolerations&lt;/strong&gt; can be specified to make sure Caretta&#39;s eBPF-agent will run on all cluster in your nodes. &lt;em&gt;default value will tolerate common control-plane node annotations&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;victoria-metrics-single.server.persistentVolume.enabled&lt;/strong&gt; can be set to &lt;em&gt;true&lt;/em&gt; if you wish to save Caretta&#39;s metrics to a persistent volume &lt;em&gt;default: false&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pollIntervalSeconds&lt;/strong&gt; can be modified to specify the polling and publishing interval of new metrics from the kernel. &lt;em&gt;default: 5&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example yaml for overriding these values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;pollIntervalSeconds: 15  # set metrics polling interval &#xA;&#xA;tolerations:             # set any desired tolerations&#xA;  - key: node-role.kubernetes.io/control-plane&#xA;    operator: Exists&#xA;    effect: NoSchedule&#xA;    &#xA; victoria-metrics-single:&#xA;  server:&#xA;    persistentVolume:&#xA;       enabled: true   # set to true to use persistent volume&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be done using the --set flag on the &lt;code&gt;helm install&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;h3&gt;Uninstallation&lt;/h3&gt; &#xA;&lt;p&gt;To uninstall, delete the helm release:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm delete caretta --namespace caretta&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if persistent storage was enabled in the installation, it may not be deleted automatically by this command.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux kernel version &amp;gt;= 4.16&lt;/li&gt; &#xA; &lt;li&gt;x64 system&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nakryiko.com/posts/bpf-portability-and-co-re/&#34;&gt;CO-RE&lt;/a&gt; support. Supported linux distributions can be found &lt;a href=&#34;https://github.com/libbpf/libbpf#bpf-co-re-compile-once--run-everywhere&#34;&gt;here&lt;/a&gt;. Specifically, Docker for Mac uses a distribution which is not currently supported.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Working with Caretta &lt;span&gt;🐢&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Caretta&#39;s helm chart ships an instance of Grafana with a predefined dashboard using data published by Caretta. This dashboard contains some examples to demonstrate the usage of Caretta&#39;s metrics.&lt;/p&gt; &#xA;&lt;h3&gt;Using the provided Grafana instance&lt;/h3&gt; &#xA;&lt;p&gt;To access Grafana, port-forward port &lt;code&gt;3000&lt;/code&gt; from the Grafana pod in Caretta&#39;s namespace.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;em&gt;kubectl&lt;/em&gt;, it should look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl port-forward --namespace caretta &amp;lt;grafana-pod-name&amp;gt; 3000:3000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE:&lt;/em&gt;&lt;/strong&gt; Anonymous mode is enabled, making the default dashboard accessible with no login needed. To edit the default dashboard or create your own dashboard, use the default administrator&#39;s credentials user:&lt;code&gt;admin&lt;/code&gt; ; password:&lt;code&gt;caretta&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Scraping Caretta&#39;s metrics&lt;/h3&gt; &#xA;&lt;p&gt;Caretta uses &lt;a href=&#34;https://victoriametrics.com/&#34;&gt;Victoria Metrics&lt;/a&gt; to collect and publish its metrics, and the outcome can be consumed by &lt;strong&gt;any Prometheus-compatible dashboard&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Caretta&#39;s main metric is &lt;code&gt;caretta_links_observed&lt;/code&gt; (Gauge). It uses the following labels to represent a specific connection (network socket) going through the cluster:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;client_name&lt;/code&gt; - either a name of a kubernetes entity, if resolved, an external domain, if resolved, or an IP address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;client_namespace&lt;/code&gt; - either the namespace of the kubernetes entity, or &#34;node&#34;, or &#34;external&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;client_kind&lt;/code&gt; - either the kind of the kubernetes entity, or &#34;node&#34;, or &#34;external&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server_name&lt;/code&gt; - either a name of a kubernetes entity, if resolved, an external domain, if resolved, or an IP address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server_namespace&lt;/code&gt; - either the namespace of the kubernetes entity, or &#34;node&#34;, or &#34;external&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server_kind&lt;/code&gt; - either the kind of the kubernetes entity, or &#34;node&#34;, or &#34;external&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server_port&lt;/code&gt; - the port used by the server.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;role&lt;/code&gt; - either 1 (client) or 2 (server).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Along those labels, Caretta uses other labels for Grafana&#39;s Node Graph panel.&lt;/p&gt; &#xA;&lt;h4&gt;Example metric data&lt;/h4&gt; &#xA;&lt;p&gt;This example shows a connection between a client named &lt;code&gt;checkoutservice&lt;/code&gt;, controlled by a deployment, to a service named &lt;code&gt;productioncatalogservice&lt;/code&gt; on port 3550, from the perspective of the client. Total bytes sent by the client in this connection is 2537 bytes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;caretta_links_observed{client_id=&#34;1074587981&#34;,client_kind=&#34;Deployment&#34;,client_name=&#34;checkoutservice&#34;,client_namespace=&#34;demo-ng&#34;,link_id=&#34;198768460&#34;,role=&#34;1&#34;,server_id=&#34;1112713827&#34;,server_kind=&#34;Service&#34;,server_name=&#34;productcatalogservice&#34;,server_namespace=&#34;demo-ng&#34;,server_port=&#34;3550&#34;} 2537&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Example queries &lt;span&gt;⭐&lt;/span&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;increase ((sum (server_port) (caretta_links_observed{client_name=&#34;some-client&#34;, server_name=&#34;some-server}))[15m]) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;` will output the throughput observed between some-client and some-server in the last 15 minutes, aggregated by port.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sum by (server_name) (rate(caretta_links_observed{client_name=&#34;some-client&#34;}))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will output the rate of traffic from some-client to servers it communicates with, aggregated by the server&#39;s name.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort_desc(increase((sum by (client_name)(caretta_links_observed{server_namespace=&#34;external&#34;}))[5m])) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will output communication to external servers by client&#39;s name, sorted descending.&lt;/p&gt; &#xA;&lt;h2&gt;Need help&lt;span&gt;❔&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to reach us on our &lt;a href=&#34;http://www.groundcover.com/join-slack&#34;&gt;slack channel&lt;/a&gt;, or create an issue in this repository.&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to add your contribution to the project.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open an issue for missing features, or bugs&lt;/li&gt; &#xA; &lt;li&gt;Create a pull request for adding code to the project&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>