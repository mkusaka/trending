<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-13T01:32:29Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xiaoyuec0de/Tank</title>
    <updated>2023-01-13T01:32:29Z</updated>
    <id>tag:github.com,2023-01-13:/xiaoyuec0de/Tank</id>
    <link href="https://github.com/xiaoyuec0de/Tank" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Tank&lt;/h1&gt; &#xA;&lt;h1&gt;该项目是什么&lt;/h1&gt; &#xA;&lt;p&gt;该项目是基于unicorn的一个安卓SO模拟器&lt;/p&gt; &#xA;&lt;p&gt;目前该项目，还不是很完善，但是已经初聚雏形&lt;/p&gt; &#xA;&lt;p&gt;这个有吸引的地方，主要在于在汇编层级对so的模拟执行，基于此可以有所作为&lt;/p&gt; &#xA;&lt;h1&gt;主要目的&lt;/h1&gt; &#xA;&lt;p&gt;用于SO的模拟执行，安全研究&lt;/p&gt; &#xA;&lt;h1&gt;已经完成的部分&lt;/h1&gt; &#xA;&lt;p&gt;1、so的加载&lt;/p&gt; &#xA;&lt;p&gt;2、so的模拟执行&lt;/p&gt; &#xA;&lt;p&gt;3、jvm环境的补充&lt;/p&gt; &#xA;&lt;p&gt;4、java类的部分加载&lt;/p&gt; &#xA;&lt;h1&gt;未完成的部分&lt;/h1&gt; &#xA;&lt;p&gt;1、jvm环境的全部API&lt;/p&gt; &#xA;&lt;h1&gt;写在最后&lt;/h1&gt; &#xA;&lt;p&gt;或许写点代码，不断的维护更新。总会慢慢的进步吧，与君共勉&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>krallin/tini</title>
    <updated>2023-01-13T01:32:29Z</updated>
    <id>tag:github.com,2023-01-13:/krallin/tini</id>
    <link href="https://github.com/krallin/tini" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tiny but valid `init` for containers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Tini - A tiny but valid &lt;code&gt;init&lt;/code&gt; for containers&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/krallin/tini&#34;&gt;&lt;img src=&#34;https://travis-ci.org/krallin/tini.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Tini is the simplest &lt;code&gt;init&lt;/code&gt; you could think of.&lt;/p&gt; &#xA;&lt;p&gt;All Tini does is spawn a single child (Tini is meant to be run in a container), and wait for it to exit all the while reaping zombies and performing signal forwarding.&lt;/p&gt; &#xA;&lt;h2&gt;Why Tini?&lt;/h2&gt; &#xA;&lt;p&gt;Using Tini has several benefits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It protects you from software that accidentally creates zombie processes, which can (over time!) starve your entire system for PIDs (and make it unusable).&lt;/li&gt; &#xA; &lt;li&gt;It ensures that the &lt;em&gt;default signal handlers&lt;/em&gt; work for the software you run in your Docker image. For example, with Tini, &lt;code&gt;SIGTERM&lt;/code&gt; properly terminates your process even if you didn&#39;t explicitly install a signal handler for it.&lt;/li&gt; &#xA; &lt;li&gt;It does so completely transparently! Docker images that work without Tini will work with Tini without any changes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you&#39;d like more detail on why this is useful, review this issue discussion: &lt;a href=&#34;https://github.com/krallin/tini/issues/8&#34;&gt;What is advantage of Tini?&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Using Tini&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: If you are using Docker 1.13 or greater, Tini is included in Docker itself. This includes all versions of Docker CE. To enable Tini, just &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/run/&#34;&gt;pass the &lt;code&gt;--init&lt;/code&gt; flag to &lt;code&gt;docker run&lt;/code&gt;&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: There are &lt;a href=&#34;https://github.com/krallin/tini-images&#34;&gt;pre-built Docker images available for Tini&lt;/a&gt;. If you&#39;re currently using an Ubuntu or CentOS image as your base, you can use one of those as a drop-in replacement.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: There are Tini packages for Alpine Linux and NixOS. See below for installation instructions.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add Tini to your container, and make it executable. Then, just invoke Tini and pass your program and its arguments as arguments to Tini.&lt;/p&gt; &#xA;&lt;p&gt;In Docker, you will want to use an entrypoint so you don&#39;t have to remember to manually invoke Tini:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Add Tini&#xA;ENV TINI_VERSION v0.19.0&#xA;ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini&#xA;RUN chmod +x /tini&#xA;ENTRYPOINT [&#34;/tini&#34;, &#34;--&#34;]&#xA;&#xA;# Run your program under Tini&#xA;CMD [&#34;/your/program&#34;, &#34;-and&#34;, &#34;-its&#34;, &#34;arguments&#34;]&#xA;# or docker run your-image /your/program ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you &lt;em&gt;can&lt;/em&gt; skip the &lt;code&gt;--&lt;/code&gt; under certain conditions, but you might as well always include it to be safe. If you see an error message that looks like &lt;code&gt;tini: invalid option -- &#39;c&#39;&lt;/code&gt;, then you &lt;em&gt;need&lt;/em&gt; to add the &lt;code&gt;--&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Arguments for Tini itself should be passed like &lt;code&gt;-v&lt;/code&gt; in the following example: &lt;code&gt;/tini -v -- /your/program&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: The binary linked above is a 64-bit dynamically-linked binary.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Signed binaries&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;tini&lt;/code&gt; and &lt;code&gt;tini-static&lt;/code&gt; binaries are signed using the key &lt;code&gt;595E85A6B1B4779EA4DAAEC70B588DFF0527A9B7&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can verify their signatures using &lt;code&gt;gpg&lt;/code&gt; (which you may install using your package manager):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ENV TINI_VERSION v0.19.0&#xA;ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini&#xA;ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini.asc /tini.asc&#xA;RUN gpg --batch --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 595E85A6B1B4779EA4DAAEC70B588DFF0527A9B7 \&#xA; &amp;amp;&amp;amp; gpg --batch --verify /tini.asc /tini&#xA;RUN chmod +x /tini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Verifying binaries via checksum&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;tini&lt;/code&gt; and &lt;code&gt;tini-static&lt;/code&gt; binaries have generated checksums (&lt;code&gt;SHA1&lt;/code&gt; and &lt;code&gt;SHA256&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;You can verify their checksums using &lt;code&gt;sha1sum&lt;/code&gt; and &lt;code&gt;sha256sum&lt;/code&gt; (which you may install using your package manager):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ENV TINI_VERSION v0.19.0&#xA;RUN wget --no-check-certificate --no-cookies --quiet https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini-amd64 \&#xA;    &amp;amp;&amp;amp; wget --no-check-certificate --no-cookies --quiet https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini-amd64.sha256sum \&#xA;    &amp;amp;&amp;amp; echo &#34;$(cat tini-amd64.sha256sum)&#34; | sha256sum -c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Alpine Linux Package&lt;/h3&gt; &#xA;&lt;p&gt;On Alpine Linux, you can use the following command to install Tini:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;RUN apk add --no-cache tini&#xA;# Tini is now available at /sbin/tini&#xA;ENTRYPOINT [&#34;/sbin/tini&#34;, &#34;--&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NixOS&lt;/h3&gt; &#xA;&lt;p&gt;Using Nix, you can use the following command to install Tini:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix-env --install tini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Debian&lt;/h3&gt; &#xA;&lt;p&gt;On Debian (Buster or newer), you can use the following command to install Tini:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get install tini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this installs &lt;code&gt;/usr/bin/tini&lt;/code&gt; (and &lt;code&gt;/usr/bin/tini-static&lt;/code&gt;), not &lt;code&gt;/tini&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Arch Linux&lt;/h3&gt; &#xA;&lt;p&gt;On Arch Linux, there is a package available on the &lt;a href=&#34;https://wiki.archlinux.org/index.php/Arch_User_Repository&#34;&gt;AUR&lt;/a&gt;. Install using the &lt;a href=&#34;https://wiki.archlinux.org/index.php/Arch_User_Repository#Installing_packages&#34;&gt;official instructions&lt;/a&gt; or use an &lt;a href=&#34;https://wiki.archlinux.org/index.php/AUR_helpers&#34;&gt;AUR helper&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pacaur -S tini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Other Platforms&lt;/h3&gt; &#xA;&lt;p&gt;ARM and 32-bit binaries are available! You can find the complete list of available binaries under &lt;a href=&#34;https://github.com/krallin/tini/releases&#34;&gt;the releases tab&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;h3&gt;Verbosity&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;-v&lt;/code&gt; argument can be used for extra verbose output (you can pass it up to 3 times, e.g. &lt;code&gt;-vvv&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Subreaping&lt;/h3&gt; &#xA;&lt;p&gt;By default, Tini needs to run as PID 1 so that it can reap zombies (by running as PID 1, zombies get re-parented to Tini).&lt;/p&gt; &#xA;&lt;p&gt;If for some reason, you cannot run Tini as PID 1, you should register Tini as a process subreaper instead (only in Linux &amp;gt;= 3.4), by either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Passing the &lt;code&gt;-s&lt;/code&gt; argument to Tini (&lt;code&gt;tini -s -- ...&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Setting the environment variable &lt;code&gt;TINI_SUBREAPER&lt;/code&gt; (e.g. &lt;code&gt;export TINI_SUBREAPER=&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This will ensure that zombies get re-parented to Tini despite Tini not running as PID 1.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: Tini will issue a warning if it detects that it isn&#39;t running as PID 1 and isn&#39;t registered as a subreaper. If you don&#39;t see a warning, you&#39;re fine.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Remapping exit codes&lt;/h3&gt; &#xA;&lt;p&gt;Tini will reuse the child&#39;s exit code when exiting, but occasionally, this may not be exactly what you want (e.g. if your child exits with 143 after receiving SIGTERM). Notably, this can be an issue with Java apps.&lt;/p&gt; &#xA;&lt;p&gt;In this case, you can use the &lt;code&gt;-e&lt;/code&gt; flag to remap an arbitrary exit code to 0. You can pass the flag multiple times if needed.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tini -e 143 -- ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Process group killing&lt;/h3&gt; &#xA;&lt;p&gt;By default, Tini only kills its immediate child process. This can be inconvenient if sending a signal to that process does not have the desired effect. For example, if you do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run krallin/ubuntu-tini sh -c &#39;sleep 10&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and ctrl-C it, nothing happens: SIGINT is sent to the &#39;sh&#39; process, but that shell won&#39;t react to it while it is waiting for the &#39;sleep&#39; to finish.&lt;/p&gt; &#xA;&lt;p&gt;With the &lt;code&gt;-g&lt;/code&gt; option, Tini kills the child process group , so that every process in the group gets the signal. This corresponds more closely to what happens when you do ctrl-C etc. in a terminal: The signal is sent to the foreground process group.&lt;/p&gt; &#xA;&lt;h3&gt;Parent Death Signal&lt;/h3&gt; &#xA;&lt;p&gt;Tini can set its parent death signal, which is the signal Tini should receive when &lt;em&gt;its&lt;/em&gt; parent exits. To set the parent death signal, use the &lt;code&gt;-p&lt;/code&gt; flag with the name of the signal Tini should receive when its parent exits:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tini -p SIGTERM -- ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: See &lt;a href=&#34;https://github.com/krallin/tini/pull/114&#34;&gt;this PR discussion&lt;/a&gt; to learn more about the parent death signal and use cases.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;More&lt;/h2&gt; &#xA;&lt;h3&gt;Existing Entrypoint&lt;/h3&gt; &#xA;&lt;p&gt;Tini can also be used with an existing entrypoint in your container!&lt;/p&gt; &#xA;&lt;p&gt;Assuming your entrypoint was &lt;code&gt;/docker-entrypoint.sh&lt;/code&gt;, then you would use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ENTRYPOINT [&#34;/tini&#34;, &#34;--&#34;, &#34;/docker-entrypoint.sh&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Statically-Linked Version&lt;/h3&gt; &#xA;&lt;p&gt;Tini has very few dependencies (it only depends on libc), but if your container fails to start, you might want to consider using the statically-built version instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini-static /tini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Size Considerations&lt;/h3&gt; &#xA;&lt;p&gt;Tini is a very small file (in the 10KB range), so it doesn&#39;t add much weight to your container.&lt;/p&gt; &#xA;&lt;p&gt;The statically-linked version is bigger, but still &amp;lt; 1M.&lt;/p&gt; &#xA;&lt;h2&gt;Building Tini&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d rather not download the binary, you can build Tini by running &lt;code&gt;cmake . &amp;amp;&amp;amp; make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before building, you probably also want to run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export CFLAGS=&#34;-DPR_SET_CHILD_SUBREAPER=36 -DPR_GET_CHILD_SUBREAPER=37&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ensure that even if you&#39;re building on a system that has old Linux Kernel headers (&amp;lt; 3.4), Tini will be built with child subreaper support. This is usually what you want if you&#39;re going to use Tini with Docker (if your host Kernel supports Docker, it should also support child subreapers).&lt;/p&gt; &#xA;&lt;h2&gt;Understanding Tini&lt;/h2&gt; &#xA;&lt;p&gt;After spawning your process, Tini will wait for signals and forward those to the child process, and periodically reap zombie processes that may be created within your container.&lt;/p&gt; &#xA;&lt;p&gt;When the &#34;first&#34; child process exits (&lt;code&gt;/your/program&lt;/code&gt; in the examples above), Tini exits as well, with the exit code of the child process (so you can check your container&#39;s exit code to know whether the child exited successfully).&lt;/p&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;If something isn&#39;t working just like you expect, consider increasing the verbosity level (up to 3):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tini -v    -- bash -c &#39;exit 1&#39;&#xA;tini -vv   -- true&#xA;tini -vvv  -- pwd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Authors&lt;/h1&gt; &#xA;&lt;p&gt;Maintainer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/krallin/&#34;&gt;Thomas Orozco&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Contributors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tianon&#34;&gt;Tianon Gravi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dpw&#34;&gt;David Wragg&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/crosbymichael&#34;&gt;Michael Crosby&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/geek&#34;&gt;Wyatt Preul&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pks-t&#34;&gt;Patrick Steinhardt&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Special thanks to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/danilobuerger&#34;&gt;Danilo Bürger&lt;/a&gt; for packaging Tini for Alpine&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/datakurre&#34;&gt;Asko Soukka&lt;/a&gt; for packaging Tini for Nix&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nfnty/pkgbuilds/tree/master/tini/tini&#34;&gt;nfnty&lt;/a&gt; for packaging Tini for Arch Linux&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>kusumi/netbsd_hammer2</title>
    <updated>2023-01-13T01:32:29Z</updated>
    <id>tag:github.com,2023-01-13:/kusumi/netbsd_hammer2</id>
    <link href="https://github.com/kusumi/netbsd_hammer2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;HAMMER2 file system for NetBSD&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NetBSD &lt;a href=&#34;https://gitweb.dragonflybsd.org/dragonfly.git/blob/HEAD:/sys/vfs/hammer2/DESIGN&#34;&gt;HAMMER2&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;HAMMER2 file system for NetBSD&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NetBSD version of &lt;a href=&#34;https://github.com/kusumi/freebsd_hammer2&#34;&gt;https://github.com/kusumi/freebsd_hammer2&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Recent NetBSD release&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NetBSD src tree under /usr/src by default&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ cd netbsd_hammer2&#xA;    $ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ sudo bash -x ./script/install.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Uninstall&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ sudo bash -x ./script/uninstall.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Initial target is read-only support, but write support is also planned once read-only support is accomplished.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Tags are merely for packaging, nothing directly to do with file system version.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;-CURRENT aka upstream NetBSD is the only tier 1 support branch at the moment.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>