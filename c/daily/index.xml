<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-04T01:28:06Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>codeplea/genann</title>
    <updated>2024-02-04T01:28:06Z</updated>
    <id>tag:github.com,2024-02-04:/codeplea/genann</id>
    <link href="https://github.com/codeplea/genann" rel="alternate"></link>
    <summary type="html">&lt;p&gt;simple neural network library in ANSI C&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/codeplea/genann&#34;&gt;&lt;img src=&#34;https://travis-ci.org/codeplea/genann.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img alt=&#34;Genann logo&#34; src=&#34;https://codeplea.com/public/content/genann_logo.png&#34; align=&#34;right&#34;&gt; &#xA;&lt;h1&gt;Genann&lt;/h1&gt; &#xA;&lt;p&gt;Genann is a minimal, well-tested library for training and using feedforward artificial neural networks (ANN) in C. Its primary focus is on being simple, fast, reliable, and hackable. It achieves this by providing only the necessary functions and little extra.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;C99 with no dependencies&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Contained in a single source code and header file.&lt;/li&gt; &#xA; &lt;li&gt;Simple.&lt;/li&gt; &#xA; &lt;li&gt;Fast and thread-safe.&lt;/li&gt; &#xA; &lt;li&gt;Easily extendible.&lt;/li&gt; &#xA; &lt;li&gt;Implements backpropagation training.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Compatible with alternative training methods&lt;/em&gt; (classic optimization, genetic algorithms, etc)&lt;/li&gt; &#xA; &lt;li&gt;Includes examples and test suite.&lt;/li&gt; &#xA; &lt;li&gt;Released under the zlib license - free for nearly any use.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Genann is self-contained in two files: &lt;code&gt;genann.c&lt;/code&gt; and &lt;code&gt;genann.h&lt;/code&gt;. To use Genann, simply add those two files to your project.&lt;/p&gt; &#xA;&lt;h2&gt;Example Code&lt;/h2&gt; &#xA;&lt;p&gt;Four example programs are included with the source code.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/codeplea/genann/master/example1.c&#34;&gt;&lt;code&gt;example1.c&lt;/code&gt;&lt;/a&gt; - Trains an ANN on the XOR function using backpropagation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/codeplea/genann/master/example2.c&#34;&gt;&lt;code&gt;example2.c&lt;/code&gt;&lt;/a&gt; - Trains an ANN on the XOR function using random search.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/codeplea/genann/master/example3.c&#34;&gt;&lt;code&gt;example3.c&lt;/code&gt;&lt;/a&gt; - Loads and runs an ANN from a file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/codeplea/genann/master/example4.c&#34;&gt;&lt;code&gt;example4.c&lt;/code&gt;&lt;/a&gt; - Trains an ANN on the &lt;a href=&#34;https://archive.ics.uci.edu/ml/datasets/Iris&#34;&gt;IRIS data-set&lt;/a&gt; using backpropagation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Example&lt;/h2&gt; &#xA;&lt;p&gt;We create an ANN taking 2 inputs, having 1 layer of 3 hidden neurons, and providing 2 outputs. It has the following structure:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/codeplea/genann/master/doc/e1.png&#34; alt=&#34;NN Example Structure&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We then train it on a set of labeled data using backpropagation and ask it to predict on a test data point:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &#34;genann.h&#34;&#xA;&#xA;/* Not shown, loading your training and test data. */&#xA;double **training_data_input, **training_data_output, **test_data_input;&#xA;&#xA;/* New network with 2 inputs,&#xA; * 1 hidden layer of 3 neurons each,&#xA; * and 2 outputs. */&#xA;genann *ann = genann_init(2, 1, 3, 2);&#xA;&#xA;/* Learn on the training set. */&#xA;for (i = 0; i &amp;lt; 300; ++i) {&#xA;    for (j = 0; j &amp;lt; 100; ++j)&#xA;        genann_train(ann, training_data_input[j], training_data_output[j], 0.1);&#xA;}&#xA;&#xA;/* Run the network and see what it predicts. */&#xA;double const *prediction = genann_run(ann, test_data_input[0]);&#xA;printf(&#34;Output for the first test data point is: %f, %f\n&#34;, prediction[0], prediction[1]);&#xA;&#xA;genann_free(ann);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example is to show API usage, it is not showing good machine learning techniques. In a real application you would likely want to learn on the test data in a random order. You would also want to monitor the learning to prevent over-fitting.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Creating and Freeing ANNs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;genann *genann_init(int inputs, int hidden_layers, int hidden, int outputs);&#xA;genann *genann_copy(genann const *ann);&#xA;void genann_free(genann *ann);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Creating a new ANN is done with the &lt;code&gt;genann_init()&lt;/code&gt; function. Its arguments are the number of inputs, the number of hidden layers, the number of neurons in each hidden layer, and the number of outputs. It returns a &lt;code&gt;genann&lt;/code&gt; struct pointer.&lt;/p&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;genann_copy()&lt;/code&gt; will create a deep-copy of an existing &lt;code&gt;genann&lt;/code&gt; struct.&lt;/p&gt; &#xA;&lt;p&gt;Call &lt;code&gt;genann_free()&lt;/code&gt; when you&#39;re finished with an ANN returned by &lt;code&gt;genann_init()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Training ANNs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void genann_train(genann const *ann, double const *inputs,&#xA;        double const *desired_outputs, double learning_rate);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;genann_train()&lt;/code&gt; will preform one update using standard backpropogation. It should be called by passing in an array of inputs, an array of expected outputs, and a learning rate. See &lt;em&gt;example1.c&lt;/em&gt; for an example of learning with backpropogation.&lt;/p&gt; &#xA;&lt;p&gt;A primary design goal of Genann was to store all the network weights in one contigious block of memory. This makes it easy and efficient to train the network weights using direct-search numeric optimization algorthims, such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Hill_climbing&#34;&gt;Hill Climbing&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Genetic_algorithm&#34;&gt;the Genetic Algorithm&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Simulated_annealing&#34;&gt;Simulated Annealing&lt;/a&gt;, etc. These methods can be used by searching on the ANN&#39;s weights directly. Every &lt;code&gt;genann&lt;/code&gt; struct contains the members &lt;code&gt;int total_weights;&lt;/code&gt; and &lt;code&gt;double *weight;&lt;/code&gt;. &lt;code&gt;*weight&lt;/code&gt; points to an array of &lt;code&gt;total_weights&lt;/code&gt; size which contains all weights used by the ANN. See &lt;em&gt;example2.c&lt;/em&gt; for an example of training using random hill climbing search.&lt;/p&gt; &#xA;&lt;h3&gt;Saving and Loading ANNs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;genann *genann_read(FILE *in);&#xA;void genann_write(genann const *ann, FILE *out);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Genann provides the &lt;code&gt;genann_read()&lt;/code&gt; and &lt;code&gt;genann_write()&lt;/code&gt; functions for loading or saving an ANN in a text-based format.&lt;/p&gt; &#xA;&lt;h3&gt;Evaluating&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;double const *genann_run(genann const *ann, double const *inputs);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Call &lt;code&gt;genann_run()&lt;/code&gt; on a trained ANN to run a feed-forward pass on a given set of inputs. &lt;code&gt;genann_run()&lt;/code&gt; will provide a pointer to the array of predicted outputs (of &lt;code&gt;ann-&amp;gt;outputs&lt;/code&gt; length).&lt;/p&gt; &#xA;&lt;h2&gt;Hints&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All functions start with &lt;code&gt;genann_&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The code is simple. Dig in and change things.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Extra Resources&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://www.faqs.org/faqs/ai-faq/neural-nets/part1/&#34;&gt;comp.ai.neural-nets FAQ&lt;/a&gt; is an excellent resource for an introduction to artificial neural networks.&lt;/p&gt; &#xA;&lt;p&gt;If you need an even smaller neural network library, check out the excellent single-hidden-layer library &lt;a href=&#34;https://github.com/glouw/tinn&#34;&gt;tinn&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re looking for a heavier, more opinionated neural network library in C, I recommend the &lt;a href=&#34;http://leenissen.dk/fann/wp/&#34;&gt;FANN library&lt;/a&gt;. Another good library is Peter van Rossum&#39;s &lt;a href=&#34;http://lwneuralnet.sourceforge.net/&#34;&gt;Lightweight Neural Network&lt;/a&gt;, which despite its name, is heavier and has more features than Genann.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dgllghr/stanchion</title>
    <updated>2024-02-04T01:28:06Z</updated>
    <id>tag:github.com,2024-02-04:/dgllghr/stanchion</id>
    <link href="https://github.com/dgllghr/stanchion" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A SQLite extension that brings column-oriented tables to SQLite&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Stanchion&lt;/h1&gt; &#xA;&lt;p&gt;Column-oriented tables in SQLite&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;Stanchion is a SQLite 3 extension that brings the power of column-oriented storage to SQLite, the most widely deployed database. SQLite exclusively supports row-oriented tables, which means it is not an ideal fit for all workloads. Using the Stanchion plugin brings all of the benefits of column-oriented storage and data warehousing to anywhere that SQLite is already deployed, including your existing tech stack.&lt;/p&gt; &#xA;&lt;p&gt;There are a number of situations where column-oriented storage outperforms row-oriented storage:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Storing and processing metric, log, and event data&lt;/li&gt; &#xA; &lt;li&gt;Timeseries data storage and analysis&lt;/li&gt; &#xA; &lt;li&gt;Analytical queries over many rows and a few columns (e.g. calculating the average temperature over months of hourly weather data)&lt;/li&gt; &#xA; &lt;li&gt;Change tracking, history/temporal tables&lt;/li&gt; &#xA; &lt;li&gt;Anchor modeling / Datomic-like data models&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Stanchion is an ideal fit for analytical queries and wide tables because it only scans data from the columns that are referenced by a given query. It uses compression techniques like run length and bit-packed encodings that significantly reduce the size of stored data, greatly reducing the cost of large data sets. This makes it an ideal solution for storing large, expanding datasets.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Download the prebuilt dynamic library for your platform from a Release or &lt;a href=&#34;https://raw.githubusercontent.com/dgllghr/stanchion/main/#Build&#34;&gt;build from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;.load /path/to/libstanchion&#xA;&#xA;CREATE VIRTUAL TABLE dnd_monsters&#xA;USING stanchion (&#xA;    id INTEGER NOT NULL,&#xA;    name TEXT NOT NULL,&#xA;    type TEXT NOT NULL,&#xA;    size INTEGER NOT NULL,&#xA;    challenge_rating FLOAT NOT NULL,&#xA;    SORT KEY (id)&#xA;);&#xA;&#xA;INSERT INTO dnd_monsters (id, name, type, size, challenge_rating)&#xA;VALUES&#xA;    (1, &#39;Beholder&#39;, &#39;ABERRATION&#39;, 4, 13),&#xA;    (2, &#39;Gelatinous Cube&#39;, &#39;OOZE&#39;, 4, 2),&#xA;    (3, &#39;Mimic&#39;, &#39;MONSTROSITY&#39;, 3, 2),&#xA;    (4, &#39;Lich&#39;, &#39;UNDEAD&#39;, 3, 21);&#xA;&#xA;-- Because the `dnd_monsters` table is column-oriented, the following query&#xA;-- only reads data from the `name`, `type`, and `challenge_rating` columns.&#xA;-- Data in the `id` and `size` columns are not accessed or scanned at all!&#xA;SELECT name&#xA;FROM dnd_monsters&#xA;WHERE type = &#39;UNDEAD&#39; AND challenge_rating &amp;gt;= 18;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;Stanchion is in &lt;em&gt;alpha&lt;/em&gt;. Things may not be fully working. The storage format may change in backwards incompatible ways. &lt;strong&gt;Do not use this in production&lt;/strong&gt;... yet.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ziglang.org/learn/getting-started/#installing-zig&#34;&gt;Install Zig (master)&lt;/a&gt; and clone the &lt;code&gt;stanchion&lt;/code&gt; repository. Then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zig build ext -Doptimize=ReleaseFast&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The SQLite extension is the dynamic library named &lt;code&gt;libstanchion&lt;/code&gt; in the &lt;code&gt;zig-out&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Load Stanchion&lt;/h3&gt; &#xA;&lt;p&gt;Stanchion is a &lt;a href=&#34;https://sqlite.org/loadext.html&#34;&gt;Run-Time Loadable Extension&lt;/a&gt; that uses SQLite&#39;s virtual table system. Currently, stanchion must be loaded by all connections that access any stanchion virtual tables. This may change in the future when stanchion supports being a &lt;a href=&#34;https://sqlite.org/loadext.html#persistent_loadable_extensions&#34;&gt;Persistent Loadable Extension&lt;/a&gt;. To load an extension from the SQLite CLI, use the &lt;code&gt;.load&lt;/code&gt; command. Check the documentation of the SQLite bindings you are using to see how to load an extension in your application. Here are some examples for different language bindings: &lt;a href=&#34;https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.load_extension&#34;&gt;&lt;code&gt;sqlite3&lt;/code&gt; for Python&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/rusqlite/latest/rusqlite/struct.Connection.html#method.load_extension&#34;&gt;&lt;code&gt;rusqlite&lt;/code&gt; for Rust&lt;/a&gt;, &lt;a href=&#34;https://rubydoc.info/gems/sqlite3/SQLite3/Database#load_extension-instance_method&#34;&gt;&lt;code&gt;sqlite3&lt;/code&gt; for Ruby&lt;/a&gt;, and &lt;a href=&#34;https://pkg.go.dev/github.com/mattn/go-sqlite3#SQLiteConn.LoadExtension&#34;&gt;&lt;code&gt;go-sqlite3&lt;/code&gt; for Go&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before loading stanchion (or any extension), you may first need to enable extension loading. Here are some examples for different language bindings: &lt;a href=&#34;https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.enable_load_extension&#34;&gt;&lt;code&gt;sqlite3&lt;/code&gt; for Python&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/rusqlite/latest/rusqlite/struct.LoadExtensionGuard.html&#34;&gt;&lt;code&gt;rusqlite&lt;/code&gt; for Rust&lt;/a&gt;, and &lt;a href=&#34;https://rubydoc.info/gems/sqlite3/SQLite3/Database#enable_load_extension-instance_method&#34;&gt;&lt;code&gt;sqlite3&lt;/code&gt; for Ruby&lt;/a&gt;. Some bindings enable extension loading by default (e.g. &lt;a href=&#34;https://github.com/mattn/go-sqlite3#feature--extension-list&#34;&gt;&lt;code&gt;go-sqlite3&lt;/code&gt; for Go&lt;/a&gt;). For more information, see the &lt;a href=&#34;https://sqlite.org/c3ref/enable_load_extension.html&#34;&gt;SQLite documentation for the C API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Create table&lt;/h3&gt; &#xA;&lt;p&gt;Creating a stanchion table works much like creating any table in SQLite:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE VIRTUAL TABLE sensor_log USING stanchion (&#xA;    sensor_id TEXT NOT NULL,&#xA;    timestamp INTEGER NOT NULL,&#xA;    value FLOAT NULL,&#xA;    variance FLOAT NULL,&#xA;    severity INTEGER NOT NULL,&#xA;    SORT KEY (sensor_id, timestamp)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;USING stanchion&lt;/code&gt; phrase tells SQLite to create &lt;code&gt;sensor_log&lt;/code&gt; as a virtual table that is implemented by stanchion.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;SORT KEY&lt;/code&gt; is required for all stanchion tables. It defines the clustered index, the order of the records in the table. The &lt;code&gt;SORT KEY&lt;/code&gt; does not enforce uniqueness. Currently, the &lt;code&gt;SORT KEY&lt;/code&gt; can only contain columns not expressions.&lt;/p&gt; &#xA;&lt;p&gt;Stanchion tables do not support foreign keys, primary keys, check, or unique constraints. These constraints are generally less useful in the scenarios that column-oriented tables are more useful and they are not widely supported across column-oriented databases. However, some of or all of these constraints may be introduced to stanchion in the future as options.&lt;/p&gt; &#xA;&lt;h4&gt;Data types&lt;/h4&gt; &#xA;&lt;p&gt;The following table shows all stanchion data types. Boolean values are converted to integers when passed through SQLite. This allows them to be used from queries and through the SQLite API, which does not support a dedicated Boolean type. See &lt;a href=&#34;https://raw.githubusercontent.com/dgllghr/stanchion/main/#boolean-type&#34;&gt;Differences from SQLite: &lt;code&gt;BOOLEAN&lt;/code&gt; type&lt;/a&gt; for more information about the &lt;code&gt;BOOLEAN&lt;/code&gt; type.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Stanchion type&lt;/th&gt; &#xA;   &lt;th&gt;SQLite type&lt;/th&gt; &#xA;   &lt;th&gt;Aliases&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;BOOLEAN&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;INTEGER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;BOOL&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;INTEGER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;INTEGER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;INT&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FLOAT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;REAL&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;REAL&lt;/code&gt;, &lt;code&gt;DOUBLE&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;BLOB&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;BLOB&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TEXT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;TEXT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;VARCHAR&lt;/code&gt;&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sub&gt;* Does not support character count&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;p&gt;There is no &lt;code&gt;ANY&lt;/code&gt; type and all inserted values must match the declared column type. It is not possible to do dynamic typing in stanchion tables. Stanchion tables are roughly equivalent to SQLite tables declared as &lt;code&gt;STRICT&lt;/code&gt; (without the any type).&lt;/p&gt; &#xA;&lt;p&gt;There are a small number of aliases supported for widely used type names. Declaring a column with an alias is no different than declaring it with the canonical type name.&lt;/p&gt; &#xA;&lt;h3&gt;Add and query data&lt;/h3&gt; &#xA;&lt;p&gt;Inserting and querying data works like any other table in SQLite. Stanchion tables even work with features like the &lt;code&gt;.import&lt;/code&gt; command for adding records to tables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO sensor_log (sensor_id, timestamp, value, variance, severity)&#xA;VALUES&#xA;    (2064, 12433702443, 74.37, 1.06, 1),&#xA;    (2064, 12433703443, 73.12, 0.96, 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Values being inserted into Stanchion tables must be of the column&#39;s declared type. This is equivalent to declaring a SQLite table with the &lt;code&gt;STRICT&lt;/code&gt; table option.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Updating and deleting records is not currently supported. Support for update and delete will be added in the future.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Stanchion tables can be used in all places that native tables can be used in SQLite. Consider the &lt;code&gt;SORT KEY&lt;/code&gt; as a composite index when writing queries to improve query performance. In the following query, the sort key is used to reduce the amount of data scanned. And of course, only the &lt;code&gt;sensor_id&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; columns are read at all.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT AVG(value)&#xA;FROM sensor_log&#xA;WHERE sensor_id = 2064 AND timestamp &amp;gt; 12433700000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Differences from SQLite&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;BOOLEAN&lt;/code&gt; type&lt;/h3&gt; &#xA;&lt;p&gt;Stanchion has a dedicated &lt;code&gt;BOOLEAN&lt;/code&gt; type. Boolean values are used within stanchion as part of each nullable segment and exposed so it can also be used directly.&lt;/p&gt; &#xA;&lt;p&gt;SQLite uses &lt;code&gt;INTEGER&lt;/code&gt; to represent booleans. Stanchion converts &lt;code&gt;BOOLEAN&lt;/code&gt; values to from &lt;code&gt;INTEGER&lt;/code&gt; values when passed through SQLite. Querying a &lt;code&gt;BOOLEAN&lt;/code&gt; stanchion column returns &lt;code&gt;INTEGER&lt;/code&gt; SQLite values.&lt;/p&gt; &#xA;&lt;h3&gt;Clustered index by &lt;code&gt;SORT KEY&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In Stanchion, the order of the records in the table (aka the clustered index) is controlled by the &lt;code&gt;SORT KEY&lt;/code&gt;. Currently, every table in stanchion must have an explicit &lt;code&gt;SORT KEY&lt;/code&gt; made up of 1 or more columns (currently expresions are not supported). It is declared when the table is created and cannot be changed. Unlike a &lt;code&gt;PRIMARY KEY&lt;/code&gt;, it does not enforce uniqueness.&lt;/p&gt; &#xA;&lt;p&gt;This differs from SQLite where tables are sorted by the &lt;code&gt;ROWID&lt;/code&gt; by default or by the &lt;code&gt;PRIMARY KEY&lt;/code&gt; if the table is a &lt;code&gt;WITHOUT ROWID&lt;/code&gt; table.&lt;/p&gt; &#xA;&lt;h3&gt;No uniqueness (&lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt;) or foreign key constraints&lt;/h3&gt; &#xA;&lt;p&gt;This may change in the future. Implementing these will likely require external indexes. When/if a &lt;code&gt;PRIMARY KEY&lt;/code&gt; is introduced, it will likley make sense to follow the lead of Clickhouse&#39;s &lt;code&gt;MergeTree&lt;/code&gt; engine and require that the &lt;code&gt;PRIMARY KEY&lt;/code&gt; &lt;a href=&#34;https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#choosing-a-primary-key-that-differs-from-the-sorting-key&#34;&gt;must be a prefix&lt;/a&gt; of the &lt;code&gt;SORT KEY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;No external indexes&lt;/h3&gt; &#xA;&lt;p&gt;There is currently no external index mechanism. The only index that is used to optimize queries is the clustered index, declared with &lt;code&gt;SORT KEY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Column types are enforced&lt;/h3&gt; &#xA;&lt;p&gt;Values being inserted into Stanchion tables must be of the column&#39;s declared type. This is equivalent to declaring a SQLite table with the &lt;code&gt;STRICT&lt;/code&gt; table option.&lt;/p&gt; &#xA;&lt;h3&gt;No support for updates or deletes (yet)&lt;/h3&gt; &#xA;&lt;p&gt;Support for &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; will be added to stanchion in the future.&lt;/p&gt; &#xA;&lt;h3&gt;Table schemas cannot be altered&lt;/h3&gt; &#xA;&lt;p&gt;This is something that stanchion would like to support, but it may be difficult because SQLite does not have a documented way of supporting schema changes to virtual tables. This is still being investigaed.&lt;/p&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;p&gt;A high level roadmap (only roughly ordered) of upcoming features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Rename table&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Optimize table&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Concurrency safety and testing&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; More encodings: RLE, Dictionary, Chimp, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Byte level lossless compression (e.g. zstd)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Function that converts SQLite native table to stanchion table&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Publish benchmarks against SQLite, DuckDB, and chDB&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;code&gt;DELETE&lt;/code&gt; &amp;amp; &lt;code&gt;UPDATE&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Configuration parameters and tuning&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Guide for using stanchion within iOS and Android apps&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Schema changes (not natively support by SQLite virtual tables)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; List data type&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Data Storage Internals&lt;/h2&gt; &#xA;&lt;h3&gt;Row groups, segments, and stripes&lt;/h3&gt; &#xA;&lt;p&gt;Records in each table are grouped into row groups. Each row group contains up to a fixed number of records. Row groups are logical (not physical) groupings and are indexed by the minimum sort key value within the row group. Currently, row groups are immutable and are constructed from a batch of newly inserted records (and possibly values from an existing row group) when the number of inserted records exceeds a threshold.&lt;/p&gt; &#xA;&lt;p&gt;A row group is made up of multiple segments. A segment contains data for a single column. Think of each row group as a span of data within a table and each segment as a span of data within a column. A segment is backed by a single SQLite &lt;code&gt;BLOB&lt;/code&gt; value. Currently, segments are immutable.&lt;/p&gt; &#xA;&lt;p&gt;Each segment is composed of 1 or more stripes. A stripe is a chunk of data of the same type that is backed by a portion (slice) of the segment&#39;s &lt;code&gt;BLOB&lt;/code&gt; value. A segment can contain the following stripes: present, primary, and length. When a segment contains null values, the primary stripe is used to indicate whether the value in each record is not &lt;code&gt;NULL&lt;/code&gt;. For &lt;code&gt;BOOLEAN&lt;/code&gt;, &lt;code&gt;INTEGER&lt;/code&gt;, and &lt;code&gt;FLOAT&lt;/code&gt; columns, the values are stored in the primary stripe. For &lt;code&gt;TEXT&lt;/code&gt; and &lt;code&gt;BLOB&lt;/code&gt; columns, the bytes of the values are stored in the primary stripe, and the length of each value is stored in the length stripe.&lt;/p&gt; &#xA;&lt;h3&gt;Pending inserts&lt;/h3&gt; &#xA;&lt;p&gt;When records are added to a stanchion table, they are inserted into a standard a persistent B+ Tree (read: native, row-oriented SQLite table) called the pending inserts table. Because it is a native sqlite table, records are stored row-oriented. They are sorted by the sort key so that they can be efficiently merged into row groups.&lt;/p&gt; &#xA;&lt;p&gt;The reason that records are first stored in the pending inserts table is because creating a segment requires having all of the data that will go into the segment. When a segment is created, the encoding used depends on the values being stored in the segment, and not all encodings support being appened to efficiently. Additionally, greater compression can be achieved when the data exhibits patterns that can be exploited by encodings and there is more data per segment. The pending inserts table acts as a buffer where records are stored until there are enough records that it makes sense to create thes segments.&lt;/p&gt; &#xA;&lt;p&gt;When a query filters on sort key columns, Stanchion applies that filter to the pending inserts directly to restrict which pending inserts are accessed. Filtering by sort key is the only indexing mechanism currently supported by Stanchion.&lt;/p&gt; &#xA;&lt;h3&gt;Row group index&lt;/h3&gt; &#xA;&lt;p&gt;The row group index is a native, row-oriented SQLite table that indexes the row groups by the starting (min) sort key of each row group. When a query filters on sort key columns, Stanchion applies that filter to the primary index to restrict which row groups are accessed. Filtering by sort key is the only indexing mechanism currently supported by Stanchion.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/dgllghr/stanchion/main/.github/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>