<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-11T01:35:17Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fail0verflow/bootmii</title>
    <updated>2022-08-11T01:35:17Z</updated>
    <id>tag:github.com,2022-08-11:/fail0verflow/bootmii</id>
    <link href="https://github.com/fail0verflow/bootmii" rel="alternate"></link>
    <summary type="html">&lt;p&gt;BootMii loader&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BootMii loader&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the public release of the source code for the BootMii stub loader.&lt;/p&gt; &#xA;&lt;p&gt;Included portions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ELF loader stub&lt;/li&gt; &#xA; &lt;li&gt;BootMii SD loader proper&lt;/li&gt; &#xA; &lt;li&gt;Reset stub&lt;/li&gt; &#xA; &lt;li&gt;mini (submodule)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Not included:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;boot2-style-wad packaging stuff&lt;/li&gt; &#xA; &lt;li&gt;PyWii (see hbc)&lt;/li&gt; &#xA; &lt;li&gt;UI/PPC side (CE1LING_CAT)&lt;/li&gt; &#xA; &lt;li&gt;Installer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that the code in this repository may differ from the source code used to build the official version of BootMii.&lt;/p&gt; &#xA;&lt;p&gt;This code is released with no warranty, and has only been build tested. If you release this to anyone but yourself without extensive testing, you are an irresponsible person and we will forever hate you.&lt;/p&gt; &#xA;&lt;h2&gt;Build instructions&lt;/h2&gt; &#xA;&lt;p&gt;You need armeb-eabi cross compilers. Same build setup as &lt;a href=&#34;https://github.com/fail0verflow/mini&#34;&gt;mini&lt;/a&gt;. See &lt;a href=&#34;https://github.com/fail0verflow/bootmii-utils&#34;&gt;bootmii-utils&lt;/a&gt; for some outdated toolchain build scripts. Type &lt;code&gt;make&lt;/code&gt; to compile. Good luck.&lt;/p&gt; &#xA;&lt;p&gt;Output is at &lt;code&gt;bootmii.bin&lt;/code&gt;, which is the main &lt;code&gt;armboot.bin&lt;/code&gt; style executable for BootMii-as-IOS, with a dummy reset stub as payload. Installation as boot2 would replace the ELF payload with the original boot2 instead.&lt;/p&gt; &#xA;&lt;h2&gt;Seriously&lt;/h2&gt; &#xA;&lt;p&gt;Do NOT release this to users unless you&#39;ve read &lt;a href=&#34;https://marcan.st/2011/01/safe-hacking/&#34;&gt;this&lt;/a&gt; and spent months testing hardware variations and building an installer that cross checks every step including boot1 simulation prior to actually committing to NAND. There&#39;s a reason we didn&#39;t brick any Wiis with this stuff. We&#39;re releasing this because it&#39;s been over a decade and some people are asking for it to experiment with devkits and other weird stuff, not because anyone should try using this on their Wii.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Unless otherwise noted in an individual file header, all source code in this repository is released under the terms of the GNU General Public License, version 2 or later. The full text of the license can be found in the COPYING file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>espressif/esp-csi</title>
    <updated>2022-08-11T01:35:17Z</updated>
    <id>tag:github.com,2022-08-11:/espressif/esp-csi</id>
    <link href="https://github.com/espressif/esp-csi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Applications based on Wi-Fi CSI (Channel state information), such as indoor positioning, human detection&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ESP-CSI&lt;/h1&gt; &#xA;&lt;p&gt;The main purpose of this project is to show the use of ESP-WIFI-CSI. The human body detection algorithm is still being optimized. You can get more accurate results through machine learning, neural network and other algorithms based on the original CSI data.&lt;/p&gt; &#xA;&lt;h2&gt;1 Introduction&lt;/h2&gt; &#xA;&lt;h3&gt;1.1 Introduction to CSI&lt;/h3&gt; &#xA;&lt;p&gt;Channel state information (CSI) includes specific indicators such as carrier signal strength, amplitude, phase, and signal delay. These indicators reveal the signal scattering, reflection, and power attenuation phenomena that occur with the carrier as the transmission distance changes. It can be used to measure the channel status of the wireless network in Wi-Fi communication. By analyzing and studying the changes in CSI, we can conversely speculate on the changes in the physical environment that cause the changes in the channel state, that is, to achieve non-contact intelligent sensing. CSI is extremely sensitive to environmental changes. In addition to perceiving environmental changes caused by large movements such as walking and running of people or animals, it can also capture subtle movements caused by small movements such as breathing and chewing of people or animals in a static environment.&lt;/p&gt; &#xA;&lt;h3&gt;1.2 The relationship between CSI and RSSI&lt;/h3&gt; &#xA;&lt;p&gt;RSSI is the energy characteristic of the Media Access Control (MAC) layer. CSI uses a more fine-grained wireless channel measurement than RSSI, so CSI has some inherent advantages in terms of information. In an indoor environment, the signal sent by the transmitter passes through multiple propagation paths and undergoes reflection and scattering before reaching the receiver. Human behavior will inevitably cause major changes in signal propagation channels by changing multipath. RSSI, as the superposition of channel strength, cannot clearly reflect the channel changes, which greatly reduces the detection rate. Different from RSSI, because the superposition of the multipath signal exchange layer has the characteristics of rapid change, the power characteristics and channel response of the physical layer CSI can distinguish the multipath characteristics. Conceptually, the channel response is the response to RSSI, just like the response of the rainbow to the solar beam, the components of different wavelengths are separated, and OFDM is the medium that refracts RSSI into CSI.&lt;/p&gt; &#xA;&lt;h3&gt;1.3 Advantages of CSI&lt;/h3&gt; &#xA;&lt;p&gt;CSI is a physical layer characteristic.Compared with other indicators, CSI amplitude shows some advantages:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Anti-interference:&lt;/strong&gt; CSI amplitude is essentially the attenuation coefficient of a set of channels. As long as the channel itself does not change, it is quite robust to interference from power adaptors and other jumpers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;More fine-grained:&lt;/strong&gt; CSI does not use synthetic values ​​(such as RSSI) to measure the channel, but decomposes the entire channel measurement into sub-carriers, and estimates the frequency response of each sub-carrier, so as to determine the channel in the frequency domain. Make a more fine-grained description.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;1.4 Espressif CSI Advantage&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;All ESP32 series support CSI:&lt;/strong&gt; ESP32 / ESP32-S2 / ESP32-C3.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful ecology:&lt;/strong&gt; Espressif is a global leader in the field of Wi-Fi MCUs, combining CSI with existing IOT equipment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;More information:&lt;/strong&gt; Such as RSSI, RF noise floor, reception time and antenna &lt;code&gt;rx_ctrl&lt;/code&gt; field.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Bluetooth Assist:&lt;/strong&gt; ESP32 also supports BLE, for example, it can scan surrounding devices to assist detection.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful processing capability:&lt;/strong&gt; ESP32 CPU handles dual-core, 240MHz, AI instructions. Can run machine learning and neural networks.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;2 CSI Application&lt;/h2&gt; &#xA;&lt;h3&gt;2.1 Intruder detection&lt;/h3&gt; &#xA;&lt;p&gt;Select high-sensitivity sub-carrier combinations and signals from non-line-of-sight path directions in different multipath propagation environments, thereby enhancing the sensitivity of passive person detection and expanding the detection range. This method can form &#34;no blind spot&#34; intruder detection in security applications. The multipath propagation characteristics of wireless signals indoors make wireless perception have natural advantages in sensing range and directionality.&lt;/p&gt; &#xA;&lt;h3&gt;2.2 Positioning and ranging&lt;/h3&gt; &#xA;&lt;p&gt;You can learn from the RSSI method and use CSI as a more informative fingerprint (including information on signal amplitude and phase on multiple subcarriers), or rely on a frequency selective attenuation model for more accurate ranging.&lt;/p&gt; &#xA;&lt;h3&gt;2.3 Human activity detection and recognition&lt;/h3&gt; &#xA;&lt;p&gt;Use CSI&#39;s high sensitivity to environmental changes to recognize human movements, gestures, breathing and other small movements and daily activities.&lt;/p&gt; &#xA;&lt;h2&gt;3 Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;The Getting Started project can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/espressif/esp-csi/master/examples/console_test&#34;&gt;examples/console_test&lt;/a&gt; directory. It will help you build a human activity detection application. See: &lt;a href=&#34;https://raw.githubusercontent.com/espressif/esp-csi/master/examples/console_test/README.md&#34;&gt;README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;4 How to get CSI&lt;/h2&gt; &#xA;&lt;h3&gt;4.1 Get router CSI&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/espressif/esp-csi/master/docs/_static/get_router_csi.png&#34; width=&#34;550&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;How ​​to implement:&lt;/strong&gt; ESP32 sends a Ping packet to the router, and receives the CSI information carried in the Ping Replay returned by the router.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Advantage:&lt;/strong&gt; Only one ESP32 plus router can be completed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Disadvantages:&lt;/strong&gt; Depends on the router, such as the location of the router, the supported Wi-Fi protocol, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Applicable scenario:&lt;/strong&gt; There is only one ESP32 in the environment, and there is a router in the detection environment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;4.2 Get CSI between devices&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/espressif/esp-csi/master/docs/_static/get_device_csi.png&#34; width=&#34;550&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;How ​​to implement:&lt;/strong&gt; ESP32 A and B both send Ping packets to the router, and ESP32 A receives the CSI information carried in the Ping Replay returned by ESP32 B, which is a supplement to the first detection scenario.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Advantage:&lt;/strong&gt; Does not depend on the location of the router, and is not affected by other devices connected under the router.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Disadvantage:&lt;/strong&gt; Depends on the Wi-Fi protocol supported by the router, environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Applicable scenario:&lt;/strong&gt; There must be more than two ESP32s in the environment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;4.3 Get CSI specific devices&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/espressif/esp-csi/master/docs/_static/get_broadcast_csi.png&#34; width=&#34;550&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;How ​​to implement:&lt;/strong&gt; The packet sending device continuously switches channels to send out packets. ESP32 A, B, and C all obtain the CSI information carried in the broadcast packet of the packet sending device. This method has the highest detection accuracy and reliability.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Advantages:&lt;/strong&gt; The completion is not affected by the router, and the detection accuracy is high. When there are multiple devices in the environment, only one packet sending device will cause little interference to the network environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Disadvantages:&lt;/strong&gt; In addition to the ordinary ESP32, it is also necessary to add a special package issuing equipment, the cost is the same and higher.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Applicable scenarios:&lt;/strong&gt; Suitable for scenarios that require high accuracy and multi-device cluster positioning.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;5 Note&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The effect of external IPEX antenna is better than PCB antenna, PCB antenna has directivity.&lt;/li&gt; &#xA; &lt;li&gt;Test in an unmanned environment. Avoid the influence of other people&#39;s activities on test results.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;6 Related resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/latest/esp32/index.html&#34;&gt;ESP-IDF Programming Guide&lt;/a&gt; is the documentation for the Espressif IoT development framework.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/wifi.html#wi-fi-channel-state-information&#34;&gt;ESP-WIFI-CSI Guide&lt;/a&gt; is the use of ESP-WIFI-CSI Description.&lt;/li&gt; &#xA; &lt;li&gt;If you find a bug or have a feature request, you can submit it on &lt;a href=&#34;https://github.com/espressif/esp-csi/issues&#34;&gt;Issues&lt;/a&gt; on GitHub. Please check to see if your question already exists in the existing Issues before submitting it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[1]杨 铮，刘云浩.Wi-Fi雷达：从RSSI到CSI[J].中国计算机学会通讯,2014年11月,10(11):55-60.&lt;/li&gt; &#xA; &lt;li&gt;[2]谈青青.基于 Wi-Fi 的被动式室内入侵检测与定位技术研究[D].南京:南京邮电大学,2019年4月.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Bithack/principia</title>
    <updated>2022-08-11T01:35:17Z</updated>
    <id>tag:github.com,2022-08-11:/Bithack/principia</id>
    <link href="https://github.com/Bithack/principia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Principia Open Source Project&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Bithack/principia/master/data-src/github-image0.gif&#34; alt=&#34;Principia&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Principia is a sandbox physics game originally released in November 2013. It is the successor to the Android hit game &#34;Apparatus&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Principia can be built on Windows, Linux, Android or iOS. The iOS version lags behind and lacks a lot of UI.&lt;/p&gt; &#xA;&lt;p&gt;Compilation on Windows and Linux should be easy, see further below.&lt;/p&gt; &#xA;&lt;p&gt;NOTE! More documentation and resources will come in short!&lt;/p&gt; &#xA;&lt;h2&gt;Getting involved&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to fork this project and send in your pull requests. This is a community project and the community decides how the project evolves. If you are serious about joining and taking a bigger role, please fill in this form:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://forms.gle/Pu7Lw5Vjc6yD4jwVA&#34;&gt;https://forms.gle/Pu7Lw5Vjc6yD4jwVA&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please join the Official Unofficial Discord here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/qV6APzKfk9&#34;&gt;https://discord.gg/qV6APzKfk9&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Follow Bithack on Twitter:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.twitter.com/Bithack&#34;&gt;https://www.twitter.com/Bithack&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building and running&lt;/h2&gt; &#xA;&lt;h2&gt;Building on Windows&lt;/h2&gt; &#xA;&lt;p&gt;The game engine behind Principia (TMS) is written in the C99 standard of C. Unfortunately, the Visual Studio C compiler does not support the C99 standard. Principia must therefore be compiled using the MSYS2 MINGW64 toolchain, as described below.&lt;/p&gt; &#xA;&lt;p&gt;Please find the latest version of the 64-bit MSYS2 here: &lt;a href=&#34;https://www.msys2.org/&#34;&gt;https://www.msys2.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;After installation, a terminal opens. Run the following command to update the environment:&lt;/p&gt; &#xA;&lt;p&gt;$ pacman -Syu&lt;/p&gt; &#xA;&lt;p&gt;The terminal will then ask you to close it when done. Proceed with doign so, and then go to the start menu and run MSYS Mingw32 64-bit. It is important that you run the &#34;MINGW64 64-Bit&#34; version and not the &#34;MSYS2 MSYS&#34; or &#34;MINGW64 32-Bit&#34;. Run the commands below to install the necessary dependencies.&lt;/p&gt; &#xA;&lt;p&gt;$ pacman -S --needed base-devel mingw-w64-x86_64-toolchain autotools&lt;/p&gt; &#xA;&lt;p&gt;$ pacman -S mingw-w64-x86_64-gtk2&lt;/p&gt; &#xA;&lt;p&gt;$ pacman -S mingw-w64-x86_64-curl&lt;/p&gt; &#xA;&lt;p&gt;Then navigate to the &#39;build-windows&#39; folder inside of where you cloned Principia, for example:&lt;/p&gt; &#xA;&lt;p&gt;$ cd /c/Users/&#xA; &lt;username&gt;&#xA;  /Principia/build-windows&#xA; &lt;/username&gt;&lt;/p&gt; &#xA;&lt;p&gt;And start the building process:&lt;/p&gt; &#xA;&lt;p&gt;$ ./autogen.sh&lt;/p&gt; &#xA;&lt;p&gt;$ ./configure&lt;/p&gt; &#xA;&lt;p&gt;$ ./go&lt;/p&gt; &#xA;&lt;p&gt;Principia will launch if everything was successful. Note that the compilation might take up to 10 minutes depending on your system.&lt;/p&gt; &#xA;&lt;h2&gt;Building on Linux&lt;/h2&gt; &#xA;&lt;p&gt;Install dependencies (example is for Debian-based packages):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get install automake libgtk2.0-dev libgl-dev libxss-dev libxxf86vm-dev libasound2-dev libudev-dev valgrind libcurl4-openssl-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Navigate to the build-linux directory and start the building process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd build-linux;&#xA;$ ./autogen.sh&#xA;$ ./configure&#xA;$ ./go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If everything goes well, Principia will start by default unless &lt;code&gt;--silent&lt;/code&gt; is passed to the &lt;code&gt;go&lt;/code&gt; script.&lt;/p&gt; &#xA;&lt;h3&gt;Packaging for Linux&lt;/h3&gt; &#xA;&lt;p&gt;When building Principia for packaging, you would want to use the following command to replace the above. It will clean the source tree, build a release version and not automatically run Principia.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./go --clean --release --silent&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Right now Principia needs to be installed with its executable next to the data directories. Putting all of that in &lt;code&gt;/opt/principia/&lt;/code&gt; and symlinking &lt;code&gt;/usr/bin/principia&lt;/code&gt; =&amp;gt; &lt;code&gt;/opt/principia/principia&lt;/code&gt; should do for now.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;build-linux&lt;/code&gt; directory contains desktop files and an usable icon, which can be installed into &lt;code&gt;/usr/share/applications/&lt;/code&gt; and &lt;code&gt;/usr/share/pixmaps&lt;/code&gt; respectively. &lt;code&gt;principia-url-handler.desktop&lt;/code&gt; is for handling principia:// protocol links and is confirmed to work on at least Firefox and Chromium.&lt;/p&gt; &#xA;&lt;h2&gt;Building for Android (on Linux)&lt;/h2&gt; &#xA;&lt;p&gt;These instructions can likely be easily adapted to build on any platform for Android.&lt;/p&gt; &#xA;&lt;p&gt;Download Android Studio from: &lt;a href=&#34;https://developer.android.com/studio&#34;&gt;https://developer.android.com/studio&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Untar the archive (your version number might differ from the example below) and run studio.sh:&lt;/p&gt; &#xA;&lt;p&gt;$ tar xzf android-studio-2021.2.1.16-linux.tar.gz&lt;/p&gt; &#xA;&lt;p&gt;$ cd bin; ./studio.sh&lt;/p&gt; &#xA;&lt;p&gt;Choose Custom in the Installer, click Next a bunch of times. Android Studio will download components for a while. Once finished, in the &#34;Welcome to Android Studio&#34; dialog, choose &#34;Customize&#34; in the left menu and then click &#34;All Settings...&#34; at the bottom center. Open Appearance -&amp;gt; System Settings -&amp;gt; Android SDK. Click the SDK Tools tab and check the following items:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NDK (Side by side)&lt;/li&gt; &#xA; &lt;li&gt;Android SDK Command-line tools&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Click Apply and wait for the components to download. Close Android Studio forever.&lt;/p&gt; &#xA;&lt;p&gt;Open a terminal and run the build scripts:&lt;/p&gt; &#xA;&lt;p&gt;$ cd build-android;&lt;/p&gt; &#xA;&lt;p&gt;$ export ANDROID_HOME=/home/EXAMPLE/Android/Sdk&lt;/p&gt; &#xA;&lt;p&gt;$ ./gradlew build&lt;/p&gt; &#xA;&lt;p&gt;ANDROID_HOME should be set to the location where Android Studio installed the SDK (which you chose during setup). You might want to put that export line in your .bashrc file.&lt;/p&gt; &#xA;&lt;p&gt;Finally, to install the game on your device:&lt;/p&gt; &#xA;&lt;p&gt;$ ./gradew install&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See LICENSE.md&lt;/p&gt;</summary>
  </entry>
</feed>