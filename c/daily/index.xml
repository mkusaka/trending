<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-01T01:30:13Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ashvardanian/SimSIMD</title>
    <updated>2024-12-01T01:30:13Z</updated>
    <id>tag:github.com,2024-12-01:/ashvardanian/SimSIMD</id>
    <link href="https://github.com/ashvardanian/SimSIMD" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Up to 200x Faster Dot Products &amp; Similarity Metrics ‚Äî for Python, Rust, C, JS, and Swift, supporting f64, f32, f16 real &amp; complex, i8, and bit vectors using SIMD for both AVX2, AVX-512, NEON, SVE, &amp; SVE2 üìê&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/ashvardanian/ashvardanian/raw/master/repositories/SimSIMD.jpg?raw=true&#34; alt=&#34;SimSIMD banner&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Computing dot-products, similarity measures, and distances between low- and high-dimensional vectors is ubiquitous in Machine Learning, Scientific Computing, Geo-Spatial Analysis, and Information Retrieval. These algorithms generally have linear complexity in time, constant or linear complexity in space, and are data-parallel. In other words, it is easily parallelizable and vectorizable and often available in packages like BLAS (level 1) and LAPACK, as well as higher-level &lt;code&gt;numpy&lt;/code&gt; and &lt;code&gt;scipy&lt;/code&gt; Python libraries. Ironically, even with decades of evolution in compilers and numerical computing, &lt;a href=&#34;https://ashvardanian.com/posts/simsimd-faster-scipy&#34;&gt;most libraries can be 3-200x slower than hardware potential&lt;/a&gt; even on the most popular hardware, like 64-bit x86 and Arm CPUs. Moreover, most lack mixed-precision support, which is crucial for modern AI! The rare few that support minimal mixed precision, run only on one platform, and are vendor-locked, by companies like Intel and Nvidia. SimSIMD provides an alternative. 1Ô∏è‚É£ SimSIMD functions are practically as fast as &lt;code&gt;memcpy&lt;/code&gt;. 2Ô∏è‚É£ Unlike BLAS, most kernels are designed for mixed-precision and bit-level operations. 3Ô∏è‚É£ SimSIMD often &lt;a href=&#34;https://pypi.org/project/simsimd/#files&#34;&gt;ships more binaries than NumPy&lt;/a&gt; and has more backends than most BLAS implementations, and more high-level interfaces than most libraries.&lt;/p&gt; &#xA;&lt;div&gt; &#xA; &lt;a href=&#34;https://pepy.tech/project/simsimd&#34;&gt; &lt;img alt=&#34;PyPI&#34; src=&#34;https://static.pepy.tech/personalized-badge/simsimd?period=total&amp;amp;units=abbreviation&amp;amp;left_color=black&amp;amp;right_color=blue&amp;amp;left_text=SimSIMD%20Python%20installs&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://www.npmjs.com/package/simsimd&#34;&gt; &lt;img alt=&#34;npm&#34; src=&#34;https://img.shields.io/npm/dy/simsimd?label=JavaScript%20NPM%20installs&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://crates.io/crates/simsimd&#34;&gt; &lt;img alt=&#34;rust&#34; src=&#34;https://img.shields.io/crates/d/simsimd?label=Rust%20Crate%20installs&#34;&gt; &lt;/a&gt; &#xA; &lt;img alt=&#34;GitHub code size in bytes&#34; src=&#34;https://img.shields.io/github/languages/code-size/ashvardanian/simsimd&#34;&gt; &#xA; &lt;a href=&#34;https://github.com/ashvardanian/SimSIMD/actions/workflows/release.yml&#34;&gt; &lt;img alt=&#34;GitHub Actions Ubuntu&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/ashvardanian/SimSIMD/release.yml?branch=main&amp;amp;label=Ubuntu&amp;amp;logo=github&amp;amp;color=blue&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://github.com/ashvardanian/SimSIMD/actions/workflows/release.yml&#34;&gt; &lt;img alt=&#34;GitHub Actions Windows&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/ashvardanian/SimSIMD/release.yml?branch=main&amp;amp;label=Windows&amp;amp;logo=windows&amp;amp;color=blue&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://github.com/ashvardanian/SimSIMD/actions/workflows/release.yml&#34;&gt; &lt;img alt=&#34;GitHub Actions MacOS&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/ashvardanian/SimSIMD/release.yml?branch=main&amp;amp;label=MacOS&amp;amp;logo=apple&amp;amp;color=blue&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://github.com/ashvardanian/SimSIMD/actions/workflows/release.yml&#34;&gt; &lt;img alt=&#34;GitHub Actions CentOS Linux&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/ashvardanian/SimSIMD/release.yml?branch=main&amp;amp;label=CentOS&amp;amp;logo=centos&amp;amp;color=blue&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;SimSIMD&lt;/strong&gt; (Arabic: &#34;ÿ≥ŸäŸÖÿ≥ŸäŸÖ ÿØŸä&#34;) is a mixed-precision math library of &lt;strong&gt;over 350 SIMD-optimized kernels&lt;/strong&gt; extensively used in AI, Search, and DBMS workloads. Named after the iconic &lt;a href=&#34;https://en.wikipedia.org/wiki/Open_sesame&#34;&gt;&#34;Open Sesame&#34;&lt;/a&gt; command that opened doors to treasure in &lt;em&gt;Ali Baba and the Forty Thieves&lt;/em&gt;, SimSimd can help you 10x the cost-efficiency of your computational pipelines. Implemented distance functions include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Euclidean (L2) and Cosine (Angular) spatial distances for Vector Search. &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#cosine-similarity-reciprocal-square-root-and-newton-raphson-iteration&#34;&gt;docs&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Dot-Products for real &amp;amp; complex vectors for DSP &amp;amp; Quantum computing. &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#complex-dot-products-conjugate-dot-products-and-complex-numbers&#34;&gt;docs&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Hamming (~ Manhattan) and Jaccard (~ Tanimoto) bit-level distances. &lt;em&gt;&lt;a href=&#34;https://github.com/ashvardanian/SimSIMD/pull/138&#34;&gt;docs&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Set Intersections for Sparse Vectors and Text Analysis. &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#set-intersection-galloping-and-binary-search&#34;&gt;docs&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Mahalanobis distance and Quadratic forms for Scientific Computing. &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#curved-spaces-mahalanobis-distance-and-bilinear-quadratic-forms&#34;&gt;docs&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Kullback-Leibler and Jensen‚ÄìShannon divergences for probability distributions. &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#logarithms-in-kullback-leibler--jensenshannon-divergences&#34;&gt;docs&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fused-Multiply-Add (FMA) and Weighted Sums to replace BLAS level 1 functions. &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#mixed-precision-in-fused-multiply-add-and-weighted-sums&#34;&gt;docs&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;For Levenshtein, Needleman‚ÄìWunsch, and Smith-Waterman, check &lt;a href=&#34;https://github.com/ashvardanian/stringzilla&#34;&gt;StringZilla&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;üîú Haversine and Vincenty&#39;s formulae for Geospatial Analysis.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Moreover, SimSIMD...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;handles &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float16&lt;/code&gt;, and &lt;code&gt;bfloat16&lt;/code&gt; real &amp;amp; complex vectors.&lt;/li&gt; &#xA; &lt;li&gt;handles &lt;code&gt;int8&lt;/code&gt; integral, &lt;code&gt;int4&lt;/code&gt; sub-byte, and &lt;code&gt;b8&lt;/code&gt; binary vectors.&lt;/li&gt; &#xA; &lt;li&gt;handles sparse &lt;code&gt;uint32&lt;/code&gt; and &lt;code&gt;uint16&lt;/code&gt; sets, and weighted sparse vectors.&lt;/li&gt; &#xA; &lt;li&gt;is a zero-dependency &lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#using-simsimd-in-c&#34;&gt;header-only C 99&lt;/a&gt; library.&lt;/li&gt; &#xA; &lt;li&gt;has &lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#using-simsimd-in-python&#34;&gt;Python&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#using-simsimd-in-rust&#34;&gt;Rust&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#using-simsimd-in-javascript&#34;&gt;JS&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#using-simsimd-in-swift&#34;&gt;Swift&lt;/a&gt; bindings.&lt;/li&gt; &#xA; &lt;li&gt;has Arm backends for NEON, Scalable Vector Extensions (SVE), and SVE2.&lt;/li&gt; &#xA; &lt;li&gt;has x86 backends for Haswell, Skylake, Ice Lake, Genoa, and Sapphire Rapids.&lt;/li&gt; &#xA; &lt;li&gt;with both compile-time and runtime CPU feature detection easily integrates anywhere!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Due to the high-level of fragmentation of SIMD support in different x86 CPUs, SimSIMD generally uses the names of select Intel CPU generations for its backends. They, however, also work on AMD CPUs. Intel Haswell is compatible with AMD Zen 1/2/3, while AMD Genoa Zen 4 covers AVX-512 instructions added to Intel Skylake and Ice Lake. You can learn more about the technical implementation details in the following blog-posts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ashvardanian.com/posts/gcc-12-vs-avx512fp16/&#34;&gt;Uses Horner&#39;s method for polynomial approximations, beating GCC 12 by 119x&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ashvardanian.com/posts/simsimd-faster-scipy/#tails-of-the-past-the-significance-of-masked-loads&#34;&gt;Uses Arm SVE and x86 AVX-512&#39;s masked loads to eliminate tail &lt;code&gt;for&lt;/code&gt;-loops&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ashvardanian/SimSIMD/releases/tag/v5.4.0&#34;&gt;Substitutes LibC&#39;s &lt;code&gt;sqrt&lt;/code&gt; with Newton Raphson iterations&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ashvardanian.com/posts/simd-set-intersections-sve2-avx512/&#34;&gt;Uses Galloping and SVE2 histograms to intersect sparse vectors&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For Python: &lt;a href=&#34;https://ashvardanian.com/posts/pybind11-cpython-tutorial/&#34;&gt;avoids slow PyBind11, SWIG, &amp;amp; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; &lt;a href=&#34;https://ashvardanian.com/posts/discount-on-keyword-arguments-in-python/&#34;&gt;using faster calling convention&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For JavaScript: &lt;a href=&#34;https://ashvardanian.com/posts/javascript-ai-vector-search/&#34;&gt;uses typed arrays and NAPI for zero-copy calls&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;table style=&#34;width: 100%; text-align: center; table-layout: fixed;&#34;&gt; &#xA; &lt;colgroup&gt; &#xA;  &lt;col style=&#34;width: 33%;&#34;&gt; &#xA;  &lt;col style=&#34;width: 33%;&#34;&gt; &#xA;  &lt;col style=&#34;width: 33%;&#34;&gt; &#xA; &lt;/colgroup&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;NumPy&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;C 99&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;SimSIMD&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;!-- Cosine distances with different precision levels --&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;cosine distances between 1536d vectors in &lt;code&gt;int8&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.cosine --&gt; üöß overflows&lt;br&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;10,548,600&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;11,379,300&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;16,151,800&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;13,524,000&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;cosine distances between 1536d vectors in &lt;code&gt;bfloat16&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.cosine --&gt; üöß not supported&lt;br&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;119,835&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;403,909&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;9,738,540&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;4,881,900&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;cosine distances between 1536d vectors in &lt;code&gt;float16&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.cosine --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;40,481&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;21,451&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;501,310&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;871,963&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;7,627,600&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;3,316,810&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;cosine distances between 1536d vectors in &lt;code&gt;float32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.cosine --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;253,902&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;46,394&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;882,484&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;399,661&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;8,202,910&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;3,400,620&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;cosine distances between 1536d vectors in &lt;code&gt;float64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.cosine --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;212,421&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;52,904&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;839,301&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;837,126&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;1,538,530&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;1,678,920&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;!-- Euclidean distance with different precision level --&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;eculidean distance between 1536d vectors in &lt;code&gt;int8&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.sqeuclidean --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;252,113&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;177,443&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;6,690,110&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;4,114,160&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;18,989,000&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;18,878,200&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;eculidean distance between 1536d vectors in &lt;code&gt;bfloat16&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.sqeuclidean --&gt; üöß not supported&lt;br&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;119,842&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;1,049,230&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;9,727,210&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;4,233,420&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;eculidean distance between 1536d vectors in &lt;code&gt;float16&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.sqeuclidean --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;54,621&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;71,793&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;196,413&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;911,370&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;19,466,800&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;3,522,760&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;eculidean distance between 1536d vectors in &lt;code&gt;float32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.sqeuclidean --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;424,944&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;292,629&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;1,295,210&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;1,055,940&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;8,924,100&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;3,602,650&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td colspan=&#34;4&#34; align=&#34;center&#34;&gt;eculidean distance between 1536d vectors in &lt;code&gt;float64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- scipy.spatial.distance.sqeuclidean --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;334,929&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;237,505&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- serial --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;1,215,190&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;905,782&lt;/b&gt; ops/s &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &#xA;    &lt;!-- simsimd --&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;x86:&lt;/span&gt; &lt;b&gt;1,701,740&lt;/b&gt; ops/s&lt;br&gt; &lt;span style=&#34;color:#ABABAB;&#34;&gt;arm:&lt;/span&gt; &lt;b&gt;1,735,840&lt;/b&gt; ops/s &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;!-- Bilinear forms --&gt; &#xA;  &lt;!-- Sparse set intersections --&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For benchmarks we mostly use 1536-dimensional vectors, like the embeddings produced by the OpenAI Ada API. The code was compiled with GCC 12, using glibc v2.35. The benchmarks performed on Arm-based Graviton3 AWS &lt;code&gt;c7g&lt;/code&gt; instances and &lt;code&gt;r7iz&lt;/code&gt; Intel Sapphire Rapids. Most modern Arm-based 64-bit CPUs will have similar relative speedups. Variance withing x86 CPUs will be larger.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Similar speedups are often observed even when compared to BLAS and LAPACK libraries underlying most numerical computing libraries, including NumPy and SciPy in Python. Broader benchmarking results:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ashvardanian.com/posts/simsimd-faster-scipy/#appendix-1-performance-on-apple-m2-pro&#34;&gt;Apple M2 Pro&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ashvardanian.com/posts/simsimd-faster-scipy/#appendix-2-performance-on-4th-gen-intel-xeon-platinum-8480&#34;&gt;Intel Sapphire Rapids&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ashvardanian.com/posts/simsimd-faster-scipy/#appendix-3-performance-on-aws-graviton-3&#34;&gt;AWS Graviton 3&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Using SimSIMD in Python&lt;/h2&gt; &#xA;&lt;p&gt;The package is intended to replace the usage of &lt;code&gt;numpy.inner&lt;/code&gt;, &lt;code&gt;numpy.dot&lt;/code&gt;, and &lt;code&gt;scipy.spatial.distance&lt;/code&gt;. Aside from drastic performance improvements, SimSIMD significantly improves accuracy in mixed precision setups. NumPy and SciPy, processing &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt; or &lt;code&gt;float16&lt;/code&gt; vectors, will use the same types for accumulators, while SimSIMD can combine &lt;code&gt;int8&lt;/code&gt; enumeration, &lt;code&gt;int16&lt;/code&gt; multiplication, and &lt;code&gt;int32&lt;/code&gt; accumulation to avoid overflows entirely. The same applies to processing &lt;code&gt;float16&lt;/code&gt; and &lt;code&gt;bfloat16&lt;/code&gt; values with &lt;code&gt;float32&lt;/code&gt; precision.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Use the following snippet to install SimSIMD and list available hardware acceleration options available on your machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pip install simsimd&#xA;python -c &#34;import simsimd; print(simsimd.get_capabilities())&#34;   # for hardware introspection&#xA;python -c &#34;import simsimd; help(simsimd)&#34;                       # for documentation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With precompiled binaries, SimSIMD ships &lt;code&gt;.pyi&lt;/code&gt; interface files for type hinting and static analysis. You can check all the available functions in &lt;a href=&#34;https://github.com/ashvardanian/SimSIMD/raw/main/python/annotations/__init__.pyi&#34;&gt;&lt;code&gt;python/annotations/__init__.pyi&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;One-to-One Distance&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import simsimd&#xA;import numpy as np&#xA;&#xA;vec1 = np.random.randn(1536).astype(np.float32)&#xA;vec2 = np.random.randn(1536).astype(np.float32)&#xA;dist = simsimd.cosine(vec1, vec2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported functions include &lt;code&gt;cosine&lt;/code&gt;, &lt;code&gt;inner&lt;/code&gt;, &lt;code&gt;sqeuclidean&lt;/code&gt;, &lt;code&gt;hamming&lt;/code&gt;, &lt;code&gt;jaccard&lt;/code&gt;, &lt;code&gt;kulbackleibler&lt;/code&gt;, &lt;code&gt;jensenshannon&lt;/code&gt;, and &lt;code&gt;intersect&lt;/code&gt;. Dot products are supported for both real and complex numbers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;vec1 = np.random.randn(768).astype(np.float64) + 1j * np.random.randn(768).astype(np.float64)&#xA;vec2 = np.random.randn(768).astype(np.float64) + 1j * np.random.randn(768).astype(np.float64)&#xA;&#xA;dist = simsimd.dot(vec1.astype(np.complex128), vec2.astype(np.complex128))&#xA;dist = simsimd.dot(vec1.astype(np.complex64), vec2.astype(np.complex64))&#xA;dist = simsimd.vdot(vec1.astype(np.complex64), vec2.astype(np.complex64)) # conjugate, same as `np.vdot`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike SciPy, SimSIMD allows explicitly stating the precision of the input vectors, which is especially useful for mixed-precision setups. The &lt;code&gt;dtype&lt;/code&gt; argument can be passed both by name and as a positional argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;dist = simsimd.cosine(vec1, vec2, &#34;int8&#34;)&#xA;dist = simsimd.cosine(vec1, vec2, &#34;float16&#34;)&#xA;dist = simsimd.cosine(vec1, vec2, &#34;float32&#34;)&#xA;dist = simsimd.cosine(vec1, vec2, &#34;float64&#34;)&#xA;dist = simsimd.hamming(vec1, vec2, &#34;bin8&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Binary distance functions are computed at a bit-level. Meaning a vector of 10x 8-bit integers will be treated as a sequence of 80 individual bits or dimensions. This differs from NumPy, that can&#39;t handle smaller-than-byte types, but you can still avoid the &lt;code&gt;bin8&lt;/code&gt; argument by reinterpreting the vector as booleans:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;vec1 = np.random.randint(2, size=80).astype(np.uint8).packbits().view(np.bool_)&#xA;vec2 = np.random.randint(2, size=80).astype(np.uint8).packbits().view(np.bool_)&#xA;hamming_distance = simsimd.hamming(vec1, vec2)&#xA;jaccard_distance = simsimd.jaccard(vec1, vec2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With other frameworks, like PyTorch, one can get a richer type-system than NumPy, but the lack of good CPython interoperability makes it hard to pass data without copies. Here is an example of using SimSIMD with PyTorch to compute the cosine similarity between two &lt;code&gt;bfloat16&lt;/code&gt; vectors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import numpy as np&#xA;buf1 = np.empty(8, dtype=np.uint16)&#xA;buf2 = np.empty(8, dtype=np.uint16)&#xA;&#xA;# View the same memory region with PyTorch and randomize it&#xA;import torch&#xA;vec1 = torch.asarray(memoryview(buf1), copy=False).view(torch.bfloat16)&#xA;vec2 = torch.asarray(memoryview(buf2), copy=False).view(torch.bfloat16)&#xA;torch.randn(8, out=vec1)&#xA;torch.randn(8, out=vec2)&#xA;&#xA;# Both libs will look into the same memory buffers and report the same results&#xA;dist_slow = 1 - torch.nn.functional.cosine_similarity(vec1, vec2, dim=0)&#xA;dist_fast = simsimd.cosine(buf1, buf2, &#34;bfloat16&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It also allows using SimSIMD for half-precision complex numbers, which NumPy does not support. For that, view data as continuous even-length &lt;code&gt;np.float16&lt;/code&gt; vectors and override type-resolution with &lt;code&gt;complex32&lt;/code&gt; string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;vec1 = np.random.randn(1536).astype(np.float16)&#xA;vec2 = np.random.randn(1536).astype(np.float16)&#xA;simd.dot(vec1, vec2, &#34;complex32&#34;)&#xA;simd.vdot(vec1, vec2, &#34;complex32&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When dealing with sparse representations and integer sets, you can apply the &lt;code&gt;intersect&lt;/code&gt; function to two 1-dimensional arrays of &lt;code&gt;uint16&lt;/code&gt; or &lt;code&gt;uint32&lt;/code&gt; integers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from random import randint&#xA;import numpy as np&#xA;import simsimd as simd&#xA;&#xA;length1, length2 = randint(1, 100), randint(1, 100)&#xA;vec1 = np.sort(np.random.randint(0, 1000, length1).astype(np.uint16))&#xA;vec2 = np.sort(np.random.randint(0, 1000, length2).astype(np.uint16))&#xA;&#xA;slow_result = len(np.intersect1d(vec1, vec2))&#xA;fast_result = simd.intersect(vec1, vec2)&#xA;assert slow_result == fast_result&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;One-to-Many Distances&lt;/h3&gt; &#xA;&lt;p&gt;Every distance function can be used not only for one-to-one but also one-to-many and many-to-many distance calculations. For one-to-many:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;vec1 = np.random.randn(1536).astype(np.float32) # rank 1 tensor&#xA;batch1 = np.random.randn(1, 1536).astype(np.float32) # rank 2 tensor&#xA;batch2 = np.random.randn(100, 1536).astype(np.float32)&#xA;&#xA;dist_rank1 = simsimd.cosine(vec1, batch2)&#xA;dist_rank2 = simsimd.cosine(batch1, batch2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Many-to-Many Distances&lt;/h3&gt; &#xA;&lt;p&gt;All distance functions in SimSIMD can be used to compute many-to-many distances. For two batches of 100 vectors to compute 100 distances, one would call it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;batch1 = np.random.randn(100, 1536).astype(np.float32)&#xA;batch2 = np.random.randn(100, 1536).astype(np.float32)&#xA;dist = simsimd.cosine(batch1, batch2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Input matrices must have identical shapes. This functionality isn&#39;t natively present in NumPy or SciPy, and generally requires creating intermediate arrays, which is inefficient and memory-consuming.&lt;/p&gt; &#xA;&lt;h3&gt;Many-to-Many All-Pairs Distances&lt;/h3&gt; &#xA;&lt;p&gt;One can use SimSIMD to compute distances between all possible pairs of rows across two matrices (akin to &lt;a href=&#34;https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html&#34;&gt;&lt;code&gt;scipy.spatial.distance.cdist&lt;/code&gt;&lt;/a&gt;). The resulting object will have a type &lt;code&gt;DistancesTensor&lt;/code&gt;, zero-copy compatible with NumPy and other libraries. For two arrays of 10 and 1,000 entries, the resulting tensor will have 10,000 cells:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import numpy as np&#xA;from simsimd import cdist, DistancesTensor&#xA;&#xA;matrix1 = np.random.randn(1000, 1536).astype(np.float32)&#xA;matrix2 = np.random.randn(10, 1536).astype(np.float32)&#xA;distances: DistancesTensor = simsimd.cdist(matrix1, matrix2, metric=&#34;cosine&#34;)   # zero-copy, managed by SimSIMD&#xA;distances_array: np.ndarray = np.array(distances, copy=True)                    # now managed by NumPy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Element-wise Kernels&lt;/h3&gt; &#xA;&lt;p&gt;SimSIMD also provides mixed-precision element-wise kernels, where the input vectors and the output have the same numeric type, but the intermediate accumulators are of a higher precision.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import numpy as np&#xA;from simsimd import fma, wsum&#xA;&#xA;# Let&#39;s take two FullHD video frames&#xA;first_frame = np.random.randn(1920 * 1024).astype(np.uint8)  &#xA;second_frame = np.random.randn(1920 * 1024).astype(np.uint8)&#xA;average_frame = np.empty_like(first_frame)&#xA;wsum(first_frame, second_frame, alpha=0.5, beta=0.5, out=average_frame)&#xA;&#xA;# Slow analog with NumPy:&#xA;slow_average_frame = (0.5 * first_frame + 0.5 * second_frame).astype(np.uint8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, the &lt;code&gt;fma&lt;/code&gt; takes three arguments and computes the fused multiply-add operation. In applications like Machine Learning you may also benefit from using the &#34;brain-float&#34; format not natively supported by NumPy. In 3D Graphics, for example, we can use FMA to compute the &lt;a href=&#34;https://en.wikipedia.org/wiki/Phong_shading&#34;&gt;Phong shading model&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# Assume a FullHD frame with random values for simplicity&#xA;light_intensity = np.random.rand(1920 * 1080).astype(np.float16)  # Intensity of light on each pixel&#xA;diffuse_component = np.random.rand(1920 * 1080).astype(np.float16)  # Diffuse reflectance on the surface&#xA;specular_component = np.random.rand(1920 * 1080).astype(np.float16)  # Specular reflectance for highlights&#xA;output_color = np.empty_like(light_intensity)  # Array to store the resulting color intensity&#xA;&#xA;# Define the scaling factors for diffuse and specular contributions&#xA;alpha = 0.7  # Weight for the diffuse component&#xA;beta = 0.3   # Weight for the specular component&#xA;&#xA;# Formula: color = alpha * light_intensity * diffuse_component + beta * specular_component&#xA;fma(light_intensity, diffuse_component, specular_component, &#xA;    dtype=&#34;float16&#34;, # Optional, unless it can&#39;t be inferred from the input&#xA;    alpha=alpha, beta=beta, out=output_color)&#xA;&#xA;# Slow analog with NumPy for comparison&#xA;slow_output_color = (alpha * light_intensity * diffuse_component + beta * specular_component).astype(np.float16)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multithreading and Memory Usage&lt;/h3&gt; &#xA;&lt;p&gt;By default, computations use a single CPU core. To override this behavior, use the &lt;code&gt;threads&lt;/code&gt; argument. Set it to &lt;code&gt;0&lt;/code&gt; to use all available CPU cores. Here is an example of dealing with large sets of binary vectors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;ndim = 1536 # OpenAI Ada embeddings&#xA;matrix1 = np.packbits(np.random.randint(2, size=(10_000, ndim)).astype(np.uint8))&#xA;matrix2 = np.packbits(np.random.randint(2, size=(1_000, ndim)).astype(np.uint8))&#xA;&#xA;distances = simsimd.cdist(matrix1, matrix2, &#xA;    metric=&#34;hamming&#34;,   # Unlike SciPy, SimSIMD doesn&#39;t divide by the number of dimensions&#xA;    out_dtype=&#34;uint8&#34;,  # so we can use `uint8` instead of `float64` to save memory.&#xA;    threads=0,          # Use all CPU cores with OpenMP.&#xA;    dtype=&#34;bin8&#34;,       # Override input argument type to `bin8` eight-bit words.&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the output distances will be stored in double-precision &lt;code&gt;float64&lt;/code&gt; floating-point numbers. That behavior may not be space-efficient, especially if you are computing the hamming distance between short binary vectors, that will generally fit into 8x smaller &lt;code&gt;uint8&lt;/code&gt; or &lt;code&gt;uint16&lt;/code&gt; types. To override this behavior, use the &lt;code&gt;dtype&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h3&gt;Helper Functions&lt;/h3&gt; &#xA;&lt;p&gt;You can turn specific backends on or off depending on the exact environment. A common case may be avoiding AVX-512 on older AMD CPUs and &lt;a href=&#34;https://travisdowns.github.io/blog/2020/08/19/icl-avx512-freq.html&#34;&gt;Intel Ice Lake&lt;/a&gt; CPUs to ensure the CPU doesn&#39;t change the frequency license and throttle performance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;$ simsimd.get_capabilities()&#xA;&amp;gt; {&#39;serial&#39;: True, &#39;neon&#39;: False, &#39;sve&#39;: False, &#39;neon_f16&#39;: False, &#39;sve_f16&#39;: False, &#39;neon_bf16&#39;: False, &#39;sve_bf16&#39;: False, &#39;neon_i8&#39;: False, &#39;sve_i8&#39;: False, &#39;haswell&#39;: True, &#39;skylake&#39;: True, &#39;ice&#39;: True, &#39;genoa&#39;: True, &#39;sapphire&#39;: True, &#39;turin&#39;: True}&#xA;$ simsimd.disable_capability(&#34;sapphire&#34;)&#xA;$ simsimd.enable_capability(&#34;sapphire&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using Python API with USearch&lt;/h3&gt; &#xA;&lt;p&gt;Want to use it in Python with &lt;a href=&#34;https://github.com/unum-cloud/usearch&#34;&gt;USearch&lt;/a&gt;? You can wrap the raw C function pointers SimSIMD backends into a &lt;code&gt;CompiledMetric&lt;/code&gt; and pass it to USearch, similar to how it handles Numba&#39;s JIT-compiled code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from usearch.index import Index, CompiledMetric, MetricKind, MetricSignature&#xA;from simsimd import pointer_to_sqeuclidean, pointer_to_cosine, pointer_to_inner&#xA;&#xA;metric = CompiledMetric(&#xA;    pointer=pointer_to_cosine(&#34;f16&#34;),&#xA;    kind=MetricKind.Cos,&#xA;    signature=MetricSignature.ArrayArraySize,&#xA;)&#xA;&#xA;index = Index(256, metric=metric)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using SimSIMD in Rust&lt;/h2&gt; &#xA;&lt;p&gt;To install, add the following to your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;simsimd = &#34;...&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before using the SimSIMD library, ensure you have imported the necessary traits and types into your Rust source file. The library provides several traits for different distance/similarity kinds - &lt;code&gt;SpatialSimilarity&lt;/code&gt;, &lt;code&gt;BinarySimilarity&lt;/code&gt;, and &lt;code&gt;ProbabilitySimilarity&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Spatial Similarity: Cosine and Euclidean Distances&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use simsimd::SpatialSimilarity;&#xA;&#xA;fn main() {&#xA;    let vector_a: Vec&amp;lt;f32&amp;gt; = vec![1.0, 2.0, 3.0];&#xA;    let vector_b: Vec&amp;lt;f32&amp;gt; = vec![4.0, 5.0, 6.0];&#xA;&#xA;    // Compute the cosine similarity between vector_a and vector_b&#xA;    let cosine_similarity = f32::cosine(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Cosine Similarity: {}&#34;, cosine_similarity);&#xA;&#xA;    // Compute the squared Euclidean distance between vector_a and vector_b&#xA;    let sq_euclidean_distance = f32::sqeuclidean(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Squared Euclidean Distance: {}&#34;, sq_euclidean_distance);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Spatial similarity functions are available for &lt;code&gt;f64&lt;/code&gt;, &lt;code&gt;f32&lt;/code&gt;, &lt;code&gt;f16&lt;/code&gt;, and &lt;code&gt;i8&lt;/code&gt; types.&lt;/p&gt; &#xA;&lt;h3&gt;Dot-Products: Inner and Complex Inner Products&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use simsimd::SpatialSimilarity;&#xA;use simsimd::ComplexProducts;&#xA;&#xA;fn main() {&#xA;    let vector_a: Vec&amp;lt;f32&amp;gt; = vec![1.0, 2.0, 3.0, 4.0];&#xA;    let vector_b: Vec&amp;lt;f32&amp;gt; = vec![5.0, 6.0, 7.0, 8.0];&#xA;&#xA;    // Compute the inner product between vector_a and vector_b&#xA;    let inner_product = SpatialSimilarity::dot(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Inner Product: {}&#34;, inner_product);&#xA;&#xA;    // Compute the complex inner product between complex_vector_a and complex_vector_b&#xA;    let complex_inner_product = ComplexProducts::dot(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    let complex_conjugate_inner_product = ComplexProducts::vdot(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Complex Inner Product: {:?}&#34;, complex_inner_product); // -18, 69&#xA;    println!(&#34;Complex C. Inner Product: {:?}&#34;, complex_conjugate_inner_product); // 70, -8&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Complex inner products are available for &lt;code&gt;f64&lt;/code&gt;, &lt;code&gt;f32&lt;/code&gt;, and &lt;code&gt;f16&lt;/code&gt; types.&lt;/p&gt; &#xA;&lt;h3&gt;Probability Distributions: Jensen-Shannon and Kullback-Leibler Divergences&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use simsimd::SpatialSimilarity;&#xA;&#xA;fn main() {&#xA;    let vector_a: Vec&amp;lt;f32&amp;gt; = vec![1.0, 2.0, 3.0];&#xA;    let vector_b: Vec&amp;lt;f32&amp;gt; = vec![4.0, 5.0, 6.0];&#xA;&#xA;    let cosine_similarity = f32::jensenshannon(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Cosine Similarity: {}&#34;, cosine_similarity);&#xA;&#xA;    let sq_euclidean_distance = f32::kullbackleibler(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Squared Euclidean Distance: {}&#34;, sq_euclidean_distance);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Probability similarity functions are available for &lt;code&gt;f64&lt;/code&gt;, &lt;code&gt;f32&lt;/code&gt;, and &lt;code&gt;f16&lt;/code&gt; types.&lt;/p&gt; &#xA;&lt;h3&gt;Binary Similarity: Hamming and Jaccard Distances&lt;/h3&gt; &#xA;&lt;p&gt;Similar to spatial distances, one can compute bit-level distance functions between slices of unsigned integers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use simsimd::BinarySimilarity;&#xA;&#xA;fn main() {&#xA;    let vector_a = &amp;amp;[0b11110000, 0b00001111, 0b10101010];&#xA;    let vector_b = &amp;amp;[0b11110000, 0b00001111, 0b01010101];&#xA;&#xA;    // Compute the Hamming distance between vector_a and vector_b&#xA;    let hamming_distance = u8::hamming(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Hamming Distance: {}&#34;, hamming_distance);&#xA;&#xA;    // Compute the Jaccard distance between vector_a and vector_b&#xA;    let jaccard_distance = u8::jaccard(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Jaccard Distance: {}&#34;, jaccard_distance);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Binary similarity functions are available only for &lt;code&gt;u8&lt;/code&gt; types.&lt;/p&gt; &#xA;&lt;h3&gt;Half-Precision Floating-Point Numbers&lt;/h3&gt; &#xA;&lt;p&gt;Rust has no native support for half-precision floating-point numbers, but SimSIMD provides a &lt;code&gt;f16&lt;/code&gt; type. It has no functionality - it is a &lt;code&gt;transparent&lt;/code&gt; wrapper around &lt;code&gt;u16&lt;/code&gt; and can be used with &lt;code&gt;half&lt;/code&gt; or any other half-precision library.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use simsimd::SpatialSimilarity;&#xA;use simsimd::f16 as SimF16;&#xA;use half::f16 as HalfF16;&#xA;&#xA;fn main() {&#xA;    let vector_a: Vec&amp;lt;HalfF16&amp;gt; = ...&#xA;    let vector_b: Vec&amp;lt;HalfF16&amp;gt; = ...&#xA;&#xA;    let buffer_a: &amp;amp;[SimF16] = unsafe { std::slice::from_raw_parts(a_half.as_ptr() as *const SimF16, a_half.len()) };&#xA;    let buffer_b: &amp;amp;[SimF16] = unsafe { std::slice::from_raw_parts(b_half.as_ptr() as *const SimF16, b_half.len()) };&#xA;&#xA;    // Compute the cosine similarity between vector_a and vector_b&#xA;    let cosine_similarity = SimF16::cosine(&amp;amp;vector_a, &amp;amp;vector_b)&#xA;        .expect(&#34;Vectors must be of the same length&#34;);&#xA;&#xA;    println!(&#34;Cosine Similarity: {}&#34;, cosine_similarity);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Half-Precision Brain-Float Numbers&lt;/h3&gt; &#xA;&lt;p&gt;The &#34;brain-float-16&#34; is a popular machine learning format. It&#39;s broadly supported in hardware and is very machine-friendly, but software support is still lagging behind. &lt;a href=&#34;https://github.com/numpy/numpy/issues/19808&#34;&gt;Unlike NumPy&lt;/a&gt;, you can already use &lt;code&gt;bf16&lt;/code&gt; datatype in SimSIMD. Luckily, to downcast &lt;code&gt;f32&lt;/code&gt; to &lt;code&gt;bf16&lt;/code&gt; you only have to drop the last 16 bits:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import numpy as np&#xA;import simsimd as simd&#xA;&#xA;a = np.random.randn(ndim).astype(np.float32)&#xA;b = np.random.randn(ndim).astype(np.float32)&#xA;&#xA;# NumPy doesn&#39;t natively support brain-float, so we need a trick!&#xA;# Luckily, it&#39;s very easy to reduce the representation accuracy&#xA;# by simply masking the low 16-bits of our 32-bit single-precision&#xA;# numbers. We can also add `0x8000` to round the numbers.&#xA;a_f32rounded = ((a.view(np.uint32) + 0x8000) &amp;amp; 0xFFFF0000).view(np.float32)&#xA;b_f32rounded = ((b.view(np.uint32) + 0x8000) &amp;amp; 0xFFFF0000).view(np.float32)&#xA;&#xA;# To represent them as brain-floats, we need to drop the second half&#xA;a_bf16 = np.right_shift(a_f32rounded.view(np.uint32), 16).astype(np.uint16)&#xA;b_bf16 = np.right_shift(b_f32rounded.view(np.uint32), 16).astype(np.uint16)&#xA;&#xA;# Now we can compare the results&#xA;expected = np.inner(a_f32rounded, b_f32rounded)&#xA;result = simd.inner(a_bf16, b_bf16, &#34;bf16&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic Dispatch in Rust&lt;/h3&gt; &#xA;&lt;p&gt;SimSIMD provides a &lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#dynamic-dispatch&#34;&gt;dynamic dispatch&lt;/a&gt; mechanism to select the most advanced micro-kernel for the current CPU. You can query supported backends and use the &lt;code&gt;SimSIMD::capabilities&lt;/code&gt; function to select the best one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;println!(&#34;uses neon: {}&#34;, capabilities::uses_neon());&#xA;println!(&#34;uses sve: {}&#34;, capabilities::uses_sve());&#xA;println!(&#34;uses haswell: {}&#34;, capabilities::uses_haswell());&#xA;println!(&#34;uses skylake: {}&#34;, capabilities::uses_skylake());&#xA;println!(&#34;uses ice: {}&#34;, capabilities::uses_ice());&#xA;println!(&#34;uses genoa: {}&#34;, capabilities::uses_genoa());&#xA;println!(&#34;uses sapphire: {}&#34;, capabilities::uses_sapphire());&#xA;println!(&#34;uses turin: {}&#34;, capabilities::uses_turin());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using SimSIMD in JavaScript&lt;/h2&gt; &#xA;&lt;p&gt;To install, choose one of the following options depending on your environment:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;npm install --save simsimd&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;yarn add simsimd&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pnpm add simsimd&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bun install simsimd&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The package is distributed with prebuilt binaries, but if your platform is not supported, you can build the package from the source via &lt;code&gt;npm run build&lt;/code&gt;. This will automatically happen unless you install the package with the &lt;code&gt;--ignore-scripts&lt;/code&gt; flag or use Bun. After you install it, you will be able to call the SimSIMD functions on various &lt;code&gt;TypedArray&lt;/code&gt; variants:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const { sqeuclidean, cosine, inner, hamming, jaccard } = require(&#39;simsimd&#39;);&#xA;&#xA;const vectorA = new Float32Array([1.0, 2.0, 3.0]);&#xA;const vectorB = new Float32Array([4.0, 5.0, 6.0]);&#xA;&#xA;const distance = sqeuclidean(vectorA, vectorB);&#xA;console.log(&#39;Squared Euclidean Distance:&#39;, distance);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other numeric types and precision levels are supported as well. For double-precision floating-point numbers, use &lt;code&gt;Float64Array&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const vectorA = new Float64Array([1.0, 2.0, 3.0]);&#xA;const vectorB = new Float64Array([4.0, 5.0, 6.0]);&#xA;const distance = cosine(vectorA, vectorB);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When doing machine learning and vector search with high-dimensional vectors you may want to quantize them to 8-bit integers. You may want to project values from the $[-1, 1]$ range to the $[-127, 127]$ range and then cast them to &lt;code&gt;Int8Array&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const quantizedVectorA = new Int8Array(vectorA.map(v =&amp;gt; (v * 127)));&#xA;const quantizedVectorB = new Int8Array(vectorB.map(v =&amp;gt; (v * 127)));&#xA;const distance = cosine(quantizedVectorA, quantizedVectorB);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A more extreme quantization case would be to use binary vectors. You can map all positive values to &lt;code&gt;1&lt;/code&gt; and all negative values and zero to &lt;code&gt;0&lt;/code&gt;, packing eight values into a single byte. After that, Hamming and Jaccard distances can be computed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const { toBinary, hamming } = require(&#39;simsimd&#39;);&#xA;&#xA;const binaryVectorA = toBinary(vectorA);&#xA;const binaryVectorB = toBinary(vectorB);&#xA;const distance = hamming(binaryVectorA, binaryVectorB);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using SimSIMD in Sift&lt;/h2&gt; &#xA;&lt;p&gt;To install, simply add the following dependency to you &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/ashvardanian/simsimd&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The package provides the most common spatial metrics for &lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Float16&lt;/code&gt;, &lt;code&gt;Float32&lt;/code&gt;, and &lt;code&gt;Float64&lt;/code&gt; vectors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SimSIMD&#xA;&#xA;let vectorA: [Int8] = [1, 2, 3]&#xA;let vectorB: [Int8] = [4, 5, 6]&#xA;&#xA;let cosineSimilarity = vectorA.cosine(vectorB)  // Computes the cosine similarity&#xA;let dotProduct = vectorA.dot(vectorB)           // Computes the dot product&#xA;let sqEuclidean = vectorA.sqeuclidean(vectorB)  // Computes the squared Euclidean distance&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using SimSIMD in C&lt;/h2&gt; &#xA;&lt;p&gt;For integration within a CMake-based project, add the following segment to your &lt;code&gt;CMakeLists.txt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;FetchContent_Declare(&#xA;    simsimd&#xA;    GIT_REPOSITORY https://github.com/ashvardanian/simsimd.git&#xA;    GIT_SHALLOW TRUE&#xA;)&#xA;FetchContent_MakeAvailable(simsimd)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that, you can use the SimSIMD library in your C code in several ways. Simplest of all, you can include the headers, and the compiler will automatically select the most recent CPU extensions that SimSIMD will use.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;simsimd/simsimd.h&amp;gt;&#xA;&#xA;int main() {&#xA;    simsimd_f32_t vector_a[1536];&#xA;    simsimd_f32_t vector_b[1536];&#xA;    simsimd_kernel_punned_t distance_function = simsimd_metric_punned(&#xA;        simsimd_metric_cos_k,   // Metric kind, like the angular cosine distance&#xA;        simsimd_datatype_f32_k, // Data type, like: f16, f32, f64, i8, b8, and complex variants&#xA;        simsimd_cap_any_k);     // Which CPU capabilities are we allowed to use&#xA;    simsimd_distance_t distance;&#xA;    distance_function(vector_a, vector_b, 1536, &amp;amp;distance);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic Dispatch in C&lt;/h3&gt; &#xA;&lt;p&gt;To avoid hard-coding the backend, you can rely on &lt;code&gt;c/lib.c&lt;/code&gt; to prepackage all possible backends in one binary, and select the most recent CPU features at runtime. That feature of the C library is called &lt;a href=&#34;https://raw.githubusercontent.com/ashvardanian/SimSIMD/main/#dynamic-dispatch&#34;&gt;dynamic dispatch&lt;/a&gt; and is extensively used in the Python, JavaScript, and Rust bindings. To test which CPU features are available on the machine at runtime, use the following APIs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int uses_dynamic_dispatch = simsimd_uses_dynamic_dispatch(); // Check if dynamic dispatch was enabled&#xA;simsimd_capability_t capabilities = simsimd_capabilities();  // Returns a bitmask&#xA;&#xA;int uses_neon = simsimd_uses_neon();&#xA;int uses_sve = simsimd_uses_sve();&#xA;int uses_haswell = simsimd_uses_haswell();&#xA;int uses_skylake = simsimd_uses_skylake();&#xA;int uses_ice = simsimd_uses_ice();&#xA;int uses_genoa = simsimd_uses_genoa();&#xA;int uses_sapphire = simsimd_uses_sapphire();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To override compilation settings and switch between runtime and compile-time dispatch, define the following macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define SIMSIMD_DYNAMIC_DISPATCH 1 // or 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Spatial Distances: Cosine and Euclidean Distances&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;simsimd/simsimd.h&amp;gt;&#xA;&#xA;int main() {&#xA;    simsimd_i8_t i8[1536];&#xA;    simsimd_i8_t u8[1536];&#xA;    simsimd_f64_t f64s[1536];&#xA;    simsimd_f32_t f32s[1536];&#xA;    simsimd_f16_t f16s[1536];&#xA;    simsimd_bf16_t bf16s[1536];&#xA;    simsimd_distance_t distance;&#xA;&#xA;    // Cosine distance between two vectors&#xA;    simsimd_cos_i8(i8s, i8s, 1536, &amp;amp;distance);&#xA;    simsimd_cos_u8(u8s, u8s, 1536, &amp;amp;distance);&#xA;    simsimd_cos_f16(f16s, f16s, 1536, &amp;amp;distance);&#xA;    simsimd_cos_f32(f32s, f32s, 1536, &amp;amp;distance);&#xA;    simsimd_cos_f64(f64s, f64s, 1536, &amp;amp;distance);&#xA;    simsimd_cos_bf16(bf16s, bf16s, 1536, &amp;amp;distance);&#xA;    &#xA;    // Euclidean distance between two vectors&#xA;    simsimd_l2sq_i8(i8s, i8s, 1536, &amp;amp;distance);&#xA;    simsimd_l2sq_u8(u8s, u8s, 1536, &amp;amp;distance);&#xA;    simsimd_l2sq_f16(f16s, f16s, 1536, &amp;amp;distance);&#xA;    simsimd_l2sq_f32(f32s, f32s, 1536, &amp;amp;distance);&#xA;    simsimd_l2sq_f64(f64s, f64s, 1536, &amp;amp;distance);&#xA;    simsimd_l2sq_bf16(bf16s, bf16s, 1536, &amp;amp;distance);&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dot-Products: Inner and Complex Inner Products&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;simsimd/simsimd.h&amp;gt;&#xA;&#xA;int main() {&#xA;    // SimSIMD provides &#34;sized&#34; type-aliases without relying on `stdint.h`&#xA;    simsimd_i8_t i8[1536];&#xA;    simsimd_i8_t u8[1536];&#xA;    simsimd_f16_t f16s[1536];&#xA;    simsimd_f32_t f32s[1536];&#xA;    simsimd_f64_t f64s[1536];&#xA;    simsimd_bf16_t bf16s[1536];&#xA;    simsimd_distance_t product;&#xA;&#xA;    // Inner product between two real vectors&#xA;    simsimd_dot_i8(i8s, i8s, 1536, &amp;amp;product);&#xA;    simsimd_dot_u8(u8s, u8s, 1536, &amp;amp;product);&#xA;    simsimd_dot_f16(f16s, f16s, 1536, &amp;amp;product);&#xA;    simsimd_dot_f32(f32s, f32s, 1536, &amp;amp;product);&#xA;    simsimd_dot_f64(f64s, f64s, 1536, &amp;amp;product);&#xA;    simsimd_dot_bf16(bf16s, bf16s, 1536, &amp;amp;product);&#xA;&#xA;    // SimSIMD provides complex types with `real` and `imag` fields&#xA;    simsimd_f64c_t f64s[768];&#xA;    simsimd_f32c_t f32s[768];&#xA;    simsimd_f16c_t f16s[768];&#xA;    simsimd_bf16c_t bf16s[768];&#xA;    simsimd_distance_t products[2]; // real and imaginary parts&#xA;&#xA;    // Complex inner product between two vectors&#xA;    simsimd_dot_f16c(f16cs, f16cs, 768, &amp;amp;products[0]);&#xA;    simsimd_dot_f32c(f32cs, f32cs, 768, &amp;amp;products[0]);&#xA;    simsimd_dot_f64c(f64cs, f64cs, 768, &amp;amp;products[0]);&#xA;    simsimd_dot_bf16c(bf16cs, bf16cs, 768, &amp;amp;products[0]);&#xA;&#xA;    // Complex conjugate inner product between two vectors&#xA;    simsimd_vdot_f16c(f16cs, f16cs, 768, &amp;amp;products[0]);&#xA;    simsimd_vdot_f32c(f32cs, f32cs, 768, &amp;amp;products[0]);&#xA;    simsimd_vdot_f64c(f64cs, f64cs, 768, &amp;amp;products[0]);&#xA;    simsimd_vdot_bf16c(bf16cs, bf16cs, 768, &amp;amp;products[0]);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Binary Distances: Hamming and Jaccard Distances&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;simsimd/simsimd.h&amp;gt;&#xA;&#xA;int main() {&#xA;    simsimd_b8_t b8s[1536 / 8]; // 8 bits per word&#xA;    simsimd_distance_t distance;&#xA;    simsimd_hamming_b8(b8s, b8s, 1536 / 8, &amp;amp;distance);&#xA;    simsimd_jaccard_b8(b8s, b8s, 1536 / 8, &amp;amp;distance);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Probability Distributions: Jensen-Shannon and Kullback-Leibler Divergences&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;simsimd/simsimd.h&amp;gt;&#xA;&#xA;int main() {&#xA;    simsimd_f64_t f64s[1536];&#xA;    simsimd_f32_t f32s[1536];&#xA;    simsimd_f16_t f16s[1536];&#xA;    simsimd_distance_t divergence;&#xA;&#xA;    // Jensen-Shannon divergence between two vectors&#xA;    simsimd_js_f16(f16s, f16s, 1536, &amp;amp;divergence);&#xA;    simsimd_js_f32(f32s, f32s, 1536, &amp;amp;divergence);&#xA;    simsimd_js_f64(f64s, f64s, 1536, &amp;amp;divergence);&#xA;&#xA;    // Kullback-Leibler divergence between two vectors&#xA;    simsimd_kl_f16(f16s, f16s, 1536, &amp;amp;divergence);&#xA;    simsimd_kl_f32(f32s, f32s, 1536, &amp;amp;divergence);&#xA;    simsimd_kl_f64(f64s, f64s, 1536, &amp;amp;divergence);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Half-Precision Floating-Point Numbers&lt;/h3&gt; &#xA;&lt;p&gt;If you aim to utilize the &lt;code&gt;_Float16&lt;/code&gt; functionality with SimSIMD, ensure your development environment is compatible with C 11. For other SimSIMD functionalities, C 99 compatibility will suffice. To explicitly disable half-precision support, define the following macro before imports:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define SIMSIMD_NATIVE_F16 0 // or 1&#xA;#define SIMSIMD_NATIVE_BF16 0 // or 1&#xA;#include &amp;lt;simsimd/simsimd.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compilation Settings and Debugging&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;SIMSIMD_DYNAMIC_DISPATCH&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;By default, SimSIMD is a header-only library. But if you are running on different generations of devices, it makes sense to pre-compile the library for all supported generations at once, and dispatch at runtime. This flag does just that and is used to produce the &lt;code&gt;simsimd.so&lt;/code&gt; shared library, as well as the Python and other bindings.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For Arm: &lt;code&gt;SIMSIMD_TARGET_NEON&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_SVE&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_SVE2&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_NEON_F16&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_SVE_F16&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_NEON_BF16&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_SVE_BF16&lt;/code&gt;. For x86: (&lt;code&gt;SIMSIMD_TARGET_HASWELL&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_SKYLAKE&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_ICE&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_GENOA&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_SAPPHIRE&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_TURIN&lt;/code&gt;, &lt;code&gt;SIMSIMD_TARGET_SIERRA&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;By default, SimSIMD automatically infers the target architecture and pre-compiles as many kernels as possible. In some cases, you may want to explicitly disable some of the kernels. Most often it&#39;s due to compiler support issues, like the lack of some recent intrinsics or low-precision numeric types. In other cases, you may want to disable some kernels to speed up the compilation process and trim the binary size.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;SIMSIMD_SQRT&lt;/code&gt;, &lt;code&gt;SIMSIMD_RSQRT&lt;/code&gt;, &lt;code&gt;SIMSIMD_LOG&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;By default, for &lt;strong&gt;non&lt;/strong&gt;-SIMD backends, SimSIMD may use &lt;code&gt;libc&lt;/code&gt; functions like &lt;code&gt;sqrt&lt;/code&gt; and &lt;code&gt;log&lt;/code&gt;. Those are generally very accurate, but slow, and introduce a dependency on the C standard library. To avoid that you can override those definitions with your custom implementations, like: &lt;code&gt;#define SIMSIMD_RSQRT(x) (1 / sqrt(x))&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Algorithms &amp;amp; Design Decisions üìö&lt;/h2&gt; &#xA;&lt;p&gt;In general there are a few principles that SimSIMD follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Avoid loop unrolling.&lt;/li&gt; &#xA; &lt;li&gt;Never allocate memory.&lt;/li&gt; &#xA; &lt;li&gt;Never throw exceptions or set &lt;code&gt;errno&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Keep all function arguments the size of the pointer.&lt;/li&gt; &#xA; &lt;li&gt;Avoid returning from public interfaces, use out-arguments instead.&lt;/li&gt; &#xA; &lt;li&gt;Don&#39;t over-optimize for old CPUs and single- and double-precision floating-point numbers.&lt;/li&gt; &#xA; &lt;li&gt;Prioritize mixed-precision and integer operations, and new ISA extensions.&lt;/li&gt; &#xA; &lt;li&gt;Prefer saturated arithmetic and avoid overflows.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Possibly, in the future:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Best effort computation silencing &lt;code&gt;NaN&lt;/code&gt; components in low-precision inputs.&lt;/li&gt; &#xA; &lt;li&gt;Detect overflows and report the distance with a &#34;signaling&#34; &lt;code&gt;NaN&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Last, but not the least - don&#39;t build unless there is a demand for it. So if you have a specific use-case, please open an issue or a pull request, and ideally, bring in more users with similar needs.&lt;/p&gt; &#xA;&lt;h3&gt;Cosine Similarity, Reciprocal Square Root, and Newton-Raphson Iteration&lt;/h3&gt; &#xA;&lt;p&gt;The cosine similarity is the most common and straightforward metric used in machine learning and information retrieval. Interestingly, there are multiple ways to shoot yourself in the foot when computing it. The cosine similarity is the inverse of the cosine distance, which is the cosine of the angle between two vectors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{CosineSimilarity}(a, b) = \frac{a \cdot b}{\|a\| \cdot \|b\|}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{CosineDistance}(a, b) = 1 - \frac{a \cdot b}{\|a\| \cdot \|b\|}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In NumPy terms, SimSIMD implementation is similar to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np&#xA;&#xA;def cos_numpy(a: np.ndarray, b: np.ndarray) -&amp;gt; float:&#xA;    ab, a2, b2 = np.dot(a, b), np.dot(a, a), np.dot(b, b) # Fused in SimSIMD&#xA;    if a2 == 0 and b2 == 0: result = 0                    # Same in SciPy&#xA;    elif ab == 0: result = 1                              # Division by zero error in SciPy&#xA;    else: result = 1 - ab / (sqrt(a2) * sqrt(b2))         # Bigger rounding error in SciPy&#xA;    return result&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In SciPy, however, the cosine distance is computed as &lt;code&gt;1 - ab / np.sqrt(a2 * b2)&lt;/code&gt;. It handles the edge case of a zero and non-zero argument pair differently, resulting in a division by zero error. It&#39;s not only less efficient, but also less accurate, given how the reciprocal square roots are computed. The C standard library provides the &lt;code&gt;sqrt&lt;/code&gt; function, which is generally very accurate, but slow. The &lt;code&gt;rsqrt&lt;/code&gt; in-hardware implementations are faster, but have different accuracy characteristics.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SSE &lt;code&gt;rsqrtps&lt;/code&gt; and AVX &lt;code&gt;vrsqrtps&lt;/code&gt;: $1.5 \times 2^{-12}$ maximal relative error.&lt;/li&gt; &#xA; &lt;li&gt;AVX-512 &lt;code&gt;vrsqrt14pd&lt;/code&gt; instruction: $2^{-14}$ maximal relative error.&lt;/li&gt; &#xA; &lt;li&gt;NEON &lt;code&gt;frsqrte&lt;/code&gt; instruction has no documented error bounds, but &lt;a href=&#34;https://gist.github.com/ashvardanian/5e5cf585d63f8ab6d240932313c75411&#34;&gt;can be&lt;/a&gt; $2^{-3}$.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To overcome the limitations of the &lt;code&gt;rsqrt&lt;/code&gt; instruction, SimSIMD uses the Newton-Raphson iteration to refine the initial estimate for high-precision floating-point numbers. It can be defined as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;x_{n+1} = x_n \cdot (3 - x_n \cdot x_n) / 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On 1536-dimensional inputs on Intel Sapphire Rapids CPU a single such iteration can result in a 2-3 orders of magnitude relative error reduction:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Datatype&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;NumPy Error&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;SimSIMD w/out Iteration&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;SimSIMD&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;bfloat16&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1.89e-08 ¬± 1.59e-08&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.07e-07 ¬± 3.09e-07&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.53e-09 ¬± 2.70e-09&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;float16&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1.67e-02 ¬± 1.44e-02&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2.68e-05 ¬± 1.95e-05&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2.02e-05 ¬± 1.39e-05&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2.21e-08 ¬± 1.65e-08&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.47e-07 ¬± 3.49e-07&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.77e-09 ¬± 2.84e-09&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0.00e+00 ¬± 0.00e+00&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.80e-07 ¬± 4.50e-07&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1.35e-11 ¬± 1.85e-11&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Curved Spaces, Mahalanobis Distance, and Bilinear Quadratic Forms&lt;/h3&gt; &#xA;&lt;p&gt;The Mahalanobis distance is a generalization of the Euclidean distance, which takes into account the covariance of the data. It&#39;s very similar in its form to the bilinear form, which is a generalization of the dot product.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{BilinearForm}(a, b, M) = a^T M b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{Mahalanobis}(a, b, M) = \sqrt{(a - b)^T M^{-1} (a - b)}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Bilinear Forms can be seen as one of the most important linear algebraic operations, surprisingly missing in BLAS and LAPACK. They are versatile and appear in various domains:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In Quantum Mechanics, the expectation value of an observable $A$ in a state $\psi$ is given by $\langle \psi | A | \psi \rangle$, which is a bilinear form.&lt;/li&gt; &#xA; &lt;li&gt;In Machine Learning, in Support Vector Machines (SVMs), bilinear forms define kernel functions that measure similarity between data points.&lt;/li&gt; &#xA; &lt;li&gt;In Differential Geometry, the metric tensor, which defines distances and angles on a manifold, is a bilinear form on the tangent space.&lt;/li&gt; &#xA; &lt;li&gt;In Economics, payoff functions in certain Game Theoretic problems can be modeled as bilinear forms of players&#39; strategies.&lt;/li&gt; &#xA; &lt;li&gt;In Physics, interactions between electric and magnetic fields can be expressed using bilinear forms.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Broad applications aside, the lack of a specialized primitive for bilinear forms in BLAS and LAPACK means significant performance overhead. A $vector * matrix * vector$ product is a scalar, whereas its constituent parts ($vector * matrix$ and $matrix * vector$) are vectors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;They need memory to be stored in: $O(n)$ allocation.&lt;/li&gt; &#xA; &lt;li&gt;The data will be written to memory and read back, wasting CPU cycles.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SimSIMD doesn&#39;t produce intermediate vector results, like &lt;code&gt;a @ M @ b&lt;/code&gt;, but computes the bilinear form directly.&lt;/p&gt; &#xA;&lt;h3&gt;Set Intersection, Galloping, and Binary Search&lt;/h3&gt; &#xA;&lt;p&gt;The set intersection operation is generally defined as the number of elements that are common between two sets, represented as sorted arrays of integers. The most common way to compute it is a linear scan:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;size_t intersection_size(int *a, int *b, size_t n, size_t m) {&#xA;    size_t i = 0, j = 0, count = 0;&#xA;    while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; m) {&#xA;        if (a[i] &amp;lt; b[j]) i++;&#xA;        else if (a[i] &amp;gt; b[j]) j++;&#xA;        else i++, j++, count++;&#xA;    }&#xA;    return count;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, one can use the binary search to find the elements in the second array that are present in the first one. On every step the checked region of the second array is halved, which is called the &lt;em&gt;galloping search&lt;/em&gt;. It&#39;s faster, but only when large arrays of very different sizes are intersected. Third approach is to use the SIMD instructions to compare multiple elements at once:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using string-intersection instructions on x86, like &lt;code&gt;pcmpestrm&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Using integer-intersection instructions in AVX-512, like &lt;code&gt;vp2intersectd&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Using vanilla equality checks present in all SIMD instruction sets.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After benchmarking, the last approach was chosen, as it&#39;s the most flexible and often the fastest.&lt;/p&gt; &#xA;&lt;h3&gt;Complex Dot Products, Conjugate Dot Products, and Complex Numbers&lt;/h3&gt; &#xA;&lt;p&gt;Complex dot products are a generalization of the dot product to complex numbers. They are supported by most BLAS packages, but almost never in mixed precision. SimSIMD defines &lt;code&gt;dot&lt;/code&gt; and &lt;code&gt;vdot&lt;/code&gt; kernels as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{dot}(a, b) = \sum_{i=0}^{n-1} a_i \cdot b_i&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{vdot}(a, b) = \sum_{i=0}^{n-1} a_i \cdot \bar{b_i}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where $\bar{b_i}$ is the complex conjugate of $b_i$. Putting that into Python code for scalar arrays:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dot(a: List[number], b: List[number]) -&amp;gt; number:&#xA;    a_real, a_imaginary = a[0::2], a[1::2]&#xA;    b_real, b_imaginary = b[0::2], b[1::2]&#xA;    ab_real, ab_imaginary = 0, 0&#xA;    for ar, ai, br, bi in zip(a_real, a_imaginary, b_real, b_imaginary):&#xA;        ab_real += ar * br - ai * bi&#xA;        ab_imaginary += ar * bi + ai * br&#xA;    return ab_real, ab_imaginary&#xA;&#xA;def vdot(a: List[number], b: List[number]) -&amp;gt; number:&#xA;    a_real, a_imaginary = a[0::2], a[1::2]&#xA;    b_real, b_imaginary = b[0::2], b[1::2]&#xA;    ab_real, ab_imaginary = 0, 0&#xA;    for ar, ai, br, bi in zip(a_real, a_imaginary, b_real, b_imaginary):&#xA;        ab_real += ar * br + ai * bi&#xA;        ab_imaginary += ar * bi - ai * br&#xA;    return ab_real, ab_imaginary&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Logarithms in Kullback-Leibler &amp;amp; Jensen‚ÄìShannon Divergences&lt;/h3&gt; &#xA;&lt;p&gt;The Kullback-Leibler divergence is a measure of how one probability distribution diverges from a second, expected probability distribution. Jensen-Shannon divergence is a symmetrized and smoothed version of the Kullback-Leibler divergence, which can be used as a distance metric between probability distributions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{KL}(P || Q) = \sum_{i} P(i) \log \frac{P(i)}{Q(i)}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{JS}(P, Q) = \frac{1}{2} \text{KL}(P || M) + \frac{1}{2} \text{KL}(Q || M), M = \frac{P + Q}{2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both functions are defined for non-negative numbers, and the logarithm is a key part of their computation.&lt;/p&gt; &#xA;&lt;h3&gt;Mixed Precision in Fused-Multiply-Add and Weighted Sums&lt;/h3&gt; &#xA;&lt;p&gt;The Fused-Multiply-Add (FMA) operation is a single operation that combines element-wise multiplication and addition with different scaling factors. The Weighted Sum is it&#39;s simplified variant without element-wise multiplication.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{FMA}_i(A, B, C, \alpha, \beta) = \alpha \cdot A_i \cdot B_i + \beta \cdot C_i&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\text{WSum}_i(A, B, \alpha, \beta) = \alpha \cdot A_i + \beta \cdot B_i&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In NumPy terms, the implementation may look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import numpy as np&#xA;def wsum(A: np.ndarray, B: np.ndarray, /, Alpha: float, Beta: float) -&amp;gt; np.ndarray:&#xA;    assert A.dtype == B.dtype, &#34;Input types must match and affect the output style&#34;&#xA;    return (Alpha * A + Beta * B).astype(A.dtype)&#xA;def fma(A: np.ndarray, B: np.ndarray, C: np.ndarray, /, Alpha: float, Beta: float) -&amp;gt; np.ndarray:&#xA;    assert A.dtype == B.dtype and A.dtype == C.dtype, &#34;Input types must match and affect the output style&#34;&#xA;    return (Alpha * A * B + Beta * C).astype(A.dtype)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tricky part is implementing those operations in mixed precision, where the scaling factors are of different precision than the input and output vectors. SimSIMD uses double-precision floating-point scaling factors for any input and output precision, including &lt;code&gt;i8&lt;/code&gt; and &lt;code&gt;u8&lt;/code&gt; integers and &lt;code&gt;f16&lt;/code&gt; and &lt;code&gt;bf16&lt;/code&gt; floats. Depending on the generation of the CPU, given native support for &lt;code&gt;f16&lt;/code&gt; addition and multiplication, the &lt;code&gt;f16&lt;/code&gt; temporaries are used for &lt;code&gt;i8&lt;/code&gt; and &lt;code&gt;u8&lt;/code&gt; multiplication, scaling, and addition. For &lt;code&gt;bf16&lt;/code&gt;, native support is generally limited to dot-products with subsequent partial accumulation, which is not enough for the FMA and WSum operations, so &lt;code&gt;f32&lt;/code&gt; is used as a temporary.&lt;/p&gt; &#xA;&lt;h3&gt;Auto-Vectorization &amp;amp; Loop Unrolling&lt;/h3&gt; &#xA;&lt;p&gt;On the Intel Sapphire Rapids platform, SimSIMD was benchmarked against auto-vectorized code using GCC 12. GCC handles single-precision &lt;code&gt;float&lt;/code&gt; but might not be the best choice for &lt;code&gt;int8&lt;/code&gt; and &lt;code&gt;_Float16&lt;/code&gt; arrays, which have been part of the C language since 2011.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Kind&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;GCC 12 &lt;code&gt;f32&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;GCC 12 &lt;code&gt;f16&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;SimSIMD &lt;code&gt;f16&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;&lt;code&gt;f16&lt;/code&gt; improvement&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Inner Product&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3,810 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;192 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;5,990 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;31 x&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Cosine Distance&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3,280 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;336 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6,880 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;20 x&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Euclidean Distance ¬≤&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;4,620 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;147 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;5,320 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;36 x&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Jensen-Shannon Divergence&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1,180 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;18 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2,140 K/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;118 x&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Dynamic Dispatch&lt;/h3&gt; &#xA;&lt;p&gt;Most popular software is precompiled and distributed with fairly conservative CPU optimizations, to ensure compatibility with older hardware. Database Management platforms, like ClickHouse, and Web Browsers, like Google Chrome,need to run on billions of devices, and they can&#39;t afford to be picky about the CPU features. For such users SimSIMD provides a dynamic dispatch mechanism, which selects the most advanced micro-kernel for the current CPU at runtime.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Subset&lt;/th&gt; &#xA;   &lt;th&gt;F&lt;/th&gt; &#xA;   &lt;th&gt;CD&lt;/th&gt; &#xA;   &lt;th&gt;ER&lt;/th&gt; &#xA;   &lt;th&gt;PF&lt;/th&gt; &#xA;   &lt;th&gt;4FMAPS&lt;/th&gt; &#xA;   &lt;th&gt;4VNNIW&lt;/th&gt; &#xA;   &lt;th&gt;VPOPCNTDQ&lt;/th&gt; &#xA;   &lt;th&gt;VL&lt;/th&gt; &#xA;   &lt;th&gt;DQ&lt;/th&gt; &#xA;   &lt;th&gt;BW&lt;/th&gt; &#xA;   &lt;th&gt;IFMA&lt;/th&gt; &#xA;   &lt;th&gt;VBMI&lt;/th&gt; &#xA;   &lt;th&gt;VNNI&lt;/th&gt; &#xA;   &lt;th&gt;BF16&lt;/th&gt; &#xA;   &lt;th&gt;VBMI2&lt;/th&gt; &#xA;   &lt;th&gt;BITALG&lt;/th&gt; &#xA;   &lt;th&gt;VPCLMULQDQ&lt;/th&gt; &#xA;   &lt;th&gt;GFNI&lt;/th&gt; &#xA;   &lt;th&gt;VAES&lt;/th&gt; &#xA;   &lt;th&gt;VP2INTERSECT&lt;/th&gt; &#xA;   &lt;th&gt;FP16&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Xeon_Phi#Knights_Landing&#34;&gt;Knights Landing&lt;/a&gt; (Xeon Phi x200, 2016)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; rowspan=&#34;9&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; rowspan=&#34;2&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;17&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Xeon_Phi#Knights_Mill&#34;&gt;Knights Mill&lt;/a&gt; (Xeon Phi x205, 2017)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;3&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;14&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Skylake_(microarchitecture)#Skylake-SP_(14_nm)_Scalable_Performance&#34;&gt;Skylake-SP&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Skylake_(microarchitecture)#Mainstream_desktop_processors&#34;&gt;Skylake-X&lt;/a&gt; (2017) &lt;/td&gt; &#xA;   &lt;td colspan=&#34;4&#34; rowspan=&#34;11&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;   &lt;td rowspan=&#34;4&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;   &lt;td colspan=&#34;3&#34; rowspan=&#34;4&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;11&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cannon_Lake_(microarchitecture)&#34;&gt;Cannon Lake&lt;/a&gt; (2018)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;9&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cascade_Lake_(microarchitecture)&#34;&gt;Cascade Lake&lt;/a&gt; (2019)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; rowspan=&#34;2&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;   &lt;td rowspan=&#34;2&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;8&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cooper_Lake_(microarchitecture)&#34;&gt;Cooper Lake&lt;/a&gt; (2020)&lt;/td&gt; &#xA;   &lt;td style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;7&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Ice_Lake_(microarchitecture)&#34;&gt;Ice Lake&lt;/a&gt; (2019)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;7&#34; rowspan=&#34;3&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td rowspan=&#34;3&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;   &lt;td colspan=&#34;5&#34; rowspan=&#34;3&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tiger_Lake_(microarchitecture)&#34;&gt;Tiger Lake&lt;/a&gt; (2020)&lt;/td&gt; &#xA;   &lt;td style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Rocket_Lake&#34;&gt;Rocket Lake&lt;/a&gt; (2021)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Alder_Lake&#34;&gt;Alder Lake&lt;/a&gt; (2021)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; style=&#34;background:#FFB;color:black;vertical-align:middle;text-align:center;&#34;&gt;Partial&lt;/td&gt; &#xA;   &lt;td colspan=&#34;15&#34; style=&#34;background:#FFB;color:black;vertical-align:middle;text-align:center;&#34;&gt;Partial&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Zen_4&#34;&gt;Zen 4&lt;/a&gt; (2022)&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; rowspan=&#34;3&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;13&#34; rowspan=&#34;3&#34; style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td colspan=&#34;2&#34; style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Sapphire_Rapids_(microprocessor)&#34;&gt;Sapphire Rapids&lt;/a&gt; (2023)&lt;/td&gt; &#xA;   &lt;td style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;   &lt;td style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Zen_5&#34;&gt;Zen 5&lt;/a&gt; (2024)&lt;/td&gt; &#xA;   &lt;td style=&#34;background:#9EFF9E;color:black;vertical-align:middle;text-align:center;&#34;&gt;Yes&lt;/td&gt; &#xA;   &lt;td style=&#34;background:#FFC7C7;color:black;vertical-align:middle;text-align:center;&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;You can compile SimSIMD on an old CPU, like Intel Haswell, and run it on a new one, like AMD Genoa, and it will automatically use the most advanced instructions available. Reverse is also true, you can compile on a new CPU and run on an old one, and it will automatically fall back to the most basic instructions. Moreover, the very first time you prove for CPU capabilities with &lt;code&gt;simsimd_capabilities()&lt;/code&gt;, it initializes the dynamic dispatch mechanism, and all subsequent calls will be faster and won&#39;t face race conditions in multi-threaded environments.&lt;/p&gt; &#xA;&lt;h2&gt;Target Specific Backends&lt;/h2&gt; &#xA;&lt;p&gt;SimSIMD exposes all kernels for all backends, and you can select the most advanced one for the current CPU without relying on built-in dispatch mechanisms. That&#39;s handy for testing and benchmarking, but also in case you want to dispatch a very specific kernel for a very specific CPU, bypassing SimSIMD assignment logic. All of the function names follow the same pattern: &lt;code&gt;simsimd_{function}_{type}_{backend}&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The backend can be &lt;code&gt;serial&lt;/code&gt;, &lt;code&gt;haswell&lt;/code&gt;, &lt;code&gt;skylake&lt;/code&gt;, &lt;code&gt;ice&lt;/code&gt;, &lt;code&gt;genoa&lt;/code&gt;, &lt;code&gt;sapphire&lt;/code&gt;, &lt;code&gt;turin&lt;/code&gt;, &lt;code&gt;neon&lt;/code&gt;, or &lt;code&gt;sve&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The type can be &lt;code&gt;f64&lt;/code&gt;, &lt;code&gt;f32&lt;/code&gt;, &lt;code&gt;f16&lt;/code&gt;, &lt;code&gt;bf16&lt;/code&gt;, &lt;code&gt;f64c&lt;/code&gt;, &lt;code&gt;f32c&lt;/code&gt;, &lt;code&gt;f16c&lt;/code&gt;, &lt;code&gt;bf16c&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, or &lt;code&gt;b8&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The function can be &lt;code&gt;dot&lt;/code&gt;, &lt;code&gt;vdot&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;l2sq&lt;/code&gt;, &lt;code&gt;hamming&lt;/code&gt;, &lt;code&gt;jaccard&lt;/code&gt;, &lt;code&gt;kl&lt;/code&gt;, &lt;code&gt;js&lt;/code&gt;, or &lt;code&gt;intersect&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To avoid hard-coding the backend, you can use the &lt;code&gt;simsimd_kernel_punned_t&lt;/code&gt; to pun the function pointer and the &lt;code&gt;simsimd_capabilities&lt;/code&gt; function to get the available backends at runtime. To match all the function names, consider a RegEx:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-regex&#34;&gt;SIMSIMD_PUBLIC void simsimd_\w+_\w+_\w+\(&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Linux, you can use the following command to list all unique functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ grep -oP &#39;SIMSIMD_PUBLIC void simsimd_\w+_\w+_\w+\(&#39; include/simsimd/*.h | sort | uniq&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_hamming_b8_haswell(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_hamming_b8_ice(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_hamming_b8_neon(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_hamming_b8_serial(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_hamming_b8_sve(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_jaccard_b8_haswell(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_jaccard_b8_ice(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_jaccard_b8_neon(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_jaccard_b8_serial(&#xA;&amp;gt; include/simsimd/binary.h:SIMSIMD_PUBLIC void simsimd_jaccard_b8_sve(&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>