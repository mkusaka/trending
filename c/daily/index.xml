<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-24T01:31:16Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>felix-pb/kfd</title>
    <updated>2023-07-24T01:31:16Z</updated>
    <id>tag:github.com,2023-07-24:/felix-pb/kfd</id>
    <link href="https://github.com/felix-pb/kfd" rel="alternate"></link>
    <summary type="html">&lt;p&gt;kfd, short for kernel file descriptor, is a project to read and write kernel memory on Apple devices.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;kfd&lt;/h1&gt; &#xA;&lt;p&gt;kfd, short for kernel file descriptor, is a project to read and write kernel memory on Apple devices. It leverages various vulnerabilities that can be exploited to obtain dangling PTEs, which will be referred to as a PUAF primitive, short for &#34;physical use-after-free&#34;. Then, it reallocates certain kernel objects inside those physical pages and manipulates them directly from user space through the dangling PTEs in order to achieve a KRKW primitive, short for &#34;kernel read/write&#34;. The exploit code is fully contained in a library, &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd.h&#34;&gt;libkfd&lt;/a&gt;, but the project also contains simple executable wrappers for &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/ContentView.swift&#34;&gt;iOS&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/macos_kfd.c&#34;&gt;macOS&lt;/a&gt;. The public API of libkfd is quite small and intuitive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum puaf_method {&#xA;    puaf_physpuppet,&#xA;    puaf_smith,&#xA;};&#xA;&#xA;enum kread_method {&#xA;    kread_kqueue_workloop_ctl,&#xA;    kread_sem_open,&#xA;};&#xA;&#xA;enum kwrite_method {&#xA;    kwrite_dup,&#xA;    kwrite_sem_open,&#xA;};&#xA;&#xA;u64 kopen(u64 puaf_pages, u64 puaf_method, u64 kread_method, u64 kwrite_method);&#xA;void kread(u64 kfd, u64 kaddr, void* uaddr, u64 size);&#xA;void kwrite(u64 kfd, void* uaddr, u64 kaddr, u64 size);&#xA;void kclose(u64 kfd);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;kopen()&lt;/code&gt; conceptually opens a &#34;kernel file descriptor&#34;. It takes the following 4 arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;puaf_pages&lt;/code&gt;: The target number of physical pages with dangling PTEs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;puaf_method&lt;/code&gt;: The method used to obtain the PUAF primitive, with the following options: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;puaf_physpuppet&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;This method exploits &lt;a href=&#34;https://support.apple.com/en-us/HT213676&#34;&gt;CVE-2023-23536&lt;/a&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;Fixed in iOS 16.4 and macOS 13.3.&lt;/li&gt; &#xA;     &lt;li&gt;Reachable from the App Sandbox but not the WebContent sandbox.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;puaf_smith&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;This method exploits &lt;a href=&#34;https://support.apple.com/en-us/HT213814&#34;&gt;CVE-2023-32434&lt;/a&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;Fixed in iOS 16.5.1 and macOS 13.4.1.&lt;/li&gt; &#xA;     &lt;li&gt;Reachable from the WebContent sandbox and might have been actively exploited.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;kread_method&lt;/code&gt;: The method used to obtain the initial &lt;code&gt;kread()&lt;/code&gt; primitive.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;kwrite_method&lt;/code&gt;: The method used to obtain the initial &lt;code&gt;kwrite()&lt;/code&gt; primitive.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the exploit is successful, &lt;code&gt;kopen()&lt;/code&gt; returns a 64-bit opaque file descriptor. In practice, this is just a user space pointer to a structure needed by libkfd. However, since that structure should not be accessed outside of the library, it is returned as an opaque integer. If the exploit is unsuccessful, the library will print an error message, sleep for 30 seconds, then exit with a status code of 1. It sleeps for 30 seconds because the kernel might panic on exit for certain PUAF methods that require some cleanup post-KRKW (e.g. &lt;code&gt;puaf_smith&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;kread()&lt;/code&gt; and &lt;code&gt;kwrite()&lt;/code&gt; are the user space equivalent of &lt;code&gt;copyout()&lt;/code&gt; and &lt;code&gt;copyin()&lt;/code&gt;, respectively. Please note that the options for &lt;code&gt;kread_method&lt;/code&gt; and &lt;code&gt;kwrite_method&lt;/code&gt; are described in a separate &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/exploiting-puafs.md&#34;&gt;write-up&lt;/a&gt;. In addition, the initial primitives granted by those methods can be used to bootstrap a better KRKW primitive. Finally, &lt;code&gt;kclose()&lt;/code&gt; simply closes the kernel file descriptor. They all take the opaque integer returned by &lt;code&gt;kopen()&lt;/code&gt; as their first argument.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;What are the supported OS versions and devices?&lt;/h2&gt; &#xA;&lt;p&gt;The later stage of the exploit makes use of various offsets. For the structures that have identical offsets across all versions that I tested, I simply included their definitions under the &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/info/static_types/&#34;&gt;static_types&lt;/a&gt; folder. For the structures that have different offsets, I built offset tables for them under the &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/info/dynamic_types/&#34;&gt;dynamic_types&lt;/a&gt; folder. Then, I map the &#34;kern.osversion&#34; of the device to the appropriate index for those offset tables. Please check the function &lt;code&gt;info_init()&lt;/code&gt;, located in &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/info.h&#34;&gt;info.h&lt;/a&gt;, for the list of currently supported iOS and macOS versions. However, please note that I only tested the exploits on an iPhone 14 Pro Max and a MacBook Air (M2 2022). Therefore, it is possible that the offsets are actually different on other devices, even for the same OS version. Keep this in mind if you get a &#34;Kernel data abort&#34; panic on a &#34;supported&#34; version. Fortunately, those offsets should all be easily retrievable from the XNU source code.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, in order to bootstrap the better KRKW primitive, the exploit makes use of certain static addresses which must be retrieved from the kernelcache. This is a tedious process, which I only carried out for the kernelcaches of certain iOS versions on the iPhone 14 Pro Max. Please check the function &lt;code&gt;perf_init()&lt;/code&gt;, located in &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/perf.h&#34;&gt;perf.h&lt;/a&gt;, for the list of currently supported versions. Note that none of the exploits require the better KRKW primitive in order to succeed. However, if you plan on doing research based on this project, then it is probably worthwhile to add support for the better KRKW primitive for your own device!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;How to build and run kfd on an iPhone?&lt;/h2&gt; &#xA;&lt;p&gt;In Xcode, open the root folder of the project and connect your iOS device.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To build the project, select Product &amp;gt; Build (⌘B).&lt;/li&gt; &#xA; &lt;li&gt;To run the project, select Product &amp;gt; Run (⌘R), then click on the &#34;kopen&#34; button in the app.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;How to build and run kfd on a Mac?&lt;/h2&gt; &#xA;&lt;p&gt;In a terminal, navigate to the root folder of the project.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, to increase the global and per-process file descriptor limits, which will improve the success rate especially on multiple consecutive runs, enter the command &lt;code&gt;make s&lt;/code&gt; and type in the sudo password.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To build the project, enter the command &lt;code&gt;make b&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To run the project, enter the command &lt;code&gt;make r&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To build and run the project at once, enter the command &lt;code&gt;make br&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Where to find detailed write-ups for the exploits?&lt;/h2&gt; &#xA;&lt;p&gt;This README presented a high-level overview of the kfd project. Once a PUAF primitive has been achieved, the rest of the exploit is generic. Therefore, I have hoisted the common part of the exploits in a dedicated write-up:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/exploiting-puafs.md&#34;&gt;Exploiting PUAFs&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, I have split the vulnerability-specific part of the exploits used to achieve the PUAF primitive into distinct write-ups, listed below in chronological order of discovery:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/physpuppet.md&#34;&gt;PhysPuppet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/smith.md&#34;&gt;Smith&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However, please note that these write-ups have been written for an audience that is already familiar with the XNU virtual memory system.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tavianator/bfs</title>
    <updated>2023-07-24T01:31:16Z</updated>
    <id>tag:github.com,2023-07-24:/tavianator/bfs</id>
    <link href="https://github.com/tavianator/bfs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A breadth-first version of the UNIX find command&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt; &lt;code&gt;bfs&lt;/code&gt; &lt;br clear=&#34;all&#34;&gt; &lt;a href=&#34;https://github.com/tavianator/bfs/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/tag/tavianator/bfs?label=version&#34; alt=&#34;Version&#34; align=&#34;left&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-0BSD-blue.svg?sanitize=true&#34; alt=&#34;License&#34; align=&#34;left&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/tavianator/bfs/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/tavianator/bfs/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI Status&#34; align=&#34;right&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/tavianator/bfs&#34;&gt;&lt;img src=&#34;https://img.shields.io/codecov/c/github/tavianator/bfs?token=PpBVuozOVC&#34; alt=&#34;Code coverage&#34; align=&#34;right&#34;&gt;&lt;/a&gt; &lt;/h1&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/#features&#34;&gt;Features&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/#installation&#34;&gt;Installation&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/docs/USAGE.md&#34;&gt;Usage&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/docs/BUILDING.md&#34;&gt;Building&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/docs/HACKING.md&#34;&gt;Hacking&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/docs/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/tavianator/bfs/gh-pages/animation-dark.svg&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://raw.githubusercontent.com/tavianator/bfs/gh-pages/animation-light.svg&#34;&gt; &#xA;  &lt;img alt=&#34;Screencast&#34; src=&#34;https://raw.githubusercontent.com/tavianator/bfs/gh-pages/animation-light.svg?sanitize=true&#34;&gt; &#xA; &lt;/picture&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;code&gt;bfs&lt;/code&gt; is a variant of the UNIX &lt;code&gt;find&lt;/code&gt; command that operates &lt;a href=&#34;https://en.wikipedia.org/wiki/Breadth-first_search&#34;&gt;&lt;strong&gt;breadth-first&lt;/strong&gt;&lt;/a&gt; rather than &lt;a href=&#34;https://en.wikipedia.org/wiki/Depth-first_search&#34;&gt;&lt;strong&gt;depth-first&lt;/strong&gt;&lt;/a&gt;. It is otherwise compatible with many versions of &lt;code&gt;find&lt;/code&gt;, including&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html&#34;&gt;POSIX&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://www.gnu.org/software/findutils/&#34;&gt;GNU&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://www.freebsd.org/cgi/man.cgi?find(1)&#34;&gt;FreeBSD&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://man.openbsd.org/find.1&#34;&gt;OpenBSD&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://man.netbsd.org/find.1&#34;&gt;NetBSD&lt;/a&gt; &amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://ss64.com/osx/find.html&#34;&gt;macOS&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;If you&#39;re not familiar with &lt;code&gt;find&lt;/code&gt;, the &lt;a href=&#34;https://www.gnu.org/software/findutils/manual/html_mono/find.html&#34;&gt;GNU find manual&lt;/a&gt; provides a good introduction.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; &lt;code&gt;bfs&lt;/code&gt; operates breadth-first, which typically finds the file(s) you&#39;re looking for faster. &lt;/summary&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA; &lt;p&gt;Imagine the following directory tree:&lt;/p&gt; &#xA; &lt;pre&gt;&#xA;haystack&#xA;├── deep&#xA;│   └── 1&#xA;│       └── 2&#xA;│           └── 3&#xA;│               └── 4&#xA;│                   └── ...&#xA;└── shallow&#xA;    └── &lt;strong&gt;needle&lt;/strong&gt;&#xA;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;find&lt;/code&gt; will explore the entire &lt;code&gt;deep&lt;/code&gt; directory tree before it ever gets to the &lt;code&gt;shallow&lt;/code&gt; one that contains what you&#39;re looking for. On the other hand, &lt;code&gt;bfs&lt;/code&gt; lists files from shallowest to deepest, so you never have to wait for it to explore an entire unrelated subtree.&lt;/p&gt; &#xA; &lt;table&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt;&#xA;    &lt;th&gt;&lt;code&gt;bfs&lt;/code&gt;&lt;/th&gt;&#xA;    &lt;th&gt;&lt;code&gt;find&lt;/code&gt;&lt;/th&gt;&#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td width=&#34;506&#34; valign=&#34;top&#34;&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bfs haystack&#xA;haystack&#xA;haystack/deep&#xA;haystack/shallow&#xA;haystack/deep/1&#xA;haystack/shallow/needle&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;    &lt;td width=&#34;506&#34; valign=&#34;top&#34;&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ find haystack&#xA;haystack&#xA;haystack/deep&#xA;haystack/deep/1&#xA;haystack/deep/1/2&#xA;haystack/deep/1/2/3&#xA;haystack/deep/1/2/3/4&#xA;...&#xA;haystack/shallow&#xA;haystack/shallow/needle&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; &lt;code&gt;bfs&lt;/code&gt; tries to be easier to use than &lt;code&gt;find&lt;/code&gt;, while remaining compatible. &lt;/summary&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA; &lt;p&gt;For example, &lt;code&gt;bfs&lt;/code&gt; is less picky about where you put its arguments:&lt;/p&gt; &#xA; &lt;table&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt;&#xA;    &lt;th&gt;&lt;code&gt;bfs&lt;/code&gt;&lt;/th&gt;&#xA;    &lt;th&gt;&lt;code&gt;find&lt;/code&gt;&lt;/th&gt;&#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td width=&#34;506&#34;&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bfs -L -name &#39;needle&#39; haystack&#xA;haystack/needle&#xA;&#xA;$ bfs haystack -L -name &#39;needle&#39;&#xA;haystack/needle&#xA;&#xA;$ bfs -L haystack -name &#39;needle&#39;&#xA;haystack/needle&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;    &lt;td width=&#34;506&#34;&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ find -L -name &#39;needle&#39; haystack&#xA;find: paths must precede expression: haystack&#xA;&#xA;$ find haystack -L -name &#39;needle&#39;&#xA;find: unknown predicate `-L&#39;&#xA;&#xA;$ find -L haystack -name &#39;needle&#39;&#xA;haystack/needle&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; &lt;code&gt;bfs&lt;/code&gt; gives helpful errors and warnings. &lt;/summary&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA; &lt;p&gt;For example, &lt;code&gt;bfs&lt;/code&gt; will detect and suggest corrections for typos:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bfs -nam needle&#xA;bfs: error: bfs -nam needle&#xA;bfs: error:     ~~~~&#xA;bfs: error: Unknown argument; did you mean -name?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;bfs&lt;/code&gt; also includes a powerful static analysis to help catch mistakes:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bfs -print -name &#39;needle&#39;&#xA;bfs: warning: bfs -print -name needle&#xA;bfs: warning:            ~~~~~~~~~~~~&#xA;bfs: warning: The result of this expression is ignored.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; &lt;code&gt;bfs&lt;/code&gt; adds some options that make common tasks easier. &lt;/summary&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA; &lt;p&gt;For example, the &lt;code&gt;-exclude&lt;/code&gt; operator skips over entire subtrees whenever an expression matches. &lt;code&gt;-exclude&lt;/code&gt; is both more powerful and easier to use than the standard &lt;code&gt;-prune&lt;/code&gt; action; compare&lt;/p&gt; &#xA; &lt;pre&gt;&#xA;$ bfs -name config &lt;strong&gt;-exclude -name .git&lt;/strong&gt;&#xA;&lt;/pre&gt; &#xA; &lt;p&gt;to the equivalent&lt;/p&gt; &#xA; &lt;pre&gt;&#xA;$ find &lt;strong&gt;! \( -name .git -prune \)&lt;/strong&gt; -name config&#xA;&lt;/pre&gt; &#xA; &lt;p&gt;As an additional shorthand, &lt;code&gt;-nohidden&lt;/code&gt; skips over all hidden files and directories. See the &lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/docs/USAGE.md#extensions&#34;&gt;usage documentation&lt;/a&gt; for more about the extensions provided by &lt;code&gt;bfs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt; &lt;code&gt;bfs&lt;/code&gt; may already be packaged for your operating system. &lt;/summary&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&#xA;&lt;strong&gt;&lt;a href=&#34;https://pkgs.alpinelinux.org/packages?name=bfs&#34;&gt;Alpine Linux&lt;/a&gt;&lt;/strong&gt;&#xA;# apk add bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://archlinux.org/packages/extra/x86_64/bfs/&#34;&gt;Arch Linux&lt;/a&gt;&lt;/strong&gt;&#xA;# pacman -S bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://packages.debian.org/sid/bfs&#34;&gt;Debian&lt;/a&gt;/&lt;a href=&#34;https://packages.ubuntu.com/kinetic/bfs&#34;&gt;Ubuntu&lt;/a&gt;&lt;/strong&gt;&#xA;# apt install bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://src.fedoraproject.org/rpms/bfs&#34;&gt;Fedora Linux&lt;/a&gt;&lt;/strong&gt;&#xA;# dnf install bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://search.nixos.org/packages?channel=unstable&amp;amp;show=bfs&amp;amp;from=0&amp;amp;size=1&amp;amp;sort=relevance&amp;amp;type=packages&amp;amp;query=bfs&#34;&gt;NixOS&lt;/a&gt;&lt;/strong&gt;&#xA;# nix-env -i bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://voidlinux.org/packages/?arch=x86_64&amp;amp;q=bfs&#34;&gt;Void Linux&lt;/a&gt;&lt;/strong&gt;&#xA;# xbps-install -S bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://www.freshports.org/sysutils/bfs&#34;&gt;FreeBSD&lt;/a&gt;&lt;/strong&gt;&#xA;# pkg install bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://ports.macports.org/port/bfs/&#34;&gt;MacPorts&lt;/a&gt;&lt;/strong&gt;&#xA;# port install bfs&#xA;&#xA;&lt;strong&gt;&lt;a href=&#34;https://formulae.brew.sh/formula/bfs&#34;&gt;Homebrew&lt;/a&gt;&lt;/strong&gt;&#xA;$ brew install bfs&#xA;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; To build &lt;code&gt;bfs&lt;/code&gt; from source, you may need to install some dependencies. &lt;/summary&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA; &lt;p&gt;The only absolute requirements for building &lt;code&gt;bfs&lt;/code&gt; are a C compiler, &lt;a href=&#34;https://www.gnu.org/software/make/&#34;&gt;GNU make&lt;/a&gt;, and &lt;a href=&#34;https://www.gnu.org/software/bash/&#34;&gt;Bash&lt;/a&gt;. These are installed by default on many systems, and easy to install on most others. Refer to your operating system&#39;s documentation on building software.&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;bfs&lt;/code&gt; also depends on some system libraries for some of its features. Here&#39;s how to install them on some common platforms:&lt;/p&gt; &#xA; &lt;pre&gt;&#xA;&lt;strong&gt;Alpine Linux&lt;/strong&gt;&#xA;# apk add acl{,-dev} attr{,-dev} libcap{,-dev} oniguruma-dev&#xA;&#xA;&lt;strong&gt;Arch Linux&lt;/strong&gt;&#xA;# pacman -S acl attr libcap oniguruma&#xA;&#xA;&lt;strong&gt;Debian/Ubuntu&lt;/strong&gt;&#xA;# apt install acl libacl1-dev attr libattr1-dev libcap2-bin libcap-dev libonig-dev&#xA;&#xA;&lt;strong&gt;Fedora&lt;/strong&gt;&#xA;# dnf install acl libacl-devel libattr-devel libcap-devel oniguruma-devel&#xA;&#xA;&lt;strong&gt;NixOS&lt;/strong&gt;&#xA;# nix-env -i acl attr libcap oniguruma&#xA;&#xA;&lt;strong&gt;Void Linux&lt;/strong&gt;&#xA;# xbps-install -S acl-{devel,progs} attr-{devel,progs} libcap-{devel,progs} oniguruma-devel&#xA;&#xA;&lt;strong&gt;FreeBSD&lt;/strong&gt;&#xA;# pkg install oniguruma&#xA;&#xA;&lt;strong&gt;MacPorts&lt;/strong&gt;&#xA;# port install oniguruma6&#xA;&#xA;&lt;strong&gt;Homebrew&lt;/strong&gt;&#xA;$ brew install oniguruma&#xA;&lt;/pre&gt; &#xA; &lt;p&gt;These dependencies are technically optional, though strongly recommended. See the &lt;a href=&#34;https://raw.githubusercontent.com/tavianator/bfs/main/docs/BUILDING.md#dependencies&#34;&gt;build documentation&lt;/a&gt; for how to disable them.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Once you have the dependencies, you can build &lt;code&gt;bfs&lt;/code&gt;. &lt;/summary&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA; &lt;p&gt;Download one of the &lt;a href=&#34;https://github.com/tavianator/bfs/releases&#34;&gt;releases&lt;/a&gt; or clone the &lt;a href=&#34;https://github.com/tavianator/bfs&#34;&gt;git repo&lt;/a&gt;. Then run&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This will build the &lt;code&gt;./bin/bfs&lt;/code&gt; binary. Run the test suite to make sure it works correctly:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;$ make check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you&#39;re interested in speed, you may want to build the release version instead:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;$ make release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Finally, if you want to install it globally, run&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;# make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt;</summary>
  </entry>
</feed>