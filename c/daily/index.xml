<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-20T01:34:16Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rui314/chibicc</title>
    <updated>2022-06-20T01:34:16Z</updated>
    <id>tag:github.com,2022-06-20:/rui314/chibicc</id>
    <link href="https://github.com/rui314/chibicc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small C compiler&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;chibicc: A Small C Compiler&lt;/h1&gt; &#xA;&lt;p&gt;(The old master has moved to &lt;a href=&#34;https://github.com/rui314/chibicc/tree/historical/old&#34;&gt;historical/old&lt;/a&gt; branch. This is a new one uploaded in September 2020.)&lt;/p&gt; &#xA;&lt;p&gt;chibicc is yet another small C compiler that implements most C11 features. Even though it still probably falls into the &#34;toy compilers&#34; category just like other small compilers do, chibicc can compile several real-world programs, including &lt;a href=&#34;https://git-scm.com/&#34;&gt;Git&lt;/a&gt;, &lt;a href=&#34;https://sqlite.org&#34;&gt;SQLite&lt;/a&gt;, &lt;a href=&#34;http://www.libpng.org/pub/png/libpng.html&#34;&gt;libpng&lt;/a&gt; and chibicc itself, without making modifications to the compiled programs. Generated executables of these programs pass their corresponding test suites. So, chibicc actually supports a wide variety of C11 features and is able to compile hundreds of thousands of lines of real-world C code correctly.&lt;/p&gt; &#xA;&lt;p&gt;chibicc is developed as the reference implementation for a book I&#39;m currently writing about the C compiler and the low-level programming. The book covers the vast topic with an incremental approach; in the first chapter, readers will implement a &#34;compiler&#34; that accepts just a single number as a &#34;language&#34;, which will then gain one feature at a time in each section of the book until the language that the compiler accepts matches what the C11 spec specifies. I took this incremental approach from &lt;a href=&#34;http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf&#34;&gt;the paper&lt;/a&gt; by Abdulaziz Ghuloum.&lt;/p&gt; &#xA;&lt;p&gt;Each commit of this project corresponds to a section of the book. For this purpose, not only the final state of the project but each commit was carefully written with readability in mind. Readers should be able to learn how a C language feature can be implemented just by reading one or a few commits of this project. For example, this is how &lt;a href=&#34;https://github.com/rui314/chibicc/commit/773115ab2a9c4b96f804311b95b20e9771f0190a&#34;&gt;while&lt;/a&gt;, &lt;a href=&#34;https://github.com/rui314/chibicc/commit/75fbd3dd6efde12eac8225d8b5723093836170a5&#34;&gt;[]&lt;/a&gt;, &lt;a href=&#34;https://github.com/rui314/chibicc/commit/1d0e942fd567a35d296d0f10b7693e98b3dd037c&#34;&gt;?:&lt;/a&gt;, and &lt;a href=&#34;https://github.com/rui314/chibicc/commit/79644e54cc1805e54428cde68b20d6d493b76d34&#34;&gt;thread-local variable&lt;/a&gt; are implemented. If you have plenty of spare time, it might be fun to read it from the &lt;a href=&#34;https://github.com/rui314/chibicc/commit/0522e2d77e3ab82d3b80a5be8dbbdc8d4180561c&#34;&gt;first commit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you like this project, please consider purchasing a copy of the book when it becomes available! ðŸ˜€ I publish the source code here to give people early access to it, because I was planing to do that anyway with a permissive open-source license after publishing the book. If I don&#39;t charge for the source code, it doesn&#39;t make much sense to me to keep it private. I hope to publish the book in 2021. You can sign up &lt;a href=&#34;https://forms.gle/sgrMWHGeGjeeEJcX7&#34;&gt;here&lt;/a&gt; to receive a notification when a free chapter is available online or the book is published.&lt;/p&gt; &#xA;&lt;p&gt;I pronounce chibicc as &lt;em&gt;chee bee cee cee&lt;/em&gt;. &#34;chibi&#34; means &#34;mini&#34; or &#34;small&#34; in Japanese. &#34;cc&#34; stands for C compiler.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;chibicc supports almost all mandatory features and most optional features of C11 as well as a few GCC language extensions.&lt;/p&gt; &#xA;&lt;p&gt;Features that are often missing in a small compiler but supported by chibicc include (but not limited to):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Preprocessor&lt;/li&gt; &#xA; &lt;li&gt;float, double and long double (x87 80-bit floating point numbers)&lt;/li&gt; &#xA; &lt;li&gt;Bit-fields&lt;/li&gt; &#xA; &lt;li&gt;alloca()&lt;/li&gt; &#xA; &lt;li&gt;Variable-length arrays&lt;/li&gt; &#xA; &lt;li&gt;Compound literals&lt;/li&gt; &#xA; &lt;li&gt;Thread-local variables&lt;/li&gt; &#xA; &lt;li&gt;Atomic variables&lt;/li&gt; &#xA; &lt;li&gt;Common symbols&lt;/li&gt; &#xA; &lt;li&gt;Designated initializers&lt;/li&gt; &#xA; &lt;li&gt;L, u, U and u8 string literals&lt;/li&gt; &#xA; &lt;li&gt;Functions that take or return structs as values, as specified by the x86-64 SystemV ABI&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;chibicc does not support complex numbers, K&amp;amp;R-style function prototypes and GCC-style inline assembly. Digraphs and trigraphs are intentionally left out.&lt;/p&gt; &#xA;&lt;p&gt;chibicc outputs a simple but nice error message when it finds an error in source code.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s no optimization pass. chibicc emits terrible code which is probably twice or more slower than GCC&#39;s output. I have a plan to add an optimization pass once the frontend is done.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m using Ubuntu 20.04 for x86-64 as a development platform. I made a few small changes so that chibicc works on Ubuntu 18.04, Fedora 32 and Gentoo 2.6, but portability is not my goal at this moment. It may or may not work on systems other than Ubuntu 20.04.&lt;/p&gt; &#xA;&lt;h2&gt;Internals&lt;/h2&gt; &#xA;&lt;p&gt;chibicc consists of the following stages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Tokenize: A tokenizer takes a string as an input, breaks it into a list of tokens and returns them.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Preprocess: A preprocessor takes as an input a list of tokens and output a new list of macro-expanded tokens. It interprets preprocessor directives while expanding macros.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Parse: A recursive descendent parser constructs abstract syntax trees from the output of the preprocessor. It also adds a type to each AST node.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Codegen: A code generator emits an assembly text for given AST nodes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;When I find a bug in this compiler, I go back to the original commit that introduced the bug and rewrite the commit history as if there were no such bug from the beginning. This is an unusual way of fixing bugs, but as a part of a book, it is important to keep every commit bug-free.&lt;/p&gt; &#xA;&lt;p&gt;Thus, I do not take pull requests in this repo. You can send me a pull request if you find a bug, but it is very likely that I will read your patch and then apply that to my previous commits by rewriting history. I&#39;ll credit your name somewhere, but your changes will be rewritten by me before submitted to this repository.&lt;/p&gt; &#xA;&lt;p&gt;Also, please assume that I will occasionally force-push my local repository to this public one to rewrite history. If you clone this project and make local commits on top of it, your changes will have to be rebased by hand when I force-push new commits.&lt;/p&gt; &#xA;&lt;h2&gt;Design principles&lt;/h2&gt; &#xA;&lt;p&gt;chibicc&#39;s core value is its simplicity and the reability of its source code. To achieve this goal, I was careful not to be too clever when writing code. Let me explain what that means.&lt;/p&gt; &#xA;&lt;p&gt;Oftentimes, as you get used to the code base, you are tempted to &lt;em&gt;improve&lt;/em&gt; the code using more abstractions and clever tricks. But that kind of &lt;em&gt;improvements&lt;/em&gt; don&#39;t always improve readability for first-time readers and can actually hurts it. I tried to avoid the pitfall as much as possible. I wrote this code not for me but for first-time readers.&lt;/p&gt; &#xA;&lt;p&gt;If you take a look at the source code, you&#39;ll find a couple of dumb-looking pieces of code. These are written intentionally that way (but at some places I might be actually missing something, though). Here is a few notable examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The recursive descendent parser contains many similar-looking functions for similar-looking generative grammar rules. You might be tempted to &lt;em&gt;improve&lt;/em&gt; it to reduce the duplication using higher-order functions or macros, but I thought that that&#39;s too complicated. It&#39;s better to allow small duplications instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;chibicc doesn&#39;t try too hard to save memory. An entire input source file is read to memory first before the tokenizer kicks in, for example.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Slow algorithms are fine if we know that n isn&#39;t too big. For example, we use a linked list as a set in the preprocessor, so the membership check takes O(n) where n is the size of the set. But that&#39;s fine because we know n is usually very small. And even if n can be very big, I stick with a simple slow algorithm until it is proved by benchmarks that that&#39;s a bottleneck.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Each AST node type uses only a few members of the &lt;code&gt;Node&lt;/code&gt; struct members. Other unused &lt;code&gt;Node&lt;/code&gt; members are just a waste of memory at runtime. We could save memory using unions, but I decided to simply put everything in the same struct instead. I believe the inefficiency is negligible. Even if it matters, we can always change the code to use unions at any time. I wanted to avoid premature optimization.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;chibicc always allocates heap memory using &lt;code&gt;calloc&lt;/code&gt;, which is a variant of &lt;code&gt;malloc&lt;/code&gt; that clears memory with zero. &lt;code&gt;calloc&lt;/code&gt; is slightly slower than &lt;code&gt;malloc&lt;/code&gt;, but that should be neligible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Last but not least, chibicc allocates memory using &lt;code&gt;calloc&lt;/code&gt; but never calls &lt;code&gt;free&lt;/code&gt;. Allocated heap memory is not freed until the process exits. I&#39;m sure that this memory management policy (or lack thereof) looks very odd, but it makes sense for short-lived programs such as compilers. DMD, a compiler for the D programming language, uses the same memory management scheme for the same reason, for example [1].&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About the Author&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;m Rui Ueyama. I&#39;m the creator of &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt;, which is a hobby C compiler, and also the original creator of the current version of &lt;a href=&#34;https://lld.llvm.org&#34;&gt;LLVM lld&lt;/a&gt; linker, which is a production-quality linker used by various operating systems and large-scale build systems.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://bellard.org/tcc/&#34;&gt;tcc&lt;/a&gt;: A small C compiler written by Fabrice Bellard. I learned a lot from this compiler, but the design of tcc and chibicc are different. In particular, tcc is a one-pass compiler, while chibicc is a multi-pass one.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/drh/lcc&#34;&gt;lcc&lt;/a&gt;: Another small C compiler. The creators wrote a &lt;a href=&#34;https://sites.google.com/site/lccretargetablecompiler/&#34;&gt;book&lt;/a&gt; about the internals of lcc, which I found a good resource to see how a compiler is implemented.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf&#34;&gt;An Incremental Approach to Compiler Construction&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://users.ece.utexas.edu/~adnan/pike.html&#34;&gt;Rob Pike&#39;s 5 Rules of Programming&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[1] &lt;a href=&#34;https://www.drdobbs.com/cpp/increasing-compiler-speed-by-over-75/240158941&#34;&gt;https://www.drdobbs.com/cpp/increasing-compiler-speed-by-over-75/240158941&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;DMD does memory allocation in a bit of a sneaky way. Since compilers are short-lived programs, and speed is of the essence, DMD just mallocs away, and never frees.&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
  <entry>
    <title>InfiniTimeOrg/InfiniTime</title>
    <updated>2022-06-20T01:34:16Z</updated>
    <id>tag:github.com,2022-06-20:/InfiniTimeOrg/InfiniTime</id>
    <link href="https://github.com/InfiniTimeOrg/InfiniTime" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Firmware for Pinetime smartwatch written in C/C++ and based on FreeRTOS&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://github.com/InfiniTimeOrg/InfiniTime&#34;&gt;InfiniTime&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/InfiniTimeOrg/InfiniTime/actions&#34;&gt;&lt;img src=&#34;https://github.com/InfiniTimeOrg/InfiniTime/workflows/Build%20PineTime%20Firmware/badge.svg?branch=master&#34; alt=&#34;Build PineTime Firmware&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/images/infinitime-logo-small.jpg&#34; alt=&#34;InfiniTime logo&#34; title=&#34;InfiniTime Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Fast open-source firmware for the &lt;a href=&#34;https://www.pine64.org/pinetime/&#34;&gt;PineTime smartwatch&lt;/a&gt; with many features, written in modern C++.&lt;/p&gt; &#xA;&lt;h2&gt;New to InfiniTime?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/gettingStarted/gettingStarted-1.0.md&#34;&gt;Getting started with InfiniTime&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/gettingStarted/updating-software.md&#34;&gt;Updating the software&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/gettingStarted/about-software.md&#34;&gt;About the firmware and bootloader&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Companion apps&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gadgetbridge.org/&#34;&gt;Gadgetbridge&lt;/a&gt; (Android)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://openrepos.net/content/piggz/amazfish/&#34;&gt;AmazFish&lt;/a&gt; (SailfishOS)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alexr4535/siglo&#34;&gt;Siglo&lt;/a&gt; (Linux)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/InfiniTimeOrg/InfiniLink&#34;&gt;InfiniLink&lt;/a&gt; &lt;strong&gt;[Experimental]&lt;/strong&gt; &lt;strong&gt;[Unmaintained, looking for developers/maintainers]&lt;/strong&gt; (iOS)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gitea.arsenm.dev/Arsen6331/itd&#34;&gt;ITD&lt;/a&gt; (Linux)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/code/Intro.md&#34;&gt;Rough structure of the code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/code/Apps.md&#34;&gt;How to implement an application&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/src/displayapp/fonts/README.md&#34;&gt;Generate the fonts and symbols&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pankajraghav.com/2021/04/03/PINETIME-STOPCLOCK.html&#34;&gt;Creating a stopwatch in Pinetime(article)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/ui_guidelines.md&#34;&gt;Tips on designing an app UI&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;InfiniSim Simulator&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;a href=&#34;https://github.com/InfiniTimeOrg/InfiniSim&#34;&gt;InfiniSim Simulator&lt;/a&gt; to experience the &lt;code&gt;InfiniTime&lt;/code&gt; user interface directly on your PC, to shorten the time until you get your hands on a real &lt;a href=&#34;https://www.pine64.org/pinetime/&#34;&gt;PineTime smartwatch&lt;/a&gt;. Or use it to develop new Watchfaces, new Screens, or quickly iterate on the user interface.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/contribute.md&#34;&gt;How to contribute?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/coding-convention.md&#34;&gt;Coding conventions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build, flash and debug&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/branches.md&#34;&gt;Project branches&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/versioning.md&#34;&gt;Versioning&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/filesInReleaseNotes.md&#34;&gt;Files included in the release notes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/buildAndProgram.md&#34;&gt;Build the project&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/openOCD.md&#34;&gt;Flash the firmware using OpenOCD and STLinkV2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/SWD.md&#34;&gt;Flash the firmware using SWD interface&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/buildWithDocker.md&#34;&gt;Build the project with Docker&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/buildWithVScode.md&#34;&gt;Build the project with VSCode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/bootloader/README.md&#34;&gt;Bootloader, OTA and DFU&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/PinetimeStubWithNrf52DK.md&#34;&gt;Stub using NRF52-DK&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;API&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/ble.md&#34;&gt;BLE implementation and API&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Architecture and technical topics&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/InfiniTimeOrg/InfiniTime/develop/doc/MemoryAnalysis.md&#34;&gt;Memory analysis&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Licenses&lt;/h2&gt; &#xA;&lt;p&gt;This project is released under the GNU General Public License version 3 or, at your option, any later version.&lt;/p&gt; &#xA;&lt;p&gt;It integrates the following projects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RTOS : &lt;strong&gt;&lt;a href=&#34;https://freertos.org&#34;&gt;FreeRTOS&lt;/a&gt;&lt;/strong&gt; under the MIT license&lt;/li&gt; &#xA; &lt;li&gt;UI : &lt;strong&gt;&lt;a href=&#34;https://lvgl.io/&#34;&gt;LittleVGL/LVGL&lt;/a&gt;&lt;/strong&gt; under the MIT license&lt;/li&gt; &#xA; &lt;li&gt;BLE stack : &lt;strong&gt;&lt;a href=&#34;https://github.com/apache/mynewt-nimble&#34;&gt;NimBLE&lt;/a&gt;&lt;/strong&gt; under the Apache 2.0 license&lt;/li&gt; &#xA; &lt;li&gt;Font : &lt;strong&gt;&lt;a href=&#34;https://www.jetbrains.com/fr-fr/lp/mono/&#34;&gt;Jetbrains Mono&lt;/a&gt;&lt;/strong&gt; under the Apache 2.0 license&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Iâ€™m not working alone on this project. First, many people create PR for this projects. Then, there is the whole #pinetime community : a lot of people all around the world who are hacking, searching, experimenting and programming the Pinetime. We exchange our ideas, experiments and code in the chat rooms and forums.&lt;/p&gt; &#xA;&lt;p&gt;Here are some people I would like to highlight:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/atc1441/&#34;&gt;Atc1441&lt;/a&gt; : He works on an Arduino based firmware for the Pinetime and many other smartwatches based on similar hardware. He was of great help when I was implementing support for the BMA421 motion sensor and IÂ²C driver.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bosmoment&#34;&gt;Koen&lt;/a&gt; : Heâ€™s working on a firmware based on RiotOS. He integrated similar libs as me : NimBLE, LittleVGL,â€¦ His help was invaluable too!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lupyuen&#34;&gt;Lup Yuen Lee&lt;/a&gt; : He is everywhere: he works on a Rust firmware, builds a MCUBoot based bootloader for the Pinetime, designs a Flutter based companion app for smartphones and writes a lot of articles about the Pinetime!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;If you feel like you should appear on this list, just get in touch with me or submit a PR :)&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pbatard/rufus</title>
    <updated>2022-06-20T01:34:16Z</updated>
    <id>tag:github.com,2022-06-20:/pbatard/rufus</id>
    <link href="https://github.com/pbatard/rufus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Reliable USB Formatting Utility&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rufus: The Reliable USB Formatting Utility&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pbatard/rufus/actions/workflows/vs2022.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/pbatard/rufus/VS2022.svg?style=flat-square&amp;amp;label=VS2022%20Build&#34; alt=&#34;VS2022 Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/pbatard/rufus/actions/workflows/mingw.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/pbatard/rufus/MinGW.svg?style=flat-square&amp;amp;label=MinGW%20Build&#34; alt=&#34;MinGW Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://scan.coverity.com/projects/pbatard-rufus&#34;&gt;&lt;img src=&#34;https://img.shields.io/coverity/scan/2172.svg?style=flat-square&amp;amp;label=Coverity%20Analysis&#34; alt=&#34;Coverity Scan Status&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/pbatard/rufus/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release-pre/pbatard/rufus.svg?style=flat-square&amp;amp;label=Latest%20Release&#34; alt=&#34;Latest Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.en.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPLv3-blue.svg?style=flat-square&amp;amp;label=License&#34; alt=&#34;Licence&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/pbatard/rufus/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/pbatard/rufus/total.svg?label=Downloads%20%28since%202019%29&amp;amp;style=flat-square&#34; alt=&#34;Download Stats&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/pbatard/rufus/graphs/contributors&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/contributors/pbatard/rufus.svg?style=flat-square&amp;amp;label=Contributors&#34; alt=&#34;Contributors&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pbatard/rufus/master/res/icons/rufus-128.png&#34; alt=&#34;Rufus logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rufus is a utility that helps format and create bootable USB flash drives.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Format USB, flash card and virtual drives to FAT/FAT32/NTFS/UDF/exFAT/ReFS/ext2/ext3&lt;/li&gt; &#xA; &lt;li&gt;Create DOS bootable USB drives, using &lt;a href=&#34;https://www.freedos.org&#34;&gt;FreeDOS&lt;/a&gt; or MS-DOS (Windows 8.1 or earlier)&lt;/li&gt; &#xA; &lt;li&gt;Create BIOS or UEFI bootable drives, including &lt;a href=&#34;https://github.com/pbatard/uefi-ntfs&#34;&gt;UEFI bootable NTFS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Create bootable drives from bootable ISOs (Windows, Linux, etc.)&lt;/li&gt; &#xA; &lt;li&gt;Create bootable drives from bootable disk images, including compressed ones&lt;/li&gt; &#xA; &lt;li&gt;Create Windows 11 installation drives for PCs that don&#39;t have TPM&lt;/li&gt; &#xA; &lt;li&gt;Create &lt;a href=&#34;https://en.wikipedia.org/wiki/Windows_To_Go&#34;&gt;Windows To Go&lt;/a&gt; drives&lt;/li&gt; &#xA; &lt;li&gt;Create persistent Linux partitions&lt;/li&gt; &#xA; &lt;li&gt;Create VHD/DD images of a drive&lt;/li&gt; &#xA; &lt;li&gt;Compute MD5, SHA-1, SHA-256 and SHA-512 checksums of the selected image&lt;/li&gt; &#xA; &lt;li&gt;Perform bad blocks checks, including detection of &#34;fake&#34; flash drives&lt;/li&gt; &#xA; &lt;li&gt;Download official Microsoft Windows 7, Windows 8, Windows 10 or Windows 11 retail ISOs&lt;/li&gt; &#xA; &lt;li&gt;Download &lt;a href=&#34;https://github.com/pbatard/UEFI-Shell&#34;&gt;UEFI Shell&lt;/a&gt; ISOs&lt;/li&gt; &#xA; &lt;li&gt;Modern and familiar UI, with &lt;a href=&#34;https://github.com/pbatard/rufus/wiki/FAQ#What_languages_are_natively_supported_by_Rufus&#34;&gt;38 languages natively supported&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Small footprint. No installation required.&lt;/li&gt; &#xA; &lt;li&gt;Portable. Secure Boot compatible.&lt;/li&gt; &#xA; &lt;li&gt;100% &lt;a href=&#34;https://www.gnu.org/philosophy/free-sw&#34;&gt;Free Software&lt;/a&gt; (&lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0&#34;&gt;GPL v3&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compilation&lt;/h2&gt; &#xA;&lt;p&gt;Use either Visual Studio 2022 or MinGW and then invoke the &lt;code&gt;.sln&lt;/code&gt; or &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;h4&gt;Visual Studio&lt;/h4&gt; &#xA;&lt;p&gt;Rufus is an OSI compliant Open Source project. You are entitled to download and use the &lt;em&gt;freely available&lt;/em&gt; &lt;a href=&#34;https://www.visualstudio.com/vs/community/&#34;&gt;Visual Studio Community Edition&lt;/a&gt; to build, run or develop for Rufus. As per the Visual Studio Community Edition license, this applies regardless of whether you are an individual or a corporate user.&lt;/p&gt; &#xA;&lt;h2&gt;Additional information&lt;/h2&gt; &#xA;&lt;p&gt;Rufus provides extensive information about what it is doing, either through its easily accessible log, or through the &lt;a href=&#34;https://docs.microsoft.com/en-us/sysinternals/downloads/debugview&#34;&gt;Windows debug facility&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rufus.ie&#34;&gt;&lt;strong&gt;Official Website&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pbatard/rufus/wiki/FAQ&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Enhancements/Bugs&lt;/h2&gt; &#xA;&lt;p&gt;Please use the &lt;a href=&#34;https://github.com/pbatard/rufus/issues&#34;&gt;GitHub issue tracker&lt;/a&gt; for reporting problems or suggesting new features.&lt;/p&gt;</summary>
  </entry>
</feed>