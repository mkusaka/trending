<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-03T01:25:55Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>raspiduino/arv32-opt</title>
    <updated>2023-10-03T01:25:55Z</updated>
    <id>tag:github.com,2023-10-03:/raspiduino/arv32-opt</id>
    <link href="https://github.com/raspiduino/arv32-opt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;[Tested successfully] Linux on Arduino UNO / atmega328p port of mini-rv32ima. Let&#39;s run Linux on the world&#39;s worst Linux PC (and beat Dmitry Grinberg)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;arv32-opt&lt;/h1&gt; &#xA;&lt;p&gt;[Tested successfully!] Atmega328p port of mini-rv32ima. Let&#39;s run Linux on the world&#39;s worst Linux PC (and beat Dmitry Grinberg)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/raspiduino/arv32-opt/assets/68118236/e457c5f7-110e-457c-ab98-48de47102af9&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/ZzReAELagG4&#34;&gt;Video on Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note: The code is in &lt;strong&gt;pure AVR C&lt;/strong&gt;. Arduino IDE is just used as &lt;em&gt;serial terminal&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What is this?&lt;/h2&gt; &#xA;&lt;p&gt;This is a port of &lt;a href=&#34;https://github.com/cnlohr/mini-rv32ima&#34;&gt;mini-rv32ima&lt;/a&gt; (a minimum RISC-V emulator, capable of booting Linux) on atmega328p (the core of Arduino UNO, a 8-bit AVR microcontroller). So basically, this code is for &lt;strong&gt;booting Linux on Arduino UNO&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Yes you are reading it correctly, Arduino UNO can (theorically, but not practically) boot Linux. And it definitely beats &lt;a href=&#34;https://dmitry.gr/?r=05.Projects&amp;amp;proj=07.%20Linux%20on%208bit&#34;&gt;Dmitry Grinberg&#39;s (once) world&#39;s worst Linux PC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How does it work?&lt;/h2&gt; &#xA;&lt;p&gt;The idea is really simple: you have an Arduino UNO (or atmega328p) to run the emulator&#39;s logic, and emulator&#39;s RAM is accessed via swapping with an SD card (which is communicated through SPI interface, see more below). The emulator also has 3 512-bytes cache (1 icache and 2 dcache interchangable) and lazy/delayed cache write system.&lt;/p&gt; &#xA;&lt;p&gt;The code is written in pure C (and not Arduino) to reduce Arduino overhead (if any). It initializes UART, SPI, SD card, and a digital input-pullup pin for triggering emulator state dump. Finally, it initialize cache, then mini-rv32ima and let the emulator does its works.&lt;/p&gt; &#xA;&lt;h2&gt;How fast is it?&lt;/h2&gt; &#xA;&lt;p&gt;About &lt;del&gt;175Hz - 205Hz&lt;/del&gt; &lt;del&gt;426 - 600Hz&lt;/del&gt; most of the time 700 Hz, peak 1500Hz, lowest 70Hz with &lt;code&gt;-O3&lt;/code&gt; code on an Arduino UNO based on atmega328p, clocked at 16MHz, with a class 4 SDHC card connected via 1-bit SPI interface. Complete boot time (from start to shell) is about 15 hours and 44 minutes.&lt;/p&gt; &#xA;&lt;p&gt;Update 24/9/2023: The speed is double/tripled by implementing icache&lt;/p&gt; &#xA;&lt;p&gt;Update 26/9/2023: The speed is x1.5 by implementing 3 cache + lazy write system&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt; Why it&#39;s &lt;em&gt;that&lt;/em&gt; slow? Read &lt;code&gt;Current issues and drawbacks&lt;/code&gt; section below.&lt;/p&gt; &#xA;&lt;h2&gt;Pinout&lt;/h2&gt; &#xA;&lt;p&gt;The pinout is really simple. On Arduino UNO, it should be:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Arduino UNO pin&lt;/th&gt; &#xA;   &lt;th&gt;Connect to&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9&lt;/td&gt; &#xA;   &lt;td&gt;ground-connected button&lt;/td&gt; &#xA;   &lt;td&gt;When connected to GND, emulator state and effective emulated speed will be dump via UART&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;10&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CS&lt;/code&gt; pin on SD card&lt;/td&gt; &#xA;   &lt;td&gt;SD&#39;s chip select/&lt;code&gt;CS&lt;/code&gt;/&lt;code&gt;EN&lt;/code&gt;/&lt;code&gt;SS&lt;/code&gt; pin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;MOSI&lt;/code&gt; pin on SD card&lt;/td&gt; &#xA;   &lt;td&gt;SD&#39;s &lt;code&gt;DI&lt;/code&gt;/&lt;code&gt;CMD&lt;/code&gt; pin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;MISO&lt;/code&gt; pin on SD card&lt;/td&gt; &#xA;   &lt;td&gt;SD&#39;s &lt;code&gt;DO&lt;/code&gt; pin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;13&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;SCLK&lt;/code&gt; pin on SD card&lt;/td&gt; &#xA;   &lt;td&gt;SD&#39;s clock/&lt;code&gt;SCK&lt;/code&gt;/&lt;code&gt;CLK&lt;/code&gt; pin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING] Since Arduino UNO (atmega328p) uses &lt;strong&gt;5V&lt;/strong&gt; logic level, while SD card use &lt;strong&gt;3.3V (or lower)&lt;/strong&gt; logic level, you will need a &lt;strong&gt;level shifter&lt;/strong&gt;. You can build your own using MOSFET, but the simplest way is to buy an SD card adapter.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;br&gt; You can change the &lt;code&gt;CS&lt;/code&gt; and the pin used to dump state to any pins you want. Just modify the code (see below).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Preparing the SD card&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First, you will need an SD card. Any type larger than 12MB.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING] You should backup all your files, since doing this SD card preparation will destroy your SD card&#39;s filesystem.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Then you need some tool to directly write a file to SD card. On Windows, you can use &lt;a href=&#34;https://hddguru.com/software/HDD-Raw-Copy-Tool/&#34;&gt;HDD Raw Copy Tool&lt;/a&gt;, on *nix you can use &lt;code&gt;dd if=file.bin of=/dev/sdX conv=notrunc&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Download the file &lt;a href=&#34;https://github.com/raspiduino/arv32-opt/raw/main/rv32.bin&#34;&gt;&lt;code&gt;arv32.bin&lt;/code&gt;&lt;/a&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;Write it directly to the SD card using the tools in step 2.&lt;/li&gt; &#xA; &lt;li&gt;Now you are done preparing the card.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;br&gt; The &lt;code&gt;Preparing the SD card&lt;/code&gt; section must be repeated every time you boot your emulator. Otherwise it might not boot (if Linux has initialized enough and start cleaning the memory). This might be fixed in the future.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Building the code&lt;/h3&gt; &#xA;&lt;p&gt;You can just download the latest HEX file in &lt;a href=&#34;https://github.com/raspiduino/arv32-opt/releases/&#34;&gt;Release&lt;/a&gt;. But if you want to build on your own, here are the steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First, clone the repo: &lt;code&gt;git clone https://github.com/raspiduino/arv32-opt&lt;/code&gt;. Then &lt;code&gt;cd arv32-opt&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Then use build the code using the following commands:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;avr-gcc -c -mmcu=atmega328p -I. -DF_CPU=16000000UL  -O3 -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -Wa,-adhlns=main.lst  -std=gnu99 main.c -o main.o&#xA;avr-gcc -c -mmcu=atmega328p -I. -DF_CPU=16000000UL  -O3 -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -Wa,-adhlns=sdcard.lst  -std=gnu99 sdcard.c -o sdcard.o&#xA;avr-gcc -c -mmcu=atmega328p -I. -DF_CPU=16000000UL  -O3 -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -Wa,-adhlns=sdprint.lst  -std=gnu99 sdprint.c -o sdprint.o&#xA;avr-gcc -c -mmcu=atmega328p -I. -DF_CPU=16000000UL  -O3 -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -Wa,-adhlns=spi.lst  -std=gnu99 spi.c -o spi.o&#xA;avr-gcc -c -mmcu=atmega328p -I. -DF_CPU=16000000UL  -O3 -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -Wa,-adhlns=uart.lst  -std=gnu99 uart.c -o uart.o&#xA;avr-gcc -mmcu=atmega328p -I. -DF_CPU=16000000UL -O3 -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -std=gnu99 main.o sdcard.o sdprint.o spi.o uart.o --output main.elf -Wl,-Map=main.map,--cref&#xA;avr-objcopy -O ihex -R .eeprom main.elf main.hex&#xA;avr-size -A -d main.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Result HEX file will be &lt;code&gt;main.hex&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;You can then flash the code to the board using &lt;code&gt;avrdude -v -V -patmega328p -carduino &#34;-PCOM10&#34; -b115200 -D &#34;-Uflash:w:main.hex:i&#34;&lt;/code&gt;. Replace &lt;code&gt;COM10&lt;/code&gt; with your &lt;code&gt;COM&lt;/code&gt; port (on Windows), or &lt;code&gt;/dev/ttyUSB*&lt;/code&gt; port on Linux. (Idk about Mac, but it should be the same)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;br&gt; If you build for another AVR microcontroller, or if you use different clock speed, please change the &lt;code&gt;-mmcu=atmega328p&lt;/code&gt; and &lt;code&gt;-DF_CPU=16000000UL&lt;/code&gt; options to match your situation.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;br&gt; Windows users can refer to the script &lt;code&gt;build.bat&lt;/code&gt; in this repo. Just change the path to your correct path and it will work.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;After completing 2 sections above, you are now ready to boot Linux on Arduino UNO. Just connect the SD card to Arduino UNO, insert the card in, then power the Arduino on. Open a serial connection at baudrate 9600 bps to connect. &lt;br&gt; You should see the following output (immidiately):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;arv32-opt: mini-rv32ima on Arduino UNO&#xA;SD card initialized successfully!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;br&gt; The &lt;code&gt;Preparing the SD card&lt;/code&gt; section must be repeated every time you boot your emulator. Otherwise it might not boot (if Linux has initialized enough and start cleaning the memory). This might be fixed in the future.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;br&gt; If you get &lt;code&gt;Error initializaing SD card&lt;/code&gt; when you just plugged your board to your computer, just press the reset button. It should work.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can also dump the state of the emulator while it&#39;s running. Just connect a button to &lt;code&gt;GND&lt;/code&gt; and then connect pin 9 to the button. When you click the button, state will be dump, and you should see something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Effective emulated speed: 1442 Hz, dtime=233596ms, dcycle=336896&#xA;Current AVR free memory: 155 bytes&#xA;icache hit/miss: 17931786/983542; dcache hit/miss: 4078057/1731330&#xA;==============================================================================&#xA;Dumping emulator state:&#xA;Registers x0 - x31:&#xA;0x00000000 0x800E6B34 0x8041F7A0 0x80332FC8&#xA;0x80420000 0x9B779A7E 0xDFB0F4A6 0x29EEBE42&#xA;0x8041F890 0xDEC0D0A6 0x9EE3B78E 0xA125AEE8&#xA;0x0A29015A 0x969C9575 0x31D9B5BA 0x1A086279&#xA;0xEFA9A208 0xAF715DDD 0x10C7F938 0x42557158&#xA;0x9A2FA369 0x6AA2616B 0x8041F8B4 0x00000000&#xA;0x00000000 0x36AAA20D 0x4BD078AB 0x000AF715&#xA;0x68A94F06 0x53A31796 0xF822BFDD 0x1A73C5BB&#xA;pc: 0x800E7144&#xA;mstatus: 0x00001880&#xA;cyclel: 0x0120A000&#xA;cycleh: 0x00000000&#xA;timerl: 0x00904E00&#xA;timerh: 0x00000000&#xA;timermatchl: 0x009050BF&#xA;timermatchh: 0x00000000&#xA;mscratch: 0x00000000&#xA;mtvec: 0x80001CBC&#xA;mie: 0x00000088&#xA;mip: 0x00000000&#xA;mepc: 0x800E6640&#xA;mtval: 0x00000000&#xA;mcause: 0x80000007&#xA;extraflags: 0x019446E3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Effective emulated speed&lt;/code&gt; is the number of instructions the emulator can execute in 1 second at that time. &lt;code&gt;dtime&lt;/code&gt; is the time difference between current time and the last time you dump the status. &lt;code&gt;dcycle&lt;/code&gt; is the number of cycle (instructions) excuted from the last time you dump the status until now. &lt;br&gt;&lt;code&gt;Registers x0 - x31&lt;/code&gt; sections show registers from &lt;code&gt;x0&lt;/code&gt; to &lt;code&gt;x31&lt;/code&gt;, listed in order from left to right then from top down.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;br&gt; The emulator will resume when you release the button (you should see something like &lt;code&gt;B1 is set to HIGH, emulator resume&lt;/code&gt;). As long as you keep holding the button, the emulator will pause. You can also use a wire connected to GND instead of a button (just like me).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Things can be changed in the code&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;UART baudrate @ &lt;code&gt;main.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;SPI bus speed @ &lt;code&gt;main.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Dump state trigger button @ &lt;code&gt;main.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;SD&#39;s CS pin @ &lt;code&gt;spi.h&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Current issues and drawbacks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The effective emulated speed is super slow. This is mostly due to the high overhead of 1-bit SPI connection with SD card, when every instruction that access memory must also access SD card.&lt;/li&gt; &#xA; &lt;li&gt;Max tested SPI bus speed is FCLK/16, which is 1MHz on 16MHz atmega328p. If you set the speed higher than this, SD card won&#39;t initialize. This might be just my problem, so feel free to try.&lt;/li&gt; &#xA; &lt;li&gt;Automatically replacing new state is not implemented yet. So every time you run the emulator, you must repeat the &lt;code&gt;Preparing the SD card&lt;/code&gt; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cnlohr&#34;&gt;cnlohr&lt;/a&gt; for writing &lt;a href=&#34;https://github.com/cnlohr/mini-rv32ima/&#34;&gt;mini-rv32ima&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ryanj1234&#34;&gt;ryanj1234&lt;/a&gt; for writing &lt;a href=&#34;https://github.com/ryanj1234/SD_TUTORIAL_PART4&#34;&gt;SD_TUTORIAL_PART4&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/adnbr/&#34;&gt;adnbr&lt;/a&gt; for writing &lt;a href=&#34;https://gist.github.com/adnbr/2439125&#34;&gt;1 ms counter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/raspiduino&#34;&gt;me (gvl610/raspiduino)&lt;/a&gt; for bringing all this stuff together.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;One last thing&lt;/h2&gt; &#xA;&lt;p&gt;If you can run this, you probably are running world&#39;s worst Linux PC. Enjoy!&lt;/p&gt;</summary>
  </entry>
</feed>