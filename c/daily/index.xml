<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-01T01:31:54Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jfedor2/hid-remapper</title>
    <updated>2023-01-01T01:31:54Z</updated>
    <id>tag:github.com,2023-01-01:/jfedor2/hid-remapper</id>
    <link href="https://github.com/jfedor2/hid-remapper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;USB input remapping dongle&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HID Remapper&lt;/h1&gt; &#xA;&lt;p&gt;This is a configurable USB dongle that allows you to remap inputs from mice, keyboards and other devices. It works completely in hardware and requires no software running on the computer during normal use.&lt;/p&gt; &#xA;&lt;p&gt;It can do things like reassign buttons, change keyboard layouts, map mouse buttons to keyboard inputs, map keystrokes to mouse inputs, change mouse sensitivity (permanently or when a button is held), rotate mouse axes by arbitrary (non-90 degree) angles, drag-lock for mouse buttons, scroll by moving the mouse, and much more.&lt;/p&gt; &#xA;&lt;p&gt;It is configurable &lt;a href=&#34;https://www.jfedor.org/hid-remapper-config/&#34;&gt;through a web browser&lt;/a&gt; using WebHID (Chrome or Chrome-based browser required).&lt;/p&gt; &#xA;&lt;p&gt;Wireless receivers are supported and multiple devices can be connected at the same time using a USB hub.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the remapping functionality, it can do polling rate overclocking up to 1000 Hz.&lt;/p&gt; &#xA;&lt;p&gt;A separate &lt;a href=&#34;https://raw.githubusercontent.com/jfedor2/hid-remapper/master/SERIAL.md&#34;&gt;serial&lt;/a&gt; version of the remapper takes inputs from a serial (RS-232) mouse and translates them to USB.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s also a &lt;a href=&#34;https://raw.githubusercontent.com/jfedor2/hid-remapper/master/BLUETOOTH.md&#34;&gt;Bluetooth&lt;/a&gt; version that runs on nRF52840-based boards, which translates Bluetooth inputs to USB.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jfedor2/hid-remapper/master/images/remapper1.jpg&#34; alt=&#34;HID Remapper&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to make the device&lt;/h2&gt; &#xA;&lt;p&gt;There are two main ways of making the HID Remapper. You can either make it yourself using a Raspberry Pi Pico (or two), or you can use the provided files to manufacture a custom board at JLCPCB or a similar service. Their functionality is the same.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/jfedor2/hid-remapper/master/HARDWARE.md&#34;&gt;here&lt;/a&gt; for details on how to make the Pico variants of the device and &lt;a href=&#34;https://raw.githubusercontent.com/jfedor2/hid-remapper/master/custom-boards/&#34;&gt;here&lt;/a&gt; for details on the custom board option.&lt;/p&gt; &#xA;&lt;h2&gt;How to use the configuration tool&lt;/h2&gt; &#xA;&lt;p&gt;A live version of the web configuration tool can be found &lt;a href=&#34;https://www.jfedor.org/hid-remapper-config/&#34;&gt;here&lt;/a&gt;. It only works in Chrome and Chrome-based browsers (including ChromeOS). On Linux you might need to give yourself permissions to the appropriate &lt;code&gt;/dev/hidraw*&lt;/code&gt; device.&lt;/p&gt; &#xA;&lt;p&gt;The input remapping mechanism is based on a list of &lt;em&gt;mappings&lt;/em&gt;. Every mapping has an input and an output. Inputs and outputs are things like mouse buttons, mouse axes, keyboard keys etc. For example if you want the right mouse button to act as the left mouse button, add a mapping with input set to &#34;Right button&#34; and output set to &#34;Left button&#34;.&lt;/p&gt; &#xA;&lt;p&gt;By default all inputs that aren&#39;t explicitly mapped to anything are passed through unchanged. If you don&#39;t want that, you can uncheck the &#34;Unmapped inputs passthrough&#34; checkbox.&lt;/p&gt; &#xA;&lt;p&gt;There can be more than one mapping with the same input and the same output. It is useful when you want to map a mouse button to, say, Ctrl-C. You can achieve that by adding two mappings, both with that button as input, one with &#34;Control&#34; as output and one with &#34;C&#34; as output.&lt;/p&gt; &#xA;&lt;p&gt;Similarly to remapping buttons, you can also remap axes. For example if you want horizontal mouse movements to be mapped to vertical cursor movements on the computer, add a mapping with the input set to &#34;Cursor X&#34; and the output set to &#34;Cursor Y&#34;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to change cursor speed (mouse sensitivity), you can use the &lt;em&gt;scaling&lt;/em&gt; part of the mapping. By default it is set to 1, but you could add mappings with the same axes for inputs and outputs and for example set scaling to 2 to make the cursor move twice as fast, or set it to -1 to invert the direction of the movement. (Usually it&#39;s best to first increase the CPI on the device if possible as that will give you better precision.)&lt;/p&gt; &#xA;&lt;p&gt;You can have a mapping that has a button or a key as input and an axis as output. For example if you add a mapping with &#34;Right arrow&#34; as input and &#34;Cursor X&#34; as output, it will make the cursor move right when right arrow is held on the keyboard.&lt;/p&gt; &#xA;&lt;p&gt;Having an axis as input and a button as output currently doesn&#39;t make a lot of sense.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;sticky&lt;/em&gt; flag on a mapping can be used to implement drag-lock functionality. When the flag is enabled on a mapping, pressing (and releasing) the input button will cause the output button to be held until the input button is pressed again.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;layers&lt;/em&gt; mechanism might sound familiar if you ever used a custom ergo keyboard. It works as follows. A special mapping can be added with some button as input and &#34;Layer X&#34; as output. This means that when that button is pressed, layer X is active and therefore mappings from layer X are applied (every mapping has a layer assigned, 0 by default). If no layer is explicitly activated, layer 0 is active. More than one layer can be active at the same time. This mechanism has many useful applications, from completely separate keyboard layouts to things like &#34;sniper button&#34; on a mouse - increasing precision when a certain button is held.&lt;/p&gt; &#xA;&lt;p&gt;Layer activating mappings work on all layers, regardless of which layer they are defined on. They can be sticky.&lt;/p&gt; &#xA;&lt;p&gt;The configuration tool comes with a list of standard inputs like mouse buttons and axes, keyboard keys and media keys like play/pause, mute, etc. Some devices will use inputs from outside that list. Good news is they can still be mapped. To make the device-specific inputs appear on the list, just connect your device to the remapper, and the remapper to your computer, and click the &#34;Open device&#34; button before you define the mappings. The configuration tool will fetch the list of inputs declared by your device and they will show up at the bottom of the input list. Unfortunately they will only appear as hex codes and will not have human friendly names. Therefore it might require some trial and error to find the input you want (and some devices will have a lot of them!).&lt;/p&gt; &#xA;&lt;p&gt;The remapper supports high-resolution mouse scrolling on the output side, which should work on Windows and modern Linux desktops. To experience it, add a mapping with &#34;Cursor Y&#34; as input and &#34;V scroll&#34; as output (perhaps on a layer). The &#34;Partial scroll timeout&#34; setting is related to this and you can safely ignore it if you&#39;re not mapping anything to mouse scroll. It applies when high-resolution scrolling is &lt;em&gt;not&lt;/em&gt; in use and is the time after which a &#34;half-tick&#34; of the scroll is forgotten.&lt;/p&gt; &#xA;&lt;p&gt;If you set the &#34;Polling rate override&#34; to anything else than &#34;don&#39;t override&#34;, it will use the selected polling rate instead of the polling rate requested by the connected device. Keep in mind this doesn&#39;t work for all devices.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re getting an &#34;Incompatible version&#34; error, try upgrading to the newest firmware.&lt;/p&gt; &#xA;&lt;p&gt;If this description wasn&#39;t particularly clear for you, perhaps looking at some of the examples that come with the configuration tool will help.&lt;/p&gt; &#xA;&lt;p&gt;If you can&#39;t use the browser-based configuration tool, there&#39;s also a &lt;a href=&#34;https://raw.githubusercontent.com/jfedor2/hid-remapper/master/config-tool&#34;&gt;command-line tool&lt;/a&gt; that takes JSON in the same format as the web tool on standard input. I only tested it on Linux, but in theory it should also run on Windows and Mac.&lt;/p&gt; &#xA;&lt;h2&gt;How to compile the firmware&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/jfedor2/hid-remapper.git&#xA;cd hid-remapper&#xA;git submodule update --init&#xA;cd firmware&#xA;mkdir build&#xA;cd build&#xA;cmake ..&#xA;# or, to build for the custom boards:&#xA;# PICO_BOARD=remapper cmake ..&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Future goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Upstream necessary modifications to the Pico-PIO-USB library.&lt;/li&gt; &#xA; &lt;li&gt;Unmapped input passthrough on layers other than 0.&lt;/li&gt; &#xA; &lt;li&gt;Runtime-configurable output report descriptor.&lt;/li&gt; &#xA; &lt;li&gt;Non-binary absolute usage support (d-pads and joysticks).&lt;/li&gt; &#xA; &lt;li&gt;Interactive remapping.&lt;/li&gt; &#xA; &lt;li&gt;Explore alternative hardware platforms.&lt;/li&gt; &#xA; &lt;li&gt;Test with more devices.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>