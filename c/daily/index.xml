<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-05T01:31:59Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>EthanArbuckle/Apollo-CustomApiCredentials</title>
    <updated>2023-07-05T01:31:59Z</updated>
    <id>tag:github.com,2023-07-05:/EthanArbuckle/Apollo-CustomApiCredentials</id>
    <link href="https://github.com/EthanArbuckle/Apollo-CustomApiCredentials" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tweak to use your own reddit API credentials in Apollo&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Use your own reddit API credentials in Apollo&lt;/h2&gt; &#xA;&lt;h3&gt;Creating an API credential:&lt;/h3&gt; &#xA;&lt;p&gt;sign out of all accounts in Apollo before installing&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install the tweak and launch Apollo.&lt;/li&gt; &#xA; &lt;li&gt;When prompted, sign into reddit.com.&lt;/li&gt; &#xA; &lt;li&gt;After signing in, you&#39;ll be redirected to your account&#39;s &#34;developer apps&#34; page.&lt;/li&gt; &#xA; &lt;li&gt;A new developer app needs to be created. The tweak will autopopulate all fields with the correct information.&lt;/li&gt; &#xA; &lt;li&gt;Complete the Captcha and click &lt;code&gt;create app&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Once the app has been created, you will land on the Apollo Home feed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EthanArbuckle/Apollo-CustomApiCredentials/main/img/credential-creation-flow.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>florylsk/RecycledInjector</title>
    <updated>2023-07-05T01:31:59Z</updated>
    <id>tag:github.com,2023-07-05:/florylsk/RecycledInjector</id>
    <link href="https://github.com/florylsk/RecycledInjector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Native Syscalls Shellcode Injector&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RecycledInjector&lt;/h1&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;(Currently) Fully Undetected same-process native/.NET assembly shellcode injector based on &lt;a href=&#34;https://github.com/thefLink/RecycledGate&#34;&gt;RecycledGate&lt;/a&gt; by thefLink, which is also based on HellsGate + HalosGate + TartarusGate to ensure undetectable native syscalls even if one technique fails.&lt;/p&gt; &#xA;&lt;p&gt;To remain stealthy and keep entropy on the final executable low, do ensure that shellcode is always loaded externally since most AV/EDRs won&#39;t check for signatures on non-executable or DLL files anyway.&lt;/p&gt; &#xA;&lt;p&gt;Important to also note that the fully undetected part refers to the loading of the shellcode, however, the shellcode will still be subject to behavior monotoring, thus make sure the loaded executable also makes use of defense evasion techniques (e.g., SharpKatz which features DInvoke instead of Mimikatz).&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;.\RecycledInjector.exe &amp;lt;path_to_shellcode_file&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Proof of Concept&lt;/h2&gt; &#xA;&lt;p&gt;This proof of concept leverages &lt;a href=&#34;https://github.com/ZeroMemoryEx/Terminator&#34;&gt;Terminator&lt;/a&gt; by ZeroMemoryEx to kill most security solution/agents present on the system. It is used against Microsoft Defender for Endpoint EDR.&lt;/p&gt; &#xA;&lt;p&gt;On the left we inject the Terminator shellcode to load the vulnerable driver and kill MDE processes, and on the right is an example of loading and executing Invoke-Mimikatz remotely from memory, which is not stopped as there is no running security solution anymore on the system.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/florylsk/RecycledInjector/assets/46110263/b3ae8ada-0e27-47b4-adeb-55ad89aef815&#34; alt=&#34;RecycledInjector&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>passthehashbrowns/BOFMask</title>
    <updated>2023-07-05T01:31:59Z</updated>
    <id>tag:github.com,2023-07-05:/passthehashbrowns/BOFMask</id>
    <link href="https://github.com/passthehashbrowns/BOFMask" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BOFMask&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the code for this blog post:&lt;/p&gt; &#xA;&lt;p&gt;BOFMask is a proof-of-concept for masking Cobalt Strike&#39;s Beacon payload while executing a Beacon Object File (BOF). Normally, Beacon is left exposed during BOF execution. If some behavior from a user-provided BOF triggers a memory scan by an EDR product, then Beacon will likely be detected in memory. Since Cobalt Strike&#39;s 4.7 release, users are able to provide a Sleep Mask to hide Beacon while it is sleeping, which is implemented as a BOF provided by the user. This demonstrates that it is possible to execute a BOF while Beacon is masked.&lt;/p&gt; &#xA;&lt;p&gt;The actual implementation of this is simple: A setup function, GetBeaconBaseAddress, is used to generate a key and find Beacon&#39;s base address. Beacon&#39;s base address is located by going up two stack frames to find the return address after the BOF finishes executing. This will be an address within Beacon&#39;s .text section, which we can pass in to the VirtualQuery API to get the base address of the .text section. Then, a simple XOR mask is used to hide Beacon, and the memory protection setting changed with the VirtualProtect API.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;One of the main goals of this code was to enable users to drop it into their existing BOF arsenals, with minimal modifications. To that end, using the BOF mask is fairly simple.&lt;/p&gt; &#xA;&lt;p&gt;You must call the GetBeaconBaseAddress function from within your BOF entrypoint. You CANNOT call another function from your entrypoint and then call GetBeaconBaseAddress. If &#34;go&#34; is the name of the function that beacon will execute in your BOF, you must call GetBeaconBaseAddress from within &#34;go&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve called GetBeaconBaseAddress to set everything up, you can toggle the BOF mask with MaskBeacon and UnmaskBeacon. There are two main caveats here: You CANNOT call Beacon API functions while Beacon is masked, and if you do not call MaskBeacon and UnmaskBeacon in the right order then your Beacon WILL DIE! For example, if you call MaskBeacon twice in a row without unmasking, then Beacon will be XOR&#39;d twice and a call to UnmaskBeacon will not fix it. If you call UnmaskBeacon twice then you may get an access violation, as Beacon may not be writable.&lt;/p&gt; &#xA;&lt;p&gt;Below is a simple intended use case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void go(char* args, int length){&#xA;    //YOUR CODE HERE, YOU MUST CALL ANY ARGUMENT UNPACKING FUNCTIONS BEFORE CALLING MaskBeacon&#xA;    GetBeaconBaseAddress();&#xA;    //YOU CAN STILL CALL BEACON APIS HERE&#xA;    MaskBeacon();&#xA;&#xA;    //YOUR CODE HERE&#xA;    //DO NOT CALL ANY BEACON APIS BETWEEN MASKING AND UNMASKING!!!!! IT WILL KILL YOUR BEACON!!!!!&#xA;&#xA;    UnmaskBeacon();&#xA;    //YOUR CODE HERE, YOU CAN NOW CALL BEACON APIS AGAIN&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The example.c file contains a simple use case which masks Beacon, calls MessageBoxA to block execution, and then unmasks Beacon.&lt;/p&gt; &#xA;&lt;h2&gt;Compiling&lt;/h2&gt; &#xA;&lt;p&gt;This code is intended to be compiled with MINGW. You can compile the example BOF included in this repository like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x86_64-w64-mingw32-gcc -c example.c -o example.x64.o -masm=intel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Defensive considerations&lt;/h3&gt; &#xA;&lt;p&gt;Detecting BOF execution by Beacon is not a particularly fruitful area to focus on. Ultimately, Beacon Object Files are just position independent code loaded by a few benign API calls (LoadLibraryA/GetProcAddress/VirtualAlloc/etc.). It should be much more productive to focus on preventing the initial Beacon execution, or detecting the subsequent post-exploitation activity. For a BOF to be useful it must generate some activity on the host or network, such as enumerating Active Directory via LDAP or performing credential dumping attacks.&lt;/p&gt; &#xA;&lt;p&gt;That said, this technique does leave the executing BOF (and the Sleep Mask BOF, if one is in use) in memory as unbacked RX (or RWX) regions. These are generally a good indicator of malicious activity for threat hunters and memory scanners. However, there are ways for these artifacts to be hidden by a skilled operator.&lt;/p&gt; &#xA;&lt;p&gt;Below is a non-comprehensive list of resources that you can use for detecting Cobalt Strike.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cobalt Strike YARA rules - Elastic - &lt;a href=&#34;https://github.com/elastic/protections-artifacts/raw/main/yara/rules/Windows_Trojan_CobaltStrike.yar&#34;&gt;https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_CobaltStrike.yar&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;PE-Sieve - Hasherezade - &lt;a href=&#34;https://github.com/hasherezade/pe-sieve&#34;&gt;https://github.com/hasherezade/pe-sieve&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Moneta - Forrest Orr - &lt;a href=&#34;https://github.com/forrest-orr/moneta&#34;&gt;https://github.com/forrest-orr/moneta&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Hunt Sleeping Beacons - @thefLinkk - &lt;a href=&#34;https://github.com/thefLink/Hunt-Sleeping-Beacons&#34;&gt;https://github.com/thefLink/Hunt-Sleeping-Beacons&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;BeaconEye - Ceri Coburn - &lt;a href=&#34;https://github.com/CCob/BeaconEye&#34;&gt;https://github.com/CCob/BeaconEye&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Cobalt Strike, A Defenders Guide - DFIR Report - &lt;a href=&#34;https://thedfirreport.com/2021/08/29/cobalt-strike-a-defenders-guide/&#34;&gt;https://thedfirreport.com/2021/08/29/cobalt-strike-a-defenders-guide/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>