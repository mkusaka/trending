<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-21T01:24:28Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xscorp/jsmug</title>
    <updated>2024-03-21T01:24:28Z</updated>
    <id>tag:github.com,2024-03-21:/xscorp/jsmug</id>
    <link href="https://github.com/xscorp/jsmug" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A PoC code for JSON Smuggling technique to smuggle arbitrary files through JSON&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;jsmug - JSON Smuggler&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;jsmug&lt;/code&gt; is a simple PoC code for JSON smuggling technique. JSON smuggling technique takes advantage of insignificant bytes in a JSON document to smuggle arbitrary files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Compilation:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gcc jsmug.c -o ./jsmug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Encoding file:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./jsmug encode &amp;lt;input_file_name&amp;gt; &amp;lt;output_file_name&amp;gt; &amp;lt;bytes_per_pair&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./jsmug encode ./malicious-binary encoded-binary.json 20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the below example, We encoded &lt;code&gt;naabu&lt;/code&gt; binary in a JSON file named &lt;code&gt;sweet-document.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xscorp/jsmug/main/media/encoding-demo.png&#34; alt=&#34;Encoding File&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Decoding file:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./jsmug decode &amp;lt;encoded_file_name&amp;gt; &amp;lt;output_file_name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./jsmug encode ./encoded-binary.json decoded-binary&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the below example, We decoded the &lt;code&gt;sweet-document.json&lt;/code&gt; JSON file generated earlier to retrieve original &lt;code&gt;naabu&lt;/code&gt; binary named &lt;code&gt;decoded-binary&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xscorp/jsmug/main/media/decoding-demo.png&#34; alt=&#34;Decoding File&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;As per the &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc8259#section-2&#34;&gt;JSON RFC&lt;/a&gt;, Certain bytes known as insignificant bytes are allowed at certain positions in a JSON file. These insignificant bytes carry no meaning in a JSON document and hence are ignored by JSON parsing tools such as &lt;code&gt;jq&lt;/code&gt;. There are 4 allowed insignificant bytes mentioned in the JSON RFC:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;0x09 (Horizontal Tab)&lt;/li&gt; &#xA; &lt;li&gt;0x0a (New Line)&lt;/li&gt; &#xA; &lt;li&gt;0x0d (Carriage Return)&lt;/li&gt; &#xA; &lt;li&gt;0x20 (Space)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since these bytes are invisible to human eye and also ignored by JSON parsers, These 4 bytes can be used for encoding arbitrary data or file. Same as we use Base 2 system for representing something in binary format, We can use a Base 4 sytem to represent data using these 4 bytes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;                                      +---+---+                                                                                         &#xA;                --------------------  | A | B |  -------------------------                          Raw Bytes                           ▲&#xA;                |                     +---+---+                          |                                                              |&#xA;                |                                                        |                                                              |   ENCODING&#xA;                |                                                        |                                                              |       ▼&#xA;                |                                                        |                                                              |       ▼&#xA;                |                                                        |                                                              |       ▼&#xA;+---+---+---+---+---+---+---+---+                         +---+---+---+---+---+---+---+---+                                             |       ▼&#xA;| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |                         | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 2 |         Base4 Representation                |       ▼&#xA;+---+---+---+---+---+---+---+---+                         +---+---+---+---+---+---+---+---+                                             |&#xA;                |                                                       |                                                               |&#xA;                |                                                       |                                                               |&#xA;                |                                                       |                                                               |&#xA;+----+----+----+----+----+----+----+----+         +----+----+----+----+----+----+----+----+                                             |&#xA;| \t | \t | \t | \t | \n | \t | \t | \n |         | \t | \t | \t | \t | \n | \t | \t | \r |         Custom Base4 Symbol Representation  |&#xA;+----+----+----+----+----+----+----+----+         +----+----+----+----+----+----+----+----+                                             |&#xA;                    \                                                 /                                                                 |&#xA;                     \                                               /                                                                  |&#xA;                      \                                             /                                                                   |&#xA;                       \                                           /                                                                    |&#xA;                        \                                         /                                                                     |&#xA;    +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+                                                   |&#xA;    | \t | \t | \t | \t | \n | \t | \t | \n | \t | \t | \t | \t | \n | \t | \t | \r |               Payload Bytes                       |&#xA;    +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+                                                   |&#xA;                                            |                                                                                           |&#xA;                                            |                                                                                           |&#xA;                                            |   bytes_per_pair = 5;                                                                     |       ▲&#xA;                                            |   no_of_pairs = ceil(8 * 2 / 5 ) = 4                                                      |       ▲&#xA;                                            |                                                                                           |       ▲&#xA;                                            |                                                                                           |       ▲&#xA;            +----------------------------------------------------------------+                                                          |       ▲&#xA;            | {&#34;data&#34;:[\t\t\t\t\n{\t\t\n\t\t&#34;json&#34;\t\t\n\t\t:\r&#34;smuggled&#34;}]} |                      JSON Bytes                          |   DECODING&#xA;            +----------------------------------------------------------------+                                                          |&#xA;                       |=========| |=======|      |========| |=|                                                                        ▼&#xA;                            p1         p2             p3      p4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;The above ASCII diagram shows how raw bytes are represented in their Base4 representation. Then those Base4 bytes are mapped to their respective insignificant bytes. Based on the &lt;code&gt;bytes_per_pair&lt;/code&gt; specified, The Base4 symbol bytes are divided in pairs and placed at certain locations in a JSON document. The ability to specify how many bytes should be together assits in bypassing any detection rules written specifically for this kind of action.&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;The idea of smuggling files/binaries/data using this technique was based on an article by &lt;a href=&#34;https://grimminck.medium.com/&#34;&gt;Grimminck&lt;/a&gt; named &#34;&lt;a href=&#34;https://grimminck.medium.com/json-smuggling-a-far-fetched-intrusion-detection-evasion-technique-51ed8f5ee05f&#34;&gt;&lt;em&gt;JSON Smuggling: A far-fetched intrusion detection evasion technique&lt;/em&gt;&lt;/a&gt;&#34;. In his article, He demonstrates an undisclosed PoC for this techniqe, I thought it would be nice to try to create one myself.&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;While keeping a lower number for &lt;code&gt;bytes_per_pair&lt;/code&gt; would be nice to evade IDS, Please make sure you are using a higher number of &lt;code&gt;bytes_per_pair&lt;/code&gt; for files of bigger size as it might lead to size calculations exceeding &lt;code&gt;size_t&lt;/code&gt; limit ultimately resulting in a segmentation fault.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>dibyendumajumdar/ravi</title>
    <updated>2024-03-21T01:24:28Z</updated>
    <id>tag:github.com,2024-03-21:/dibyendumajumdar/ravi</id>
    <link href="https://github.com/dibyendumajumdar/ravi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ravi is a dialect of Lua, featuring limited optional static typing, JIT and AOT compilers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;========================= Ravi Programming Language&lt;/h1&gt; &#xA;&lt;p&gt;.. image:: &lt;a href=&#34;https://github.com/dibyendumajumdar/ravi/workflows/build/badge.svg&#34;&gt;https://github.com/dibyendumajumdar/ravi/workflows/build/badge.svg&lt;/a&gt; :target: &lt;a href=&#34;https://github.com/dibyendumajumdar/ravi&#34;&gt;https://github.com/dibyendumajumdar/ravi&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ravi is a dialect of &lt;code&gt;Lua &amp;lt;http://www.lua.org/&amp;gt;&lt;/code&gt;_ with limited optional static typing and features a JIT compiler powered by &lt;code&gt;MIR &amp;lt;https://github.com/vnmakarov/mir&amp;gt;&lt;/code&gt;_ as well as support for AOT compilation to native code. The name Ravi comes from the Sanskrit word for the Sun. Interestingly a precursor to Lua was &lt;code&gt;Sol &amp;lt;http://www.lua.org/history.html&amp;gt;&lt;/code&gt;_ which had support for static types; Sol means the Sun in Portugese.&lt;/p&gt; &#xA;&lt;p&gt;Lua is perfect as a small embeddable dynamic language so why a derivative? Ravi extends Lua with static typing for improved performance when JIT compilation is enabled. However, the static typing is optional and therefore Lua programs are also valid Ravi programs.&lt;/p&gt; &#xA;&lt;p&gt;There are other attempts to add static typing to Lua - e.g. &lt;code&gt;Typed Lua &amp;lt;https://github.com/andremm/typedlua&amp;gt;&lt;/code&gt;_ but these efforts are mostly about adding static type checks in the language while leaving the VM unmodified. The Typed Lua effort is very similar to the approach taken by Typescript in the JavaScript world. The static typing is to aid programming in the large - the code is eventually translated to standard Lua and executed in the unmodified Lua VM.&lt;/p&gt; &#xA;&lt;p&gt;My motivation is somewhat different - I want to enhance the VM to support more efficient operations when types are known. Type information can be exploited by JIT compilation technology to improve performance. At the same time, I want to keep the language safe and therefore usable by non-expert programmers.&lt;/p&gt; &#xA;&lt;p&gt;Of course there is the fantastic &lt;code&gt;LuaJIT &amp;lt;http://luajit.org&amp;gt;&lt;/code&gt;_ implementation. Ravi has a different goal compared to LuaJIT. Ravi prioritizes ease of maintenance and support, language safety, and compatibility with Lua 5.3, over maximum performance. For more detailed comparison please refer to the documentation links below.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optional static typing&lt;/li&gt; &#xA; &lt;li&gt;Type specific bytecodes to improve performance&lt;/li&gt; &#xA; &lt;li&gt;Compatibility with Lua 5.3 (see Compatibility section below)&lt;/li&gt; &#xA; &lt;li&gt;Generational GC from Lua 5.4&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;defer&lt;/code&gt; statement for releasing resources&lt;/li&gt; &#xA; &lt;li&gt;Compact JIT backend &lt;code&gt;MIR &amp;lt;https://github.com/vnmakarov/mir&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;distribution with batteries &amp;lt;https://github.com/dibyendumajumdar/Suravi&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;Visual Studio Code debugger extension &amp;lt;https://marketplace.visualstudio.com/items?itemName=ravilang.ravi-debug&amp;gt;&lt;/code&gt;_ - interpreted mode debugger&lt;/li&gt; &#xA; &lt;li&gt;A new compiler framework for &lt;code&gt;JIT and AOT compilation &amp;lt;https://the-ravi-programming-language.readthedocs.io/en/latest/ravi-compiler.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AOT Compilation to shared library &amp;lt;https://github.com/dibyendumajumdar/ravi/tree/master/aot-examples&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;Preview feature: Ability to &lt;code&gt;embed C code snippets &amp;lt;https://github.com/dibyendumajumdar/ravi-compiler/wiki/Embedding-C&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Articles about Ravi&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Ravi - Lua Dialect &amp;lt;https://medium.com/@dibyendumajumdar/ravi-a-lua-dialect-690f3844d4cd&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Embedding C code in Ravi &amp;lt;https://medium.com/@dibyendumajumdar/embedding-c-code-in-ravi-a-lua-dialect-1777c8be8819&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Reference Manual &amp;lt;https://the-ravi-programming-language.readthedocs.io/en/latest/ravi-reference.html&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MIR JIT Build instructions &amp;lt;https://the-ravi-programming-language.readthedocs.io/en/latest/ravi-mir-instructions.html&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Lua 2015 Workshop &amp;lt;http://www.lua.org/wshop15.html&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Lua 2022 Workshop &amp;lt;https://www.lua.org/wshop22.html&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Lua Goodies&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;An Introduction to Lua &amp;lt;http://the-ravi-programming-language.readthedocs.io/en/latest/lua-introduction.html&amp;gt;&lt;/code&gt;_ attempts to provide a quick overview of Lua for folks coming from other languages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Lua 5.3 Bytecode Reference &amp;lt;http://the-ravi-programming-language.readthedocs.io/en/latest/lua_bytecode_reference.html&amp;gt;&lt;/code&gt;_ is my attempt to bring up to date the &lt;code&gt;Lua 5.1 Bytecode Reference &amp;lt;http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;patch for Lua 5.3 &amp;lt;https://github.com/dibyendumajumdar/ravi/blob/master/patches/defer_statement_for_Lua_5_3.patch&amp;gt;&lt;/code&gt;_ implements the &#39;defer&#39; statement.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;patch for Lua 5.4.[0-2] &amp;lt;https://github.com/dibyendumajumdar/ravi/blob/master/patches/defer_statement_for_Lua_5_4.patch&amp;gt;&lt;/code&gt;_ implements the &#39;defer&#39; statement.&lt;/li&gt; &#xA; &lt;li&gt;Updated &lt;code&gt;patch for Lua 5.4.[3-4] &amp;lt;https://github.com/dibyendumajumdar/ravi/blob/master/patches/defer_statement_patch_for_Lua_5_4_3.patch&amp;gt;&lt;/code&gt;_ implements the &#39;defer&#39; statement.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Lua 5.4 Position Statement&lt;/h1&gt; &#xA;&lt;p&gt;Lua 5.4 relationship to Ravi is as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generational GC - back-ported to Ravi.&lt;/li&gt; &#xA; &lt;li&gt;New random number generator - back-ported to Ravi.&lt;/li&gt; &#xA; &lt;li&gt;Multiple user values can be associated with userdata - under consideration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;const&amp;gt;&lt;/code&gt; variables - not planned.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;close&amp;gt;&lt;/code&gt; variables - Ravi has &lt;code&gt;&#39;defer&#39;&lt;/code&gt; statement which is the better option in my opinion, hence no plans to support &lt;code&gt;&amp;lt;close&amp;gt;&lt;/code&gt; variables.&lt;/li&gt; &#xA; &lt;li&gt;Interpreter performance improvements - these are beneficial to Lua interpreter but not to the JIT backends, hence not much point in back-porting.&lt;/li&gt; &#xA; &lt;li&gt;Table implementation changes - under consideration.&lt;/li&gt; &#xA; &lt;li&gt;String to number coercion is now part of string library metamethods - back-ported to Ravi.&lt;/li&gt; &#xA; &lt;li&gt;utf8 library accepts codepoints up to 2^31 - back-ported to Ravi.&lt;/li&gt; &#xA; &lt;li&gt;Removal of compatibility layers for 5.1, and 5.2 - not implemented as Ravi continues to provide these layers as per Lua 5.3.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Compatibility with Lua 5.3&lt;/h1&gt; &#xA;&lt;p&gt;Ravi should be able to run all Lua 5.3 programs in interpreted mode, but following should be noted:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ravi supports optional typing and enhanced types such as arrays (see the documentation). Programs using these features cannot be run by standard Lua. However all types in Ravi can be passed to Lua functions; operations on Ravi arrays within Lua code will be subject to restrictions as described in the section above on arrays.&lt;/li&gt; &#xA; &lt;li&gt;Values crossing from Lua to Ravi will be subjected to typechecks should these values be assigned to typed variables.&lt;/li&gt; &#xA; &lt;li&gt;Upvalues cannot subvert the static typing of local variables (issue #26) when types are annotated.&lt;/li&gt; &#xA; &lt;li&gt;Certain Lua limits are reduced due to changed byte code structure. These are described below.&lt;/li&gt; &#xA; &lt;li&gt;Ravi uses an extended bytecode which means it is not compatible with Lua 5.x bytecode.&lt;/li&gt; &#xA; &lt;li&gt;Ravi incorporates the new Generational GC from Lua 5.4, hence the GC interface has changed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;+-----------------+-------------+-------------+ | Limit name | Lua value | Ravi value | +=================+=============+=============+ | MAXUPVAL | 255 | 125 | +-----------------+-------------+-------------+ | LUAI_MAXCCALLS | 200 | 125 | +-----------------+-------------+-------------+ | MAXREGS | 255 | 125 | +-----------------+-------------+-------------+ | MAXVARS | 200 | 125 | +-----------------+-------------+-------------+ | MAXARGLINE | 250 | 120 | +-----------------+-------------+-------------+&lt;/p&gt; &#xA;&lt;p&gt;When JIT compilation is enabled there are following additional constraints:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ravi will only execute JITed code from the main Lua thread; any secondary threads (coroutines) execute in interpreter mode.&lt;/li&gt; &#xA; &lt;li&gt;In JITed code tailcalls are implemented as regular calls so unlike the interpreter VM which supports infinite tail recursion JIT compiled code only supports tail recursion to a depth of about 110 (issue #17)&lt;/li&gt; &#xA; &lt;li&gt;Debug api and hooks are not supported in JIT mode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;History&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2015 - Implemented JIT compilation using LLVM - Implemented &lt;code&gt;libgccjit based alternative JIT &amp;lt;https://github.com/dibyendumajumdar/ravi/tree/gccjit-ravi534&amp;gt;&lt;/code&gt;_ (now discontinued)&lt;/li&gt; &#xA; &lt;li&gt;2016 - Implemented debugger for Ravi and Lua 5.3 for &lt;code&gt;Visual Studio Code &amp;lt;https://github.com/dibyendumajumdar/ravi/tree/master/vscode-debugger&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;2017 - Embedded C compiler using dmrC project (C JIT compiler) (now discontinued) - Additional type-annotations&lt;/li&gt; &#xA; &lt;li&gt;2018 - Implemented &lt;code&gt;Eclipse OMR JIT backend &amp;lt;https://github.com/dibyendumajumdar/ravi/tree/omrjit&amp;gt;&lt;/code&gt;_ (now discontinued) - Created &lt;code&gt;Ravi with batteries &amp;lt;https://github.com/dibyendumajumdar/Suravi&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA; &lt;li&gt;2019 - New language feature - &lt;code&gt;defer&lt;/code&gt; statement - New JIT backend &lt;code&gt;MIR &amp;lt;https://github.com/vnmakarov/mir&amp;gt;&lt;/code&gt;_.&lt;/li&gt; &#xA; &lt;li&gt;2020 - &lt;code&gt;New parser / type checker / compiler &amp;lt;https://github.com/dibyendumajumdar/ravi-compiler&amp;gt;&lt;/code&gt;_ - Generational GC back-ported from Lua 5.4 - Support for &lt;code&gt;LLVM backend &amp;lt;https://github.com/dibyendumajumdar/ravi/tree/llvm&amp;gt;&lt;/code&gt;_ archived&lt;/li&gt; &#xA; &lt;li&gt;2021 - Integrated AOT and JIT compilation support - &lt;code&gt;Embedded C syntax &amp;lt;https://github.com/dibyendumajumdar/ravi-compiler/wiki/Embedding-C&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;2022-2023 - Improve Embedded C support with more validation - Improve tests and documentation overall - Ensure new compiler is production grade (i.e. always generates correct code)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;MIT License&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>X1Plus/X1Plus</title>
    <updated>2024-03-21T01:24:28Z</updated>
    <id>tag:github.com,2024-03-21:/X1Plus/X1Plus</id>
    <link href="https://github.com/X1Plus/X1Plus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Custom firmware for Bambu Lab X1 and X1 Carbon 3D printers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;X1Plus&lt;/h1&gt; &#xA;&lt;h2&gt;Installation instructions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Welcome to X1Plus!&lt;/em&gt; If you&#39;re a user, you probably want to &lt;a href=&#34;https://github.com/X1Plus/X1Plus/wiki&#34;&gt;go straight to the wiki&lt;/a&gt;, which tells you everything you need to know about installing and using X1Plus on your printer.&lt;/p&gt; &#xA;&lt;p&gt;The rest of this file has boring stuff for really big nerds who want to develop X1Plus.&lt;/p&gt; &#xA;&lt;h2&gt;Development instructions&lt;/h2&gt; &#xA;&lt;p&gt;Ok, don&#39;t say I didn&#39;t warn you. Anyway, hi! Glad you&#39;re interested in contributing to X1Plus! Here is a bunch of information on how to build it, how it&#39;s structured internally, and various things you might need to know about how to make changes and how to contribute back. X1Plus is the result of a year or so of vaguely-structured work; it started life as a fairly frumious hack, and over the past few months, we&#39;ve been working hard to try to clean it up for release to the outside world. All that said, there are parts that you will find are still a mess, and for that, we&#39;re truly sorry! We hope you&#39;ll come play around with it anyway. There&#39;s a lot of fun stuff to be done, and we have only barely scratched the surface so far.&lt;/p&gt; &#xA;&lt;h3&gt;How do I get started?&lt;/h3&gt; &#xA;&lt;p&gt;Probably the easiest way to get started building X1Plus is in a Docker container. If you&#39;re adventurous, you can probably build X1Plus on any old Linux machine (I do), but if you do that and it breaks, we really don&#39;t want to hear about it, so you really should just build it in Docker. You&#39;ll need the filesystem decryption key from a live printer (running either X1Plus or the Official Rootable Firmware) in order to build X1Plus; try something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone ...&#xA;$ cd X1Plus&#xA;$ docker build -t x1plusbuild scripts/docker/&#xA;$ docker run -u `id -u` -v `pwd`:/work x1plusbuild bash -c &#39;git config --global --add safe.directory /work&#39;&#xA;$ docker run -u `id -u` -v `pwd`:/work x1plusbuild make scripts&#xA;$ scp scripts/getkey root@bambu:/tmp&#xA;$ ssh root@bambu /tmp/getkey &amp;gt;&amp;gt; localconfig.mk&#xA;$ docker run -u `id -u` -v `pwd`:/work x1plusbuild make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With some luck, you should get a &lt;code&gt;.x1p&lt;/code&gt; file in your working directory! You can copy that to your SD card (&lt;code&gt;scp&lt;/code&gt; it over -- never remove an SD card from a live X1Plus system, you goofball), reboot your printer, and install it from the menu.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re going to make changes to any of the UI files, you should really read the rest of this document... otherwise you might be in for a nasty surprise next time you &lt;code&gt;git pull&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How does X1Plus work, from the printer&#39;s perspective?&lt;/h3&gt; &#xA;&lt;p&gt;The core concept of X1Plus is that we build an overlay on top of the Bambu Lab firmware, and replace only the parts that we need in order to launch X1Plus. We are very careful not to redistribute any of Bambu Lab&#39;s IP directly; when it&#39;s necessary to use or patch Bambu Lab binaries, we download them directly from Bambu Lab servers, and then patch them onboard the printer. We also try to be pretty careful to leave the printer in a &#34;fail-safe&#34; state by modifying as little of the on-printer flash as possible. Below is a rough flow of how X1Plus works, from installer through to normal boot.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Host-side installer.&lt;/strong&gt; The host-side installer is an Electron app that wraps all the logic to check whether the printer is running a supported version of the base firmware, and that wraps the mechanics of logging into the printer over MQTT, over FTP, and over SSH. (In development versions of X1Plus that relied on exploits to install, the PC-side installer was somewhat more complicated!) Roughly, this is implemented in &lt;code&gt;installer-clientside/install-gui/src/index.ts&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The installer copies an &lt;code&gt;.x1p&lt;/code&gt; image to the SD card, as well as a small tarball containing the on-printer install GUI stub. It SSHes to the printer, unpacks the tarball into &lt;code&gt;/userdata&lt;/code&gt; on the printer, and runs a first-stage installer launch script that it (hopefully) unpacked; then, it waits for MQTT messages that indicate the progress of the installation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;First-stage install scripts.&lt;/strong&gt; The first-stage installer (implemented in &lt;code&gt;installer-clientside/stage1/x1plus/launch.sh&lt;/code&gt;) first shuts down the printer&#39;s service checker (otherwise, the GUI would get restarted!), and then shuts down the GUI. It drops a marker for the host-side installer to indicate that it has started up, and then relaunches the printer&#39;s GUI engine with X1Plus&#39;s setup GUI injected into it to replace the normal printer GUI.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;X1Plus setup GUI.&lt;/strong&gt; The precise mechanism by which we inject code into the GUI is interesting, but it is somewhat getting ahead of ourselves to discuss it exactly at this moment :) I&#39;ll talk about that in a moment. For now, all you really need to know is that this is implemented in QML, with &lt;code&gt;bbl_screen-patch/kexec_ui/printerui/qml/Screen.qml&lt;/code&gt; as the initial item (the C++ native components live in &lt;code&gt;bbl_screen-patch/interpose.cpp&lt;/code&gt;). As you might suspect from the name, this GUI is also part of the X1Plus boot process, but the first-stage installer launches it in such a way that the GUI goes straight into the installer screen. The installer mechanism, the &lt;code&gt;SelectX1pPage&lt;/code&gt;, looks for &lt;code&gt;.x1p&lt;/code&gt; images on the SD card, and asks the user which &lt;code&gt;x1p&lt;/code&gt; to install. (An &lt;code&gt;x1p&lt;/code&gt; is just a zip file that has an &lt;code&gt;info.json&lt;/code&gt; and a &lt;code&gt;payload.tar.gz&lt;/code&gt; in it.) Once the user chooses an &lt;code&gt;x1p&lt;/code&gt; file, &lt;code&gt;InstallingPage&lt;/code&gt; unpacks the &lt;code&gt;payload.tar.gz&lt;/code&gt; into &lt;code&gt;/userdata&lt;/code&gt;, invokes the Python-based install backend, and begins listening for DDS messages with status updates. (DDS is an internal pubsub message bus.)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Python install backend.&lt;/strong&gt; The mechanics of what the Python installer does is probably better served by reading the code for it, which is in &lt;code&gt;installer/install.py&lt;/code&gt;. We drop a precompiled version of Python into &lt;code&gt;/userdata&lt;/code&gt;, and to communicate with the DDS message bus, we use &lt;code&gt;ctypes&lt;/code&gt; to talk to the DDS system libraries. Roughly, the Python installer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;checks to make sure that the printer&#39;s device tree is known and compatible;&lt;/li&gt; &#xA; &lt;li&gt;backs up a few printer configuration objects to the SD card;&lt;/li&gt; &#xA; &lt;li&gt;downloads an original firmware from Bambu Lab;&lt;/li&gt; &#xA; &lt;li&gt;decrypts it and decompresses it, unpacks the ext2 filesystem image, and then repacks that filesystem as a squashfs on the SD card;&lt;/li&gt; &#xA; &lt;li&gt;creates an ext4 loopback file on the SD card;&lt;/li&gt; &#xA; &lt;li&gt;copies an overlay squashfs and a kernel to the SD card;&lt;/li&gt; &#xA; &lt;li&gt;writes a bootloader stub to the printer&#39;s internal filesystem;&lt;/li&gt; &#xA; &lt;li&gt;and reports success, and offers to reboot.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(You can read the details of each of those in the Python installer itself.) When installation is complete, the printer reboots into the slightly modified internal filesystem.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;On boot: SD card check and GUI display.&lt;/strong&gt; When the printer powers up, it boots first into the onboard eMMC installation, as normal. We inject a shell script into &lt;code&gt;/etc/init.d/S75kexec&lt;/code&gt;, which subsequently launches &lt;code&gt;/opt/kexec/check_kexec&lt;/code&gt;. (Both of these scripts live in &lt;code&gt;internal-fs/&lt;/code&gt; in this tree.) This script checks an &#34;emergency override&#34; (engaged by pressing and holding the POWER and ESTOP buttons while powering the printer up), and if those buttons are pressed, it quits as quickly as possible to return control to the internal printer firmware. Otherwise, it launches the same GUI as was used in the X1Plus Setup process above, and offers to either boot into SD card firmware or run advanced options. (Because it was launched from the actual boot process, the &lt;code&gt;dialog/KexecDialog&lt;/code&gt; is presented, rather than the &lt;code&gt;SelectX1pPage&lt;/code&gt;.) If the user chooses to boot from the SD card, the shell script &lt;code&gt;/opt/kexec/boot&lt;/code&gt; runs and prepares to boot the printer into the new kernel.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;kexec&#39;ing into the new world.&lt;/strong&gt; Things start getting weird here, and fast. The net result of this stage is that we are going to reboot the printer into a custom-compiled kernel. The process of doing so is rather unusual; because we can&#39;t convince the first-stage bootloader on the system to do our bidding (the kernel is signed from that perspective), we need to hot-reboot. We perform the following steps in order to do this.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First, we hash the running kernel&#39;s device tree (or, at least, keys of it that we care about) to make sure that we have an appropriate device tree for the kernel that we are going to jump into. We have a somewhat modified device tree; since we want to patch in the printer&#39;s serial number and similar things, we compile it at runtime using a &lt;code&gt;dtc&lt;/code&gt; that we have on the printer. (This also chooses the correct includes to make sure we light up the correct one of four possible LCD panels that the printer could come with.)&lt;/li&gt; &#xA; &lt;li&gt;We prepare a few other parameters for the new kernel, and its userspace, including what we currently think the printer&#39;s serial number is, and which filesystems we will want to mount when we come back up.&lt;/li&gt; &#xA; &lt;li&gt;Now we start getting a little bit creative. We want to use &lt;code&gt;kexec&lt;/code&gt;, but the Bambu Lab kernel does not have &lt;code&gt;kexec&lt;/code&gt; built in; worse, &lt;code&gt;kexec&lt;/code&gt; is nominally only available as a compiled-in option, so we can&#39;t compile a module for it from kernel sources. Luckily for us, there have been a series of attempts to make this work -- originally, &lt;a href=&#34;https://github.com/amonakov/kexec-module&#34;&gt;amonakov&#39;s &lt;code&gt;kexec-module&lt;/code&gt;&lt;/a&gt;, and subsequently, &lt;a href=&#34;https://github.com/fabianishere/kexec-mod&#34;&gt;fabianishere&#39;s &lt;code&gt;kexec-mod-arm64&lt;/code&gt;&lt;/a&gt;! We build on this work in &lt;code&gt;kexec-mod/&lt;/code&gt;, where we port this kernel module to ARM32. Much of the Rockchip SoC gets astonishingly angry if hot-rebooted; we very carefully reset large chunks of the SoC&#39;s state in &lt;code&gt;kexec-mod/kernel/arch/arm/machine_kexec_drv.c&lt;/code&gt;. To get access to many of the symbols we need, even if they are not &lt;code&gt;EXPORT_SYMBOL&lt;/code&gt;, we bootstrap with &lt;code&gt;kallsyms_lookup_name&lt;/code&gt; (which we, uh, grab from &lt;code&gt;/proc/kallsyms&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;We load a kernel from the SD card, load our compiled device tree, load an initramfs from the SD card, and then have &lt;code&gt;kexec&lt;/code&gt; do its thing; away we go, sailing into the New World.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Setting up the overlays in the initramfs.&lt;/strong&gt; Once the new kernel boots, the first userspace code that executes is an initramfs, with init being a shellscript that lives, oddly enough, in &lt;code&gt;initramfs/init&lt;/code&gt;. We start off by painting a cute logo, and setting a larger font on screen. Then, roughly, we:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mount the SD card. It should be FAT32; with particularly slow SD cards, it might take a bit to enumerate.&lt;/li&gt; &#xA; &lt;li&gt;Mount each of the base layers. At compile and install time, we build a bunch of squashfses: a Bambu Lab base image, a custom firmware overlay, and a GUI patch overlay.&lt;/li&gt; &#xA; &lt;li&gt;Mount the persistent overlay storage layer, which is an ext4fs that lives in a file on the FAT32 partition.&lt;/li&gt; &#xA; &lt;li&gt;Create an overlay that stacks up each of these into a single root partition. Bind the overlay around as needed, and then...&lt;/li&gt; &#xA; &lt;li&gt;Transfer control to the &#34;real&#34; &lt;code&gt;init&lt;/code&gt; process.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At the moment that &lt;code&gt;init&lt;/code&gt; gets control, the filesystem looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/             # Combined root filesystem, including all layers.&#xA;/mnt/sdcard   # SD card mount moved to be a subtree of the new root.&#xA;/mnt/rootfs   # Access to the &#34;real&#34; root filesystem, so that kernel drivers can see it if needed.&#xA;/mnt/overlay  # tmpfs containing individual overlay layers, including:&#xA;/mnt/overlay/00.00.28.55.squashfs    # Repacked Bambu base filesystem&#xA;/mnt/overlay/1.0.squashfs            # Precompiled X1Plus filesystem&#xA;/mnt/overlay/bbl_screen-1.0.squashfs # Patched bbl_screen image&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Booting the OS.&lt;/strong&gt; OS boot is mostly unremarkable, but we do override some components of the base system. See &lt;code&gt;images/cfw/etc/init.d/&lt;/code&gt; for bits and pieces that we override.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Launching the patched GUI.&lt;/strong&gt; Here is the other sort of &#34;interesting and creative&#34; bit of X1Plus: how we patch the GUI. Our general goal is that we wish to redistribute as little of Bambu Lab&#39;s IP as possible, and instead, only redistribute our own modifications to it. The mechanics of this is all handled by &lt;code&gt;bbl_screen-patch/&lt;/code&gt;, which ultimately spits out a &lt;code&gt;printer_ui.so&lt;/code&gt; that gets &lt;code&gt;LD_PRELOAD&lt;/code&gt;ed into &lt;code&gt;bbl_screen&lt;/code&gt;. Here is the rough process from start to finish of how that happens; most of it happens at build time:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We start by extracting all of the Qt resources from the original &lt;code&gt;bbl_screen&lt;/code&gt;. We do this by statically looking up all of the callsites of &lt;code&gt;qInitResources&lt;/code&gt;, and then using the Unicorn Engine to emulate the instructions leading up to them. Once we know the arguments to each call of &lt;code&gt;qInitResources&lt;/code&gt;, we know the in-memory locations of each resource bundle, and we traverse the Qt resource bundle hierarchy to extract each bundle to its constituent files, and a &lt;code&gt;root.qrc&lt;/code&gt; that can be later used to recompile a resource bundle. This all happens in &lt;code&gt;extract_qrc.py&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Once we have unpacked the resource bundle to the &lt;code&gt;printer_ui-orig&lt;/code&gt; directory, we copy it to a new directory, and apply all of the patches in the &lt;code&gt;patches/&lt;/code&gt; folder, using &lt;code&gt;patcher.py&lt;/code&gt;. This creates a &lt;code&gt;printer_ui/&lt;/code&gt; with our new GUI bundle.&lt;/li&gt; &#xA; &lt;li&gt;We then compile a resource bundle with &lt;code&gt;rcc&lt;/code&gt;. We also compile an interposer that will intercept the appropriate call to &lt;code&gt;qInitResources&lt;/code&gt; and replace it with our resource bundle, as well as adding a handful of other helpful C++ classes; this lives in &lt;code&gt;interpose.cpp&lt;/code&gt;, which is at least lightly commented. All of these get linked together into a &lt;code&gt;printer_ui.so&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Because the &lt;code&gt;printer_ui.so&lt;/code&gt; has a meaningful amount of original Bambu Lab IP in it, we do not want to redistribute this directly; instead, we distribute an &lt;code&gt;xdelta&lt;/code&gt;-encoded patch from the original &lt;code&gt;bbl_screen&lt;/code&gt;, which we reassemble into a &lt;code&gt;printer_ui.so&lt;/code&gt; at install time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At last, you have a beautiful X1Plus splash screen!&lt;/p&gt; &#xA;&lt;h3&gt;How does the X1Plus build system work?&lt;/h3&gt; &#xA;&lt;p&gt;This probably could use a fair bit more discussion, but in short, you should be able to just &lt;code&gt;make&lt;/code&gt;. I would describe it better, but it is really quite embarrassing. The Electron installer app really is not integrated into the build system yet, and if you intend to hack on that, you should probably ask about it if you cannot decipher it already.&lt;/p&gt; &#xA;&lt;p&gt;One thing to think about is that, by default, &lt;code&gt;bbl_screen-patch/Makefile&lt;/code&gt; will overwrite the &lt;code&gt;printer_ui&lt;/code&gt; directory if it believes that the &lt;code&gt;patches&lt;/code&gt; directory has changed. This is great if you are just building from git, but if you are actually trying to make changes to the &lt;code&gt;printer_ui&lt;/code&gt;, this is rather surprising behavior. To avoid this, you can put &lt;code&gt;NO_AUTO_PATCH=yes&lt;/code&gt; in your &lt;code&gt;localconfig.mk&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You almost certainly want to build in Docker.&lt;/p&gt; &#xA;&lt;h3&gt;How do I contribute?&lt;/h3&gt; &#xA;&lt;p&gt;For better or for worse, we do most of our development discussion in Discord. Because of how much of a pain it is to merge &lt;code&gt;printer_ui&lt;/code&gt; patches, please let other people know what you&#39;re working on!&lt;/p&gt; &#xA;&lt;p&gt;We work with pull requests and bug reports on GitHub. Please reserve bug reports for actually triaged -- or, if not triaged, triageable -- bugs; if you have usage questions, please talk about those in &#34;Discussions&#34;!&lt;/p&gt; &#xA;&lt;p&gt;Please be reasonable human beings to each other. It is just a 3D printer. If you have a problem, please chat with some of the maintainers and we will try to help you resolve it.&lt;/p&gt; &#xA;&lt;h3&gt;Who is X1Plus?&lt;/h3&gt; &#xA;&lt;p&gt;X1Plus was written by a small number of people, not all of whom wish to be publicly identified. You might see a handful names around the code from people who don&#39;t mind sharing their identity, but there were many more people behind the scenes who have contributed over time!&lt;/p&gt; &#xA;&lt;h3&gt;Miscellaneous stuff&lt;/h3&gt; &#xA;&lt;p&gt;This probably ought go into a wiki page, but, you know, here we are.&lt;/p&gt; &#xA;&lt;h4&gt;Building a kernel&lt;/h4&gt; &#xA;&lt;p&gt;As of writing, it&#39;s not necessary to build a kernel image yourself as there&#39;s one present in &lt;code&gt;prebuilt&lt;/code&gt;. But you can! This might be desirable to enable other kernel features for development, or to build a kernel module against.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install prerequestites, including &lt;code&gt;lz4&lt;/code&gt; for compressing the final image.&lt;/li&gt; &#xA; &lt;li&gt;Install the appropriate toolchain.&lt;/li&gt; &#xA; &lt;li&gt;Grab the latest kernel source from &lt;a href=&#34;https://github.com/X1Plus/x1-linux-kernel&#34;&gt;our repository&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Ensure the toolchain is on your PATH, and add LDFLAGS/CCFLAGS to point to the toolchain (unsure how necessary this is): &lt;pre&gt;&lt;code&gt;export LDFLAGS=&#34;-L$TOOLCHAIN/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf \&#xA;-Larm-linux-gnueabihf/libc/usr/lib/ -L/usr/arm-linux-gnueabihf/lib/&#34;&#xA;export CCFLAGS=&#34;-I$TOOLCHAIN/include -I/usr/include&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;From the root of kernel folder, run &lt;code&gt;make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- O=build x1plus_defconfig&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;make mrproper&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;CD into &lt;code&gt;build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;sed -i &#39;s/YYLTYPE yylloc/extern YYLTYPE yylloc/&#39; ./scripts/dtc/dtc-lexer.lex.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage&lt;/code&gt; to build the kernel. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You probably want to add &lt;code&gt;-jn&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of threads (logical cores) you have available to dramatically speed up building (using all threads may slow down OS).&lt;/li&gt; &#xA;   &lt;li&gt;Build output file is &lt;code&gt;arch/arm/boot/zImage&lt;/code&gt; you can copy this over &lt;code&gt;prebuilt/kernel&lt;/code&gt; to use it with this repo.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>