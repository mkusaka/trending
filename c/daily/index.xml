<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-21T01:31:45Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>little-brother/sqlite-gui</title>
    <updated>2023-04-21T01:31:45Z</updated>
    <id>tag:github.com,2023-04-21:/little-brother/sqlite-gui</id>
    <link href="https://github.com/little-brother/sqlite-gui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight SQLite editor for Windows&lt;/p&gt;&lt;hr&gt;&lt;p&gt;sqlite-gui is a lightweight &lt;a href=&#34;https://www.sqlite.org/index.html&#34;&gt;SQLite&lt;/a&gt; editor for Windows powered by C++/mingw64/WinAPI.&lt;br&gt; Small, simple, &lt;a href=&#34;https://youtu.be/lctkqWD7HTk&#34;&gt;powerfull&lt;/a&gt;, fast, free.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/releases/latest&#34;&gt;&lt;strong&gt;Download the latest version&lt;/strong&gt;&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/little-brother/sqlite-gui/master/resources/demo.webp&#34; alt=&#34;View&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Syntax highlighting and code completion&lt;/li&gt; &#xA; &lt;li&gt;Edit multiple tables at the same time&lt;/li&gt; &#xA; &lt;li&gt;Colorized data grid&lt;/li&gt; &#xA; &lt;li&gt;Store an execution history and user scripts&lt;/li&gt; &#xA; &lt;li&gt;Export/Import data&lt;/li&gt; &#xA; &lt;li&gt;Database diagram&lt;/li&gt; &#xA; &lt;li&gt;Database comparison&lt;/li&gt; &#xA; &lt;li&gt;Search text in the whole database&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#quick-references&#34;&gt;Quick data references&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/little-brother/sqlite-gui/master/resources/terminal.webp&#34;&gt;Terminal mode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#charts&#34;&gt;Charts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#query-parameters&#34;&gt;Query parameters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#query-shortcuts&#34;&gt;Query shortcuts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#custom-functions&#34;&gt;Custom functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#jinja-scripting&#34;&gt;Jinja scripting&lt;/a&gt; (experimental)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#data-generator&#34;&gt;Data generator&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#extensions&#34;&gt;Extension pack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki#rest-api-web-server&#34;&gt;Built-in REST API web server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Demo database &#34;Bookstore&#34; for beginners&lt;/li&gt; &#xA; &lt;li&gt;Does not require installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Need a much simpler tool? Try &lt;a href=&#34;https://github.com/little-brother/sqlite-x&#34;&gt;sqlite-x&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;If you like the project, press the like-button on &lt;a href=&#34;https://alternativeto.net/software/sqlite-gui/about&#34;&gt;AlternativeTo&lt;/a&gt; or rate the app on &lt;a href=&#34;https://www.softpedia.com/get/Internet/Servers/Database-Utils/SQLite-GUI-LB.shtml&#34;&gt;Softpedia&lt;/a&gt; to support it.&lt;br&gt; If you have any problems, comments or suggestions, check &lt;a href=&#34;https://github.com/little-brother/sqlite-gui/wiki&#34;&gt;Wiki&lt;/a&gt;, create &lt;a href=&#34;https://github.com/little-brother/sqlite-gui/issues&#34;&gt;issue&lt;/a&gt; or just let me know &lt;a href=&#34;mailto:lb.im@yandex.ru?subject=sqlite-gui&#34;&gt;&lt;/a&gt;&lt;a href=&#34;mailto:lb.im@yandex.ru&#34;&gt;lb.im@yandex.ru&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>M0nster3/RpcsDemo</title>
    <updated>2023-04-21T01:31:45Z</updated>
    <id>tag:github.com,2023-04-21:/M0nster3/RpcsDemo</id>
    <link href="https://github.com/M0nster3/RpcsDemo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RpcsDemo&lt;/h1&gt; &#xA;&lt;p&gt;Description&lt;/p&gt; &#xA;&lt;h2&gt;1、前言&lt;/h2&gt; &#xA;&lt;p&gt;本项目主要编写了一些利用RPC协议在内网中的一些攻击面，有时候Bypass EDR等设备会有较好的效果，那么什么是RPC呢，RPC 代表“远程过程调用”，它不是 Windows 特定的概念。RPC 的第一个实现是在80年代在UNIX系统上实现的。这允许机器在网络上相互通信，它甚至被“用作网络文件系统（NFS）的基础”，其实简单的说就是它允许请求另一台计算机上的服务。&lt;/p&gt; &#xA;&lt;p&gt;Demo大部分都是参考了impact工具，大家可以查看impacket源码，发现更多有趣的攻击面。&lt;/p&gt; &#xA;&lt;h2&gt;2、相关Demo的功能&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Demo&lt;/th&gt; &#xA;   &lt;th&gt;注释&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DumpLsass&lt;/td&gt; &#xA;   &lt;td&gt;Dump lsass.exe&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MS-SAMR/AddUser&lt;/td&gt; &#xA;   &lt;td&gt;添加用户&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MS-SAMR/ChangeNtlm&lt;/td&gt; &#xA;   &lt;td&gt;通过NTLM hash修改密码&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MS-TSCH_DESK&lt;/td&gt; &#xA;   &lt;td&gt;创建计划任务&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OXIDINterka_network_card&lt;/td&gt; &#xA;   &lt;td&gt;探测内网多网卡&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;RPC over SMB&lt;/td&gt; &#xA;   &lt;td&gt;通过SMB做信息探测（无Demo）&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CreateService&lt;/td&gt; &#xA;   &lt;td&gt;创建服务&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;3、后续打算出一篇相关相关Demo的原理&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.t00ls.com/articles-68609.html&#34;&gt;https://www.t00ls.com/articles-68609.html&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rvs/planD</title>
    <updated>2023-04-21T01:31:45Z</updated>
    <id>tag:github.com,2023-04-21:/rvs/planD</id>
    <link href="https://github.com/rvs/planD" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Plan9 from Containerspace&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;planD: Plan9 from Containerspace&lt;/h1&gt; &#xA;&lt;p&gt;Looking back at it from 2020 it clearly seems that the Original &lt;a href=&#34;https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs&#34;&gt;Plan9&lt;/a&gt; was very much ahead of its time. Some of its insigts are much better appreciated 30 years later when the general &#34;zeitgeist&#34; of the software developer community has enthusiastically moved towards fully distributed, eventually consistent systems. These types of software systems may feel new, but a lot of the &lt;a href=&#34;http://doc.cat-v.org/plan_9/1st_edition/designing_plan_9&#34;&gt;ideas&lt;/a&gt; behind them were first articulated and implemented in Plan9.&lt;/p&gt; &#xA;&lt;p&gt;One of these fundamental ideas was the notion of a system composed of microservices communicating via a well established system of network API requests encoded as 9P messages. Of course, these days, we would express a system like this through use of containarized applications communicating via REST or gRPC. Some even suggest that &lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45406.pdf&#34;&gt;these new patterns&lt;/a&gt; will be as influential in software design as object oriented patterns have been. While the jury is still very much out on that bombastic claim (and arguably the Gang of Four book has done more damanage than good to teh software industry) one fact is undeniable: OCI contatiners have very much become the building blocks of moderm distributed systems.&lt;/p&gt; &#xA;&lt;p&gt;Container technology like Docker, however, is great at helping you package your application inside of the container, but it doesn&#39;t really help in figuring out what is that you are packaging. There are multiple attempts of retrofiting old school Unix/Linux development tools to this new cotnainerized world. Arguably, the rise of Alpine Linux as a basis for how UNIX applications need to be containerized is a direct result of trying to answer this question: &lt;a href=&#34;https://blogs.vmware.com/opensource/2020/02/27/distribution-tools-container-creation/&#34;&gt;what are the best building blocks to go inside containers&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project attempts at giving an answer to the same question that is rooted in Plan9, rather than UNIX software development culture. After all, what was Plan9 if not an attempt to fix all the cruft that accumulated in UNIX over the years!&lt;/p&gt; &#xA;&lt;p&gt;One final note before we deep dive into containerizing Plan9. A lot what you will read here is condensed presentation of the following 5 resources. Each of them is absolutely amazing in its own right and contains treasure troves of collective Plan9 wisdom:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://9p.io/plan9/index.html&#34;&gt;Plan 9 from Bell Labs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://cat-v.org/&#34;&gt;cat-v.org&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://9p.io/wiki/plan9/plan_9_wiki/&#34;&gt;Plan 9 Wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://9front.org/&#34;&gt;9front.org&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.ueber.net/who/mjl/plan9/plan9-obsd.html&#34;&gt;plan 9 on openbsd&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to help with this project, please take a look at the #TODO list at the bottom.&lt;/p&gt; &#xA;&lt;h2&gt;Plan9 on &#34;cloud native&#34; infrastructure&lt;/h2&gt; &#xA;&lt;p&gt;Plan9 was concieved in an infrastructure landscape that was massively heterogenous hardware and (worse yet!) &lt;a href=&#34;http://doc.cat-v.org/plan_9/4th_edition/papers/net/&#34;&gt;networking&lt;/a&gt; perspectives. Today&#39;s &#34;cloud native&#34; infrastructure is mostly amd64 and arm64 compute devices connected by TCP/IP networks. On the compute side, you can consume that infrastrucure by leveraging one of the two runtime APIs:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;a generalized Virtual Machine API&lt;/li&gt; &#xA; &lt;li&gt;a POSIX-like process group API (typically backed by a Linux kernel)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;1. VM API&lt;/h3&gt; &#xA;&lt;p&gt;VM APIs are the closes to the original view that Plan9 had of hardware infrastructure. In fact, the job of a Plan9 kernel can be greatly simplified today since there&#39;s absolutely no need to support the vast collection of various I/O devices: a very basic set of disk, network and serial devices emulated by the VMM would suffice (it will be nice, however, to support virtio in Plan9: see our #TODO list). In fact, the boostrapping phases of the Plan9 kernel and how they interplay is extremely congenial with the &#34;cloud native&#34; infrastructure views of today:&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Plan9 has an ability of producing a self-contained &lt;a href=&#34;https://9p.io/magic/man2html/8/9boot&#34;&gt;multiboot&lt;/a&gt; kernel binary from its build. On some systems this kernel binary can be used directly, on other ones it needs to be wrapped into a trivial disk image.&lt;/li&gt; &#xA; &lt;li&gt;As a matter of fact, the self-contained nature of the Plan9 kernel image extends beyound just the binary bits that get loaded into kernel memory. Plan9 as an ability of also packaging filesystem content of the initial root filesystem right into the kernel binary itself (thus obviating the need for things like initrd in Linux). The content of this filesystem is managed by the &lt;a href=&#34;http://man.cat-v.org/plan_9/3/root&#34;&gt;root device&lt;/a&gt; and what files get included in the binary kernel image gets managed by &lt;a href=&#34;https://9p.io/sources/plan9/sys/src/9/pc/pc&#34;&gt;bootdir section&lt;/a&gt; of the architecture specific (the example above is for x86 architecture) Plan9 kernel build script (exploring various of those scripts in the same folder will give you a taste of how to build different flavors of Plan9 kernel).&lt;/li&gt; &#xA; &lt;li&gt;One of the files that gets included in that root device filesystem is &lt;code&gt;/boot/boot&lt;/code&gt;. This executable is the first one to run and &lt;a href=&#34;https://9p.io/magic/man2html/8/boot&#34;&gt;its job is to connect to the actual filesystem&lt;/a&gt;. As its last step, &lt;code&gt;/boot/boot&lt;/code&gt; executes &lt;code&gt;/$cputype/init [options]&lt;/code&gt; and at that point the Plan9 system is considered to be &lt;a href=&#34;https://9p.io/sources/plan9/sys/src/cmd/init.c&#34;&gt;fully bootstrapped&lt;/a&gt;. It must be kept in mind, that init is sensitive to what &#34;flavor&#34; of the Plan9 this is. You should just read the source above, but the key takeaway is that depending on the flavor you can expect &lt;code&gt;/rc/bin/cpurc&lt;/code&gt;, &lt;code&gt;/rc/bin/termrc&lt;/code&gt; and &lt;code&gt;lib/profile&lt;/code&gt; hooks to be called before init transitions into effectively a shell &lt;code&gt;/bin/rc&lt;/code&gt; console.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Most of the time Plan9 is pretty stateless so you can simply kill a VM without any kind of shutdown sequence. However, if your instance is managing disk (and thus state) you may need to call &lt;code&gt;fshalt -r&lt;/code&gt; which, provided that you booted with &lt;code&gt;acpi=1&lt;/code&gt; in &lt;code&gt;plan9.ini&lt;/code&gt; will also call &lt;a href=&#34;http://man.9front.org/8/fshalt&#34;&gt;scram(8)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Plan9 kernel booting can be further customized by using an intermediate boot kernel (yes! Plan9 effectively supported kexec way before Linux kids dreamt it up) passing a series of command line arguments to the final Plan9 kernel via &lt;a href=&#34;http://man.cat-v.org/plan_9/8/plan9.ini&#34;&gt;plan9.ini&lt;/a&gt;. This kind of boot sequence is described in &lt;a href=&#34;http://man.cat-v.org/plan_9/8/9boot&#34;&gt;9boot&lt;/a&gt; and is mostly helpful if you decide to do PXE booting.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://9legacy.org/&#34;&gt;Plan9 legacy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bitbucket.org/forsyth/plan9-9k/src/master/&#34;&gt;Plan9 9k&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;XXXX&lt;/h2&gt; &#xA;&lt;p&gt;how differnt things (networks, disk, bitmap) get represented in plan9 via devices (/dev/sdC0) and userspace (partfs)&lt;/p&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Provide a containerized (possbily based on linuxkit) build of a Plan9 kernel&lt;/li&gt; &#xA; &lt;li&gt;Explore linuxkit&#39;s ability to load various images into public clouds as VMs&lt;/li&gt; &#xA; &lt;li&gt;Explore running on Plan9 kernel on &lt;a href=&#34;https://github.com/firecracker-microvm/firecracker/raw/master/docs/getting-started.md&#34;&gt;firecracker VMM&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Implement &lt;a href=&#34;https://github.com/lf-edge/eve/raw/master/docs/HYPERVISORS.md#device-models&#34;&gt;key&lt;/a&gt; virtio devices in Plan9 kernel&lt;/li&gt; &#xA; &lt;li&gt;Explore &lt;a href=&#34;https://cloudboot.org/&#34;&gt;cloudboot&lt;/a&gt; for PXE booting Plan9&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>