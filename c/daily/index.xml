<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-30T01:32:38Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>reveng007/DarkWidow</title>
    <updated>2023-07-30T01:32:38Z</updated>
    <id>tag:github.com,2023-07-30:/reveng007/DarkWidow</id>
    <link href="https://github.com/reveng007/DarkWidow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Indirect Dynamic Syscall, SSN + Syscall address sorting via Modified TartarusGate approach + Remote Process Injection via APC Early Bird + Spawns a sacrificial Process as target process + (ACG+BlockDll) mitigation policy on spawned process + PPID spoofing + Api resolving from TIB + API hashing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DarkWidow&lt;/h1&gt; &#xA;&lt;p&gt;This is a Dropper/PostExploitation Tool (or can be used in both situations) targeting Windows.&lt;/p&gt; &#xA;&lt;h3&gt;Capabilities:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Indirect Dynamic Syscall&lt;/li&gt; &#xA; &lt;li&gt;SSN + Syscall address sorting via Modified TartarusGate approach&lt;/li&gt; &#xA; &lt;li&gt;Remote Process Injection via APC Early Bird&lt;/li&gt; &#xA; &lt;li&gt;Spawns a sacrificial Process as the target process&lt;/li&gt; &#xA; &lt;li&gt;ACG(Arbitrary Code Guard)/BlockDll mitigation policy on spawned process&lt;/li&gt; &#xA; &lt;li&gt;PPID spoofing (&lt;strong&gt;MITRE ATT&amp;amp;CK TTP: &lt;a href=&#34;https://attack.mitre.org/techniques/T1134/004/&#34;&gt;T1134.004&lt;/a&gt;&lt;/strong&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Api resolving from TIB (Directly via offset (from TIB) -&amp;gt; TEB -&amp;gt; PEB -&amp;gt; resolve Nt Api)&lt;/li&gt; &#xA; &lt;li&gt;Cursed Nt API hashing&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Bonus: If blessed with Admin privilege =&amp;gt;&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Disables Event Log via &lt;em&gt;killing&lt;/em&gt; EventLog Service Threads (&lt;strong&gt;MITRE ATT&amp;amp;CK TTP: &lt;a href=&#34;https://attack.mitre.org/techniques/T1562/002/&#34;&gt;T1562.002&lt;/a&gt;&lt;/strong&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Disadv&lt;/strong&gt;: If threads are resumed, all events that occurred during the suspension of Event Logger, get logged Again!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;So, thought of killing them instead!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;It&#39;s more Invasive than suspension, but the decision is always up to the operator. Besides, killing threads get logged on the kernel level&#34; - &lt;a href=&#34;https://twitter.com/Sektor7Net&#34;&gt;@SEKTOR7net&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;While Killing only those threads in the indirect syscall implant, was facing an error. I was unable to get the &#34;&lt;strong&gt;eventlog&lt;/strong&gt;&#34; &lt;em&gt;SubProcessTag Value&lt;/em&gt;. So thought of killing all threads, i.e. killing the whole process (responsible &lt;strong&gt;svchost.exe&lt;/strong&gt;). Yeah creating &lt;em&gt;&lt;strong&gt;an IOC&lt;/strong&gt;&lt;/em&gt;!.&lt;/h4&gt; &#xA;&lt;h3&gt;= EDR/Ring-3/UserLand hook Bypass!&lt;/h3&gt; &#xA;&lt;h3&gt;Compile:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;Directly via VS compiler:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/reveng007/Learning-EDR-and-EDR_Evasion/assets/61424547/622c39a1-c3b3-4388-ad3a-5a36d18e29ff&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Also add &lt;strong&gt;/MT&lt;/strong&gt; compiler flag! =&amp;gt; To statically links CRT functions together in a binary (Yeah, U guessed it, it bloats the implant)&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/reveng007/DarkWidow/assets/61424547/58e9a9d4-e068-4364-8114-96744bdbc0a7&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Also via compile.bat (prefer option 1.)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;./compile.bat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:&amp;gt; .\x64\Release\indirect.exe&#xA;[!] Wrong!&#xA;[-&amp;gt;] Syntax: .\x64\Release\indirect.exe &amp;lt;PPID to spoof&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;In Action:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/reveng007/DarkWidow/assets/61424547/62a90c5b-84af-4389-8ddc-9f7926debdcf&#34;&gt;https://github.com/reveng007/DarkWidow/assets/61424547/62a90c5b-84af-4389-8ddc-9f7926debdcf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Sofos XDR Bypass:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/SofosXDR.PNG&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Further Improvements:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;PPID spoofing (&lt;strong&gt;Emotet method&lt;/strong&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;Much Stealthier&lt;/strong&gt;&lt;/em&gt; Use Case of EventLog Disabling!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Portions of the Code and links those helped:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;TIB:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Win32_Thread_Information_Block&#34;&gt;https://en.wikipedia.org/wiki/Win32_Thread_Information_Block&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.wikiwand.com/en/Win32_Thread_Information_Block&#34;&gt;https://www.wikiwand.com/en/Win32_Thread_Information_Block&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GS and FS register:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/39137043/what-is-the-gs-register-used-for-on-windows&#34;&gt;https://stackoverflow.com/questions/39137043/what-is-the-gs-register-used-for-on-windows&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/10810203/what-is-the-fs-gs-register-intended-for#:~:text=The%20registers%20FS%20and%20GS,to%20access%20thread%2Dspecific%20memory&#34;&gt;https://stackoverflow.com/questions/10810203/what-is-the-fs-gs-register-intended-for#:~:text=The%20registers%20FS%20and%20GS,to%20access%20thread%2Dspecific%20memory&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;PEB LDR structure:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=9L9I1T5QDg4&amp;amp;t=205s&#34;&gt;BlackHat - What Malware Authors Don&#39;t Want You to Know - Evasive Hollow Process Injection&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/monnappa22&#34;&gt;@monnappa22&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;A pic of process Memory from the Above link:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/1.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;From &lt;a href=&#34;https://labs.cognisys.group/posts/Combining-Indirect-Dynamic-Syscalls-and-API-Hashing/#retrieving-apis-base-address&#34;&gt;labs.cognisys.group&lt;/a&gt;, a blog by &lt;a href=&#34;https://twitter.com/D1rkMtr&#34;&gt;@D1rkMtr &lt;/a&gt;:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/2.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;TIB -&amp;gt; TEB -&amp;gt; PEB -&amp;gt; Resolve Nt API and API hashing&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/41277888/iterating-over-peb-dllname-shows-only-exe-name&#34;&gt;https://stackoverflow.com/questions/41277888/iterating-over-peb-dllname-shows-only-exe-name&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://doxygen.reactos.org/d7/d55/ldrapi_8c_source.html#l01124&#34;&gt;https://doxygen.reactos.org/d7/d55/ldrapi_8c_source.html#l01124&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://labs.cognisys.group/posts/Combining-Indirect-Dynamic-Syscalls-and-API-Hashing/#retrieving-apis-base-address&#34;&gt;labs.cognisys.group&lt;/a&gt;, a blog by &lt;a href=&#34;https://twitter.com/D1rkMtr&#34;&gt;@D1rkMtr &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;A pic of the snippet from the above link, which I used here to resolve API dynamically without HardCoding Offsets:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/3.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ACG(Arbitrary Code Guard)/BlockDll mitigation policy:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;links:&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://blog.xpnsec.com/protecting-your-malware/&#34;&gt;Protecting Your Malware&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/_xpn_&#34;&gt;@&lt;em&gt;xpn&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/reveng007/AQUARMOURY/raw/1923e65190875f7c61c76fb430d526e5deaa062a/Wraith/Src/Injector.h&#34;&gt;Wraith&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/_winterknife_&#34;&gt;@winterknife&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/boku7/spawn&#34;&gt;spawn&lt;/a&gt; and &lt;a href=&#34;https://github.com/boku7/HOLLOW&#34;&gt;HOLLOW&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/0xBoku&#34;&gt;@0xBoku&lt;/a&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/4.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;PPID Spoofing Detection:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing&#34;&gt;PPID Spoofing Detect&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/spotheplanet&#34;&gt;@spotheplanet&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;If got time, I will be adding a detection Portion to this portion! -&amp;gt; &lt;em&gt;[Remaining..............................................!]&lt;/em&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Moneta Detection and PESieve Detection:\&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;Moneta&lt;/strong&gt;:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/5.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;PESieve&lt;/strong&gt;:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/6.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Capa Scan:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/7.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;How Thread Stack Looks of the Implant Process:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Implant Process&lt;/th&gt; &#xA;   &lt;th&gt;Legit Cmd process&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/8.png&#34; alt=&#34;alt text&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/9.png&#34; alt=&#34;alt text&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;It follows that by executing the return instruction in the memory of the ntdll.dll in the indirect syscall POC, the return address can be successfully spoofed, the ntdll.dll can be placed at the top of the call stack and the EDR will interpret a higher legitimacy.&lt;/strong&gt; - &lt;a href=&#34;https://twitter.com/VirtualAllocEx&#34;&gt;@VirtualAllocEx&lt;/a&gt; from &lt;a href=&#34;https://redops.at/blog/direct-syscalls-vs-indirect-syscalls&#34;&gt;DirectSyscall Vs Indirect Syscall&lt;/a&gt;&lt;br&gt; Also thanks to, &lt;a href=&#34;https://twitter.com/peterwintrsmith&#34;&gt;@peterwintrsmith&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol start=&#34;10&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;EventLogger Config, I used: &lt;img src=&#34;https://github.com/reveng007/DarkWidow/assets/61424547/c2005b8c-1750-4046-bffa-9d09eb4472a8&#34; alt=&#34;image&#34;&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/10.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Setting SeDebugPrivilege:&lt;br&gt; &lt;strong&gt;From&lt;/strong&gt; Here: &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/11.png&#34; alt=&#34;alt text&#34;&gt; &lt;strong&gt;To&lt;/strong&gt; Here: &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/12.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Killing Event Log Threads:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://institute.sektor7.net/rto-win-evasion&#34;&gt;rto-win-evasion&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/Sektor7Net&#34;&gt;@SEKTOR7net&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/hlldz/Phant0m&#34;&gt;Phant0m&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/hlldz&#34;&gt;@hlldz&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/reveng007/AQUARMOURY/raw/master/Goblin/Src/EventLog.h&#34;&gt;Goblin&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/_winterknife_&#34;&gt;@winterknife&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.ired.team/offensive-security/defense-evasion/disabling-windows-event-logs-by-suspending-eventlog-service-threads&#34;&gt;disabling-windows-event-logs-by-suspending-eventlog-service-threads&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/spotheplanet&#34;&gt;@spotheplanet&lt;/a&gt;&lt;br&gt; &lt;strong&gt;From&lt;/strong&gt; here:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/13.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt; &lt;strong&gt;To&lt;/strong&gt; here:&lt;br&gt; &lt;img src=&#34;https://github.com/reveng007/DarkWidow/raw/main/img/14.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;This Method, Ended up causing errors in indirect syscall implementation. So, I ended up killing all those threads present within responsible svchost.exe&lt;/strong&gt; (reason: &lt;a href=&#34;https://github.com/reveng007/DarkWidow/edit/main/README.md#bonus-if-blessed-with-admin-privilege-&#34;&gt;Go up&lt;/a&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Major Thanks for helping me out (Directly/indirectly (pun NOT intended :))):&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/Sektor7Net&#34;&gt;@SEKTOR7net&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/peterwintrsmith&#34;&gt;@peterwintrsmith&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/Jean_Maes_1994&#34;&gt;@Jean_Maes_1994&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/D1rkMtr&#34;&gt;@D1rkMtr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/spotheplanet&#34;&gt;@spotheplanet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/0xBoku&#34;&gt;@0xBoku&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/Sh0ckFR&#34;&gt;@Sh0ckFR&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/_winterknife_&#34;&gt;@winterknife&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/monnappa22&#34;&gt;@monnappa22&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/_xpn_&#34;&gt;@&lt;em&gt;xpn&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/hlldz&#34;&gt;@hlldz&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;I hope I didn&#39;t miss someone!&lt;/p&gt; &#xA;&lt;h3&gt;This project is a part of my journey to learn about EDR World! =&amp;gt; &lt;a href=&#34;https://github.com/reveng007/Learning-EDR-and-EDR_Evasion&#34;&gt;Learning-EDR-and-EDR_Evasion&lt;/a&gt;&lt;/h3&gt;</summary>
  </entry>
  <entry>
    <title>tomojitakasu/PocketSDR</title>
    <updated>2023-07-30T01:32:38Z</updated>
    <id>tag:github.com,2023-07-30:/tomojitakasu/PocketSDR</id>
    <link href="https://github.com/tomojitakasu/PocketSDR" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;strong&gt;Pocket SDR - An Open-Source GNSS SDR, ver. 0.8&lt;/strong&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Overview&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Pocket SDR is an open-source GNSS (Global Navigation Satellite System) receiver based on SDR (software defined radio) technology. It consists of a RF front-end device, some utilities for the device and GNSS-SDR APs (application programs) written in Python and C. It supports almost all signals for GPS, GLONASS, Galileo, QZSS, BeiDou, NavIC and SBAS.&lt;/p&gt; &#xA;&lt;p&gt;The RF front-end device consists of 2 CH Maxim MAX2771 GNSS RF front-end IC (LNA, mixer, filter, ADC, frequency synthesizer) and Cypress EZ-USB FX2LP USB 2.0 controller to connect to host PCs. The front-end CH1 is dedicated for GNSS L1 band (1525 - 1610 MHz) and CH2 is for GNSS L2/L5/L6 band (1160 - 1290 MHz). The frequency of the reference oscillator (TCXO) is 24.000 MHz and ADC sampling frequency can be configured up to 24 MHz.&lt;/p&gt; &#xA;&lt;p&gt;Pocket SDR contains some utility programs for the RF front-end device to configure the device, capture and dump the digitized IF (inter-frequency) data. These supports Windows, Linux and other environments.&lt;/p&gt; &#xA;&lt;p&gt;Pocket SDR also provides GNSS-SDR APs to show the PSD (power spectrum density) of captured IF data, search the GNSS signals, track these signals and decode navigation data in them. The supported GNSS signals are as follows. These APs are written in Python by very compact way. They are easily modified by users to add user&#39;s unique algorithms.&lt;/p&gt; &#xA;&lt;p&gt;GPS: L1C/A, L1CP, L1CD, L2CM, L5I, L5Q, GLONASS: L1C/A, L2C/A, L3OCD, L3OCP, Galileo: E1B, E1C, E5aI, E5aQ, E5bI, E5bQ, E6B, E6C, QZSS: L1C/A, L1C/B, L1CP, L1CD, L1S, L2CM, L5I, L5Q, L5SI, L5SQ, L6D, L6E, BeiDou: B1I, B1CP, B1CD, B2I, B2aD, B2aP, B2bI, B3I, NavIC: L5-SPS, SBAS: L1C/A, L5I, L5Q&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/pocket_sdr_image.jpg&#34; width=&#34;80%&#34;&gt; &#xA;&lt;p&gt;The introduction of Pocket SDR is shown in the following slides.&lt;/p&gt; &#xA;&lt;p&gt;T.Takasu, An Open Source GNSS SDR: Development and Application, IPNTJ Next GNSS Technology WG, Feb 21, 2022 (&lt;a href=&#34;https://gpspp.sakura.ne.jp/paper2005/IPNTJ_NEXTWG_202202.pdf&#34;&gt;https://gpspp.sakura.ne.jp/paper2005/IPNTJ_NEXTWG_202202.pdf&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Package Structure&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;PocketSDR --+-- bin     Pocket SDR utilities and APs binary programs for Windows&#xA;            +-- app     Pocket SDR utilities and APs source programs&#xA;            +-- src     Pocket SDR library source programs&#xA;            +-- python  Pocket SDR Python scripts&#xA;            +-- lib     External library for utilities and APs&#xA;            +-- conf    Configuration files for device settings&#xA;            +-- driver  Windows driver for EZ-USB FX2LP/FX3 (cyusb3.sys) ([4])&#xA;            +-- doc     Documents (ref {1], [2])&#xA;            +-- FW      Firmware source programs and images&#xA;            |   +-- cypress  Cypress libraries for EZ-USB firmware development&#xA;            |                (ref [4])&#xA;            +-- HW      Pocket SDR RF frontend CAD data and parts list&#xA;            |           (*.brd and *.sch are for Eagle, *.f3d is for Fusion 360)&#xA;            +-- image   Image files for documents&#xA;            +-- sample  Sample digital IF data captured by Pocket SDR&#xA;            +-- test    Test codes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Installation for Windows&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Extract PocketSDR.zip to an appropriate directory &amp;lt;install_dir&amp;gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Attach Pocket SDR RF frontend to PC via USB cable.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install USB driver (CYUSB) for Pocket SDR RF frontend according to PocketSDR\driver\readme.txt.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the Pocket SDR binary programs path (&amp;lt;install_dir&amp;gt;\PocketSDR\bin) to the command search path (Path) of Windows environment variables.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the Pocket SDR Python scripts path (&amp;lt;install_dir&amp;gt;\PocketSDR\python) to the command search path (Path) of Windows environment variables.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To rebuild the binary programs, you need MinGW64 and libusb-1.0 library. Refer MSYS2 (&lt;a href=&#34;https://www.msys2.org/&#34;&gt;https://www.msys2.org/&lt;/a&gt;) for details.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In MinGW64 environment, you need fftw3 library. To install fftw3 library.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ pacman -S mingw-w64-x86_64-fftw&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Installation for Linux&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extract PocketSDR.zip to an appropriate directory &amp;lt;install_dir&amp;gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ unzip PocketSDR.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install libusb-1.0 developtment package. For Ubuntu:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ sudo apt install libusb-1.0-0-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install libfftw3 developtment package. For Ubuntu:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ sudo apt install libfftw3-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Move to the library directory, build libraries.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ cd &amp;lt;install_dir&amp;gt;/lib/build&#xA;    $ make&#xA;    $ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Move to the source program directory, build utilities and APs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ cd &amp;lt;install_dir&amp;gt;/app&#xA;    $ make&#xA;    $ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the Pocket SDR binary programs path (&amp;lt;install_dir&amp;gt;/PocketSDR/bin) to the command search path.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Usually you need to have root permission to access USB devices. So you add sudo to execute pocket_conf, pocket_dump like:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;   $ sudo pocket_conf ../conf/pocket_L1L6_12MHz.conf&#xA;   $ sudo pocket_dump -t 10 ch1.bin ch2.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Utility Programs for RF frontend&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Pocket SDR contains the following utility programs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_conf&lt;/strong&gt;: SDR device configurator&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_scan&lt;/strong&gt;: Scan and list USB Devices&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_dump&lt;/strong&gt;: Capture and dump digital IF data of SDR device&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For details, refer comment lines in src/pocket_conf.c, src/pocket_scan.c, src/pocket_dump.c.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;GNSS-SDR APs (Application Programs)&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Pocket SDR contains the following application programs for GNSS-SDR.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_psd.py&lt;/strong&gt; : Plot PSD and histgrams of digital IF data&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_acq.py&lt;/strong&gt; : GNSS signal acquisition in digital IF data&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_trk.py&lt;/strong&gt; : GNSS signal tracking and navigation data decoding in digital IF data&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_snap.py&lt;/strong&gt;: Snapshot positioning with digital IF data&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_plot.py&lt;/strong&gt;: Plot GNSS signal tracking log by pocket_trk.py&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_acq&lt;/strong&gt; : C-version of pocket_acq.py (w/o graph plots)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pocket_trk&lt;/strong&gt; : C-version of pocket_trk.py (w/o graph plots)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For details, refer comment lines in python/pocket_psd.py, python/pocket_acq.py, python/pocket_trk.py, python/pocket_snap.py and python/pocket_plot.py. You need Python 3, Numpy, Scipy and matplotlib to execute Python scripts. pocket_trk.py uses external shared libraries of LIBFEC [5] and RTKLIB [6] in lib/ directory. These were built for Windows (64bit) and Linux for x86_64 CPU.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Execution Examples of Utility Programs and GNSS-SDR APs&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ pocket_conf&#xA;    ...&#xA;    $ pocket_conf conf/pocket_L1L6_12MHz.conf&#xA;    Pocket SDR device settings are changed.&#xA;    &#xA;    $ pocket_dump -t 5 ch1.bin ch2.bin&#xA;      TIME(s)    T   CH1(Bytes)   T   CH2(Bytes)   RATE(Ks/s)&#xA;          5.0    I     59768832  IQ    119537664      11922.8&#xA;    &#xA;    $ pocket_psd.py ch1.bin -f 12 -h&#xA;    $ pocket_acq.py ch1.bin -f 12 -fi 3 -sig L1CA -prn 1-32,193-199&#xA;    PRN   1: SIG= L1CA, COFF=  0.12817 ms, DOP=  3500 Hz, C/N0= 37.4 dB-Hz&#xA;    PRN   2: SIG= L1CA, COFF=  0.85242 ms, DOP= -3500 Hz, C/N0= 36.8 dB-Hz&#xA;    PRN   3: SIG= L1CA, COFF=  0.39400 ms, DOP= -2000 Hz, C/N0= 37.0 dB-Hz&#xA;    PRN   4: SIG= L1CA, COFF=  0.96692 ms, DOP=  2000 Hz, C/N0= 44.7 dB-Hz&#xA;    ...&#xA;    $ pocket_acq.py ch1.bin -f 12 -fi 3 -sig L1CA -prn 26&#xA;&#xA;    $ pocket_acq.py ch1.bin -f 12 -fi 3 -sig L1CA -prn 26 -3d&#xA;&#xA;    $ pocket_acq.py ch2.bin -f 12 -sig L6D -prn 194 -p&#xA;    &#xA;    $ pocket_trk.py L1_24M.bin -prn 1-32 -f 24 -fi 6&#xA;&#x9;  TIME(s)   SIG  PRN  STATE   LOCK(s)  C/N0 (dB-Hz)        COFF(ms)   DOP(Hz)   ADR(cyc)  SYNC #NAV #ERR&#xA;&#x9;    1.550  L1CA    1   LOCK     1.539  42.5 ||||||||      0.8017699    3218.8     4949.3  ---     0    0&#xA;&#x9;    0.011  L1CA    2   IDLE     0.000   0.0               0.0000000       0.0        0.0  ---     0    0&#xA;&#x9;    0.011  L1CA    3   IDLE     0.000   0.0               0.0000000       0.0        0.0  ---     0    0&#xA;&#x9;    0.011  L1CA    4   IDLE     0.000   0.0               0.0000000       0.0        0.0  ---     0    0&#xA;&#x9;    0.011  L1CA    5   IDLE     0.000   0.0               0.0000000       0.0        0.0  ---     0    0&#xA;&#x9;    0.011  L1CA    6   IDLE     0.000   0.0               0.0000000       0.0        0.0  ---     0    0&#xA;&#x9;    1.550  L1CA    7   LOCK     1.539  45.7 ||||||||||    0.6995059     582.8      901.5  ---     0    0&#xA;&#x9;    1.550  L1CA    8   LOCK     1.539  47.6 |||||||||||   0.0733506    -777.2    -1196.8  ---     0    0&#xA;&#x9;    0.011  L1CA    9   IDLE     0.000   0.0               0.0000000       0.0        0.0  ---     0    0&#xA;&#x9;    1.550  L1CA   10   LOCK     1.539  38.6 |||||         0.8658548      -6.2       -9.4  ---     0    0&#xA;&#x9;...&#xA;    $ pocket_trk.py L1_24M.bin -prn 194 -sig L1CA -f 24 -fi 6 -log trk.log  -p&#xA;    ...&#xA;    $ pocket_trk.py L5_24M.bin -prn 13 -sig E5AI -f 24 -log trk.log -p -ts 0.2&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/image001.jpg&#34; width=&#34;49%&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/image002.jpg&#34; width=&#34;49%&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/image003.jpg&#34; width=&#34;49%&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/image004.jpg&#34; width=&#34;49%&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/image005.jpg&#34; width=&#34;49%&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/image006.jpg&#34; width=&#34;49%&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tomojitakasu/PocketSDR/master/image/image007.jpg&#34; width=&#34;49%&#34;&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Rebuild F/W and Write F/W Image to Pocket SDR RF frontend&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Cypress EZ-USB FX2LP Development Kit (ref [4]) to a Windows PC. As default, it is installed to C:\Cypress and C:\Keil.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Execute Keil uVision2 (C:\Keil\UV2\uv2.exe).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Execute Menu Project - Open Project, select &amp;lt;install_dir&amp;gt;\PocketSDR\FW\pocket_fw.Uv2&amp;gt; and open the project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Execute Menu Project - Rebuild all target files and you can get a F/W image as &amp;lt;install_dir&amp;gt;\PocketSDR\FW\pocket_fw.iic.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Attach Pocket SDR RF frontend via USB cable to the PC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Execute USB Control Center (C:\Cypress\USB\CY3684_EZ-USB_FX2LP_DVK\1.1\Windows Applications&lt;br&gt; c_sharp\controlcenter\bin\Release\CyControl.exe).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select Cypress FX2LP Sample Device, execute menu Program - FX2 - 64KB EEPROM, select the F/W image &amp;lt;install_dir&amp;gt;\PocketSDR\FW\pocket_fw.iic and open it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you see &#34;Programming succeeded.&#34; in status bar, the F/W is properly written to PocketSDR.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To use utility programs for Pocket SDR, you need to reinstall WinUSB driver for Pocket SDR. Refer &#34;Installation for Windows&#34; above.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;[1] Maxim integrated, MAX2771 Multiband Universal GNSS Receiver, July 2018&lt;/p&gt; &#xA;&lt;p&gt;[2] Cypress, EZ-USB FX2LP USB Microcontroller High-Speed USB Peripheral Controller, Rev. AB, December 6, 2018&lt;/p&gt; &#xA;&lt;p&gt;[3] (deleted)&lt;/p&gt; &#xA;&lt;p&gt;[4] Cypress, CY3684 EZ-USB FX2LP Development Kit (&lt;a href=&#34;https://www.cypress.com/documentation/development-kitsboards/cy3684-ez-usb-fx2lp-development-kit&#34;&gt;https://www.cypress.com/documentation/development-kitsboards/cy3684-ez-usb-fx2lp-development-kit&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;[5] &lt;a href=&#34;https://github.com/quiet/libfec&#34;&gt;https://github.com/quiet/libfec&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;[6] &lt;a href=&#34;https://github.com/tomojitakasu/RTKLIB&#34;&gt;https://github.com/tomojitakasu/RTKLIB&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;strong&gt;History&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2021-10-20 0.1 1st draft version&lt;/li&gt; &#xA; &lt;li&gt;2021-10-25 0.2 Add Rebuild F/W and Write F/W Image to PocketSDR&lt;/li&gt; &#xA; &lt;li&gt;2021-12-01 0.3 Add and modify Python scripts&lt;/li&gt; &#xA; &lt;li&gt;2021-12-25 0.4 Add and modify Python scripts&lt;/li&gt; &#xA; &lt;li&gt;2022-01-05 0.5 Fix several problems.&lt;/li&gt; &#xA; &lt;li&gt;2022-01-13 0.6 Add and modify Python scripts&lt;/li&gt; &#xA; &lt;li&gt;2022-02-15 0.7 Improve performance, Add some Python scripts.&lt;/li&gt; &#xA; &lt;li&gt;2022-07-08 0.8 Add C-version of pocket_acq.py and pocket_trk.py.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>lrh2000/StackRot</title>
    <updated>2023-07-30T01:32:38Z</updated>
    <id>tag:github.com,2023-07-30:/lrh2000/StackRot</id>
    <link href="https://github.com/lrh2000/StackRot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CVE-2023-3269: Linux kernel privilege escalation vulnerability&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;StackRot (CVE-2023-3269): Linux kernel privilege escalation vulnerability&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/lrh2000/StackRot/actions&#34;&gt;&lt;img src=&#34;https://github.com/lrh2000/StackRot/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/lrh2000/StackRot/actions&#34;&gt;&lt;em&gt;(GitHub-CI-verified exploit)&lt;/em&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A flaw was found in the handling of stack expansion in the Linux kernel 6.1 through 6.4, aka &#34;Stack Rot&#34;. The maple tree, responsible for managing virtual memory areas, can undergo node replacement without properly acquiring the MM write lock, leading to use-after-free issues. An unprivileged local user could use this flaw to compromise the kernel and escalate their privileges.&lt;/p&gt; &#xA;&lt;p&gt;As StackRot is a Linux kernel vulnerability found in the memory management subsystem, it affects almost all kernel configurations and requires minimal capabilities to trigger. However, it should be noted that maple nodes are freed using RCU callbacks, delaying the actual memory deallocation until after the RCU grace period. Consequently, exploiting this vulnerability is considered challenging.&lt;/p&gt; &#xA;&lt;p&gt;To the best of my knowledge, there are currently no publicly available exploits targeting use-after-free-by-RCU (UAFBR) bugs. This marks the first instance where UAFBR bugs have been proven to be exploitable, even without the presence of CONFIG_PREEMPT or CONFIG_SLAB_MERGE_DEFAULT settings. Notably, this exploit has been successfully demonstrated in the environment provided by &lt;a href=&#34;https://google.github.io/kctf/vrp.html&#34;&gt;Google kCTF VRP&lt;/a&gt; (&lt;a href=&#34;https://storage.googleapis.com/kctf-vrp-public-files/bzImage_upstream_6.1.25&#34;&gt;bzImage_upstream_6.1.25&lt;/a&gt;, &lt;a href=&#34;https://storage.googleapis.com/kctf-vrp-public-files/bzImage_upstream_6.1.25_config&#34;&gt;config&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The StackRot vulnerability has been present in the Linux kernel since version 6.1 when the VMA tree structure was &lt;a href=&#34;https://lore.kernel.org/lkml/20220906194824.2110408-1-Liam.Howlett@oracle.com/&#34;&gt;changed&lt;/a&gt; from red-black trees to maple trees.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Whenever the &lt;code&gt;mmap()&lt;/code&gt; system call is utilized to establish a memory mapping, the kernel generates a structure called &lt;code&gt;vm_area_struct&lt;/code&gt; to represent the corresponding virtual memory area (VMA). This structure stores various information including flags, properties, and other pertinent details related to the mapping.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct vm_area_struct {&#xA;        long unsigned int          vm_start;             /*     0     8 */&#xA;        long unsigned int          vm_end;               /*     8     8 */&#xA;        struct mm_struct *         vm_mm;                /*    16     8 */&#xA;        pgprot_t                   vm_page_prot;         /*    24     8 */&#xA;        long unsigned int          vm_flags;             /*    32     8 */&#xA;        union {&#xA;                struct {&#xA;                        struct rb_node rb __attribute__((__aligned__(8))); /*    40    24 */&#xA;                        /* --- cacheline 1 boundary (64 bytes) --- */&#xA;                        long unsigned int rb_subtree_last; /*    64     8 */&#xA;                } __attribute__((__aligned__(8))) shared __attribute__((__aligned__(8))); /*    40    32 */&#xA;                struct anon_vma_name * anon_name;        /*    40     8 */&#xA;        } __attribute__((__aligned__(8)));               /*    40    32 */&#xA;        /* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */&#xA;        struct list_head           anon_vma_chain;       /*    72    16 */&#xA;        struct anon_vma *          anon_vma;             /*    88     8 */&#xA;        const struct vm_operations_struct  * vm_ops;     /*    96     8 */&#xA;        long unsigned int          vm_pgoff;             /*   104     8 */&#xA;        struct file *              vm_file;              /*   112     8 */&#xA;        void *                     vm_private_data;      /*   120     8 */&#xA;        /* --- cacheline 2 boundary (128 bytes) --- */&#xA;        atomic_long_t              swap_readahead_info;  /*   128     8 */&#xA;        struct vm_userfaultfd_ctx  vm_userfaultfd_ctx;   /*   136     0 */&#xA;&#xA;        /* size: 136, cachelines: 3, members: 14 */&#xA;        /* forced alignments: 1 */&#xA;        /* last cacheline: 8 bytes */&#xA;} __attribute__((__aligned__(8)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Subsequently, when the kernel encounters page faults or other memory-related system calls, it requires fast lookup of the VMA solely based on the address. Previously, the VMAs were managed using red-black trees. However, starting from Linux kernel version 6.1, the migration to maple trees took place. &lt;a href=&#34;https://docs.kernel.org/6.4/core-api/maple_tree.html&#34;&gt;Maple trees&lt;/a&gt; are RCU-safe B-tree data structures optimized for storing non-overlapping ranges. Nonetheless, their intricate nature adds complexity to the codebase and introduces the StackRot vulnerability.&lt;/p&gt; &#xA;&lt;p&gt;At its core, a maple tree is made up of maple nodes. While the tree&#39;s structure may be complex, it&#39;s important to note that this complexity has nothing to do with the StackRot bug. Therefore, throughout this article, it is assmued that the maple tree consists of only one node, i.e., the root node.&lt;/p&gt; &#xA;&lt;p&gt;This root node can contain up to 16 intervals. These intervals may either represent a gap or point to a VMA. As gaps also count as intervals, all intervals are connected sequentially, resulting in the need for only 15 endpoints, also known as pivots, within the node&#39;s structure. Note that the leftmost endpoint and the rightmost endpoint are omitted, as they can be retrieved from the parent node.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct maple_range_64 {&#xA;        struct maple_pnode *       parent;               /*     0     8 */&#xA;        long unsigned int          pivot[15];            /*     8   120 */&#xA;        /* --- cacheline 2 boundary (128 bytes) --- */&#xA;        union {&#xA;                void *             slot[16];             /*   128   128 */&#xA;                struct {&#xA;                        void *     pad[15];              /*   128   120 */&#xA;                        /* --- cacheline 3 boundary (192 bytes) was 56 bytes ago --- */&#xA;                        struct maple_metadata meta;      /*   248     2 */&#xA;                };                                       /*   128   128 */&#xA;        };                                               /*   128   128 */&#xA;&#xA;        /* size: 256, cachelines: 4, members: 3 */&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;maple_range_64&lt;/code&gt; structure, as shown above, represents a maple node. In addition to the pivots, the slots are used to refer to the VMA structure when the node functions as a leaf node, or to other maple nodes when the node functions as an interior node. If an interval corresponds to a gap, the slot will simply contain a NULL value. The arrangement of pivot points and slots can be visualized as illustrated below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Slots -&amp;gt; | 0 | 1 | 2 | ... | 12 | 13 | 14 | 15 |&#xA;          ┬   ┬   ┬   ┬     ┬    ┬    ┬    ┬    ┬&#xA;          │   │   │   │     │    │    │    │    └─ Implied maximum&#xA;          │   │   │   │     │    │    │    └─ Pivot 14&#xA;          │   │   │   │     │    │    └─ Pivot 13&#xA;          │   │   │   │     │    └─ Pivot 12&#xA;          │   │   │   │     └─ Pivot 11&#xA;          │   │   │   └─ Pivot 2&#xA;          │   │   └─ Pivot 1&#xA;          │   └─ Pivot 0&#xA;          └─  Implied minimum&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Regarding concurrent modification, the maple tree imposes a specific restriction, that is, an exclusive lock must be held by writers (&lt;em&gt;Rule W&lt;/em&gt;). In the case of the VMA tree, the exclusive lock corresponds to the MM write lock. As for readers, two options are available. The first option involves holding the MM read lock (&lt;em&gt;Rule A1&lt;/em&gt;), which results in the writer being blocked by the MM read-write lock. Alternatively, the second option is to enter the RCU critical section (&lt;em&gt;Rule A2&lt;/em&gt;). By doing so, the writer is not blocked, and readers can continue their operations since the maple tree is RCU-safe. While most existing VMA accesses opt for the first option (i.e., Rule A1), Rule A2 is employed in a few performance-critical scenarios, such as lockless page faults.&lt;/p&gt; &#xA;&lt;p&gt;However, there is an additional aspect that requires particular attention, which pertains to stack expansion. The stack represents a memory area that is mapped with the MAP_GROWSDOWN flag, indicating automatic expansion when an address below the region is accessed. In such cases, the start address of the corresponding VMA is adjusted, as well as the associated interval within the maple tree. Notably, these adjustments are made without holding the MM write lock.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline&#xA;void do_user_addr_fault(struct pt_regs *regs,&#xA;                        unsigned long error_code,&#xA;                        unsigned long address)&#xA;{&#xA;&#x9;// ...&#xA;&#xA;&#x9;if (unlikely(!mmap_read_trylock(mm))) {&#xA;&#x9;&#x9;// ...&#xA;&#x9;}&#xA;&#x9;// ...&#xA;&#x9;if (unlikely(expand_stack(vma, address))) {&#xA;&#x9;&#x9;// ...&#xA;&#x9;}&#xA;&#xA;&#x9;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Typically, a gap exists between the stack VMA and its neighboring VMA, as the kernel enforces a stack guard. In this scenario, when expanding the stack, only the pivot value in the maple node needs updating, a process that can be performed atomically. However, if the neighboring VMA also possesses the MAP_GROWSDOWN flag, no stack guard is enforced.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int expand_downwards(struct vm_area_struct *vma, unsigned long address)&#xA;{&#xA;&#x9;// ...&#xA;&#xA;&#x9;if (prev) {&#xA;&#x9;&#x9;if (!(prev-&amp;gt;vm_flags &amp;amp; VM_GROWSDOWN) &amp;amp;&amp;amp;&#xA;&#x9;&#x9;    vma_is_accessible(prev) &amp;amp;&amp;amp;&#xA;&#x9;&#x9;    (address - prev-&amp;gt;vm_end &amp;lt; stack_guard_gap))&#xA;&#x9;&#x9;&#x9;return -ENOMEM;&#xA;&#x9;}&#xA;&#xA;&#x9;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As a result, the stack expansion can eliminate the gap. In such situations, the gap interval within the maple node must be removed. As the maple tree is RCU-safe, overwriting the node in-place is not possible. Instead, a new node is created, triggering node replacement, and the old node is subsequently destroyed using an RCU callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void mas_wr_modify(struct ma_wr_state *wr_mas)&#xA;{&#xA;&#x9;// ...&#xA;&#xA;&#x9;if ((wr_mas-&amp;gt;offset_end - mas-&amp;gt;offset &amp;lt;= 1) &amp;amp;&amp;amp;&#xA;&#x9;    mas_wr_slot_store(wr_mas))           // &amp;lt;-- in-place update&#xA;&#x9;&#x9;return;&#xA;&#x9;else if (mas_wr_node_store(wr_mas))      // &amp;lt;-- node replacement&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The RCU callback is invoked only after all pre-existing RCU critical sections have concluded. However, the issue arises when accessing VMAs, as only the MM read lock is held, and it does not enter the RCU critical section (according to Rule A1). Consequently, in theory, the callback could be invoked at any time, resulting in the freeing of the old maple node. However, pointers to the old node may have already been fetched, leading to a use-after-free bug when attempting subsequent access to it.&lt;/p&gt; &#xA;&lt;p&gt;The backtrace where use-after-free (UAF) occurs is shown below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  - CPU 0 -                                        - CPU 1 -&#xA;&#xA;  mm_read_lock()                                    mm_read_lock()&#xA;  expand_stack()                                    find_vma_prev()&#xA;    expand_downwards()                                mas_walk()&#xA;      mas_store_prealloc()                              mas_state_walk()&#xA;        mas_wr_story_entry()                              mas_start()&#xA;          mas_wr_modify()                                   mas_root()&#xA;            mas_wr_node_store()                               node = rcu_dereference_check()&#xA;              mas_replace()                                   [ The node pointer is recorded ]&#xA;                mas_free()&#xA;                  ma_free_rcu()&#xA;                    call_rcu(&amp;amp;mt_free_rcu)&#xA;                    [ The node is dead ]&#xA;  mm_read_unlock()&#xA;&#xA;  [ Wait for the next RCU grace period.. ]&#xA;  rcu_do_batch()                                      mas_prev()&#xA;    mt_free_rcu()                                       mas_prev_entry()&#xA;      kmem_cache_free()                                   mas_prev_nentry()&#xA;      [ The node is freed ]                                 mas_slot()&#xA;                                                              mt_slot()&#xA;                                                                rcu_dereference_check(node-&amp;gt;..)&#xA;                                                                [ UAF occurs here ]&#xA;                                                    mm_read_unlock()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fix&lt;/h2&gt; &#xA;&lt;p&gt;I reported this vulnerability to the Linux kernel security team on June 15th. Following that, the process of addressing this bug was led by Linus Torvalds. Given its complexity, it took nearly two weeks to develop a set of patches that received consensus.&lt;/p&gt; &#xA;&lt;p&gt;On June 28th, during the merge window for Linux kernel 6.5, the fix was merged into Linus&#39; tree. Linus provided a &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9471f1f2f50282b9e8f59198ec6bb738b4ccc009&#34;&gt;comprehensive merge message&lt;/a&gt; to elucidate the patch series from a technical perspective.&lt;/p&gt; &#xA;&lt;p&gt;These patches were subsequently backported to stable kernels (&lt;a href=&#34;https://lore.kernel.org/stable/2023070133-create-stainless-9a8c@gregkh/T/&#34;&gt;6.1.37&lt;/a&gt;, &lt;a href=&#34;https://lore.kernel.org/stable/2023070146-endearing-bounding-d21a@gregkh/T/&#34;&gt;6.3.11&lt;/a&gt;, and &lt;a href=&#34;https://lore.kernel.org/stable/2023070140-eldercare-landlord-133c@gregkh/T/&#34;&gt;6.4.1&lt;/a&gt;), effectively resolving the &#34;Stack Rot&#34; bug on July 1st.&lt;/p&gt; &#xA;&lt;h2&gt;Exploit&lt;/h2&gt; &#xA;&lt;p&gt;The exploit primarily focuses on the Google kCTF challenge, specifically when neither CONFIG_PREEMPT nor CONFIG_SLAB_MERGE_DEFAULT is set. To exploit StackRot, the most important task is to locate a VMA iteration that fulfills the following criteria:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The iteration&#39;s timing can be controlled. This control allows us to ensure that the RCU grace period concludes during the VMA iteration.&lt;/li&gt; &#xA; &lt;li&gt;The iteration retrieves specific information from the VMA structure, and returns the information to the userspace. This feature enables us to exploit the UAF vulnerability of the maple node to leak some kernel addresses.&lt;/li&gt; &#xA; &lt;li&gt;The iteration invokes certain function pointers in the VMA structure. This particular capability allows us to exploit the UAF of the maple node to control the kernel-mode program counter (PC).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The chosen VMA iteration is the iteration responsible for generating the contents of &lt;code&gt;/proc/[pid]/maps&lt;/code&gt;. The following sections will show how this iteration satisfies the above criteria.&lt;/p&gt; &#xA;&lt;h3&gt;Step 0: From UAFBR to UAF&lt;/h3&gt; &#xA;&lt;p&gt;During any VMA iteration, the reference to the root node of the VMA tree is obtained, and the iteration proceeds through its slots. Thus, by triggering stack expansion in another thread on a separate CPU during the VMA iteration, the node replacement can be concurrently initiated. At this point, accessing the old node is considered a use-after-free-by-RCU (UAFBR) situation. However, actual issues arise only when the old node is truly freed, which occurs in the RCU callback.&lt;/p&gt; &#xA;&lt;p&gt;This presents two challenges: (i) determining when the old node is freed and (ii) ensuring that the VMA iteration does not complete before the old node is freed.&lt;/p&gt; &#xA;&lt;p&gt;The first question is relatively straightforward. In the kernel, the &lt;code&gt;synchronize_rcu()&lt;/code&gt; function can be employed to wait until the RCU grace period concludes, ensuring that all pre-existing RCU callbacks have been invoked. In userspace, system calls that ultimately call &lt;code&gt;synchronize_rcu()&lt;/code&gt; can be utilized for the same purpose. Thus, when such system calls terminate, it is known that the old node has been freed. Notably, there is a system call, &lt;code&gt;membarrier(MEMBARRIER_CMD_GLOBAL, 0, -1)&lt;/code&gt;, that solely invokes &lt;code&gt;synchronize_rcu()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;SYSCALL_DEFINE3(membarrier, int, cmd, unsigned int, flags, int, cpu_id)&#xA;{&#xA;&#x9;// ...&#xA;&#xA;&#x9;switch (cmd) {&#xA;&#x9;// ...&#xA;&#x9;case MEMBARRIER_CMD_GLOBAL:&#xA;&#x9;&#x9;/* MEMBARRIER_CMD_GLOBAL is not compatible with nohz_full. */&#xA;&#x9;&#x9;if (tick_nohz_full_enabled())&#xA;&#x9;&#x9;&#x9;return -EINVAL;&#xA;&#x9;&#x9;if (num_online_cpus() &amp;gt; 1)&#xA;&#x9;&#x9;&#x9;synchronize_rcu();&#xA;&#x9;&#x9;return 0;&#xA;&#x9;// ...&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second question necessitates further consideration. Several potential solutions are as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The iteration task gets preempted, the RCU grace period ends, and the iteration resumes execution. However, this approach is ineffective if CONFIG_PREEMPT is not set.&lt;/li&gt; &#xA; &lt;li&gt;The iteration task enters a sleep state (e.g., waiting for I/O), the RCU grace period ends, and the iteration continues. Currently, I am unaware of any VMA iteration that satisfies this requirement and can be exploited to leak kernel addresses and control the program counter (PC). It may exist, but a thorough investigation is required.&lt;/li&gt; &#xA; &lt;li&gt;The iteration task experiences an interruption (e.g., timer interrupt), during which the RCU grace period concludes. It is possible to employ timerfd to create multiple hardware timers that, upon timeout during the VMA iteration, can trigger a lengthy interrupt. However, this approach is not viable because the interrupt handler operates with interrupts disabled, and if a CPU cannot handle inter-processor interrupts (IPIs), the RCU grace period will not end.&lt;/li&gt; &#xA; &lt;li&gt;The iteration task is deliberately prolonged, allowing the RCU grace period to expire. This is the chosen solution. If the current RCU grace period surpasses RCU_TASK_IPI_DELAY (defaulting to 0.5 seconds), inter-processor interrupts (IPIs) are dispatched to all CPUs to verify that they are not in RCU critical sections. In the case of VMA iteration, the answer is negative, signifying that the RCU grace period concludes and the maple node is freed, effectively converting UAFBR into a genuine use-after-free (UAF) scenario.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;One significant observation is that during VMA iteration for &lt;code&gt;/proc/[pid]/maps&lt;/code&gt;, it generates the entire file path for file-mapped memory regions. Although the directory name is typically restricted to a maximum of 255 characters, there is no limitation on the directory depth. This means that by creating a file with an exceedingly large directory depth and establishing a memory mapping for this file, accessing &lt;code&gt;/proc/[pid]/maps&lt;/code&gt; can take a considerable amount of time during the VMA iteration. Consequently, this extended duration enables the possibility of concluding the RCU grace period and acquiring the UAF primitive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static void&#xA;show_map_vma(struct seq_file *m, struct vm_area_struct *vma)&#xA;{&#xA;&#x9;// ...&#xA;&#xA;&#x9;/*&#xA;&#x9; * Print the dentry name for named mappings, and a&#xA;&#x9; * special [heap] marker for the heap:&#xA;&#x9; */&#xA;&#x9;if (file) {&#xA;&#x9;&#x9;seq_pad(m, &#39; &#39;);&#xA;&#x9;&#x9;/*&#xA;&#x9;&#x9; * If user named this anon shared memory via&#xA;&#x9;&#x9; * prctl(PR_SET_VMA ..., use the provided name.&#xA;&#x9;&#x9; */&#xA;&#x9;&#x9;if (anon_name)&#xA;&#x9;&#x9;&#x9;seq_printf(m, &#34;[anon_shmem:%s]&#34;, anon_name-&amp;gt;name);&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;seq_file_path(m, file, &#34;\n&#34;);&#xA;&#x9;&#x9;goto done;&#xA;&#x9;}&#xA;&#xA;&#x9;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This step is illustrated in the following figure:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lrh2000/StackRot/master/pic/nodes_free_and_use.png&#34; alt=&#34;Step 0: From UAFBR to UAF&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: From slab UAF to page UAF&lt;/h3&gt; &#xA;&lt;p&gt;Now that UAF is functioning within a slab. If CONFIG_SLAB_MERGE_DEFAULT is enabled and the slab of maple nodes merges with kmalloc-256, the contents within the old node can be controlled by allocating a new structure from kmalloc-256 and populating it with userspace data. However, if CONFIG_SLAB_MERGE_DEFAULT is not set, an alternative approach is required. In this case, one needs to return the page of the freed node to the page allocator, allowing the old node to be controlled by allocating a new page and filling it accordingly.&lt;/p&gt; &#xA;&lt;p&gt;Recall that the VMA tree will only contain one node. Hence, by utilizing &lt;code&gt;fork()&lt;/code&gt;/&lt;code&gt;clone()&lt;/code&gt;, multiple VMA trees and an equal number of maple nodes are generated. Assuming one slab encompasses M maple nodes, and one node per M nodes is retained while all other nodes are freed via &lt;code&gt;exit()&lt;/code&gt;, the remaining nodes become the sole nodes within their respective slabs. Initially, these slabs reside in the CPU&#39;s partial list. When the partial list reaches its capacity, the slabs are flushed back to the partial list of the corresponding NUMA node.&lt;/p&gt; &#xA;&lt;p&gt;If the last maple node within a slab is freed, the slab becomes empty. If this slab resides in the partial list of a NUMA node, and the partial list of that particular NUMA node is already at maximum capacity, the page is immediately returned to the page allocator. Consequently, the slab UAF transforms into a page UAF scenario. The contents within the freed page can be manipulated by sending some data via &lt;code&gt;msgsnd()&lt;/code&gt;, which allocates elastic objects and directly populates them with the provided user data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static void __slab_free(struct kmem_cache *s, struct slab *slab,&#xA;&#x9;&#x9;&#x9;void *head, void *tail, int cnt,&#xA;&#x9;&#x9;&#x9;unsigned long addr)&#xA;&#xA;{&#xA;&#x9;// ...&#xA;&#xA;&#x9;if (unlikely(!new.inuse &amp;amp;&amp;amp; n-&amp;gt;nr_partial &amp;gt;= s-&amp;gt;min_partial))&#xA;&#x9;&#x9;goto slab_empty;&#xA;&#xA;&#x9;// ...&#xA;&#x9;return;&#xA;&#xA;slab_empty:&#xA;&#x9;// ...&#xA;&#x9;discard_slab(s, slab);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The number of maple nodes per slab, M, depends on the number of CPUs. The exploit implementation considers a situation with two CPUs and therefore assumes 16 as the value of M, as illustrated in the following figure:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lrh2000/StackRot/master/pic/node_master_fengshui.png&#34; alt=&#34;Step 1: From slab UAF to page UAF&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Step 2: From UAF to address leaking&lt;/h3&gt; &#xA;&lt;p&gt;Upon gaining control of the maple node, it becomes possible to manipulate the addresses of subsequent VMAs that will be later iterated. As the targeted iteration is aimed at generating &lt;code&gt;/proc/self/maps&lt;/code&gt;, certain VMA information, such as the start and end addresses, which reside within the VMA structure, are returned to the user space.&lt;/p&gt; &#xA;&lt;p&gt;However, a challenge arises: the address of a VMA structure in the maple node can only be appropriately set if some addresses are already known. Fortunately, CVE-2023-0597 directly serves this purpose. According to CVE-2023-0597, the address of &lt;code&gt;cpu_entry_area&lt;/code&gt; is not randomized. Although this vulnerability has been patched in Linux 6.2, it has not been backported to earlier stable kernels as of the time of writing. Consequently, by overwriting the address of the VMA structure with that of the last IDT entry, the entry that contains the address of &lt;code&gt;asm_sysvec_spurious_apic_interrupt&lt;/code&gt; is directly leaked, thereby revealing the base addresses of the kernel code and kernel data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lrh2000/StackRot/master/pic/node_master_code_leak.png&#34; alt=&#34;Step 2: From UAF to address leaking (1)&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The previously discussed method can be used recurrently to incrementally expose more addresses from the kernel data section. For instance, the &lt;code&gt;init_task.tasks.prev&lt;/code&gt; pointer within the data section directs to the &lt;code&gt;task_struct&lt;/code&gt; structure of the latest created task, which is without question allocated on the heap.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lrh2000/StackRot/master/pic/node_master_heap_leak.png&#34; alt=&#34;Step 2: From UAF to address leaking (2)&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When all newly established tasks are terminated, their &lt;code&gt;task_struct&lt;/code&gt; structures will subsequently be deallocated. If the quantity of these tasks is large enough, the corresponding pages can be surrendered back to the page allocator. This allows for the possibility to reallocate these pages and fill them with user data. However, keep in mind that the released pages generally belong to the per-cpu page (PCP) list. For pages present in the PCP list, they can be reallocated exclusively in the same page order. Consequently, solely mapping new pages into the user space, which requires only order-0 pages from the page allocator, won&#39;t fulfill the objectives.&lt;/p&gt; &#xA;&lt;p&gt;Nonetheless, the msgsnd system call will solicit memory chunks via kmalloc and populate these chunks with user-defined data. When the kmalloc cache is exhausted, it will requisition pages from the page allocator at a specific order. If the message size is accurately adjusted, the exact order will be desired. Thus, the page whose address has been previously leaked will be reallocated. As a result, it becomes possible to obtain a page with a known address and user-manipulated data.&lt;/p&gt; &#xA;&lt;h3&gt;Step 3: From UAF to root privileges&lt;/h3&gt; &#xA;&lt;p&gt;It is now possible to forge the VMA structure in the address-known page and control the &lt;code&gt;vma-&amp;gt;vm_ops-&amp;gt;name&lt;/code&gt; function pointer. The next step involves finding suitable gadgets to escape containers and acquire root privileges.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static void&#xA;show_map_vma(struct seq_file *m, struct vm_area_struct *vma)&#xA;{&#xA;&#x9;// ...&#xA;&#xA;&#x9;if (vma-&amp;gt;vm_ops &amp;amp;&amp;amp; vma-&amp;gt;vm_ops-&amp;gt;name) {&#xA;&#x9;&#x9;name = vma-&amp;gt;vm_ops-&amp;gt;name(vma);&#xA;&#x9;&#x9;if (name)&#xA;&#x9;&#x9;&#x9;goto done;&#xA;&#x9;}&#xA;&#xA;&#x9;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lrh2000/StackRot/master/pic/node_master_kern_exec.png&#34; alt=&#34;Step 3: From UAF to root privileges&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The gadget constructions are as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Stack pivot: &lt;code&gt;movq %rbx, %rsi; movq %rbp, %rdi; call __x86_indirect_thunk_r13&lt;/code&gt; -&amp;gt; &lt;code&gt;pushq %rsi; jmp 46(%rsi)&lt;/code&gt; -&amp;gt; &lt;code&gt;popq %rsp; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;popq %rsp; ret&lt;/code&gt;, where %rdi, %rbx, and %r13 &lt;em&gt;initially&lt;/em&gt; points to user-controllable data.&lt;/li&gt; &#xA; &lt;li&gt;Gain root privileges: &lt;code&gt;popq %rdi; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;prepare_kernel_cred&lt;/code&gt; -&amp;gt; &lt;code&gt;popq %rdi; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;movq %rax, (%rdi); ret&lt;/code&gt;, where %rdi &lt;em&gt;now&lt;/em&gt; points to the stack top; &lt;code&gt;popq %rdi; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;commit_creds&lt;/code&gt;, effectively executing &lt;code&gt;commit_creds(prepare_kernel_cred(&amp;amp;init_task))&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Escape containers: &lt;code&gt;popq %rdi; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;find_task_by_vpid&lt;/code&gt; -&amp;gt; &lt;code&gt;popq %rdi; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;movq %rax, (%rdi); ret&lt;/code&gt;, where %rdi &lt;em&gt;now&lt;/em&gt; points to the stack top; &lt;code&gt;popq %rdi; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;popq %rsi; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;switch_task_namespaces&lt;/code&gt;, effectively performing &lt;code&gt;switch_task_namespaces(find_task_by_vpid(1), &amp;amp;init_nsproxy)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Unlock mm: &lt;code&gt;popq %rax; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;movq %rbp, %rdi; call __x86_indirect_thunk_rax&lt;/code&gt;, where %rbp points to the original seq_file; &lt;code&gt;popq %rax; ret&lt;/code&gt; -&amp;gt; &lt;code&gt;m_stop&lt;/code&gt;, effectively executing &lt;code&gt;m_stop(seq_file, ..)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Return to userspace: use &lt;code&gt;swapgs_restore_regs_and_return_to_usermode&lt;/code&gt;, and call &lt;code&gt;execve()&lt;/code&gt; to get the shell.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Finally, using &lt;code&gt;nsenter --mount=/proc/1/ns/mnt&lt;/code&gt; to restore the mount namespace and get the flag via &lt;code&gt;cat /flag/flag&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Source code&lt;/h3&gt; &#xA;&lt;p&gt;The full exploit source is available &lt;a href=&#34;https://raw.githubusercontent.com/lrh2000/StackRot/master/exp&#34;&gt;here&lt;/a&gt;. For more details, refer to its README file.&lt;/p&gt;</summary>
  </entry>
</feed>