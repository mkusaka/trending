<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-13T01:33:02Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sksalahuddin2828/C</title>
    <updated>2023-07-13T01:33:02Z</updated>
    <id>tag:github.com,2023-07-13:/sksalahuddin2828/C</id>
    <link href="https://github.com/sksalahuddin2828/C" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Educational Purpose only&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;C Programming Language&lt;/h1&gt; &#xA;&lt;h3&gt;Overview&lt;/h3&gt; &#xA;&lt;p&gt;C is a general-purpose programming language that was developed in the early 1970s by Dennis Ritchie at Bell Labs. It is a procedural language that has gained immense popularity due to its simplicity, efficiency, and portability. C serves as a foundation for many modern programming languages and operating systems, making it an essential language for programmers to learn.&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;p&gt;C provides a wide range of features that contribute to its popularity and versatility:&lt;/p&gt; &#xA;&lt;h3&gt;Simplicity:&lt;/h3&gt; C offers a relatively simple and straightforward syntax, making it easy to learn and understand. Its minimalistic design focuses on essential programming constructs and allows for efficient code execution. &#xA;&lt;h3&gt;Portability:&lt;/h3&gt; C programs can be compiled and executed on various platforms, including different operating systems and hardware architectures. This portability is achieved through the use of compilers that translate C code into machine-specific instructions. &#xA;&lt;h3&gt;Efficiency:&lt;/h3&gt; C is known for its efficiency and low-level programming capabilities. It provides direct memory access and precise control over hardware resources, making it suitable for systems programming, embedded systems, and performance-critical applications. &#xA;&lt;h3&gt;Modularity:&lt;/h3&gt; C supports modular programming through the use of functions and libraries. Developers can break down complex programs into smaller, reusable modules, enhancing code organization and maintainability. &#xA;&lt;h3&gt;Extensibility:&lt;/h3&gt; C allows for the integration of assembly code within the program, enabling fine-grained control over hardware and direct manipulation of memory. This feature is particularly useful in areas where low-level system interactions are required. &#xA;&lt;h3&gt;Standard Libraries:&lt;/h3&gt; C comes with a rich set of standard libraries that provide a wide range of functions for tasks like input/output operations, string manipulation, memory allocation, and mathematical computations. These libraries simplify development and reduce the need for writing code from scratch. &#xA;&lt;h2&gt;Applications&lt;/h2&gt; &#xA;&lt;p&gt;C is widely used in various domains and applications, including:&lt;/p&gt; &#xA;&lt;h3&gt;System Programming:&lt;/h3&gt; Due to its efficiency and low-level access, C is extensively used for developing operating systems, device drivers, firmware, and other system software. &#xA;&lt;h3&gt;Embedded Systems:&lt;/h3&gt; C is a popular choice for programming embedded systems, such as microcontrollers, because of its ability to interact directly with hardware. &#xA;&lt;h3&gt;Game Development:&lt;/h3&gt; Many game engines and frameworks are implemented in C, allowing developers to create high-performance games for different platforms. &#xA;&lt;h3&gt;Compilers and Interpreters:&lt;/h3&gt; C is often used to develop compilers, interpreters, and programming language implementations due to its ability to generate efficient and optimized code. &#xA;&lt;h3&gt;Scientific and Numeric Computing:&lt;/h3&gt; C is employed in scientific simulations, data analysis, and numerical computation tasks, providing fast and efficient computations. &#xA;&lt;h3&gt;Utilities and Tools:&lt;/h3&gt; Numerous command-line utilities, text editors, and development tools are written in C, taking advantage of its performance and portability.</summary>
  </entry>
  <entry>
    <title>mkirchner/hamt</title>
    <updated>2023-07-13T01:33:02Z</updated>
    <id>tag:github.com,2023-07-13:/mkirchner/hamt</id>
    <link href="https://github.com/mkirchner/hamt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A hash array-mapped trie implementation in C&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;libhamt&lt;/h1&gt; &#xA;&lt;p&gt;A hash array-mapped trie (HAMT) implementation in C99. A HAMT is a data structure that can be used to efficiently implement &lt;a href=&#34;https://en.wikipedia.org/wiki/Persistent_data_structure&#34;&gt;&lt;em&gt;persistent&lt;/em&gt;&lt;/a&gt; associative arrays (aka maps, dicts) and sets, see the &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#introduction&#34;&gt;Introduction&lt;/a&gt;. The implementation here loosely follows Bagwell&#39;s 2000 paper&lt;a href=&#34;https://lampwww.epfl.ch/papers/idealhashtrees.pdf&#34;&gt;[1]&lt;/a&gt;, with a focus on code clarity.&lt;/p&gt; &#xA;&lt;p&gt;What prompted the somewhat detailed writeup was the realization that there is not a lot of in-depth documentation for HAMTs beyond the original Bagwell paper[&lt;a href=&#34;https://lampwww.epfl.ch/papers/idealhashtrees.pdf&#34;&gt;1&lt;/a&gt;]. Some of the more helpful posts are &lt;a href=&#34;http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html&#34;&gt;Karl Krukow&#39;s intro to Clojure&#39;s &lt;code&gt;PersistentHashMap&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/chaelim/HAMT&#34;&gt;C. S. Lim&#39;s C++ template implementation&lt;/a&gt;, &lt;a href=&#34;https://blog.acolyer.org/2015/11/27/hamt/&#34;&gt;Adrian Coyler&#39;s morning paper post&lt;/a&gt; and the original &lt;a href=&#34;https://michael.steindorfer.name/publications/oopsla15.pdf&#34;&gt;Steindoerfer/Vinju compressed HAMT article it summarizes&lt;/a&gt;. The rest mostly seems to be all bits and pieces and this document is an attempt to (partially) improve that situation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;FIXME: Complete docs (removal, persistence, path copying)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;To build the library and run the tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone git@github.com:mkirchner/hamt.git&#xA;$ cd hamt&#xA;$ make&#xA;$ make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to use &lt;code&gt;libhamt&lt;/code&gt; in your own projects, copy &lt;code&gt;include/hamt.h&lt;/code&gt; and &lt;code&gt;src/hamt.c&lt;/code&gt; in your own source tree and build from there.&lt;/p&gt; &#xA;&lt;h3&gt;Benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;For basic performance comparison with AVL and red-black trees (from &lt;code&gt;libavl&lt;/code&gt;) and the HashTree from GLib, see &lt;a href=&#34;https://github.com/mkirchner/hamt-bench&#34;&gt;the benchmarking repo&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;A &lt;em&gt;hash array mapped trie (HAMT)&lt;/em&gt; is a data structure that can be used to implement &lt;a href=&#34;https://en.wikipedia.org/wiki/Associative_array&#34;&gt;associative arrays&lt;/a&gt; (aka maps) and &lt;a href=&#34;https://en.wikipedia.org/wiki/Set_(abstract_data_type)&#34;&gt;sets&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Structurally, HAMTs are &lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_tree_(persistent_data_structure)&#34;&gt;hash trees&lt;/a&gt; that combine favorable characteristics of &lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table&#34;&gt;hash tables&lt;/a&gt; and array mapped &lt;a href=&#34;https://en.wikipedia.org/wiki/Trie&#34;&gt;tries&lt;/a&gt;, namely almost hash table-like time complexity guarantees&lt;a href=&#34;https://lampwww.epfl.ch/papers/idealhashtrees.pdf&#34;&gt;[1]&lt;/a&gt; (O(log&lt;sub&gt;32&lt;/sub&gt;n)) and economic use of memory.&lt;/p&gt; &#xA;&lt;p&gt;An additional benefit, and a key motivation for the work presented here, is that augmentation of HAMTs with path copying and garbage collection allows for a straightforward and efficient implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Persistent_data_structure&#34;&gt;persistent&lt;/a&gt; versions of maps and sets.&lt;/p&gt; &#xA;&lt;p&gt;The remaining documentation starts with a description of the &lt;code&gt;libhamt&lt;/code&gt; API and two examples that demonstrate the use of a HAMT as an ephemeral and persistent data structure, respectively. It then details the implementation: starting from the foundational data structures and the helper code required for hash exhaustion and table management, we cover search, insertion, removal, and iterators. The final implementation section introduces path copying and explains the changes required to support persistent insert and remove operations. It closes with an outlook and an appendix.&lt;/p&gt; &#xA;&lt;h1&gt;API&lt;/h1&gt; &#xA;&lt;h2&gt;HAMT lifecycle&lt;/h2&gt; &#xA;&lt;p&gt;The core data type exported in the &lt;code&gt;libhamt&lt;/code&gt; interface is &lt;code&gt;struct hamt&lt;/code&gt;. In order to create a &lt;code&gt;struct hamt&lt;/code&gt; instance, one must call &lt;code&gt;hamt_create()&lt;/code&gt;, which requires a hash function of type &lt;code&gt;hamt_key_hash_fn&lt;/code&gt; to hash keys, a comparison function of type &lt;code&gt;hamt_cmp_fn&lt;/code&gt; to compare keys, and a pointer to a &lt;code&gt;hamt_allocator&lt;/code&gt; instance. &lt;code&gt;hamt_delete()&lt;/code&gt; deletes &lt;code&gt;struct hamt&lt;/code&gt; instances that were created with &lt;code&gt;hamt_create()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* The libhamt core data structure is a handle to a hash array-mapped trie */&#xA;&#xA;/* Function signature definitions for key comparison and hashing */&#xA;typedef int (*hamt_cmp_fn)(const void *lhs, const void *rhs);&#xA;typedef uint32_t (*hamt_key_hash_fn)(const void *key, const size_t gen);&#xA;&#xA;/* API functions for lifecycle management */&#xA;struct hamt *hamt_create(hamt_key_hash_fn key_hash, hamt_cmp_fn key_cmp, struct hamt_allocator *ator);&#xA;void hamt_delete(struct hamt *);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;hamt_key_hash_fn&lt;/code&gt; takes a &lt;code&gt;key&lt;/code&gt; and a generation &lt;code&gt;gen&lt;/code&gt;. The expectation is that the supplied hash function returns different hashes for the same key but different generations. Depending on the choice of hash function this can be implemented using &lt;code&gt;gen&lt;/code&gt; as a seed or modifying a copy of &lt;code&gt;key&lt;/code&gt; on the fly. See the &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#examples&#34;&gt;examples&lt;/a&gt; section for a &lt;code&gt;murmur3&lt;/code&gt;-based implementation and the &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#hashing&#34;&gt;hashing&lt;/a&gt; section for more information on suitable hash functions.&lt;/p&gt; &#xA;&lt;h3&gt;Memory management&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;libhamt&lt;/code&gt; exports its internal memory management API through the &lt;code&gt;hamt_allocator&lt;/code&gt; struct. The struct specifies the functions that the HAMT implementation uses to allocate, re-allocate and deallocate system memory. The API provides a default &lt;code&gt;hamt_allocator_default&lt;/code&gt; which refers to the standard &lt;code&gt;malloc()&lt;/code&gt;, &lt;code&gt;realloc()&lt;/code&gt; and &lt;code&gt;free()&lt;/code&gt; functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct hamt_allocator {&#xA;    void *(*malloc)(const size_t size);&#xA;    void *(*realloc)(void *chunk, const size_t size);&#xA;    void (*free)(void *chunk);&#xA;};&#xA;&#xA;extern struct hamt_allocator hamt_allocator_default;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Exporting the &lt;code&gt;libhamt&lt;/code&gt; memory management API enables library clients to make use of alternate memory management solutions, most notably of garbage collection solutions (e.g. the &lt;a href=&#34;https://www.hboehm.info/gc/&#34;&gt;Boehm-Demers-Weiser GC&lt;/a&gt;) which are required when using the HAMT as a persistent data structure (see the &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#example-2-garbage-collected-persistent-hamts&#34;&gt;structural sharing example&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Query&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;size_t hamt_size(const struct hamt *trie);&#xA;const void *hamt_get(const struct hamt *trie, void *key);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;hamt_size()&lt;/code&gt; function returns the size of the HAMT in O(1). Querying the HAMT (i.e. searching a key) is done with &lt;code&gt;hamt_get()&lt;/code&gt; which takes a pointer to a key and returns a result in O(log&lt;sub&gt;32&lt;/sub&gt; n) - or &lt;code&gt;NULL&lt;/code&gt; if the key does not exist in the HAMT.&lt;/p&gt; &#xA;&lt;h3&gt;Iterators&lt;/h3&gt; &#xA;&lt;p&gt;The API also provides key/value pair access through the &lt;code&gt;hamt_iterator&lt;/code&gt; struct.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;size_t hamt_size(const struct hamt *trie);&#xA;const void *hamt_get(const struct hamt *trie, void *key);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Iterators are tied to a specific HAMT and are created using the &lt;code&gt;hamt_it_create()&lt;/code&gt; function, passing the HAMT instance the iterator should refer to. Iterators can be advanced with the &lt;code&gt;hamt_it_next()&lt;/code&gt; function and as long as &lt;code&gt;hamt_it_valid()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;hamt_it_get_key()&lt;/code&gt; and &lt;code&gt;hamt_it_get_value()&lt;/code&gt; functions will return the pointers to the current key/value pair. In order to delete an existing and/or exhausted iterator, call &lt;code&gt;hamt_it_delete()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct hamt_iterator_impl *hamt_iterator;&#xA;&#xA;hamt_iterator hamt_it_create(const struct hamt *trie);&#xA;void hamt_it_delete(hamt_iterator it);&#xA;bool hamt_it_valid(hamt_iterator it);&#xA;hamt_iterator hamt_it_next(hamt_iterator it);&#xA;const void *hamt_it_get_key(hamt_iterator it);&#xA;const void *hamt_it_get_value(hamt_iterator it);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Iterators maintain state about their traversal path and changes to the HAMT that an iterator refers to implicitly invalidate the iteration (i.e. undefined behavior).&lt;/p&gt; &#xA;&lt;p&gt;The order in which iterators return the key value pairs is fully defined by the structure of the trie, which, in turn, is completely defined by the choice of hash function and (where applicable) seed.&lt;/p&gt; &#xA;&lt;h2&gt;Insert &amp;amp; Remove&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;libhamt&lt;/code&gt; supports ephemeral and &lt;a href=&#34;https://en.wikipedia.org/wiki/Persistent_data_structure&#34;&gt;persistent&lt;/a&gt; (aka not ephemeral) HAMTs through two different interfaces: &lt;code&gt;hamt_set()&lt;/code&gt; and &lt;code&gt;hamt_remove()&lt;/code&gt; for ephemeral use, and their &lt;code&gt;p&lt;/code&gt;-versions &lt;code&gt;hamt_pset()&lt;/code&gt; and &lt;code&gt;hamt_premove()&lt;/code&gt; for persistent use.&lt;/p&gt; &#xA;&lt;h3&gt;Ephemeral modification&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const void *hamt_set(struct hamt *trie, void *key, void *value);&#xA;void *hamt_remove(struct hamt *trie, void *key);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;hamt_set()&lt;/code&gt; takes a pair of &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; pointers and adds the pair to the HAMT, returning a pointer to the &lt;code&gt;value&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; already exists, &lt;code&gt;hamt_set()&lt;/code&gt; updates the pointer to the &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;hamt_remove()&lt;/code&gt; takes a &lt;code&gt;key&lt;/code&gt; and removes the key/value pair with the respective &lt;code&gt;key&lt;/code&gt; from the HAMT, returning a pointer to the &lt;code&gt;value&lt;/code&gt; that was just removed. If the &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;hamt_remove()&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Persistent HAMTs&lt;/h3&gt; &#xA;&lt;p&gt;The semantics of persistent HAMTs are different from their ephemeral counterparts: since every modification creates a new version of a HAMT, the modificiation functions return a new HAMT. Modification of a persistent HAMT therefore requires a reassignment idiom if the goal is modification only:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const struct hamt *h = hamt_create(...)&#xA;...&#xA;/* Set a value and drop the reference to the old HAMT; the GC&#xA; * will take care of cleaning up remaining unreachable allocations.&#xA; */&#xA;h = hamt_pset(h, some_key, some_value);&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This seems wasteful at first glance but the respective functions implement structural sharing such that the overhead is limited to &lt;em&gt;~log&lt;sub&gt;32&lt;/sub&gt;(N)&lt;/em&gt; nodes (where &lt;em&gt;N&lt;/em&gt; is the number of nodes in the graph).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const struct hamt *hamt_pset(const struct hamt *trie, void *key, void *value);&#xA;const struct hamt *hamt_premove(const struct hamt *trie, void *key);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;hamt_pset()&lt;/code&gt; inserts or updates the &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; and returns an opaque handle to the new HAMT. The new HAMT is guaranteed to contain the new key/value pair.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;hamt_premove()&lt;/code&gt; attempts to remove the value with the key &lt;code&gt;key&lt;/code&gt;. It is &lt;em&gt;not&lt;/em&gt; an error if the key does not exist; the new HAMT is guaranteed to not contain the key &lt;code&gt;key&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Example 1: ephemeral HAMT w/ standard allocation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdint.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;&#xA;#include &#34;hamt.h&#34;&#xA;#include &#34;murmur3.h&#34;&#xA;&#xA;&#xA;static uint32_t hash_string(const void *key, const size_t gen)&#xA;{&#xA;    return murmur3_32((uint8_t *)key, strlen((const char *)key), gen);&#xA;}&#xA;&#xA;int main(int argn, char *argv[])&#xA;{&#xA;    enum { N = 5; };&#xA;    struct {&#xA;        char *country;&#xA;        char *capital;&#xA;    } cities[N] = {&#xA;        {&#34;Germany&#34;, &#34;Berlin&#34;},&#xA;        {&#34;Spain&#34;, &#34;Madrid&#34;},&#xA;        {&#34;Italy&#34;, &#34;Rome&#34;},&#xA;        {&#34;France&#34;, &#34;Paris&#34;},&#xA;        {&#34;Romania&#34;, &#34;Bucharest&#34;}&#xA;        /* ... */&#xA;    };&#xA;&#xA;    struct hamt *t;&#xA;&#xA;    /* create table */&#xA;    t = hamt_create(hash_string, strcmp, &amp;amp;hamt_allocator_default);&#xA;    /* load table */&#xA;    for (size_t i = 0; i &amp;lt; N; i++) {&#xA;        hamt_set(t, cities[i].country, cities[i].capital);&#xA;    }&#xA;&#xA;    /* query table */&#xA;    for (size_t i = 0; i &amp;lt; N; i++) {&#xA;        printf(&#34;%s has capital %s\n&#34;, cities[i].country,&#xA;                                      hamt_get(t, cities[i].country));&#xA;    }&#xA;    /* cleanup */&#xA;    hamt_delete(t);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 2: Garbage-collected persistent HAMTs&lt;/h3&gt; &#xA;&lt;p&gt;The key to making use of structural sharing is to provide &lt;code&gt;libhamt&lt;/code&gt; with a &lt;code&gt;struct hamt_allocator&lt;/code&gt; instance that implements garbage collection.&lt;/p&gt; &#xA;&lt;p&gt;The example below uses the the &lt;a href=&#34;https://www.hboehm.info/gc/&#34;&gt;Boehm-Demers-Weiser&lt;/a&gt; GC. For GC installation, compilation and linking instructions, please refer to the GC documentation.&lt;/p&gt; &#xA;&lt;p&gt;In brief, the Boehm GC provides a &lt;code&gt;gc.h&lt;/code&gt; include file and drop-in replacements for the standard memory management functions, including &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following snippet illustrates the required changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;...&#xA;#include &#34;gc.h&#34;  /* Boehm-Demers-Weiser GC */&#xA;&#xA;...&#xA;&#xA;inline void nop(void *_) { return; }&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;    ...&#xA;    /*&#xA;    Set up garbage collection. We set the function pointer for `free` to&#xA;    NULL to avoid explicit freeing of memory.&#xA;    */&#xA;    struct hamt_allocator gc_alloc = {GC_malloc, GC_realloc, nop};&#xA;    const struct hamt *t = hamt_create(hash_string, strcmp, &amp;amp;gc_alloc);&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We set the &lt;code&gt;gc_alloc.free&lt;/code&gt; function pointer to point to &lt;code&gt;nop()&lt;/code&gt;, a no-operation function. This is necessary to ensure that we rely on the garbage collector. If we were to provide a pointer to &lt;code&gt;GC_free()&lt;/code&gt; (i.e. GC&#39;s drop-in replacement for the &lt;code&gt;free()&lt;/code&gt; function), we would still implement explicit deallocation, just with a different free function.&lt;/p&gt; &#xA;&lt;h3&gt;Example 3: Iterators&lt;/h3&gt; &#xA;&lt;p&gt;The following snipped illustrates how to create, test, exhaust and dispose of an iterator. We first create the iterator using &lt;code&gt;hamt_it_create()&lt;/code&gt;, jump into a &lt;code&gt;while&lt;/code&gt; loop and advance the iterator using &lt;code&gt;hamt_it_next()&lt;/code&gt; while the iterator is valid. In every interation we print the current key/value pair to &lt;code&gt;stdout&lt;/code&gt;. Once we exit the loop, we clean up using &lt;code&gt;hamt_it_delete()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    ...&#xA;    struct hamt *t = hamt_create(hash_string, strcmp, &amp;amp;hamt_allocator_default);&#xA;&#xA;    /* load table */&#xA;    ...&#xA;&#xA;    /* create iterator */&#xA;    hamt_iterator it = hamt_it_create(t);&#xA;    while (hamt_it_valid(it)) {&#xA;        printf(&#34;(%s, %s)\n&#34;, (char *)hamt_it_get_key(it),&#xA;                             (char *)hamt_it_get_value(it));&#xA;        hamt_it_next(it);&#xA;    }&#xA;    /* clean up */&#xA;    hamt_it_delete(it);&#xA;&#xA;    ...&#xA;    hamt_delete(t);&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This concludes the description of the &lt;code&gt;libhamt&lt;/code&gt; interface and we now move on to detailed implementation notes.&lt;/p&gt; &#xA;&lt;h1&gt;Implementation&lt;/h1&gt; &#xA;&lt;h2&gt;Prelude: Setup&lt;/h2&gt; &#xA;&lt;h3&gt;Project structure&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;hamt&lt;/code&gt; source tree has the following structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hamt/&#xA;  build/         Out-of-source build destination&#xA;  include/       Header files that are part of the interface&#xA;  src/           Source and header files&#xA;  test/          Test and utility headers &amp;amp; sources&#xA;  Makefile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sources are organized in three folders: the &lt;code&gt;include&lt;/code&gt; folder, for all header files that are part of the public interface; the &lt;code&gt;src&lt;/code&gt; folder, for the actual implementation and private header files; and the &lt;code&gt;test&lt;/code&gt; folder, for all test code, including headers and sources for testing utilities (e.g. data loading and benchmarking functions).&lt;/p&gt; &#xA;&lt;p&gt;The build process is governed by a single &lt;code&gt;Makefile&lt;/code&gt; in the project root directory.&lt;/p&gt; &#xA;&lt;h3&gt;Programming Style&lt;/h3&gt; &#xA;&lt;h3&gt;Building the project&lt;/h3&gt; &#xA;&lt;p&gt;To build the library and run the tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make &amp;amp;&amp;amp; make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;h3&gt;Introduction&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Hash tables.&lt;/strong&gt; A common and practical answer to efficient value retrieval from a collection given a key is to &#34;use a &lt;em&gt;hash table&lt;/em&gt;&#34;. This is good advice. &lt;em&gt;Hash tables&lt;/em&gt; provide insert, modification, and retrieval in amortized constant average time, using space linear in the number of elements they store. They have been the subject of intensive research and optimization and are part of &lt;a href=&#34;https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X&#34;&gt;every&lt;/a&gt; &lt;a href=&#34;https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=zg_bs_491298_1/147-2375898-2942653?pd_rd_i=0262033844&amp;amp;psc=1&#34;&gt;introductory&lt;/a&gt; CS textbook. Chances are that the standard library of the languange at hand contains a readily available, tried and tested implementation.&lt;/p&gt; &#xA;&lt;p&gt;For instance, &lt;code&gt;std::unordered_set&lt;/code&gt; and &lt;code&gt;std::unordered_map&lt;/code&gt; (and their &lt;code&gt;*_multiset&lt;/code&gt; cousins) are hash table implementations for C++ &lt;sup id=&#34;ac_hash_table_cpp&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#fn_hash_table_cpp&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;; for C, multiple &lt;a href=&#34;https://en.wikipedia.org/wiki/C_standard_library&#34;&gt;libc&lt;/a&gt; implementations (e.g. &lt;a href=&#34;https://en.wikipedia.org/wiki/Glibc&#34;&gt;glibc&lt;/a&gt;, &lt;a href=&#34;https://www.musl-libc.org&#34;&gt;musl&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/C_standard_library#BSD_libc&#34;&gt;BSD libc&lt;/a&gt;) provide POSIX-compliant &lt;code&gt;hsearch&lt;/code&gt; facilities, GNOME&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/GLib&#34;&gt;GLib&lt;/a&gt; and others provide &lt;a href=&#34;https://gitlab.gnome.org/GNOME/glib/-/blob/main/glib/ghash.c&#34;&gt;hash table&lt;/a&gt; implementations&lt;sup id=&#34;ac_hash_table_c&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#fn_hash_table_c&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Python has the &lt;code&gt;dict&lt;/code&gt; type for associative arrays which &lt;a href=&#34;https://stackoverflow.com/a/9022835&#34;&gt;is implemented as a hash table&lt;/a&gt;&lt;sup id=&#34;ac_hash_table_python&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#fn_hash_table_python&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Java has &lt;code&gt;Hashtable&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, and &lt;code&gt;HashSet&lt;/code&gt; &lt;sup id=&#34;ac_hash_table_java&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#fn_hash_table_java&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; and JavaScript has &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;One property of the classical hash table implementations is that they do not provide support for &lt;em&gt;persistence&lt;/em&gt; (in the sense of &lt;a href=&#34;https://en.wikipedia.org/wiki/Persistent_data_structure&#34;&gt;persistent data structures&lt;/a&gt;, not persistent storage). They are a &lt;a href=&#34;https://github.com/matthiasn/talk-transcripts/raw/master/Hickey_Rich/ValueOfValues.md&#34;&gt;place-oriented&lt;/a&gt; solution to associative storage and make destructive modifications to the data structure when the data changes (note that this is independent of any particular conflict resolution and capacity maintenance strategies).&lt;/p&gt; &#xA;&lt;p&gt;Persistent associative containers require a different approach.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Persistent data structures.&lt;/strong&gt; &lt;em&gt;(Full) persistence&lt;/em&gt; is the property of a data structure to always preserve (all) previous versions if itself under modification. The property is related to &lt;a href=&#34;https://en.wikipedia.org/wiki/Immutable_object&#34;&gt;immutability&lt;/a&gt;: from the perspective of the client, every update yields a new copy, making instances practically immutable. This is a huge conceptual change: if data structures are immutable, functions using these data structures are pure (i.e. side effect-free). That in turn enables &lt;a href=&#34;https://en.wikipedia.org/wiki/Value_semantics&#34;&gt;value semantics&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Referential_transparency&#34;&gt;referential transparency&lt;/a&gt;, and, consequently, substantial reduction in programming complexity when dealing with paralellism and synchronization (see e.g. Rich Hickey&#39;s presentations on &lt;a href=&#34;https://github.com/matthiasn/talk-transcripts/raw/master/Hickey_Rich/ValueOfValues.md&#34;&gt;&lt;em&gt;The Value of Values&lt;/em&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/matthiasn/talk-transcripts/raw/master/Hickey_Rich/AreWeThereYet.md&#34;&gt;&lt;em&gt;Are We There Yet?&lt;/em&gt;&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The catch is that classical hash tables set a high bar in terms of time and space performance characteristics, and persistent data structures need to approximate that bar.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Efficient persistence.&lt;/strong&gt; Persistent associative data structures need to minimize the memory overhead introduced by value semantics (i.e. returning copies as opposed to modified originals) and, at the same time, provide practically average constant time insert, retrieve and delete capabilities to minimize the performance gap to classical hash tables.&lt;/p&gt; &#xA;&lt;p&gt;It turns out that the data structure of choice to tackle these challenges is a &lt;em&gt;tree&lt;/em&gt;. Trees support efficient &lt;a href=&#34;https://en.wikipedia.org/wiki/Persistent_data_structure#Trees&#34;&gt;&lt;em&gt;structural sharing&lt;/em&gt;&lt;/a&gt; strategies for efficient memory management and, if they are &lt;em&gt;balanced&lt;/em&gt; and have &lt;em&gt;large branching factors&lt;/em&gt;, provide O(log&lt;sub&gt;k&lt;/sub&gt; N) average performance guarantees.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Persistent hash array-mapped tries&lt;/em&gt; are, in essence, a sophisticated, practical implementation of such a data structure.&lt;/p&gt; &#xA;&lt;h3&gt;Persistent Hash Array-Mapped Tries&lt;/h3&gt; &#xA;&lt;p&gt;One way to understand hash array-mapped tries is to look at them as an evolution of &lt;em&gt;k&lt;/em&gt;-ary trees (Fig. 1) that follows from a series of real-world tradeoffs.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/doc/img/hamt-trees.png&#34; width=&#34;600&#34;&gt; &lt;/p&gt; &#xA;&lt;p class=&#34;image-caption&#34;&gt;&lt;b&gt;Figure 1:&lt;/b&gt; *k*-ary tree, hash tree, and hash array-mapped trie.&lt;/p&gt; &#xA;&lt;p&gt;In classic &lt;em&gt;k&lt;/em&gt;-ary trees Ⓐ, Internal and leaf nodes have different types: internal nodes point to &lt;em&gt;n&lt;/em&gt; internal or leaf nodes and leaf nodes hold or point to data (i.e. the keys/value pairs). In their basic form, &lt;em&gt;n&lt;/em&gt;-ary trees (just like binary trees) are not balanced and their performance characteristics can easily degrade from &lt;em&gt;O(log&lt;sub&gt;k&lt;/sub&gt; n)&lt;/em&gt; to &lt;em&gt;O(n)&lt;/em&gt; for degenerate input sequences.&lt;/p&gt; &#xA;&lt;p&gt;One approach to balanced trees are explicit implementations of tree rebalancing (as in e.g. &lt;a href=&#34;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&#34;&gt;Red-black trees&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/AVL_tree&#34;&gt;AVL trees&lt;/a&gt;, or &lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree&#34;&gt;B-trees&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Another option is to use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_tree_(persistent_data_structure)&#34;&gt;&lt;em&gt;hash tree&lt;/em&gt;&lt;/a&gt; Ⓑ: like the name implies, it uses the &lt;em&gt;hash&lt;/em&gt; of the key, interpreted as a sequence of &lt;em&gt;b&lt;/em&gt;-bit groups, to detetermine the location of the leaf node that stores the key/value pair. The group size &lt;em&gt;b&lt;/em&gt; determines the branching factor 2&lt;sup&gt;&lt;i&gt;b&lt;/i&gt;&lt;/sup&gt;, i.e. for &lt;em&gt;b&lt;/em&gt;=5, every node can have 2&lt;sup&gt;5&lt;/sup&gt;=32 child nodes. Instead of implementing explicit tree rebalancing, hash trees rely on the distributional properties of a (good) hash function to place nodes uniformly. While this saves some effort for rebalancing, note that hash trees &lt;em&gt;do&lt;/em&gt; require a strategy to deal with &lt;em&gt;hash exhaustion&lt;/em&gt;, a topic covered below.&lt;/p&gt; &#xA;&lt;p&gt;The challenge with vanilla hash trees is that they reserve space for &lt;em&gt;k&lt;/em&gt; children in every internal node. If the tree is sparsely populated this will cause significant memory overhead and impact performance due to cache misses.&lt;/p&gt; &#xA;&lt;p&gt;For that reason, HAMTs implement &lt;em&gt;array mapping&lt;/em&gt; Ⓒ: instead of reserving space for &lt;em&gt;n&lt;/em&gt; pointers to children in each internal node, the parent node stores a bitmap that indicates which children are present and the actual node only allocates the memory required to refer to its children. This is an important optimization that makes trees with a high branching factor more memory efficient and cache-friendly.&lt;/p&gt; &#xA;&lt;p&gt;In order to implement a &lt;em&gt;persistent&lt;/em&gt; map or set, every modification operation must return a modified copy and maintain the source data structure. And returning actual copies is prohibitively expensive in time and memory.&lt;/p&gt; &#xA;&lt;p&gt;This, finally, is where HAMTs really shine and the true reason why we build them in the first place.&lt;/p&gt; &#xA;&lt;p&gt;HAMTs are trees and trees are compatible with &lt;a href=&#34;https://en.wikipedia.org/wiki/Persistent_data_structure&#34;&gt;structural sharing&lt;/a&gt; strategies. Common techniques are copy-on-write, fat nodes, &lt;a href=&#34;https://en.wikipedia.org/wiki/Persistent_data_structure#Techniques_for_preserving_previous_versions&#34;&gt;path copying&lt;/a&gt;, and there are &lt;a href=&#34;https://www.cs.cmu.edu/~sleator/papers/another-persistence.pdf&#34;&gt;complex combinations of the previous three&lt;/a&gt;. Path copying is simple, efficient and general and therefore the technique of choice for &lt;code&gt;libhamt&lt;/code&gt;: Instead of returning an actual copy of the tree during an insert, update or delete operations, we follow the search path to the item in question, maintaining a path copy with all the nodes along the way, make our modification along this path and return it to the caller.&lt;/p&gt; &#xA;&lt;p&gt;Note that enabling persistence &lt;em&gt;requires&lt;/em&gt; the use of a garbage collection strategy. Under stanard &lt;code&gt;malloc()&lt;/code&gt; memory management, there is no way for the HAMT nodes to know how many descendants of a HAMT refer to them.&lt;/p&gt; &#xA;&lt;h3&gt;Documentation structure and implementation strategy&lt;/h3&gt; &#xA;&lt;p&gt;In the following we will address these concepts in turn: we first define the foundational data structure used to build a tree and introduce the concept of an &lt;em&gt;anchor&lt;/em&gt;. We then dive into hash functions and the &lt;em&gt;hash state management&lt;/em&gt; required to make hashing work for trees of arbitrary depths and in the presence of hash collisions. We then turn to &lt;em&gt;table management&lt;/em&gt;, introducing a set of functions used to create, modify, query and dispose of mapped arrays. With these pieces in place, we are ready to implement the insert/update, query, and delete functions for non-persistent HAMTs. And lastly, we introduce the concept of path copying and close with the implementation of persistent insert/update and delete functions for HAMTs.&lt;/p&gt; &#xA;&lt;h3&gt;Foundational data structures&lt;/h3&gt; &#xA;&lt;!--&#xA;&lt;p align=&#34;center&#34;&gt;&#xA;&lt;img src=&#34;doc/img/hamt-overview.png&#34; width=&#34;600&#34;&gt;&lt;/img&gt;&#xA;&lt;/p&gt;&#xA;&lt;p class=&#34;image-caption&#34;&gt;&lt;b&gt;Figure 1:&lt;/b&gt; HAMT data structure.&#xA;&lt;code&gt;libhamt&lt;/code&gt; implements&#xA;HAMTs using linked, heap-allocated tables. Table rows hold&#xA;either an index vector and pointer to a subtable or pointers to key and&#xA;value (one pair of key/value pointers illustrated in blue, and implicit to all&#xA;empty table fields).&lt;/p&gt;&#xA;--&gt; &#xA;&lt;p&gt;&lt;code&gt;libhamt&lt;/code&gt; uses different types to implement internal and leaf nodes.&lt;/p&gt; &#xA;&lt;p&gt;Leaf nodes contain two fields, called &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; (the rationale for the reverse ordering of the two fields will become evident shortly).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct {&#xA;    void *value;&#xA;    void *key;&#xA;} kv;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both fields are defined as &lt;code&gt;void*&lt;/code&gt; pointers to support referring to arbitrary data types via type casting &lt;sup id=&#34;ac_cpp_virtual_method_table&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#fn_cpp_virtual_method_table&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;libhamt&lt;/code&gt;&#39;s internal nodes are where the magic happens, based on Bagwell&#39;s &lt;em&gt;&lt;a href=&#34;https://lampwww.epfl.ch/papers/idealhashtrees.pdf&#34;&gt;Ideal Hash Trees&lt;/a&gt;&lt;/em&gt; paper and according to the design principles outlined above.&lt;/p&gt; &#xA;&lt;p&gt;With a branching factor &lt;em&gt;k&lt;/em&gt;, internal nodes have at most &lt;em&gt;k&lt;/em&gt; successors but can be sparsely populated. To allow for a memory-efficient representation, internal nodes have a pointer &lt;code&gt;ptr&lt;/code&gt; that points to a fixed-size, right-sized &lt;em&gt;array&lt;/em&gt; of child nodes (also known as a &lt;em&gt;table&lt;/em&gt;) and a &lt;em&gt;k&lt;/em&gt;-bit &lt;code&gt;index&lt;/code&gt; bitmap field that keeps track of the size and occupancy of that array.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;libhamt&lt;/code&gt; uses &lt;em&gt;k&lt;/em&gt;=32 and because &lt;code&gt;index&lt;/code&gt; is a 32-bit bitmap field, the number of one-bits in &lt;code&gt;index&lt;/code&gt; yields the size of the array that &lt;code&gt;ptr&lt;/code&gt; points to (also known as the &lt;em&gt;population count&lt;/em&gt; or &lt;code&gt;popcount()&lt;/code&gt; of &lt;code&gt;index&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;This suggests an initial (incomplete) definition along the following lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct {&#xA;    struct T *ptr;  /* incomplete */&#xA;    uint32_t index;&#xA;} table;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The specification of &lt;code&gt;T&lt;/code&gt; must provide the ability for that datatype to point to internal and external nodes alike, using only a single pointer type. A solution is to wrap the two types into a &lt;code&gt;union&lt;/code&gt; (and then to wrap the &lt;code&gt;union&lt;/code&gt; into a &lt;code&gt;typedef&lt;/code&gt; for convenience):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct hamt_node {&#xA;    union {&#xA;        struct {&#xA;            void *value;&#xA;            void *key;&#xA;        } kv;&#xA;        struct {&#xA;            struct hamt_node *ptr;&#xA;            uint32_t index;&#xA;        } table;&#xA;    } as;&#xA;} hamt_node;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this structure, given a pointer &lt;code&gt;hamt_node *p&lt;/code&gt; to a &lt;code&gt;hamt_node&lt;/code&gt; instance, &lt;code&gt;p-&amp;gt;as.kv&lt;/code&gt; addresses the leaf node, and &lt;code&gt;p-&amp;gt;as.table&lt;/code&gt; addresses the internal node and &lt;code&gt;p-&amp;gt;as.kv.value&lt;/code&gt;, &lt;code&gt;p-&amp;gt;as.kv.key&lt;/code&gt;, &lt;code&gt;p-&amp;gt;as.table.ptr&lt;/code&gt;, and &lt;code&gt;p-&amp;gt;as.table.index&lt;/code&gt; provide access to the respective fields.&lt;/p&gt; &#xA;&lt;p&gt;To maintain sanity, we define the following convenience macros:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define TABLE(node) node-&amp;gt;as.table.ptr&#xA;#define INDEX(node) node-&amp;gt;as.table.index&#xA;#define VALUE(node) node-&amp;gt;as.kv.value&#xA;#define KEY(node)   node-&amp;gt;as.kv.key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/doc/img/hamtnode-table.png&#34; width=&#34;450&#34;&gt; &lt;/p&gt; &#xA;&lt;p class=&#34;image-caption&#34;&gt;&lt;b&gt;Figure 2:&lt;/b&gt; Memory structure of an internal node. If &lt;code&gt;node&lt;/code&gt; is a pointer to an internal node, &lt;code&gt;TABLE(node)&lt;/code&gt; (or, equivalently, &lt;code&gt; node-&amp;gt;as.table.ptr&lt;/code&gt;) points to the first field of the successor table. &lt;/p&gt; &#xA;&lt;h3&gt;The Anchor&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;libhamt&lt;/code&gt; codebase makes liberal use of the concept of an &lt;em&gt;anchor&lt;/em&gt;. An &lt;em&gt;anchor&lt;/em&gt; is a &lt;code&gt;hamt_node*&lt;/code&gt; pointer to an internal node (i.e. &lt;code&gt;is_value(VALUE(anchor))&lt;/code&gt; evaluates to false). An &lt;code&gt;anchor&lt;/code&gt; provides access to all information relevant to manage the table of child nodes: &lt;code&gt;INDEX(anchor)&lt;/code&gt; returns the bitmap that encodes the array mapping, applying a popcount to the bitmap gives the size of the table and indexing is implemented using partial popcounts. Table elements can be accessed through &lt;code&gt;TABLE(anchor)[i]&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; must be in the valid range.&lt;/p&gt; &#xA;&lt;h3&gt;Pointer tagging&lt;/h3&gt; &#xA;&lt;p&gt;The definition of &lt;code&gt;hamt_node&lt;/code&gt; enables the construction of trees with a mix of internal and leaf nodes. What the definition does not provide, is a way to determine if a concrete &lt;code&gt;hamt_node*&lt;/code&gt; pointer points to an internal or a leaf node. One solution would be to specify an &lt;code&gt;enum&lt;/code&gt; that indicates the type (i.e. &lt;code&gt;NODE_LEAF&lt;/code&gt;, etc.) and to add a &lt;code&gt;type&lt;/code&gt; field to &lt;code&gt;struct hamt_node&lt;/code&gt;. While valid, this would also increase the size of the struct by 50% just to maintain a single bit of information. Luckily, there is a more memory-efficient solution: pointer tagging.&lt;/p&gt; &#xA;&lt;p&gt;Since pointers need to be word-aligned, that leaves the lower 3 bits of all pointers on 64-bit architectures always set to zero. It is possible to make use of these bits under two conditions: (1) we know we are looking at a pointer (the bottom three bits for the integer 1 are zero, too); and (2) we carefully mask the bits in question whenever we actually use the pointer (since it would point to the wrong location otherwise). The first is not a problem since we own the code; the second requires diligence and some helper functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define HAMT_TAG_MASK 0x3&#xA;#define HAMT_TAG_VALUE 0x1&#xA;#define tagged(__p) (hamt_node *)((uintptr_t)__p | HAMT_TAG_VALUE)&#xA;#define untagged(__p) (hamt_node *)((uintptr_t)__p &amp;amp; ~HAMT_TAG_MASK)&#xA;#define is_value(__p) (((uintptr_t)__p &amp;amp; HAMT_TAG_MASK) == HAMT_TAG_VALUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to mark a leaf node as such, we set &lt;code&gt;key&lt;/code&gt; as usual and tag the value pointer before assigning it to &lt;code&gt;value&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    p-&amp;gt;as.kv.key = key_ptr;&#xA;    p-&amp;gt;as.kv.value = tagged(value_ptr);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Given a pointer to a leaf (e.g. a search result), we untag &lt;code&gt;value&lt;/code&gt; before returning it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    ...&#xA;    if (status == SEARCH_SUCCESS) {&#xA;        return untagged(p-&amp;gt;as.kv.value);&#xA;    }&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, in order to determine what we are looking at, we use &lt;code&gt;is_value&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (is_value(p-&amp;gt;as.kv.value)) {&#xA;        /* this is a leaf */&#xA;        ...&#xA;    } else {&#xA;        /* this is an internal node */&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pointer tagging is the reason why the &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; fields in the &lt;code&gt;struct kv&lt;/code&gt; struct are ordered the way they are. The &lt;code&gt;union&lt;/code&gt; in &lt;code&gt;hamt_node&lt;/code&gt; causes the memory locations of the &lt;code&gt;struct kv&lt;/code&gt; and &lt;code&gt;struct table&lt;/code&gt; structs to overlap. Since the &lt;code&gt;table.index&lt;/code&gt; field is &lt;em&gt;not&lt;/em&gt; a pointer (and the bottom-three-bits-are-zero guarantee does not apply), its storage location cannot be used for pointer tagging, leaving the &lt;code&gt;table.ptr&lt;/code&gt; to the task. Putting &lt;code&gt;kv.value&lt;/code&gt; first, aligns the value field with &lt;code&gt;table.ptr&lt;/code&gt;. The reverse order would work, but the &lt;code&gt;kv.key&lt;/code&gt; pointer is dereferenced much more often in the code and so it is more convenient to use &lt;code&gt;kv.value&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Array mapping&lt;/h2&gt; &#xA;&lt;p&gt;The principal idea behing array mapping is to project a sparse bitmap index onto the index of a dense array, where the size of the array corresponds to the number of non-zero bits in the bitmap index.&lt;/p&gt; &#xA;&lt;p&gt;Given &lt;code&gt;hamt_node *p&lt;/code&gt; is a valid pointer to a node, &lt;code&gt;INDEX(p)&lt;/code&gt; corresponds to a sparse bitmap index. The dense array is located at &lt;code&gt;TABLE(p)&lt;/code&gt; and its size is determined by the &lt;a href=&#34;https://en.wikipedia.org/wiki/Hamming_weight&#34;&gt;&lt;em&gt;population count&lt;/em&gt;&lt;/a&gt; of &lt;code&gt;INDEX(p)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The mapping itself is conceptually trivial: to determine the dense index for every non-zero bit in the bitmap index, count the number of non-zero bits to the right of it. In other words, the first set bit goes to index 0, the second to index 1, and so forth.&lt;/p&gt; &#xA;&lt;p&gt;Efficiently implementing population counting (also known as the hamming weight) of a bitset is &lt;a href=&#34;https://en.wikipedia.org/wiki/Hamming_weight&#34;&gt;not trivial&lt;/a&gt;. &lt;code&gt;libhamt&lt;/code&gt; falls back on a GCC/Clang intrinsic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline int get_popcount(uint32_t n) { return __builtin_popcount(n); }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;code&gt;get_popcount()&lt;/code&gt; available, determining the position (i.e. dense index) for a sparse index in a bitmap reduces to calculating the population count of the bitmap masked off above the sparse index:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline int get_pos(uint32_t sparse_index, uint32_t bitmap)&#xA;{&#xA;    return get_popcount(bitmap &amp;amp; ((1 &amp;lt;&amp;lt; sparse_index) - 1));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lastly, to determine if a node has a child at a particular index &lt;code&gt;index&lt;/code&gt;, we check if the bit at that index is set in the bitmap:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline bool has_index(const hamt_node *anchor, size_t index)&#xA;{&#xA;    return INDEX(anchor) &amp;amp; (1 &amp;lt;&amp;lt; index);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Hashing&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_function&#34;&gt;&lt;em&gt;hash function&lt;/em&gt;&lt;/a&gt; is a function that takes data of arbitrary size and maps it to a fixed-size value (often machine word sizes). &lt;em&gt;Good&lt;/em&gt; hash functions are fast to compute and produce &lt;em&gt;uniform&lt;/em&gt; output, they map their inputs as evenly as possible over the output range. If it is practically infeasible to invert the mapping (i.e. determine which hash corresponds to which input value), the hash function is called a &lt;a href=&#34;https://en.wikipedia.org/wiki/Cryptographic_hash_function&#34;&gt;cryptographic hash function&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For the purpose of implementing a HAMT, cryptographical security is not a design goal. However, the uniformity of the hash function has direct impact on the balance of the tree: it is the hash that pre-determines all key positions in the fully populated tree and it is its distribution properties that determines the number of collisions (and hence depth extensions) we introduce.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;libhamt&lt;/code&gt; does not force clients to use a particular hash function. The libary exposes a hash function signature of the form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef uint32_t (*hamt_key_hash_fn)(const void *key, const size_t gen);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and expects users to provide a suitable function pointer as part of the call to &lt;code&gt;hamt_create()&lt;/code&gt; which, among other parameters, takes a hash function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* ... see below for a practical definition of my_keyhash_string */&#xA;&#xA;    struct hamt *t = hamt_create(my_keyhash_string, my_keycmp_string,&#xA;                                 &amp;amp;hamt_allocator_default);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are multiple &lt;a href=&#34;https://theoryofcomputing.org/articles/v009a030/v009a030.pdf&#34;&gt;good, practical choices&lt;/a&gt; for the HAMT. Per default &lt;code&gt;libhamt&lt;/code&gt; includes its &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/src/murmur3.c&#34;&gt;own&lt;/a&gt;, &lt;a href=&#34;https://github.com/mkirchner/hamt/raw/62a24e5501d72d5fb505d3c642113015f46904d3/test/test_hamt.c#L92&#34;&gt;tested&lt;/a&gt; implementation of 32-bit &lt;a href=&#34;https://en.wikipedia.org/wiki/MurmurHash&#34;&gt;MurmurHash3&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* from include/murmur3.h */&#xA;&#xA;uint32_t murmur3_32(const uint8_t *key, size_t len, uint32_t seed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This declares the &lt;em&gt;murmur&lt;/em&gt; hash function. In its standard form &lt;code&gt;murmur3_32&lt;/code&gt; takes a pointer &lt;code&gt;key&lt;/code&gt; to byte-sized objects, a count of &lt;code&gt;len&lt;/code&gt; that speficies the number of bytes to hash and a random seed &lt;code&gt;seed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to use murmur3 as a &lt;code&gt;hamt&lt;/code&gt; hash function, we need to wrap it into a helper function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static uint32_t my_keyhash_string(const void *key, const size_t gen)&#xA;{&#xA;    uint32_t hash = murmur3_32((uint8_t *)key, strlen((const char *)key), gen);&#xA;    return hash;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, the wrapper makes use of &lt;code&gt;strlen(3)&lt;/code&gt;, assuming valid C strings as keys. Note the use of &lt;code&gt;gen&lt;/code&gt; as a seed for the hash (see below for the hash exhaustion discussion).&lt;/p&gt; &#xA;&lt;p&gt;Here is a full example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;murmur3.h&#34;&#xA;&#xA;/* ... */&#xA;&#xA;static uint32_t my_keyhash_string(const void *key, const size_t gen)&#xA;{&#xA;    uint32_t hash = murmur3_32((uint8_t *)key, strlen((const char *)key), gen);&#xA;    return hash;&#xA;}&#xA;&#xA;/* ... */&#xA;&#xA;    struct hamt *t = hamt_create(my_keyhash_string, my_keycmp_string,&#xA;                                 &amp;amp;hamt_allocator_default);&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Hash exhaustion: hash generations and state management&lt;/h3&gt; &#xA;&lt;p&gt;For a hash trie, the number of elements in the trie is limited by the total number of hashes that fits into a 32-bit &lt;code&gt;uint32_t&lt;/code&gt;, i.e. 2^32-1. Since the HAMT only uses 30 bits (in 6 chunks of 5 bits), the number of unique keys in the trie is limited to 2&lt;sup&gt;30&lt;/sup&gt;-1 = 1,073,741,823 keys. At the same time, since every layer of the tree uses 5 bits of the hash, the trie depth is limited to 32/5 = 6 layers. Neither the hard limit to the number of elements in the trie, nor the inability to build a trie beyond depth of 6 are desirable properties.&lt;/p&gt; &#xA;&lt;p&gt;To address both issues, &lt;code&gt;libhamt&lt;/code&gt; recalculates the hash with a different seed every 6 layers. This requires a bit of state management and motivates the existence of the &lt;code&gt;hash_state&lt;/code&gt; data type and functions that operate on it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct hash_state {&#xA;    const void *key;&#xA;    hamt_key_hash_fn hash_fn;&#xA;    uint32_t hash;&#xA;    size_t depth;&#xA;    size_t shift;&#xA;} hash_state;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The struct maintains the pointers &lt;code&gt;key&lt;/code&gt; to the key that is being hashed and &lt;code&gt;hash_fn&lt;/code&gt; to the hash function used to calculate the current hash &lt;code&gt;hash&lt;/code&gt;. At the same time, it tracks the current depth &lt;code&gt;depth&lt;/code&gt; in the tree (this is the &lt;em&gt;hash generation&lt;/em&gt;) and the bitshift &lt;code&gt;shift&lt;/code&gt; of the current 5-bit hash chunk.&lt;/p&gt; &#xA;&lt;p&gt;The interface provides two functions: the means to step from the current 5-bit hash to the next in &lt;code&gt;hash_next()&lt;/code&gt;; and the ability query the current index of a key at the current trie depth in &lt;code&gt;hash_get_index()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;hash_next()&lt;/code&gt; takes a pointer to a &lt;code&gt;hash_state&lt;/code&gt; instance and steps that instance from the current to the next chunk. Taking a step involves increasing the &lt;code&gt;depth&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt;, and initiating a rehash if the &lt;code&gt;shift&lt;/code&gt; indicates that the hash has been exhausted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline hash_state *hash_next(hash_state *h)&#xA;{&#xA;    h-&amp;gt;depth += 1;&#xA;    h-&amp;gt;shift += 5;&#xA;    if (h-&amp;gt;shift &amp;gt; 25) {&#xA;        h-&amp;gt;hash = h-&amp;gt;hash_fn(h-&amp;gt;key, h-&amp;gt;depth / 5);&#xA;        h-&amp;gt;shift = 0;&#xA;    }&#xA;    return h;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The index of a hash at its current depth corresponds to the decimal representation of the current chunk. To determine the current chunk, we right-shift the hash by &lt;code&gt;h-&amp;gt;shift&lt;/code&gt; to right-align the desired LSB and then mask with &lt;code&gt;0x11111&lt;/code&gt; which equals &lt;code&gt;0x1f&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline uint32_t hash_get_index(const hash_state *h)&#xA;{&#xA;    return (h-&amp;gt;hash &amp;gt;&amp;gt; h-&amp;gt;shift) &amp;amp; 0x1f;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Table management&lt;/h2&gt; &#xA;&lt;p&gt;In order to facilitate memory management for tables (aka the internal nodes), &lt;code&gt;libhamt&lt;/code&gt; defines a set of helper functions. Each of these functions takes a &lt;code&gt;hamt_allocator&lt;/code&gt; and calls the user-supplied allocation, re-allocation and deallocation functions as appropriate.&lt;/p&gt; &#xA;&lt;p&gt;We start by defining a simple memory abstraction (it would also be correct to use real functions instead of preprocessor macros for this):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define mem_alloc(ator, size) (ator)-&amp;gt;malloc(size)&#xA;#define mem_realloc(ator, ptr, size) (ator)-&amp;gt;realloc(ptr, size)&#xA;#define mem_free(ator, ptr) (ator)-&amp;gt;free(ptr)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will make it easier to add optimizations (e.g. table caching) in the future. On top of these macros, table lifecycle management is accomplished with a few dedicated allocation and de-allocation functions.&lt;/p&gt; &#xA;&lt;h3&gt;Simple allocation and deallocation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;table_allocate()&lt;/code&gt; allocates tables with size &lt;code&gt;size&lt;/code&gt; and returns a pointer to the newly allocated table.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;hamt_node *table_allocate(struct hamt_allocator *ator, size_t size)&#xA;{&#xA;    return (hamt_node *)mem_alloc(ator, (size * sizeof(hamt_node)));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;table_free()&lt;/code&gt; deallocates the allocation referenced by &lt;code&gt;ptr&lt;/code&gt;. It also supports taking a &lt;code&gt;size&lt;/code&gt; parameter for future extension (e.g. provide a hint for allocation pool management) that is currently ignored by the underlying &lt;code&gt;mem_free()&lt;/code&gt; implementation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void table_free(struct hamt_allocator *ator, hamt_node *ptr, size_t size)&#xA;{&#xA;    mem_free(ator, ptr);&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specialized table resize operations&lt;/h3&gt; &#xA;&lt;p&gt;While it is possible to implement table re- and right-sizing with the two functions introduced above, it makes a lot of sense to provide specialized functionality for the key allocation/de-allocation use cases: extending, shrinking and gathering a table.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table extension.&lt;/strong&gt; Since the tables in a HAMT are right-sized to minimize memory overhead, item insertion must necessarily add an additional row to an existing table. As illustrated in figure 3, the table extension function takes an anchor for an existing table, allocates a new table with increased size, copies over the exsiting entries (leaving a gap at the appropriate position for the new row), assigns the new key and value to the fields in the new row, updates the anchor with the new memory location of the table and the new index, and eventually frees the memory of the old table.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/doc/img/table-extend.png&#34; width=&#34;450&#34;&gt; &lt;/p&gt; &#xA;&lt;p class=&#34;image-caption&#34;&gt;&lt;b&gt;Figure 3:&lt;/b&gt; Extending a table creates a new copy of the existing table with an additional row for the new node. &lt;/p&gt; &#xA;&lt;p&gt;Looking at the code, this is implemented in verbatim in the &lt;code&gt;table_extend()&lt;/code&gt; function. &lt;code&gt;table_extend()&lt;/code&gt; takes an &lt;code&gt;anchor&lt;/code&gt; pointer to a table of size &lt;code&gt;n_rows&lt;/code&gt;, then uses the allocator &lt;code&gt;ator&lt;/code&gt; to create a new table of size &lt;code&gt;n_rows + 1&lt;/code&gt; with an empty row at position &lt;code&gt;pos&lt;/code&gt; and the bitmap index bit &lt;code&gt;index&lt;/code&gt; set. It uses &lt;code&gt;memcpy()&lt;/code&gt; to copy memory ranges into the the appropriate positions in the new allocation, frees the old table and assignes the new table &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; in the anchor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;hamt_node *table_extend(struct hamt_allocator *ator, hamt_node *anchor,&#xA;                       size_t n_rows, uint32_t index, uint32_t pos)&#xA;{&#xA;    hamt_node *new_table = table_allocate(ator, n_rows + 1);&#xA;    if (!new_table)&#xA;        return NULL;&#xA;    if (n_rows &amp;gt; 0) {&#xA;        /* copy over table */&#xA;        memcpy(&amp;amp;new_table[0], &amp;amp;TABLE(anchor)[0], pos * sizeof(hamt_node));&#xA;        /* note: this works since (n_rows - pos) == 0 for cases&#xA;         * where we&#39;re adding the new k/v pair at the end and memcpy(a, b, 0)&#xA;         * is a nop */&#xA;        memcpy(&amp;amp;new_table[pos + 1], &amp;amp;TABLE(anchor)[pos],&#xA;               (n_rows - pos) * sizeof(hamt_node));&#xA;    }&#xA;    table_free(ator, TABLE(anchor), n_rows);&#xA;    TABLE(anchor) = new_table;&#xA;    INDEX(anchor) |= (1 &amp;lt;&amp;lt; index);&#xA;    return anchor;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Shrinking a table.&lt;/strong&gt; Shrinking a table is the inverse operation of table extension: since we maintain right-sized tables as an invariant, we need to adjust table sizes the moment the client deletes a key/value pair from the HAMT.&lt;/p&gt; &#xA;&lt;p&gt;Figure 4 illustrates the concept: given an anchor, the shrinking function returns a new table with the specified row removed.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/doc/img/table-shrink.png&#34; width=&#34;450&#34;&gt; &lt;/p&gt; &#xA;&lt;p class=&#34;image-caption&#34;&gt;&lt;b&gt;Figure 4:&lt;/b&gt; Shrinking a table creates a new copy of the table with the specified row removed. &lt;/p&gt; &#xA;&lt;p&gt;In the code, this is what &lt;code&gt;table_shrink()&lt;/code&gt; does. In the same way as &lt;code&gt;table_extend()&lt;/code&gt; the function takes a pointer &lt;code&gt;ator&lt;/code&gt; to the global allocator, a pointer &lt;code&gt;anchor&lt;/code&gt; to the current anchor, the size of the current tables as &lt;code&gt;n_rows&lt;/code&gt;, and the pair of one-hot bitmap index &lt;code&gt;index&lt;/code&gt; and storage array position &lt;code&gt;pos&lt;/code&gt;. And, in analogy to table extension, the function allocation a right-sized table, copies the data to keep using range copies with &lt;code&gt;memcpy()&lt;/code&gt;, frees up the old table and updates the anchor to reflect the changes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;hamt_node *table_shrink(struct hamt_allocator *ator, hamt_node *anchor,&#xA;                       size_t n_rows, uint32_t index, uint32_t pos)&#xA;{&#xA;    hamt_node *new_table = NULL;&#xA;    uint32_t new_index = 0;&#xA;    if (n_rows &amp;gt; 0) {&#xA;        new_table = table_allocate(ator, n_rows - 1);&#xA;        if (!new_table)&#xA;            return NULL;&#xA;        new_index = INDEX(anchor) &amp;amp; ~(1 &amp;lt;&amp;lt; index);&#xA;        memcpy(&amp;amp;new_table[0], &amp;amp;TABLE(anchor)[0], pos * sizeof(hamt_node));&#xA;        memcpy(&amp;amp;new_table[pos], &amp;amp;TABLE(anchor)[pos + 1],&#xA;               (n_rows - pos - 1) * sizeof(hamt_node));&#xA;    }&#xA;    table_free(ator, TABLE(anchor), n_rows);&#xA;    INDEX(anchor) = new_index;&#xA;    TABLE(anchor) = new_table;&#xA;    return anchor;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table gathering.&lt;/strong&gt; As we are deleting entries from the HAMT, we may end up with the table structure shown in Figure 5: a table in which one of the entries is a single-row table. What we want to do in these cases is to replace the table entry in &lt;code&gt;TABLE(anchor)[1]&lt;/code&gt; with the key/value pair from &lt;code&gt;TABLE(TABLE(anchor)[1])&lt;/code&gt; and &lt;em&gt;gather&lt;/em&gt; the one-row table into its parent. While this comes at additional computational cost upon delete, it maintains the logarithmic depth properties as the HAMT changes its size.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/doc/img/table-gather.png&#34; width=&#34;450&#34;&gt; &lt;/p&gt; &#xA;&lt;p class=&#34;image-caption&#34;&gt;&lt;b&gt;Figure 5:&lt;/b&gt; Gathering pulls a one-row-sized table into its parent table (essentially converting an internal node into a leaf node). &lt;/p&gt; &#xA;&lt;p&gt;The code is straightforward: we take the allocator &lt;code&gt;alloc&lt;/code&gt;, the &lt;code&gt;anchor&lt;/code&gt; pointer, and the position &lt;code&gt;pos&lt;/code&gt; of the single-row table inside the parent table, copy over the key and value from the child table to the parent (maintaining a temporary handle on the child) and then free the child table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;hamt_node *table_gather(struct hamt_allocator *ator, hamt_node *anchor,&#xA;                       uint32_t pos)&#xA;{&#xA;    int n_rows = get_popcount(INDEX(anchor));&#xA;    hamt_node *table = TABLE(anchor);&#xA;    KEY(anchor) = table[pos].as.kv.key;&#xA;    VALUE(anchor) = table[pos].as.kv.value; /* already tagged */&#xA;    table_free(ator, table, n_rows);&#xA;    return anchor;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table duplication.&lt;/strong&gt; Lastly, table duplication. This will be required for path copying when we implement persistency and it is so straightforward that there is no diagram: given an anchor, &lt;code&gt;table_dup()&lt;/code&gt; determines the size of the table that the anchor points to, allocates the required memory and performs a range copy using &lt;code&gt;memcpy()&lt;/code&gt; to duplicate the table contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;hamt_node *table_dup(struct hamt_allocator *ator, hamt_node *anchor)&#xA;{&#xA;    int n_rows = get_popcount(INDEX(anchor));&#xA;    hamt_node *new_table = table_allocate(ator, n_rows);&#xA;    if (new_table) {&#xA;        memcpy(&amp;amp;new_table[0], &amp;amp;TABLE(anchor)[0], n_rows * sizeof(hamt_node));&#xA;    }&#xA;    return new_table;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Putting it all together&lt;/h2&gt; &#xA;&lt;p&gt;The following subsections detail the implementations of search, insertion and removal of key/value pairs in our HAMT implementation. Note that, while the implementations shown here have been thoroughly tested and are deemed correct, they may have been replaced by faster or more capable implementations in the actual &lt;code&gt;libhamt&lt;/code&gt; source. An attempt is being made to keep this section up to date with the actual implementation but the choice here is in favor of conceptual clarity and will not necessarily cover every implementation detail. PRs welcome.&lt;/p&gt; &#xA;&lt;h3&gt;Example data&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;key&lt;/th&gt; &#xA;   &lt;th&gt;key hash&lt;/th&gt; &#xA;   &lt;th&gt;binary key hash&lt;/th&gt; &#xA;   &lt;th&gt;5-bit ints&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&#34;0&#34;&lt;/td&gt; &#xA;   &lt;td&gt;d271c07f&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;11 01001 00111 00011 10000 00011 11111&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[ 31 3 16 3 7 9 ]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&#34;2&#34;&lt;/td&gt; &#xA;   &lt;td&gt;0129e217&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;00 00000 10010 10011 11000 10000 10111&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[ 23 16 24 19 18 0 ]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&#34;4&#34;&lt;/td&gt; &#xA;   &lt;td&gt;e131cc88&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;11 10000 10011 00011 10011 00100 01000&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[ 8 4 19 3 19 16 ]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&#34;7&#34;&lt;/td&gt; &#xA;   &lt;td&gt;23ea8628&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;00 10001 11110 10101 00001 10001 01000&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[ 8 17 1 21 30 17 ]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&#34;8&#34;&lt;/td&gt; &#xA;   &lt;td&gt;bd920017&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;10 11110 11001 00100 00000 00000 10111&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[ 23 0 0 4 25 30 ]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Search: internal API&lt;/h3&gt; &#xA;&lt;p&gt;Search plays a double role: finding a HAMT entry is a fundamental part of the HAMT interface (exposed by &lt;code&gt;hamt_get()&lt;/code&gt;); and the first step in the insert and remove functions is finding the anchors to operate on.&lt;/p&gt; &#xA;&lt;p&gt;It is therefore desirable to approach the search implementation from a more generic perspective such that we do not need to re-invent the wheel for each of these use cases. We therefore define an internal search function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static ... search_recursive(...);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;that is called from internal and the API functions alike. As the name implies, we implement search in a recursive manner (this is for clarity; conversion to an iterative solution is straightforward).&lt;/p&gt; &#xA;&lt;p&gt;When we search for a key in the HAMT, there are two fundamental outcomes: the key is either there, or it is not (note that these are exactly the semantics of the user-facing &lt;code&gt;hamt_get()&lt;/code&gt; function: it either returns a pointer to the value stored under the key or it returns &lt;code&gt;NULL&lt;/code&gt;). However, looking more closely, searches can fail for two reasons: the search can be unsuccessful because a key does not exist in the HAMT &lt;em&gt;or&lt;/em&gt; it can be unsuccessful because there is a key value pair that happens to have the same partial hash but a different key (i.e. there is a hash collission or the hash has not been sufficiently exhausted to differentiate between the two keys). And each of these three cases is meaningful (the latter two corresponding directly to the two different insertion strategies described below).&lt;/p&gt; &#xA;&lt;p&gt;A good approach here is to define a ternary return value (as opposed to the usual, binary use-&lt;code&gt;NULL&lt;/code&gt;-as-a-failure-indicator approach that is often prevalent in C code) to allow us to signal each of these cases clearly.&lt;/p&gt; &#xA;&lt;p&gt;We create a suitable three-value &lt;code&gt;enum&lt;/code&gt; called &lt;code&gt;search_status&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef enum {&#xA;    SEARCH_SUCCESS,&#xA;    SEARCH_FAIL_NOTFOUND,&#xA;    SEARCH_FAIL_KEYMISMATCH&#xA;} search_status;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;SEARCH_SUCCESS&lt;/code&gt; indicates that the key in question was found, &lt;code&gt;SEARCH_FAIL_NOTFOUND&lt;/code&gt; indicates a search failure due to a missing key, and &lt;code&gt;SEARCH_FAIL_KEYMISMATCH&lt;/code&gt; signals a hash conflict.&lt;/p&gt; &#xA;&lt;p&gt;In order to return the result of a search (and not only its status), we introduce a search result data type that is a bit more heavy-weight:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct search_result {&#xA;    search_status status;&#xA;    hamt_node *anchor;&#xA;    hamt_node *value;&#xA;    hash_state *hash;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, &lt;code&gt;anchor&lt;/code&gt; always points to the anchor at which the search was terminated; if the search was successful, &lt;code&gt;value&lt;/code&gt; points to the table row that holds the key/value pair with matching key; if it was unsuccessful with a key mismatch, &lt;code&gt;value&lt;/code&gt; points to the mismatching key/value pair; and if it was unsuccessful because the key did not exist, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;NULL&lt;/code&gt;. Depending on the depth that the search reached, we may have hit hash exhaustion and the hash may have been recalculated, so we are returning this here, too.&lt;/p&gt; &#xA;&lt;p&gt;Given &lt;code&gt;struct search_result&lt;/code&gt;, the return value of &lt;code&gt;search_recursive()&lt;/code&gt; becomes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static struct search_result search_recursive(...)&#xA;{&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With these prerequisites out of the way, we can tackle the actual search algorithm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    search_recursive(anchor, hash, eq, key, ...):&#xA;        if the current 5-bit sub-hash is a valid index in the current table: &#xA;            if the index refers to a key/value pair:&#xA;                if the key matches the search key:&#xA;                    return SEARCH_SUCCESS&#xA;                else:&#xA;                    return SEARCH_FAIL_KEYMISMATCH&#xA;            else (i.e. it refers to a sub-table):&#xA;                search_recursive(sub-table, hash_next(hash), eq, key)&#xA;        else:&#xA;            return SEARCH_FAIL_NOTFOUND&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The basic idea is to start from the root of the HAMT and then, at every level, test if the curret sub-hash of the key is present in the current sub-trie. If not, bail and report failure immediately. If yes, check if the entry refers to a key/value pair or to another table. If this is true as well, check if the keys match and return success or failure accordingly. If the entry refers to a sub-table, repeat the search at the level of the sub-table.&lt;/p&gt; &#xA;&lt;p&gt;With the conceptual approach lined out, let&#39;s get into the implementation details. We start with deriving the table index for the current search level from the hash. This is accomplished using &lt;code&gt;hash_get_index()&lt;/code&gt;, which encapsulates the bit-fiddling required to extract the correct 5-bit hash for the current search level and returns the index as an unsigned integer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static search_result search_recursive(hamt_node *anchor,&#xA;                                      hash_state *hash,&#xA;                                      hamt_cmp_fn cmp_eq,&#xA;                                      const void *key, ...)&#xA;{&#xA;    uint32_t expected_index = hash_get_index(hash);&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code then checks if the &lt;code&gt;expected_index&lt;/code&gt; exists in the current table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    ...&#xA;    if (has_index(anchor, expected_index)) {&#xA;    ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, &lt;code&gt;has_index()&lt;/code&gt; is a simple helper function that checks if the &lt;code&gt;INDEX(anchor)&lt;/code&gt; bitfield has the bit set at &lt;code&gt;expected_index&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline bool has_expected_index(const hamt_node *anchor, size_t expected_index)&#xA;{&#xA;    return INDEX(anchor) &amp;amp; (1 &amp;lt;&amp;lt; expected_index);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;has_index()&lt;/code&gt; evaluates to false, the key does not exist in the HAMT and we can immediately fail the search and return the result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{&#xA;    uint32_t expected_index = hash_get_index(hash);&#xA;    if (has_index(anchor, expected_index)) {&#xA;        ...&#xA;        ... &#xA;        ...&#xA;    }&#xA;    search_result result = {.status = SEARCH_FAIL_NOTFOUND,&#xA;                            .anchor = anchor,&#xA;                            .value = NULL,&#xA;                            .hash = hash};&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;has_index()&lt;/code&gt; evaluates to true, we find the array index using &lt;code&gt;get_pos()&lt;/code&gt; (see above), store it into &lt;code&gt;pos&lt;/code&gt; and then acquire a pointer to the &lt;code&gt;next&lt;/code&gt; node by addressing &lt;code&gt;pos&lt;/code&gt; indices into the &lt;code&gt;anchor&lt;/code&gt;&#39;s table.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{&#xA;    ...&#xA;    if (has_index(anchor, expected_index)) {&#xA;        /* If yes, get the compact index to address the array */&#xA;        int pos = get_pos(expected_index, INDEX(anchor));&#xA;        /* Index into the table */&#xA;        hamt_node *next = &amp;amp;TABLE(anchor)[pos];&#xA;        ...&#xA;    }&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the &lt;code&gt;next&lt;/code&gt; node is not a value, we advance the hash state and recurse the search. If it is, we compare the keys and return success or failure accordingly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{&#xA;        ...&#xA;        /* Index into the table */&#xA;        hamt_node *next = &amp;amp;TABLE(anchor)[pos];&#xA;        /* Are we looking at a value or another level of tables? */&#xA;        if (is_value(VALUE(next))) {&#xA;            if ((*cmp_eq)(key, KEY(next)) == 0) {&#xA;                /* Found: keys match */&#xA;                search_result result = {.status = SEARCH_SUCCESS,&#xA;                                        .anchor = anchor,&#xA;                                        .value = next,&#xA;                                        .hash = hash};&#xA;                return result;&#xA;            }&#xA;            /* Not found: same hash but different key */&#xA;            search_result result = {.status = SEARCH_FAIL_KEYMISMATCH,&#xA;                                    .anchor = anchor,&#xA;                                    .value = next,&#xA;                                    .hash = hash};&#xA;            return result;&#xA;        } else {&#xA;            /* For table entries, recurse to the next level */&#xA;            return search_recursive(next, hash_next(hash), cmp_eq, key);&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That concludes the implementation of the recursive search function and the complete implementation looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static search_result search_recursive(hamt_node *anchor, hash_state *hash,&#xA;                                      hamt_cmp_fn cmp_eq, const void *key)&#xA;{&#xA;    /* Determine the expected index in table */&#xA;    uint32_t expected_index = hash_get_index(hash);&#xA;    /* Check if the expected index is set */&#xA;    if (has_index(anchor, expected_index)) {&#xA;        /* If yes, get the compact index to address the array */&#xA;        int pos = get_pos(expected_index, INDEX(anchor));&#xA;        /* Index into the table */&#xA;        hamt_node *next = &amp;amp;TABLE(anchor)[pos];&#xA;        /* Are we looking at a value or another level of tables? */&#xA;        if (is_value(VALUE(next))) {&#xA;            if ((*cmp_eq)(key, KEY(next)) == 0) {&#xA;                /* Found: keys match */&#xA;                search_result result = {.status = SEARCH_SUCCESS,&#xA;                                        .anchor = anchor,&#xA;                                        .value = next,&#xA;                                        .hash = hash};&#xA;                return result;&#xA;            }&#xA;            /* Not found: same hash but different key */&#xA;            search_result result = {.status = SEARCH_FAIL_KEYMISMATCH,&#xA;                                    .anchor = anchor,&#xA;                                    .value = next,&#xA;                                    .hash = hash};&#xA;            return result;&#xA;        } else {&#xA;            /* For table entries, recurse to the next level */&#xA;            return search_recursive(next, hash_next(hash), cmp_eq, key);&#xA;        }&#xA;    }&#xA;    /* Not found: expected index is not set, key does not exist */&#xA;    search_result result = {.status = SEARCH_FAIL_NOTFOUND,&#xA;                            .anchor = anchor,&#xA;                            .value = NULL,&#xA;                            .hash = hash};&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Search: external API&lt;/h3&gt; &#xA;&lt;p&gt;The external API for search is &lt;code&gt;hamt_get(trie, key)&lt;/code&gt; which takes a &lt;code&gt;trie&lt;/code&gt; and attempts to find (and return) a key/value pair specified by &lt;code&gt;key&lt;/code&gt;. Its implementation uses &lt;code&gt;search_recursive()&lt;/code&gt; from above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const void *hamt_get(const struct hamt *trie, void *key)&#xA;{&#xA;    hash_state *hash = &amp;amp;(hash_state){.key = key,&#xA;                                     .hash_fn = trie-&amp;gt;key_hash,&#xA;                                     .hash = trie-&amp;gt;key_hash(key, 0),&#xA;                                     .depth = 0,&#xA;                                     .shift = 0};&#xA;    search_result sr = search_recursive(trie-&amp;gt;root, hash, trie-&amp;gt;key_cmp, key,&#xA;                                        NULL, trie-&amp;gt;ator);&#xA;    if (sr.status == SEARCH_SUCCESS) {&#xA;        return untagged(sr.VALUE(value));&#xA;    }&#xA;    return NULL;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to use &lt;code&gt;search_recursive()&lt;/code&gt;, it is necessary to set up the hash state management, initializing it with the &lt;code&gt;key&lt;/code&gt;, the hashed &lt;code&gt;key&lt;/code&gt;, and starting search from level &lt;code&gt;0&lt;/code&gt; (corresponding to a shift of &lt;code&gt;0&lt;/code&gt;). If the search is not successful, the function returns &lt;code&gt;NULL&lt;/code&gt;, if it is successful, it passes a &lt;code&gt;void&lt;/code&gt; pointer to the value that corresponds to &lt;code&gt;key&lt;/code&gt;. Note the &lt;em&gt;untagging&lt;/em&gt; of the &lt;code&gt;value&lt;/code&gt; field since we&#39;re using it as a &lt;em&gt;tagged pointer&lt;/em&gt; to indicate field types.&lt;/p&gt; &#xA;&lt;h3&gt;Insert: internal functions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;libhamt&lt;/code&gt; does not support an explicit insertion function; all insertions into the HAMT are &lt;em&gt;upserts&lt;/em&gt;, i.e. after calling &lt;code&gt;hamt_set()&lt;/code&gt; the API guarantees that the requested key/value pair exists, irrespective of potential previous entries that may have had the same key but a different value.&lt;/p&gt; &#xA;&lt;p&gt;The internal function that implements this behavior is &lt;code&gt;set()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static const hamt_node *set(struct hamt *h, hamt_node *anchor, hamt_key_hash_fn hash_fn,&#xA;                            hamt_cmp_fn cmp_fn, void *key, void *value)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;set()&lt;/code&gt; takes a HAMT, an anchor in that HAMT, hashing and comparison functions as well as a key/value pair. After initializing the hash state, the function makes use of &lt;code&gt;search_recursive&lt;/code&gt; to find the specified &lt;code&gt;key&lt;/code&gt;. It deals with three different search outcomes: (1) if the search is successful, the value of &lt;code&gt;key&lt;/code&gt; gets replaced with the new &lt;code&gt;value&lt;/code&gt;; (2) if the search is unsuccessful because the key does not exist, it attempts to insert a new key/value pair at the appropriate position; and (3) if the search fails due to a key mismatch (i.e. there is an entry at the expected hash position but its key does not equal &lt;code&gt;key&lt;/code&gt;), it extends the hash trie until the new key/value pair can be placed correctly. Cases (2) and (3) are covered by the &lt;code&gt;insert_kv()&lt;/code&gt; and &lt;code&gt;insert_table()&lt;/code&gt; helper functions, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static const hamt_node *set(struct hamt *h, hamt_node *anchor, hamt_key_hash_fn hash_fn,&#xA;                            hamt_cmp_fn cmp_fn, void *key, void *value)&#xA;{&#xA;    hash_state *hash = &amp;amp;(hash_state){.key = key,&#xA;                                     .hash_fn = hash_fn,&#xA;                                     .hash = hash_fn(key, 0),&#xA;                                     .depth = 0,&#xA;                                     .shift = 0};&#xA;    search_result sr =&#xA;        search_recursive(anchor, hash, cmp_fn, key, NULL, h-&amp;gt;ator);&#xA;    const hamt_node *inserted;&#xA;    switch (sr.status) {&#xA;    case SEARCH_SUCCESS:&#xA;        sr.VALUE(value) = tagged(value);&#xA;        inserted = sr.value;&#xA;        break;&#xA;    case SEARCH_FAIL_NOTFOUND:&#xA;        if ((inserted = insert_kv(sr.anchor, sr.hash, key, value, h-&amp;gt;ator)) !=&#xA;            NULL) {&#xA;            h-&amp;gt;size += 1;&#xA;        }&#xA;        break;&#xA;    case SEARCH_FAIL_KEYMISMATCH:&#xA;        if ((inserted = insert_table(sr.value, sr.hash, key, value, h-&amp;gt;ator)) !=&#xA;            NULL) {&#xA;            h-&amp;gt;size += 1;&#xA;        }&#xA;        break;&#xA;    }&#xA;    return inserted;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the call to &lt;code&gt;search_recursive()&lt;/code&gt; fails with &lt;code&gt;SEARCH_FAIL_NOTFOUND&lt;/code&gt;, we know that there is a free row in the table of &lt;code&gt;sr.anchor&lt;/code&gt;. To insert the new &lt;code&gt;key&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; pair, we calculate the position of the &lt;code&gt;key&lt;/code&gt; in the current table: it extracts the 0-31 index position for the current key and stores it into &lt;code&gt;ix&lt;/code&gt;, extends the existing &lt;code&gt;INDEX(anchor)&lt;/code&gt; index bitmap to include the new key by setting the &lt;code&gt;ix&lt;/code&gt;-th bit, and then calculates the dense index position of the new entry via &lt;code&gt;get_pos()&lt;/code&gt;. It then uses &lt;code&gt;table_extend()&lt;/code&gt; to extend the table to the correct size and populates the &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; entries to reflect the new key/value pair. Note the pointer tagging on the value field to mark it as a key/value row in the table (as opposed to a row that points to a sub-table).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static const hamt_node *insert_kv(hamt_node *anchor, hash_state *hash,&#xA;                                  void *key, void *value,&#xA;                                  struct hamt_allocator *ator)&#xA;{&#xA;    /* calculate position in new table */&#xA;    uint32_t ix = hash_get_index(hash);&#xA;    uint32_t new_index = INDEX(anchor) | (1 &amp;lt;&amp;lt; ix);&#xA;    int pos = get_pos(ix, new_index);&#xA;    /* extend table */&#xA;    size_t n_rows = get_popcount(INDEX(anchor));&#xA;    anchor = table_extend(ator, anchor, n_rows, ix, pos);&#xA;    if (!anchor)&#xA;        return NULL;&#xA;    hamt_node *new_table = TABLE(anchor);&#xA;    /* set new k/v pair */&#xA;    new_table[pos].as.kv.key = key;&#xA;    new_table[pos].as.kv.value = tagged(value);&#xA;    /* return a pointer to the inserted k/v pair */&#xA;    return &amp;amp;new_table[pos];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When the call to &lt;code&gt;search_recursive()&lt;/code&gt; in &lt;code&gt;set()&lt;/code&gt; fails with &lt;code&gt;SEARCH_FAIL_KEYMISMATCH&lt;/code&gt;, the situation is different: there is another entry (either a key/value pair or a reference to a sub-table) in the HAMT that currently occupies a transitionary trie location for &lt;code&gt;key&lt;/code&gt;. This is expected to happen regularly: keys are always inserted with the shortest possible trie path that resolves hashing conflicts between &lt;em&gt;existing&lt;/em&gt; keys. As more and more entries are added to the HAMT, these paths necessarily must increase in length. This situation is handled by &lt;code&gt;insert_table()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static const hamt_node *insert_table(hamt_node *anchor, hash_state *hash,&#xA;                                     void *key, void *value,&#xA;                                     struct hamt_allocator *ator)&#xA;{&#xA;    /* Collect everything we know about the existing value */&#xA;    hash_state *x_hash =&#xA;        &amp;amp;(hash_state){.key = KEY(anchor),&#xA;                      .hash_fn = hash-&amp;gt;hash_fn,&#xA;                      .hash = hash-&amp;gt;hash_fn(KEY(anchor), hash-&amp;gt;depth / 5),&#xA;                      .depth = hash-&amp;gt;depth,&#xA;                      .shift = hash-&amp;gt;shift};&#xA;    void *x_value = VALUE(anchor); /* tagged (!) value ptr */&#xA;    /* increase depth until the hashes diverge, building a list&#xA;     * of tables along the way */&#xA;    hash_state *next_hash = hash_next(hash);&#xA;    hash_state *x_next_hash = hash_next(x_hash);&#xA;    uint32_t next_index = hash_get_index(next_hash);&#xA;    uint32_t x_next_index = hash_get_index(x_next_hash);&#xA;    while (x_next_index == next_index) {&#xA;        TABLE(anchor) = table_allocate(ator, 1);&#xA;        INDEX(anchor) = (1 &amp;lt;&amp;lt; next_index);&#xA;        next_hash = hash_next(next_hash);&#xA;        x_next_hash = hash_next(x_next_hash);&#xA;        next_index = hash_get_index(next_hash);&#xA;        x_next_index = hash_get_index(x_next_hash);&#xA;        anchor = TABLE(anchor);&#xA;    }&#xA;    /* the hashes are different, let&#39;s allocate a table with two&#xA;     * entries to store the existing and new values */&#xA;    TABLE(anchor) = table_allocate(ator, 2);&#xA;    INDEX(anchor) = (1 &amp;lt;&amp;lt; next_index) | (1 &amp;lt;&amp;lt; x_next_index);&#xA;    /* determine the proper position in the allocated table */&#xA;    int x_pos = get_pos(x_next_index, INDEX(anchor));&#xA;    int pos = get_pos(next_index, INDEX(anchor));&#xA;    /* fill in the existing value; no need to tag the value pointer&#xA;     * since it is already tagged. */&#xA;    TABLE(anchor)[x_pos].as.kv.key = (void *)x_hash-&amp;gt;key;&#xA;    TABLE(anchor)[x_pos].as.kv.value = x_value;&#xA;    /* fill in the new key/value pair, tagging the pointer to the&#xA;     * new value to mark it as a value ptr */&#xA;    TABLE(anchor)[pos].as.kv.key = key;&#xA;    TABLE(anchor)[pos].as.kv.value = tagged(value);&#xA;&#xA;    return &amp;amp;TABLE(anchor)[pos];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;insert_table()&lt;/code&gt; works in three stages: (1) it initiatlizes the &lt;code&gt;hash_state&lt;/code&gt; for the current anchor; (2) creates a series of single-entry tables until the hashes of the current and new keys diverge; and (3) finally creates a new table of size 2 that holds the old entry as well as the new key/value pair.&lt;/p&gt; &#xA;&lt;h3&gt;Insert: external API&lt;/h3&gt; &#xA;&lt;p&gt;The implementation of the external API for inserting and updating values in the HAMT is straighforward:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const void *hamt_set(struct hamt *trie, void *key, void *value)&#xA;{&#xA;    const hamt_node *n =&#xA;        set(trie, trie-&amp;gt;root, trie-&amp;gt;key_hash, trie-&amp;gt;key_cmp, key, value);&#xA;    return VALUE(n);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;hamt_set()&lt;/code&gt; uses a vanilla call to the internal &lt;code&gt;set()&lt;/code&gt; function and returns a pointer to the value of the new key.&lt;/p&gt; &#xA;&lt;h3&gt;Remove&lt;/h3&gt; &#xA;&lt;h3&gt;Iterators&lt;/h3&gt; &#xA;&lt;h2&gt;Persistent data structures and structural sharing&lt;/h2&gt; &#xA;&lt;h3&gt;Path copying&lt;/h3&gt; &#xA;&lt;h3&gt;Insert&lt;/h3&gt; &#xA;&lt;h3&gt;Remove&lt;/h3&gt; &#xA;&lt;h1&gt;Appendix&lt;/h1&gt; &#xA;&lt;h2&gt;Unit testing&lt;/h2&gt; &#xA;&lt;p&gt;For testing, &lt;code&gt;hamt&lt;/code&gt; uses a variant of &lt;a href=&#34;http://www.jera.com/techinfo/jtns/jtn002.html&#34;&gt;John Brewer&#39;s &lt;code&gt;minunit&lt;/code&gt; testing framework&lt;/a&gt;. Minunit is extremely minimalistic and its header-only implementation easily fits on a single page:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test/minunit.h&#xA;#ifndef MINUNIT_H&#xA;#define MINUNIT_H&#xA;&#xA;#define MU_ASSERT(test, message)                                               \&#xA;    do {                                                                       \&#xA;        if (!(test))                                                           \&#xA;            return message;                                                    \&#xA;    } while (0)&#xA;#define MU_RUN_TEST(test)                                                      \&#xA;    do {                                                                       \&#xA;        char *message = test();                                                \&#xA;        mu_tests_run++;                                                        \&#xA;        if (message)                                                           \&#xA;            return message;                                                    \&#xA;    } while (0)&#xA;&#xA;#define MU_TEST_CASE(name) static char *name()&#xA;#define MU_TEST_SUITE(name) static char *name()&#xA;&#xA;extern int mu_tests_run;&#xA;&#xA;#endif /* !MINUNIT_H */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;code&gt;minunit&lt;/code&gt;, every unit test is a &lt;code&gt;MU_TEST_CASE&lt;/code&gt; We use &lt;code&gt;MU_ASSERT&lt;/code&gt; to test the test invariants. Test cases are grouped into &lt;code&gt;MU_TEST_SUITE&lt;/code&gt;s as sequential calls to &lt;code&gt;MU_RUN_TEST&lt;/code&gt;. When an assertion fails, the &lt;code&gt;return&lt;/code&gt; statement in &lt;code&gt;MU_ASSERT&lt;/code&gt; short-circuts test execution and returns a non-null pointer to the respective &lt;code&gt;message&lt;/code&gt; (generally a static string). This, in turn, causes &lt;code&gt;MU_RUN_TEST&lt;/code&gt; to issue a &lt;code&gt;return&lt;/code&gt; call with the string pointer, short-circuting the remaining test suite. The header also declares a global variable &lt;code&gt;mu_tests_run&lt;/code&gt; that keeps track of the total number of executed tests.&lt;/p&gt; &#xA;&lt;p&gt;The following listing illustrates the basic structure of unit test implementations with &lt;code&gt;minunit&lt;/code&gt;, check the &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/test/test_hamt.c&#34;&gt;actual tests&lt;/a&gt; for a full listing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test/test_hamt.c&#xA;#include &#34;minunit.h&#34;&#xA;#include &#34;../src/hamt.c&#34;&#xA;&#xA;int mu_tests_run = 0;&#xA;&#xA;MU_TEST_CASE(test_dummy)&#xA;{&#xA;    /* do something here */&#xA;    MU_ASSERT(0 == 0, &#34;Oops X-{&#34;);&#xA;    return 0;&#xA;}&#xA;&#xA;MU_TEST_SUITE(test_suite)&#xA;{&#xA;    /* Add tests here */&#xA;    MU_RUN_TEST(test_dummy);&#xA;    /*&#xA;     * ... many more ...&#xA;     */&#xA;    return 0;&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    printf(&#34;---=[ Hash array mapped trie tests\n&#34;);&#xA;    char *result = test_suite();&#xA;    if (result != 0) {&#xA;        printf(&#34;%s\n&#34;, result);&#xA;    } else {&#xA;        printf(&#34;All tests passed.\n&#34;);&#xA;    }&#xA;    printf(&#34;Tests run: %d\n&#34;, tests_run);&#xA;    return result != 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the test setup &lt;code&gt;include&lt;/code&gt;s the &lt;code&gt;hamt.c&lt;/code&gt; implementation file. This is a common trick used in unit testing to gain easy access to testing &lt;code&gt;static&lt;/code&gt; functions that would otherwise be inaccessible since they are local to the &lt;code&gt;hamt.c&lt;/code&gt; compilation unit. This requires some care in the Makefile setup in order to avoid symbol duplication.&lt;/p&gt; &#xA;&lt;h1&gt;Footnotes&lt;/h1&gt; &#xA;&lt;p&gt;&lt;b id=&#34;fn_hash_table_cpp&#34;&gt;[1]&lt;/b&gt; The &lt;code&gt;std::unordered_*&lt;/code&gt; methods implement open hashing (aka separate chaining), with the hash table being an array of buckets, each pointing to the head of a linked list. This is a deliberate and reasonable compromise for general use; gaining an order of magnitude of speed improvements for specialized use cases (e.g. append-only, guaranteed high-quality hash functions) is possible. See &lt;a href=&#34;https://stackoverflow.com/a/31113618&#34;&gt;this stackoverflow post&lt;/a&gt; for a summary of the &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html&#34;&gt;standard proposal&lt;/a&gt;. &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#ac_hash_table_cpp&#34;&gt;↩&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;b id=&#34;fn_hash_table_c&#34;&gt;[2]&lt;/b&gt; &lt;code&gt;musl&lt;/code&gt; provides a &lt;code&gt;hsearch&lt;/code&gt; implementation that uses closed hashing with quadratic probing for conflict resolution. The &lt;a href=&#34;https://git.musl-libc.org/cgit/musl/tree/src/search/hsearch.c&#34;&gt;documentation&lt;/a&gt; states that they use powers of two for table sizing which seems wrong due to the impact on the modulo (table sizes should ideally be prime). The GLib &lt;code&gt;GHashTable&lt;/code&gt; has surprisingly little documentation in its implementation details but &lt;a href=&#34;https://gitlab.gnome.org/GNOME/glib/-/blob/main/glib/ghash.c&#34;&gt;appears to be using&lt;/a&gt; a separate chaining approach similar to the C++ solution. &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#ac_hash_table_c&#34;&gt;↩&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;b id=&#34;fn_hash_table_python&#34;&gt;[3]&lt;/b&gt; Python&#39;s &lt;code&gt;dict&lt;/code&gt; implementation uses closed hashing (aka open addressing) with pseudo-random probing to mitigate the poor hashing properties of standard python &lt;code&gt;hash()&lt;/code&gt; function for some data types (from &lt;a href=&#34;https://stackoverflow.com/a/9022835&#34;&gt;here&lt;/a&gt;). Python keeps the load factor below 0.66; this avoids gradual performance degradation associated w/ high load factors in closed hashing but comes at increased memory footprint. The &lt;a href=&#34;https://github.com/python/cpython/raw/main/Objects/dictobject.c&#34;&gt;codebase&lt;/a&gt; was refactored to split the actual data from the hash table in 3.6, resulting in better memory efficiency and GC friendliness (see &lt;a href=&#34;https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://mail.python.org/pipermail/python-dev/2012-December/123028.html&#34;&gt;here&lt;/a&gt;). &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#ac_hash_table_python&#34;&gt;↩&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;b id=&#34;fn_hash_table_java&#34;&gt;[4]&lt;/b&gt; Java provides &lt;code&gt;Hashtable&amp;lt;K,V&amp;gt;&lt;/code&gt; and &lt;code&gt;HashMap&amp;lt;K,V&amp;gt;&lt;/code&gt;, both of which implement &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Collection&lt;/code&gt; interfaces; in addition, &lt;code&gt;Hashtable&lt;/code&gt; is synchronized. The &lt;code&gt;HashSet&lt;/code&gt; type internally uses a &lt;code&gt;HashMap&lt;/code&gt;. &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; implement open hashing (separate chaining) with a default load factor of 0.75; The OpenJDK implementation of &lt;code&gt;HashMap&lt;/code&gt; converts between linked list and tree representations in the hash buckets, depending on bucket size, see &lt;a href=&#34;https://github.com/openjdk/jdk17/raw/74007890bb9a3fa3a65683a3f480e399f2b1a0b6/src/java.base/share/classes/java/util/HashMap.java&#34;&gt;the source&lt;/a&gt;. &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#ac_hash_table_java&#34;&gt;↩&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;b id=&#34;fn_cpp_virtual_method_table&#34;&gt;[5]&lt;/b&gt; There are alternative approaches to enable (somewhat) typesafe templating in C, mainly by implementing what basically amounts to virtual method tables using the C preprocessor. See e.g. &lt;a href=&#34;https://stackoverflow.com/questions/10950828/simulation-of-templates-in-c-for-a-queue-data-type/11035347&#34;&gt;here&lt;/a&gt; for a useful stackoverflow summary or &lt;a href=&#34;http://blog.pkh.me/p/20-templating-in-c.html&#34;&gt;here&lt;/a&gt; for a more in-depth treatise. &lt;a href=&#34;https://raw.githubusercontent.com/mkirchner/hamt/main/#ac_cpp_virtual_method_table&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>