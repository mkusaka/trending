<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-11T01:44:14Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>esp32-open-mac/esp32-open-mac</title>
    <updated>2023-12-11T01:44:14Z</updated>
    <id>tag:github.com,2023-12-11:/esp32-open-mac/esp32-open-mac</id>
    <link href="https://github.com/esp32-open-mac/esp32-open-mac" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Reverse engineered wifi driver for the ESP32&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ESP32 open Wi-Fi MAC proof-of-concept&lt;/h1&gt; &#xA;&lt;p&gt;This is a proof-of-concept, showing how to use the ESP32 Wi-Fi hardware peripherals. Espressif (the manufacturer of the ESP32) did not document the Wi-Fi hardware peripherals in any of their (public) datasheets, so we had to reverse engineer the functionality of the hardware, see &lt;a href=&#34;https://zeus.ugent.be/blog/23-24/open-source-esp32-wifi-mac/&#34;&gt;https://zeus.ugent.be/blog/23-24/open-source-esp32-wifi-mac/&lt;/a&gt; for how this was done. The goal is to have a Wi-Fi capable, blob-free SDK/firmware for the ESP32.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Currently, we can send and receive frames, without any proprietary code &lt;em&gt;running&lt;/em&gt; (proprietary code is still used to initialize the hardware in the begin, but is not needed anymore after that). The example code currently connects to a hardcoded open access point and transmits UDP packets to a hardcoded IP address.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Sending wifi frames&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Receiving wifi frames&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Send an ACK packet as reply to packets that are sent to the ESP32&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; intermediate goal: connect to an open access point &amp;amp; send UDP packets&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Switching channels&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Changing rate&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Adjusting TX power&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Hardware packet filtering based on MAC address (we previously used promiscuous mode to receive all packets, but this is a bit inefficient)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Implement wifi hardware initialization ourselves (this is now done using the functions in the proprietary blobs)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Connect our sending, receiving and other primitives to an open source 802.11 MAC implementation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Frequently asked questions&lt;/h2&gt; &#xA;&lt;h3&gt;What is the license of this project?&lt;/h3&gt; &#xA;&lt;p&gt;See the license/README.md in this repository&lt;/p&gt; &#xA;&lt;h3&gt;What is the goal of this project?&lt;/h3&gt; &#xA;&lt;p&gt;At the moment, developers that use the ESP32 are dependent on Espressif for features and bug fixes related to the Wi-Fi functionality. If the MAC layer were to be open sourced, we could fix bugs and implement features ourselves (as long as only a software change is needed). The ESP32 seems to have a SoftMAC architecture, so most of the Wi-Fi implementation is done in software, not in hardware. An open-source implementation also allows for easier security audits. The goal of this project is to document how the Wi-Fi hardware inside the ESP32 and related chips work, in order to make open-source implementations possible.&lt;/p&gt; &#xA;&lt;p&gt;My original goal was to have 802.11 standards compliant mesh networking (IEEE 802.11s) on the ESP32. Espressif has their own version of mesh networking, but their implementation has several technical drawbacks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;it&#39;s not compatible with other devices&lt;/li&gt; &#xA; &lt;li&gt;it forces a rather awkward tree topology, forcing the entire network to be rebuild if the root node goes down&lt;/li&gt; &#xA; &lt;li&gt;it uses NAT instead of layer 2 ethernet routing, so it&#39;s hard to reach nodes in the mesh network from outside of the mesh network&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;On what microcontrollers does this run?&lt;/h3&gt; &#xA;&lt;p&gt;At the moment, this only runs on the plain ESP32 (so not the ESP32-S2, ESP32-S3 or other variants). This is because the location and functionality of the Wi-Fi hardware peripherals is hardcoded. Porting this to other variants of the ESP32 might or might not be trivial, depending on how similar the internal hardware is.&lt;/p&gt; &#xA;&lt;p&gt;This project was only tested against ESP-IDF v5.0.1. After we implement the hardware initialisation ourselves, we won&#39;t have to use the proprietary esp32-wifi-lib anymore, and we&#39;ll be able to run on other ESP-IDF versions.&lt;/p&gt; &#xA;&lt;h3&gt;Can I contribute?&lt;/h3&gt; &#xA;&lt;p&gt;Yes! Please contact &lt;a href=&#34;mailto:zeusblog@devreker.be&#34;&gt;zeusblog@devreker.be&lt;/a&gt; to coordinate, so you don&#39;t waste your time trying to reverse engineer functionality someone else has already reverse engineered&lt;/p&gt; &#xA;&lt;h3&gt;Are there other works related to this?&lt;/h3&gt; &#xA;&lt;p&gt;Yes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First blog post talking about this: &lt;a href=&#34;https://zeus.ugent.be/blog/23-24/open-source-esp32-wifi-mac/&#34;&gt;https://zeus.ugent.be/blog/23-24/open-source-esp32-wifi-mac/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;ESP32 QEMU fork modified for reverse engineering: &lt;a href=&#34;https://github.com/esp32-open-mac/qemu&#34;&gt;https://github.com/esp32-open-mac/qemu&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Setting up JTAG debugging on the ESP32: &lt;a href=&#34;https://github.com/amirgon/ESP32-JTAG&#34;&gt;https://github.com/amirgon/ESP32-JTAG&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Espressifs wifi blobs: &lt;a href=&#34;https://github.com/espressif/esp32-wifi-lib&#34;&gt;https://github.com/espressif/esp32-wifi-lib&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;What will this project use as MAC layer?&lt;/h3&gt; &#xA;&lt;p&gt;How we&#39;ll implement the MAC layer (this does among others the association with access points) is still an open question. The only open source 802.11 MAC implementation I know is the one in the Linux kernel (mac80211), and I don&#39;t know how hard it will be to rip it out and combine it with FreeRTOS instead.&lt;/p&gt; &#xA;&lt;h3&gt;Some free ideas&lt;/h3&gt; &#xA;&lt;p&gt;Here are some idea&#39;s that are made easier by this project. I&#39;m probably not going to execute them.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fuzzing the proprietary Wi-Fi implementation to find security vulnerabilities, using the modifications in QEMU&lt;/li&gt; &#xA; &lt;li&gt;Turning the ESP32 into a USB SoftMAC Wi-Fi adapter (the ESP32-S2 has native USB, so this would be a lot nicer than the plain ESP32)&lt;/li&gt; &#xA; &lt;li&gt;Using a similar approach to reverse engineer and reimplement the Bluetooth functionality&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>raspberrypi/rpi-imager</title>
    <updated>2023-12-11T01:44:14Z</updated>
    <id>tag:github.com,2023-12-11:/raspberrypi/rpi-imager</id>
    <link href="https://github.com/raspberrypi/rpi-imager" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The home of Raspberry Pi Imager, a user-friendly tool for creating bootable media for Raspberry Pi devices.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rpi-imager&lt;/h1&gt; &#xA;&lt;p&gt;Raspberry Pi Imaging Utility&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the latest version for Windows, macOS and Ubuntu from the &lt;a href=&#34;https://www.raspberrypi.com/software/&#34;&gt;Raspberry Pi downloads page&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To install on Raspberry Pi OS, use &lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install rpi-imager&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to use Raspberry Pi Imager&lt;/h1&gt; &#xA;&lt;p&gt;Please see our &lt;a href=&#34;https://www.raspberrypi.com/documentation/computers/getting-started.html#raspberry-pi-imager&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The main code of the Imaging Utility is made available under the terms of the Apache license. See license.txt and files in &#34;src/dependencies&#34; folder for more information about the various open source licenses that apply to the third-party dependencies used such as Qt, libarchive, drivelist, mountutils and libcurl. For the embedded (netboot) build see also &#34;embedded/legal-info&#34; for more information about the extra system software included in that.&lt;/p&gt; &#xA;&lt;h2&gt;How to rebuild&lt;/h2&gt; &#xA;&lt;h3&gt;Debian/Ubuntu Linux&lt;/h3&gt; &#xA;&lt;h4&gt;Get dependencies&lt;/h4&gt; &#xA;&lt;p&gt;Install the build dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install --no-install-recommends build-essential devscripts debhelper cmake git libarchive-dev libcurl4-gnutls-dev liblzma-dev \&#xA;    qtbase5-dev qtbase5-dev-tools qtdeclarative5-dev libqt5svg5-dev qttools5-dev libgnutls28-dev \&#xA;    qml-module-qtquick2 qml-module-qtquick-controls2 qml-module-qtquick-layouts qml-module-qtquick-templates2 qml-module-qtquick-window2 qml-module-qtgraphicaleffects&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Get the source&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --depth 1 https://github.com/raspberrypi/rpi-imager&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Building on the Pi&lt;/h4&gt; &#xA;&lt;p&gt;If building on a device with limited memory (e.g. 1 GB Pi), disable parallel build or it may run out of memory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export DEB_BUILD_OPTIONS=&#34;parallel=1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Build the Debian package&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd rpi-imager&#xA;debuild -uc -us&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;debuild will compile everything, create a .deb package and put it in the parent directory. Can install it with apt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ..&#xA;sudo apt install ./rpi-imager*.deb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It should create an icon in the start menu under &#34;Utilities&#34; or &#34;Accessories&#34;. The imaging utility will normally be run as regular user, and will call udisks2 over DBus to perform privileged operations like opening the disk device for writing. If udisks2 is not functional on your Linux distribution, you can alternatively start it as &#34;root&#34; with sudo and similar tools.&lt;/p&gt; &#xA;&lt;h3&gt;Fedora/RHEL/CentOS Linux&lt;/h3&gt; &#xA;&lt;h4&gt;Get dependencies&lt;/h4&gt; &#xA;&lt;p&gt;Install the build dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo yum install git gcc gcc-c++ make cmake libarchive-devel libcurl-devel lzma-sdk-devel openssl-devel qt5-qtbase-devel qt5-qtquickcontrols2-devel qt5-qtsvg-devel qt5-linguist xz-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Get the source&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --depth 1 https://github.com/raspberrypi/rpi-imager&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Build and install the software&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd rpi-imager&#xA;mkdir -p build&#xA;cd build&#xA;cmake ../src&#xA;make&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;h4&gt;Get dependencies&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the Qt online installer from: &lt;a href=&#34;https://www.qt.io/download-open-source&#34;&gt;https://www.qt.io/download-open-source&lt;/a&gt; During installation, choose a Qt 5.x with Mingw32 32-bit toolchain and CMake.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If using the official Qt distribution that does NOT have schannel (Windows native SSL library) support, compile OpenSSL libraries ( &lt;a href=&#34;https://wiki.qt.io/Compiling_OpenSSL_with_MinGW&#34;&gt;https://wiki.qt.io/Compiling_OpenSSL_with_MinGW&lt;/a&gt; ) and copy the libssl/crypto DLLs to C:\qt\5.x\mingw73_32\bin the include files to C:\qt\5.x\mingw73_32\include and the import library files to C:\qt\5.x\mingw73_32\lib&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For building installer get Nullsoft scriptable install system: &lt;a href=&#34;https://nsis.sourceforge.io/Download&#34;&gt;https://nsis.sourceforge.io/Download&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It is assumed you already have a proper code signing certificate, and signtool.exe from the Windows SDK installed. If NOT and are you only compiling for your own personal use, comment out all lines mentioning signtool from CMakelists.txt and the .nsi installer script.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Building&lt;/h4&gt; &#xA;&lt;p&gt;Building can be done manually using the command-line, using &#34;cmake&#34;, &#34;make&#34;, etc., but if you are not that familar with setting up a proper Windows build environment (setting paths, etc.), it is easiest to use the Qt creator GUI instead.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download source .zip from github and extract it to a folder on disk&lt;/li&gt; &#xA; &lt;li&gt;Open src/CMakeLists.txt in Qt creator.&lt;/li&gt; &#xA; &lt;li&gt;For builds you distribute to others, make sure you choose &#34;Release&#34; in the toolchain settings and not the debug flavour.&lt;/li&gt; &#xA; &lt;li&gt;Menu &#34;Build&#34; -&amp;gt; &#34;Build all&#34;&lt;/li&gt; &#xA; &lt;li&gt;Result will be in build_rpi-imager_someversion&lt;/li&gt; &#xA; &lt;li&gt;Go to the BUILD folder, right click on the .nsi script &#34;Compile NSIS script&#34;, to create installer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: the CMake integration in Qt Creator is a bit flaky at times. If you made any custom changes to the CMakeLists.txt file and it subsequently gets in an endless loop where it never finishes the &#34;configures&#34; stage while re-processing the file, delete &#34;build_rpi-imager_someversion&#34; directory and try again.&lt;/p&gt; &#xA;&lt;h3&gt;macOS&lt;/h3&gt; &#xA;&lt;h4&gt;Get dependencies&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get the Qt online installer from: &lt;a href=&#34;https://www.qt.io/download-open-source&#34;&gt;https://www.qt.io/download-open-source&lt;/a&gt; During installation, choose a Qt 5.x edition and CMake.&lt;/li&gt; &#xA; &lt;li&gt;For creating a .DMG for distribution you can use an utility like: &lt;a href=&#34;https://github.com/sindresorhus/create-dmg&#34;&gt;https://github.com/sindresorhus/create-dmg&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;It is assumed you have an Apple developer subscription, and already have a &#34;Developer ID&#34; code signing certificate for distribution outside the Mac Store. (Privileged apps are not allowed in the Mac store)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Building&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download source .zip from github and extract it to a folder on disk&lt;/li&gt; &#xA; &lt;li&gt;Start Qt Creator (may need to start &#34;finder&#34; navigate to home folder using the &#34;Go&#34; menu, and find Qt folder to start it manually as it may not have created icon in Applications), and open src/CMakeLists.txt&lt;/li&gt; &#xA; &lt;li&gt;Menu &#34;Build&#34; -&amp;gt; &#34;Build all&#34;&lt;/li&gt; &#xA; &lt;li&gt;Result will be in build_rpi-imager_someversion&lt;/li&gt; &#xA; &lt;li&gt;For distribution to others: code sign the .app, create a DMG, code sign the DMG, submit it for notarization to Apple and staple the notarization ticket to the DMG.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;E.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd build-rpi-imager-Desktop_Qt_5_14_1_clang_64bit-Release/&#xA;codesign --deep --force --verify --verbose --sign &#34;YOUR KEYID&#34; --options runtime rpi-imager.app&#xA;mv rpi-imager.app &#34;Raspberry Pi Imager.app&#34;&#xA;create-dmg Raspberry\ Pi\ Imager.app&#xA;mv Raspberry\ Pi\ Imager\ .dmg imager.dmg&#xA;xcrun altool --notarize-app -t osx -f imager.dmg --primary-bundle-id=&#34;org.raspberrypi.imagingutility&#34; -u YOUR-EMAIL-ADDRESS -p YOUR-APP-SPECIFIC-APPLE-PASSWORD -itc_provider TEAM-ID-IF-APPLICABLE&#xA;xcrun stapler staple imager.dmg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Linux embedded (netboot) build&lt;/h3&gt; &#xA;&lt;p&gt;The embedded build runs under a minimalistic Linux distribution compiled by buildroot. To build:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You must be running a Linux system, and have the buildroot dependencies installed as listed in the buildroot manual: &lt;a href=&#34;https://buildroot.org/downloads/manual/manual.html#requirement&#34;&gt;https://buildroot.org/downloads/manual/manual.html#requirement&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd rpi-imager/embedded&#xA;./build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result will be in the &#34;output&#34; directory. The files can be copied to a FAT32 formatted SD card, and inserted in a Pi for testing. If you would like to build a (signed) netboot image there are tools for that at: &lt;a href=&#34;https://github.com/raspberrypi/usbboot/tree/master/tools&#34;&gt;https://github.com/raspberrypi/usbboot/tree/master/tools&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Other notes&lt;/h2&gt; &#xA;&lt;h3&gt;Debugging&lt;/h3&gt; &#xA;&lt;p&gt;On Linux and Mac the application will print debug messages to console by default if started from console. On Windows start the application with the command-line option --debug to let it open a console window.&lt;/p&gt; &#xA;&lt;h3&gt;Custom repository&lt;/h3&gt; &#xA;&lt;p&gt;If the application is started with &#34;--repo [your own URL]&#34; it will use a custom image repository. So can simply create another &#39;start menu shortcut&#39; to the application with that parameter to use the application with your own images.&lt;/p&gt; &#xA;&lt;h3&gt;Telemetry&lt;/h3&gt; &#xA;&lt;p&gt;In order to understand usage of the application (e.g. uptake of Raspberry Pi Imager versions and which images and operating systems are most popular) when using the default image repository, the URL, operating system name and category (if present) of a selected image are sent along with the running version of Raspberry Pi Imager, your operating system, CPU architecture, locale and Raspberry Pi revision (if applicable) to &lt;a href=&#34;https://rpi-imager-stats.raspberrypi.com&#34;&gt;https://rpi-imager-stats.raspberrypi.com&lt;/a&gt; by downloadstatstelemetry.cpp.&lt;/p&gt; &#xA;&lt;p&gt;This web service is hosted by &lt;a href=&#34;https://www.heroku.com&#34;&gt;Heroku&lt;/a&gt; and only stores an incrementing counter using a &lt;a href=&#34;https://redis.io/topics/data-types#sorted-sets&#34;&gt;Redis Sorted Set&lt;/a&gt; for each URL, operating system name and category per day in the &lt;code&gt;eu-west-1&lt;/code&gt; region and does not associate any personal data with those counts. This allows us to query the number of downloads over time and nothing else.&lt;/p&gt; &#xA;&lt;p&gt;The last 1,500 requests to the service are logged for one week before expiring as this is the &lt;a href=&#34;https://devcenter.heroku.com/articles/logging#log-history-limits&#34;&gt;minimum log retention period for Heroku&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On Windows, you can opt out of telemetry by disabling it in the Registry:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;reg add &#34;HKCU\Software\Raspberry Pi\Imager&#34; /v telemetry /t REG_DWORD /d 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Linux, run &lt;code&gt;rpi-imager --disable-telemetry&lt;/code&gt; or add the following to &lt;code&gt;~/.config/Raspberry Pi/Imager.conf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[General]&#xA;telemetry=false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On macOS, disable it by editing the property list for the application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;defaults write org.raspberrypi.Imager.plist telemetry -bool NO&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OS Customization&lt;/h3&gt; &#xA;&lt;p&gt;When using the app, press &lt;kbd&gt;CTRL&lt;/kbd&gt; + &lt;kbd&gt;SHIFT&lt;/kbd&gt; + &lt;kbd&gt;X&lt;/kbd&gt; to reveal the &lt;strong&gt;OS Customization&lt;/strong&gt; dialog.&lt;/p&gt; &#xA;&lt;p&gt;In here, you can specify several things you would otherwise set in the boot configuration files. For example, you can enable SSH, set the Wi-Fi login, and specify your locale settings for the system image.&lt;/p&gt;</summary>
  </entry>
</feed>