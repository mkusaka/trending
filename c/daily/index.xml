<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-12T01:26:10Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tidwall/neco</title>
    <updated>2024-04-12T01:26:10Z</updated>
    <id>tag:github.com,2024-04-12:/tidwall/neco</id>
    <link href="https://github.com/tidwall/neco" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Concurrency library for C (coroutines)&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;docs/assets/logo-dark.png&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;docs/assets/logo-light.png&#34;&gt; &#xA;  &lt;img alt=&#34;Neco&#34; src=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/assets/logo-light.png&#34; width=&#34;260&#34;&gt; &#xA; &lt;/picture&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/api-reference-blue.svg?style=flat-square&#34; alt=&#34;API Reference&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Neco is a C library that provides concurrency using coroutines. It&#39;s small &amp;amp; fast, and intended to make concurrent I/O &amp;amp; network programming easy.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#basic-operations&#34;&gt;Coroutines&lt;/a&gt;: starting, sleeping, suspending, resuming, yielding, and joining.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#channels&#34;&gt;Synchronization&lt;/a&gt;: channels, generators, mutexes, condition variables, and waitgroups.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#deadlines-and-cancelation&#34;&gt;deadlines and cancelation&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#posix-wrappers&#34;&gt;Posix friendly&lt;/a&gt; interface using file descriptors.&lt;/li&gt; &#xA; &lt;li&gt;Addtional APIs for &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#networking-utilities&#34;&gt;networking&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#signals&#34;&gt;signals&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#random-number-generator&#34;&gt;random data&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#streams-and-buffered-io&#34;&gt;streams&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#streams-and-buffered-io&#34;&gt;buffered I/O&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Lightweight runtime with a fair and deterministic &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/#the-scheduler&#34;&gt;scheduler&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/#fast-context-switching&#34;&gt;Fast&lt;/a&gt; user-space context switching. Uses assembly in most cases.&lt;/li&gt; &#xA; &lt;li&gt;Stackful coroutines that are nestable, with their life times fully managed by the scheduler.&lt;/li&gt; &#xA; &lt;li&gt;Cross-platform. Linux, Mac, FreeBSD. &lt;em&gt;(Also WebAssembly and Windows with &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/#platform-notes&#34;&gt;some limitations&lt;/a&gt;)&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Single file amalgamation. No dependencies.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/tests/README.md&#34;&gt;Test suite&lt;/a&gt; with 100% coverage using sanitizers and &lt;a href=&#34;https://valgrind.org&#34;&gt;Valgrind&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For a deeper dive, check out the &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md&#34;&gt;API reference&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It may also be worthwhile to see the &lt;a href=&#34;https://github.com/tidwall/bluebox&#34;&gt;Bluebox&lt;/a&gt; project for a more complete example of using Neco, including benchmarks.&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Give C programs fast single-threaded concurrency.&lt;/li&gt; &#xA; &lt;li&gt;To use a concurrency model that resembles the simplicity of pthreads or Go.&lt;/li&gt; &#xA; &lt;li&gt;Provide an API for concurrent networking and I/O.&lt;/li&gt; &#xA; &lt;li&gt;Make it easy to interop with existing Posix functions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It&#39;s a non-goal for Neco to provide a scalable multithreaded runtime, where the coroutine scheduler is shared among multiple cpu cores. Or to use other concurrency models like async/await.&lt;/p&gt; &#xA;&lt;h2&gt;Using&lt;/h2&gt; &#xA;&lt;p&gt;Just drop the &#34;neco.c&#34; and &#34;neco.h&#34; files into your project. Uses standard C11 so most modern C compilers should work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cc -c neco.c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 1 (Start a coroutine)&lt;/h2&gt; &#xA;&lt;p&gt;A coroutine is started with the &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#neco_start&#34;&gt;&lt;code&gt;neco_start()&lt;/code&gt;&lt;/a&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;neco_start()&lt;/code&gt; is called for the first time it will initialize a Neco runtime and scheduler for the current thread, and then blocks until the coroutine and all child coroutines have terminated.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void coroutine(int argc, void *argv[]) {&#xA;    printf(&#34;main coroutine started\n&#34;);&#xA;}&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;    neco_start(coroutine, 0);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 2 (Use neco_main instead of main)&lt;/h2&gt; &#xA;&lt;p&gt;Optionally, &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#neco_main&#34;&gt;&lt;code&gt;neco_main()&lt;/code&gt;&lt;/a&gt; can be used in place of the standard &lt;code&gt;main()&lt;/code&gt;. This is for when the entirety of your program is intended to be run from only coroutines. It &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#neco_main&#34;&gt;adjusts the behavior&lt;/a&gt; of the program slightly to make development and error checking easier.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    printf(&#34;main coroutine started\n&#34;);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 3 (Multiple coroutines)&lt;/h2&gt; &#xA;&lt;p&gt;Here we&#39;ll start two coroutines that continuously prints &#34;tick&#34; every one second and &#34;tock&#34; every two.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void ticker(int argc, void *argv[]) {&#xA;    while (1) {&#xA;        neco_sleep(NECO_SECOND);&#xA;        printf(&#34;tick\n&#34;);&#xA;    }&#xA;}&#xA;&#xA;void tocker(int argc, void *argv[]) {&#xA;    while (1) {&#xA;        neco_sleep(NECO_SECOND*2);&#xA;        printf(&#34;tock\n&#34;);&#xA;    }&#xA;}&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    neco_start(ticker, 0);&#xA;    neco_start(tocker, 0);&#xA;    &#xA;    // Keep the program alive for an hour.&#xA;    neco_sleep(NECO_HOUR);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 4 (Coroutine arguments)&lt;/h2&gt; &#xA;&lt;p&gt;A coroutine is like its own little program that accepts any number of arguments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void coroutine(int argc, void *argv[])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arguments are a series of pointers passed to the coroutine. All arguments are guaranteed to be in scope when the coroutine starts and until the first &lt;code&gt;neco_&lt;/code&gt; function is called. This allows you an opportunity to validate and/or copy them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;assert.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void coroutine(int argc, void *argv[]) {&#xA;&#xA;    // All arguments are currently in scope and should be copied before first&#xA;    // neco_*() function is called in this coroutine.&#xA;&#xA;    int arg0 = *(int*)argv[0];&#xA;    int arg1 = *(int*)argv[1];&#xA;    int arg2 = *(int*)argv[2];&#xA;    char *arg3 = argv[3];&#xA;    char *arg4 = argv[4];&#xA;&#xA;    printf(&#34;arg0=%d, arg1=%d, arg2=%d, arg3=%s, arg4=%s\n&#34;, &#xA;        arg0, arg1, arg2, arg3, arg4);&#xA;&#xA;    neco_sleep(NECO_SECOND/2);&#xA;&#xA;    // The arguments are no longer in scope and it&#39;s unsafe to use the argv&#xA;    // variable any further.&#xA;&#xA;    printf(&#34;second done\n&#34;);&#xA;    &#xA;}&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;&#xA;    int arg0 = 0;&#xA;    int *arg1 = malloc(sizeof(int));&#xA;    *arg1 = 1;&#xA;&#xA;    neco_start(coroutine, 5, &amp;amp;arg0, arg1, &amp;amp;(int){2}, NULL, &#34;hello world&#34;);&#xA;    free(arg2);&#xA;&#xA;    neco_sleep(NECO_SECOND);&#xA;    printf(&#34;first done\n&#34;);&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 5 (Channels)&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#channels&#34;&gt;channel&lt;/a&gt; is a mechanism for communicating between two or more coroutines.&lt;/p&gt; &#xA;&lt;p&gt;Here we&#39;ll create a second coroutine that sends the message &#39;ping&#39; to the first coroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void coroutine(int argc, void *argv[]) {&#xA;    neco_chan *messages = argv[0];&#xA;    &#xA;    // Send a message of the &#39;messages&#39; channel. &#xA;    char *msg = &#34;ping&#34;;&#xA;    neco_chan_send(messages, &amp;amp;msg);&#xA;&#xA;    // This coroutine no longer needs the channel.&#xA;    neco_chan_release(messages);&#xA;}&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;&#xA;    // Create a new channel that is used to send &#39;char*&#39; string messages.&#xA;    neco_chan *messages;&#xA;    neco_chan_make(&amp;amp;messages, sizeof(char*), 0);&#xA;&#xA;    // Start a coroutine that sends messages over the channel. &#xA;    // It&#39;s a good idea to use neco_chan_retain on a channel before using it&#xA;    // in a new coroutine. This will avoid potential use-after-free bugs.&#xA;    neco_chan_retain(messages);&#xA;    neco_start(coroutine, 1, messages);&#xA;&#xA;    // Receive the next incoming message. Here weâ€™ll receive the &#34;ping&#34;&#xA;    // message we sent above and print it out.&#xA;    char *msg = NULL;&#xA;    neco_chan_recv(messages, &amp;amp;msg);&#xA;    printf(&#34;%s\n&#34;, msg);&#xA;    &#xA;    // This coroutine no longer needs the channel.&#xA;    neco_chan_release(messages);&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 6 (Generators)&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#generators&#34;&gt;generator&lt;/a&gt; is like channel but is stricly bound to a coroutine and is intended to treat the coroutine like an iterator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void coroutine(int argc, void *argv[]) {&#xA;    // Yield each int to the caller, one at a time.&#xA;    for (int i = 0; i &amp;lt; 10; i++) {&#xA;        neco_gen_yield(&amp;amp;i);&#xA;    }&#xA;}&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    &#xA;    // Create a new generator coroutine that is used to send ints.&#xA;    neco_gen *gen;&#xA;    neco_gen_start(&amp;amp;gen, sizeof(int), coroutine, 0);&#xA;&#xA;    // Iterate over each int until the generator is closed.&#xA;    int i;&#xA;    while (neco_gen_next(gen, &amp;amp;i) != NECO_CLOSED) {&#xA;        printf(&#34;%d\n&#34;, i); &#xA;    }&#xA;&#xA;    // This coroutine no longer needs the generator.&#xA;    neco_gen_release(gen);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 7 (Connect to server)&lt;/h2&gt; &#xA;&lt;p&gt;Neco provides &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#neco_dial&#34;&gt;&lt;code&gt;neco_dial()&lt;/code&gt;&lt;/a&gt; for easily connecting to server.&lt;/p&gt; &#xA;&lt;p&gt;Here we&#39;ll performing a (very simple) HTTP request which prints the homepage of the &lt;a href=&#34;http://example.com&#34;&gt;http://example.com&lt;/a&gt; website.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    int fd = neco_dial(&#34;tcp&#34;, &#34;example.com:80&#34;);&#xA;    if (fd &amp;lt; 0) {&#xA;        printf(&#34;neco_dial: %s\n&#34;, neco_strerror(fd));&#xA;        return 0;&#xA;    }&#xA;    char req[] = &#34;GET / HTTP/1.1\r\n&#34;&#xA;                 &#34;Host: example.com\r\n&#34;&#xA;                 &#34;Connection: close\r\n&#34;&#xA;                 &#34;\r\n&#34;;&#xA;    neco_write(fd, req, sizeof(req));&#xA;    while (1) {&#xA;        char buf[256];&#xA;        int n = neco_read(fd, buf, sizeof(buf));&#xA;        if (n &amp;lt;= 0) {&#xA;            break;&#xA;        }&#xA;        printf(&#34;%.*s&#34;, n, buf);&#xA;    }&#xA;    close(fd);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 8 (Create a server)&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md&#34;&gt;&lt;code&gt;neco_serve()&lt;/code&gt;&lt;/a&gt; to quickly bind and listen on an address.&lt;/p&gt; &#xA;&lt;p&gt;Here we&#39;ll run a tiny webserver at &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;../neco.h&#34;&#xA;&#xA;void request(int argc, void *argv[]) {&#xA;    int fd = *(int*)argv[0];&#xA;    char req[256];&#xA;    int n = neco_read(fd, req, sizeof(req));&#xA;    if (n &amp;gt; 0) {&#xA;        char res[] = &#34;HTTP/1.0 200 OK\r\n&#34;&#xA;                     &#34;Content-Type: text/html\r\n&#34;&#xA;                     &#34;Content-Length: 21\r\n&#34;&#xA;                     &#34;\r\n&#34;&#xA;                     &#34;&amp;lt;h1&amp;gt;Hello Neco!&amp;lt;/h1&amp;gt;\n&#34;;&#xA;        neco_write(fd, res, sizeof(res));&#xA;    }&#xA;    close(fd);&#xA;}&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    int servfd = neco_serve(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;);&#xA;    if (servfd &amp;lt; 0) {&#xA;        printf(&#34;neco_serve: %s\n&#34;, neco_strerror(servfd));&#xA;        return 0;&#xA;    }&#xA;    printf(&#34;Serving at http://127.0.0.1:8080\n&#34;);&#xA;    while (1) {&#xA;        int fd = neco_accept(servfd, 0, 0);&#xA;        if (servfd &amp;lt; 0) {&#xA;            printf(&#34;neco_accept: %s\n&#34;, neco_strerror(fd));&#xA;            continue;&#xA;        }&#xA;        neco_start(request, 1, &amp;amp;fd);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 9 (Echo server and client)&lt;/h2&gt; &#xA;&lt;p&gt;Run server with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cc neco.c echo-server.c &amp;amp;&amp;amp; ./a.out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run client with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cc neco.c echo-client.c &amp;amp;&amp;amp; ./a.out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;echo-server.c&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void client(int argc, void *argv[]) {&#xA;    int conn = *(int*)argv[0];&#xA;    printf(&#34;client connected\n&#34;);&#xA;    char buf[64];&#xA;    while (1) {&#xA;        ssize_t n = neco_read(conn, buf, sizeof(buf));&#xA;        if (n &amp;lt;= 0) {&#xA;            break;&#xA;        }&#xA;        printf(&#34;%.*s&#34;, (int)n, buf);&#xA;    }&#xA;    printf(&#34;client disconnected\n&#34;);&#xA;    close(conn);&#xA;}&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    int ln = neco_serve(&#34;tcp&#34;, &#34;localhost:19203&#34;);&#xA;    if (ln == -1) {&#xA;        perror(&#34;neco_serve&#34;);&#xA;        exit(1);&#xA;    }&#xA;    printf(&#34;listening at localhost:19203\n&#34;);&#xA;    while (1) {&#xA;        int conn = neco_accept(ln, 0, 0);&#xA;        if (conn &amp;gt; 0) {&#xA;            neco_start(client, 1, &amp;amp;conn);&#xA;        }&#xA;    }&#xA;    close(ln);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;echo-client.c&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    int fd = neco_dial(&#34;tcp&#34;, &#34;localhost:19203&#34;);&#xA;    if (fd == -1) {&#xA;        perror(&#34;neco_listen&#34;);&#xA;        exit(1);&#xA;    }&#xA;    printf(&#34;connected\n&#34;);&#xA;    char buf[64];&#xA;    while (1) {&#xA;        printf(&#34;&amp;gt; &#34;);&#xA;        fflush(stdout);&#xA;        ssize_t nbytes = neco_read(STDIN_FILENO, buf, sizeof(buf));&#xA;        if (nbytes &amp;lt; 0) {&#xA;            break;&#xA;        }&#xA;        ssize_t ret = neco_write(fd, buf, nbytes);&#xA;        if (ret &amp;lt; 0) {&#xA;            break;&#xA;        }&#xA;    }&#xA;    printf(&#34;disconnected\n&#34;);&#xA;    close(fd);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example 10 (Suspending and resuming a coroutine)&lt;/h2&gt; &#xA;&lt;p&gt;Any coroutines can suspended itself indefinetly and then be resumed by other coroutines by using &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#neco_suspend&#34;&gt;&lt;code&gt;neco_suspend()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/docs/API.md#neco_resume&#34;&gt;&lt;code&gt;neco_resume()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void coroutine(int argc, void *argv[]) {&#xA;    printf(&#34;Suspending coroutine\n&#34;);&#xA;    neco_suspend();&#xA;    printf(&#34;Coroutine resumed\n&#34;);&#xA;}&#xA;&#xA;int neco_main(int argc, char *argv[]) {&#xA;    neco_start(coroutine, 0);&#xA;    &#xA;    for (int i = 0; i &amp;lt; 3; i++) {&#xA;        printf(&#34;%d\n&#34;, i+1);&#xA;        neco_sleep(NECO_SECOND);&#xA;    }&#xA;&#xA;    // Resume the suspended. The neco_lastid() returns the identifier for the&#xA;    // last coroutine started by the current coroutine.&#xA;    neco_resume(neco_lastid());&#xA;    return 0;&#xA;}&#xA;// Output:&#xA;// Suspending coroutine&#xA;// 1&#xA;// 2&#xA;// 3&#xA;// Coroutine resumed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;More examples&lt;/h3&gt; &#xA;&lt;p&gt;You can find more &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/examples&#34;&gt;examples here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Platform notes&lt;/h2&gt; &#xA;&lt;p&gt;Linux, Mac, and FreeBSD supports all features.&lt;/p&gt; &#xA;&lt;p&gt;Windows and WebAssembly support the core coroutine features, but have some key limitiations, mostly with working with file descriptors and networking. This is primarly because the Neco event queue works with epoll and kqueue, which are only available on Linux and Mac/BSD respectively. This means that the &lt;code&gt;neco_wait()&lt;/code&gt; (which allows for a coroutine to wait for a file descriptor to be readable or writeable) is not currently available on those platforms.&lt;/p&gt; &#xA;&lt;p&gt;Other limitations include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows only supports amd64.&lt;/li&gt; &#xA; &lt;li&gt;Windows and WebAssembly use smaller default stacks of 1MB.&lt;/li&gt; &#xA; &lt;li&gt;Windows and WebAssembly do not support guards or gaps.&lt;/li&gt; &#xA; &lt;li&gt;Windows and WebAssembly do not support NECO_CSPRNG (Cryptographically secure pseudorandom number generator)&lt;/li&gt; &#xA; &lt;li&gt;Windows does not support stack unwinding.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other than that, Neco works great on those platforms.&lt;/p&gt; &#xA;&lt;p&gt;Any contributions towards making Windows and WebAssembly feature complete are welcome.&lt;/p&gt; &#xA;&lt;h2&gt;The scheduler&lt;/h2&gt; &#xA;&lt;p&gt;Neco uses &lt;a href=&#34;https://github.com/tidwall/sco&#34;&gt;sco&lt;/a&gt;, which is a fair and deterministic scheduler. This means that no coroutine takes priority over another and that all concurrent operations will reproduce in an expected order.&lt;/p&gt; &#xA;&lt;h3&gt;Fast context switching&lt;/h3&gt; &#xA;&lt;p&gt;The coroutine context switching is powered by &lt;a href=&#34;https://github.com/tidwall/llco&#34;&gt;llco&lt;/a&gt; and uses assembly code in most cases. On my lab machine (AMD Ryzen 9 5950X) a context switch takes about 11 nanoseconds.&lt;/p&gt; &#xA;&lt;h3&gt;Thread local runtime&lt;/h3&gt; &#xA;&lt;p&gt;There can be no more than one scheduler per thread.&lt;/p&gt; &#xA;&lt;p&gt;When the first coroutine is started using &lt;code&gt;neco_start()&lt;/code&gt;, a new Neco runtime is initialized in the current thread, and each runtime has its own scheduler.&lt;/p&gt; &#xA;&lt;p&gt;Communicating between coroutines that are running in different threads will require I/O mechanisms that do not block the current schedulers, such as &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;eventfd()&lt;/code&gt; or atomics.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Pthread utilties such as &lt;code&gt;pthread_mutex_t&lt;/code&gt; and &lt;code&gt;pthread_cond_t&lt;/code&gt; do not work very well in coroutines.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;For example, here we&#39;ll create two threads, running their own Neco schedulers. Each using pipes to communicate with the other.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &amp;lt;pthread.h&amp;gt;&#xA;#include &#34;neco.h&#34;&#xA;&#xA;void coro1(int argc, void *argv[]) {&#xA;    // This coroutine is running in a different scheduler than coro2.&#xA;    int rd = *(int*)argv[0];&#xA;    int wr = *(int*)argv[1];&#xA;    int val;&#xA;    neco_read(rd, &amp;amp;val, sizeof(int));&#xA;    printf(&#34;coro1: %d\n&#34;, val);&#xA;    neco_write(wr, &amp;amp;(int){ 2 }, sizeof(int));&#xA;}&#xA;&#xA;void coro2(int argc, void *argv[]) {&#xA;    // This coroutine is running in a different scheduler than coro1.&#xA;    int rd = *(int*)argv[0];&#xA;    int wr = *(int*)argv[1];&#xA;    int val;&#xA;    neco_write(wr, &amp;amp;(int){ 1 }, sizeof(int));&#xA;    neco_read(rd, &amp;amp;val, sizeof(int));&#xA;    printf(&#34;coro2: %d\n&#34;, val);&#xA;}&#xA;&#xA;void *runtime1(void *arg) {&#xA;    int *pipefds = arg;&#xA;    neco_start(coro1, 2, &amp;amp;pipefds[0], &amp;amp;pipefds[3]);&#xA;    return 0;&#xA;}&#xA;&#xA;void *runtime2(void *arg) {&#xA;    int *pipefds = arg;&#xA;    neco_start(coro2, 2, &amp;amp;pipefds[2], &amp;amp;pipefds[1]);&#xA;    return 0;&#xA;}&#xA;&#xA;int main() {&#xA;    int pipefds[4];&#xA;    pipe(&amp;amp;pipefds[0]);&#xA;    pipe(&amp;amp;pipefds[2]);&#xA;    pthread_t th1, th2;&#xA;    pthread_create(&amp;amp;th1, 0, runtime1, pipefds);&#xA;    pthread_create(&amp;amp;th2, 0, runtime2, pipefds);&#xA;    pthread_join(th1, 0);&#xA;    pthread_join(th2, 0);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Source code is available under the MIT &lt;a href=&#34;https://raw.githubusercontent.com/tidwall/neco/main/LICENSE&#34;&gt;License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>