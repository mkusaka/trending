<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-15T02:42:16Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>janet-lang/janet</title>
    <updated>2023-04-15T02:42:16Z</updated>
    <id>tag:github.com,2023-04-15:/janet-lang/janet</id>
    <link href="https://github.com/janet-lang/janet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A dynamic language and bytecode vm&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://gitter.im/janet-language/community&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/janet-language/community.svg?sanitize=true&#34; alt=&#34;Join the chat&#34;&gt;&lt;/a&gt; &amp;nbsp; &lt;a href=&#34;https://builds.sr.ht/~bakpakin/janet/commits/master/freebsd.yml?&#34;&gt;&lt;img src=&#34;https://builds.sr.ht/~bakpakin/janet/commits/master/freebsd.yml.svg?sanitize=true&#34; alt=&#34;builds.sr.ht status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://builds.sr.ht/~bakpakin/janet/commits/master/openbsd.yml?&#34;&gt;&lt;img src=&#34;https://builds.sr.ht/~bakpakin/janet/commits/master/openbsd.yml.svg?sanitize=true&#34; alt=&#34;builds.sr.ht status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/janet-lang/janet/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/janet-lang/janet/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Actions Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/janet-lang/janet/master/assets/janet-w200.png&#34; alt=&#34;Janet logo&#34; width=&#34;200&#34; align=&#34;left&#34;&gt; &#xA;&lt;p&gt;&lt;strong&gt;Janet&lt;/strong&gt; is a functional and imperative programming language and bytecode interpreter. It is a lisp-like language, but lists are replaced by other data structures (arrays, tables (hash table), struct (immutable hash table), tuples). The language also supports bridging to native code written in C, meta-programming with macros, and bytecode assembly.&lt;/p&gt; &#xA;&lt;p&gt;There is a REPL for trying out the language, as well as the ability to run script files. This client program is separate from the core runtime, so Janet can be embedded in other programs. Try Janet in your browser at &lt;a href=&#34;https://janet-lang.org&#34;&gt;https://janet-lang.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to financially support the ongoing development of Janet, consider &lt;a href=&#34;https://github.com/sponsors/bakpakin&#34;&gt;sponsoring its primary author&lt;/a&gt; through GitHub.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Use Cases&lt;/h2&gt; &#xA;&lt;p&gt;Janet makes a good system scripting language, or a language to embed in other programs. It&#39;s like Lua and Guile in that regard. It has more built-in functionality and a richer core language than Lua, but smaller than GNU Guile or Python.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configurable at build time - turn features on or off for a smaller or more featureful build&lt;/li&gt; &#xA; &lt;li&gt;Minimal setup - one binary and you are good to go!&lt;/li&gt; &#xA; &lt;li&gt;First-class closures&lt;/li&gt; &#xA; &lt;li&gt;Garbage collection&lt;/li&gt; &#xA; &lt;li&gt;First-class green threads (continuations)&lt;/li&gt; &#xA; &lt;li&gt;Python-style generators (implemented as a plain macro)&lt;/li&gt; &#xA; &lt;li&gt;Mutable and immutable arrays (array/tuple)&lt;/li&gt; &#xA; &lt;li&gt;Mutable and immutable hashtables (table/struct)&lt;/li&gt; &#xA; &lt;li&gt;Mutable and immutable strings (buffer/string)&lt;/li&gt; &#xA; &lt;li&gt;Macros&lt;/li&gt; &#xA; &lt;li&gt;Multithreading&lt;/li&gt; &#xA; &lt;li&gt;Per-thread event loop for efficient evented IO&lt;/li&gt; &#xA; &lt;li&gt;Byte code interpreter with an assembly interface, as well as bytecode verification&lt;/li&gt; &#xA; &lt;li&gt;Tail call Optimization&lt;/li&gt; &#xA; &lt;li&gt;Direct interop with C via abstract types and C functions&lt;/li&gt; &#xA; &lt;li&gt;Dynamically load C libraries&lt;/li&gt; &#xA; &lt;li&gt;Functional and imperative standard library&lt;/li&gt; &#xA; &lt;li&gt;Lexical scoping&lt;/li&gt; &#xA; &lt;li&gt;Imperative programming as well as functional&lt;/li&gt; &#xA; &lt;li&gt;REPL&lt;/li&gt; &#xA; &lt;li&gt;Parsing Expression Grammars built into the core library&lt;/li&gt; &#xA; &lt;li&gt;400+ functions and macros in the core library&lt;/li&gt; &#xA; &lt;li&gt;Embedding Janet in other programs&lt;/li&gt; &#xA; &lt;li&gt;Interactive environment with detailed stack traces&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For a quick tutorial, see &lt;a href=&#34;https://janet-lang.org/docs/index.html&#34;&gt;the introduction&lt;/a&gt; for more details.&lt;/li&gt; &#xA; &lt;li&gt;For the full API for all functions in the core library, see &lt;a href=&#34;https://janet-lang.org/api/index.html&#34;&gt;the core API doc&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Documentation is also available locally in the REPL. Use the &lt;code&gt;(doc symbol-name)&lt;/code&gt; macro to get API documentation for symbols in the core library. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(doc apply)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Shows documentation for the &lt;code&gt;apply&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;To get a list of all bindings in the default environment, use the &lt;code&gt;(all-bindings)&lt;/code&gt; function. You can also use the &lt;code&gt;(doc)&lt;/code&gt; macro with no arguments if you are in the REPL to show bound symbols.&lt;/p&gt; &#xA;&lt;h2&gt;Source&lt;/h2&gt; &#xA;&lt;p&gt;You can get the source on &lt;a href=&#34;https://github.com/janet-lang/janet&#34;&gt;GitHub&lt;/a&gt; or &lt;a href=&#34;https://git.sr.ht/~bakpakin/janet&#34;&gt;SourceHut&lt;/a&gt;. While the GitHub repo is the official repo, the SourceHut mirror is actively maintained.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;macOS and Unix-like&lt;/h3&gt; &#xA;&lt;p&gt;The Makefile is non-portable and requires GNU-flavored make.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd somewhere/my/projects/janet&#xA;make&#xA;make test&#xA;make repl&#xA;make install&#xA;make install-jpm-git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Find out more about the available make targets by running &lt;code&gt;make help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;32-bit Haiku&lt;/h3&gt; &#xA;&lt;p&gt;32-bit Haiku build instructions are the same as the UNIX-like build instructions, but you need to specify an alternative compiler, such as &lt;code&gt;gcc-x86&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd somewhere/my/projects/janet&#xA;make CC=gcc-x86&#xA;make test&#xA;make repl&#xA;make install&#xA;make install-jpm-git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FreeBSD&lt;/h3&gt; &#xA;&lt;p&gt;FreeBSD build instructions are the same as the UNIX-like build instructions, but you need &lt;code&gt;gmake&lt;/code&gt; to compile. Alternatively, install directly from packages, using &lt;code&gt;pkg install lang/janet&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd somewhere/my/projects/janet&#xA;gmake&#xA;gmake test&#xA;gmake repl&#xA;gmake install&#xA;gmake install-jpm-git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NetBSD&lt;/h3&gt; &#xA;&lt;p&gt;NetBSD build instructions are the same as the FreeBSD build instructions. Alternatively, install directly from packages, using &lt;code&gt;pkgin install janet&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community&amp;amp;rel=15#&#34;&gt;Visual Studio&lt;/a&gt; or &lt;a href=&#34;https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&amp;amp;rel=15#&#34;&gt;Visual Studio Build Tools&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run a Visual Studio Command Prompt (cl.exe and link.exe need to be on the PATH) and cd to the directory with janet.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;build_win&lt;/code&gt; to compile janet.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;build_win test&lt;/code&gt; to make sure everything is working.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To build an &lt;code&gt;.msi&lt;/code&gt; installer executable, in addition to the above steps, you will have to:&lt;/p&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;Install, or otherwise add to your PATH the &lt;a href=&#34;https://github.com/wixtoolset/wix3/releases&#34;&gt;WiX 3.11 Toolset&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;run &lt;code&gt;build_win dist&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Now you should have an &lt;code&gt;.msi&lt;/code&gt;. You can run &lt;code&gt;build_win install&lt;/code&gt; to install the &lt;code&gt;.msi&lt;/code&gt;, or execute the file itself.&lt;/p&gt; &#xA;&lt;h3&gt;Meson&lt;/h3&gt; &#xA;&lt;p&gt;Janet also has a build file for &lt;a href=&#34;https://mesonbuild.com/&#34;&gt;Meson&lt;/a&gt;, a cross-platform build system. Although Meson has a Python dependency, Meson is a very complete build system that is maybe more convenient and flexible for integrating into existing pipelines. Meson also provides much better IDE integration than Make or batch files, as well as support for cross-compilation.&lt;/p&gt; &#xA;&lt;p&gt;For the impatient, building with Meson is as follows. The options provided to &lt;code&gt;meson setup&lt;/code&gt; below emulate Janet&#39;s Makefile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/janet-lang/janet.git&#xA;cd janet&#xA;meson setup build \&#xA;          --buildtype release \&#xA;          --optimization 2 \&#xA;          --libdir /usr/local/lib \&#xA;          -Dgit_hash=$(git log --pretty=format:&#39;%h&#39; -n 1)&#xA;ninja -C build&#xA;&#xA;# Run the binary&#xA;build/janet&#xA;&#xA;# Installation&#xA;ninja -C build install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Janet can be hacked on with pretty much any environment you like, but for IDE lovers, &lt;a href=&#34;https://wiki.gnome.org/Apps/Builder&#34;&gt;Gnome Builder&lt;/a&gt; is probably the best option, as it has excellent meson integration. It also offers code completion for Janet&#39;s C API right out of the box, which is very useful for exploring. VSCode, Vim, Emacs, and Atom will have syntax packages for the Janet language, though.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://janet-lang.org/docs/index.html&#34;&gt;Introduction&lt;/a&gt; for more details. If you just want to try out the language, you don&#39;t need to install anything. You can also move the &lt;code&gt;janet&lt;/code&gt; executable wherever you want on your system and run it.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;A REPL is launched when the binary is invoked with no arguments. Pass the -h flag to display the usage information. Individual scripts can be run with &lt;code&gt;./janet myscript.janet&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you are looking to explore, you can print a list of all available macros, functions, and constants by entering the command &lt;code&gt;(all-bindings)&lt;/code&gt; into the REPL.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ janet&#xA;Janet 1.7.1-dev-951e10f  Copyright (C) 2017-2020 Calvin Rose&#xA;janet:1:&amp;gt; (+ 1 2 3)&#xA;6&#xA;janet:2:&amp;gt; (print &#34;Hello, World!&#34;)&#xA;Hello, World!&#xA;nil&#xA;janet:3:&amp;gt; (os/exit)&#xA;$ janet -h&#xA;usage: build/janet [options] script args...&#xA;Options are:&#xA;  -h : Show this help&#xA;  -v : Print the version string&#xA;  -s : Use raw stdin instead of getline like functionality&#xA;  -e code : Execute a string of janet&#xA;  -r : Enter the REPL after running all scripts&#xA;  -p : Keep on executing if there is a top-level error (persistent)&#xA;  -q : Hide prompt, logo, and REPL output (quiet)&#xA;  -k : Compile scripts but do not execute (flycheck)&#xA;  -m syspath : Set system path for loading global modules&#xA;  -c source output : Compile janet source code into an image&#xA;  -n : Disable ANSI color output in the REPL&#xA;  -l path : Execute code in a file before running the main script&#xA;  -- : Stop handling options&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If installed, you can also run &lt;code&gt;man janet&lt;/code&gt; to get usage information.&lt;/p&gt; &#xA;&lt;h2&gt;Embedding&lt;/h2&gt; &#xA;&lt;p&gt;Janet can be embedded in a host program very easily. The normal build will create a file &lt;code&gt;build/janet.c&lt;/code&gt;, which is a single C file that contains all the source to Janet. This file, along with &lt;code&gt;src/include/janet.h&lt;/code&gt; and &lt;code&gt;src/conf/janetconf.h&lt;/code&gt; can be dragged into any C project and compiled into the project. Janet should be compiled with &lt;code&gt;-std=c99&lt;/code&gt; on most compilers, and will need to be linked to the math library, &lt;code&gt;-lm&lt;/code&gt;, and the dynamic linker, &lt;code&gt;-ldl&lt;/code&gt;, if one wants to be able to load dynamic modules. If there is no need for dynamic modules, add the define &lt;code&gt;-DJANET_NO_DYNAMIC_MODULES&lt;/code&gt; to the compiler options.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://janet-lang.org/capi/embedding.html&#34;&gt;Embedding Section&lt;/a&gt; on the website for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;See the examples directory for some example janet code.&lt;/p&gt; &#xA;&lt;h2&gt;Discussion&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to ask questions and join the discussion on the &lt;a href=&#34;https://gitter.im/janet-language/community&#34;&gt;Janet Gitter Channel&lt;/a&gt;. Gitter provides Matrix and irc bridges as well.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Where is (favorite feature from other language)?&lt;/h3&gt; &#xA;&lt;p&gt;It may exist, it may not. If you want to propose major language features, go ahead and open an issue, but they will likely by closed as &#34;will not implement&#34;. Often, such features make one usecase simpler at the expense of 5 others by making the language more complicated.&lt;/p&gt; &#xA;&lt;h3&gt;Is there a language spec?&lt;/h3&gt; &#xA;&lt;p&gt;There is not currently a spec besides the documentation at &lt;a href=&#34;https://janet-lang.org&#34;&gt;https://janet-lang.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Is this Scheme/Common Lisp? Where are the cons cells?&lt;/h3&gt; &#xA;&lt;p&gt;Nope. There are no cons cells here.&lt;/p&gt; &#xA;&lt;h3&gt;Is this a Clojure port?&lt;/h3&gt; &#xA;&lt;p&gt;No. It&#39;s similar to Clojure superficially because I like Lisps and I like the aesthetics. Internally, Janet is not at all like Clojure.&lt;/p&gt; &#xA;&lt;h3&gt;Are the immutable data structures (tuples and structs) implemented as hash tries?&lt;/h3&gt; &#xA;&lt;p&gt;No. They are immutable arrays and hash tables. Don&#39;t try and use them like Clojure&#39;s vectors and maps, instead they work well as table keys or other identifiers.&lt;/p&gt; &#xA;&lt;h3&gt;Can I do Object Oriented programming with Janet?&lt;/h3&gt; &#xA;&lt;p&gt;To some extent, yes. However, it is not the recommended method of abstraction, and performance may suffer. That said, tables can be used to make mutable objects with inheritance and polymorphism, where object methods are implemeted with keywords.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(def Car @{:honk (fn [self msg] (print &#34;car &#34; self &#34; goes &#34; msg)) })&#xA;(def my-car (table/setproto @{} Car))&#xA;(:honk my-car &#34;Beep!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Why can&#39;t we add (feature from Clojure) into the core?&lt;/h3&gt; &#xA;&lt;p&gt;Usually, one of a few reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Often, it already exists in a different form and the Clojure port would be redundant.&lt;/li&gt; &#xA; &lt;li&gt;Clojure programs often generate a lot of garbage and rely on the JVM to clean it up. Janet does not run on the JVM, and has a more primitive garbage collector.&lt;/li&gt; &#xA; &lt;li&gt;We want to keep the Janet core small. With Lisps, usually a feature can be added as a library without feeling &#34;bolted on&#34;, especially when compared to ALGOL like languages. Adding features to the core also makes it a bit more difficult to keep Janet maximally portable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Why is my terminal spitting out junk when I run the REPL?&lt;/h3&gt; &#xA;&lt;p&gt;Make sure your terminal supports ANSI escape codes. Most modern terminals will support these, but some older terminals, Windows consoles, or embedded terminals will not. If your terminal does not support ANSI escape codes, run the REPL with the &lt;code&gt;-n&lt;/code&gt; flag, which disables color output. You can also try the &lt;code&gt;-s&lt;/code&gt; if further issues ensue.&lt;/p&gt; &#xA;&lt;h2&gt;Why is it called &#34;Janet&#34;?&lt;/h2&gt; &#xA;&lt;p&gt;Janet is named after the almost omniscient and friendly artificial being in &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Good_Place&#34;&gt;The Good Place&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>