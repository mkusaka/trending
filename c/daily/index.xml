<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-26T01:25:42Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>linux-nvme/nvme-cli</title>
    <updated>2024-01-26T01:25:42Z</updated>
    <id>tag:github.com,2024-01-26:/linux-nvme/nvme-cli</id>
    <link href="https://github.com/linux-nvme/nvme-cli" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NVMe management command line interface.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nvme-cli&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://scan.coverity.com/projects/24883/badge.svg?sanitize=true&#34; alt=&#34;Coverity Scan Build Status&#34;&gt; &lt;img src=&#34;https://github.com/linux-nvme/nvme-cli/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;MesonBuild&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/linux-nvme/nvme-cli&#34; alt=&#34;GitHub&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;NVM-Express user space tooling for Linux.&lt;/p&gt; &#xA;&lt;h2&gt;Build from source&lt;/h2&gt; &#xA;&lt;p&gt;nvme-cli uses meson as build system. There is more than one way to configure and build the project in order to mitigate meson dependency on the build environment.&lt;/p&gt; &#xA;&lt;p&gt;If you build on a relative modern system, either use meson directly or the Makefile wrapper.&lt;/p&gt; &#xA;&lt;p&gt;Older distros might ship a too old version of meson, in this case it&#39;s possible to build the project using &lt;a href=&#34;https://github.com/michaelforney/samurai&#34;&gt;samurai&lt;/a&gt; and &lt;a href=&#34;https://github.com/annacrombie/muon&#34;&gt;muon&lt;/a&gt;. Both build tools have only a minimal dependency on the build environment. Too easy this step there is a build script which helps to setup a build environment.&lt;/p&gt; &#xA;&lt;h3&gt;nvme-cli dependencies:&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;Dependency&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;libnvme, libnvme-mi&lt;/td&gt; &#xA;   &lt;td&gt;yes&lt;/td&gt; &#xA;   &lt;td&gt;be either installed or included into the build via meson fallback feature&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;json-c&lt;/td&gt; &#xA;   &lt;td&gt;optional&lt;/td&gt; &#xA;   &lt;td&gt;recommended, without all plugins are disabled and json-c output format is disabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Build with meson&lt;/h3&gt; &#xA;&lt;h4&gt;Configuring&lt;/h4&gt; &#xA;&lt;p&gt;In case libnvme is not installed on the system, it possible to use meson&#39;s fallback feature to resolve the dependency.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ meson setup --force-fallback-for=libnvme .build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the libnvme is already installed on the system meson is using pkg-config to find the dependency. In this case a plain setup call is enough:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ meson setup .build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With meson&#39;s --wrap-mode argument it&#39;s possible to control if the additional dependencies should also resolved or not. The options are&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--wrap-mode {default,nofallback,nodownload,forcefallback,nopromote}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note for nvme-cli the &#39;default&#39; is set to nofallback.&lt;/p&gt; &#xA;&lt;h4&gt;Building&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ meson compile -C .build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Installing&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# meson install -C .build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build with build.sh wrapper&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;scripts/build.sh&lt;/code&gt; is used for the CI build but can also be used for configuring and building the project.&lt;/p&gt; &#xA;&lt;p&gt;Running &lt;code&gt;scripts/build.sh&lt;/code&gt; without any argument builds the project in the default configuration (meson, gcc and defaults)&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s possible to change the compiler to clang&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;scripts/builds.sh -c clang&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;or enabling all the fallbacks&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;scripts/build.sh fallback&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Minimal static build with muon&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;scripts/build.sh -m muon&lt;/code&gt; will download and build &lt;code&gt;samurai&lt;/code&gt; and &lt;code&gt;muon&lt;/code&gt; instead using &lt;code&gt;meson&lt;/code&gt; to build the project. This reduces the dependency on the build environment to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;gcc&lt;/li&gt; &#xA; &lt;li&gt;make&lt;/li&gt; &#xA; &lt;li&gt;git&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Furthermore, this configuration will produce a static binary.&lt;/p&gt; &#xA;&lt;h3&gt;Build with Makefile wrapper&lt;/h3&gt; &#xA;&lt;p&gt;There is a Makefile wrapper for meson for backwards compatibility&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make&#xA;# make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note in this case libnvme needs to be installed by hand first.&lt;/p&gt; &#xA;&lt;p&gt;RPM build support via Makefile that uses meson&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make rpm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Static binary(no dependency) build support via Makefile that uses meson&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make static&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If not sure how to use, find the top-level documentation with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ man nvme&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or find a short summary with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nvme help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Distro Support&lt;/h2&gt; &#xA;&lt;p&gt;Many popular distributions (Alpine, Arch, Debian, Fedora, FreeBSD, Gentoo, Ubuntu, Nix(OS), openSUSE, ...) and the usual package name is nvme-cli.&lt;/p&gt; &#xA;&lt;h4&gt;OpenEmbedded/Yocto&lt;/h4&gt; &#xA;&lt;p&gt;An &lt;a href=&#34;https://layers.openembedded.org/layerindex/recipe/88631/&#34;&gt;nvme-cli recipe&lt;/a&gt; is available as part of the &lt;code&gt;meta-openembeded&lt;/code&gt; layer collection.&lt;/p&gt; &#xA;&lt;h4&gt;Buildroot&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;nvme-cli&lt;/code&gt; is available as &lt;a href=&#34;https://buildroot.org&#34;&gt;buildroot&lt;/a&gt; package. The package is named &lt;code&gt;nvme&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Developers&lt;/h2&gt; &#xA;&lt;p&gt;You may wish to add a new command or possibly an entirely new plug-in for some special extension outside the spec.&lt;/p&gt; &#xA;&lt;p&gt;This project provides macros that help generate the code for you. If you&#39;re interested in how that works, it is very similar to how trace events are created by Linux kernel&#39;s &#39;ftrace&#39; component.&lt;/p&gt; &#xA;&lt;h3&gt;Add command to existing built-in&lt;/h3&gt; &#xA;&lt;p&gt;The first thing to do is define a new command entry in the command list. This is declared in nvme-builtin.h. Simply append a new &#34;ENTRY&#34; into the list. The ENTRY normally takes three arguments: the &#34;name&#34; of the subcommand (this is what the user will type at the command line to invoke your command), a short help description of what your command does, and the name of the function callback that you&#39;re going to write. Additionally, You can declare an alias name of subcommand with fourth argument, if needed.&lt;/p&gt; &#xA;&lt;p&gt;After the ENTRY is defined, you need to implement the callback. It takes four arguments: argc, argv, the command structure associated with the callback, and the plug-in structure that contains that command. The prototype looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int f(int argc, char **argv, struct command *cmd, struct plugin *plugin);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The argc and argv are adjusted from the command line arguments to start after the sub-command. So if the command line is &#34;nvme foo --option=bar&#34;, the argc is 1 and argv starts at &#34;--option&#34;.&lt;/p&gt; &#xA;&lt;p&gt;You can then define argument parsing for your sub-command&#39;s specific options then do some command specific action in your callback.&lt;/p&gt; &#xA;&lt;h3&gt;Add a new plugin&lt;/h3&gt; &#xA;&lt;p&gt;The nvme-cli provides macros to make define a new plug-in simpler. You can certainly do all this by hand if you want, but it should be easier to get going using the macros. To start, first create a header file to define your plugin. This is where you will give your plugin a name, description, and define all the sub-commands your plugin implements.&lt;/p&gt; &#xA;&lt;p&gt;There is a very important order on how to define the plugin. The following is a basic example on how to start this:&lt;/p&gt; &#xA;&lt;p&gt;File: foo-plugin.h&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#undef CMD_INC_FILE&#xA;#define CMD_INC_FILE plugins/foo/foo-plugin&#xA;&#xA;#if !defined(FOO) || defined(CMD_HEADER_MULTI_READ)&#xA;#define FOO&#xA;&#xA;#include &#34;cmd.h&#34;&#xA;&#xA;PLUGIN(NAME(&#34;foo&#34;, &#34;Foo plugin&#34;),&#xA;&#x9;COMMAND_LIST(&#xA;&#x9;&#x9;ENTRY(&#34;bar&#34;, &#34;foo bar&#34;, bar)&#xA;&#x9;&#x9;ENTRY(&#34;baz&#34;, &#34;foo baz&#34;, baz)&#xA;&#x9;&#x9;ENTRY(&#34;qux&#34;, &#34;foo quz&#34;, qux)&#xA;&#x9;)&#xA;);&#xA;&#xA;#endif&#xA;&#xA;#include &#34;define_cmd.h&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to have the compiler generate the plugin through the xmacro expansion, you need to include this header in your source file, with pre-defining macro directive to create the commands.&lt;/p&gt; &#xA;&lt;p&gt;To get started from the above example, we just need to define &#34;CREATE_CMD&#34; and include the header:&lt;/p&gt; &#xA;&lt;p&gt;File: foo-plugin.c&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;nvme.h&#34;&#xA;&#xA;#define CREATE_CMD&#xA;#include &#34;foo-plugin.h&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that, you just need to implement the functions you defined in each ENTRY, then append the object file name to the meson.build &#34;sources&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;meson tips&lt;/h2&gt; &#xA;&lt;p&gt;In case meson doesn&#39;t find libnvme header files (via pkg-config) it will fallback using subprojects. meson checks out libnvme in subprojects directory as git tree once to the commit level specified in the libnvme.wrap file revision parm. After this initial checkout, the libnvme code level will not change unless explicitly told. That means if the current branch is updated via git, the subprojects/libnvme branch will not updated accordingly. To update it, either use the normal git operations or the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ meson subprojects update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dependency&lt;/h2&gt; &#xA;&lt;p&gt;libnvme depends on the /sys/class/nvme-subsystem interface which was introduced in the Linux kernel release v4.15. Hence nvme-cli 2.x is only working on kernels &amp;gt;= v4.15. For older kernels nvme-cli 1.x is recommended to be used.&lt;/p&gt; &#xA;&lt;h2&gt;How to contribute&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways to send code changes to the project. The first one is by sending the changes to &lt;a href=&#34;mailto:linux-nvme@lists.infradead.org&#34;&gt;linux-nvme@lists.infradead.org&lt;/a&gt;. The second one is by posting a pull request on github. In both cases please follow the Linux contributions guidelines as documented in&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.kernel.org/process/submitting-patches.html#&#34;&gt;https://docs.kernel.org/process/submitting-patches.html#&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;That means the changes should be a clean series (no merges should be present in a github PR for example) and every commit should build.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://opensource.com/article/19/7/create-pull-request-github&#34;&gt;https://opensource.com/article/19/7/create-pull-request-github&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;How to cleanup your series before creating PR&lt;/h3&gt; &#xA;&lt;p&gt;This example here assumes, the changes are in a branch called fix-something, which branched away from master in the past. In the meantime the upstream project has changed, hence the fix-something branch is not based on the current HEAD. Before posting the PR, the branch should be rebased on the current HEAD and retest everything.&lt;/p&gt; &#xA;&lt;p&gt;For example rebasing can be done by following steps&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Update master branch&#xA;#   upstream == https://github.com/linux-nvme/nvme-cli.git&#xA;$ git switch master&#xA;$ git fetch --all&#xA;$ git reset --hard upstream/master&#xA;&#xA;# Make sure all dependencies are up to date and make a sanity build&#xA;$ meson subprojects update&#xA;$ ninja -C .build&#xA;&#xA;# Go back to the fix-something branch&#xA;$ git switch fix-something&#xA;&#xA;# Rebase it to the current HEAD&#xA;$ git rebase master&#xA;[fixup all merge conflicts]&#xA;[retest]&#xA;&#xA;# Push your changes to github and trigger a PR&#xA;$ git push -u origin fix-something&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Persistent, volatile configuration&lt;/h2&gt; &#xA;&lt;p&gt;Persistent configurations can be stored in two different locations: either in the file &lt;code&gt;/etc/nvme/discovery.conf&lt;/code&gt; using the old style, or in the file &lt;code&gt;/etc/nvme/config.json&lt;/code&gt; using the new style.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, volatile configurations, such as those obtained from third-party tools like &lt;code&gt;nvme-stats&lt;/code&gt; or &lt;code&gt;blktests&#39;&lt;/code&gt; can be stored in the &lt;code&gt;/run/nvme&lt;/code&gt; directory. When using the &lt;code&gt;nvme-cli&lt;/code&gt; tool, all these configurations are combined into a single configuration that is used as input.&lt;/p&gt; &#xA;&lt;p&gt;The volatile configuration is particularly useful for coordinating access to the global resources among various components. For example, when executing &lt;code&gt;blktests&lt;/code&gt; for the FC transport, the &lt;code&gt;nvme-cli&lt;/code&gt; udev rules can be triggered. To prevent interference with a test, &lt;code&gt;blktests&lt;/code&gt; can create a JSON configuration file in &lt;code&gt;/run/nvme&lt;/code&gt; to inform &lt;code&gt;nvme-cli&lt;/code&gt; that it should not perform any actions triggered from the udev context. This behavior can be controlled using the &lt;code&gt;--context&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;p&gt;For example a &lt;code&gt;blktests&lt;/code&gt; volatile configuration could look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  {&#xA;    &#34;hostnqn&#34;: &#34;nqn.2014-08.org.nvmexpress:uuid:242d4a24-2484-4a80-8234-d0169409c5e8&#34;,&#xA;    &#34;hostid&#34;: &#34;242d4a24-2484-4a80-8234-d0169409c5e8&#34;,&#xA;    &#34;subsystems&#34;: [&#xA;      {&#xA;&#x9;&#34;application&#34;: &#34;blktests&#34;,&#xA;        &#34;nqn&#34;: &#34;blktests-subsystem-1&#34;,&#xA;        &#34;ports&#34;: [&#xA;          {&#xA;            &#34;transport&#34;: &#34;fc&#34;,&#xA;&#x9;    &#34;traddr&#34;: &#34;nn-0x10001100aa000001:pn-0x20001100aa000001&#34;,&#xA;&#x9;    &#34;host_traddr&#34;: &#34;nn-0x10001100aa000002:pn-0x20001100aa000002&#34;&#xA;          }&#xA;        ]&#xA;      }&#xA;    ]&#xA;  }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note when updating the volatile configuration during runtime, it should done in a an atomic way. For example create a temporary file without the &lt;code&gt;.json&lt;/code&gt; file extension in &lt;code&gt;/run/nvme&lt;/code&gt; and write the contents to this file. When finished use &lt;code&gt;rename&lt;/code&gt; to add the &lt;code&gt;&#39;.json&#39;&lt;/code&gt; file name extension. This ensures nvme-cli only sees the complete file.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;For testing purposes a x86_64 AppImage is build from the current HEAD and is available here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://monom.org/linux-nvme/upload/AppImage/nvme-cli-latest-x86_64.AppImage&#34;&gt;https://monom.org/linux-nvme/upload/AppImage/nvme-cli-latest-x86_64.AppImage&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>P001water/yuze</title>
    <updated>2024-01-26T01:25:42Z</updated>
    <id>tag:github.com,2024-01-26:/P001water/yuze</id>
    <link href="https://github.com/P001water/yuze" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A socksv5 proxy tool Written by CLang. 一款纯C实现的基于socks5协议的轻量内网穿透工具，支持ew的全部数据转发方式&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;README&lt;/h1&gt; &#xA;&lt;h1&gt;yuze🤗&lt;/h1&gt; &#xA;&lt;h2&gt;简介&lt;/h2&gt; &#xA;&lt;p&gt;yuze 是一款纯C实现的轻量的内网穿透工具，支持正向，反向socksv5代理隧道的搭建，支持EarthWorm (ew) 的全部数据转发方式。&lt;/p&gt; &#xA;&lt;p&gt;目前仅支持Windows平台，更多平台很快完善中......&lt;/p&gt; &#xA;&lt;h2&gt;使用简介&lt;/h2&gt; &#xA;&lt;p&gt;为方便本地测试, 以下主机皆为127.0.0.1本地环回地址&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;普通网络环境：&#xA;    1.  (正向代理) 可控主机有公网IP且可开启任意监听端口：&#xA;&#xA;              +---------+     +-------------------+  &#xA;              |HackTools| -&amp;gt;&amp;gt; | 7878 -&amp;gt;  Host_One |&#xA;              +---------+     +-------------------+&#xA;&#xA;        a) ./yuze -m s_server -l 7878&#xA;&#xA;        b) HackTools可使用Host_One主机的7878端口提供的socks5代理&#xA;            &#xA;    2.  (反向代理) 可控主机不存在公网IP，但是可出网，通过主动连接的方式建立反向socks代理。&#xA;    类似frp&#xA;            &#xA;                                    一台可控公网IP主机                  可控内网主机&#xA;              +---------+     +--------------------------+    |     +---------------+&#xA;              |HackTools| -&amp;gt;&amp;gt; | 7878 -&amp;gt;  Host_One -&amp;gt; 9999 |  防火墙  | &amp;lt;--  Host_Two  |&#xA;              +---------+     +--------------------------+    |     +---------------+&#xA;&#xA;        a) ./yuze -m yuze_listen -s 7878 -e 9999&#xA;                    // 在具有公网IP的主机上添加转接隧道，将7878端口收到的代理请求转交给反连9999端口的主机&#xA;                    &#xA;        b) ./yuze -m r_server -r 127.0.0.1 -s 9999        &#xA;                    // 将目标主机反向连接公网转接主机&#xA;&#xA;        c) HackTools可使用Host_One主机的7878端口提供的socks5代理&#xA;        &#xA;对于二重网络环境：        &#xA;    1.  获得目标网络内两台主机 A、B 的权限，情况描述如下：&#xA;    &#xA;            A 主机：  存在公网 IP，且自由监听任意端口，无法访问特定资源&#xA;            B 主机：  目标网络内部主机，可访问特定资源，但无法访问公网&#xA;            A 主机可直连 B 主机&#xA;                &#xA;                                    可控边界主机A             可访问指定资源的主机B&#xA;              +---------+     +-----------------------+      +-----------------+&#xA;              |HackTools| -&amp;gt;&amp;gt; | 7878 --&amp;gt;  Host_One --&amp;gt; | -&amp;gt;&amp;gt;  | 9999 -&amp;gt; Host_Two |&#xA;              +---------+     +-----------------------+      +-----------------+&#xA;    &#xA;        a)  ./yuze -m s_server -l 9999&#xA;                // 在 Host_Two 主机上利用 s_server 模式启动 9999 端口的正向 socks 代理&#xA;                &#xA;        b)  ./yuze -m yuze_tran -s 7878 -d 127.0.0.1 -e 9999 &#xA;                // 在Host_One上将 7878 端口收到的 socks 代理请求转交给 Host_Two 主机。&#xA;                &#xA;        c)  HackTools可使用Host_One主机的7878端口提供的socks5代理&#xA;        &#xA;    2.  获得目标网络内两台主机 A、B 的权限，情况描述如下：&#xA;    &#xA;            A 主机：  目标网络的边界主机，无公网 IP，无法访问特定资源。&#xA;            B 主机：  目标网络内部主机，可访问特定资源，却无法回连公网。&#xA;            A 主机可直连 B 主机&#xA;&#xA;&#x9;      一台可控公网IP主机                    可控内网主机A         可访问指定资源的主机B&#xA;+---------+     +--------------------------+    |    +-----------------+      +-----------------+&#xA;|HackTools| -&amp;gt;&amp;gt; | 7878 -&amp;gt; Host_One -&amp;gt; 8888 |  防火墙  | &amp;lt;--  Host_Two --&amp;gt; | -&amp;gt;&amp;gt; | 9999 -&amp;gt; Host_Three |&#xA;+---------+     +--------------------------+    |    +-----------------+      +-----------------+&#xA;&#xA;        a)  ./yuze -m yuze_listen -s 7878 -e 8888&#xA;                    // 在 Host_One 公网主机添加转接隧道，将 7878 收到的代理请求&#xA;                    // 转交给反连 8888 端口的主机&#xA;                    &#xA;        b)  ./yuze -m s_server -l 9999&#xA;                    // 在 Host_Three 主机上利用 s_server 模式启动 9999 端口的正向 socks 代理&#xA;                    &#xA;        c)  ./yuze -m yuze_slave -r 127.0.0.1 -s 8888 -d 127.0.0.1 -e 9999&#xA;                    // 在 Host_Two 上，通过工具的 yuze_slave 模式，&#xA;                    // 打通Host_One:8888 和 Host_Three:9999 之间的通讯隧道&#xA;                    &#xA;        d)  HackTools可使用Host_One主机的7878端口提供的socks5代理&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;演示 （正向代理）&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/P001water/yuze/master/img/show.gif&#34; alt=&#34;show&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;跨平台支持 (很快完成)&lt;/li&gt; &#xA; &lt;li&gt;通信流量加密&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;闲谈&lt;/h1&gt; &#xA;&lt;p&gt;yuze是我学习socket网络编程后产出的工具，它帮助我深入了解了内网渗透中常见的隧道代理，流量转发的原理。最初用go语言实现了正向、反向代理，由于体积问题，改用纯C实现。它的很多的灵感来自于逆向 EarthWorm，像前辈致敬。感谢编写ew的readme.txt的师傅.&lt;/p&gt; &#xA;&lt;p&gt;如果遇见实际情况解决不了的场景，欢迎PR提供问题或思路&lt;/p&gt;</summary>
  </entry>
</feed>