<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-28T01:33:45Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xorvoid/sectorc</title>
    <updated>2023-05-28T01:33:45Z</updated>
    <id>tag:github.com,2023-05-28:/xorvoid/sectorc</id>
    <link href="https://github.com/xorvoid/sectorc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A C Compiler that fits in the 512 byte boot sector of an x86 machine&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SectorC&lt;/h1&gt; &#xA;&lt;p&gt;SectorC is a C compiler written in x86-16 assembly that fits within the 512 byte boot sector of an x86 machine. It supports a subset of C that is large enough to write real and interesting programs. It is quite likely the smallest C compiler ever written.&lt;/p&gt; &#xA;&lt;p&gt;In a base64 encoding, it looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;6gUAwAdoADAfaAAgBzH/6DABPfQYdQXoJQHr8+gjAVOJP+gSALDDqluB+9lQdeAG/zdoAEAfy+gI&#xA;AegFAYnYg/hNdFuE9nQNsOiqiwcp+IPoAqvr4j3/FXUG6OUAquvXPVgYdQXoJgDrGj0C2nUGV+gb&#xA;AOsF6CgA68Ow6apYKfiD6AKrifgp8CaJRP7rrOg4ALiFwKu4D4Srq1fonP9ewz2N/HUV6JoA6BkA&#xA;ieu4iQRQuIs26IAAWKvD6AcAieu4iQbrc4nd6HkA6HYA6DgAHg4fvq8Bra052HQGhcB19h/DrVCw&#xA;UKroWQDoGwC4WZGrW4D/wHUMuDnIq7i4AKu4AA+ridirH8M9jfx1COgzALiLBOucg/j4dQXorf/r&#xA;JIP49nUI6BwAuI0G6wyE0nQFsLiq6wa4iwarAduJ2KvrA+gAAOhLADwgfvkx2zHJPDkPnsI8IH4S&#xA;weEIiMFr2wqD6DABw+gqAOvqicg9Ly90Dj0qL3QSPSkoD5TGidjD6BAAPAp1+eu86Ln/g/jDdfjr&#xA;slIx9osEMQQ8O3QUuAACMdLNFIDkgHX0PDt1BIkEMcBaw/v/A8H9/yvB+v/34fb/I8FMAAvBLgAz&#xA;wYQA0+CaANP4jwCUwHf/lcAMAJzADgCfwIUAnsCZAJ3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAVao=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Supported language&lt;/h2&gt; &#xA;&lt;p&gt;A fairly large subset is supported: global variables, functions, if statements, while statements, lots of operators, pointer dereference, inline machine-code, comments, etc. All of these features make it quite capable.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following program animates a moving sine-wave:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;int y;&#xA;int x;&#xA;int x_0;&#xA;void sin_positive_approx()&#xA;{&#xA;  y = ( x_0 * ( 157 - x_0 ) ) &amp;gt;&amp;gt; 7;&#xA;}&#xA;void sin()&#xA;{&#xA;  x_0 = x;&#xA;  while( x_0 &amp;gt; 314 ){&#xA;    x_0 = x_0 - 314;&#xA;  }&#xA;  if( x_0 &amp;lt;= 157 ){&#xA;    sin_positive_approx();&#xA;  }&#xA;  if( x_0 &amp;gt; 157 ){&#xA;    x_0 = x_0 - 157;&#xA;    sin_positive_approx();&#xA;    y = 0 - y;&#xA;  }&#xA;  y = 100 + y;&#xA;}&#xA;&#xA;&#xA;int offset;&#xA;int x_end;&#xA;void draw_sine_wave()&#xA;{&#xA;  x = offset;&#xA;  x_end = x + 314;&#xA;  while( x &amp;lt;= x_end ){&#xA;    sin();&#xA;    pixel_x = x - offset;&#xA;    pixel_y = y;&#xA;    vga_set_pixel();&#xA;    x = x + 1;&#xA;  }&#xA;}&#xA;&#xA;int v_1;&#xA;int v_2;&#xA;void delay()&#xA;{&#xA;  v_1 = 0;&#xA;  while( v_1 &amp;lt; 50 ){&#xA;    v_2 = 0;&#xA;    while( v_2 &amp;lt; 10000 ){&#xA;      v_2 = v_2 + 1;&#xA;    }&#xA;    v_1 = v_1 + 1;&#xA;  }&#xA;}&#xA;&#xA;void main()&#xA;{&#xA;  vga_init();&#xA;&#xA;  offset = 0;&#xA;  while( 1 ){&#xA;    vga_clear();&#xA;    draw_sine_wave();&#xA;&#xA;    delay();&#xA;    offset = offset + 1;&#xA;    if( offset &amp;gt;= 314 ){ // mod the value to avoid 2^16 integer overflow&#xA;      offset = offset - 314;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Screenshot&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xorvoid/sectorc/main/img/sinwave.png&#34; alt=&#34;Moving Sinwave&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Provided Example Code&lt;/h2&gt; &#xA;&lt;p&gt;A few examples are provided that leverage the unique hardware aspects of the x86-16 IBM PC:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;examples/hello.c:&lt;/code&gt; Print a text greeting on the screen writing to memory at 0xB8000&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;examples/sinwave.c:&lt;/code&gt; Draw a moving sine wave animation with VGA Mode 0x13 using an appropriately bad approximation of sin(x)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;examples/twinkle.c:&lt;/code&gt; Play “Twinkle Twinkle Little Star” through the PC Speaker (Warning: LOUD)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Grammar&lt;/h2&gt; &#xA;&lt;p&gt;The following grammar is accepted and compiled by sectorc:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;program     = (var_decl | func_decl)+&#xA;var_decl    = &#34;int&#34; identifier &#34;;&#34;&#xA;func_decl   = &#34;void&#34; func_name &#34;{&#34; statement* &#34;}&#34;&#xA;func_name   = &amp;lt;identifier that ends in &#34;()&#34; with no space&amp;gt;&#xA;statement   = &#34;if(&#34; expr &#34;){&#34; statement* &#34;}&#34;&#xA;            | &#34;while(&#34; expr &#34;){&#34; statement* &#34;}&#34;&#xA;            | &#34;asm&#34; integer &#34;;&#34;&#xA;            | func_name &#34;;&#34;&#xA;            | assign_expr &#34;;&#34;&#xA;assign_expr = deref? identifier &#34;=&#34; expr&#xA;deref       = &#34;*(int*)&#34;&#xA;expr        = unary (op unary)?&#xA;unary       = deref identifier&#xA;            | &#34;&amp;amp;&#34; identifier&#xA;            | &#34;(&#34; expr &#34;)&#34;&#xA;            | indentifier&#xA;            | integer&#xA;op          = &#34;+&#34; | &#34;-&#34; | &#34;&amp;amp;&#34; | &#34;|&#34; | &#34;^&#34; | &#34;&amp;lt;&amp;lt;&#34; | &#34;&amp;gt;&amp;gt;&#34;&#xA;            | &#34;==&#34; | &#34;!=&#34; | &#34;&amp;lt;&#34; | &#34;&amp;gt;&#34; | &#34;&amp;lt;=&#34; | &#34;&amp;gt;=&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, both &lt;code&gt;// comment&lt;/code&gt; and &lt;code&gt;/* multi-line comment */&lt;/code&gt; styles are supported.&lt;/p&gt; &#xA;&lt;p&gt;(NOTE: This grammar is 704 bytes in ascii, 38% larger than it&#39;s implementation!)&lt;/p&gt; &#xA;&lt;h2&gt;How?&lt;/h2&gt; &#xA;&lt;p&gt;See blog post: &lt;a href=&#34;https://xorvoid.com/sectorc.html&#34;&gt;SectorC: A C Compiler in 512 bytes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;In 2020, cesarblum wrote a Forth that fits in a bootsector: (&lt;a href=&#34;https://github.com/cesarblum/sectorforth&#34;&gt;sectorforth&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;In 2021, jart et. al. wrote a Lisp that fits in the bootsector: (&lt;a href=&#34;https://github.com/jart/sectorlisp&#34;&gt;sectorlisp&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Naturally, C always needs to come and crash (literally) every low-level systems party regaurdless of whether it was even invited.&lt;/p&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;p&gt;Dependencies:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nasm&lt;/code&gt; for assembling (I used v2.16.01)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;qemu-system-i386&lt;/code&gt; for emulating x86-16 (I used v8.0.0)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Build: &lt;code&gt;./build.sh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Run: &lt;code&gt;./run.sh your_source.c&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;NOTE: Tested only on a MacBook M1&lt;/p&gt; &#xA;&lt;h2&gt;What is this useful for?&lt;/h2&gt; &#xA;&lt;p&gt;Probably Nothing.&lt;/p&gt; &#xA;&lt;p&gt;Or at least that&#39;s what I thought when starting out. But, I didn&#39;t think I&#39;d get such a feature set. Now, I&#39;d say that it &lt;strong&gt;might&lt;/strong&gt; be useful for someone that wants to explore x86-16 bios functions and machine model w/o having to learn lots of x86 assembly first. But, then again, you should just use a proper C compiler and write a tiny bootloader to execute it.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>lh3/seqtk</title>
    <updated>2023-05-28T01:33:45Z</updated>
    <id>tag:github.com,2023-05-28:/lh3/seqtk</id>
    <link href="https://github.com/lh3/seqtk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Toolkit for processing sequences in FASTA/Q formats&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Seqtk is a fast and lightweight tool for processing sequences in the FASTA or FASTQ format. It seamlessly parses both FASTA and FASTQ files which can also be optionally compressed by gzip. To install &lt;code&gt;seqtk&lt;/code&gt;,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/lh3/seqtk.git;&#xA;cd seqtk; make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The only library dependency is zlib.&lt;/p&gt; &#xA;&lt;h2&gt;Seqtk Examples&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Convert FASTQ to FASTA:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk seq -a in.fq.gz &amp;gt; out.fa&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Convert ILLUMINA 1.3+ FASTQ to FASTA and mask bases with quality lower than 20 to lowercases (the 1st command line) or to &lt;code&gt;N&lt;/code&gt; (the 2nd):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk seq -aQ64 -q20 in.fq &amp;gt; out.fa&#xA;  seqtk seq -aQ64 -q20 -n N in.fq &amp;gt; out.fa&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fold long FASTA/Q lines and remove FASTA/Q comments:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk seq -Cl60 in.fa &amp;gt; out.fa&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Convert multi-line FASTQ to 4-line FASTQ:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk seq -l0 in.fq &amp;gt; out.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Reverse complement FASTA/Q:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk seq -r in.fq &amp;gt; out.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Extract sequences with names in file &lt;code&gt;name.lst&lt;/code&gt;, one sequence name per line:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk subseq in.fq name.lst &amp;gt; out.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Extract sequences in regions contained in file &lt;code&gt;reg.bed&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk subseq in.fa reg.bed &amp;gt; out.fa&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Mask regions in &lt;code&gt;reg.bed&lt;/code&gt; to lowercases:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk seq -M reg.bed in.fa &amp;gt; out.fa&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Subsample 10000 read pairs from two large paired FASTQ files (remember to use the same random seed to keep pairing):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk sample -s100 read1.fq 10000 &amp;gt; sub1.fq&#xA;  seqtk sample -s100 read2.fq 10000 &amp;gt; sub2.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Trim low-quality bases from both ends using the Phred algorithm:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk trimfq in.fq &amp;gt; out.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Trim 5bp from the left end of each read and 10bp from the right end:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk trimfq -b 5 -e 10 in.fa &amp;gt; out.fa&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Find telomere (TTAGGG)n repeats:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  seqtk telo seq.fa &amp;gt; telo.bed 2&amp;gt; telo.count&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>WKL-Sec/HiddenDesktop</title>
    <updated>2023-05-28T01:33:45Z</updated>
    <id>tag:github.com,2023-05-28:/WKL-Sec/HiddenDesktop</id>
    <link href="https://github.com/WKL-Sec/HiddenDesktop" rel="alternate"></link>
    <summary type="html">&lt;p&gt;HVNC for Cobalt Strike&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hidden Desktop BOF&lt;/h1&gt; &#xA;&lt;p&gt;Hidden Desktop (often referred to as HVNC) is a tool that allows operators to interact with a remote desktop session without the user knowing. The VNC protocol is not involved, but the result is a similar experience. This Cobalt Strike BOF implementation was created as an alternative to TinyNuke/forks that are written in C++.&lt;/p&gt; &#xA;&lt;p&gt;There are four components of Hidden Desktop:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;BOF initializer: Small program responsible for injecting the HVNC code into the Beacon process.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;HVNC shellcode: PIC implementation of TinyNuke HVNC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Server and operator UI: Server that listens for connections from the HVNC shellcode and a UI that allows the operator to interact with the remote desktop. Currently only supports Windows.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Application launcher BOFs: Set of Beacon Object Files that execute applications in the new desktop.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Download the &lt;a href=&#34;https://github.com/WKL-Sec/HiddenDesktop/releases&#34;&gt;latest release&lt;/a&gt; or compile yourself using &lt;code&gt;make&lt;/code&gt;. Start the HVNC server on a Windows machine accessible from the teamserver. You can then execute the client with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;HiddenDesktop &amp;lt;server&amp;gt; &amp;lt;port&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see a new blank window on the server machine. The BOF does not execute any applications by default. You can use the application launcher BOFs to execute common programs on the new desktop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hd-launch-edge&#xA;hd-launch-explorer&#xA;hd-launch-run&#xA;hd-launch-cmd&#xA;hd-launch-chrome&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also launch programs through File Explorer using the mouse and keyboard. Other applications can be executed using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hd-launch &amp;lt;command&amp;gt; [args]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/WKL-Sec/HiddenDesktop/assets/9327972/82f73393-ba44-42b4-8eae-b36b7181fac0&#34;&gt;https://github.com/WKL-Sec/HiddenDesktop/assets/9327972/82f73393-ba44-42b4-8eae-b36b7181fac0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Details&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The Aggressor script generates random pipe and desktop names. These are passed to the BOF initializer as arguments. The desktop name is stored in CS preferences at execution and is used by the application launcher BOFs. HVNC traffic is forwarded back to the team server using &lt;code&gt;rportfwd&lt;/code&gt;. Status updates are sent back to Beacon through a named pipe.&lt;/li&gt; &#xA; &lt;li&gt;The BOF initializer starts by resolving the required modules and functions. Arguments from the Aggressor script are resolved. A pointer to a structure containing the arguments and function addresses is passed to the &lt;code&gt;InputHandler&lt;/code&gt; function in the HVNC shellcode. It uses &lt;code&gt;BeaconInjectProcess&lt;/code&gt; to execute the shellcode, meaning the behavior can be customized in a Malleable C2 profile or with process injection BOFs. You could modify Hidden Desktop to target remote processes, but this is not currently supported. This is done so the BOF can exit and the HVNC shellcode can continue running.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;InputHandler&lt;/code&gt; creates a new named pipe for Beacon to connect to. Once a connection has been established, the specified desktop is opened (&lt;code&gt;OpenDesktopA&lt;/code&gt;) or created (&lt;code&gt;CreateDesktopA&lt;/code&gt;). A new socket is established through a reverse port forward (&lt;code&gt;rportfwd&lt;/code&gt;) to the HVNC server. The input handler creates a new thread for the &lt;code&gt;DesktopHandler&lt;/code&gt; function described below. This thread will receive mouse and keyboard input from the HVNC server and forward it to the desktop.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DesktopHandler&lt;/code&gt; establishes an additional socket connection to the HVNC server through the reverse port forward. This thread will monitor windows for changes and forward them to the HVNC server.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;The HiddenDesktop BOF was tested using &lt;a href=&#34;https://raw.githubusercontent.com/WKL-Sec/HiddenDesktop/main/example.profile&#34;&gt;example.profile&lt;/a&gt; on the following Windows versions/architectures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows Server 2022 x64&lt;/li&gt; &#xA; &lt;li&gt;Windows Server 2016 x64&lt;/li&gt; &#xA; &lt;li&gt;Windows Server 2012 R2 x64&lt;/li&gt; &#xA; &lt;li&gt;Windows Server 2008 x86&lt;/li&gt; &#xA; &lt;li&gt;Windows 7 SP1 x64&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Known Issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The start menu is not functional.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Heavily based on &lt;a href=&#34;https://github.com/rossja/TinyNuke&#34;&gt;TinyNuke&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Included improvements/fixes from &lt;a href=&#34;https://github.com/Meltedd/HVNC&#34;&gt;Meltedd/HVNC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Uses Beacon job interface and project structure from &lt;a href=&#34;https://github.com/SolomonSklash/netntlm&#34;&gt;SecIdiot/netntlm&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>