<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-06T01:28:50Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>MicroLua/MicroLua</title>
    <updated>2023-11-06T01:28:50Z</updated>
    <id>tag:github.com,2023-11-06:/MicroLua/MicroLua</id>
    <link href="https://github.com/MicroLua/MicroLua" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lua for the RP2040 microcontroller&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MicroLua - Lua for the RP2040 microcontroller&lt;/h1&gt; &#xA;&lt;!-- Copyright 2023 Remy Blank &lt;remy@c-space.org&gt; --&gt; &#xA;&lt;!-- SPDX-License-Identifier: MIT --&gt; &#xA;&lt;p&gt;MicroLua allows &lt;strong&gt;programming the &lt;a href=&#34;https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html&#34;&gt;RP2040 microcontroller&lt;/a&gt; in &lt;a href=&#34;https://www.lua.org/&#34;&gt;Lua&lt;/a&gt;&lt;/strong&gt;. It packages the latest Lua interpreter with bindings for the &lt;a href=&#34;https://github.com/raspberrypi/pico-sdk&#34;&gt;Pico SDK&lt;/a&gt; and a cooperative threading library.&lt;/p&gt; &#xA;&lt;p&gt;MicroLua is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/LICENSE.md&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mailing list: &lt;a href=&#34;https://www.freelists.org/list/microlua&#34;&gt;microlua@freelists.org&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Lua is a small, embeddable language. It is easy to learn and reasonably fast.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The RP2040 is a small, powerful microcontroller with a nice set of peripherals and an active developer community. Besides the official &lt;a href=&#34;https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html#technical-specification&#34;&gt;Pico&lt;/a&gt; and &lt;a href=&#34;https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html#raspberry-pi-pico-w-and-pico-wh&#34;&gt;Pico W&lt;/a&gt; boards from &lt;a href=&#34;https://www.raspberrypi.com/&#34;&gt;Raspberry Pi&lt;/a&gt;, a variety of cheap modules in various shapes and configurations are readily available for purchase.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I had been wanting to play with Lua for a very long time, without having a concrete use case for it. Similarly, I wanted to explore the RP2040 but didn&#39;t have a concrete project for it. MicroLua served as an excuse to get started with both.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Pristine, unpatched Lua interpreter:&lt;/strong&gt; MicroLua runs the latest, unmodified Lua 5.4.x interpreter, imported as a git submodule. All customization is done through &lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/core/luaconf.in.h&#34;&gt;&lt;code&gt;luaconf.h&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Per-core interpreter instances:&lt;/strong&gt; MicroLua runs a separate Lua interpreter in each core. They don&#39;t share state except through C libraries.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cooperative multithreading through Lua coroutines:&lt;/strong&gt; MicroLua implements cooperative threads as coroutines. This enables multitasking without the need for locks. Blocking library calls (e.g. &lt;code&gt;pico.time.sleep_us()&lt;/code&gt;) yield to other threads.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Thin bindings to C libraries:&lt;/strong&gt; MicroLua exposes a growing subset of the functionality provided by the Pico SDK. The bindings are designed with a straightforward and consistent &lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/docs/core.md#binding-conventions&#34;&gt;mapping&lt;/a&gt; to their underlying C implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Comprehensive suite of unit tests:&lt;/strong&gt; They not only test the binding layer, but when possible also the underlying functionality of the Pico SDK.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;Performance is adequate for applications that don&#39;t require very low latency, but it could be better. Event dispatch latency is currently in the hundreds of microseconds, which is fairly slow. This is mainly due to a naive threading implementation, and it can be improved.&lt;/p&gt; &#xA;&lt;p&gt;So it probably isn&#39;t realistic to try bit-banging high-speed serial protocols or PWM in Lua, but that&#39;s what the PIO and PWM peripherals are for. Anything that requires precise timings should probably be implemented in C. But Lua is a great glue language for the non timing-critical logic, and very easy to interface to C code.&lt;/p&gt; &#xA;&lt;h3&gt;Roadmap&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Add more bindings for the Pico SDK.&lt;/strong&gt; SPI and PIO are high on the list, followed by USB, Wifi and Bluetooth. Eventually, most SDK libraries should have a binding.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Improve threading performance.&lt;/strong&gt; A C implementation of the &lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/docs/mlua.md#mluathread&#34;&gt;&lt;code&gt;mlua.thread&lt;/code&gt;&lt;/a&gt; module, with a less naive timer list, could significantly improve event dispatch latency.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Add a filesystem&lt;/strong&gt; (probably &lt;a href=&#34;https://github.com/littlefs-project/littlefs&#34;&gt;littlefs&lt;/a&gt;) with support for loading Lua modules and updating them over USB. This will enable simpler development workflows similar to e.g. &lt;a href=&#34;https://micropython.org/&#34;&gt;MicroPython&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://thonny.org/&#34;&gt;Thonny&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tune garbage collection.&lt;/strong&gt; Garbage collection parameters are currently left at their default value, which may not be ideal for a memory-constrained target.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Improve cross-core communication.&lt;/strong&gt; Each core runs its own Lua interpreter, so they cannot communicate directly through shared Lua state. Currently, the only way for the cores to communicate is the SIO FIFOs, which is fairly limited. A form of memory-based cross-core channel would be useful.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Add multi-chip communication.&lt;/strong&gt; As an extension of cross-core channels, cross-chip channels could enable fast communication between multiple RP2040 chips.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s how to build and run the test suite on a Raspberry Pi Pico module.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Configure the location of the Pico SDK. Adjust for your setup.&#xA;$ export PICO_SDK_PATH=&#34;${HOME}/pico-sdk&#34;&#xA;&#xA;# Clone the repository and initialize submodules.&#xA;$ git clone https://github.com/MicroLua/MicroLua.git&#xA;$ cd MicroLua&#xA;$ git submodule update --init&#xA;&#xA;# Connect a Picoprobe to the target, on the UART and optionally on the debug&#xA;# port. Then view the Picoprobe&#39;s UART connection in a separate terminal.&#xA;# The &#34;term&#34; script uses socat.&#xA;$ tools/term /dev/ttyACM0&#xA;&#xA;# Build the unit tests.&#xA;$ cmake -s . -B build -DPICO_BOARD=pico&#xA;$ make -j9 -C build/lib&#xA;&#xA;# Start the target in BOOTSEL mode and flash it with picotool.&#xA;$ picotool load -v -x build/lib/mlua_tests.elf&#xA;&#xA;# Alternatively, start the target in BOOTSEL mode and copy to its boot drive.&#xA;$ cp build/lib/mlua_tests.uf2 /mnt/RPI-RP2/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/MicroLua/MicroLua-examples&#34;&gt;MicroLua-examples&lt;/a&gt; repository contains example programs that demonstrate how to use the features of the RP2040 from Lua.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s the &lt;code&gt;blink&lt;/code&gt; example in MicroLua, a translation of the &lt;a href=&#34;https://github.com/raspberrypi/pico-examples/tree/master/blink&#34;&gt;&lt;code&gt;blink&lt;/code&gt;&lt;/a&gt; example from the &lt;a href=&#34;https://github.com/raspberrypi/pico-examples&#34;&gt;&lt;code&gt;pico-examples&lt;/code&gt;&lt;/a&gt; repository.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;_ENV = mlua.Module(...)&#xA;&#xA;local gpio = require &#39;hardware.gpio&#39;&#xA;local pico = require &#39;pico&#39;&#xA;local time = require &#39;pico.time&#39;&#xA;&#xA;function main()&#xA;    local LED_PIN = pico.DEFAULT_LED_PIN&#xA;    gpio.init(LED_PIN)&#xA;    gpio.set_dir(LED_PIN, gpio.OUT)&#xA;    while true do&#xA;        gpio.put(LED_PIN, 1)&#xA;        time.sleep_ms(250)&#xA;        gpio.put(LED_PIN, 0)&#xA;        time.sleep_ms(250)&#xA;    end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/docs/core.md&#34;&gt;Core functionality&lt;/a&gt; of MicroLua.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/docs/hardware.md&#34;&gt;&lt;code&gt;hardware.*&lt;/code&gt;&lt;/a&gt;: Bindings for the &lt;code&gt;hardware_*&lt;/code&gt; libraries of the Pico SDK.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/docs/pico.md&#34;&gt;&lt;code&gt;pico.*&lt;/code&gt;&lt;/a&gt;: Bindings for the &lt;code&gt;pico_*&lt;/code&gt; libraries of the Pico SDK.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MicroLua/MicroLua/main/docs/mlua.md&#34;&gt;&lt;code&gt;mlua.*&lt;/code&gt;&lt;/a&gt;: MicroLua libraries.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;While I&#39;m happy to accept bug reports, feature requests and other suggestions on the &lt;a href=&#34;https://www.freelists.org/list/microlua&#34;&gt;mailing list&lt;/a&gt;, I am not actively looking for code contributions. In particular, &lt;strong&gt;please do not send pull requests&lt;/strong&gt; on Github. MicroLua is developed in a private &lt;a href=&#34;https://www.mercurial-scm.org/&#34;&gt;Mercurial&lt;/a&gt; repository, which is mirrored to Github.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Why Lua? Why the RP2040?&lt;/h3&gt; &#xA;&lt;p&gt;Both Lua and the RP2040 evolve at a velocity that can be followed by a single developer in their spare time. Lua is developed by a small team: the language itself evolves very slowly and the interpreter has a couple of minor releases each year. Similarly, the RP2040 is developed by a small company, and a new chip may be released every few years.&lt;/p&gt; &#xA;&lt;p&gt;Contrast this with e.g. Python: the language evolves rather quickly nowadays, and the interpreter gets contributions from dozens (hundreds? thousands?) of developers. Similarly, large semiconductor companies release new chips and variants every year. Developing for these targets is a game of catch-up that I don&#39;t want to play.&lt;/p&gt; &#xA;&lt;h3&gt;Can MicroLua support other microcontroller families?&lt;/h3&gt; &#xA;&lt;p&gt;No, that&#39;s an explicit non-goal. Supporting multiple microcontroller families inevitably leads to either limiting features to the common denominator, or introducing a complex configuration system.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, MicroLua integrates directly with the build system of the Pico SDK, which is strongly tied to the RP2040. Supporting other microcontrollers would require a different build system.&lt;/p&gt; &#xA;&lt;p&gt;MicroLua will likely support later RP devices if / when they get released, but until then, the RP2040 is the only supported target.&lt;/p&gt; &#xA;&lt;h3&gt;How does MicroLua compare to other Lua projects for the Pico?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/kevinboone/luapico&#34;&gt;picolua&lt;/a&gt; is based on a patched Lua 5.4 interpreter, and aims to provide a full embedded development environment, including a shell and an editor. It exposes a limited subset of Pico-specific functionality.&lt;/p&gt; &lt;p&gt;MicroLua uses an unpatched Lua interpreter at the latest stable version, and aims to expose most of the functionality provided by the Pico SDK through a thin binding layer.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;What&#39;s the relationship with MicroLua DS?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sourceforge.net/projects/microlua/&#34;&gt;MicroLua DS&lt;/a&gt; was a development environment for building apps for the Nintendo DS in Lua. It was last released in January 2014. MicroLua has no relationship with MicroLua DS.&lt;/p&gt; &#xA;&lt;p&gt;While the naming conflict is unfortunate, I felt that almost 10 years of inactivity was long enough that it was fair game to re-use the name.&lt;/p&gt;</summary>
  </entry>
</feed>