<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-01T01:31:44Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>NUL0x4C/AtomLdr</title>
    <updated>2023-03-01T01:31:44Z</updated>
    <id>tag:github.com,2023-03-01:/NUL0x4C/AtomLdr</id>
    <link href="https://github.com/NUL0x4C/AtomLdr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A DLL loader with advanced evasive features&lt;/p&gt;&lt;hr&gt;&lt;h2 align=&#34;center&#34;&gt; AtomLdr: A DLL loader with evasive features &lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Disclaimer&lt;/h3&gt; &#xA;&lt;h4&gt;This loader utilizes techniques taught in MalDev Academy. The training will be launched in the upcoming weeks on &lt;a href=&#34;https://raw.githubusercontent.com/NUL0x4C/AtomLdr/main/maldevacademy.com&#34;&gt;maldevacademy.com&lt;/a&gt;.&lt;/h4&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Features:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CRT library independent.&lt;/li&gt; &#xA; &lt;li&gt;The final DLL file, can run the payload by loading the DLL (executing its entry point), or by executing the exported &lt;code&gt;&#34;Atom&#34;&lt;/code&gt; function via the command line.&lt;/li&gt; &#xA; &lt;li&gt;DLL unhooking from \KnwonDlls\ directory, with &lt;strong&gt;no RWX&lt;/strong&gt; sections.&lt;/li&gt; &#xA; &lt;li&gt;The encrypted payload is saved in the resource section and retrieved via custom code.&lt;/li&gt; &#xA; &lt;li&gt;AES256-CBC Payload encryption using custom no table/data-dependent branches using &lt;a href=&#34;https://github.com/bitcoin-core/ctaes&#34;&gt;ctaes&lt;/a&gt;; this is one of the best custom AES implementations I&#39;ve encountered.&lt;/li&gt; &#xA; &lt;li&gt;Aes Key &amp;amp; Iv Encryption.&lt;/li&gt; &#xA; &lt;li&gt;Indirect syscalls, utilizing &lt;a href=&#34;https://github.com/Maldev-Academy/HellHall&#34;&gt;HellHall&lt;/a&gt; with &lt;em&gt;ROP&lt;/em&gt; gadgets (for the unhooking part).&lt;/li&gt; &#xA; &lt;li&gt;Payload injection using APC calls - alertable thread.&lt;/li&gt; &#xA; &lt;li&gt;Payload execution using APC - alertable thread.&lt;/li&gt; &#xA; &lt;li&gt;Api hashing using two different implementations of the &lt;code&gt;CRC32&lt;/code&gt; string hashing algorithm.&lt;/li&gt; &#xA; &lt;li&gt;The total Size is 17kb + payload size (multiple of 16).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;How Does The Unhooking Part Work&lt;/h3&gt; &#xA;&lt;p&gt;AtomLdr&#39;s unhooking method looks like the following&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/111295429/221431770-e27726a7-ca3d-4ec3-8fa1-0e04f8405f83.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;the program Unhooking from the \KnwonDlls\ directory is not a new method to bypass user-land hooks. However, this loader tries to avoid allocating &lt;strong&gt;RWX&lt;/strong&gt; memory when doing so. This was obligatory to do in &lt;a href=&#34;https://github.com/NUL0x4C/KnownDllUnhook&#34;&gt;KnownDllUnhook&lt;/a&gt; for example, where &lt;strong&gt;RWX&lt;/strong&gt; permissions were needed to replace the text section of the hooked modules, and at the same time allow execution of functions within these text sections.&lt;/p&gt; &#xA;&lt;p&gt;This was changed in this loader, where it suspends the running threads, in an attempt to block any function from being called from within the targetted text sections, thus eliminating the need of having them marked as &lt;strong&gt;RWX&lt;/strong&gt; sections before unhooking, making &lt;strong&gt;RW&lt;/strong&gt; permissions a possible choice.&lt;/p&gt; &#xA;&lt;p&gt;This approach, however, created another problem; when unhooking, &lt;code&gt;NtProtectVirtualMemory&lt;/code&gt; syscall and others were using the syscall instruction inside of ntdll.dll module, as an indirect-syscall approach. Still, as mentioned above, the unhooked modules will be marked as &lt;strong&gt;RW&lt;/strong&gt; sections, making it impossible to perform indirect syscalls, because the syscall instruction that we were jumping to, can&#39;t be executed now, so we had to jump to another &lt;em&gt;executable&lt;/em&gt; place, this is where &lt;code&gt;win32u.dll&lt;/code&gt; was used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;win32u.dll&lt;/code&gt; contains some syscalls that are GUI-related functions, making it suitable to jump to instead of ntdll.dll. win32u.dll is loaded (statically), but not included in the unhooking routine, which is done to insure that win32u.dll can still execute the syscall instruction we are jumping to.&lt;/p&gt; &#xA;&lt;p&gt;The suspended threads after that are resumed.&lt;/p&gt; &#xA;&lt;p&gt;It is worth mentioning that this approach may not be that efficient, and can be unstable, that is due to the thread suspension trick used. However, it has been tested with multiple processes with positive results, in the meantime, if you encountered any problems, feel free to open an issue.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/NUL0x4C/AtomLdr/tree/main/PayloadBuilder&#34;&gt;PayloadBuilder&lt;/a&gt; is compiled and executed with the specified payload, it will output a &lt;code&gt;PayloadConfig.pc&lt;/code&gt; file, that contains the encrypted payload, and its encrypted key and iv.&lt;/li&gt; &#xA; &lt;li&gt;The generated &lt;code&gt;PayloadConfig.pc&lt;/code&gt; file will then replace &lt;a href=&#34;https://github.com/NUL0x4C/AtomLdr/raw/main/AtomLdr/PayloadConfig.pc&#34;&gt;this&lt;/a&gt; in the &lt;code&gt;AtomLdr&lt;/code&gt; project.&lt;/li&gt; &#xA; &lt;li&gt;Compile the &lt;code&gt;AtomLdr&lt;/code&gt; project as x64 Release.&lt;/li&gt; &#xA; &lt;li&gt;To enable debug mode, uncomment this &lt;a href=&#34;https://github.com/NUL0x4C/AtomLdr/raw/main/AtomLdr/Debug.h#L6&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Demo (1)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Executing &lt;code&gt;AtomLdr.dll&lt;/code&gt; using rundll32.exe, running &lt;a href=&#34;https://github.com/HavocFramework/Havoc&#34;&gt;Havoc&lt;/a&gt; payload, and capturing a screenshot&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/111295429/221431188-8f1b6a04-c0ce-48d3-91b3-9f2ba1ce9385.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AtomLdr.dll&lt;/code&gt;&#39;s Import Address Table&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/111295429/221433130-c285f84f-8cb9-4e69-aeb8-549f3d69fd19.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Demo - Debug Mode(2)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Running &lt;code&gt;PayloadBuilder.exe&lt;/code&gt;, to encrypt &lt;code&gt;demon[111].bin&lt;/code&gt; - a Havoc payload file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/111295429/221431453-0f4b2840-3f03-4957-996b-dbdea605e9c0.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Running &lt;code&gt;AtomLdr.dll&lt;/code&gt; using rundll32.exe&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/111295429/221432698-cd358adc-a72a-40f2-8502-e47482f65a59.png&#34; alt=&#34;image&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/111295429/221432709-5455bd08-014c-4c04-b774-22e6778c2783.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Havoc capturing a screenshot, after payload execution&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/111295429/221432872-08ce8327-502f-45bb-be0e-040ce39bfabf.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Based on&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bitcoin-core/ctaes&#34;&gt;ctaes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.x86matthew.com/view_post?id=writeprocessmemory_apc&#34;&gt;WriteProcessMemoryAPC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vxunderground/VX-API&#34;&gt;VX-API&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>realoriginal/bootlicker</title>
    <updated>2023-03-01T01:31:44Z</updated>
    <id>tag:github.com,2023-03-01:/realoriginal/bootlicker</id>
    <link href="https://github.com/realoriginal/bootlicker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A generic UEFI bootkit used to achieve initial usermode execution. It works with modifications.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;bootlicker is a legacy, extensible UEFI firmware rootkit targeting vmware hypervisor virtual machines. It is designed to achieve initial code execution within the context of the windows kernel, regardless of security settings configured.&lt;/p&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ONRLJZe.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;bootlicker takes its design from the legacy CosmicStrain, MoonBounce, and ESPECTRE rootkits to achive arbitrary code excution without triggering patchguard or other related security mechanisms.&lt;/p&gt; &#xA;&lt;p&gt;After initial insertion into a UEFI driver firmware using the the &lt;a href=&#34;https://raw.githubusercontent.com/realoriginal/bootlicker/master/scripts/inject.py&#34;&gt;injection utility&lt;/a&gt;, the shellcodes &lt;a href=&#34;https://raw.githubusercontent.com/realoriginal/bootlicker/master/bootkit/EfiMain.c&#34;&gt;EfiMain&lt;/a&gt; achieves execution as the host starts up, and inserts a hook into the UEFI firmware&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/realoriginal/bootlicker/master/bootkit/ExitBootServices.c&#34;&gt;ExitBootServices routine&lt;/a&gt;. The ExitBootServices routine will then, on execution, find the source caller of the function, and if it matches WinLoad.EFI, attempts to find the unexported winload.efi!OslArchTransferToKernel routine, which will allow us to attack the booting kernel before it achieves its initial execution.&lt;/p&gt; &#xA;&lt;p&gt;Once &lt;a href=&#34;https://raw.githubusercontent.com/realoriginal/bootlicker/master/bootkit/OslArchTransferToKernel.c&#34;&gt;OslArchTransferToKernel&lt;/a&gt; executes, it will search for the ACPI.SYS driver, find the &lt;code&gt;.rsrc&lt;/code&gt; PE section, and inject a small stager shellcode entrypoint called &lt;a href=&#34;https://raw.githubusercontent.com/realoriginal/bootlicker/master/bootkit/DrvMain.c&#34;&gt;DrvMain&lt;/a&gt; to copy over a larger payload that will act as our kernel implant.&lt;/p&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Entirely based upon d_olex / cr4sh&#39;s &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorBoot&#34;&gt;DmaBackdoorBoot&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Epilogue&lt;/h3&gt; &#xA;&lt;p&gt;This code is apart of a larger project I&#39;ve been working on that on / off in between burnout, like most of the concepts I&#39;ve produced over the years under various aliases, will never see the light of day. Some of the code comments I&#39;ve been to lazy to strip out that refer to unrelated functiaonlity, despite it being previously present. Do not expect this to work out of the box, some slight modifications are certainly necessary.&lt;/p&gt; &#xA;&lt;p&gt;I build these things purely for myself, and to advertise my skillsets. I&#39;m a hobbyist engineer purely just trying to occupy my mind and keep myself mentally active. Professionally, I work as a consultant, and developer for a firm known as GuidePoint Security, where I&#39;ve RE&#39;d various exploits, software, mawlware, etc, anything I can get my hands on, for fun, in between work hours outside of billable work, purely because I find it more interesting than conducting another pentest or red-team.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m happy to answer any questions from anybody, despite my opinionated criticisms in public, I enjoy talking with people, and hearing other sides. Feel free to ask away. However: I won&#39;t be hand holding anyone through this. Best of luck, and have fun.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>PCRE2Project/pcre2</title>
    <updated>2023-03-01T01:31:44Z</updated>
    <id>tag:github.com,2023-03-01:/PCRE2Project/pcre2</id>
    <link href="https://github.com/PCRE2Project/pcre2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PCRE2 development is now based here.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PCRE2 - Perl-Compatible Regular Expressions&lt;/h1&gt; &#xA;&lt;p&gt;The PCRE2 library is a set of C functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5. PCRE2 has its own native API, as well as a set of wrapper functions that correspond to the POSIX regular expression API. The PCRE2 library is free, even for building proprietary software. It comes in three forms, for processing 8-bit, 16-bit, or 32-bit code units, in either literal or UTF encoding.&lt;/p&gt; &#xA;&lt;p&gt;PCRE2 was first released in 2015 to replace the API in the original PCRE library, which is now obsolete and no longer maintained. As well as a more flexible API, the code of PCRE2 has been much improved since the fork.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;As well as downloading from the &lt;a href=&#34;https://github.com/PCRE2Project/pcre2&#34;&gt;GitHub site&lt;/a&gt;, you can download PCRE2 or the older, unmaintained PCRE1 library from an &lt;a href=&#34;https://sourceforge.net/projects/pcre/files/&#34;&gt;&lt;em&gt;unofficial&lt;/em&gt; mirror&lt;/a&gt; at SourceForge.&lt;/p&gt; &#xA;&lt;p&gt;You can check out the PCRE2 source code via Git or Subversion:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/PCRE2Project/pcre2.git&#xA;svn co    https://github.com/PCRE2Project/pcre2.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributed Ports&lt;/h2&gt; &#xA;&lt;p&gt;If you just need the command-line PCRE2 tools on Windows, precompiled binary versions are available at this &lt;a href=&#34;http://www.rexegg.com/pcregrep-pcretest.html&#34;&gt;Rexegg page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A PCRE2 port for z/OS, a mainframe operating system which uses EBCDIC as its default character encoding, can be found at &lt;a href=&#34;http://www.cbttape.org/&#34;&gt;http://www.cbttape.org&lt;/a&gt; (File 939).&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;You can read the PCRE2 documentation &lt;a href=&#34;https://PCRE2Project.github.io/pcre2/doc/html/index.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Comparisons to Perl&#39;s regular expression semantics can be found in the community authored Wikipedia entry for PCRE.&lt;/p&gt; &#xA;&lt;p&gt;There is a curated summary of changes for each PCRE release, copies of documentation from older releases, and other useful information from the third party authored &lt;a href=&#34;http://www.rexegg.com/pcre-documentation.html&#34;&gt;RexEgg PCRE Documentation and Change Log page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;To report a problem with the PCRE2 library, or to make a feature request, please use the PCRE2 GitHub issues tracker. There is a mailing list for discussion of PCRE2 issues and development at &lt;a href=&#34;mailto:pcre2-dev@googlegroups.com&#34;&gt;pcre2-dev@googlegroups.com&lt;/a&gt;, which is where any announcements will be made. You can browse the &lt;a href=&#34;https://groups.google.com/g/pcre2-dev&#34;&gt;list archives&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>