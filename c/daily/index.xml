<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-04T01:27:21Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yitter/IdGenerator</title>
    <updated>2023-12-04T01:27:21Z</updated>
    <id>tag:github.com,2023-12-04:/yitter/IdGenerator</id>
    <link href="https://github.com/yitter/IdGenerator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;💎多语言实现，高性能生成唯一数字ID。 💎优化的雪花算法（SnowFlake）——雪花漂移算法，在缩短ID长度的同时，具备极高瞬时并发处理能力（50W/0.1s）。 💎原生支持 C#/Java/Go/Rust/C/JavaScript/TypeScript/Python/Pascal 多语言，提供其它适用于其它语言的多线程安全调用动态库（FFI）。💎支持容器环境自动扩容（自动注册 WorkerId ），单机或分布式唯一IdGenerator。💎顶尖优化，超强效能。&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;雪花算法中非常好用的数字ID生成器&lt;/h1&gt; &#xA;&lt;h2&gt;💎 最佳实践（置顶）&lt;/h2&gt; &#xA;&lt;p&gt;针对大家在测试过程中，经常出现的性能问题，以下给出3组最佳实践配置：&lt;/p&gt; &#xA;&lt;p&gt;❄ 如果生成ID速度不超过5W/s，不用修改任何配置参数&lt;/p&gt; &#xA;&lt;p&gt;❄ 如果生成ID速度超过5W/s，低于50W，推荐修改：SeqBitLength=10&lt;/p&gt; &#xA;&lt;p&gt;❄ 如果生成ID速度超过50W/s，接近500W，推荐修改：SeqBitLength=12&lt;/p&gt; &#xA;&lt;p&gt;总之，增加 SeqBitLength 会让性能更高，但生成的 ID 也会更长。&lt;/p&gt; &#xA;&lt;h2&gt;💎 算法介绍&lt;/h2&gt; &#xA;&lt;p&gt;❄ 这是优化的雪花算法（雪花漂移），它生成的ID更短、速度更快。&lt;/p&gt; &#xA;&lt;p&gt;❄ 支持 k8s 等容器环境自动扩容（自动注册 WorkerId），可在单机或分布式环境生成数字型唯一ID。&lt;/p&gt; &#xA;&lt;p&gt;❄ 原生支持 C#/Java/Go/C/Rust/Python/Node.js/PHP(C扩展)/SQL/ 等语言，并提供多线程安全调用动态库（FFI）。&lt;/p&gt; &#xA;&lt;p&gt;❄ 兼容所有雪花算法（号段模式或经典模式，大厂或小厂），将来你可做任意的升级切换。&lt;/p&gt; &#xA;&lt;p&gt;❄ 这是计算机历史上最全面的雪花ID生成工具。【截至2022年8月】&lt;/p&gt; &#xA;&lt;h4&gt;需求来源&lt;/h4&gt; &#xA;&lt;p&gt;💧 作为架构设计的你，想要解决数据库主键唯一的问题，特别是在分布式系统多数据库中。&lt;/p&gt; &#xA;&lt;p&gt;💧 你希望数据表主键用最少的存储空间，索引速度更快，Select、Insert 和 Update 更迅速。&lt;/p&gt; &#xA;&lt;p&gt;💧 你要考虑在分库分表（合库合表）时，主键值可直接使用，并能反映业务时序。&lt;/p&gt; &#xA;&lt;p&gt;💧 如果这样的主键值太长，超过前端 js Number 类型最大值，须把 Long 型转换为 String 型，你会觉得有点沮丧。&lt;/p&gt; &#xA;&lt;p&gt;💧 尽管 Guid 能自增，但占用空间大，索引速度慢，你不想用它。&lt;/p&gt; &#xA;&lt;p&gt;💧 应用实例可能超过50个，每个并发请求可达10W/s。&lt;/p&gt; &#xA;&lt;p&gt;💧 要在容器环境部署应用，支持水平复制、自动扩容。&lt;/p&gt; &#xA;&lt;p&gt;💧 不想依赖 redis 的自增操作获得连续的主键ID，因为连续的ID存在业务数据安全风险。&lt;/p&gt; &#xA;&lt;p&gt;💧 你希望系统运行 100 年以上。&lt;/p&gt; &#xA;&lt;h4&gt;传统算法问题&lt;/h4&gt; &#xA;&lt;p&gt;❌ 生成的ID太长。&lt;/p&gt; &#xA;&lt;p&gt;❌ 瞬时并发量不够。&lt;/p&gt; &#xA;&lt;p&gt;❌ 不能解决时间回拨问题。&lt;/p&gt; &#xA;&lt;p&gt;❌ 不支持后补生成前序ID。&lt;/p&gt; &#xA;&lt;p&gt;❌ 可能依赖外部存储系统。&lt;/p&gt; &#xA;&lt;h4&gt;新算法特点&lt;/h4&gt; &#xA;&lt;p&gt;✔ 整形数字，随时间单调递增（不一定连续），长度更短，用50年都不会超过 js Number类型最大值。（默认配置）&lt;/p&gt; &#xA;&lt;p&gt;✔ 速度更快，是传统雪花算法的2-5倍，0.1秒可生成50万个（基于8代低压i7）。&lt;/p&gt; &#xA;&lt;p&gt;✔ 支持时间回拨处理。比如服务器时间回拨1秒，本算法能自动适应生成临界时间的唯一ID。&lt;/p&gt; &#xA;&lt;p&gt;✔ 支持手工插入新ID。当业务需要在历史时间生成新ID时，用本算法的预留位能生成5000个每秒。&lt;/p&gt; &#xA;&lt;p&gt;✔ 不依赖任何外部缓存和数据库。（k8s环境下自动注册 WorkerId 的动态库依赖 redis）&lt;/p&gt; &#xA;&lt;p&gt;✔ 基础功能，开箱即用，无需配置文件、数据库连接等。&lt;/p&gt; &#xA;&lt;h4&gt;性能数据&lt;/h4&gt; &#xA;&lt;p&gt;(参数：10位自增序列，1000次漂移最大值)&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;连续请求量&lt;/th&gt; &#xA;   &lt;th&gt;5K&lt;/th&gt; &#xA;   &lt;th&gt;5W&lt;/th&gt; &#xA;   &lt;th&gt;50W&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;传统雪花算法&lt;/td&gt; &#xA;   &lt;td&gt;0.0045s&lt;/td&gt; &#xA;   &lt;td&gt;0.053s&lt;/td&gt; &#xA;   &lt;td&gt;0.556s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;雪花漂移算法&lt;/td&gt; &#xA;   &lt;td&gt;0.0015s&lt;/td&gt; &#xA;   &lt;td&gt;0.012s&lt;/td&gt; &#xA;   &lt;td&gt;0.113s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;💍 极致性能：500W/s~3000W/s。（所有测试数据均基于8代低压i7计算）&lt;/p&gt; &#xA;&lt;h4&gt;如何处理时间回拨&lt;/h4&gt; &#xA;&lt;p&gt;🔶 当发生系统时间回拨时，算法采用过去时序的预留序数生成新的ID。&lt;/p&gt; &#xA;&lt;p&gt;🔶 回拨生成的ID序号，默认靠前，也可以调整为靠后。&lt;/p&gt; &#xA;&lt;p&gt;🔶 允许时间回拨至本算法预设基数（参数可调）。&lt;/p&gt; &#xA;&lt;h2&gt;💎 ID组成说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;本算法生成的ID由3部分组成（沿用雪花算法定义）：&lt;/li&gt; &#xA; &lt;li&gt;+-------------------------+--------------+----------+&lt;/li&gt; &#xA; &lt;li&gt;| 1.相对基础时间的时间差 | 2.WorkerId | 3.序列数 |&lt;/li&gt; &#xA; &lt;li&gt;+-------------------------+--------------+----------+&lt;/li&gt; &#xA; &lt;li&gt;&lt;/li&gt; &#xA; &lt;li&gt;第1部分，时间差，是生成ID时的系统时间减去 BaseTime 的总时间差（毫秒单位）。&lt;/li&gt; &#xA; &lt;li&gt;第2部分，WorkerId，是区分不同机器或不同应用的唯一ID，最大值由 WorkerIdBitLength（默认6）限定。&lt;/li&gt; &#xA; &lt;li&gt;第3部分，序列数，是每毫秒下的序列数，由参数中的 SeqBitLength（默认6）限定。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;ID示例&lt;/h4&gt; &#xA;&lt;p&gt;🟣 本算法生成的 ID ，是整数（占用空间最多8字节），以下是基于默认配置生成的ID：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;129053495681099        (运行1年，长度：15)&#xA;387750301904971        (运行3年，长度：15)&#xA;646093214093387        (运行5年，长度：15)&#xA;1292658282840139       (运行10年，长度：16)&#xA;9007199254740992       (运行70年，达到 js Number 最大值，长度：16)&#xA;165399880288699493     (运行1000年，等同普通雪花算法运行1年，长度：18)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;🟣 本算法生成的 ID 值，是 js Number 最大值的 1%-10%，是普通雪花算法值的千分之一，而生成速度却超过普通雪花算法。&lt;/p&gt; &#xA;&lt;p&gt;🟣 js Number 类型最大数值：9007199254740992，本算法在保持并发性能（5W+/0.01s）和最大64个 WorkerId（6bit）的同时，能用70年才到 js Number Max 值。&lt;/p&gt; &#xA;&lt;h3&gt;长度估算&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;💍 每增加 1位 WorkerIdBitLength 或 SeqBitLength，生成的ID数字值将会乘以2（基础长度可参考前一节“ID示例”），反之则除以2。&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;能用多久&lt;/h3&gt; &#xA;&lt;p&gt;能用多久的解释，是指生成的ID数字，何时能增长到超过 long（有符号64位，8字节）最大值。&lt;/p&gt; &#xA;&lt;p&gt;🔵 在默认配置下，ID可用 71000 年不重复。&lt;/p&gt; &#xA;&lt;p&gt;🔵 在支持 1024 个工作节点时，ID可用 4480 年不重复。&lt;/p&gt; &#xA;&lt;p&gt;🔵 在支持 4096 个工作节点时，ID可用 1120 年不重复。&lt;/p&gt; &#xA;&lt;h2&gt;💎 参数设置&lt;/h2&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;WorkerIdBitLength&lt;/strong&gt;&lt;/em&gt;，机器码位长，决定 WorkerId 的最大值，&lt;strong&gt;默认值6&lt;/strong&gt;，取值范围 [1, 19]，实际上有些语言采用 无符号 ushort (uint16) 类型接收该参数，所以最大值是16，如果是采用 有符号 short (int16)，则最大值为15。&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;strong&gt;WorkerId&lt;/strong&gt;，机器码，&lt;strong&gt;最重要参数&lt;/strong&gt;，无默认值，必须 &lt;strong&gt;全局唯一&lt;/strong&gt;（或相同 DataCenterId 内唯一），必须 &lt;strong&gt;程序设定&lt;/strong&gt;，缺省条件（WorkerIdBitLength取默认值）时最大值63，理论最大值 2^WorkerIdBitLength-1（不同实现语言可能会限定在 65535 或 32767，原理同 WorkerIdBitLength 规则）。不同机器或不同应用实例 &lt;strong&gt;不能相同&lt;/strong&gt;，你可通过应用程序配置该值，也可通过调用外部服务获取值。针对自动注册WorkerId需求，本算法提供默认实现：通过 redis 自动注册 WorkerId 的动态库，详见“Tools\AutoRegisterWorkerId”。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;特别提示&lt;/strong&gt;：如果一台服务器部署多个独立服务，需要为每个服务指定不同的 WorkerId。&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;SeqBitLength&lt;/strong&gt;&lt;/em&gt;，序列数位长，&lt;strong&gt;默认值6&lt;/strong&gt;，取值范围 [3, 21]（建议不小于4），决定每毫秒基础生成的ID个数。如果每秒请求数不超过5W，保持默认值6即可；如果超过5W，不超过50W，建议赋值10或更大，以此类推。规则要求：WorkerIdBitLength + SeqBitLength 不超过 22。&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;MinSeqNumber&lt;/strong&gt;&lt;/em&gt;，最小序列数，默认值5，取值范围 [5, MaxSeqNumber]，每毫秒的前5个序列数对应编号0-4是保留位，其中1-4是时间回拨相应预留位，0是手工新值预留位。&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;MaxSeqNumber&lt;/strong&gt;&lt;/em&gt;，最大序列数，设置范围 [MinSeqNumber, 2^SeqBitLength-1]，默认值0，真实最大序列数取最大值（2^SeqBitLength-1），不为0时，取其为真实最大序列数，一般无需设置，除非多机共享WorkerId分段生成ID（此时还要正确设置最小序列数）。&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;BaseTime&lt;/strong&gt;&lt;/em&gt;，基础时间（也称：基点时间、原点时间、纪元时间），有默认值（2020年），是毫秒时间戳（是整数，.NET是DatetTime类型），作用是：用生成ID时的系统时间与基础时间的差值（毫秒数）作为生成ID的时间戳。基础时间一般无需设置，如果觉得默认值太老，你可以重新设置，不过要注意，这个值以后最好不变。&lt;/p&gt; &#xA;&lt;p&gt;第二版计划增加参数：&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;DataCenterId&lt;/strong&gt;&lt;/em&gt;，数据中心ID（机房ID，默认0），请确保全局唯一。&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;DataCenterIdBitLength&lt;/strong&gt;&lt;/em&gt;，数据中心ID长度（默认0）。&lt;/p&gt; &#xA;&lt;p&gt;❄ &lt;em&gt;&lt;strong&gt;TimestampType&lt;/strong&gt;&lt;/em&gt;，时间戳类型（0-毫秒，1-秒），默认0。&lt;/p&gt; &#xA;&lt;h4&gt;常规集成&lt;/h4&gt; &#xA;&lt;p&gt;1️⃣ 用单例模式调用。本算法采用单线程生成ID，多方调用会被互斥。在同一应用实例内，调用者使用多线程（或并行）方式调用本算法，不会增加ID产出速度。&lt;/p&gt; &#xA;&lt;p&gt;2️⃣ 指定唯一的 WorkerId。必须由外部系统确保 WorkerId 的全局唯一性，并赋值给本算法入口参数。&lt;/p&gt; &#xA;&lt;p&gt;3️⃣ 单机多实例部署时使用不同 WorkerId。并非所有实现都支持跨进程的并发唯一，保险起见，在同一主机上部署多应用实例时，请确保各 WorkerId 唯一。&lt;/p&gt; &#xA;&lt;p&gt;4️⃣ 异常处理。算法会抛出所有 Exception，外部系统应 catch 异常并做好应对处理，以免引发更大的系统崩溃。&lt;/p&gt; &#xA;&lt;p&gt;5️⃣ 认真理解 IdGeneratorOptions 的定义，这对集成和使用本算法有帮助。&lt;/p&gt; &#xA;&lt;p&gt;6️⃣ 使用雪花漂移算法。虽然代码里包含了传统雪花算法的定义，并且你可以在入口处指定（Method=2）来启用传统算法，但仍建议你使用雪花漂移算法（Method=1，默认的），毕竟它具有更好的伸缩力和更高的性能。&lt;/p&gt; &#xA;&lt;p&gt;7️⃣ 不要修改核心算法。本算法内部参数较多，逻辑较为复杂，在你尚未掌握核心逻辑时，请勿修改核心代码且用于生产环境，除非通过大量细致、科学的测试验证。&lt;/p&gt; &#xA;&lt;p&gt;8️⃣ 应用域内配置策略相同。当系统运行一段时间后，项目需要从程序指定 WorkerId 转到自动注册 WorkerId 时，请确保同一应用域内所有在用实例采用一致的配置策略，这不仅仅针对 WorkerId，也包含其他配置参数。&lt;/p&gt; &#xA;&lt;p&gt;9️⃣ 管理好服务器时间。雪花算法依赖系统时间，不要手工大幅度回调操作系统时间。如果一定要调整，切记：确保服务再次启动时的系统时间大于最后一次关闭时的时间。（注：世界级或网络级的时间同步或回拨，引起的系统时间小幅度变化，对本算法没影响）&lt;/p&gt; &#xA;&lt;h4&gt;配置变更&lt;/h4&gt; &#xA;&lt;p&gt;配置变更是指系统运行一段时间后，再调整运行参数（IdGeneratorOptions 对象属性），请注意：&lt;/p&gt; &#xA;&lt;p&gt;🔴 1.首要原则是：BaseTime &lt;strong&gt;只能更旧&lt;/strong&gt;（距现在更远），让生成的ID值较历史最大值更大，确保没有时间重叠区，不产生重复ID。[&lt;strong&gt;不推荐&lt;/strong&gt; 在系统运行之后调整 BaseTime]&lt;/p&gt; &#xA;&lt;p&gt;🔴 2.任何时候增加 WorkerIdBitLength 或 SeqBitLength，都是允许的，但应慎用 “减小”操作，因为这可能导致在未来某天生成的 ID 与旧配置时相同。[允许在系统运行之后 &lt;strong&gt;增加&lt;/strong&gt; 任何一个 xxxBitLength 值]&lt;/p&gt; &#xA;&lt;p&gt;🔴 3.如果必须减小 WorkerIdBitLength 或 SeqBitLength 其中的一项，一定要满足条件：新的两个 xxxBitLength 之和要大于旧值之和。[&lt;strong&gt;不推荐&lt;/strong&gt; 在运行之后缩小任何一个 BitLength 值]&lt;/p&gt; &#xA;&lt;p&gt;🔴 4.上述3条规则，并未在本算法内做逻辑控制，使用者应在确认新配置符合要求后，再实施配置变更。&lt;/p&gt; &#xA;&lt;h2&gt;自动注册WorkerId&lt;/h2&gt; &#xA;&lt;p&gt;🔍 唯一ID生成器，依赖WorkerId，当业务服务需要水平无差别复制（自动扩容）时，这就要求能自动注册全局唯一WorkerId，然后才能生产唯一ID。&lt;/p&gt; &#xA;&lt;p&gt;🔍 本算法提供开源动态库（go语言实现），能在容器 k8s 等容器环境下，通过 redis 自动注册 WorkerId。&lt;/p&gt; &#xA;&lt;p&gt;🔍 通过redis注册WorkerId，并非唯一方法。你还可以开发中心化的配置服务，各端点服务启动时，通过中心服务获取唯一 WorkerId。&lt;/p&gt; &#xA;&lt;p&gt;🔍 当然，如果你的服务无需自动扩容，那就不必自动注册WorkerId，而是为它们分别设置全局唯一值。&lt;/p&gt; &#xA;&lt;p&gt;🔍 方法还有很多，例如：开发中心化的ID生成服务，由它为各端点服务（单个或批量）生成可用ID。&lt;/p&gt; &#xA;&lt;h4&gt;自动注册流程图&lt;/h4&gt; &#xA;&lt;p&gt;图片链接：&lt;a href=&#34;https://github.com/yitter/IdGenerator/raw/master/Tools/AutoRegisterWorkerId/regprocess.jpg&#34;&gt;https://github.com/yitter/IdGenerator/blob/master/Tools/AutoRegisterWorkerId/regprocess.jpg&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;源码路径：/Go/source/regworkerid/reghelper.go&lt;/p&gt; &#xA;&lt;h4&gt;动态库下载&lt;/h4&gt; &#xA;&lt;p&gt;下载链接：&lt;a href=&#34;https://github.com/yitter/IdGenerator/releases/download/v1.3.3/workeridgo_lib_v1.3.3.zip&#34;&gt;https://github.com/yitter/IdGenerator/releases/download/v1.3.3/workeridgo_lib_v1.3.3.zip&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;动态库接口定义&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;// 注册一个 WorkerId，会先注销所有本机已注册的记录&#xA;// address: Redis连接地址，单机模式示例：127.0.0.1:6379，哨兵/集群模式示例：127.0.0.1:26380,127.0.0.1:26381,127.0.0.1:26382&#xA;// password: Redis连接密码&#xA;// db: Redis指定存储库，示例：1&#xA;// sentinelMasterName: Redis 哨兵模式下的服务名称，示例：mymaster，非哨兵模式传入空字符串即可&#xA;// minWorkerId: WorkerId 最小值，示例：30&#xA;// maxWorkerId: WorkerId 最大值，示例：63&#xA;// lifeTimeSeconds: WorkerId缓存时长（秒，3的倍数），推荐值15&#xA;extern GoInt32 RegisterOne(char* server, char* password, GoInt32 db, char* sentinelMasterName, GoInt32 minWorkerId, GoInt32 maxWorkerId, GoInt32 lifeTimeSeconds);&#xA;&#xA;// 注销本机已注册的 WorkerId&#xA;extern void UnRegister();&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;已实现的语言&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;语言&lt;/th&gt; &#xA;   &lt;th&gt;github&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 C#&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/C%23.NET&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 Java&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/Java&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 Go&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/Go&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 Rust&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/Rust&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 Python&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/IdGenerator/tree/master/Python&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 C&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/C&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 C (PHP扩展)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/PHP&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 Delphi (Pascal)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/Delphi&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 JavaScript&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/IdGenerator/tree/master/JavaScript&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 TypeScript&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/IdGenerator/tree/master/TypeScript&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 V&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/Delphi&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;🌲 D&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yitter/idgenerator/tree/master/zzz-OtherLanguages/D&#34;&gt;查看示例&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;技术支持&lt;/h2&gt; &#xA;&lt;p&gt;开源地址：&lt;a href=&#34;https://github.com/yitter/IdGenerator&#34;&gt;https://github.com/yitter/IdGenerator&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;QQ群：646049993&lt;/p&gt;</summary>
  </entry>
</feed>