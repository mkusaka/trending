<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-19T01:31:27Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bernhardstrobl/Pico3D</title>
    <updated>2023-04-19T01:31:27Z</updated>
    <id>tag:github.com,2023-04-19:/bernhardstrobl/Pico3D</id>
    <link href="https://github.com/bernhardstrobl/Pico3D" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open World 3D Game Engine for the PicoSystem &amp; RP2040 Microcontroller&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pico3D Open World 3D Game Engine for the Pimoroni PicoSystem &amp;amp; RP2040 Microcontroller&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bernhardstrobl/Pico3D/main/docs/pico3d.jpg&#34; alt=&#34;Pico3D preview&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This engine basically utilizes the second core of the RP2040 as a dedicated rasterizer/GPU.&lt;br&gt; It contains a small city as well as an outskirts featuring shootable zombies.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=n6bECGQyNuk&#34;&gt;Gameplay video&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://www.youtube.com/watch?v=6WkltAOFDYs&#34;&gt;Demo video&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;If all you want are .uf2 binaries, check the releases for the newest version.&lt;/p&gt; &#xA;&lt;p&gt;You will need the &lt;a href=&#34;https://github.com/pimoroni/picosystem&#34;&gt;PicoSystem SDK&lt;/a&gt; (and the required Pico SDK).&lt;br&gt; Copy the whole Pico3D folder as an example project into picosystem/examples and add &#34;add_subdirectory(pico3d)&#34; entry into the CMakeLists.txt.&lt;/p&gt; &#xA;&lt;p&gt;The project needs multi-core support to compile:&lt;br&gt; Add pico_multicore to the target_link_libraries in picosystem.cmake found in picosystem/libraries.&lt;/p&gt; &#xA;&lt;p&gt;You should now be able to compile all the examples including pico3d.&lt;/p&gt; &#xA;&lt;h2&gt;Blender Tutorials&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bernhardstrobl/Pico3D/main/docs/tutorial_blender_export.md&#34;&gt;Creating and exporting a game world in Blender&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bernhardstrobl/Pico3D/main/docs/tutorial_blender_materials.md&#34;&gt;Material, lights and textures in Blender&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bernhardstrobl/Pico3D/main/docs/tutorial_blender_mesh.md&#34;&gt;Exporting individual meshes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;F.A.Q.&lt;/h2&gt; &#xA;&lt;h3&gt;I don&#39;t have a PicoSystem?!&lt;/h3&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://github.com/Daft-Freak/DERP&#34;&gt;Daft&#39;s Emulator for RP2040&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How did this project come about?&lt;/h3&gt; &#xA;&lt;p&gt;Pico3D was created as part of a master&#39;s thesis at the Kempten University of Applied Sciences (Hochschule Kempten).&lt;br&gt; It was designed to answer the question of whether a modern $1 microcontroller could run a complete open world 3D game. The thesis is available &lt;a href=&#34;https://lavarails.com/download/open_world_3D_microcontroller.pdf&#34;&gt;here&lt;/a&gt; and should answer most of the design decisions behind the engine.&lt;/p&gt; &#xA;&lt;h3&gt;Where do I start?&lt;/h3&gt; &#xA;&lt;p&gt;Check out the Blender tutorials on creating your own game worlds. The main.cpp file contains a general overview of the game and engine. The most important Pico3D feature is going to be the render_triangle() function. This function basically does all of the hard work of transforming a triangle (in world space) and pushing it into the renderer (no deep engine/graphics knowledge needed!).&lt;br&gt; See the test models and the render_model_16bit functions for an example on how to put in your own meshes.&lt;/p&gt; &#xA;&lt;h3&gt;How big can the world be?&lt;/h3&gt; &#xA;&lt;p&gt;The included game has a grid size of 12x12 chunks (each chunk is 10x10m in size -&amp;gt; world size of 120x120m).&lt;br&gt; Right now the chunk cache uses an 8 bit int for each direction limiting the world size to 256x256 chunks (2.56x2.56km). This can be extended if needed.&lt;br&gt; Unless heavy use of repeat/procedurally generated chunks is made use of the binary is also likely to exceed 16MB. Plenty of creative procedural tricks are possible to get around this issue as well however if you want the next Daggerfall.&lt;/p&gt; &#xA;&lt;h3&gt;How are the NPCs loaded in/out?&lt;/h3&gt; &#xA;&lt;p&gt;Right now the game simply simulates all 50 NPCs and 50 zombies at the same time since that is pretty cheap compared to the actual rendering.&lt;br&gt; It&#39;s also more realistic that way and uncovers any big issues in the self-made RNG ;).&lt;br&gt; Rendering is optimized with distance and view frustum culling.&lt;/p&gt; &#xA;&lt;h3&gt;What is the Gamescom version of the game?&lt;/h3&gt; &#xA;&lt;p&gt;This version was used to demonstrate the engine at Gamescom and replaces the zombies with balloons to conform to USK ratings. It is left in the codebase to show how to make a possible variant of the game for developers.&lt;/p&gt; &#xA;&lt;h3&gt;What were the inspirations for the game world?&lt;/h3&gt; &#xA;&lt;p&gt;The city itself was inspired heavily by Cyberpunk 2077 and the Yakuza series of games. The outskirts have a Legend of Zelda: Breath of the Wild influence.&lt;/p&gt; &#xA;&lt;h3&gt;Why are there so many redundant functions in certain code areas like the zombie logic?&lt;/h3&gt; &#xA;&lt;p&gt;Divisions are relatively expensive on the RP2040 if performed in quick succession such as when interpolating vertices for mesh blending.&lt;br&gt; Performance can be tested by changing the NPC or Zombie walk animations to a non power of 2 number such as 127, forcing the compiler to apply actual divisions instead of cheaper bit shifts.&lt;br&gt; As the compiler does not know during compilation time if a variable will be a power of 2 or not, it will simply apply divisions regardless if the value is not fixed as it is now.&lt;br&gt; There are likely ways to improve on this code redundancy but I have not taken the time to think of one yet (don&#39;t forget, function calls themselves are relatively expensive).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>DallasFR/WinShellcode</title>
    <updated>2023-04-19T01:31:27Z</updated>
    <id>tag:github.com,2023-04-19:/DallasFR/WinShellcode</id>
    <link href="https://github.com/DallasFR/WinShellcode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Make your own windows shellcode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WinShellcode&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What is it?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It&#39;s a C code project created in Visual Studio that helps you generate shellcode from your C code.&lt;/p&gt; &#xA;&lt;p&gt;HashMe: Hash your string with the Murmur hash function in both ANSI and UNICODE formats.&lt;/p&gt; &#xA;&lt;p&gt;text_to_shellcode: Extract the .text section from your compiled binary and create a binary file containing the shellcode.&lt;/p&gt; &#xA;&lt;p&gt;shellcode_dll: A Visual Studio project containing C code, which you need to modify to obtain your shellcode.&lt;/p&gt; &#xA;&lt;p&gt;take_shellcode.bat: Run this script to generate the .bin file containing the shellcode from your compiled executable file.&lt;/p&gt; &#xA;&lt;p&gt;Also, this project work only in x64&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Credits&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.codeproject.com/Articles/5304605/Creating-Shellcode-from-any-Code-Using-Visual-Stud&#34;&gt;https://www.codeproject.com/Articles/5304605/Creating-Shellcode-from-any-Code-Using-Visual-Stud&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/vxunderground/VX-API/raw/main/VX-API/HashStringMurmur.cpp&#34;&gt;https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringMurmur.cpp&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cproape/toolkit</title>
    <updated>2023-04-19T01:31:27Z</updated>
    <id>tag:github.com,2023-04-19:/cproape/toolkit</id>
    <link href="https://github.com/cproape/toolkit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ToolKit是一套应用于嵌入式系统的通用工具包，目前为止工具包包含：循环队列、软件定时器、事件集&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ToolKit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/version-V1.0.6-brightgreen.svg?sanitize=true&#34; alt=&#34;version&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/date-2020.12.09-brightgreen.svg?sanitize=true&#34; alt=&#34;date&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;1、介绍&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cproape&#34;&gt;ToolKit&lt;/a&gt;是一套应用于嵌入式系统的通用工具包，可灵活应用到有无RTOS的程序中，采用C语言面向对象的思路实现各个功能，尽可能最大化的复用代码，目前为止工具包包含：&lt;strong&gt;循环队列、软件定时器、事件集&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt; 循环队列 &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;支持动态、静态方式进行队列的创建与删除。&lt;/li&gt; &#xA;   &lt;li&gt;可独立配置缓冲区大小。&lt;/li&gt; &#xA;   &lt;li&gt;支持数据&lt;strong&gt;最新保持&lt;/strong&gt;功能，当配置此模式并且缓冲区已满，若有新的数据存入，将会移除最早数据，并保持缓冲区已满。&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Timer&lt;/strong&gt; 软件定时器 &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;支持动态、静态方式进行定时器的创建与删除。&lt;/li&gt; &#xA;   &lt;li&gt;支持&lt;strong&gt;循环&lt;/strong&gt;、&lt;strong&gt;单次&lt;/strong&gt;模式。&lt;/li&gt; &#xA;   &lt;li&gt;可配置有无超时回调函数。&lt;/li&gt; &#xA;   &lt;li&gt;可配置定时器工作在&lt;strong&gt;周期&lt;/strong&gt;或&lt;strong&gt;间隔&lt;/strong&gt;模式。&lt;/li&gt; &#xA;   &lt;li&gt;使用双向链表，超时统一管理，不会因为增加定时器而增加超时判断代码。&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Event&lt;/strong&gt; 事件集 &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;支持动态、静态方式进行事件集的创建与删除。&lt;/li&gt; &#xA;   &lt;li&gt;每个事件最大支持&lt;strong&gt;32&lt;/strong&gt;个标志位。&lt;/li&gt; &#xA;   &lt;li&gt;事件的触发可配置为**“标志与”&lt;strong&gt;和&lt;/strong&gt;“标志或”**。&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;2 、文件目录&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;toolkit&#xA;├── include                         // 包含文件目录&#xA;|   ├── toolkit.h                   // toolkit头文件&#xA;|   └── toolkit_cfg.h               // toolkit配置文件&#xA;├── src                             // toolkit源码目录&#xA;|   ├── tk_queue.c                  // 循环队列源码&#xA;|   ├── tk_timer.c                  // 软件定时器源码&#xA;|   └── tk_event.c                  // 事件集源码&#xA;├── samples                         // 例子&#xA;|   ├── tk_queue_samples.c          // 循环队列使用例程源码&#xA;|   ├── tk_timer_samples.c          // 软件定时器使用例程源码&#xA;|   └── tk_event_samples.c          // 事件集使用例程源码&#xA;└── README.md                       // 说明文档&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;3 、函数定义&lt;/h2&gt; &#xA;&lt;h3&gt;3.1 配置文件&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ToolKit配置项&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;宏定义&lt;/th&gt; &#xA;     &lt;th&gt;描述&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TOOLKIT_USING_ASSERT&lt;/td&gt; &#xA;     &lt;td&gt;ToolKit使用断言功能&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TOOLKIT_USING_QUEUE&lt;/td&gt; &#xA;     &lt;td&gt;ToolKit使用循环队列功能&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TOOLKIT_USING_TIMER&lt;/td&gt; &#xA;     &lt;td&gt;ToolKit使用软件定时器功能&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TOOLKIT_USING_EVENT&lt;/td&gt; &#xA;     &lt;td&gt;ToolKit使用事件集功能&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Queue 循环队列配置项&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;宏定义&lt;/th&gt; &#xA;     &lt;th&gt;描述&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TK_QUEUE_USING_CREATE&lt;/td&gt; &#xA;     &lt;td&gt;Queue 循环队列使用动态创建和删除&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Timer 软件定时器配置项&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;宏定义&lt;/th&gt; &#xA;     &lt;th&gt;描述&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TK_TIMER_USING_CREATE&lt;/td&gt; &#xA;     &lt;td&gt;Timer 软件定时器使用动态创建和删除&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TK_TIMER_USING_INTERVAL&lt;/td&gt; &#xA;     &lt;td&gt;Timer 软件定时器使用间隔模式&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TK_TIMER_USING_TIMEOUT_CALLBACK&lt;/td&gt; &#xA;     &lt;td&gt;Timer 软件定时器使用超时回调函数&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Event 事件集配置项&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;宏定义&lt;/th&gt; &#xA;     &lt;th&gt;描述&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;TK_EVENT_USING_CREATE&lt;/td&gt; &#xA;     &lt;td&gt;Event 事件集使用动态创建和删除&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：当配置&lt;strong&gt;TOOLKIT_USING_ASSERT&lt;/strong&gt;后，所有功能都将会启动参数检查。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;3.2 Queue 循环队列API函数&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;以下为详细API说明及简要示例程序，综合demo可查看&lt;a href=&#34;https://raw.githubusercontent.com/cproape/toolkit/master/samples/tk_queue_samples.c&#34;&gt;tk_queue_samples.c&lt;/a&gt;示例。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;3.2.1 动态创建队列&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当配置&lt;strong&gt;TOOLKIT_USING_QUEUE&lt;/strong&gt;后，才能使用此函数。此函数需要用到&lt;strong&gt;malloc&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct tk_queue *tk_queue_create(uint16_t queue_size, uint16_t max_queues, bool keep_fresh);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue_size&lt;/td&gt; &#xA;   &lt;td&gt;缓存区大小(单位字节)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;max_queues&lt;/td&gt; &#xA;   &lt;td&gt;最大队列个数&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;keep_fresh&lt;/td&gt; &#xA;   &lt;td&gt;是否为保持最新模式，&lt;strong&gt;true&lt;/strong&gt;：保持最新；&lt;strong&gt;false&lt;/strong&gt;：默认(存满不能再存)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;创建的队列对象（&lt;strong&gt;NULL&lt;/strong&gt;为创建失败）&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;队列创建示例：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char *argv[])&#xA;{&#xA;    /* 动态方式创建一个循环队&#34;queue&#34;,缓冲区大小50字节，不保持最新 */&#xA;    struct tk_queue *queue = tk_queue_create(50, 1, false);&#xA;    if( queue == NULL){&#xA;        printf(&#34;队列创建失败!\n&#34;);&#xA;    }&#xA;    /* ... */&#xA;    /* You can add your code under here. */&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;strong&gt;3.2.2&lt;/strong&gt; 动态删除队列&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当配置&lt;strong&gt;TOOLKIT_USING_QUEUE&lt;/strong&gt;后，才能使用此函数。此函数需要用到&lt;strong&gt;free&lt;/strong&gt;。必须为&lt;strong&gt;动态&lt;/strong&gt;方式创建的队列对象。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_delete(struct tk_queue *queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要删除的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：删除成功；&lt;strong&gt;false&lt;/strong&gt;：删除失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;&lt;strong&gt;3.2.3&lt;/strong&gt; 静态初始化队列&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_init(struct tk_queue *queue, void *queuepool, uint16_t pool_size, uint16_t queue_size, bool keep_fresh);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要初始化的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*queuepool&lt;/td&gt; &#xA;   &lt;td&gt;队列缓存区&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;pool_size&lt;/td&gt; &#xA;   &lt;td&gt;缓存区大小(单位字节)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue_size&lt;/td&gt; &#xA;   &lt;td&gt;队列元素大小(单位字节)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;keep_fresh&lt;/td&gt; &#xA;   &lt;td&gt;是否为保持最新模式，&lt;strong&gt;true&lt;/strong&gt;：保持最新；&lt;strong&gt;false&lt;/strong&gt;：默认(存满不能再存)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：初始化成功；&lt;strong&gt;false&lt;/strong&gt;：初始化失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;队列创建示例：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char *argv[])&#xA;{&#xA;    /* 定义一个循环队列 */&#xA;    struct tk_queue queue;&#xA;    /* 定义循环队列缓冲区 */&#xA;    uint8_t queue_pool[100];&#xA;    /* 静态方式创建一个循环队列&#34;queue&#34;,缓存区为queue_pool，大小为queue_pool的大小,模式为保持最新 */&#xA;    if( tk_queue_init(&amp;amp;queue, queue_pool, sizeof(queue_pool), &#xA;                      sizeof(queue_pool[0]), true) == false){&#xA;        printf(&#34;队列创建失败!\n&#34;);&#xA;    }&#xA;    /* ... */&#xA;    /* You can add your code under here. */&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3.2.4 静态脱离队列&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 会使缓存区脱离与队列的关联。必须为&lt;strong&gt;静态&lt;/strong&gt;方式创建的队列对象。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_detach(struct tk_queue *queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要脱离的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：脱离成功；&lt;strong&gt;false&lt;/strong&gt;：脱离失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.5 清空队列&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_clean(struct tk_queue *queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要清空的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：清除成功；&lt;strong&gt;false&lt;/strong&gt;：清除失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.6 判断队列是否为空&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_empty(struct tk_queue *queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要查询的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：空；&lt;strong&gt;false&lt;/strong&gt;：不为空&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.7 判断队列是否已满&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_full(struct tk_queue *queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要查询的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：满；&lt;strong&gt;false&lt;/strong&gt;：不为满&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.8 从队列中读取一个元素(不从队列中删除)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_peep(struct tk_queue *queue, void *pval);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*pval&lt;/td&gt; &#xA;   &lt;td&gt;读取值地址&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：读取成功；&lt;strong&gt;false&lt;/strong&gt;：读取失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.9 移除一个元素&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_remove(struct tk_queue *queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要移除元素的对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：移除成功；&lt;strong&gt;false&lt;/strong&gt;：移除失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.10 向队列压入(入队)1个元素数据&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_push(struct tk_queue *queue, void *val);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要压入的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*val&lt;/td&gt; &#xA;   &lt;td&gt;压入值&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：成功；&lt;strong&gt;false&lt;/strong&gt;：失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.11 从队列弹出(出队)1个元素数据&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_queue_pop(struct tk_queue *queue, void *pval);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要弹出的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*pval&lt;/td&gt; &#xA;   &lt;td&gt;弹出值&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：成功；&lt;strong&gt;false&lt;/strong&gt;：失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.12 查询队列当前数据长度&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;uint16_t tk_queue_curr_len(struct tk_queue *queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要查询的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;队列数据当前长度&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.13 向队列压入(入队)多个元素数据&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;uint16_t tk_queue_push_multi(struct tk_queue *queue, void *pval, uint16_t len);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要压入的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*pval&lt;/td&gt; &#xA;   &lt;td&gt;压入数据首地址&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;len&lt;/td&gt; &#xA;   &lt;td&gt;压入元素个数&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;实际压入个数&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.2.14 从队列弹出(出队)多个元素数据&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;uint16_t tk_queue_pop_multi(struct tk_queue *queue, void *pval, uint16_t len);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;queue&lt;/td&gt; &#xA;   &lt;td&gt;要弹出的队列对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*pval&lt;/td&gt; &#xA;   &lt;td&gt;存放弹出数据的首地址&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;len&lt;/td&gt; &#xA;   &lt;td&gt;希望弹出的数据个数&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;实际弹出个数&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;3.3 Timer 软件定时器API函数&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;以下为详细API说明及简要示例程序，综合demo可查看&lt;a href=&#34;https://raw.githubusercontent.com/cproape/toolkit/master/samples/tk_timer_samples.c&#34;&gt;tk_timer_samples.c&lt;/a&gt;示例。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;3.3.1 软件定时器功能初始化&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：此函数在使用定时器功能最初调用，目的是创建定时器列表头结点，和配置tick获取回调函数。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_func_init(uint32_t (*get_tick_func)(void));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;get_tick_func&lt;/td&gt; &#xA;   &lt;td&gt;获取系统tick回调函数&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：初始化成功；&lt;strong&gt;false&lt;/strong&gt;：初始化失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.2 动态创建定时器&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当配置&lt;strong&gt;TOOLKIT_USING_TIMER&lt;/strong&gt;后，才能使用此函数。此函数需要用到&lt;strong&gt;malloc&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct tk_timer *tk_timer_create(void(*timeout_callback)(struct tk_timer *timer));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timeout_callback&lt;/td&gt; &#xA;   &lt;td&gt;定时器超时回调函数，不使用可配置为NULL&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;创建的定时器对象(&lt;strong&gt;NULL&lt;/strong&gt;为创建失败)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;定时器创建示例：&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* 定义获取系统tick回调函数 */&#xA;uint32_t get_sys_tick(void)&#xA;{&#xA;    return tick;&#xA;}&#xA;&#xA;/* 定时器超时回调函数 */&#xA;void timer_timeout_callback(struct tk_timer *timer)&#xA;{&#xA;    printf(&#34;timeout_callback: timer timeout:%ld\n&#34;, get_sys_tick());&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    /* 初始化软件定时器功能，并配置tick获取回调函数*/&#xA;    tk_timer_func_init(get_sys_tick);&#xA;    &#xA;    /* 定义定时器指针 */&#xA;    tk_timer_t timer = NULL;&#xA;    /* 动态方式创建timer,并配置定时器超时回调函数 */&#xA;    timer = tk_timer_create((tk_timer_timeout_callback *)timer_timeout_callback);&#xA;    if (timer == NULL)&#xA;    {&#xA;        printf(&#34;定时器创建失败!\n&#34;);&#xA;        return 0;&#xA;    }&#xA;    /* ... */&#xA;    /* You can add your code under here. */&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3.3.3 动态删除定时器&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;当配置&lt;strong&gt;TOOLKIT_USING_TIMER&lt;/strong&gt;后，才能使用此函数。此函数需要用到&lt;strong&gt;free&lt;/strong&gt;。必须为&lt;strong&gt;动态&lt;/strong&gt;方式创建的定时器对象。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_delete(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要删除的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：删除成功；&lt;strong&gt;false&lt;/strong&gt;：删除失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.4 静态初始化定时器&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_init(struct tk_timer *timer, void (*timeout_callback)(struct tk_timer *timer));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要初始化的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timeout_callback&lt;/td&gt; &#xA;   &lt;td&gt;定时器超时回调函数，不使用可配置为&lt;strong&gt;NULL&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：创建成功；&lt;strong&gt;false&lt;/strong&gt;：创建失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;队列创建示例：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* 定义获取系统tick回调函数 */&#xA;uint32_t get_sys_tick(void)&#xA;{&#xA;    return tick;&#xA;}&#xA;&#xA;/* 定时器超时回调函数 */&#xA;void timer_timeout_callback(struct tk_timer *timer)&#xA;{&#xA;    printf(&#34;timeout_callback: timer timeout:%ld\n&#34;, get_sys_tick());&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    /* 定义定时器timer */&#xA;    struct tk_timer timer;&#xA;    bool result = tk_timer_init( &amp;amp;timer,(tk_timer_timeout_callback *)timer_timeout_callback);&#xA;    if (result == NULL)&#xA;    {&#xA;        printf(&#34;定时器创建失败!\n&#34;);&#xA;        return 0;&#xA;    }&#xA;    /* ... */&#xA;    /* You can add your code under here. */&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3.3.5 静态脱离定时器&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 会将timer从定时器链表中移除。必须为&lt;strong&gt;静态&lt;/strong&gt;方式创建的定时器对象。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_detach(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要脱离的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：脱离成功；&lt;strong&gt;false&lt;/strong&gt;：脱离失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.6 定时器启动&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_start(struct tk_timer *timer, tk_timer_mode mode, uint32_t delay_tick);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要启动的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;mode&lt;/td&gt; &#xA;   &lt;td&gt;工作模式，&lt;strong&gt;单次：&lt;/strong&gt; &lt;em&gt;TIMER_MODE_SINGLE&lt;/em&gt;；&lt;strong&gt;循环：&lt;/strong&gt; &lt;em&gt;TIMER_MODE_LOOP&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;delay_tick&lt;/td&gt; &#xA;   &lt;td&gt;定时器时长(单位tick)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：启动成功；&lt;strong&gt;false&lt;/strong&gt;：启动失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.7 定时器停止&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_stop(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要停止的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：停止成功；&lt;strong&gt;false&lt;/strong&gt;：停止失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.8 定时器继续&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_continue(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要继续的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：继续成功；&lt;strong&gt;false&lt;/strong&gt;：继续失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.9 定时器重启&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：重启时长为最后一次启动定时器时配置的时长。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_restart(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要重启的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：重启成功；&lt;strong&gt;false&lt;/strong&gt;：重启失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.10 获取定时器模式&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;tk_timer_mode tk_timer_get_mode(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要获取的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;定时器模式&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;定时器模式&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TIMER_MODE_SINGLE&lt;/td&gt; &#xA;   &lt;td&gt;单次模式&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TIMER_MODE_LOOP&lt;/td&gt; &#xA;   &lt;td&gt;循环模式&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.11 获取定时器状态&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;tk_timer_state tk_timer_get_state(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;timer&lt;/td&gt; &#xA;   &lt;td&gt;要获取的定时器对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;定时器状态&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;定时器模式&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TIMER_STATE_RUNNING&lt;/td&gt; &#xA;   &lt;td&gt;运行状态&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TIMER_STATE_STOP&lt;/td&gt; &#xA;   &lt;td&gt;停止状态&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TIMER_STATE_TIMEOUT&lt;/td&gt; &#xA;   &lt;td&gt;超时状态&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.3.12 定时器处理&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_timer_loop_handler(void);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：正常；&lt;strong&gt;false&lt;/strong&gt;：异常，在调用此函数前，未初始化定时器功能“&lt;em&gt;tk_timer_func_init&lt;/em&gt;”&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：tk_timer_loop_handler函数要不断的循环调用。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;3.3.13 超时回调函数&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef void (*timeout_callback)(struct tk_timer *timer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：超时回调函数可定义多个，即一个定时器对应一个回调函数，也可多个定时器对应一个回调函数。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;一对一&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* 定义两个回调函数，对应定时器timer1和timer2 */&#xA;void timer1_timeout_callback(struct tk_timer *timer){&#xA;&#x9;printf(&#34;定时器1超时!\n&#34;);&#xA;}&#xA;void timer2_timeout_callback(struct tk_timer *timer){&#xA;&#x9;printf(&#34;定时器2超时!\n&#34;);&#xA;}&#xA;/* 创建两个定时器,配置单独超时回调函数 */&#xA;timer1 = tk_timer_create((timeout_callback *)timer1_timeout_callback);&#xA;timer2 = tk_timer_create((timeout_callback *)timer2_timeout_callback);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;多对一&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* 定时器timer1和timer2共用一个回调函数，在回调函数做区分 */&#xA;void timer_timeout_callback(struct tk_timer *timer){&#xA;&#x9;if (timer == timer1)&#xA;&#x9;&#x9;printf(&#34;定时器1超时!\n&#34;);&#xA;    else if (timer == timer2)&#xA;        printf(&#34;定时器2超时!\n&#34;);&#xA;}&#xA;/* 创建两个定时器,使用相同的超时回调函数 */&#xA;timer1 = tk_timer_create((timeout_callback *)timer_timeout_callback);&#xA;timer2 = tk_timer_create((timeout_callback *)timer_timeout_callback);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;3.4 Event 事件集API函数&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;以下为详细API说明及简要示例程序，综合demo可查看&lt;a href=&#34;https://raw.githubusercontent.com/cproape/toolkit/master/samples/tk_event_samples.c&#34;&gt;tk_event_samples.c&lt;/a&gt;示例。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;3.4.1 动态创建一个事件&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当配置&lt;strong&gt;TOOLKIT_USING_EVENT&lt;/strong&gt;后，才能使用此函数。此函数需要用到&lt;strong&gt;malloc&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct tk_event *tk_event_create(void);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;创建的事件对象(&lt;strong&gt;NULL&lt;/strong&gt;为创建失败)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.4.2 动态删除一个事件&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;当配置&lt;strong&gt;TOOLKIT_USING_TIMER&lt;/strong&gt;后，才能使用此函数。此函数需要用到&lt;strong&gt;free&lt;/strong&gt;。必须为&lt;strong&gt;动态&lt;/strong&gt;方式创建的事件对象。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_event_delete(struct tk_event *event);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;event&lt;/td&gt; &#xA;   &lt;td&gt;要删除的事件对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：删除成功；&lt;strong&gt;false&lt;/strong&gt;：删除失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.4.3 静态初始化一个事件&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_event_init(struct tk_event *event);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;event&lt;/td&gt; &#xA;   &lt;td&gt;要初始化的事件对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：创建成功；&lt;strong&gt;false&lt;/strong&gt;：创建失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.4.4 发送事件标志&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_event_send(struct tk_event *event, uint32_t event_set);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;event&lt;/td&gt; &#xA;   &lt;td&gt;发送目标事件对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;event_set&lt;/td&gt; &#xA;   &lt;td&gt;事件标志，每个标志占1Bit，发送多个标志可“|”&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：发送成功；&lt;strong&gt;false&lt;/strong&gt;：发送失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;3.4.5 接收事件&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool tk_event_recv(struct tk_event *event, uint32_t event_set, uint8_t option, uint32_t *recved);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;参数&lt;/th&gt; &#xA;   &lt;th&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;event&lt;/td&gt; &#xA;   &lt;td&gt;接收目标事件对象&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;event_set&lt;/td&gt; &#xA;   &lt;td&gt;感兴趣的标志，每个标志占1Bit，多个标志可“|”&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;option&lt;/td&gt; &#xA;   &lt;td&gt;操作，&lt;strong&gt;标志与&lt;/strong&gt;：TK_EVENT_OPTION_AND; &lt;strong&gt;标志或&lt;/strong&gt;：TK_EVENT_OPTION_OR; &lt;strong&gt;清除标志&lt;/strong&gt;:TK_EVENT_OPTION_CLEAR&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;返回值&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;true&lt;/strong&gt;：发送成功；&lt;strong&gt;false&lt;/strong&gt;：发送失败&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>