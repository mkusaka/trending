<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-25T01:35:10Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ehids/ecapture</title>
    <updated>2022-06-25T01:35:10Z</updated>
    <id>tag:github.com,2022-06-25:/ehids/ecapture</id>
    <link href="https://github.com/ehids/ecapture" rel="alternate"></link>
    <summary type="html">&lt;p&gt;capture SSL/TLS text content without CA cert using eBPF. supports Linux x86_64/Aarch64, Android(GKI) Aarch64.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ehids/ecapture/master/images/ecapture-logo-400x400.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ehids/ecapture/master/README_CN.md&#34;&gt;中文介绍&lt;/a&gt; | English&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ehids/ecapture&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/ehids/ecapture.svg?label=Stars&amp;amp;logo=github&#34; alt=&#34;GitHub stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ehids/ecapture&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/forks/ehids/ecapture?label=Forks&amp;amp;logo=github&#34; alt=&#34;GitHub forks&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ehids/ecapture/actions/workflows/code-analysis.yml&#34;&gt;&lt;img src=&#34;https://github.com/ehids/ecapture/actions/workflows/codeql-analysis.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ehids/ecapture/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/ehids/ecapture?display_name=tag&amp;amp;include_prereleases&amp;amp;sort=semver&#34; alt=&#34;Github Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;eCapture(旁观者): capture SSL/TLS text content without CA cert Using eBPF.&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;How eCapture works&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ehids/ecapture/master/images/how-ecapture-works.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SSL/TLS text context capture, support openssl\libressl\boringssl\gnutls\nspr(nss) libraries.&lt;/li&gt; &#xA; &lt;li&gt;bash audit, capture bash command for Host Security Audit.&lt;/li&gt; &#xA; &lt;li&gt;mysql query SQL audit, support mysqld 5.6\5.7\8.0, and mariadDB.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;eCapture Architecture&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ehids/ecapture/master/images/ecapture-architecture.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;eCapture User Manual&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=CoDIjEQCvvA&#34; title=&#34;eCapture User Manual&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ehids/ecapture/master/images/ecapture-user-manual.png&#34; alt=&#34;eCapture User Manual&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Getting started&lt;/h1&gt; &#xA;&lt;h2&gt;use ELF binary file&lt;/h2&gt; &#xA;&lt;p&gt;Download ELF zip file &lt;a href=&#34;https://github.com/ehids/ecapture/releases&#34;&gt;release&lt;/a&gt; , unzip and use by command &lt;code&gt;./ecapture --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux kernel version &amp;gt;= 4.18&lt;/li&gt; &#xA; &lt;li&gt;Enable BTF &lt;a href=&#34;https://www.kernel.org/doc/html/latest/bpf/btf.html&#34;&gt;BPF Type Format (BTF)&lt;/a&gt; (Optional, 2022-04-17)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;check your server BTF config：&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cfc4n@vm-server:~$# uname -r&#xA;4.18.0-305.3.1.el8.x86_64&#xA;cfc4n@vm-server:~$# cat /boot/config-`uname -r` | grep CONFIG_DEBUG_INFO_BTF&#xA;CONFIG_DEBUG_INFO_BTF=y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;tls command&lt;/h3&gt; &#xA;&lt;p&gt;capture tls text context. Step 1:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./ecapture tls --hex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Step 2:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl https://github.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;libressl&amp;amp;boringssl&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# for installed libressl, libssl.so.52 is the dynamic ssl lib&#xA;vm@vm-server:~$ ldd /usr/local/bin/openssl&#xA;&#x9;linux-vdso.so.1 (0x00007ffc82985000)&#xA;&#x9;libssl.so.52 =&amp;gt; /usr/local/lib/libssl.so.52 (0x00007f1730f9f000)&#xA;&#x9;libcrypto.so.49 =&amp;gt; /usr/local/lib/libcrypto.so.49 (0x00007f1730d8a000)&#xA;&#x9;libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1730b62000)&#xA;&#x9;/lib64/ld-linux-x86-64.so.2 (0x00007f17310b2000)&#xA;&#xA;# use the libssl to config the libssl.so path&#xA;vm@vm-server:~$ sudo ./ecapture tls --libssl=&#34;/usr/local/lib/libssl.so.52&#34; --hex&#xA;&#xA;# in another terminal, use the command, then type some string, watch the output of ecapture&#xA;vm@vm-server:~$ /usr/local/bin/openssl s_client -connect github.com:443&#xA;&#xA;# for installed boringssl, usage is the same&#xA;/path/to/bin/bssl s_client -connect github.com:443&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;bash command&lt;/h3&gt; &#xA;&lt;p&gt;capture bash command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ps -ef | grep foo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;What&#39;s eBPF&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ebpf.io&#34;&gt;eBPF&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;uprobe HOOK&lt;/h2&gt; &#xA;&lt;h3&gt;openssl\libressl\boringssl hook&lt;/h3&gt; &#xA;&lt;p&gt;eCapture hook&lt;code&gt;SSL_write&lt;/code&gt; \ &lt;code&gt;SSL_read&lt;/code&gt; function of shared library &lt;code&gt;/lib/x86_64-linux-gnu/libssl.so.1.1&lt;/code&gt;. get text context, and send message to user space by &lt;a href=&#34;https://www.kernel.org/doc/html/latest/bpf/maps.html&#34;&gt;eBPF maps&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Probes: []*manager.Probe{&#xA;    {&#xA;        Section:          &#34;uprobe/SSL_write&#34;,&#xA;        EbpfFuncName:     &#34;probe_entry_SSL_write&#34;,&#xA;        AttachToFuncName: &#34;SSL_write&#34;,&#xA;        //UprobeOffset:     0x386B0,&#xA;        BinaryPath: &#34;/lib/x86_64-linux-gnu/libssl.so.1.1&#34;,&#xA;    },&#xA;    {&#xA;        Section:          &#34;uretprobe/SSL_write&#34;,&#xA;        EbpfFuncName:     &#34;probe_ret_SSL_write&#34;,&#xA;        AttachToFuncName: &#34;SSL_write&#34;,&#xA;        //UprobeOffset:     0x386B0,&#xA;        BinaryPath: &#34;/lib/x86_64-linux-gnu/libssl.so.1.1&#34;,&#xA;    },&#xA;    {&#xA;        Section:          &#34;uprobe/SSL_read&#34;,&#xA;        EbpfFuncName:     &#34;probe_entry_SSL_read&#34;,&#xA;        AttachToFuncName: &#34;SSL_read&#34;,&#xA;        //UprobeOffset:     0x38380,&#xA;        BinaryPath: &#34;/lib/x86_64-linux-gnu/libssl.so.1.1&#34;,&#xA;    },&#xA;    {&#xA;        Section:          &#34;uretprobe/SSL_read&#34;,&#xA;        EbpfFuncName:     &#34;probe_ret_SSL_read&#34;,&#xA;        AttachToFuncName: &#34;SSL_read&#34;,&#xA;        //UprobeOffset:     0x38380,&#xA;        BinaryPath: &#34;/lib/x86_64-linux-gnu/libssl.so.1.1&#34;,&#xA;    },&#xA;    /**/&#xA;},&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;bash readline.so hook&lt;/h3&gt; &#xA;&lt;p&gt;hook &lt;code&gt;/bin/bash&lt;/code&gt; symbol name &lt;code&gt;readline&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;How to compile&lt;/h1&gt; &#xA;&lt;p&gt;Linux Kernel: &amp;gt;= 4.18.&lt;/p&gt; &#xA;&lt;h2&gt;Tools&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;golang 1.16&lt;/li&gt; &#xA; &lt;li&gt;clang 9.0.0&lt;/li&gt; &#xA; &lt;li&gt;cmake 3.18.4&lt;/li&gt; &#xA; &lt;li&gt;clang backend: llvm 9.0.0&lt;/li&gt; &#xA; &lt;li&gt;kernel config:CONFIG_DEBUG_INFO_BTF=y (Optional, 2022-04-17)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;command&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone git@github.com:ehids/ecapture.git&#xA;cd ecapture&#xA;make&#xA;bin/ecapture --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;compile without BTF&lt;/h2&gt; &#xA;&lt;p&gt;eCapture support NO BTF with command &lt;code&gt;make nocore&lt;/code&gt; to compile on 2022/04/17.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make nocore&#xA;bin/ecapture --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/ehids/ecapture/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; for details on submitting patches and the contribution workflow.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>littlefs-project/littlefs</title>
    <updated>2022-06-25T01:35:10Z</updated>
    <id>tag:github.com,2022-06-25:/littlefs-project/littlefs</id>
    <link href="https://github.com/littlefs-project/littlefs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A little fail-safe filesystem designed for microcontrollers&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;littlefs&lt;/h2&gt; &#xA;&lt;p&gt;A little fail-safe filesystem designed for microcontrollers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   | | |     .---._____&#xA;  .-----.   |          |&#xA;--|o    |---| littlefs |&#xA;--|     |---|          |&#xA;  &#39;-----&#39;   &#39;----------&#39;&#xA;   | | |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Power-loss resilience&lt;/strong&gt; - littlefs is designed to handle random power failures. All file operations have strong copy-on-write guarantees and if power is lost the filesystem will fall back to the last known good state.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dynamic wear leveling&lt;/strong&gt; - littlefs is designed with flash in mind, and provides wear leveling over dynamic blocks. Additionally, littlefs can detect bad blocks and work around them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bounded RAM/ROM&lt;/strong&gt; - littlefs is designed to work with a small amount of memory. RAM usage is strictly bounded, which means RAM consumption does not change as the filesystem grows. The filesystem contains no unbounded recursion and dynamic memory is limited to configurable buffers that can be provided statically.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a simple example that updates a file named &lt;code&gt;boot_count&lt;/code&gt; every time main runs. The program can be interrupted at any time without losing track of how many times it has been booted and without corrupting the filesystem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;lfs.h&#34;&#xA;&#xA;// variables used by the filesystem&#xA;lfs_t lfs;&#xA;lfs_file_t file;&#xA;&#xA;// configuration of the filesystem is provided by this struct&#xA;const struct lfs_config cfg = {&#xA;    // block device operations&#xA;    .read  = user_provided_block_device_read,&#xA;    .prog  = user_provided_block_device_prog,&#xA;    .erase = user_provided_block_device_erase,&#xA;    .sync  = user_provided_block_device_sync,&#xA;&#xA;    // block device configuration&#xA;    .read_size = 16,&#xA;    .prog_size = 16,&#xA;    .block_size = 4096,&#xA;    .block_count = 128,&#xA;    .cache_size = 16,&#xA;    .lookahead_size = 16,&#xA;    .block_cycles = 500,&#xA;};&#xA;&#xA;// entry point&#xA;int main(void) {&#xA;    // mount the filesystem&#xA;    int err = lfs_mount(&amp;amp;lfs, &amp;amp;cfg);&#xA;&#xA;    // reformat if we can&#39;t mount the filesystem&#xA;    // this should only happen on the first boot&#xA;    if (err) {&#xA;        lfs_format(&amp;amp;lfs, &amp;amp;cfg);&#xA;        lfs_mount(&amp;amp;lfs, &amp;amp;cfg);&#xA;    }&#xA;&#xA;    // read current count&#xA;    uint32_t boot_count = 0;&#xA;    lfs_file_open(&amp;amp;lfs, &amp;amp;file, &#34;boot_count&#34;, LFS_O_RDWR | LFS_O_CREAT);&#xA;    lfs_file_read(&amp;amp;lfs, &amp;amp;file, &amp;amp;boot_count, sizeof(boot_count));&#xA;&#xA;    // update boot count&#xA;    boot_count += 1;&#xA;    lfs_file_rewind(&amp;amp;lfs, &amp;amp;file);&#xA;    lfs_file_write(&amp;amp;lfs, &amp;amp;file, &amp;amp;boot_count, sizeof(boot_count));&#xA;&#xA;    // remember the storage is not updated until the file is closed successfully&#xA;    lfs_file_close(&amp;amp;lfs, &amp;amp;file);&#xA;&#xA;    // release any resources we were using&#xA;    lfs_unmount(&amp;amp;lfs);&#xA;&#xA;    // print the boot count&#xA;    printf(&#34;boot_count: %d\n&#34;, boot_count);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Detailed documentation (or at least as much detail as is currently available) can be found in the comments in &lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/lfs.h&#34;&gt;lfs.h&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;littlefs takes in a configuration structure that defines how the filesystem operates. The configuration struct provides the filesystem with the block device operations and dimensions, tweakable parameters that tradeoff memory usage for performance, and optional static buffers if the user wants to avoid dynamic memory.&lt;/p&gt; &#xA;&lt;p&gt;The state of the littlefs is stored in the &lt;code&gt;lfs_t&lt;/code&gt; type which is left up to the user to allocate, allowing multiple filesystems to be in use simultaneously. With the &lt;code&gt;lfs_t&lt;/code&gt; and configuration struct, a user can format a block device or mount the filesystem.&lt;/p&gt; &#xA;&lt;p&gt;Once mounted, the littlefs provides a full set of POSIX-like file and directory functions, with the deviation that the allocation of filesystem structures must be provided by the user.&lt;/p&gt; &#xA;&lt;p&gt;All POSIX operations, such as remove and rename, are atomic, even in event of power-loss. Additionally, file updates are not actually committed to the filesystem until sync or close is called on the file.&lt;/p&gt; &#xA;&lt;h2&gt;Other notes&lt;/h2&gt; &#xA;&lt;p&gt;Littlefs is written in C, and specifically should compile with any compiler that conforms to the &lt;code&gt;C99&lt;/code&gt; standard.&lt;/p&gt; &#xA;&lt;p&gt;All littlefs calls have the potential to return a negative error code. The errors can be either one of those found in the &lt;code&gt;enum lfs_error&lt;/code&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/lfs.h&#34;&gt;lfs.h&lt;/a&gt;, or an error returned by the user&#39;s block device operations.&lt;/p&gt; &#xA;&lt;p&gt;In the configuration struct, the &lt;code&gt;prog&lt;/code&gt; and &lt;code&gt;erase&lt;/code&gt; function provided by the user may return a &lt;code&gt;LFS_ERR_CORRUPT&lt;/code&gt; error if the implementation already can detect corrupt blocks. However, the wear leveling does not depend on the return code of these functions, instead all data is read back and checked for integrity.&lt;/p&gt; &#xA;&lt;p&gt;If your storage caches writes, make sure that the provided &lt;code&gt;sync&lt;/code&gt; function flushes all the data to memory and ensures that the next read fetches the data from memory, otherwise data integrity can not be guaranteed. If the &lt;code&gt;write&lt;/code&gt; function does not perform caching, and therefore each &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; call hits the memory, the &lt;code&gt;sync&lt;/code&gt; function can simply return 0.&lt;/p&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;p&gt;At a high level, littlefs is a block based filesystem that uses small logs to store metadata and larger copy-on-write (COW) structures to store file data.&lt;/p&gt; &#xA;&lt;p&gt;In littlefs, these ingredients form a sort of two-layered cake, with the small logs (called metadata pairs) providing fast updates to metadata anywhere on storage, while the COW structures store file data compactly and without any wear amplification cost.&lt;/p&gt; &#xA;&lt;p&gt;Both of these data structures are built out of blocks, which are fed by a common block allocator. By limiting the number of erases allowed on a block per allocation, the allocator provides dynamic wear leveling over the entire filesystem.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;                    root&#xA;                   .--------.--------.&#xA;                   | A&#39;| B&#39;|         |&#xA;                   |   |   |-&amp;gt;       |&#xA;                   |   |   |         |&#xA;                   &#39;--------&#39;--------&#39;&#xA;                .----&#39;   &#39;--------------.&#xA;       A       v                 B       v&#xA;      .--------.--------.       .--------.--------.&#xA;      | C&#39;| D&#39;|         |       | E&#39;|new|         |&#xA;      |   |   |-&amp;gt;       |       |   | E&#39;|-&amp;gt;       |&#xA;      |   |   |         |       |   |   |         |&#xA;      &#39;--------&#39;--------&#39;       &#39;--------&#39;--------&#39;&#xA;      .-&#39;   &#39;--.                  |   &#39;------------------.&#xA;     v          v              .-&#39;                        v&#xA;.--------.  .--------.        v                       .--------.&#xA;|   C    |  |   D    |   .--------.       write       | new E  |&#xA;|        |  |        |   |   E    |        ==&amp;gt;        |        |&#xA;|        |  |        |   |        |                   |        |&#xA;&#39;--------&#39;  &#39;--------&#39;   |        |                   &#39;--------&#39;&#xA;                         &#39;--------&#39;                   .-&#39;    |&#xA;                         .-&#39;    &#39;-.    .-------------|------&#39;&#xA;                        v          v  v              v&#xA;                   .--------.  .--------.       .--------.&#xA;                   |   F    |  |   G    |       | new F  |&#xA;                   |        |  |        |       |        |&#xA;                   |        |  |        |       |        |&#xA;                   &#39;--------&#39;  &#39;--------&#39;       &#39;--------&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More details on how littlefs works can be found in &lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/DESIGN.md&#34;&gt;DESIGN.md&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/SPEC.md&#34;&gt;SPEC.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/DESIGN.md&#34;&gt;DESIGN.md&lt;/a&gt; - A fully detailed dive into how littlefs works. I would suggest reading it as the tradeoffs at work are quite interesting.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/SPEC.md&#34;&gt;SPEC.md&lt;/a&gt; - The on-disk specification of littlefs with all the nitty-gritty details. May be useful for tooling development.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;The littlefs comes with a test suite designed to run on a PC using the &lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/bd/lfs_testbd.h&#34;&gt;emulated block device&lt;/a&gt; found in the &lt;code&gt;bd&lt;/code&gt; directory. The tests assume a Linux environment and can be started with make:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The littlefs is provided under the &lt;a href=&#34;https://spdx.org/licenses/BSD-3-Clause.html&#34;&gt;BSD-3-Clause&lt;/a&gt; license. See &lt;a href=&#34;https://raw.githubusercontent.com/littlefs-project/littlefs/master/LICENSE.md&#34;&gt;LICENSE.md&lt;/a&gt; for more information. Contributions to this project are accepted under the same license.&lt;/p&gt; &#xA;&lt;p&gt;Individual files contain the following tag instead of the full license text.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SPDX-License-Identifier:    BSD-3-Clause&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This enables machine processing of license information based on the SPDX License Identifiers that are here available: &lt;a href=&#34;http://spdx.org/licenses/&#34;&gt;http://spdx.org/licenses/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/geky/littlefs-fuse&#34;&gt;littlefs-fuse&lt;/a&gt; - A &lt;a href=&#34;https://github.com/libfuse/libfuse&#34;&gt;FUSE&lt;/a&gt; wrapper for littlefs. The project allows you to mount littlefs directly on a Linux machine. Can be useful for debugging littlefs if you have an SD card handy.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/geky/littlefs-js&#34;&gt;littlefs-js&lt;/a&gt; - A javascript wrapper for littlefs. I&#39;m not sure why you would want this, but it is handy for demos. You can see it in action &lt;a href=&#34;http://littlefs.geky.net/demo.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://pypi.org/project/littlefs-python/&#34;&gt;littlefs-python&lt;/a&gt; - A Python wrapper for littlefs. The project allows you to create images of the filesystem on your PC. Check if littlefs will fit your needs, create images for a later download to the target memory or inspect the content of a binary image of the target memory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/whitecatboard/Lua-RTOS-ESP32/tree/master/components/mklfs/src&#34;&gt;mklfs&lt;/a&gt; - A command line tool built by the &lt;a href=&#34;https://github.com/whitecatboard/Lua-RTOS-ESP32&#34;&gt;Lua RTOS&lt;/a&gt; guys for making littlefs images from a host PC. Supports Windows, Mac OS, and Linux.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/armmbed/mbed-os&#34;&gt;Mbed OS&lt;/a&gt; - The easiest way to get started with littlefs is to jump into Mbed which already has block device drivers for most forms of embedded storage. littlefs is available in Mbed OS as the &lt;a href=&#34;https://os.mbed.com/docs/mbed-os/v5.12/apis/littlefilesystem.html&#34;&gt;LittleFileSystem&lt;/a&gt; class.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/pellepl/spiffs&#34;&gt;SPIFFS&lt;/a&gt; - Another excellent embedded filesystem for NOR flash. As a more traditional logging filesystem with full static wear-leveling, SPIFFS will likely outperform littlefs on small memories such as the internal flash on microcontrollers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/dlbeer/dhara&#34;&gt;Dhara&lt;/a&gt; - An interesting NAND flash translation layer designed for small MCUs. It offers static wear-leveling and power-resilience with only a fixed &lt;em&gt;O(|address|)&lt;/em&gt; pointer structure stored on each block and in RAM.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>id-Software/DOOM</title>
    <updated>2022-06-25T01:35:10Z</updated>
    <id>tag:github.com,2022-06-25:/id-Software/DOOM</id>
    <link href="https://github.com/id-Software/DOOM" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DOOM Open Source Release&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Here it is, at long last. The DOOM source code is released for your non-profit use. You still need real DOOM data to work with this code. If you don&#39;t actually own a real copy of one of the DOOMs, you should still be able to find them at software stores.&lt;/p&gt; &#xA;&lt;p&gt;Many thanks to Bernd Kreimeier for taking the time to clean up the project and make sure that it actually works. Projects tends to rot if you leave it alone for a few years, and it takes effort for someone to deal with it again.&lt;/p&gt; &#xA;&lt;p&gt;The bad news: this code only compiles and runs on linux. We couldn&#39;t release the dos code because of a copyrighted sound library we used (wow, was that a mistake -- I write my own sound code now), and I honestly don&#39;t even know what happened to the port that microsoft did to windows.&lt;/p&gt; &#xA;&lt;p&gt;Still, the code is quite portable, and it should be straightforward to bring it up on just about any platform.&lt;/p&gt; &#xA;&lt;p&gt;I wrote this code a long, long time ago, and there are plenty of things that seem downright silly in retrospect (using polar coordinates for clipping comes to mind), but overall it should still be a usefull base to experiment and build on.&lt;/p&gt; &#xA;&lt;p&gt;The basic rendering concept -- horizontal and vertical lines of constant Z with fixed light shading per band was dead-on, but the implementation could be improved dramatically from the original code if it were revisited. The way the rendering proceded from walls to floors to sprites could be collapsed into a single front-to-back walk of the bsp tree to collect information, then draw all the contents of a subsector on the way back up the tree. It requires treating floors and ceilings as polygons, rather than just the gaps between walls, and it requires clipping sprite billboards into subsector fragments, but it would be The Right Thing.&lt;/p&gt; &#xA;&lt;p&gt;The movement and line of sight checking against the lines is one of the bigger misses that I look back on. It is messy code that had some failure cases, and there was a vastly simpler (and faster) solution sitting in front of my face. I used the BSP tree for rendering things, but I didn&#39;t realize at the time that it could also be used for environment testing. Replacing the line of sight test with a bsp line clip would be pretty easy. Sweeping volumes for movement gets a bit tougher, and touches on many of the challenges faced in quake / quake2 with edge bevels on polyhedrons.&lt;/p&gt; &#xA;&lt;p&gt;Some project ideas:&lt;/p&gt; &#xA;&lt;p&gt;Port it to your favorite operating system.&lt;/p&gt; &#xA;&lt;p&gt;Add some rendering features -- transparency, look up / down, slopes, etc.&lt;/p&gt; &#xA;&lt;p&gt;Add some game features -- weapons, jumping, ducking, flying, etc.&lt;/p&gt; &#xA;&lt;p&gt;Create a packet server based internet game.&lt;/p&gt; &#xA;&lt;p&gt;Create a client / server based internet game.&lt;/p&gt; &#xA;&lt;p&gt;Do a 3D accelerated version. On modern hardware (fast pentium + 3DFX) you probably wouldn&#39;t even need to be clever -- you could just draw the entire level and get reasonable speed. With a touch of effort, it should easily lock at 60 fps (well, there are some issues with DOOM&#39;s 35 hz timebase...). The biggest issues would probably be the non-power of two texture sizes and the walls composed of multiple textures.&lt;/p&gt; &#xA;&lt;p&gt;I don&#39;t have a real good guess at how many people are going to be playing with this, but if significant projects are undertaken, it would be cool to see a level of community cooperation. I know that most early projects are going to be rough hacks done in isolation, but I would be very pleased to see a coordinated &#39;net release of an improved, backwards compatable version of DOOM on multiple platforms next year.&lt;/p&gt; &#xA;&lt;p&gt;Have fun.&lt;/p&gt; &#xA;&lt;p&gt;John Carmack 12-23-97&lt;/p&gt;</summary>
  </entry>
</feed>