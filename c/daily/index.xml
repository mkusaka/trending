<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-27T01:31:21Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zserge/fenster</title>
    <updated>2023-01-27T01:31:21Z</updated>
    <id>tag:github.com,2023-01-27:/zserge/fenster</id>
    <link href="https://github.com/zserge/fenster" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The most minimal cross-platform GUI library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fenster&lt;/h1&gt; &#xA;&lt;p&gt;Fenster /ˈfɛnstɐ/ -- a German word for &#34;window&#34;.&lt;/p&gt; &#xA;&lt;p&gt;This library provides the most minimal and highly opinionated way to display a cross-platform 2D canvas. If you remember Borland BGI or drawing things in QBASIC or &lt;code&gt;INT 10h&lt;/code&gt;- you know what I mean. As a nice bonus you also get cross-platform keyboard/mouse input and audio playback in only a few lines of code.&lt;/p&gt; &#xA;&lt;h2&gt;What it does for you&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Single application window of given size with a title.&lt;/li&gt; &#xA; &lt;li&gt;Application lifecycle and system events are all handled automatically.&lt;/li&gt; &#xA; &lt;li&gt;Minimal 24-bit RGB framebuffer.&lt;/li&gt; &#xA; &lt;li&gt;Cross-platform keyboard events (keycodes).&lt;/li&gt; &#xA; &lt;li&gt;Cross-platform mouse events (X/Y + mouse click).&lt;/li&gt; &#xA; &lt;li&gt;Cross-platform timers to have a stable FPS rate.&lt;/li&gt; &#xA; &lt;li&gt;Cross-platform audio playback (WinMM, CoreAudio, ALSA).&lt;/li&gt; &#xA; &lt;li&gt;Simple polling API without a need for callbacks or multithreading (like Arduino/Processing).&lt;/li&gt; &#xA; &lt;li&gt;One C99 header of ~300LOC, easy to understand and extend.&lt;/li&gt; &#xA; &lt;li&gt;Go bindings (&lt;code&gt;import &#34;github.com/zserge/fenster&#34;&lt;/code&gt;, see &lt;a href=&#34;https://pkg.go.dev/github.com/zserge/fenster&#34;&gt;godoc&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Zig bindings (see &lt;a href=&#34;https://raw.githubusercontent.com/zserge/fenster/main/examples/minimal-zig&#34;&gt;examples/minimal-zig&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;And, yes, &lt;a href=&#34;https://raw.githubusercontent.com/zserge/fenster/main/examples/doom-c&#34;&gt;it can run Doom&lt;/a&gt;!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s how to draw white noise:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// main.c&#xA;#include &#34;fenster.h&#34;&#xA;#define W 320&#xA;#define H 240&#xA;int main() {&#xA;  uint32_t buf[W * H];&#xA;  struct fenster f = { .title = &#34;hello&#34;, .width = W, .height = H, .buf = buf };&#xA;  fenster_open(&amp;amp;f);&#xA;  while (fenster_loop(&amp;amp;f) == 0) {&#xA;    for (int i = 0; i &amp;lt; W; i++) {&#xA;      for (int j = 0; j &amp;lt; H; j++) {&#xA;        fenster_pixel(&amp;amp;f, i, j) = rand();&#xA;      }&#xA;    }&#xA;  }&#xA;  fenster_close(&amp;amp;f);&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compile it and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Linux&#xA;cc main.c -lX11 -lasound -o main &amp;amp;&amp;amp; ./main&#xA;# macOS&#xA;cc main.c -framework Cocoa -framework AudioToolbox -o main &amp;amp;&amp;amp; ./main&#xA;# windows&#xA;cc main.c -lgdi32 -lwinmm -o main.exe &amp;amp;&amp;amp; main.exe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it.&lt;/p&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;API is designed to be a polling loop, where on every iteration the framebuffer get updated and the user input (mouse/keyboard) can be polled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct fenster {&#xA;  const char *title; /* window title */&#xA;  const int width; /* window width */&#xA;  const int height; /* window height */&#xA;  uint32_t *buf; /* window pixels, 24-bit RGB, row by row, pixel by pixel */&#xA;  int keys[256]; /* keys are mostly ASCII, but arrows are 17..20 */&#xA;  int mod;       /* mod is 4 bits mask, ctrl=1, shift=2, alt=4, meta=8 */&#xA;  int x;         /* mouse X coordinate */&#xA;  int y;         /* mouse Y coordinate */&#xA;  int mouse;     /* 0 = no buttons pressed, 1 = left button pressed */&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;int fenster_open(struct fenster *f)&lt;/code&gt; - opens a new app window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;int fenster_loop(struct fenster *f)&lt;/code&gt; - handles system events and refreshes the canvas. Returns negative values when app window is closed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;void fenster_close(struct fenster *f)&lt;/code&gt; - closes the window and exists the graphical app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;void fenster_sleep(int ms)&lt;/code&gt; - pauses for &lt;code&gt;ms&lt;/code&gt; milliseconds.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;int64_t fenster_time()&lt;/code&gt; - returns current time in milliseconds.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fenster_pixel(f, x, y) = 0xRRGGBB&lt;/code&gt; - set pixel color.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uint32_t px = fenster_pixel(f, x, y);&lt;/code&gt; - get pixel color.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/zserge/fenster/main/examples/drawing-c&#34;&gt;examples/drawing-c&lt;/a&gt; for more old-school drawing primitives, but also feel free to experiment with your own graphical algorithms!&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Code is distributed under MIT license, feel free to use it in your proprietary projects as well.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>GetRektBoy724/DCMB</title>
    <updated>2023-01-27T01:31:21Z</updated>
    <id>tag:github.com,2023-01-27:/GetRektBoy724/DCMB</id>
    <link href="https://github.com/GetRektBoy724/DCMB" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dont Call Me Back - Dynamic kernel callback resolver.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DCMB - Dont Call Me Back&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;&#34;I really want to remove AC/AV/EDR&#39;s kernel callback, but i dont like working with offsets and/or signature&#34;&lt;/em&gt;. Well, not anymore! DCMB will help you to find those callbacks dynamically. DCMB&#39;s objective is to &lt;strong&gt;find&lt;/strong&gt; kernel callback list/array &lt;strong&gt;without&lt;/strong&gt; using signatures or offset &lt;strong&gt;across multiple Windows version&lt;/strong&gt;. This project is not intended to being integrated to your project, instead you should learn the logics thats used on this project. Contributions and bug reports are really appreciated!&lt;/p&gt; &#xA;&lt;h1&gt;Supported Callback&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Process Creation Callback (Returns PspCreateProcessNotifyRoutine array address)&lt;/li&gt; &#xA; &lt;li&gt;Thread Creation Callback (Returns PspCreateThreadNotifyRoutine array address)&lt;/li&gt; &#xA; &lt;li&gt;Image Load Callback (Returns PspLoadImageNotifyRoutine array address)&lt;/li&gt; &#xA; &lt;li&gt;Registry RW Callback (Returns CallbackListHead doubly linked list address)&lt;/li&gt; &#xA; &lt;li&gt;Object Creation Callback (Both Process and Thread object) (Returns PsProcessType&#39;s and PsThreadType&#39;s CallbackList linked list address)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Compile them, enable test signing mode, load it, and view the results through DebugView &lt;img src=&#34;https://user-images.githubusercontent.com/41237415/199712912-c06c8b30-cc43-4da6-b2fd-22fc046f2a74.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>EFeru/hoverboard-firmware-hack-FOC</title>
    <updated>2023-01-27T01:31:21Z</updated>
    <id>tag:github.com,2023-01-27:/EFeru/hoverboard-firmware-hack-FOC</id>
    <link href="https://github.com/EFeru/hoverboard-firmware-hack-FOC" rel="alternate"></link>
    <summary type="html">&lt;p&gt;With Field Oriented Control (FOC)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hoverboard-firmware-hack-FOC&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/EFeru/hoverboard-firmware-hack-FOC/actions/workflows/build_on_commit.yml&#34;&gt;&lt;img src=&#34;https://github.com/EFeru/hoverboard-firmware-hack-FOC/actions/workflows/build_on_commit.yml/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-GPLv3-blue.svg?sanitize=true&#34; alt=&#34;License: GPL v3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;amp;business=CU2SWN2XV9SCY&amp;amp;currency_code=EUR&amp;amp;source=url&#34;&gt;&lt;img src=&#34;https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif&#34; alt=&#34;paypal&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository implements Field Oriented Control (FOC) for stock hoverboards. Compared to the commutation method, this new FOC control method offers superior performance featuring:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;reduced noise and vibrations&lt;/li&gt; &#xA; &lt;li&gt;smooth torque output and improved motor efficiency. Thus, lower energy consumption&lt;/li&gt; &#xA; &lt;li&gt;field weakening to increase maximum speed range&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Wiki:&lt;/strong&gt; please check the wiki pages for &lt;a href=&#34;https://github.com/EFeru/hoverboard-firmware-hack-FOC/wiki#getting-started&#34;&gt;Getting Started&lt;/a&gt; and for &lt;a href=&#34;https://github.com/EFeru/hoverboard-firmware-hack-FOC/wiki#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/#hardware&#34;&gt;Hardware&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/#foc-firmware&#34;&gt;FOC Firmware&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/#example-variants&#34;&gt;Example Variants&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/#projects-and-links&#34;&gt;Projects and Links&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/#contributions&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;The hoverboards with mainboards also come with 2 sideboards(not &lt;a href=&#34;https://github.com/EFeru/hoverboard-firmware-hack-FOC/wiki/Firmware-Compatibility#split-boards&#34;&gt;splitboards&lt;/a&gt;), check the following &lt;a href=&#34;https://github.com/EFeru/hoverboard-firmware-hack-FOC/wiki/Sideboards&#34;&gt;wiki&lt;/a&gt; about this firmware&lt;/h4&gt; &#xA;&lt;h4&gt;For the FOC controller design, see the following repository:&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/EFeru/bldc-motor-control-FOC&#34;&gt;bldc-motor-control-FOC&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Videos:&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/IgHCcj0NgWQ&#34; title=&#34;Hovercar&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/videos_preview/hovercar_intro.png&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/gtyqtc37r10&#34; title=&#34;Cruise Control functionality&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/videos_preview/cruise_control.png&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/jadD0M1VBoc&#34; title=&#34;Hovercar pedal functionality&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/videos_preview/hovercar_pedals.png&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/UnlbMrCkjnE&#34; title=&#34;Commutation vs. FOC (constant speed)&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/videos_preview/com_foc_const.png&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/V-_L2w10wZk&#34; title=&#34;Commutation vs. FOC (variable speed)&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/videos_preview/com_foc_var.png&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/tVj_lpsRirA&#34; title=&#34;Reliable Serial Communication&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/videos_preview/serial_com.png&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Hardware&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/mainboard_pinout.png&#34; alt=&#34;mainboard_pinout&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The original Hardware supports two 4-pin cables that originally were connected to the two sideboards. They break out GND, 12/15V and USART2&amp;amp;3 of the Hoverboard mainboard. Both USART2&amp;amp;3 support UART, PWM, PPM, and iBUS input. Additionally, the USART2 can be used as 12bit ADC, while USART3 can be used for I2C. Note that while USART3 (right sideboard cable) is 5V tolerant, USART2 (left sideboard cable) is &lt;strong&gt;not&lt;/strong&gt; 5V tolerant.&lt;/p&gt; &#xA;&lt;p&gt;Typically, the mainboard brain is an &lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/literature/%5B10%5D_STM32F103xC_datasheet.pdf&#34;&gt;STM32F103RCT6&lt;/a&gt;, however some mainboards feature a &lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/literature/%5B11%5D_GD32F103xx-Datasheet-Rev-2.7.pdf&#34;&gt;GD32F103RCT6&lt;/a&gt; which is also supported by this firmware.&lt;/p&gt; &#xA;&lt;p&gt;For the reverse-engineered schematics of the mainboard, see &lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/20150722_hoverboard_sch.pdf&#34;&gt;20150722_hoverboard_sch.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;FOC Firmware&lt;/h2&gt; &#xA;&lt;p&gt;In this firmware 3 control types are available, it can be set in config.h file via CTRL_TYP_SEL parameter:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Commutation (COM_CTRL)&lt;/li&gt; &#xA; &lt;li&gt;Sinusoidal (SIN_CTRL)&lt;/li&gt; &#xA; &lt;li&gt;Field Oriented Control (FOC_CTRL) with the following 3 control modes that can be set in config.h file with parameter CTRL_MOD_REQ: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;VOLTAGE MODE(VLT_MODE)&lt;/strong&gt;: in this mode the controller applies a constant Voltage to the motors. Recommended for robotics applications or applications where a fast motor response is required.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;SPEED MODE(SPD_MODE)&lt;/strong&gt;: in this mode a closed-loop controller realizes the input speed RPM target by rejecting any of the disturbance (resistive load) applied to the motor. Recommended for robotics applications or constant speed applications.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;TORQUE MODE(TRQ_MODE)&lt;/strong&gt;: in this mode the input torque target is realized. This mode enables motor &#34;freewheeling&#34; when the torque target is &lt;code&gt;0&lt;/code&gt;. Recommended for most applications with a sitting human driver.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Comparison between different control methods&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Control method&lt;/th&gt; &#xA;   &lt;th&gt;Complexity&lt;/th&gt; &#xA;   &lt;th&gt;Efficiency&lt;/th&gt; &#xA;   &lt;th&gt;Smoothness&lt;/th&gt; &#xA;   &lt;th&gt;Field Weakening&lt;/th&gt; &#xA;   &lt;th&gt;Freewheeling&lt;/th&gt; &#xA;   &lt;th&gt;Standstill hold&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Commutation&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;n.a.&lt;/td&gt; &#xA;   &lt;td&gt;n.a.&lt;/td&gt; &#xA;   &lt;td&gt;+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Sinusoidal&lt;/td&gt; &#xA;   &lt;td&gt;+&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;   &lt;td&gt;n.a.&lt;/td&gt; &#xA;   &lt;td&gt;+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FOC VOLTAGE&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;n.a.&lt;/td&gt; &#xA;   &lt;td&gt;+&lt;sup&gt;(2)&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FOC SPEED&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;   &lt;td&gt;+&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;n.a.&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FOC TORQUE&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;/td&gt; &#xA;   &lt;td&gt;++&lt;/td&gt; &#xA;   &lt;td&gt;+++&lt;sup&gt;(1)&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;n.a&lt;sup&gt;(2)&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;(1)&lt;/sup&gt; By enabling &lt;code&gt;ELECTRIC_BRAKE_ENABLE&lt;/code&gt; in &lt;code&gt;config.h&lt;/code&gt;, the freewheeling amount can be adjusted using the &lt;code&gt;ELECTRIC_BRAKE_MAX&lt;/code&gt; parameter.&lt;br&gt; &lt;sup&gt;(2)&lt;/sup&gt; The standstill hold functionality can be forced by enabling &lt;code&gt;STANDSTILL_HOLD_ENABLE&lt;/code&gt; in &lt;code&gt;config.h&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In all FOC control modes, the controller features maximum motor speed and maximum motor current protection. This brings great advantages to fulfil the needs of many robotic applications while maintaining safe operation.&lt;/p&gt; &#xA;&lt;h3&gt;Field Weakening / Phase Advance&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;By default the Field weakening is disabled. You can enable it in config.h file by setting the FIELD_WEAK_ENA = 1&lt;/li&gt; &#xA; &lt;li&gt;The Field Weakening is a linear interpolation from 0 to FIELD_WEAK_MAX or PHASE_ADV_MAX (depeding if FOC or SIN is selected, respectively)&lt;/li&gt; &#xA; &lt;li&gt;The Field Weakening starts engaging at FIELD_WEAK_LO and reaches the maximum value at FIELD_WEAK_HI&lt;/li&gt; &#xA; &lt;li&gt;The figure below shows different possible calibrations for Field Weakening / Phase Advance &lt;img src=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/docs/pictures/FieldWeakening.png&#34; alt=&#34;Field Weakening&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;⚠️ If you re-calibrate the Field Weakening please take all the safety measures! The motors can spin very fast! Power consumption will be highly increase and you can trigger the overvoltage protection of your BMS ⚠️&lt;/p&gt; &#xA;&lt;h3&gt;Parameters&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All the calibratable motor parameters can be found in the &#39;BLDC_controller_data.c&#39;. I provided you with an already calibrated controller, but if you feel like fine tuning it feel free to do so&lt;/li&gt; &#xA; &lt;li&gt;The parameters are represented in Fixed-point data type for a more efficient code execution&lt;/li&gt; &#xA; &lt;li&gt;For calibrating the fixed-point parameters use the &lt;a href=&#34;https://github.com/EFeru/FixedPointViewer&#34;&gt;Fixed-Point Viewer&lt;/a&gt; tool&lt;/li&gt; &#xA; &lt;li&gt;The controller parameters are given in &lt;a href=&#34;https://github.com/EFeru/bldc-motor-control-FOC/raw/master/02_Figures/paramTable.png&#34;&gt;this table&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;FOC Webview&lt;/h3&gt; &#xA;&lt;p&gt;To explore the controller without a Matlab/Simulink installation click on the link below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://eferu.github.io/bldc-motor-control-FOC/&#34;&gt;https://eferu.github.io/bldc-motor-control-FOC/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example Variants&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_ADC&lt;/strong&gt;: The motors are controlled by two potentiometers connected to the Left sensor cable (long wired)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_USART&lt;/strong&gt;: The motors are controlled via serial protocol (e.g. on USART3 right sensor cable, the short wired cable). The commands can be sent from an Arduino. Check out the &lt;a href=&#34;https://raw.githubusercontent.com/EFeru/hoverboard-firmware-hack-FOC/main/Arduino/hoverserial&#34;&gt;hoverserial.ino&lt;/a&gt; as an example sketch.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_NUNCHUK&lt;/strong&gt;: Wii Nunchuk offers one hand control for throttle, braking and steering. This was one of the first input device used for electric armchairs or bottle crates.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_PPM&lt;/strong&gt;: RC remote control with PPM Sum signal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_PWM&lt;/strong&gt;: RC remote control with PWM signal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_IBUS&lt;/strong&gt;: RC remote control with Flysky iBUS protocol connected to the Left sensor cable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_HOVERCAR&lt;/strong&gt;: The motors are controlled by two pedals brake and throttle. Reverse is engaged by double tapping on the brake pedal at standstill. See &lt;a href=&#34;https://github.com/EFeru/hoverboard-firmware-hack-FOC/wiki/Variant-HOVERCAR&#34;&gt;HOVERCAR wiki&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_HOVERBOARD&lt;/strong&gt;: The mainboard reads the two sideboards data. The sideboards need to be flashed with the hacked version. The balancing controller is &lt;strong&gt;not&lt;/strong&gt; yet implemented.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_TRANSPOTTER&lt;/strong&gt;: This is for transpotter build, which is a hoverboard based transportation system. For more details on how to build it check &lt;a href=&#34;https://github.com/NiklasFauth/hoverboard-firmware-hack/wiki/Build-Instruction:-TranspOtter&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://hackaday.io/project/161891-transpotter-ng&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VARIANT_SKATEBOARD&lt;/strong&gt;: This is for skateboard build, controlled using an RC remote with PWM signal connected to the right sensor cable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Of course the firmware can be further customized for other needs or projects.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Projects and Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Original firmware:&lt;/strong&gt; &lt;a href=&#34;https://github.com/lucysrausch/hoverboard-firmware-hack&#34;&gt;https://github.com/lucysrausch/hoverboard-firmware-hack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/Candas1/&#34;&gt;Candas&lt;/a&gt; Hoverboard Web Serial Control:&lt;/strong&gt; &lt;a href=&#34;https://github.com/Candas1/Hoverboard-Web-Serial-Control&#34;&gt;https://github.com/Candas1/Hoverboard-Web-Serial-Control&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/RoboDurden&#34;&gt;RoboDurden&#39;s&lt;/a&gt; online compiler:&lt;/strong&gt; &lt;a href=&#34;https://pionierland.de/hoverhack/&#34;&gt;https://pionierland.de/hoverhack/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hoverboard hack for AT32F403RCT6 mainboards:&lt;/strong&gt; &lt;a href=&#34;https://github.com/cloidnerux/hoverboard-firmware-hack&#34;&gt;https://github.com/cloidnerux/hoverboard-firmware-hack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hoverboard hack for split mainboards:&lt;/strong&gt; &lt;a href=&#34;https://github.com/flo199213/Hoverboard-Firmware-Hack-Gen2&#34;&gt;https://github.com/flo199213/Hoverboard-Firmware-Hack-Gen2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hoverboard hack from BiPropellant:&lt;/strong&gt; &lt;a href=&#34;https://github.com/bipropellant&#34;&gt;https://github.com/bipropellant&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hoverboard breakout boards:&lt;/strong&gt; &lt;a href=&#34;https://github.com/Jana-Marie/hoverboard-breakout&#34;&gt;https://github.com/Jana-Marie/hoverboard-breakout&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;a&gt;&lt;/a&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Bobbycar&lt;/strong&gt; &lt;a href=&#34;https://github.com/larsmm/hoverboard-firmware-hack-FOC-bbcar&#34;&gt;https://github.com/larsmm/hoverboard-firmware-hack-FOC-bbcar&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Wheel chair:&lt;/strong&gt; &lt;a href=&#34;https://github.com/Lahorde/steer_speed_ctrl&#34;&gt;https://github.com/Lahorde/steer_speed_ctrl&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;TranspOtterNG:&lt;/strong&gt; &lt;a href=&#34;https://github.com/Jan--Henrik/transpOtterNG&#34;&gt;https://github.com/Jan--Henrik/transpOtterNG&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hoverboard driver for ROS:&lt;/strong&gt; &lt;a href=&#34;https://github.com/alex-makarov/hoverboard-driver&#34;&gt;https://github.com/alex-makarov/hoverboard-driver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ongoing OneWheel project:&lt;/strong&gt; &lt;a href=&#34;https://forum.esk8.news/t/yet-another-hoverboard-to-onewheel-project/60979/14&#34;&gt;https://forum.esk8.news/t/yet-another-hoverboard-to-onewheel-project/60979/14&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ST Community:&lt;/strong&gt; &lt;a href=&#34;https://community.st.com/s/question/0D50X0000B28qTDSQY/custom-foc-control-current-measurement-dma-timer-interrupt-needs-review&#34;&gt;Custom FOC motor control&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;a&gt;&lt;/a&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Telegram Community:&lt;/strong&gt; If you are an enthusiast join our &lt;a href=&#34;https://t.me/joinchat/BHWO_RKu2LT5ZxEkvUB8uw&#34;&gt;Hooover Telegram Group&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Stargazers&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://starchart.cc/EFeru/hoverboard-firmware-hack-FOC&#34;&gt;&lt;img src=&#34;https://starchart.cc/EFeru/hoverboard-firmware-hack-FOC.svg?sanitize=true&#34; alt=&#34;Stargazers over time&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Every contribution to this repository is highly appreciated! Feel free to create pull requests to improve this firmware as ultimately you are going to help everyone.&lt;/p&gt; &#xA;&lt;p&gt;If you want to donate to keep this firmware updated, please use the link below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;amp;business=CU2SWN2XV9SCY&amp;amp;currency_code=EUR&amp;amp;source=url&#34;&gt;&lt;img src=&#34;https://www.paypalobjects.com/en_US/NL/i/btn/btn_donateCC_LG.gif&#34; alt=&#34;paypal&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt;</summary>
  </entry>
</feed>