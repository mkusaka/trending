<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-06T01:35:26Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>singul4ri7y/promit</title>
    <updated>2022-07-06T01:35:26Z</updated>
    <id>tag:github.com,2022-07-06:/singul4ri7y/promit</id>
    <link href="https://github.com/singul4ri7y/promit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Promit is object oriented, bytecode interpreted, lightweight, elegant and fast programming language designed by a 19 year old.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;Project Promit&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt;A programming language inspired by JavaScript and Python!&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/singul4ri7y/promit/master/#introduction&#34;&gt;Introduction&lt;/a&gt; . &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/singul4ri7y/promit/master/#contribution&#34;&gt;Contribution&lt;/a&gt; . &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/singul4ri7y/promit/master/#why&#34;&gt;Why&lt;/a&gt; . &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/singul4ri7y/promit/master/#install&#34;&gt;Install&lt;/a&gt; . &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/singul4ri7y/promit/master/#build&#34;&gt;Build&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Promit is &lt;b&gt;object oriented&lt;/b&gt;, &lt;b&gt;bytecode interpreted&lt;/b&gt;, &lt;b&gt;lightweight&lt;/b&gt;, &lt;b&gt;elegant&lt;/b&gt; and &lt;b&gt;fast&lt;/b&gt; programming language. It has simple yet &lt;b&gt;aesthetic syntax&lt;/b&gt; and easy, &lt;b&gt;condensed&lt;/b&gt; library which helps to tackle down any modern programs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Key features :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;High-Level Language with dynamically typed syntax.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Take the name as an input string.&#xA;take name = receive(string);&#xA;&#xA;// Now print the name.&#xA;showl &#39;Your name is : $name!&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fast, stack-based bytecode interpreter with rich single-pass compiler.&lt;/li&gt; &#xA; &lt;li&gt;Fully Object Oriented with classes and instances.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;const cities = [ &#39;New York&#39;, &#39;Constantinople&#39;, &#39;Sin City (Vegas)&#39; ];&#xA;&#xA;const class Promit {&#xA;&#x9;const visit(city) {&#xA;&#x9;&#x9;showl &#39;Promit has visited $city!&#39;;&#xA;&#x9;}&#xA;};&#xA;&#xA;take promit = Promit();&#xA;&#xA;cities.foreach(fn(city) {&#xA;&#x9;promit.visit(city);&#xA;});&#xA;&#xA;showl &#34;The variable &#39;promit&#39; is ${typeof promit} and ${promit instof Promit}.&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports inheritance.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class Breakfast {&#xA;&#x9;have() {&#xA;&#x9;&#x9;showl &#34;Dalicious!&#34;;&#xA;&#x9;}&#xA;};&#xA;&#xA;class Soup is Breakfast {&#xA;&#x9;have() {&#xA;&#x9;&#x9;showl &#34;Isn&#39;t having soup for breakfast too odd!&#34;;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;super.have();&#xA;&#x9;}&#xA;};&#xA;&#xA;take breakfast = Soup();&#xA;&#xA;breakfast.have();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automated memory management with a swift Mark-Sweep garbage collector.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;take string = &#34;This is a string! Rest easy!&#34;;&#xA;&#xA;// GC.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Modern string interpolation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;show &#34;Enter two numbers : &#34;;&#xA;&#xA;take a = receive(num), b = receive(num);&#xA;&#xA;showl &#39;Summation of those two numbers is : ${a + b}!&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Minimalist library.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;take dictionary = {&#xA;&#x9;&#39;name&#39;(const)    :  &#39;SD Asif Hossein&#39;,&#xA;&#x9;&#39;age&#39;            :  19,    // Now, yes.&#xA;&#x9;&#39;passion&#39;(const) :  &#39;Programming&#39;&#xA;};&#xA;&#xA;showl &#39;key-value pair is : &#39;;&#xA;&#xA;dictionary.keys()    // Returns a list.&#xA;&#x9;.foreach(fn(key) {&#xA;&#x9;&#x9;showl &#34;$key : ${dictionary[key]}&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Has functions and closures (Yeah, I know you&#39;ve already guessed).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;const fn call() {&#xA;&#x9;take outer = &#34;This is outer!&#34;;&#xA;&#xA;&#x9;// Closure capturing &#39;outer&#39; variable.&#xA;&#x9;return fn() {&#xA;&#x9;&#x9;showl outer;&#xA;&#x9;&#x9;showl &#39;Changing outer variable!&#39;;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;outer = &#34;Now it&#39;s inner!&#34;;&#xA;&#x9;&#xA;&#x9;&#x9;return outer;&#xA;&#x9;}&#xA;}&#xA;&#xA;take result = call();   // Result is actually the returned closure.&#xA;&#xA;showl typeof result;    // Expected &#39;closure&#39;.&#xA;&#xA;showl result();         // Expected &#34;Now it&#39;s inner!&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Has &lt;code&gt;continue&lt;/code&gt; in switch.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;take bird = &#39;Duck&#39;;&#xA;&#xA;switch(bird) {&#xA;&#x9;case &#39;Koel&#39; : {&#xA;&#x9;&#x9;showl &#39;The bird is Koel!&#39;;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#x9;case &#39;Duck&#39; : {&#xA;&#x9;&#x9;showl &#39;The bird is Duck (maybe)!&#39;;&#xA;&#x9;&#x9;continue;    // Code will fallthrough to next case.&#xA;&#x9;&#x9;showl &#39;This portion will not be executed!!&#39;;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#x9;case &#39;Fallthrough&#39; : showl &#39;Fallthrough!&#39;; break;&#xA;&#x9;default : break;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Has loops (&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;do ... while&lt;/code&gt;), control flow (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; and ternary operator &lt;code&gt;condition ? expr : else_expr&lt;/code&gt;) and many more!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;First of all it&#39;s a community project. &lt;b&gt;So, feel free to contribute 😀.&lt;/b&gt; I will try to merge all the pull request I will get related to bug fixes, feature updates and improvements.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Follow the below rules of contribution:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All the codes contributed in this repository must be of MIT license.&lt;/li&gt; &#xA; &lt;li&gt;If you are a contributor, leave your fullname, email and current age (Yes, &lt;code&gt;age&lt;/code&gt;. I want person of any age to contribute to this project and I want to show it to the people, even if you are 8 or 70 year old) in such manners &lt;code&gt;(index) fullname &amp;lt;email&amp;gt; age&lt;/code&gt;. If you do not want to put your age, Use &lt;code&gt;&amp;lt;restricted&amp;gt;&lt;/code&gt; in the age portion like &lt;code&gt;fullname &amp;lt;email&amp;gt; &amp;lt;restricted&amp;gt;&lt;/code&gt;. In the next line, please denote your contribution or designation in one line starting with a tab.&lt;/li&gt; &#xA; &lt;li&gt;Leave full details of your contribution in the commit changes log and in the pull request as well.&lt;/li&gt; &#xA; &lt;li&gt;Try leaving comments, as that helps (Like I&#39;m the one to talk).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;b&gt;&lt;i&gt;Happy contribution.&lt;/i&gt;&lt;/b&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Promit comes with compiled interpreter binary with each release, which you can use to run your programs from the command line. With some tweaking with IDE&#39;s like &lt;b&gt;NetBeans&lt;/b&gt;, &lt;b&gt;VS Code&lt;/b&gt;, &lt;b&gt;Atom&lt;/b&gt; etc. you can integrate the &lt;b&gt;promit&lt;/b&gt; interpreter binary to run programs directly from the IDE.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Supported Platforms:&lt;/strong&gt; Currently Promit only supports &lt;strong&gt;Linux&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt; and in some point &lt;b&gt;*BSD&#39;s&lt;/b&gt;. As I do not have a Mac, I could not test the code in MacOS 😅. So, for that reason, &lt;strong&gt;Promit does not support MacOS and current release won&#39;t be having any MacOS binary&lt;/strong&gt; (Mac users don&#39;t hate me).&lt;/p&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Download binary the releases at:&lt;/strong&gt; &lt;a href=&#34;https://github.com/singul4ri7y/promit/releases&#34;&gt;https://github.com/singul4ri7y/promit/releases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;How to install:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download your specific platform binary. For example, if I am a Windows user, my preference would be &lt;code&gt;promit-&amp;lt;version&amp;gt;-windows-64bit.zip&lt;/code&gt; file for 64 Bit Windows or &lt;code&gt;promit-&amp;lt;version&amp;gt;-windows-32bit.zip&lt;/code&gt; file for 32 Bit Windows (Isn&#39;t 32 bit obsolete?).&lt;/li&gt; &#xA; &lt;li&gt;Extract the archive &lt;code&gt;.tar.gz&lt;/code&gt; for Linux users and &lt;code&gt;.zip&lt;/code&gt; for Windows users.&lt;/li&gt; &#xA; &lt;li&gt;Under the &lt;code&gt;bin/&lt;/code&gt; folder the the Promit Interpreter binary resides. Move it to any location which is in the &lt;strong&gt;system path&lt;/strong&gt; variable. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;For Windows users, my recommendation is create a folder named &lt;code&gt;MyBIN&lt;/code&gt; on the disk your Windows is installed on and add the folder location to system path variable (How to add folder location to system path variable? Well it&#39;s 21&#39;st century. Google it).&lt;/li&gt; &#xA;   &lt;li&gt;For Linux users, you probably already know what to do. My preference is to move the binary to &lt;code&gt;/usr/local/bin&lt;/code&gt; where every user can use it. Or create a new folder to store the binary and add it to system path (Make changes to &lt;code&gt;$PATH&lt;/code&gt; adding your folder location. To make it permanent in do it in the &lt;code&gt;/etc/environment&lt;/code&gt; file).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Now run any Promit program in the terminal or command prompt using &lt;code&gt;promit MyProgram.promit&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;b&gt;&lt;i&gt;Done.&lt;/i&gt;&lt;/b&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/singul4ri7y/promit/master/logos/logo.jpg&#34; type=&#34;image/jpg&#34; align=&#34;right&#34; width=&#34;350&#34;&gt; &#xA;&lt;p align=&#34;justify&#34;&gt;Well the idea is very simple. I started my programming journey as a Web Developer. As I got deeper inside the computer science stuff and programming languages, I reinvented my interests in Low-Level things such as kernel development, memory managements, operating systems, compiler design, etc. At the same time, I got into high school (At the time of writing, I&#39;m 19 BTW). I met a very fascinating person, who is one of my dearest friends named &lt;b&gt;Meraj Hossain Promit&lt;/b&gt;. He was a real inspiration. A lot of thing went through. Long story short, when I was a first year at high school, I promised him that I would make a full-fledged programming language with the honor of his name under age of 20. You can see the rest.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites :&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;gcc&lt;/code&gt; (checked with gcc-10, gcc-11 and gcc-12, any version greater than 6 will do)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make&lt;/code&gt; to run the &lt;code&gt;Makefile&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git&lt;/code&gt; to clone the repo (Optional).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation :&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Arch Linux/Manjaro/Arch Based :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-arch&#34;&gt;pacman --sync git base-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Debian/Ubuntu/Debian Based :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-debian&#34;&gt;apt install git build-essential&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Windows :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The only way is to switch to Linux 😁.&lt;/p&gt; &#xA;&lt;p&gt;Nah, just kidding.&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;code&gt;MinGW-w64&lt;/code&gt;, &lt;code&gt;Cygwin&lt;/code&gt; or &lt;code&gt;TDM GCC&lt;/code&gt; which has &lt;code&gt;make&lt;/code&gt; baked within it.&lt;/p&gt; &#xA;&lt;p&gt;Install git from : &lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;https://git-scm.com/downloads&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;The easy stuff :&lt;/h3&gt; &#xA;&lt;p&gt;Go to any folder, clone the repo and hit &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/singul4ri7y/promit&#xA;cd promit/promit&#xA;make build_release_x64&#xA;cd ../bin/Release-x64/&#xA;./promit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will start Promit&#39;s REPL (Run-Evaluate-Print-Loop) mode. Enjoy the binary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Configurations :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;make&lt;/code&gt; or &lt;code&gt;make build_debug_x64&lt;/code&gt; builds the project in Debug configuration and x64 architecture.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make build_debug_x86&lt;/code&gt; builds the project in Debug configuration and x86 architecture.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make build_release_x64&lt;/code&gt; builds the project in Release configuration and x64 architecture.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make build_release_x86&lt;/code&gt; builds the project in Release configuration and x86 architecture.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;i&gt;Peace.&lt;/i&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>EZLippi/Tinyhttpd</title>
    <updated>2022-07-06T01:35:26Z</updated>
    <id>tag:github.com,2022-07-06:/EZLippi/Tinyhttpd</id>
    <link href="https://github.com/EZLippi/Tinyhttpd" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tinyhttpd 是J. David Blackstone在1999年写的一个不到 500 行的超轻量型 Http Server，用来学习非常不错，可以帮助我们真正理解服务器程序的本质。官网:http://tinyhttpd.sourceforge.net&lt;/p&gt;&lt;hr&gt;&lt;p&gt;A mirror for tinyhttpd(Tinyhttpd非官方镜像,Fork自&lt;a href=&#34;https://sourceforge.net/projects/tiny-httpd/&#34;&gt;sourceForge&lt;/a&gt;,仅供学习)&lt;/p&gt; &#xA;&lt;p&gt;测试CGI时需要本机安装PERL，同时安装perl-cgi&lt;/p&gt; &#xA;&lt;h3&gt;Prepare&lt;/h3&gt; &#xA;&lt;p&gt;Compile for Linux&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; To compile for Linux:&#xA;  1) Comment out the #include &amp;lt;pthread.h&amp;gt; line.&#xA;  2) Comment out the line that defines the variable newthread.&#xA;  3) Comment out the two lines that run pthread_create().&#xA;  4) Uncomment the line that runs accept_request().&#xA;  5) Remove -lsocket from the Makefile.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;每个函数的作用：&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;accept_request: &amp;nbsp;处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;bad_request: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;cat: 读取服务器上某个文件写到 socket 套接字。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;cannot_execute: 主要处理发生在执行 cgi 程序时出现的错误。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;error_die: 把错误信息写到 perror 并退出。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;execute_cgi: 运行 cgi 程序的处理，也是个主要函数。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;headers: 把 HTTP 响应的头部写到套接字。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;not_found: 主要处理找不到请求的文件时的情况。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;sever_file: 调用 cat 把服务器文件返回给浏览器。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;startup: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;unimplemented: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;建议源码阅读顺序： main -&amp;gt; startup -&amp;gt; accept_request -&amp;gt; execute_cgi, 通晓主要工作流程后再仔细把每个函数的源码看一看。&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;h4&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;工作流程&lt;/h4&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;（1） 服务器启动，在指定端口或随机选取端口绑定 httpd 服务。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;（2）收到一个 HTTP 请求时（其实就是 listen 的端口 accpet 的时候），派生一个线程运行 accept_request 函数。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;（3）取出 HTTP 请求中的 method (GET 或 POST) 和 url,。对于 GET 方法，如果有携带参数，则 query_string 指针指向 url 中 ？ 后面的 GET 参数。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;（4） 格式化 url 到 path 数组，表示浏览器请求的服务器文件路径，在 tinyhttpd 中服务器文件是在 htdocs 文件夹下。当 url 以 / 结尾，或 url 是个目录，则默认在 path 中加上 index.html，表示访问主页。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;（5）如果文件路径合法，对于无参数的 GET 请求，直接输出服务器文件到浏览器，即用 HTTP 格式写到套接字上，跳到（10）。其他情况（带参数 GET，POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; （6）读取整个 HTTP 请求并丢弃，如果是 POST 则找出 Content-Length. 把 HTTP 200 &amp;nbsp;状态码写到套接字。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; （7） 建立两个管道，cgi_input 和 cgi_output, 并 fork 一个进程。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; （8） 在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，设置 request_method 的环境变量，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序。&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; （9） 在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。这一部分比较乱，见下图说明：&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20141226173222750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamNqYzkxOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&#34; width=&#34;484&#34; height=&#34;222&#34; alt=&#34;&#34;&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;p&gt;图 1 &amp;nbsp; &amp;nbsp;管道初始状态&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20141226161119981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamNqYzkxOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt; 图 2 &amp;nbsp;管道最终状态&amp;nbsp;&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; （10） 关闭与浏览器的连接，完成了一次 HTTP 请求与回应，因为 HTTP 是无连接的。&lt;/p&gt; &#xA;&lt;p&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;p&gt;以下内容来自源作者:&lt;/p&gt; &#xA;&lt;p&gt;This software is copyright 1999 by J. David Blackstone. Permission is granted to redistribute and modify this software under the terms of the GNU General Public License, available at &lt;a href=&#34;http://www.gnu.org/&#34;&gt;http://www.gnu.org/&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;p&gt;If you use this software or examine the code, I would appreciate knowing and would be overjoyed to hear about it at &lt;a href=&#34;mailto:jdavidb@sourceforge.net&#34;&gt;jdavidb@sourceforge.net&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;p&gt;This software is not production quality. It comes with no warranty of any kind, not even an implied warranty of fitness for a particular purpose. I am not responsible for the damage that will likely result if you use this software on your computer system.&lt;/p&gt; &#xA;&lt;p&gt;I wrote this webserver for an assignment in my networking class in 1999. We were told that at a bare minimum the server had to serve pages, and told that we would get extra credit for doing &#34;extras.&#34; Perl had introduced me to a whole lot of UNIX functionality (I learned sockets and fork from Perl!), and O&#39;Reilly&#39;s lion book on UNIX system calls plus O&#39;Reilly&#39;s books on CGI and writing web clients in Perl got me thinking and I realized I could make my webserver support CGI with little trouble.&lt;/p&gt; &#xA;&lt;p&gt;Now, if you&#39;re a member of the Apache core group, you might not be impressed. But my professor was blown over. Try the color.cgi sample script and type in &#34;chartreuse.&#34; Made me seem smarter than I am, at any rate. :)&lt;/p&gt; &#xA;&lt;p&gt;Apache it&#39;s not. But I do hope that this program is a good educational tool for those interested in http/socket programming, as well as UNIX system calls. (There&#39;s some textbook uses of pipes, environment variables, forks, and so on.)&lt;/p&gt; &#xA;&lt;p&gt;One last thing: if you look at my webserver or (are you out of mind?!?) use it, I would just be overjoyed to hear about it. Please email me. I probably won&#39;t really be releasing major updates, but if I help you learn something, I&#39;d love to know!&lt;/p&gt; &#xA;&lt;p&gt;Happy hacking!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;                               J. David Blackstone&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>skywind3000/kcp</title>
    <updated>2022-07-06T01:35:26Z</updated>
    <id>tag:github.com,2022-07-06:/skywind3000/kcp</id>
    <link href="https://github.com/skywind3000/kcp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;⚡ KCP - A Fast and Reliable ARQ Protocol&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KCP - A Fast and Reliable ARQ Protocol&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp&#34;&gt;&lt;img src=&#34;https://github.com/skywind3000/kcp/raw/master/kcp.svg?sanitize=true&#34; alt=&#34;Powered&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/skywind3000/kcp&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/skywind3000/kcp.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/skywind3000/kcp/master/#backers&#34;&gt;&lt;img src=&#34;https://opencollective.com/kcp/backers/badge.svg?sanitize=true&#34; alt=&#34;Backers on Open Collective&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/skywind3000/kcp/master/#sponsors&#34;&gt;&lt;img src=&#34;https://opencollective.com/kcp/sponsors/badge.svg?sanitize=true&#34; alt=&#34;Sponsors on Open Collective&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/raw/master/README.en.md&#34;&gt;README in English&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;简介&lt;/h1&gt; &#xA;&lt;p&gt;KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。&lt;/p&gt; &#xA;&lt;p&gt;整个协议只有 ikcp.h, ikcp.c两个源文件，可以方便的集成到用户自己的协议栈中。也许你实现了一个P2P，或者某个基于 UDP的协议，而缺乏一套完善的ARQ可靠协议实现，那么简单的拷贝这两个文件到现有项目中，稍微编写两行代码，即可使用。&lt;/p&gt; &#xA;&lt;h1&gt;技术特性&lt;/h1&gt; &#xA;&lt;p&gt;TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果：&lt;/p&gt; &#xA;&lt;h4&gt;RTO翻倍vs不翻倍：&lt;/h4&gt; &#xA;&lt;p&gt;TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。&lt;/p&gt; &#xA;&lt;h4&gt;选择性重传 vs 全部重传：&lt;/h4&gt; &#xA;&lt;p&gt;TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。&lt;/p&gt; &#xA;&lt;h4&gt;快速重传：&lt;/h4&gt; &#xA;&lt;p&gt;发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。&lt;/p&gt; &#xA;&lt;h4&gt;延迟ACK vs 非延迟ACK：&lt;/h4&gt; &#xA;&lt;p&gt;TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。&lt;/p&gt; &#xA;&lt;h4&gt;UNA vs ACK+UNA：&lt;/h4&gt; &#xA;&lt;p&gt;ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。&lt;/p&gt; &#xA;&lt;h4&gt;非退让流控：&lt;/h4&gt; &#xA;&lt;p&gt;KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。&lt;/p&gt; &#xA;&lt;h1&gt;快速安装&lt;/h1&gt; &#xA;&lt;p&gt;您可以使用&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;库管理器下载并安装kcp:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Microsoft/vcpkg.git&#xA;cd vcpkg&#xA;./bootstrap-vcpkg.sh&#xA;./vcpkg integrate install&#xA;./vcpkg install kcp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;vcpkg中的kcp库由Microsoft团队成员和社区贡献者保持最新状态。如果版本过时，请在vcpkg存储库上&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;创建issue或提出PR&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h1&gt;基本使用&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;创建 KCP对象：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 初始化 kcp对象，conv为一个表示会话编号的整数，和tcp的 conv一样，通信双&#xA;// 方需保证 conv相同，相互的数据包才能够被认可，user是一个给回调函数的指针&#xA;ikcpcb *kcp = ikcp_create(conv, user);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;设置回调函数：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// KCP的下层协议输出函数，KCP需要发送数据时会调用它&#xA;// buf/len 表示缓存和长度&#xA;// user指针为 kcp对象创建时传入的值，用于区别多个 KCP对象&#xA;int udp_output(const char *buf, int len, ikcpcb *kcp, void *user)&#xA;{&#xA;  ....&#xA;}&#xA;// 设置回调函数&#xA;kcp-&amp;gt;output = udp_output;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;循环调用 update：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 以一定频率调用 ikcp_update来更新 kcp状态，并且传入当前时钟（毫秒单位）&#xA;// 如 10ms调用一次，或用 ikcp_check确定下次调用 update的时间不必每次调用&#xA;ikcp_update(kcp, millisec);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;输入一个下层数据包：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 收到一个下层数据包（比如UDP包）时需要调用：&#xA;ikcp_input(kcp, received_udp_packet, received_udp_size);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;处理了下层协议的输出/输入后 KCP协议就可以正常工作了，使用 ikcp_send 来向 远端发送数据。而另一端使用 ikcp_recv(kcp, ptr, size)来接收数据。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;协议配置&lt;/h1&gt; &#xA;&lt;p&gt;协议默认模式是一个标准的 ARQ，需要通过配置打开各项加速开关：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;工作模式：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;nodelay ：是否启用 nodelay模式，0不启用；1启用。&lt;/li&gt; &#xA;   &lt;li&gt;interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms&lt;/li&gt; &#xA;   &lt;li&gt;resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）&lt;/li&gt; &#xA;   &lt;li&gt;nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。&lt;/li&gt; &#xA;   &lt;li&gt;普通模式： ikcp_nodelay(kcp, 0, 40, 0, 0);&lt;/li&gt; &#xA;   &lt;li&gt;极速模式： ikcp_nodelay(kcp, 1, 10, 2, 1);&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;最大窗口：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;最大传输单元：&lt;/p&gt; &lt;p&gt;纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;最小RTO：&lt;/p&gt; &lt;p&gt;不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;kcp-&amp;gt;rx_minrto = 10;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;文档索引&lt;/h1&gt; &#xA;&lt;p&gt;协议的使用和配置都是很简单的，大部分情况看完上面的内容基本可以使用了。如果你需要进一步进行精细的控制，比如改变 KCP的内存分配器，或者你需要更有效的大规模调度 KCP链接（比如 3500个以上），或者如何更好的同 TCP结合，那么可以继续延伸阅读：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki&#34;&gt;Wiki Home&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/KCP-Best-Practice&#34;&gt;KCP 最佳实践&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Cooperate-With-Tcp-Server&#34;&gt;同现有TCP服务器集成&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Network-Encryption&#34;&gt;传输数据加密&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Flow-Control-for-Users&#34;&gt;应用层流量控制&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/KCP-Benchmark&#34;&gt;性能评测&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;开源案例&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xtaci/kcptun&#34;&gt;kcptun&lt;/a&gt;: 基于 kcp-go做的高速远程端口转发(隧道) ，配合ssh -D，可以比 shadowsocks 更流畅的看在线视频。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vzex/dog-tunnel&#34;&gt;dog-tunnel&lt;/a&gt;: GO开发的网络隧道，使用 KCP极大的改进了传输速度，并移植了一份 GO版本 KCP&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.v2ray.com&#34;&gt;v2ray&lt;/a&gt;: 著名代理软件，Shadowsocks 代替者，1.17后集成了 kcp协议，使用UDP传输，无数据包特征。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ldcsaa/HP-Socket&#34;&gt;HP-Socket&lt;/a&gt;: 高性能网络通信框架 HP-Socket。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fatedier/frp&#34;&gt;frp&lt;/a&gt;: 高性能内网穿透的反向代理软件，可将将内网服务暴露映射到外网服务器。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/libinzhangyuan/asio_kcp&#34;&gt;asio-kcp&lt;/a&gt;: 使用 KCP的完整 UDP网络库，完整实现了基于 UDP的链接状态管理，会话控制，KCP协议调度等&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hkspirt/kcp-java&#34;&gt;kcp-java&lt;/a&gt;: Java版本 KCP协议实现。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/szhnet/kcp-netty&#34;&gt;kcp-netty&lt;/a&gt;: kcp的Java语言实现，基于netty。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/l42111996/java-Kcp&#34;&gt;java-kcp&lt;/a&gt;: JAVA版本KCP,基于netty实现(包含fec功能)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/l42111996/csharp-kcp&#34;&gt;csharp-kcp&lt;/a&gt;: csharp版本KCP,基于dotNetty实现(包含fec功能)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Unit-X/kcp-cpp&#34;&gt;kcp-cpp&lt;/a&gt;: KCP 的多平台（Windows、MacOS、Linux）C++ 实现作为应用程序中的简单库。包含适用于所有平台的套接字处理和辅助函数。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xtaci/kcp-go&#34;&gt;kcp-go&lt;/a&gt;: 高安全性的kcp的 GO语言实现，包含 UDP会话管理的简单实现，可以作为后续开发的基础库。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/limpo1989/kcp-csharp&#34;&gt;kcp-csharp&lt;/a&gt;: kcp的 csharp移植，同时包含一份回话管理，可以连接上面kcp-go的服务端。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KumoKyaku/KCP&#34;&gt;kcp-csharp&lt;/a&gt;: 新版本 Kcp的 csharp移植。线程安全，运行时无alloc，对gc无压力。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vis2k/kcp2k/&#34;&gt;kcp2k&lt;/a&gt;: Line-by-line translation to C#, with optional Server/Client on top.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/en/kcp-rs&#34;&gt;kcp-rs&lt;/a&gt;: KCP的 rust移植&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Matrix-Zhang/kcp&#34;&gt;kcp-rust&lt;/a&gt;：新版本 KCP的 rust 移植&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Matrix-Zhang/tokio_kcp&#34;&gt;tokio-kcp&lt;/a&gt;：rust tokio 的 kcp 集成&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/b23r0/kcp-rust-native&#34;&gt;kcp-rust-native&lt;/a&gt;：rust 的 kcp bindings&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/linxiaolong/lua-kcp&#34;&gt;lua-kcp&lt;/a&gt;: KCP的 Lua扩展，用于 Lua服务器&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/leenjewel/node-kcp&#34;&gt;node-kcp&lt;/a&gt;: node-js 的 KCP 接口&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyyd/nysocks&#34;&gt;nysocks&lt;/a&gt;: 基于libuv实现的&lt;a href=&#34;https://nodejs.org/api/addons.html&#34;&gt;node-addon&lt;/a&gt;，提供nodejs版本的代理服务，客户端接入支持SOCKS5和ss两种协议&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-android&#34;&gt;shadowsocks-android&lt;/a&gt;: Shadowsocks for android 集成了 kcptun 使用 kcp协议加速 shadowsocks，效果不错&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/elisaday/kcpuv&#34;&gt;kcpuv&lt;/a&gt;: 使用 libuv开发的kcpuv库，目前还在 Demo阶段&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://getlantern.org/&#34;&gt;Lantern&lt;/a&gt;：更好的 VPN，Github 50000 星，使用 kcpgo 加速&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/smallnest/rpcx&#34;&gt;rpcx&lt;/a&gt; ：RPC 框架，1000+ 星，使用 kcpgo 加速 RPC&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/liudf0716/xkcptun&#34;&gt;xkcptun&lt;/a&gt;: c语言实现的kcptun，主要用于&lt;a href=&#34;https://github.com/openwrt/openwrt&#34;&gt;OpenWrt&lt;/a&gt;, &lt;a href=&#34;https://github.com/lede-project/source&#34;&gt;LEDE&lt;/a&gt;开发的路由器项目上&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egametang/ET&#34;&gt;et-frame&lt;/a&gt;: C#前后端框架(前端unity3d)，统一用C#开发游戏，实现了前后端kcp协议&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yasio/yasio&#34;&gt;yasio&lt;/a&gt;: 一个跨平台专注于任意客户端程序的异步socket库, 易于使用，相同的API操作KCP/TCP/UDP, 性能测试结果: &lt;a href=&#34;https://github.com/yasio/yasio/raw/master/benchmark.md&#34;&gt;benchmark-pump&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shaoyuan1943/gouxp&#34;&gt;gouxp&lt;/a&gt;: 用Go实现基于回调方式的KCP开发包，包含加解密和FEC支持，简单易用。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;商业案例&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.taptap.com/app/50664&#34;&gt;明日帝国&lt;/a&gt;：Game K17 的 《明日帝国》 （Google Play），使用 KCP 加速游戏消息，让全球玩家流畅联网&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.taptap.com/app/27242&#34;&gt;仙灵大作战&lt;/a&gt;：4399 的 MOBA游戏，使用 KCP 优化游戏同步&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://cc.163.com/&#34;&gt;CC&lt;/a&gt;：网易 CC 使用 kcp 加速视频推流，有效提高流畅性&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://bobo.163.com/&#34;&gt;BOBO&lt;/a&gt;：网易 BOBO 使用 kcp 加速主播推流&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.yfcloud.com/&#34;&gt;云帆加速&lt;/a&gt;：使用 KCP 加速文件传输和视频推流，优化了台湾主播推流的流畅度&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://improbable.io/spatialOS&#34;&gt;SpatialOS&lt;/a&gt;: 大型多人分布式游戏服务端引擎，BigWorld 的后继者，使用 KCP 加速数据传输。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;欢迎告知更多案例&lt;/p&gt; &#xA;&lt;h1&gt;协议比较&lt;/h1&gt; &#xA;&lt;p&gt;如果网络永远不卡，那 KCP/TCP 表现类似，但是网络本身就是不可靠的，丢包和抖动无法避免（否则还要各种可靠协议干嘛）。在内网这种几乎理想的环境里直接比较，大家都差不多，但是放到公网上，放到3G/4G网络情况下，或者使用内网丢包模拟，差距就很明显了。公网在高峰期有平均接近10%的丢包，wifi/3g/4g下更糟糕，这些都会让传输变卡。&lt;/p&gt; &#xA;&lt;p&gt;感谢 &lt;a href=&#34;https://github.com/libinzhangyuan/asio_kcp&#34;&gt;asio-kcp&lt;/a&gt; 的作者 &lt;a href=&#34;https://github.com/libinzhangyuan&#34;&gt;zhangyuan&lt;/a&gt; 对 KCP 与 enet, udt做过的一次横向评测，结论如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ASIO-KCP &lt;strong&gt;has good performace in wifi and phone network(3G, 4G)&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The kcp is the &lt;strong&gt;first choice for realtime pvp game&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The lag is less than 1 second when network lag happen. &lt;strong&gt;3 times better than enet&lt;/strong&gt; when lag happen.&lt;/li&gt; &#xA; &lt;li&gt;The enet is a good choice if your game allow 2 second lag.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;UDT is a bad idea&lt;/strong&gt;. It always sink into badly situation of more than serval seconds lag. And the recovery is not expected.&lt;/li&gt; &#xA; &lt;li&gt;enet has the problem of lack of doc. And it has lots of functions that you may intrest.&lt;/li&gt; &#xA; &lt;li&gt;kcp&#39;s doc is chinese. Good thing is the function detail which is writen in code is english. And you can use asio_kcp which is a good wrap.&lt;/li&gt; &#xA; &lt;li&gt;The kcp is a simple thing. You will write more code if you want more feature.&lt;/li&gt; &#xA; &lt;li&gt;UDT has a perfect doc. UDT may has more bug than others as I feeling.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;具体见：&lt;a href=&#34;https://github.com/libinzhangyuan/reliable_udp_bench_mark&#34;&gt;横向比较&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/KCP-Benchmark&#34;&gt;评测数据&lt;/a&gt;，为犹豫选择的人提供了更多指引。&lt;/p&gt; &#xA;&lt;p&gt;大型多人游戏服务端引擎 &lt;a href=&#34;https://improbable.io/spatialOS&#34;&gt;SpatialOS&lt;/a&gt; 在集成 KCP 协议后做了同 TCP/RakNet 的评测：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/skywind3000/kcp/raw/master/images/spatialos-50.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;对比了在服务端刷新率为 60 Hz 同时维护 50 个角色时的响应时间，详细对比报告见：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://improbable.io/blog/kcp-a-new-low-latency-secure-network-stack&#34;&gt;Kcp a new low latency secure network stack&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;关于协议&lt;/h1&gt; &#xA;&lt;p&gt;近年来，网络游戏和各类社交网络都在成几何倍数的增长，不管网络游戏还是各类互动社交网络，交互性和复杂度都在迅速提高，都需要在极短的时间内将数据同时投递给大量用户，因此传输技术自然变为未来制约发展的一个重要因素，而开源界里各种著名的传输协议，如 raknet/enet 之类，一发布都是整套协议栈一起发布，这种形式是不利于多样化的，我的项目只能选择用或者不用你，很难选择 “部分用你”，然而你一套协议栈设计的再好，是非常难以满足不同角度的各种需求的。&lt;/p&gt; &#xA;&lt;p&gt;因此 KCP 的方式是把协议栈 “拆开”，让大家可以根据项目需求进行灵活的调整和组装，你可以下面加一层 reed solomon 的纠删码做 FEC，上面加一层类 RC4/Salsa20 做流加密，握手处再设计一套非对称密钥交换，底层 UDP 传输层再做一套动态路由系统，同时探测多条路径，选最好路径进行传输。这些不同的 “协议单元” 可以像搭建积木一般根据需要自由组合，保证 “简单性” 和 “可拆分性”，这样才能灵活适配多变的业务需求，哪个模块不好，换了就是。&lt;/p&gt; &#xA;&lt;p&gt;未来传输方面的解决方案必然是根据使用场景深度定制的，因此给大家一个可以自由组合的 “协议单元” ，方便大家集成在自己的协议栈中。&lt;/p&gt; &#xA;&lt;p&gt;For more information, please see the &lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Success-Stories&#34;&gt;Success Stories&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;关于作者&lt;/h1&gt; &#xA;&lt;p&gt;作者：林伟 (skywind3000)&lt;/p&gt; &#xA;&lt;p&gt;欢迎关注我的：&lt;a href=&#34;https://twitter.com/skywind3000&#34;&gt;twitter&lt;/a&gt; 和 &lt;a href=&#34;https://www.zhihu.com/people/skywind3000&#34;&gt;zhihu&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;我在多年的开发经历中，一直都喜欢研究解决程序中的一些瓶颈问题，早年喜欢游戏开发，照着《VGA编程》来做游戏图形，读 Michael Abrash 的《图形程序开发人员指南》做软渲染器，爱好摆弄一些能够榨干 CPU 能够运行更快的代码，参加工作后，兴趣转移到服务端和网络相关的技术。&lt;/p&gt; &#xA;&lt;p&gt;2007 年时做了几个传统游戏后开始研究快速动作游戏的同步问题，期间写过不少文章，算是国内比较早研究同步问题的人，然而发现不管怎么解决同步都需要在网络传输方面有所突破，后来离开游戏转行互联网后也发现不少领域有这方面的需求，于是开始花时间在网络传输这个领域上，尝试基于 UDP 实现一些保守的可靠协议，仿照 BSD Lite 4.4 的代码实现一些类 TCP 协议，觉得比较有意思，又接着实现一些 P2P 和动态路由网相关的玩具。KCP 协议诞生于 2011 年，基本算是自己传输方面做的几个玩具中的一个。&lt;/p&gt; &#xA;&lt;p&gt;Kcptun 的作者 xtaci 是我的大学同学，我俩都是学通信的，经常在一起研究如何进行传输优化。&lt;/p&gt; &#xA;&lt;h1&gt;欢迎捐赠&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/skywind3000/kcp/master/images/donation.png&#34; alt=&#34;欢迎使用支付宝对该项目进行捐赠&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;欢迎使用支付宝手扫描上面的二维码，对该项目进行捐赠。捐赠款项将用于持续优化 KCP协议以及完善文档。&lt;/p&gt; &#xA;&lt;p&gt;感谢：明明、星仔、进、帆、颁钊、斌铨、晓丹、余争、虎、晟敢、徐玮、王川、赵刚强、胡知锋、万新朝、何新超、刘旸、侯宪辉、吴佩仪、华斌、如涛、胡坚。。。（早先的名单实在不好意思没记录下来）等同学的捐助与支持。&lt;/p&gt; &#xA;&lt;p&gt;欢迎关注&lt;/p&gt; &#xA;&lt;p&gt;KCP交流群：364933586（QQ群号），KCP集成，调优，网络传输以及相关技术讨论&lt;/p&gt; &#xA;&lt;p&gt;Gitter 群：&lt;a href=&#34;https://gitter.im/skywind3000/KCP&#34;&gt;https://gitter.im/skywind3000/KCP&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;blog: &lt;a href=&#34;http://www.skywind.me&#34;&gt;http://www.skywind.me&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;This project exists thanks to all the people who contribute. &lt;a href=&#34;https://github.com/skywind3000/kcp/graphs/contributors&#34;&gt;&lt;img src=&#34;https://opencollective.com/kcp/contributors.svg?width=890&amp;amp;button=false&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>