<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-10T01:31:51Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Octoberfest7/DropSpawn_BOF</title>
    <updated>2023-06-10T01:31:51Z</updated>
    <id>tag:github.com,2023-06-10:/Octoberfest7/DropSpawn_BOF</id>
    <link href="https://github.com/Octoberfest7/DropSpawn_BOF" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CobaltStrike BOF to spawn Beacons using DLL Application Directory Hijacking&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DropSpawn&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;DropSpawn is a CobaltStrike BOF used to spawn additional Beacons via a relatively unknown method of DLL hijacking. Works x86-x86, x64-x64, and x86-x64/vice versa. Use as an alternative to process injection.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dmcxblue.gitbook.io/red-team-notes/persistence/dll-search-order-hijacking&#34;&gt;Windows executables will follow the DLL search order&lt;/a&gt; when trying to load DLL&#39;s whose absolute paths were not specified:&lt;br&gt; &lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/c4251d34-f7ba-45bc-84b4-27536c757324&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;DLL hijacking typically requires that either:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;A.&lt;/strong&gt;&lt;/em&gt; A user has write permissions in a folder with a higher search order precedence than where the real DLL resides&lt;/p&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;B.&lt;/strong&gt;&lt;/em&gt; That the DLL in question doesn&#39;t exist anywhere on the system, in which case it can be placed in a user-writable folder in the user&#39;s %PATH% variable (like %USERPROFILE%\appdata\local\microsoft\windowsapps).&lt;/p&gt; &#xA;&lt;p&gt;These requirements rule out DLL hijacking for executables residing in C:\Windows\System32 because almost all DLL&#39;s that these executables load also reside in System32. Copying a System32 executable to a user-writable location and executing it there is an option, but isn&#39;t very OPSEC safe because System32 binaries running from alternate locations are easy to identify.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;DropSpawn enables DLL hijacking using System32 executables (and others found in additional non-user-writable folders) by spoofing the &#34;The directory from which the application is loaded&#34; to an arbitrary user-specified one.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Note:&lt;/h3&gt; &#xA;&lt;p&gt;The public release of DropSpawn differs slightly from the non-public one. The non-public release leverages a proprietary payload generator, making the experience much more seamless for the operator. The public release has been altered slightly to account for the fact that users will have their own ways of generating DLL hijack compatible payloads. A Python3 script as well as source code for a demonstration DLL have been included to assist users in integrating and weaponizing dropspawn.&lt;/p&gt; &#xA;&lt;h2&gt;How to Use&lt;/h2&gt; &#xA;&lt;h3&gt;1.&lt;/h3&gt; &#xA;&lt;p&gt;Identify some target executables that try to load DLL&#39;s without specifying their absolute paths. You can do this by copying the exe into a user-writable directory and executing it while monitoring it with &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;Procmon&lt;/a&gt;. In this example we&#39;ll use WerFault.exe which normally resides at C:\Windows\System32\WerFault.exe &lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/e4c88036-0018-41d4-88a1-cd429669e39b&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the above example cryptsp.dll, wer.dll, dbghelp.dll, and bcrypt.dll are all viable candidates because their absolute paths were not specified within WerFault; as a result, WerFault will attempt to load them from its application directory first before resorting to the rest of the DLL search order. Note that this typically isn&#39;t a concern because WerFault&#39;s application directory IS System32.&lt;/p&gt; &#xA;&lt;h3&gt;2.&lt;/h3&gt; &#xA;&lt;p&gt;Download one of the hijackable DLL&#39;s from the target system.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/2938bd57-90ff-450f-b82a-0704292f30f7&#34; alt=&#34;image&#34;&gt; This is necessary so that we can extract its exports and include them in our payload DLL. It is important to grab the hijackable DLL from the same machine you wish you use DropSpawn on, as DLL&#39;s change between Windows versions. Additionally, if you are running a x86 beacon and want to spawn an x64 beacon using DropSpawn, make sure you download the x64 version of the real DLL by specifying &#39;C:\windows\sysnative...&#39; instead of &#39;C:\windows\system32...&#39;.&lt;/p&gt; &#xA;&lt;h3&gt;3.&lt;/h3&gt; &#xA;&lt;p&gt;Run generate_dll.py, passing in the downloaded DLL and the desired payload architecture. Generate_dll.py is a modified version of &lt;a href=&#34;https://github.com/tothi/dll-hijack-by-proxying&#34;&gt;this script&lt;/a&gt;. It will parse the supplied DLL, create a .def file containing the DLL&#39;s exports, and call MingW to compile our demonstration payload DLL. When the spawned process tries to call a real function within the spoofed DLL, our payload DLL will forward the call to the real DLL located in System32 so that the host process doesn&#39;t crash. &lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/eb9f10d9-4775-4ea1-8de5-ff6a8ec5ded6&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;4.&lt;/h3&gt; &#xA;&lt;p&gt;Call dropspawn using the generated payload DLL.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;dropspawn &amp;lt;payload DLL&amp;gt; &amp;lt;x86|x64&amp;gt; &amp;lt;program to spawn&amp;gt; [writable target folder] [parent]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;payload DLL&lt;/strong&gt; - the full path to the generated DLL payload.&lt;br&gt; &lt;strong&gt;architecture&lt;/strong&gt; - the architecture of the process you wish to spawn&lt;br&gt; &lt;strong&gt;program to spawn&lt;/strong&gt; - the name/path of the process you wish to spawn. If this process resides in System32(or syswow64), you can just specify the name. Otherwise, specify the full path. You can also supply arguments command line arguments to the process. If there are spaces in the path/if you use arguments, wrap the whole thing in quotes.&lt;br&gt; &lt;strong&gt;writable target folder&lt;/strong&gt; - Optional. If left blank, dropspawn will try to use the Beacon&#39;s current directory. Use quotes if there are spaces in the path.&lt;br&gt; &lt;strong&gt;parent&lt;/strong&gt; - Optional. The name of the process to use for PPID spoofing with the newly spawned process. If a process is specified that has multiple running instances of difference privilege levels (i.e. svchost.exe), dropspawn will try and identify one that can be used for PPID spoofing.&lt;/p&gt; &#xA;&lt;p&gt;Example: dropspawn /root/gitlab/DropSpawn_BOF/dist/dbgcore.dll x64 &#34;WerFault.exe -u -p 4352 -s 160&#34; C:\users\user\appdata\local\temp explorer.exe&lt;/p&gt; &#xA;&lt;p&gt;This will drop the payload DLL &#39;dbgcore.dll&#39; to disk at &#39;c:\users\user\appdata\local\temp\dbgcore.dll&#39; and spawn a x64 WerFault.exe process with the commandline arguments &#39;-u -p 4352 -s 160&#39; and explorer.exe as the parent process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/1d1da108-9603-4bd0-8cff-4f47960a5b8c&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/730bfe59-9808-413c-8e70-9e8f3788f856&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;5.&lt;/h3&gt; &#xA;&lt;p&gt;Cleanup is easy. By including the &lt;a href=&#34;https://github.com/LloydLabs/delete-self-poc&#34;&gt;Self-Deletion&lt;/a&gt; function in the payload DLL that is dropped to disk, it will be deleted as soon as our new process spawns and loads it. This is a game changer, as typically the DLL would be locked on disk so long as our process that loaded it continues to run. If the Self-Deletion technique fails for some reason (or the process fails to spawn), DropSpawn will attempt to delete the payload DLL from disk and will inform the user of the result of the operation either way.&lt;/p&gt; &#xA;&lt;h2&gt;Detection&lt;/h2&gt; &#xA;&lt;p&gt;Process injection typically follows the open remote process -&amp;gt; allocate remote memory -&amp;gt; write remote memory -&amp;gt; execute remote memory chain, with an option to spawn a new process at the beginning instead of using an existing one. DropSpawn only creates a new process; the newly spawned process is responsible for allocating, writing, and executing shellcode, so we can avoid a lot of the IOC&#39;s typically associated with remote process injection.&lt;/p&gt; &#xA;&lt;p&gt;This technique is of course at the mercy of how good your DLL payloads are. But we can take a look at what Windows sees (this next section using the private version of DropSpawn and spawning Beacons).&lt;/p&gt; &#xA;&lt;p&gt;As far as Event Viewer is concerned, everything looks normal: &lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/bf68fd99-b673-470a-8d51-b379ceca4769&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In MDE there is very little to see.&lt;/p&gt; &#xA;&lt;p&gt;Running dropspawn:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/4baa07ff-def4-4aff-a4e9-5b756e3ba6c3&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;MDE Logs:&lt;/p&gt; &#xA;&lt;p&gt;With PPID spoofing:&lt;br&gt; &lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/d10f3ceb-4a75-4826-9b22-8fbf0f53a11b&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Without PPID spoofing: &lt;img src=&#34;https://github.com/Octoberfest7/DropSpawn_BOF/assets/91164728/32b8cd5d-d967-466d-b105-eea04c304b8c&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In both cases we see our original beacon process (also a werfault) drop dbgcore.dll to disk, create a new WerFault.exe process, the newly spawned process loading dbgcore.dll, and then renaming (deleting) it. Critically there is no extra scrutiny of dbgcore.dll that often comes with DLL hijacks because we aren&#39;t writing it to any often hijacked location, and WerFault.exe (or whatever process you choose to use) isn&#39;t really associated with DLL hijacks in the way that things like WmiPrvSE.exe are.&lt;/p&gt; &#xA;&lt;p&gt;Interestingly it is almost more visible to do this with PPID spoofing than without. This may vary depending on the security product however.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;As mentioned, it is essential that users download the real DLL&#39;s from the target machine they plan to use DropSpawn on. Using the wrong version of a DLL can result in the spawned process crashing if it tries to call a function that doesn&#39;t exist.&lt;/p&gt; &#xA;&lt;p&gt;DropSpawn can be used with executables outside System32; be warned however that issues can arise if the process tries to load additional DLL&#39;s from the processes true application directory. Because we have spoofed the application directory elswhere, if the real application directory isn&#39;t also reachable via the DLL search order otherwise, the process will crash/fail to start because it cannot locate essential DLL&#39;s. Always test potential hijacks on development machines before using them in production!&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;This research first came about as I was exploring how processes assemble their final DLL search order (as it must be determined at runtime due to executables residing in different directories, the current directory being part of the search path, etc). My research led me to &lt;a href=&#34;http://www.rohitab.com/discuss/topic/41379-running-native-applications-with-rtlcreateuserprocess/&#34;&gt;this&lt;/a&gt; forum post, which served as the origin of the two critical undocumented API&#39;s that are central to this technique.&lt;/p&gt; &#xA;&lt;p&gt;They are linked earlier already, but &lt;a href=&#34;https://www.netspi.com/blog/technical/adversary-simulation/adaptive-dll-hijacking/&#34;&gt;this post concerning avoiding loader lock&lt;/a&gt;, &lt;a href=&#34;https://github.com/tothi/dll-hijack-by-proxying&#34;&gt;this script for generating a .def file for DLL proxying&lt;/a&gt;, and &lt;a href=&#34;https://github.com/LloydLabs/delete-self-poc&#34;&gt;this research on enabling self-deletion of running executables&lt;/a&gt; are essential to producing effective, weaponized DLL payloads suitable for DropSpawn.&lt;/p&gt; &#xA;&lt;p&gt;When I first published this technique on &lt;a href=&#34;https://twitter.com/Octoberfest73/status/1642165975805050881?s=20&#34;&gt;Twitter&lt;/a&gt;, several others joined the conversation and produced POC&#39;s. &lt;a href=&#34;https://github.com/SecurityAndStuff/DllLoadPath&#34;&gt;SecurityAndStuff produced this one&lt;/a&gt;, while &lt;a href=&#34;https://gist.github.com/snovvcrash/3d5008d7e46d1cc60f0f8bdc8cdb66a5&#34;&gt;Snovvcrash has his here&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>westes/flex</title>
    <updated>2023-06-10T01:31:51Z</updated>
    <id>tag:github.com,2023-06-10:/westes/flex</id>
    <link href="https://github.com/westes/flex" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Fast Lexical Analyzer - scanner generator for lexing in C and C++&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/westes/flex/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/westes/flex/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is flex, the fast lexical analyzer generator.&lt;/p&gt; &#xA;&lt;p&gt;flex is a tool for generating scanners: programs which recognize lexical patterns in text.&lt;/p&gt; &#xA;&lt;p&gt;The flex codebase is kept in &lt;a href=&#34;https://github.com/westes/flex&#34;&gt;Git on GitHub.&lt;/a&gt; Source releases of flex with some intermediate files already built can be found on &lt;a href=&#34;https://github.com/westes/flex/releases&#34;&gt;the github releases page.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use GitHub&#39;s &lt;a href=&#34;https://github.com/westes/flex/issues&#34;&gt;issues&lt;/a&gt; and &lt;a href=&#34;https://github.com/westes/flex&#34;&gt;pull request&lt;/a&gt; features to file bugs and submit patches.&lt;/p&gt; &#xA;&lt;p&gt;There are several mailing lists available as well:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:flex-announce@lists.sourceforge.net&#34;&gt;flex-announce@lists.sourceforge.net&lt;/a&gt; - where posts will be made announcing new releases of flex.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:flex-help@lists.sourceforge.net&#34;&gt;flex-help@lists.sourceforge.net&lt;/a&gt; - where you can post questions about using flex&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:flex-devel@lists.sourceforge.net&#34;&gt;flex-devel@lists.sourceforge.net&lt;/a&gt; - where you can discuss development of flex itself&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Find information on subscribing to the mailing lists or search in the archive at: &lt;a href=&#34;https://sourceforge.net/p/flex/mailman/&#34;&gt;https://sourceforge.net/p/flex/mailman/&lt;/a&gt; Note: Posting is only allowed from addresses that are subscribed to the lists.&lt;/p&gt; &#xA;&lt;p&gt;The flex distribution contains the following files which may be of interest:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;README.md - This file.&lt;/li&gt; &#xA; &lt;li&gt;NEWS - current version number and list of user-visible changes.&lt;/li&gt; &#xA; &lt;li&gt;INSTALL.md - basic installation information.&lt;/li&gt; &#xA; &lt;li&gt;ABOUT-NLS - description of internationalization support in flex.&lt;/li&gt; &#xA; &lt;li&gt;COPYING - flex&#39;s copyright and license.&lt;/li&gt; &#xA; &lt;li&gt;doc/ - user documentation.&lt;/li&gt; &#xA; &lt;li&gt;examples/ - containing examples of some possible flex scanners and a few other things. See the file examples/README for more details.&lt;/li&gt; &#xA; &lt;li&gt;tests/ - regression tests. See tests/README for details.&lt;/li&gt; &#xA; &lt;li&gt;po/ - internationalization support files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;This file is part of flex.&lt;/p&gt; &#xA;&lt;p&gt;This code is derived from software contributed to Berkeley by Vern Paxson.&lt;/p&gt; &#xA;&lt;p&gt;The United States Government has rights in this work pursuant to contract no. DE-AC03-76SF00098 between the United States Department of Energy and the University of California.&lt;/p&gt; &#xA;&lt;p&gt;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.&lt;/li&gt; &#xA; &lt;li&gt;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Neither the name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.&lt;/p&gt; &#xA;&lt;p&gt;THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.&lt;/p&gt;</summary>
  </entry>
</feed>