<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-23T01:30:02Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>plasma-umass/coz</title>
    <updated>2024-04-23T01:30:02Z</updated>
    <id>tag:github.com,2024-04-23:/plasma-umass/coz</id>
    <link href="https://github.com/plasma-umass/coz" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Coz: Causal Profiling&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Coz: Finding Code that Counts with Causal Profiling&lt;/h1&gt; &#xA;&lt;p&gt;by &lt;a href=&#34;https://curtsinger.cs.grinnell.edu/&#34;&gt;Charlie Curtsinger&lt;/a&gt; and &lt;a href=&#34;https://emeryberger.com&#34;&gt;Emery Berger&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/coz&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/d/coz?logo=rust&amp;amp;link=https%3A%2F%2Fcrates.io%2Fcrates%2Fcoz&#34; alt=&#34;Rust Crate downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Coz is a profiler for native code (C/C++/Rust) that unlocks optimization opportunities missed by traditional profilers. Coz employs a novel technique called &lt;em&gt;causal profiling&lt;/em&gt; that measures optimization potential. It predicts what the impact of optimizing code will have on overall throughput or latency.&lt;/p&gt; &#xA;&lt;p&gt;Profiles generated by Coz show the &#34;bang for buck&#34; of optimizing a line of code in an application. In the below profile, almost every effort to optimize the performance of this line of code directly leads to an increase in overall performance, making it an excellent candidate for optimization efforts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/plasma-umass/coz/raw/master/example-coz-output.png&#34; alt=&#34;Example Coz profile&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Coz&#39;s measurement matches developers&#39; assumptions about profilers: that optimizing highly-ranked code will have the greatest impact on performance. Causal profiling measures optimization potential for serial, parallel, and asynchronous programs without instrumentation of special handling for library calls and concurrency primitives. Instead, a causal profiler uses performance experiments to predict the effect of optimizations. This allows the profiler to establish causality: &#34;optimizing function X will have effect Y,&#34; exactly the measurement developers had assumed they were getting all along.&lt;/p&gt; &#xA;&lt;p&gt;Full details of Coz are available in our paper, &lt;a href=&#34;http://arxiv.org/pdf/1608.03676v1.pdf&#34;&gt;Coz: Finding Code that Counts with Causal Profiling (pdf)&lt;/a&gt;, SOSP 2015, October 2015 (recipient of a Best Paper Award).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=jE0V-p1odPg&amp;amp;t=0m28s&#34; title=&#34;Coz presentation at SOSP&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/jE0V-p1odPg/0.jpg&#34; alt=&#34;Coz presentation at SOSP&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;On Debian and Ubuntu, you can install Coz via apt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt install coz-profiler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An OpenSUSE package was prepared by user &lt;a href=&#34;https://github.com/zethra&#34;&gt;@zethra&lt;/a&gt; and is available at &lt;a href=&#34;https://build.opensuse.org/package/show/home:zethra/coz-profiler&#34;&gt;https://build.opensuse.org/package/show/home:zethra/coz-profiler&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Coz should work on any modern Linux system (specifically, running version 2.6.32 or later, with support for the &lt;code&gt;perf_event_open&lt;/code&gt; system call) with a Python 3.x interpreter.&lt;/p&gt; &#xA;&lt;h2&gt;Libraries/Wrappers&lt;/h2&gt; &#xA;&lt;p&gt;By default, Coz works for C, C++, and Rust programs. It has been ported or has wrappers for several other languages, listed below:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Language&lt;/th&gt; &#xA;   &lt;th&gt;Link&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Java&lt;/td&gt; &#xA;   &lt;td&gt;JCoz: &lt;a href=&#34;https://github.com/Decave/JCoz&#34;&gt;https://github.com/Decave/JCoz&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Go&lt;/td&gt; &#xA;   &lt;td&gt;Cozgo: &lt;a href=&#34;https://github.com/urjitbhatia/cozgo&#34;&gt;https://github.com/urjitbhatia/cozgo&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Swift&lt;/td&gt; &#xA;   &lt;td&gt;Swift Coz: &lt;a href=&#34;https://github.com/funcmike/swift-coz&#34;&gt;https://github.com/funcmike/swift-coz&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Building Coz From Source&lt;/h2&gt; &#xA;&lt;p&gt;To build Coz from source, you will need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A copy of the source code for this project&lt;/li&gt; &#xA; &lt;li&gt;A compiler with C++0x support (clang++ or g++)&lt;/li&gt; &#xA; &lt;li&gt;A Python interpreter (Python 3.x is required)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;OPTIONAL&lt;/em&gt;: for building the profiler viewer, you need NodeJS and npm -- &lt;code&gt;sudo apt-get install nodejs npm&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once you have all dependencies in place, build Coz with CMake. On Debian-based distributions, the following commands should take care of the entire process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get update&#xA;sudo apt-get install libdwarf-dev&#xA;sudo apt-get install build-essential cmake docutils-common git python3 pkg-config&#xA;git clone https://github.com/antoyo/libelfin &amp;amp;&amp;amp; cd libelfin &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install &amp;amp;&amp;amp; cd ..&#xA;git clone https://github.com/plasma-umass/coz &amp;amp;&amp;amp; cd coz &amp;amp;&amp;amp; cmake . &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install &amp;amp;&amp;amp; cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, you need to change the &#34;perf_event_paranoia&#34; level so Coz can run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo sh -c &#39;echo 1 &amp;gt;/proc/sys/kernel/perf_event_paranoid&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can test Coz. Build the benchmark suite and run one of the benchmarks (the SQLite3 benchmark takes a while to build).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install libbz2-dev libsqlite3-dev&#xA;cd coz/benchmarks &amp;amp;&amp;amp; cmake . &amp;amp;&amp;amp; make &amp;amp;&amp;amp; cd ../..&#xA;coz run --- ./coz/benchmarks/toy/toy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, use the Coz viewer to see the results. This command will open up a browser tab, from which you will need to load the file &lt;code&gt;profile.coz&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;coz plot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are on a remote system, you can open the Coz viewer in your browser: &lt;a href=&#34;https://plasma-umass.github.io/coz&#34;&gt;https://plasma-umass.github.io/coz&lt;/a&gt; and then load the file &lt;code&gt;profile.coz&lt;/code&gt;, which you will have to transfer to your local machine.&lt;/p&gt; &#xA;&lt;p&gt;(You may need to move the &#34;Minimum Points&#34; slider on the left side to see the results.)&lt;/p&gt; &#xA;&lt;h2&gt;Using Coz&lt;/h2&gt; &#xA;&lt;p&gt;Using Coz requires a small amount of setup, but you can jump ahead to the section on the included &lt;a href=&#34;https://raw.githubusercontent.com/plasma-umass/coz/master/#sample-applications&#34;&gt;sample applications&lt;/a&gt; in this repository if you want to try Coz right away.&lt;/p&gt; &#xA;&lt;p&gt;To run your program with Coz, you will need to build it with debug information (&lt;code&gt;-g -gdwarf-3&lt;/code&gt;). You do not need to include debug symbols in the main executable: coz uses the same procedure as &lt;code&gt;gdb&lt;/code&gt; to locate debug information for stripped binaries.&lt;/p&gt; &#xA;&lt;p&gt;Once you have your program built with debug information, you can run it with Coz using the command &lt;code&gt;coz run {coz options} --- {program name and arguments}&lt;/code&gt;. But, to produce a useful profile you need to decide which part(s) of the application you want to speed up by specifying one or more progress points.&lt;/p&gt; &#xA;&lt;h3&gt;Profiling Modes&lt;/h3&gt; &#xA;&lt;p&gt;Coz departs from conventional profiling by making it possible to view the effect of optimizations on both throughput and latency. To profile throughput, you must specify a progress point. To profile latency, you must specify a pair of progress points.&lt;/p&gt; &#xA;&lt;h4&gt;Throughput Profiling: Specifying Progress Points&lt;/h4&gt; &#xA;&lt;p&gt;To profile throughput you must indicate a line in the code that corresponds to the end of a unit of work. For example, a progress point could be the point at which a transaction concludes, when a web page finishes rendering, or when a query completes. Coz then measures the rate of visits to each progress point to determine any potential optimization&#39;s effect on throughput.&lt;/p&gt; &#xA;&lt;p&gt;To place a progress point, include &lt;code&gt;coz.h&lt;/code&gt; (under the &lt;code&gt;include&lt;/code&gt; directory in this repository) and add the &lt;code&gt;COZ_PROGRESS&lt;/code&gt; macro to at least one line you would like to execute more frequently. Don&#39;t forget to link your program with libdl: use the &lt;code&gt;-ldl&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;By default, Coz uses the source file and line number as the name for your progress points. If you use &lt;code&gt;COZ_PROGRESS_NAMED(&#34;name for progress point&#34;)&lt;/code&gt; instead, you can provide an informative name for your progress points. This also allows you to mark multiple source locations that correspond to the same progress point.&lt;/p&gt; &#xA;&lt;h4&gt;Latency Profiling: Specifying Progress Points&lt;/h4&gt; &#xA;&lt;p&gt;To profile latency, you must place two progress points that correspond to the start and end of an event of interest, such as when a transaction begins and completes. Simply mark the beginning of a transaction with the &lt;code&gt;COZ_BEGIN(&#34;transaction name&#34;)&lt;/code&gt; macro, and the end with the &lt;code&gt;COZ_END(&#34;transaction name&#34;)&lt;/code&gt; macro. Unlike regular progress points, you always need to specify a name for your latency progress points. Don&#39;t forget to link your program with libdl: use the &lt;code&gt;-ldl&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;When coz tests a hypothetical optimization it will report the effect of that optimization on the average latency between these two points. Coz can track this information without any knowledge of individual transactions thanks to &lt;a href=&#34;https://en.wikipedia.org/wiki/Little%27s_law&#34;&gt;Little&#39;s Law&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Specifying Progress Points on the Command Line&lt;/h3&gt; &#xA;&lt;p&gt;Coz has command line options to specify progress points when profiling the application instead of modifying its source. This feature is currently disabled because it did not work particularly well. Adding support for better command line-specified progress points is planned in the near future.&lt;/p&gt; &#xA;&lt;h2&gt;Processing Results&lt;/h2&gt; &#xA;&lt;p&gt;To plot profile results, go to &lt;a href=&#34;http://plasma-umass.github.io/coz/&#34;&gt;http://plasma-umass.github.io/coz/&lt;/a&gt; and load your profile. This page also includes several sample profiles from PARSEC benchmarks.&lt;/p&gt; &#xA;&lt;h2&gt;Sample Applications&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;benchmarks&lt;/code&gt; directory in this repository includes several small benchmarks with progress points added at appropriate locations. To build and run one of these benchmarks with &lt;code&gt;coz&lt;/code&gt;, just browse to &lt;code&gt;benchmarks/{bench name}&lt;/code&gt; and type &lt;code&gt;cmake . &amp;amp;&amp;amp; make&lt;/code&gt;. These programs may require several runs before coz has enough measurements to generate a useful profile. Once you have profiled these programs for several minutes, go to &lt;a href=&#34;http://plasma-umass.github.io/coz/&#34;&gt;http://plasma-umass.github.io/coz/&lt;/a&gt; to load and plot your profile.&lt;/p&gt; &#xA;&lt;h2&gt;CMake&lt;/h2&gt; &#xA;&lt;p&gt;When you install coz it installs a cmake config file. To add coz to a cmake project simply use the command &lt;code&gt;find_package(coz-profiler)&lt;/code&gt;. This will import a target for the library and includes called &lt;code&gt;coz::coz&lt;/code&gt; and a target for the coz binary &lt;code&gt;coz::profiler&lt;/code&gt;. For guidance on how to use these targets refer to the CMake documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;Coz currently does not support interpreted or JIT-compiled languages such as Python, Ruby, or JavaScript. Interpreted languages will likely not be supported at any point, but support for JIT-compiled languages that produce debug information could be added in the future.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;All source code is licensed under the BSD 2-clause license unless otherwise indicated. See LICENSE.md for details.&lt;/p&gt; &#xA;&lt;p&gt;Sample applications (in the &lt;code&gt;benchmarks&lt;/code&gt; directory) include several &lt;a href=&#34;https://github.com/kozyraki/phoenix&#34;&gt;Phoenix&lt;/a&gt; programs and &lt;a href=&#34;http://compression.ca/pbzip2/&#34;&gt;pbzip2&lt;/a&gt;, which are licensed separately and included with this release for convenience.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>wareya/DIY-Gaming-Mouse</title>
    <updated>2024-04-23T01:30:02Z</updated>
    <id>tag:github.com,2024-04-23:/wareya/DIY-Gaming-Mouse</id>
    <link href="https://github.com/wareya/DIY-Gaming-Mouse" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Completely open source DIY gaming mouse, including hardware (PCB, shell) design files&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DIY Gaming Mouse&lt;/h1&gt; &#xA;&lt;p&gt;Video about why and how I made this, and what the various iterations were like: &lt;a href=&#34;https://www.youtube.com/watch?v=h-Cdl4Vq9H4&#34;&gt;https://www.youtube.com/watch?v=h-Cdl4Vq9H4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains the code, schematic, PCB layout, and 3d model for a completely DIY gaming mouse, all designed around a Pixart PMW3360 sensor.&lt;/p&gt; &#xA;&lt;p&gt;The firmware for this mouse uses a special debouncing algorithm that completely eliminates chatter without adding ANY latency, and eliminates bounce better than commercial mice do. Random double-clicks be gone!&lt;/p&gt; &#xA;&lt;p&gt;None of the companies that make gaming mouse sensors sell them to consumers, including Pixart, so the sensor needs to be salvaged (or bought from a scalper, or a small business that specializes in reselling them).&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/b0d7f284-dda6-4e33-833e-19e7270b6a2f&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/ba9f6bce-50b7-4b4e-8d83-0501b01e5e16&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; opened mouse &lt;/td&gt; &#xA;   &lt;td&gt; assembled mouse &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;(The shell has a top, too, but it&#39;s turned off in this picture so you can see the PCB.)&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;True zero-latency button debouncing with no glitching&lt;/li&gt; &#xA; &lt;li&gt;Buttons that will not develop double-clicking problems after only a few months&lt;/li&gt; &#xA; &lt;li&gt;Low-latency motion tracking (no smoothing)&lt;/li&gt; &#xA; &lt;li&gt;Completely open source (Apache 2.0 license)&lt;/li&gt; &#xA; &lt;li&gt;Even the hardware is open source! (except the processor and sensor)&lt;/li&gt; &#xA; &lt;li&gt;Ultra light-weight shell and assembly (55g in total)&lt;/li&gt; &#xA; &lt;li&gt;Fingertip-grip shell shape&lt;/li&gt; &#xA; &lt;li&gt;Extra middle mouse button&lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the button that normally controls DPI on other mice is mapped to M3&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;PCB exposes extra unused pins from the rp2040 as test pads for hardware/firmware modding fun; attach your own sensors! or LEDs! whatever you want!&lt;/li&gt; &#xA; &lt;li&gt;Full 1000hz tracking&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;TODO:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configurable DPI (currently hardcoded at 1200)&lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;To change it in the firmware code, edit the &lt;code&gt;spi_write(REG_CONFIG1, 11); // 1200 dpi&lt;/code&gt; line, replacing 11 with your dpi divided by 100 minus 1, e.g. 7 for 800 dpi, 3 for 400, 15 for 1600, etc&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;rebinding, macros, etc&lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;can already be hardcoded atm if you&#39;re skilled at programming&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&#34;fun&#34; optional features like WMO-style diagonal jaggy removal or optional in-firmware acceleration, anti-smoothing (prediction), angle snapping, cinematic smoothing, etc&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Required skills&lt;/h2&gt; &#xA;&lt;p&gt;You need to be familiar with, or be able to learn quickly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;3d printing&lt;/li&gt; &#xA; &lt;li&gt;how to use a &#34;slicer&#34; (e.g. Cura) to convert stl models to gcode (what your 3d printer uses)&lt;/li&gt; &#xA; &lt;li&gt;repeatedly making test prints&lt;/li&gt; &#xA; &lt;li&gt;how to clean up 3d prints and remove support material from fragile prints&lt;/li&gt; &#xA; &lt;li&gt;basic firmware code debugging skills&lt;/li&gt; &#xA; &lt;li&gt;the ability to read embedded C/C++ code&lt;/li&gt; &#xA; &lt;li&gt;the Arduino IDE (I use 2.x, not 1.x)&lt;/li&gt; &#xA; &lt;li&gt;desoldering (with a hot air rework station)&lt;/li&gt; &#xA; &lt;li&gt;soldering (with a soldering iron)&lt;/li&gt; &#xA; &lt;li&gt;soldering bodge wires to existing pieces of hardware without creating solder bridges (for SROM extraction)&lt;/li&gt; &#xA; &lt;li&gt;comfort using a hot air rework station to soften and fix misshapen parts on 3d printed objects if they print improperly&lt;/li&gt; &#xA; &lt;li&gt;the ability to do all of the above without wasting tons of money or burning your home down&lt;/li&gt; &#xA; &lt;li&gt;familiarity with PCB printing companies and PCB assembly manufacturers (JLCPCB, PCBWay, etc)&lt;/li&gt; &#xA; &lt;li&gt;patience&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you cannot do all of the above, you should have someone else build this project for you, rather than building it for yourself. Or, at the very least, I can&#39;t give you support if you don&#39;t have the skills needed to make this; I&#39;m just some random guy.&lt;/p&gt; &#xA;&lt;p&gt;You also need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;access to a 3d printer that you can repeatedly print test prints on until they come out right&lt;/li&gt; &#xA; &lt;li&gt;a hot air rework station with temperature and air flow rate control&lt;/li&gt; &#xA; &lt;li&gt;a soldering iron with temperature control&lt;/li&gt; &#xA; &lt;li&gt;hot glue device (for securing the USB cable, nothing else)&lt;/li&gt; &#xA; &lt;li&gt;various small tools like screwdrivers, tweezers, cleanup blades / deburring tools, etc. for various parts of the building process&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;h3&gt;3D printing the shell&lt;/h3&gt; &#xA;&lt;p&gt;This assumes you&#39;re using a filament printer. Resin printers might work too, but I have never used one.&lt;/p&gt; &#xA;&lt;p&gt;I print with PLA filament.&lt;/p&gt; &#xA;&lt;p&gt;Print each of the STL files in the &#34;Case Model&#34; directory in their natural (not default!) orientations. To repeat, some of the models have to be rotated; they&#39;re saved in the orientation they have in the mouse, not the orientation they need to have on the 3d printer&#39;s build plate.&lt;/p&gt; &#xA;&lt;p&gt;You need to convert the stl files to gcode yourself and run various test prints because each 3d printer and filament has different requirements for layer thickness, support cutoff angle, printing speed, z seam alignment placement, etc.&lt;/p&gt; &#xA;&lt;p&gt;Cura will complain about certain pieces (like the shell bottom) not being &#34;water tight&#34;, but it&#39;s wrong; the watertightness check doesn&#39;t handle multiple overlapping solids properly. The models will still slice correctly and without glitches.&lt;/p&gt; &#xA;&lt;p&gt;The thumb pieces must be rotated into the orientation where they do not need any supports. This means the small part of the thumb piece is facing up, and the long part of the switch clamp section is on the bottom.&lt;/p&gt; &#xA;&lt;p&gt;The scroll wheel must be rotated so that the thick cylinder part is on the bottom and the thin pin part is on the top. It must be printed with supports; any type of support is fine. It should be printed at 100% speed or lower, not higher, until it gets to the pin, at which point you MUST reduce the printing speed as low as you can tolerate. On my printer, a Sovol SV06, I had to turn it down to 25% speed. If your printer doesn&#39;t allow you to change the speed mid-print, you have to print at the low speed for the entire print. This is important; you have to print it slowly, because otherwise, the pin will be misaligned with itself and the scroll wheel will be off-balance and hit the middle mouse button switch with different pressures depending on where it is in its spin cycle.&lt;/p&gt; &#xA;&lt;p&gt;Print the scroll wheel brace as-is.&lt;/p&gt; &#xA;&lt;p&gt;Print the shell bottom as-is.&lt;/p&gt; &#xA;&lt;p&gt;Print the shell top with tree supports and a support cutoff angle between 60 and 70 degrees. Do not use &#34;standard&#34;/traditional/grid supports; they will be too difficult to remove, and you will probably damage the print trying to remove them. On my printer, a Sovol SV06, 67 degrees was just right. If you have poor print quality, you might need to reduce the cutoff angle down to something silly like 50 degrees. If you have to go below 50 degrees, get a better printer, or make sure you&#39;re using the right filament at the right temperature, etc.&lt;/p&gt; &#xA;&lt;p&gt;Once the shell top is printed, you need to use a deburring tool (or other hard, sharp metal implement) to remove a small amount of material from a certain curved edge along the seam where it meets the shell bottom, on the right side of the shell (with the button pieces away from you and the &#34;butt&#34; part towards you). The shell will fit together without removing a small amount of material from this part of the shell top, but it&#39;ll be misaligned by around a quarter of a millimeter and the right click won&#39;t quite work right. This material has to be removed because it sags during printing, and it sags during printing because of how support bridging works; the 3d model itself is correct.&lt;/p&gt; &#xA;&lt;p&gt;You should print each part one-by-one and check for errors each time.&lt;/p&gt; &#xA;&lt;p&gt;The final result will be somewhat rough and rugged, but it&#39;s a functional mouse shell.&lt;/p&gt; &#xA;&lt;h3&gt;SROM preparation&lt;/h3&gt; &#xA;&lt;p&gt;Note: The SROM is optional, but highly recommended because it contains sensor firmware bugfixes. If you can&#39;t get it, comment out the call to &lt;code&gt;srom_upload();&lt;/code&gt; in &lt;code&gt;pmw3360_boot()&lt;/code&gt;, and then rename the &lt;code&gt;.h&lt;/code&gt; file inclusion to &lt;code&gt;#include &#34;srom_dummy_blank.h&#34;&lt;/code&gt;, but be warned that your mouse might experience glitchy behavior like &#34;spinout&#34; or have generally poor tracking. For example, while writing this and testing the firmware without an SROM, I click-and-dragged a title bar on a window, and then the mouse cursor teleported 300~400 pixels to the right for no reason.&lt;/p&gt; &#xA;&lt;p&gt;The SROM needs to be captured from an existing mouse because it&#39;s copyrighted. Give it the name &lt;code&gt;srom_3360_0x03.h&lt;/code&gt;, &lt;code&gt;srom_3360_0x04.h&lt;/code&gt;, or &lt;code&gt;srom_3360_0x05.h&lt;/code&gt;, depending on what version it is. I poked around github and found other projects using the 3360 SROM, and this seems to be the way they decided to name their SROM header files, so I&#39;m copying the filename from them.&lt;/p&gt; &#xA;&lt;p&gt;Once you have the SROM, edit the &lt;code&gt;#include &#34;srom_3360_0x05.h&#34;&lt;/code&gt; line in &lt;code&gt;3360_Mouse_pico.ino&lt;/code&gt; to point to the file for your SROM.&lt;/p&gt; &#xA;&lt;p&gt;The below is instructions on how to capture the SROM from a commercial mouse.&lt;/p&gt; &#xA;&lt;p&gt;Capture the SROM from a commercial 3360 mouse with this code, and a standalone raspberry pi pico (not this mouse&#39;s custom PCB): &lt;a href=&#34;https://gist.github.com/wareya/0dc3498bd80be93c47b6f79aa9164321&#34;&gt;https://gist.github.com/wareya/0dc3498bd80be93c47b6f79aa9164321&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note: the above SROM capturing code requires you to use the &#34;arduino-pico&#34; board type in the Arduino IDE. But the firmware in this repostory requires you to use the &#34;mbed OS&#34; rp2040 board type.&lt;/p&gt; &#xA;&lt;p&gt;Use a breadboard to make a ripping setup equivalent to that depicted in the following image:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/19571f49-33f4-4286-96d8-effffb80b110&#34; alt=&#34;EspAlvz&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Be very careful not to create any solder bridges between any of the pins on the 3360.&lt;/p&gt; &#xA;&lt;p&gt;Reconnect the mouse so that it reboots and sends the SROM to the sensor again.&lt;/p&gt; &#xA;&lt;p&gt;The output should be exactly 4094 bytes long, and the second byte should be 0x03, 0x04, or 0x05 (different versions).&lt;/p&gt; &#xA;&lt;p&gt;Repeat the capturing process until you get the same SROM several times, just to make sure that it captured properly. To capture the SROM again, you need to reboot the mouse. This can be plugging it in to your computer again, or disconnecting and reconnecting its USB power wire, or any safe method you prefer.&lt;/p&gt; &#xA;&lt;p&gt;The MD5 checksums of the versions of the SROM that I know about are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0x03 - C64F2BDA742DD1623D6A5DC869FC5E60&#xA;0x04 - 0BCB410858FF21D091DDC497D19BC943&#xA;0x05 - 337254C54AD82C689D4B9A58D06A3CF6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have an SROM with a different version number, it might not work with this firmware. It might, but it also might not. I can&#39;t provide support for other SROM versions.&lt;/p&gt; &#xA;&lt;p&gt;After capturing the SROM data, save it in a formatted .h file formatted as such:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&#xA;#define SROM_LENGTH (4094)&#xA;&#xA;const uint8_t PROGMEM srom[SROM_LENGTH] =&#xA;{&#xA;0x01,&#xA;0x&amp;lt;version number&amp;gt;,&#xA;// ...&#xA;// etc&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I cannot distribute the SROM in this repository, because it&#39;s copyrighted proprietary code.&lt;/p&gt; &#xA;&lt;p&gt;Disclaimer: The above steps do not bypass any copy protection, no encryption is being broken, and copyright law is not being violated by making your own backup copy of the sensor&#39;s SROM and using it on your own device. This is fully legal in reasonable countries (like the US).&lt;/p&gt; &#xA;&lt;h3&gt;PMW 3360 sensor salvage&lt;/h3&gt; &#xA;&lt;p&gt;The Pixart PMW3360 is not sold commercially to hobbyists or small repair shops; to get one, you have to either buy an expensive breakout board, buy it from scalpers on aliexpress (or similar), or salvage it from an existing commercial mouse. This project assumes that you&#39;re salvaging it from an existing commercial mouse, after capturing the SROM from that mouse.&lt;/p&gt; &#xA;&lt;p&gt;You need a hot air rework station, NOT a soldering iron, to desolder and salvage the 3360 safely. If you try to use a soldering iron, even with desoldering wick and/or a desoldering pump, you are VERY likely to fail to salvage it, damaging the pins or sensor internals in the process. The 3360 is somewhat sensitive to high temperatures, so you can only heat it up for a fairly short amount of time, and desoldering the ground pin with a soldering iron will get the sensor hot enough that it might start to damage it.&lt;/p&gt; &#xA;&lt;p&gt;The 3360 sensor&#39;s lens is usually directly mounted to the sensor by melting its clear mounting pins down onto the top of the sensor&#39;s IC package.&lt;/p&gt; &#xA;&lt;p&gt;Take the commercial mouse&#39;s PCB, scrape off (don&#39;t break off) the top melted part of the lens&#39;s mounting posts. Then, being careful not to damage anything, remove the lens from the sensor and PCB and put it somewhere safe.&lt;/p&gt; &#xA;&lt;p&gt;Now, put the commercial mouse&#39;s PCB upside down on a non-flammable surface, in a workspace free of any flammable material. I cannot be held responsible if you start a fire in an unsafe workspace. You have been warned!&lt;/p&gt; &#xA;&lt;p&gt;Before continuing, you might want to cover the bottom of the sensor with paper and/or tape to prevent anything from getting inside of it. If you do this, do it in a way that doesn&#39;t create a fire hazard.&lt;/p&gt; &#xA;&lt;p&gt;Find the bottom of the sensor&#39;s pins. To each of these pins, apply a small amount of either leaded solder (if it&#39;s all you have) or low-temperature non-leaded solder paste/gel/etc (preferred) (NOT the same thing as flux!). You want to mix your solder into the existing solder on the pins because this will lower the melting temperature of the existing solder and make it easier to desolder the chip. Use a soldering iron or hot air tool at around 600F/300C to make the two types of solder mix together. Do not physically touch the PCB or pins with the hot air tool; rely only on the air itself.&lt;/p&gt; &#xA;&lt;p&gt;Once the solder for each pin is mixed together, pass the hot air tool over each section of pins in a circular motion until the sensor eventually, finally comes loose. At this point, use any metal tool (like metal tweezers or a screw driver) to make sure the sensor fully comes out of the PCB.&lt;/p&gt; &#xA;&lt;p&gt;Now, use a soldering iron to clean any excess remaining solder off of the pins. If the soldering iron ends up with too much solder on it, clean it off with brass/bronze wool or similar. Be warned that, at very high temperatures, brass wool is flammable. Do not use steel wool as a subtitute, as it is even more flammable.&lt;/p&gt; &#xA;&lt;h3&gt;PCB building and assembly&lt;/h3&gt; &#xA;&lt;p&gt;Build gerber files and drill files and all the other necessary files (BOM, pick and place, etc) that your PCB manufacturer needs to print &lt;strong&gt;and assemble&lt;/strong&gt; the PCB. Some of the components on the PCB are very, very delicate, so unless you&#39;re a genuine expert, trying to hand-solder them is doomed.&lt;/p&gt; &#xA;&lt;p&gt;Once you have your PCBs, you need the following parts to manually solder to the board:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;6 Omron D2F-01F switches (or compatible, e.g. D2FC)&lt;/li&gt; &#xA; &lt;li&gt;11mm Alps-compatible scroll wheel encoder&lt;/li&gt; &#xA; &lt;li&gt;salvaged PMW 3360 sensor, undamaged, pins not bent&lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;3360 sensor&#39;s lens, with mounting posts still intact&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Four dupont-compatible header pins for connecting to USB cable (optional)&lt;/li&gt; &#xA; &lt;li&gt;spare discrete resistors in case you messed up any of the resistor values when ordering the PCB like I did&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And the following additional parts for assembly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;USB cable, ideally with dupont-compatible connectors (you can crimp them on yourself, you don&#39;t have to buy a special cable for this)&lt;/li&gt; &#xA; &lt;li&gt;3d printed shell (2 parts)&lt;/li&gt; &#xA; &lt;li&gt;3d printed side buttons (2 parts)&lt;/li&gt; &#xA; &lt;li&gt;3d printed scroll wheel brace (1 part)&lt;/li&gt; &#xA; &lt;li&gt;3d printed scroll wheel OR salvaged scroll wheel for 11mm Alps-compatible scroll wheel encoder with the right middle-mouse-button shaft thickness&lt;/li&gt; &#xA; &lt;li&gt;mouse feet (salvaged or custom) with approximately 0.6mm thickness (that&#39;s zero-point-six millimeters)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The mouse feet thickness is very important, within a quarter of a millimeter! Using any other thickness of mouse feet is likely to result in poor, glitchy tracking. The PMW3360 is VERY sensitive to VERY small changes in tracking distance.&lt;/p&gt; &#xA;&lt;p&gt;Make sure you have screws the right size to screw everything together. I recommend doing a test-fit of the shell and plain PCB with screws before doing anything else. Be careful not to overtighten the side screws; doing so can cause their mounting holes to split. The PCB is held down with two screws and the case is held together with three screws. I used salvaged screws with a major diameter (outside edge of threads) of 2mm and a minor diameter of around 1.65~1.7mm, and the holes on the case were designed around these screws, but slightly different screws will still work.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/2df3f1eb-3b81-4f22-a2cc-522cd9e09db8&#34; alt=&#34;PPRKHyR&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Solder the dupont-compatible header pins to the PCB, or if you have a different plan to connect the PCB to USB, do that instead. Then, connect it to your computer and make sure you can program it with the Arduino IDE. If it doesn&#39;t work, try a different copy of the PCB. Don&#39;t continue until you know that the PCB and its rp2040 processor are working properly. You should also do a test-fit of the PCB inside the 3d printed shell bottom to make sure nothing went wrong in 3d printing, and that the edge cuts and drill holes on the PCB are accurate to how they were specified in the design files.&lt;/p&gt; &#xA;&lt;p&gt;Solder each Omron switch to the board with the plungers aligned with the outline on the silkscreen illustration. Check and double check that the switches are fully flush with the board before and while you solder them; double check that they&#39;re flush after soldering the first pin.&lt;/p&gt; &#xA;&lt;p&gt;Test fit the PCB into the shell bottom, and without screwing anything into anything else, attach the top half of the shell and make sure that the buttons can be clicked properly and aren&#39;t clicked just by attaching the top half of the shell. If they&#39;re hard to click or they click themselves, your 3d printer has poor tolerances, and you may need to adjust the button pieces by softening them with the hot air tool and bending them slightly until they fit just right. Once you&#39;re done here, remove the PCB from the shell.&lt;/p&gt; &#xA;&lt;p&gt;Solder the scroll wheel encoder in into the RotaryEncoder footprint on the PCB. Be very sure that it&#39;s all the way down before and while soldering it. You may need to twist the pins very slightly with a pair of needle-nose pliers to get them to fit into their holes; the holes are very narrow, on purpose, to reduce the chance of solder bridges forming between them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/30d91764-0442-48c3-8c1d-a2128166a1b8&#34; alt=&#34;firefox_2024-04-07_00-51-23&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;(Example photo of a 11mm Alps-compatible encoder. 11mm is the distance between the center of the rotor and the surface of the PCB, not the top to bottom of the entire encoder.)&lt;/p&gt; &#xA;&lt;p&gt;Solder the PMW3360 sensor to the center of the PCB, making VERY, VERY sure that it&#39;s in ALL THE WAY before and while soldering it. If it&#39;s not in all the way, the PCB may not fit properly in the shell, and/or the sensor may fail to track properly. The sensor must be mounted &#34;upside-down&#34; relative to the rest of the board, such that the text on it is upside-down compared to the text at the top of the board. If you put the sensor in the wrong way, it will look uncentered; if you put it in the right way (upside-down), it will look centered. If you get the wrong, the sensor might fry itself when you turn the mouse on, and the lens might not even fit against the sensor through the PCB.&lt;/p&gt; &#xA;&lt;p&gt;Attach the lens to the sensor on the underside of the PCB. Then, slot the PCB into the bottom shell and make sure it fully fits all the way down.&lt;/p&gt; &#xA;&lt;p&gt;If, at this point, you connect the mouse to USB again and check what it says in the Arduino IDE&#39;s &#34;Serial Logger&#34; when the mouse boots, and the SROM&#39;s ID is a value other than zero or 0xFF, the sensor is working properly. If it&#39;s working properly but still doesn&#39;t track, double check the value of the LED resistor; that&#39;s the component closest to the &#34;U10&#34; silkscreen text, also near four diodes arranged in a rectangle (not in a row). The resistor value should be 39 ohms, or something very close like 40. If the resistor value is wrong, you have to desolder it and bodge on 40 ohms worth of discrete resistors (I personally use two 20 ohm resistors in series). WARNING: Using too few ohms will permanently damage the sensor&#39;s LED and make the sensor useless.&lt;/p&gt; &#xA;&lt;p&gt;Remove the PCB and fit the side button thumb pieces to their switches. This is difficult and should feel like you&#39;re almost going to break the thumb pieces, but not like you&#39;re definitely going to break them. The long piece of the switch brace should wrap around the &#34;inside&#34; of the switches (towards the other side button switch), not the &#34;outside&#34;. To get the thumb pieces around the switches, first fit the &#34;hook&#34; to the bottom around the edge of the PCB, slightly offset from the switch, and rotate the thumb piece down so that the far end of its brace hits the top of the switch. Move it as far from the switch as you comfortably can, so that it doesn&#39;t have to bend too much to slide down past the top and around the other side of the switch. Once that happens, slide it towards the switch so that the small hook piece at the end of the brace fully wraps around the other corner of the switch. Repeat this for the other switch&#39;s thumb piece.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/a08bd5af-7435-46e2-8b38-3d783ea6fb01&#34; alt=&#34;firefox_2024-04-08_01-20-12&#34;&gt; &lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/86bda439-689d-4ce7-8297-1052b1211e62&#34; alt=&#34;firefox_2024-04-08_01-20-14&#34;&gt; &lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/78926e60-1c9f-456a-991d-6e4c54f80c34&#34; alt=&#34;firefox_2024-04-08_01-20-17&#34;&gt; &lt;img src=&#34;https://github.com/wareya/DIY-Gaming-Mouse/assets/585488/ea0520ec-fe53-4e1a-b1d2-67a40bf0a244&#34; alt=&#34;firefox_2024-04-08_01-20-19&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Above is a visual image series depicting the process for mounting the thumb button pieces. It&#39;s OK if they crack or break while attempting to fit them; they will still fit and work, just be slightly less snug than they&#39;re supposed to be.&lt;/p&gt; &#xA;&lt;p&gt;Fit scroll wheel brace around the middle mouse button (near the right mouse button), with the spikes towards the &#34;inside&#34; of the mouse and away from the middle mouse button. Now fit the scroll wheel and make sure it&#39;s snug and properly balanced. If it&#39;s not, you&#39;ll need to reprint it.&lt;/p&gt; &#xA;&lt;p&gt;Put the PCB back into the shell bottom and make sure it&#39;s still snug. Route the USB cable behind the support post in the back of the case (it has a screw hole in it) and around the right side of the PCB (NOT the left side), hugging the right side of the right mouse button, and then feed it out through the slot in the front. Use hot glue to secure the USB cable to that front slot. Make sure that it points relatively straight out the front when you hot glue it down.&lt;/p&gt; &#xA;&lt;p&gt;Plug it in, compile and upload the firmware from the Arduino IDE, and make sure everything works. If it does, you&#39;re done! Just re-screw everything together. Be careful not to overtighten the side screws; doing so can cause their mounting holes to split.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;3360_Mouse_pico.ino, the main file of this project, is released under the Apache License, version 2.0.&lt;/p&gt; &#xA;&lt;p&gt;relmouse_16.h is based on files from mbed OS, also licensed under the Apache License, version 2.0. &lt;a href=&#34;https://github.com/arduino/ArduinoCore-mbed&#34;&gt;https://github.com/arduino/ArduinoCore-mbed&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The hardware design files (under &#34;Case Model&#34; and &#34;KiCad schematic + PCB&#34;) are licensed under the SolderpadLicense, version 2.1, as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2024 wareya&#xA;SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1&#xA;&#xA;Licensed under the Solderpad Hardware License v 2.1 (the “License”); you may not use this file except in compliance with the License, or, at your option, the Apache License version 2.0. You may obtain a copy of the License at&#xA;&#xA;https://solderpad.org/licenses/SHL-2.1/&#xA;&#xA;Unless required by applicable law or agreed to in writing, any work distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>