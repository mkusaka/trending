<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-24T01:26:44Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>luainkernel/lunatik</title>
    <updated>2024-04-24T01:26:44Z</updated>
    <id>tag:github.com,2024-04-24:/luainkernel/lunatik</id>
    <link href="https://github.com/luainkernel/lunatik" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lunatik is a framework for scripting the Linux kernel with Lua.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lunatik&lt;/h1&gt; &#xA;&lt;p&gt;Lunatik is a framework for scripting the Linux kernel with &lt;a href=&#34;https://www.lua.org/&#34;&gt;Lua&lt;/a&gt;. It is composed by the Lua interpreter modified to run in the kernel; a &lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/lunatik.lua&#34;&gt;device driver&lt;/a&gt; (written in Lua =)) and a &lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/lunatik&#34;&gt;command line tool&lt;/a&gt; to load and run scripts and manage runtime environments from the user space; a &lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/#lunatik-c-api&#34;&gt;C API&lt;/a&gt; to load and run scripts and manage runtime environments from the kernel; and &lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/#lunatik-lua-apis&#34;&gt;Lua APIs&lt;/a&gt; for binding kernel facilities to Lua scripts.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of a character device driver written in Lua using Lunatik to generate random ASCII printable characters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Lua&#34;&gt;-- /lib/modules/lua/passwd.lua&#xA;--&#xA;-- implements /dev/passwd for generate passwords&#xA;-- usage: $ sudo lunatik run passwd&#xA;--        $ head -c &amp;lt;width&amp;gt; /dev/passwd&#xA;&#xA;local device = require(&#34;device&#34;)&#xA;local linux  = require(&#34;linux&#34;)&#xA;&#xA;local function nop() end -- do nothing&#xA;&#xA;local s = linux.stat&#xA;local driver = {name = &#34;passwd&#34;, open = nop, release = nop, mode = s.IRUGO}&#xA;&#xA;function driver:read() -- read(2) callback&#xA;&#x9;-- generate random ASCII printable characters&#xA;&#x9;return string.char(linux.random(32, 126))&#xA;end&#xA;&#xA;-- creates a new character device&#xA;device.new(driver)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;make&#xA;sudo make install&#xA;sudo lunatik # execute Lunatik REPL&#xA;Lunatik 3.4  Copyright (C) 2023-2024 ring-0 Ltda.&#xA;&amp;gt; return 42 -- execute this line in the kernel&#xA;42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;lunatik&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;usage: lunatik [load|unload|reload|status|list] [run|spawn|stop &amp;lt;script&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;load&lt;/code&gt;: load Lunatik kernel modules&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unload&lt;/code&gt;: unload Lunatik kernel modules&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;reload&lt;/code&gt;: reload Lunatik kernel modules&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;status&lt;/code&gt;: show which Lunatik kernel modules are currently loaded&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;list&lt;/code&gt;: show which runtime environments are currently running&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;run&lt;/code&gt;: create a new runtime environment to run the script &lt;code&gt;/lib/modules/lua/&amp;lt;script&amp;gt;.lua&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;spawn&lt;/code&gt;: create a new runtime environment and spawn a thread to run the script &lt;code&gt;/lib/modules/lua/&amp;lt;script&amp;gt;.lua&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stop&lt;/code&gt;: stop the runtime environment created to run the script &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;default&lt;/code&gt;: start a &lt;em&gt;REPL (Read–Eval–Print Loop)&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Lua Version&lt;/h2&gt; &#xA;&lt;p&gt;Lunatik 3.4 is based on &lt;a href=&#34;https://github.com/luainkernel/lua&#34;&gt;Lua 5.4 adapted&lt;/a&gt; to run in the kernel.&lt;/p&gt; &#xA;&lt;h3&gt;Floating-point numbers&lt;/h3&gt; &#xA;&lt;p&gt;Lunatik &lt;strong&gt;does not&lt;/strong&gt; support floating-point arithmetic, thus it &lt;strong&gt;does not&lt;/strong&gt; support &lt;code&gt;__div&lt;/code&gt; nor &lt;code&gt;__pow&lt;/code&gt; &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#2.4&#34;&gt;metamethods&lt;/a&gt; and the type &lt;em&gt;number&lt;/em&gt; has only the subtype &lt;em&gt;integer&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Lua API&lt;/h3&gt; &#xA;&lt;p&gt;Lunatik &lt;strong&gt;does not&lt;/strong&gt; support both &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#6.8&#34;&gt;io&lt;/a&gt; and &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#6.9&#34;&gt;os&lt;/a&gt; libraries, and the given identifiers from the following libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-debug.debug&#34;&gt;debug.debug&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.acos&#34;&gt;math.acos&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.asin&#34;&gt;math.asin&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.atan&#34;&gt;math.atan&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.ceil&#34;&gt;math.ceil&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.cos&#34;&gt;math.cos&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.deg&#34;&gt;math.deg&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.exp&#34;&gt;math.exp&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.floor&#34;&gt;math.floor&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.fmod&#34;&gt;math.fmod&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.huge&#34;&gt;math.huge&lt;/a&gt;. &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.log&#34;&gt;math.log&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.modf&#34;&gt;math.modf&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.pi&#34;&gt;math.pi&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.rad&#34;&gt;math.rad&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.random&#34;&gt;math.random&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.randomseed&#34;&gt;math.randomseed&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.sin&#34;&gt;math.sin&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.sqrt&#34;&gt;math.sqrt&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.tan&#34;&gt;math.tan&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.type&#34;&gt;math.type&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-package.cpath&#34;&gt;package.cpath&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Lunatik &lt;strong&gt;modifies&lt;/strong&gt; the following identifiers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-_VERSION&#34;&gt;_VERSION&lt;/a&gt;: is defined as &lt;code&gt;&#34;Lua 5.4-kernel&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-collectgarbage&#34;&gt;collectgarbage(&#34;count&#34;)&lt;/a&gt;: returns the total memory in use by Lua in &lt;strong&gt;bytes&lt;/strong&gt;, instead of &lt;em&gt;Kbytes&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-package.path&#34;&gt;package.path&lt;/a&gt;: is defined as &lt;code&gt;&#34;/lib/modules/lua/?.lua;/lib/modules/lua/?/init.lua&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-require&#34;&gt;require&lt;/a&gt;: only supports built-in or already linked C modules, that is, Lunatik &lt;strong&gt;cannot&lt;/strong&gt; load kernel modules dynamically.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;C API&lt;/h3&gt; &#xA;&lt;p&gt;Lunatik &lt;strong&gt;does not&lt;/strong&gt; support &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#luaL_Stream&#34;&gt;luaL_Stream&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#luaL_execresult&#34;&gt;luaL_execresult&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#luaL_fileresult&#34;&gt;luaL_fileresult&lt;/a&gt;, &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-luaopen_io&#34;&gt;luaopen_io&lt;/a&gt; and &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-luaopen_os&#34;&gt;luaopen_os&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Lunatik &lt;strong&gt;modifies&lt;/strong&gt; &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#luaL_openlibs&#34;&gt;luaL_openlibs&lt;/a&gt; to remove &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-luaopen_io&#34;&gt;luaopen_io&lt;/a&gt; and &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-luaopen_os&#34;&gt;luaopen_os&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Lunatik C API&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;lunatik.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;lunatik_runtime&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int lunatik_runtime(lunatik_object_t **pruntime, const char *script, bool sleep);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik_runtime()&lt;/em&gt; creates a new &lt;code&gt;runtime&lt;/code&gt; environment then loads and runs the script &lt;code&gt;/lib/modules/lua/&amp;lt;script&amp;gt;.lua&lt;/code&gt; as the entry point for this environment. It &lt;em&gt;must&lt;/em&gt; only be called from &lt;em&gt;process context&lt;/em&gt;. The &lt;code&gt;runtime&lt;/code&gt; environment is a Lunatik object that holds a &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#lua_State&#34;&gt;Lua state&lt;/a&gt;. Lunatik objects are special Lua &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#2.1&#34;&gt;userdata&lt;/a&gt; which also hold a &lt;a href=&#34;https://docs.kernel.org/locking/locktypes.html&#34;&gt;lock type&lt;/a&gt; and a &lt;a href=&#34;https://www.kernel.org/doc/Documentation/kref.txt&#34;&gt;reference counter&lt;/a&gt;. If &lt;code&gt;sleep&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt;, &lt;em&gt;lunatik_runtime()&lt;/em&gt; will use a &lt;a href=&#34;https://docs.kernel.org/locking/mutex-design.html&#34;&gt;mutex&lt;/a&gt; for locking the &lt;code&gt;runtime&lt;/code&gt; environment and the &lt;a href=&#34;https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html&#34;&gt;GFP_KERNEL&lt;/a&gt; flag for allocating new memory later on on &lt;a href=&#34;https://github.com/luainkernel/lunatik#lunatik_run&#34;&gt;lunatik_run()&lt;/a&gt; calls. Otherwise, it will use a &lt;a href=&#34;https://docs.kernel.org/locking/locktypes.html#raw-spinlock-t-and-spinlock-t&#34;&gt;spinlock&lt;/a&gt; and &lt;a href=&#34;https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html&#34;&gt;GFP_ATOMIC&lt;/a&gt;. &lt;em&gt;lunatik_runtime()&lt;/em&gt; opens the Lua standard libraries &lt;a href=&#34;https://github.com/luainkernel/lunatik#c-api&#34;&gt;present on Lunatik&lt;/a&gt;. If successful, &lt;em&gt;lunatik_runtime()&lt;/em&gt; sets the address pointed by &lt;code&gt;pruntime&lt;/code&gt; and &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#lua_getextraspace&#34;&gt;Lua&#39;s extra space&lt;/a&gt; with a pointer for the new created &lt;code&gt;runtime&lt;/code&gt; environment, sets the &lt;em&gt;reference counter&lt;/em&gt; to &lt;code&gt;1&lt;/code&gt; and then returns &lt;code&gt;0&lt;/code&gt;. Otherwise, it returns &lt;code&gt;-ENOMEM&lt;/code&gt;, if insufficient memory is available; or &lt;code&gt;-EINVAL&lt;/code&gt;, if it fails to load or run the &lt;code&gt;script&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Example&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Lua&#34;&gt;-- /lib/modules/lua/mydevice.lua&#xA;function myread(len, off)&#xA;&#x9;return &#34;42&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static lunatik_object_t *runtime;&#xA;&#xA;static int __init mydevice_init(void)&#xA;{&#xA;&#x9;return lunatik_runtime(&amp;amp;runtime, &#34;mydevice&#34;, true);&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;lunatik_stop&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int lunatik_stop(lunatik_object_t *runtime);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik_stop()&lt;/em&gt; &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#lua_close&#34;&gt;closes&lt;/a&gt; the &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#lua_State&#34;&gt;Lua state&lt;/a&gt; created for this &lt;code&gt;runtime&lt;/code&gt; environment and decrements the &lt;a href=&#34;https://www.kernel.org/doc/Documentation/kref.txt&#34;&gt;reference counter&lt;/a&gt;. Once the reference counter is decremented to zero, the &lt;a href=&#34;https://docs.kernel.org/locking/locktypes.html&#34;&gt;lock type&lt;/a&gt; and the memory allocated for the &lt;code&gt;runtime&lt;/code&gt; environment are released. If the &lt;code&gt;runtime&lt;/code&gt; environment has been released, it returns &lt;code&gt;1&lt;/code&gt;; otherwise, it returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;lunatik_run&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void lunatik_run(lunatik_object_t *runtime, &amp;lt;inttype&amp;gt; (*handler)(...), &amp;lt;inttype&amp;gt; &amp;amp;ret, ...);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik_run()&lt;/em&gt; locks the &lt;code&gt;runtime&lt;/code&gt; environment and calls the &lt;code&gt;handler&lt;/code&gt; passing the associated Lua state as the first argument followed by the variadic arguments. If the Lua state has been closed, &lt;code&gt;ret&lt;/code&gt; is set with &lt;code&gt;-ENXIO&lt;/code&gt;; otherwise, &lt;code&gt;ret&lt;/code&gt; is set with the result of &lt;code&gt;handler(L, ...)&lt;/code&gt; call. Then, it restores the Lua stack and unlocks the &lt;code&gt;runtime&lt;/code&gt; environment. It is defined as a macro.&lt;/p&gt; &#xA;&lt;h5&gt;Example&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static int l_read(lua_State *L, char *buf, size_t len, loff_t *off)&#xA;{&#xA;&#x9;size_t llen;&#xA;&#x9;const char *lbuf;&#xA;&#xA;&#x9;lua_getglobal(L, &#34;myread&#34;);&#xA;&#x9;lua_pushinteger(L, len);&#xA;&#x9;lua_pushinteger(L, *off);&#xA;&#x9;if (lua_pcall(L, 2, 2, 0) != LUA_OK) { /* calls myread(len, off) */&#xA;&#x9;&#x9;pr_err(&#34;%s\n&#34;, lua_tostring(L, -1));&#xA;&#x9;&#x9;return -ECANCELED;&#xA;&#x9;}&#xA;&#xA;&#x9;lbuf = lua_tolstring(L, -2, &amp;amp;llen);&#xA;&#x9;llen = min(len, llen);&#xA;&#x9;if (copy_to_user(buf, lbuf, llen) != 0)&#xA;&#x9;&#x9;return -EFAULT;&#xA;&#xA;&#x9;*off = (loff_t)luaL_optinteger(L, -1, *off + llen);&#xA;&#x9;return (ssize_t)llen;&#xA;}&#xA;&#xA;static ssize_t mydevice_read(struct file *f, char *buf, size_t len, loff_t *off)&#xA;{&#xA;&#x9;ssize_t ret;&#xA;&#x9;lunatik_object_t *runtime = (lunatik_object_t *)f-&amp;gt;private_data;&#xA;&#xA;&#x9;lunatik_run(runtime, l_read, ret, buf, len, off);&#xA;&#x9;return ret;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;lunatik_getobject&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void lunatik_getobject(lunatik_object_t *object);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik_getobject()&lt;/em&gt; increments the &lt;a href=&#34;https://www.kernel.org/doc/Documentation/kref.txt&#34;&gt;reference counter&lt;/a&gt; of this &lt;code&gt;object&lt;/code&gt; (e.g., &lt;code&gt;runtime&lt;/code&gt; environment).&lt;/p&gt; &#xA;&lt;h4&gt;lunatik_put&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int lunatik_putobject(lunatik_object_t *object);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik_putobject()&lt;/em&gt; decrements the &lt;a href=&#34;https://www.kernel.org/doc/Documentation/kref.txt&#34;&gt;reference counter&lt;/a&gt; of this &lt;code&gt;object&lt;/code&gt; (e.g., &lt;code&gt;runtime&lt;/code&gt; environment). If the &lt;code&gt;object&lt;/code&gt; has been released, it returns &lt;code&gt;1&lt;/code&gt;; otherwise, it returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;lunatik_toruntime&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;lunatik_object_t *lunatik_toruntime(lua_State *L);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik_toruntime()&lt;/em&gt; returns the &lt;code&gt;runtime&lt;/code&gt; environment referenced by the &lt;code&gt;L&lt;/code&gt;&#39;s &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#lua_getextraspace&#34;&gt;extra space&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Lunatik Lua APIs&lt;/h2&gt; &#xA;&lt;h3&gt;lunatik&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;lunatik&lt;/code&gt; library provides support to load and run scripts and manage runtime environments from Lua.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;lunatik.runtime(script [, sleep])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik.runtime()&lt;/em&gt; creates a new &lt;a href=&#34;https://github.com/luainkernel/lunatik#lunatik_runtime&#34;&gt;runtime environment&lt;/a&gt; then loads and runs the script &lt;code&gt;/lib/modules/lua/&amp;lt;script&amp;gt;.lua&lt;/code&gt; as the entry point for this environment. It returns a Lunatik object representing the &lt;code&gt;runtime&lt;/code&gt; environment. If &lt;code&gt;sleep&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; or omitted, it will use a &lt;a href=&#34;https://docs.kernel.org/locking/mutex-design.html&#34;&gt;mutex&lt;/a&gt; and &lt;a href=&#34;https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html&#34;&gt;GFP_KERNEL&lt;/a&gt;; otherwise, it will use a &lt;a href=&#34;https://docs.kernel.org/locking/locktypes.html#raw-spinlock-t-and-spinlock-t&#34;&gt;spinlock&lt;/a&gt; and &lt;a href=&#34;https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html&#34;&gt;GFP_ATOMIC&lt;/a&gt;. &lt;em&gt;lunatik.runtime()&lt;/em&gt; opens the Lua standard libraries &lt;a href=&#34;https://github.com/luainkernel/lunatik#c-api&#34;&gt;present on Lunatik&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;lunatik.stop(runtime)&lt;/code&gt;, &lt;code&gt;runtime:stop()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;lunatik.stop()&lt;/em&gt; &lt;a href=&#34;https://github.com/luainkernel/lunatik#lunatik_stop&#34;&gt;stops&lt;/a&gt; the &lt;code&gt;runtime&lt;/code&gt; environment and clear its reference from the runtime object.&lt;/p&gt; &#xA;&lt;h3&gt;device&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;device&lt;/code&gt; library provides support for writting &lt;a href=&#34;https://static.lwn.net/images/pdf/LDD3/ch03.pdf&#34;&gt;character device drivers&lt;/a&gt; in Lua.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;device.new(driver)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;device.new()&lt;/em&gt; returns a new &lt;code&gt;device&lt;/code&gt; object and installs its &lt;code&gt;driver&lt;/code&gt; in the system. The &lt;code&gt;driver&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; be defined as a table containing the following field:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: string defining the device name; it is used for creating the device file (e.g., &lt;code&gt;/dev/&amp;lt;name&amp;gt;&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;driver&lt;/code&gt; table might optionally contain the following fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;read&lt;/code&gt;: callback function to handle the &lt;a href=&#34;https://docs.kernel.org/filesystems/vfs.html#id2&#34;&gt;read operation&lt;/a&gt; on the device file. It receives the &lt;code&gt;driver&lt;/code&gt; table as the first argument followed by two integers, the &lt;code&gt;length&lt;/code&gt; to be read and the file &lt;code&gt;offset&lt;/code&gt;. It should return a string and, optionally, the &lt;code&gt;updated offset&lt;/code&gt;. If the length of the returned string is greater than the requested &lt;code&gt;length&lt;/code&gt;, the string will be corrected to that &lt;code&gt;length&lt;/code&gt;. If the &lt;code&gt;updated offset&lt;/code&gt; is not returned, the &lt;code&gt;offset&lt;/code&gt; will be updated with &lt;code&gt;offset + length&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;write&lt;/code&gt;: callback function to handle the &lt;a href=&#34;https://docs.kernel.org/filesystems/vfs.html#id2&#34;&gt;write operation&lt;/a&gt; on the device file. It receives the &lt;code&gt;driver&lt;/code&gt; table as the first argument followed by the string to be written and an integer as the file &lt;code&gt;offset&lt;/code&gt;. It might return optionally the written &lt;code&gt;length&lt;/code&gt; followed by the &lt;code&gt;updated offset&lt;/code&gt;. If the returned length is greater than the requested &lt;code&gt;length&lt;/code&gt;, the returned length will be corrected. If the &lt;code&gt;updated offset&lt;/code&gt; is not returned, the &lt;code&gt;offset&lt;/code&gt; will be updated with &lt;code&gt;offset + length&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;open&lt;/code&gt;: callback function to handle the &lt;a href=&#34;https://docs.kernel.org/filesystems/vfs.html#id2&#34;&gt;open operation&lt;/a&gt; on the device file. It receives the &lt;code&gt;driver&lt;/code&gt; table and it is expected to return nothing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;release&lt;/code&gt;: callback function to handle the &lt;a href=&#34;https://docs.kernel.org/filesystems/vfs.html#id2&#34;&gt;release operation&lt;/a&gt; on the device file. It receives the &lt;code&gt;driver&lt;/code&gt; table and it is expected to return nothing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mode&lt;/code&gt;: an integer specifying the device &lt;a href=&#34;https://github.com/luainkernel/lunatik#linuxstat&#34;&gt;file mode&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If an operation callback is not defined, the &lt;code&gt;device&lt;/code&gt; returns &lt;code&gt;-ENXIO&lt;/code&gt; to VFS on its access.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;device.stop(dev)&lt;/code&gt;, &lt;code&gt;dev:stop()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;device.stop()&lt;/em&gt; removes a device &lt;code&gt;driver&lt;/code&gt; specified by the &lt;code&gt;dev&lt;/code&gt; object from the system.&lt;/p&gt; &#xA;&lt;h3&gt;linux&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;linux&lt;/code&gt; library provides support for some Linux kernel facilities.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;linux.random([m [, n]])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;linux.random()&lt;/em&gt; mimics the behavior of &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#pdf-math.random&#34;&gt;math.random&lt;/a&gt;, but binding &lt;em&gt;&amp;lt;linux/random.h&amp;gt;&lt;/em&gt;&#39;s &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/random.h#L42&#34;&gt;get_random_u32()&lt;/a&gt; and &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/random.h#L43&#34;&gt;get_random_u64()&lt;/a&gt; APIs.&lt;/p&gt; &#xA;&lt;p&gt;When called without arguments, produces an integer with all bits (pseudo)random. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;em&gt;linux.random()&lt;/em&gt; returns a pseudo-random integer with uniform distribution in the range &lt;code&gt;[m, n]&lt;/code&gt;. The call &lt;code&gt;math.random(n)&lt;/code&gt;, for a positive &lt;code&gt;n&lt;/code&gt;, is equivalent to &lt;code&gt;math.random(1, n)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;linux.stat&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;linux.stat&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/stat.h&#34;&gt;&amp;lt;linux/stat.h&amp;gt;&lt;/a&gt; integer flags to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IRWXUGO&#34;&lt;/code&gt;: permission to &lt;em&gt;read&lt;/em&gt;, &lt;em&gt;write&lt;/em&gt; and &lt;em&gt;execute&lt;/em&gt; for &lt;em&gt;user&lt;/em&gt;, &lt;em&gt;group&lt;/em&gt; and &lt;em&gt;other&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IRUGO&#34;&lt;/code&gt;: permission only to &lt;em&gt;read&lt;/em&gt; for &lt;em&gt;user&lt;/em&gt;, &lt;em&gt;group&lt;/em&gt; and &lt;em&gt;other&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IWUGO&#34;&lt;/code&gt;: permission only to &lt;em&gt;write&lt;/em&gt; for &lt;em&gt;user&lt;/em&gt;, &lt;em&gt;group&lt;/em&gt; and &lt;em&gt;other&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IXUGO&#34;&lt;/code&gt;: permission only to &lt;em&gt;execute&lt;/em&gt; for &lt;em&gt;user&lt;/em&gt;, &lt;em&gt;group&lt;/em&gt; and &lt;em&gt;other&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;linux.schedule([timeout [, state]])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;linux.schedule()&lt;/em&gt; sets the current task &lt;code&gt;state&lt;/code&gt; and makes the it sleep until &lt;code&gt;timeout&lt;/code&gt; milliseconds have elapsed. If &lt;code&gt;timeout&lt;/code&gt; is omitted, it uses &lt;code&gt;MAX_SCHEDULE_TIMEOUT&lt;/code&gt;. If &lt;code&gt;state&lt;/code&gt; is omitted, it uses &lt;code&gt;task.INTERRUPTIBLE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;linux.task&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;linux.task&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L7v3&#34;&gt;task state&lt;/a&gt; flags to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RUNNING&#34;&lt;/code&gt;: task is executing on a CPU or waiting to be executed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;INTERRUPTIBLE&#34;&lt;/code&gt;: task is waiting for a signal or a resource (sleeping).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;UNINTERRUPTIBLE&#34;&lt;/code&gt;: behaves like &#34;INTERRUPTIBLE&#34; with the exception that signal will not wake up the task.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;KILLABLE&#34;&lt;/code&gt;: behaves like &#34;UNINTERRUPTIBLE&#34; with the exception that fatal signals will wake up the task.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IDLE&#34;&lt;/code&gt;: behaves like &#34;UNINTERRUPTIBLE&#34; with the exception that it avoids the loadavg accounting.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;linux.errno&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;linux.errno&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/errno-base.h&#34;&gt;&amp;lt;uapi/asm-generic/errno-base.h&amp;gt;&lt;/a&gt; flags to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PERM&#34;&lt;/code&gt;: Operation not permitted.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOENT&#34;&lt;/code&gt;: No such file or directory.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SRCH&#34;&lt;/code&gt;: No such process.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;INTR&#34;&lt;/code&gt;: Interrupted system call.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IO&#34;&lt;/code&gt;: I/O error.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NXIO&#34;&lt;/code&gt;:No such device or address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;2BIG&#34;&lt;/code&gt;:, Argument list too long.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOEXEC&#34;&lt;/code&gt;: Exec format error.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;BADF&#34;&lt;/code&gt;: Bad file number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;CHILD&#34;&lt;/code&gt;: No child processes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;AGAIN&#34;&lt;/code&gt;: Try again.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOMEM&#34;&lt;/code&gt;: Out of memory.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ACCES&#34;&lt;/code&gt;: Permission denied.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;FAULT&#34;&lt;/code&gt;: Bad address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOTBLK&#34;&lt;/code&gt;: Block device required.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;BUSY&#34;&lt;/code&gt;: Device or resource busy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;EXIST&#34;&lt;/code&gt;: File exists.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;XDEV&#34;&lt;/code&gt;: Cross-device link.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NODEV&#34;&lt;/code&gt;: No such device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOTDIR&#34;&lt;/code&gt;: Not a directory.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ISDIR&#34;&lt;/code&gt;: Is a directory.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;INVAL&#34;&lt;/code&gt;: Invalid argument.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NFILE&#34;&lt;/code&gt;: File table overflow.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MFILE&#34;&lt;/code&gt;: Too many open files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOTTY&#34;&lt;/code&gt;: Not a typewriter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;TXTBSY&#34;&lt;/code&gt;: Text file busy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;FBIG&#34;&lt;/code&gt;: File too large.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOSPC&#34;&lt;/code&gt;: No space left on device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SPIPE&#34;&lt;/code&gt;: Illegal seek.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ROFS&#34;&lt;/code&gt;: Read-only file system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MLINK&#34;&lt;/code&gt;: Too many links.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PIPE&#34;&lt;/code&gt;: Broken pipe.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DOM&#34;&lt;/code&gt;: Math argument out of domain of func.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RANGE&#34;&lt;/code&gt;: Math result not representable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;notifier&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;notifier&lt;/code&gt; library provides support for the kernel &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/notifier.h&#34;&gt;notifier chains&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;notifier.keyboard(callback)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;notifier.keyboard()&lt;/em&gt; returns a new keyboard &lt;code&gt;notifier&lt;/code&gt; object and installs it in the system. The &lt;code&gt;callback&lt;/code&gt; function is called whenever a console keyboard event happens (e.g., a key has been pressed or released). This &lt;code&gt;callback&lt;/code&gt; receives the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;event&lt;/code&gt;: the available &lt;em&gt;events&lt;/em&gt; are defined by the &lt;a href=&#34;https://github.com/luainkernel/lunatik#notifierkbd&#34;&gt;notifier.kbd&lt;/a&gt; table.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;down&lt;/code&gt;: &lt;code&gt;true&lt;/code&gt;, if the key is pressed; &lt;code&gt;false&lt;/code&gt;, if it is released.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;shift&lt;/code&gt;: &lt;code&gt;true&lt;/code&gt;, if the shift key is held; &lt;code&gt;false&lt;/code&gt;, otherwise.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;key&lt;/code&gt;: &lt;em&gt;keycode&lt;/em&gt; or &lt;em&gt;keysym&lt;/em&gt; depending on &lt;code&gt;event&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;callback&lt;/code&gt; function might return the values defined by the &lt;a href=&#34;https://github.com/luainkernel/lunatik#notifiernotify&#34;&gt;notifier.notify&lt;/a&gt; table.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;notifier.kbd&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;notifier.kbd&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/notifier.h#L229&#34;&gt;KBD&lt;/a&gt; flags to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;KEYCODE&#34;&lt;/code&gt;: keyboard &lt;em&gt;keycode&lt;/em&gt;, called before any other.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;UNBOUND_KEYCODE&#34;&lt;/code&gt;: keyboard &lt;em&gt;keycode&lt;/em&gt; which is not bound to any other.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;UNICODE&#34;&lt;/code&gt;: keyboard unicode.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;KEYSYM&#34;&lt;/code&gt;: keyboard &lt;em&gt;keysym&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;POST_KEYSYM&#34;&lt;/code&gt;: called after keyboard &lt;em&gt;keysym&lt;/em&gt; interpretation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;notifier.netdevice(callback)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;notifier.netdevice()&lt;/em&gt; returns a new netdevice &lt;code&gt;notifier&lt;/code&gt; object and installs it in the system. The &lt;code&gt;callback&lt;/code&gt; function is called whenever a console netdevice event happens (e.g., a network interface has been connected or disconnected). This &lt;code&gt;callback&lt;/code&gt; receives the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;event&lt;/code&gt;: the available &lt;em&gt;events&lt;/em&gt; are defined by the &lt;a href=&#34;https://github.com/luainkernel/lunatik#notifiernetdev&#34;&gt;notifier.netdev&lt;/a&gt; table.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: the device name.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;callback&lt;/code&gt; function might return the values defined by the &lt;a href=&#34;https://github.com/luainkernel/lunatik#notifiernotify&#34;&gt;notifier.notify&lt;/a&gt; table.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;notifier.netdev&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;notifier.netdev&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/v6.3/source/include/linux/netdevice.h#L2812&#34;&gt;NETDEV&lt;/a&gt; flags to Lua.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;notifier.notify&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;notifier.notify&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/notifier.h#L183&#34;&gt;NOTIFY&lt;/a&gt; flags to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DONE&#34;&lt;/code&gt;: don&#39;t care.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;OK&#34;&lt;/code&gt;: suits me.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;BAD&#34;&lt;/code&gt;: bad/veto action.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;STOP&#34;&lt;/code&gt;: clean way to return from the notifier and stop further calls.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;notifier.delete(notfr)&lt;/code&gt;, &lt;code&gt;notfr:delete()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;notifier.delete()&lt;/em&gt; removes a &lt;code&gt;notifier&lt;/code&gt; specified by the &lt;code&gt;notfr&lt;/code&gt; object from the system.&lt;/p&gt; &#xA;&lt;h3&gt;socket&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;socket&lt;/code&gt; library provides support for the kernel &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/net.h&#34;&gt;networking handling&lt;/a&gt;. This library was inspired by &lt;a href=&#34;https://github.com/tcz717&#34;&gt;Chengzhi Tan&lt;/a&gt;&#39;s &lt;a href=&#34;https://summerofcode.withgoogle.com/archive/2018/projects/5993341447569408&#34;&gt;GSoC project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.new(family, type, protocol)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.new()&lt;/em&gt; creates a new &lt;code&gt;socket&lt;/code&gt; object. This function receives the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;family&lt;/code&gt;: the available &lt;em&gt;address families&lt;/em&gt; are defined by the &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketaf&#34;&gt;socket.af&lt;/a&gt; table.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sock&lt;/code&gt;: the available &lt;em&gt;types&lt;/em&gt; are present on the &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketsock&#34;&gt;socket.sock&lt;/a&gt; table.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;protocol&lt;/code&gt;: the available &lt;em&gt;protocols&lt;/em&gt; are defined by the &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketipproto&#34;&gt;socket.ipproto&lt;/a&gt; table.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.af&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.af&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/socket.h#L187&#34;&gt;address families (AF)&lt;/a&gt; to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;UNSPEC&#34;&lt;/code&gt;: Unspecified.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;UNIX&#34;&lt;/code&gt;: Unix domain sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;LOCAL&#34;&lt;/code&gt;: POSIX name for AF_UNIX.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;INET&#34;&lt;/code&gt;: Internet IP Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;AX25&#34;&lt;/code&gt;: Amateur Radio AX.25.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IPX&#34;&lt;/code&gt;: Novell IPX.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;APPLETALK&#34;&lt;/code&gt;: AppleTalk DDP.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NETROM&#34;&lt;/code&gt;: Amateur Radio NET/ROM.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;BRIDGE&#34;&lt;/code&gt;: Multiprotocol bridge.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ATMPVC&#34;&lt;/code&gt;: ATM PVCs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;X25&#34;&lt;/code&gt;: Reserved for X.25 project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;INET6&#34;&lt;/code&gt;: IP version 6.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ROSE&#34;&lt;/code&gt;: Amateur Radio X.25 PLP.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DEC&#34;&lt;/code&gt;: Reserved for DECnet project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NETBEUI&#34;&lt;/code&gt;: Reserved for 802.2LLC project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SECURITY&#34;&lt;/code&gt;: Security callback pseudo AF.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;KEY&#34;&lt;/code&gt;: PF_KEY key management API.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NETLINK&#34;&lt;/code&gt;: Netlink.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ROUTE&#34;&lt;/code&gt;: Alias to emulate 4.4BSD.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PACKET&#34;&lt;/code&gt;: Packet family.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ASH&#34;&lt;/code&gt;: Ash.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ECONET&#34;&lt;/code&gt;: Acorn Econet.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ATMSVC&#34;&lt;/code&gt;: ATM SVCs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RDS&#34;&lt;/code&gt;: RDS sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SNA&#34;&lt;/code&gt;: Linux SNA Project (nutters!).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IRDA&#34;&lt;/code&gt;: IRDA sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PPPOX&#34;&lt;/code&gt;: PPPoX sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;WANPIPE&#34;&lt;/code&gt;: Wanpipe API Sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;LLC&#34;&lt;/code&gt;: Linux LLC.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IB&#34;&lt;/code&gt;: Native InfiniBand address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MPLS&#34;&lt;/code&gt;: MPLS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;CAN&#34;&lt;/code&gt;: Controller Area Network.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;TIPC&#34;&lt;/code&gt;: TIPC sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;BLUETOOTH&#34;&lt;/code&gt;: Bluetooth sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IUCV&#34;&lt;/code&gt;: IUCV sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RXRPC&#34;&lt;/code&gt;: RxRPC sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ISDN&#34;&lt;/code&gt;: mISDN sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PHONET&#34;&lt;/code&gt;: Phonet sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IEEE802154&#34;&lt;/code&gt;: IEEE802154 sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;CAIF&#34;&lt;/code&gt;: CAIF sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ALG&#34;&lt;/code&gt;: Algorithm sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NFC&#34;&lt;/code&gt;: NFC sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;VSOCK&#34;&lt;/code&gt;: vSockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;KCM&#34;&lt;/code&gt;: Kernel Connection Multiplexor.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;QIPCRTR&#34;&lt;/code&gt;: Qualcomm IPC Router.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SMC&#34;&lt;/code&gt;: reserve number for PF_SMC protocol family that reuses AF_INET address family.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;XDP&#34;&lt;/code&gt;: XDP sockets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MCTP&#34;&lt;/code&gt;: Management component transport protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MAX&#34;&lt;/code&gt;: Maximum.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.sock&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.sock&lt;/em&gt; is a table that exports socket &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/net.h#L49&#34;&gt;types (SOCK)&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;STREAM&#34;&lt;/code&gt;: stream (connection) socket.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DGRAM&#34;&lt;/code&gt;: datagram (conn.less) socket.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RAW&#34;&lt;/code&gt;: raw socket.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RDM&#34;&lt;/code&gt;: reliably-delivered message.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SEQPACKET&#34;&lt;/code&gt;: sequential packet socket.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DCCP&#34;&lt;/code&gt;: Datagram Congestion Control Protocol socket.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PACKET&#34;&lt;/code&gt;: linux specific way of getting packets at the dev level.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;and &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/net.h#L78&#34;&gt;flags (SOCK)&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;CLOEXEC&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NONBLOCK&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.ipproto&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.ipproto&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/in.h#L27&#34;&gt;IP protocols (IPPROTO)&lt;/a&gt; to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IP&#34;&lt;/code&gt;: Dummy protocol for TCP.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ICMP&#34;&lt;/code&gt;: Internet Control Message Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IGMP&#34;&lt;/code&gt;: Internet Group Management Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IPIP&#34;&lt;/code&gt;: IPIP tunnels (older KA9Q tunnels use 94).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;TCP&#34;&lt;/code&gt;: Transmission Control Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;EGP&#34;&lt;/code&gt;: Exterior Gateway Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PUP&#34;&lt;/code&gt;: PUP protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;UDP&#34;&lt;/code&gt;: User Datagram Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IDP&#34;&lt;/code&gt;: XNS IDP protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;TP&#34;&lt;/code&gt;: SO Transport Protocol Class 4.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DCCP&#34;&lt;/code&gt;: Datagram Congestion Control Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;IPV6&#34;&lt;/code&gt;: IPv6-in-IPv4 tunnelling.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RSVP&#34;&lt;/code&gt;: RSVP Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;GRE&#34;&lt;/code&gt;: Cisco GRE tunnels (rfc 1701,1702).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ESP&#34;&lt;/code&gt;: Encapsulation Security Payload protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;AH&#34;&lt;/code&gt;: Authentication Header protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MTP&#34;&lt;/code&gt;: Multicast Transport Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;BEETPH&#34;&lt;/code&gt;: IP option pseudo header for BEET.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ENCAP&#34;&lt;/code&gt;: Encapsulation Header.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PIM&#34;&lt;/code&gt;: Protocol Independent Multicast.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;COMP&#34;&lt;/code&gt;: Compression Header Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SCTP&#34;&lt;/code&gt;: Stream Control Transport Protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;UDPLITE&#34;&lt;/code&gt;: UDP-Lite (RFC 3828).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MPLS&#34;&lt;/code&gt;: MPLS in IP (RFC 4023).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ETHERNET&#34;&lt;/code&gt;: Ethernet-within-IPv6 Encapsulation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RAW&#34;&lt;/code&gt;: Raw IP packets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MPTCP&#34;&lt;/code&gt;: Multipath TCP connection.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket:close(sock)&lt;/code&gt;, &lt;code&gt;sock:close()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.close()&lt;/em&gt; removes &lt;code&gt;sock&lt;/code&gt; object from the system.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.send(sock, message, [addr [, port]])&lt;/code&gt;, &lt;code&gt;sock:send(message, [addr [, port]])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.send()&lt;/em&gt; sends a string &lt;code&gt;message&lt;/code&gt; through the socket &lt;code&gt;sock&lt;/code&gt;. If the &lt;code&gt;sock&lt;/code&gt; address family is &lt;code&gt;af.INET&lt;/code&gt;, then it expects the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the destination IPv4 address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the destination IPv4 port.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Otherwise:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#6.4.2&#34;&gt;packed string&lt;/a&gt; describing the destination address.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.receive(sock, length, [flags [, from]])&lt;/code&gt;, &lt;code&gt;sock:receive(length, [flags [, from]])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.receive()&lt;/em&gt; receives a string with up to &lt;code&gt;length&lt;/code&gt; bytes through the socket &lt;code&gt;sock&lt;/code&gt;. The available &lt;em&gt;message flags&lt;/em&gt; are defined by the &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketmsg&#34;&gt;socket.msg&lt;/a&gt; table. If &lt;code&gt;from&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it returns the received message followed by the peer&#39;s address. Otherwise, it returns only the received message.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.msg&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.msg&lt;/em&gt; is a table that exports &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/socket.h#L298&#34;&gt;message flags&lt;/a&gt; to Lua.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;OOB&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PEEK&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DONTROUTE&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;TRYHARD&#34;&lt;/code&gt;: Synonym for &lt;code&gt;&#34;DONTROUTE&#34;&lt;/code&gt; for DECnet.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;CTRUNC&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;PROBE&#34;&lt;/code&gt;: Do not send. Only probe path f.e. for MTU.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;TRUNC&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;DONTWAIT&#34;&lt;/code&gt;: Nonblocking io.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;EOR&#34;&lt;/code&gt;: End of record.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;WAITALL&#34;&lt;/code&gt;: Wait for a full request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;FIN&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SYN&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;CONFIRM&#34;&lt;/code&gt;: Confirm path validity.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;RST&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ERRQUEUE&#34;&lt;/code&gt;: Fetch message from error queue.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NOSIGNAL&#34;&lt;/code&gt;: Do not generate SIGPIPE.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;MORE&#34;&lt;/code&gt;: Sender will send more.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;WAITFORONE&#34;&lt;/code&gt;: recvmmsg(): block until 1+ packets avail.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SENDPAGE_NOPOLICY&#34;&lt;/code&gt;: sendpage() internal: do no apply policy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SENDPAGE_NOTLAST&#34;&lt;/code&gt;: sendpage() internal: not the last page.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;BATCH&#34;&lt;/code&gt;: sendmmsg(): more messages coming.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;EOF&#34;&lt;/code&gt;: n/a.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;NO_SHARED_FRAGS&#34;&lt;/code&gt;: sendpage() internal: page frags are not shared.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;SENDPAGE_DECRYPTED&#34;&lt;/code&gt;: sendpage() internal: page may carry plain text and require encryption.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;ZEROCOPY&#34;&lt;/code&gt;: Use user data in kernel path.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;FASTOPEN&#34;&lt;/code&gt;: Send data in TCP SYN.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;CMSG_CLOEXEC&#34;&lt;/code&gt;: Set close_on_exec for file descriptor received through SCM_RIGHTS.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.bind(sock, addr [, port])&lt;/code&gt;, &lt;code&gt;sock:bind(addr [, port])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.bind()&lt;/em&gt; binds the socket &lt;code&gt;sock&lt;/code&gt; to a given address. If the &lt;code&gt;sock&lt;/code&gt; address family is &lt;code&gt;af.INET&lt;/code&gt;, then it expects the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing host IPv4 address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing host IPv4 port.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Otherwise:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#6.4.2&#34;&gt;packed string&lt;/a&gt; describing host address.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.listen(sock [, backlog])&lt;/code&gt;, &lt;code&gt;sock:listen([backlog])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.listen()&lt;/em&gt; moves the socket &lt;code&gt;sock&lt;/code&gt; to listening state.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;backlog&lt;/code&gt;: pending connections queue size. If omitted, it uses &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/linux/socket.h#L296&#34;&gt;SOMAXCONN&lt;/a&gt; as default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.accept(sock [, flags])&lt;/code&gt;, &lt;code&gt;sock:accept([flags])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.accept()&lt;/em&gt; accepts a connection on socket &lt;code&gt;sock&lt;/code&gt;. It returns a new &lt;code&gt;socket&lt;/code&gt; object. The available &lt;em&gt;flags&lt;/em&gt; are present on the &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketsock&#34;&gt;socket.sock&lt;/a&gt; table.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.connect(sock, addr [, port] [, flags])&lt;/code&gt;, &lt;code&gt;sock:connect(addr [, port] [, flags])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.connect()&lt;/em&gt; connects the socket &lt;code&gt;sock&lt;/code&gt; to the address &lt;code&gt;addr&lt;/code&gt;. If the &lt;code&gt;sock&lt;/code&gt; address family is &lt;code&gt;af.INET&lt;/code&gt;, then it expects the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the destination IPv4 address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the destination IPv4 port.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Otherwise:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#6.4.2&#34;&gt;packed string&lt;/a&gt; describing the destination address.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The available &lt;em&gt;flags&lt;/em&gt; are present on the &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketsock&#34;&gt;socket.sock&lt;/a&gt; table.&lt;/p&gt; &#xA;&lt;p&gt;For datagram sockets, &lt;code&gt;addr&lt;/code&gt; is the address to which datagrams are sent by default, and the only address from which datagrams are received. For stream sockets, attempts to connect to &lt;code&gt;addr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.getsockname(sock)&lt;/code&gt;, &lt;code&gt;sock:getsockname()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.getsockname()&lt;/em&gt; get the address which the socket &lt;code&gt;sock&lt;/code&gt; is bound. If the &lt;code&gt;sock&lt;/code&gt; address family is &lt;code&gt;af.INET&lt;/code&gt;, then it returns the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the bounded IPv4 address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the bounded IPv4 port.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Otherwise:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#6.4.2&#34;&gt;packed string&lt;/a&gt; describing the bounded address.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;socket.getpeername(sock)&lt;/code&gt;, &lt;code&gt;sock:getpeername()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;socket.getpeername()&lt;/em&gt; get the address which the socket &lt;code&gt;sock&lt;/code&gt; is connected. If the &lt;code&gt;sock&lt;/code&gt; address family is &lt;code&gt;af.INET&lt;/code&gt;, then it returns the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the peer&#39;s IPv4 address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; describing the peer&#39;s IPv4 port.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Otherwise:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#6.4.2&#34;&gt;packed string&lt;/a&gt; describing the peer&#39;s address.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;socket.inet&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;socket.inet&lt;/code&gt; library provides support for high-level IPv4 sockets.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;inet.tcp()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;inet.tcp()&lt;/em&gt; creates a new &lt;code&gt;socket&lt;/code&gt; using &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketaf&#34;&gt;af.INET&lt;/a&gt; address family, &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketsock&#34;&gt;sock.STREAM&lt;/a&gt; type and &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketipproto&#34;&gt;ipproto.TCP&lt;/a&gt; protocol. It overrides &lt;code&gt;socket&lt;/code&gt; methods to use addresses as &lt;em&gt;numbers-and-dots notation&lt;/em&gt; (e.g., &lt;code&gt;&#34;127.0.0.1&#34;&lt;/code&gt;), instead of integers.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;inet.udp()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;inet.udp()&lt;/em&gt; creates a new &lt;code&gt;socket&lt;/code&gt; using &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketaf&#34;&gt;af.INET&lt;/a&gt; address family, &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketsock&#34;&gt;sock.DGRAM&lt;/a&gt; type and &lt;a href=&#34;https://github.com/luainkernel/lunatik#socketipproto&#34;&gt;ipproto.UDP&lt;/a&gt; protocol. It overrides &lt;code&gt;socket&lt;/code&gt; methods to use addresses as &lt;em&gt;numbers-and-dots notation&lt;/em&gt; (e.g., &lt;code&gt;&#34;127.0.0.1&#34;&lt;/code&gt;), instead of integers.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;udp:receivefrom(length [, flags])&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;&lt;em&gt;udp:receivefrom()&lt;/em&gt; is just an alias to &lt;code&gt;sock:receive(length, flags, true)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;rcu&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;rcu&lt;/code&gt; library provides support for the kernel &lt;a href=&#34;https://lwn.net/Articles/262464/&#34;&gt;Read-copy update (RCU)&lt;/a&gt; synchronization mechanism. This library was inspired by &lt;a href=&#34;https://github.com/cmessias&#34;&gt;Caio Messias&lt;/a&gt;&#39; &lt;a href=&#34;https://summerofcode.withgoogle.com/archive/2018/projects/5736202426646528&#34;&gt;GSoC project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;rcu.table([size])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;rcu.table()&lt;/em&gt; creates a new &lt;code&gt;rcu.table&lt;/code&gt; object which binds the kernel &lt;a href=&#34;https://lwn.net/Articles/510202/&#34;&gt;generic hash table&lt;/a&gt;. This function receives as argument the number of buckets rounded up to the next power of 2. The default size is &lt;code&gt;1024&lt;/code&gt;. Key must be a string and value must be a Lunatik object or nil.&lt;/p&gt; &#xA;&lt;h3&gt;thread&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;thread&lt;/code&gt; library provides support for the &lt;a href=&#34;https://lwn.net/Articles/65178/&#34;&gt;kernel thread primitives&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;thread.run(runtime, name)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;thread.run()&lt;/em&gt; creates a new &lt;code&gt;thread&lt;/code&gt; object and wakes it up. This function receives the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;runtime&lt;/code&gt;: the &lt;a href=&#34;https://github.com/luainkernel/lunatik#lunatikruntimescript--sleep&#34;&gt;runtime environment&lt;/a&gt; for running a task in the created kernel thread. The task must be specified by returning a function on the script loaded in the &lt;code&gt;runtime&lt;/code&gt; environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: string representing the name for the thread (e.g., as shown on &lt;code&gt;ps&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;thread.shouldstop()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;thread.shouldstop()&lt;/em&gt; returns &lt;code&gt;true&lt;/code&gt; if &lt;a href=&#34;https://github.com/luainkernel/lunatik#threadstopthrd-thrdstop&#34;&gt;thread.stop()&lt;/a&gt; was called; otherwise, it returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;thread.current()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;thread.current()&lt;/em&gt; returns a &lt;code&gt;thread&lt;/code&gt; object representing the current task.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;thread.stop(thrd), thrd:stop()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;thread.stop()&lt;/em&gt; sets &lt;a href=&#34;https://github.com/luainkernel/lunatik#threadshouldstop&#34;&gt;thread.shouldstop()&lt;/a&gt; on the thread &lt;code&gt;thrd&lt;/code&gt; to return true, wakes &lt;code&gt;thrd&lt;/code&gt;, and waits for it to exit.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;thread.task(thread), thrd:task()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;thread.task()&lt;/em&gt; returns a table containing the task information of this &lt;code&gt;thread&lt;/code&gt; (e.g., &#34;cpu&#34;, &#34;command&#34;, &#34;pid&#34; and &#34;tgid&#34;).&lt;/p&gt; &#xA;&lt;h3&gt;fib&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;fib&lt;/code&gt; library provides support for the &lt;a href=&#34;https://thermalcircle.de/doku.php?id=blog:linux:routing_decisions_in_the_linux_kernel_1_lookup_packet_flow&#34;&gt;kernel Forwarding Information Base&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;fib.newrule(table, priority)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;fib.newrule()&lt;/em&gt; binds the kernel &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/net/fib_rules.h#L182&#34;&gt;fib_nl_newrule&lt;/a&gt; API; it creates a new FIB rule that matches the specified routing &lt;em&gt;table&lt;/em&gt; with the specified &lt;em&gt;priorioty&lt;/em&gt;. This function is similar to the user-space command &lt;a href=&#34;https://datahacker.blog/industry/technology-menu/networking/iptables/follow-the-ip-rules&#34;&gt;ip rule add&lt;/a&gt; provided by &lt;a href=&#34;https://wiki.linuxfoundation.org/networking/iproute2&#34;&gt;iproute2&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;fib.delrule(table, priority)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;fib.delrule()&lt;/em&gt; binds the kernel &lt;a href=&#34;https://elixir.bootlin.com/linux/latest/source/include/net/fib_rules.h#L184&#34;&gt;fib_nl_delrule&lt;/a&gt; API; it removes a FIB rule that matches the specified routing &lt;em&gt;table&lt;/em&gt; with the specified &lt;em&gt;priorioty&lt;/em&gt;. This function is similar to the user-space command &lt;a href=&#34;https://datahacker.blog/industry/technology-menu/networking/iptables/follow-the-ip-rules&#34;&gt;ip rule del&lt;/a&gt; provided by &lt;a href=&#34;https://wiki.linuxfoundation.org/networking/iproute2&#34;&gt;iproute2&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;data&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;data&lt;/code&gt; library provides support for binding the system memory to Lua.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;data.new(size)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;data.new()&lt;/em&gt; creates a new &lt;code&gt;data&lt;/code&gt; object which allocates &lt;code&gt;size&lt;/code&gt; bytes.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;data.getnumber(d, offset), d:getnumber(offset)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;data.getnumber()&lt;/em&gt; extracts a &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#lua_Integer&#34;&gt;lua_Integer&lt;/a&gt; from the memory referenced by a &lt;code&gt;data&lt;/code&gt; object and a byte &lt;code&gt;offset&lt;/code&gt;, starting from zero.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;data.setnumber(d, offset, number), d:setnumber(offset, number)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;data.setnumber()&lt;/em&gt; insert a &lt;a href=&#34;https://www.lua.org/manual/5.4/manual.html#lua_Integer&#34;&gt;lua_Integer&lt;/a&gt; &lt;code&gt;number&lt;/code&gt; into the memory referenced by a &lt;code&gt;data&lt;/code&gt; object and a byte &lt;code&gt;offset&lt;/code&gt;, starting from zero.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;data.getbyte(d, offset), d:getbyte(offset)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;data.getbyte()&lt;/em&gt; extracts a byte from the memory referenced by a &lt;code&gt;data&lt;/code&gt; object and a byte &lt;code&gt;offset&lt;/code&gt;, starting from zero.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;data.setbyte(d, offset, byte), d:setbyte(offset, byte)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;data.setbyte()&lt;/em&gt; insert a byte into the memory referenced by a &lt;code&gt;data&lt;/code&gt; object and a byte &lt;code&gt;offset&lt;/code&gt;, starting from zero.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;data.getstring(d, offset, length), d:getstring(offset, length)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;data.getstring()&lt;/em&gt; extracts a string with &lt;code&gt;length&lt;/code&gt; bytes from the memory referenced by a &lt;code&gt;data&lt;/code&gt; object and a byte &lt;code&gt;offset&lt;/code&gt;, starting from zero.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;data.setstring(d, offset, s), d:setstring(offset, s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;data.setstring()&lt;/em&gt; insert the string &lt;code&gt;s&lt;/code&gt; into the memory referenced by a &lt;code&gt;data&lt;/code&gt; object and a byte &lt;code&gt;offset&lt;/code&gt;, starting from zero.&lt;/p&gt; &#xA;&lt;h3&gt;probe&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;probe&lt;/code&gt; library provides support for &lt;a href=&#34;https://docs.kernel.org/trace/kprobes.html&#34;&gt;kernel probes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;probe.new(symbol|address, handlers)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;probe.new()&lt;/em&gt; returns a new &lt;code&gt;probe&lt;/code&gt; object for monitoring a kernel &lt;code&gt;symbol&lt;/code&gt; (string) or &lt;code&gt;address&lt;/code&gt; (light userdata) and installs its &lt;code&gt;handlers&lt;/code&gt; in the system. The &lt;code&gt;handler&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; be defined as a table containing the following field:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pre&lt;/code&gt;: function to be called before the probed instruction. It receives the &lt;code&gt;symbol&lt;/code&gt; or &lt;code&gt;address&lt;/code&gt;, followed by a closure that may be called to &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.6.19/source/include/linux/sched/debug.h#L26&#34;&gt;show the CPU registers and stack&lt;/a&gt; in the system log.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;post&lt;/code&gt;: function to be called after the probed instruction. It receives the &lt;code&gt;symbol&lt;/code&gt; or &lt;code&gt;address&lt;/code&gt;, followed by a closure that may be called to &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.6.19/source/include/linux/sched/debug.h#L26&#34;&gt;show the CPU registers and stack&lt;/a&gt; in the system log.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;probe.stop(p), p:stop()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;probe.stop()&lt;/em&gt; removes the &lt;code&gt;probe&lt;/code&gt; handlers from the system.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;probe.enable(p, bool), p:enable(bool)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;probe.enable()&lt;/em&gt; enables or disables the &lt;code&gt;probe&lt;/code&gt; handlers, accordingly to &lt;code&gt;bool&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;syscall&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;syscall&lt;/code&gt; library provides support for system call addresses and numbers.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;syscall.address(number)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;syscall.address()&lt;/em&gt; returns the system call address (light userdata) referenced by the given &lt;code&gt;number&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;syscall.number(name)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;syscall.number()&lt;/em&gt; returns the system call number referenced by the given &lt;code&gt;name&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;syscall.table&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;syscall.table&lt;/code&gt; library provides support for translating system call names to addresses (light userdata).&lt;/p&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;h3&gt;spyglass&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/examples/spyglass.lua&#34;&gt;spyglass&lt;/a&gt; is a kernel script that implements a &lt;em&gt;keylogger&lt;/em&gt; inspired by the &lt;a href=&#34;https://github.com/jarun/spy&#34;&gt;spy&lt;/a&gt; kernel module. This kernel script logs the &lt;em&gt;keysym&lt;/em&gt; of the pressed keys in a device (&lt;code&gt;/dev/spyglass&lt;/code&gt;). If the &lt;em&gt;keysym&lt;/em&gt; is a printable character, &lt;code&gt;spyglass&lt;/code&gt; logs the &lt;em&gt;keysym&lt;/em&gt; itself; otherwise, it logs a mnemonic of the ASCII code, (e.g., &lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; stands for &lt;code&gt;127&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make examples_install          # installs examples&#xA;sudo lunatik run examples/spyglass  # runs spyglass&#xA;sudo tail -f /dev/spyglass          # prints the key log&#xA;sudo sh -c &#34;echo &#39;enable=false&#39; &amp;gt; /dev/spyglass&#34;       # disable the key logging&#xA;sudo sh -c &#34;echo &#39;enable=true&#39; &amp;gt; /dev/spyglass&#34;        # enable the key logging&#xA;sudo sh -c &#34;echo &#39;net=127.0.0.1:1337&#39; &amp;gt; /dev/spyglass&#34; # enable network support&#xA;nc -lu 127.0.0.1 1337 &amp;amp;             # listen to UDP 127.0.0.1:1337&#xA;sudo tail -f /dev/spyglass          # sends the key log through the network&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;keylocker&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/examples/keylocker.lua&#34;&gt;keylocker&lt;/a&gt; is a kernel script that implements &lt;a href=&#34;https://en.wikipedia.org/wiki/Konami_Code&#34;&gt;Konami Code&lt;/a&gt; for locking and unlocking the console keyboard. When the user types &lt;code&gt;↑ ↑ ↓ ↓ ← → ← → LCTRL LALT&lt;/code&gt;, the keyboard will be &lt;em&gt;locked&lt;/em&gt;; that is, the system will stop processing any key pressed until the user types the same key sequence again.&lt;/p&gt; &#xA;&lt;h4&gt;Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make examples_install                     # installs examples&#xA;sudo lunatik run examples/keylocker            # runs keylocker&#xA;&amp;lt;↑&amp;gt; &amp;lt;↑&amp;gt; &amp;lt;↓&amp;gt; &amp;lt;↓&amp;gt; &amp;lt;←&amp;gt; &amp;lt;→&amp;gt; &amp;lt;←&amp;gt; &amp;lt;→&amp;gt; &amp;lt;LCTRL&amp;gt; &amp;lt;LALT&amp;gt; # locks keyboard&#xA;&amp;lt;↑&amp;gt; &amp;lt;↑&amp;gt; &amp;lt;↓&amp;gt; &amp;lt;↓&amp;gt; &amp;lt;←&amp;gt; &amp;lt;→&amp;gt; &amp;lt;←&amp;gt; &amp;lt;→&amp;gt; &amp;lt;LCTRL&amp;gt; &amp;lt;LALT&amp;gt; # unlocks keyboard&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;tap&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/examples/tap.lua&#34;&gt;tap&lt;/a&gt; is a kernel script that implements a &lt;em&gt;sniffer&lt;/em&gt; using &lt;code&gt;AF_PACKET&lt;/code&gt; socket. It prints destination and source MAC addresses followed by Ethernet type and the frame size.&lt;/p&gt; &#xA;&lt;h4&gt;Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make examples_install    # installs examples&#xA;sudo lunatik run examples/tap # runs tap&#xA;cat /dev/tap&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;shared&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/examples/shared.lua&#34;&gt;shared&lt;/a&gt; is a kernel script that implements an in-memory key-value store using &lt;a href=&#34;https://github.com/luainkernel/lunatik#rcu&#34;&gt;rcu&lt;/a&gt;, &lt;a href=&#34;https://github.com/luainkernel/lunatik#data&#34;&gt;data&lt;/a&gt;, &lt;a href=&#34;https://github.com/luainkernel/lunatik#socket&#34;&gt;socket&lt;/a&gt; and &lt;a href=&#34;https://github.com/luainkernel/lunatik#thread&#34;&gt;thread&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make examples_install         # installs examples&#xA;sudo lunatik spawn examples/shared # spawns shared&#xA;nc 127.0.0.1 90                    # connects to shared&#xA;foo=bar                            # assigns &#34;bar&#34; to foo&#xA;foo                                # retrieves foo&#xA;bar&#xA;^C                                 # finishes the connection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;echod&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/examples/echod&#34;&gt;echod&lt;/a&gt; is an echo server implemented as kernel scripts.&lt;/p&gt; &#xA;&lt;h4&gt;Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make examples_install               # installs examples&#xA;sudo lunatik spawn examples/echod/daemon # runs echod&#xA;nc 127.0.0.1 1337&#xA;hello kernel!&#xA;hello kernel!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;systrack&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/examples/systrack.lua&#34;&gt;systrack&lt;/a&gt; is a kernel script that implements a device driver to monitor system calls. It prints the amount of times each &lt;a href=&#34;https://raw.githubusercontent.com/luainkernel/lunatik/master/examples/systrack.lua#L29&#34;&gt;system call&lt;/a&gt; was called since the driver has been installed.&lt;/p&gt; &#xA;&lt;h4&gt;Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make examples_install         # installs examples&#xA;sudo lunatik run examples/systrack # runs systracker&#xA;cat /dev/systrack&#xA;writev: 0&#xA;close: 1927&#xA;write: 1085&#xA;openat: 2036&#xA;read: 4131&#xA;readv: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://netdevconf.info/0x17/sessions/talk/scripting-the-linux-routing-table-with-lua.html&#34;&gt;Scripting the Linux Routing Table with Lua&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=-ufBgy044HI&#34;&gt;Lua no Núcleo&lt;/a&gt; (Portuguese)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://legacy.netdevconf.info/0x14/session.html?talk-linux-network-scripting-with-lua&#34;&gt;Linux Network Scripting with Lua&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.netbsd.org/~lneto/dls14.pdf&#34;&gt;Scriptables Operating Systems with Lua&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>floesen/KExecDD</title>
    <updated>2024-04-24T01:26:44Z</updated>
    <id>tag:github.com,2024-04-24:/floesen/KExecDD</id>
    <link href="https://github.com/floesen/KExecDD" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Admin to Kernel code execution using the KSecDD driver&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KExecDD&lt;/h1&gt; &#xA;&lt;p&gt;The Kernel Security Support Provider Interface (KSecDD.sys) allows the Local Security Authority Server Service (LSASS) to execute arbitrary kernel-mode addresses using the &lt;code&gt;IOCTL_KSEC_IPC_SET_FUNCTION_RETURN&lt;/code&gt; operation. This behavior can be observed in &lt;code&gt;ksecdd.sys!KsecIoctlHandleFunctionReturn&lt;/code&gt;. As soon as LSASS starts, it invokes &lt;code&gt;lsass.exe!LsapOpenKsec&lt;/code&gt; where it connects itself to the interface using the &lt;code&gt;IOCTL_KSEC_CONNECT_LSA&lt;/code&gt; operation. From this point on, no further process can connect to the interface and therefore the logic can only be triggered by LSASS. Note, however, that exactly one connection can be created for each server silo, but I am not sure about the implications of this.&lt;/p&gt; &#xA;&lt;p&gt;The proof of concept injects a DLL into the LSASS process from where it disables Driver Signature Enforcement by overwriting &lt;code&gt;ci.dll!g_CiOptions&lt;/code&gt; (keep in mind that this will eventually trigger Patchguard after some time). This obviously only works if LSASS does not run as a protected process (LSA Protection has to be disabled).&lt;/p&gt; &#xA;&lt;h1&gt;Demo&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/floesen/KExecDD/raw/main/demo.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>