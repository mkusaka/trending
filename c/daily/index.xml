<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-03T01:26:17Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ElliotKillick/LdrLockLiberator</title>
    <updated>2023-11-03T01:26:17Z</updated>
    <id>tag:github.com,2023-11-03:/ElliotKillick/LdrLockLiberator</id>
    <link href="https://github.com/ElliotKillick/LdrLockLiberator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;For when DLLMain is the only way&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://github.com/ElliotKillick/LdrLockLiberator&#34;&gt; &lt;img width=&#34;160&#34; src=&#34;https://raw.githubusercontent.com/ElliotKillick/LdrLockLiberator/main/logo.webp&#34; alt=&#34;Logo&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt; LdrLockLiberator &lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; For when &lt;b&gt;DLLMain&lt;/b&gt; is the only way &lt;/p&gt; &#xA;&lt;p&gt;LdrLockLiberator is a collection of techniques for escaping or otherwise forgoing Loader Lock while executing your code from &lt;code&gt;DllMain&lt;/code&gt; or anywhere else the lock may be present. It was released in conjuction with the &lt;a href=&#34;https://elliotonsecurity.com/perfect-dll-hijacking&#34;&gt;&#34;Perfect DLL Hijacking&#34;&lt;/a&gt; article. We give you the &lt;b&gt;key&lt;/b&gt; to unlock the library loader and do what you want with your loader (on your own computer)!&lt;/p&gt; &#xA;&lt;p&gt;The techniques are intended to be &lt;strong&gt;universal, clean, and 100% safe&lt;/strong&gt; where possible. They&#39;re designed to work without modifying memory protection or pointers. This is important for staying compatible with modern exploit mitigations.&lt;/p&gt; &#xA;&lt;h2&gt;Techniques&lt;/h2&gt; &#xA;&lt;h3&gt;LdrFullUnlock&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s exactly what it sounds like. Unlock Loader Lock, set loader events, and flip &lt;code&gt;LdrpWorkInProgress&lt;/code&gt;. It&#39;s recommended to keep &lt;code&gt;RUN_PAYLOAD_DIRECTLY_FROM_DLLMAIN&lt;/code&gt; undefined for the best stability.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;DO NOT USE THIS TECHNIQUE IN PROUDCTION CODE.&lt;/strong&gt; This was created as a byproduct of my sheer curiosity and will to leave no stone unturned. Anything you do with this code is on you.&lt;/p&gt; &#xA;&lt;h3&gt;Escaping at the Exit&lt;/h3&gt; &#xA;&lt;p&gt;We use the CRT &lt;code&gt;atexit&lt;/code&gt; typically used by EXEs in our DLL code to escape Loader Lock when the program exits. For dynamic loads (using LoadLibrary), this is made &lt;b&gt;100% safe&lt;/b&gt; by pinning (&lt;code&gt;LDR_ADDREF_DLL_PIN&lt;/code&gt;) our library using &lt;code&gt;LdrAddRefDll&lt;/code&gt; so a following &lt;code&gt;FreeLibrary&lt;/code&gt; won&#39;t remove our DLL from memory.&lt;/p&gt; &#xA;&lt;h3&gt;Using Locks to Our Advantage&lt;/h3&gt; &#xA;&lt;p&gt;Coming soon!&lt;/p&gt; &#xA;&lt;h2&gt;Samples&lt;/h2&gt; &#xA;&lt;p&gt;The provided samples hijack &lt;code&gt;MpClient.dll&lt;/code&gt; from &lt;code&gt;C:\Program Files\Windows Defender\Offline\OfflineScannerShell.exe&lt;/code&gt;. Instructions are provided in the source code comments to easily adapt this for any other DLL and program pairing (primarily just updating the exports for static loads)!&lt;/p&gt; &#xA;&lt;p&gt;As a proof of concept, we run &lt;code&gt;ShellExecute&lt;/code&gt; as the default payload. However, you can make this do anything you want!&lt;/p&gt; &#xA;&lt;h2&gt;Compilation&lt;/h2&gt; &#xA;&lt;h3&gt;Visual Studio&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;LdrLockLiberator.c&lt;/code&gt; at the root of this project has been tested to compile on Visual Studio 2022.&lt;/p&gt; &#xA;&lt;h3&gt;WDK&lt;/h3&gt; &#xA;&lt;h4&gt;Installing the Correct WDK&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to the &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads#step-2-install-the-wdk&#34;&gt;WDK download page&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click on the Windows 7 &lt;a href=&#34;https://www.microsoft.com/en-us/download/confirmation.aspx?id=11800&#34;&gt;WDK 7.1.0&lt;/a&gt; link to start download the correct WDK version&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This is the last WDK that &lt;strong&gt;officially&lt;/strong&gt; supports linking to the original MSVCRT (&lt;code&gt;C:\Windows\System32\msvcrt.dll&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;SHA-256 checksum: &lt;code&gt;5edc723b50ea28a070cad361dd0927df402b7a861a036bbcf11d27ebba77657d&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Mount the downloaded ISO then run &lt;code&gt;KitSetup.exe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click through the installation process using the default options&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Compiling&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In the Start menu, search for &#34;x64 Free Build Environment&#34; then open it&lt;/li&gt; &#xA; &lt;li&gt;Navigate (using &lt;code&gt;cd&lt;/code&gt;) to &lt;code&gt;LdrLockLiberatorWDK&lt;/code&gt; in this repo&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;build&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Done! Your DLL is built and ready for use!&lt;/p&gt; &#xA;&lt;p&gt;As an alternative to WDK, cross-compiling with MinGW would also probably work.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT License - Copyright (C) 2023 Elliot Killick &lt;a href=&#34;mailto:contact@elliotkillick.com&#34;&gt;contact@elliotkillick.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cozis/microtcp</title>
    <updated>2023-11-03T01:26:17Z</updated>
    <id>tag:github.com,2023-11-03:/cozis/microtcp</id>
    <link href="https://github.com/cozis/microtcp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A minimal TCP/IP stack&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MicroTCP&lt;/h1&gt; &#xA;&lt;p&gt;MicroTCP is a TCP/IP network stack I started building as a learning exercise while attending the Computer Networking course at the Universit√† degli Studi di Napoli Federico II. It&#39;s just a hobby project and is intended to just be a minimal, yet complete, implementation.&lt;/p&gt; &#xA;&lt;p&gt;At this moment MicroTCP implements ARP (RFC 826, complete), IPv4 (no fragmentation), ICMP (minimum necessary to reply to pings) and TCP (complete but not stress-tested). Note that &#34;complete&#34; should not be intended as &#34;fully compliant&#34; but just as a measure of progress on all of the major features. For instance, it&#39;s complete enough to handle HTTP traffic on a local network (Look into examples/microhttp to know more).&lt;/p&gt; &#xA;&lt;h2&gt;Where does it run?&lt;/h2&gt; &#xA;&lt;p&gt;MicroTCP can run on Windows and Linux alongside the OS&#39;s network stack. To route the network traffic to MicroTCP, the process running it behaves as a virtual host with its own IP address. This is done using a TAP device, which comes built-in on Linux and needs to be installed on Windows. It should be very easy to adapt MicroTCP to run on microcontrollers but haven&#39;t tried yet. The dream is to serve my &lt;a href=&#34;https://cozis.github.io/&#34;&gt;blog&lt;/a&gt; from an STM32 board!&lt;/p&gt; &#xA;&lt;h2&gt;Build and Install&lt;/h2&gt; &#xA;&lt;p&gt;If you are on Windows, you need to install the TAP driver provided by OpenVPN and instanciate a virtual NIC so that MicroTCP can connect to it when started. To build the project from source, make sure you cloned the repository with submodules&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/cozis/microtcp.git --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need both &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;cmake&lt;/code&gt; for it to work. If all goes well, you&#39;ll find the library files &lt;code&gt;libtuntap.a&lt;/code&gt;, &lt;code&gt;libmicrotcp.a&lt;/code&gt; and header files &lt;code&gt;tuntap.h&lt;/code&gt;, &lt;code&gt;tuntap-export.h&lt;/code&gt;, &lt;code&gt;microtcp.h&lt;/code&gt; in &lt;code&gt;out/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;MicroTCP&#39;s uses the usual socket interface any network programmer is familiar with, the main difference being you need to explicitly instanciate the network stack and pass its handle around.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a simple echo server that shows the basic usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;microtcp.h&amp;gt;&#xA;&#xA;int main(void)&#xA;{&#xA;    microtcp_t *mtcp = microtcp_create(&#34;10.0.0.5&#34;, &#34;10.0.0.4&#34;, NULL, NULL);&#xA;    if (mtcp == NULL)&#xA;        return -1; // Couldn&#39;t create MicroTCP instance&#xA;&#xA;    uint16_t port = 8081;&#xA;    microtcp_socket_t *server = microtcp_open(mtcp, port);&#xA;    if (server == NULL) {&#xA;        microtcp_destroy(mtcp);&#xA;        return -1;&#xA;    }&#xA;&#xA;    while (1) {&#xA;    &#xA;        microtcp_socket_t *client = microtcp_accept(server);&#xA;        if (client == NULL)&#xA;            break;&#xA;        &#xA;        char buffer[1024];&#xA;        int num = microtcp_recv(client, buffer, sizeof(buffer));&#xA;        if (num &amp;gt; 0) {&#xA;            microtcp_send(client, &#34;echo: &#34;, 6);&#xA;            microtcp_send(client, buffer, num);&#xA;        }&#xA;        microtcp_close(client);&#xA;    }&#xA;    &#xA;    microtcp_close(server);&#xA;    microtcp_destroy(mtcp);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should be pretty straight forward to understand. One thing may be worth noting is that &lt;code&gt;microtcp_open&lt;/code&gt; behaves as the BSD&#39;s &lt;code&gt;socket+bind+listen&lt;/code&gt; all at once to setup a listening TCP server.&lt;/p&gt; &#xA;&lt;p&gt;There is more than one way to set up the stack, the main way being &lt;code&gt;microtcp_create&lt;/code&gt; which creates a virtual network inferface on the host OS with IP 10.0.0.5/24 and a virtual host for the MicroTCP process at 10.0.0.4/24. You can open Wireshark on the virtual NIC to inspect the traffic between the host and the process.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also possible to configure the stack using the &lt;code&gt;microtcp_create_using_callbacks&lt;/code&gt;, which lets you explicitly provide the input L2 frames to it and receive the frames in a buffer. This is how one would configure the stack to run on a microcontroller.&lt;/p&gt; &#xA;&lt;p&gt;Each instance of MicroTCP (without considering the callbacks) is completely isolated from the others, therefore, if your specific callback implementation allows it, you can have as many instances as you like!&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;There is still no testing infractructure. The way I&#39;m testing it is by setting up an HTTP or echo server and stressing it until something breaks while capturing what happened using Wireshark.&lt;/p&gt;</summary>
  </entry>
</feed>