<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-09T01:31:29Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Syllo/nvtop</title>
    <updated>2022-12-09T01:31:29Z</updated>
    <id>tag:github.com,2022-12-09:/Syllo/nvtop</id>
    <link href="https://github.com/Syllo/nvtop" rel="alternate"></link>
    <summary type="html">&lt;p&gt;GPUs process monitoring for AMD, Intel and NVIDIA&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NVTOP&lt;/h1&gt; &#xA;&lt;h2&gt;What is NVTOP?&lt;/h2&gt; &#xA;&lt;p&gt;Nvtop stands for Neat Videocard TOP, a (h)top like task monitor for AMD, Intel and NVIDIA GPUs. It can handle multiple GPUs and print information about them in a htop familiar way.&lt;/p&gt; &#xA;&lt;p&gt;Because a picture is worth a thousand words:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/screenshot/NVTOP_ex1.png&#34; alt=&#34;NVTOP interface&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#nvtop-options-and-interactive-commands&#34;&gt;NVTOP Options and Interactive Commands&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#interactive-setup-window&#34;&gt;Interactive Setup Window&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#saving-preferences&#34;&gt;Saving Preferences&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#nvtop-manual-and-command-line-options&#34;&gt;NVTOP Manual and Command line Options&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#gpu-support&#34;&gt;GPU Support&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#amd&#34;&gt;AMD&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#intel&#34;&gt;Intel&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#nvidia&#34;&gt;NVIDIA&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#build&#34;&gt;Build&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#distribution-specific-installation-process&#34;&gt;Distribution Specific Installation Process&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#ubuntu--debian&#34;&gt;Ubuntu / Debian&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#ubuntu-disco-1904--debian-buster-stable&#34;&gt;Ubuntu disco (19.04) / Debian buster (stable)&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#fedora--redhat--centos&#34;&gt;Fedora / RedHat / CentOS&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#opensuse&#34;&gt;OpenSUSE&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#arch-linux&#34;&gt;Arch Linux&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#appimage&#34;&gt;AppImage&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#snap&#34;&gt;Snap&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#docker&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#nvtop-build&#34;&gt;NVTOP Build&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#troubleshoot&#34;&gt;Troubleshoot&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;NVTOP Options and Interactive Commands&lt;/h2&gt; &#xA;&lt;h3&gt;Interactive Setup Window&lt;/h3&gt; &#xA;&lt;p&gt;NVTOP has a builtin setup utility that provides a way to specialize the interface to your needs. Simply press &lt;code&gt;F2&lt;/code&gt; and select the options that are the best for you.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/screenshot/Nvtop-config.png&#34; alt=&#34;NVTOP Setup Window&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Saving Preferences&lt;/h3&gt; &#xA;&lt;p&gt;You can save the preferences set in the setup window by pressing &lt;code&gt;F12&lt;/code&gt;. The preferences will be loaded the next time you run &lt;code&gt;nvtop&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;NVTOP Manual and Command line Options&lt;/h3&gt; &#xA;&lt;p&gt;NVTOP comes with a manpage!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;man nvtop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For quick command line arguments help&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nvtop -h&#xA;nvtop --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;GPU Support&lt;/h2&gt; &#xA;&lt;h3&gt;AMD&lt;/h3&gt; &#xA;&lt;p&gt;NVTOP supports AMD GPUs using the &lt;code&gt;amdgpu&lt;/code&gt; driver through the exposed DRM and sysfs interface.&lt;/p&gt; &#xA;&lt;p&gt;AMD introduced the fdinfo interface in kernel 5.14 (&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/amd/amdgpu/amdgpu_fdinfo.c?h=linux-5.14.y&#34;&gt;browse kernel source&lt;/a&gt;). Hence, you will need a kernel with a version greater or equal to 5.14 to see the processes using AMD GPUs.&lt;/p&gt; &#xA;&lt;p&gt;Support for recent GPUs are regularly mainlined into the linux kernel, so please use a recent-enough kernel for your GPU.&lt;/p&gt; &#xA;&lt;h3&gt;Intel&lt;/h3&gt; &#xA;&lt;p&gt;NVTOP supports Intel GPUs using the &lt;code&gt;i915&lt;/code&gt; linux driver.&lt;/p&gt; &#xA;&lt;p&gt;Intel introduced the fdinfo interface in kernel 5.19 (&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/i915/i915_drm_client.c?h=linux-5.19.y&#34;&gt;browse kernel source&lt;/a&gt;). Hence, you will need a kernel with a version greater or equal to 5.19 to see the processes using Intel GPUs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;INTEL SUPPORT STATUS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel is working on exposing more hardware information through an &lt;code&gt;HWMON&lt;/code&gt; interface. The patches are still a work in progress: &lt;a href=&#34;https://patchwork.freedesktop.org/series/104278/&#34;&gt;see patch series&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The fdinfo interface does not expose the memory allocated by the process. The field in the process list is therefore empty.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;NVIDIA&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;em&gt;NVML library&lt;/em&gt; does not support some of the queries for GPUs coming before the Kepler microarchitecture. Anything starting at GeForce 600, GeForce 800M and successor should work fine. For more information about supported GPUs please take a look at the &lt;a href=&#34;http://docs.nvidia.com/deploy/nvml-api/nvml-api-reference.html#nvml-api-reference&#34;&gt;NVML documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;Several libraries are required in order for NVTOP to display GPU information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;em&gt;ncurses&lt;/em&gt; library driving the user interface. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This makes the screen look beautiful.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For NVIDIA: the &lt;em&gt;NVIDIA Management Library&lt;/em&gt; (&lt;em&gt;NVML&lt;/em&gt;) which comes with the GPU driver. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This queries the GPU for information.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For AMD: the libdrm library used to query AMD GPUs through the kernel driver.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Distribution Specific Installation Process&lt;/h2&gt; &#xA;&lt;h3&gt;Ubuntu / Debian&lt;/h3&gt; &#xA;&lt;p&gt;If your distribution provides the snap utility, follow the &lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#snap&#34;&gt;snap installation process&lt;/a&gt; to obtain an up-to-date version of nvtop.&lt;/p&gt; &#xA;&lt;p&gt;A standalone application is available as &lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#appimage&#34;&gt;AppImage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Ubuntu Impish (21.10), Debian buster (stable) and more recent&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install nvtop&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Ubuntu PPA&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://launchpad.net/~flexiondotorg/+archive/ubuntu/nvtop&#34;&gt;PPA supporting Ubuntu 20.04, 22.04 and newer&lt;/a&gt; is provided by &lt;a href=&#34;https://github.com/flexiondotorg&#34;&gt;Martin Wimpress&lt;/a&gt; that offers an up-to-date version of &lt;code&gt;nvtop&lt;/code&gt;, enabled for NVIDIA, AMD and Intel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo add-apt-repository ppa:flexiondotorg/nvtop&#xA;sudo apt install nvtop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Older&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;AMD and Intel Dependencies&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install libdrm-dev libsystemd-dev&#xA;# Ubuntu 18.04&#xA;sudo apt install libudev-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NVIDIA Depenency&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;NVIDIA drivers (see &lt;a href=&#34;https://help.ubuntu.com/community/BinaryDriverHowto/Nvidia&#34;&gt;Ubuntu Wiki&lt;/a&gt; or &lt;a href=&#34;https://launchpad.net/~graphics-drivers/+archive/ubuntu/ppa&#34;&gt;Ubuntu PPA&lt;/a&gt; or &lt;a href=&#34;https://wiki.debian.org/NvidiaGraphicsDrivers#NVIDIA_Proprietary_Driver&#34;&gt;Debian Wiki&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NVTOP Dependencies&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CMake, ncurses and git&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install cmake libncurses5-dev libncursesw5-dev git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NVTOP &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Follow the &lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#nvtop-build&#34;&gt;NVTOP Build&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Fedora / RedHat / CentOS&lt;/h3&gt; &#xA;&lt;p&gt;A standalone application is available as &lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#appimage&#34;&gt;AppImage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Build process for Fedora / RedHat / CentOS:&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;AMD and Intel Dependencies&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dnf install libdrm-devel systemd-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NVIDIA Depenency&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;NVIDIA drivers, &lt;strong&gt;CUDA required for nvml libraries&lt;/strong&gt; (see &lt;a href=&#34;https://rpmfusion.org/Howto/NVIDIA&#34;&gt;RPM Fusion&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NVTOP Dependencies&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CMake, ncurses, c++ and git&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dnf install cmake ncurses-devel git gcc-c++&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NVTOP &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Follow the &lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#nvtop-build&#34;&gt;NVTOP Build&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;OpenSUSE&lt;/h3&gt; &#xA;&lt;p&gt;A standalone application is available as &lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#appimage&#34;&gt;AppImage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Build process for OpenSUSE:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;AMD Dependecy&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo zypper install libdrm-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NVIDIA Depenency&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;NVIDIA drivers (see &lt;a href=&#34;https://en.opensuse.org/SDB:NVIDIA_drivers&#34;&gt;SUSE Support Database&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NVTOP Dependencies&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;CMake, ncurses and git &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo zypper install cmake ncurses-devel git&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NVTOP&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Follow the &lt;a href=&#34;https://raw.githubusercontent.com/Syllo/nvtop/master/#nvtop-build&#34;&gt;NVTOP Build&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Arch Linux&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pacman -S nvtop&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Gentoo&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo layman -a guru &amp;amp;&amp;amp; sudo emerge -av nvtop&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;AppImage&lt;/h3&gt; &#xA;&lt;p&gt;An AppImage is a standalone application. Just download the AppImage, make it executable and run it!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Go to the &lt;a href=&#34;https://github.com/Syllo/nvtop/releases/latest&#34;&gt;release page&lt;/a&gt; and download &lt;code&gt;nvtop-x86_64.AppImage&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Go to the download location ** The path may differ on your system **&#xA;cd $HOME/Downloads&#xA;# Make the AppImage executable&#xA;chmod u+x nvtop-x86_64.AppImage&#xA;# Enjoy nvtop&#xA;./nvtop-x86_64.AppImage&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you are curious how that works, please visit the &lt;a href=&#34;https://appimage.org/&#34;&gt;AppImage website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Snap&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;snap install nvtop&#xA;# Add the capability to kill processes inside nvtop&#xA;snap connect nvtop:process-control&#xA;# Add the capability to inspect GPU info (Fan, PCIe, Power, etc)&#xA;snap connect nvtop:hardware-observe&#xA;# AMDGPU process list support (read /proc/&amp;lt;pid&amp;gt;)&#xA;snap connect nvtop:system-observe&#xA;# Temporary workaround to get per-process GPU usage (read /proc/&amp;lt;pid&amp;gt;/fdinfo)&#xA;snap connect nvtop:kubernetes-support&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Notice: The connect commands allow&lt;/p&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;NVIDIA drivers (same as above)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker&#34;&gt;nvidia-docker&lt;/a&gt; (See &lt;a href=&#34;https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker&#34;&gt;Container Toolkit Installation Guide&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Syllo/nvtop.git &amp;amp;&amp;amp; cd nvtop&#xA;sudo docker build --tag nvtop .&#xA;sudo docker run -it --rm --runtime=nvidia --gpus=all --pid=host nvtop&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;NVTOP Build&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Syllo/nvtop.git&#xA;mkdir -p nvtop/build &amp;amp;&amp;amp; cd nvtop/build&#xA;cmake .. -DNVIDIA_SUPPORT=ON -DAMDGPU_SUPPORT=ON -DINTEL_SUPPORT=ON&#xA;make&#xA;&#xA;# Install globally on the system&#xA;sudo make install&#xA;&#xA;# Alternatively, install without privileges at a location of your choosing&#xA;# make DESTDIR=&#34;/your/install/path&#34; install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you use &lt;strong&gt;conda&lt;/strong&gt; as environment manager and encounter an error while building nvtop, try &lt;code&gt;conda deactivate&lt;/code&gt; before invoking &lt;code&gt;cmake&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The build system supports multiple build type (e.g. -DCMAKE_BUILD_TYPE=RelWithDebInfo):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Release: Binary without debug information&lt;/li&gt; &#xA; &lt;li&gt;RelWithDebInfo: Binary with debug information&lt;/li&gt; &#xA; &lt;li&gt;Debug: Compile with warning flags and address/undefined sanitizers enabled (for development purposes)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Troubleshoot&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The plot looks bad: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Verify that you installed the wide character version of the NCurses library (libncurses&lt;strong&gt;w&lt;/strong&gt;5-dev for Debian / Ubuntu), clean the build directory and restart the build process.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Putty&lt;/strong&gt;: Tell putty not to lie about its capabilities (&lt;code&gt;$TERM&lt;/code&gt;) by setting the field &lt;code&gt;Terminal-type string&lt;/code&gt; to &lt;code&gt;putty&lt;/code&gt; in the menu &lt;code&gt;Connection &amp;gt; Data &amp;gt; Terminal Details&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Nvtop is licensed under the GPLV3 license or any later version. You will find a copy of the license inside the COPYING file of the repository or at the gnu website &amp;lt;&lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;www.gnu.org/licenses/&lt;/a&gt;&amp;gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>OpenAtomFoundation/TencentOS-tiny</title>
    <updated>2022-12-09T01:31:29Z</updated>
    <id>tag:github.com,2022-12-09:/OpenAtomFoundation/TencentOS-tiny</id>
    <link href="https://github.com/OpenAtomFoundation/TencentOS-tiny" rel="alternate"></link>
    <summary type="html">&lt;p&gt;腾讯物联网终端操作系统&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;开放原子开源基金会首批孵化项目&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/image/introduction/TencentOS_tiny_log.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Tencent/TencentOS-tiny/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;http://img.shields.io/badge/license-BSD-blue.svg?sanitize=true&#34; alt=&#34;license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Tencent/TencentOS-tiny/pulls&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/PRs-welcome-blue.svg?sanitize=true&#34; alt=&#34;PRs Welcome&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/Tencent/TencentOS-tiny&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Tencent/TencentOS-tiny.svg?branch=master&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/README_en.md&#34;&gt;(English Documents Available)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;一、TencentOS Tiny 简介&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/product/tos-tiny&#34;&gt;TencentOS tiny&lt;/a&gt; 是腾讯面向物联网领域开发的实时操作系统，具有低功耗，低资源占用，模块化，安全可靠等特点，可有效提升物联网终端产品开发效率。TencentOS tiny 提供精简的 RTOS 内核，内核组件可裁剪可配置，可快速移植到多种主流 MCU (如 STM32 全系列)及模组芯片上。而且，基于 RTOS 内核提供了丰富的物联网组件，内部集成主流物联网协议栈（如 CoAP/MQTT/TLS/DTLS/LoRaWAN/NB-IoT 等），可助力物联网终端设备及业务快速接入腾讯云物联网平台。&lt;/p&gt; &#xA;&lt;h2&gt;1、TencentOS tiny整体架构&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/image/introduction/TencentOS_tiny_Architecture.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;TencentOS tiny 主体架构图，从下到上主要包括：&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CPU 库&lt;/strong&gt; ：TencentOS tiny 支持的 CPU IP 核架构，当前主要支持 ARM Cortex M0/3/4/7，Cortex A7，RISC-V、MSP430、AVR、STM8 等。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;驱动管理层&lt;/strong&gt; ：包括板级支持包（BSP，主要由 MCU 芯片厂家开发与维护）、硬件抽象层（HAL，主要由 TencentOS tiny 提供，方便不同芯片的适配与移植）、设备驱动（Drivers，例如 Wi-Fi、GPRS、LoRa 等模块的驱动程序）。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;内核&lt;/strong&gt; ：TencentOS tiny 实时内核包括任务管理、实时调度、时间管理、中断管理、内存管理、异常处理、软件定时器、链表、消息队列、信号量、互斥锁、事件标志等模块。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;IoT 协议栈&lt;/strong&gt;：TencentOS tiny 提供 lwip、AT Adapter、SAL 层，支持不同的网络硬件，例如以太网、串口 Wi-Fi、GPRS、NB-IoT、4G 等通信模块。TCP/IP 网络协议栈上提供常用的物联网协议栈，例如 CoAP、MQTT，支撑终端业务快速接入腾讯云。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;安全框架&lt;/strong&gt;：TencentOS tiny 为了确保物联网终端数据传输安全以及设备认证安全，提供了完整的安全解决方案。安全框架提供的 DTLS 和 TLS 安全协议，加固了 COAP 及 MQTT 的传输层，可确保物联网终端在对接腾讯云时实现安全认证和数据加密；另外针对低资源的终端硬件，安全框架还提供与腾讯云 IoTHub 配套的密钥认证方案，确保资源受限设备也能在一定程度上实现设备安全认证。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;组件框架&lt;/strong&gt;：TencentOS tiny 提供文件系统、KV 存储、自组网、JS 引擎、低功耗框架、设备框架、OTA、调试工具链等一系列组件，供用户根据业务场景选用。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;开放 API（规划开发中）&lt;/strong&gt;：TencentOS tiny 将在协议中间件和框架层上提供开放 API 函数，方便用户调用中间件功能，使用户无需过多关心中间件具体实现，快速对接腾讯云，实现终端业务上云的需求，期望最大程度减少终端物联网产品开发周期，节省开发成本。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;示例应用&lt;/strong&gt;：TencentOS tiny 提供的示例代码，模块测试代码等，方便用户参考使用。&lt;/p&gt; &#xA;&lt;h2&gt;2、TencentOS tiny 优势&lt;/h2&gt; &#xA;&lt;h3&gt;(1).小体积&lt;/h3&gt; &#xA;&lt;p&gt;最小内核：RAM 0.6KB，ROM 1.8KB 典型 LoraWAN 及传感器应用：RAM 3.3KB，ROM 12KB&lt;/p&gt; &#xA;&lt;h3&gt;(2).低功耗&lt;/h3&gt; &#xA;&lt;p&gt;休眠最低功耗低至 2uA 支持外设功耗管理框架&lt;/p&gt; &#xA;&lt;h3&gt;(3).丰富的 IoT 组件&lt;/h3&gt; &#xA;&lt;p&gt;集成主流 IoT 协议栈 多种通信模组SAL层适配框架； 支持 OTA 升级 提供简单易用端云 API，加速用户业务接入腾讯云&lt;/p&gt; &#xA;&lt;h3&gt;(4).可靠的安全框架&lt;/h3&gt; &#xA;&lt;p&gt;多样化的安全分级方案 均衡安全需求&amp;amp;成本控制&lt;/p&gt; &#xA;&lt;h3&gt;(5).良好的可移植性&lt;/h3&gt; &#xA;&lt;p&gt;内核及IoT组件高度解耦，提供标准适配层 提供自动化移植工具，提升开发效率&lt;/p&gt; &#xA;&lt;h3&gt;(6).便捷的调试手段&lt;/h3&gt; &#xA;&lt;p&gt;提供云化的最后一屏调试功能 故障现场信息自动上传云平台，方便开发人员调试分析&lt;/p&gt; &#xA;&lt;h2&gt;3、TencentOS tiny携手合作伙伴共建IoT生态&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/image/introduction/Partners.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;TencentOS tiny 自开源发布以来也在努力发展合作伙伴，期待合作共赢，共同扩展 IoT 应用生态。目前已经与多家 MCU/IP 核厂家达成了合作，包括意法半导体、恩智浦半导体、兆易半导体、ARM、华大半导体、芯来科技等；也与无线 SOC 和模组厂家达成了广泛的合作关系，包括瑞兴恒方、国民技术、Nordic 蓝牙、亮牛半导体、有人物联网等，&lt;/p&gt; &#xA;&lt;p&gt;除了MCU和模组外，TencentOS tiny 也积极推进终端产品及项目的落地，目前已经形成了AI智慧农业、智能货柜、智慧会议室等方案，并且在腾讯内部与微信支付、腾讯云智慧行业、 AI 平台部、腾讯微瓴、QQ family 达成内部合作，共同扩展行业生态；同时也开始积极发展外部客户，目前与深圳光合显示科技的墨水屏零售标签、鑫悦购充电桩等达成业务合作。TencentOS tiny 将携手合作伙伴为物联网终端厂家提供更优质的 IoT 终端软件解决方案，方便各种物联网设备快速接入腾讯云，共同扩展 IoT 生态，更好地支撑智慧城市、智能水表、智能家居、智能穿戴、车联网等多种行业应用。&lt;/p&gt; &#xA;&lt;p&gt;欢迎 IoT 相关项目合作，有合作需求的请邮件联系 TencentOS tiny 官方工作人员，邮箱地址 ： &lt;a href=&#34;mailto:supowang@tencent.com&#34;&gt;supowang@tencent.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;二、TencentOS tiny 代码目录&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/09.Code_Directories.md&#34;&gt;TencentOS tiny 代码目录说明&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;三、TencentOS tiny 参考文档&lt;/h1&gt; &#xA;&lt;h2&gt;1、移植指南&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/10.Porting_Manual_for_KEIL.md&#34;&gt;TencentOS tiny 移植指南（KEIL 版本）&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/11.Porting_Manual_for_IAR.md&#34;&gt;TencentOS tiny 移植指南（IAR 版本）&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/12.Porting_Manual_for_GCC.md&#34;&gt;TencentOS tiny 移植指南（GCC 版本）&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/tools/mdk_pack/Documentation/README.md&#34;&gt;TencentOS tiny 移植指南（基于MDK pack)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/tools/STM32CubeMX_pack/Documentation/README.md&#34;&gt;TencentOS tiny 移植指南（基于STM32 CubeMx)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;2、TencentOS tiny 开发指南&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/04.Development_Manual.md&#34;&gt;TencentOS tiny 内核开发指南&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/05.SDK_Manual.md&#34;&gt;TencentOS tiny API 参考&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/08.QCloud_IoTHub_Quick_Start.md&#34;&gt;TencentOS tiny 对接腾讯云 IoTHub 开发指南&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;3、TencentOS tiny 腾讯云大学视频教程&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/edu/paths/series/IoT&#34;&gt;TencentOS tiny 端侧开发实践课&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;四、TencentOS tiny 开源协议&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TencentOS tiny 遵循 &lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/LICENSE&#34;&gt;BSD-3 开源许可协议&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;五、TencentOS tiny 支持的物联网平台&lt;/h1&gt; &#xA;&lt;p&gt;TencentOS tiny 能支持物联网终端设备和业务快速接入&lt;a href=&#34;https://cloud.tencent.com/product/iotexplorer&#34;&gt;腾讯云物联网平台 IoT Explorer&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;TencentOS tiny 结合腾讯云物联网开发平台 IoT Explorer，已经构筑起连接通讯芯片到云开发的能力，加上已经建设完成的国内最大规模 LoRa 网络，腾讯彻底打通从芯片通讯开发、网络支撑服务，物理设备定义管理，数据分析和多场景应用开发等全链条IoT云开发服务能力，重新定义了物联网开发模式，助力亿级设备多方式多模式低门槛接入腾讯云服务。作为物联网基础设施建设服务者，腾讯将持续打造开放的物联网生态体系，促进物联网生态良性发展。&lt;/p&gt; &#xA;&lt;h1&gt;六、TencentOS tiny 快速入门参考&lt;/h1&gt; &#xA;&lt;p&gt;TencentOS tiny 联合合作伙伴(南京厚德物联网)设计了定制开发板，如下图： &lt;img src=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/image/introduction/EVB_MX.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.holdiot.com/product/showproduct.php?id=8&#34;&gt;TencentOS tiny 定制开发板介绍页&lt;/a&gt;，开发者可以基于定制开发板进行快速入门学习，点击下载参考文档&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/15.TencentOS_tiny_EVB_MX_Plus_Quick_Start.md&#34;&gt;TencentOS-tiny 定制开发板入门指南&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;七、贡献代码&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;在您自己的 GitHub 账户下 Fork TencentOS tiny 开源项目；&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ol start=&#34;2&#34;&gt; &#xA;   &lt;li&gt;根据您的需求在本地 clone 一份 TencentOS tiny 代码；&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ol start=&#34;3&#34;&gt; &#xA;   &lt;li&gt;您修改或者新增功能后，push 到您 fork 的远程分支；&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ol start=&#34;4&#34;&gt; &#xA;   &lt;li&gt;创建 pull request，向 TencentOS tiny 官方开发分支提交合入请求；&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ol start=&#34;5&#34;&gt; &#xA;   &lt;li&gt;TencentOS tiny 研发团队会定期 review 代码，通过测试后合入。&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;八、加入TencentOS tiny官方QQ技术交流群&lt;/h1&gt; &#xA;&lt;p&gt;扫码加群，请备注 TencentOS tiny 开发者，工作人员会根据备注进行审核：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/OpenAtomFoundation/TencentOS-tiny/master/doc/image/introduction/qq.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;九、第三方开发者评测&lt;/h1&gt; &#xA;&lt;p&gt;1.基于 TencentOS tiny 的环境监测实战项目 &lt;a href=&#34;https://www.bilibili.com/video/av73782956?from=search&amp;amp;seid=4421984671929108231&#34;&gt;【TencentOS tiny】环境监测实战项目最终完整版&lt;/a&gt; 感谢阿正的贡献&lt;/p&gt; &#xA;&lt;p&gt;2.基于野火 stm32f103 开发板上移植的 TencentOS tiny 例程、源码剖析、视频讲解。 感谢 CSDN 博客专家杰杰的贡献&lt;/p&gt; &#xA;&lt;h2&gt;简单上手：&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/101034426&#34;&gt;超详细的 TencentOS tiny 移植到 STM32F103 全教程&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;深度源码分析：&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/99618912&#34;&gt;【TencentOS tiny 学习】源码分析（1）——task&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/99665883&#34;&gt;【TencentOS tiny 学习】源码分析（2）——调度器&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/99687678&#34;&gt;【TencentOS tiny 学习】源码分析（3）——队列&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/99781093&#34;&gt;【TencentOS tiny 学习】源码分析（4）——消息队列&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/100052643&#34;&gt;【TencentOS tiny 学习】源码分析（5）——信号量&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/100056641&#34;&gt;【TencentOS tiny 学习】源码分析（6）——互斥锁&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/100492219&#34;&gt;【TencentOS tiny 学习】源码分析（7）——事件&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiejiemcu/article/details/101846089&#34;&gt;【TencentOS tiny 学习】源码分析（8）——软件定时器&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;配套例程：&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/hello-world&#34;&gt;【TencentOS tiny 学习】例程（0）——hello world&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/01-task&#34;&gt;【TencentOS tiny 学习】例程（1）——task&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/02-queue&#34;&gt;【TencentOS tiny 学习】例程（2）——队列&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/03-msg_queue&#34;&gt;【TencentOS tiny 学习】例程（3）——消息队列&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/04-sem&#34;&gt;【TencentOS tiny 学习】例程（4）——信号量&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/05-mutex&#34;&gt;【TencentOS tiny 学习】例程（5）——互斥锁&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/06-event&#34;&gt;【TencentOS tiny 学习】例程（6）——事件&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/07-timer&#34;&gt;【TencentOS tiny 学习】例程（7）——软件定时器&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/08-mmblk&#34;&gt;【TencentOS tiny 学习】例程（8）——内存池&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/09-mmheap&#34;&gt;【TencentOS tiny 学习】例程（9）——内存堆&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;视频教程：&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596?from=search&amp;amp;seid=10160676184801585522&#34;&gt;【TencentOS tiny 学习】视频汇总&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=1&#34;&gt;【视频】01-初识 TencentOS tiny&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=2&#34;&gt;【视频】02-TencentOS tiny 基础知识&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=3&#34;&gt;【视频】03-TencentOS tiny 移植&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=4&#34;&gt;【视频】04-TencentOS tiny 任务-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=5&#34;&gt;【视频】05-TencentOS tiny 任务-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=6&#34;&gt;【视频】06-TencentOS tiny 队列-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=7&#34;&gt;【视频】07-TencentOS tiny 队列-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=8&#34;&gt;【视频】08-TencentOS tiny 消息队列&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=9&#34;&gt;【视频】09-TencentOS tiny 信号量-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=10&#34;&gt;【视频】10-TencentOS tiny 信号量-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=11&#34;&gt;【视频】11-TencentOS tiny 互斥锁-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=12&#34;&gt;【视频】12-TencentOS tiny 互斥锁-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=13&#34;&gt;【视频】13-TencentOS tiny 互斥锁-3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=14&#34;&gt;【视频】14-TencentOS tiny 事件-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=15&#34;&gt;【视频】15-TencentOS tiny 事件-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=16&#34;&gt;【视频】16-TencentOS tiny 软件定时器-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=11&#34;&gt;【视频】17-TencentOS tiny 软件定时器-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/av70478596/?p=18&#34;&gt;【视频】18-TencentOS tiny 软件定时器-3&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;相关PPT资料：&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jiejieTop/TencentOS-Demo/tree/master/PPT&#34;&gt;【TencentOS tiny 学习】视频 PPT&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>cpq/bare-metal-programming-guide</title>
    <updated>2022-12-09T01:31:29Z</updated>
    <id>tag:github.com,2022-12-09:/cpq/bare-metal-programming-guide</id>
    <link href="https://github.com/cpq/bare-metal-programming-guide" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A bare metal programming guide on STM32 microcontroller&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A bare metal programming guide&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/cpq/bare-metal-programming-guide/actions&#34;&gt;&lt;img src=&#34;https://github.com/cpq/bare-metal-programming-guide/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This guide is written for developers who wish to start programming microcontrollers using GCC compiler and bare metal approach. We are going to use a &lt;a href=&#34;https://www.st.com/en/evaluation-tools/nucleo-f429zi.html&#34;&gt;Nucleo-F429ZI&lt;/a&gt; development board with STM32F429 microcontroller (&lt;a href=&#34;https://eu.mouser.com/ProductDetail/STMicroelectronics/NUCLEO-F429ZI?qs=mKNKSX85ZJcE6FU0UkiXTA%3D%3D&#34;&gt;buy on Mouser&lt;/a&gt;). But basic principles would be applicable to any other microcontroller.&lt;/p&gt; &#xA;&lt;p&gt;In this guide, I&#39;ll show how to program a microcontroller using just a compiler and a datasheet, nothing else. Later I&#39;ll explain what are the vendor&#39;s CMSIS headers, how and why they should be used. We&#39;ll learn how to blink LEDs, how to redirect &lt;code&gt;printf()&lt;/code&gt; to UART, how to set up the system clock, how to use interrupts, and even how to run a web server with device dashboard.&lt;/p&gt; &#xA;&lt;p&gt;To proceed, the following tools are required:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ARM GCC, &lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;https://launchpad.net/gcc-arm-embedded&lt;/a&gt; - for compiling and linking&lt;/li&gt; &#xA; &lt;li&gt;GNU make, &lt;a href=&#34;http://www.gnu.org/software/make/&#34;&gt;http://www.gnu.org/software/make/&lt;/a&gt; - for build automation&lt;/li&gt; &#xA; &lt;li&gt;ST link, &lt;a href=&#34;https://github.com/stlink-org/stlink&#34;&gt;https://github.com/stlink-org/stlink&lt;/a&gt; - for flashing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Tools setup instructions for Mac. Start a terminal, and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ /bin/bash -c &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&#34;&#xA;$ brew install --cask gcc-arm-embedded make stlink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tools setup instructions for Linux (Ubuntu). Start a terminal, and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo apt -y install gcc-arm-none-eabi make stlink-tools&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tools setup instructions for Windows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download and install &lt;a href=&#34;https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&amp;amp;hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C&#34;&gt;gcc-arm-none-eabi-10.3-2021.10-win32.exe&lt;/a&gt;. Enable &#34;Add path to environment variable&#34; during the installation&lt;/li&gt; &#xA; &lt;li&gt;Create &lt;code&gt;c:\tools&lt;/code&gt; folder&lt;/li&gt; &#xA; &lt;li&gt;Download &lt;a href=&#34;https://github.com/stlink-org/stlink/releases/download/v1.7.0/stlink-1.7.0-x86_64-w64-mingw32.zip&#34;&gt;stlink-1.7.0-x86_64-w64-mingw32.zip&lt;/a&gt; and unpack &lt;code&gt;bin/st-flash.exe&lt;/code&gt; into &lt;code&gt;c:\tools&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Download &lt;a href=&#34;https://sourceforge.net/projects/ezwinports/files/make-4.4-without-guile-w32-bin.zip/download&#34;&gt;make-4.4-without-guile-w32-bin.zip&lt;/a&gt; and unpack &lt;code&gt;bin/make.exe&lt;/code&gt; into &lt;code&gt;c:\tools&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;c:\tools&lt;/code&gt; to the &lt;code&gt;Path&lt;/code&gt; environment variable&lt;/li&gt; &#xA; &lt;li&gt;Verify installation: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Download and unzip &lt;a href=&#34;https://github.com/cpq/bare-metal-programming-guide/archive/refs/heads/main.zip&#34;&gt;this repository&lt;/a&gt; into &lt;code&gt;c:\&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Start command prompt, and execute the following:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;pre style=&#34;color: silver;&#34;&gt;&#xA;C:\Users\YOURNAME&amp;gt; &lt;b style=&#34;color: black;&#34;&gt;cd \&lt;/b&gt;&#xA;C:\&amp;gt; &lt;b style=&#34;color: black;&#34;&gt;cd bare-metal-programming-guide-main\step-0-minimal&lt;/b&gt;&#xA;C:\bare-metal-programming-guide-main\step-0-minimal&amp;gt; &lt;b style=&#34;color: black;&#34;&gt;make&lt;/b&gt;&#xA;arm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror ...&#xA;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, download two datasheets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/resource/en/reference_manual/dm00031020-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf&#34;&gt;STM32F429 MCU datasheet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/resource/en/user_manual/dm00244518-stm32-nucleo144-boards-mb1137-stmicroelectronics.pdf&#34;&gt;Nucleo-F429ZI board datasheet&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;A microcontroller (uC, or MCU) is a small computer. Typically it has CPU, RAM, flash to store firmware code, and a bunch of pins that stick out. Some pins are used to power the MCU, usually marked as GND (ground) and VCC pins. Other pins are used to communicate with the MCU, by means of high/low voltage applied to those pins. One of the simplest ways of communication is an LED attached to a pin: one LED contact is attached to the ground pin (GND), and another contact is attached to a signal pin via a current-limiting resistor. A firmware code can set high or low voltage on a signal pin, making LED blink:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/mcu.svg?sanitize=true&#34; height=&#34;200&#34;&gt; &#xA;&lt;h3&gt;Memory and registers&lt;/h3&gt; &#xA;&lt;p&gt;The 32-bit address space of the MCU is divided by regions. For example, some region of memory is mapped to the internal MCU flash at a specific address. Firmware code instructions are read and executed by reading from that memory region. Another region is RAM, which is also mapped to a specific address. We can read and write any values to the RAM region.&lt;/p&gt; &#xA;&lt;p&gt;From STM32F429 datasheet, we can take a look at section 2.3.1 and learn that RAM region starts at address 0x20000000 and has size of 192KB. From section 2.4 we can learn that flash is mapped at address 0x08000000. Our MCU has 2MB flash, so flash and RAM regions are located like this:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/mem.svg?sanitize=true&#34;&gt; &#xA;&lt;p&gt;From the datasheet we can also learn that there are many more memory regions. Their address ranges are given in the section 2.3 &#34;Memory Map&#34;. For example, there is a &#34;GPIOA&#34; region that starts at 0x40020000 and has length of 1KB.&lt;/p&gt; &#xA;&lt;p&gt;These memory regions correspond to a different &#34;peripherals&#34; inside the MCU - a piece of silicon circuitry that make certain pins behave in a special way. A peripheral memory region is a collection of 32-bit &lt;strong&gt;registers&lt;/strong&gt;. Each register is a 4-byte memory range at a certain address, that maps to a certain function of the given peripheral. By writing values into a register - in other words, by writing a 32-bit value at a certain memory address, we can control how given peripheral should behave. By reading registers, we can read back peripheral&#39;s data or configuration.&lt;/p&gt; &#xA;&lt;p&gt;There are many different peripherals. One of the simpler ones are GPIO (General Purpose Input Output), which allow user to set MCU pins into &#34;output mode&#34; and set high or low voltage on them. Or, set pins into an &#34;input mode&#34; and read voltage values from them. There is a UART peripheral which can transmit and receive serial data over two pins using serial protocol. There are many other peripherals.&lt;/p&gt; &#xA;&lt;p&gt;Often, there are multiple &#34;instances&#34; of the same peripheral, for example GPIOA, GPIOB, ... which control different set of MCU pins. Likewise, there could be UART1, UART2, ... which allow to implement multiple UART channels. On Nucleo-F429, there are several GPIO and UART peripherals.&lt;/p&gt; &#xA;&lt;p&gt;For example, GPIOA peripheral starts at 0x40020000, and we can find GPIO register description in section 8.4. The datasheet says that &lt;code&gt;GPIOA_MODER&lt;/code&gt; register has offset 0, that means that it&#39;s address is &lt;code&gt;0x40020000 + 0&lt;/code&gt;, and this is the format of the register:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/moder.png&#34; style=&#34;max-width: 100%&#34;&gt; &#xA;&lt;p&gt;The datasheet shows that the 32-bit MODER register is a collection of 2-bit values, 16 in total. Therefore, one MODER register controls 16 physical pins, Bits 0-1 control pin 0, bits 2-3 control pin 1, and so on. The 2-bit value encodes pin mode: 0 means input, 1 means output, 2 means &#34;alternate function&#34; - some specific behavior described elsewhere, and 3 means analog. Since the peripheral name is &#34;GPIOA&#34;, then pins are named &#34;A0&#34;, &#34;A1&#34;, etc. For peripheral &#34;GPIOB&#34;, pin naming would be &#34;B0&#34;, &#34;B1&#34;, ...&lt;/p&gt; &#xA;&lt;p&gt;If we write 32-bit value &lt;code&gt;0&lt;/code&gt; to the register MODER, we&#39;ll set all 16 pins, from A0 to A15, to input mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  * (volatile uint32_t *) (0x40020000 + 0) = 0;  // Set A0-A15 to input mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By setting individual bits, we can selectively set specific pins to a desired mode. For example, this snippet sets pin A3 to output mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  * (volatile uint32_t *) (0x40020000 + 0) &amp;amp;= ~(3 &amp;lt;&amp;lt; 6);  // CLear bits 6-7&#xA;  * (volatile uint32_t *) (0x40020000 + 0) |= 1 &amp;lt;&amp;lt; 6;     // Set bits 6-7 to 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some registers are not mapped to the MCU peripherals, but they are mapped to the ARM CPU configuration and control. For example, there is a &#34;Reset at clock control&#34; unit (RCC), described in section 6 of the datasheet. It describes registers that allow to set systems clock and other things.&lt;/p&gt; &#xA;&lt;h2&gt;Human-readable peripherals programming&lt;/h2&gt; &#xA;&lt;p&gt;In the previous section we have learned that we can read and write peripheral register by direct accessing certain memory addresses. Let&#39;s look at the snippet that sets pin A3 to output mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  * (volatile uint32_t *) (0x40020000 + 0) &amp;amp;= ~(3 &amp;lt;&amp;lt; 6);  // CLear bits 6-7&#xA;  * (volatile uint32_t *) (0x40020000 + 0) |= 1 &amp;lt;&amp;lt; 6;     // Set bits 6-7 to 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is pretty cryptic. Without extensive comments, such code would be quite hard to understand. We can rewrite this code to a much more readable form. The idea is to represent the whole peripheral as a structure that contains 32-bit fields. Let&#39;s see what registers exist for the GPIO peripheral in the section 8.4 of the datasheet. They are MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR. Their offsets are with offsets 0, 4, 8, etc... . That means we can represent them as a structure with 32-bit fields, and make a define for GPIOA:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct gpio {&#xA;  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];&#xA;};&#xA;&#xA;#define GPIOA ((struct gpio *) 0x40020000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, for setting GPIO pin mode, we can define a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Enum values are per datasheet: 0, 1, 2, 3&#xA;enum {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG};&#xA;&#xA;static inline void gpio_set_mode(struct gpio *gpio, uint8_t pin, uint8_t mode) {&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (pin * 2));        // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (pin * 2);   // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we can rewrite the snippet for A3 like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gpio_set_mode(GPIOA, 3 /* pin */, GPIO_MODE_OUTPUT);  // Set A3 to output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our MCU has several GPIO peripherals (also called &#34;banks&#34;): A, B, C, ... K. From section 2.3 we can see that they are 1KB away from each other: GPIOA is at address 0x40020000, GPIOB is at 0x40020400, and so on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can create pin numbering that includes the bank and the pin number. To do that, we use 2-byte &lt;code&gt;uint16_t&lt;/code&gt; value, where upper byte indicates GPIO bank, and lower byte indicates pin number:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define PIN(bank, num) ((((bank) - &#39;A&#39;) &amp;lt;&amp;lt; 8) | (num))&#xA;#define PINNO(pin) (pin &amp;amp; 255)&#xA;#define PINBANK(pin) (pin &amp;gt;&amp;gt; 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way, we can specify pins for any GPIO bank:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint16_t pin1 = PIN(&#39;A&#39;, 3);    // A3   - GPIOA pin 3&#xA;  uint16_t pin2 = PIN(&#39;G&#39;, 11);   // G11  - GPIOG pin 11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s rewrite the &lt;code&gt;gpio_set_mode()&lt;/code&gt; function to take our pin specification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin)); // GPIO bank&#xA;  uint8_t n = PINNO(pin);                 // Pin number&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (n * 2));        // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (n * 2);   // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the code for A3 is self-explanatory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint16_t pin = PIN(&#39;A&#39;, 3);            // Pin A3&#xA;  gpio_set_mode(pin, GPIO_MODE_OUTPUT);  // Set to output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we have created a useful initial API for the GPIO peripheral. Other peripherals, like UART (serial communication) and others - can be implemented in a similar way. This is a good programming practice that makes code self-explanatory and human readable.&lt;/p&gt; &#xA;&lt;h2&gt;MCU boot and vector table&lt;/h2&gt; &#xA;&lt;p&gt;When STM32F429 MCU boots, it reads a so-called &#34;vector table&#34; from the beginning of flash memory. A vector table is a concept common to all ARM MCUs. That is a array of 32-bit addresses of interrupt handlers. First 16 entries are reserved by ARM and are common to all ARM MCUs. The rest of interrupt handlers are specific to the given MCU - these are interrupt handlers for peripherals. Simpler MCUs with few peripherals have few interrupt handlers, and more complex MCUs have many.&lt;/p&gt; &#xA;&lt;p&gt;Vector table for STM32F429 is documented in Table 62. From there we can learn that there are 91 peripheral handlers, in addition to the standard 16.&lt;/p&gt; &#xA;&lt;p&gt;At this point, we are interested in the first two entries of the vector table, because they play a key role in the MCU boot process. Those two first values are: initial stack pointer, and an address of the boot function to execute (a firmware entry point).&lt;/p&gt; &#xA;&lt;p&gt;So now we know, that we must make sure that our firmware should be composed in a way that the 2nd 32-bit value in the flash should contain an address of out boot function. When MCU boots, it&#39;ll read that address from flash, and jump to our boot function.&lt;/p&gt; &#xA;&lt;h2&gt;Minimal firmware&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s create a file &lt;code&gt;main.c&lt;/code&gt;, and specify our boot function that initially does nothing (falls into infinite loop), and specify a vector table that contains 16 standard entries and 91 STM32 entries. In your editor of choice, create &lt;code&gt;main.c&lt;/code&gt; file and copy/paste the following into &lt;code&gt;main.c&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Startup code&#xA;__attribute__((naked, noreturn)) void _reset(void) {&#xA;  for (;;) (void) 0;  // Infinite loop&#xA;}&#xA;&#xA;// 16 standard and 91 STM32-specific handlers&#xA;__attribute__((section(&#34;.vectors&#34;))) void (*tab[16 + 91])(void) = {&#xA;  0, _reset&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For function &lt;code&gt;_reset()&lt;/code&gt;, we have used GCC-specific attributes &lt;code&gt;naked&lt;/code&gt; and &lt;code&gt;noreturn&lt;/code&gt; - they mean, standard function&#39;s prologue and epilogue should not be created by the compiler, and that function does not return.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;void (*tab[16 + 91])(void)&lt;/code&gt; expression means: define an array of 16 + 91 pointers to functions, that return nothing (void) and take to arguments. Each such function is an IRQ handler (Interrupt ReQuest handler). An array of those handlers is called a vector table.&lt;/p&gt; &#xA;&lt;p&gt;The vector table &lt;code&gt;tab&lt;/code&gt; we put in a separate section called &lt;code&gt;.vectors&lt;/code&gt; - that we need later to tell the linker to put that section right at the beginning of the generated firmware - and consecutively, at the beginning of flash memory. We leave the rest of vector table filled with zeroes.&lt;/p&gt; &#xA;&lt;p&gt;Note that we do not set the first entry in the vector table, which is an initial value for the stack pointer. Why? Because we don&#39;t know the correct value for it. We&#39;ll handle it later.&lt;/p&gt; &#xA;&lt;h3&gt;Compilation&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s compile our code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-gcc -mcpu=cortex-m4 main.c -c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That works! The compilation produced a file &lt;code&gt;main.o&lt;/code&gt; which contains our minimal firmware that does nothing. The &lt;code&gt;main.o&lt;/code&gt; file is in ELF binary format, which contains several sections. Let&#39;s see them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-objdump -h main.o&#xA;...&#xA;Sections:&#xA;Idx Name          Size      VMA       LMA       File off  Algn&#xA;  0 .text         00000002  00000000  00000000  00000034  2**1&#xA;                  CONTENTS, ALLOC, LOAD, READONLY, CODE&#xA;  1 .data         00000000  00000000  00000000  00000036  2**0&#xA;                  CONTENTS, ALLOC, LOAD, DATA&#xA;  2 .bss          00000000  00000000  00000000  00000036  2**0&#xA;                  ALLOC&#xA;  3 .vectors      000001ac  00000000  00000000  00000038  2**2&#xA;                  CONTENTS, ALLOC, LOAD, RELOC, DATA&#xA;  4 .comment      0000004a  00000000  00000000  000001e4  2**0&#xA;                  CONTENTS, READONLY&#xA;  5 .ARM.attributes 0000002e  00000000  00000000  0000022e  2**0&#xA;                  CONTENTS, READONLY&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that VMA/LMA addresses for sections are set to 0 - meaning, &lt;code&gt;main.o&lt;/code&gt; is not yet a complete firmware, because it does not contain the information where those section should be loaded in the address space. We need to use a linker to produce a full firmware &lt;code&gt;firmware.elf&lt;/code&gt; from &lt;code&gt;main.o&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The section .text contains firmware code, in our case it is just a _reset() function, 2-bytes long - a jump instruction to its own address. There is an empty &lt;code&gt;.data&lt;/code&gt; section and an empty &lt;code&gt;.bss&lt;/code&gt; section (data that is initialized to zero) . Our firmware will be copied to the flash region at offset 0x8000000, but our data section should reside in RAM - therefore our &lt;code&gt;_reset()&lt;/code&gt; function should copy the contents of the &lt;code&gt;.data&lt;/code&gt; section to RAM. Also it has to write zeroes to the whole &lt;code&gt;.bss&lt;/code&gt; section. Our &lt;code&gt;.data&lt;/code&gt; and &lt;code&gt;.bss&lt;/code&gt; sections are empty, but let&#39;s modify our &lt;code&gt;_reset()&lt;/code&gt; function anyway to handle them properly.&lt;/p&gt; &#xA;&lt;p&gt;Also, our &lt;code&gt;_reset()&lt;/code&gt; function should set the initial stack pointer, cause our vector table has zero in the corresponding entry at index 0.&lt;/p&gt; &#xA;&lt;p&gt;In order to do all that, we must know where stack starts, and where data and bss section start. This we can specify in the &#34;linker script&#34;, which is a file with the instructions to the linker, where to put various sections in the address space, and which symbols to create.&lt;/p&gt; &#xA;&lt;h3&gt;Linker script&lt;/h3&gt; &#xA;&lt;p&gt;Create a minimal linker script &lt;code&gt;link.ld&lt;/code&gt;, and copy-paste contents from &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-0-minimal/link.ld&#34;&gt;step-0-minimal/link.ld&lt;/a&gt;. Below is the explanation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ENTRY(_reset);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This line tells the linker the value of the &#34;entry point&#34; attribute in the generated ELF header - so this is a duplicate to what a vector table has. This is an aid for a debugger (like Ozone, described below) that helps to set a breakpoint at the beginning of the firmware. A debugger does not know about a vector table, so it relies on the ELF header.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;MEMORY {&#xA;  flash(rx)  : ORIGIN = 0x08000000, LENGTH = 2048k&#xA;  sram(rwx) : ORIGIN = 0x20000000, LENGTH = 192k  /* remaining 64k in a separate address space */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tells the linker that we have two memory regions in the address space, their addresses and sizes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;_estack     = ORIGIN(sram) + LENGTH(sram);    /* stack points to end of SRAM */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tell a linker to create a symbol &lt;code&gt;estack&lt;/code&gt; with value at the very end of the RAM memory region. That will be our initial stack value!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  .vectors  : { KEEP(*(.vectors)) }   &amp;gt; flash&#xA;  .text     : { *(.text*) }           &amp;gt; flash&#xA;  .rodata   : { *(.rodata*) }         &amp;gt; flash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These lines tell the linker to put vectors table on flash first, followed by &lt;code&gt;.text&lt;/code&gt; section (firmware code), followed by the read only data &lt;code&gt;.rodata&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The next goes &lt;code&gt;.data&lt;/code&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  .data : {&#xA;    _sdata = .;   /* .data section start */&#xA;    *(.first_data)&#xA;    *(.data SORT(.data.*))&#xA;    _edata = .;  /* .data section end */&#xA;  } &amp;gt; sram AT &amp;gt; flash&#xA;  _sidata = LOADADDR(.data);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we tell linker to create &lt;code&gt;_sdata&lt;/code&gt; and &lt;code&gt;_edata&lt;/code&gt; symbols. We&#39;ll use them to copy data section to RAM in the &lt;code&gt;_reset()&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Same for &lt;code&gt;.bss&lt;/code&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  .bss : {&#xA;    _sbss = .;              /* .bss section start */&#xA;    *(.bss SORT(.bss.*) COMMON)&#xA;    _ebss = .;              /* .bss section end */&#xA;  } &amp;gt; sram&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Startup code&lt;/h3&gt; &#xA;&lt;p&gt;Now we can update our &lt;code&gt;_reset()&lt;/code&gt; function. We initialize stack pointer, copy data section to RAM, and initialise bss section to zeroes. Then, we call main() function - and fall into infinite loop in case if main() returns:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(void) {&#xA;  return 0; // Do nothing so far&#xA;}&#xA;&#xA;// Startup code&#xA;__attribute__((naked, noreturn)) void _reset(void) {&#xA;  asm(&#34;ldr sp, = _estack&#34;);  // Set initial stack pointer&#xA;&#xA;  // memset .bss to zero, and copy .data section to RAM region&#xA;  extern long _sbss, _ebss, _sdata, _edata, _sidata;&#xA;  for (long *src = &amp;amp;_sbss; src &amp;lt; &amp;amp;_ebss; src++) *src = 0;&#xA;  for (long *src = &amp;amp;_sdata, *dst = &amp;amp;_sidata; src &amp;lt; &amp;amp;_edata;) *src++ = *dst++;&#xA;&#xA;  main();             // Call main()&#xA;  for (;;) (void) 0;  // Infinite loop in the case if main() returns&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following diagram visualises how &lt;code&gt;_reset()&lt;/code&gt; initialises .data and .bss:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/mem2.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now we are ready to produce a full firmware file &lt;code&gt;firmware.elf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-gcc -T link.ld -nostdlib main.o -o firmware.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s examine sections in firmware.elf:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-objdump -h firmware.elf&#xA;...&#xA;Sections:&#xA;Idx Name          Size      VMA       LMA       File off  Algn&#xA;  0 .vectors      000001ac  08000000  08000000  00010000  2**2&#xA;                  CONTENTS, ALLOC, LOAD, DATA&#xA;  1 .text         00000058  080001ac  080001ac  000101ac  2**2&#xA;                  CONTENTS, ALLOC, LOAD, READONLY, CODE&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can see that the .vectors section will reside at the very beginning of flash memory at address 0x8000000, then the .text section right after it, at 0x80001ac. Our code does not create any variables, so there is no data section.&lt;/p&gt; &#xA;&lt;h2&gt;Flash firmware&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re ready to flash this firmware! First, extract sections from the firmware.elf into a single contiguous binary blob:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-objcopy -O binary firmware.elf firmware.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use &lt;code&gt;st-link&lt;/code&gt; utility to flash the firmware.bin. Plug your board to the USB, and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ st-flash --reset write firmware.bin 0x8000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Done! We&#39;ve flashed a firmware that does nothing.&lt;/p&gt; &#xA;&lt;h2&gt;Makefile: build automation&lt;/h2&gt; &#xA;&lt;p&gt;Instead of typing those compilation, linking and flashing commands, we can use &lt;code&gt;make&lt;/code&gt; command line tool to automate the whole process. &lt;code&gt;make&lt;/code&gt; utility uses a configuration file named &lt;code&gt;Makefile&lt;/code&gt; where it reads instructions how to execute actions. This automation is great because it also documents the process of building firmware, used compilation flags, etc.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Makefile&lt;/code&gt; format is simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;action1:&#xA;&#x9;command ...     # Comments can go after hash symbol&#xA;&#x9;command ....    # IMPORTANT: command must be preceded with the TAB character&#xA;&#xA;action2:&#xA;&#x9;command ...     # Don&#39;t forget about TAB. Spaces won&#39;t work!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we can invoke &lt;code&gt;make&lt;/code&gt; with the action name (also called &lt;em&gt;target&lt;/em&gt;) to execute a corresponding action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make action1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible to define variables and use them in commands. Also, actions can be file names that needs to be created:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;firmware.elf:&#xA;&#x9;COMPILATION COMMAND .....&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, any action can have a list of dependencies. For example, &lt;code&gt;firmware.elf&lt;/code&gt; depends on our source file &lt;code&gt;main.c&lt;/code&gt;. Whenever &lt;code&gt;main.c&lt;/code&gt; file changes, the &lt;code&gt;make build&lt;/code&gt; command rebuilds &lt;code&gt;firmware.elf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;build: firmware.elf&#xA;&#xA;firmware.elf: main.c&#xA;&#x9;COMPILATION COMMAND&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we are ready to write a Makefile for our firmware. We define a &lt;code&gt;build&lt;/code&gt; action / target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;CFLAGS  ?=  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion \&#xA;            -Wformat-truncation -fno-common -Wconversion \&#xA;            -g3 -Os -ffunction-sections -fdata-sections -I. \&#xA;            -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 $(EXTRA_CFLAGS)&#xA;LDFLAGS ?= -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=$@.map&#xA;SOURCES = main.c &#xA;&#xA;build: firmware.elf&#xA;&#xA;firmware.elf: $(SOURCES)&#xA;&#x9;arm-none-eabi-gcc $(SOURCES) $(CFLAGS) $(LDFLAGS) -o $@&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There, we define compilation flags. The &lt;code&gt;?=&lt;/code&gt; means that&#39;s a default value; we could override them from the command line like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make build CFLAGS=&#34;-O2 ....&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We specify &lt;code&gt;CFLAGS&lt;/code&gt;, &lt;code&gt;LDFLAGS&lt;/code&gt; and &lt;code&gt;SOURCES&lt;/code&gt; variables. Then we tell &lt;code&gt;make&lt;/code&gt;: if you&#39;re told to &lt;code&gt;build&lt;/code&gt;, then create a &lt;code&gt;firmware.elf&lt;/code&gt; file. It depends on the &lt;code&gt;main.c&lt;/code&gt; file, and to create it, start &lt;code&gt;arm-none-eabi-gcc&lt;/code&gt; compiler with a given flags. &lt;code&gt;$@&lt;/code&gt; special variable expands to a target name - in our case, &lt;code&gt;firmware.elf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s call &lt;code&gt;make&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make build&#xA;arm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion -Wformat-truncation -fno-common -Wconversion -g3 -Os -ffunction-sections -fdata-sections -I. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16  -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=firmware.elf.map -o firmware.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we run it again:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make build&#xA;make: Nothing to be done for `build&#39;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;make&lt;/code&gt; utility examines modification times for &lt;code&gt;main.c&lt;/code&gt; dependency and &lt;code&gt;firmware.elf&lt;/code&gt; - and does not do anything if &lt;code&gt;firmware.elf&lt;/code&gt; is up to date. But if we change &lt;code&gt;main.c&lt;/code&gt;, then next &lt;code&gt;make build&lt;/code&gt; will recompile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ touch main.c # Simulate changes in main.c&#xA;$ make build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, what is left - is the &lt;code&gt;flash&lt;/code&gt; target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;firmware.bin: firmware.elf&#xA;&#x9;$(DOCKER) $(CROSS)-objcopy -O binary $&amp;lt; $@&#xA;&#xA;flash: firmware.bin&#xA;&#x9;st-flash --reset write $(TARGET).bin 0x8000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! Now, &lt;code&gt;make flash&lt;/code&gt; terminal command creates a &lt;code&gt;firmware.bin&lt;/code&gt; file, and flashes it to the board. It&#39;ll recompile the firmware if &lt;code&gt;main.c&lt;/code&gt; changes, because &lt;code&gt;firmware.bin&lt;/code&gt; depends on &lt;code&gt;firmware.elf&lt;/code&gt;, and it in turn depends on &lt;code&gt;main.c&lt;/code&gt;. So, now the development cycle would be these two actions in a loop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Develop code in main.c&#xA;$ make flash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is a good idea to add a clean target to remove build artifacts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;clean:&#xA;&#x9;rm -rf firmware.*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-0-minimal&#34;&gt;step-0-minimal&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Blinky LED&lt;/h2&gt; &#xA;&lt;p&gt;Now as we have the whole build / flash infrastructure set up, it is time to teach our firmware to do something useful. Something useful is of course blinking an LED. A Nucleo-F429ZI board has three built-in LEDs. In a Nucleo board datasheet section 6.5 we can see which pins built-in LEDs are attached to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PB0: green LED&lt;/li&gt; &#xA; &lt;li&gt;PB7: blue LED&lt;/li&gt; &#xA; &lt;li&gt;PB14: red LED&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s modify &lt;code&gt;main.c&lt;/code&gt; file and add our definitions for PIN, &lt;code&gt;gpio_set_mode()&lt;/code&gt;. In the main() function, we set the blue LED to output mode, and start an infinite loop. First, let&#39;s copy the definitions for pins and GPIO we have discussed earlier. Note we also add a convenience macro &lt;code&gt;BIT(position)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;inttypes.h&amp;gt;&#xA;#include &amp;lt;stdbool.h&amp;gt;&#xA;&#xA;#define BIT(x) (1UL &amp;lt;&amp;lt; (x))&#xA;#define PIN(bank, num) ((((bank) - &#39;A&#39;) &amp;lt;&amp;lt; 8) | (num))&#xA;#define PINNO(pin) (pin &amp;amp; 255)&#xA;#define PINBANK(pin) (pin &amp;gt;&amp;gt; 8)&#xA;&#xA;struct gpio {&#xA;  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];&#xA;};&#xA;#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))&#xA;&#xA;// Enum values are per datasheet: 0, 1, 2, 3&#xA;enum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };&#xA;&#xA;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (n * 2));         // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (n * 2);    // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some microcontrollers, when they are powered, have all their peripherals powered and enabled, automatically. STM32 MCUs, however, by default have their peripherals disabled in order to save power. In order to enable a GPIO peripheral, it should be enabled (clocked) via the RCC (Reset and Clock Control) unit. In the datasheet section 7.3.10 we find that the AHB1ENR (AHB1 peripheral clock enable register) is responsible to turn GPIO banks on or off. First we add a definition for the whole RCC unit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct rcc {&#xA;  volatile uint32_t CR, PLLCFGR, CFGR, CIR, AHB1RSTR, AHB2RSTR, AHB3RSTR,&#xA;      RESERVED0, APB1RSTR, APB2RSTR, RESERVED1[2], AHB1ENR, AHB2ENR, AHB3ENR,&#xA;      RESERVED2, APB1ENR, APB2ENR, RESERVED3[2], AHB1LPENR, AHB2LPENR,&#xA;      AHB3LPENR, RESERVED4, APB1LPENR, APB2LPENR, RESERVED5[2], BDCR, CSR,&#xA;      RESERVED6[2], SSCGR, PLLI2SCFGR;&#xA;};&#xA;#define RCC ((struct rcc *) 0x40023800)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the AHB1ENR register documentation we see that bits from 0 to 8 inclusive set the clock for GPIO banks GPIOA - GPIOE:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(void) {&#xA;  uint16_t led = PIN(&#39;B&#39;, 7);            // Blue LED&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(PINBANK(led));     // Enable GPIO clock for LED&#xA;  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode&#xA;  for (;;) asm volatile(&#34;nop&#34;);          // Infinite loop&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, what is left to do, is to find out how to set a GPIO pin on and off, and then modify the main loop to set an LED pin on, delay, off, delay. Looking at the datasheet section 8.4.7, wee see that the register BSRR is responsible for setting voltage high or low. The low 16 bit are used to set the ODR register (i.e. set pin high), and high 16 bit are used to reset the ODR register (i.e. set pin low). Let&#39;s define an API function for that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_write(uint16_t pin, bool val) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));&#xA;  gpio-&amp;gt;BSRR |= (1U &amp;lt;&amp;lt; PINNO(pin)) &amp;lt;&amp;lt; (val ? 0 : 16);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next we need to implement a delay function. We do not require an accurate delay at this moment, so let&#39;s define a function &lt;code&gt;spin()&lt;/code&gt; that just executes a NOP instruction a given number of times:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void spin(volatile uint32_t count) {&#xA;  while (count--) asm(&#34;nop&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, we&#39;re ready to modify our main loop to implement LED blinking:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  for (;;) {&#xA;    gpio_write(pin, true);&#xA;    spin(999999);&#xA;    gpio_write(pin, false);&#xA;    spin(999999);&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;make flash&lt;/code&gt; and enjoy blue LED flashing. A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-1-blinky&#34;&gt;step-1-blinky&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Blinky with SysTick interrupt&lt;/h2&gt; &#xA;&lt;p&gt;In order to implement an accurate time keeping, we should enable ARM&#39;s SysTick interrupt. SysTick a 24-bit hardware counter, and is part of ARM core, therefore it is documented by the ARM datasheet. Looking at the datasheet, we see that SysTick has four registers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CTRL - used to enable/disable systick&lt;/li&gt; &#xA; &lt;li&gt;LOAD - an initial counter value&lt;/li&gt; &#xA; &lt;li&gt;VAL - a current counter value, decremented on each clock cycle&lt;/li&gt; &#xA; &lt;li&gt;CALIB - calibration register&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Every time VAL drops to zero, a SysTick interrupt is generated. The SysTick interrupt index in the vector table is 15, so we need to set it. Upon boot, our board Nucleo-F429ZI runs at 16Mhz. We can configure the SysTick counter to trigger interrupt each millisecond.&lt;/p&gt; &#xA;&lt;p&gt;First, let&#39;s define a SysTick peripheral. We know 4 registers, and from the datasheet we can learn that the SysTick address is 0xe000e010. So:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct systick {&#xA;  volatile uint32_t CTRL, LOAD, VAL, CALIB;&#xA;};&#xA;#define SYSTICK ((struct systick *) 0xe000e010)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, add an API function that configures it. We need to enable SysTick in the &lt;code&gt;SYSTICK-&amp;gt;CTRL&lt;/code&gt; register, and also we must clock it via the &lt;code&gt;RCC-&amp;gt;APB2ENR&lt;/code&gt;, described in the section 7.4.14:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define BIT(x) (1UL &amp;lt;&amp;lt; (x))&#xA;static inline void systick_init(uint32_t ticks) {&#xA;  if ((ticks - 1) &amp;gt; 0xffffff) return;  // Systick timer is 24 bit&#xA;  SYSTICK-&amp;gt;LOAD = ticks - 1;&#xA;  SYSTICK-&amp;gt;VAL = 0;&#xA;  SYSTICK-&amp;gt;CTRL = BIT(0) | BIT(1) | BIT(2);  // Enable systick&#xA;  RCC-&amp;gt;APB2ENR |= BIT(14);                   // Enable SYSCFG&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, Nucleo-F429ZI board runs at 16Mhz. That means, if we call &lt;code&gt;systick_init(16000000 / 1000);&lt;/code&gt;, then SysTick interrupt will be generated every millisecond. We should have interrupt handler function defined - here it is, we simply increment a 32-bit millisecond counter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static volatile uint32_t s_ticks;&#xA;void SysTick_Handler(void) {&#xA;  s_ticks++;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And we should add this handler to the vector table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__attribute__((section(&#34;.vectors&#34;))) void (*tab[16 + 91])(void) = {&#xA;    0, _reset, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SysTick_Handler};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we have a precise millisecond clock! Let&#39;s create a helper function for arbitrary periodic timers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// t: expiration time, prd: period, now: current time. Return true if expired&#xA;bool timer_expired(uint32_t *t, uint64_t prd, uint64_t now) {&#xA;  if (now + prd &amp;lt; *t) *t = 0;                    // Time wrapped? Reset timer&#xA;  if (*t == 0) *t = now + prd;                   // First poll? Set expiration&#xA;  if (*t &amp;gt; now) return false;                    // Not expired yet, return&#xA;  *t = (now - *t) &amp;gt; prd ? now + prd : *t + prd;  // Next expiration time&#xA;  return true;                                   // Expired, return true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we are ready to update our main loop and use a precise timer for LED blink. For example, let&#39;s use 250 milliseconds blinking interval:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint32_t timer, period = 250;          // Declare timer and 250ms period&#xA;  for (;;) {&#xA;    if (timer_expired(&amp;amp;timer, period, s_ticks)) {&#xA;      static bool on;       // This block is executed&#xA;      gpio_write(led, on);  // Every `period` milliseconds&#xA;      on = !on;             // Toggle LED state&#xA;    }&#xA;    // Here we could perform other activities!&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that using SysTick, and a helper &lt;code&gt;timer_expired()&lt;/code&gt; function, we made our main loop (also called superloop) non-blocking. That means that inside that loop we can perform many actions - for example, have different timers with different periods, and they all will be triggered in time.&lt;/p&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-2-systick&#34;&gt;step-2-systick&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Add UART debug output&lt;/h2&gt; &#xA;&lt;p&gt;Now it&#39;s time to add a human-readable diagnostics to our firmware. One of the MCU peripherals is a serial UART interface. Looking at the datasheet section 2.3, we see that there are several UART/USART controllers - i.e. pieces of circuitry inside MCU that, properly configured, can exchange data via certain pins. A mimimal UART setup uses two pins, RX (receive) and TX (transmit).&lt;/p&gt; &#xA;&lt;p&gt;In a Nucleo board datasheet section 6.9 we see that one of the controllers, USART3, is using pins PD8 (TX) and PD9 (RX) and is connected to the on-board ST-LINK debugger. That means that if we configure USART3 and output data via the PD9 pin, we can see it on our workstation via the ST-LINK USB connection.&lt;/p&gt; &#xA;&lt;p&gt;Thus, let us create a handy API for the UART, the way we did it for GPIO. Datasheet section 30.6 summarises UART registers - so here is our UART struct:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct uart {&#xA;  volatile uint32_t SR, DR, BRR, CR1, CR2, CR3, GTPR;&#xA;};&#xA;#define UART1 ((struct uart *) 0x40011000)&#xA;#define UART2 ((struct uart *) 0x40004400)&#xA;#define UART3 ((struct uart *) 0x40004800)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To configure UART, we need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enable UART clock by setting appropriate bit in &lt;code&gt;RCC-&amp;gt;APB2ENR&lt;/code&gt; register&lt;/li&gt; &#xA; &lt;li&gt;Set &#34;alternate function&#34; pin mode for RX and TX pins. There can be several alternate functions (AF) for any given pin, depending on the peripheral that is used. The AF list can be found in the &lt;a href=&#34;https://www.st.com/resource/en/datasheet/stm32f429zi.pdf&#34;&gt;STM32F429ZI&lt;/a&gt; table 12&lt;/li&gt; &#xA; &lt;li&gt;Set baud rate (receive/transmit clock frequency) via the BRR register&lt;/li&gt; &#xA; &lt;li&gt;Enable the peripheral, receive and transmit via the CR1 register&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We already know how to set a GPIO pin into a specific mode. If a pin is in the AF mode, we also need to specify the &#34;function number&#34;, i.e. which exactly peripheral takes control. This can be done via the &#34;alternate function register&#34;, &lt;code&gt;AFR&lt;/code&gt;, of the GPIO peripheral. Reading the AFR register description in the datasheet, we can see that the AF number occupies 4 bits, thus the whole setup for 16 pins occupies 2 registers. If a p&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_set_af(uint16_t pin, uint8_t af_num) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  gpio-&amp;gt;AFR[n &amp;gt;&amp;gt; 3] &amp;amp;= ~(15UL &amp;lt;&amp;lt; ((n &amp;amp; 7) * 4));&#xA;  gpio-&amp;gt;AFR[n &amp;gt;&amp;gt; 3] |= ((uint32_t) af_num) &amp;lt;&amp;lt; ((n &amp;amp; 7) * 4);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to completely hide register-specific code from the GPIO API, let&#39;s move the GPIO clock init to the &lt;code&gt;gpio_set_mode()&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(PINBANK(pin));       // Enable GPIO clock&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we&#39;re ready to create a UART initialization API function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define FREQ 16000000  // CPU frequency, 16 Mhz&#xA;static inline void uart_init(struct uart *uart, unsigned long baud) {&#xA;  // https://www.st.com/resource/en/datasheet/stm32f429zi.pdf&#xA;  uint8_t af = 0;           // Alternate function&#xA;  uint16_t rx = 0, tx = 0;  // pins&#xA;&#xA;  if (uart == UART1) RCC-&amp;gt;APB2ENR |= BIT(4);&#xA;  if (uart == UART2) RCC-&amp;gt;APB1ENR |= BIT(17);&#xA;  if (uart == UART3) RCC-&amp;gt;APB1ENR |= BIT(18);&#xA;&#xA;  if (uart == UART1) af = 4, tx = PIN(&#39;A&#39;, 9), rx = PIN(&#39;A&#39;, 10);&#xA;  if (uart == UART2) af = 4, tx = PIN(&#39;A&#39;, 2), rx = PIN(&#39;A&#39;, 3);&#xA;  if (uart == UART3) af = 7, tx = PIN(&#39;D&#39;, 8), rx = PIN(&#39;D&#39;, 9);&#xA;&#xA;  gpio_set_mode(tx, GPIO_MODE_AF);&#xA;  gpio_set_af(tx, af);&#xA;  gpio_set_mode(rx, GPIO_MODE_AF);&#xA;  gpio_set_af(rx, af);&#xA;  uart-&amp;gt;CR1 = 0;                           // Disable this UART&#xA;  uart-&amp;gt;BRR = FREQ / baud;                 // FREQ is a CPU frequency &#xA;  uart-&amp;gt;CR1 |= BIT(13) | BIT(2) | BIT(3);  // Set UE, RE, TE&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, finally, functions for reading and writing to the UART. The datasheet section 30.6.1 tells us that the status register SR tells us whether data is ready:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline int uart_read_ready(struct uart *uart) {&#xA;  return uart-&amp;gt;SR &amp;amp; BIT(5);  // If RXNE bit is set, data is ready&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The data byte itself can be fetched from the data register DR:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline uint8_t uart_read_byte(struct uart *uart) {&#xA;  return (uint8_t) (uart-&amp;gt;DR &amp;amp; 255);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Transmitting a single byte can be done via the data register too. After setting a byte to write, we need to wait for the transmission to end, indicated via bit 7 in the status register:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void uart_write_byte(struct uart *uart, uint8_t byte) {&#xA;  uart-&amp;gt;DR = byte;&#xA;  while ((uart-&amp;gt;SR &amp;amp; BIT(7)) == 0) spin(1);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And writing a buffer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void uart_write_buf(struct uart *uart, char *buf, size_t len) {&#xA;  while (len-- &amp;gt; 0) uart_write_byte(uart, *(uint8_t *) buf++);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, initialise UART in our main() function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  ...&#xA;  uart_init(UART3, 115200);              // Initialise UART&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we&#39;re ready to print a message &#34;hi\r\n&#34; every time LED blinks!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (timer_expired(&amp;amp;timer, period, s_ticks)) {&#xA;      ...&#xA;      uart_write_buf(UART3, &#34;hi\r\n&#34;, 4);  // Write message&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rebuild, reflash, and attach a terminal program to the ST-LINK port. On my Mac workstation, I use &lt;code&gt;cu&lt;/code&gt;. It also can be used on Linux. On Windows, using &lt;code&gt;putty&lt;/code&gt; utility can be a good idea. Run a terminal and see the messages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cu -l /dev/cu.YOUR_SERIAL_PORT -s 115200&#xA;hi&#xA;hi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-3-uart&#34;&gt;step-3-uart&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Redirect printf() to UART&lt;/h2&gt; &#xA;&lt;p&gt;In this section, we replace &lt;code&gt;uart_write_buf()&lt;/code&gt; call by &lt;code&gt;printf()&lt;/code&gt; call, which gives us an ability to do formatted output - and increase our abilities to print diagnostic information, implemeting so called &#34;printf-style debugging&#34;.&lt;/p&gt; &#xA;&lt;p&gt;A GNU ARM toolchain that we&#39;re using comes not only with a GCC compiler and other tools, but with a C library called newlib, &lt;a href=&#34;https://sourceware.org/newlib&#34;&gt;https://sourceware.org/newlib&lt;/a&gt;. A newlib library was developed by RedHat for embedded systems.&lt;/p&gt; &#xA;&lt;p&gt;If our firmware calls a standard C library function, for example &lt;code&gt;strcmp()&lt;/code&gt;, then a newlib code will be added to our firmware by the GCC linker.&lt;/p&gt; &#xA;&lt;p&gt;Some of the standard C functions that newlib implements, specifically, file input/output (IO) operations, implemented by the newlib is a special fashion: those functions eventually call a set of low-level IO functions called &#34;sycalls&#34;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;fopen()&lt;/code&gt; eventually calls &lt;code&gt;_open()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fread()&lt;/code&gt; eventually calls a low level &lt;code&gt;_read()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fwrite()&lt;/code&gt;, &lt;code&gt;fprintf()&lt;/code&gt;, &lt;code&gt;printf()&lt;/code&gt; eventually call a low level &lt;code&gt;_write()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;malloc()&lt;/code&gt; eventually calls &lt;code&gt;_sbrk()&lt;/code&gt;, and so on.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thus, by modifying a &lt;code&gt;_write()&lt;/code&gt; syscall, we can redirect printf() to whatever we want. That mechanism is called &#34;IO retargeting&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Note: STM32 Cube also uses ARM GCC with newlib, that&#39;s why Cube projects typically include &lt;code&gt;syscalls.c&lt;/code&gt; file. Other toolchains, like TI&#39;s CCS, Keil&#39;s CC, might use a different C library with a bit different retargeting mechanism. We use newlib, so let&#39;s modify &lt;code&gt;_write()&lt;/code&gt; syscall to print to the UART3.&lt;/p&gt; &#xA;&lt;p&gt;Before that, let&#39;s organise our source code in the following way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;move all API definitions to the file &lt;code&gt;mcu.h&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;move startup code to &lt;code&gt;startup.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;create an empty file &lt;code&gt;syscalls.c&lt;/code&gt; for newlib &#34;syscalls&#34;&lt;/li&gt; &#xA; &lt;li&gt;modify Makefile to add &lt;code&gt;syscalls.c&lt;/code&gt; and &lt;code&gt;startup.c&lt;/code&gt; to the build&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After moving all API definitions to the &lt;code&gt;mcu.h&lt;/code&gt;, our &lt;code&gt;main.c&lt;/code&gt; file becomes quite compact. Note that it does not have any mention of the low-level registers, just a high level API functions that are easy to understand:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;mcu.h&#34;&#xA;&#xA;static volatile uint32_t s_ticks;&#xA;void SysTick_Handler(void) {&#xA;  s_ticks++;&#xA;}&#xA;&#xA;int main(void) {&#xA;  uint16_t led = PIN(&#39;B&#39;, 7);            // Blue LED&#xA;  systick_init(16000000 / 1000);         // Tick every 1 ms&#xA;  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode&#xA;  uart_init(UART3, 115200);              // Initialise UART&#xA;  uint32_t timer = 0, period = 250;      // Declare timer and 250ms period&#xA;  for (;;) {&#xA;    if (timer_expired(&amp;amp;timer, period, s_ticks)) {&#xA;      static bool on;                      // This block is executed&#xA;      gpio_write(led, on);                 // Every `period` milliseconds&#xA;      on = !on;                            // Toggle LED state&#xA;      uart_write_buf(UART3, &#34;hi\r\n&#34;, 4);  // Write message&#xA;    }&#xA;    // Here we could perform other activities!&#xA;  }&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Great, now let&#39;s retarget printf to the UART3. In the empty syscalls.c, copy/paste the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;mcu.h&#34;&#xA;&#xA;int _write(int fd, char *ptr, int len) {&#xA;  (void) fd, (void) ptr, (void) len;&#xA;  if (fd == 1) uart_write_buf(UART3, ptr, (size_t) len);&#xA;  return -1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we say: if the file descriptor we&#39;re writing to is 1 (which is a standard output descriptor), then write the buffer to the UART3. Otherwise, ignore. This is the essence of retargeting!&lt;/p&gt; &#xA;&lt;p&gt;Rebuilding this firmware results in a bunch of linker errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-sbrkr.o): in function `_sbrk_r&#39;:&#xA;sbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk&#39;&#xA;closer.c:(.text._close_r+0xc): undefined reference to `_close&#39;&#xA;lseekr.c:(.text._lseek_r+0x10): undefined reference to `_lseek&#39;&#xA;readr.c:(.text._read_r+0x10): undefined reference to `_read&#39;&#xA;fstatr.c:(.text._fstat_r+0xe): undefined reference to `_fstat&#39;&#xA;isattyr.c:(.text._isatty_r+0xc): undefined reference to `_isatty&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since we&#39;ve used a newlib stdio function, we need to supply newlib with the rest of syscalls. Let&#39;s add just a simple stubs that do nothing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int _fstat(int fd, struct stat *st) {&#xA;  (void) fd, (void) st;&#xA;  return -1;&#xA;}&#xA;&#xA;void *_sbrk(int incr) {&#xA;  (void) incr;&#xA;  return NULL;&#xA;}&#xA;&#xA;int _close(int fd) {&#xA;  (void) fd;&#xA;  return -1;&#xA;}&#xA;&#xA;int _isatty(int fd) {&#xA;  (void) fd;&#xA;  return 1;&#xA;}&#xA;&#xA;int _read(int fd, char *ptr, int len) {&#xA;  (void) fd, (void) ptr, (void) len;&#xA;  return -1;&#xA;}&#xA;&#xA;int _lseek(int fd, int ptr, int dir) {&#xA;  (void) fd, (void) ptr, (void) dir;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, rebuild gives no errors. Last step: replace the &lt;code&gt;uart_write_buf()&lt;/code&gt; call in the &lt;code&gt;main()&lt;/code&gt; function with &lt;code&gt;printf()&lt;/code&gt; call that prints something useful, e.g. a LED status and a current value of systick:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&#34;LED: %d, tick: %lu\r\n&#34;, on, s_ticks);  // Write message&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The serial output looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;LED: 1, tick: 250&#xA;LED: 0, tick: 500&#xA;LED: 1, tick: 750&#xA;LED: 0, tick: 1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Congratulations! We learned how IO retargeting works, and can now printf-debug our firmware. A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-4-printf&#34;&gt;step-4-printf&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Debug with Segger Ozone&lt;/h2&gt; &#xA;&lt;p&gt;What if our firmware is stuck somewhere and printf debug does not work? What if even a startup code does not work? We would need a debugger. There are many options, but I&#39;d recommend using an Ozone debugger from Segger. Why? Because it is stand-alone. It does not need any IDE set up. We can feed our &lt;code&gt;firmware.elf&lt;/code&gt; directly to Ozone, and it&#39;ll pick up our source files.&lt;/p&gt; &#xA;&lt;p&gt;So, &lt;a href=&#34;https://www.segger.com/products/development-tools/ozone-j-link-debugger/&#34;&gt;download Ozone&lt;/a&gt; from the Segger website. Before we can use it with our Nucleo board, we need to convert ST-LINK firmware on the onboard debugger to the jlink firmware that Ozone understands. Follow the &lt;a href=&#34;https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/&#34;&gt;instructions&lt;/a&gt; on the Segger site.&lt;/p&gt; &#xA;&lt;p&gt;Now, run Ozone. Choose our device in the wizard:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone1.png&#34; width=&#34;50%&#34;&gt; &#xA;&lt;p&gt;Select a debugger we&#39;re going to use - that should be a ST-LINK:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone2.png&#34; width=&#34;50%&#34;&gt; &#xA;&lt;p&gt;Choose our firmware.elf file:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone3.png&#34; width=&#34;50%&#34;&gt; &#xA;&lt;p&gt;Leave the defaults on the next screen, click Finish, and we&#39;ve got our debugger loaded (note the mcu.h source code is picked up):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Click the green button to download, run the firmware, and we&#39;re stopped here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now we can single-step through code, set breakpoints, and do the usual debugging stuff. One thing that could be noted, is a handy Ozone peripheral view:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Using it, we can directly examine or set the state of the peripherals. For example, let&#39;s turn on a green on-board LED (PB0):&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We need to clock GPIOB first. Find Peripherals -&amp;gt; RCC -&amp;gt; AHB1ENR, and enable GPIOBEN bit - set it to 1:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone7.png&#34; width=&#34;75%&#34;&gt; 2. Find Peripherals -&amp;gt; GPIO -&amp;gt; GPIOB -&amp;gt; MODER, set MODER0 to 1 (output): &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone8.png&#34; width=&#34;75%&#34;&gt; 3. Find Peripherals -&amp;gt; GPIO -&amp;gt; GPIOB -&amp;gt; ODR, set ODR0 to 1 (on): &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone9.png&#34; width=&#34;75%&#34;&gt; &#xA;&lt;p&gt;Now, a green LED should be on! Happy debugging.&lt;/p&gt; &#xA;&lt;h2&gt;Vendor CMSIS headers&lt;/h2&gt; &#xA;&lt;p&gt;In the previous sections, we have developed the firmware using only datasheets, editor, and GCC compiler. We have created peripheral structure definitions manually, using datasheets.&lt;/p&gt; &#xA;&lt;p&gt;Now as you know how it all works, it is time to introduce CMSIS headers. What is it ? These are header files with all definitions, created and supplied by the MCU vendor. They contain definitions for everything that MCU contains, therefore they rather big.&lt;/p&gt; &#xA;&lt;p&gt;CMSIS stands for Common Microcontroller Software Interface Standard, thus it is a common ground for the MCU manufacturers to specify peripheral API. Since CMSIS is an ARM standard, and since CMSIS headers are supplied by the MCU vendor, they are the source of authority. Therefore, using vendor headers is is a preferred way, rather than writing definitions manually.&lt;/p&gt; &#xA;&lt;p&gt;In this section, we will replace our API functions in the &lt;code&gt;mcu.h&lt;/code&gt; by the CMSIS vendor header, and leave the rest of the firmware intact.&lt;/p&gt; &#xA;&lt;p&gt;STM32 CMSIS headers for F4 family can be found at &lt;a href=&#34;https://github.com/STMicroelectronics/cmsis_device_f4&#34;&gt;https://github.com/STMicroelectronics/cmsis_device_f4&lt;/a&gt; repo. From there, copy the following files into our firmware directory, &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-5-cmsis&#34;&gt;step-5-cmsis&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f4/master/Include/stm32f429xx.h&#34;&gt;stm32f429xx.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f4/master/Include/system_stm32f4xx.h&#34;&gt;system_stm32f4xx.h&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Those two files depend on a standard ARM CMSIS includes, download them too:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/core_cm4.h&#34;&gt;core_cm4.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_gcc.h&#34;&gt;cmsis_gcc.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_version.h&#34;&gt;cmsis_version.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_compiler.h&#34;&gt;cmsis_compiler.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/mpu_armv7.h&#34;&gt;mpu_armv7.h&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;From the &lt;code&gt;mcu.h&lt;/code&gt;, remove all peripheral API and definitions, and leave only standard C inludes, vendor CMSIS include, defines to PIN, BIT, FREQ, and &lt;code&gt;timer_expired()&lt;/code&gt; helper function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#pragma once&#xA;&#xA;#include &amp;lt;inttypes.h&amp;gt;&#xA;#include &amp;lt;stdbool.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;sys/stat.h&amp;gt;&#xA;&#xA;#include &#34;stm32f429xx.h&#34;&#xA;&#xA;#define FREQ 16000000  // CPU frequency, 16 Mhz&#xA;#define BIT(x) (1UL &amp;lt;&amp;lt; (x))&#xA;#define PIN(bank, num) ((((bank) - &#39;A&#39;) &amp;lt;&amp;lt; 8) | (num))&#xA;#define PINNO(pin) (pin &amp;amp; 255)&#xA;#define PINBANK(pin) (pin &amp;gt;&amp;gt; 8)&#xA;&#xA;static inline void spin(volatile uint32_t count) {&#xA;  while (count--) asm(&#34;nop&#34;);&#xA;}&#xA;&#xA;static inline bool timer_expired(uint32_t *t, uint32_t prd, uint32_t now) {&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we try to rebuild the firmware - &lt;code&gt;make clean build&lt;/code&gt;, then GCC will fail complaining about missing &lt;code&gt;systick_init()&lt;/code&gt;, &lt;code&gt;GPIO_MODE_OUTPUT&lt;/code&gt;, &lt;code&gt;uart_init()&lt;/code&gt;, and &lt;code&gt;UART3&lt;/code&gt;. Let&#39;s add those using STM32 CMSIS files.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s start from &lt;code&gt;systick_init()&lt;/code&gt;. The &lt;code&gt;core_cm4.h&lt;/code&gt; header defines &lt;code&gt;SysTick_Type&lt;/code&gt; structure which is identical to our &lt;code&gt;struct systick&lt;/code&gt;, and has an appropriate #define for &lt;code&gt;SysTick&lt;/code&gt; peripheral. Also, &lt;code&gt;stm32f429xx.h&lt;/code&gt; has a &lt;code&gt;RCC_TypeDef&lt;/code&gt; structure and appropriate #define for the &lt;code&gt;RCC&lt;/code&gt;. Therefore our &lt;code&gt;systick_init()&lt;/code&gt; function remains almost unchanged: we only have to replace &lt;code&gt;SYSTICK&lt;/code&gt; with &lt;code&gt;SysTick&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void systick_init(uint32_t ticks) {&#xA;  if ((ticks - 1) &amp;gt; 0xffffff) return;  // Systick timer is 24 bit&#xA;  SysTick-&amp;gt;LOAD = ticks - 1;&#xA;  SysTick-&amp;gt;VAL = 0;&#xA;  SysTick-&amp;gt;CTRL = BIT(0) | BIT(1) | BIT(2);  // Enable systick&#xA;  RCC-&amp;gt;APB2ENR |= BIT(14);                   // Enable SYSCFG&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next goes &lt;code&gt;gpio_set_mode()&lt;/code&gt; function. The &lt;code&gt;stm32f429xx.h&lt;/code&gt; header has &lt;code&gt;GPIO_TypeDef&lt;/code&gt; structure, identical to our &lt;code&gt;struct gpio&lt;/code&gt;. Let&#39;s use it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define GPIO(bank) ((GPIO_TypeDef *) (GPIOA_BASE + 0x400 * (bank)))&#xA;enum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };&#xA;&#xA;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  GPIO_TypeDef *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(PINBANK(pin));       // Enable GPIO clock&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (n * 2));         // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (n * 2);    // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;gpio_set_af()&lt;/code&gt; and &lt;code&gt;gpio_write()&lt;/code&gt; functions is also trivial - simply replace &lt;code&gt;struct gpio&lt;/code&gt; with &lt;code&gt;GPIO_TypeDef&lt;/code&gt;, and that&#39;s all.&lt;/p&gt; &#xA;&lt;p&gt;Next goes UART. There is a &lt;code&gt;USART_TypeDef&lt;/code&gt;, and defines for USART1, USART2, USART3. Let&#39;s use them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define UART1 USART1&#xA;#define UART2 USART2&#xA;#define UART3 USART3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;code&gt;uart_init()&lt;/code&gt; and the rest of UART functions, change &lt;code&gt;struct uart&lt;/code&gt; to &lt;code&gt;USART_TypeDef&lt;/code&gt;. The rest stays the same!&lt;/p&gt; &#xA;&lt;p&gt;And we are done. Rebuild, reflash the firmware. The LED blinks, the UART shows the output. Congratulations, we have adopted our firmware code to use vendor CMSIS header files. Now let&#39;s reorganise the repository a bit by moving all standard files into &lt;code&gt;include&lt;/code&gt; directory and updating Makefile to let GCC know about it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;...&#xA;  -g3 -Os -ffunction-sections -fdata-sections -I. -Iinclude \&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have left with a project template that can be reused for the future projects. A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-5-cmsis&#34;&gt;step-5-cmsis&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Setting up clocks&lt;/h2&gt; &#xA;&lt;p&gt;After boot, Nucleo-F429ZI CPU runs at 16MHz. The maximum frequency is 180MHz. Note that system clock frequency is not the only factor we need to care about. Peripherals are attached to different buses, APB1 and APB2 which are clocked differently. Their clock speeds are configured by the frequency prescaler values, set in the RCC. The main CPU clock source can also be different - we can use either an external crystal oscillator (HSE) or an internal oscillator (HSI). In our case, we&#39;ll use HSI.&lt;/p&gt; &#xA;&lt;p&gt;When CPU executes instructions from flash, a flash read speed (which is around 25MHz) becomes a bottleneck if CPU clock gets higher. There are several tricks that can help. Instruction prefetch is one. Also, we can give a clue to the flash controller, how faster the system clock is: that value is called flash latency. For 180MHz system clock, the &lt;code&gt;FLASH_LATENCY&lt;/code&gt; value is 5. Bits 8 and 9 in the flash controller enable instruction and data caches:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  FLASH-&amp;gt;ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash latency, caches&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The clock source (HSI or HSE) goes through a piece of hardware called PLL, which multiplies source frequency by a certain value. Then, a set of frequency dividers are used to set the system clock and APB1, APB2 clocks. In order to obtain the maximum system clock of 180MHz, multiple values of PLL dividers and APB prescalers are possible. Section 6.3.3 of the datasheet tells us the maximum values for APB1 clock: &amp;lt;= 45MHz, and the APB2 clock: &amp;lt;= 90MHz. That narrows down the list of possible combinations. Here we chose the values manually. Note that tools like CubeMX can automate the process and make it easy and visual.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum { APB1_PRE = 5 /* AHB clock / 4 */, APB2_PRE = 4 /* AHB clock / 2 */ };&#xA;enum { PLL_HSI = 16, PLL_M = 8, PLL_N = 180, PLL_P = 2 };  // Run at 180 Mhz&#xA;#define PLL_FREQ (PLL_HSI * PLL_N / PLL_M / PLL_P)&#xA;#define FREQ (PLL_FREQ * 1000000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we&#39;re ready for a simple algorithm to set up the clock for CPU and peripheral buses may look like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optionally, enable FPU&lt;/li&gt; &#xA; &lt;li&gt;Set flash latency&lt;/li&gt; &#xA; &lt;li&gt;Decide on a clock source, and PLL, APB1 and APB2 prescalers&lt;/li&gt; &#xA; &lt;li&gt;Configure RCC by setting respective values:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void clock_init(void) {                 // Set clock frequency&#xA;  SCB-&amp;gt;CPACR |= ((3UL &amp;lt;&amp;lt; 10 * 2) | (3UL &amp;lt;&amp;lt; 11 * 2));  // Enable FPU&#xA;  FLASH-&amp;gt;ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash latency, caches&#xA;  RCC-&amp;gt;PLLCFGR &amp;amp;= ~((BIT(17) - 1));                   // Clear PLL multipliers&#xA;  RCC-&amp;gt;PLLCFGR |= (((PLL_P - 2) / 2) &amp;amp; 3) &amp;lt;&amp;lt; 16;      // Set PLL_P&#xA;  RCC-&amp;gt;PLLCFGR |= PLL_M | (PLL_N &amp;lt;&amp;lt; 6);               // Set PLL_M and PLL_N&#xA;  RCC-&amp;gt;CR |= BIT(24);                                 // Enable PLL&#xA;  while ((RCC-&amp;gt;CR &amp;amp; BIT(25)) == 0) spin(1);           // Wait until done&#xA;  RCC-&amp;gt;CFGR = (APB1_PRE &amp;lt;&amp;lt; 10) | (APB2_PRE &amp;lt;&amp;lt; 13);    // Set prescalers&#xA;  RCC-&amp;gt;CFGR |= 2;                                     // Set clock source to PLL&#xA;  while ((RCC-&amp;gt;CFGR &amp;amp; 12) == 0) spin(1);              // Wait until done&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What is left, is to call &lt;code&gt;clock_init()&lt;/code&gt; from main, then rebuild and reflash. And our board runs at its maximum speed, 180MHz! A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-6-clock&#34;&gt;step-6-clock&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Web server with device dashboard&lt;/h2&gt; &#xA;&lt;p&gt;The Nucleo-F429ZI comes with Ethernet on-board. Ethernet hardware needs two components: a PHY (which transmits/receives electrical signals to the media like copper, optical cable, etc) and MAC (which drives PHY controller). On our Nucleo, the MAC controller is built-in, and the PHY is external (specifically, is is Microchip&#39;s LAN8720a).&lt;/p&gt; &#xA;&lt;p&gt;MAC and PHY can talk several interfaces, we&#39;ll use RMII. For that, a bunch of pins must be configured to use their Alternative Function (AF). To implement a web server, we need 3 software components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a network driver, which sends/receives Ethernet frames to/from MAC controller&lt;/li&gt; &#xA; &lt;li&gt;a network stack, that parses frames and understands TCP/IP&lt;/li&gt; &#xA; &lt;li&gt;a network library that understands HTTP&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We will use &lt;a href=&#34;https://github.com/cesanta/mongoose&#34;&gt;Mongoose Network Library&lt;/a&gt; which implements all of that in a single file. It is a dual-licensed library (GPLv2/commercial) that was designed to make network embedded development fast and easy.&lt;/p&gt; &#xA;&lt;p&gt;So, copy &lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.c&#34;&gt;mongoose.c&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.h&#34;&gt;mongoose.h&lt;/a&gt; to our project. Now we have a driver, a network stack, and a library at hand. Mongoose also provides a large set of examples, and one of them is a &lt;a href=&#34;https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard&#34;&gt;device dashboard example&lt;/a&gt;. It implements lots of things - like dashboard login, real-time data exchange over WebSocket, embedded file system, MQTT communication, etcetera. So let&#39;s use that example. Copy two extra files:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/net.c&#34;&gt;net.c&lt;/a&gt; - implements dashboard functionality&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/packed_fs.c&#34;&gt;packed_fs.c&lt;/a&gt; - contains HTML/CSS/JS GUI files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What we need is to tell Mongoose which functionality to enable. That can be done via compilation flags, by setting preprocessor constants. Alternatively, the same constants can be set in the &lt;code&gt;mongoose_custom.h&lt;/code&gt; file. Let&#39;s go the second way. Create &lt;code&gt;mongoose_custom.h&lt;/code&gt; file with the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#pragma once&#xA;#define MG_ARCH MG_ARCH_NEWLIB&#xA;#define MG_ENABLE_MIP 1&#xA;#define MG_ENABLE_PACKED_FS 1&#xA;#define MG_IO_SIZE 512&#xA;#define MG_ENABLE_CUSTOM_MILLIS 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now it&#39;s time to add some networking code to main.c. We &lt;code&gt;#include &#34;mongoose.c&#34;&lt;/code&gt;, initialise Ethernet RMII pins and enable Ethernet in the RCC:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint16_t pins[] = {PIN(&#39;A&#39;, 1),  PIN(&#39;A&#39;, 2),  PIN(&#39;A&#39;, 7),&#xA;                     PIN(&#39;B&#39;, 13), PIN(&#39;C&#39;, 1),  PIN(&#39;C&#39;, 4),&#xA;                     PIN(&#39;C&#39;, 5),  PIN(&#39;G&#39;, 11), PIN(&#39;G&#39;, 13)};&#xA;  for (size_t i = 0; i &amp;lt; sizeof(pins) / sizeof(pins[0]); i++) {&#xA;    gpio_init(pins[i], GPIO_MODE_AF, GPIO_OTYPE_PUSH_PULL, GPIO_SPEED_INSANE,&#xA;              GPIO_PULL_NONE, 11);&#xA;  }&#xA;  nvic_enable_irq(61);                          // Setup Ethernet IRQ handler&#xA;  RCC-&amp;gt;APB2ENR |= BIT(14);                      // Enable SYSCFG&#xA;  SYSCFG-&amp;gt;PMC |= BIT(23);                       // Use RMII. Goes first!&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(25) | BIT(26) | BIT(27);  // Enable Ethernet clocks&#xA;  RCC-&amp;gt;AHB1RSTR |= BIT(25);                     // ETHMAC force reset&#xA;  RCC-&amp;gt;AHB1RSTR &amp;amp;= ~BIT(25);                    // ETHMAC release reset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mongoose&#39;s driver uses Ethernet interrupt, thus we need to update &lt;code&gt;startup.c&lt;/code&gt; and add &lt;code&gt;ETH_IRQHandler&lt;/code&gt; to the vector table. Let&#39;s reorganise vector table definition in &lt;code&gt;startup.c&lt;/code&gt; in a way that does not require any modification to add an interrupt handler function. The idea is to use a &#34;weak symbol&#34; concept.&lt;/p&gt; &#xA;&lt;p&gt;A function can be marked &#34;weak&#34; and it works like a normal function. The difference comes when a source code defines a function with the same name elsewhere. Normally, two functions with the same name make a build fail. However if one function is marked weak, then a build succeeds and linker selects a non-weak function. This gives an ability to provide a &#34;default&#34; function in a boilerplate, with an ability to override it by simply creating a function with the same name elsewhere in the code.&lt;/p&gt; &#xA;&lt;p&gt;Here how it works in our case. We want to fill a vector table with default handlers, but give user an ability to override any handler. For that, we create a function &lt;code&gt;DefaultIRQHandler()&lt;/code&gt; and mark it weak. Then, for every IRQ handler, we declare a handler name and make it an alias to &lt;code&gt;DefaultIRQHandler()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __attribute__((weak)) DefaultIRQHandler(void) {&#xA;  for (;;) (void) 0;&#xA;}&#xA;#define WEAK_ALIAS __attribute__((weak, alias(&#34;DefaultIRQHandler&#34;)))&#xA;&#xA;WEAK_ALIAS void NMI_Handler(void);&#xA;WEAK_ALIAS void HardFault_Handler(void);&#xA;WEAK_ALIAS void MemManage_Handler(void);&#xA;...&#xA;__attribute__((section(&#34;.vectors&#34;))) void (*tab[16 + 91])(void) = {&#xA;    0, _reset, NMI_Handler, HardFault_Handler, MemManage_Handler,&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we can define any IRQ handler in our code, and it will replace the default one. This is what happens in our case: there is a &lt;code&gt;ETH_IRQHandler()&lt;/code&gt; defined by the Mongoose&#39;s STM32 driver which replaces a default handler.&lt;/p&gt; &#xA;&lt;p&gt;The next step is to initialise Mongoose library: create an event manager, setup network driver, and start a listening HTTP connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  struct mg_mgr mgr;        // Initialise Mongoose event manager&#xA;  mg_mgr_init(&amp;amp;mgr);        // and attach it to the MIP interface&#xA;  mg_log_set(MG_LL_DEBUG);  // Set log level&#xA;&#xA;  struct mip_driver_stm32 driver_data = {.mdc_cr = 4};  // See driver_stm32.h&#xA;  struct mip_if mif = {&#xA;      .mac = {2, 0, 1, 2, 3, 5},&#xA;      .use_dhcp = true,&#xA;      .driver = &amp;amp;mip_driver_stm32,&#xA;      .driver_data = &amp;amp;driver_data,&#xA;  };&#xA;  mip_init(&amp;amp;mgr, &amp;amp;mif);&#xA;  extern void device_dashboard_fn(struct mg_connection *, int, void *, void *);&#xA;  mg_http_listen(&amp;amp;mgr, &#34;http://0.0.0.0&#34;, device_dashboard_fn, &amp;amp;mgr);&#xA;  MG_INFO((&#34;Init done, starting main loop&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What is left, is to add a &lt;code&gt;mg_mgr_poll()&lt;/code&gt; call into the main loop.&lt;/p&gt; &#xA;&lt;p&gt;Now, add &lt;code&gt;mongoose.c&lt;/code&gt;, &lt;code&gt;net.c&lt;/code&gt; and &lt;code&gt;packed_fs.c&lt;/code&gt; files to the Makefile. Rebuild, reflash the board. Attach a serial console to the debug output, observe that the board obtains an IP address over DHCP:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;847 3 mongoose.c:6784:arp_cache_add     ARP cache: added 0xc0a80001 @ 90:5c:44:55:19:8b&#xA;84e 2 mongoose.c:6817:onstatechange     READY, IP: 192.168.0.24&#xA;854 2 mongoose.c:6818:onstatechange            GW: 192.168.0.1&#xA;859 2 mongoose.c:6819:onstatechange            Lease: 86363 sec&#xA;LED: 1, tick: 2262&#xA;LED: 0, tick: 2512&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fire up a browser at that IP address, and get a working dashboard, with real-time graph over WebSocket, with MQTT, authentication, and other things! See &lt;a href=&#34;https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard&#34;&gt;full description&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/screenshots/dashboard.png&#34; alt=&#34;Device dashboard&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-7-webserver&#34;&gt;step-7-webserver&lt;/a&gt; directory.&lt;/p&gt;</summary>
  </entry>
</feed>