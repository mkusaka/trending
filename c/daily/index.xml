<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-30T01:24:40Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>liam-ilan/crumb</title>
    <updated>2023-08-30T01:24:40Z</updated>
    <id>tag:github.com,2023-08-30:/liam-ilan/crumb</id>
    <link href="https://github.com/liam-ilan/crumb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Crumb Programming Language&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liam-ilan/crumb/main/media/color-rounded-text.svg?sanitize=true&#34; alt=&#34;crumb icon&#34; height=&#34;150&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;The Crumb Programming Language&lt;/h1&gt; &#xA;&lt;p&gt;Crumb is a high level, functional, interpreted, dynamically typed, general-purpose programming language, with a terse syntax, and a verbose standard library.&lt;/p&gt; &#xA;&lt;p&gt;It features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Strictly &lt;strong&gt;no side effects&lt;/strong&gt;* to help you write functional code&lt;/li&gt; &#xA; &lt;li&gt;The ability to &lt;strong&gt;localize the effects of imported Crumb files&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Dynamic typing&lt;/strong&gt; and &lt;strong&gt;garbage collection&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;0 keywords, &lt;strong&gt;everything is a function&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;*With the exception of IO&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Click here to &lt;a href=&#34;https://raw.githubusercontent.com/liam-ilan/crumb/main/#getting-started&#34;&gt;Get Started&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code&gt;table = (map (range 10) {_ y -&amp;gt;&#xA;  &amp;lt;- (map (range 10) {item x -&amp;gt;&#xA;    &amp;lt;- (multiply (add x 1) (add y 1))&#xA;  })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;From &lt;a href=&#34;https://raw.githubusercontent.com/liam-ilan/crumb/main/examples/mult-table.crumb&#34;&gt;&lt;code&gt;examples/mult-table.crumb&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liam-ilan/crumb/main/media/game-of-life.gif&#34; alt=&#34;Game of Life in Crumb&#34;&gt; &lt;em&gt;From &lt;a href=&#34;https://raw.githubusercontent.com/liam-ilan/crumb/main/examples/game-of-life.crumb&#34;&gt;&lt;code&gt;examples/game-of-life.crumb&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Find more examples under the &lt;code&gt;examples&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Syntax&lt;/h2&gt; &#xA;&lt;p&gt;Crumb utilizes a notably terse syntax definition. The whole syntax can described in 6 lines of EBNF. Additionally, there are no reserved words, and only 7 reserved symbols.&lt;/p&gt; &#xA;&lt;h3&gt;EBNF&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ebnf&#34;&gt;program = start, statement, end;&#xA;statement = {return | assignment | value};&#xA;return = &#34;&amp;lt;-&#34;, value;&#xA;assignment = identifier, &#34;=&#34;, value;&#xA;value = application | function | int | float | string | identifier;&#xA;application = &#34;(&#34;, {value}, &#34;)&#34;;&#xA;function = &#34;{&#34;, [{identifier}, &#34;-&amp;gt;&#34;], statement, &#34;}&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liam-ilan/crumb/main/media/syntax-diagram.png&#34; alt=&#34;Syntax Diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Crumb syntax diagram, generated with &lt;a href=&#34;https://jacquev6.github.io/DrawGrammar/&#34;&gt;DrawGrammar&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Tokens&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;=&#34;&#xA;&#34;(&#34;&#xA;&#34;)&#34;&#xA;&#34;{&#34;&#xA;&#34;}&#34;&#xA;&#34;-&amp;gt;&#34;&#xA;&#34;&amp;lt;-&#34;&#xA;identifier&#xA;int&#xA;float&#xA;string&#xA;start&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifics&lt;/h3&gt; &#xA;&lt;p&gt;Strings are characters surrounded by quotes, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;hello world&#34;&#xA;&#34;this is\nsplit between new lines&#34;&#xA;&#34;\e[31mthis text is in red\e[0m&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Escape codes in crumb are equivalent to their respective C escape codes. The list of supported escape codes is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;\a&#34;&#xA;&#34;\b&#34;&#xA;&#34;\f&#34;&#xA;&#34;\n&#34; &#xA;&#34;\r&#34;&#xA;&#34;\t&#34;&#xA;&#34;\v&#34;&#xA;&#34;\e&#34;&#xA;&#34;\\&#34;&#xA;&#34;\&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Integers are groups of number characters, that may be preceded by &lt;code&gt;-&lt;/code&gt; for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1234&#xA;-14&#xA;345&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Floats are like integers, but have a decimal in them, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;13.45&#xA;-2.3&#xA;745.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Identifiers are any collection of characters, that are not separated by whitespace, don&#39;t begin with quotes or numbers, and are not any reserved symbols, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hello&#xA;xâ‚‚&#xA;symbol1&#xA;+&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Comments start with &#34;//&#34;, and end with the end of a line, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// this is a program that prints hi&#xA;(print &#34;hi&#34;) // this prints hi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;For a quick start, you can use Replit, by forking &lt;a href=&#34;https://replit.com/@snowboardsheep/Crumb-on-Replit&#34;&gt;this repl&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;First, clone this repo,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/liam-ilan/crumb.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then compile with gcc,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc src/*.c -Wall -lm -o crumb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or with clang,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clang src/*.c -Wall -lm -o crumb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From there, run a quick example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./crumb examples/car.crumb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or run your own code,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./crumb YOURCODE.crumb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The Crumb interpreter is built for POSIX compliant systems, and utilizes &lt;code&gt;ioctl.h&lt;/code&gt; and &lt;code&gt;unistd.h&lt;/code&gt;. To use Crumb on windows, either use WSL, or use a Linux container.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Basics&lt;/h3&gt; &#xA;&lt;p&gt;All function calls are done with s-expressions (think lisp). For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(print &#34;hello world&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, the function &lt;code&gt;print&lt;/code&gt; is applied with the &lt;code&gt;string&lt;/code&gt; &lt;code&gt;&#34;hello world&#34;&lt;/code&gt; as an argument.&lt;/p&gt; &#xA;&lt;p&gt;All data in crumb is one of 6 different types:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;function&lt;/code&gt; / &lt;code&gt;native function&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;list&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;void&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We can store this data in variables, for example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a = 5&#xA;b = &#34;hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can combine data together to form lists,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;magic_list = (list 123 &#34;hello&#34; 42.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lists are always passed by value.&lt;/p&gt; &#xA;&lt;p&gt;We can encapsulate code in functions using curly braces,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;f = {&#xA;  (print &#34;Funky!&#34;)&#xA;}&#xA;&#xA;(f) // prints &#34;Funky&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Functions can get arguments, denoted using the &#34;-&amp;gt;&#34; symbol. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;add_two_things = {a b -&amp;gt;&#xA;  (print (add a b))&#xA;}&#xA;&#xA;(add_two_things 3 5) // prints 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;They can also return values using the &#34;&amp;lt;-&#34; symbol,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;geometric_mean = {a b -&amp;gt;&#xA;  &amp;lt;- (power (multiply a b) 0.5)&#xA;}&#xA;&#xA;(print (geometric_mean 3 5) &#34;\n&#34;) // prints 3.87...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Functions operate in a few important ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Function applications are &lt;em&gt;dynamically scoped&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Functions &lt;em&gt;cannot create side effects&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Like in JavaScript and Python, &lt;em&gt;functions can be passed into other functions as arguments&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Most of the features you may expect in a programming language are implemented in the form of functions. For example, here is a Fizzbuzz program using the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;remainder&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, and &lt;code&gt;print&lt;/code&gt; functions,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(loop 100 {i -&amp;gt; &#xA;  i = (add i 1)&#xA;  &#xA;  (if (is (remainder i 15) 0) {&#xA;    (print &#34;fizzbuzz\n&#34;)&#xA;  } {&#xA;    (if (is (remainder i 3) 0) {&#xA;      (print &#34;fizz\n&#34;)&#xA;    } {&#xA;      (if (is (remainder i 5) 0) {&#xA;        (print &#34;buzz\n&#34;)&#xA;      } {&#xA;        (print i &#34;\n&#34;)&#xA;      })&#xA;    })&#xA;  })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;From &lt;a href=&#34;https://raw.githubusercontent.com/liam-ilan/crumb/main/examples/fizzbuzz.crumb&#34;&gt;&lt;code&gt;examples/fizzbuzz.crumb&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;You should now be ready to write your own Crumb programs! More info on how to build applications with events, files, code-splitting, and more, is found in the standard library documentation below.&lt;/p&gt; &#xA;&lt;h2&gt;Standard Library&lt;/h2&gt; &#xA;&lt;h3&gt;IO&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A list command line arguments, like argv in C.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(print arg1 arg2 arg3 ...)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Prints all arguments to stdout, returns nothing.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(input)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Gets a line of input from stdin.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(rows)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the number of rows in the terminal.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(columns)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the number of columns in the terminal.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(read_file path)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the contents of the file designated by &lt;code&gt;path&lt;/code&gt;, in a string&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;path&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(write_file path contents)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Writes the string &lt;code&gt;contents&lt;/code&gt; into the file designated by &lt;code&gt;path&lt;/code&gt;, returns nothing.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;path&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;contents&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(event)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the ANSI string corresponding with the current event. This may block for up to 0.1 seconds.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(use path1 path2 path3 ... fn)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Crumb&#39;s code splitting method. Runs code in file paths, in order, on a new scope. Then uses said scope to apply &lt;code&gt;fn&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;path1&lt;/code&gt;, &lt;code&gt;path2&lt;/code&gt;, &lt;code&gt;path3&lt;/code&gt;, ...: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;function&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Comparisons&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(is a b)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Checks if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal, returns &lt;code&gt;1&lt;/code&gt; if so, else returns &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are lists, a deep comparison is made.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(less_than a b)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Checks if &lt;code&gt;a&lt;/code&gt; is less than &lt;code&gt;b&lt;/code&gt;, returns &lt;code&gt;1&lt;/code&gt; if so, else returns &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(greater_than a b)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Checks if &lt;code&gt;a&lt;/code&gt; is greater than &lt;code&gt;b&lt;/code&gt;, returns &lt;code&gt;1&lt;/code&gt; if so, else returns &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Logical Operators&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(not a)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(and a b)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both &lt;code&gt;1&lt;/code&gt;, else returns &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(or a b)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;1&lt;/code&gt;, else returns &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Arithmetic&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(add arg1 arg2 arg3 ...)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;arg1&lt;/code&gt; + &lt;code&gt;arg2&lt;/code&gt; + &lt;code&gt;arg3&lt;/code&gt; + ...&lt;/li&gt; &#xA;   &lt;li&gt;Requires a minimum of two args&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;arg3&lt;/code&gt;, ...: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(subtract arg1 arg2 arg3 ...)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;arg1&lt;/code&gt; - &lt;code&gt;arg2&lt;/code&gt; - &lt;code&gt;arg3&lt;/code&gt; - ...&lt;/li&gt; &#xA;   &lt;li&gt;Requires a minimum of two args&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;arg3&lt;/code&gt;, ...: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(divide arg1 arg2 arg3 ...)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;arg1&lt;/code&gt; / &lt;code&gt;arg2&lt;/code&gt; / &lt;code&gt;arg3&lt;/code&gt; / ...&lt;/li&gt; &#xA;   &lt;li&gt;Requires a minimum of two args&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;arg3&lt;/code&gt;, ...: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(multiply arg1 arg2 arg3 ...)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;arg1&lt;/code&gt; * &lt;code&gt;arg2&lt;/code&gt; * &lt;code&gt;arg3&lt;/code&gt; * ...&lt;/li&gt; &#xA;   &lt;li&gt;Requires a minimum of two args&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;arg3&lt;/code&gt;, ...: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(remainder a b)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the remainder of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(power a b)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;a&lt;/code&gt; to the power of &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(random)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a random number from 0 to 1.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Control&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(loop count fn)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Applies &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; times. If &lt;code&gt;fn&lt;/code&gt; returns, the loop breaks, and &lt;code&gt;loop&lt;/code&gt; returns whatever &lt;code&gt;fn&lt;/code&gt; returned, else repeats until loop is completed.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;count&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is greater than or equal to &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;function&lt;/code&gt;, which is in the form &lt;code&gt;{n -&amp;gt; ...}&lt;/code&gt;, where n is the current loop index (starting at &lt;code&gt;0&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(until stop fn initial_state)&lt;/code&gt; or &lt;code&gt;(until stop fn)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Applies &lt;code&gt;fn&lt;/code&gt;, and repeats until &lt;code&gt;fn&lt;/code&gt; returns &lt;code&gt;stop&lt;/code&gt;. &lt;code&gt;until&lt;/code&gt; returns whatever &lt;code&gt;fn&lt;/code&gt; returned, before &lt;code&gt;stop&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;The return value of every past iteration is passed on to the next. The initial iteration uses &lt;code&gt;initial_state&lt;/code&gt; if supplied, or returns &lt;code&gt;void&lt;/code&gt; if not.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;function&lt;/code&gt;, which is in the form &lt;code&gt;{state n -&amp;gt; ...}&lt;/code&gt;, where n is the current loop index (starting at &lt;code&gt;0&lt;/code&gt;), and &lt;code&gt;state&lt;/code&gt; is the current state.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(if condition fn1)&lt;/code&gt; or &lt;code&gt;(if condition fn1 fn2)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, applies &lt;code&gt;fn1&lt;/code&gt;. (like the &#34;then&#34; part in an if statement).&lt;/li&gt; &#xA;   &lt;li&gt;If &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;fn2&lt;/code&gt; was supplied, apply &lt;code&gt;fn2&lt;/code&gt;. (the &#34;else&#34; part in an if statement).&lt;/li&gt; &#xA;   &lt;li&gt;Returns whatever &lt;code&gt;fn1&lt;/code&gt; or &lt;code&gt;fn2&lt;/code&gt; return&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;condition&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;fn1&lt;/code&gt;: &lt;code&gt;function&lt;/code&gt;, which takes no arguments&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;fn2&lt;/code&gt;: &lt;code&gt;function&lt;/code&gt;, which takes no arguments&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(wait time)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Blocks execution for &lt;code&gt;time&lt;/code&gt; amount of seconds.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Types&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;void&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A value of type &lt;code&gt;void&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(integer a)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;a&lt;/code&gt; as an &lt;code&gt;integer&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, or &lt;code&gt;integer&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(string a)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;a&lt;/code&gt; as a &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, or &lt;code&gt;integer&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(float a)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns &lt;code&gt;a&lt;/code&gt; as a &lt;code&gt;float&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, or &lt;code&gt;integer&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(type a)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the type of &lt;code&gt;a&lt;/code&gt; as a &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;List and String&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(list arg1 arg2 arg3 ...)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a &lt;code&gt;list&lt;/code&gt;, with the arguments as it&#39;s contents.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(length x)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the length of &lt;code&gt;x&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(join arg1 arg2 arg3 ...)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns all args joined together.&lt;/li&gt; &#xA;   &lt;li&gt;All args must be of the same type.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;arg3&lt;/code&gt;, ...: &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(get x index1)&lt;/code&gt; or &lt;code&gt;(get x index1 index2)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the item in &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;index1&lt;/code&gt;. If x is a &lt;code&gt;string&lt;/code&gt;, this is a single char.&lt;/li&gt; &#xA;   &lt;li&gt;If &lt;code&gt;index2&lt;/code&gt; is supplied, returns a sub-array or substring from &lt;code&gt;index1&lt;/code&gt; to &lt;code&gt;index2&lt;/code&gt;, not including &lt;code&gt;index2&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;index1&lt;/code&gt;: &lt;code&gt;int&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;index2&lt;/code&gt;: &lt;code&gt;int&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(insert x item)&lt;/code&gt; or &lt;code&gt;(insert x item index)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;, in which &lt;code&gt;item&lt;/code&gt; was inserted into &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;index&lt;/code&gt;. Does not overwrite any data.&lt;/li&gt; &#xA;   &lt;li&gt;If &lt;code&gt;index&lt;/code&gt; not supplied, &lt;code&gt;item&lt;/code&gt; is assumed to be put at the end of &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;item&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;string&lt;/code&gt;, else any&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;index&lt;/code&gt;: &lt;code&gt;int&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(set x item index)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;, in which the item located at &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;, was replaced by &lt;code&gt;item&lt;/code&gt;.Overwrites data.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;item&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;string&lt;/code&gt;, else any&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;index&lt;/code&gt;: &lt;code&gt;int&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(delete x index1)&lt;/code&gt; or &lt;code&gt;(delete x index1 index2)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;, where &lt;code&gt;index1&lt;/code&gt; was removed from &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;If &lt;code&gt;index2&lt;/code&gt; is supplied, all items from &lt;code&gt;index1&lt;/code&gt; to &lt;code&gt;index2&lt;/code&gt; are removed, not including &lt;code&gt;index2&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;index1&lt;/code&gt;: &lt;code&gt;int&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;index2&lt;/code&gt;: &lt;code&gt;int&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(map arr fn)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a list created by calling &lt;code&gt;fn&lt;/code&gt; on every item of &lt;code&gt;arr&lt;/code&gt;, and using the values returned by &lt;code&gt;fn&lt;/code&gt; to populate the returned array.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arr&lt;/code&gt;: &lt;code&gt;list&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;function&lt;/code&gt;, which is in the form &lt;code&gt;{item i -&amp;gt; ...}&lt;/code&gt;, where &lt;code&gt;item&lt;/code&gt; is the current item, and &lt;code&gt;i&lt;/code&gt; is the current index.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(reduce arr fn initial_acc)&lt;/code&gt; or &lt;code&gt;(reduce arr fn)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a value, computed via running &lt;code&gt;fn&lt;/code&gt; on every item in &lt;code&gt;arr&lt;/code&gt;. With every iteration, the last return from &lt;code&gt;fn&lt;/code&gt; is passed to the next application of &lt;code&gt;fn&lt;/code&gt;. The final returned value from &lt;code&gt;fn&lt;/code&gt; is the value returned from &lt;code&gt;reduce&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arr&lt;/code&gt;: &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;function&lt;/code&gt;, which is in the form &lt;code&gt;{acc item i -&amp;gt; ...}&lt;/code&gt;, where &lt;code&gt;item&lt;/code&gt; is the current item, &lt;code&gt;acc&lt;/code&gt; is the accumulator (the result of &lt;code&gt;fn&lt;/code&gt; from the last item), and &lt;code&gt;i&lt;/code&gt; is the current index. &lt;code&gt;acc&lt;/code&gt; is &lt;code&gt;initial_acc&lt;/code&gt; if supplied, or &lt;code&gt;void&lt;/code&gt; if not.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(range n)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns a list with the integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;, not including &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;n&lt;/code&gt;: &lt;code&gt;integer&lt;/code&gt;, which is greater than or equal to 0.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(find x item)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Returns the index of &lt;code&gt;item&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. Returns &lt;code&gt;void&lt;/code&gt; if not found.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;item&lt;/code&gt;: &lt;code&gt;string&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;string&lt;/code&gt;, else any&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;When debugging the interpreter, it may be useful to compile with the &lt;code&gt;-g&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc src/*.c -g -Wall -lm -o crumb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will allow Valgrind to provide extra information,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;valgrind --leak-check=full -s ./crumb -d YOURCODE.crumb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To obtain debug information about how your code is interpreted (Tokens, AST, etc.), add the &lt;code&gt;-d&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./crumb -d YOURCODE.crumb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Credit&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Built by &lt;a href=&#34;https://www.liamilan.com/&#34;&gt;Liam Ilan&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>