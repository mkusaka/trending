<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-05T01:28:25Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hufrea/byedpi</title>
    <updated>2024-08-05T01:28:25Z</updated>
    <id>tag:github.com,2024-08-05:/hufrea/byedpi</id>
    <link href="https://github.com/hufrea/byedpi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bypass DPI&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Implementation of some DPI bypass methods. The program is a local SOCKS proxy server.&lt;/p&gt; &#xA;&lt;p&gt;Usage example: ciadpi --disorder 1 --auto=torst --tlsrec 1+s ciadpi --fake -1 --ttl 8&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Описание аргументов&lt;/h3&gt; &#xA;&lt;p&gt;-i, --ip &#xA; &lt;ip&gt;&#xA;   Прослушиваемый IP, по умолчанию 0.0.0.0&#xA; &lt;/ip&gt;&lt;/p&gt; &#xA;&lt;p&gt;-p, --port &#xA; &lt;num&gt;&#xA;   Прослушиваемый порт, по умолчанию 1080&#xA; &lt;/num&gt;&lt;/p&gt; &#xA;&lt;p&gt;-c, --max-conn &#xA; &lt;count&gt;&#xA;   Максимальное количество клиентских подключений, по умолчанию 512&#xA; &lt;/count&gt;&lt;/p&gt; &#xA;&lt;p&gt;-I --conn-ip &#xA; &lt;ip&gt;&#xA;   Адрес, к которому будут привязаны исходящие соединения, по умолчанию :: При указании IPv4 адреса запросы на IPv6 будут отклоняться&#xA; &lt;/ip&gt;&lt;/p&gt; &#xA;&lt;p&gt;-b, --buf-size &#xA; &lt;size&gt;&#xA;   Максимальный размер данных, получаемых и отправляемых за один вызов recv/send Размер указывается в байтах, по умолчанию равен 16384&#xA; &lt;/size&gt;&lt;/p&gt; &#xA;&lt;p&gt;-g, --def-ttl &#xA; &lt;num&gt;&#xA;   Значение TTL для всех исходящий соединений Может быть полезен для обхода обнаружения нестандартного/уменьшенного TTL&#xA; &lt;/num&gt;&lt;/p&gt; &#xA;&lt;p&gt;-N, --no-domain Отбрасывать запросы, если в качестве адреса указан домен Т.к. резолвинг выполняется синхронно, то он может замедлить или даже заморозить работу&lt;/p&gt; &#xA;&lt;p&gt;-U, --no-udp Не проксировать UDP&lt;/p&gt; &#xA;&lt;p&gt;-F, --tfo Включает TCP Fast Open Если сервер его поддерживает, то первый пакет будет отправлен сразу вместе с SYN Поддерживается только в Linux (4.11+)&lt;/p&gt; &#xA;&lt;p&gt;-A, --auto[=t,r,c,s,a,n] Автоматический режим Если произошло событие, похожее на блокировку или поломку, то будут применены параметры обхода, следующие за данной опцией Возможные события: torst : Вышло время ожидания или сервер сбросил подключение после первого запроса redirect: HTTP Redirect с Location, домен которого не совпадает с исходящим cl_err : HTTP ответ, код которого равен 40x, но не 429 sid_inv : session_id в TLS ServerHello и ClientHello не совпадают alert : TLS Error Alert в ответе none : Предыдущая группа пропущена, например из-за ограничения по доменам или протоколам&lt;/p&gt; &#xA;&lt;p&gt;-u, --cache-ttl &#xA; &lt;sec&gt;&#xA;   Время жизни значения в кеше, по умолчанию 100800 (28 часов)&#xA; &lt;/sec&gt;&lt;/p&gt; &#xA;&lt;p&gt;-T, --timeout &#xA; &lt;sec&gt;&#xA;   Таймаут ожидания первого ответа от сервера в секундах В Linux переводится в миллисекунды, поэтому можно указать дробное число&#xA; &lt;/sec&gt;&lt;/p&gt; &#xA;&lt;p&gt;-K, --proto &amp;lt;t,h,u&amp;gt; Белый список протоколов: tls,http,udp&lt;/p&gt; &#xA;&lt;p&gt;-H, --hosts &amp;lt;file|:string&amp;gt; Ограничить область действия параметров списком доменов Домены должны быть разделены новой строкой или пробелом&lt;/p&gt; &#xA;&lt;p&gt;-V, --pf &amp;lt;port[-portr]&amp;gt; Ограничитель по портам&lt;/p&gt; &#xA;&lt;p&gt;-s, --split &amp;lt;n[+s]&amp;gt; Разбить запрос по указанному смещению После числа можно добавить флаг: +s: добавить смещение SNI +h: добавить смещение Host Можно указывать несколько раз, чтобы разбить запрос по нескольким позициям При указании отрицательного значения к нему прибавляется размер пакета&lt;/p&gt; &#xA;&lt;p&gt;-d, --disorder &amp;lt;n[+s]&amp;gt; Подобен --split, но части отправляются в обратном порядке ! Поведение в Windows отлично: сначала отправляется лишь часть, но затем целый запрос&lt;/p&gt; &#xA;&lt;p&gt;-o, --oob &amp;lt;n[+s]&amp;gt; Подобен --split, но после части отсылается один или несколько байт OOB данных&lt;/p&gt; &#xA;&lt;p&gt;-f, --fake &amp;lt;n[+s]&amp;gt; Подобен --disorder, только перед отправкой первого куска отправляется часть поддельного Количество байт отправляемого из фейка равно рамеру разбиваемой части&lt;/p&gt; &#xA;&lt;p&gt;-t, --ttl &#xA; &lt;num&gt;&#xA;   TTL для поддельного пакета, по умолчанию 8 Необходимо подобрать такое значение, чтобы пакет не дошел до сервера, но был обработан DPI&#xA; &lt;/num&gt;&lt;/p&gt; &#xA;&lt;p&gt;-k, --ip-opt[=file|:str] Установить опции для фейкового IP пакета Существенно снизит вероятность, что пакет дойдет до сервера Стоит учесть, что до DPI он также может не дойти В Windows поддержка может быть отключена&lt;/p&gt; &#xA;&lt;p&gt;-S, --md5sig Установить опцию TCP MD5 Signature для фейкового пакета Большинство серверов (в основном на Linux) отбрасывают пакеты с данной опцией Поддерживается только в Linux, может быть выключен в некоторых сборках ядра (&amp;lt; 3.9, Android)&lt;/p&gt; &#xA;&lt;p&gt;-l, --fake-data &amp;lt;file|:str&amp;gt; Указать свои поддельные пакеты, вместо дефолтных&lt;/p&gt; &#xA;&lt;p&gt;-e, --oob-data &amp;lt;file|:str&amp;gt; Данные, отсылаемые вне основного потока, по умолчанию один байт &#39;a&#39; ! При размере более одного байта может работать нестабильно&lt;/p&gt; &#xA;&lt;p&gt;-n, --tls-sni &#xA; &lt;str&gt;&#xA;   Изменить SNI в fake пакете на указанный&#xA; &lt;/str&gt;&lt;/p&gt; &#xA;&lt;p&gt;-M, --mod-http &amp;lt;h[,d,r]&amp;gt; Всякие манипуляции с HTTP пакетом, можно комбинировать hcsmix: &#34;Host: name&#34; -&amp;gt; &#34;hOsT: name&#34; dcsmix: &#34;Host: name&#34; -&amp;gt; &#34;Host: NaMe&#34; rmspace: &#34;Host: name&#34; -&amp;gt; &#34;Host:name\t&#34;&lt;/p&gt; &#xA;&lt;p&gt;-r, --tlsrec &amp;lt;n[+s]&amp;gt; Разделить ClientHello на отдельные записи по указанному смещению Можно указывать несколько раз&lt;/p&gt; &#xA;&lt;p&gt;-a, --udp-fake &#xA; &lt;count&gt;&#xA;   Количество фейковых UDP пакетов&#xA; &lt;/count&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Подробнее&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;--split&lt;br&gt; Разбивает запрос на части. Пример на запросе в 30 байт:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Параметры: --split 3 --split 7&lt;/li&gt; &#xA; &lt;li&gt;Порядок отправки: 1-3, 3-7, 7-30&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;--disorder&lt;br&gt; Часть, попадающая под disorder, будет отправлена с TTL=1, т.е. фактически не будет никуда доставлена. ОС узнает об этом лишь после отсылки последующей части, когда сервер сообщит о потере с помощью SACK. Системе придется отослать предыдущий пакет заново, тем самым нарушив обычный порядок.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Параметры: --disorder 7&lt;/li&gt; &#xA; &lt;li&gt;Порядок отправки: 7-30, 1-7&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Вышесказанное распространяется только на Linux. В Windows выполняется полная ретрансмиссия:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Параметры: --disorder 7&lt;/li&gt; &#xA; &lt;li&gt;Порядок отправки: 7-30, 1-30&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Поэтому желательно использовать ещё и split:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Параметры: --split 7 --disorder 23&lt;/li&gt; &#xA; &lt;li&gt;Порядок отправки: 1-7, 23-30, 7-30&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;На практике оптимально использовать:&lt;br&gt; Linux: --disorder 1&lt;br&gt; Windows: --split 1+s --disorder 3+s&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;--fake&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Параметры: --fake 7&lt;/li&gt; &#xA; &lt;li&gt;Порядок отправки: 1-7 фейк, 7-30 оригинал, 1-7 оригинал&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Данные в первой части запроса заменяются на поддельные.&lt;br&gt; Эта часть должна пройти через DPI, но не дойти до сервера. А раз часть не дойдет, то ОС отправит ее снова, тем самым изменив порядок подобно disorder. Для того, чтобы фейк не дошел до сервера, есть опции ttl, ip-opt и md5sig.&lt;/p&gt; &#xA;&lt;p&gt;TTL необходимо подбирать такой, чтобы пакет прошел через все DPI, но не дошел до сервера.&lt;br&gt; Для Linux есть md5sig. Он устанавливает опцию TCP MD5 Signature, что не дает пакету быть принятым многими серверами. К сожалению, md5sig работает не во всех сборках.&lt;/p&gt; &#xA;&lt;p&gt;Для Windows есть еще один способ избежать обработки фейка сервером. Это комбинирование fake с disorder:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Параметры: --disorder 1 --fake 7&lt;/li&gt; &#xA; &lt;li&gt;Порядок отправки: 2-7 фейк, 7-30 оригинал, 1-30 оригинал&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Если поддельный пакет и дойдет до сервера, то он будет перезаписан из-за полной ретрансмисси.&lt;/p&gt; &#xA;&lt;p&gt;На практике оптимально использовать:&lt;br&gt; Linux: --fake -1 --md5sig&lt;br&gt; Windows: --disorder 1 --fake -1&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;--oob&lt;br&gt; TCP может отсылать данные вне основного потока, используя флаг URG, однако лишь 1 байт в пакете. Все данные в таком пакете будут доставлены приложению, кроме последнего байта, который и является внеканальным:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Параметры: --oob 3&lt;/li&gt; &#xA; &lt;li&gt;Отправка: 1-4 с флагом URG (1-3 данные запроса + 4-й байт, который будет усечен), 3-30&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Этот байт желательно помещать в SNI: --oob 3+s&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;--tlsrec&lt;br&gt; Одну TLS запись можно разбить на несколько, немного переделав заголовок. На месте разбиения вставляется новый заголовок, увеличивая размер запроса на 5 байт.&lt;br&gt; Этот заголовок можно поместить в середину SNI, не давая возможность DPI правильно его прочитать: --tlsrec 3+s&lt;/p&gt; &#xA;&lt;p&gt;Хоть tlsrec и oob запутывают DPI, они также могут запутать всякие мидлбоксы, которые не поддерживают полноценный стек TCP/TLS.&lt;br&gt; Из-за этого их следует использовать вместе с --auto:&lt;br&gt; --auto=torst --timeout 3 --tlsrec 3+s&lt;br&gt; В примере tlsrec будет применяться лишь в случаях, когда сброшено подключение или вышел таймаут, т.е. когда, скорее всего, произошла блокировка.&lt;br&gt; Можно наоборот - отменять tlsrec, если сервер сбрасывает подключение или откидывает пакет:&lt;br&gt; --tlsrec 3+s --auto=torst --timeout 3&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;--auto, --hosts&lt;br&gt; Параметр auto делит опции на группы. Для каждого запроса они обходятся слева на право. Сначала проверяется триггер, указанный в auto, затем proto и hosts.&lt;br&gt; Можно указывать несколько групп опций, раделяя их данным параметром. Параметры, которые можно вынести в отдельную группу:&lt;br&gt; proto, hosts, pf, split, disorder, oob, fake, ttl, ip-opt, md5sig, fake-data, mod-http, tlsrec, udp-fake&lt;/p&gt; &#xA;&lt;p&gt;Примеры:&lt;br&gt; --fake -1 --ttl 10 --auto=alert,sid_inv --fake -1 --ttl 5&lt;br&gt; По умолчанию использовать fake с ttl=10, в случае ошибки использовать fake с ttl=5&lt;/p&gt; &#xA;&lt;p&gt;--hosts list.txt --disorder 3 --auto=none&lt;br&gt; Применять запутывание только для доменов из list.txt&lt;/p&gt; &#xA;&lt;p&gt;--hosts list.txt --auto=none --disorder 3&lt;br&gt; Не применять запутывание для доменов из list.txt&lt;/p&gt; &#xA;&lt;p&gt;--auto=torst --hosts list.txt --disorder 3&lt;br&gt; По умолчанию ничего не делать, использовать disorder при условии, что произошла блокировка и домен входит в list.txt.&lt;/p&gt; &#xA;&lt;p&gt;--proto=http,tls --disorder 3 --auto=none&lt;br&gt; Запутывать только HTTP и TLS&lt;/p&gt; &#xA;&lt;p&gt;--proto=http --fake -1 --fake-data=&#39;:GET /...&#39; --auto=none --fake -1&lt;br&gt; Переопределить фейковый пакет для HTTP&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Сборка&lt;/h3&gt; &#xA;&lt;p&gt;Для сборки понадобится: make, gcc/clang для Linux, mingw для Windows&lt;/p&gt; &#xA;&lt;p&gt;Linux: make&lt;br&gt; Windows: make windows CC=x86_64-w64-mingw32-gcc&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Дополнительная информация о DPI, источники идей&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bol-van/zapret/raw/master/docs/readme.txt&#34;&gt;https://github.com/bol-van/zapret/blob/master/docs/readme.txt&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://geneva.cs.umd.edu/papers/geneva_ccs19.pdf&#34;&gt;https://geneva.cs.umd.edu/papers/geneva_ccs19.pdf&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://habr.com/ru/post/335436&#34;&gt;https://habr.com/ru/post/335436&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>