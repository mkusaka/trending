<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-23T01:33:45Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mildsunrise/cursed_gpu_linux</title>
    <updated>2023-01-23T01:33:45Z</updated>
    <id>tag:github.com,2023-01-23:/mildsunrise/cursed_gpu_linux</id>
    <link href="https://github.com/mildsunrise/cursed_gpu_linux" rel="alternate"></link>
    <summary type="html">&lt;p&gt;⚙️ Attempt to run Linux in a GPU shader&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Linux in the GPU&lt;/h1&gt; &#xA;&lt;p&gt;This is an attempt at emulating a Linux kernel inside a GLSL shader.&lt;/p&gt; &#xA;&lt;p&gt;Read the &lt;a href=&#34;https://twitter.com/mild_sunrise/status/1538447372392488968&#34;&gt;threads&lt;/a&gt; for the full (and very long) story. I&#39;ve chosen the RISC-V architecture, 32-bit, without an FPU or even M-mode. The plan is to first write a C version, but trying to stick only to features that are present in GLSL ES 3.0, to facilitate the port afterwards. We need GLSL ES 3.0 for its integer support, and also because it has switches.&lt;/p&gt; &#xA;&lt;p&gt;The core emulator is now mature enough to emulate a full startup of Linux, including the userspace. Specs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RV32IMA&lt;/li&gt; &#xA; &lt;li&gt;S &amp;amp; U modes&lt;/li&gt; &#xA; &lt;li&gt;Rv32 MMU&lt;/li&gt; &#xA; &lt;li&gt;On x64, it performs at about 165 instructions, 60 cycles (per emulated instruction).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The full emulator exposes a few peripherals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;512MiB main memory&lt;/li&gt; &#xA; &lt;li&gt;Standard RISC-V PLIC (32 interrupts, no priority support)&lt;/li&gt; &#xA; &lt;li&gt;Standard SBI, with the timer extension&lt;/li&gt; &#xA; &lt;li&gt;8250/16550 UART for console, mapped as stdin/stdout&lt;/li&gt; &#xA; &lt;li&gt;virtio-net v2 interface, mapped as TAP interface (no extra features)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/IFZeNgyV6Glf3TBrc5Nn08QjL&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/IFZeNgyV6Glf3TBrc5Nn08QjL.svg?sanitize=true&#34; alt=&#34;Interacting with the emulated machine through the console (recording)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;p&gt;No reason in particular, I just thought it would be rad as hell. And also let me learn a bit more about emulation, ISAs and kernels in general.&lt;/p&gt; &#xA;&lt;h2&gt;Structure&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;core.c&lt;/code&gt;, &lt;code&gt;core.h&lt;/code&gt;: Part of the emulator that implements the RISC-V core itself, including the MMU.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;emulator.c&lt;/code&gt;: Part of the emulator that provides the platform (environment), including memory mapping &amp;amp; peripherals. Sets up state, memory and enters into the I/O + emulation loop. Calls into &lt;code&gt;core.c&lt;/code&gt; for the emulation, handling any exceptions, memory accesses or interrupts.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;linux_config&lt;/code&gt;: Config for the kernel. Nothing too exotic, provided mostly for reference.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;buildroot_config&lt;/code&gt;: Buildroot config to build a minimal rootfs for the kernel. You can use whatever userspace you like, just specify it when building the kernel.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;linux_dts&lt;/code&gt;: Source code for the Device Tree describing the hardware exposed by the emulator. It&#39;s compiled into &lt;code&gt;linux_dtb&lt;/code&gt;, which is loaded into memory by the emulator and passed to the kernel.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;test.c&lt;/code&gt;: Simple test environment that emulates a user-mode ELF (loads it into memory, provides a stack region) using &lt;code&gt;core.c&lt;/code&gt;. I used this in early stages of the project to verify that the core was working properly.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt;: By any means a serious buildsystem, more like a set of common commands I wanted to automate or note somewhere.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To execute the C emulator, you first need a kernel. And to build the kernel, you first need a userspace and a toolchain. I did that using &lt;a href=&#34;https://buildroot.org&#34;&gt;Buildroot&lt;/a&gt;, so clone it under &lt;code&gt;buildroot&lt;/code&gt; in the repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/buildroot/buildroot.git -b 2022.05 --depth=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then build using the provided &lt;code&gt;buildroot_config&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd buildroot&#xA;cp ../buildroot_config .config&#xA;make&#xA;cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the rootfs is built, clone Linux under &lt;code&gt;linux&lt;/code&gt; in the repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/torvalds/linux.git -b v5.19-rc5 --depth=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then build using the provided &lt;code&gt;linux_config&lt;/code&gt; and the toolchain produced by Buildroot:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PATH=&#34;$PWD/buildroot/output/host/bin:$PATH&#34;&#xA;export CROSS_COMPILE=riscv32-buildroot-linux-gnu- ARCH=riscv&#xA;cd linux&#xA;cp ../linux_config .config&#xA;make&#xA;cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now build the DTB and the emulator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And run the emulator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./emulator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The paths to the DTB and the kernel are hardcoded in &lt;code&gt;emulator.c&lt;/code&gt;, change them if needed. You should see the Linux UART output appear.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>open-quantum-safe/liboqs</title>
    <updated>2023-01-23T01:33:45Z</updated>
    <id>tag:github.com,2023-01-23:/open-quantum-safe/liboqs</id>
    <link href="https://github.com/open-quantum-safe/liboqs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C library for prototyping and experimenting with quantum-resistant cryptography&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://ci.appveyor.com/project/dstebila/liboqs&#34;&gt;AppVeyor&lt;/a&gt;: &lt;img src=&#34;https://ci.appveyor.com/api/projects/status/9d2ts78x88r8wnii/branch/main?svg=true&#34; alt=&#34;Build status image&#34;&gt;, &lt;a href=&#34;https://circleci.com/gh/open-quantum-safe/liboqs/tree/main&#34;&gt;CircleCI&lt;/a&gt;: &lt;img src=&#34;https://circleci.com/gh/open-quantum-safe/liboqs/tree/main.svg?style=svg&#34; alt=&#34;Build status image&#34;&gt;, &lt;a href=&#34;https://travis-ci.com/github/open-quantum-safe/liboqs&#34;&gt;TravisCI&lt;/a&gt;: &lt;a href=&#34;https://travis-ci.com/open-quantum-safe/liboqs&#34;&gt;&lt;img src=&#34;https://travis-ci.com/open-quantum-safe/liboqs.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;liboqs&lt;/h1&gt; &#xA;&lt;p&gt;liboqs is an open source C library for quantum-safe cryptographic algorithms.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#status&#34;&gt;Status&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#supported-algorithms&#34;&gt;Supported algorithms&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#limitations-and-security&#34;&gt;Limitations and Security&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#quickstart&#34;&gt;Quickstart&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#linuxmacOS&#34;&gt;Linux / macOS&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#windows&#34;&gt;Windows&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#cross-compilation&#34;&gt;Cross compilation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;liboqs provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a collection of open source implementations of quantum-safe key encapsulation mechanism (KEM) and digital signature algorithms; the full list can be found &lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/#supported-algorithms&#34;&gt;below&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;a common API for these algorithms&lt;/li&gt; &#xA; &lt;li&gt;a test harness and benchmarking routines&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;liboqs is part of the &lt;strong&gt;Open Quantum Safe (OQS)&lt;/strong&gt; project led by &lt;a href=&#34;https://www.douglas.stebila.ca/research/&#34;&gt;Douglas Stebila&lt;/a&gt; and &lt;a href=&#34;http://faculty.iqc.uwaterloo.ca/mmosca/&#34;&gt;Michele Mosca&lt;/a&gt;, which aims to develop and integrate into applications quantum-safe cryptography to facilitate deployment and testing in real world contexts. In particular, OQS provides prototype integrations of liboqs into TLS and SSH, through &lt;a href=&#34;https://github.com/open-quantum-safe/openssl&#34;&gt;OpenSSL&lt;/a&gt; and &lt;a href=&#34;https://github.com/open-quantum-safe/openssh-portable&#34;&gt;OpenSSH&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;More information on OQS can be found &lt;a href=&#34;https://openquantumsafe.org/&#34;&gt;here&lt;/a&gt; and in the &lt;a href=&#34;https://openquantumsafe.org/papers/SAC-SteMos16.pdf&#34;&gt;associated&lt;/a&gt; &lt;a href=&#34;https://openquantumsafe.org/papers/NISTPQC-CroPaqSte19.pdf&#34;&gt;whitepapers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;h3&gt;Supported Algorithms&lt;/h3&gt; &#xA;&lt;p&gt;Details on each supported algorithm can be found in the &lt;a href=&#34;https://github.com/open-quantum-safe/liboqs/tree/main/docs/algorithms&#34;&gt;docs/algorithms&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;The list below indicates all algorithms supported by liboqs, but not all those algorithms have been selected for standardization by NIST, specifically Kyber (excluding the &#34;-90s&#34; variants), Dilithium (excluding the &#34;-AES&#34; variants), Falcon, and SPHINCS+ (excluding the &#34;robust&#34; variants). Activating only those standardized algorithms for use in &lt;code&gt;liboqs&lt;/code&gt; can be facilitated by setting the &lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/CONFIGURE.md#oqs_algs_enabled&#34;&gt;OQS_ALGS_ENABLED&lt;/a&gt; build configuration variable to &lt;code&gt;STD&lt;/code&gt;. By default &lt;code&gt;liboqs&lt;/code&gt; is built supporting all, incl. experimental, PQ algorithms listed below.&lt;/p&gt; &#xA;&lt;h4&gt;Key encapsulation mechanisms&lt;/h4&gt; &#xA;&lt;!-- OQS_TEMPLATE_FRAGMENT_LIST_KEXS_START --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;BIKE&lt;/strong&gt;: BIKE-L1, BIKE-L3&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Classic McEliece&lt;/strong&gt;: Classic-McEliece-348864†, Classic-McEliece-348864f†, Classic-McEliece-460896†, Classic-McEliece-460896f†, Classic-McEliece-6688128†, Classic-McEliece-6688128f†, Classic-McEliece-6960119†, Classic-McEliece-6960119f†, Classic-McEliece-8192128†, Classic-McEliece-8192128f†&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;FrodoKEM&lt;/strong&gt;: FrodoKEM-640-AES, FrodoKEM-640-SHAKE, FrodoKEM-976-AES, FrodoKEM-976-SHAKE, FrodoKEM-1344-AES, FrodoKEM-1344-SHAKE&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;HQC&lt;/strong&gt;: HQC-128, HQC-192, HQC-256†&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Kyber&lt;/strong&gt;: Kyber512, Kyber512-90s, Kyber768, Kyber768-90s, Kyber1024, Kyber1024-90s&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;NTRU-Prime&lt;/strong&gt;: sntrup761&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- OQS_TEMPLATE_FRAGMENT_LIST_KEXS_END --&gt; &#xA;&lt;h4&gt;Signature schemes&lt;/h4&gt; &#xA;&lt;!-- OQS_TEMPLATE_FRAGMENT_LIST_SIGS_START --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;CRYSTALS-Dilithium&lt;/strong&gt;: Dilithium2, Dilithium3, Dilithium5, Dilithium2-AES, Dilithium3-AES, Dilithium5-AES&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Falcon&lt;/strong&gt;: Falcon-512, Falcon-1024&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SPHINCS+-Haraka&lt;/strong&gt;: SPHINCS+-Haraka-128f-robust, SPHINCS+-Haraka-128f-simple, SPHINCS+-Haraka-128s-robust, SPHINCS+-Haraka-128s-simple, SPHINCS+-Haraka-192f-robust, SPHINCS+-Haraka-192f-simple, SPHINCS+-Haraka-192s-robust, SPHINCS+-Haraka-192s-simple, SPHINCS+-Haraka-256f-robust, SPHINCS+-Haraka-256f-simple, SPHINCS+-Haraka-256s-robust, SPHINCS+-Haraka-256s-simple&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SPHINCS+-SHA256&lt;/strong&gt;: SPHINCS+-SHA256-128f-robust, SPHINCS+-SHA256-128f-simple, SPHINCS+-SHA256-128s-robust, SPHINCS+-SHA256-128s-simple, SPHINCS+-SHA256-192f-robust, SPHINCS+-SHA256-192f-simple, SPHINCS+-SHA256-192s-robust, SPHINCS+-SHA256-192s-simple, SPHINCS+-SHA256-256f-robust, SPHINCS+-SHA256-256f-simple, SPHINCS+-SHA256-256s-robust, SPHINCS+-SHA256-256s-simple&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SPHINCS+-SHAKE256&lt;/strong&gt;: SPHINCS+-SHAKE256-128f-robust, SPHINCS+-SHAKE256-128f-simple, SPHINCS+-SHAKE256-128s-robust, SPHINCS+-SHAKE256-128s-simple, SPHINCS+-SHAKE256-192f-robust, SPHINCS+-SHAKE256-192f-simple, SPHINCS+-SHAKE256-192s-robust, SPHINCS+-SHAKE256-192s-simple, SPHINCS+-SHAKE256-256f-robust, SPHINCS+-SHAKE256-256f-simple, SPHINCS+-SHAKE256-256s-robust, SPHINCS+-SHAKE256-256s-simple&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- OQS_TEMPLATE_FRAGMENT_LIST_SIGS_END --&gt; &#xA;&lt;p&gt;Note that for algorithms marked with a dagger (†), liboqs contains at least one implementation that uses a large amount of stack space; this may cause failures when run in threads or in constrained environments. For more information, consult the algorithm information sheets in the &lt;a href=&#34;https://github.com/open-quantum-safe/liboqs/tree/main/docs/algorithms&#34;&gt;docs/algorithms&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h3&gt;Limitations and Security&lt;/h3&gt; &#xA;&lt;p&gt;While at the time of this writing there are no vulnerabilities known in any of the quantum-safe algorithms used in this library, caution is advised when deploying quantum-safe algorithms as most of the algorithms and software have not been subject to the same degree of scrutiny as for currently deployed algorithms. Particular attention should be paid to guidance provided by the standards community, especially from the NIST &lt;a href=&#34;https://csrc.nist.gov/Projects/Post-Quantum-Cryptography/Post-Quantum-Cryptography-Standardization&#34;&gt;Post-Quantum Cryptography Standardization&lt;/a&gt; project. As research advances, the supported algorithms may see rapid changes in their security, and may even prove insecure against both classical and quantum computers. Moreover, note that the &lt;code&gt;sntrup761&lt;/code&gt; is only included for interop testing.&lt;/p&gt; &#xA;&lt;p&gt;liboqs does not intend to &#34;pick winners&#34;: algorithm support is informed by the NIST PQC standardization project. We strongly recommend that applications and protocols rely on the outcomes of ths effort when deploying post-quantum cryptography.&lt;/p&gt; &#xA;&lt;p&gt;We realize some parties may want to deploy quantum-safe cryptography prior to the conclusion of the NIST PQC standardization project. We strongly recommend such attempts make use of so-called &lt;strong&gt;hybrid cryptography&lt;/strong&gt;, in which quantum-safe public-key algorithms are used alongside traditional public key algorithms (like RSA or elliptic curves) so that the solution is at least no less secure than existing traditional cryptography.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;WE DO NOT CURRENTLY RECOMMEND RELYING ON THIS LIBRARY IN A PRODUCTION ENVIRONMENT OR TO PROTECT ANY SENSITIVE DATA.&lt;/strong&gt; This library is meant to help with research and prototyping. While we make a best-effort approach to avoid security bugs, this library has not received the level of auditing and analysis that would be necessary to rely on it for high security use.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;h3&gt;Linux/macOS&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install dependencies:&lt;/p&gt; &lt;p&gt;On Ubuntu:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  sudo apt install astyle cmake gcc ninja-build libssl-dev python3-pytest python3-pytest-xdist unzip xsltproc doxygen graphviz python3-yaml valgrind&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;On macOS, using a package manager of your choice (we&#39;ve picked Homebrew):&lt;/p&gt; &lt;pre&gt;&lt;code&gt; brew install cmake ninja openssl@1.1 wget doxygen graphviz astyle valgrind&#xA; pip3 install pytest pytest-xdist pyyaml&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note that, if you want liboqs to use OpenSSL for various symmetric crypto algorithms (AES, SHA-2, etc.) then you must have OpenSSL version 1.1.1 or higher.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the source:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; git clone -b main https://github.com/open-quantum-safe/liboqs.git&#xA; cd liboqs&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;and build:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; mkdir build &amp;amp;&amp;amp; cd build&#xA; cmake -GNinja ..&#xA; ninja&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Various &lt;code&gt;cmake&lt;/code&gt; build options to customize the resultant artifacts are available and are &lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/CONFIGURE.md&#34;&gt;documented in CONFIGURE.md&lt;/a&gt;. All supported options are also listed in the &lt;code&gt;.CMake/alg-support.cmake&lt;/code&gt; file, and can be viewed by running &lt;code&gt;cmake -LAH ..&lt;/code&gt; in the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;The following instructions assume we are in &lt;code&gt;build&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;By default the main build result is &lt;code&gt;lib/liboqs.a&lt;/code&gt;, a static library. If you want to build a shared/dynamic library, append &lt;a href=&#34;https://raw.githubusercontent.com/open-quantum-safe/liboqs/main/CONFIGURE.md#build_shared_libs&#34;&gt;&lt;code&gt;-DBUILD_SHARED_LIBS=ON&lt;/code&gt;&lt;/a&gt; to the &lt;code&gt;cmake -GNinja ..&lt;/code&gt; command above and the result will be &lt;code&gt;lib/liboqs.so|dylib|dll&lt;/code&gt;. The public headers are located in the &lt;code&gt;include&lt;/code&gt; directory. There are also a variety of programs built under the &lt;code&gt;tests&lt;/code&gt; directory:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;test_kem&lt;/code&gt;: Simple test harness for key encapsulation mechanisms&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;test_sig&lt;/code&gt;: Simple test harness for key signature schemes&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;test_kem_mem&lt;/code&gt;: Simple test harness for checking memory consumption of key encapsulation mechanisms&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;test_sig_mem&lt;/code&gt;: Simple test harness for checking memory consumption of key signature schemes&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;kat_kem&lt;/code&gt;: Program that generates known answer test (KAT) values for key encapsulation mechanisms using the same procedure as the NIST submission requirements, for checking against submitted KAT values using &lt;code&gt;tests/test_kat.py&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;kat_sig&lt;/code&gt;: Program that generates known answer test (KAT) values for signature schemes using the same procedure as the NIST submission requirements, for checking against submitted KAT values using &lt;code&gt;tests/test_kat.py&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;speed_kem&lt;/code&gt;: Benchmarking program for key encapsulation mechanisms; see &lt;code&gt;./speed_kem --help&lt;/code&gt; for usage instructions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;speed_sig&lt;/code&gt;: Benchmarking program for signature mechanisms; see &lt;code&gt;./speed_sig --help&lt;/code&gt; for usage instructions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;example_kem&lt;/code&gt;: Minimal runnable example showing the usage of the KEM API&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;example_sig&lt;/code&gt;: Minimal runnable example showing the usage of the signature API&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;test_aes&lt;/code&gt;, &lt;code&gt;test_sha3&lt;/code&gt;: Simple test harnesses for crypto sub-components&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;test_portability&lt;/code&gt;: Simple test harnesses for checking cross-CPU code portability; requires presence of &lt;code&gt;qemu&lt;/code&gt;; proper operation validated only on Ubuntu&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The complete test suite can be run using&lt;/p&gt; &lt;pre&gt;&lt;code&gt; ninja run_tests&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To generate HTML documentation of the API, run:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; ninja gen_docs&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Then open &lt;code&gt;docs/doxygen/html/index.html&lt;/code&gt; in your web browser.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ninja install&lt;/code&gt; can be run to install the built library and &lt;code&gt;include&lt;/code&gt; files to a location of choice, which can be specified by passing the &lt;code&gt;-DCMAKE_INSTALL_PREFIX=&amp;lt;dir&amp;gt;&lt;/code&gt; option to &lt;code&gt;cmake&lt;/code&gt; at configure time. Alternatively, &lt;code&gt;ninja package&lt;/code&gt; can be run to create an install package.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;Binaries can be generated using Visual Studio 2019 with the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools&#34;&gt;CMake Tools&lt;/a&gt; extension installed. The same options as explained above for Linux/macOS can be used and build artifacts are generated in the specified &lt;code&gt;build&lt;/code&gt; folders.&lt;/p&gt; &#xA;&lt;p&gt;If you want to create Visual Studio build files, e.g., if not using &lt;code&gt;ninja&lt;/code&gt;, be sure to &lt;em&gt;not&lt;/em&gt; pass the parameter &lt;code&gt;-GNinja&lt;/code&gt; to the &lt;code&gt;cmake&lt;/code&gt; command as exemplified above. You can then build all components using &lt;code&gt;msbuild&lt;/code&gt;, e.g. as follows: &lt;code&gt;msbuild ALL_BUILD.vcxproj&lt;/code&gt; and install all artifacts e.g. using this command &lt;code&gt;msbuild INSTALL.vcxproj&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Cross compilation&lt;/h3&gt; &#xA;&lt;p&gt;You can cross compile liboqs for various platforms. Detailed information is available &lt;a href=&#34;https://github.com/open-quantum-safe/liboqs/wiki/Platform-specific-notes-for-building-liboqs#cross-compiling&#34;&gt;in the Wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;More detailed information on building, optional build parameters, example applications, coding conventions and more can be found in the &lt;a href=&#34;https://github.com/open-quantum-safe/liboqs/wiki&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions that meet the acceptance criteria are gratefully welcomed. See our &lt;a href=&#34;https://github.com/open-quantum-safe/liboqs/wiki/Contributing-Guide&#34;&gt;Contributing Guide&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;liboqs is licensed under the MIT License; see &lt;a href=&#34;https://github.com/open-quantum-safe/liboqs/raw/main/LICENSE.txt&#34;&gt;LICENSE.txt&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;liboqs includes some third party libraries or modules that are licensed differently; the corresponding subfolder contains the license that applies in that case. In particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.CMake/CMakeDependentOption.cmake&lt;/code&gt;: BSD 3-Clause License&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/common.c&lt;/code&gt;: includes portions which are Apache License v2.0&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/crypto/aes/aes_c.c&lt;/code&gt;: public domain or any OSI-approved license&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/crypto/aes/aes*_ni.c&lt;/code&gt;: public domain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/crypto/sha2/sha2_c.c&lt;/code&gt;: public domain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/crypto/sha3/xkcp_low&lt;/code&gt; : CC0 (public domain), except &lt;code&gt;brg_endian.h&lt;/code&gt; and &lt;code&gt;KeccakP-1600-AVX2.s&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/crypto/sha3/xkcp_low/.../brg_endian.h&lt;/code&gt; : BSD 3-Clause License&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/crypto/sha3/xkcp_low/.../KeccakP-1600-AVX2.s&lt;/code&gt; : BSD-like &lt;a href=&#34;http://www.openssl.org/~appro/cryptogams/&#34;&gt;CRYPTOGAMS license&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/common/rand/rand_nist.c&lt;/code&gt;: See file&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/kem/bike/additional&lt;/code&gt;: Apache License v2.0&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/kem/classic_mceliece/pqclean_*&lt;/code&gt;: public domain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/kem/kyber/pqclean_*&lt;/code&gt;: public domain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/sig/dilithium/pqclean_*&lt;/code&gt;: public domain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/sig/sphincs/pqclean_*&lt;/code&gt;: CC0 (public domain)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Various companies, including Amazon Web Services, Cisco Systems, evolutionQ, IBM Research, and Microsoft Research have dedicated programmer time to contribute source code to OQS. &lt;a href=&#34;https://github.com/open-quantum-safe/liboqs/raw/main/CONTRIBUTORS&#34;&gt;Various people&lt;/a&gt; have contributed source code to liboqs.&lt;/p&gt; &#xA;&lt;p&gt;Financial support for the development of Open Quantum Safe has been provided by Amazon Web Services, the Canadian Centre for Cyber Security, the Unitary Fund, the NGI Assure Fund, and VeriSign Inc.&lt;/p&gt; &#xA;&lt;p&gt;Research projects which developed specific components of OQS have been supported by various research grants, including funding from the Natural Sciences and Engineering Research Council of Canada (NSERC); see the source papers for funding acknowledgments.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>adafruit/Adafruit-GFX-Library</title>
    <updated>2023-01-23T01:33:45Z</updated>
    <id>tag:github.com,2023-01-23:/adafruit/Adafruit-GFX-Library</id>
    <link href="https://github.com/adafruit/Adafruit-GFX-Library" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Adafruit GFX graphics core Arduino library, this is the &#39;core&#39; class that all our other graphics libraries derive from&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Adafruit GFX Library &lt;img src=&#34;https://github.com/adafruit/Adafruit-GFX-Library/workflows/Arduino%20Library%20CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;This is the core graphics library for all our displays, providing a common set of graphics primitives (points, lines, circles, etc.). It needs to be paired with a hardware-specific library for each display device we carry (to handle the lower-level functions).&lt;/p&gt; &#xA;&lt;p&gt;Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit!&lt;/p&gt; &#xA;&lt;p&gt;Written by Limor Fried/Ladyada for Adafruit Industries. BSD license, check license.txt for more information. All text above must be included in any redistribution.&lt;/p&gt; &#xA;&lt;p&gt;Recent Arduino IDE releases include the Library Manager for easy installation. Otherwise, to download, click the DOWNLOAD ZIP button, uncompress and rename the uncompressed folder Adafruit_GFX. Confirm that the Adafruit_GFX folder contains Adafruit_GFX.cpp and Adafruit_GFX.h. Place the Adafruit_GFX library folder your ArduinoSketchFolder/Libraries/ folder. You may need to create the Libraries subfolder if its your first library. Restart the IDE.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;You will also need to install the latest Adafruit BusIO library.&lt;/strong&gt; Search for &#34;Adafruit BusIO&#34; in the library manager, or install by hand from &lt;a href=&#34;https://github.com/adafruit/Adafruit_BusIO&#34;&gt;https://github.com/adafruit/Adafruit_BusIO&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Useful Resources&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Image2Code: This is a handy Java GUI utility to convert a BMP file into the array code necessary to display the image with the drawBitmap function. Check out the code at ehubin&#39;s GitHub repository: &lt;a href=&#34;https://github.com/ehubin/Adafruit-GFX-Library/tree/master/Img2Code&#34;&gt;https://github.com/ehubin/Adafruit-GFX-Library/tree/master/Img2Code&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;drawXBitmap function: You can use the GIMP photo editor to save a .xbm file and use the array saved in the file to draw a bitmap with the drawXBitmap function. See the pull request here for more details: &lt;a href=&#34;https://github.com/adafruit/Adafruit-GFX-Library/pull/31&#34;&gt;https://github.com/adafruit/Adafruit-GFX-Library/pull/31&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&#39;Fonts&#39; folder contains bitmap fonts for use with recent (1.1 and later) Adafruit_GFX. To use a font in your Arduino sketch, #include the corresponding .h file and pass address of GFXfont struct to setFont(). Pass NULL to revert to &#39;classic&#39; fixed-space bitmap font.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&#39;fontconvert&#39; folder contains a command-line tool for converting TTF fonts to Adafruit_GFX header format.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can also use &lt;a href=&#34;https://github.com/tchapi/Adafruit-GFX-Font-Customiser&#34;&gt;this GFX Font Customiser tool&lt;/a&gt; (&lt;em&gt;web version &lt;a href=&#34;https://tchapi.github.io/Adafruit-GFX-Font-Customiser/&#34;&gt;here&lt;/a&gt;&lt;/em&gt;) to customize or correct the output from &lt;a href=&#34;https://github.com/adafruit/Adafruit-GFX-Library/tree/master/fontconvert&#34;&gt;fontconvert&lt;/a&gt;, and create fonts with only a subset of characters to optimize size.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Roadmap&lt;/h3&gt; &#xA;&lt;p&gt;The PRIME DIRECTIVE is to maintain backward compatibility with existing Arduino sketches -- many are hosted elsewhere and don&#39;t track changes here, some are in print and can never be changed! This &#34;little&#34; library has grown organically over time and sometimes we paint ourselves into a design corner and just have to live with it or add progressively more ungainly workarounds.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;We are grateful for everyone&#39;s contributions, but pull requests for the following will NOT be merged:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Additional or incompatible font formats (see Prime Directive above). There are already two formats and the code is quite bloaty there as it is. This also creates liabilities for tools and documentation. What&#39;s there isn&#39;t perfect but it does the job.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Additional or incompatible bitmap formats, for similar reasons. It&#39;s getting messy.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Adding background color to custom fonts to erase prior screen contents. The ONLY acceptable methods are to clear the area with a filled rect, or (to avoid flicker) draw text into a GFXcanvas1 and copy to screen with drawBitmap() w/background color. This is on purpose and by design. We&#39;ve discussed this. Glyphs can overlap.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Scrolling, whether hardware- or software-based. Such implementations tend to rely on hardware-specific features (not universally available), read access to the screen&#39;s framebuffer (ditto) and/or the addition of virtual functions in GFX which them must be added in &lt;em&gt;every&lt;/em&gt; subclass, of which there are many. The GFX API is largely &#34;set&#34; at this point and this is just a limitation we live with now.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Please don&#39;t reformat code for the sake of reformatting code. The resulting large &#34;visual diff&#34; makes it impossible to untangle actual bug fixes from merely rearranged lines. clang-format will be the final arbiter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Please no more pentagram-drawing PRs. Any oddly-specific drawing functions can go in your own code and aren&#39;t helpful in a library context.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you &lt;em&gt;must&lt;/em&gt; have one of these features, consider creating a fork with the features required for your project...it&#39;s easy to keep synced with the upstream code.&lt;/p&gt;</summary>
  </entry>
</feed>