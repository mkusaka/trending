<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-26T01:32:29Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bsauce/kernel-exploit-factory</title>
    <updated>2023-03-26T01:32:29Z</updated>
    <id>tag:github.com,2023-03-26:/bsauce/kernel-exploit-factory</id>
    <link href="https://github.com/bsauce/kernel-exploit-factory" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Linux kernel CVE exploit analysis report and relative debug environment. You don&#39;t need to compile Linux kernel and configure your environment anymore.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;kernel-exploit-factory&lt;/h1&gt; &#xA;&lt;p&gt;Keep updating......&lt;/p&gt; &#xA;&lt;p&gt;Linux kernel CVE exploit analysis report and relative debug environment. You don&#39;t need to compile Linux kernel and configure your environment anymore.&lt;/p&gt; &#xA;&lt;p&gt;This repository is to extract all Linux kernel exploit and relative debug environment. You can use Qemu to boot the kernel and test the exploit.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Eg, test CVE-2017-11176, finally you levate privileges and get the shell&#xA;john@john-virtual-machine:~/Desktop/kernel-exploit-factory/CVE-2017-11176$ ./start.sh &#xA;chmod: /dev/csaw: No such file or directory&#xA;ifconfig: SIOCSIFADDR: No such device&#xA;route: SIOCADDRT: No such device&#xA;/ $ uname -a&#xA;Linux (none) 4.11.9 #1 SMP Sat Feb 20 21:52:39 CST 2021 x86_64 GNU/Linux&#xA;/ $ id&#xA;uid=1000(chal) gid=1000(chal) groups=1000(chal)&#xA;/ $ cd exp&#xA;/exp $ ./exp-slab-4119&#xA;[*] sk_rmem_alloc &amp;gt; sk_rcvbuf ==&amp;gt; ok&#xA;[*] mq_notify start&#xA;[*] wake up thread 1&#xA;... ...&#xA;/exp # id&#xA;uid=0(root) gid=0(root)&#xA;/exp # &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Catalog&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;CVE-2015-8550&lt;/li&gt; &#xA; &lt;li&gt;CVE-2016-9793&lt;/li&gt; &#xA; &lt;li&gt;4-20-BPF-integer&lt;/li&gt; &#xA; &lt;li&gt;CVE-2017-5123&lt;/li&gt; &#xA; &lt;li&gt;CVE-2017-6074&lt;/li&gt; &#xA; &lt;li&gt;CVE-2017-7308&lt;/li&gt; &#xA; &lt;li&gt;CVE-2017-8890&lt;/li&gt; &#xA; &lt;li&gt;CVE-2017-11176&lt;/li&gt; &#xA; &lt;li&gt;CVE-2017-16995&lt;/li&gt; &#xA; &lt;li&gt;CVE-2017-1000112&lt;/li&gt; &#xA; &lt;li&gt;CVE-2018-5333&lt;/li&gt; &#xA; &lt;li&gt;CVE-2019-9213 &amp;amp; CVE-2019-8956&lt;/li&gt; &#xA; &lt;li&gt;CVE-2019-15666&lt;/li&gt; &#xA; &lt;li&gt;CVE-2020-8835&lt;/li&gt; &#xA; &lt;li&gt;CVE-2020-27194&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-3156&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-31440&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-3490&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-22555&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-41073&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-4154&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-42008&lt;/li&gt; &#xA; &lt;li&gt;CVE-2021-43267&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-0185&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-0847&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-0995&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-1015&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-2588&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-2639&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-25636&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-27666&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-32250&lt;/li&gt; &#xA; &lt;li&gt;CVE-2022-34918&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Detail&lt;/h2&gt; &#xA;&lt;h4&gt;1.CVE-2015-8550&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/panhewu9919/article/details/100891770&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.19.65&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启kaslr/SMEP，未开启SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: gcc 编译优化导致的&lt;strong&gt;Double-Fetch漏洞&lt;/strong&gt;，可直接劫持控制流。&lt;/p&gt; &#xA;&lt;h4&gt;2. CVE-2016-9793&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/panhewu9919/article/details/120164051&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.8.13&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 未开 KASLR/SMAP/SMEP。伪造的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.8.13/source/include/linux/skbuff.h#L414&#34;&gt;skb_shared_info&lt;/a&gt;结构在用户空间，显然不能绕过SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;net/core/sock.c&lt;/code&gt;中的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v4.8.13/source/net/core/sock.c#L658&#34;&gt;sock_setsockopt()&lt;/a&gt; 函数&lt;strong&gt;错误处理负值&lt;/strong&gt;，导致 &lt;code&gt;sk_sndbuf&lt;/code&gt; 和 &lt;code&gt;sk_rcvbuf&lt;/code&gt;取值为负。调用&lt;code&gt;write&lt;/code&gt;时将&lt;code&gt;skb-&amp;gt;head&lt;/code&gt;和&lt;code&gt;skb-&amp;gt;end&lt;/code&gt;设置错误，最后调用&lt;code&gt;close&lt;/code&gt;释放时会访问用户空间报错。用户空间地址&lt;code&gt;0xfffffed0&lt;/code&gt;处伪造&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.8.13/source/include/linux/skbuff.h#L414&#34;&gt;skb_shared_info&lt;/a&gt;结构，通过&lt;code&gt;skb_shared_info-&amp;gt;destructor_arg-&amp;gt;callback&lt;/code&gt; 劫持控制流。&lt;/p&gt; &#xA;&lt;h4&gt;3. 4-20-BPF-integer&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/bsauce/p/11560224.html&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.20.0-rc3&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP，未开启kaslr/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: Linux ebpf 模块中&lt;code&gt;queue_stack_map_alloc()&lt;/code&gt;中&lt;strong&gt;整数溢出&lt;/strong&gt;漏洞，导致堆溢出。修改虚表指针劫持控制流到&lt;code&gt;xchg eax, esp&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;h4&gt;4.CVE-2017-5123&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/90a040114188&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux 4.14-rc4&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启 SMEP / SMAP，关闭KASLR。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;/kernel/exit.c&lt;/code&gt;中的&lt;code&gt;waitid&lt;/code&gt;的实现，在调用&lt;code&gt;unsafe_put_user()&lt;/code&gt;将内核数据拷贝到用户空间地址时，没有调用&lt;code&gt;access_ok()&lt;/code&gt;检测用户空间地址的合法性，导致实际可以往内核空间地址拷贝数据。 &lt;strong&gt;waitid未检测用户地址合法性 导致 null 任意地址写&lt;/strong&gt;。可执行0地址shellcode 或 覆盖某猜测范围的cred 来提权。&lt;/p&gt; &#xA;&lt;h4&gt;5.CVE-2017-6074&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2021/09/17/CVE-2017-6074/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-6074&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.9.12&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP，关闭kASLR。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: Linux内核IP V6协议簇的DCCP（数据报拥塞控制协议），&lt;code&gt;net/dccp/input.c&lt;/code&gt;中的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/input.c#L574&#34;&gt;dccp_rcv_state_process()&lt;/a&gt; 函数，在&lt;code&gt;LISTEN&lt;/code&gt;状态下错误处理 &lt;code&gt;DCCP_PKT_REQUEST&lt;/code&gt; 包数据结构，用户采用&lt;code&gt;IPV6_RECVPKTINFO&lt;/code&gt;选项调用&lt;code&gt;setsockopt()&lt;/code&gt;时会触发**&lt;code&gt;sk_buff&lt;/code&gt;结构的 Double-Free**。利用方式类似CVE-2016-8655。第一次触发漏洞，堆喷伪造&lt;code&gt;po-&amp;gt;rx_ring-&amp;gt;prb_bdqc-&amp;gt;retire_blk_timer&lt;/code&gt;结构，执行&lt;code&gt;native_write_cr4(0x406e0)&lt;/code&gt;来关闭SMEP/SMAP；第二次触发漏洞，堆喷伪造&lt;code&gt;skb-&amp;gt; ... -&amp;gt;destructor_arg&lt;/code&gt;结构，执行&lt;code&gt;commit_creds(prepare_kernel_cred(0))&lt;/code&gt;来提权。&lt;/p&gt; &#xA;&lt;h4&gt;6.CVE-2017-7308&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/b53862cd64a6&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-7308&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.10.6&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启 SMEP / SMAP，关闭KASLR。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;net/packet/af_packet.c&lt;/code&gt;中的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.10.6/source/net/packet/af_packet.c#L4181&#34;&gt;&lt;code&gt;packet_set_ring()&lt;/code&gt;&lt;/a&gt;函数没有正确检查块size，长度判断条件错误，导致&lt;strong&gt;堆溢出&lt;/strong&gt;，需要&lt;code&gt;CAP_NET_RAW &lt;/code&gt;权限。两次劫持函数指针，先关闭SMEP/SMAP防护，再提权。&lt;/p&gt; &#xA;&lt;h4&gt;7.CVE-2017-8890&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/699de662f567&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://xz.aliyun.com/t/2383&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.10.15&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP，关闭kASLR、SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;net/ipv4/inet_connection_sock.c&lt;/code&gt;文件中的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.10.15/source/net/ipv4/inet_connection_sock.c#L652&#34;&gt;&lt;code&gt;inet_csk_clone_lock()&lt;/code&gt;&lt;/a&gt;函数存在&lt;strong&gt;Double-Free&lt;/strong&gt;漏洞。利用Double-Free来篡改RCU的回调函数指针，关闭SMEP并跳转到shellcode来修改cred。&lt;/p&gt; &#xA;&lt;h4&gt;8.CVE-2017-11176&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/76041ec5c59f&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.11.9&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP，关闭kASLR、SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: Linux内核中的POSIX消息队列的实现，&lt;code&gt;mq_notify()&lt;/code&gt;函数没有把sock指针置为null，导致UAF。实际上是由于&lt;strong&gt;竞争导致的Double-Free漏洞&lt;/strong&gt;，但竞态的时间可以无限延长。&lt;/p&gt; &#xA;&lt;h4&gt;9.CVE-2017-16995&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/bsauce/p/11583310.html&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.4.110&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: Linux ebpf 模块&lt;strong&gt;整数扩展&lt;/strong&gt;问题，主要问题是二者寄存器值类型不同，导致check函数和真正的函数的执行方法不一致。本漏洞不包含堆栈攻击或控制流劫持，仅用系统调用数据进行提权，是Data-Oriented Attacks在linux内核上的一个典型应用。&lt;/p&gt; &#xA;&lt;h4&gt;10. CVE-2017-1000112&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/1fa163fd5b82&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://bbs.pediy.com/thread-265319.htm&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.12.6&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP，关闭SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;net/ipv4/ip_output.c&lt;/code&gt; 中的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.12.6/source/net/ipv4/ip_output.c#L910&#34;&gt;__ip_append_data()&lt;/a&gt; 没有保证UDP报文处理的一致性，导致两次send报文时，可从UFO路径切换为non-UFO路径，导致&lt;strong&gt;堆溢出&lt;/strong&gt;。利用时可通过覆盖&lt;code&gt;skb_shared_info-&amp;gt;destructor_arg-&amp;gt;callback&lt;/code&gt;劫持控制流。&lt;/p&gt; &#xA;&lt;h4&gt;11. CVE-2018-5333&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/panhewu9919/article/details/119153052&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.14.13&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP，关闭SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;net/rds/rdma.c&lt;/code&gt;中的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v4.14.13/source/net/rds/rdma.c#L788&#34;&gt;&lt;code&gt;rds_cmsg_atomic()&lt;/code&gt;&lt;/a&gt; 函数中忘记将&lt;code&gt;rm-&amp;gt;atomic.op_active&lt;/code&gt;置0，导致 &lt;a href=&#34;https://elixir.bootlin.com/linux/v4.14.13/source/net/rds/rdma.c#L474&#34;&gt;rds_atomic_free_op()&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://elixir.bootlin.com/linux/v4.14.13/source/mm/page-writeback.c#L2559&#34;&gt;set_page_dirty()&lt;/a&gt; 引用&lt;code&gt;page-&amp;gt;page_link&lt;/code&gt;时发生 &lt;strong&gt;&lt;code&gt;null-dereference&lt;/code&gt; 漏洞&lt;/strong&gt;。在0地址伪造结构和函数指针，劫持控制流。&lt;/p&gt; &#xA;&lt;h4&gt;12. CVE-2019-9213 &amp;amp; CVE-2019-8956&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/panhewu9919/article/details/118557802&#34;&gt;CVE-2019-9213-writeup&lt;/a&gt; &lt;a href=&#34;https://blog.csdn.net/panhewu9919/article/details/118557844&#34;&gt;CVE-2019-8956-writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-4.20.0 32位&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP，关闭SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CVE-2019-9213：&lt;code&gt;mm/mmap.c&lt;/code&gt;中的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.20.7/source/mm/mmap.c#L2413&#34;&gt;&lt;code&gt;expand_downwards()&lt;/code&gt;&lt;/a&gt;对mmap最小地址的检查出错，对错误的task进行了capability检查，导致绕过了&lt;code&gt;mmap_min_addr&lt;/code&gt;的限制，&lt;strong&gt;逻辑漏洞&lt;/strong&gt;。利用&lt;code&gt;LD_DEBUG=help /bin/su 1&amp;gt;&amp;amp;%d&lt;/code&gt;命令执行write操作，本来应检测exp的cred，结果错误检测了write进程的cred，就将低地址标记为特权可访问。只有32位系统能成功利用漏洞，原因不详。&lt;/li&gt; &#xA; &lt;li&gt;CVE-2019-8956：&lt;code&gt;net/sctp/socket.c&lt;/code&gt;中的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v4.20.7/source/net/sctp/socket.c#L2025&#34;&gt;&lt;code&gt;sctp_sendmsg()&lt;/code&gt;&lt;/a&gt; 函数在处理&lt;code&gt;SCTP_SENDALL&lt;/code&gt; flag时出现&lt;strong&gt;空指针引用&lt;/strong&gt;漏洞。结合CVE-2019-9213，绕过&lt;code&gt;mmap_min_addr&lt;/code&gt;的限制，可以mmap到低地址0xd4并伪造结构，劫持控制流。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;13. CVE-2019-15666&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2021/09/14/CVE-2019-15666/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/riskeco/Lucky/raw/master/lucky0_RE.c&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Ubuntu 18.04（4.15.0-20-generic #21）&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;net/xfrm/xfrm_user.c&lt;/code&gt;中的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_user.c#L1379&#34;&gt;verify_newpolicy_info()&lt;/a&gt; 错误处理了&lt;code&gt;dir&lt;/code&gt;验证，导致&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L2202&#34;&gt;__xfrm_policy_unlink()&lt;/a&gt;中出现&lt;strong&gt;越界访问&lt;/strong&gt;。漏洞原本是个越界减1，可以利用别的路径来构造UAF，可以往&lt;strong&gt;空闲块上的8字节写null&lt;/strong&gt;。漏洞对象&lt;code&gt;xfrm_policy&lt;/code&gt;位于&lt;code&gt;kmalloc-1024&lt;/code&gt;，cred结构位于&lt;code&gt;kmalloc-192&lt;/code&gt;。首先利用&lt;code&gt;setxattr+userfaultfd&lt;/code&gt;在&lt;code&gt;policy0&lt;/code&gt;周围都喷射&lt;code&gt;kmalloc-1024&lt;/code&gt;堆块，释放&lt;code&gt;policy0&lt;/code&gt;后同时释放喷射块，促使该slab释放后被c子进程的cred复用，然后触发UAF 空闲块8字节NULL写来修改cred中的&lt;code&gt;gid/suid&lt;/code&gt;，再将当前用户添加到sudoers，即可提权。&lt;/p&gt; &#xA;&lt;h4&gt;14. CVE-2020-8835&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/bsauce/p/14123111.html&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://xz.aliyun.com/t/7690&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.5.0&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: kernel/bpf/verifier.c没有正确将64位值转换为32位（直接取低32位），发生&lt;strong&gt;整数截断&lt;/strong&gt;，使得BPF代码验证阶段和实际执行阶段不一致，导致越界读写。&lt;/p&gt; &#xA;&lt;h4&gt;15. CVE-2020-27194&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/b6f11d8df37a&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/willinin/CVE-2020-27194-exp&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.8.14&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: eBPF验证程序中进行or操作时，&lt;code&gt;scalar32_min_max_or()&lt;/code&gt;函数将64位的值赋值到32位的变量上，导致&lt;strong&gt;整数截断&lt;/strong&gt;，进而错误计算了寄存器的范围，从而绕过bpf的检查，导致越界读写。&lt;/p&gt; &#xA;&lt;h4&gt;16. CVE-2021-3156&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/18f36f1342b3&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/blasty/CVE-2021-3156&#34;&gt;exploit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Ubuntu 19.04、Sudo 1.8.27&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: sudo在处理命令行参数时，处理单个反斜杠结尾的命令时，发生逻辑错误，导致&lt;strong&gt;堆溢出&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h4&gt;17. CVE-2021-31440&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2021/06/09/CVE-2021-31440/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/bsauce/kernel-exploit-factory/tree/main/CVE-2021-31440/exp&#34;&gt;exploit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.11&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: eBPF模块—&lt;code&gt;kernel/bpf/verifier.c&lt;/code&gt;的&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.11.20/source/kernel/bpf/verifier.c#L1312&#34;&gt;&lt;code&gt;__reg_combine_64_into_32()&lt;/code&gt;&lt;/a&gt; 函数，寄存器计算错误。利用verifier阶段与实际执行阶段的不一致性，进行越界读写。泄露内核基址、伪造函数表、实现任意读写后篡改本线程的cred。&lt;/p&gt; &#xA;&lt;h4&gt;18. CVE-2021-3490&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2021/08/31/CVE-2021-3490/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/chompie1337/Linux_LPE_eBPF_CVE-2021-3490&#34;&gt;exploit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.11 Linux-5.11.16&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启SMEP/SMAP/kaslr。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: eBPF模块—&lt;code&gt;kernel/bpf/verifier.c&lt;/code&gt;的按位操作（AND、OR 和 XOR）的 eBPF ALU32 边界跟踪没有正确更新 32 位边界，造成 Linux 内核中的越界读取和写入，从而导致任意代码执行。三个漏洞函数分别是 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7078&#34;&gt;scalar32_min_max_and()&lt;/a&gt; 、&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7149&#34;&gt;scalar32_min_max_or()&lt;/a&gt;、&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7219&#34;&gt;scalar32_min_max_xor()&lt;/a&gt;。利用verifier阶段与实际执行阶段的不一致性，进行越界读写。泄露内核基址、伪造函数表、实现任意读写后篡改本线程的cred。&lt;/p&gt; &#xA;&lt;h4&gt;19. CVE-2021-22555&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2021/09/23/CVE-2021-22555/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/google/security-research/raw/master/pocs/linux/cve-2021-22555/exploit.c&#34;&gt;exploit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.11.14&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;net/netfilter/x_tables.c&lt;/code&gt; 中 &lt;code&gt;Netfilter&lt;/code&gt; 模块的&lt;code&gt;ip_tables&lt;/code&gt;子模块， 当调用&lt;code&gt;setsockopt()&lt;/code&gt;和选项&lt;code&gt;IPT_SO_SET_REPLACE&lt;/code&gt;（或 &lt;code&gt;IP6T_SO_SET_REPLACE&lt;/code&gt;）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L731&#34;&gt;xt_compat_match_from_user()&lt;/a&gt; 函数时&lt;strong&gt;堆溢出写 0 ，可转化为UAF&lt;/strong&gt;。攻击者可用于提权，或者从docker、k8s容器（&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29232090&#34;&gt;kubernetes&lt;/a&gt;）中逃逸。需要&lt;code&gt;CAP_NET_ADMIN&lt;/code&gt;权限，或者支持&lt;code&gt;user+network&lt;/code&gt;命名空间。&lt;/p&gt; &#xA;&lt;h4&gt;20. CVE-2021-41073&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/07/11/CVE-2021-41073/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.14.6&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。未开启 &lt;code&gt;CONFIG_SLAB_FREELIST_RANDOM&lt;/code&gt; / &lt;code&gt;CONFIG_SLAB_FREELIST_HARDENED&lt;/code&gt; / &lt;code&gt;CONFIG_BPF_JIT_ALWAYS_ON&lt;/code&gt; / &lt;code&gt;CONFIG_MEMCG &lt;/code&gt;（默认是开启的）。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;fs/io_uring.c&lt;/code&gt;中的&lt;code&gt;loop_rw_iter()&lt;/code&gt;函数存在 &lt;strong&gt;&lt;code&gt;type confusion&lt;/code&gt;漏洞&lt;/strong&gt;，&lt;code&gt;io_kiocb-&amp;gt;rw.addr&lt;/code&gt; 既充当内核地址又充当用户地址，但是在&lt;code&gt;loop_rw_iter()&lt;/code&gt;函数中递增时没有作区分，导致在读文件时错误将内核地址递增，最后错误&lt;strong&gt;将位于可控偏移处的相邻buffer释放掉&lt;/strong&gt;（kmalloc-32）。利用条件很严格，由于漏洞对象位于 kmalloc-32，所以关闭了 freelist 保护机制；由于 &lt;code&gt;seq_operations&lt;/code&gt; 对象采用 &lt;code&gt;GFP_KERNEL_ACCOUNT&lt;/code&gt; flag 分配，所以还关闭了 &lt;code&gt;CONFIG_MEMCG*&lt;/code&gt; 机制；本漏洞采用篡改eBPF中的 &lt;code&gt;sk_filter-&amp;gt;prog&lt;/code&gt; 指针并伪造 BPF程序的方式来进行提权，所以还关闭了 &lt;code&gt;CONFIG_BPF_JIT_ALWAYS_ON&lt;/code&gt; 配置。&lt;/p&gt; &#xA;&lt;h4&gt;21. CVE-2021-4154&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/10/17/CVE-2021-4154/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/Markakd/DirtyCred&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.13.3&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;kernel/cgroup/cgroup-v1.c&lt;/code&gt; 的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13.3/source/kernel/cgroup/cgroup-v1.c#L905&#34;&gt;cgroup1_parse_param()&lt;/a&gt; 函数（通过&lt;code&gt;fsconfig&lt;/code&gt; 系统调用触发）存在类型混淆，导致&lt;strong&gt;UAF漏洞&lt;/strong&gt;。可以调用syscall &lt;code&gt;fsconfig&lt;/code&gt; 设置任意的 fd，最终关闭该文件后 fd 对应 &lt;code&gt;file&lt;/code&gt; 对象会被释放。这样我们就能&lt;strong&gt;释放任意一个文件描述符对应的 &lt;code&gt;file&lt;/code&gt; 结构&lt;/strong&gt;。本文采用两种方法实现利用，一是DirtyCred，二是构造ROP。对比两种方法，DirtyCred方法的优点是跨内核版本通用，不需要适配，缺点是需要覆写特权文件来提权，所以在docker等容器中无法提权；ROP的优点是可以任意读写内核内存并执行任意代码，缺点是对不同内核版本的适配很麻烦。&lt;/p&gt; &#xA;&lt;h4&gt;22. CVE-2021-42008&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2021/12/09/CVE-2021-42008/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://syst3mfailure.io/sixpack-slab-out-of-bounds&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.13.12&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR / SMEP / SMAP / PTI。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;drivers/net/hamradio/6pack.c&lt;/code&gt;中 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L826&#34;&gt;decode_data()&lt;/a&gt; 函数存在&lt;strong&gt;堆溢出&lt;/strong&gt;，用户需具备 &lt;code&gt;CAP_NET_ADMIN&lt;/code&gt; 权限。&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L962&#34;&gt;sixpack_decode()&lt;/a&gt; 可多次调用 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L826&#34;&gt;decode_data()&lt;/a&gt; ，对输入进行解码并保存到 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.13.12/source/drivers/net/hamradio/6pack.c#L98&#34;&gt;sixpack-&amp;gt;cooked_buf&lt;/a&gt; ，&lt;code&gt;sixpack-&amp;gt;rx_count_cooked&lt;/code&gt;成员充当访问 &lt;code&gt;sixpack-&amp;gt;cooked_buf&lt;/code&gt; 的下标，确定写入解码字节的目标偏移。问题是如果多次调用&lt;code&gt;decode_data()&lt;/code&gt;，&lt;code&gt;rx_count_cooked&lt;/code&gt;就会一直递增，直到超过 &lt;code&gt;cooked_buf&lt;/code&gt; 的长度（400字节），导致越界写。参考&lt;a href=&#34;https://www.anquanke.com/post/id/252558&#34;&gt;Linux内核中利用msg_msg结构实现任意地址读写&lt;/a&gt;构造越界读和任意地址写，篡改&lt;code&gt;modprobe_path&lt;/code&gt;提权，缺点是得用到&lt;code&gt;userfaultfd&lt;/code&gt;，且绕不开 &lt;code&gt;CAP_NET_ADMIN&lt;/code&gt; 的槛。&lt;/p&gt; &#xA;&lt;h4&gt;23. CVE-2021-43267&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2021/12/06/CVE-2021-43267/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://haxx.in/posts/pwning-tipc/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.14.15&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: 漏洞位于 &lt;code&gt;net/tipc/crypto.c&lt;/code&gt; 文件，TIPC（Transparent Inter-Process Communication）集群内通信协议中对 &lt;code&gt;MSG_CRYPTO&lt;/code&gt; 类型的消息长度验证出错，导致&lt;strong&gt;堆溢出&lt;/strong&gt;。&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/crypto.c#L2281&#34;&gt;tipc_crypto_key_rcv()&lt;/a&gt; 函数中，TIPC消息（&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/msg.h#L148&#34;&gt;tipc_msg&lt;/a&gt;结构）的数据部分指向&lt;code&gt;MSG_CRYPTO&lt;/code&gt;消息（&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.14.15/source/include/uapi/linux/tipc.h#L241&#34;&gt;tipc_aead_key&lt;/a&gt;结构），在分配&lt;code&gt;tipc_aead_key&lt;/code&gt; 空间并拷贝 &lt;code&gt;tipc_aead_key-&amp;gt;key&lt;/code&gt; 时，未校验&lt;code&gt;tipc_aead_key-&amp;gt;keylen&lt;/code&gt;的有效性，导致拷贝越界。只对TIPC消息的 &lt;code&gt;header size&lt;/code&gt; 和 &lt;code&gt;msg size&lt;/code&gt; 进行检查，却没有对 &lt;code&gt;MSG_CRYPTO&lt;/code&gt;消息的&lt;code&gt;tipc_aead_key-&amp;gt;keylen&lt;/code&gt;进行检查。利用 &lt;code&gt;elastic object&lt;/code&gt; 泄露内核基址，并篡改&lt;code&gt;tty_struct-&amp;gt;tty_operations.ioctl&lt;/code&gt; 指向任意写gadget （&lt;code&gt;mov QWORD PTR [rdx],rsi&lt;/code&gt;），篡改 &lt;code&gt;modprobe_path&lt;/code&gt; 提权。&lt;/p&gt; &#xA;&lt;h4&gt;24. CVE-2022-0185&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/04/08/CVE-2022-0185/&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.11.22&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: 在google kctf 上完成提权，赢得3万美金。内核的 &lt;code&gt;File System Context&lt;/code&gt; 模块（文件系统环境）的&lt;code&gt;fs/fs_context.c&lt;/code&gt;文件中存在&lt;strong&gt;整数溢出&lt;/strong&gt;导致堆溢出。攻击者必须具备 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 权限，或者使用命名空间或者使用&lt;code&gt;unshare(CLONE_NEWNS|CLONE_NEWUSER)&lt;/code&gt; （等同于命令&lt;code&gt;$ unshare -Urm&lt;/code&gt;）来进入含有&lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;权限的命名空间。两种方法利用，一是利用 &lt;strong&gt;FUSE&lt;/strong&gt;（相当于userfault）构造任意地址写，修改 &lt;code&gt;modprobe_path&lt;/code&gt;，二是利用 &lt;code&gt;msg_msg&lt;/code&gt; 构造任意释放，再构造ROP提权。&lt;/p&gt; &#xA;&lt;h4&gt;25. CVE-2022-0847&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/04/03/CVE-2022-0847/&#34;&gt;writeup&lt;/a&gt; reference-&lt;a href=&#34;https://blog.csdn.net/Breeze_CAT/article/details/123393188&#34;&gt;1&lt;/a&gt; &lt;a href=&#34;https://www.anquanke.com/post/id/269886&#34;&gt;2&lt;/a&gt; &lt;a href=&#34;https://www.freebuf.com/vuls/324700.html&#34;&gt;3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.16.10&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;strong&gt;DirtyPipe漏洞&lt;/strong&gt;。&lt;code&gt;splice&lt;/code&gt;调用将包含文件的页面缓存（page cache），链接到pipe的环形缓冲区 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.10/source/include/linux/pipe_fs_i.h#L26&#34;&gt;pipe_buffer&lt;/a&gt; 时，&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.10/source/lib/iov_iter.c#L384&#34;&gt;copy_page_to_iter_pipe()&lt;/a&gt; 和 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.10/source/lib/iov_iter.c#L547&#34;&gt;push_pipe()&lt;/a&gt; 函数都没有将 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.10/source/include/linux/pipe_fs_i.h#L26&#34;&gt;pipe_buffer&lt;/a&gt; -&amp;gt; &lt;code&gt;flag&lt;/code&gt; 成员初始化（变量未初始化漏洞）。由于没有清除 &lt;code&gt;PIPE_BUF_FLAG_CAN_MERGE&lt;/code&gt; 属性，导致后续进行 &lt;code&gt;pipe_write()&lt;/code&gt; 时误以为write操作可合并，从而将非法数据写入了文件页面缓存（重启可复原），导致任意文件覆盖漏洞。该漏洞能写任意文件的page cache，提权方法是修改/etc/passwd的page cache，短时间内所有访问该文件的进程都将访问到被篡改的文件缓存页。&lt;/p&gt; &#xA;&lt;h4&gt;26. CVE-2022-0995&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/04/15/CVE-2022-0995/&#34;&gt;writeup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.11.22&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;watch_queue &lt;/code&gt; 事件通知子系统存在&lt;strong&gt;堆溢出&lt;/strong&gt;，漏洞函数是&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.14/source/kernel/watch_queue.c#L286&#34;&gt;watch_queue_set_filter()&lt;/a&gt;。内核会对用户传入的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.14/source/include/uapi/linux/watch_queue.h#L52&#34;&gt;watch_notification_type_filter&lt;/a&gt; 类型的 filter 进行两次有效性检查，第1次检查是为了确定分配的内存大小，第2次是为了将用户filter 存入该内存。但是两次检查不一致，导致分配空间过小，可溢出存入更多的 filter。可以利用第2次溢出，对相邻的堆块特定bit位置1，接下来的利用方法和 &lt;a href=&#34;https://bsauce.github.io/2021/09/23/CVE-2021-22555/&#34;&gt;CVE-2021-22555&lt;/a&gt; 一样。&lt;/p&gt; &#xA;&lt;h4&gt;27. CVE-2022-1015&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/07/16/CVE-2022-1015/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.17&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: nftables模块中，&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.17/source/net/netfilter/nf_tables_api.c#L9325&#34;&gt;nft_parse_register_load()&lt;/a&gt; 和 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.17/source/net/netfilter/nf_tables_api.c#L9377&#34;&gt;nft_parse_register_store()&lt;/a&gt; 函数没有限制传入的寄存器下标范围，导致整数溢出（能够通过范围校验），从而触发&lt;strong&gt;栈溢出越界读写&lt;/strong&gt;。漏洞利用时，需从中断上下文中返回到用户态，需要利用 &lt;code&gt;__do_softirq()&lt;/code&gt; 函数的末尾完美返回到syscall的上下文，然后调用 &lt;code&gt;switch_task_namespaces(current, &amp;amp;init_nsproxy)&lt;/code&gt; 和 &lt;code&gt;commit_cred(&amp;amp;init_cred)&lt;/code&gt; 提权。&lt;/p&gt; &#xA;&lt;h4&gt;28. CVE-2022-2588&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/10/21/CVE-2022-2588/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/Markakd/CVE-2022-2588&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.19.1&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: 和 &lt;a href=&#34;https://access.redhat.com/security/cve/cve-2021-3715&#34;&gt;CVE-2021-3715&lt;/a&gt; （参见 &lt;a href=&#34;https://zplin.me/talks/BHEU21_trash_kernel_bug.pdf&#34;&gt;BlackHat 2021-Europe-Your Trash Kernel Bug, My Precious 0-day&lt;/a&gt; 16页）类似，由于将 &lt;code&gt;route4_filter&lt;/code&gt; 对象从链表中删除和释放时的检查条件不一致，导致该对象被释放后仍存于链表中，后面可以触发 &lt;strong&gt;Double-Free&lt;/strong&gt;。需要 &lt;code&gt;User Namespaces&lt;/code&gt; 才能触发。采用 &lt;strong&gt;DirtCred&lt;/strong&gt; 方法进行提权。&lt;/p&gt; &#xA;&lt;h4&gt;29. CVE-2022-2639&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/11/24/CVE-2022-2639/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://veritas501.github.io/2022_10_18-CVE-2022-2639%20%20openvswitch%20LPE%20%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.17.4&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;openvswitch&lt;/code&gt; 内核模块中，&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.17.4/source/net/openvswitch/flow_netlink.c#L2439&#34;&gt;reserve_sfa_size()&lt;/a&gt; 存在整数溢出导致 &lt;strong&gt;kmalloc-0x10000 堆溢出写&lt;/strong&gt;，需要利用页喷射构造 cross-cache 溢出。本文基于 &lt;code&gt;pipe-primitive&lt;/code&gt; 来篡改任意文件，所以不需要绕过 KASLR/SMEP/SMAP/KPTI 保护机制，跨版本不需要适配就能完成利用。&lt;strong&gt;先创建pipe并splice到只读文件&lt;code&gt;/usr/bin/mount&lt;/code&gt;，堆喷伪造 &lt;code&gt;pipe_buffer-&amp;gt;flags = PIPE_BUF_FLAG_CAN_MERGE&lt;/code&gt; ，这样就能往 &lt;code&gt;/usr/bin/mount&lt;/code&gt; 文件写入 suid-shell 然后执行提权&lt;/strong&gt;。 两次触发OOB，第一次是溢出篡改 &lt;code&gt;msg_msg-&amp;gt;m_ts&lt;/code&gt; 越界读取相邻的 &lt;code&gt;msg_msg-&amp;gt;m_list.next&lt;/code&gt; &lt;strong&gt;泄露kmalloc-1024堆地址&lt;/strong&gt;；第2次是溢出篡改 &lt;code&gt;msg_msg-&amp;gt;m_list.next&lt;/code&gt; 指向泄露的kmalloc-1024堆地址，&lt;strong&gt;构造任意释放&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h4&gt;30. CVE-2022-25636&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/12/13/CVE-2022-25636/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/Bonfee/CVE-2022-25636&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.13.19&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;nf_table&lt;/code&gt; 模块的 &lt;code&gt;net/netfilter/nf_dup_netdev.c&lt;/code&gt;中的 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.11/source/net/netfilter/nf_dup_netdev.c#L67&#34;&gt;nft_fwd_dup_netdev_offload()&lt;/a&gt; 函数由于计算分配空间与实际初始化时判断条件不一致，存在&lt;strong&gt;OOB write&lt;/strong&gt;（系统必须支持包处理卸载-Network Interface Cards (NICs)，但是现实中很少见），&lt;strong&gt;溢出写入一个 &lt;code&gt;net_device&lt;/code&gt; 对象的地址（位于kmalloc-4k）&lt;/strong&gt;，且漏洞对象的大小可以变化（由传入的含 &lt;code&gt;NFT_OFFLOAD_F_ACTION&lt;/code&gt; 标记的rule个数决定，可以位于 &lt;code&gt;kmalloc-128&lt;/code&gt; 或 &lt;code&gt;kmalloc-192&lt;/code&gt; 等等），需要 &lt;code&gt;SYS_ADMIN&lt;/code&gt; 权限。利用时&lt;strong&gt;通过 &lt;code&gt;msg_msgseg&lt;/code&gt; 泄露 &lt;code&gt;net_device&lt;/code&gt; kmalloc-4k 堆指针，通过覆写 &lt;code&gt;msg_msg-&amp;gt;security&lt;/code&gt; 指针构造任意释放，通过自带功能 &lt;code&gt;ioctl(fd, SIOCGIFHWADDR, leak)&lt;/code&gt; 读取 &lt;code&gt;net_device-&amp;gt;dev_addr&lt;/code&gt; 来泄露内核基址，通过伪造 &lt;code&gt;net_device-&amp;gt;ethtool_ops-&amp;gt;begin&lt;/code&gt; 函数指针劫持控制流提权&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h4&gt;31. CVE-2022-27666&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://paper.seebug.org/1889/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://etenal.me/archives/1825&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.16.14&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: 在PWN2OWN比赛上，完成对Ubuntu 21.10 的提权。内核的 esp6 crypto 模块，接收缓冲区是 8-page，但发送者可以发送大于 8-page 的数据，由 &lt;a href=&#34;https://elixir.bootlin.com/linux/v5.16.14/source/crypto/crypto_null.c#L76&#34;&gt;null_skcipher_crypt()&lt;/a&gt; 函数导致&lt;strong&gt;页溢出&lt;/strong&gt;。总体采用页喷射技术，首先利用 &lt;code&gt;user_key_payload&lt;/code&gt; 弹性对象泄露 &lt;code&gt;msg_msg-&amp;gt;next&lt;/code&gt;，然后利用 &lt;code&gt;msg_msg&lt;/code&gt; 来泄露 &lt;code&gt;seq_operations-&amp;gt;start&lt;/code&gt; 内核地址，最后利用 &lt;code&gt;msg_msg&lt;/code&gt; 和 FUSE页错误处理构造任意写，来篡改 &lt;code&gt;modprobe_path&lt;/code&gt; 提权。&lt;/p&gt; &#xA;&lt;h4&gt;32. CVE-2022-32250&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/11/03/CVE-2022-32250/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://github.com/theori-io/CVE-2022-32250-exploit&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.17.12&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: &lt;code&gt;nftables&lt;/code&gt; 模块的 &lt;code&gt;net/netfilter/nf_tables_api.c&lt;/code&gt; 采用 &lt;code&gt;NFT_MSG_NEWSET&lt;/code&gt; 功能来添加 &lt;code&gt;nft_set&lt;/code&gt; 时，处理 &lt;code&gt;lookup&lt;/code&gt; 和 &lt;code&gt;dynset&lt;/code&gt; expression 时，由于错误的 &lt;code&gt;NFT_EXPR_STATEFUL&lt;/code&gt; 检查，&lt;code&gt;nft_expr&lt;/code&gt; 对象释放后仍位于&lt;code&gt;nft_set-&amp;gt;binding&lt;/code&gt; 链表中，新加入 &lt;code&gt;nft_expr&lt;/code&gt; 时导致&lt;strong&gt;UAF写&lt;/strong&gt;（触发漏洞需要 &lt;code&gt;CAP_NET_ADMIN&lt;/code&gt; 权限）。UAF写会往 &lt;code&gt;kmalloc-64&lt;/code&gt; 的偏移 0x18 处写入另一个 &lt;code&gt;kmalloc-64&lt;/code&gt; 堆块偏移 0x18 的地址值。利用方法，采用 &lt;strong&gt;mqueue 中的 &lt;code&gt;msg_msg&lt;/code&gt; 来泄露内核基址&lt;/strong&gt;，因为 mqueue 中的 &lt;code&gt;posix_msg_tree_node-&amp;gt;msg_list&lt;/code&gt; 偏移为 0x18（且位于&lt;code&gt;kmalloc-64&lt;/code&gt;），恰好是UAF写的偏移；另外，&lt;strong&gt;&lt;code&gt;posix_msg_tree_node-&amp;gt;msg_list&lt;/code&gt; 也能用来构造 Unlink 利用&lt;/strong&gt;来篡改 &lt;code&gt;modprobe_path&lt;/code&gt;。利用&lt;code&gt;user_key_payload&lt;/code&gt;泄露堆地址（便于构造unlink），老生常谈了。注意，需使用ubuntu21.04 以上的版本的libmnl 或 libnftnl才行。&lt;/p&gt; &#xA;&lt;h4&gt;33. CVE-2022-34918&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bsauce.github.io/2022/07/26/CVE-2022-34918/&#34;&gt;writeup&lt;/a&gt; &lt;a href=&#34;https://www.randorisec.fr/crack-linux-firewall/&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Test version&lt;/strong&gt;: Linux-5.17.15&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;: 开启KASLR/SMEP/SMAP。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: nftables模块中，&lt;a href=&#34;https://elixir.bootlin.com/linux/v5.18.10/source/net/netfilter/nf_tables_api.c#L5459&#34;&gt;nft_set_elem_init()&lt;/a&gt; 函数存在&lt;strong&gt;堆溢出&lt;/strong&gt;，溢出长度可达 &lt;code&gt;64-16=48&lt;/code&gt;字节，漏洞对象可以位于 &lt;code&gt;kmalloc-{64,96,128,192}&lt;/code&gt;（本文利用时选取 kmalloc-64 漏洞对象）。漏洞利用——首先构造堆布局 &lt;code&gt;vul_obj -&amp;gt; user_key_payload -&amp;gt; percpu_ref_data&lt;/code&gt;，溢出篡改 &lt;code&gt;user_key_payload-&amp;gt;datalen&lt;/code&gt; 为 0xffff，以泄露出 &lt;code&gt;percpu_ref_data-&amp;gt;release&lt;/code&gt; 内核基址和 &lt;code&gt;percpu_ref_data-&amp;gt;ref&lt;/code&gt; physmap基址；然后构造堆布局 &lt;code&gt;vul_obj -&amp;gt; simple_xattr&lt;/code&gt;，溢出篡改 &lt;code&gt;simple_xattr-&amp;gt;list&lt;/code&gt; 链表，利用这个有限制的任意写将 &lt;code&gt;modprobe_path&lt;/code&gt; 从 &lt;code&gt;/sbin/modprobe&lt;/code&gt; 修改为 &lt;code&gt;/tmp/xxxxprobe&lt;/code&gt; 来提权（从链表中移除xattr时触发该任意写）。该任意写的前提条件是需要泄露 physmap 地址，&lt;code&gt;percpu_ref_data&lt;/code&gt; / &lt;code&gt;shm_file_data&lt;/code&gt; 都既包含内核基址又包含physmap地址。&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>TheRealOrange/icer_compression</title>
    <updated>2023-03-26T01:32:29Z</updated>
    <id>tag:github.com,2023-03-26:/TheRealOrange/icer_compression</id>
    <link href="https://github.com/TheRealOrange/icer_compression" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Progressive, error tolerant, wavelet-based image compression algorithm&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ICER Image Compression Algorithm&lt;/h1&gt; &#xA;&lt;p&gt;The code in this repository implements the NASA ICER image compression algorithm as a C library. Said compression algorithm is a progressive, wavelet-based image compression algorithm designed to be resistant to data loss, making it suitable for use as the image compression algorithm when encoding images to be transmitted over unreliable delivery channels, such as those in satellite radio communications.&lt;/p&gt; &#xA;&lt;p&gt;This library was designed with memory-constrained embedded systems in mind, hence the language choice of C, but it should function just as well on normal machines.&lt;/p&gt; &#xA;&lt;p&gt;Below are sample images of the compression algorithm producing output images of varying quality depending on the space allocated for it. 10 error containment segments are used, and 9 bitplanes were compressed&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;img src=&#34;https://github.com/TheRealOrange/icer_compression/raw/master/assets/original.bmp?raw=true&#34; alt=&#34;original&#34;&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;img src=&#34;https://github.com/TheRealOrange/icer_compression/raw/master/assets/70kb_quota.bmp?raw=true&#34; alt=&#34;70kb_quota&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;original image (512x512, 262 kilobyte)&lt;/td&gt; &#xA;   &lt;td&gt;70 kilobyte quota&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/TheRealOrange/icer_compression/raw/master/assets/50kb_quota.bmp?raw=true&#34; alt=&#34;50kb_quota&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/TheRealOrange/icer_compression/raw/master/assets/30kb_quota.bmp?raw=true&#34; alt=&#34;30kb_quota&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;50 kilobyte quota&lt;/td&gt; &#xA;   &lt;td&gt;30 kilobyte quota&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The compression effectiveness depends greatly on the number of error containment segments chosen.&lt;/p&gt; &#xA;&lt;p&gt;This library uses snippets and sections of code written by others, I will credit them accordingly here.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CRC32 checksum library, taken from the &lt;a href=&#34;https://github.com/vonj/snippets.org&#34;&gt;SNIPPETS C Source Code Archive&lt;/a&gt; (now itself archived on a github repository)&lt;/li&gt; &#xA; &lt;li&gt;Image parsing libaries, taken from &lt;a href=&#34;https://github.com/nothings/stb&#34;&gt;STB libraries&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What is this?&lt;/h2&gt; &#xA;&lt;p&gt;This compression algorithm is based on &lt;a href=&#34;https://ipnpr.jpl.nasa.gov/progress_report/42-155/155J.pdf&#34;&gt;a document published by NASA&lt;/a&gt;. This repository simply implements the algorithm as described by the paper.&lt;/p&gt; &#xA;&lt;p&gt;This algorithm is best described by the abstract of the document by NASA, which reads as follows:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;ICER is a progressive, wavelet-based image data compressor designed to meet the specialized needs of deep-space applications while achieving state-of-the-art compression effectiveness. ICER can provide lossless and lossy compression, and incorporates an error-containment scheme to limit the effects of data loss during transmission. The Mars Exploration Rover (MER) mission will rely primarily on a software implementation of ICER for image compression. This article describes ICER and the methods it uses to meet its goals, and explains the rationale behind the choice of methods. Performance results also are presented.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To get a better understanding of how this works, as well as its advantages and disadvantages, its recommended that you read the original NASA document.&lt;/p&gt; &#xA;&lt;h2&gt;Key Features&lt;/h2&gt; &#xA;&lt;p&gt;There are a few key design considerations which were taking into account when writing this library, which are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Designed to only utilise integer arithmetic operations, as designed by NASA&lt;/li&gt; &#xA; &lt;li&gt;Avoids dynamic memory allocation in the library, so memory can be better managed in memory-constrained embedded systems&lt;/li&gt; &#xA; &lt;li&gt;Optimised for execution on embedded systems&lt;/li&gt; &#xA; &lt;li&gt;Error containment features prevent data loss from affecting the quality of the whole image&lt;/li&gt; &#xA; &lt;li&gt;Ability to set a output size target and stop compression once the quota is reached&lt;/li&gt; &#xA; &lt;li&gt;Able to compress images losslessly (if the output quota permits)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(again, recommended that you carefully read the NASA document to understand why and how these are significant)&lt;/p&gt; &#xA;&lt;h2&gt;How do I use it?&lt;/h2&gt; &#xA;&lt;p&gt;The project is designed as a C-library and as such is intended to be used as a part of a larger program, not as a standalone program. First, one must call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int icer_init();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in order to initialise the constants and look up tables used in encode and decode functions. The main functions which are important for the usage of the library are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int icer_compress_image_uint8(uint8_t *image, size_t image_w, size_t image_h, uint8_t stages, enum icer_filter_types filt, uint8_t segments, icer_output_data_buf_typedef *output_data);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which is the function which enables the user to specify an image buffer of a specific width and height, as well as the filter coefficients to use, the number of time to perform wavelet decomposition, and the number of error containment segments to subdivide the image into&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int icer_decompress_image_uint8(uint8_t *image, size_t *image_w, size_t *image_h, size_t image_bufsize, uint8_t *datastream, size_t data_length, uint8_t stages, enum icer_filter_types filt, uint8_t segments);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which is the function which enables the user to decompress a byte stream stored inside &lt;code&gt;datastream&lt;/code&gt; and fill the image and the dimensions into the buffer specified.&lt;/p&gt; &#xA;&lt;h2&gt;How do I test it?&lt;/h2&gt; &#xA;&lt;p&gt;To run the example code, simply build it and place the &lt;code&gt;boat.512.bmp&lt;/code&gt; image as the same folder as the executable to generate the output.&lt;/p&gt; &#xA;&lt;h3&gt;Note: Work in progress!&lt;/h3&gt; &#xA;&lt;p&gt;This project is still a work in progress! Currently, images of a bit depth of 5-6 bits per pixel are supported, because the wavelet transform produces an increased dynamic range which can cause overflows. Encoding in a 16-bit word will allow for a greater bit depth per pixel, and such functions have been implemented but as of yet are untested Colour image support is also yet to be implemented.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>open-education-hub/operating-systems</title>
    <updated>2023-03-26T01:32:29Z</updated>
    <id>tag:github.com,2023-03-26:/open-education-hub/operating-systems</id>
    <link href="https://github.com/open-education-hub/operating-systems" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Teaching resources (OER) for Operating Systems&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Operating Systems (OER)&lt;/h1&gt; &#xA;&lt;p&gt;These are open educational resources (&lt;a href=&#34;https://en.wikipedia.org/wiki/Open_educational_resources&#34;&gt;OER&lt;/a&gt;) for Operating Systems classes. They are to be used by teachers, trainers, students and hobbyists who want to learn about modern topics in operating systems.&lt;/p&gt; &#xA;&lt;h2&gt;Using the Content&lt;/h2&gt; &#xA;&lt;p&gt;Content is located in the &lt;code&gt;content/&lt;/code&gt; folder. It currently consists of 5 chapters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-education-hub/operating-systems/master/content/chapters/software-stack/&#34;&gt;Software Stack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-education-hub/operating-systems/master/content/chapters/data/&#34;&gt;Data&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-education-hub/operating-systems/master/content/chapters/compute/&#34;&gt;Compute&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-education-hub/operating-systems/master/content/chapters/io/&#34;&gt;Input/Output&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-education-hub/operating-systems/master/content/chapters/app-interact/&#34;&gt;Application Interaction&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each chapter has its own folder. Content for each chapter is split in two subfolders:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lecture/&lt;/code&gt;: content to be presented and discussed as part of lectures&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lab/&lt;/code&gt;: content to be worked on as practical activities during labs / seminars&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Lecture content is expected to be presented and followed. Lab content is expected to be used as practice work.&lt;/p&gt; &#xA;&lt;h2&gt;Chapter Contents&lt;/h2&gt; &#xA;&lt;p&gt;Lecture content consists of slides and demos. Slides are written in &lt;a href=&#34;https://guides.github.com/features/mastering-markdown/&#34;&gt;GitHub Markdown&lt;/a&gt; and use &lt;a href=&#34;https://github.com/webpro/reveal-md&#34;&gt;reveal-md&lt;/a&gt; and &lt;a href=&#34;https://revealjs.com/&#34;&gt;reveal.js&lt;/a&gt; to render HTML output. Lecture slides are built from the &lt;code&gt;slides.md&lt;/code&gt; file using the &lt;code&gt;make&lt;/code&gt; command (and the &lt;code&gt;Makefile&lt;/code&gt;). Demos are snippets of code and support files that showcase concepts and ideas related to the lecture. Demos are located in the &lt;code&gt;demo/&lt;/code&gt; folder. Each demo has its own folder with source code, &lt;code&gt;Makefile&lt;/code&gt; or other build files (if required) and support files.&lt;/p&gt; &#xA;&lt;p&gt;Lab content consists of lab text and lab activities. Lab text is placed in the &lt;code&gt;README.md&lt;/code&gt; file. Each lab activity has its own folder with source code, &lt;code&gt;Makefile&lt;/code&gt; or other build files (if required) and support files.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome. See the &lt;a href=&#34;https://raw.githubusercontent.com/open-education-hub/operating-systems/master/CONTRIBUTING.md&#34;&gt;contribution guide&lt;/a&gt; on how you could report or fix issues and on how you can improve the content.&lt;/p&gt; &#xA;&lt;p&gt;Reviewers are requested to follow the &lt;a href=&#34;https://raw.githubusercontent.com/open-education-hub/operating-systems/master/REVIEWING.md&#34;&gt;reviewing guide&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>