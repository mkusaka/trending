<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-25T01:29:50Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kiks7/CVE-2022-2602-Kernel-Exploit</title>
    <updated>2022-12-25T01:29:50Z</updated>
    <id>tag:github.com,2022-12-25:/kiks7/CVE-2022-2602-Kernel-Exploit</id>
    <link href="https://github.com/kiks7/CVE-2022-2602-Kernel-Exploit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CVE-2022-2602-Kernel-Exploit&lt;/h1&gt; &#xA;&lt;h2&gt;Details&lt;/h2&gt; &#xA;&lt;h2&gt;TL;DR&lt;/h2&gt; &#xA;&lt;p&gt;The vulnerability is an Use-After-Free that impacts the registered file descriptor functionality in the io_uring subsystem. It&#39;s possible to register a file in the io_uring context, free it from the Unix Garbage Collector and re-use it with the requested io_uring operation (for example, a &lt;code&gt;writev&lt;/code&gt; operation). To exploit the bug, it was a matter of replace the freed file structure with a read-only file (e.g. /etc/passwd), in order to write into it, and achieve a good timing with a small race window.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>AncientJames/uGrey</title>
    <updated>2022-12-25T01:29:50Z</updated>
    <id>tag:github.com,2022-12-25:/AncientJames/uGrey</id>
    <link href="https://github.com/AncientJames/uGrey" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Micropython native module to display greyscale on a monochrome oled.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Greyscale driver for SSD1306 displays.&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Very specifically, for RP2040 devices with a 72x40 SPI display.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a micropython native module which rapidly updates a monochrome display to achieve a greyscale image. It provides a normal greyscale framebuffer supporting all the usual primitive operations, and uses the RP2040&#39;s second core handle re-rendering and updating the display.&lt;/p&gt; &#xA;&lt;p&gt;I created it for a tiny computer in a brick (&lt;a href=&#34;https://www.youtube.com/watch?v=0pUV_3qeHog&#34;&gt;https://www.youtube.com/watch?v=0pUV_3qeHog&lt;/a&gt;), but it also works on the Thumby.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to build it yourself, you just need to copy &lt;code&gt;ugrey.mpy&lt;/code&gt; to your device, and import it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import ugrey&#xA;&#xA;with ugrey.Device() as display:&#xA;    display.start()&#xA;&#xA;    fb = display.framebuffer&#xA;&#xA;    while True:&#xA;        fb.fill(0)&#xA;&#xA;        # normal framebuf drawing shenanigans&#xA;&#xA;        display.show()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After initialising the device (but before starting it), you can configure some settings:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;display.grey_bits&lt;/code&gt; is the number of bits of greyscale. 1 is monochrome, 3 is probably as high as it&#39;s worth going.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;display.dither_bits&lt;/code&gt; can be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; - whether to add dithering into the mix.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;display.temporal_dither&lt;/code&gt; - whether to alternate the dithering each frame&lt;/p&gt; &#xA;&lt;p&gt;You can also initialise it with &lt;code&gt;ugrey.Device(bpp=x)&lt;/code&gt;, and let it choose sensible defaults for the given bit depth. The default is &lt;code&gt;4&lt;/code&gt;, which gives you 3 bits of grey + 1 bit of dither in a &lt;code&gt;GS4&lt;/code&gt; framebuffer. &lt;code&gt;bpp=8&lt;/code&gt; keeps the same output settings but gives you a &lt;code&gt;GS8&lt;/code&gt; framebuffer.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t supply a framebuffer, it will create its own using a format which fits the requested bit depth.&lt;/p&gt; &#xA;&lt;p&gt;Depending on your display you might need to fiddle with &lt;code&gt;display.frame_period&lt;/code&gt; - SSD1306 displays should work at around 5500 uS. I&#39;ve had some which can&#39;t lock at this frequency, but work at 6400.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>atc1441/ATC_MiThermometer</title>
    <updated>2022-12-25T01:29:50Z</updated>
    <id>tag:github.com,2022-12-25:/atc1441/ATC_MiThermometer</id>
    <link href="https://github.com/atc1441/ATC_MiThermometer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Custom firmware for the Xiaomi Thermometer LYWSD03MMC and Telink Flasher via USB to Serial converter&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ATC_MiThermometer&lt;/h1&gt; &#xA;&lt;p&gt;Custom firmware for the Xiaomi Thermometer LYWSD03MMC and Telink Flasher via USB to Serial converter.&lt;/p&gt; &#xA;&lt;h3&gt;Hardware revision B1.4, B1.6 and B1.9 is now fully compatible&lt;/h3&gt; &#xA;&lt;p&gt;This repo is made together with this explanation video:(click on it)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=NXKzFG61lNs&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/NXKzFG61lNs/0.jpg&#34; alt=&#34;YoutubeVideo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Victor @pvvx did some very nice refinings of this custom firmare so i really suggest on cheking it out and even use his version as it offers many more functions including non-volatile storage and a better low power management &lt;a href=&#34;https://github.com/pvvx/ATC_MiThermometer&#34;&gt;https://github.com/pvvx/ATC_MiThermometer&lt;/a&gt;&lt;/h5&gt; &#xA;&lt;p&gt;It is possible to update the Firmware of the Xiaomi Thermometer OTA with this WEB Tool I wrote: &lt;a href=&#34;https://atc1441.github.io/TelinkFlasher.html&#34;&gt;https://atc1441.github.io/TelinkFlasher.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The web flasher works for many devices that uses the Telink TLSR82** MCUs and it can also be used to reflash the Stock firmware back to the device.&lt;/p&gt; &#xA;&lt;h3&gt;You can support my work via PayPal: &lt;a href=&#34;https://paypal.me/hoverboard1&#34;&gt;https://paypal.me/hoverboard1&lt;/a&gt; this keeps projects like this coming.&lt;/h3&gt; &#xA;&lt;p&gt;Tutorial in spanish: &lt;a href=&#34;https://domoticaencasa.es/tutorial-custom-firmware-termohigrometro-xiaomi-lywsd03mmc&#34;&gt;https://domoticaencasa.es/tutorial-custom-firmware-termohigrometro-xiaomi-lywsd03mmc&lt;/a&gt; Thanks to Eduardo Ruiz&lt;/p&gt; &#xA;&lt;h2&gt;OTA&lt;/h2&gt; &#xA;&lt;h3&gt;How to flash the custom firmware:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the ATC_Thermometer.bin file from the &lt;a href=&#34;https://github.com/atc1441/ATC_MiThermometer/releases&#34;&gt;latest release&lt;/a&gt; assets and open the Web Flasher.&lt;/li&gt; &#xA; &lt;li&gt;Connect to the Xiaomi thermometer; searching may take a while as it broadcasts not so often for better battery life.&lt;/li&gt; &#xA; &lt;li&gt;After the connection is successful click on &#34;Do Activation&#34; to Authorize the Connection. While it&#39;s doing so you can already select the firmware file. Be careful to select the right one as it&#39;s not possible to check the firmware further.&lt;/li&gt; &#xA; &lt;li&gt;Click on start flashing to flash the new firmware to the Thermometer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After the flashing is done, the device should reboot. If the screen stays off, pull the battery out for a short amount of time.&lt;/p&gt; &#xA;&lt;p&gt;To flash the stock firmware back to the Thermometer, just open the corresponding file (link in the section &#34;Stock firmware&#34; at the bottom of this document) for flashing.&lt;/p&gt; &#xA;&lt;h2&gt;USB to UART&lt;/h2&gt; &#xA;&lt;h3&gt;How to flash the custom firmware or unbrick the device:&lt;/h3&gt; &#xA;&lt;p&gt;To flash a new firmware via an standard USB to UART adapter, simply connect the Thermometer as seen in the picture &lt;a href=&#34;https://raw.githubusercontent.com/atc1441/ATC_MiThermometer/master/Mi_SWS_Connection.jpg&#34;&gt;Mi_SWS_Connection.jpg&lt;/a&gt; to the USB to UART converter and run the ATCtelink.py tool with the first parameter being the name of the file you want to flash.&lt;/p&gt; &#xA;&lt;p&gt;Example: &#34;python3 ATCtelink.py ATC_Thermometer.bin&#34;&lt;/p&gt; &#xA;&lt;p&gt;If the flashing fails or no valid COM port can be found, you can edit it in the Python script. Also try to increase the ResetTime, I will try to make that nicer in the future! So far it turned out that flashing via MAC does not work correctly. I think it&#39;s because the data will not get pushed out in real time so the Emulated SWS protocol gets interrupted.&lt;/p&gt; &#xA;&lt;p&gt;The UART flasher software uses code base from &lt;a href=&#34;https://github.com/pvvx/TlsrComSwireWriter&#34;&gt;https://github.com/pvvx/TlsrComSwireWriter&lt;/a&gt;. Thanks to pvvx for the awesome work on this!&lt;/p&gt; &#xA;&lt;h2&gt;Custom firmware:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To build the custom firmware on your own, follow this guide to get a working TC32 Compiler environment ready where you can add the Custom Mi firmware.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Original guide in Chinese: &lt;a href=&#34;https://github.com/Ai-Thinker-Open/Telink_825X_SDK&#34;&gt;https://github.com/Ai-Thinker-Open/Telink_825X_SDK&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Guide translated to English with Google Translate: &lt;a href=&#34;https://translate.google.com/translate?sl=auto&amp;amp;tl=en&amp;amp;u=https://github.com/Ai-Thinker-Open/Telink_825X_SDK&#34;&gt;https://translate.google.com/translate?sl=auto&amp;amp;tl=en&amp;amp;u=https://github.com/Ai-Thinker-Open/Telink_825X_SDK&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Try to &#34;make&#34; the blink example included in the SDK once to see if the compiling works as it should.&lt;/li&gt; &#xA; &lt;li&gt;You can then copy the folder &#34;ATC_Thermometer&#34; into the example folder and go into that with the terminal.&lt;/li&gt; &#xA; &lt;li&gt;Now do a &#34;make&#34; and it will build the custom firmware.&lt;/li&gt; &#xA; &lt;li&gt;The newly created .bin file can then simply be flashed by either the Web Flasher or the USB to UART method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Because of the OTA dual bank update method a firmware can be maximum 256kB in size.&lt;/p&gt; &#xA;&lt;p&gt;The MCU used in the Thermometer is the TLSR8251 the datasheet can be found here: &lt;a href=&#34;http://wiki.telink-semi.cn/doc/ds/DS_TLSR8251-E_Datasheet%20for%20Telink%20BLE+IEEE802.15.4%20Multi-Standard%20Wireless%20SoC%20TLSR8251.pdf&#34;&gt;http://wiki.telink-semi.cn/doc/ds/DS_TLSR8251-E_Datasheet%20for%20Telink%20BLE+IEEE802.15.4%20Multi-Standard%20Wireless%20SoC%20TLSR8251.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Getting the MAC of your Thermometer:&lt;/h3&gt; &#xA;&lt;p&gt;On boot the custom firmware will show the last three bytes of the MAC Address in the humidity display part on the LCD for 2 seconds each, the first three bytes are always the same (A4:C1:38) so not shown. Also the BLE name will include the last three bytes of the MAC Address.&lt;/p&gt; &#xA;&lt;h2&gt;Settings in custom firmware:&lt;/h2&gt; &#xA;&lt;p&gt;The following settings can be sent to the RxTx Characteristics 0x1F10/0x1f1f&lt;/p&gt; &#xA;&lt;p&gt;These settings can be stored in the device by clicking the &#34;Save current settings in flash&#34; button or can be reset to default by clicking the &#34;Reset settings to default&#34; button.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;default value&lt;/strong&gt; is denoted by the option being written in &lt;strong&gt;bold&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Show battery level in LCD :&lt;/h3&gt; &#xA;&lt;p&gt;Will show Battery % (when the battery symbol is displayed at the bottom of the screen) or Humidity % (when the battery symbol is NOT displayed at the bottom of the screen) alternatively every 5~6 seconds.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;0xB1 = Enabled&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;0xB0 = Disabled&lt;/p&gt; &#xA;&lt;h3&gt;Change display to °F or °C:&lt;/h3&gt; &#xA;&lt;p&gt;0xFF = Temperature in °F&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;0xCC = Temperature in °C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Blinking smiley:&lt;/h3&gt; &#xA;&lt;p&gt;0xA0 = Smiley off&lt;/p&gt; &#xA;&lt;p&gt;0xA1 = Smiley happy&lt;/p&gt; &#xA;&lt;p&gt;0xA2 = Smiley sad&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;0xA3 = Comfort Indicator&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;0xAB = Smiley blinking&lt;/p&gt; &#xA;&lt;h3&gt;Advertising type:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;0xAE = Custom&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;0xAF = Mi Like&lt;/p&gt; &#xA;&lt;h3&gt;Advertising interval&lt;/h3&gt; &#xA;&lt;p&gt;byte0 0xFE&lt;/p&gt; &#xA;&lt;p&gt;byte1 0x06 - value times 10 seconds = interval &lt;strong&gt;60 seconds default&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Temp and Humi offset&lt;/h3&gt; &#xA;&lt;p&gt;byte0 0xFA = Temp offset&lt;/p&gt; &#xA;&lt;p&gt;byte0 0xFB = Humi offset&lt;/p&gt; &#xA;&lt;p&gt;byte1 as an int8_t&lt;/p&gt; &#xA;&lt;p&gt;so Temp = range -12,8 - + 12,8 °C offset Humi = range -50 - +50 % offset&lt;/p&gt; &#xA;&lt;h3&gt;Temp or Humi instant advertising&lt;/h3&gt; &#xA;&lt;p&gt;When the temp or Humidity changes too fast between the main loop (5 seconds interval), the Advertising will be instant for that one.&lt;/p&gt; &#xA;&lt;p&gt;byte0 0xFC = temp_alarm_point // value divided by 10 for temp in °C&lt;/p&gt; &#xA;&lt;p&gt;byte0 0xFD = humi_alarm_point&lt;/p&gt; &#xA;&lt;p&gt;byte1 as int8_t&lt;/p&gt; &#xA;&lt;p&gt;Temp alarm from 0,1°C to 25,5°C Range &amp;lt;- 0,5°C Default&lt;/p&gt; &#xA;&lt;p&gt;Humi alarm from 1% to 50% Range &amp;lt;- &lt;strong&gt;5% Default&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Advertising format of the custom firmware:&lt;/h2&gt; &#xA;&lt;p&gt;The custom firmware sends every minute an update of advertising data on the UUID 0x181A with the Tempereature, Humidity and Battery data.&lt;/p&gt; &#xA;&lt;p&gt;The format of the advertising data is as follow:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Byte 5-10 MAC in correct order&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Byte 11-12 Temperature in int16&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Byte 13 Humidity in percent&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Byte 14 Battery in percent&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Byte 15-16 Battery in mV uint16_t&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Byte 17 frame packet counter&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example: 0x0e, 0x16, 0x1a, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xbb, 0xcc, 0xdd, 0xdd, 0x00&lt;/p&gt; &#xA;&lt;h2&gt;Using custom firmware with ESPHome&lt;/h2&gt; &#xA;&lt;p&gt;The LYWSD03MMC sensors work out of the box with ESPHome. There are three ways to use them:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;With the original firmware by using the &lt;a href=&#34;https://esphome.io/components/sensor/xiaomi_ble.html#lywsd03mmc&#34;&gt;&lt;code&gt;xiaomi_lywsd03mmc&lt;/code&gt; sensor platform&lt;/a&gt;. For this, you need to &lt;a href=&#34;https://esphome.io/components/sensor/xiaomi_ble.html#obtaining-the-bindkey&#34;&gt;obtain the bindkey&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;With the custom firmware from this project, either by &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;using &lt;a href=&#34;https://esphome.io/components/sensor/xiaomi_ble.html#lywsd03mmc&#34;&gt;&lt;code&gt;platform: atc_mithermometer&lt;/code&gt; in ESPHome&lt;/a&gt; when the firmware is configured to an advertising type of “custom” (the default) or&lt;/li&gt; &#xA;   &lt;li&gt;setting the firmware to “Mi Like” advertisement and using &lt;code&gt;platform: xiaomi_lywsd03mmc&lt;/code&gt; with 32 arbitrary hex digits as the bindkey, e.g. &lt;code&gt;eef418daf699a0c188f3bfd17e4565d9&lt;/code&gt;. (This works because the values in the broadcast are not encrypted when using this firmware, but &lt;code&gt;bindkey&lt;/code&gt; is still a required parameter.)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;platform: xiaomi_lywsd03mmc&lt;/code&gt; is available since ESPHome 1.15, &lt;code&gt;platform: atc_mithermometer&lt;/code&gt; since 1.16.&lt;/p&gt; &#xA;&lt;h2&gt;Using custom firmware with OpenMQTTGateway&lt;/h2&gt; &#xA;&lt;p&gt;The LYWSD03MMC sensors work out of the box with &lt;a href=&#34;https://docs.openmqttgateway.com/&#34;&gt;OpenMQTTGateway&lt;/a&gt;. You can directly upload OMG to the ESP32 from your web browser &lt;a href=&#34;https://docs.openmqttgateway.com/upload/web-install.html&#34;&gt;here&lt;/a&gt;, choose &lt;code&gt;esp32dev-ble&lt;/code&gt; or &lt;code&gt;esp32dev-ble-cont&lt;/code&gt; (for continuous scanning).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;With the original LYWSD03MMC firmware, OMG will connect to the sensor so as to retrieve the sensors values and publish to MQTT.&lt;/li&gt; &#xA; &lt;li&gt;With the custom LYWSD03MMC firmware from this project, OMG will detect automatically the sensor and publish to MQTT. In both cases the sensor will be auto discovered in Home Assistant per default (no configuration needed if you are already using the MQTT integration with auto discovery). You can also follow this tutorial(&lt;a href=&#34;https://1technophile.blogspot.com/2021/08/get-your-ble-sensors-data-into-home.html&#34;&gt;https://1technophile.blogspot.com/2021/08/get-your-ble-sensors-data-into-home.html&lt;/a&gt;) for the Home Assistant integration. You can also integrate to OpenHAB or other MQTT compatible controllers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Stock firmware:&lt;/h3&gt; &#xA;&lt;p&gt;This .zip file contains the stock firmware to go back: &lt;a href=&#34;https://github.com/pvvx/ATC_MiThermometer/files/7300157/LYWSD03MMC_0130_upd_miaomiaoce.sensor_ht.t2.zip&#34;&gt;https://github.com/pvvx/ATC_MiThermometer/files/7300157/LYWSD03MMC_0130_upd_miaomiaoce.sensor_ht.t2.zip&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Building manual for docker:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/AlmightyFrog/BuildEnvironmentATCMiThermometer&#34;&gt;https://github.com/AlmightyFrog/BuildEnvironmentATCMiThermometer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Many thanks to:&lt;/h4&gt; &#xA;&lt;p&gt;@danielkucera &lt;a href=&#34;https://github.com/danielkucera/mi-standardauth/raw/master/provision.py&#34;&gt;https://github.com/danielkucera/mi-standardauth/blob/master/provision.py&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;@romanhosek &lt;a href=&#34;https://twitter.com/romanhosek&#34;&gt;https://twitter.com/romanhosek&lt;/a&gt; &lt;a href=&#34;https://github.com/hosek&#34;&gt;https://github.com/hosek&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>