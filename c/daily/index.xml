<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-16T01:26:39Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>DummrenDuck/cgame</title>
    <updated>2023-12-16T01:26:39Z</updated>
    <id>tag:github.com,2023-12-16:/DummrenDuck/cgame</id>
    <link href="https://github.com/DummrenDuck/cgame" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;a very lightweight game written in c&lt;/p&gt; &#xA;&lt;p&gt;work in progress&lt;/p&gt; &#xA;&lt;p&gt;this repository contains a lot of shitcode because i almost never worked with THIS low-level and non-object oriented languages&lt;/p&gt; &#xA;&lt;h2&gt;tl;dr&lt;/h2&gt; &#xA;&lt;p&gt;go to the &lt;code&gt;releases&lt;/code&gt; section&lt;/p&gt; &#xA;&lt;h2&gt;congitiohazards&lt;/h2&gt; &#xA;&lt;p&gt;if you dont want to go insane i strongly advise you not to open &lt;code&gt;src/obj.c&lt;/code&gt; file&lt;/p&gt; &#xA;&lt;h2&gt;dependencies&lt;/h2&gt; &#xA;&lt;p&gt;*windows*&lt;/p&gt; &#xA;&lt;p&gt;all dependencies are preinstalled with your system or provided with an exe file&lt;/p&gt; &#xA;&lt;p&gt;*fedora*&lt;/p&gt; &#xA;&lt;p&gt;you need the following packages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo dnf install gcc glfw-devel glew-devel libglvnd-devel stb-devel make python3 xxd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;additional packages if you want to build cgame for windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo dnf install mingw32-gcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;build&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/DummrenDuck/cgame.git&#xA;cd cgame&#xA;make release&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>rockchip-linux/rknn-toolkit2</title>
    <updated>2023-12-16T01:26:39Z</updated>
    <id>tag:github.com,2023-12-16:/rockchip-linux/rknn-toolkit2</id>
    <link href="https://github.com/rockchip-linux/rknn-toolkit2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;RKNN software stack can help users to quickly deploy AI models to Rockchip chips. The overall framework is as follows: &lt;/p&gt;&#xA;&lt;center class=&#34;half&#34;&gt; &#xA; &lt;div style=&#34;background-color:#ffffff;&#34;&gt; &#xA;  &lt;img src=&#34;https://raw.githubusercontent.com/rockchip-linux/rknn-toolkit2/master/res/framework.png&#34; title=&#34;RKNN&#34;&gt; &#xA; &lt;/div&gt;&#xA;&lt;/center&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;In order to use RKNPU, users need to first run the RKNN-Toolkit2 tool on the computer, convert the trained model into an RKNN format model, and then inference on the development board using the RKNN C API or Python API.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;RKNN-Toolkit2 is a software development kit for users to perform model conversion, inference and performance evaluation on PC and Rockchip NPU platforms.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RKNN-Toolkit-Lite2 provides Python programming interfaces for Rockchip NPU platform to help users deploy RKNN models and accelerate the implementation of AI applications.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RKNN Runtime provides C/C++ programming interfaces for Rockchip NPU platform to help users deploy RKNN models and accelerate the implementation of AI applications.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RKNPU kernel driver is responsible for interacting with NPU hardware. It has been open source and can be found in the Rockchip kernel code.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Support Platform&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RK3566/RK3568 Series&lt;/li&gt; &#xA; &lt;li&gt;RK3588 Series&lt;/li&gt; &#xA; &lt;li&gt;RK3562 Series&lt;/li&gt; &#xA; &lt;li&gt;RV1103/RV1106&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note:&lt;/p&gt; &#xA;&lt;p&gt;​ &lt;strong&gt;For RK1808/RV1109/RV1126/RK3399Pro, please refer to :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;​ &lt;a href=&#34;https://github.com/airockchip/rknn-toolkit&#34;&gt;https://github.com/airockchip/rknn-toolkit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;​ &lt;a href=&#34;https://github.com/airockchip/rknpu&#34;&gt;https://github.com/airockchip/rknpu&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;​ &lt;a href=&#34;https://github.com/airockchip/RK3399Pro_npu&#34;&gt;https://github.com/airockchip/RK3399Pro_npu&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Download&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can also download all packages, docker image, examples, docs and platform-tools from &lt;a href=&#34;https://console.zbox.filez.com/l/I00fc3&#34;&gt;RKNPU2_SDK&lt;/a&gt;, fetch code: rknn&lt;/li&gt; &#xA; &lt;li&gt;You can get more examples from &lt;a href=&#34;https://github.com/airockchip/rknn_model_zoo&#34;&gt;rknn mode zoo&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Notes&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RKNN-Toolkit2 is not compatible with &lt;a href=&#34;https://github.com/airockchip/rknn-toolkit&#34;&gt;RKNN-Toolkit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Currently only support on: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ubuntu 18.04 python 3.6/3.7&lt;/li&gt; &#xA;   &lt;li&gt;Ubuntu 20.04 python 3.8/3.9&lt;/li&gt; &#xA;   &lt;li&gt;Ubuntu 22.04 python 3.10/3.11&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Latest version:1.6.0(Release version)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;CHANGELOG&lt;/h1&gt; &#xA;&lt;h2&gt;1.6.0&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support ONNX model of OPSET 12~19&lt;/li&gt; &#xA; &lt;li&gt;Support custom operators (including CPU and GPU)&lt;/li&gt; &#xA; &lt;li&gt;Optimization operators support such as dynamic weighted convolution, Layernorm, RoiAlign, Softmax, ReduceL2, Gelu, GLU, etc.&lt;/li&gt; &#xA; &lt;li&gt;Added support for python3.7/3.9/3.11&lt;/li&gt; &#xA; &lt;li&gt;Add rknn_convert function&lt;/li&gt; &#xA; &lt;li&gt;Optimize transformer support&lt;/li&gt; &#xA; &lt;li&gt;Optimize the MatMul API, such as increasing the K limit length, RK3588 adding int4 * int4 -&amp;gt; int16 support, etc.&lt;/li&gt; &#xA; &lt;li&gt;Optimize RV1106 rknn_init initialization time, memory consumption, etc.&lt;/li&gt; &#xA; &lt;li&gt;RV1106 adds int16 support for some operators&lt;/li&gt; &#xA; &lt;li&gt;Fixed the problem that the convolution operator of RV1106 platform may make random errors in some cases.&lt;/li&gt; &#xA; &lt;li&gt;Optimize user manual&lt;/li&gt; &#xA; &lt;li&gt;Reconstruct the rknn model zoo and add support for multiple models such as detection, segmentation, OCR, and license plate recognition.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;for older version, please refer &lt;a href=&#34;https://raw.githubusercontent.com/rockchip-linux/rknn-toolkit2/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Feedback and Community Support&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://redmine.rock-chips.com&#34;&gt;Redmine&lt;/a&gt; (&lt;strong&gt;Feedback recommended, Please consult our sales or FAE for the redmine account&lt;/strong&gt;)&lt;/li&gt; &#xA; &lt;li&gt;QQ Group Chat: 1025468710 (full, please join group 3)&lt;/li&gt; &#xA; &lt;li&gt;QQ Group Chat2: 547021958 (full, please join group 3)&lt;/li&gt; &#xA; &lt;li&gt;QQ Group Chat3: 469385426&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;center class=&#34;half&#34;&gt; &#xA; &lt;img width=&#34;200&#34; height=&#34;200&#34; src=&#34;https://raw.githubusercontent.com/rockchip-linux/rknn-toolkit2/master/res/QQGroupQRCode.png&#34; title=&#34;QQ Group Chat&#34;&gt; &#xA; &lt;img width=&#34;200&#34; height=&#34;200&#34; src=&#34;https://raw.githubusercontent.com/rockchip-linux/rknn-toolkit2/master/res/QQGroup2QRCode.png&#34; title=&#34;QQ Group Chat2&#34;&gt; &#xA; &lt;img width=&#34;200&#34; height=&#34;200&#34; src=&#34;https://raw.githubusercontent.com/rockchip-linux/rknn-toolkit2/master/res/QQGroup3QRCode.png&#34; title=&#34;QQ Group Chat3&#34;&gt; &#xA;&lt;/center&gt;</summary>
  </entry>
  <entry>
    <title>rochus-keller/CspChan</title>
    <updated>2023-12-16T01:26:39Z</updated>
    <id>tag:github.com,2023-12-16:/rochus-keller/CspChan</id>
    <link href="https://github.com/rochus-keller/CspChan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A pure C (-std=c89) implementation of Go channels, including blocking and non-blocking selects.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This C library implements channels, as introduced by Hoare (Communicating Sequential Processes, 1985) and popularized by the Go programming language.&lt;/p&gt; &#xA;&lt;p&gt;Buffered and unbuffered channels are supported, and also the select statement in its blocking and non-blocking variants, as in the Go programming language.&lt;/p&gt; &#xA;&lt;p&gt;The library currently works with Pthreads; support for Win32 threads is work in progress.&lt;/p&gt; &#xA;&lt;h3&gt;How to use&lt;/h3&gt; &#xA;&lt;p&gt;Just include the CspChan.h and CspChan.c files in your project, or build a shared library with the CspChan.c file.&lt;/p&gt; &#xA;&lt;p&gt;More information can be found in the source code.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &#34;CspChan.h&#34;&#xA;&#xA;static void* senderA(void* arg) {&#xA;    CspChan_t* out = (CspChan_t*)arg;&#xA;    int i = 0;&#xA;    while(!CspChan_closed(out)) {&#xA;        CspChan_send(out,&amp;amp;i);&#xA;        i++;&#xA;        CspChan_sleep(1000);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;static void* senderB(void* arg) {&#xA;    CspChan_t* out = (CspChan_t*)arg;&#xA;    int i = -1;&#xA;    while(!CspChan_closed(out)) {&#xA;        CspChan_sleep(1000);&#xA;        CspChan_send(out,&amp;amp;i);&#xA;        i--;&#xA;        CspChan_sleep(1000);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;typedef struct receiverAB_arg {&#xA;    CspChan_t* a;&#xA;    CspChan_t* b;&#xA;} receiverAB_arg;&#xA;&#xA;static void* receiverAB(void* arg) {&#xA;    receiverAB_arg* ra = (receiverAB_arg*)arg;&#xA;    while( !CspChan_closed(ra-&amp;gt;a) &amp;amp;&amp;amp; !CspChan_closed(ra-&amp;gt;b) ) {&#xA;        int a,b;&#xA;        CspChan_t* receivers[2] = { ra-&amp;gt;a, ra-&amp;gt;b };&#xA;        void* rData[2] = { &amp;amp;a, &amp;amp;b };&#xA;        switch( CspChan_select(receivers,rData,2, 0, 0, 0) ) {&#xA;        case 0:&#xA;            printf(&#34;a: %d\n&#34;,a);&#xA;            fflush(stdout);&#xA;            break;&#xA;        case 1:&#xA;            printf(&#34;b: %d\n&#34;,b);&#xA;            fflush(stdout);&#xA;            break;&#xA;        }&#xA;    }&#xA;    free(arg);&#xA;    return 0;&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    CspChan_t* a = CspChan_create(0,4); /* unbuffered channel */&#xA;    CspChan_t* b = CspChan_create(1,4); /* buffered channel */&#xA;    CspChan_fork(senderA,a);&#xA;    CspChan_fork(senderB,b);&#xA;    receiverAB_arg* arg = (receiverAB_arg*)malloc(sizeof(receiverAB_arg));&#xA;    arg-&amp;gt;a = a;&#xA;    arg-&amp;gt;b = b;&#xA;    CspChan_fork(receiverAB,arg);&#xA;&#xA;    CspChan_sleep(9000);&#xA;    CspChan_close(a);&#xA;    CspChan_close(b);&#xA;&#xA;    CspChan_dispose(a);&#xA;    CspChan_dispose(b);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, test.c includes some of the examples from Birch Hansen, Per (1987): Joyce - A Programming Language for Distributed Systems.&lt;/p&gt; &#xA;&lt;h3&gt;Planned or work-in-progress features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Unix version with buffered channels and blocking and non-blocking select&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Unix version with unbuffered channels&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Windows version&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Implement a thread-pool to re-use threads instead of starting a new one with each call to CspChan_fork to improve performance&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Related work&lt;/h3&gt; &#xA;&lt;p&gt;There are a couple of C++ implementations of CSP channels, e.g. &lt;a href=&#34;https://www.cs.kent.ac.uk/projects/ofa/c++csp/&#34;&gt;https://www.cs.kent.ac.uk/projects/ofa/c++csp/&lt;/a&gt; or &lt;a href=&#34;https://github.com/atollk/copper&#34;&gt;https://github.com/atollk/copper&lt;/a&gt;, but the intention of the present library is a C89 implementation of Go channels.&lt;/p&gt; &#xA;&lt;p&gt;For C there are also some libraries, partially with similar goals as the present one.&lt;/p&gt; &#xA;&lt;p&gt;Pipe (&lt;a href=&#34;https://github.com/cgaebel/pipe&#34;&gt;https://github.com/cgaebel/pipe&lt;/a&gt;) is a C99 implementation of a thread-safe FIFO. The library is very well documented, but also more complex than the present one, and with more dynamic allocations (CspChan uses a simple fixed size ring buffer instead, like Go). The Pipe library has no select implementation, and adding one seems pretty complicated and requires changes to the library.&lt;/p&gt; &#xA;&lt;p&gt;The Chan library (&lt;a href=&#34;https://github.com/tylertreat/chan&#34;&gt;https://github.com/tylertreat/chan&lt;/a&gt;) is a C implementation of Go channels and shares the same goals as the present library. There is even an implementation of Go select. The implementation is rather complex (with separate implementations for buffered and unbuffered channels) and also with more dynamic allocations than I would hope for; apparently only non-blocking selects are supported (i.e. only Go selects with default); adding blocking selects would require significant changes to the library.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;If you need support or would like to post issues or feature requests please use the Github issue list at &lt;a href=&#34;https://github.com/rochus-keller/CspChan/issues&#34;&gt;https://github.com/rochus-keller/CspChan/issues&lt;/a&gt; or send an email to the author.&lt;/p&gt;</summary>
  </entry>
</feed>