<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-15T02:47:11Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>antirez/linenoise</title>
    <updated>2024-04-15T02:47:11Z</updated>
    <id>tag:github.com,2024-04-15:/antirez/linenoise</id>
    <link href="https://github.com/antirez/linenoise" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small self-contained alternative to readline and libedit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Linenoise&lt;/h1&gt; &#xA;&lt;p&gt;A minimal, zero-config, BSD licensed, readline replacement used in Redis, MongoDB, Android and many other projects.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Single and multi line editing mode with the usual key bindings implemented.&lt;/li&gt; &#xA; &lt;li&gt;History handling.&lt;/li&gt; &#xA; &lt;li&gt;Completion.&lt;/li&gt; &#xA; &lt;li&gt;Hints (suggestions at the right of the prompt as you type).&lt;/li&gt; &#xA; &lt;li&gt;Multiplexing mode, with prompt hiding/restoring for asynchronous output.&lt;/li&gt; &#xA; &lt;li&gt;About ~850 lines (comments and spaces excluded) of BSD license source code.&lt;/li&gt; &#xA; &lt;li&gt;Only uses a subset of VT100 escapes (ANSI.SYS compatible).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Can a line editing library be 20k lines of code?&lt;/h2&gt; &#xA;&lt;p&gt;Line editing with some support for history is a really important feature for command line utilities. Instead of retyping almost the same stuff again and again it&#39;s just much better to hit the up arrow and edit on syntax errors, or in order to try a slightly different command. But apparently code dealing with terminals is some sort of Black Magic: readline is 30k lines of code, libedit 20k. Is it reasonable to link small utilities to huge libraries just to get a minimal support for line editing?&lt;/p&gt; &#xA;&lt;p&gt;So what usually happens is either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Large programs with configure scripts disabling line editing if readline is not present in the system, or not supporting it at all since readline is GPL licensed and libedit (the BSD clone) is not as known and available as readline is (real world example of this problem: Tclsh).&lt;/li&gt; &#xA; &lt;li&gt;Smaller programs not using a configure script not supporting line editing at all (A problem we had with &lt;code&gt;redis-cli&lt;/code&gt;, for instance).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The result is a pollution of binaries without line editing support.&lt;/p&gt; &#xA;&lt;p&gt;So I spent more or less two hours doing a reality check resulting in this little library: is it &lt;em&gt;really&lt;/em&gt; needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporting line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to Linenoise if not.&lt;/p&gt; &#xA;&lt;h2&gt;Terminals, in 2010.&lt;/h2&gt; &#xA;&lt;p&gt;Apparently almost every terminal you can happen to use today has some kind of support for basic VT100 escape sequences. So I tried to write a lib using just very basic VT100 features. The resulting library appears to work everywhere I tried to use it, and now can work even on ANSI.SYS compatible terminals, since no VT220 specific sequences are used anymore.&lt;/p&gt; &#xA;&lt;p&gt;The library is currently about 850 lines of code. In order to use it in your project just look at the &lt;em&gt;example.c&lt;/em&gt; file in the source distribution, it is pretty straightforward. The library supports both a blocking mode and a multiplexing mode, see the API documentation later in this file for more information.&lt;/p&gt; &#xA;&lt;p&gt;Linenoise is BSD-licensed code, so you can use both in free software and commercial software.&lt;/p&gt; &#xA;&lt;h2&gt;Tested with...&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux text only console ($TERM = linux)&lt;/li&gt; &#xA; &lt;li&gt;Linux KDE terminal application ($TERM = xterm)&lt;/li&gt; &#xA; &lt;li&gt;Linux xterm ($TERM = xterm)&lt;/li&gt; &#xA; &lt;li&gt;Linux Buildroot ($TERM = vt100)&lt;/li&gt; &#xA; &lt;li&gt;Mac OS X iTerm ($TERM = xterm)&lt;/li&gt; &#xA; &lt;li&gt;Mac OS X default Terminal.app ($TERM = xterm)&lt;/li&gt; &#xA; &lt;li&gt;OpenBSD 4.5 through an OSX Terminal.app ($TERM = screen)&lt;/li&gt; &#xA; &lt;li&gt;IBM AIX 6.1&lt;/li&gt; &#xA; &lt;li&gt;FreeBSD xterm ($TERM = xterm)&lt;/li&gt; &#xA; &lt;li&gt;ANSI.SYS&lt;/li&gt; &#xA; &lt;li&gt;Emacs comint mode ($TERM = dumb)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please test it everywhere you can and report back!&lt;/p&gt; &#xA;&lt;h2&gt;Let&#39;s push this forward!&lt;/h2&gt; &#xA;&lt;p&gt;Patches should be provided in the respect of Linenoise sensibility for small easy to understand code.&lt;/p&gt; &#xA;&lt;p&gt;Send feedbacks to antirez at gmail&lt;/p&gt; &#xA;&lt;h1&gt;The API&lt;/h1&gt; &#xA;&lt;p&gt;Linenoise is very easy to use, and reading the example shipped with the library should get you up to speed ASAP. Here is a list of API calls and how to use them. Let&#39;s start with the simple blocking mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;char *linenoise(const char *prompt);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the main Linenoise call: it shows the user a prompt with line editing and history capabilities. The prompt you specify is used as a prompt, that is, it will be printed to the left of the cursor. The library returns a buffer with the line composed by the user, or NULL on end of file or when there is an out of memory condition.&lt;/p&gt; &#xA;&lt;p&gt;When a tty is detected (the user is actually typing into a terminal session) the maximum editable line length is &lt;code&gt;LINENOISE_MAX_LINE&lt;/code&gt;. When instead the standard input is not a tty, which happens every time you redirect a file to a program, or use it in an Unix pipeline, there are no limits to the length of the line that can be returned.&lt;/p&gt; &#xA;&lt;p&gt;The returned line should be freed with the &lt;code&gt;free()&lt;/code&gt; standard system call. However sometimes it could happen that your program uses a different dynamic allocation library, so you may also used &lt;code&gt;linenoiseFree&lt;/code&gt; to make sure the line is freed with the same allocator it was created.&lt;/p&gt; &#xA;&lt;p&gt;The canonical loop used by a program using Linenoise will be something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;while((line = linenoise(&#34;hello&amp;gt; &#34;)) != NULL) {&#xA;    printf(&#34;You wrote: %s\n&#34;, line);&#xA;    linenoiseFree(line); /* Or just free(line) if you use libc malloc. */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Single line VS multi line editing&lt;/h2&gt; &#xA;&lt;p&gt;By default, Linenoise uses single line editing, that is, a single row on the screen will be used, and as the user types more, the text will scroll towards left to make room. This works if your program is one where the user is unlikely to write a lot of text, otherwise multi line editing, where multiple screens rows are used, can be a lot more comfortable.&lt;/p&gt; &#xA;&lt;p&gt;In order to enable multi line editing use the following API call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;linenoiseSetMultiLine(1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can disable it using &lt;code&gt;0&lt;/code&gt; as argument.&lt;/p&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;Linenoise supporst history, so that the user does not have to retype again and again the same things, but can use the down and up arrows in order to search and re-edit already inserted lines of text.&lt;/p&gt; &#xA;&lt;p&gt;The followings are the history API calls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;int linenoiseHistoryAdd(const char *line);&#xA;int linenoiseHistorySetMaxLen(int len);&#xA;int linenoiseHistorySave(const char *filename);&#xA;int linenoiseHistoryLoad(const char *filename);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;linenoiseHistoryAdd&lt;/code&gt; every time you want to add a new element to the top of the history (it will be the first the user will see when using the up arrow).&lt;/p&gt; &#xA;&lt;p&gt;Note that for history to work, you have to set a length for the history (which is zero by default, so history will be disabled if you don&#39;t set a proper one). This is accomplished using the &lt;code&gt;linenoiseHistorySetMaxLen&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Linenoise has direct support for persisting the history into an history file. The functions &lt;code&gt;linenoiseHistorySave&lt;/code&gt; and &lt;code&gt;linenoiseHistoryLoad&lt;/code&gt; do just that. Both functions return -1 on error and 0 on success.&lt;/p&gt; &#xA;&lt;h2&gt;Mask mode&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes it is useful to allow the user to type passwords or other secrets that should not be displayed. For such situations linenoise supports a &#34;mask mode&#34; that will just replace the characters the user is typing with &lt;code&gt;*&lt;/code&gt; characters, like in the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./linenoise_example&#xA;hello&amp;gt; get mykey&#xA;echo: &#39;get mykey&#39;&#xA;hello&amp;gt; /mask&#xA;hello&amp;gt; *********&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can enable and disable mask mode using the following two functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void linenoiseMaskModeEnable(void);&#xA;void linenoiseMaskModeDisable(void);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Completion&lt;/h2&gt; &#xA;&lt;p&gt;Linenoise supports completion, which is the ability to complete the user input when she or he presses the &lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt; key.&lt;/p&gt; &#xA;&lt;p&gt;In order to use completion, you need to register a completion callback, which is called every time the user presses &lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;. Your callback will return a list of items that are completions for the current string.&lt;/p&gt; &#xA;&lt;p&gt;The following is an example of registering a completion callback:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;linenoiseSetCompletionCallback(completion);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The completion must be a function returning &lt;code&gt;void&lt;/code&gt; and getting as input a &lt;code&gt;const char&lt;/code&gt; pointer, which is the line the user has typed so far, and a &lt;code&gt;linenoiseCompletions&lt;/code&gt; object pointer, which is used as argument of &lt;code&gt;linenoiseAddCompletion&lt;/code&gt; in order to add completions inside the callback. An example will make it more clear:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void completion(const char *buf, linenoiseCompletions *lc) {&#xA;    if (buf[0] == &#39;h&#39;) {&#xA;        linenoiseAddCompletion(lc,&#34;hello&#34;);&#xA;        linenoiseAddCompletion(lc,&#34;hello there&#34;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Basically in your completion callback, you inspect the input, and return a list of items that are good completions by using &lt;code&gt;linenoiseAddCompletion&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to test the completion feature, compile the example program with &lt;code&gt;make&lt;/code&gt;, run it, type &lt;code&gt;h&lt;/code&gt; and press &lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Hints&lt;/h2&gt; &#xA;&lt;p&gt;Linenoise has a feature called &lt;em&gt;hints&lt;/em&gt; which is very useful when you use Linenoise in order to implement a REPL (Read Eval Print Loop) for a program that accepts commands and arguments, but may also be useful in other conditions.&lt;/p&gt; &#xA;&lt;p&gt;The feature shows, on the right of the cursor, as the user types, hints that may be useful. The hints can be displayed using a different color compared to the color the user is typing, and can also be bold.&lt;/p&gt; &#xA;&lt;p&gt;For example as the user starts to type &lt;code&gt;&#34;git remote add&#34;&lt;/code&gt;, with hints it&#39;s possible to show on the right of the prompt a string &lt;code&gt;&amp;lt;name&amp;gt; &amp;lt;url&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The feature works similarly to the history feature, using a callback. To register the callback we use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;linenoiseSetHintsCallback(hints);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The callback itself is implemented like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;char *hints(const char *buf, int *color, int *bold) {&#xA;    if (!strcasecmp(buf,&#34;git remote add&#34;)) {&#xA;        *color = 35;&#xA;        *bold = 0;&#xA;        return &#34; &amp;lt;name&amp;gt; &amp;lt;url&amp;gt;&#34;;&#xA;    }&#xA;    return NULL;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The callback function returns the string that should be displayed or NULL if no hint is available for the text the user currently typed. The returned string will be trimmed as needed depending on the number of columns available on the screen.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to return a string allocated in dynamic way, by also registering a function to deallocate the hint string once used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The free hint callback will just receive the pointer and free the string as needed (depending on how the hits callback allocated it).&lt;/p&gt; &#xA;&lt;p&gt;As you can see in the example above, a &lt;code&gt;color&lt;/code&gt; (in xterm color terminal codes) can be provided together with a &lt;code&gt;bold&lt;/code&gt; attribute. If no color is set, the current terminal foreground color is used. If no bold attribute is set, non-bold text is printed.&lt;/p&gt; &#xA;&lt;p&gt;Color codes are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;red = 31&#xA;green = 32&#xA;yellow = 33&#xA;blue = 34&#xA;magenta = 35&#xA;cyan = 36&#xA;white = 37;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Screen handling&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you may want to clear the screen as a result of something the user typed. You can do this by calling the following function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void linenoiseClearScreen(void);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Asyncrhronous API&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you want to read from the keyboard but also from sockets or other external events, and at the same time there could be input to display to the user &lt;em&gt;while&lt;/em&gt; the user is typing something. Let&#39;s call this the &#34;IRC problem&#34;, since if you want to write an IRC client with linenoise, without using some fully featured libcurses approach, you will surely end having such an issue.&lt;/p&gt; &#xA;&lt;p&gt;Fortunately now a multiplexing friendly API exists, and it is just what the blocking calls internally use. To start, we need to initialize a linenoise context like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct linenoiseState ls;&#xA;char buf[1024];&#xA;linenoiseEditStart(&amp;amp;ls,-1,-1,buf,sizeof(buf),&#34;some prompt&amp;gt; &#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The two -1 and -1 arguments are the stdin/out descriptors. If they are set to -1, linenoise will just use the default stdin/out file descriptors. Now as soon as we have data from stdin (and we know it via select(2) or some other way), we can ask linenoise to read the next character with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;linenoiseEditFeed(&amp;amp;ls);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function returns a &lt;code&gt;char&lt;/code&gt; pointer: if the user didn&#39;t yet press enter to provide a line to the program, it will return &lt;code&gt;linenoiseEditMore&lt;/code&gt;, that means we need to call &lt;code&gt;linenoiseEditFeed()&lt;/code&gt; again when more data is available. If the function returns non NULL, then this is a heap allocated data (to be freed with &lt;code&gt;linenoiseFree()&lt;/code&gt;) representing the user input. When the function returns NULL, than the user pressed CTRL-C or CTRL-D with an empty line, to quit the program, or there was some I/O error.&lt;/p&gt; &#xA;&lt;p&gt;After each line is received (or if you want to quit the program, and exit raw mode), the following function needs to be called:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;linenoiseEditStop(&amp;amp;ls);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To start reading the next line, a new linenoiseEditStart() must be called, in order to reset the state, and so forth, so a typical event handler called when the standard input is readable, will work similarly to the example below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void stdinHasSomeData(void) {&#xA;    char *line = linenoiseEditFeed(&amp;amp;LineNoiseState);&#xA;    if (line == linenoiseEditMore) return;&#xA;    linenoiseEditStop(&amp;amp;LineNoiseState);&#xA;    if (line == NULL) exit(0);&#xA;&#xA;    printf(&#34;line: %s\n&#34;, line);&#xA;    linenoiseFree(line);&#xA;    linenoiseEditStart(&amp;amp;LineNoiseState,-1,-1,LineNoiseBuffer,sizeof(LineNoiseBuffer),&#34;serial&amp;gt; &#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we have a way to avoid blocking in the user input, we can use two calls to hide/show the edited line, so that it is possible to also show some input that we received (from socekts, bluetooth, whatever) on screen:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;linenoiseHide(&amp;amp;ls);&#xA;printf(&#34;some data...\n&#34;);&#xA;linenoiseShow(&amp;amp;ls);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To the API calls, the linenoise example C file implements a multiplexing example using select(2) and the asynchronous API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    struct linenoiseState ls;&#xA;    char buf[1024];&#xA;    linenoiseEditStart(&amp;amp;ls,-1,-1,buf,sizeof(buf),&#34;hello&amp;gt; &#34;);&#xA;&#xA;    while(1) {&#xA;        // Select(2) setup code removed...&#xA;        retval = select(ls.ifd+1, &amp;amp;readfds, NULL, NULL, &amp;amp;tv);&#xA;        if (retval == -1) {&#xA;            perror(&#34;select()&#34;);&#xA;            exit(1);&#xA;        } else if (retval) {&#xA;            line = linenoiseEditFeed(&amp;amp;ls);&#xA;            /* A NULL return means: line editing is continuing.&#xA;             * Otherwise the user hit enter or stopped editing&#xA;             * (CTRL+C/D). */&#xA;            if (line != linenoiseEditMore) break;&#xA;        } else {&#xA;            // Timeout occurred&#xA;            static int counter = 0;&#xA;            linenoiseHide(&amp;amp;ls);&#xA;            printf(&#34;Async output %d.\n&#34;, counter++);&#xA;            linenoiseShow(&amp;amp;ls);&#xA;        }&#xA;    }&#xA;    linenoiseEditStop(&amp;amp;ls);&#xA;    if (line == NULL) exit(0); /* Ctrl+D/C. */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can test the example by running the example program with the &lt;code&gt;--async&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/arangodb/linenoise-ng&#34;&gt;Linenoise NG&lt;/a&gt; is a fork of Linenoise that aims to add more advanced features like UTF-8 support, Windows support and other features. Uses C++ instead of C as development language.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/andybest/linenoise-swift&#34;&gt;Linenoise-swift&lt;/a&gt; is a reimplementation of Linenoise written in Swift.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>