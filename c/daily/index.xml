<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-04T01:31:06Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OISF/suricata</title>
    <updated>2022-12-04T01:31:06Z</updated>
    <id>tag:github.com,2022-12-04:/OISF/suricata</id>
    <link href="https://github.com/OISF/suricata" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Suricata git repository maintained by the OISF&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Suricata&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&amp;amp;can=1&amp;amp;q=proj:suricata&#34;&gt;&lt;img src=&#34;https://oss-fuzz-build-logs.storage.googleapis.com/badges/suricata.svg?sanitize=true&#34; alt=&#34;Fuzzing Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/OISF/suricata&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/OISF/suricata/branch/master/graph/badge.svg?token=QRyyn2BSo1&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://suricata.io&#34;&gt;Suricata&lt;/a&gt; is a network IDS, IPS and NSM engine developed by the &lt;a href=&#34;https://oisf.net&#34;&gt;OISF&lt;/a&gt; and the Suricata community.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://suricata.readthedocs.io/en/latest/install.html&#34;&gt;https://suricata.readthedocs.io/en/latest/install.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;User Guide&lt;/h2&gt; &#xA;&lt;p&gt;You can follow the &lt;a href=&#34;https://suricata.readthedocs.io/en/latest/&#34;&gt;Suricata user guide&lt;/a&gt; to get started.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re happily taking patches and other contributions. Please see &lt;a href=&#34;https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Contributing&#34;&gt;https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Contributing&lt;/a&gt; for how to get started.&lt;/p&gt; &#xA;&lt;p&gt;Suricata is a complex piece of software dealing with mostly untrusted input. Mishandling this input will have serious consequences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;in IPS mode a crash may knock a network offline;&lt;/li&gt; &#xA; &lt;li&gt;in passive mode a compromise of the IDS may lead to loss of critical and confidential data;&lt;/li&gt; &#xA; &lt;li&gt;missed detection may lead to undetected compromise of the network.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In other words, we think the stakes are pretty high, especially since in many common cases the IDS/IPS will be directly reachable by an attacker.&lt;/p&gt; &#xA;&lt;p&gt;For this reason, we have developed a QA process that is quite extensive. A consequence is that contributing to Suricata can be a somewhat lengthy process.&lt;/p&gt; &#xA;&lt;p&gt;On a high level, the steps are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Github-CI based checks. This runs automatically when a pull request is made.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Review by devs from the team and community&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;QA runs from private QA setups. These are private due to the nature of the test traffic.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Overview of Suricata&#39;s QA steps&lt;/h3&gt; &#xA;&lt;p&gt;OISF team members are able to submit builds to our private QA setup. It will run a series of build tests and a regression suite to confirm no existing features break.&lt;/p&gt; &#xA;&lt;p&gt;The final QA runs takes a few hours minimally, and generally runs overnight. It currently runs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;extensive build tests on different OS&#39;, compilers, optimization levels, configure features&lt;/li&gt; &#xA; &lt;li&gt;static code analysis using cppcheck, scan-build&lt;/li&gt; &#xA; &lt;li&gt;runtime code analysis using valgrind, AddressSanitizer, LeakSanitizer&lt;/li&gt; &#xA; &lt;li&gt;regression tests for past bugs&lt;/li&gt; &#xA; &lt;li&gt;output validation of logging&lt;/li&gt; &#xA; &lt;li&gt;unix socket testing&lt;/li&gt; &#xA; &lt;li&gt;pcap based fuzz testing using ASAN and LSAN&lt;/li&gt; &#xA; &lt;li&gt;traffic replay based IDS and IPS tests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Next to these tests, based on the type of code change further tests can be run manually:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;traffic replay testing (multi-gigabit)&lt;/li&gt; &#xA; &lt;li&gt;large pcap collection processing (multi-terabytes)&lt;/li&gt; &#xA; &lt;li&gt;fuzz testing (might take multiple days or even weeks)&lt;/li&gt; &#xA; &lt;li&gt;pcap based performance testing&lt;/li&gt; &#xA; &lt;li&gt;live performance testing&lt;/li&gt; &#xA; &lt;li&gt;various other manual tests based on evaluation of the proposed changes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It&#39;s important to realize that almost all of the tests above are used as acceptance tests. If something fails, it&#39;s up to you to address this in your code.&lt;/p&gt; &#xA;&lt;p&gt;One step of the QA is currently run post-merge. We submit builds to the Coverity Scan program. Due to limitations of this (free) service, we can submit once a day max. Of course it can happen that after the merge the community will find issues. For both cases we request you to help address the issues as they may come up.&lt;/p&gt; &#xA;&lt;h3&gt;FAQ&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Will you accept my PR?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: That depends on a number of things, including the code quality. With new features it also depends on whether the team and/or the community think the feature is useful, how much it affects other code and features, the risk of performance regressions, etc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: When will my PR be merged?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: It depends, if it&#39;s a major feature or considered a high risk change, it will probably go into the next major version.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Why was my PR closed?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: As documented in the Suricata Github workflow here &lt;a href=&#34;https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Github_work_flow&#34;&gt;https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Github_work_flow&lt;/a&gt;, we expect a new pull request for every change.&lt;/p&gt; &#xA;&lt;p&gt;Normally, the team (or community) will give feedback on a pull request after which it is expected to be replaced by an improved PR. So look at the comments. If you disagree with the comments we can still discuss them in the closed PR.&lt;/p&gt; &#xA;&lt;p&gt;If the PR was closed without comments it&#39;s likely due to QA failure. If the Github-CI checks failed, the PR should be fixed right away. No need for a discussion about it, unless you believe the QA failure is incorrect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: the compiler/code analyser/tool is wrong, what now?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: To assist in the automation of the QA, we&#39;re not accepting warnings or errors to stay. In some cases this could mean that we add a suppression if the tool supports that (e.g. valgrind, DrMemory). Some warnings can be disabled. In some exceptional cases the only &#39;solution&#39; is to refactor the code to work around a static code checker limitation false positive. While frustrating, we prefer this over leaving warnings in the output. Warnings tend to get ignored and then increase risk of hiding other warnings.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: I think your QA test is wrong&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: If you really think it is, we can discuss how to improve it. But don&#39;t come to this conclusion too quickly, more often it&#39;s the code that turns out to be wrong.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: do you require signing of a contributor license agreement?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Yes, we do this to keep the ownership of Suricata in one hand: the Open Information Security Foundation. See &lt;a href=&#34;http://suricata.io/about/open-source/&#34;&gt;http://suricata.io/about/open-source/&lt;/a&gt; and &lt;a href=&#34;http://suricata.io/about/contribution-agreement/&#34;&gt;http://suricata.io/about/contribution-agreement/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>CodeXTF2/WindowSpy</title>
    <updated>2022-12-04T01:31:06Z</updated>
    <id>tag:github.com,2022-12-04:/CodeXTF2/WindowSpy</id>
    <link href="https://github.com/CodeXTF2/WindowSpy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WindowSpy 👀&lt;/h1&gt; &#xA;&lt;p&gt;WindowSpy is a Cobalt Strike Beacon Object File meant for targetted user surveillance. The goal of this project was to trigger surveillance capabilities only on certain targets, e.g. browser login pages, confidential documents, vpn logins etc. The purpose was to increase stealth during user surveillance by preventing detection of repeated use of surveillance capabilities e.g. screenshots. It also saves the red team time in sifting through many pages of user surveillance data, which would be produced if keylogging/screenwatch was running at all times.&lt;/p&gt; &#xA;&lt;h1&gt;How it works&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/29991665/205124642-c9d3441e-a8da-4bf2-8430-a2267e476b6c.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Each time a beacon checks in, the BOF runs on the target. The BOF comes with a hardcoded list of strings that are common in useful window titles e.g. login, administrator, control panel, vpn etc. You can customize this list and recompile yourself. It enumerates the visible windows and compares the titles to the list of strings, and if any of these are detected, it triggers a local aggressorscript function defined in WindowSpy.cna named spy(). By default, it takes a screenshot. You may customize this function however you want, e.g. keylogging, WireTap, webcam, etc.&lt;/p&gt; &#xA;&lt;p&gt;The spy() function has 1 argument, $1 being the beacon id of the beacon that triggered it.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;load the WindowSpy.cna script into Cobalt Strike&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Building from source&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;open the WindowSpy.sln solution file in Visual Studio&lt;/li&gt; &#xA; &lt;li&gt;Build for target BOF (x64/x86)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Leave it to run. It should automatically run on each beacon checkin and trigger accordingly.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;I built this because I was bored, and was messing with user surveillance. If there are bugs, open an issue. If there are any issues with the design, feel free to open an issue too.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SPuerBRead/shovel</title>
    <updated>2022-12-04T01:31:06Z</updated>
    <id>tag:github.com,2022-12-04:/SPuerBRead/shovel</id>
    <link href="https://github.com/SPuerBRead/shovel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Docker容器逃逸工具（Docker Escape Tools）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Shovel&lt;/h2&gt; &#xA;&lt;p&gt;Docker容器逃逸工具&lt;/p&gt; &#xA;&lt;p&gt;1、通过mount命令逃逸触发告警？&lt;/p&gt; &#xA;&lt;p&gt;2、unshare命令发现没有-C参数？&lt;/p&gt; &#xA;&lt;p&gt;3、机器上没有各种语言的执行环境？&lt;/p&gt; &#xA;&lt;p&gt;4、逃逸程序太大不好下载？&lt;/p&gt; &#xA;&lt;p&gt;遇到以上问题那就用下这个程序吧，原理上就是逃逸的那一堆shell脚本，换成系统调用，绕过bash的监控&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SPuerBRead/shovel/master/img/shovel.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;功能&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;支持的逃逸方式&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;release_agent&lt;/li&gt; &#xA;   &lt;li&gt;device_allow&lt;/li&gt; &#xA;   &lt;li&gt;cve-2022-0492&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;支持的存储驱动&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;device_mapper&lt;/li&gt; &#xA;   &lt;li&gt;aufs&lt;/li&gt; &#xA;   &lt;li&gt;btrfs&lt;/li&gt; &#xA;   &lt;li&gt;vfs&lt;/li&gt; &#xA;   &lt;li&gt;zfs&lt;/li&gt; &#xA;   &lt;li&gt;overlayfs&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;支持的利用类型&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;exec: 在宿主机执行命令&lt;/li&gt; &#xA;   &lt;li&gt;shell: 获取宿主机shell&lt;/li&gt; &#xA;   &lt;li&gt;reverse: 反弹shell&lt;/li&gt; &#xA;   &lt;li&gt;backdoor: 向宿主机植入后门并运行&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;自动清理攻击痕迹&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;使用方式&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;usage: shovel [options ...]&#xA;&#xA;Options:&#xA;Options of program&#xA;    -h, --help                           show help message&#xA;    -v, --version                        show program version&#xA;Options of escape&#xA;    -r, --release-agent                  escape by release-agent&#xA;    -d, --devices-allow                  escape by devices-allow&#xA;    -u, --cve-2022-0492                  get cap_sys_admin by cve-2022-0492 and return new namespace bash&#xA;Options of other&#xA;    -p, --container_path=xxx             manually specify path of container in host,use this parameter if program can&#39;t get it automatically&#xA;    -m, --mode=xxx                       the mode that needs to be returned after a successful escape { exec | shell | reverse | backdoor }&#xA;    -c, --command=xxx                    set command in exec mode&#xA;    -I, --ip                             set ip address in reverse mode&#xA;    -P, --port                           set port in reverse mode&#xA;    -B, --backdoor_path                  set backdoor file path&#xA;    -y, --assumeyes                      automatically answer yes for all questions&#xA;Mode (-m) type guide&#xA;    exec:     run a single command and return the result&#xA;    shell:    get host shell in current console&#xA;    reverse:  reverse shell to remote listening address&#xA;    backdoor: put a backdoor to the host and execute&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;编译&lt;/h2&gt; &#xA;&lt;p&gt;编译时尽量用低版本glibc，高版本glibc编译到老系统上没办法运行&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake .&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>