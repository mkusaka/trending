<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-06T01:35:52Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nkanaev/tipsy</title>
    <updated>2022-08-06T01:35:52Z</updated>
    <id>tag:github.com,2022-08-06:/nkanaev/tipsy</id>
    <link href="https://github.com/nkanaev/tipsy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;tiny playstationy renderer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;tipsy&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;tipsy&lt;/em&gt; (tiny playstationy) is a PS1-like software renderer written in ~500 lines of C99.&lt;br&gt; Features all the charm of the original PS1, like:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;low resolution display (320x240)&lt;/li&gt; &#xA; &lt;li&gt;no texture filtering (pixelated textures)&lt;/li&gt; &#xA; &lt;li&gt;affine texture mapping (warped textures)&lt;/li&gt; &#xA; &lt;li&gt;no anti-aliasing (chunky edges)&lt;/li&gt; &#xA; &lt;li&gt;lack of subpixel rasterization (polygon jittering/wobble)&lt;/li&gt; &#xA; &lt;li&gt;old shading techniques (flat &amp;amp; Gouraud)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/4911300/182365285-0148b08a-5b33-4bf3-9e48-d0fdd7f286bd.mp4&#34;&gt;https://user-images.githubusercontent.com/4911300/182365285-0148b08a-5b33-4bf3-9e48-d0fdd7f286bd.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;building prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;On Ubuntu 20.04&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt update&#xA;sudo apt install -y build-essential x11proto-core-dev libx11-dev mesa-common-dev libglu1-mesa-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;building&lt;/h2&gt; &#xA;&lt;p&gt;Building requires C99 compiler &amp;amp; OpenGL (see &lt;code&gt;makefile&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The project should compile on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux (tested on Ubuntu 20.04)&lt;/li&gt; &#xA; &lt;li&gt;MacOS (tested on Monterey)&lt;/li&gt; &#xA; &lt;li&gt;Windows (untested)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Get the source &amp;amp; run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;./tipsy path/to/wavefront.obj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hold down the left mouse button and drag to rotate.&lt;/p&gt; &#xA;&lt;p&gt;Keybindings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;kbd&gt;Left&lt;/kbd&gt;/&lt;kbd&gt;Right&lt;/kbd&gt;: rotate horizontally&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;Up&lt;/kbd&gt;/&lt;kbd&gt;Down&lt;/kbd&gt;: rotate vertically&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;W&lt;/kbd&gt;: toggle wireframe drawing&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;Z&lt;/kbd&gt;: toggle z-buffering&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;P&lt;/kbd&gt;: toggle perspective correct texture mapping (default = off)&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;C&lt;/kbd&gt;: toggle back/front face culling (default = back)&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;J&lt;/kbd&gt;: toggle jittering (default = on)&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;F&lt;/kbd&gt;: toggle vertical flip&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;R&lt;/kbd&gt;: reset model position&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;1&lt;/kbd&gt;: switch off shading (default)&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;2&lt;/kbd&gt;: switch to flat shading&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;3&lt;/kbd&gt;: switch to gouraud shading&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.david-colson.com/2021/11/30/ps1-style-renderer.html&#34;&gt;Building a PS1 style retro 3D renderer&lt;/a&gt; article by David Colson. &lt;br&gt; Polygon jittering imitation technique was taken from there.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.copetti.org/writings/consoles/playstation/&#34;&gt;Playstation Architecture&lt;/a&gt; article by Rodrigo Copetti. &lt;br&gt; Provides a good overview of the PSX architecture.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/glouw/gel&#34;&gt;gel&lt;/a&gt; by Gustav Louw. Similar project with the same spirit.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/erkkah/tigr&#34;&gt;tigr&lt;/a&gt; by Erik AgsjÃ¶. The graphics library the project relies on.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>lurk101/pshell</title>
    <updated>2022-08-06T01:35:52Z</updated>
    <id>tag:github.com,2022-08-06:/lurk101/pshell</id>
    <link href="https://github.com/lurk101/pshell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;tiny shell for Pico, with Vi and C compiler&lt;/p&gt;&lt;hr&gt;&lt;p&gt;A tiny Raspberry Pico shell with flash file system, Vi, and C compiler.&lt;/p&gt; &#xA;&lt;p&gt;Credit where credit is due...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The vi code is ported from the &lt;a href=&#34;https://www.busybox.net&#34;&gt;BusyBox&lt;/a&gt; source code.&lt;/li&gt; &#xA; &lt;li&gt;The compiler code is a remix of the &lt;a href=&#34;https://github.com/jserv/amacc.git&#34;&gt;amacc compiler&lt;/a&gt; parser generator and the &lt;a href=&#34;https://github.com/rswier/c4.git&#34;&gt;c4 virtual machine&lt;/a&gt;. Many important amacc enhancements such as floating point, array, struct and type checking support were taken fom the &lt;a href=&#34;https://github.com/HPCguy/Squint.git&#34;&gt;Squint&lt;/a&gt; project.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lurk101/pshell/master/WHATSNEW.md&#34;&gt;What&#39;s new&lt;/a&gt; in pshell&lt;/p&gt; &#xA;&lt;p&gt;About the compiler, brieflyâ€¦&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Data types: integer, float, char and pointer.&lt;/li&gt; &#xA; &lt;li&gt;Aggregate types: array, struct and union.&lt;/li&gt; &#xA; &lt;li&gt;Flow control: for, while, if then else, break, continue and goto.&lt;/li&gt; &#xA; &lt;li&gt;Memory, math and SDK functions. (&lt;a href=&#34;https://raw.githubusercontent.com/lurk101/pshell/master/FUNCTIONS.md&#34;&gt;list of implemented functions&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Raspberry Pi Forums &lt;a href=&#34;https://forums.raspberrypi.com/viewtopic.php?t=336843&#34;&gt;thread&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lurk101/pshell/master/GETTING-STARTED.md&#34;&gt;Getting Started&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Building from source.&lt;/p&gt; &#xA;&lt;p&gt;Edit the root folder CMakeLists.tx file to pick a console device, then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# NOTE: Requires sdk 1.3 or later&#xA;git clone https://github.com/lurk101/pshell.git&#xA;cd pshell&#xA;git submodule update --init&#xA;mkdir build&#xA;cd build&#xA;cmake ..&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Starting with version 1.0.4 all development will occur on the dev branch. To build it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git checkout dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build for UART (USB is the default):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake .. -DUSB_CONSOLE=OFF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;C source code &lt;a href=&#34;https://raw.githubusercontent.com/lurk101/pshell/master/c-examples&#34;&gt;examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example console log.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Pico Shell - Copyright 1883 (c) Thomas Edison&#xA;This program comes with ABSOLUTELY NO WARRANTY.&#xA;This is free software, and you are welcome to redistribute it&#xA;under certain conditions. See LICENSE file for details.&#xA;&#xA;Pico Shell v1.0.8 [master d002f0a], LittleFS v2.5, Vi 0.9.1, SDK 1.4.0&#xA;&#xA;console on UART [120 X 48]&#xA;&#xA;enter command, hit return for help&#xA;&#xA;file system automatically mounted&#xA;&#xA;/: ls&#xA;&#xA;       0 [src]&#xA;       9 .exrc&#xA;     960 b.c&#xA;      39 test.c&#xA;&#xA;/: cd src&#xA;&#xA;changed to /src&#xA;&#xA;/src: ls&#xA;&#xA;     270 blink.c&#xA;     319 clocks.c&#xA;     103 crash.c&#xA;      59 hello.c&#xA;    1133 io.c&#xA;     203 pi.c&#xA;     225 printf.c&#xA;     531 sieve.c&#xA;     298 sine.c&#xA;     584 string.c&#xA;     256 tictoc.c&#xA;&#xA;/src: cc sine.c&#xA;&#xA;                              *&#xA;                                    *&#xA;                                           *&#xA;                                                *&#xA;                                                    *&#xA;                                                      *&#xA;                                                      *&#xA;                                                     *&#xA;                                                 *&#xA;                                            *&#xA;                                      *&#xA;                               *&#xA;                         *&#xA;                   *&#xA;             *&#xA;         *&#xA;      *&#xA;      *&#xA;       *&#xA;          *&#xA;              *&#xA;                    *&#xA;                           *&#xA;&#xA;CC=0&#xA;&#xA;/src: cat sine.c&#xA;/* Math function test. Display a sine wave */&#xA;&#xA;int main() {&#xA;        int angle, incr;&#xA;        for (angle = incr, incr = 16; angle &amp;lt;= 360; angle += incr) {&#xA;                float rad = (float)angle * 0.01745329252;&#xA;                int pos = 30 + (int)(sinf(rad) * 25.0);&#xA;                while (pos &amp;gt; 0) {&#xA;                        printf(&#34; &#34;);&#xA;                        pos--;&#xA;                }&#xA;                printf(&#34;*\n&#34;);&#xA;        }&#xA;}&#xA;&#xA;/src: cc -si sine.c&#xA;1: /* Math function test. Display a sine wave */&#xA;2:&#xA;3: int main() {&#xA;4:      int angle, incr;&#xA;5:      for (angle = incr, incr = 16; angle &amp;lt;= 360; angle += incr) {&#xA;6:              float rad = (float)angle * 0.01745329252;&#xA;7:              int pos = 30 + (int)(sinf(rad) * 25.0);&#xA;8:              while (pos &amp;gt; 0) {&#xA;9:                      printf(&#34; &#34;);&#xA;10:                     pos--;&#xA;11:             }&#xA;12:             printf(&#34;*\n&#34;);&#xA;13:     }&#xA;14: }&#xA;0000: 00000007 00000004  ENT  4&#xA;0002: 00000000 ffffffff  LEA  angle (-1)&#xA;0004: 0000000a           PSH&#xA;0005: 00000000 fffffffe  LEA  incr (-2)&#xA;0007: 0000000d           LI&#xA;0008: 00000010           SI&#xA;0009: 00000000 fffffffe  LEA  incr (-2)&#xA;0011: 0000000a           PSH&#xA;0012: 00000001 00000010  IMM  16&#xA;0014: 00000010           SI&#xA;0015: 00000003 20015644  JMP  0104&#xA;0017: 00000000 fffffffd  LEA  rad (-3)&#xA;0019: 0000000a           PSH&#xA;0020: 00000000 ffffffff  LEA  angle (-1)&#xA;0022: 0000000d           LI&#xA;0023: 00000027           ITOF&#xA;0024: 0000000b           PSHF&#xA;0025: 00000002 3c8efa35  IMMF 0x3c8efa35&#xA;0027: 00000024           MULF&#xA;0028: 00000011           SF&#xA;0029: 00000000 fffffffc  LEA  pos (-4)&#xA;0031: 0000000a           PSH&#xA;0032: 00000001 0000001e  IMM  30&#xA;0034: 0000000a           PSH&#xA;0035: 00000000 fffffffd  LEA  rad (-3)&#xA;0037: 0000000e           LF&#xA;0038: 0000000b           PSHF&#xA;0039: 00000001 00000400  IMM  1024&#xA;0041: 0000002e 0000000e  SYSC sinf&#xA;0043: 00000008 00000421  ADJ  1&#xA;0045: 0000000b           PSHF&#xA;0046: 00000002 41c80000  IMMF 0x41c80000&#xA;0048: 00000024           MULF&#xA;0049: 00000026           FTOI&#xA;0050: 0000001d           ADD&#xA;0051: 00000010           SI&#xA;0052: 00000003 200155d4  JMP  0076&#xA;0054: 00000001 2000c868  IMM  0x2000c868&#xA;0056: 0000000a           PSH&#xA;0057: 00000001 00000000  IMM  0&#xA;0059: 0000002e 00000000  SYSC printf&#xA;0061: 00000008 00000001  ADJ  1&#xA;0063: 00000000 fffffffc  LEA  pos (-4)&#xA;0065: 0000000a           PSH&#xA;0066: 0000000d           LI&#xA;0067: 0000000a           PSH&#xA;0068: 00000001 00000001  IMM  1&#xA;0070: 0000001e           SUB&#xA;0071: 00000010           SI&#xA;0072: 0000000a           PSH&#xA;0073: 00000001 00000001  IMM  1&#xA;0075: 0000001d           ADD&#xA;0076: 00000000 fffffffc  LEA  pos (-4)&#xA;0078: 0000000d           LI&#xA;0079: 0000000a           PSH&#xA;0080: 00000001 00000000  IMM  0&#xA;0082: 00000019           GT&#xA;0083: 00000006 2001557c  BNZ  0054&#xA;0085: 00000001 2000c86c  IMM  0x2000c86c&#xA;0087: 0000000a           PSH&#xA;0088: 00000001 00000000  IMM  0&#xA;0090: 0000002e 00000000  SYSC printf&#xA;0092: 00000008 00000001  ADJ  1&#xA;0094: 00000000 ffffffff  LEA  angle (-1)&#xA;0096: 0000000a           PSH&#xA;0097: 0000000d           LI&#xA;0098: 0000000a           PSH&#xA;0099: 00000000 fffffffe  LEA  incr (-2)&#xA;0101: 0000000d           LI&#xA;0102: 0000001d           ADD&#xA;0103: 00000010           SI&#xA;0104: 00000000 ffffffff  LEA  angle (-1)&#xA;0106: 0000000d           LI&#xA;0107: 0000000a           PSH&#xA;0108: 00000001 00000168  IMM  360&#xA;0110: 0000001a           LE&#xA;0111: 00000006 200154e8  BNZ  0017&#xA;0113: 00000009           LEV&#xA;14:&#xA;&#xA;/src:&#xA;&#xA;    cat - display text file&#xA;     cc - compile C source file&#xA;     cd - change directory&#xA;  clear - clear the screen&#xA;     cp - copy a file&#xA; format - format the filesystem&#xA;     ls - list directory&#xA;  mkdir - create directory&#xA;  mount - mount filesystem&#xA;     mv - rename file or directory&#xA;   quit - shutdown system&#xA; reboot - Restart system&#xA;     rm - remove file or directory&#xA; status - filesystem status&#xA;unmount - unmount filesystem&#xA;     vi - editor&#xA;   xget - get file (xmodem)&#xA;   xput - put file (xmodem)&#xA;&#xA;/src:&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>ufrisk/MemProcFS</title>
    <updated>2022-08-06T01:35:52Z</updated>
    <id>tag:github.com,2022-08-06:/ufrisk/MemProcFS</id>
    <link href="https://github.com/ufrisk/MemProcFS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Memory Process File System&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MemProcFS:&lt;/h1&gt; &#xA;&lt;p&gt;MemProcFS is an easy and convenient way of viewing physical memory as files in a virtual file system.&lt;/p&gt; &#xA;&lt;p&gt;Easy trivial point and click memory analysis without the need for complicated commandline arguments! Access memory content and artifacts via files in a mounted virtual file system or via a feature rich application library to include in your own projects!&lt;/p&gt; &#xA;&lt;p&gt;Analyze memory dump files, &lt;b&gt;live memory&lt;/b&gt; via DumpIt or WinPMEM, &lt;b&gt;live memory in read-write mode&lt;/b&gt; from virtual machines or from &lt;a href=&#34;https://github.com/ufrisk/pcileech/&#34;&gt;PCILeech&lt;/a&gt; &lt;a href=&#34;https://github.com/ufrisk/pcileech-fpga/&#34;&gt;FPGA&lt;/a&gt; hardware devices!&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s even possible to connect to a remote LeechAgent memory acquisition agent over a secured connection - allowing for remote live memory incident response - even over higher latency low band-width connections! Peek into Virtual Machines with &lt;a href=&#34;https://github.com/ufrisk/LeechCore/wiki/Device_LiveCloudKd&#34;&gt;LiveCloudKd&lt;/a&gt; or &lt;a href=&#34;https://github.com/ufrisk/LeechCore/wiki/Device_VMWare&#34;&gt;VMWare&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;Use your favorite tools to analyze memory - use your favorite hex editors, your python and powershell scripts, WinDbg or your favorite disassemblers and debuggers - all will work trivally with MemProcFS by just reading and writing files!&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://github.com/ufrisk/MemProcFS/wiki/resources/proc_base3.png&#34; height=&#34;190&#34;&gt;&lt;img src=&#34;https://github.com/ufrisk/MemProcFS/wiki/resources/pciescreamer.jpeg&#34; height=&#34;190&#34;&gt;&lt;img src=&#34;https://github.com/ufrisk/MemProcFS/wiki/resources/proc_modules.png&#34; height=&#34;190&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Get Started!&lt;/h1&gt; &#xA;&lt;p&gt;Check out the excellent quick walkthrough from &lt;a href=&#34;https://www.13cubed.com/&#34;&gt;13Cubed&lt;/a&gt; to get going! Also check out my older conference talks from Disobey and BlueHat.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://youtu.be/hjWVUrf7Obk&#34; alt=&#34;13Cubed: MemProcFS - This Changes Everything&#34; target=&#34;_new&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/hjWVUrf7Obk/0.jpg&#34; height=&#34;230&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://youtu.be/mca3rLsHuTA?t=952&#34; alt=&#34;Disobey 2020 talk - Live Memory Attacks and Forensics&#34; target=&#34;_new&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/mca3rLsHuTA/0.jpg&#34; height=&#34;230&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.youtube.com/watch?v=Da_9SV9FA34&#34; alt=&#34;Microsoft BlueHatIL 2019 talk - Practical Uses for Hardware-assisted Memory Visualization&#34; target=&#34;_new&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/Da_9SV9FA34/0.jpg&#34; height=&#34;230&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For additional documentation &lt;strong&gt;please check out the &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki&#34;&gt;project wiki&lt;/a&gt;&lt;/strong&gt; for in-depth detailed information about the file system itself, its API and its plugin modules! For additional information about memory acqusition methods check out the &lt;strong&gt;&lt;a href=&#34;https://github.com/ufrisk/LeechCore/&#34;&gt;LeechCore project&lt;/a&gt;&lt;/strong&gt; or hop into the &lt;a href=&#34;https://discord.gg/sEkn3aa&#34;&gt;#pcileech&lt;/a&gt; Discord channel!&lt;/p&gt; &#xA;&lt;p&gt;To get going clone the sources in the repository or download the &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/latest&#34;&gt;latest binaries, modules and configuration files&lt;/a&gt; from the releases section and &lt;strong&gt;check out the &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki&#34;&gt;guide&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installing:&lt;/h1&gt; &#xA;&lt;p&gt;&lt;b&gt;Get the latest &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/latest&#34;&gt;binaries, modules and configuration files&lt;/a&gt; from the latest release.&lt;/b&gt; Alternatively clone the repository and build from source.&lt;/p&gt; &#xA;&lt;h2&gt;Windows&lt;/h2&gt; &#xA;&lt;p&gt;Mounting the file system requires the &lt;b&gt;Dokany file system library&lt;/b&gt; to be installed. Please download and install the latest version of Dokany version 2 at: &lt;a href=&#34;https://github.com/dokan-dev/dokany/releases/latest&#34;&gt;https://github.com/dokan-dev/dokany/releases/latest&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To capture live memory (without PCILeech FPGA hardware) download &lt;a href=&#34;https://www.comae.com/&#34;&gt;DumpIt&lt;/a&gt; and start MemProcFS via DumpIt /LIVEKD mode. Alternatively, get WinPMEM by downloading the most recent signed &lt;a href=&#34;https://github.com/Velocidex/c-aff4/tree/master/tools/pmem/resources/winpmem&#34;&gt;WinPMEM driver&lt;/a&gt; and place it alongside MemProcFS - detailed instructions in the &lt;a href=&#34;https://github.com/ufrisk/LeechCore/wiki/Device_WinPMEM&#34;&gt;LeechCore Wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;PCILeech FPGA will require hardware as well as &lt;em&gt;FTD3XX.dll&lt;/em&gt; to be dropped alongside the MemProcFS binaries. Please check out the &lt;a href=&#34;https://github.com/ufrisk/LeechCore&#34;&gt;LeechCore&lt;/a&gt; project for instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Linux&lt;/h2&gt; &#xA;&lt;p&gt;MemProcFS is dependent on packages, please do a &lt;code&gt;sudo apt-get install libusb-1.0 fuse openssl lz4&lt;/code&gt; before trying out MemProcFS. If building from source please check out the guide about &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/_Linux&#34;&gt;MemProcFS on Linux&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Extensive Python, Java, C# and C/C++ API:&lt;/h1&gt; &#xA;&lt;p&gt;Include MemProcFS in your &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/API_C&#34;&gt;C/C++&lt;/a&gt;, &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/API_CSharp&#34;&gt;C#&lt;/a&gt;, &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/API_Java&#34;&gt;Java&lt;/a&gt; or &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/API_Python&#34;&gt;Python&lt;/a&gt; programming projects! Everything in MemProcFS is exposed via an easy-to-use API for use in your own projects! The Plugin friendly architecture allows users to easily extend MemProcFS with native C .DLL plugins or Python plugins!&lt;/p&gt; &#xA;&lt;p&gt;Everything in MemProcFS is exposed as APIs. APIs exist for both C/C++ &lt;code&gt;vmmdll.h&lt;/code&gt;, C# &lt;code&gt;vmmsharp.cs&lt;/code&gt;, Java and Python &lt;code&gt;memprocfs.py&lt;/code&gt;. The file system itself is made available virtually via the API without the need to mount it. SIt is possible to read both virtual process memory as well as physical memory! The example below shows reading 0x20 bytes from physical address 0x1000:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import memprocfs&#xA;&amp;gt;&amp;gt;&amp;gt; vmm = memprocfs.Vmm([&#39;-device&#39;, &#39;c:/temp/win10_memdump.raw&#39;])&#xA;&amp;gt;&amp;gt;&amp;gt; print(vmm.hex( vmm.memory.read(0x1000, 0x20) ))&#xA;0000    e9 4d 06 00 01 00 00 00  01 00 00 00 3f 00 18 10   .M..........?...&#xA;0010    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   ................&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples:&lt;/h1&gt; &#xA;&lt;p&gt;Start MemProcFS from the command line - possibly by using one of the examples below.&lt;/p&gt; &#xA;&lt;p&gt;Or register the memory dump file extension with MemProcFS.exe so that the file system is automatically mounted when double-clicking on a memory dump file!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;mount the memory dump file as default M: &lt;br&gt;&lt;code&gt;memprocfs.exe -device c:\temp\win10x64-dump.raw&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount the memory dump file as default M: with extra verbosity: &lt;br&gt;&lt;code&gt;memprocfs.exe -device c:\temp\win10x64-dump.raw -v&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount the memory dump file as default M: and start forensics mode: &lt;br&gt;&lt;code&gt;memprocfs.exe -device c:\temp\win10x64-dump.raw -forensic 1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount the memory dump file as /home/pi/mnt/ on Linux: &lt;br&gt;&lt;code&gt;./memprocfs -mount /home/pi/linux -device /dumps/win10x64-dump.raw&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount the memory dump file as S: &lt;br&gt;&lt;code&gt;memprocfs.exe -mount s -device c:\temp\win10x64-dump.raw&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount live target memory, in verbose read-only mode, with DumpIt in /LIVEKD mode: &lt;br&gt;&lt;code&gt;DumpIt.exe /LIVEKD /A memprocfs.exe /C &#34;-v&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount live target memory, in read-only mode, with WinPMEM driver: &lt;br&gt;&lt;code&gt;memprocfs.exe -device pmem&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount live target memory, in read/write mode, with PCILeech FPGA memory acquisition device: &lt;br&gt;&lt;code&gt;memprocfs.exe -device fpga -memmap auto&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mount a memory dump with a corresponding page files: &lt;br&gt;&lt;code&gt;memprocfs.exe -device unknown-x64-dump.raw -pagefile0 pagefile.sys -pagefile1 swapfile.sys&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Building:&lt;/h1&gt; &#xA;&lt;p&gt;&lt;b&gt;Pre-built &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/latest&#34;&gt;binaries, modules and configuration files&lt;/a&gt; are found in the latest release.&lt;/b&gt;. MemProcFS binaries are built with Visual Studio 2022 and Ubuntu x64/AARCH64.&lt;/p&gt; &#xA;&lt;p&gt;Detailed build instructions may be found in the &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki&#34;&gt;Wiki&lt;/a&gt; in the &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/Dev_Building&#34;&gt;Building&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h1&gt;License:&lt;/h1&gt; &#xA;&lt;p&gt;The project source code is released under: GNU Affero General Public License v3.0. Some bundled dependencies and plugins are released under GPLv3. Some bundled Microsoft redistributable binaries are released under separate licenses. Alternative closed-source licensing may be possible upon request.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing:&lt;/h1&gt; &#xA;&lt;p&gt;PCILeech, MemProcFS and LeechCore are open source but not open contribution. PCILeech, MemProcFS and LeechCore offers a highly flexible plugin architecture that will allow for contributions in the form of plugins. If you wish to make a contribution, other than a plugin, to the core projects please contact me before starting to develop.&lt;/p&gt; &#xA;&lt;h1&gt;Links:&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Twitter: &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=UlfFrisk&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/UlfFrisk?label=UlfFrisk&amp;amp;style=social&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Discord: &lt;a href=&#34;https://discord.gg/sEkn3aa&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/736724457258745996.svg?label=&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;color=7389D8&amp;amp;labelColor=6A7EC2&#34; alt=&#34;Discord | Porchetta Industries&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;PCILeech: &lt;a href=&#34;https://github.com/ufrisk/pcileech&#34;&gt;https://github.com/ufrisk/pcileech&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;PCILeech FPGA: &lt;a href=&#34;https://github.com/ufrisk/pcileech-fpga&#34;&gt;https://github.com/ufrisk/pcileech-fpga&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;LeechCore: &lt;a href=&#34;https://github.com/ufrisk/LeechCore&#34;&gt;https://github.com/ufrisk/LeechCore&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;MemProcFS: &lt;a href=&#34;https://github.com/ufrisk/MemProcFS&#34;&gt;https://github.com/ufrisk/MemProcFS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;YouTube: &lt;a href=&#34;https://www.youtube.com/channel/UC2aAi-gjqvKiC7s7Opzv9rg&#34;&gt;https://www.youtube.com/channel/UC2aAi-gjqvKiC7s7Opzv9rg&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Blog: &lt;a href=&#34;http://blog.frizk.net&#34;&gt;http://blog.frizk.net&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Links - Related Projects:&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MemProcFSHunter: &lt;a href=&#34;https://github.com/memprocfshunt/MemProcFSHunter&#34;&gt;https://github.com/memprocfshunt/MemProcFSHunter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;MemProcFS-Analyzer: &lt;a href=&#34;https://github.com/evild3ad/MemProcFS-Analyzer&#34;&gt;https://github.com/evild3ad/MemProcFS-Analyzer&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Support PCILeech/MemProcFS development:&lt;/h1&gt; &#xA;&lt;p&gt;PCILeech and MemProcFS is free and open source!&lt;/p&gt; &#xA;&lt;p&gt;I put a lot of time and energy into PCILeech and MemProcFS and related research to make this happen. Some aspects of the projects relate to hardware and I put quite some money into my projects and related research. If you think PCILeech and/or MemProcFS are awesome tools and/or if you had a use for them it&#39;s now possible to contribute by becoming a sponsor!&lt;/p&gt; &#xA;&lt;p&gt;If you like what I&#39;ve created with PCIleech and MemProcFS with regards to DMA, Memory Analysis and Memory Forensics and would like to give something back to support future development please consider becoming a sponsor at: &lt;a href=&#34;https://github.com/sponsors/ufrisk&#34;&gt;&lt;code&gt;https://github.com/sponsors/ufrisk&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To all my sponsors, Thank You ðŸ’–&lt;/p&gt; &#xA;&lt;h1&gt;Changelog:&lt;/h1&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Previous releases (click to expand):&lt;/summary&gt; &#xA; &lt;p&gt;v1.0&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Initial Release.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;v1.1-v3.10&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Various updates. Please see individual relases for more information.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.0&#34;&gt;v4.0&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Linux support (x64 and aarch64).&lt;/li&gt; &#xA;  &lt;li&gt;Separate releases for Windows and Linux.&lt;/li&gt; &#xA;  &lt;li&gt;API Changes and some incompatibilities.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.1&#34;&gt;v4.1&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Bug fixes.&lt;/li&gt; &#xA;  &lt;li&gt;Offline kernel symbols (partial support). This allows for more functionality in Linux mode and in Windows offline mode.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.2&#34;&gt;v4.2&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Support for VMWare live VM introspection.&lt;/li&gt; &#xA;  &lt;li&gt;Support for remote agent-based memory analysis.&lt;/li&gt; &#xA;  &lt;li&gt;Map kernel memory space into csrss.exe process (to make win32k easier to access).&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.3&#34;&gt;v4.3&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Support for Windows Server 2022.&lt;/li&gt; &#xA;  &lt;li&gt;Support for Active Memory and Full Bitmap Microsoft Crash Dump files.&lt;/li&gt; &#xA;  &lt;li&gt;32-bit support for Windows and Linux (no 32-bit binary release yet).&lt;br&gt; Many thanks to &lt;a href=&#34;https://github.com/JosiahWhite&#34;&gt;@JosiahWhite&lt;/a&gt; for helping out getting me going and showing this was possible!&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.4&#34;&gt;v4.4&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Bug fixes: large modules no longer missing.&lt;/li&gt; &#xA;  &lt;li&gt;Initial support for &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Pool&#34;&gt;kernel pool parsing&lt;/a&gt;.&lt;br&gt; Thank you &lt;a href=&#34;https://twitter.com/yarden_shafir&#34;&gt;@yarden_shafir&lt;/a&gt; for the excellent &lt;a href=&#34;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf&#34;&gt;BlackHat talk&lt;/a&gt; and &lt;a href=&#34;https://github.com/yardenshafir/PoolViewer&#34;&gt;PoolViewer&lt;/a&gt; tool.&lt;/li&gt; &#xA;  &lt;li&gt;Better network connection recovery.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.5&#34;&gt;v4.5&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Merge memprocfs (Windows) and memprocfs_fuse (Linux) projects.&lt;/li&gt; &#xA;  &lt;li&gt;New VMMDLL_Scatter_* API to simplify C/C++ ReadScatter use.&lt;/li&gt; &#xA;  &lt;li&gt;Pool parsing bug fixes.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.6&#34;&gt;v4.6&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;New ReadScatter API for Python.&lt;/li&gt; &#xA;  &lt;li&gt;VMMDLL_Scatter_* API efficiency improvements for some smaller reads.&lt;/li&gt; &#xA;  &lt;li&gt;Visual Studio 2022 Support.&lt;/li&gt; &#xA;  &lt;li&gt;Upgrade to &lt;a href=&#34;https://github.com/dokan-dev/dokany/releases&#34;&gt;Dokany2&lt;/a&gt; (NB! Dokany2 will have to be installed!).&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.7&#34;&gt;v4.7&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;New memory search functionality (file system and API).&lt;/li&gt; &#xA;  &lt;li&gt;New/improved logging sub-system.&lt;/li&gt; &#xA;  &lt;li&gt;Minor API updates.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.8&#34;&gt;v4.8&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Bug fixes.&lt;/li&gt; &#xA;  &lt;li&gt;New WriteScatter API.&lt;/li&gt; &#xA;  &lt;li&gt;Process environment variables.&lt;/li&gt; &#xA;  &lt;li&gt;C# support for New Scatter API and Search API.&lt;/li&gt; &#xA;  &lt;li&gt;Forensic file consistency when analyzing local file with -forensic start-up option.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/FS_Search&#34;&gt;Search&lt;/a&gt; updates.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/FS_BitLocker&#34;&gt;Bitlocker&lt;/a&gt; key recovery.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v4.9&#34;&gt;v4.9&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Bug fixes.&lt;/li&gt; &#xA;  &lt;li&gt;Python and C# API updates.&lt;/li&gt; &#xA;  &lt;li&gt;Additional FindEvil detection vectors.&lt;/li&gt; &#xA;  &lt;li&gt;Process child/parent parsing improvements.&lt;/li&gt; &#xA;  &lt;li&gt;Process integrity levels and full SID list.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/FS_Process_Heaps&#34;&gt;Heap parsing&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/FS_Web&#34;&gt;Web history&lt;/a&gt; plugin.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ufrisk/MemProcFS/releases/tag/v5.0&#34;&gt;v5.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Major release with new features to support parallel analysis tasks.&lt;/li&gt; &#xA; &lt;li&gt;Breaking API changes and major updates.&lt;/li&gt; &#xA; &lt;li&gt;Extended forensic analysis capabilties and &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_CSV&#34;&gt;CSV file&lt;/a&gt; support.&lt;/li&gt; &#xA; &lt;li&gt;New &lt;a href=&#34;https://github.com/ufrisk/MemProcFS/wiki/API_Java&#34;&gt;Java API&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>