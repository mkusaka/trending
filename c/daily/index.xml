<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-19T01:31:55Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ptitSeb/box64</title>
    <updated>2022-11-19T01:31:55Z</updated>
    <id>tag:github.com,2022-11-19:/ptitSeb/box64</id>
    <link href="https://github.com/ptitSeb/box64" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Box64 - Linux Userspace x86_64 Emulator with a twist, targeted at ARM64 Linux devices&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ptitSeb/box64/main/img/Box64Logo.png&#34; alt=&#34;Official logo&#34; title=&#34;Official Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Linux Userspace x86_64 Emulator with a twist&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ptitSeb/box64/raw/main/docs/CHANGELOG.md&#34;&gt;View changelog&lt;/a&gt; | &lt;a href=&#34;https://github.com/ptitSeb/box64/raw/main/docs/README_CN.md&#34;&gt;中文&lt;/a&gt; | &lt;a href=&#34;https://github.com/ptitSeb/box64/issues/new&#34;&gt;Report an error&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://app.travis-ci.com/ptitSeb/box64.svg?branch=main&#34; alt=&#34;build&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/ptitSeb/box64&#34; alt=&#34;stars&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/forks/ptitSeb/box64&#34; alt=&#34;forks&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/contributors/ptitSeb/box64&#34; alt=&#34;contributors&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/issues-pr/ptitSeb/box64&#34; alt=&#34;prs&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/issues/ptitSeb/box64&#34; alt=&#34;issues&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Box64 lets you run x86_64 Linux programs (such as games) on non-x86_64 Linux systems, like ARM (host system needs to be 64-bit little-endian).&lt;/p&gt; &#xA;&lt;p&gt;You can find many Box64 videos on the &lt;a href=&#34;https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ&#34;&gt;MicroLinux&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g&#34;&gt;Pi Labs&lt;/a&gt; or &lt;a href=&#34;https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA&#34;&gt;The Byteman&lt;/a&gt; YouTube channels.&lt;/p&gt; &#xA;&lt;p&gt;Since Box64 uses the native versions of some &#34;system&#34; libraries, like libc, libm, SDL, and OpenGL, it&#39;s easy to integrate and use with most applications, and performance can be surprisingly high in many cases. Take a look at thoses bench analysis for an example &lt;a href=&#34;https://box86.org/index.php/2021/06/game-performances/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Box64 integrates with DynaRec (dynamic recompiler) for the ARM64 platform, providing a speed boost between 5 to 10 times faster than using only the interpreter. Some high level information on how DynaRec works can be found &lt;a href=&#34;https://box86.org/2021/07/inner-workings-a-high%e2%80%91level-view-of-box86-and-a-low%e2%80%91level-view-of-the-dynarec/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Some x64 internal opcodes use parts of &#34;Realmode X86 Emulator Library&#34;, see &lt;a href=&#34;https://raw.githubusercontent.com/ptitSeb/box64/src/emu/x64primop.c&#34;&gt;x64primop.c&lt;/a&gt; for copyright details&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/ptitSeb/box64/main/img/Box64Icon.png&#34; width=&#34;96&#34; height=&#34;96&#34;&gt; &#xA;&lt;p&gt;Logo and Icon made by @grayduck, thanks!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;There are a few environment variables to control the behaviour of Box64.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/ptitSeb/box64/main/USAGE.md&#34;&gt;here&lt;/a&gt; for all the environment variables and what they do.&lt;/p&gt; &#xA;&lt;p&gt;Note: Box64&#39;s Dynarec uses a mechanism with Memory Protection and a SegFault signal handler to handle JIT code. In simpler terms, if you want to use GDB to debug a running program that use JIT&#39;d code (like mono/Unity3D), you will still have many &#34;normal&#34; segfaults triggering. It is suggested to use something like &lt;code&gt;handle SIGSEGV nostop&lt;/code&gt; in GDB to not stop at each segfault, and maybe put a breakpoint inside &lt;code&gt;my_memprotectionhandler&lt;/code&gt; in &lt;code&gt;signals.c&lt;/code&gt; if you want to trap SegFaults.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Compiling/Installation&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Compilation instructions can be found &lt;a href=&#34;https://raw.githubusercontent.com/ptitSeb/box64/main/COMPILE.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Version history/Change log&lt;/h2&gt; &#xA;&lt;p&gt;The change log is available &lt;a href=&#34;https://raw.githubusercontent.com/ptitSeb/box64/main/CHANGELOG.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Notes about 32-bit platforms&lt;/h2&gt; &#xA;&lt;p&gt;Because Box64 works by directly translating function calls from x86_64 to host system, the host system (the one Box64 is running on) needs to have 64-bit libraries. Box64 doesn&#39;t include any 64-bit &amp;lt;-&amp;gt; 32-bit translation.&lt;/p&gt; &#xA;&lt;p&gt;So understand that box64 will only runs 64-bit linux binaries. For 32-bit binaries, you need box86 (with all the multiarch or proot trickery it imply on 64-bit OS). Note that many installer (mojo setup based) will fall back to &#34;x86&#34; when detecting ARM64 OS, and so will try to use box86 for the setup, even if an x86_64 version exist. You can hack your way around with a fake &#34;uname&#34; that return &#34;x86_64&#34; when the argument is &#34;-m&#34;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Notes about Unity game emulation&lt;/h2&gt; &#xA;&lt;p&gt;Running Unity games should just works, but you should also note that many Unity3D games require OpenGL 3+ which can be tricky to provide on ARM SBC (single-board computers). Also many newer Unity3D (like KSP) games use the BC7 compressed textures, wich is not supported on many ARM integrated GPU. Hint: on Pi4, use &lt;code&gt;MESA_GL_VERSION_OVERRIDE=3.2&lt;/code&gt; and with Panfrost use &lt;code&gt;PAN_MESA_DEBUG=gl3&lt;/code&gt; to use higher profile if the game starts then quits before showing anything.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Notes about GTK programs&lt;/h2&gt; &#xA;&lt;p&gt;GTK libraries are now wrapped on box64, both gtk2 and gtk3.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Notes about Steam&lt;/h2&gt; &#xA;&lt;p&gt;Note that Steam is a hybrid 32-bit / 64-bit. You NEED box86 to run Steam, as the client app is a 32-bit binary. It also uses a 64-bit local server binaries, but like most stuff using libcef/chromium, it&#39;s not working correctly on box64 for now. So, no Steam for now on box64.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Notes about Wine&lt;/h2&gt; &#xA;&lt;p&gt;Wine64 is supported on box64. Proton should also work. Be aware that 64-bit Wine also includes 32-bit components, to be able to run 32-bit Windows programs. The 32-bit apps will need box86 and will not run without it. On a system where both box64 and box86 are present and working, a wine 64-bit setup can run both 32-bit and 64-bit Windows programs (just use &lt;code&gt;wine&lt;/code&gt; and &lt;code&gt;wine64&lt;/code&gt; respectively). Note that the new 32bits PE in 64bits process that the Wine time in currently implementing in Wine 7.+ is not yet supported. I tested Wine 7.5 64bits and it worked, but more recent version will probably just not work yet.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Notes about Vulkan&lt;/h2&gt; &#xA;&lt;p&gt;Box64 wraps Vulkan libraries, but note that it as only been tested with a RX550 card, so some extensions may be missing depending on your graphics card.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Final word&lt;/h2&gt; &#xA;&lt;p&gt;I want to thank everyone who has contributed to box64 development. There are many ways to contribute: code contribution, financial, hardware and advertisement! So, in no particular order, I want to thank:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For their major code contribution: rajdakin, mogery&lt;/li&gt; &#xA; &lt;li&gt;For their major financial contribution: FlyingFathead, stormchaser3000, dennis1248, sll00, &lt;a href=&#34;https://libre.computer/&#34;&gt;libre-computer-project&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;For hardware contribution and LoongArch migration: &lt;a href=&#34;https://www.linuxgame.cn/&#34;&gt;xiaoji&lt;/a&gt;, Deepin Beijing Develop Team&lt;/li&gt; &#xA; &lt;li&gt;For their hardware contribution: &lt;a href=&#34;https://rockpi.org/&#34;&gt;Radxa&lt;/a&gt;, &lt;a href=&#34;https://www.pine64.org/&#34;&gt;Pine64&lt;/a&gt;, &lt;a href=&#34;https://rvspace.org/&#34;&gt;StarFive&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;For their continous advertisement of box64 project: salva (&lt;a href=&#34;https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ&#34;&gt;microLinux&lt;/a&gt;), &lt;a href=&#34;https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g&#34;&gt;PILab&lt;/a&gt;/&lt;a href=&#34;https://twisteros.com/&#34;&gt;TwisterOS&lt;/a&gt; team, &lt;a href=&#34;https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA&#34;&gt;The Byteman&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/channel/UCpv7NFr0-9AB5xoklh3Snhg&#34;&gt;NicoD&lt;/a&gt;, ekianjo (&lt;a href=&#34;https://boilingsteam.com/&#34;&gt;Boilingsteam&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And I also thank the many other people who participated even once in this project.&lt;/p&gt; &#xA;&lt;p&gt;(If you use Box64 in your project, please don&#39;t forget to mention it!)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>osqzss/gps-sdr-sim</title>
    <updated>2022-11-19T01:31:55Z</updated>
    <id>tag:github.com,2022-11-19:/osqzss/gps-sdr-sim</id>
    <link href="https://github.com/osqzss/gps-sdr-sim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Software-Defined GPS Signal Simulator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GPS-SDR-SIM&lt;/h1&gt; &#xA;&lt;p&gt;GPS-SDR-SIM generates GPS baseband signal data streams, which can be converted to RF using software-defined radio (SDR) platforms, such as &lt;a href=&#34;https://wiki.analog.com/university/tools/pluto&#34;&gt;ADALM-Pluto&lt;/a&gt;, &lt;a href=&#34;http://nuand.com/&#34;&gt;bladeRF&lt;/a&gt;, &lt;a href=&#34;https://github.com/mossmann/hackrf/wiki&#34;&gt;HackRF&lt;/a&gt;, and &lt;a href=&#34;http://www.ettus.com/&#34;&gt;USRP&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Windows build instructions&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Start Visual Studio.&lt;/li&gt; &#xA; &lt;li&gt;Create an empty project for a console application.&lt;/li&gt; &#xA; &lt;li&gt;On the Solution Explorer at right, add &#34;gpssim.c&#34; and &#34;getopt.c&#34; to the Souce Files folder.&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;Release&#34; in Solution Configurations drop-down list.&lt;/li&gt; &#xA; &lt;li&gt;Build the solution.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Building with GCC&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gcc gpssim.c -lm -O3 -o gps-sdr-sim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using bigger user motion files&lt;/h3&gt; &#xA;&lt;p&gt;In order to use user motion files with more than 30000 samples (at 10Hz), the &lt;code&gt;USER_MOTION_SIZE&lt;/code&gt; variable can be set to the maximum time of the user motion file in seconds. It is advisable to do this using make so gps-sdr-bin can update the size when needed. e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make USER_MOTION_SIZE=4000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This variable can also be set when compiling directly with GCC:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gcc gpssim.c -lm -O3 -o gps-sdr-sim -DUSER_MOTION_SIZE=4000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generating the GPS signal file&lt;/h3&gt; &#xA;&lt;p&gt;A user-defined trajectory can be specified in either a CSV file, which contains the Earth-centered Earth-fixed (ECEF) user positions, or an NMEA GGA stream. The sampling rate of the user motion has to be 10Hz. The user is also able to assign a static location directly through the command line.&lt;/p&gt; &#xA;&lt;p&gt;The user specifies the GPS satellite constellation through a GPS broadcast ephemeris file. The daily GPS broadcast ephemeris file (brdc) is a merge of the individual site navigation files into one. The archive for the daily file can be downloaded from: &lt;a href=&#34;https://cddis.nasa.gov/archive/gnss/data/daily/&#34;&gt;https://cddis.nasa.gov/archive/gnss/data/daily/&lt;/a&gt;. Access to this site requires registration, which is free.&lt;/p&gt; &#xA;&lt;p&gt;These files are then used to generate the simulated pseudorange and Doppler for the GPS satellites in view. This simulated range data is then used to generate the digitized I/Q samples for the GPS signal.&lt;/p&gt; &#xA;&lt;p&gt;The bladeRF and ADALM-Pluto command line interface requires I/Q pairs stored as signed 16-bit integers, while the hackrf_transfer and gps-sdr-sim-uhd.py support signed bytes.&lt;/p&gt; &#xA;&lt;p&gt;HackRF, bladeRF and ADALM-Pluto can accept the default sample rate of 2.6MHz, while the USRP2 requires an even integral decimator of 100 MHz, i.e. 2.5MHz.&lt;/p&gt; &#xA;&lt;p&gt;The simulation start time can be specified if the corresponding set of ephemerides is available. Otherwise the first time of ephemeris in the RINEX navigation file is selected.&lt;/p&gt; &#xA;&lt;p&gt;The maximum simulation duration time is defined by USER_MOTION_SIZE to prevent the output file from getting too large.&lt;/p&gt; &#xA;&lt;p&gt;The output file size can be reduced by using &#34;-b 1&#34; option to store four 1-bit I/Q samples into a single byte. You can use &lt;a href=&#34;https://github.com/osqzss/gps-sdr-sim/tree/master/player&#34;&gt;bladeplayer&lt;/a&gt; for bladeRF to playback the compressed file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: gps-sdr-sim [options]&#xA;Options:&#xA;  -e &amp;lt;gps_nav&amp;gt;     RINEX navigation file for GPS ephemerides (required)&#xA;  -u &amp;lt;user_motion&amp;gt; User motion file in ECEF x, y, z format (dynamic mode)&#xA;  -x &amp;lt;user_motion&amp;gt; User motion file in lat, lon, height format (dynamic mode)&#xA;  -g &amp;lt;nmea_gga&amp;gt;    NMEA GGA stream (dynamic mode)&#xA;  -c &amp;lt;location&amp;gt;    ECEF X,Y,Z in meters (static mode) e.g. 3967283.15,1022538.18,4872414.48&#xA;  -l &amp;lt;location&amp;gt;    Lat,Lon,Hgt (static mode) e.g. 30.286502,120.032669,100&#xA;  -t &amp;lt;date,time&amp;gt;   Scenario start time YYYY/MM/DD,hh:mm:ss&#xA;  -T &amp;lt;date,time&amp;gt;   Overwrite TOC and TOE to scenario start time&#xA;  -d &amp;lt;duration&amp;gt;    Duration [sec] (dynamic mode max: 300 static mode max: 86400)&#xA;  -o &amp;lt;output&amp;gt;      I/Q sampling data file (default: gpssim.bin ; use - for stdout)&#xA;  -s &amp;lt;frequency&amp;gt;   Sampling frequency [Hz] (default: 2600000)&#xA;  -b &amp;lt;iq_bits&amp;gt;     I/Q data format [1/8/16] (default: 16)&#xA;  -i               Disable ionospheric delay for spacecraft scenario&#xA;  -v               Show details about simulated channels&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The user motion can be specified in either dynamic or static mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; gps-sdr-sim -e brdc3540.14n -u circle.csv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; gps-sdr-sim -e brdc3540.14n -x circle_llh.csv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; gps-sdr-sim -e brdc3540.14n -g triumphv3.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; gps-sdr-sim -e brdc3540.14n -l 30.286502,120.032669,100&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transmitting the samples&lt;/h3&gt; &#xA;&lt;p&gt;The TX port of a particular SDR platform is connected to the GPS receiver under test through a DC block and a fixed 50-60dB attenuator.&lt;/p&gt; &#xA;&lt;h4&gt;BladeRF:&lt;/h4&gt; &#xA;&lt;p&gt;The simulated GPS signal file, named &#34;gpssim.bin&#34;, can be loaded into the bladeRF for playback as shown below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;set frequency 1575.42M&#xA;set samplerate 2.6M&#xA;set bandwidth 2.5M&#xA;set txvga1 -25&#xA;cal lms&#xA;cal dc tx&#xA;tx config file=gpssim.bin format=bin&#xA;tx start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also execute these commands via the &lt;code&gt;bladeRF-cli&lt;/code&gt; script option as below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; bladeRF-cli -s bladerf.script&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HackRF:&lt;/h4&gt; &#xA;&lt;p&gt;The output data have to be 8-bit signed I/Q samples.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; gps-sdr-sim -e brdc0010.22n -b 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;hackrf_transfer&lt;/code&gt; tool in the HackRF host software.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; hackrf_transfer -t gpssim.bin -f 1575420000 -s 2600000 -a 1 -x 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;UHD supported devices (tested with USRP2 only):&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; gps-sdr-sim-uhd.py -t gpssim.bin -s 2500000 -x 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use &lt;code&gt;tx_samples_from_file&lt;/code&gt; tool included in the UHD examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; tx_samples_from_file --file gpssim.bin --type short --rate 2500000 --freq 1575420000 --gain 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;LimeSDR (in case of 1 Msps 1-bit file, to get full BaseBand dynamic and low RF power):&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; limeplayer -s 1000000 -b 1 -d 2047 -g 0.1 &amp;lt; ../circle.1b.1M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ADALM-Pluto (PlutoSDR):&lt;/h4&gt; &#xA;&lt;p&gt;The ADALM-Pluto device is expected to have its network interface up and running and is accessible via &#34;pluto.local&#34; by default.&lt;/p&gt; &#xA;&lt;p&gt;Default settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; plutoplayer -t gpssim.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set TX attenuation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; plutoplayer -t gpssim.bin -a -30.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Default -20.0dB. Applicable range 0.0dB to -80.0dB in 0.25dB steps.&lt;/p&gt; &#xA;&lt;p&gt;Set RF bandwidth:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; plutoplayer -t gpssim.bin -b 3.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Default 3.0MHz. Applicable range 1.0MHz to 5.0MHz.&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;Copyright © 2015-2022 Takuji Ebinuma&lt;br&gt; Distributed under the &lt;a href=&#34;http://www.opensource.org/licenses/mit-license.php&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tomasz-lisowski/swicc</title>
    <updated>2022-11-19T01:31:55Z</updated>
    <id>tag:github.com,2022-11-19:/tomasz-lisowski/swicc</id>
    <link href="https://github.com/tomasz-lisowski/swicc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A framework for creating smart cards (ICC-based cards with contacts).&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;swICC Library&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Project &lt;strong&gt;needs&lt;/strong&gt; to be cloned recursively. Downloading the ZIP is not enough.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Software ICC (or swICC) is a framework providing an easy and flexible way to develop most types of smart cards. It also allows any swICC-based card to be connected to the PC through the &lt;a href=&#34;https://en.wikipedia.org/wiki/PC/SC&#34;&gt;PC/SC&lt;/a&gt; interface (using the &lt;a href=&#34;https://github.com/tomasz-lisowski/swicc-drv-ifd&#34;&gt;swICC PC/SC reader&lt;/a&gt;) which is the de facto standard for connecting smart cards to PCs.&lt;/p&gt; &#xA;&lt;h2&gt;Scope&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Framework for developing smart cards in software, with no hardware dependencies.&lt;/li&gt; &#xA; &lt;li&gt;Any swICC-based card can connect to the PC via PC/SC using the &lt;a href=&#34;https://github.com/tomasz-lisowski/swicc-drv-ifd&#34;&gt;swICC PC/SC reader&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Smart card file system can be defined using JSON, examples present in &lt;code&gt;./test/data/disk&lt;/code&gt;. The FS can be saved to disk as a &lt;code&gt;.swicc&lt;/code&gt; file, and loaded back into the card.&lt;/li&gt; &#xA; &lt;li&gt;Plenty debug utilities.&lt;/li&gt; &#xA; &lt;li&gt;Includes an easy-to-use BER-TLV implementation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You need &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;cmake&lt;/code&gt;, and &lt;code&gt;gcc&lt;/code&gt; to compile the project. No extra runtime dependencies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;sudo apt-get install make cmake gcc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git clone --recurse-submodules git@github.com:tomasz-lisowski/swicc.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd swicc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make main-dbg&lt;/code&gt; (for more info on building, take a look at &lt;code&gt;./doc/install.md&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Link with &lt;code&gt;./build/libswicc.a&lt;/code&gt; (e.g. &lt;code&gt;-Llib/swicc/build -lswicc&lt;/code&gt;) and add &lt;code&gt;./include&lt;/code&gt; to the include path (e.g. &lt;code&gt;-Ilib/swicc/include&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;In your project add &lt;code&gt;#include &amp;lt;swicc/swicc.h&amp;gt;&lt;/code&gt; to include all headers.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To create a minimal smart card do the following:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Make sure to follow the installation instructions first and make sure &lt;code&gt;./build/libswicc.a&lt;/code&gt; exists.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mkdir card&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd card&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Copy the following code into a &lt;code&gt;main.c&lt;/code&gt; file inside the &lt;code&gt;./card&lt;/code&gt; directory.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to see source code.&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdint.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;swicc/swicc.h&amp;gt;&#xA;&#xA;swicc_net_client_st client_ctx = {0U};&#xA;&#xA;static void sig_exit_handler(__attribute__((unused)) int signum)&#xA;{&#xA;    printf(&#34;Shutting down...\n&#34;);&#xA;    swicc_net_client_destroy(&amp;amp;client_ctx);&#xA;    exit(0);&#xA;}&#xA;&#xA;int32_t main(int32_t const argc, char const *const argv[const argc])&#xA;{&#xA;    swicc_disk_st disk = {0U};&#xA;    swicc_ret_et ret = swicc_diskjs_disk_create(&amp;amp;disk, &#34;../test/data/disk/006-in.json&#34;);&#xA;    if (ret == SWICC_RET_SUCCESS)&#xA;    {&#xA;        swicc_st swicc_ctx = {0U};&#xA;        ret = swicc_fs_disk_mount(&amp;amp;swicc_ctx, &amp;amp;disk);&#xA;        if (ret == SWICC_RET_SUCCESS)&#xA;        {&#xA;            ret = swicc_net_client_sig_register(sig_exit_handler);&#xA;            if (ret == SWICC_RET_SUCCESS)&#xA;            {&#xA;                ret =&#xA;                    swicc_net_client_create(&amp;amp;client_ctx, &#34;127.0.0.1&#34;, &#34;37324&#34;);&#xA;                if (ret == SWICC_RET_SUCCESS)&#xA;                {&#xA;                    ret = swicc_net_client(&amp;amp;swicc_ctx, &amp;amp;client_ctx);&#xA;                    if (ret != SWICC_RET_SUCCESS)&#xA;                    {&#xA;                        printf(&#34;Failed to run network client.\n&#34;);&#xA;                    }&#xA;                    swicc_net_client_destroy(&amp;amp;client_ctx);&#xA;                }&#xA;                else&#xA;                {&#xA;                    printf(&#34;Failed to create a client.\n&#34;);&#xA;                }&#xA;            }&#xA;            else&#xA;            {&#xA;                printf(&#34;Failed to register signal handler.\n&#34;);&#xA;            }&#xA;            swicc_terminate(&amp;amp;swicc_ctx);&#xA;        }&#xA;        else&#xA;        {&#xA;            printf(&#34;Failed to mount disk.\n&#34;);&#xA;            swicc_disk_unload(&amp;amp;disk);&#xA;        }&#xA;    }&#xA;    else&#xA;    {&#xA;        printf(&#34;Failed to create disk.\n&#34;);&#xA;    }&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;&lt;code&gt;gcc main.c -I../include -L../build -lswicc -o card.elf&lt;/code&gt; to build the card.&lt;/li&gt; &#xA; &lt;li&gt;To interact with the card over PC/SC, you will need to start a swICC card server, e.g., the &lt;a href=&#34;https://github.com/tomasz-lisowski/swicc-drv-ifd&#34;&gt;swICC PC/SC reader&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;./card.elf&lt;/code&gt; which will connect the card to the card reader.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pcsc_scan&lt;/code&gt; (part of the &lt;code&gt;pcsc-tools&lt;/code&gt; package) will show some details of the card.&lt;/li&gt; &#xA; &lt;li&gt;You can begin interacting with the card through PC/SC as you would with a real card.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To implement a custom card, one needs to register an APDU demuxer (before running the network client) through &lt;code&gt;swicc_apduh_pro_register&lt;/code&gt;, as well as APDU handlers that get called by the demuxer depending on command that was received. A good example for using the framework in a more advanced way is the &lt;a href=&#34;https://github.com/tomasz-lisowski/swsim&#34;&gt;swSIM&lt;/a&gt; project which implements a SIM card using swICC.&lt;/p&gt;</summary>
  </entry>
</feed>