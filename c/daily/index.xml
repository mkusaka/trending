<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-14T01:23:43Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>EpicGamesExt/raddebugger</title>
    <updated>2024-03-14T01:23:43Z</updated>
    <id>tag:github.com,2024-03-14:/EpicGamesExt/raddebugger</id>
    <link href="https://github.com/EpicGamesExt/raddebugger" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A native, user-mode, multi-process, graphical debugger.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The RAD Debugger Project&lt;/h1&gt; &#xA;&lt;p&gt;The RAD Debugger is a native, user-mode, multi-process, graphical debugger. It currently only supports local-machine Windows x64 debugging with PDBs, with plans to expand and port in the future. In the future we&#39;ll expand to also support native Linux debugging and DWARF debug info.&lt;/p&gt; &#xA;&lt;p&gt;The RAD Debugger is currently in &lt;em&gt;ALPHA&lt;/em&gt;. In order to get the debugger bullet- proof, it&#39;d greatly help out if you submitted the issues you find here, along with any information you can gather, like dump files (along with the build you used), instructions to reproduce, test executables, and so on.&lt;/p&gt; &#xA;&lt;p&gt;You can download pre-built binaries for the debugger &lt;a href=&#34;https://github.com/EpicGames/raddebugger/releases&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The RAD Debugger project aims to simplify the debugger by simplifying and unifying the underlying debug info format. In that pursuit we&#39;ve built the RADDBG debug info format, which is what the debugger parses and uses. To work with existing toolchains, we convert PDB (and eventually PE/ELF files with embedded DWARF) into the RADDBG format on-demand. This conversion process is currently an unoptimized reference version. Nevertheless it&#39;s still quite fast for smaller PDB files (in many cases faster than many other programs simply deserialize the PDBs). It is much slower for much larger projects at the moment, but we expect this will vastly improve overtime.&lt;/p&gt; &#xA;&lt;p&gt;The RADDBG format is currently specified in code, in the files within the &lt;code&gt;src/raddbg_format&lt;/code&gt; folder. The other relevant folders for working with the format are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg_cons&lt;/code&gt;: The RADDBG construction layer, for constructing RADDBG files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg_convert&lt;/code&gt;: Our implementation of PDB-to-RADDBG (and an in-progress implementation of a DWARF-to-RADDBG) conversion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg_dump&lt;/code&gt;: Code for textually dumping information from RADDBG files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development Setup Instructions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note: Currently, only x64 Windows development is supported.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;1. Installing the Required Tools (MSVC &amp;amp; Windows SDK)&lt;/h3&gt; &#xA;&lt;p&gt;In order to work with the codebase, you&#39;ll need the &lt;a href=&#34;https://aka.ms/vs/17/release/vs_BuildTools.exe&#34;&gt;Microsoft C/C++ Build Tools v15 (2017) or later&lt;/a&gt;, for both the Windows SDK and the MSVC compiler and linker.&lt;/p&gt; &#xA;&lt;p&gt;If the Windows SDK is installed (e.g. via installation of the Microsoft C/C++ Build Tools), you may also build with &lt;a href=&#34;https://releases.llvm.org/&#34;&gt;Clang&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;2. Build Environment Setup&lt;/h3&gt; &#xA;&lt;p&gt;Building the codebase can be done in a terminal which is equipped with the ability to call either MSVC or Clang from command line.&lt;/p&gt; &#xA;&lt;p&gt;This is generally done by calling &lt;code&gt;vcvarsall.bat x64&lt;/code&gt;, which is included in the Microsoft C/C++ Build Tools. This script is automatically called by the &lt;code&gt;x64 Native Tools Command Prompt for VS &amp;lt;year&amp;gt;&lt;/code&gt; variant of the vanilla &lt;code&gt;cmd.exe&lt;/code&gt;. If you&#39;ve installed the build tools, this command prompt may be easily located by searching for &lt;code&gt;Native&lt;/code&gt; from the Windows Start Menu search.&lt;/p&gt; &#xA;&lt;p&gt;You can ensure that the MSVC compiler is accessible from your command line by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If everything is set up correctly, you should have output very similar to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30151 for x64&#xA;Copyright (C) Microsoft Corporation.  All rights reserved.&#xA;&#xA;usage: cl [ option... ] filename... [ /link linkoption... ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. Building&lt;/h3&gt; &#xA;&lt;p&gt;Within this terminal, &lt;code&gt;cd&lt;/code&gt; to the root directory of the codebase, and just run the &lt;code&gt;build.bat&lt;/code&gt; script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see the following output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[debug mode]&#xA;[msvc compile]&#xA;[default mode, assuming `raddbg` build]&#xA;metagen_main.c&#xA;searching C:\devel\raddebugger/src... 299 files found&#xA;parsing metadesk... 12 metadesk files parsed&#xA;gathering tables... 37 tables found&#xA;generating layer code...&#xA;raddbg.cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If everything worked correctly, there will be a &lt;code&gt;build&lt;/code&gt; folder in the root level of the codebase, and it will contain a freshly-built &lt;code&gt;raddbg.exe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Short-To-Medium-Term Roadmap&lt;/h2&gt; &#xA;&lt;h3&gt;The Initial Alpha Battle-Testing Phase&lt;/h3&gt; &#xA;&lt;p&gt;The first priority for the project is to ensure that the most crucial debugger components are functioning extremely reliably for local, x64, Windows debugging. This would include parts like debug info conversion, debug info loading, process control, stepping, evaluation (correct usage of both location info and type info), and a robust frontend which ensures the lower level parts are usable.&lt;/p&gt; &#xA;&lt;p&gt;We feel that the debugger has already come a long way in all of these respects, but given the massive set of possible combinations of languages, build settings, toolchains, used language features, and patterns of generated code, there are still cases where the debugger has not been tested, and so there are still issues. So, we feel that the top priority is eliminating these issues, such that the debugging experience is rock solid.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, the debug info conversion process is not fast (nor wide) enough to support extremely large projects. This is for two reasons: (a) the PDB-to-RADDBG converter is an unoptimized reference implementation, and (b) the debugger learns of new modules (and thus which PDBs to load) in a serially-dependent way (this is necessarily the case for correct debugging results). We expect that the conversion process&#39; performance can be massively improved, and also that some heuristics can be used to begin converting PDBs to RADDBGs before the debugger knows those PDBs are needed, thus ensuring the associated RADDBG files are ready instantaneously when the associated modules are finally loaded by the debugger. Improving this situation is a major part of this phase, as it will make the debugger much more usable for large projects.&lt;/p&gt; &#xA;&lt;h3&gt;Local x64 Linux Debugging Phase&lt;/h3&gt; &#xA;&lt;p&gt;The next priority for the project is to take the rock solid x64 Windows debugging experience, and port all of the relevant pieces to support local x64 Linux debugging also.&lt;/p&gt; &#xA;&lt;p&gt;The debugger has been written to abstract over the parts that need to differ on either Linux or Windows, and this is mainly going to be a task in building out different backends for those abstraction layers.&lt;/p&gt; &#xA;&lt;p&gt;The major parts of this phase are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/demon&lt;/code&gt; layer to implement the Demon local process control abstraction API.&lt;/li&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/unwind&lt;/code&gt; layer to support x64 ELF unwinding (currently, there is only an x64 PE unwinding implementation).&lt;/li&gt; &#xA; &lt;li&gt;Creating a DWARF-to-RADDBG converter (in the same way that we&#39;ve built a PDB- to-RADDBG converter). A partial implementation of this is in &lt;code&gt;src/raddbg_convert/dwarf&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/render&lt;/code&gt; layer to implement all of the rendering features the frontend needs on a Linux-compatible API (the backend used on Windows is D3D11).&lt;/li&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/font_provider&lt;/code&gt; layer to a Linux-compatible font rasterization backend, like FreeType (the backend used on Windows is DirectWrite).&lt;/li&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/os&lt;/code&gt; layers to Linux. This includes core operating system abstraction (virtual memory allocation, threading and synchronization primitives, and so on), and graphical operating system abstraction (windows, input events, and so on).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once the above list is complete, and once every part is rock solid, the Windows debugging experience we&#39;ll have worked diligently to create will also be available natively on Linux machines.&lt;/p&gt; &#xA;&lt;h3&gt;And Beyond!&lt;/h3&gt; &#xA;&lt;p&gt;There are several directions we might take after these two major phases, like remote debugging, porting to different architectures, further improving the debugger&#39;s features (like improving the visualization engine), and so on. But for now, we&#39;re mostly focused on those first two phases.&lt;/p&gt; &#xA;&lt;h2&gt;Top-Level Directory Descriptions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;data&lt;/code&gt;: Small binary files which are used when building, either to embed within build artifacts, or to package with them.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src&lt;/code&gt;: All source code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After setting up the codebase and building, the following directories will also exist:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;build&lt;/code&gt;: All build artifacts. Not checked in to version control.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;local&lt;/code&gt;: Local files, used for local build configuration input files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Codebase Introduction&lt;/h2&gt; &#xA;&lt;p&gt;The codebase is organized into &lt;em&gt;layers&lt;/em&gt;. Layers are separated either to isolate certain problems, and to allow inclusion into various builds without needing to pull everything in the codebase into a build. Layers correspond with folders inside of the &lt;code&gt;src&lt;/code&gt; directory. Sometimes, one folder inside of the &lt;code&gt;src&lt;/code&gt; directory will include multiple sub-layers, but the structure is intended to be fairly flat.&lt;/p&gt; &#xA;&lt;p&gt;Layers correspond roughly 1-to-1 with &lt;em&gt;namespaces&lt;/em&gt;. The term &#34;namespaces&#34; in this context does not refer to specific namespace language features, but rather a naming convention for C-style namespaces, which are written in the codebase as a short prefix, usually 1-3 characters, followed by an underscore. These namespaces are used such that the layer to which certain code belongs may be quickly understood by glancing at code. The namespaces are generally quite short to ensure that they aren&#39;t much of a hassle to write. Sometimes, multiple sub- layers will share a namespace. A few layers do not have a namespace, but most do. Namespaces are either all-caps or lowercase depending on the context in which they&#39;re used. For types, enum values, and some macros, they are capitalized. For functions and global variables, they are lowercase.&lt;/p&gt; &#xA;&lt;p&gt;Layers depend on other layers, but circular dependencies would break the separability and isolation utility of layers (in effect, forming one big layer), so in other words, layers are arranged into a directed acyclic graph.&lt;/p&gt; &#xA;&lt;p&gt;A list of the layers in the codebase and their associated namespaces is below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;base&lt;/code&gt; (no namespace): Universal, codebase-wide constructs. Strings, math, memory allocators, helper macros, command-line parsing, and so on. Depends on no other codebase layers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;coff&lt;/code&gt; (&lt;code&gt;COFF_&lt;/code&gt;): Code for parsing and/or writing the COFF (Common Object File Format) file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ctrl&lt;/code&gt; (&lt;code&gt;CTRL_&lt;/code&gt;): The debugger&#39;s &#34;control system&#34; layer. Implements asynchronous process control, stepping, and breakpoints for all attached processes. Runs in lockstep with attached processes. When it runs, attached processes are halted. When attached processes are running, it is halted. Driven by a debugger frontend on another thread.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dasm&lt;/code&gt; (&lt;code&gt;DASM_&lt;/code&gt;): An asynchronous disassembly decoder and cache. Users ask for disassembly for a particular virtual address range in a process, and threads implemented in this layer decode and cache the disassembly for that range.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dbgi&lt;/code&gt; (&lt;code&gt;DBGI_&lt;/code&gt;): An asynchronous debug info loader and cache. Loads debug info stored in the RADDBG format. Users ask for debug info for a particular executable, and on separate threads, this layer loads the associated debug info file. If necessary, it will launch a separate conversion process to convert original debug info into the RADDBG format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;demon&lt;/code&gt; (&lt;code&gt;DEMON_&lt;/code&gt;): An abstraction layer for local-machine, low-level process control. The abstraction is used to provide a common interface for process control on target platforms. Used to implement part of &lt;code&gt;ctrl&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;df/core&lt;/code&gt; (&lt;code&gt;DF_&lt;/code&gt;): The debugger&#39;s non-graphical frontend. Implements a debugger &#34;entity cache&#34; (where &#34;entities&#34; include processes, threads, modules, breakpoints, source files, targets, and so on). Implements a command loop for driving process control, which is used to implement stepping commands and user breakpoints. Implements extractors and caches for various entity-related data, like full thread unwinds and local variable maps. Also implements core building blocks for evaluation and evaluation visualization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;df/gfx&lt;/code&gt; (&lt;code&gt;DF_&lt;/code&gt;): The debugger&#39;s graphical frontend. Builds on top of &lt;code&gt;df/core&lt;/code&gt; to provide all graphical features, including windows, panels, all of the various debugger interfaces, and evaluation visualization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;draw&lt;/code&gt; (&lt;code&gt;D_&lt;/code&gt;): Implements a high-level graphics drawing API for the debugger&#39;s purposes, using the underlying &lt;code&gt;render&lt;/code&gt; abstraction layer. Provides high-level APIs for various draw commands, but takes care of batching them, and so on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;eval&lt;/code&gt; (&lt;code&gt;EVAL_&lt;/code&gt;): Implements a compiler for an expression language built for evaluation of variables, registers, and so on from debugger-attached processes and/or debug info. Broken into several phases mostly corresponding to traditional compiler phases - lexer, parser, type-checker, IR generation, and IR evaluation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;font_cache&lt;/code&gt; (&lt;code&gt;F_&lt;/code&gt;): Implements a cache of rasterized font data, both in CPU- side data for text shaping, and in GPU texture atlases for rasterized glyphs. All cache information is sourced from the &lt;code&gt;font_provider&lt;/code&gt; abstraction layer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;font_provider&lt;/code&gt; (&lt;code&gt;FP_&lt;/code&gt;): An abstraction layer for various font file decoding and font rasterization backends.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;geo_cache&lt;/code&gt; (&lt;code&gt;GEO_&lt;/code&gt;): Implements an asynchronously-filled cache for GPU geometry data, filled by data sourced in the &lt;code&gt;hash_store&lt;/code&gt; layer&#39;s cache. Used for asynchronously preparing data for memory visualization in the debugger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hash_store&lt;/code&gt; (&lt;code&gt;HS_&lt;/code&gt;): Implements a cache for general data blobs, keyed by a 128-bit hash of the data. Used as a general data store by other layers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metagen&lt;/code&gt; (&lt;code&gt;MG_&lt;/code&gt;): A metaprogram which is used to generate primarily code and data tables. Consumes Metadesk files, stored with the extension &lt;code&gt;.mdesk&lt;/code&gt;, and generates C code which is then included by hand-written C code. Currently, it does not analyze the codebase&#39;s hand-written C code, but in principle this is possible. This allows easier &amp;amp; less-error-prone management of large data tables, which are then used to produce e.g. C &lt;code&gt;enum&lt;/code&gt;s and a number of associated data tables. There are also a number of other generation features, like embedding binary files or complex multi-line strings into source code. This layer cannot depend on any other layer in the codebase directly, including &lt;code&gt;base&lt;/code&gt;, because it may be used to generate code for those layers. To still use &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;os&lt;/code&gt; layer features in the &lt;code&gt;metagen&lt;/code&gt; program, a separate, duplicate version of &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;os&lt;/code&gt; are included in this layer. They are updated manually, as needed. This is to ensure the stability of the metaprogram.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mule&lt;/code&gt; (no namespace): Test executables for battle testing debugger functionality.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;natvis&lt;/code&gt; (no namespace): NatVis files for type visualization of the codebase&#39;s types in other debuggers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;os/core&lt;/code&gt; (&lt;code&gt;OS_&lt;/code&gt;): An abstraction layer providing core, non-graphical functionality from the operating system under an abstract API, which is implemented per-target-operating-system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;os/gfx&lt;/code&gt; (&lt;code&gt;OS_&lt;/code&gt;): An abstraction layer, building on &lt;code&gt;os/core&lt;/code&gt;, providing graphical operating system features under an abstract API, which is implemented per-target-operating-system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;os/socket&lt;/code&gt; (&lt;code&gt;OS_&lt;/code&gt;): An abstraction layer, building on &lt;code&gt;os/core&lt;/code&gt;, providing networking operating system features under an abstract API, which is implemented per-target-operating-system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pe&lt;/code&gt; (&lt;code&gt;PE_&lt;/code&gt;): Code for parsing and/or writing the PE (Portable Executable) file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg&lt;/code&gt; (no namespace): The layer which ties everything together for the main graphical debugger. Not much &#34;meat&#34;, just drives &lt;code&gt;df&lt;/code&gt;, implements command line options, and so on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg_cons&lt;/code&gt; (&lt;code&gt;CONS_&lt;/code&gt;): Implements an API for constructing files of the RADDBG debug info file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg_dump&lt;/code&gt; (&lt;code&gt;DUMP_&lt;/code&gt;): A dumper utility program for dumping textualizations of RADDBG debug info files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg_format&lt;/code&gt; (&lt;code&gt;RADDBG_&lt;/code&gt;): Standalone types and helper functions for the RADDBG debug info file format. Does not depend on &lt;code&gt;base&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg_markup&lt;/code&gt; (&lt;code&gt;RADDBG_&lt;/code&gt;): Standalone header file for marking up user programs to work with various features in the &lt;code&gt;raddbg&lt;/code&gt; debugger. Does not depend on &lt;code&gt;base&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;regs&lt;/code&gt; (&lt;code&gt;REGS_&lt;/code&gt;): Types, helper functions, and metadata for registers on supported architectures. Used in reading/writing registers in &lt;code&gt;demon&lt;/code&gt;, or in looking up register metadata.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render&lt;/code&gt; (&lt;code&gt;R_&lt;/code&gt;): An abstraction layer providing an abstract API for rendering using various GPU APIs under a common interface. Does not implement a high level drawing API - this layer is strictly for minimally abstracting on an as-needed basis. Higher level drawing features are implemented in the &lt;code&gt;draw&lt;/code&gt; layer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scratch&lt;/code&gt; (no namespace): Scratch space for small and transient test or sample programs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;texture_cache&lt;/code&gt; (&lt;code&gt;TEX_&lt;/code&gt;): Implements an asynchronously-filled cache for GPU texture data, filled by data sourced in the &lt;code&gt;hash_store&lt;/code&gt; layer&#39;s cache. Used for asynchronously preparing data for memory visualization in the debugger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;txti&lt;/code&gt; (&lt;code&gt;TXTI_&lt;/code&gt;): Machinery for asynchronously-loaded, asynchronously hot- reloaded, asynchronously parsed, and asynchronously mutated source code files. Used by the debugger to visualize source code files. Users ask for text lines, tokens, and metadata, and it is prepared on background threads.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;type_graph&lt;/code&gt; (&lt;code&gt;TG_&lt;/code&gt;): Code for analyzing and navigating type structures from RADDBG debug info files, with the additional capability of constructing synthetic types &lt;em&gt;not&lt;/em&gt; found in debug info. Used in &lt;code&gt;eval&lt;/code&gt; and for various visualization features.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ui&lt;/code&gt; (&lt;code&gt;UI_&lt;/code&gt;): Machinery for building graphical user interfaces. Provides a core immediate mode hierarchical user interface data structure building API, and has helper layers for building some higher-level widgets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unwind&lt;/code&gt; (&lt;code&gt;UNW_&lt;/code&gt;): Code for generating unwind information from threads, for supported operating systems and architectures.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>rkaehn/cr_task.h</title>
    <updated>2024-03-14T01:23:43Z</updated>
    <id>tag:github.com,2024-03-14:/rkaehn/cr_task.h</id>
    <link href="https://github.com/rkaehn/cr_task.h" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Header-only library for asynchronous tasks in C&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;cr_task.h&lt;/h1&gt; &#xA;&lt;p&gt;This library provides a minimal set of types and functions for an asynchronous task system in C. It was designed to be lock-free in the common case, with locks only needed for allocations of backing memory for the task pool and when the worker threads are starved for tasks to execute. It is written in standard C11 with no dependencies besides the C POSIX library.&lt;/p&gt; &#xA;&lt;p&gt;To get started, create an executor with the desired number of worker threads and define a task.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;cr_executor_t* exec = cr_executor_create(4);&#xA;cr_task_t* task = cr_task_create(exec, func, args);&#xA;cr_task_run(task);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the task is going to run immediately on &lt;code&gt;cr_task_run&lt;/code&gt;. If you want it to run later, call &lt;code&gt;cr_task_wait&lt;/code&gt; before &lt;code&gt;run&lt;/code&gt;, and &lt;code&gt;cr_task_signal&lt;/code&gt; later.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;cr_task_t* task = cr_task_create(exec, func, args);&#xA;cr_task_wait(task);&#xA;cr_task_run(task);&#xA;// Later... (possibly on a different thread or inside a task)&#xA;cr_task_signal(task);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of calling &lt;code&gt;signal&lt;/code&gt; yourself, you can also request a signal from another task, creating a dependency. Here, &lt;code&gt;task_1&lt;/code&gt; has to finish before &lt;code&gt;task_2&lt;/code&gt; can start.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;cr_task_t* task_1 = cr_task_create(exec, func, args);&#xA;cr_task_t* task_2 = cr_task_create(exec, func, args);&#xA;cr_task_wait(task_2);&#xA;cr_task_request_signal(task_2, task_1);&#xA;cr_task_run(task_2);&#xA;// task_2 does not execute yet&#xA;cr_task_run(task_1);&#xA;// task_1 executes, then task_2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since telling one task to wait and requesting a signal from another is such a common operation, there is a shorthand function called &lt;code&gt;cr_task_wait_request_signal&lt;/code&gt;. &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt; calls must always be balanced, and as soon as the wait count hits zero and &lt;code&gt;run&lt;/code&gt; has been called, the task executes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;cr_task_t* task = cr_task_create(exec, func, args);&#xA;cr_task_wait_request_signal(task, task_dep_1);&#xA;cr_task_wait_request_signal(task, task_dep_2);&#xA;cr_task_run(task);&#xA;// task_dep_1 and task_dep_2 execute, then task&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you want to synchronously wait for a task to finish execution, call &lt;code&gt;cr_task_sync&lt;/code&gt;. Since a task destroys itself automatically after it has run, you need to call &lt;code&gt;cr_task_retain&lt;/code&gt; before, and &lt;code&gt;cr_task_release&lt;/code&gt; after waiting. And again, because this pattern of &lt;code&gt;retain&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;sync&lt;/code&gt;, and &lt;code&gt;release&lt;/code&gt; is relatively common, there is a shorthand called &lt;code&gt;cr_task_run_sync&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;cr_task_t* task = cr_task_create(exec, func, args);&#xA;cr_task_retain(task);&#xA;cr_task_run(task);&#xA;cr_task_sync(task);&#xA;cr_task_release(task);&#xA;// Or the shorthand...&#xA;cr_task_run_sync(task);&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>