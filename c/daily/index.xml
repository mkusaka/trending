<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-06T05:29:03Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AlkaMotors/AM32-MultiRotor-ESC-firmware</title>
    <updated>2024-06-06T05:29:03Z</updated>
    <id>tag:github.com,2024-06-06:/AlkaMotors/AM32-MultiRotor-ESC-firmware</id>
    <link href="https://github.com/AlkaMotors/AM32-MultiRotor-ESC-firmware" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Firmware for stm32f051 based speed controllers for use with mutirotors&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;All mcu&#39;s have been combined to one project. Please use the new repository &lt;a href=&#34;https://github.com/am32-firmware/AM32&#34;&gt;here&lt;/a&gt;.&lt;/h1&gt; &#xA;&lt;h1&gt;AM32-MultiRotor-ESC-firmware&lt;/h1&gt; &#xA;&lt;p&gt;Firmware for ARM based speed controllers&lt;/p&gt; &#xA;&lt;p align=&#34;left&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/AlkaMotors/AM32-MultiRotor-ESC-firmware/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL--3.0-brightgreen&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;The AM32 firmware is designed for STM32 ARM processors to control a brushless motor (BLDC). The firmware is intended to be safe and fast with smooth fast startups and linear throttle. It is meant for use with multiple vehicle types and a flight controller. The firmware can also be built with support for crawlers. For crawler usage please read this wiki page &lt;a href=&#34;https://github.com/AlkaMotors/AM32-MultiRotor-ESC-firmware/wiki/Crawler-Hardware-and-AM32&#34;&gt;Crawler Hardware&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;AM32 has the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Firmware upgradable via betaflight passthrough, single wire serial or arduino&lt;/li&gt; &#xA; &lt;li&gt;Servo PWM, Dshot(300, 600) motor protocol support&lt;/li&gt; &#xA; &lt;li&gt;Bi-directional Dshot&lt;/li&gt; &#xA; &lt;li&gt;KISS standard ESC telemetry&lt;/li&gt; &#xA; &lt;li&gt;Variable PWM frequency&lt;/li&gt; &#xA; &lt;li&gt;Sinusoidal startup mode, which is designed to get larger motors up to speed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build instructions&lt;/h2&gt; &#xA;&lt;p&gt;-&#34;make&#34; - builds all targets -&#34;make AM32_XXX_F051 builds&#34; a speciic target -Github actions -Fork project and run the build action within github itself.&lt;/p&gt; &#xA;&lt;h2&gt;Firmware Release &amp;amp; Configuration Tool&lt;/h2&gt; &#xA;&lt;p&gt;The latest release of the firmware can be found &lt;a href=&#34;https://github.com/AlkaMotors/AM32-MultiRotor-ESC-firmware/releases/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To configure AM32 and upload firmware you can use the Multi_ESC config tool using Betaflight passthrough. They can be downloaded from here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://drive.google.com/file/d/1qw2f7nM6OZftIE5GTgMPWB5zXCELxYG9/view?usp=sharing&#34;&gt;WINDOWS&lt;/a&gt;, &lt;a href=&#34;https://drive.google.com/file/d/1QtSKwp3RT6sncPADsPkmdasGqNIk68HH/view?usp=sharing&#34;&gt;LINUX&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternately you can use the &lt;a href=&#34;https://esc-configurator.com/&#34;&gt;Online-ESC Configurator&lt;/a&gt; to flash or change settings with any web browser that supports web serial.&lt;/p&gt; &#xA;&lt;h2&gt;Hardware&lt;/h2&gt; &#xA;&lt;p&gt;AM32 currently has support for STSPIN32F0, STM32F051, STM32G071, GD32E230, AT32F415 and AT32F421. The CKS32F051 is not recommended due to too many random issues. Target compatibility List can be found &lt;a href=&#34;https://github.com/AlkaMotors/AM32-MultiRotor-ESC-firmware/wiki/List-of-Supported-Hardware&#34;&gt;here&lt;/a&gt; (APR 2021)&lt;/p&gt; &#xA;&lt;h2&gt;Installation &amp;amp; Bootloader&lt;/h2&gt; &#xA;&lt;p&gt;To use AM32 firmware on a blank ESC, a bootloader must first be installed using an ST-LINK, GD-LINK , CMIS-DAP or AT-LINK. THe bootloader will be dependant on the MCU used ont he esc . Choose the bootloader that matches the MCU type and signal input pin of the ESC. The compatibility chart has the bootloader pinouts listed. Current bootloaders can be found &lt;a href=&#34;https://github.com/AlkaMotors/AM32_Bootloader_F051/tree/main/Bootloaders&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After the bootloader has been installed the main firmware from can be installed either with the configuration tools and a Betaflight flight controller or a direct connection with a usb serial adapter modified for one wire.&lt;/p&gt; &#xA;&lt;p&gt;To update an existing AM32 bootloader an update tool can be found &lt;a href=&#34;https://github.com/AlkaMotors/F051_Bootloader_Updater/releases&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Support and Developers Channel&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways you can get support or participate in improving am32. We have a discord server here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/h7ddYMmEVV&#34;&gt;https://discord.gg/h7ddYMmEVV&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s a dedicated Slack chat channel here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://am32-invite.herokuapp.com/&#34;&gt;https://am32-invite.herokuapp.com/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Etiquette: Please wait around long enough for a reply - sometimes people are out flying, asleep or at work and can&#39;t answer immediately.&lt;/p&gt; &#xA;&lt;p&gt;If you wish to support the project please join the Patreon.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.patreon.com/user?u=44228479&#34;&gt;https://www.patreon.com/user?u=44228479&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;The AM32 project would not have made this far without help from the following sponsors:&lt;/p&gt; &#xA;&lt;p&gt;Holmes Hobbies - &lt;a href=&#34;https://holmeshobbies.com/&#34;&gt;https://holmeshobbies.com/&lt;/a&gt; - The project would not be where it is today without the support of HH. Check out the Crawlmaster V2 for the best am32 experience!&lt;/p&gt; &#xA;&lt;p&gt;Quaternium - &lt;a href=&#34;https://www.quaternium.com/&#34;&gt;https://www.quaternium.com/&lt;/a&gt; - Firmware development support and hardware donations&lt;/p&gt; &#xA;&lt;p&gt;Airbot - Many hardware donations&lt;/p&gt; &#xA;&lt;p&gt;NeutronRC - For hardware, am32 promotion and schematics&lt;/p&gt; &#xA;&lt;p&gt;Aikon - Hardware donations and schematics&lt;br&gt; Skystars - For hardware and taking a chance on the first commercial am32 esc&#39;s&lt;br&gt; Diatone - Hardware donations&lt;br&gt; T-motor - Motor and Hardware donations&lt;br&gt; HLGRC - Hardaware donations&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;A big thanks to all those who contributed time, advice and code to the AM32 project.&lt;br&gt; Hugo Chiang (Dusking)&lt;br&gt; Micheal Keller (Mikeller)&lt;br&gt; ColinNiu&lt;br&gt; Jacob Walser&lt;/p&gt; &#xA;&lt;p&gt;And for feedback from pilots and drivers:&lt;br&gt; Jye Smith&lt;br&gt; Markus Gritsch&lt;br&gt; Voodoobrew&lt;/p&gt; &#xA;&lt;p&gt;(and many more)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>riscv-software-src/riscv-tests</title>
    <updated>2024-06-06T05:29:03Z</updated>
    <id>tag:github.com,2024-06-06:/riscv-software-src/riscv-tests</id>
    <link href="https://github.com/riscv-software-src/riscv-tests" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;riscv-tests&lt;/h1&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;This repository hosts unit tests for RISC-V processors.&lt;/p&gt; &#xA;&lt;h2&gt;Building from repository&lt;/h2&gt; &#xA;&lt;p&gt;We assume that the RISCV environment variable is set to the RISC-V tools install path, and that the riscv-gnu-toolchain package is installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/riscv/riscv-tests&#xA;$ cd riscv-tests&#xA;$ git submodule update --init --recursive&#xA;$ autoconf&#xA;$ ./configure --prefix=$RISCV/target&#xA;$ make&#xA;$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The rest of this document describes the format of test programs for the RISC-V architecture.&lt;/p&gt; &#xA;&lt;h2&gt;Test Virtual Machines&lt;/h2&gt; &#xA;&lt;p&gt;To allow maximum reuse of a given test, each test program is constrained to only use features of a given &lt;em&gt;test virtual machine&lt;/em&gt; or TVM. A TVM hides differences between alternative implementations by defining:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The set of registers and instructions that can be used.&lt;/li&gt; &#xA; &lt;li&gt;Which portions of memory can be accessed.&lt;/li&gt; &#xA; &lt;li&gt;The way the test program starts and ends execution.&lt;/li&gt; &#xA; &lt;li&gt;The way that test data is input.&lt;/li&gt; &#xA; &lt;li&gt;The way that test results are output.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following table shows the TVMs currently defined for RISC-V. All of these TVMs only support a single hardware thread.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;TVM Name&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rv32ui&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RV32 user-level, integer only&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rv32si&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RV32 supervisor-level, integer only&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rv64ui&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RV64 user-level, integer only&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rv64uf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RV64 user-level, integer and floating-point&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rv64uv&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RV64 user-level, integer, floating-point, and vector&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rv64si&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RV64 supervisor-level, integer only&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rv64sv&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RV64 supervisor-level, integer and vector&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;A test program for RISC-V is written within a single assembly language file, which is passed through the C preprocessor, and all regular assembly directives can be used. An example test program is shown below. Each test program should first include the &lt;code&gt;riscv_test.h&lt;/code&gt; header file, which defines the macros used by the TVM. The header file will have different contents depending on the target environment for which the test will be built. One of the goals of the various TVMs is to allow the same test program to be compiled and run on very different target environments yet still produce the same results. The following table shows the target environment currently defined.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Target Environment Name&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;virtual memory is disabled, only core 0 boots up&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pm&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;virtual memory is disabled, all cores boot up&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;virtual memory is disabled, timer interrupt fires every 100 cycles&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;virtual memory is enabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Each test program must next specify for which TVM it is designed by including the appropriate TVM macro, &lt;code&gt;RVTEST_RV64U&lt;/code&gt; in this example. This specification can change the way in which subsequent macros are interpreted, and supports a static check of the TVM functionality used by the program.&lt;/p&gt; &#xA;&lt;p&gt;The test program will begin execution at the first instruction after &lt;code&gt;RVTEST_CODE_BEGIN&lt;/code&gt;, and continue until execution reaches an &lt;code&gt;RVTEST_PASS&lt;/code&gt; macro or the &lt;code&gt;RVTEST_CODE_END&lt;/code&gt; macro, which is implicitly a success. A test can explicitly fail by invoking the &lt;code&gt;RVTEST_FAIL&lt;/code&gt; macro.&lt;/p&gt; &#xA;&lt;p&gt;The example program contains self-checking code to test the result of the add. However, self-checks rely on correct functioning of the processor instructions used to implement the self check (e.g., the branch) and so cannot be the only testing strategy.&lt;/p&gt; &#xA;&lt;p&gt;All tests should also contain a test data section, delimited by &lt;code&gt;RVTEST_DATA_BEGIN&lt;/code&gt; and &lt;code&gt;RVTEST_DATA_END&lt;/code&gt;. There is no alignment guarantee for the start of the test data section, so regular assembler alignment instructions should be used to ensure desired alignment of data values. This region of memory will be captured at the end of the test to act as a signature from the test. The signature can be compared with that from a run on the golden model.&lt;/p&gt; &#xA;&lt;p&gt;Any given test environment for running tests should also include a timeout facility, which will class a test as failing if it does not successfully complete a test within a reasonable time bound.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;riscv_test.h&#34;&#xA;&#xA;RVTEST_RV64U        # Define TVM used by program.&#xA;&#xA;# Test code region.&#xA;RVTEST_CODE_BEGIN   # Start of test code.&#xA;        lw      x2, testdata&#xA;        addi    x2, 1         # Should be 42 into $2.&#xA;        sw      x2, result    # Store result into memory overwriting 1s.&#xA;        li      x3, 42        # Desired result.&#xA;        bne     x2, x3, fail  # Fail out if doesn&#39;t match.&#xA;        RVTEST_PASS           # Signal success.&#xA;fail:&#xA;        RVTEST_FAIL&#xA;RVTEST_CODE_END     # End of test code.&#xA;&#xA;# Input data section.&#xA;# This section is optional, and this data is NOT saved in the output.&#xA;.data&#xA;        .align 3&#xA;testdata:&#xA;        .dword 41&#xA;&#xA;# Output data section.&#xA;RVTEST_DATA_BEGIN   # Start of test output data region.&#xA;        .align 3&#xA;result:&#xA;        .dword -1&#xA;RVTEST_DATA_END     # End of test output data region.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;User-Level TVMs&lt;/h2&gt; &#xA;&lt;p&gt;Test programs for the &lt;code&gt;rv32u*&lt;/code&gt; and &lt;code&gt;rv64u*&lt;/code&gt; TVMs can contain all instructions from the respective base user-level ISA (RV32 or RV64), except for those with the SYSTEM major opcode (syscall, break, rdcycle, rdtime, rdinstret). All user registers (pc, x0-x31, f0-f31, fsr) can be accessed.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rv32ui&lt;/code&gt; and &lt;code&gt;rv64ui&lt;/code&gt; TVMs are integer-only subsets of &lt;code&gt;rv32u&lt;/code&gt; and &lt;code&gt;rv64u&lt;/code&gt; respectively. These subsets can not use any floating-point instructions (major opcodes: LOAD-FP, STORE-FP, MADD, MSUB, NMSUB, NMADD, OP-FP), and hence cannot access the floating-point register state (f0-f31 and fsr). The integer-only TVMs are useful for initial processor bringup and to test simpler implementations that lack a hardware FPU.&lt;/p&gt; &#xA;&lt;p&gt;Note that any &lt;code&gt;rv32ui&lt;/code&gt; test program is also valid for the &lt;code&gt;rv32u&lt;/code&gt; TVM, and similarly &lt;code&gt;rv64ui&lt;/code&gt; is a strict subset of &lt;code&gt;rv64u&lt;/code&gt;. To allow a given test to run on the widest possible set of implementations, it is desirable to write any given test to run on the smallest or least capable TVM possible. For example, any simple tests of integer functionality should be written for the &lt;code&gt;rv64ui&lt;/code&gt; TVM, as the same test can then be run on RV64 implementations with or without a hardware FPU. As another example, all tests for these base user-level TVMs will also be valid for more advanced processors with instruction-set extensions.&lt;/p&gt; &#xA;&lt;p&gt;At the start of execution, the values of all registers are undefined. All branch and jump destinations must be to labels within the test code region of the assembler source file. The code and data sections will be relocated differently for the various implementations of the test environment, and so test program results shall not depend on absolute addresses of instructions or data memory. The test build environment should support randomization of the section relocation to provide better coverage and to ensure test signatures do not contain absolute addresses.&lt;/p&gt; &#xA;&lt;h2&gt;Supervisor-Level TVMs&lt;/h2&gt; &#xA;&lt;p&gt;The supervisor-level TVMs allow testing of supervisor-level state and instructions. As with the user-level TVMs, we provide integer-only supervisor-level TVMs indicated with a trailing &lt;code&gt;i&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;History and Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;This style of test virtual machine originated with the T0 (Torrent-0) vector microprocessor project at UC Berkeley and ICSI, begun in 1992. The main developers of this test strategy were Krste Asanovic and David Johnson. A precursor to &lt;code&gt;torture&lt;/code&gt; was &lt;code&gt;rantor&lt;/code&gt; developed by Phil Kohn at ICSI.&lt;/p&gt; &#xA;&lt;p&gt;A variant of this testing approach was also used for the Scale vector-thread processor at MIT, begun in 2000. Ronny Krashinsky and Christopher Batten were the principal architects of the Scale chip. Jeffrey Cohen and Mark Hampton developed a version of torture capable of generating vector-thread code.&lt;/p&gt;</summary>
  </entry>
</feed>