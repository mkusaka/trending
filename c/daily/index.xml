<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-15T01:31:59Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ldpreload/BlackLotus</title>
    <updated>2023-07-15T01:31:59Z</updated>
    <id>tag:github.com,2023-07-15:/ldpreload/BlackLotus</id>
    <link href="https://github.com/ldpreload/BlackLotus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;BlackLotus UEFI Windows Bootkit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BlackLotus&lt;/h1&gt; &#xA;&lt;p&gt;BlackLotus is an innovative UEFI Bootkit designed specifically for Windows. It incorporates a built-in Secure Boot bypass and Ring0/Kernel protection to safeguard against any attempts at removal. This software serves the purpose of functioning as an HTTP Loader. Thanks to its robust persistence, there is no necessity for frequent updates of the Agent with new encryption methods. Once deployed, traditional antivirus software will be incapable of scanning and eliminating it. The software comprises two primary components: the Agent, which is installed on the targeted device, and the Web Interface, utilized by administrators to manage the bots. In this context, a bot refers to a device equipped with the installed Agent.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;FYI&lt;/strong&gt;: This version of BlackLotus (v2) has removed baton drop, and replaced the original version SHIM loaders with bootlicker. UEFI loading, infection and post-exploitation persistence are all the same.&lt;/p&gt; &#xA;&lt;h2&gt;General&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Written in C and x86asm&lt;/li&gt; &#xA; &lt;li&gt;Utilizes on Windows API, NTAPI, EFIAPI (NO 3rd party libraries used),&lt;/li&gt; &#xA; &lt;li&gt;NO CRT (C Runtime Library).&lt;/li&gt; &#xA; &lt;li&gt;Compiled binary including the user-mode loader is only 80kb in size&lt;/li&gt; &#xA; &lt;li&gt;Uses secure HTTPS C2 communication by using RSA and AES encryption&lt;/li&gt; &#xA; &lt;li&gt;Dynamic configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;HVCI bypass&lt;/li&gt; &#xA; &lt;li&gt;UAC bypass&lt;/li&gt; &#xA; &lt;li&gt;Secure Boot bypass&lt;/li&gt; &#xA; &lt;li&gt;BitLocker boot sequence bypass&lt;/li&gt; &#xA; &lt;li&gt;Windows Defender bypass (patch Windows Defender drivers in memory, and prevent Windows Defender usermode engine from scanning/uploading files)&lt;/li&gt; &#xA; &lt;li&gt;Dynamic hashed API calls (hell&#39;s gate)&lt;/li&gt; &#xA; &lt;li&gt;x86&amp;lt;=&amp;gt;x64 process injection&lt;/li&gt; &#xA; &lt;li&gt;API Hooking engine&lt;/li&gt; &#xA; &lt;li&gt;Anti-Hooking engine (for disabling, bypassing, and controlling EDRs)&lt;/li&gt; &#xA; &lt;li&gt;Modular plugin system&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Setup by modifying the config.c file by including your C2s hostname or IP address. After that compliation should be easy, just keep the included settings in the Visual Studio solution.&lt;/p&gt; &#xA;&lt;h2&gt;Default Panel Credentials:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;user&lt;/strong&gt;: yukari&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;password&lt;/strong&gt;: default&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Welivesecurity: &lt;a href=&#34;https://www.welivesecurity.com/2023/03/01/blacklotus-uefi-bootkit-myth-confirmed&#34;&gt;https://www.welivesecurity.com/2023/03/01/blacklotus-uefi-bootkit-myth-confirmed&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Binarly: &lt;a href=&#34;https://www.binarly.io/posts/The_Untold_Story_of_the_BlackLotus_UEFI_Bootkit/index.html&#34;&gt;https://www.binarly.io/posts/The_Untold_Story_of_the_BlackLotus_UEFI_Bootkit/index.html&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NSA Mitigation Guide: &lt;a href=&#34;https://www.nsa.gov/Press-Room/Press-Releases-Statements/Press-Release-View/Article/3435305/nsa-releases-guide-to-mitigate-blacklotus-threat&#34;&gt;https://www.nsa.gov/Press-Room/Press-Releases-Statements/Press-Release-View/Article/3435305/nsa-releases-guide-to-mitigate-blacklotus-threat&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;TheHackerNews: &lt;a href=&#34;https://thehackernews.com/2023/03/blacklotus-becomes-first-uefi-bootkit.html&#34;&gt;https://thehackernews.com/2023/03/blacklotus-becomes-first-uefi-bootkit.html&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Bootlicker: &lt;a href=&#34;https://github.com/realoriginal/bootlicker&#34;&gt;https://github.com/realoriginal/bootlicker&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ldpreload/Medusa</title>
    <updated>2023-07-15T01:31:59Z</updated>
    <id>tag:github.com,2023-07-15:/ldpreload/Medusa</id>
    <link href="https://github.com/ldpreload/Medusa" rel="alternate"></link>
    <summary type="html">&lt;p&gt;LD_PRELOAD Rootkit&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;i&gt;&lt;u&gt;Paralyze resistance with persistence.&lt;/u&gt;&lt;/i&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://files.catbox.moe/q78mg1.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;⌈&lt;strong&gt;Description&lt;/strong&gt;⌉&lt;/h1&gt; &#xA;&lt;p&gt;Medusa is a powerful, stealthy, versatile, and, modular rootkit designed to give attackers complete control over Linux systems. Medusa is compiled and ready to be executed as a small ELF executable file, which no means extra building or configuration requirements! Medusa is larger than a few hundred kilobytes in size. Once installed, the rootkit sets up a dynamic linker that modifies the way applications are loaded and executed on the system. At this point the Medusa hooks a plethora of API system calls, library functions and signal handlers to achieve imbreakable and uninterceptable persistence. Medusa intercepts a plethoa of system calls made by all applications on the Medusa infected machine.. Hooking these system calls allows a Medusa to control and modify the behavior when system call is made. For example, with &lt;code&gt;stat()&lt;/code&gt; family calls, a user can specify what information should be returned when those calls are made, or make changes to the permissions of files and directories. With &lt;code&gt;access()&lt;/code&gt;, the user can control who has permission to what areas of the system. With &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;open()&lt;/code&gt;, and their derivatives, Medusa can control what files and directories are accessed by the system, and what data is written to them. Truncate and &lt;code&gt;chmod()&lt;/code&gt; / &lt;code&gt;chown()&lt;/code&gt; allows for control over how files and directories are manipulated. Pututxline, updwtmp, and pututline are used for managing user logins and account information.&lt;/p&gt; &#xA;&lt;h1&gt;⌈&lt;strong&gt;Features&lt;/strong&gt;⌉&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;PAM Backdoor&lt;/strong&gt; → Hook libpam authentication system calls for persisting with a hidden root user&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Process Hiding&lt;/strong&gt; → Hooks rootkit can intercept the &#39;kill&#39; function to prevent the user from terminating the rootkit process. By hiding itself from the system, the rootkit can remain undetected and achieve persistence on the system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;File Hiding&lt;/strong&gt; → Hooks &#39;stat&#39; and &#39;readdir&#39; to hide files and directories.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Network Hiding&lt;/strong&gt; → Hooks the &#39;getaddrinfo&#39; function to filter out addresses of remote hosts that it wants to hide. By using these techniques, the rootkit can effectively hide network activity from the user and other programs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Anti-Debugging&lt;/strong&gt; → Also Hooks &#39;kill&#39; system call can be intercepted to prevent the debugger from sending signals to the rootkit process. By evading debugging, the rootkit can make it more difficult for security researchers to discover and analyze its behavior.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Auth Logging&lt;/strong&gt; → Hooks &lt;code&gt;pam_prompt()&lt;/code&gt;, &lt;code&gt;pam_vprompt&lt;/code&gt; and &lt;code&gt;pam_syslog&lt;/code&gt; to log all successful authentications locally, or remotely via SSH to Medusa home directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Execution Logging&lt;/strong&gt; → Hooks &lt;code&gt;syslog()&lt;/code&gt; and &lt;code&gt;pam_syslog&lt;/code&gt; to log all successful authentications locally, or remotely via SSH to Medusa home directory&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;&lt;strong&gt;Building And Deployment&lt;/strong&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Change the settings you want in &lt;strong&gt;src/config.c&lt;/strong&gt; this includes your username and password that will be used to access the backdoor deployed by Medusa.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default Backdoor Credentials:&lt;/strong&gt; &lt;strong&gt;Username&lt;/strong&gt;: adm1n &lt;strong&gt;Password&lt;/strong&gt;: asdfasdf&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ssh&#34;&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The executable in &lt;strong&gt;bin/rkload&lt;/strong&gt; is the deployable rootkit.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Connect via SSH to backdoor:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ssh&#34;&gt;ssh adm1n@infected-host.com&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>rgerganov/ggtag</title>
    <updated>2023-07-15T01:31:59Z</updated>
    <id>tag:github.com,2023-07-15:/rgerganov/ggtag</id>
    <link href="https://github.com/rgerganov/ggtag" rel="alternate"></link>
    <summary type="html">&lt;p&gt;programmable e-paper tag with RFID&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/rgerganov/ggtag/actions&#34;&gt;&lt;img src=&#34;https://github.com/rgerganov/ggtag/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;ggtag&lt;/code&gt; is an electronic tag that can be programmed with sound using the &lt;a href=&#34;https://github.com/ggerganov/ggwave&#34;&gt;ggwave&lt;/a&gt; library. It is based on the RP2040 microcontroller and has 3.52&#34; e-paper display. Additionally, ggtag supports USB serial programming and allows emulation of 125kHz RFID tags (ASK and FSK).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Subscribe to our &lt;a href=&#34;https://www.crowdsupply.com/eurolan-ltd/ggtag&#34;&gt;CrowdSupply page&lt;/a&gt; to get latest updates about the project&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rgerganov/ggtag/master/pics/front.jpg&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rgerganov/ggtag/master/pics/back.jpg&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Some example tags:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ggtag.io/?i=%5Cr18%2C15%2C82%2C82%5Cq22%2C19%2C3%2Chttps%3A%2F%2Fggtag.io%5CI273%2C15%2C70%2C70%2C0%2Chttps%3A%2F%2Fggtag.io%2Fggtag-180x180.png%5Ct139%2C118%2C5%2Cggtag%5Ct58%2C149%2C3%2Cprogrammable%20e-paper%20tag%5Ca58%2C200%2C20%2Clink%5Ct86%2C203%2C4%2Chttps%3A%2F%2Fggtag.io&#34;&gt;demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ggtag.io/?i=%5Cr10%2C25%2C110%2C110%5CI15%2C30%2C100%2C100%2C0%2Chttps%3A%2F%2Favatars.githubusercontent.com%2Fu%2F583231%5Ct140%2C50%2C5%2CThe%20Octocat%5Ct140%2C80%2C2%2Cgithub.com%2Foctocat%5Ca13%2C156%2C16%2Cmap-marker-alt%5Ct33%2C158%2C2%2CSan%20Francisco%5Ca13%2C183%2C16%2Cbuilding%5Ct33%2C185%2C2%2C%40github%5Ca180%2C154%2C16%2Clink%5Ct202%2C158%2C2%2Chttps%3A%2F%2Fgithub.blog%5Ca180%2C185%2C16%2Cenvelope%5Ct202%2C185%2C2%2Coctocat%40github.com&#34;&gt;octocat&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ggtag.io/?i=%5CI17%2C19%2C0%2C0%2C0%2Chttps%3A%2F%2Fggtag.io%2Fmario.png%5Ct144%2C42%2C5%2CSUPER%20MARIO%5Ct146%2C75%2C4%2Cplumber%5Ca30%2C165%2C23%2Cphone-alt%5Ct68%2C168%2C3%2C08812345%5Ca30%2C208%2C23%2Cenvelope%5Ct68%2C210%2C3%2Cm%40ggtag.io%5Ca215%2C165%2C23%2Cglobe%5Ct248%2C167%2C3%2Cggtag.io%5Ca217%2C203%2C23%2Cmap-marker-alt%5Ct248%2C208%2C3%2CSofia&#34;&gt;mario&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ggtag.io/?i=%5Ca20%2C20%2C75%2Cwifi%5Cq254%2C16%2C3%2CWIFI%3AS%3AWelcome%20To%20Hell%3BT%3AWPA%3BP%3A12345678%3B%3B%5Ct1%2C159%2C5%2CSSID%3A%20Welcome%20To%20Hell%5Ct1%2C189%2C5%2C%20PWD%3A%2012345678&#34;&gt;wifi&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both firmware and hardware are open source and licensed under the GPLv3 license. The PCB is made by &lt;a href=&#34;http://www.eurolan.net/&#34;&gt;Eurolan&lt;/a&gt;, you can find more details about the hardware design in the &lt;a href=&#34;https://raw.githubusercontent.com/rgerganov/ggtag/master/hardware&#34;&gt;hardware&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;ggtag&lt;/code&gt; can be programmed either with sound or with USB serial. To program with sound, you need to put a CR2032 battery in the battery holder and flip the switch to the &lt;code&gt;BATT&lt;/code&gt; position. To program with USB serial, you need to connect &lt;code&gt;ggtag&lt;/code&gt; to a USB host and flip the switch to the &lt;code&gt;USB&lt;/code&gt; position. Both programming modes are supported in the web interface hosted at &lt;a href=&#34;https://ggtag.io&#34;&gt;ggtag.io&lt;/a&gt;, all you need is a modern HTML browser.&lt;/p&gt; &#xA;&lt;h2&gt;Programming with sound&lt;/h2&gt; &#xA;&lt;p&gt;Here is a demonstration of how programming with sound works. Initially, three ggtags are listening and then programmed simultaneously using mobile phone. After the initial programming, you need to press the button on the side for ggtag to start listening again. At the end make sure to flip the switch back to &lt;code&gt;USB&lt;/code&gt; position in order to preserve the battery.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/271616/233822561-fff766fd-9242-4774-a4a4-4f87c363f370.mp4&#34;&gt;https://user-images.githubusercontent.com/271616/233822561-fff766fd-9242-4774-a4a4-4f87c363f370.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Programming with USB serial&lt;/h2&gt; &#xA;&lt;p&gt;The web interface is using &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Web_Serial_API&#34;&gt;Web Serial API&lt;/a&gt; for USB serial programming, so you need a web browser (e.g. Chrome, Edge) which supports this API. Mobile Chrome running on Android is also supported. Here is a demo of using Pixel5 phone for USB serial programming:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rgerganov/ggtag/assets/271616/d471cdec-4e41-4382-ae9f-f745ea71745e&#34;&gt;https://github.com/rgerganov/ggtag/assets/271616/d471cdec-4e41-4382-ae9f-f745ea71745e&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Emulating RFID tags&lt;/h2&gt; &#xA;&lt;p&gt;You can emulate 125kHz RFID tags with ggtag. This is accomplished with an ATtiny85 MCU and the &lt;a href=&#34;https://github.com/scanlime/navi-misc/raw/master/avrfid/avrfid.S&#34;&gt;avrfid&lt;/a&gt; firmware. When ggtag receives an RFID command, it generates the corresponding avrfid firmware and programs the ATtiny85 with it. Demo with Flipper Zero:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rgerganov/ggtag/assets/271616/654c1e1a-a8cb-4189-a39e-80669b1f9637&#34;&gt;https://github.com/rgerganov/ggtag/assets/271616/654c1e1a-a8cb-4189-a39e-80669b1f9637&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Another demo with USB RFID reader:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rgerganov/ggtag/assets/271616/f1d7bd59-880e-44ea-8732-c919e1119cd3&#34;&gt;https://github.com/rgerganov/ggtag/assets/271616/f1d7bd59-880e-44ea-8732-c919e1119cd3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Python examples&lt;/h2&gt; &#xA;&lt;p&gt;There is a &lt;code&gt;ggtag&lt;/code&gt; python package which can be used together with &lt;code&gt;pyserial&lt;/code&gt; or &lt;code&gt;ggwave&lt;/code&gt; to program the device. See the &lt;a href=&#34;https://raw.githubusercontent.com/rgerganov/ggtag/master/examples/&#34;&gt;examples&lt;/a&gt; folder for more details.&lt;/p&gt; &#xA;&lt;h1&gt;Known issues&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;With some RFID readers you need to keep &lt;code&gt;ggtag&lt;/code&gt; at 1cm distance for read to be successful.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggerganov/ggwave&#34;&gt;ggwave&lt;/a&gt; (MIT license)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ArmDeveloperEcosystem/microphone-library-for-pico/&#34;&gt;microphone-library-for-pico&lt;/a&gt; (Apache 2.0 license)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/waveshare/Pico_ePaper_Code&#34;&gt;Pico_ePaper_Code&lt;/a&gt; (GPLv3 license)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nayuki/QR-Code-generator&#34;&gt;QR-Code-generator&lt;/a&gt; (MIT license)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google/web-serial-polyfill&#34;&gt;Serial API Polyfill&lt;/a&gt; (Apache 2.0 license)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/scanlime/navi-misc/raw/master/avrfid/avrfid.S&#34;&gt;avrfid&lt;/a&gt; (BSD license)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nothings/stb/raw/master/stb_truetype.h&#34;&gt;stb_truetype&lt;/a&gt; (MIT license)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://fontawesome.com/&#34;&gt;Font Awesome&lt;/a&gt; (CC BY 3.0 license)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Project structure&lt;/h1&gt; &#xA;&lt;p&gt;The codebase is structured in the following way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;target&lt;/code&gt; - contains the firmware source code for RP2040&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;shared&lt;/code&gt; - contains the shared code between the firmware and the host library&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;host&lt;/code&gt; - contains the host library&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docs&lt;/code&gt; - contains the web interface&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;python&lt;/code&gt; - contains Python bindings for the host library&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;examples&lt;/code&gt; - contains some examples&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hardware&lt;/code&gt; - contains hardware design files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building the firmware&lt;/h2&gt; &#xA;&lt;p&gt;Follow these steps to build the RP2040 firmware:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/raspberrypi/pico-sdk&#xA;cd pico-sdk&#xA;git submodule init&#xA;git submodule update&#xA;cd ..&#xA;git clone https://github.com/raspberrypi/pico-extras&#xA;cd pico-extra&#xA;git submodule init&#xA;git submodule update&#xA;cd ..&#xA;export PICO_SDK_PATH=&amp;lt;full_path_to_pico_sdk&amp;gt;&#xA;export PICO_EXTRAS_PATH=&amp;lt;full_path_to_pico_extras&amp;gt;&#xA;export PICO_TOOLCHAIN_PATH=&amp;lt;full_path_to_arm_toolchain&amp;gt;&#xA;&#xA;git clone git@github.com:rgerganov/ggtag&#xA;cd ggtag&#xA;git submodule init&#xA;git submodule update&#xA;mkdir build&#xA;cd build&#xA;cmake .. -DPICO_BOARD=pico&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building the web interface&lt;/h2&gt; &#xA;&lt;p&gt;The host library is compiled to WASM using &lt;a href=&#34;https://emscripten.org/&#34;&gt;Emscripten&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;source &amp;lt;path_to_emsdk_env.sh&amp;gt;&#xA;CXX=emcc make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can start a local server with &lt;code&gt;make server&lt;/code&gt; and access the web interface at &lt;a href=&#34;http://localhost:8000&#34;&gt;http://localhost:8000&lt;/a&gt;. There is a hosted version available at &lt;a href=&#34;https://ggtag.io&#34;&gt;https://ggtag.io&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Flashing the firmware&lt;/h2&gt; &#xA;&lt;p&gt;Put ggtag into USB mode, press and hold the button and plug the USB cable. Download the latest firmware &lt;a href=&#34;https://github.com/rgerganov/ggtag/releases&#34;&gt;release&lt;/a&gt; and copy the &lt;code&gt;.uf2&lt;/code&gt; file to the &lt;code&gt;RPI-RP2&lt;/code&gt; drive. The tag will reboot and run the new firmware.&lt;/p&gt;</summary>
  </entry>
</feed>