<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-11T01:32:13Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lem0nSec/ShellGhost</title>
    <updated>2023-07-11T01:32:13Z</updated>
    <id>tag:github.com,2023-07-11:/lem0nSec/ShellGhost</id>
    <link href="https://github.com/lem0nSec/ShellGhost" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A memory-based evasion technique which makes shellcode invisible from process start to end.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ShellGhost&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/ShellGhost/master/pictures/logo.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;A memory-based evasion technique which makes shellcode invisible from process start to end.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;I wanted to share this shellcode self-injection POC to showcase some AV/EDR evasion concepts that may turn useful for Red Teaming. Just a few weeks ago I came up with a custom in-memory evasion technique which I named ShellGhost. This technique stems from the need for having &lt;strong&gt;a code that executes an &#39;invisible&#39; shellcode from process start to finish&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Handling the Thread Execution Flow&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;ShellGhost relies on Vectored Exception Handling in combination with software breakpoints&lt;/strong&gt; to cyclically stop thread execution, replace the executed breakpoint with a RC4-encrypted shellcode instruction, decrypt the instruction and resume execution after restoring memory protection to RX. When the subsequent EXCEPTION_BREAKPOINT is raised, the exception handler replaces the previous shellcode instruction with a new breakpoint so that the allocation will never disclose the complete shellcode in an unencrypted state. This happens inside a private memory page which is initially marked as READ/WRITE. Having a RW PRV allocation will not be considered an &#39;Indicator of Compromise&#39; by memory scanners such as PE-Sieve and Moneta. When the allocation becomes RX and the page is scanned, nothing but breakpoints will be found. This happens while the shellcode is actually under execution. The following picture shows that a reverse shell is running, but no IOC is found by Moneta (other than the binary being unsigned).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/ShellGhost/master/pictures/moneta_detection.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Trying to scan the process with Pe-Sieve has an even better outcome:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/ShellGhost/master/pictures/pe-sieve.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Shellcode Mapping&lt;/h2&gt; &#xA;&lt;p&gt;Shellcode Mapping is the core functionality of ShellGhost. This tactic enables the thread to intermittently execute instructions while never exposing the entire shellcode in memory. This is possible because the position of each single shellcode instruction that the thread executes corresponds to the position of a certain breakpoint inside the allocated memory page. ShellGhost resolves this position by calculating the Relative Virtual Address (RVA) from the thread RIP to the base address of the allocated memory page and adds it to the base address of the encrypted shellcode / encrypted instructions. The number of breakpoints that will be replaced is not always the same, but it varies depending on the number of opcodes that each instruction needs to be correctly generated and interpreted (QUOTA). So for example the instruction &#39;POP RBP&#39; is equal to &#39;5D&#39;, which means only one breakpoint will be replaced. By contrast, the instruction &#39;JMP RAX&#39; requires opcodes &#39;FF E0&#39;, so two breakpoints will be replaced. For this reason I created the following C data structure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct CRYPT_BYTES_QUOTA {&#xA;&#xA;&#x9;DWORD RVA;&#x9;&#x9;// offset to encrypted instruction &#xA;&#x9;DWORD quota;&#x9;// number of opcodes that generate the instruction&#xA;&#xA;} CRYPT_BYTES_QUOTA, * PCRYPT_BYTES_QUOTA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Breakpoints are not immediately replaced with their instruction counterparts. This is because instructions need to undergo a decryption routine before being executed. This is where the &lt;code&gt;DWORD quota&lt;/code&gt; comes into play. ShellGhost relies on the now popular &#39;SystemFunction032&#39; to perform RC4 decryption. Unlike XOR, RC4 is not a single-byte encryption scheme. This means that the shellcode cannot be encrypted and decrypted all at once. This is also another reason why each instruction is treated separately. After the breakpoints are replaced, the buffer length that SystemFunction032 needs will be equal to the &#39;instruction quota&#39;, which again represents the number of opcodes the specific instruction is composed of. So for example, consider the following snippet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&#xA;CRYPT_BYTES_QUOTA instruction[200];&#xA;instruction[5].quota = 2&#xA;&#xA;USTRING buf = { 0 }; &#x9;// will contain the buffer to be decrypted and its length&#xA;USTRING key = { 0 }; &#x9;// will contain the RC4 key and length&#xA;&#xA;buf.Length = 2 &#x9;&#x9;// buffer length, or length of the instruction to be decrypted&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We know that shellcode instruction number 5 is composed of 2 opcodes, so a buffer length of 2 will be passed to SystemFunction032. This is important because trying to decrypt the entire shellcode with a single call to SystemFunction032 will corrupt it entirely.&lt;/p&gt; &#xA;&lt;h3&gt;How is Shellcode Mapping performed?&lt;/h3&gt; &#xA;&lt;p&gt;The shellcode needs to be mapped with &lt;code&gt;ShellGhost_mapping.py&lt;/code&gt; before compilation. The script extracts each single instruction and treats it as a small and independent shellcode. Instructions are encrypted one by one and printed out in C format all together as unsigned char. The result can be hardcoded inside the C code. Below is an example of what an encrypted MSF shellcode instructions for calc.exe looks like.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/ShellGhost/master/pictures/shellcode_mapping_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This shellcode has 98 instructions, so 98 CRYPT_BYTES_QUOTA structs are declared. When the code executes, these structs have to be populated with the proper instructions RVAs and QUOTAs. The &#39;-1&#39; parameter instructs the mapping script to print out the piece of code that does this.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/ShellGhost/master/pictures/shellcode_mapping_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Adjusting Winapi Parameters&lt;/h2&gt; &#xA;&lt;p&gt;Metasploit x64 shellcodes tipically have winapi string parameters stored between instructions. So to say, a MSF x64 shellcode that calls Winexec does not push a series of bytes with a nullbyte at the end to have the first parameter string on the stack. Rather, the RCX register (first parameter) is a pointer inside the shellcode itself just like the following picture.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/ShellGhost/master/pictures/msf_jmp_rax.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This means that the breakpoints whose position relates to the string will never be resolved, because the RIP will never touch that position. As a matter of fact, this code resolves actual shellcode instructions the RIP goes through, not parameters that will never be executed like instructions. To fix this, I noticed that MSF shellcodes always store a pointer to the winapi they are calling inside the RAX register, then make a jump to the register itself. So when ShellGhost VEH detects that the resolved breakpoint is &#39;JMP RAX&#39; and the RCX register contains a pointer to a position inside the shellcode, it attempts to also resolve what pointed by RCX. Subsequently, execution is not returned to the allocated memory. Rather, RAX (winapi address) is copied into RIP and thread execution is resumed from the winapi, thus overriding the &#39;JMP RAX&#39; and keeping the allocated memory RW. This is needed for reverse shells calling WaitForSingleObject, which would cause the thread to sleep after the &#39;JMP RAX&#39; while leaving memory RX for as long as the shell remains alive. The following code snippet contains the two conditions that has to be met in order for ShellGhost to adjust the RCX register when it contains a winapi parameter string and allow the MSF shellcode to correctly issue the function call (WinExec in the example here).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;lt;snip&amp;gt;&#xA;&#x9;&#xA;if (*(WORD*)(WORD*)exceptionData-&amp;gt;ContextRecord-&amp;gt;Rip == 0xe0ff) // if RIP is &#39;JMP RAX&#39;&#xA;&#xA;&amp;lt;snip&amp;gt;&#xA;&#xA;if ((contextRecord-&amp;gt;Rcx &amp;gt;= (DWORD64)allocation_base) &amp;amp;&amp;amp; (contextRecord-&amp;gt;Rcx &amp;lt;= ((DWORD64)allocation_base + sizeof(sh)))) // if RCX is inside the allocation&#xA;&#xA;&amp;lt;snip&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;RDX, R8 and R9 (second, third, and fourth parameters) are not covered yet.&lt;/p&gt; &#xA;&lt;h2&gt;Differences and Similarities with other Techniques&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mgeeky/ShellcodeFluctuation&#34;&gt;ShellcodeFluctuation&lt;/a&gt; is a very similar in-memory evasion concept. Just like it, the allocated memory here &#39;fluctuates&#39; from RW to RX. In contrast, ShellGhost introduces the following improvements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RC4 encryption plus &#39;Shellcode Mapping&#39; rather than single-byte XOR&lt;/li&gt; &#xA; &lt;li&gt;No need to hook functions&lt;/li&gt; &#xA; &lt;li&gt;Support for Metasploit shellcodes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;ShellGhost is far from being a perfect technique though. It still suffers from the biggest downside all these techniques have, namely &lt;strong&gt;the need to have private executable memory at some point during execution&lt;/strong&gt;. More advanced techniques like Foliage already found a way around this. In addition, a memory allocation full of software breakpoints can be detected by a YARA rule. The following picture shows Moneta correctly detecting an IOC for the RX PRV allocation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/ShellGhost/master/pictures/moneta_detection_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When it comes to evading an EDR solution, memory scanning is just part of a bigger picture. The complete absence of IOCs does not necessarily mean that a binary using this technique will prove effective against a given EDR. As far as I can tell, I experienced situations when the solution does not even allow you to launch the binary the way you&#39;re doing it. The other side of the medal is that IOCs are not always precise indicators, and some of them may turn out to be false positives. With that being said, this is just a raw technique and an inspiration which I hope the reader appreciates. The Red Teamer knows that just like the components of an EDR, in-memory evasion is only one component of the engine.&lt;/p&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;p&gt;Compilation requires disabling incremental linking. This VS project has all compiler/linker options already set.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>termux/termux-x11</title>
    <updated>2023-07-11T01:32:13Z</updated>
    <id>tag:github.com,2023-07-11:/termux/termux-x11</id>
    <link href="https://github.com/termux/termux-x11" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Termux X11 add-on application. Still in early development.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Termux:X11&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/termux/termux-x11/actions/workflows/debug_build.yml&#34;&gt;&lt;img src=&#34;https://github.com/termux/termux-x11/actions/workflows/debug_build.yml/badge.svg?branch=master&#34; alt=&#34;Nightly build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/termux/termux&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/termux/termux.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/termux/termux&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/HXpF69X&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/641256914684084234?label=&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;color=5865F2&#34; alt=&#34;Join the Termux discord server&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://termux.com&#34;&gt;Termux&lt;/a&gt; X11 server add-on app.&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Termux:X11 is a fully fledged X server. It is built with Android NDK and optimized to be used with Termux.&lt;/p&gt; &#xA;&lt;h2&gt;Submodules caveat&lt;/h2&gt; &#xA;&lt;p&gt;This repo uses submodules. Use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~ $ git clone --recurse-submodules https://github.com/termux/termux-x11 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~ $ git clone https://github.com/termux/termux-x11&#xA;~ $ cd termux-x11&#xA;~ $ git submodule update --init --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How does it work?&lt;/h2&gt; &#xA;&lt;p&gt;Just like any other X server.&lt;/p&gt; &#xA;&lt;h2&gt;Setup Instructions&lt;/h2&gt; &#xA;&lt;p&gt;For this one you must enable the &lt;code&gt;x11-repo&lt;/code&gt; repository can be done by executing &lt;code&gt;pkg install x11-repo&lt;/code&gt; command&lt;/p&gt; &#xA;&lt;p&gt;For X applications to work, you must install Termux-x11 companion package. You can do that by downloading an artifact from &lt;a href=&#34;https://github.com/termux/termux-x11/actions/workflows/debug_build.yml&#34;&gt;last successful build&lt;/a&gt; and installing &lt;code&gt;*.apk&lt;/code&gt; and &lt;code&gt;*.deb&lt;/code&gt; (if you use termux with &lt;code&gt;pkg&lt;/code&gt;) or &lt;code&gt;*.tar.xz&lt;/code&gt; (if you use termux with &lt;code&gt;pacman&lt;/code&gt;) files. Or you can install nightly companion package from repositories with &lt;code&gt;pkg in x11-repo &amp;amp;&amp;amp; pkg in termux-x11-nightly&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Running Graphical Applications&lt;/h2&gt; &#xA;&lt;p&gt;You can start your desired graphical application by doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~ $ termux-x11 :1 &amp;amp;&#xA;~ $ env DISPLAY=:1 dbus-launch --exit-with-session xfce4-session&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~ $ termux-x11 :1 -xstartup &#34;dbus-launch --exit-with-session xfce4-session&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may replace &lt;code&gt;xfce4-session&lt;/code&gt; if you use other than Xfce&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;dbus-launch&lt;/code&gt; does not work for some users so you can start session with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~ $ termux-x11 :1 -xstartup &#34;xfce4-session&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re done using Termux:X11 just simply exit it through it&#39;s notification drawer by expanding the Termux:X11 notification then &#34;Exit&#34; But you should pay attention that &lt;code&gt;termux-x11&lt;/code&gt; command is still running and can not be killed this way.&lt;/p&gt; &#xA;&lt;h2&gt;Using with proot environment&lt;/h2&gt; &#xA;&lt;p&gt;If you plan to use the program with proot, keep in mind that you need to launch proot/proot-distro with the --shared-tmp option. If passing this option is not possible, set the TMPDIR environment variable to point to the directory that corresponds to /tmp in the target container. If you are using proot-distro you should know that it is possible to start &lt;code&gt;termux-x11&lt;/code&gt; command from inside proot container.&lt;/p&gt; &#xA;&lt;h2&gt;Using with chroot environment&lt;/h2&gt; &#xA;&lt;p&gt;If you plan to use the program with chroot or unshare, you must to run it as root and set the TMPDIR environment variable to point to the directory that corresponds to /tmp in the target container. This directory must be accessible from the shell from which you launch termux-x11, i.e. it must be in the same SELinux context, same mount namespace, and so on. Also you must set &lt;code&gt;XKB_CONFIG_ROOT&lt;/code&gt; environment variable pointing to container&#39;s &lt;code&gt;/usr/share/X11/xkb&lt;/code&gt; directory, otherwise you will have &lt;code&gt;xkbcomp&lt;/code&gt;-related errors. You can get loader for nightly build from an artifact of &lt;a href=&#34;https://github.com/termux/termux-x11/actions/workflows/debug_build.yml&#34;&gt;last successful build&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export TMPDIR=/path/to/chroot/container/tmp&#xA;export CLASSPATH=$(/system/bin/pm path com.termux.x11 | cut -d: -f2)&#xA;/system/bin/app_process / com.termux.x11.CmdEntryPoint :0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Logs&lt;/h3&gt; &#xA;&lt;p&gt;If you need to obtain logs from the &lt;code&gt;com.termux.x11&lt;/code&gt; application, set the &lt;code&gt;TERMUX_X11_DEBUG&lt;/code&gt; environment variable to 1, like this: &lt;code&gt;TERMUX_X11_DEBUG=1 termux-x11 :0&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The log obtained in this way can be quite long. It&#39;s better to redirect the output of the command to a file right away.&lt;/p&gt; &#xA;&lt;h3&gt;Notification&lt;/h3&gt; &#xA;&lt;p&gt;In Android 13 post notifications was restricted so you should explicitly let Termux:X11 show you notifications.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Video&lt;/summary&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/9674930/227760411-11d440eb-90b8-451e-9024-d5a194d10b16.webm&#34;&gt;img_enable-notifications.webm&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Preferences: You can access preferences menu three ways:&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;By clicking &#34;PREFERENCES&#34; button on main screen when no client connected.&lt;/summary&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/termux/termux-x11/master/img/1.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;By clicking &#34;Preferences&#34; button in notification, if available.&lt;/summary&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/termux/termux-x11/master/img/2.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;By clicking &#34;Preferences&#34; application shortcut (long tap `Termux:X11` icon in launcher). &lt;/summary&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/termux/termux-x11/master/img/3.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Touch gestures&lt;/h2&gt; &#xA;&lt;h3&gt;Touchpad emulation mode.&lt;/h3&gt; &#xA;&lt;p&gt;In touchpad emulation mode you can use the following gestures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tap for click&lt;/li&gt; &#xA; &lt;li&gt;Double tap for double click&lt;/li&gt; &#xA; &lt;li&gt;Two-finger tap for right click&lt;/li&gt; &#xA; &lt;li&gt;Three-finger tap for middle click&lt;/li&gt; &#xA; &lt;li&gt;Two-finger vertical swipe for vertical scroll&lt;/li&gt; &#xA; &lt;li&gt;Two-finger horizontal swipe for horizontal scroll&lt;/li&gt; &#xA; &lt;li&gt;Three-finger swipe down to show-hide additional keys bar.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Mouse emulation mode.&lt;/h3&gt; &#xA;&lt;p&gt;In touchpad emulation mode you can use the following gestures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mouse is in click mode as long as you hold finger on a screen.&lt;/li&gt; &#xA; &lt;li&gt;Double tap for double click&lt;/li&gt; &#xA; &lt;li&gt;Two-finger tap for right click&lt;/li&gt; &#xA; &lt;li&gt;Three-finger tap for middle click&lt;/li&gt; &#xA; &lt;li&gt;Two-finger vertical swipe for vertical scroll&lt;/li&gt; &#xA; &lt;li&gt;Two-finger horizontal swipe for horizontal scroll&lt;/li&gt; &#xA; &lt;li&gt;Three-finger swipe down to show-hide additional keys bar.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Font or scaling is too big!&lt;/h2&gt; &#xA;&lt;p&gt;Some apps may have issues with X server regarding DPI. please see &lt;a href=&#34;https://wiki.archlinux.org/title/HiDPI&#34;&gt;https://wiki.archlinux.org/title/HiDPI&lt;/a&gt; on how to override application-specific DPI or scaling.&lt;/p&gt; &#xA;&lt;p&gt;You can fix this in your window manager settings (in the case of xfce4 and lxqt via Applications Menu &amp;gt; Settings &amp;gt; Appearance). Look for the DPI value, if it is disabled enable it and adjust its value until the fonts are the appropriate size.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Screenshot &lt;/summary&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/termux/termux-x11/master/img/dpi-scale.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Also you can start &lt;code&gt;termux-x11&lt;/code&gt; with &lt;code&gt;-dpi&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~ $ termux-x11 :1 -xstartup &#34;xfce4-session&#34; -dpi 120&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using with 3rd party apps&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to use Termux:X11 with 3rd party apps. Check how &lt;code&gt;shell-loader/src/main/java/com/termux/x11/Loader.java&lt;/code&gt; works.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Released under the &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.html&#34;&gt;GPLv3 license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>