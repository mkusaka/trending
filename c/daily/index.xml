<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-04T01:31:24Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>oracle-samples/bpftune</title>
    <updated>2023-07-04T01:31:24Z</updated>
    <id>tag:github.com,2023-07-04:/oracle-samples/bpftune</id>
    <link href="https://github.com/oracle-samples/bpftune" rel="alternate"></link>
    <summary type="html">&lt;p&gt;bpftune uses BPF to auto-tune Linux systems&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bpftune - BPF driven auto-tuning&lt;/h1&gt; &#xA;&lt;p&gt;bpftune aims to provide lightweight, always-on auto-tuning of system behaviour. The key benefit it provides are&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;by using BPF observability features, we can continuously monitor and adjust system behaviour&lt;/li&gt; &#xA; &lt;li&gt;because we can observe system behaviour at a fine grain (rather than using coarse system-wide stats), we can tune at a finer grain too (individual socket policies, individual device policies etc)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;The problem&lt;/h2&gt; &#xA;&lt;p&gt;The Linux kernel contains a large number of tunables; these often take the form of sysctl(8) parameters, and are usually introduced for situations where there is no one &#34;right&#34; answer for a configuration choice. The number of tunables available is quite daunting. On a 6.2 kernel we see&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# sysctl --all 2&amp;gt;/dev/null|wc -l&#xA;1624&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At the same time, individual systems get a lot less care and adminstrator attention than they used to; phrases like &#34;cattle not pets&#34; exemplify this. Given the modern cloud architectures used for most deployments, most systems never have any human adminstrator interaction after initial provisioning; in fact given the scale requirements, this is often an explicit design goal - &#34;no ssh&#39;ing in!&#34;.&lt;/p&gt; &#xA;&lt;p&gt;These two observations are not unrelated; in an earlier era of fewer, larger systems, tuning by administrators was more feasible.&lt;/p&gt; &#xA;&lt;p&gt;These trends - system complexity combined with minimal admin interaction suggest a rethink in terms of tunable management.&lt;/p&gt; &#xA;&lt;p&gt;A lot of lore accumulates around these tunables, and to help clarify why we developed bpftune, we will use a straw-man version of the approach taken with tunables:&lt;/p&gt; &#xA;&lt;p&gt;&#34;find the set of magic numbers that will work for the system forever&#34;&lt;/p&gt; &#xA;&lt;p&gt;This is obviously a caricature of how administrators approach the problem, but it does highlight a critical implicit assumption - that systems are static.&lt;/p&gt; &#xA;&lt;p&gt;And that gets to the &#34;BPF&#34; in bpftune; BPF provides means to carry out low-overhead observability of systems. So not only can we observe the system and tune appropriately, we can also observe the effect of that tuning and re-tune if necessary.&lt;/p&gt; &#xA;&lt;h2&gt;Key design principles&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Minimize overhead. Use observability features sparingly; do not trace very high frequency events.&lt;/li&gt; &#xA; &lt;li&gt;Be explicit about policy changes providing both a &#34;what&#34; - what change was made - and a &#34;why&#34; - how does it help? syslog logging makes policy actions explicit with explanations&lt;/li&gt; &#xA; &lt;li&gt;Get out of the way of the administrator. We can use BPF observability to see if the admin sets tunable values that we are auto-tuning; if they do, we need to get out of the way and disable auto-tuning of the related feature set.&lt;/li&gt; &#xA; &lt;li&gt;Don&#39;t replace tunables with more tunables! bpftune is designed to be zero configuration; there are no options, and we try to avoid magic numbers where possible.&lt;/li&gt; &#xA; &lt;li&gt;Use push-pull approaches. For example, with tcp buffer sizing, we often want to get out of the way of applications and bump up tcp sndbuf and rcvbuf, but at a certain point we run the risk of exhausting TCP memory. We can however monitor if we are approaching TCP memory pressure and if so we can tune down values that we&#39;ve tuned up. In this way, we can let the system find a balance between providing resources and exhausting them. In some cases, we won&#39;t need to tune up values; they may be fine as they are. But in other cases these limits block optimal performance, and if they are raised safely - with awareness of global memory limits - we can get out the way of improved performance. Another concern is that increasing buffer size leads to latency - to handle that, we correlate buffer size changes and TCP smoothed round-trip time; if the correlation between these exceeds a threshold (0.7) we stop increasing buffer size.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Concepts&lt;/h2&gt; &#xA;&lt;p&gt;The key components are&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;tuners: each tuner manages tunables and handles events sent from BPF programs to userspace via the shared ring buffer. Each tuner has an associated set of tunables that it manages.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;events specify a&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;tuner id: which tuner the event is destined for&lt;/li&gt; &#xA;   &lt;li&gt;a scenario: what happened&lt;/li&gt; &#xA;   &lt;li&gt;an associated netns (if supported)&lt;/li&gt; &#xA;   &lt;li&gt;information about the event (IP address etc)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the tuner then responds to the event with a strategy; increase or decrease a tunable value, etc. Describing the event in the log is key; this allows an admin to understand what changed and why.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;bpftune is a daemon which manages a set of .so plugin tuners; each of these is a shared object that is loaded on start-up.&lt;/li&gt; &#xA; &lt;li&gt;tuners can be enabled or disabled; a tuner is automatically disabled if the admin changes associated tunables manually.&lt;/li&gt; &#xA; &lt;li&gt;tuners share a global BPF ring buffer which allows posting of events from BPF programs to userspace. For example, if the sysctl tuner sees a systl being set, it posts an event.&lt;/li&gt; &#xA; &lt;li&gt;each tuner has an associated id (set when it is loaded), and events posted contain the tuner id.&lt;/li&gt; &#xA; &lt;li&gt;each tuner has a BPF component (built using a BPF skeleton) and a userspace component. The latter has init(), fini() and event_handler() entrypoints. When an event is received, the tuner id is used to identify the appropriate event handler and its event_handler() callback function is run.&lt;/li&gt; &#xA; &lt;li&gt;init, fini and event_handler functions are loaded from the tuner .so object.&lt;/li&gt; &#xA; &lt;li&gt;BPF components should include bpftune.bpf.h; it contains the common map definitions (ringbuf, etc) and shared variables such as learning rate and tuner ids that each tuner needs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported tuners&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;congestion tuner: auto-tune choice of congestion control algorithm. See bpftune-tcp-cong (8).&lt;/li&gt; &#xA; &lt;li&gt;neighbour table tuner: auto-tune neighbour table sizes by growing tables when approaching full. See bpftune-neigh (8).&lt;/li&gt; &#xA; &lt;li&gt;route table tuner: auto-tune route table size by growing tables when approaching full. See bpftune-route (8).&lt;/li&gt; &#xA; &lt;li&gt;sysctl tuner: monitor sysctl setting and if it collides with an auto-tuned sysctl value, disable the associated tuner. See bpftune-sysctl (8).&lt;/li&gt; &#xA; &lt;li&gt;TCP buffer tuner: auto-tune max and initial buffer sizes. See bpftune-tcp-buffer (8).&lt;/li&gt; &#xA; &lt;li&gt;net buffer tuner: auto-tune tunables related to core networking. See bpftune-net-buffer (8).&lt;/li&gt; &#xA; &lt;li&gt;netns tuner: notices addition and removal of network namespaces, which helps power namespace awareness for bpftune as a whole. Namespace awareness is important as we want to be able to auto-tune containers also. See bpftune-netns (8).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Code organization&lt;/h2&gt; &#xA;&lt;p&gt;Both core bpftune.c and individual tuners use the libbpftune library. It handles logging, tuner init/fini, and BPF init/fini.&lt;/p&gt; &#xA;&lt;p&gt;Each tuner shared object defines an init(), fini() and event_handler() function. These respectively set up and clean up BPF and handle events that originate from the BPF code.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;If building the repository manually, simply run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make ; sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;at the top-level of the repository. bpftune also supports a&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make pkg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;target, which will make a bpftune RPM. See ./buildrpm/bpftune.spec&lt;/p&gt; &#xA;&lt;p&gt;To build the following packages are needed (names may vary by distro);&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;libbpf, libbpf-devel &amp;gt;= 0.6&lt;/li&gt; &#xA; &lt;li&gt;libcap-devel&lt;/li&gt; &#xA; &lt;li&gt;bpftool &amp;gt;= 4.18&lt;/li&gt; &#xA; &lt;li&gt;libnl3-devel&lt;/li&gt; &#xA; &lt;li&gt;clang &amp;gt;= 11&lt;/li&gt; &#xA; &lt;li&gt;llvm &amp;gt;= 11&lt;/li&gt; &#xA; &lt;li&gt;python3-docutils&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To enable bpftune as a service&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo service bpftune start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...and to enable it by default&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo systemctl enable bpftune&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;bpftune logs to syslog so /var/log/messages will contain details of any tuning carried out.&lt;/p&gt; &#xA;&lt;p&gt;bpftune can also be run in the foreground as a program; to redirect output to stdout/stderr, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo bpftune -s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On exit, bpftune will summarize any tuning done.&lt;/p&gt; &#xA;&lt;h2&gt;Tests&lt;/h2&gt; &#xA;&lt;p&gt;Tests are supplied for each tuner in the tests/ subdirectory. &#34;make test&#34; runs all the tests. Tests use network namespaces to simulate interactions with remote hosts. See ./TESTING.md for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This project welcomes contributions from the community. Before submitting a pull request, please &lt;a href=&#34;https://raw.githubusercontent.com/oracle-samples/bpftune/main/CONTRIBUTING.md&#34;&gt;review our contribution guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Please consult the &lt;a href=&#34;https://raw.githubusercontent.com/oracle-samples/bpftune/main/SECURITY.md&#34;&gt;security guide&lt;/a&gt; for our responsible security vulnerability disclosure process&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2023 Oracle and/or its affiliates.&lt;/p&gt; &#xA;&lt;p&gt;This software is available to you under&lt;/p&gt; &#xA;&lt;p&gt;SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note&lt;/p&gt; &#xA;&lt;p&gt;Being under the terms of the GNU General Public License version 2.&lt;/p&gt; &#xA;&lt;p&gt;SPDX-URL: &lt;a href=&#34;https://spdx.org/licenses/GPL-2.0.html&#34;&gt;https://spdx.org/licenses/GPL-2.0.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/oracle-samples/bpftune/main/LICENSE.txt&#34;&gt;the license file&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Does my system support bpftune?&lt;/h2&gt; &#xA;&lt;p&gt;Simply run &#34;bpftune -S&#34; to see:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bpftune -S&#xA;bpftune works fully&#xA;bpftune supports per-netns policy (via netns cookie)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Two aspects are important here&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;does the system support fentry/fexit etc? If so full support is likely.&lt;/li&gt; &#xA; &lt;li&gt;does the system support network namespace cookies? If so per-network-namespace policy is supported.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;Simply starting bpftune and observing changes made via /var/log/messages can be instructive. For example, on a standard VM with sysctl defaults, I ran&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ service bpftune start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...and went about normal development activities such as cloning git trees from upstream, building kernels, etc. From the log we see some of the adjustments bpftune made to accommodate these activities&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo grep bpftune /var/log/messages&#xA;...&#xA;Apr 19 16:14:59 bpftest bpftune[2778]: bpftune works fully&#xA;Apr 19 16:14:59 bpftest bpftune[2778]: bpftune supports per-netns policy (via netns cookie)&#xA;Apr 19 16:18:40 bpftest bpftune[2778]: Scenario &#39;specify bbr congestion control&#39; occurred for tunable &#39;TCP congestion control&#39; in global ns. Because loss rate has exceeded 1 percent for a connection, use bbr congestion control algorithm instead of default&#xA;Apr 19 16:18:40 bpftest bpftune[2778]: due to loss events for 145.40.68.75, specify &#39;bbr&#39; congestion control algorithm&#xA;Apr 19 16:26:53 bpftest bpftune[2778]: Scenario &#39;need to increase TCP buffer size(s)&#39; occurred for tunable &#39;net.ipv4.tcp_rmem&#39; in global ns. Need to increase buffer size(s) to maximize throughput&#xA;Apr 19 16:26:53 bpftest bpftune[2778]: Due to need to increase max buffer size to maximize throughput change net.ipv4.tcp_rmem(min default max) from (4096 131072 6291456) -&amp;gt; (4096 131072 7864320)&#xA;Apr 19 16:26:53 bpftest bpftune[2778]: Scenario &#39;need to increase TCP buffer size(s)&#39; occurred for tunable &#39;net.ipv4.tcp_rmem&#39; in global ns. Need to increase buffer size(s) to maximize throughput&#xA;Apr 19 16:26:53 bpftest bpftune[2778]: Due to need to increase max buffer size to maximize throughput change net.ipv4.tcp_rmem(min default max) from (4096 131072 7864320) -&amp;gt; (4096 131072 9830400)&#xA;Apr 19 16:29:04 bpftest bpftune[2778]: Scenario &#39;specify bbr congestion control&#39; occurred for tunable &#39;TCP congestion control&#39; in global ns. Because loss rate has exceeded 1 percent for a connection, use bbr congestion control algorithm instead of default&#xA;Apr 19 16:29:04 bpftest bpftune[2778]: due to loss events for 140.91.12.81, specify &#39;bbr&#39; congestion control algorithm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To deterministically trigger bpftune behaviour, one approach we can take is to download a large file with inappropriate settings.&lt;/p&gt; &#xA;&lt;p&gt;In one window, set tcp rmem max to a too-low value, and run bpftune as a program logging to stdout/stderr (-s):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo sysctl -w net.ipv4.tcp_rmem=&#34;4096 131072 1310720&#34;&#xA;net.ipv4.tcp_rmem = 4096 131072 1310720&#xA;$ sudo bpftune -s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In another window, wget a large file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ wget https://yum.oracle.com/ISOS/OracleLinux/OL8/u7/x86_64/OracleLinux-R8-U7-x86_64-dvd.iso&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the first window, we see bpftune tuning up rmem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bpftune: bpftune works in legacy mode&#xA;bpftune: bpftune does not support per-netns policy (via netns cookie)&#xA;bpftune: Scenario &#39;need to increase TCP buffer size(s)&#39; occurred for tunable &#39;net.ipv4.tcp_rmem&#39; in global ns. Need to increase buffer size(s) to maximize throughput&#xA;bpftune: Due to need to increase max buffer size to maximize throughput change net.ipv4.tcp_rmem(min default max) from (4096 131072 1310720) -&amp;gt; (4096 131072 1638400)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This occurs multiple times, and on exit (Ctrl+C) we see the summary of changes made:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bpftune: Summary: scenario &#39;need to increase TCP buffer size(s)&#39; occurred 9 times for tunable &#39;net.ipv4.tcp_rmem&#39; in global ns. Need to increase buffer size(s) to maximize throughput&#xA;bpftune: sysctl &#39;net.ipv4.tcp_rmem&#39; changed from (4096 131072 1310720 ) -&amp;gt; (4096 131072 9765625 )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;For more info&lt;/h2&gt; &#xA;&lt;p&gt;See the docs/ subdirectory for manual pages covering bpftune and associated tuners.&lt;/p&gt;</summary>
  </entry>
</feed>