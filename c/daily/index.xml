<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-25T01:28:51Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Maldev-Academy/RemoteTLSCallbackInjection</title>
    <updated>2024-01-25T01:28:51Z</updated>
    <id>tag:github.com,2024-01-25:/Maldev-Academy/RemoteTLSCallbackInjection</id>
    <link href="https://github.com/Maldev-Academy/RemoteTLSCallbackInjection" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Utilizing TLS callbacks to execute a payload without spawning any threads in a remote process&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Maldev Academy - RemoteTLSCallbackInjection&lt;/h1&gt; &#xA;&lt;h2&gt;Quick Links&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://maldevacademy.com&#34;&gt;Maldev Academy Home&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://maldevacademy.com/syllabus&#34;&gt;Maldev Academy Syllabus&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Related Maldev Academy Modules&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://maldevacademy.com/new/modules/34&#34;&gt;New Module 34: TLS Callbacks For Anti-Debugging&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://maldevacademy.com/new/modules/35&#34;&gt;New Module 35: Threadless Injection&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This method utilizes TLS callbacks to execute a payload without spawning any threads in a remote process. This method is inspired by &lt;a href=&#34;https://github.com/CCob/ThreadlessInject/tree/master&#34;&gt;Threadless Injection&lt;/a&gt; as RemoteTLSCallbackInjection does not invoke any API calls to trigger the injected payload.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Steps&lt;/h2&gt; &#xA;&lt;p&gt;The PoC follows these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a suspended process using the &lt;code&gt;CreateProcessViaWinAPIsW&lt;/code&gt; function (i.e. &lt;code&gt;RuntimeBroker.exe&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Fetch the remote process image base address followed by reading the process&#39;s PE headers.&lt;/li&gt; &#xA; &lt;li&gt;Fetch an address to a TLS callback function.&lt;/li&gt; &#xA; &lt;li&gt;Patch a fixed shellcode (i.e. &lt;a href=&#34;https://github.com/Maldev-Academy/RemoteTLSCallbackInjection/raw/main/RemoteTLSCallbackInjection/main.c#L56&#34;&gt;g_FixedShellcode&lt;/a&gt;) with runtime-retrieved values. This shellcode is responsible for restoring both original bytes and memory permission of the TLS callback function&#39;s address.&lt;/li&gt; &#xA; &lt;li&gt;Inject both shellcodes: &lt;code&gt;g_FixedShellcode&lt;/code&gt; and the main payload.&lt;/li&gt; &#xA; &lt;li&gt;Patch the TLS callback function&#39;s address and replace it with the address of our injected payload.&lt;/li&gt; &#xA; &lt;li&gt;Resume process.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The &lt;code&gt;g_FixedShellcode&lt;/code&gt; shellcode will then make sure that the main payload executes only once by restoring the original TLS callback&#39;s original address before calling the main payload. A TLS callback can execute multiple times across the lifespan of a process, therefore it is important to control the number of times the payload is triggered by restoring the original code path execution to the original TLS callback function.&lt;/p&gt; &#xA;&lt;h3&gt;Demo&lt;/h3&gt; &#xA;&lt;p&gt;The following image shows our implementation, &lt;code&gt;RemoteTLSCallbackInjection.exe&lt;/code&gt;, spawning a &lt;code&gt;cmd.exe&lt;/code&gt; as its main payload.&lt;/p&gt; &#xA;&lt;img width=&#34;1200px&#34; alt=&#34;demo&#34; src=&#34;https://github.com/Maldev-Academy/RemoteTLSCallbackInjection/assets/111295429/1b1b2c9c-17af-490c-8d77-ea11f53ccfaf&#34;&gt;</summary>
  </entry>
  <entry>
    <title>the-tcpdump-group/libpcap</title>
    <updated>2024-01-25T01:28:51Z</updated>
    <id>tag:github.com,2024-01-25:/the-tcpdump-group/libpcap</id>
    <link href="https://github.com/the-tcpdump-group/libpcap" rel="alternate"></link>
    <summary type="html">&lt;p&gt;the LIBpcap interface to various kernel packet capture mechanism&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LIBPCAP 1.x.y by &lt;a href=&#34;https://www.tcpdump.org&#34;&gt;The Tcpdump Group&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;To report a security issue please send an e-mail to &lt;a href=&#34;mailto:security@tcpdump.org&#34;&gt;security@tcpdump.org&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To report bugs and other problems, contribute patches, request a feature, provide generic feedback etc please see the &lt;a href=&#34;https://raw.githubusercontent.com/the-tcpdump-group/libpcap/master/CONTRIBUTING.md&#34;&gt;guidelines for contributing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/the-tcpdump-group/libpcap/master/doc/&#34;&gt;documentation directory&lt;/a&gt; has README files about specific operating systems and options.&lt;/p&gt; &#xA;&lt;p&gt;Anonymous Git is available via:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/the-tcpdump-group/libpcap.git&#34;&gt;https://github.com/the-tcpdump-group/libpcap.git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This directory contains source code for libpcap, a system-independent interface for user-level packet capture. libpcap provides a portable framework for low-level network monitoring. Applications include network statistics collection, security monitoring, network debugging, etc. Since almost every system vendor provides a different interface for packet capture, and since we&#39;ve developed several tools that require this functionality, we&#39;ve created this system-independent API to ease in porting and to alleviate the need for several system-dependent packet capture modules in each application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;formerly from&#x9;Lawrence Berkeley National Laboratory&#xA;&#x9;&#x9;Network Research Group &amp;lt;libpcap@ee.lbl.gov&amp;gt;&#xA;&#x9;&#x9;ftp://ftp.ee.lbl.gov/old/libpcap-0.4a7.tar.Z&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Support for particular platforms and BPF&lt;/h3&gt; &#xA;&lt;p&gt;For some platforms there are &lt;code&gt;README.{system}&lt;/code&gt; files that discuss issues with the OS&#39;s interface for packet capture on those platforms, such as how to enable support for that interface in the OS, if it&#39;s not built in by default.&lt;/p&gt; &#xA;&lt;p&gt;The libpcap interface supports a filtering mechanism based on the architecture in the BSD packet filter. BPF is described in the 1993 Winter Usenix paper ``The BSD Packet Filter: A New Architecture for User-level Packet Capture&#39;&#39; (&lt;a href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.ps.Z&#34;&gt;compressed PostScript&lt;/a&gt;, &lt;a href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.ps.gz&#34;&gt;gzipped PostScript&lt;/a&gt;, &lt;a href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.pdf&#34;&gt;PDF&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Although most packet capture interfaces support in-kernel filtering, libpcap utilizes in-kernel filtering only for the BPF interface. On systems that don&#39;t have BPF, all packets are read into user-space and the BPF filters are evaluated in the libpcap library, incurring added overhead (especially, for selective filters). Ideally, libpcap would translate BPF filters into a filter program that is compatible with the underlying kernel subsystem, but this is not yet implemented.&lt;/p&gt; &#xA;&lt;p&gt;BPF is standard in 4.4BSD, BSD/OS, NetBSD, FreeBSD, OpenBSD, DragonFly BSD, macOS, and Solaris 11; an older, modified and undocumented version is standard in AIX. {DEC OSF/1, Digital UNIX, Tru64 UNIX} uses the packetfilter interface but has been extended to accept BPF filters (which libpcap utilizes).&lt;/p&gt; &#xA;&lt;p&gt;Linux has a number of BPF based systems, and libpcap does not support any of the eBPF mechanisms as yet, although it supports many of the memory mapped receive mechanisms. See the &lt;a href=&#34;https://raw.githubusercontent.com/the-tcpdump-group/libpcap/master/doc/README.linux&#34;&gt;Linux-specific README&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Note to Linux distributions and *BSD systems that include libpcap:&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;s now a rule to make a shared library, which should work on Linux and *BSD, among other platforms.&lt;/p&gt; &#xA;&lt;p&gt;It sets the soname of the library to &lt;code&gt;libpcap.so.1&lt;/code&gt;; this is what it should be, &lt;strong&gt;NOT&lt;/strong&gt; &lt;code&gt;libpcap.so.1.x&lt;/code&gt; or &lt;code&gt;libpcap.so.1.x.y&lt;/code&gt; or something such as that.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ve been maintaining binary compatibility between libpcap releases for quite a while; there&#39;s no reason to tie a binary linked with libpcap to a particular release of libpcap.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>RedSiege/GraphStrike</title>
    <updated>2024-01-25T01:28:51Z</updated>
    <id>tag:github.com,2024-01-25:/RedSiege/GraphStrike</id>
    <link href="https://github.com/RedSiege/GraphStrike" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cobalt Strike HTTPS beaconing over Microsoft Graph API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GraphStrike&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/RedSiege/GraphStrike/assets/152210699/adee8da9-b712-4dc5-b9c5-a32798338ee8&#34; alt=&#34;gscolor&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Release blog: &lt;a href=&#34;https://redsiege.com/blog/2024/01/graphstrike-release&#34;&gt;GraphStrike: Using Microsoft Graph API to Make Beacon Traffic Disappear&lt;/a&gt;&lt;br&gt; Developer blog: &lt;a href=&#34;https://redsiege.com/blog/2024/01/graphstrike-developer&#34;&gt;GraphStrike: Anatomy of Offensive Tool Development&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;GraphStrike is a suite of tools that enables Cobalt Strike&#39;s HTTPS Beacon to use &lt;a href=&#34;https://learn.microsoft.com/en-us/graph/use-the-api&#34;&gt;Microsoft Graph API&lt;/a&gt; for C2 communications. All Beacon traffic will be transmitted via two files created in the attacker&#39;s SharePoint site, and all communications from Beacon will route to &lt;a href=&#34;https://graph.microsoft.com&#34;&gt;https://graph.microsoft.com&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/RedSiege/GraphStrike/assets/152210699/ddb744d0-93dd-4791-9f5e-3f0f2dfd65bb&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;GraphStrike includes a provisioner to create the required Azure assets for Cobalt Strike HTTPS over Graph API:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/RedSiege/GraphStrike/assets/152210699/a5d777d6-deb2-4640-a394-1bde0b51bdc8&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;GraphStrike does not create any paid assets in Azure, so no additional cost is incurred by the use of GraphStrike or it&#39;s provisioner.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Why?&lt;/h3&gt; &#xA;&lt;p&gt;Threat intelligence has been released regarding several different APTs leveraging Microsoft Graph API and other Microsoft services for offensive campaigns:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.volexity.com/blog/2021/08/17/north-korean-apt-inkysquid-infects-victims-using-browser-exploits/&#34;&gt;BLUELIGHT - APT37/InkySquid/ScarCruft&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://malpedia.caad.fkie.fraunhofer.de/details/win.graphite&#34;&gt;Graphite - APT28/Fancy Bear&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/flea-backdoor-microsoft-graph-apt15&#34;&gt;Graphican - APT15/Nickel/The Flea&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.elastic.co/security-labs/siestagraph-new-implant-uncovered-in-asean-member-foreign-ministry&#34;&gt;SiestaGraph - UNKNOWN&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Threat actors continue to leverage legitimate services for illegitimate purposes. Utilizing a high-reputation domain like graph.microsoft.com for C2 communications is extremely effective and desirable, but often complicated and prohibitive from a time and effort standpoint. Most C2 frameworks do not support methods to fetch or rotate access tokens, which makes them unable to use Graph API. This can make it difficult for red teams to replicate these techniques, and deprives defenders of a chance to observe and develop signatures for this kind of activity. GraphStrike seeks to ease that burden and provide a reliable and repeatable process to leverage Microsoft Graph API while keeping the familiarity and reliability of the Cobalt Strike user experience.&lt;/p&gt; &#xA;&lt;h3&gt;Is this an External C2?&lt;/h3&gt; &#xA;&lt;p&gt;Not technically, no. Having previously built a true &lt;a href=&#34;https://github.com/Octoberfest7/Presentations/raw/main/TradecraftCON_2022/Teams_CobaltStrike_External_C2.pdf&#34;&gt;External C2 using Graph API&lt;/a&gt; (which sent Beacon traffic as Microsoft Teams messages), the burden of having to develop, maintain, and integrate a custom implant that meets the External C2 specification and gets the job done is all too familiar. GraphStrike instead leverages an open source &lt;a href=&#34;https://www.cobaltstrike.com/product/features/user-defined-reflective-loader&#34;&gt;User Defined Reflective Loader&lt;/a&gt;(UDRL) called &lt;a href=&#34;https://github.com/kyleavery/AceLdr/tree/main&#34;&gt;AceLdr&lt;/a&gt; by Kyle Avery (adapted as &#39;GraphLdr&#39; in this project) to hook the WinINet library calls that Beacon normally makes and manipulate them as neccessary in order to use Graph API. There is no custom implant or additional process to speak of, just the Beacon process with a couple of hooked Windows API&#39;s. On the server side there is a Python3 program that translates Cobalt Strike Team Server traffic into Graph API traffic and vice-versa.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;p&gt;GraphStrike supports almost all normal Cobalt Strike activities to include:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use of Proxychains through a Cobalt Strike SOCKS proxy (though it is very slow...)&lt;/li&gt; &#xA; &lt;li&gt;Upload/Download of large files&lt;/li&gt; &#xA; &lt;li&gt;BOFs, execute-assembly, etc.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This also includes GraphStrike integration of the sleep, exit, and remove commands to match GraphStrike Server sleep times with Beacon as well as delete files in SharePoint when a Beacon is exited or removed.&lt;/p&gt; &#xA;&lt;p&gt;GraphStrike additionally incorporates all of the features and functionality of the original AceLdr, with some additional API&#39;s made to utilize call stack spoofing as well.&lt;/p&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;p&gt;GraphStrike requires the following before you get started:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A Microsoft Azure tenant with a SharePoint/O365 license assigned + site created. The default site is fine.&lt;/li&gt; &#xA; &lt;li&gt;An Azure account with Global Administrator permissions in that tenant.&lt;/li&gt; &#xA; &lt;li&gt;Python 3.8-3.11&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RedSiege/GraphStrike/main/#notes&#34;&gt;Note #4&lt;/a&gt;&lt;/sup&gt; (and additional dependencies that will be installed during the setup process)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Firewall rules&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Ensure that each machine that the Cobalt Strike client runs on is able to connect to the Cobalt Strike team server machine on ports 443 and 5000.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Setup&lt;/h1&gt; &#xA;&lt;p&gt;Make note of the following before proceeding with the setup process:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;1. Certain components utilize relative paths to locate other assets. Please change directories as instructed below.&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;2. The Cobalt Strike profile may only be edited BEFORE step 5 in the below setup process&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RedSiege/GraphStrike/main/#notes&#34;&gt;Note #1&lt;/a&gt;&lt;/sup&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;On the machine that will run the Cobalt Strike team server:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the repo.&lt;/li&gt; &#xA; &lt;li&gt;From the repo directory, run &lt;code&gt;sudo setup/install_dependencies.sh&lt;/code&gt; to install required system dependencies.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;python3 -m venv virtual&lt;/code&gt; and then &lt;code&gt;source virtual/bin/activate&lt;/code&gt; to create and then enter the virtual environment.&lt;/li&gt; &#xA; &lt;li&gt;Change to the setup directory and run &lt;code&gt;pip3 install -r requirements.txt&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;./provisioner.py new&lt;/code&gt; and complete the setup process.&lt;/li&gt; &#xA; &lt;li&gt;Start the Cobalt Strike team server using graphstrike.profile as the malleable C2 profile.&lt;/li&gt; &#xA; &lt;li&gt;Start a Cobalt Strike client instance (you can do this on a client machine, or on the TS box and kill it afterwards) and create a Cobalt Strike HTTPS listener on port 443 with &lt;code&gt;graph.microsoft.com&lt;/code&gt; as the HTTPS Hosts and HTTPS Host(Stager) fields.&lt;/li&gt; &#xA; &lt;li&gt;Change back to the primary repo directory and run the GraphStrike Server using &lt;code&gt;./GraphStrike.py&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;On ALL machines that will run the Cobalt Strike client:&lt;/h3&gt; &#xA;&lt;ol start=&#34;9&#34;&gt; &#xA; &lt;li&gt;Copy the GraphStrike/client directory to the client machine from the TS machine. &lt;strong&gt;This must be done only AFTER completing provisioning!&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Import GraphStrike.cna to Cobalt Strike using the Script Manager.&lt;/li&gt; &#xA; &lt;li&gt;Create Cobalt Strike payloads, whether that be raw shellcode or compiled artifacts using the Artifact Kit or an alternate payload generation framework. &lt;strong&gt;Artifact Kit users see below!&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Profit.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Artifact Kit Users&lt;/h3&gt; &#xA;&lt;p&gt;Due to the size of GraphLdr, users of the Artifact Kit will need to re-compile it with specific options in order for GraphStrike to be compatible with Artifact Kit generated payloads. Specifically, the &#39;Stage Size&#39; and &#39;RDLL Size&#39; fields need to be specified so as to use the 100K RDLL size. Two examples of working syntax are provided below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;./build.sh pipe VirtualAlloc 505029 100 false false none /opt/cobaltstrike/artifacts&lt;/code&gt;&lt;br&gt; &lt;code&gt;./build.sh peek HeapAlloc 492376 100 false true indirect /opt/cobaltstrike/artifacts&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Cleanup&lt;/h1&gt; &#xA;&lt;h3&gt;On the machine that is running the TS + GraphStrike Server:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Stop the GraphStrike server&lt;/li&gt; &#xA; &lt;li&gt;Change back to the setup directory and run &lt;code&gt;./provisioner.py delete&lt;/code&gt; to remove created Azure assets.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Notes&lt;/h1&gt; &#xA;&lt;p&gt;In no particular order, here are a few suggestions and observations to help use GraphStrike to it&#39;s full potential.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The profile included with GraphStrike is very minimalistic; this is by design. &lt;strong&gt;Changing any of the EXISTING fields in the profile may/will break GraphStrike!&lt;/strong&gt; You should be able to add additional profile language/behaviour to other sections that are not already defined (.e.g customize pipe name, injection behaviour, etc). &lt;strong&gt;Any edits to the profile MUST be made prior to running the provisioner!&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;The Azure application that is used for C2 communications by both Beacon and the GraphStrike Server is rate-limited to 1200 requests/min. The GraphStrike Server uses 120/min as a baseline to function. The lower a Beacon&#39;s sleep time is the more requests it will make; additionally, each Beacon created using GraphStrike is going to be using some of that 1200/min limit. Going interactive with a Beacon is doable, but going interactive with more than one Beacon probably isn&#39;t. If you run into rate limiting issues, consider increasing the sleep time for your beacons, decreasing the number of Beacon&#39;s you have running, or both.&lt;/li&gt; &#xA; &lt;li&gt;While the GraphStrike Server&#39;s sleep time changes on a per-Beacon basis according to issued sleep commands, what this really means is that the GraphStrike Server will sleep for the specified time before checking in with the TS for tasking. It does NOT mean that Beacon will immediately receive and process the tasking as soon as it is retrieved from the TS by the GraphStrike server. Beacon will sleep the specified time before reaching out to SharePoint to retrieve TS tasking, but due to the nature of async C2 this will not be in lockstep with when the GraphStrike Server uploads it.&lt;/li&gt; &#xA; &lt;li&gt;If a Beacon dies without having exited gracefully (AV, it crashes, etc), the Beacon will &lt;strong&gt;appear&lt;/strong&gt; to still be calling into the TS, and the fact that it is dead will only become apparent once you issue it a command. What is really connecting to the TS / making it appear that the Beacon is still calling in is the GraphStrike server, so this really isn&#39;t a reflection on the health of a Beacon. Such is the nature of async C2.&lt;/li&gt; &#xA; &lt;li&gt;GraphStrike works on a 1:1:1 model; 1 SharePoint site is associated with 1 GraphStrike server which is associated with 1 TS. You&#39;ll have issues if you try connecting two TS/GraphStrike servers to a single SharePoint site. You can of course connect multiple Cobalt Strike clients to a single TS / GraphStrike server, each client just needs a copy of the &#39;client&#39; folder produced by the provisioning process.&lt;/li&gt; &#xA; &lt;li&gt;There is a &lt;a href=&#34;https://github.com/Azure/azure-cli/issues/27673&#34;&gt;known issue&lt;/a&gt; regarding compatibility of the az utility used by GraphStrike and Python 3.12.&lt;/li&gt; &#xA; &lt;li&gt;I&#39;d recommend you review the documentation for &lt;a href=&#34;https://github.com/kyleavery/AceLdr/tree/main&#34;&gt;AceLdr&lt;/a&gt;, as all of the notes from that project apply here as well.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Limitations&lt;/h1&gt; &#xA;&lt;p&gt;The following limitations exist in GraphStrike:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Only x64 Beacons are supported.&lt;/li&gt; &#xA; &lt;li&gt;Staged Beacons are not supported.&lt;/li&gt; &#xA; &lt;li&gt;GraphStrike is only compatible with the WinINet library; the new WinHTTP library option for Beacons is not supported.&lt;/li&gt; &#xA; &lt;li&gt;No support for issuing a sleep command via Beacon&#39;s right-click menu. Sleep beacons using the command line option instead.&lt;/li&gt; &#xA; &lt;li&gt;GraphStrike is only supported on Linux instances of Cobalt Strike. Windows support is certainly possible to implement, and is really just a matter of changing around some paths within the Python files and Aggressor script.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;p&gt;GraphStrike would not be possible without the contributions of the following individuals:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Kyle Avery for &lt;a href=&#34;https://github.com/kyleavery/AceLdr/tree/main&#34;&gt;AceLdr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Didier Stevens for &lt;a href=&#34;https://github.com/DidierStevens/DidierStevensSuite/raw/master/cs-decrypt-metadata.py&#34;&gt;cs-decrypt-metadata.py&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Mike Saunders, Corey Overstreet, Chris Truncer, and Justin Palk from the Red Siege team who all kindly beta tested GraphStrike and identified multiple issues that were fixed prior to release.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>