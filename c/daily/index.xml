<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-15T01:35:46Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kgsws/doom-in-doom</title>
    <updated>2022-07-15T01:35:46Z</updated>
    <id>tag:github.com,2022-07-15:/kgsws/doom-in-doom</id>
    <link href="https://github.com/kgsws/doom-in-doom" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Doom 2 code execution. With a Doom port.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Doom-in-Doom&lt;/h1&gt; &#xA;&lt;p&gt;Everything should be explained here &lt;a href=&#34;https://www.youtube.com/watch?v=c6hnQ1RKhbo&#34;&gt;https://www.youtube.com/watch?v=c6hnQ1RKhbo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Chocolate Doom&lt;/h1&gt; &#xA;&lt;p&gt;The original unmodified code is available here &lt;a href=&#34;https://github.com/chocolate-doom&#34;&gt;https://github.com/chocolate-doom&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>exo-lang/exo</title>
    <updated>2022-07-15T01:35:46Z</updated>
    <id>tag:github.com,2022-07-15:/exo-lang/exo</id>
    <link href="https://github.com/exo-lang/exo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Exocompilation for productive programming of hardware accelerators&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ChezJrk/exo/actions/workflows/main.yml&#34;&gt;&lt;img src=&#34;https://github.com/ChezJrk/exo/actions/workflows/main.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/ChezJrk/exo&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/ChezJrk/exo/branch/master/graph/badge.svg?token=BFIZ0WKP4I&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Install Exo&lt;/h1&gt; &#xA;&lt;p&gt;Exo is published on PyPI and can be installed locally via pip by the following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ pip install exo-lang&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;Take a look at &lt;code&gt;exo/examples&lt;/code&gt; for scheduling examples.&lt;/p&gt; &#xA;&lt;h1&gt;Exo&#39;s scheduling API&lt;/h1&gt; &#xA;&lt;h2&gt;Top-level Python function decorator&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;@proc&lt;/code&gt; - decorates a Python function which is parsed and compiled as Exo. Replaces the function with a &lt;code&gt;Procedure&lt;/code&gt; object.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;@instr&lt;/code&gt; - same as &lt;code&gt;@proc&lt;/code&gt;, but accepts a hardware instruction as a format string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;@config&lt;/code&gt; - decorates a Python class which is parsed and compiled as an Exo configuration object&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Procedure object methods&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Introspection operations&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.name()&lt;/code&gt; returns the procedure name.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.check_effects()&lt;/code&gt; forces Exo to run effect checking on the procedure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.show_effects()&lt;/code&gt; prints the effects of the procedure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.show_effect(stmt)&lt;/code&gt; prints the effect of the &lt;code&gt;stmt&lt;/code&gt; in the procedure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.is_instr()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the procedure has a hardware instruction string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.get_instr()&lt;/code&gt; returns the hardware instruction string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.get_ast()&lt;/code&gt; returns a &lt;code&gt;QAST&lt;/code&gt;, which is an AST representation suitable for introspection.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Execution / interpretation operations&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.compile_c(directory, filename)&lt;/code&gt; compiles the procedure into C and stores in &lt;code&gt;filename&lt;/code&gt; in the &lt;code&gt;directory&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.interpret(**args)&lt;/code&gt; runs Exo interpreter on the procedure.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Scheduling operations on Procedure objects&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Buffer related operations&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.data_reuse(buf1, buf2)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Reuses a buffer &lt;code&gt;buf1&lt;/code&gt; in the use site of &lt;code&gt;buf2&lt;/code&gt; and removes the allocation of &lt;code&gt;buf2&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.inline_window(win_stmt)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Removes the window statement &lt;code&gt;win_stmt&lt;/code&gt;, which is an alias to the window, and inlines the windowing in its use site.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.expand_dim(stmt, alloc_dim, indexing)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Expands the dimension of the allocation statement &lt;code&gt;stmt&lt;/code&gt; with dimension &lt;code&gt;alloc_dim&lt;/code&gt; of indexing &lt;code&gt;indexing&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.bind_expr(new_name, expr)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Binds the right hand side expression &lt;code&gt;expr&lt;/code&gt; to a newly allocated buffer named &lt;code&gt;new_name&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.stage_mem(win_expr, new_name, stmt_start, stmt_end=None)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Stages the buffer &lt;code&gt;win_expr&lt;/code&gt; to the new window expression &lt;code&gt;new_name&lt;/code&gt; in statement block (&lt;code&gt;stmt_start&lt;/code&gt; to &lt;code&gt;stmt_end&lt;/code&gt;), and adds an initialization loop and a write-back loop.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.stage_assn(new_name, stmt)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Binds the left hand side expression of &lt;code&gt;stmt&lt;/code&gt; to a newly allocated buffer named &lt;code&gt;new_name&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.rearrange_dim(alloc, dimensions)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes an allocation statement and a list of integers to map the dimension. It rearranges the dimensions of &lt;code&gt;alloc&lt;/code&gt; in &lt;code&gt;dimension&lt;/code&gt; order. E.g., if &lt;code&gt;alloc&lt;/code&gt; were &lt;code&gt;foo[N,M,K]&lt;/code&gt; and the &lt;code&gt;dimension&lt;/code&gt; were &lt;code&gt;[2,0,1]&lt;/code&gt;, it would become &lt;code&gt;foo[K,N,M]&lt;/code&gt; after this operation.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.lift_alloc(alloc, n_lifts=1, keep_dims=False)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Lifts the allocation statement &lt;code&gt;alloc&lt;/code&gt; out of &lt;code&gt;n_lifts&lt;/code&gt; number of scopes. If and For statements are the only statements in Exo which introduce a scope. When lifting the allocation out of a for loop, it will expand its dimension to the loop bound if &lt;code&gt;keep_dims&lt;/code&gt; is True.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Loop related operations&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.split(loop, split_const, iter_vars, tail=&#39;guard&#39;, perfect=False)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Splits &lt;code&gt;loop&lt;/code&gt; into an outer and an inner loop. The inner loop bound is &lt;code&gt;split_const&lt;/code&gt; and the outer and inner loop names are specified by a list of strings &lt;code&gt;iter_vars&lt;/code&gt;. If &lt;code&gt;perfect&lt;/code&gt; is True, it will not introduce a tail case. &lt;code&gt;tail&lt;/code&gt; specifies the tail strategies, where the options are &lt;code&gt;guard&lt;/code&gt;, &lt;code&gt;cut&lt;/code&gt;, and &lt;code&gt;cut_and_guard&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.fuse_loop(loop1, loop2)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fuses two adjacent loops with a common iteration variable.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.partition_loop(loop, num)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Partitions &lt;code&gt;loop&lt;/code&gt; into two loops, the first running between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;num&lt;/code&gt; and the second between &lt;code&gt;num+1&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt;&#39;s original bound.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.reorder(loop1, loop2)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Reorders two nested loops. &lt;code&gt;loop2&lt;/code&gt; should be nested directly inside &lt;code&gt;loop1&lt;/code&gt;. &lt;code&gt;loop1&lt;/code&gt; will be nested inside &lt;code&gt;loop2&lt;/code&gt; after this operation.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.unroll(loop)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Unrolls the loop. The loop needs to have a constant bound.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.fission_after(stmt, n_lifts=1)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fissions the &lt;code&gt;n_lifts&lt;/code&gt; number of loops around the &lt;code&gt;stmt&lt;/code&gt;. The fissioned loops around the &lt;code&gt;stmt&lt;/code&gt; need to be directly nested with each other and the statements before and after the &lt;code&gt;stmt&lt;/code&gt; should not have any allocation dependencies.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.remove_loop(loop)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Replaces the loop with its body if the body is idempotent. The system must be able to prove that the loop runs at least once.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Config related operations&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.bind_config(expr, config, field)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Binds the right hand side &lt;code&gt;expr&lt;/code&gt; to &lt;code&gt;config.field&lt;/code&gt;. It will replace the use site of &lt;code&gt;expr&lt;/code&gt; with &lt;code&gt;config.field&lt;/code&gt; and introduces a config statement of &lt;code&gt;config.field = expr&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.configwrite_root(config, field, expr)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Inserts the config statement &lt;code&gt;config.field = expr&lt;/code&gt; in the beginning of the procedure.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.configwrite_after(stmt, config, field, expr)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Inserts the config statement &lt;code&gt;config.field = expr&lt;/code&gt; after &lt;code&gt;stmt&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.delete_config(stmt)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deletes the configuration statement.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Other scheduling operations&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.add_assertion(assertion)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Asserts the truth of the expression &lt;code&gt;assertion&lt;/code&gt; at the beginning of the procedure.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.lift_if(if, n_lifts=1)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Lifts the if statement &lt;code&gt;if&lt;/code&gt; out of &lt;code&gt;n_lifts&lt;/code&gt; number of scopes. This is similar to &lt;code&gt;reorder()&lt;/code&gt;, but for if statements.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.assert_if(if, bool)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Unsafely asserts that the &lt;code&gt;if&lt;/code&gt; condition is always True or False. This can be used to remove branches.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.delete_pass()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deletes a &lt;code&gt;Pass&lt;/code&gt; statement in the procedure.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.reorder_stmts(stmt1, stmt2)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Reorder two adjacent statements &lt;code&gt;stmt1&lt;/code&gt; and &lt;code&gt;stmt2&lt;/code&gt;. After this operation, the order will be &lt;code&gt;stmt2&lt;/code&gt; &lt;code&gt;stmt1&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.reorder_before(stmt)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Move the statement &lt;code&gt;stmt&lt;/code&gt; before the previous statement. This is a shorthand for &lt;code&gt;reorder_stmts()&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.replace(subproc, stmt)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Replace the statement with a call to &lt;code&gt;subproc&lt;/code&gt;. This operation is one of our contributions and is explained in detail in the paper.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.replace_all(subproc)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Eagerly replace every matching statement with a call to &lt;code&gt;subproc&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.inline(call_site)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Inline the function call.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.is_eq(another_proc)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Returns True if &lt;code&gt;another_proc&lt;/code&gt; is equivalent to the procedure.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.call_eqv(eqv_proc, call_site)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Replace the function call statement of &lt;code&gt;call_site&lt;/code&gt; with a call to an equivalent procedure &lt;code&gt;eqv_proc&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.repeat(directive, *args)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Continue to run the directive until it fails. The directive and its arguments are given separately, e.g. &lt;code&gt;proc.repeat(Procedure.inline, &#34;proc_to_inline(_)&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.simplify()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Simplify the code in the procedure body. Tries to reduce expressions to constants and eliminate dead branches and loops. Uses branch conditions to simplify expressions inside the branches.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.rename(new_name)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Rename this procedure to &lt;code&gt;new_name&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.make_instr(instr_string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Converts this procedure to an instruction procedure with instruction &lt;code&gt;instr_string&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.partial_eval(*args, **kwargs)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Specializes this procedure to the given argument values.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.set_precision(name, type)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sets the precision type of &lt;code&gt;name&lt;/code&gt; to &lt;code&gt;type&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.set_window(name, is_window)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If &lt;code&gt;is_window&lt;/code&gt; is True, it sets the buffer &lt;code&gt;name&lt;/code&gt; to window type, instead of a tensor type.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.set_memory(name, mem_type)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sets a buffer &lt;code&gt;name&lt;/code&gt;&#39;s memory type to &lt;code&gt;mem_type&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Exo&#39;s repository structure&lt;/h1&gt; &#xA;&lt;p&gt;In this repository, folders are structured as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;src/exo&lt;/code&gt; is where the core Exo implementation resides. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;API.py&lt;/code&gt; defines the stable API. Documentation for this API can be found in the section below.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;libs/&lt;/code&gt; contains some common memory definitions (&lt;code&gt;memories.py&lt;/code&gt;) and custom malloc implementations. These could be user-defined, but we provide them for convenience.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;platforms/&lt;/code&gt; contains instruction definitions that are part of the release. These could be user-defined, but we provide them for convenience.&lt;/li&gt; &#xA;   &lt;li&gt;Other files are implementation details of Exo (e.g., &lt;code&gt;typecheck.py&lt;/code&gt; implements typecheck), but we will not dwell on these as they are not exposed to users.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apps/&lt;/code&gt; contains some sample applications written in Exo.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dependencies/&lt;/code&gt; contains submodules that Exo&#39;s apps and testing depends on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;examples/&lt;/code&gt; contains a Python notebook that we used for live demos. This should be ignored.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tests/&lt;/code&gt; contains the Exo test suite.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Build Exo from source&lt;/h1&gt; &#xA;&lt;p&gt;We make active use of newer Python 3.x features, so please use the same version of Python as our CI if you&#39;re getting errors about unsupported features.&lt;/p&gt; &#xA;&lt;p&gt;Setting up Exo for development is like any other Python project. We &lt;em&gt;strongly&lt;/em&gt; recommend you use a virtual environment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:exo-lang/exo.git&#xA;$ cd exo/&#xA;$ git submodule update --init --recursive&#xA;$ python -m venv ~/.venv/exo&#xA;$ . ~/.venv/exo&#xA;(exo) $ python -m pip install -U pip setuptools wheel&#xA;(exo) $ python -m pip install -r requirements.txt&#xA;(exo) $ python -m build&#xA;(exo) $ pip install dist/*.whl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;PySMT&lt;/h2&gt; &#xA;&lt;p&gt;Depending on your setup, getting PySMT to work correctly may be difficult. You need to independently install a solver such as Z3 or CVC4, and even then getting the PySMT library to correctly locate that solver may be difficult. We have included the &lt;code&gt;z3-solver&lt;/code&gt; package as a requirement, which will hopefully avoid this issue, but you can also install z3 (or your choice of solver) independently.&lt;/p&gt; &#xA;&lt;h1&gt;Notes for Testing&lt;/h1&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;h3&gt;Build system (required)&lt;/h3&gt; &#xA;&lt;p&gt;The Exo test harness generates C code and as such needs to compile and link using an unknown (i.e. system) compiler. To do this, it generates CMake build files and invokes CMake behind the scenes.&lt;/p&gt; &#xA;&lt;p&gt;Therefore, you must have CMake &lt;strong&gt;3.21&lt;/strong&gt; or newer installed.&lt;/p&gt; &#xA;&lt;p&gt;By default, CMake will use &lt;a href=&#34;https://ninja-build.org&#34;&gt;Ninja&lt;/a&gt; as its backend, but this may be overridden by setting the environment variable &lt;code&gt;CMAKE_GENERATOR&lt;/code&gt; to &lt;code&gt;Unix Makefiles&lt;/code&gt;, in case you do not wish to install Ninja.&lt;/p&gt; &#xA;&lt;h3&gt;SDE (optional)&lt;/h3&gt; &#xA;&lt;p&gt;For testing x86 features on processors which don&#39;t support them (e.g., AVX-512 or AMX), we rely on the &lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/articles/tool/software-development-emulator.html&#34;&gt;Intel Software Development Emulator&lt;/a&gt; as an optional dependency. Tests which rely on this (namely for AMX) look for &lt;code&gt;sde64&lt;/code&gt; either in the path defined by the &lt;code&gt;SDE_PATH&lt;/code&gt; environment variable or in the system &lt;code&gt;PATH&lt;/code&gt;, and are skipped if it is not available.&lt;/p&gt; &#xA;&lt;h2&gt;Running tests&lt;/h2&gt; &#xA;&lt;p&gt;To run the tests, simply type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pytest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in the root of the project.&lt;/p&gt; &#xA;&lt;h2&gt;Running Coverage Testing&lt;/h2&gt; &#xA;&lt;p&gt;To run pytest with coverage tests, execute&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pytest --cov=./ --cov-report=html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, if you want to see annotated source files, open &lt;code&gt;./htmlcov/index.html&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Publication&lt;/h1&gt; &#xA;&lt;p&gt;The first paper on Exo was published at PLDI &#39;22. You can download the paper &lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3519939.3523446&#34;&gt;from ACM Digital Library&lt;/a&gt;. If you use Exo, please consider citing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inproceedings{10.1145/3519939.3523446,&#xA;author = {Ikarashi, Yuka and Bernstein, Gilbert Louis and Reinking, Alex and Genc, Hasan and Ragan-Kelley, Jonathan},&#xA;title = {Exocompilation for Productive Programming of Hardware Accelerators},&#xA;year = {2022},&#xA;isbn = {9781450392655},&#xA;publisher = {Association for Computing Machinery},&#xA;address = {New York, NY, USA},&#xA;url = {https://doi.org/10.1145/3519939.3523446},&#xA;doi = {10.1145/3519939.3523446},&#xA;abstract = {High-performance kernel libraries are critical to exploiting accelerators and specialized instructions in many applications. Because compilers are difficult to extend to support diverse and rapidly-evolving hardware targets, and automatic optimization is often insufficient to guarantee state-of-the-art performance, these libraries are commonly still coded and optimized by hand, at great expense, in low-level C and assembly. To better support development of high-performance libraries for specialized hardware, we propose a new programming language, Exo, based on the principle of exocompilation: externalizing target-specific code generation support and optimization policies to user-level code. Exo allows custom hardware instructions, specialized memories, and accelerator configuration state to be defined in user libraries. It builds on the idea of user scheduling to externalize hardware mapping and optimization decisions. Schedules are defined as composable rewrites within the language, and we develop a set of effect analyses which guarantee program equivalence and memory safety through these transformations. We show that Exo enables rapid development of state-of-the-art matrix-matrix multiply and convolutional neural network kernels, for both an embedded neural accelerator and x86 with AVX-512 extensions, in a few dozen lines of code each.},&#xA;booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},&#xA;pages = {703â€“718},&#xA;numpages = {16},&#xA;keywords = {program optimization, user-schedulable languages, user-extensible backend &amp;amp;amp; scheduling, instruction abstraction, scheduling, hardware accelerators},&#xA;location = {San Diego, CA, USA},&#xA;series = {PLDI 2022}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>hd-zero/hdzero-vtx</title>
    <updated>2022-07-15T01:35:46Z</updated>
    <id>tag:github.com,2022-07-15:/hd-zero/hdzero-vtx</id>
    <link href="https://github.com/hd-zero/hdzero-vtx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;HDZero VTX Firmware&lt;/h2&gt; &#xA;&lt;p&gt;Firmware runs on a build-in C51 MCU of DM5680 which is the Baseband chip of VTX.&lt;/p&gt; &#xA;&lt;p&gt;It works on all VTXs, including VTX Whoop, VTX Whoop Lite, VTX Race V1, VTX Race V2, VTX Freestyle.&lt;/p&gt; &#xA;&lt;h3&gt;Define target&lt;/h3&gt; &#xA;&lt;p&gt;Edit &lt;code&gt;./src/common.h&lt;/code&gt;: define MACROs for different VTXs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;#define VTX_L&lt;/strong&gt; --&amp;gt; VTX Free Style&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;#define VTX_WL&lt;/strong&gt; --&amp;gt; VTX Whoop Lite&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;#define VTX_S&lt;/strong&gt; --&amp;gt; VTX Whoop&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;#define VTX_R&lt;/strong&gt; --&amp;gt; VTX Race V1, VTX Race V2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See: &lt;a href=&#34;https://www.hd-zero.com/&#34;&gt;https://www.hd-zero.com/&lt;/a&gt; for more production information.&lt;/p&gt; &#xA;&lt;h2&gt;hex2bin.exe&lt;/h2&gt; &#xA;&lt;p&gt;Generate &lt;strong&gt;firmware.bin&lt;/strong&gt; from &lt;strong&gt;firmware.hex&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;./hex2bin.exe firmware.hex&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>