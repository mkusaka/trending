<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-01T01:27:27Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lastpass/lastpass-cli</title>
    <updated>2023-09-01T01:27:27Z</updated>
    <id>tag:github.com,2023-09-01:/lastpass/lastpass-cli</id>
    <link href="https://github.com/lastpass/lastpass-cli" rel="alternate"></link>
    <summary type="html">&lt;p&gt;LastPass command line interface tool&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LastPass CLI&lt;/h1&gt; &#xA;&lt;h4&gt;(c) 2014-2019 LastPass.&lt;/h4&gt; &#xA;&lt;p&gt;Command line interface to &lt;a href=&#34;https://lastpass.com/&#34;&gt;LastPass.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Operating System Support&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;lpass&lt;/code&gt; is designed to run on GNU/Linux, Cygwin and Mac OS X.&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.libressl.org/&#34;&gt;LibreSSL&lt;/a&gt; or &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://curl.haxx.se/&#34;&gt;libcurl&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://xmlsoft.org/&#34;&gt;libxml2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gnupg.org/related_software/pinentry/index.en.html&#34;&gt;pinentry&lt;/a&gt; (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.methods.co.nz/asciidoc/&#34;&gt;AsciiDoc&lt;/a&gt; (build-time documentation generation only)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://sourceforge.net/projects/xclip/&#34;&gt;xclip&lt;/a&gt;, &lt;a href=&#34;http://www.vergenet.net/~conrad/software/xsel/&#34;&gt;xsel&lt;/a&gt;, &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/pbcopy.1.html&#34;&gt;pbcopy&lt;/a&gt;, or &lt;a href=&#34;https://cygwin.com/cgi-bin2/package-grep.cgi?grep=cygutils-extra&#34;&gt;putclip from cygutils-extra&lt;/a&gt; for clipboard support (optional)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installing on Linux&lt;/h3&gt; &#xA;&lt;h4&gt;Arch&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A binary package is available from the community repository, use pacman to simple install lastpass-cli.&lt;/li&gt; &#xA; &lt;li&gt;Can be build from source with the &#34;lastpass-cli-git&#34; *&lt;a href=&#34;https://aur.archlinux.org/packages.php?O=0&amp;amp;L=0&amp;amp;C=0&amp;amp;K=lastpass-cli&#34;&gt;Arch User Repository (AUR)&lt;/a&gt;. Information about installing packages from the AUR &lt;a href=&#34;https://wiki.archlinux.org/index.php/Arch_User_Repository#Installing_packages&#34;&gt;can be found on the Arch wiki&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;# from community repository&#xA;sudo pacman -S lastpass-cli&#xA;# from AUR repository&#xA;packer -S lastpass-cli-git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Fedora&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Packages are available in Fedora 22 and later.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo dnf install lastpass-cli&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Red Hat/Centos&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Packages are available in &lt;a href=&#34;https://fedoraproject.org/wiki/EPEL&#34;&gt;EPEL&lt;/a&gt; for RHEL/CentOS 7 and later.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo yum install lastpass-cli&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For older versions: Install the needed build dependencies, and then follow instructions in the &#39;Building&#39; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo yum install openssl libcurl libxml2 pinentry xclip openssl-devel libxml2-devel libcurl-devel gcc gcc-c++ make cmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Debian/Ubuntu&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the needed build dependencies, and then follow instructions in the &#39;Building&#39; section.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For Ubuntu 16.04 (xenial)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get --no-install-recommends -yqq install \&#xA;  bash-completion \&#xA;  build-essential \&#xA;  cmake \&#xA;  libcurl3  \&#xA;  libcurl3-openssl-dev  \&#xA;  libssl1.0.0 \&#xA;  libssl-dev \&#xA;  libxml2 \&#xA;  libxml2-dev  \&#xA;  pkg-config \&#xA;  ca-certificates \&#xA;  xclip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For Debian (stable/oldstable) and other Ubuntus &amp;lt; 18.04&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get --no-install-recommends -yqq install \&#xA;  bash-completion \&#xA;  build-essential \&#xA;  cmake \&#xA;  libcurl3  \&#xA;  libcurl3-openssl-dev  \&#xA;  libssl1.0 \&#xA;  libssl1.0-dev \&#xA;  libxml2 \&#xA;  libxml2-dev  \&#xA;  pkg-config \&#xA;  ca-certificates \&#xA;  xclip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For Debian (testing/experimental) and Ubuntu &amp;gt;= 18.04&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get --no-install-recommends -yqq install \&#xA;  bash-completion \&#xA;  build-essential \&#xA;  cmake \&#xA;  libcurl4  \&#xA;  libcurl4-openssl-dev  \&#xA;  libssl-dev  \&#xA;  libxml2 \&#xA;  libxml2-dev  \&#xA;  libssl1.1 \&#xA;  pkg-config \&#xA;  ca-certificates \&#xA;  xclip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Gentoo&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the package:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo emerge lastpass-cli&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Other Linux Distros&lt;/h4&gt; &#xA;&lt;p&gt;Install the packages listed in the Dependencies section of this document, and then follow instructions in the &#39;Building&#39; section.&lt;/p&gt; &#xA;&lt;h3&gt;Installing on OS X&lt;/h3&gt; &#xA;&lt;h4&gt;With &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; (easiest)&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install Homebrew, if necessary.&lt;/li&gt; &#xA; &lt;li&gt;Update Homebrew&#39;s local formula cache:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the lastpass-cli formula:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew install lastpass-cli&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;With &lt;a href=&#34;https://www.macports.org/&#34;&gt;MacPorts&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.macports.org/install.php&#34;&gt;Install MacPorts&lt;/a&gt;, if necessary.&lt;/li&gt; &#xA; &lt;li&gt;Update MacPorts&#39; local ports tree:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo port selfupdate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the lastpass-cli port:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo port install lastpass-cli&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optionally install the documentation:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo port install lastpass-cli-doc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Manually&lt;/h4&gt; &#xA;&lt;p&gt;Install the packages listed in the Dependencies section of this document, and then follow instructions in the &#39;Building&#39; section.&lt;/p&gt; &#xA;&lt;h3&gt;Installing on FreeBSD&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the binary package:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo pkg install security/lastpass-cli&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Or build the port yourself:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make -C /usr/ports/security/lastpass-cli all install clean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installing on Cygwin&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://github.com/transcode-open/apt-cyg&#34;&gt;apt-cyg&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Using apt-cyg, install the needed build dependencies, and then follow instructions in the &#39;Building&#39; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-cyg install wget make cmake gcc-core gcc-g++ openssl-devel libcurl-devel libxml2-devel libiconv-devel cygutils-extra&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Under the covers, make invokes cmake in a build directory; you may also use cmake directly if you need more control over the build process.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These environment variables can be passed to make to do the right thing: &lt;code&gt;PREFIX&lt;/code&gt;, &lt;code&gt;DESTDIR&lt;/code&gt;, &lt;code&gt;BINDIR&lt;/code&gt;, &lt;code&gt;LIBDIR&lt;/code&gt;, &lt;code&gt;MANDIR&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;ve installed it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ lpass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, from the build directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./lpass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;code&gt;asciidoc&lt;/code&gt; and &lt;code&gt;xsltproc&lt;/code&gt; if they are not already installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get install asciidoc xsltproc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;install-doc&lt;/code&gt; target builds and installs the documentation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo make install-doc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once installed,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ man lpass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can view the full documentation in the manpage, &lt;code&gt;man lpass&lt;/code&gt; or &lt;a href=&#34;https://lastpass.github.io/lastpass-cli/lpass.1.html&#34;&gt;view it online&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>gabriellandau/EDRSandblast-GodFault</title>
    <updated>2023-09-01T01:27:27Z</updated>
    <id>tag:github.com,2023-09-01:/gabriellandau/EDRSandblast-GodFault</id>
    <link href="https://github.com/gabriellandau/EDRSandblast-GodFault" rel="alternate"></link>
    <summary type="html">&lt;p&gt;EDRSandblast-GodFault&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;EDRSandblast-GodFault&lt;/h1&gt; &#xA;&lt;p&gt;By &lt;a href=&#34;https://twitter.com/GabrielLandau&#34;&gt;Gabriel Landau&lt;/a&gt; at &lt;a href=&#34;https://www.elastic.co/security-labs/&#34;&gt;Elastic Security&lt;/a&gt;. Modification of EDRSandblast - see original README below.&lt;/p&gt; &#xA;&lt;p&gt;Integrates &lt;a href=&#34;https://github.com/gabriellandau/PPLFault#godfault&#34;&gt;GodFault&lt;/a&gt; into &lt;a href=&#34;https://github.com/wavestone-cdt/EDRSandblast&#34;&gt;EDR Sandblast&lt;/a&gt;, achieving the same result without the use of any vulnerable drivers.&lt;/p&gt; &#xA;&lt;h3&gt;Example Output&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\Users\user\Desktop\Offsets&amp;gt;EDRSandblast.exe --kernelmode cmd&#xA;  ______ _____  _____   _____                 _ _     _           _&#xA; |  ____|  __ \|  __ \ / ____|               | | |   | |         | |&#xA; | |__  | |  | | |__) | (___   __ _ _ __   __| | |__ | | __ _ ___| |_&#xA; |  __| | |  | |  _  / \___ \ / _` | &#39;_ \ / _` | &#39;_ \| |/ _` / __| __|&#xA; | |____| |__| | | \ \ ____) | (_| | | | | (_| | |_) | | (_| \__ | |_&#xA; |______|_____/|_|  \_|_____/ \__,_|_| |_|\__,_|_.__/|_|\__,_|___/\__|&#xA;&#xA;  D3FC0N 30 Edition | Thomas DIOT (@_Qazeer) &amp;amp; Maxime MEIGNAN (@th3m4ks)&#xA;&#xA;[!] If kernel mode bypass is enabled, it is recommended to enable usermode bypass as well (e.g. to unhook the NtLoadDriver API call)&#xA;&#xA;[===== KERNEL MODE =====]&#xA;&#xA;[+] Setting up prerequisites for the kernel read/write primitives...&#xA;[+] Loading kernel related offsets from the CSV file&#xA;[*] System&#39;s ntoskrnl.exe file version is: ntoskrnl_22621-1702.exe&#xA;[+] Offsets are available for this version of ntoskrnl.exe (ntoskrnl_22621-1702.exe)!&#xA;[+] Checking if any EDR kernel notify rountines are set for image loading, process and thread creations...&#xA;[+] [NotifyRountines]   Enumerating process creation callbacks&#xA;[+] Running command: GodFault.exe -t 2684&#xA; [?] Server does not appear to be running.  Attempting to install it...&#xA; [+] CSRSS PID is 748&#xA; [+] Testing initial ability to acquire PROCESS_ALL_ACCESS to System: Failure&#xA; [+] Ready.  Spawning WinTcb.&#xA; [+] SpawnPPL: Waiting for child process to finish.&#xA; [+] Thread 2684 (KTHREAD FFFF910961E4C080) has been blessed by GodFault&#xA;[+] [NotifyRountines]           fffff8034df25500 [cng.sys + 0x5500]&#xA;[+] [NotifyRountines]           fffff8034e9efdc0 [WdFilter.sys + 0x4fdc0]&#xA;[+] [NotifyRountines]           Found callback belonging to EDR driver WdFilter.sys&#xA;[+] [NotifyRountines]           fffff803487bc460 [ksecdd.sys + 0x1c460]&#xA;[+] [NotifyRountines]           fffff8034eff3fd0 [tcpip.sys + 0x13fd0]&#xA;[+] [NotifyRountines]           fffff8034f5ed980 [iorate.sys + 0xd980]&#xA;[+] [NotifyRountines]           fffff8034dea8890 [CI.dll + 0x88890]&#xA;[+] [NotifyRountines]           fffff803525079f0 [dxgkrnl.sys + 0x179f0]&#xA;[+] [NotifyRountines]           fffff80352be0a70 [vm3dmp.sys + 0x10a70]&#xA;[+] [NotifyRountines]           fffff8036ebccd00 [peauth.sys + 0x3cd00]&#xA;[+] [NotifyRountines]           fffff8036eda1550 [wtd.sys + 0x1550]&#xA;[+] [NotifyRountines]   Found a total of 1 EDR / security products driver(s)&#xA;[+] [NotifyRountines]   Enumerating thread creation callbacks&#xA;[+] [NotifyRountines]           fffff8034e9f15c0 [WdFilter.sys + 0x515c0]&#xA;[+] [NotifyRountines]           Found callback belonging to EDR driver WdFilter.sys&#xA;[+] [NotifyRountines]           fffff8034e9f1350 [WdFilter.sys + 0x51350]&#xA;[+] [NotifyRountines]           Found callback belonging to EDR driver WdFilter.sys&#xA;[+] [NotifyRountines]           fffff8036eb71010 [mmcss.sys + 0x1010]&#xA;[+] [NotifyRountines]   Found a total of 2 EDR / security products driver(s)&#xA;[+] [NotifyRountines]   Enumerating image loading callbacks&#xA;[+] [NotifyRountines]           fffff8034e9f0820 [WdFilter.sys + 0x50820]&#xA;[+] [NotifyRountines]           Found callback belonging to EDR driver WdFilter.sys&#xA;[+] [NotifyRountines]           fffff80352ab5710 [ahcache.sys + 0x25710]&#xA;[+] [NotifyRountines]   Found a total of 1 EDR / security products driver(s)&#xA;&#xA;[+] Checking if EDR callbacks are registered on processes and threads handle creation/duplication...&#xA;[+] [ObjectCallblacks]  Enumerating Process object callbacks :&#xA;[+] [ObjectCallblacks]          Callback at FFFF800C5E2F2940 for handle creations &amp;amp; duplications:&#xA;[+] [ObjectCallblacks]                  Status: Enabled&#xA;[+] [ObjectCallblacks]                  Preoperation at 0xfffff8034e9eda30 [WdFilter.sys + 0x4da30]&#xA;[+] [ObjectCallblacks]                  Callback belongs to an EDR and is enabled!&#xA;[+] [ObjectCallblacks]  Enumerating Thread object callbacks :&#xA;[+] [ObjectCallblacks]  Object callbacks are present !&#xA;&#xA;[+] [ETWTI]     Checking the ETW Threat Intelligence Provider state...&#xA;[+] [ETWTI]     ETW Threat Intelligence Provider is ENABLED!&#xA;&#xA;[+] Process is NOT &#34;safe&#34; to launch our payload, removing monitoring and starting another process...&#xA;&#xA;[+] [ETWTI]     Disabling the ETW Threat Intel provider by patching ProviderEnableInfo at 0xffff91095ce8c430 with 0x00.&#xA;[+] [ETWTI]     The ETW Threat Intel provider was successfully disabled!&#xA;&#xA;[+] Removing kernel callbacks registered by EDR for process creation, thread creation and image loading...&#xA;[+] [NotifyRountines]   Removing process creation callbacks&#xA;[+] [NotifyRountines]   Removing callback of EDR driver &#34;WdFilter.sys&#34; [callback addr: 0xfffff8034970c2a8 | callback struct: 0xffff91095dbf3a5f | callback function: 0xfffff8034e9efdc0]&#xA;[+] [NotifyRountines]   Removing thread creation callbacks&#xA;[+] [NotifyRountines]   Removing callback of EDR driver &#34;WdFilter.sys&#34; [callback addr: 0xfffff8034970c4a0 | callback struct: 0xffff91095dbf3b1f | callback function: 0xfffff8034e9f15c0]&#xA;[+] [NotifyRountines]   Removing callback of EDR driver &#34;WdFilter.sys&#34; [callback addr: 0xfffff8034970c4a8 | callback struct: 0xffff91095dbf3b4f | callback function: 0xfffff8034e9f1350]&#xA;[+] [NotifyRountines]   Removing image loading callbacks&#xA;[+] [NotifyRountines]   Removing callback of EDR driver &#34;WdFilter.sys&#34; [callback addr: 0xfffff8034970c6a0 | callback struct: 0xffff91095dbf3e4f | callback function: 0xfffff8034e9f0820]&#xA;&#xA;[+] Disabling kernel callbacks registered by EDR for process and thread opening or handle duplication...&#xA;[+] [ObjectCallblacks]  Disabling WdFilter.sys callback...&#xA;&#xA;[+] All EDR drivers were successfully removed from Kernel callbacks!&#xA;&#xA;==================================================&#xA;Starting a new unmonitored process...&#xA;==================================================&#xA;&#xA;[!] If kernel mode bypass is enabled, it is recommended to enable usermode bypass as well (e.g. to unhook the NtLoadDriver API call)&#xA;&#xA;[===== KERNEL MODE =====]&#xA;&#xA;[+] Setting up prerequisites for the kernel read/write primitives...&#xA;[+] Loading kernel related offsets from the CSV file&#xA;[*] System&#39;s ntoskrnl.exe file version is: ntoskrnl_22621-1702.exe&#xA;[+] Offsets are available for this version of ntoskrnl.exe (ntoskrnl_22621-1702.exe)!&#xA;[+] Checking if any EDR kernel notify rountines are set for image loading, process and thread creations...&#xA;[+] [NotifyRountines]   Enumerating process creation callbacks&#xA;[+] Running command: GodFault.exe -t 8344&#xA; [+] Thread 8344 (KTHREAD FFFF91096169F080) has been blessed by GodFault&#xA; [+] Initial blessing successful&#xA;[+] [NotifyRountines]           fffff8034df25500 [cng.sys + 0x5500]&#xA;[+] [NotifyRountines]           fffff803487bc460 [ksecdd.sys + 0x1c460]&#xA;[+] [NotifyRountines]           fffff8034eff3fd0 [tcpip.sys + 0x13fd0]&#xA;[+] [NotifyRountines]           fffff8034f5ed980 [iorate.sys + 0xd980]&#xA;[+] [NotifyRountines]           fffff8034dea8890 [CI.dll + 0x88890]&#xA;[+] [NotifyRountines]           fffff803525079f0 [dxgkrnl.sys + 0x179f0]&#xA;[+] [NotifyRountines]           fffff80352be0a70 [vm3dmp.sys + 0x10a70]&#xA;[+] [NotifyRountines]           fffff8036ebccd00 [peauth.sys + 0x3cd00]&#xA;[+] [NotifyRountines]           fffff8036eda1550 [wtd.sys + 0x1550]&#xA;[+] [NotifyRountines]   No EDR driver(s) found!&#xA;[+] [NotifyRountines]   Enumerating thread creation callbacks&#xA;[+] [NotifyRountines]           fffff8036eb71010 [mmcss.sys + 0x1010]&#xA;[+] [NotifyRountines]   No EDR driver(s) found!&#xA;[+] [NotifyRountines]   Enumerating image loading callbacks&#xA;[+] [NotifyRountines]           fffff80352ab5710 [ahcache.sys + 0x25710]&#xA;[+] [NotifyRountines]   No EDR driver(s) found!&#xA;&#xA;[+] Checking if EDR callbacks are registered on processes and threads handle creation/duplication...&#xA;[+] [ObjectCallblacks]  Enumerating Process object callbacks :&#xA;[+] [ObjectCallblacks]          Callback at FFFF800C5E2F2940 for handle creations &amp;amp; duplications:&#xA;[+] [ObjectCallblacks]                  Status: Disabled&#xA;[+] [ObjectCallblacks]                  Preoperation at 0xfffff8034e9eda30 [WdFilter.sys + 0x4da30]&#xA;[+] [ObjectCallblacks]                  Callback belongs to an EDR but is disabled.&#xA;[+] [ObjectCallblacks]  Enumerating Thread object callbacks :&#xA;[+] [ObjectCallblacks]  Object callbacks are not found !&#xA;&#xA;[+] [ETWTI]     Checking the ETW Threat Intelligence Provider state...&#xA;[+] [ETWTI]     ETW Threat Intelligence Provider is DISABLED!&#xA;&#xA;[+] Process is &#34;safe&#34; to launch our payload&#xA;&#xA;[+] Kernel callbacks have normally been removed, starting cmd.exe&#xA;WARNING: EDR kernel callbacks will be restored after exiting the cmd prompt (by typing exit)&#xA;WARNING: While unlikely, the longer the callbacks are removed, the higher the chance of being detected / causing a BSoD upon restore is!&#xA;&#xA;Microsoft Windows [Version 10.0.22621.1702]&#xA;(c) Microsoft Corporation. All rights reserved.&#xA;&#xA;C:\Users\user\Desktop\Offsets&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ðŸ‘‡ Original README below ðŸ‘‡&lt;/p&gt; &#xA;&lt;h1&gt;EDRSandBlast&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;EDRSandBlast&lt;/code&gt; is a tool written in &lt;code&gt;C&lt;/code&gt; that weaponize a vulnerable signed driver to bypass EDR detections (Notify Routine callbacks, Object Callbacks and &lt;code&gt;ETW TI&lt;/code&gt; provider) and &lt;code&gt;LSASS&lt;/code&gt; protections. Multiple userland unhooking techniques are also implemented to evade userland monitoring.&lt;/p&gt; &#xA;&lt;p&gt;As of release, combination of userland (&lt;code&gt;--usermode&lt;/code&gt;) and Kernel-land (&lt;code&gt;--kernelmode&lt;/code&gt;) techniques were used to dump &lt;code&gt;LSASS&lt;/code&gt; memory under EDR scrutiny, without being blocked nor generating &#34;OS Credential Dumping&#34;-related events in the product (cloud) console. The tests were performed on 3 distinct EDR products and were successful in each case.&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;h3&gt;EDR bypass through Kernel Notify Routines removal&lt;/h3&gt; &#xA;&lt;p&gt;EDR products use Kernel &#34;Notify Routines&#34; callbacks on Windows to be notified by the kernel of system activity, such as process and thread creation and loading of images (&lt;code&gt;exe&lt;/code&gt; / &lt;code&gt;DLL&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;These Kernel callbacks are defined from kernel-land, usually from the driver implementing the callbacks, using a number of documented APIs (&lt;code&gt;nt!PsSetCreateProcessNotifyRoutine&lt;/code&gt;, &lt;code&gt;nt!PsSetCreateThreadNotifyRoutine&lt;/code&gt;, etc.). These APIs add driver-supplied callback routines to undocumented arrays of routines in Kernel-space:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;PspCreateProcessNotifyRoutine&lt;/code&gt; for process creation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PspCreateThreadNotifyRoutine&lt;/code&gt; for thread creation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PspLoadImageNotifyRoutine&lt;/code&gt; for image loading&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;EDRSandBlast&lt;/code&gt; enumerates the routines defined in those arrays and remove any callback routine linked to a predefined list of EDR drivers (more than 1000 drivers of security products supported, see the &lt;a href=&#34;https://raw.githubusercontent.com/gabriellandau/EDRSandblast-GodFault/main/#edr-drivers-and-processes-detection&#34;&gt;EDR driver detection section&lt;/a&gt;. The enumeration and removal are made possible through the exploitation of an arbitrary Kernel memory read / write primitive provided by the exploitation of a vulnerable driver (see &lt;a href=&#34;https://raw.githubusercontent.com/gabriellandau/EDRSandblast-GodFault/main/#vulnerable-drivers-detection&#34;&gt;Vulnerable drivers section&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The offsets of the aforementioned arrays are recovered using multiple techniques, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/gabriellandau/EDRSandblast-GodFault/main/#ntoskrnl-and-wdigest-offsets&#34;&gt;Offsets section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;EDR bypass through Object Callbacks removal&lt;/h3&gt; &#xA;&lt;p&gt;EDR (and even EPP) products often register &#34;Object callbacks&#34; through the use of the &lt;code&gt;nt!ObRegisterCallbacks&lt;/code&gt; kernel API. These callbacks allow the security product to be notified at each handle generation on specific object types (Processes, Threads and Desktops related object callbacks are now supported by Windows). A handle generation may occur on object opening (call to &lt;code&gt;OpenProcess&lt;/code&gt;, &lt;code&gt;OpenThread&lt;/code&gt;, etc.) as well as handle duplication (call to &lt;code&gt;DuplicateHandle&lt;/code&gt;, etc.).&lt;/p&gt; &#xA;&lt;p&gt;By being notified by the kernel on each of these operations, a security product may analyze the legitimacy of the handle creation (&lt;em&gt;e.g. an unknown process is trying to open LSASS&lt;/em&gt;), and even block it if a threat is detected.&lt;/p&gt; &#xA;&lt;p&gt;At each callback registration using &lt;code&gt;ObRegisterCallbacks&lt;/code&gt;, a new item is added to the &lt;code&gt;CallbackList&lt;/code&gt; double-linked list present in the &lt;code&gt;_OBJECT_TYPE&lt;/code&gt; object describing the type of object affected by the callback (either a Process, a Thread or a Desktop). Unfortunately, these items are described by a structure that is not documented nor published in symbol files by Microsoft. However, studying it from various &lt;code&gt;ntoskrnl.exe&lt;/code&gt; versions seems to indicate that the structure did not change between (at least) Windows 10 builds 10240 and 22000 (from 2015 to 2022).&lt;/p&gt; &#xA;&lt;p&gt;The mentionned structure, representing an object callback registration, is the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct OB_CALLBACK_ENTRY_t {&#xA;    LIST_ENTRY CallbackList; // linked element tied to _OBJECT_TYPE.CallbackList&#xA;    OB_OPERATION Operations; // bitfield : 1 for Creations, 2 for Duplications&#xA;    BOOL Enabled;            // self-explanatory&#xA;    OB_CALLBACK* Entry;      // points to the structure in which it is included&#xA;    POBJECT_TYPE ObjectType; // points to the object type affected by the callback&#xA;    POB_PRE_OPERATION_CALLBACK PreOperation;      // callback function called before each handle operation&#xA;    POB_POST_OPERATION_CALLBACK PostOperation;     // callback function called after each handle operation&#xA;    KSPIN_LOCK Lock;         // lock object used for synchronization&#xA;} OB_CALLBACK_ENTRY;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;OB_CALLBACK&lt;/code&gt; structure mentionned above is also undocumented, and is defined by the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct OB_CALLBACK_t {&#xA;    USHORT Version;                           // usually 0x100&#xA;    USHORT OperationRegistrationCount;        // number of registered callbacks&#xA;    PVOID RegistrationContext;                // arbitrary data passed at registration time&#xA;    UNICODE_STRING AltitudeString;            // used to determine callbacks order&#xA;    struct OB_CALLBACK_ENTRY_t EntryItems[1]; // array of OperationRegistrationCount items&#xA;    WCHAR AltitudeBuffer[1];                  // is AltitudeString.MaximumLength bytes long, and pointed by AltitudeString.Buffer&#xA;} OB_CALLBACK;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to disable EDR-registered object callbacks, three techniques are implemented in &lt;code&gt;EDRSandblast&lt;/code&gt;; however only one is enabled for the moment.&lt;/p&gt; &#xA;&lt;h4&gt;Using the &lt;code&gt;Enabled&lt;/code&gt; field of &lt;code&gt;OB_CALLBACK_ENTRY&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;This is the default technique enabled in &lt;code&gt;EDRSandblast&lt;/code&gt;. In order to detect and disable EDR-related object callbacks, the &lt;code&gt;CallbackList&lt;/code&gt; list located in the &lt;code&gt;_OBJECT_TYPE&lt;/code&gt; objects tied to the &lt;em&gt;Process&lt;/em&gt; and &lt;em&gt;Thread&lt;/em&gt; types is browsed. Both &lt;code&gt;_OBJECT_TYPE&lt;/code&gt;s are pointed by public global symbols in the kernel, &lt;code&gt;PsProcessType&lt;/code&gt; and &lt;code&gt;PsThreadType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Each item of the list is assumed to fit the &lt;code&gt;OB_CALLBACK_ENTRY&lt;/code&gt; structure described above (assumption that seems to hold at least in all Windows 10 builds at the time of writing). Functions defined in &lt;code&gt;PreOperation&lt;/code&gt; and &lt;code&gt;PostOperation&lt;/code&gt; fields are located to checks if they belong to an EDR driver, and if so, callbacks are simply disabled toggling the &lt;code&gt;Enabled&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;p&gt;While being a pretty safe technique, it has the inconvenient of relying on an undocumented structure; to reduce the risk of unsafe manipulation of this structure, basic checks are performed to validate that some fields have the expected values :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Enabled&lt;/code&gt; is either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt; (&lt;em&gt;don&#39;t laugh, a &lt;code&gt;BOOL&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt;, so it could be anything other than &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;&lt;/em&gt;);&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Operations&lt;/code&gt; is &lt;code&gt;OB_OPERATION_HANDLE_CREATE&lt;/code&gt;, &lt;code&gt;OB_OPERATION_HANDLE_DUPLICATE&lt;/code&gt; or both;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ObjectType&lt;/code&gt; points on &lt;code&gt;PsProcessType&lt;/code&gt; or &lt;code&gt;PsThreadType&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Unlinking the &lt;code&gt;CallbackList&lt;/code&gt; of threads and process&lt;/h4&gt; &#xA;&lt;p&gt;Another strategy that do not rely on an undocumented structure (and is thus theoretically more robust against NT kernel changes) is the unlinking of the whole &lt;code&gt;CallbackList&lt;/code&gt; for both processes and threads. The &lt;code&gt;_OBJECT_TYPE&lt;/code&gt; object is the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;struct _OBJECT_TYPE {&#xA;&#x9;LIST_ENTRY TypeList;&#xA;&#x9;UNICODE_STRING Name;&#xA;&#x9;[...]&#xA;&#x9;_OBJECT_TYPE_INITIALIZER TypeInfo;&#xA;&#x9;[...]&#xA;&#x9;LIST_ENTRY CallbackList;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Making the &lt;code&gt;Flink&lt;/code&gt; and &lt;code&gt;Blink&lt;/code&gt; pointers of the &lt;code&gt;CallbackList&lt;/code&gt; &lt;code&gt;LIST_ENTRY&lt;/code&gt; point to the &lt;code&gt;LIST_ENTRY&lt;/code&gt; itself effectively make the list empty. Since the &lt;code&gt;_OBJECT_TYPE&lt;/code&gt; structure is published in the kernel&#39; symbols, the technique does not rely on hardcoded offsets/structures. However, it has some drawbacks.&lt;/p&gt; &#xA;&lt;p&gt;The first being not able to only disable callbacks from EDR; indeed, the technique affects all object callbacks that could have been registered by &#34;legitimate&#34; software. It should nevertheless be noted that object callbacks are not used by any pre-installed component on Windows 10 (at the time of writing) so disabling them should not affect the machine stability (even more so if the disabling is only temporary).&lt;/p&gt; &#xA;&lt;p&gt;The second drawback is that process or thread handle operation are really frequent (nearly continuous) in the normal functioning of the OS. As such, if the kernel write primitive used cannot perform a &lt;code&gt;QWORD&lt;/code&gt; write &#34;atomically&#34;, there is a good chance that the &lt;code&gt;_OBJECT_TYPE.CallbackList.Flink&lt;/code&gt; pointer will be accessed by the kernel in the middle of its overwriting. For instance, the MSI vulnerable driver &lt;code&gt;RTCore64.sys&lt;/code&gt; can only perform a &lt;code&gt;DWORD&lt;/code&gt; write at a time, so 2 distinct IOCTLs will be needed to overwrite the pointer, between which the kernel has a high probability of using it (resulting in a crash). On the other hand, the vulnerable DELL driver &lt;code&gt;DBUtil_2_3.sys&lt;/code&gt; can perform writes of arbitrary sizes in one IOCTL, so using this method with it does not risk causing a crash.&lt;/p&gt; &#xA;&lt;h4&gt;Disabling object callbacks altogether&lt;/h4&gt; &#xA;&lt;p&gt;One last technique we found was to disable entirely the object callbacks support for thread and processes. Inside the &lt;code&gt;_OBJECT_TYPE&lt;/code&gt; structure corresponding to the process and thread types resides a &lt;code&gt;TypeInfo&lt;/code&gt; field, following the documented &lt;code&gt;_OBJECT_TYPE_INITIALIZER&lt;/code&gt; structure. The latter contains a &lt;code&gt;ObjectTypeFlags&lt;/code&gt; bit field, whose &lt;code&gt;SupportsObjectCallbacks&lt;/code&gt; flag determines if the described object type (Process, Thread, Desktop, Token, File, etc.) supports object callback registering or not. As previously stated, only Process, Thread and Desktop object types supports these callbacks on a Windows installation at the time of writing.&lt;/p&gt; &#xA;&lt;p&gt;Since the &lt;code&gt;SupportsObjectCallbacks&lt;/code&gt; bit is checked by &lt;code&gt;ObpCreateHandle&lt;/code&gt; or &lt;code&gt;ObDuplicateObject&lt;/code&gt; before even reading the &lt;code&gt;CallbackList&lt;/code&gt; (and before executing callbacks, of course), flipping the bit at kernel runtime effectively disable all object callbacks execution.&lt;/p&gt; &#xA;&lt;p&gt;The main drawback of the method is simply that &lt;em&gt;KPP&lt;/em&gt; (&#34;&lt;em&gt;PatchGuard&lt;/em&gt;&#34;) monitors the integrity of some (all ?) &lt;code&gt;_OBJECT_TYPE&lt;/code&gt; structures, and triggers a &lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0x109---critical-structure-corruption&#34;&gt;&lt;code&gt;0x109 Bug Check&lt;/code&gt;&lt;/a&gt; with parameter 4 being equal to &lt;code&gt;0x8&lt;/code&gt;, meaning an object type structure has been altered.&lt;/p&gt; &#xA;&lt;p&gt;However, performing the disabling / re-enabling (and &#34;malicious&#34; action in-between) quickly enough should be enough to &#34;race&#34; &lt;em&gt;PatchGuard&lt;/em&gt; (unless you are unlucky and a periodic check is performed just at the wrong moment).&lt;/p&gt; &#xA;&lt;h3&gt;EDR bypass through deactivation of the ETW Microsoft-Windows-Threat-Intelligence provider&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;ETW Microsoft-Windows-Threat-Intelligence&lt;/code&gt; provider logs data about the usages of some Windows API commonly used maliciously. This include the &lt;code&gt;nt!MiReadWriteVirtualMemory&lt;/code&gt; API, called by &lt;code&gt;nt!NtReadVirtualMemory&lt;/code&gt; (which is used to dump &lt;code&gt;LSASS&lt;/code&gt; memory) and monitored by the &lt;code&gt;nt!EtwTiLogReadWriteVm&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;EDR products can consume the logs produced by the &lt;code&gt;ETW TI&lt;/code&gt; provider through services or processes running as, respectively, &lt;code&gt;SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT&lt;/code&gt; or &lt;code&gt;PS_PROTECTED_ANTIMALWARE_LIGHT&lt;/code&gt;, and associated with an &lt;code&gt;Early Launch Anti Malware (ELAM)&lt;/code&gt; driver.&lt;/p&gt; &#xA;&lt;p&gt;As published by &lt;a href=&#34;https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider&#34;&gt;&lt;code&gt;slaeryan&lt;/code&gt; in a &lt;code&gt;CNO Development Labs&lt;/code&gt; blog post&lt;/a&gt;, the &lt;code&gt;ETW TI&lt;/code&gt; provider can be disabled altogether by patching, in kernel memory, its &lt;code&gt;ProviderEnableInfo&lt;/code&gt; attribute to &lt;code&gt;0x0&lt;/code&gt;. Refer to the great aforementioned blog post for more information on the technique.&lt;/p&gt; &#xA;&lt;p&gt;Similarly to the Kernel callbacks removal, the necessary &lt;code&gt;ntoskrnl.exe&lt;/code&gt; offsets (&lt;code&gt;nt!EtwThreatIntProvRegHandleOffset&lt;/code&gt;, &lt;code&gt;_ETW_REG_ENTRY&lt;/code&gt;&#39;s &lt;code&gt;GuidEntry&lt;/code&gt;, and &lt;code&gt;_ETW_GUID_ENTRY&lt;/code&gt;&#39;s &lt;code&gt;ProviderEnableInfo&lt;/code&gt;) are computed in the &lt;code&gt;NtoskrnlOffsets.csv&lt;/code&gt; file for a number of the Windows Kernel versions.&lt;/p&gt; &#xA;&lt;h3&gt;EDR bypass through userland hooking bypass&lt;/h3&gt; &#xA;&lt;h4&gt;How userland hooking works&lt;/h4&gt; &#xA;&lt;p&gt;In order to easily monitor actions that are performed by processes, EDR products often deploy a mechanism called &lt;em&gt;userland hooking&lt;/em&gt;. First, EDR products register a kernel callback (usually &lt;em&gt;image loading&lt;/em&gt; or &lt;em&gt;process creation&lt;/em&gt; callbacks, see above) that allows them to be notified upon each process start.&lt;/p&gt; &#xA;&lt;p&gt;When a process is loaded by Windows, and before it actually starts, the EDR is able to inject some custom DLL into the process address space, which contains its monitoring logic. While loading, this DLL injects &#34;&lt;em&gt;hooks&lt;/em&gt;&#34; at the start of every function that is to be monitored by the EDR. At runtime, when the monitored functions are called by the process under surveillance, these hooks redirect the control flow to some supervision code present in the EDR&#39;s DLL, which allows it to inspect arguments and return values of these calls.&lt;/p&gt; &#xA;&lt;p&gt;Most of the time, monitored functions are system calls (such as &lt;code&gt;NtReadVirtualMemory&lt;/code&gt;, &lt;code&gt;NtOpenProcess&lt;/code&gt;, etc.), whose implementations reside in &lt;code&gt;ntdll.dll&lt;/code&gt;. Intercepting calls to &lt;code&gt;Nt*&lt;/code&gt; functions allows products to be as close as possible to the userland / kernel-land boundary (while remaining in userland), but functions from some higher-level DLLs may also be monitored as well.&lt;/p&gt; &#xA;&lt;p&gt;Bellow are examples of the same function, before and after beeing hooked by the EDR product:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;NtProtectVirtualMemory   proc near&#xA;&#x9;mov r10, rcx&#xA;&#x9;mov eax, 50h&#xA;&#x9;test byte ptr ds:7FFE0308h, 1&#xA;&#x9;jnz short loc_18009D1E5&#xA;&#x9;syscall&#xA;&#x9;retn&#xA;loc_18009D1E5:&#xA;&#x9;int 2Eh&#xA;&#x9;retn&#xA;NtProtectVirtualMemory   endp&#x9;&#x9;&#x9;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;NtProtectVirtualMemory proc near&#xA;&#x9;jmp     sub_7FFC74490298     ; --&amp;gt; &#34;hook&#34;, jump to EDR analysis function&#xA;&#x9;int 3                        ; overwritten instructions&#xA;&#x9;int 3                        ; overwritten instructions&#xA;&#x9;int 3                        ; overwritten instructions&#xA;&#x9;test byte_7FFE0308, 1        ; &amp;lt;-- execution resumes here after analysis&#xA;&#x9;jnz short loc_7FFCB44AD1E5&#xA;&#x9;syscall&#xA;&#x9;retn&#xA;loc_7FFCB44AD1E5:&#xA;&#x9;int 2Eh&#xA;&#x9;retn&#xA;NtProtectVirtualMemory   endp&#x9;&#x9;&#x9;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Hooks detection&lt;/h4&gt; &#xA;&lt;p&gt;Userland hooks have the &#34;weakness&#34; to be located in userland memory, which means they are directly observable and modifiable by the process under scrutiny. To automatically detect hooks in the process address space, the main idea is to compare the differences between the original DLL on disk and the library residing in memory, that has been potentially altered by an EDR. To perform this comparison, the following steps are followed by EDRSandblast:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The list of all loaded DLLs is enumerated thanks to the &lt;code&gt;InLoadOrderModuleList&lt;/code&gt; located int the &lt;code&gt;PEB&lt;/code&gt; (to avoid calling any API that could be monitored and suspicious)&lt;/li&gt; &#xA; &lt;li&gt;For each loaded DLL, its content on disk is read and its headers parsed. The corresponding library, residing in memory, is also parsed to identify sections, exports, etc.&lt;/li&gt; &#xA; &lt;li&gt;Relocations of the DLL are parsed and applied, by taking the base address of the corresponding loaded library into account. This allows the content of both the in-memory library and DLL originating from disk to have the exact same content (on sections where relocations are applied), and thus making the comparison reliable.&lt;/li&gt; &#xA; &lt;li&gt;Exported functions are enumerated and the first bytes of the &#34;in-memory&#34; and &#34;on-disk&#34; versions are compared. Any difference indicates an alteration that has been made after the DLL was loaded, and thus is very probably an EDR hook.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: The process can be generalized to find differences anywhere in non-writable sections and not only at the start of exported functions, for example if EDR products start to apply hooks in the middle of function :) Thus not used by the tool, this has been implemented in &lt;code&gt;findDiffsInNonWritableSections&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to bypass the monitoring performed by these hooks, multiples techniques are possible, and each has benefits and drawbacks.&lt;/p&gt; &#xA;&lt;h4&gt;Hook bypass using ... unhooking&lt;/h4&gt; &#xA;&lt;p&gt;The most intuitive method to bypass the hook-based monitoring is to remove the hooks. Since the hooks are present in memory that is reachable by the process itself, to remove a hook, the process can simply:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Change the permissions on the page where the hook is located (RX -&amp;gt; RWX or RW)&lt;/li&gt; &#xA; &lt;li&gt;Write the original bytes that are known thanks to the on-disk DLL content&lt;/li&gt; &#xA; &lt;li&gt;Change back the permissions to RX&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This approach is fairly simple, and can be used to remove every detected hook all at once. Performed by an offensive tool at its beginning, this allows the rest of the code to be completely unaware of the hooking mechnanism and perform normally without being monitored.&lt;/p&gt; &#xA;&lt;p&gt;However, it has two main drawbacks. The EDR is probably monitoring the use of &lt;code&gt;NtProtectVirtualMemory&lt;/code&gt;, so using it to change the permissions of the page where the hooks have been installed is (at least conceptually) a bad idea. Also, if a thread is executed by the EDR and periodically check the integrity of the hooks, this could also trigger some detection.&lt;/p&gt; &#xA;&lt;p&gt;For implementation details, check the &lt;code&gt;unhook()&lt;/code&gt; function&#39;s code path when &lt;code&gt;unhook_method&lt;/code&gt; is &lt;code&gt;UNHOOK_WITH_NTPROTECTVIRTUALMEMORY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important note: for simplicity, this technique is implemented in EDRSandblast as the base technique used to &lt;em&gt;showcase&lt;/em&gt; the other bypass techniques; each of them demonstrates how to obtain an unmonitored version of &lt;code&gt;NtProtectVirtualMemory&lt;/code&gt;, but performs the same operation afterward (unhooking a specific hook).&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Hook bypass using a custom trampoline&lt;/h4&gt; &#xA;&lt;p&gt;To bypass a specific hook, it is possible to simply &#34;jump over&#34; and execute the rest of the function as is. First, the original bytes of the monitored function, that have been overwritten by the EDR to install the hook, must be recovered from the DLL file. In our previous code example, this would be the bytes corresponding to the following instructions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;mov r10, rcx&#xA;mov eax, 50h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Identifying these bytes is a simple task since we are able to perform a clean &lt;em&gt;diff&lt;/em&gt; of both the memory and disk versions of the library, as previously described. Then, we assemble a jump instruction that is built to redirect the control flow to the code following immediately the hook, at address &lt;code&gt;NtProtectVirtualMemory + sizeof(overwritten_instructions)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;jmp NtProtectVirtualMemory+8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, we concatenate these opcodes, store them in (newly) executable memory and keep a pointer to them. This object is called a &#34;&lt;em&gt;trampoline&lt;/em&gt;&#34; and can then be used as a function pointer, strictly equivalent to the original &lt;code&gt;NtProtectVirtualMemory&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;The main benefit of this technique as for every techniques bellow, is that the hook is never erased, so any integrity check performed on the hooks by the EDR should pass. However, it requires to allocate writable then executable memory, which is typical of a shellcode allocation, thus attracting the EDR&#39;s scrutiny.&lt;/p&gt; &#xA;&lt;p&gt;For implementation details, check the &lt;code&gt;unhook()&lt;/code&gt; function&#39;s code path when &lt;code&gt;unhook_method&lt;/code&gt; is &lt;code&gt;UNHOOK_WITH_INHOUSE_NTPROTECTVIRTUALMEMORY_TRAMPOLINE&lt;/code&gt;. Please remember the technique is only showcased in our implementation and is, in the end, used to &lt;strong&gt;remove&lt;/strong&gt; hooks from memory, as every technique bellow.&lt;/p&gt; &#xA;&lt;h4&gt;Hook bypass using the own EDR&#39;s trampoline&lt;/h4&gt; &#xA;&lt;p&gt;The EDR product, in order for its hook to work, must save somewhere in memory the opcodes that it has removed. Worst (&lt;em&gt;or &#34;better&#34;, from the attacker point of view&lt;/em&gt;), to effectively use the original instructions the EDR has probably allocated itself a &lt;em&gt;trampoline&lt;/em&gt; somewhere to execute the original function after having intercepted the call.&lt;/p&gt; &#xA;&lt;p&gt;This trampoline can be searched for and used as a replacement for the hooked function, without the need to allocate executable memory, or call any API except &lt;code&gt;VirtualQuery&lt;/code&gt;, which is most likely not monitored being an innocuous function.&lt;/p&gt; &#xA;&lt;p&gt;To find the trampoline in memory, we browse the whole address space using &lt;code&gt;VirtualQuery&lt;/code&gt; looking for commited and executable memory. For each such region of memory, we scan it to look for a jump instruction that targets the address following the overwritten instructions (&lt;code&gt;NtProtectVirtualMemory+8&lt;/code&gt; in our previous example). The trampoline can then be used to call the hooked function without triggering the hook.&lt;/p&gt; &#xA;&lt;p&gt;This technique works surprisingly well as it recovers nearly all trampolines on tested EDR. For implementation details, check the &lt;code&gt;unhook()&lt;/code&gt; function&#39;s code path when &lt;code&gt;unhook_method&lt;/code&gt; is &lt;code&gt;UNHOOK_WITH_EDR_NTPROTECTVIRTUALMEMORY_TRAMPOLINE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Hook bypass using duplicate DLL&lt;/h4&gt; &#xA;&lt;p&gt;Another simple method to get access to an unmonitored version of &lt;code&gt;NtProtectVirtualMemory&lt;/code&gt; function is to load a duplicate version of the &lt;code&gt;ntdll.dll&lt;/code&gt; library into the process address space. Since two identical DLLs can be loaded in the same process, provided they have different names, we can simply copy the legitimate &lt;code&gt;ntdll.dll&lt;/code&gt; file into another location, load it using &lt;code&gt;LoadLibrary&lt;/code&gt; (or reimplement the loading process), and access the function using &lt;code&gt;GetProcAddress&lt;/code&gt; for example.&lt;/p&gt; &#xA;&lt;p&gt;This technique is very simple to understand and implement, and have a decent chance of success, since most of EDR products does not re-install hooks on newly loaded DLLs once the process is running. However, the major drawback is that copying Microsoft signed binaries under a different name is often considered as suspicious by EDR products as itself.&lt;/p&gt; &#xA;&lt;p&gt;This technique is nevertheless implemented in &lt;code&gt;EDRSandblast&lt;/code&gt;. For implementation details, check the &lt;code&gt;unhook()&lt;/code&gt; function&#39;s code path when &lt;code&gt;unhook_method&lt;/code&gt; is &lt;code&gt;UNHOOK_WITH_DUPLICATE_NTPROTECTVIRTUALMEMORY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Hook bypass using direct syscalls&lt;/h4&gt; &#xA;&lt;p&gt;In order to use system calls related functions, one program can reimplement syscalls (in assembly) in order to call the corresponding OS features without actually touching the code in &lt;code&gt;ntdll.dll&lt;/code&gt;, which might be monitored by the EDR. This completely bypasses any userland hooking done on syscall functions in &lt;code&gt;ntdll.dll&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This nevertheless has some drawbacks. First, this implies being able to know the list of syscall numbers of functions the program needs, which changes for each version of Windows. This is nevertheless mitigated by implementing multiple heuristics that are known to work in all the past versions of Windows NT (sorting &lt;code&gt;ntdll&lt;/code&gt;&#39;s&#39; &lt;code&gt;Zw*&lt;/code&gt; exports, searching for &lt;code&gt;mov rax, #syscall_number&lt;/code&gt; instruction in the associated &lt;code&gt;ntdll&lt;/code&gt; function, etc.), and checking they all return the same result (see &lt;code&gt;Syscalls.c&lt;/code&gt; for more details).&lt;/p&gt; &#xA;&lt;p&gt;Also, functions that are not technically syscalls (e.g. &lt;code&gt;LoadLibraryX&lt;/code&gt;/&lt;code&gt;LdrLoadDLL&lt;/code&gt;) could be monitored as well, and cannot simply be reimplemented using a syscall.&lt;/p&gt; &#xA;&lt;p&gt;The direct syscalls technique is implemented in EDRSandblast. As previously stated, it is only used to execute &lt;code&gt;NtProtectVirtualMemory&lt;/code&gt; safely, and remove all detected hooks.&lt;/p&gt; &#xA;&lt;p&gt;For implementation details, check the &lt;code&gt;unhook()&lt;/code&gt; function&#39;s code path when &lt;code&gt;unhook_method&lt;/code&gt; is &lt;code&gt;UNHOOK_WITH_DIRECT_SYSCALL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Vulnerable drivers exploitation&lt;/h3&gt; &#xA;&lt;p&gt;As previously stated, every action that needs a kernel memory read or write relies on a vulnerable driver to give this primitive. In EDRSanblast, adding the support for a new driver providing the read/write primitive can be &#34;easily&#34; done, only three functions need to be implemented:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;code&gt;ReadMemoryPrimitive_DRIVERNAME(SIZE_T Size, DWORD64 Address, PVOID Buffer)&lt;/code&gt; function, that copies &lt;code&gt;Size&lt;/code&gt; bytes from kernel address &lt;code&gt;Address&lt;/code&gt; to userland buffer &lt;code&gt;Buffer&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;WriteMemoryPrimitive_DRIVERNAME(SIZE_T Size, DWORD64 Address, PVOID Buffer)&lt;/code&gt; function, that copies &lt;code&gt;Size&lt;/code&gt; bytes from userland buffer &lt;code&gt;Buffer&lt;/code&gt; to kernel address &lt;code&gt;Address&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;CloseDriverHandle_DRIVERNAME()&lt;/code&gt; that ensures all handles to the driver are closed (needed before uninstall operation which is driver-agnostic, for the moment).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As an example, two drivers are currently supported by EDRSandblast, &lt;code&gt;RTCore64.sys&lt;/code&gt; (SHA256: &lt;code&gt;01AA278B07B58DC46C84BD0B1B5C8E9EE4E62EA0BF7A695862444AF32E87F1FD&lt;/code&gt;) and &lt;code&gt;DBUtils_2_3.sys&lt;/code&gt; (SHA256: &lt;code&gt;0296e2ce999e67c76352613a718e11516fe1b0efc3ffdb8918fc999dd76a73a5&lt;/code&gt;). The following code in &lt;code&gt;KernelMemoryPrimitives.h&lt;/code&gt; is to be updated if the used vulnerable driver needs to be changed, or if a new one implemented.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define RTCore 0&#xA;#define DBUtil 1&#xA;// Select the driver to use with the following #define&#xA;#define VULN_DRIVER RTCore&#xA;&#xA;#if VULN_DRIVER == RTCore&#xA;#define DEFAULT_DRIVER_FILE TEXT(&#34;RTCore64.sys&#34;)&#xA;#define CloseDriverHandle CloseDriverHandle_RTCore&#xA;#define ReadMemoryPrimitive ReadMemoryPrimitive_RTCore&#xA;#define WriteMemoryPrimitive WriteMemoryPrimitive_RTCore&#xA;#elif VULN_DRIVER == DBUtil&#xA;#define DEFAULT_DRIVER_FILE TEXT(&#34;DBUtil_2_3.sys&#34;)&#xA;#define CloseDriverHandle CloseDriverHandle_DBUtil&#xA;#define ReadMemoryPrimitive ReadMemoryPrimitive_DBUtil&#xA;#define WriteMemoryPrimitive WriteMemoryPrimitive_DBUtil&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;EDR drivers and processes detection&lt;/h3&gt; &#xA;&lt;p&gt;Multiple techniques are currently used to determine if a specific driver or process belongs to an EDR product or not.&lt;/p&gt; &#xA;&lt;p&gt;First, the name of the driver can simply be used for that purpose. Indeed, Microsoft allocates specific numbers called &#34;Altitudes&#34; for all drivers that need to insert callbacks in the kernel. This allow a deterministic order in callbacks execution, independent from the registering order, but only based on the driver usage. A list of (vendors of) drivers that have reserved specific &lt;em&gt;altitude&lt;/em&gt; can be found &lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/allocated-altitudes&#34;&gt;on MSDN&lt;/a&gt;. As a consequence, a nearly comprehensive list of security driver names tied to security products is offered by Microsoft, mainly in the &#34;FSFilter Anti-Virus&#34; and &#34;FSFilter Activity Monitor&#34; lists. These lists of driver names are embedded in EDRSandblast, as well as additional contributions.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, EDR executables and DLL are more than often digitally signed using the vendors signing certificate. Thus, checking the signer of an executable or DLL associated to a process may allow to quickly identify EDR products.&lt;/p&gt; &#xA;&lt;p&gt;Also, drivers need to be directly signed by Microsoft to be allowed to be loaded in kernel space. While the driver&#39;s vendor is not directly the signer of the driver itself, it would seam that the vendor&#39;s name is still included inside an attribute of the signature; this detection technique is nevertheless yet to be investigated and implemented.&lt;/p&gt; &#xA;&lt;p&gt;Finally, when facing an EDR unknown to EDRSandblast, the best approach is to run the tool in &#34;audit&#34; mode, and check the list of drivers having registered kernel callbacks; then the driver&#39;s name can be added to the list, the tool recompiled and re-run.&lt;/p&gt; &#xA;&lt;h3&gt;RunAsPPL bypass&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Local Security Authority (LSA) Protection&lt;/code&gt; mechanism, first introduced in Windows 8.1 and Windows Server 2012 R2, leverage the &lt;code&gt;Protected Process Light (PPL)&lt;/code&gt; technology to restrict access to the &lt;code&gt;LSASS&lt;/code&gt; process. The &lt;code&gt;PPL&lt;/code&gt; protection regulates and restricts operations, such as memory injection or memory dumping of protected processes, even from a process holding the &lt;code&gt;SeDebugPrivilege&lt;/code&gt; privilege. Under the process protection model, only processes running with higher protection levels can perform operations on protected processes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;_EPROCESS&lt;/code&gt; structure, used by the Windows kernel to represent a process in kernel memory, includes a &lt;code&gt;_PS_PROTECTION&lt;/code&gt; field defining the protection level of a process through its &lt;code&gt;Type&lt;/code&gt; (&lt;code&gt;_PS_PROTECTED_TYPE&lt;/code&gt;) and &lt;code&gt;Signer&lt;/code&gt; (&lt;code&gt;_PS_PROTECTED_SIGNER&lt;/code&gt;) attributes.&lt;/p&gt; &#xA;&lt;p&gt;By writing in kernel memory, the EDRSandblast process is able to upgrade its own protection level to &lt;code&gt;PsProtectedSignerWinTcb-Light&lt;/code&gt;. This level is sufficient to dump the &lt;code&gt;LSASS&lt;/code&gt; process memory, since it &#34;dominates&#34; to &lt;code&gt;PsProtectedSignerLsa-Light&lt;/code&gt;, the protection level of the &lt;code&gt;LSASS&lt;/code&gt; process running with the &lt;code&gt;RunAsPPL&lt;/code&gt; mechanism.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EDRSandBlast&lt;/code&gt; implements the self protection as follow:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;open a handle to the current process&lt;/li&gt; &#xA; &lt;li&gt;leak all system handles using &lt;code&gt;NtQuerySystemInformation&lt;/code&gt; to find the opened handle on the current process, and the address of the current process&#39; &lt;code&gt;EPROCESS&lt;/code&gt; structure in kernel memory.&lt;/li&gt; &#xA; &lt;li&gt;use the arbitrary read / write vulnerability of the &lt;code&gt;Micro-Star MSI Afterburner&lt;/code&gt; driver to overwrite the &lt;code&gt;_PS_PROTECTION&lt;/code&gt; field of the current process in kernel memory. The offsets of the &lt;code&gt;_PS_PROTECTION&lt;/code&gt; field relative to the &lt;code&gt;EPROCESS&lt;/code&gt; structure (defined by the &lt;code&gt;ntoskrnl&lt;/code&gt; version in use) are computed in the &lt;code&gt;NtoskrnlOffsets.csv&lt;/code&gt; file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Credential Guard bypass&lt;/h3&gt; &#xA;&lt;p&gt;Microsoft &lt;code&gt;Credential Guard&lt;/code&gt; is a virtualization-based isolation technology, introduced in Microsoft&#39;s &lt;code&gt;Windows 10 (Enterprise edition)&lt;/code&gt; which prevents direct access to the credentials stored in the &lt;code&gt;LSASS&lt;/code&gt; process.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;Credentials Guard&lt;/code&gt; is activated, an &lt;code&gt;LSAIso&lt;/code&gt; (&lt;em&gt;LSA Isolated&lt;/em&gt;) process is created in &lt;code&gt;Virtual Secure Mode&lt;/code&gt;, a feature that leverages the virtualization extensions of the CPU to provide added security of data in memory. Access to the &lt;code&gt;LSAIso&lt;/code&gt; process are restricted even for an access with the &lt;code&gt;NT AUTHORITY\SYSTEM&lt;/code&gt; security context. When processing a hash, the &lt;code&gt;LSA&lt;/code&gt; process perform a &lt;code&gt;RPC&lt;/code&gt; call to the &lt;code&gt;LSAIso&lt;/code&gt; process, and waits for the &lt;code&gt;LSAIso&lt;/code&gt; result to continue. Thus, the &lt;code&gt;LSASS&lt;/code&gt; process won&#39;t contain any secrets and in place will store &lt;code&gt;LSA Isolated Data&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As stated in original research conducted by &lt;code&gt;N4kedTurtle&lt;/code&gt;: &#34;&lt;code&gt;Wdigest&lt;/code&gt; can be enabled on a system with Credential Guard by patching the values of &lt;code&gt;g_fParameter_useLogonCredential&lt;/code&gt; and &lt;code&gt;g_IsCredGuardEnabled&lt;/code&gt; in memory&#34;. The activation of &lt;code&gt;Wdigest&lt;/code&gt; will result in cleartext credentials being stored in &lt;code&gt;LSASS&lt;/code&gt; memory for any new interactive logons (without requiring a reboot of the system). Refer to the &lt;a href=&#34;https://teamhydra.blog/2020/08/25/bypassing-credential-guard/&#34;&gt;original research blog post&lt;/a&gt; for more details on this technique.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EDRSandBlast&lt;/code&gt; simply make the original PoC a little more opsec friendly and provide support for a number of &lt;code&gt;wdigest.dll&lt;/code&gt; versions (through computed offsets for &lt;code&gt;g_fParameter_useLogonCredential&lt;/code&gt; and &lt;code&gt;g_IsCredGuardEnabled&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Offsets retrieval&lt;/h3&gt; &#xA;&lt;p&gt;In order to reliably perform kernel monitoring bypass operations, EDRSandblast needs to know exactly where to read and write kernel memory. This is done using offsets of global variables inside the targeted image (ntoskrnl.exe, wdigest.dll), as well as offset of specific fields in structures whose definitions are published by Microsoft in symbol files. These offsets are specific to each build of the targeted images, and must be gathered at least once for a specific platform version.&lt;/p&gt; &#xA;&lt;p&gt;The choice of using &#34;hardcoded&#34; offsets instead of pattern searches to locate the structures and variables used by EDRSandblast is justified by the fact that the undocumented APIs responsible for Kernel callbacks addition / removal are subject to change and that any attempt to read or write Kernel memory at the wrong address may (and often will) result in a &lt;code&gt;Bug Check&lt;/code&gt; (&lt;code&gt;Blue Screen of Death&lt;/code&gt;). A machine crash is not acceptable in both red-teaming and normal penetration testing scenarios, since a machine that crashes is highly visible by defenders, and will lose any credentials that was still in memory at the moment of the attack.&lt;/p&gt; &#xA;&lt;p&gt;To retrieve offsets for each specific version of Windows, two approaches are implemented.&lt;/p&gt; &#xA;&lt;h4&gt;Manual offset retrieval&lt;/h4&gt; &#xA;&lt;p&gt;The required &lt;code&gt;ntoskrnl.exe&lt;/code&gt; and &lt;code&gt;wdigest.dll&lt;/code&gt; offsets can be extracted using the provided &lt;code&gt;ExtractOffsets.py&lt;/code&gt; Python script, that relies on &lt;code&gt;radare2&lt;/code&gt; and &lt;code&gt;r2pipe&lt;/code&gt; to download and parse symbols from PDB files, and extracted the needed offsets from them. Offsets are then stored in CSV files for later use by EDRSandblast.&lt;/p&gt; &#xA;&lt;p&gt;In order to support out-of-the-box a wide range of Windows builds, many versions of the &lt;code&gt;ntoskrnl.exe&lt;/code&gt; and &lt;code&gt;wdigest.dll&lt;/code&gt; binaries are referenced by &lt;a href=&#34;https://winbindex.m417z.com/&#34;&gt;Winbindex&lt;/a&gt; , and can be automatically downloaded (and their offsets extracted) by the &lt;code&gt;ExtractOffsets.py&lt;/code&gt;. This allows to extract offsets from nearly all files that were ever published in Windows update packages (to date 450+ &lt;code&gt;ntoskrnl.exe&lt;/code&gt; and 30+ &lt;code&gt;wdigest.dll&lt;/code&gt; versions are available and pre-computed).&lt;/p&gt; &#xA;&lt;h4&gt;Automatic offsets retrieval and update&lt;/h4&gt; &#xA;&lt;p&gt;An additionnal option has been implemented in &lt;code&gt;EDRSandBlast&lt;/code&gt; to allow the program to download the needed &lt;code&gt;.pdb&lt;/code&gt; files itself from Microsoft Symbol Server, extract the required offsets, and even update the corresponding &lt;code&gt;.csv&lt;/code&gt; files if present.&lt;/p&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;--internet&lt;/code&gt; option make the tool execution much simpler, while introducing an additionnal OpSec risk, since a &lt;code&gt;.pdb&lt;/code&gt; file is downloaded and dropped on disk during the process. This is required by the &lt;code&gt;dbghelp.dll&lt;/code&gt; functions used to parse the symbols database ; however, full in-memory PDB parsing might be implemented in the future to lift this requirement and reduce the tool&#39;s footprint.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The vulnerable &lt;code&gt;RTCore64.sys&lt;/code&gt; driver can be retrieved at:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://download-eu2.guru3d.com/afterburner/%5BGuru3D.com%5D-MSIAfterburnerSetup462Beta2.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Quick usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: EDRSandblast.exe [-h | --help] [-v | --verbose] &amp;lt;audit | dump | cmd | credguard&amp;gt; [--usermode [--unhook-method &amp;lt;N&amp;gt;]] [--kernelmode] [--dont-unload-driver] [--dont-restore-callbacks] [--driver &amp;lt;RTCore64.sys&amp;gt;] [--service &amp;lt;SERVICE_NAME&amp;gt;] [--nt-offsets &amp;lt;NtoskrnlOffsets.csv&amp;gt;] [--wdigest-offsets &amp;lt;WdigestOffsets.csv&amp;gt;] [--add-dll &amp;lt;dll name or path&amp;gt;]* [-o | --dump-output &amp;lt;DUMP_FILE&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Options&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;-h | --help             Show this help message and exit.&#xA;-v | --verbose          Enable a more verbose output.&#xA;&#xA;Actions mode:&#xA;&#xA;        audit           Display the user-land hooks and / or Kernel callbacks without taking actions.&#xA;        dump            Dump the LSASS process, by default as &#39;lsass&#39; in the current directory or at the&#xA;                        specified file using -o | --output &amp;lt;DUMP_FILE&amp;gt;.&#xA;        cmd             Open a cmd.exe prompt.&#xA;        credguard       Patch the LSASS process&#39; memory to enable Wdigest cleartext passwords caching even if&#xA;                        Credential Guard is enabled on the host. No kernel-land actions required.&#xA;&#xA;--usermode              Perform user-land operations (DLL unhooking).&#xA;--kernelmode            Perform kernel-land operations (Kernel callbacks removal and ETW TI disabling).&#xA;&#xA;--unhook-method &amp;lt;N&amp;gt;&#xA;   Choose the userland un-hooking technique, from the following:&#xA;&#xA;        1 (Default)     Uses the (probably monitored) NtProtectVirtualMemory function in ntdll to remove all&#xA;                        present userland hooks.&#xA;        2               Constructs a &#39;unhooked&#39; (i.e. unmonitored) version of NtProtectVirtualMemory, by&#xA;                        allocating an executable trampoline jumping over the hook, and remove all present&#xA;                        userland hooks.&#xA;        3               Searches for an existing trampoline allocated by the EDR itself, to get an &#39;unhooked&#39;&#xA;                        (i.e. unmonitored) version of NtProtectVirtualMemory, and remove all present userland&#xA;                        hooks.&#xA;        4               Loads an additional version of ntdll library into memory, and use the (hopefully&#xA;                        unmonitored) version of NtProtectVirtualMemory present in this library to remove all&#xA;                        present userland hooks.&#xA;        5               Allocates a shellcode that uses a direct syscall to call NtProtectVirtualMemory,&#xA;                        and uses it to remove all detected hooks&#xA;&#xA;Other options:&#xA;&#xA;--dont-unload-driver                    Keep the vulnerable driver installed on the host&#xA;                                        Default to automatically unsinstall the driver.&#xA;--dont-restore-callbacks                Do not restore the EDR drivers&#39; Kernel Callbacks that were removed.&#xA;                                        Default to restore the callbacks.&#xA;&#xA;--driver &amp;lt;RTCore64.sys&amp;gt;                 Path to the vulnerable driver file.&#xA;                                        Default to &#39;RTCore64.sys&#39; in the current directory.&#xA;--service &amp;lt;SERVICE_NAME&amp;gt;                Name of the vulnerable service to intall / start.&#xA;&#xA;--nt-offsets &amp;lt;NtoskrnlOffsets.csv&amp;gt;      Path to the CSV file containing the required ntoskrnl.exe&#39;s offsets.&#xA;                                        Default to &#39;NtoskrnlOffsets.csv&#39; in the current directory.&#xA;--wdigest-offsets &amp;lt;WdigestOffsets.csv&amp;gt;  Path to the CSV file containing the required wdigest.dll&#39;s offsets&#xA;                                        (only for the &#39;credguard&#39; mode).&#xA;                                        Default to &#39;WdigestOffsets.csv&#39; in the current directory.&#xA;&#xA;--add-dll &amp;lt;dll name or path&amp;gt;            Loads arbitrary libraries into the process&#39; address space, before starting&#xA;                                        anything. This can be useful to audit userland hooking for DLL that are not&#xA;                                        loaded by default by this program. Use this option multiple times to load&#xA;                                        multiple DLLs all at once.&#xA;                                        Example of interesting DLLs to look at: user32.dll, ole32.dll, crypt32.dll,&#xA;                                        samcli.dll, winhttp.dll, urlmon.dll, secur32.dll, shell32.dll...&#xA;&#xA;-o | --output &amp;lt;DUMP_FILE&amp;gt;               Output path to the dump file that will be generated by the &#39;dump&#39; mode.&#xA;                                        Default to &#39;lsass&#39; in the current directory.&#xA;&#xA;-i | --internet                         Enables automatic symbols download from Microsoft Symbol Server&#xA;                                        If a corresponding *Offsets.csv file exists, appends the downloaded offsets to the file for later use&#xA;                                        OpSec warning: downloads and drops on disk a PDB file for ntoskrnl.exe and/or wdigest.dll&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;EDRSandBlast&lt;/code&gt; (x64 only) was built on Visual Studio 2019 (Windows SDK Version: &lt;code&gt;10.0.19041.0&lt;/code&gt; and Plateform Toolset: &lt;code&gt;Visual Studio 2019 (v142)&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;ExtractOffsets.py usage&lt;/h3&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;ExtractOffsets.py&lt;/code&gt; has only be tested on Windows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Installation of Python dependencies&#xA;pip.exe install -m .\requirements.txt&#xA;&#xA;# Script usage&#xA;ExtractOffsets.py [-h] -i INPUT [-o OUTPUT] [-d] mode&#xA;&#xA;positional arguments:&#xA;  mode                  ntoskrnl or wdigest. Mode to download and extract offsets for either ntoskrnl or wdigest&#xA;&#xA;optional arguments:&#xA;  -h, --help            show this help message and exit&#xA;  -i INPUT, --input INPUT&#xA;                        Single file or directory containing ntoskrnl.exe / wdigest.dll to extract offsets from.&#xA;                        If in download mode, the PE downloaded from MS symbols servers will be placed in this folder.&#xA;  -o OUTPUT, --output OUTPUT&#xA;                        CSV file to write offsets to. If the specified file already exists, only new ntoskrnl versions will be&#xA;                        downloaded / analyzed.&#xA;                        Defaults to NtoskrnlOffsets.csv / WdigestOffsets.csv in the current folder.&#xA;  -d, --download         Flag to download the PE from Microsoft servers using list of versions from winbindex.m417z.com.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Detection&lt;/h2&gt; &#xA;&lt;p&gt;From the defender (EDR vendor, Microsoft, SOC analysts looking at EDR&#39;s telemetry, ...) point of view, multiple indicators can be used to detect or prevent this kind of techniques.&lt;/p&gt; &#xA;&lt;h3&gt;Driver whitelisting&lt;/h3&gt; &#xA;&lt;p&gt;Since every action performed by the tool in kernel-mode memory relies on a vulnerable driver to read/write arbitrary content, driver loading events should be heaviliy scrutinized by EDR product (or SOC analysts), and raise an alert at any uncommon driver loading, or even block known vulnerable drivers. This latter approach is even &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-driver-block-rules&#34;&gt;recommended by Microsoft themselves&lt;/a&gt;: any HVCI (&lt;em&gt;Hypervisor-protected code integrity&lt;/em&gt;) enabled Windows device embeds a drivers blocklist, and this will be progressively become a default behaviour on Windows (it already is on Windows 11).&lt;/p&gt; &#xA;&lt;h3&gt;Kernel-memory integrity checks&lt;/h3&gt; &#xA;&lt;p&gt;Since an attacker could still use an unknown vulnerable driver to perform the same actions in memory, the EDR driver could periodically check that its kernel callbacks are still registered, directly by inspecting kernel memory (like this tool does), or simply by triggering events (process creation, thread creation, image loading, etc.) and checking the callback functions are indeed called by the executive kernel.&lt;/p&gt; &#xA;&lt;p&gt;As a side note, this type of data structure could be protected via the recent &lt;a href=&#34;https://www.microsoft.com/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-platform-security-technology-for-preventing-data-corruption/&#34;&gt;Kernel Data Protection (KDP)&lt;/a&gt; mechanism, which relies on Virtual Based Security, in order to make the kernel callbacks array non-writable without calling the right APIs.&lt;/p&gt; &#xA;&lt;p&gt;The same logic could apply to sensitive ETW variables such as the &lt;code&gt;ProviderEnableInfo&lt;/code&gt;, abused by this tool to disable the ETW Threat Intelligence events generation.&lt;/p&gt; &#xA;&lt;h3&gt;User-mode detection&lt;/h3&gt; &#xA;&lt;p&gt;The first indicator that a process is actively trying to evade user-land hooking is the file accesses to each DLL corresponding to loaded modules; in a normal execution, a userland process rarely needs to read DLL files outside of a &lt;code&gt;LoadLibrary&lt;/code&gt; call, especially &lt;code&gt;ntdll.dll&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to protect API hooking from being bypassed, EDR products could periodically check that hooks are not altered in memory, inside each monitored process.&lt;/p&gt; &#xA;&lt;p&gt;Finally, to detect hooking bypass (abusing a trampoline, using direct syscalls, etc.) that does not imply the hooks removal, EDR products could potentially rely on kernel callbacks associated to the abused syscalls (ex. &lt;code&gt;PsCreateProcessNotifyRoutine&lt;/code&gt; for &lt;code&gt;NtCreateProcess&lt;/code&gt; syscall, &lt;code&gt;ObRegisterCallbacks&lt;/code&gt; for &lt;code&gt;NtOpenProcess&lt;/code&gt; syscall, etc.), and perform user-mode call-stack analysis in order to determine if the syscall was triggered from a normal path (&lt;code&gt;kernel32.dll&lt;/code&gt; -&amp;gt; &lt;code&gt;ntdll.dll&lt;/code&gt; -&amp;gt; syscall) or an abnormal one (ex. &lt;code&gt;program.exe&lt;/code&gt; -&amp;gt; direct syscall).&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Kernel callbacks enumeration and removal: &lt;a href=&#34;https://github.com/br-sn/CheekyBlinder&#34;&gt;https://github.com/br-sn/CheekyBlinder&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Kernel memory Read / Write primitives through the vulnerable &lt;code&gt;Micro-Star MSI Afterburner&lt;/code&gt; driver: &lt;a href=&#34;https://github.com/Barakat/CVE-2019-16098/&#34;&gt;https://github.com/Barakat/CVE-2019-16098/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Disabling of the ETW Threat Intelligence provider: &lt;a href=&#34;https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider&#34;&gt;https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Driver install / uninstall: &lt;a href=&#34;https://github.com/gentilkiwi/mimikatz&#34;&gt;https://github.com/gentilkiwi/mimikatz&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Initial list of EDR drivers names: &lt;a href=&#34;https://github.com/SadProcessor/SomeStuff/raw/master/Invoke-EDRCheck.ps1&#34;&gt;https://github.com/SadProcessor/SomeStuff/blob/master/Invoke-EDRCheck.ps1&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Credential Guard bypass by re-enabling &lt;code&gt;Wdigest&lt;/code&gt; through &lt;code&gt;LSASS&lt;/code&gt; memory patching: &lt;a href=&#34;https://teamhydra.blog/2020/08/25/bypassing-credential-guard/&#34;&gt;https://teamhydra.blog/2020/08/25/bypassing-credential-guard/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Qazeer/&#34;&gt;Thomas DIOT (Qazeer)&lt;/a&gt; &lt;a href=&#34;https://github.com/themaks&#34;&gt;Maxime MEIGNAN (themaks)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Licence&lt;/h2&gt; &#xA;&lt;p&gt;CC BY 4.0 licence - &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;https://creativecommons.org/licenses/by/4.0/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Azure/azure-c-shared-utility</title>
    <updated>2023-09-01T01:27:27Z</updated>
    <id>tag:github.com,2023-09-01:/Azure/azure-c-shared-utility</id>
    <link href="https://github.com/Azure/azure-c-shared-utility" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Azure C SDKs common code&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;. For more information see the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/faq/&#34;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:opencode@microsoft.com&#34;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt; &#xA;&lt;h1&gt;Azure C Shared Utility&lt;/h1&gt; &#xA;&lt;p&gt;azure-c-shared-utility is a C library providing common functionality for basic tasks (like string, list manipulation, IO, etc.).&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;azure-c-shared-utility provides 3 tlsio implementations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;tlsio_schannel - runs only on Windows&lt;/li&gt; &#xA; &lt;li&gt;tlsio_openssl - depends on OpenSSL being installed&lt;/li&gt; &#xA; &lt;li&gt;tlsio_wolfssl - depends on WolfSSL being installed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;azure-c-shared-utility depends on curl for HTTPAPI for Linux.&lt;/p&gt; &#xA;&lt;p&gt;azure-c-shared-utility uses cmake for configuring build files.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone &lt;strong&gt;azure-c-shared-utility&lt;/strong&gt; using the recursive option:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --recursive https://github.com/Azure/azure-c-shared-utility.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a folder called &lt;em&gt;cmake&lt;/em&gt; under &lt;em&gt;azure-c-shared-utility&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Switch to the &lt;em&gt;cmake&lt;/em&gt; folder and run&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Build&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation and Use&lt;/h3&gt; &#xA;&lt;p&gt;Optionally, you may choose to install azure-c-shared-utility on your machine:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Switch to the &lt;em&gt;cmake&lt;/em&gt; folder and run&lt;/p&gt; &lt;pre&gt;&lt;code&gt;cmake -Duse_installed_dependencies=ON ../&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code&gt;cmake --build . --target install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or install using the follow commands for each platform:&lt;/p&gt; &lt;p&gt;On Linux:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;On Windows:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;msbuild /m INSTALL.vcxproj&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use it in your project (if installed)&lt;/p&gt; &lt;pre&gt;&lt;code&gt;find_package(azure_c_shared_utility REQUIRED CONFIG)&#xA;target_link_library(yourlib aziotsharedutil)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;If running tests, this requires that umock-c, azure-ctest, and azure-c-testrunnerswitcher are installed (through CMake) on your machine.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Building the tests&lt;/h3&gt; &#xA;&lt;p&gt;In order to build the tests use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake .. -Drun_unittests:bool=ON&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration options&lt;/h2&gt; &#xA;&lt;p&gt;In order to turn on/off the tlsio implementations use the following CMAKE options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-Duse_schannel:bool={ON/OFF}&lt;/code&gt; - turns on/off the SChannel support&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Duse_openssl:bool={ON/OFF}&lt;/code&gt; - turns on/off the OpenSSL support. If this option is used, an environment variable named OpenSSLDir should be set to point to the OpenSSL folder.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Duse_wolfssl:bool={ON/OFF}&lt;/code&gt; - turns on/off the WolfSSL support. If this option is used, an environment variable named WolfSSLDir should be set to point to the WolfSSL folder.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Duse_http:bool={ON/OFF}&lt;/code&gt; - turns on/off the HTTP API support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Duse_installed_dependencies:bool={ON/OFF}&lt;/code&gt; - turns on/off building azure-c-shared-utility using installed dependencies. This package may only be installed if this flag is ON.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Drun_unittests:bool={ON/OFF}&lt;/code&gt; - enables building of unit tests. Default is OFF.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Duse_default_uuid:bool={ON/OFF}&lt;/code&gt; - use the out-of-the-box UUID implementation that comes with the SDK rather than platform specific implementations. Default is OFF.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Dno_openssl_engine:bool={ON/OFF}&lt;/code&gt; - disables the use of ENGINEs in OpenSSL. Default is OFF.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Porting to new devices&lt;/h2&gt; &#xA;&lt;p&gt;Instructions for porting the Azure IoT C SDK to new devices are located &lt;a href=&#34;https://github.com/Azure/azure-c-shared-utility/raw/master/devdoc/porting_guide.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>