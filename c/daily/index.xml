<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-07T01:28:24Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ataradov/usb-sniffer-lite</title>
    <updated>2024-08-07T01:28:24Z</updated>
    <id>tag:github.com,2024-08-07:/ataradov/usb-sniffer-lite</id>
    <link href="https://github.com/ataradov/usb-sniffer-lite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple USB sniffer based on Raspberry Pi RP2040&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Usb Sniffer Lite for RP2040&lt;/h1&gt; &#xA;&lt;p&gt;This is a simple USB sniffer based on a Raspberry Pi RP2040. It supports Low Speed and Full Speed modes.&lt;/p&gt; &#xA;&lt;p&gt;The firmware presents itself as a virtual COM-port (VCP), so no additional software is necessary and it is compatible with all operating systems.&lt;/p&gt; &#xA;&lt;p&gt;Here are a couple of example capture logs for the &lt;a href=&#34;https://raw.githubusercontent.com/ataradov/usb-sniffer-lite/main/doc/usb_fs_enumeration.txt&#34;&gt;enumeration&lt;/a&gt; and a regular &lt;a href=&#34;https://raw.githubusercontent.com/ataradov/usb-sniffer-lite/main/doc/usb_fs_data.txt&#34;&gt;data transfer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The compiled binary is available &lt;a href=&#34;https://raw.githubusercontent.com/ataradov/usb-sniffer-lite/main/bin/UsbSnifferLite.uf2&#34;&gt;here&lt;/a&gt;. Boot RP2040 into the BootROM mode and copy the UF2 file to the drive.&lt;/p&gt; &#xA;&lt;p&gt;This sniffer has no packet decoding capabilities, but there is an excellent online &lt;a href=&#34;https://eleccelerator.com/usbdescreqparser/&#34;&gt;USB Descriptor and Request Parser&lt;/a&gt; that is very helpful with decoding of the standard descriptors and requests.&lt;/p&gt; &#xA;&lt;p&gt;The compiled binary needs to have CRC value updated to be recognized by the RP2040. This can be done using &lt;a href=&#34;https://github.com/ataradov/tools/tree/master/bin2uf2&#34;&gt;bin2uf2&lt;/a&gt; tool.&lt;/p&gt; &#xA;&lt;h2&gt;Hardware Connections&lt;/h2&gt; &#xA;&lt;p&gt;USB D+ and D- signals can be directly connected to the MCU pins. The default pin assignments are shown in the following table:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;RP2040 Pin&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Function&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;USB Cable Color&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GND&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Ground&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Black&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GPIO 10&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;D+&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Green&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GPIO 11&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;D-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;White&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GPIO 12&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Start (internal)&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GPIO 18&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Trigger&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GPIO 25&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Status LED&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GPIO 26&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Error LED&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The easiest way to connect the signals to the Raspberry Pi Pico board is to splice the USB cable. It does not have to be pretty. Below is a picture of a cable that took less than 10 minutes to make. Feel free to make it prettier.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ataradov/usb-sniffer-lite/main/doc/cable.jpg&#34; alt=&#34;USB Cable&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ataradov/usb-sniffer-lite/main/doc/Hardware.md&#34;&gt;Here&lt;/a&gt; are some pictures of a cleaner version based on the &lt;a href=&#34;https://github.com/ataradov/breakout-boards/tree/master/rp2040&#34;&gt;custom breakout board&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Trigger input is internally pulled up and the active level is low. When trigger is enabled in the settings, the capture would pause until the trigger pin is pulled low. Given the limited size of the capture buffer, trigger mechanism provides a way for the debugged target to mark the part of interest.&lt;/p&gt; &#xA;&lt;h2&gt;Dedicated Hardware&lt;/h2&gt; &#xA;&lt;p&gt;There is now a dedicated board. It integrates FE8.1 USB HUB, so you only need one connection to the host PC. This simplifies setup a lot and eliminates wiring mess that usually happens when working with USB sniffers.&lt;/p&gt; &#xA;&lt;p&gt;Normally it is not advised to use the same host port for the sniffer and the target device, but since in this case only USB Low Speed and Full Speed modes are supported, there is plenty of bandwidth for both devices.&lt;/p&gt; &#xA;&lt;p&gt;Schematics and Gerber files are available in the &lt;a href=&#34;https://raw.githubusercontent.com/ataradov/usb-sniffer-lite/main/hardware/&#34;&gt;hardware&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ataradov/usb-sniffer-lite/main/doc/usb-sniffer-lite.jpg&#34; alt=&#34;USB Sniffer Lite PCB&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Settings&lt;/h2&gt; &#xA;&lt;p&gt;The following settings are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Capture speed (e) -- Low / Full&lt;/li&gt; &#xA; &lt;li&gt;Capture trigger (g) -- Enabled / Disabled&lt;/li&gt; &#xA; &lt;li&gt;Capture limit (l) -- 100/200/500/1000/2000/5000/10000 packets / Unlimited&lt;/li&gt; &#xA; &lt;li&gt;Time display format (t) -- Relative to the first packet / previous packet / SOF / bus reset&lt;/li&gt; &#xA; &lt;li&gt;Data display format (a) -- Full / Limit to 16 bytes / Limit to 64 bytes / Do not display data&lt;/li&gt; &#xA; &lt;li&gt;Fold empty frames (f) -- Enabled / Disabled&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A frame is delimited by the SOF packet in the Full Speed mode or by a keep-alive signal in the Low Speed mode.&lt;/p&gt; &#xA;&lt;p&gt;An empty frame is a frame that contains no packets other than IN/NAK and contains no packets with errors detected. Folding of the empty frames shortens the displayed information by combining consecutive empty frames into one entry, since they don&#39;t carry useful information, but happen very often in a typical USB transaction.&lt;/p&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;The following commands are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Print the help message (h)&lt;/li&gt; &#xA; &lt;li&gt;Display current buffer (b)&lt;/li&gt; &#xA; &lt;li&gt;Start capture (s)&lt;/li&gt; &#xA; &lt;li&gt;Stop capture (p)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once capture is started and the trigger condition is met, the sniffer captures the specified number of packets. After the capture is done, the buffer is displayed using current settings.&lt;/p&gt; &#xA;&lt;p&gt;The display settings may be adjusted without a new capture. Once the buffer is captured, it is stored in the memory and can be displayed again using a &lt;code&gt;b&lt;/code&gt; command.&lt;/p&gt;</summary>
  </entry>
</feed>