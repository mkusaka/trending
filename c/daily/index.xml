<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-28T01:48:33Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>last-byte/RIPPL</title>
    <updated>2022-07-28T01:48:33Z</updated>
    <id>tag:github.com,2022-07-28:/last-byte/RIPPL</id>
    <link href="https://github.com/last-byte/RIPPL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;RIPPL is a tool that abuses a usermode only exploit to manipulate PPL processes on Windows&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RIPPL&lt;/h1&gt; &#xA;&lt;h3&gt;Manipulating PPL protected processes without using a driver&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/last-byte/RIPPL/master/defenderfunny.gif&#34; alt=&#34;defender funny&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tool implements a &lt;strong&gt;userland&lt;/strong&gt; exploit to manipulate Windows PPL protected processes. The technique was initially discussed by James Forshaw (a.k.a. &lt;a href=&#34;https://twitter.com/tiraniddo&#34;&gt;@tiraniddo&lt;/a&gt;) and Clément Labro (a.k.a. &lt;a href=&#34;https://twitter.com/itm4n&#34;&gt;@itm4n&lt;/a&gt;) in the following blogposts.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Blog post from James Forshaw&lt;/strong&gt;: &lt;a href=&#34;https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html&#34;&gt;Windows Exploitation Tricks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Blog post from Clément Labro part #1&lt;/strong&gt;: &lt;a href=&#34;https://itm4n.github.io/lsass-runasppl/&#34;&gt;Do You Really Know About LSA Protection (RunAsPPL)?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Blog post from Clément Labro part #2&lt;/strong&gt;: &lt;a href=&#34;https://blog.scrt.ch/2021/04/22/bypassing-lsa-protection-in-userland/&#34;&gt;Bypassing LSA Protection in Userland&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Warning: the safe version of the binary &lt;strong&gt;NEVER&lt;/strong&gt; outputs anything, as all the strings and print function are stripped away using conditional compilation macros.&lt;/h3&gt; &#xA;&lt;p&gt;Simply run the executable without any argument and you will get a detailed help/usage (only valid for binaries compiled without defining the &lt;code&gt;OPSEC&lt;/code&gt; macro)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;c:\Temp&amp;gt;.\rippl.exe&#xA;  _____  _____ _____  _____  _&#xA; |  __ \|_   _|  __ \|  __ \| |&#xA; | |__) | | | | |__) | |__) | |      version 0.1&#xA; |  _  /  | | |  ___/|  ___/| |      by @last0x00&#xA; | | \ \ _| |_| |    | |    | |____  forked by itm4n&#39;s PPLDump&#xA; |_|  \_\_____|_|    |_|    |______|&#xA;&#xA;Description:&#xA;  Manipulate Protected Process Light (PPL) processes with a *userland* exploit&#xA;&#xA;Usage:&#xA;  rippl.exe (-D|-K|-S|-R|-L|-X|-W|-Z|-T|-U) [-v] [-d] [-f] (PROC_NAME|PID) [DUMP_FILE|DRIVER_NAME]&#xA;  () -&amp;gt; mandatory arguments&#xA;  [] -&amp;gt; optional arguments&#xA;&#xA;Operation modes (choose ONLY one):&#xA;  -D -&amp;gt; Dump the given process&#xA;  -K -&amp;gt; Kill the given process&#xA;  -S -&amp;gt; Suspend the given process&#xA;  -R -&amp;gt; Resume the previously suspended process&#xA;  -L -&amp;gt; Leak a PROCESS_ALL_ACCESS handle to the given process (not yet implemented)&#xA;  -X -&amp;gt; Kill the given process by assigning it to a job object and terminating the object&#xA;  -W -&amp;gt; Freeze the process by assigning it to a job object and severely constraining its CPU resources&#xA;  -Z -&amp;gt; Kill the given process by injecting a thread into it which calls exit(0)&#xA;  -T -&amp;gt; Sandbox the process by disabling all of its token&#39;s privileges and lowering integrity to untrusted&#xA;  -U -&amp;gt; Unload the provided driver&#xA;&#xA;Arguments:&#xA;  PROC_NAME   -&amp;gt; The name of the process to interact with&#xA;  PID         -&amp;gt; The ID of the process to interact with&#xA;  DUMP_FILE   -&amp;gt; The path of the output dump file - valid ONLY with the -D option&#xA;  DRIVER_NAME -&amp;gt; The name of the driver to unload - valid ONLY with the -U option&#xA;&#xA;Options:&#xA;  -d -&amp;gt; (Debug) Enable debug mode&#xA;  -f -&amp;gt; (Force) Bypass DefineDosDevice error check&#xA;&#xA;Examples:&#xA;  rippl.exe -K MsMpEng.exe&#xA;  rippl.exe -S MsMpEng.exe&#xA;  rippl.exe -R MsMpEng.exe&#xA;  rippl.exe -D -f lsass.exe lsass.dmp&#xA;  rippl.exe -D -d -f 720 out.dmp&#xA;  rippl.exe -U Wdfilter&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>peng-zhihui/L-ink_Card</title>
    <updated>2022-07-28T01:48:33Z</updated>
    <id>tag:github.com,2022-07-28:/peng-zhihui/L-ink_Card</id>
    <link href="https://github.com/peng-zhihui/L-ink_Card" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Smart NFC &amp; ink-Display Card&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;[L-ink]电子墨水屏NFC智能卡片&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;这是为了解决个人使用IC卡时遇到的一些痛点设计的一个迷你NFC智能卡片，基于STM32L051和ST25DV。&lt;/p&gt; &#xA; &lt;p&gt;想着既然要自制这玩意那就往炫酷了做，于是很自觉地把电子墨水屏也加上了，顺手也写了个配套APP用于显示内容定制。&lt;/p&gt; &#xA; &lt;p&gt;总之是个比较有意思的小项目，方案不算复杂，第一版设计也存在一些值得改进的地方，后续有空会继续优化方案设计的。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/L-ink_V0.5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;演示视频&lt;/h2&gt; &#xA;&lt;p&gt;B站指路：&lt;a href=&#34;https://www.bilibili.com/video/BV1Cf4y1y7KT/&#34;&gt;https://www.bilibili.com/video/BV1Cf4y1y7KT/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;项目文件说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hardware&lt;/strong&gt;：source里面是电路原理图和PCB文件，使用Altium Designer打开；release里面是gerber文件可以直接发给厂家打样，也包含了元器件BOM表（部分IC不太常用可能要单独购买）。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Firmware&lt;/strong&gt;：STM32L051的固件，我提供了Clion和Keil两个版本的工程文件，源码内容是一致的，分两个版本只是因为个人对Clion爱得深沉。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;3D Model&lt;/strong&gt;：屏幕架和外壳的3D文件，step格式一般3D建模软件都能打开编辑，STL格式用于直接3D打印。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;DAP-Link&lt;/strong&gt;：自己设计的下载调试器的硬件和固件源码，也包括预编译的hex固件，如果你有J-Link或者ST-Link之类的下载器就不用这个了。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Android&lt;/strong&gt;：配套的APP安装包。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;固件编译说明&lt;/h2&gt; &#xA;&lt;p&gt;STM32因为使用了L0系列的MCU，所以如果你是第一次在你的电脑上开发STM32L0，那么需要先装一下L0的固件支持包，有两种方式：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;使用STM32CubMX安装：&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;使用Keil的Package Installer安装：&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;然后就不会报头文件的错误了。&lt;/p&gt; &#xA;&lt;p&gt;有几点注意的：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;如果想在Clion中编译工程的话可以参考我这篇教程：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/145801160&#34;&gt;https://zhuanlan.zhihu.com/p/145801160&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Clion中OpenOCD默认是使用ST-Link下载，其他下载器自己修改工程目录下的stlink.cfg文件&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;关于硬件方案&lt;/h2&gt; &#xA;&lt;p&gt;硬件方案比较简单，主要IC就两个--STM32和ST25DV，电子墨水屏是200x200的单色屏幕，我是买的微雪的（注意如果是买的几年前的库存，那驱动芯片会有点区别导致代码不通用，只要是新款的应该都没问题）。&lt;/p&gt; &#xA;&lt;p&gt;ST25DV作为NFC的PHY通过I2C总线和STM32通信，主要作用有两个：能量采集以及NFC通信。注意，ST25DV只是负责和手机进行NFC通信，而不负责IC卡的读写功能，因为&lt;strong&gt;ST25DV只支持ISO 15693的RFID协议，而我们常用的IC卡（M1卡）是ISO 14443协议的&lt;/strong&gt;，所以并不能直接使用这颗芯片进行IC卡模拟。&lt;/p&gt; &#xA;&lt;p&gt;IC卡的模拟功能这一版中实现得比较简单，就是直接集成了多颗UID芯片（很便宜，1~2元一片），然后和ST25DV共用NFC天线，卡片的切换是通过拨轮换挡实现的。好处在于，你可以把L-ink当作多张独立卡片的合集处理，复制和刷卡都是很直接的（使用PM3或者PN532等模块读取原卡信息并写入L-link）。当然缺点就是添加的卡片一多，按键的数量就要增加（因为每一档对应一张卡）。&lt;/p&gt; &#xA;&lt;p&gt;所以我也在改进方案，后面可能会使用支持ISO 14443协议的ST95或者ST25T系列的芯片来实现软件层面的IC卡模拟功能。&lt;/p&gt; &#xA;&lt;p&gt;另外下一个版本的硬件方案&lt;strong&gt;我会把黑白的电子墨水屏换成彩色的&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;关于配套APP&lt;/h2&gt; &#xA;&lt;p&gt;Android APP目前只是实现了功能，这是基于我以前做的一个算法验证框架APP改的，UI还没有重新做设计，可以等后续更新。&lt;/p&gt; &#xA;&lt;p&gt;工程文件的话我后面可以把其中的核心功能模块封装成Module，然后给个Sample Project供参考使用，工作太忙等我缓过这阵子先~&lt;/p&gt; &#xA;&lt;h2&gt;教程整理中...&lt;/h2&gt; &#xA;&lt;p&gt;有问题先看Issue（包括已经close的），另外&lt;/p&gt; &#xA;&lt;h4&gt;跟项目工程无关的问题不要发在Issues里面！跟项目工程无关的问题不要发在Issues里面！跟项目工程无关的问题不要发在Issues里面！&lt;/h4&gt; &#xA;&lt;p&gt;聊天内容可以给我发评论或者私信（B站、知乎），我看到的话基本都会回复，issue里面发的话所有watch项目的人都会收到邮件，会对大家产生困扰的！&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;以下是&lt;a href=&#34;https://github.com/simonire&#34;&gt;simonire&lt;/a&gt;修改的版本，适配新款的屏幕驱动，修改拨轮为五维按键，有需要的可以参考：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/simonire/L-ink_Card&#34;&gt;https://github.com/simonire/L-ink_Card&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/TruePic.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>micropython/micropython</title>
    <updated>2022-07-28T01:48:33Z</updated>
    <id>tag:github.com,2022-07-28:/micropython/micropython</id>
    <link href="https://github.com/micropython/micropython" rel="alternate"></link>
    <summary type="html">&lt;p&gt;MicroPython - a lean and efficient Python implementation for microcontrollers and constrained systems&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/micropython/micropython/actions?query=branch%3Amaster+event%3Apush&#34;&gt;&lt;img src=&#34;https://github.com/micropython/micropython/workflows/unix%20port/badge.svg?sanitize=true&#34; alt=&#34;CI badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/micropython/micropython&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/micropython/micropython/branch/master/graph/badge.svg?token=I92PfD05sD&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;The MicroPython project&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/micropython/micropython/master/logo/upython-with-micro.jpg&#34; alt=&#34;MicroPython Logo&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;This is the MicroPython project, which aims to put an implementation of Python 3.x on microcontrollers and small embedded systems. You can find the official website at &lt;a href=&#34;http://www.micropython.org&#34;&gt;micropython.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WARNING: this project is in beta stage and is subject to changes of the code-base, including project-wide name changes and API changes.&lt;/p&gt; &#xA;&lt;p&gt;MicroPython implements the entire Python 3.4 syntax (including exceptions, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;yield from&lt;/code&gt;, etc., and additionally &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; keywords from Python 3.5). The following core datatypes are provided: &lt;code&gt;str&lt;/code&gt; (including basic Unicode support), &lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;frozenset&lt;/code&gt;, &lt;code&gt;array.array&lt;/code&gt;, &lt;code&gt;collections.namedtuple&lt;/code&gt;, classes and instances. Builtin modules include &lt;code&gt;sys&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, and &lt;code&gt;struct&lt;/code&gt;, etc. Select ports have support for &lt;code&gt;_thread&lt;/code&gt; module (multithreading). Note that only a subset of Python 3 functionality is implemented for the data types and modules.&lt;/p&gt; &#xA;&lt;p&gt;MicroPython can execute scripts in textual source form or from precompiled bytecode, in both cases either from an on-device filesystem or &#34;frozen&#34; into the MicroPython executable.&lt;/p&gt; &#xA;&lt;p&gt;See the repository &lt;a href=&#34;http://github.com/micropython/pyboard&#34;&gt;http://github.com/micropython/pyboard&lt;/a&gt; for the MicroPython board (PyBoard), the officially supported reference electronic circuit board.&lt;/p&gt; &#xA;&lt;p&gt;Major components in this repository:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;py/ -- the core Python implementation, including compiler, runtime, and core library.&lt;/li&gt; &#xA; &lt;li&gt;mpy-cross/ -- the MicroPython cross-compiler which is used to turn scripts into precompiled bytecode.&lt;/li&gt; &#xA; &lt;li&gt;ports/unix/ -- a version of MicroPython that runs on Unix.&lt;/li&gt; &#xA; &lt;li&gt;ports/stm32/ -- a version of MicroPython that runs on the PyBoard and similar STM32 boards (using ST&#39;s Cube HAL drivers).&lt;/li&gt; &#xA; &lt;li&gt;ports/minimal/ -- a minimal MicroPython port. Start with this if you want to port MicroPython to another microcontroller.&lt;/li&gt; &#xA; &lt;li&gt;tests/ -- test framework and test scripts.&lt;/li&gt; &#xA; &lt;li&gt;docs/ -- user documentation in Sphinx reStructuredText format. Rendered HTML documentation is available at &lt;a href=&#34;http://docs.micropython.org&#34;&gt;http://docs.micropython.org&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additional components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ports/bare-arm/ -- a bare minimum version of MicroPython for ARM MCUs. Used mostly to control code size.&lt;/li&gt; &#xA; &lt;li&gt;ports/teensy/ -- a version of MicroPython that runs on the Teensy 3.1 (preliminary but functional).&lt;/li&gt; &#xA; &lt;li&gt;ports/pic16bit/ -- a version of MicroPython for 16-bit PIC microcontrollers.&lt;/li&gt; &#xA; &lt;li&gt;ports/cc3200/ -- a version of MicroPython that runs on the CC3200 from TI.&lt;/li&gt; &#xA; &lt;li&gt;ports/esp8266/ -- a version of MicroPython that runs on Espressif&#39;s ESP8266 SoC.&lt;/li&gt; &#xA; &lt;li&gt;ports/esp32/ -- a version of MicroPython that runs on Espressif&#39;s ESP32 SoC.&lt;/li&gt; &#xA; &lt;li&gt;ports/nrf/ -- a version of MicroPython that runs on Nordic&#39;s nRF51 and nRF52 MCUs.&lt;/li&gt; &#xA; &lt;li&gt;extmod/ -- additional (non-core) modules implemented in C.&lt;/li&gt; &#xA; &lt;li&gt;tools/ -- various tools, including the pyboard.py module.&lt;/li&gt; &#xA; &lt;li&gt;examples/ -- a few example Python scripts.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The subdirectories above may include READMEs with additional info.&lt;/p&gt; &#xA;&lt;p&gt;&#34;make&#34; is used to build the components, or &#34;gmake&#34; on BSD-based systems. You will also need bash, gcc, and Python 3.3+ available as the command &lt;code&gt;python3&lt;/code&gt; (if your system only has Python 2.7 then invoke make with the additional option &lt;code&gt;PYTHON=python2&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;The MicroPython cross-compiler, mpy-cross&lt;/h2&gt; &#xA;&lt;p&gt;Most ports require the MicroPython cross-compiler to be built first. This program, called mpy-cross, is used to pre-compile Python scripts to .mpy files which can then be included (frozen) into the firmware/executable for a port. To build mpy-cross use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd mpy-cross&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Unix version&lt;/h2&gt; &#xA;&lt;p&gt;The &#34;unix&#34; port requires a standard Unix environment with gcc and GNU make. x86 and x64 architectures are supported (i.e. x86 32- and 64-bit), as well as ARM and MIPS. Making full-featured port to another architecture requires writing some assembly code for the exception handling and garbage collection. Alternatively, fallback implementation based on setjmp/longjmp can be used.&lt;/p&gt; &#xA;&lt;p&gt;To build (see section below for required dependencies):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd ports/unix&#xA;$ make submodules&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then to give it a try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./micropython&#xA;&amp;gt;&amp;gt;&amp;gt; list(5 * x + y for x in range(10) for y in [4, 2, 1])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;CTRL-D&lt;/code&gt; (i.e. EOF) to exit the shell. Learn about command-line options (in particular, how to increase heap size which may be needed for larger applications):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./micropython -h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run complete testsuite:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unix version comes with a builtin package manager called upip, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./micropython -m upip install micropython-pystone&#xA;$ ./micropython -m pystone&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Browse available modules on &lt;a href=&#34;https://pypi.python.org/pypi?%3Aaction=search&amp;amp;term=micropython&#34;&gt;PyPI&lt;/a&gt;. Standard library modules come from &lt;a href=&#34;https://github.com/micropython/micropython-lib&#34;&gt;micropython-lib&lt;/a&gt; project.&lt;/p&gt; &#xA;&lt;h2&gt;External dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Building MicroPython ports may require some dependencies installed.&lt;/p&gt; &#xA;&lt;p&gt;For Unix port, &lt;code&gt;libffi&lt;/code&gt; library and &lt;code&gt;pkg-config&lt;/code&gt; tool are required. On Debian/Ubuntu/Mint derivative Linux distros, install &lt;code&gt;build-essential&lt;/code&gt; (includes toolchain and make), &lt;code&gt;libffi-dev&lt;/code&gt;, and &lt;code&gt;pkg-config&lt;/code&gt; packages.&lt;/p&gt; &#xA;&lt;p&gt;Other dependencies can be built together with MicroPython. This may be required to enable extra features or capabilities, and in recent versions of MicroPython, these may be enabled by default. To build these additional dependencies, in the port directory you&#39;re interested in (e.g. &lt;code&gt;ports/unix/&lt;/code&gt;) first execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make submodules&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will fetch all the relevant git submodules (sub repositories) that the port needs. Use the same command to get the latest versions of submodules as they are updated from time to time. After that execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make deplibs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will build all available dependencies (regardless whether they are used or not). If you intend to build MicroPython with additional options (like cross-compiling), the same set of options should be passed to &lt;code&gt;make deplibs&lt;/code&gt;. To actually enable/disable use of dependencies, edit &lt;code&gt;ports/unix/mpconfigport.mk&lt;/code&gt; file, which has inline descriptions of the options. For example, to build SSL module (required for &lt;code&gt;upip&lt;/code&gt; tool described above, and so enabled by default), &lt;code&gt;MICROPY_PY_USSL&lt;/code&gt; should be set to 1.&lt;/p&gt; &#xA;&lt;p&gt;For some ports, building required dependences is transparent, and happens automatically. But they still need to be fetched with the &lt;code&gt;make submodules&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;h2&gt;The STM32 version&lt;/h2&gt; &#xA;&lt;p&gt;The &#34;stm32&#34; port requires an ARM compiler, arm-none-eabi-gcc, and associated bin-utils. For those using Arch Linux, you need arm-none-eabi-binutils, arm-none-eabi-gcc and arm-none-eabi-newlib packages. Otherwise, try here: &lt;a href=&#34;https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm&#34;&gt;https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd ports/stm32&#xA;$ make submodules&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You then need to get your board into DFU mode. On the pyboard, connect the 3V3 pin to the P1/DFU pin with a wire (on PYBv1.0 they are next to each other on the bottom left of the board, second row from the bottom).&lt;/p&gt; &#xA;&lt;p&gt;Then to flash the code via USB DFU to your device:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make deploy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will use the included &lt;code&gt;tools/pydfu.py&lt;/code&gt; script. If flashing the firmware does not work it may be because you don&#39;t have the correct permissions, and need to use &lt;code&gt;sudo make deploy&lt;/code&gt;. See the README.md file in the ports/stm32/ directory for further details.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;MicroPython is an open-source project and welcomes contributions. To be productive, please be sure to follow the &lt;a href=&#34;https://github.com/micropython/micropython/wiki/ContributorGuidelines&#34;&gt;Contributors&#39; Guidelines&lt;/a&gt; and the &lt;a href=&#34;https://github.com/micropython/micropython/raw/master/CODECONVENTIONS.md&#34;&gt;Code Conventions&lt;/a&gt;. Note that MicroPython is licenced under the MIT license, and all contributions should follow this license.&lt;/p&gt;</summary>
  </entry>
</feed>