<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-07T01:37:25Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>woltapp/blurhash</title>
    <updated>2024-07-07T01:37:25Z</updated>
    <id>tag:github.com,2024-07-07:/woltapp/blurhash</id>
    <link href="https://github.com/woltapp/blurhash" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A very compact representation of a placeholder for an image.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;http://blurha.sh&#34;&gt;BlurHash&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;BlurHash is a compact representation of a placeholder for an image.&lt;/p&gt; &#xA;&lt;h2&gt;Why would you want this?&lt;/h2&gt; &#xA;&lt;p&gt;Does your designer cry every time you load their beautifully designed screen, and it is full of empty boxes because all the images have not loaded yet? Does your database engineer cry when you want to solve this by trying to cram little thumbnail images into your data to show as placeholders?&lt;/p&gt; &#xA;&lt;p&gt;BlurHash will solve your problems! How? Like this:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/Media/WhyBlurHash.png&#34; width=&#34;600&#34;&gt; &#xA;&lt;p&gt;You can also see nice examples and try it out yourself at &lt;a href=&#34;http://blurha.sh/&#34;&gt;blurha.sh&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;How does it work?&lt;/h2&gt; &#xA;&lt;p&gt;In short, BlurHash takes an image, and gives you a short string (only 20-30 characters!) that represents the placeholder for this image. You do this on the backend of your service, and store the string along with the image. When you send data to your client, you send both the URL to the image, and the BlurHash string. Your client then takes the string, and decodes it into an image that it shows while the real image is loading over the network. The string is short enough that it comfortably fits into whatever data format you use. For instance, it can easily be added as a field in a JSON object.&lt;/p&gt; &#xA;&lt;p&gt;In summary:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/Media/HowItWorks1.jpg&#34; width=&#34;250&#34;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;img src=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/Media/HowItWorks2.jpg&#34; width=&#34;250&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Want to know all the gory technical details? Read the &lt;a href=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/Algorithm.md&#34;&gt;algorithm description&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Implementing the algorithm is actually quite easy! Implementations are short and easily ported to your favourite language or platform.&lt;/p&gt; &#xA;&lt;h2&gt;Implementations&lt;/h2&gt; &#xA;&lt;p&gt;So far, we have created these implementations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/C&#34;&gt;C&lt;/a&gt; - An encoder implementation in portable C code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/Swift&#34;&gt;Swift&lt;/a&gt; - Encoder and decoder implementations, and a larger library offering advanced features. There is also an example app to play around with the algorithm.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/Kotlin&#34;&gt;Kotlin&lt;/a&gt; - A decoder implementation for Android.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/TypeScript&#34;&gt;TypeScript&lt;/a&gt; - Encoder and decoder implementations, and an example page to test.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/woltapp/blurhash-python&#34;&gt;Python&lt;/a&gt; - Integration of the C encoder code into Python.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These cover our use cases, but could probably use polishing, extending and improving. There are also these third party implementations that we know of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/halcy/blurhash-python&#34;&gt;Pure Python&lt;/a&gt; - Implementation of both the encoder and decoder in pure Python.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bbrks/go-blurhash&#34;&gt;One version in Go&lt;/a&gt;, and &lt;a href=&#34;https://github.com/buckket/go-blurhash&#34;&gt;another version in Go&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kornrunner/php-blurhash&#34;&gt;PHP&lt;/a&gt; - Encoder and decoder implementations in pure PHP.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hsch/blurhash-java&#34;&gt;Java&lt;/a&gt; - Encoder implementation in Java.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/siili-core/blurhash&#34;&gt;Clojure&lt;/a&gt; - Encoder and decoder implementations in Clojure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SolitudeSF/blurhash&#34;&gt;Nim&lt;/a&gt; - Encoder and decoder implementation in pure Nim.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fpapado/blurhash-rust-wasm&#34;&gt;Rust and WebAssembly&lt;/a&gt; - Encoder and decoder implementations in Rust. Distributed as both native Rust and WebAssembly packages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Gargron/blurhash&#34;&gt;Ruby&lt;/a&gt; - Encoder implementation in Ruby.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Sija/blurhash.cr&#34;&gt;Crystal&lt;/a&gt; - Encoder implementation in pure Crystal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WhileTruu/elm-blurhash&#34;&gt;Elm&lt;/a&gt; - Encoder and decoder in Elm.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/folksable/blurhash_ffi&#34;&gt;Dart&lt;/a&gt; - Encoder and decoder implementation in C into Dart using dart-ffi.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/justacid/blurhash-dart&#34;&gt;Pure Dart&lt;/a&gt; - Encoder and decoder implementation in pure Dart.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MarkusPalcer/blurhash.net&#34;&gt;.NET&lt;/a&gt; - Encoder and decoder in C#.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Dens49/blurhash-js&#34;&gt;JavaScript&lt;/a&gt; - Encoder and decoder implementation in pure JavaScript.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Bond-009/BlurHashSharp&#34;&gt;.NET&lt;/a&gt; - Encoder implementation in C#.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SamProtas/JuicyPixels-blurhash&#34;&gt;Haskell&lt;/a&gt; - Encoder and decoder in pure Haskell.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/markussammallahti/blurhash-scala&#34;&gt;Scala&lt;/a&gt; - Encoder and decoder in Scala.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/perzanko/blurhash-elixir&#34;&gt;Elixir&lt;/a&gt; - Encoder implementation in pure Elixir.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/armedi/rescript-blurhash&#34;&gt;ReScript&lt;/a&gt; - Encoder and decoder implementation in ReScript (BuckleScript).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mad-gooze/fast-blurhash&#34;&gt;JavaScript&lt;/a&gt; - Tiny optimized decoder implementation JS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/piradoiv/xojo-blurhash/&#34;&gt;Xojo&lt;/a&gt; - Encoder and decoder implementation in pure Xojo.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mrousavy/react-native-blurhash&#34;&gt;React Native&lt;/a&gt; - UI Component for React Native. (Decoder in Swift and Kotlin)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhoward540/blurhash-zig&#34;&gt;Zig&lt;/a&gt; - Encoder implementation in Zig.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/m1ga/ti.blurhash&#34;&gt;Titanium SDK&lt;/a&gt; - Decoder for Titanium SDK (Android)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dancek/blurhash-bqn&#34;&gt;BQN&lt;/a&gt; - Encoder, decoder and terminal viewer in pure BQN.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wajahat-iqbal/BlurHashPainter&#34;&gt;Jetpack Compose&lt;/a&gt; - Decoder Jetpack Compose implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Nheko-Reborn/blurhash&#34;&gt;C++&lt;/a&gt; - Encoder and decoder in C++.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vanniktech/blurhash&#34;&gt;Kotlin Multiplatform&lt;/a&gt; - Encoding &amp;amp; decoding for Android, iOS &amp;amp; JVM&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ushitora-anqou/ocaml-blurhash&#34;&gt;OCaml&lt;/a&gt; - Encoder implementation in OCaml.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Can&#39;t find the language you&#39;re looking for? Try your luck with the GitHub search. For example, here are the search results for &lt;a href=&#34;https://github.com/search?q=blurhash+in%3Aname&amp;amp;type=repositories&#34;&gt;repos which have &#34;blurhash&#34; in their name&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Perhaps you&#39;d like to help extend this list? Which brings us to...&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;d love contributions! The algorithm is &lt;a href=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/Algorithm.md&#34;&gt;very simple&lt;/a&gt; - less than two hundred lines of code - and can easily be ported to your platform of choice. And having support for more platforms would be wonderful! So, Java decoder? Golang encoder? Haskell? Rust? We want them all!&lt;/p&gt; &#xA;&lt;p&gt;We will also try to tag any issues on our &lt;a href=&#34;https://github.com/woltapp/blurhash/issues&#34;&gt;issue tracker&lt;/a&gt; that we&#39;d love help with, so if you just want to dip in, go have a look.&lt;/p&gt; &#xA;&lt;p&gt;You can file a pull request with us, or you can start your own repo and project if you want to run everything yourself, we don&#39;t mind.&lt;/p&gt; &#xA;&lt;p&gt;If you do want to contribute to this project, we have a &lt;a href=&#34;https://raw.githubusercontent.com/woltapp/blurhash/master/CodeOfConduct.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Users&lt;/h2&gt; &#xA;&lt;p&gt;Who uses BlurHash? Here are some projects we know about:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://wolt.com/&#34;&gt;Wolt&lt;/a&gt; - We are of course using it ourselves. BlurHashes are used in the mobile clients on iOS and Android, as well as on the web, as placeholders during image loading.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tootsuite/mastodon&#34;&gt;Mastodon&lt;/a&gt; - The Mastodon decentralised social media network uses BlurHashes both as loading placeholders, as well as for hiding media marked as sensitive.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://signal.org/&#34;&gt;Signal&lt;/a&gt; - Signal Private Messenger uses Blurhashes as placeholders before photo &amp;amp; video messages are downloaded in chat conversations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jellyfin.org/&#34;&gt;Jellyfin&lt;/a&gt; - Jellyfin the free software media system uses Blurhashes as placeholders for images of movies and TV shows when they are being downloaded.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Good Questions&lt;/h2&gt; &#xA;&lt;h3&gt;How fast is encoding? Decoding?&lt;/h3&gt; &#xA;&lt;p&gt;These implementations are not very optimised. Running them on very large images can be a bit slow. The performance of the encoder and decoder are about the same for the same input or output size, so decoding very large placeholders, especially on your UI thread, can also be a bit slow.&lt;/p&gt; &#xA;&lt;p&gt;However! The trick to using the algorithm efficiently is to not run it on full-sized data. The fine detail of an image is all thrown away, so you should scale your images down before running BlurHash on them. If you are creating thumbnails, run BlurHash on those instead of the full images.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, when displaying the placeholders, very small images work very well when scaled up. We usually decode placeholders that are 32 or even 20 pixels wide, and then let the UI layer scale them up, which is indistinguishable from decoding them at full size.&lt;/p&gt; &#xA;&lt;h3&gt;How do I pick the number of X and Y components?&lt;/h3&gt; &#xA;&lt;p&gt;It depends a bit on taste. The more components you pick, the more information is retained in the placeholder, but the longer the BlurHash string will be. Also, it doesn&#39;t always look good with too many components. We usually go with 4 by 3, which seems to strike a nice balance.&lt;/p&gt; &#xA;&lt;p&gt;However, you should adjust the number of components depending on the aspect ratio of your images. For instance, very wide images should have more X components and fewer Y components.&lt;/p&gt; &#xA;&lt;p&gt;The Swift example project contains a test app where you can play around with the parameters and see the results.&lt;/p&gt; &#xA;&lt;h3&gt;What is the &lt;code&gt;punch&lt;/code&gt; parameter in some of these implementations?&lt;/h3&gt; &#xA;&lt;p&gt;It is a parameter that adjusts the contrast on the decoded image. 1 means normal, smaller values will make the effect more subtle, and larger values will make it stronger. This is basically a design parameter, which lets you adjust the look.&lt;/p&gt; &#xA;&lt;p&gt;Technically, what it does is scale the AC components up or down.&lt;/p&gt; &#xA;&lt;h3&gt;Is this only useful as an image loading placeholder?&lt;/h3&gt; &#xA;&lt;p&gt;Well, that is what it was designed for originally, but it turns out to be useful for a few other things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Masking images without having to use expensive blurs - &lt;a href=&#34;http://github.com/tootsuite/mastodon&#34;&gt;Mastodon&lt;/a&gt; uses it for this.&lt;/li&gt; &#xA; &lt;li&gt;The data representation makes it quite easy to extract colour averages of the image for different areas. You can easily find approximations of things like the average colour of the top edge of the image, or of a corner. There is some code in the Swift BlurHashKit implementation to experiment with this. Also, the average colour of the entire image is just the DC component and can be decoded even without implementing any of the more complicated DCT stuff.&lt;/li&gt; &#xA; &lt;li&gt;We have been meaning to try to implement tinted drop shadows for UI elements by using the BlurHash and extending the borders. Haven&#39;t actually had time to implement this yet though.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Why base 83?&lt;/h3&gt; &#xA;&lt;p&gt;First, 83 seems to be about how many low-ASCII characters you can find that are safe for use in all of JSON, HTML and shells.&lt;/p&gt; &#xA;&lt;p&gt;Secondly, 83 * 83 is very close to, and a little more than, 19 * 19 * 19, making it ideal for encoding three AC components in two characters.&lt;/p&gt; &#xA;&lt;h3&gt;What about using the full Unicode character set to get a more efficient encoding?&lt;/h3&gt; &#xA;&lt;p&gt;We haven&#39;t looked into how much overhead UTF-8 encoding would introduce versus base 83 in single-byte characters, but the encoding and decoding would probably be a lot more complicated, so in the spirit of minimalism BlurHash uses the simpler option. It might also be awkward to copy-paste, depending on OS capabilities.&lt;/p&gt; &#xA;&lt;p&gt;If you think it can be done and is worth it, though, do make your own version and show us! We&#39;d love to see it in action.&lt;/p&gt; &#xA;&lt;h3&gt;What about other basis representations than DCT?&lt;/h3&gt; &#xA;&lt;p&gt;This is something we&#39;d &lt;em&gt;love&lt;/em&gt; to try. The DCT looks quite ugly when you increase the number of components, probably because the shape of the basis functions becomes too visible. Using a different basis with more aesthetically pleasing shape might be a big win.&lt;/p&gt; &#xA;&lt;p&gt;However, we have not managed come up with one. Some experimenting with a &lt;a href=&#34;https://en.wikipedia.org/wiki/Fourier%E2%80%93Bessel_series&#34;&gt;Fourier-Bessel base&lt;/a&gt;, targeted at images that are going to be cropped into circles has been done, but without much success. Here again we&#39;d love to see what you can come up with!&lt;/p&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/DagAgren&#34;&gt;Dag Ågren&lt;/a&gt; - Original algorithm design, Swift and C implementations&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/shchurov&#34;&gt;Mykhailo Shchurov&lt;/a&gt; - Kotlin decoder implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/hangduykhiem&#34;&gt;Hang Duy Khiem&lt;/a&gt; - Android demo app&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/omahlama&#34;&gt;Olli Mahlamäki&lt;/a&gt; - TypeScript decoder and encoder implementations&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/lautat&#34;&gt;Atte Lautanala&lt;/a&gt; - Python integration&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/halcy&#34;&gt;Lorenz Diener&lt;/a&gt; - Pure Python implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/kornrunner&#34;&gt;Boris Momčilović&lt;/a&gt; - Pure PHP implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/hsch&#34;&gt;Hendrik Schnepel&lt;/a&gt; - Java encoder implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/tvirolai&#34;&gt;Tuomo Virolainen&lt;/a&gt; - Clojure implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/fpapado&#34;&gt;Fotis Papadogeorgopoulos&lt;/a&gt; - Rust and WebAssembly implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/SamProtas&#34;&gt;Sam Protas&lt;/a&gt; - Pure Haskell implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/markussammallahti&#34;&gt;Markus Sammallahti&lt;/a&gt; - Scala implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/perzanko&#34;&gt;Kacper Perzankowski&lt;/a&gt; - Elixir encoder implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/KingsMentor/BlurHashExt&#34;&gt;Belvi Nosakhare&lt;/a&gt; - Kotlin extensions of Blurhash for ImageView, Glide, and Piccasso optimized for Android.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/armedi&#34;&gt;Armedi&lt;/a&gt; - ReScript (BuckleScript) implementation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/piradoiv&#34;&gt;Ricardo Cruz&lt;/a&gt; - Xojo implementation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/mrousavy&#34;&gt;Marc Rousavy&lt;/a&gt; - React Native UI Component&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/mhoward540&#34;&gt;Matt Howard&lt;/a&gt; - Zig implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/dancek&#34;&gt;Hannu Hartikainen&lt;/a&gt; - BQN implementation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/wajahat-iqbal&#34;&gt;Wajahat Iqbal&lt;/a&gt; - Jetpack compose-based implementation optimized for using any component as a painter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Your name here?&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>fairyglade/ly</title>
    <updated>2024-07-07T01:37:25Z</updated>
    <id>tag:github.com,2024-07-07:/fairyglade/ly</id>
    <link href="https://github.com/fairyglade/ly" rel="alternate"></link>
    <summary type="html">&lt;p&gt;display manager with console UI&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ly - a TUI display manager&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/5473047/88958888-65efbf80-d2a1-11ea-8ae5-3f263bce9cce.png&#34; alt=&#34;Ly screenshot&#34; title=&#34;Ly screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ly is a lightweight TUI (ncurses-like) display manager for Linux and BSD.&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compile-time: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;zig 0.12.0&lt;/li&gt; &#xA;   &lt;li&gt;a C standard library&lt;/li&gt; &#xA;   &lt;li&gt;pam&lt;/li&gt; &#xA;   &lt;li&gt;xcb&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Runtime (with default config): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;xorg&lt;/li&gt; &#xA;   &lt;li&gt;xorg-xauth&lt;/li&gt; &#xA;   &lt;li&gt;mcookie&lt;/li&gt; &#xA;   &lt;li&gt;tput&lt;/li&gt; &#xA;   &lt;li&gt;shutdown&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Debian&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;# apt install build-essential libpam0g-dev libxcb-xkb-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fedora&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: You may encounter issues with SELinux on Fedora. It is recommended to add a rule for Ly as it currently does not ship one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# dnf install kernel-devel pam-devel libxcb-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;The following desktop environments were tested with success:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;awesome&lt;/li&gt; &#xA; &lt;li&gt;bspwm&lt;/li&gt; &#xA; &lt;li&gt;budgie&lt;/li&gt; &#xA; &lt;li&gt;cinnamon&lt;/li&gt; &#xA; &lt;li&gt;deepin&lt;/li&gt; &#xA; &lt;li&gt;dwl&lt;/li&gt; &#xA; &lt;li&gt;dwm&lt;/li&gt; &#xA; &lt;li&gt;enlightenment&lt;/li&gt; &#xA; &lt;li&gt;gnome&lt;/li&gt; &#xA; &lt;li&gt;i3&lt;/li&gt; &#xA; &lt;li&gt;kde&lt;/li&gt; &#xA; &lt;li&gt;labwc&lt;/li&gt; &#xA; &lt;li&gt;lxde&lt;/li&gt; &#xA; &lt;li&gt;lxqt&lt;/li&gt; &#xA; &lt;li&gt;mate&lt;/li&gt; &#xA; &lt;li&gt;maxx&lt;/li&gt; &#xA; &lt;li&gt;pantheon&lt;/li&gt; &#xA; &lt;li&gt;qtile&lt;/li&gt; &#xA; &lt;li&gt;spectrwm&lt;/li&gt; &#xA; &lt;li&gt;sway&lt;/li&gt; &#xA; &lt;li&gt;windowmaker&lt;/li&gt; &#xA; &lt;li&gt;xfce&lt;/li&gt; &#xA; &lt;li&gt;xmonad&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Ly should work with any X desktop environment, and provides basic wayland support (sway works very well, for example).&lt;/p&gt; &#xA;&lt;h2&gt;systemd?&lt;/h2&gt; &#xA;&lt;p&gt;Unlike what you may have heard, Ly does not require &lt;code&gt;systemd&lt;/code&gt;, and was even specifically designed not to depend on &lt;code&gt;logind&lt;/code&gt;. You should be able to make it work easily with a better init, changing the source code won&#39;t be necessary :)&lt;/p&gt; &#xA;&lt;h2&gt;Cloning and Compiling&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/fairyglade/ly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change the directory to ly&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd ly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compile&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ zig build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Test in the configured tty (tty2 by default) or a terminal emulator (but desktop environments won&#39;t start)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# zig build run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install Ly and the provided systemd service file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# zig build installsystemd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable the service&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# systemctl enable ly.service&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to switch between ttys after Ly&#39;s start you also have to disable getty on Ly&#39;s tty to prevent &#34;login&#34; from spawning on top of it&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# systemctl disable getty@tty2.service&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OpenRC&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: On Gentoo, Ly will disable the &lt;code&gt;display-manager-init&lt;/code&gt; service in order to run.&lt;/p&gt; &#xA;&lt;p&gt;Clone, compile and test.&lt;/p&gt; &#xA;&lt;p&gt;Install Ly and the provided OpenRC service&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# zig build installopenrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable the service&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# rc-update add ly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can edit which tty Ly will start on by editing the &lt;code&gt;tty&lt;/code&gt; option in the configuration file.&lt;/p&gt; &#xA;&lt;p&gt;If you choose a tty that already has a login/getty running (has a basic login prompt), then you have to disable getty, so it doesn&#39;t respawn on top of ly&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# rc-update del agetty.tty2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;runit&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;# zig build installrunit&#xA;# ln -s /etc/sv/ly /var/service/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, ly will run on tty2. To change the tty it must be set in &lt;code&gt;/etc/ly/config.ini&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You should as well disable your existing display manager service if needed, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# rm /var/service/lxdm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The agetty service for the tty console where you are running ly should be disabled. For instance, if you are running ly on tty2 (that&#39;s the default, check your &lt;code&gt;/etc/ly/config.ini&lt;/code&gt;) you should disable the agetty-tty2 service like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# rm /var/service/agetty-tty2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating&lt;/h3&gt; &#xA;&lt;p&gt;You can also install Ly without copying the system service and the configuration file. That&#39;s called &lt;em&gt;updating&lt;/em&gt;. To update, simply run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# zig build installnoconf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to also copy the default config file (but still not the system service), run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# zig build installexe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Arch Linux Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install ly from the &lt;a href=&#34;https://archlinux.org/packages/extra/x86_64/ly/&#34;&gt;&lt;code&gt;[extra]&lt;/code&gt; repos&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo pacman -S ly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You can find all the configuration in &lt;code&gt;/etc/ly/config.ini&lt;/code&gt;. The file is commented, and includes the default values.&lt;/p&gt; &#xA;&lt;h2&gt;Controls&lt;/h2&gt; &#xA;&lt;p&gt;Use the up and down arrow keys to change the current field, and the left and right arrow keys to change the target desktop environment while on the desktop field (above the login field).&lt;/p&gt; &#xA;&lt;h2&gt;.xinitrc&lt;/h2&gt; &#xA;&lt;p&gt;If your .xinitrc doesn&#39;t work make sure it is executable and includes a shebang. This file is supposed to be a shell script! Quoting from xinit&#39;s man page:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If no specific client program is given on the command line, xinit will look for a file in the user&#39;s home directory called .xinitrc to run as a shell script to start up client programs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;On Arch Linux, the example .xinitrc (/etc/X11/xinit/xinitrc) starts like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tips&lt;/h2&gt; &#xA;&lt;p&gt;The numlock and capslock state is printed in the top-right corner. Use the F1 and F2 keys to respectively shutdown and reboot. Take a look at your .xsession if X doesn&#39;t start, as it can interfere (this file is launched with X to configure the display properly).&lt;/p&gt; &#xA;&lt;h2&gt;PSX DOOM fire animation&lt;/h2&gt; &#xA;&lt;p&gt;To enable the famous PSX DOOM fire described by &lt;a href=&#34;http://fabiensanglard.net/doom_fire_psx/index.html&#34;&gt;Fabien Sanglard&lt;/a&gt;, just uncomment &lt;code&gt;animate = true&lt;/code&gt; in &lt;code&gt;/etc/ly/config.ini&lt;/code&gt;. You may also disable the main box borders with &lt;code&gt;hide_borders = true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Information&lt;/h2&gt; &#xA;&lt;p&gt;The name &#34;Ly&#34; is a tribute to the fairy from the game Rayman. Ly was tested by oxodao, who is some seriously awesome dude.&lt;/p&gt; &#xA;&lt;h2&gt;Gentoo (OpenRC) installation tip&lt;/h2&gt; &#xA;&lt;p&gt;To avoid a console spawning on top on Ly, comment out the appropriate line from /etc/inittab (default is 2).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>EpicGamesExt/raddebugger</title>
    <updated>2024-07-07T01:37:25Z</updated>
    <id>tag:github.com,2024-07-07:/EpicGamesExt/raddebugger</id>
    <link href="https://github.com/EpicGamesExt/raddebugger" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A native, user-mode, multi-process, graphical debugger.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The RAD Debugger Project&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; This README does not document usage instructions and tips for the debugger itself, and is intended as a technical overview of the project. The debugger&#39;s README, which includes usage instructions and tips, can be found packaged along with debugger releases, or within the &lt;code&gt;build&lt;/code&gt; folder after a local copy has been built.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The RAD Debugger is a native, user-mode, multi-process, graphical debugger. It currently only supports local-machine Windows x64 debugging with PDBs, with plans to expand and port in the future. In the future we&#39;ll expand to also support native Linux debugging and DWARF debug info.&lt;/p&gt; &#xA;&lt;p&gt;The RAD Debugger is currently in &lt;em&gt;ALPHA&lt;/em&gt;. In order to get the debugger bullet- proof, it&#39;d greatly help out if you submitted the issues you find here, along with any information you can gather, like dump files (along with the build you used), instructions to reproduce, test executables, and so on.&lt;/p&gt; &#xA;&lt;p&gt;You can download pre-built binaries for the debugger &lt;a href=&#34;https://github.com/EpicGames/raddebugger/releases&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The RAD Debugger project aims to simplify the debugger by simplifying and unifying the underlying debug info format. In that pursuit we&#39;ve built the RAD Debug Info (RDI) format, which is what the debugger parses and uses. To work with existing toolchains, we convert PDB (and eventually PE/ELF files with embedded DWARF) into the RDI format on-demand.&lt;/p&gt; &#xA;&lt;p&gt;The RDI format is currently specified in code, in the files within the &lt;code&gt;src/lib_rdi_format&lt;/code&gt; folder. The other relevant folders for working with the format are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lib_rdi_make&lt;/code&gt;: The &#34;RAD Debug Info Make&#34; library, for making RDI debug info.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rdi_from_pdb&lt;/code&gt;: Our PDB-to-RDI converter. Can be used as a helper codebase layer, or built as an executable with a command line interface frontend.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rdi_from_dwarf&lt;/code&gt;: Our in-progress DWARF-to-RDI converter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rdi_dump&lt;/code&gt;: Our RDI textual dumping utility.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development Setup Instructions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note: Currently, only x64 Windows development is supported.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;1. Installing the Required Tools (MSVC &amp;amp; Windows SDK)&lt;/h3&gt; &#xA;&lt;p&gt;In order to work with the codebase, you&#39;ll need the &lt;a href=&#34;https://aka.ms/vs/17/release/vs_BuildTools.exe&#34;&gt;Microsoft C/C++ Build Tools v15 (2017) or later&lt;/a&gt;, for both the Windows SDK and the MSVC compiler and linker.&lt;/p&gt; &#xA;&lt;p&gt;If the Windows SDK is installed (e.g. via installation of the Microsoft C/C++ Build Tools), you may also build with &lt;a href=&#34;https://releases.llvm.org/&#34;&gt;Clang&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;2. Build Environment Setup&lt;/h3&gt; &#xA;&lt;p&gt;Building the codebase can be done in a terminal which is equipped with the ability to call either MSVC or Clang from command line.&lt;/p&gt; &#xA;&lt;p&gt;This is generally done by calling &lt;code&gt;vcvarsall.bat x64&lt;/code&gt;, which is included in the Microsoft C/C++ Build Tools. This script is automatically called by the &lt;code&gt;x64 Native Tools Command Prompt for VS &amp;lt;year&amp;gt;&lt;/code&gt; variant of the vanilla &lt;code&gt;cmd.exe&lt;/code&gt;. If you&#39;ve installed the build tools, this command prompt may be easily located by searching for &lt;code&gt;Native&lt;/code&gt; from the Windows Start Menu search.&lt;/p&gt; &#xA;&lt;p&gt;You can ensure that the MSVC compiler is accessible from your command line by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If everything is set up correctly, you should have output very similar to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30151 for x64&#xA;Copyright (C) Microsoft Corporation.  All rights reserved.&#xA;&#xA;usage: cl [ option... ] filename... [ /link linkoption... ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. Building&lt;/h3&gt; &#xA;&lt;p&gt;Within this terminal, &lt;code&gt;cd&lt;/code&gt; to the root directory of the codebase, and just run the &lt;code&gt;build.bat&lt;/code&gt; script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see the following output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[debug mode]&#xA;[msvc compile]&#xA;[default mode, assuming `raddbg` build]&#xA;metagen_main.c&#xA;searching C:\devel\raddebugger/src... 299 files found&#xA;parsing metadesk... 12 metadesk files parsed&#xA;gathering tables... 37 tables found&#xA;generating layer code...&#xA;raddbg.cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If everything worked correctly, there will be a &lt;code&gt;build&lt;/code&gt; folder in the root level of the codebase, and it will contain a freshly-built &lt;code&gt;raddbg.exe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Short-To-Medium-Term Roadmap&lt;/h2&gt; &#xA;&lt;h3&gt;The Initial Alpha Battle-Testing Phase&lt;/h3&gt; &#xA;&lt;p&gt;The first priority for the project is to ensure that the most crucial debugger components are functioning extremely reliably for local, x64, Windows debugging. This would include parts like debug info conversion, debug info loading, process control, stepping, evaluation (correct usage of both location info and type info), and a robust frontend which ensures the lower level parts are usable.&lt;/p&gt; &#xA;&lt;p&gt;We feel that the debugger has already come a long way in all of these respects, but given the massive set of possible combinations of languages, build settings, toolchains, used language features, and patterns of generated code, there are still cases where the debugger has not been tested, and so there are still issues. So, we feel that the top priority is eliminating these issues, such that the debugging experience is rock solid.&lt;/p&gt; &#xA;&lt;h3&gt;Local x64 Linux Debugging Phase&lt;/h3&gt; &#xA;&lt;p&gt;The next priority for the project is to take the rock solid x64 Windows debugging experience, and port all of the relevant pieces to support local x64 Linux debugging also.&lt;/p&gt; &#xA;&lt;p&gt;The debugger has been written to abstract over the parts that need to differ on either Linux or Windows, and this is mainly going to be a task in building out different backends for those abstraction layers.&lt;/p&gt; &#xA;&lt;p&gt;The major parts of this phase are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/demon&lt;/code&gt; layer to implement the Demon local process control abstraction API.&lt;/li&gt; &#xA; &lt;li&gt;Implementing an x64 ELF Linux unwinder in the &lt;code&gt;src/ctrl&lt;/code&gt; layer.&lt;/li&gt; &#xA; &lt;li&gt;Creating a DWARF-to-RDI converter (in the same way that we&#39;ve built a PDB-to-RDI converter). A partial implementation of this is in &lt;code&gt;src/rdi_from_dwarf&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/render&lt;/code&gt; layer to implement all of the rendering features the frontend needs on a Linux-compatible API (the backend used on Windows is D3D11).&lt;/li&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/font_provider&lt;/code&gt; layer to a Linux-compatible font rasterization backend, like FreeType (the backend used on Windows is DirectWrite).&lt;/li&gt; &#xA; &lt;li&gt;Porting the &lt;code&gt;src/os&lt;/code&gt; layers to Linux. This includes core operating system abstraction (virtual memory allocation, threading and synchronization primitives, and so on), and graphical operating system abstraction (windows, input events, and so on).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once the above list is complete, and once every part is rock solid, the Windows debugging experience we&#39;ll have worked diligently to create will also be available natively on Linux machines.&lt;/p&gt; &#xA;&lt;h3&gt;And Beyond!&lt;/h3&gt; &#xA;&lt;p&gt;There are several directions we might take after these two major phases, like remote debugging, porting to different architectures, further improving the debugger&#39;s features (like improving the visualization engine), and so on. But for now, we&#39;re mostly focused on those first two phases.&lt;/p&gt; &#xA;&lt;h2&gt;Top-Level Directory Descriptions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;data&lt;/code&gt;: Small binary files which are used when building, either to embed within build artifacts, or to package with them.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src&lt;/code&gt;: All source code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After setting up the codebase and building, the following directories will also exist:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;build&lt;/code&gt;: All build artifacts. Not checked in to version control.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;local&lt;/code&gt;: Local files, used for local build configuration input files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Codebase Introduction&lt;/h2&gt; &#xA;&lt;p&gt;The codebase is organized into &lt;em&gt;layers&lt;/em&gt;. Layers are separated either to isolate certain problems, and to allow inclusion into various builds without needing to pull everything in the codebase into a build. Layers correspond with folders inside of the &lt;code&gt;src&lt;/code&gt; directory. Sometimes, one folder inside of the &lt;code&gt;src&lt;/code&gt; directory will include multiple sub-layers, but the structure is intended to be fairly flat.&lt;/p&gt; &#xA;&lt;p&gt;Layers correspond roughly 1-to-1 with &lt;em&gt;namespaces&lt;/em&gt;. The term &#34;namespaces&#34; in this context does not refer to specific namespace language features, but rather a naming convention for C-style namespaces, which are written in the codebase as a short prefix, usually 1-3 characters, followed by an underscore. These namespaces are used such that the layer to which certain code belongs may be quickly understood by glancing at code. The namespaces are generally quite short to ensure that they aren&#39;t much of a hassle to write. Sometimes, multiple sub- layers will share a namespace. A few layers do not have a namespace, but most do. Namespaces are either all-caps or lowercase depending on the context in which they&#39;re used. For types, enum values, and some macros, they are capitalized. For functions and global variables, they are lowercase.&lt;/p&gt; &#xA;&lt;p&gt;Layers depend on other layers, but circular dependencies would break the separability and isolation utility of layers (in effect, forming one big layer), so in other words, layers are arranged into a directed acyclic graph.&lt;/p&gt; &#xA;&lt;p&gt;A few layers are built to be used completely independently from the rest of the codebase, as libraries in other codebases and projects. As such, these layers do not depend on any other layers in the codebase. The folders which contain these layers are prefixed with &lt;code&gt;lib_&lt;/code&gt;, like &lt;code&gt;lib_rdi_format&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A list of the layers in the codebase and their associated namespaces is below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;base&lt;/code&gt; (no namespace): Universal, codebase-wide constructs. Strings, math, memory allocators, helper macros, command-line parsing, and so on. Depends on no other codebase layers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;codeview&lt;/code&gt; (&lt;code&gt;CV_&lt;/code&gt;): Code for parsing and/or writing the CodeView format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;coff&lt;/code&gt; (&lt;code&gt;COFF_&lt;/code&gt;): Code for parsing and/or writing the COFF (Common Object File Format) file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ctrl&lt;/code&gt; (&lt;code&gt;CTRL_&lt;/code&gt;): The debugger&#39;s &#34;control system&#34; layer. Implements asynchronous process control, stepping, and breakpoints for all attached processes. Runs in lockstep with attached processes. When it runs, attached processes are halted. When attached processes are running, it is halted. Driven by a debugger frontend on another thread.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dasm&lt;/code&gt; (&lt;code&gt;DASM_&lt;/code&gt;): An asynchronous disassembly decoder and cache. Users ask for disassembly for a particular virtual address range in a process, and threads implemented in this layer decode and cache the disassembly for that range.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dbgi&lt;/code&gt; (&lt;code&gt;DI_&lt;/code&gt;): An asynchronous debug info loader and cache. Loads debug info stored in the RDI format. Users ask for debug info for a particular path, and on separate threads, this layer loads the associated debug info file. If necessary, it will launch a separate conversion process to convert original debug info into the RDI format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;demon&lt;/code&gt; (&lt;code&gt;DEMON_&lt;/code&gt;): An abstraction layer for local-machine, low-level process control. The abstraction is used to provide a common interface for process control on target platforms. Used to implement part of &lt;code&gt;ctrl&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;df/core&lt;/code&gt; (&lt;code&gt;DF_&lt;/code&gt;): The debugger&#39;s non-graphical frontend. Implements a debugger &#34;entity cache&#34; (where &#34;entities&#34; include processes, threads, modules, breakpoints, source files, targets, and so on). Implements a command loop for driving process control, which is used to implement stepping commands and user breakpoints. Implements extractors and caches for various entity-related data, like full thread unwinds and local variable maps. Also implements core building blocks for evaluation and evaluation visualization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;df/gfx&lt;/code&gt; (&lt;code&gt;DF_&lt;/code&gt;): The debugger&#39;s graphical frontend. Builds on top of &lt;code&gt;df/core&lt;/code&gt; to provide all graphical features, including windows, panels, all of the various debugger interfaces, and evaluation visualization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;draw&lt;/code&gt; (&lt;code&gt;D_&lt;/code&gt;): Implements a high-level graphics drawing API for the debugger&#39;s purposes, using the underlying &lt;code&gt;render&lt;/code&gt; abstraction layer. Provides high-level APIs for various draw commands, but takes care of batching them, and so on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;eval&lt;/code&gt; (&lt;code&gt;EVAL_&lt;/code&gt;): Implements a compiler for an expression language built for evaluation of variables, registers, and so on from debugger-attached processes and/or debug info. Broken into several phases mostly corresponding to traditional compiler phases - lexer, parser, type-checker, IR generation, and IR evaluation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;font_cache&lt;/code&gt; (&lt;code&gt;F_&lt;/code&gt;): Implements a cache of rasterized font data, both in CPU- side data for text shaping, and in GPU texture atlases for rasterized glyphs. All cache information is sourced from the &lt;code&gt;font_provider&lt;/code&gt; abstraction layer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;font_provider&lt;/code&gt; (&lt;code&gt;FP_&lt;/code&gt;): An abstraction layer for various font file decoding and font rasterization backends.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;geo_cache&lt;/code&gt; (&lt;code&gt;GEO_&lt;/code&gt;): Implements an asynchronously-filled cache for GPU geometry data, filled by data sourced in the &lt;code&gt;hash_store&lt;/code&gt; layer&#39;s cache. Used for asynchronously preparing data for memory visualization in the debugger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hash_store&lt;/code&gt; (&lt;code&gt;HS_&lt;/code&gt;): Implements a cache for general data blobs, keyed by a 128-bit hash of the data. Used as a general data store by other layers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lib_raddbg_markup&lt;/code&gt; (&lt;code&gt;RADDBG_&lt;/code&gt;): Standalone library for marking up user programs to work with various features in the &lt;code&gt;raddbg&lt;/code&gt; debugger. Does not depend on &lt;code&gt;base&lt;/code&gt;, and can be independently relocated to other codebases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lib_rdi_make&lt;/code&gt; (&lt;code&gt;RDIM_&lt;/code&gt;): Standalone library for constructing RDI debug info data. Does not depend on &lt;code&gt;base&lt;/code&gt;, and can be independently relocated to other codebases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lib_rdi_format&lt;/code&gt; (&lt;code&gt;RDI_&lt;/code&gt;): Standalone library which defines the core RDI types and helper functions for reading and writing the RDI debug info file format. Does not depend on &lt;code&gt;base&lt;/code&gt;, and can be independently relocated to other codebases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metagen&lt;/code&gt; (&lt;code&gt;MG_&lt;/code&gt;): A metaprogram which is used to generate primarily code and data tables. Consumes Metadesk files, stored with the extension &lt;code&gt;.mdesk&lt;/code&gt;, and generates C code which is then included by hand-written C code. Currently, it does not analyze the codebase&#39;s hand-written C code, but in principle this is possible. This allows easier &amp;amp; less-error-prone management of large data tables, which are then used to produce e.g. C &lt;code&gt;enum&lt;/code&gt;s and a number of associated data tables. There are also a number of other generation features, like embedding binary files or complex multi-line strings into source code. This layer cannot depend on any other layer in the codebase directly, including &lt;code&gt;base&lt;/code&gt;, because it may be used to generate code for those layers. To still use &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;os&lt;/code&gt; layer features in the &lt;code&gt;metagen&lt;/code&gt; program, a separate, duplicate version of &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;os&lt;/code&gt; are included in this layer. They are updated manually, as needed. This is to ensure the stability of the metaprogram.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;msf&lt;/code&gt; (&lt;code&gt;MSF_&lt;/code&gt;): Code for parsing and/or writing the MSF file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mule&lt;/code&gt; (no namespace): Test executables for battle testing debugger functionality.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;natvis&lt;/code&gt; (no namespace): NatVis files for type visualization of the codebase&#39;s types in other debuggers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;os/core&lt;/code&gt; (&lt;code&gt;OS_&lt;/code&gt;): An abstraction layer providing core, non-graphical functionality from the operating system under an abstract API, which is implemented per-target-operating-system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;os/gfx&lt;/code&gt; (&lt;code&gt;OS_&lt;/code&gt;): An abstraction layer, building on &lt;code&gt;os/core&lt;/code&gt;, providing graphical operating system features under an abstract API, which is implemented per-target-operating-system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;os/socket&lt;/code&gt; (&lt;code&gt;OS_&lt;/code&gt;): An abstraction layer, building on &lt;code&gt;os/core&lt;/code&gt;, providing networking operating system features under an abstract API, which is implemented per-target-operating-system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pdb&lt;/code&gt; (&lt;code&gt;PDB_&lt;/code&gt;): Code for parsing and/or writing the PDB file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pe&lt;/code&gt; (&lt;code&gt;PE_&lt;/code&gt;): Code for parsing and/or writing the PE (Portable Executable) file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raddbg&lt;/code&gt; (no namespace): The layer which ties everything together for the main graphical debugger. Not much &#34;meat&#34;, just drives &lt;code&gt;df&lt;/code&gt;, implements command line options, and so on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rdi_from_pdb&lt;/code&gt; (&lt;code&gt;P2R_&lt;/code&gt;): Our implementation of PDB-to-RDI conversion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rdi_from_dwarf&lt;/code&gt; (&lt;code&gt;D2R_&lt;/code&gt;): Our in-progress implementation of DWARF-to-RDI conversion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rdi_dump&lt;/code&gt; (no namespace): A dumper utility program for dumping textualizations of RDI debug info files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;regs&lt;/code&gt; (&lt;code&gt;REGS_&lt;/code&gt;): Types, helper functions, and metadata for registers on supported architectures. Used in reading/writing registers in &lt;code&gt;demon&lt;/code&gt;, or in looking up register metadata.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render&lt;/code&gt; (&lt;code&gt;R_&lt;/code&gt;): An abstraction layer providing an abstract API for rendering using various GPU APIs under a common interface. Does not implement a high level drawing API - this layer is strictly for minimally abstracting on an as-needed basis. Higher level drawing features are implemented in the &lt;code&gt;draw&lt;/code&gt; layer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scratch&lt;/code&gt; (no namespace): Scratch space for small and transient test or sample programs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;texture_cache&lt;/code&gt; (&lt;code&gt;TEX_&lt;/code&gt;): Implements an asynchronously-filled cache for GPU texture data, filled by data sourced in the &lt;code&gt;hash_store&lt;/code&gt; layer&#39;s cache. Used for asynchronously preparing data for memory visualization in the debugger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;txti&lt;/code&gt; (&lt;code&gt;TXTI_&lt;/code&gt;): Machinery for asynchronously-loaded, asynchronously hot- reloaded, asynchronously parsed, and asynchronously mutated source code files. Used by the debugger to visualize source code files. Users ask for text lines, tokens, and metadata, and it is prepared on background threads.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;type_graph&lt;/code&gt; (&lt;code&gt;TG_&lt;/code&gt;): Code for analyzing and navigating type structures from RDI debug info files, with the additional capability of constructing synthetic types &lt;em&gt;not&lt;/em&gt; found in debug info. Used in &lt;code&gt;eval&lt;/code&gt; and for various visualization features.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ui&lt;/code&gt; (&lt;code&gt;UI_&lt;/code&gt;): Machinery for building graphical user interfaces. Provides a core immediate mode hierarchical user interface data structure building API, and has helper layers for building some higher-level widgets.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>