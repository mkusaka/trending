<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-01T01:41:03Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hengyoush/kyanos</title>
    <updated>2024-12-01T01:41:03Z</updated>
    <id>tag:github.com,2024-12-01:/hengyoush/kyanos</id>
    <link href="https://github.com/hengyoush/kyanos" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Visualize the time packets spend in the kernel, watch &amp; analyze in command line.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;kyanos&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/last-commit/hengyoush/kyanos&#34; alt=&#34;GitHub last commit&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/hengyoush/kyanos&#34; alt=&#34;GitHub release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/hengyoush/kyanos/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/hengyoush/kyanos/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Test&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/kyanos-demo.gif&#34; alt=&#34;&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/README_CN.md&#34;&gt;ÁÆÄ‰Ωì‰∏≠Êñá&lt;/a&gt; | English&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kyanos.pages.dev/&#34;&gt;English Document&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#-what-is-kyanos&#34;&gt;What is kyanos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#-examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#-requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#-how-to-get-kyanos&#34;&gt;How to get kyanos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#-documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#-usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#-feedback-and-contributions&#34;&gt;Feedback and Contributions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#%EF%B8%8F-contacts&#34;&gt;Contacts&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What is kyanos&lt;/h2&gt; &#xA;&lt;p&gt;Kyanos is an &lt;strong&gt;eBPF-based&lt;/strong&gt; network issue analysis tool that enables you to capture network requests, such as HTTP, Redis, and MySQL requests.&lt;br&gt; It also helps you analyze abnormal network issues and quickly troubleshooting without the complex steps of packet capturing, downloading, and analysis.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful Traffic Filtering&lt;/strong&gt;: Not only can filter based on traditional IP/port information, can also filter by process/container, L7 protocol information, request/response byte size, latency, and more.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Filter by pid&#xA;./kyanos watch --pids 1234&#xA;# Filter by container id&#xA;./kyanos watch --container-id abc&#xA;# Filter by Redis key&#xA;./kyanos watch redis --keys my-key1,my-key2&#xA;# Filter by response byte size&#xA;./kyanos watch --resp-size 10000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Advanced Analysis Capabilities&lt;/strong&gt; : Unlike tcpdump, which only provides fine-grained packet capture, Kyanos supports aggregating captured packet metrics across various dimensions, quickly providing the critical data most useful for troubleshooting.&lt;br&gt; Imagine if the bandwidth of your HTTP service is suddenly maxed out‚Äîhow would you quickly analyze &lt;code&gt;which IPs&lt;/code&gt; and &lt;code&gt;which requests&lt;/code&gt; are causing it?&lt;br&gt; With Kyanos, you just need one command: &lt;code&gt;kyanos stat http --bigresp&lt;/code&gt; to find the largest response byte sizes sent to remote IPs and view specific data on request and response metrics.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/whatkyanos.gif&#34; alt=&#34;kyanos find big response&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;In-Depth Kernel-Level Latency Details&lt;/strong&gt;: In real-world, slow queries to remote services like Redis can be challenging to diagnose precisely. Kyanos provides kernel trace points from the arrival of requests/responses at the network card to the kernel socket buffer, displaying these details in a visual format. This allows you to identify exactly which stage is causing delays.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/timedetail.jpg&#34; alt=&#34;kyanos time detail&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Lightweight and Dependency-Free&lt;/strong&gt;: Almost zero dependencies‚Äîjust a single binary file and one command, with all results displayed in the command line.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Automatic SSL Traffic Decryption&lt;/strong&gt; : All captured requests and responses are presented in plaintext.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Capture HTTP Traffic with Latency Details&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Run the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./kyanos watch http&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result is as follows:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/qs-watch-http.gif&#34; alt=&#34;kyanos quick start watch http&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Capture Redis Traffic with Latency Details&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Run the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./kyanos watch redis&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result is as follows:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/qs-redis.gif&#34; alt=&#34;kyanos quick start watch redis&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Identify the Slowest Requests in the Last 5 Seconds&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Run the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; ./kyanos stat --slow --time 5 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result is as follows:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/qs-stat-slow.gif&#34; alt=&#34;kyanos stat slow&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;‚ùó Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Kyanos currently supports kernel versions 3.10(from 3.10.0-957) and 4.14 or above (with plans to support versions between 4.7 and 4.14 in the future).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can check your kernel version using &lt;code&gt;uname -r&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;üéØ How to get kyanos&lt;/h2&gt; &#xA;&lt;p&gt;You can download a statically linked binary compatible with x86_64 and arm64 architectures from the &lt;a href=&#34;https://github.com/hengyoush/kyanos/releases&#34;&gt;release page&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar xvf kyanos_vx.x.x_linux_x86.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kyanos watch &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the following table appears: &lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/quickstart-success.png&#34; alt=&#34;kyanos quick start success&#34;&gt; üéâ Congratulations! Kyanos has started successfully.&lt;/p&gt; &#xA;&lt;h2&gt;üìù Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://kyanos.pages.dev/&#34;&gt;English Document&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;‚öô Usage&lt;/h2&gt; &#xA;&lt;p&gt;The simplest usage captures all protocols currently supported by Kyanos:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./kyanos watch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each request-response record is stored as a row in a table, with each column capturing basic information about that request. You can use the arrow keys or &lt;code&gt;j/k&lt;/code&gt; to move up and down through the records: &lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/watch-result.jpg&#34; alt=&#34;kyanos watch result&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Press &lt;code&gt;Enter&lt;/code&gt; to access the details view:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/docs/public/watch-result-detail.jpg&#34; alt=&#34;kyanos watch result detail&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the details view, the first section shows &lt;strong&gt;Latency Details&lt;/strong&gt;. Each block represents a &#34;node&#34; that the data packet passes through, such as the process, network card, and socket buffer.&lt;br&gt; Each block includes a time value indicating the time elapsed from the previous node to this node, showing the process flow from the process sending the request to the network card, to the response being copied to the socket buffer, and finally read by the process, with each step‚Äôs duration displayed.&lt;/p&gt; &#xA;&lt;p&gt;The second section provides &lt;strong&gt;Detailed Request and Response Content&lt;/strong&gt;, split into Request and Response parts, and truncates content over 1024 bytes.&lt;/p&gt; &#xA;&lt;p&gt;For targeted traffic capture, such as HTTP traffic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./kyanos watch http&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can narrow it further to capture traffic for a specific HTTP path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./kyanos watch http --path /abc &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Learn more: &lt;a href=&#34;https://kyanos.pages.dev/&#34;&gt;Kyanos Docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ü§ù Feedback and Contributions&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] If you encounter any issues or bugs while using the tool, please feel free to ask questions in the issue tracker.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;üó®Ô∏è Contacts&lt;/h2&gt; &#xA;&lt;p&gt;For more detailed inquiries, you can use the following contact methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;My Email:&lt;/strong&gt; &lt;a href=&#34;mailto:hengyoush1@163.com&#34;&gt;hengyoush1@163.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;My Blog:&lt;/strong&gt; &lt;a href=&#34;http://blog.deadlock.cloud/&#34;&gt;http://blog.deadlock.cloud&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hengyoush/kyanos/main/#top&#34;&gt;Back to top&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/AFL</title>
    <updated>2024-12-01T01:41:03Z</updated>
    <id>tag:github.com,2024-12-01:/google/AFL</id>
    <link href="https://github.com/google/AFL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;american fuzzy lop - a security-oriented fuzzer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;american fuzzy lop&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/google/AFL&#34;&gt;&lt;img src=&#34;https://travis-ci.org/google/AFL.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Originally developed by Michal Zalewski &lt;a href=&#34;mailto:lcamtuf@google.com&#34;&gt;lcamtuf@google.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/QuickStartGuide.txt&#34;&gt;QuickStartGuide.txt&lt;/a&gt; if you don&#39;t have time to read this file.&lt;/p&gt; &#xA;&lt;h2&gt;1) Challenges of guided fuzzing&lt;/h2&gt; &#xA;&lt;p&gt;Fuzzing is one of the most powerful and proven strategies for identifying security issues in real-world software; it is responsible for the vast majority of remote code execution and privilege escalation bugs found to date in security-critical software.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, fuzzing is also relatively shallow; blind, random mutations make it very unlikely to reach certain code paths in the tested code, leaving some vulnerabilities firmly outside the reach of this technique.&lt;/p&gt; &#xA;&lt;p&gt;There have been numerous attempts to solve this problem. One of the early approaches - pioneered by Tavis Ormandy - is corpus distillation. The method relies on coverage signals to select a subset of interesting seeds from a massive, high-quality corpus of candidate files, and then fuzz them by traditional means. The approach works exceptionally well, but requires such a corpus to be readily available. In addition, block coverage measurements provide only a very simplistic understanding of program state, and are less useful for guiding the fuzzing effort in the long haul.&lt;/p&gt; &#xA;&lt;p&gt;Other, more sophisticated research has focused on techniques such as program flow analysis (&#34;concolic execution&#34;), symbolic execution, or static analysis. All these methods are extremely promising in experimental settings, but tend to suffer from reliability and performance problems in practical uses - and currently do not offer a viable alternative to &#34;dumb&#34; fuzzing techniques.&lt;/p&gt; &#xA;&lt;h2&gt;2) The afl-fuzz approach&lt;/h2&gt; &#xA;&lt;p&gt;American Fuzzy Lop is a brute-force fuzzer coupled with an exceedingly simple but rock-solid instrumentation-guided genetic algorithm. It uses a modified form of edge coverage to effortlessly pick up subtle, local-scale changes to program control flow.&lt;/p&gt; &#xA;&lt;p&gt;Simplifying a bit, the overall algorithm can be summed up as:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Load user-supplied initial test cases into the queue,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Take next input file from the queue,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Attempt to trim the test case to the smallest size that doesn&#39;t alter the measured behavior of the program,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Repeatedly mutate the file using a balanced and well-researched variety of traditional fuzzing strategies,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If any of the generated mutations resulted in a new state transition recorded by the instrumentation, add mutated output as a new entry in the queue.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Go to 2.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The discovered test cases are also periodically culled to eliminate ones that have been obsoleted by newer, higher-coverage finds; and undergo several other instrumentation-driven effort minimization steps.&lt;/p&gt; &#xA;&lt;p&gt;As a side result of the fuzzing process, the tool creates a small, self-contained corpus of interesting test cases. These are extremely useful for seeding other, labor- or resource-intensive testing regimes - for example, for stress-testing browsers, office applications, graphics suites, or closed-source tools.&lt;/p&gt; &#xA;&lt;p&gt;The fuzzer is thoroughly tested to deliver out-of-the-box performance far superior to blind fuzzing or coverage-only tools.&lt;/p&gt; &#xA;&lt;h2&gt;3) Instrumenting programs for use with AFL&lt;/h2&gt; &#xA;&lt;p&gt;When source code is available, instrumentation can be injected by a companion tool that works as a drop-in replacement for gcc or clang in any standard build process for third-party code.&lt;/p&gt; &#xA;&lt;p&gt;The instrumentation has a fairly modest performance impact; in conjunction with other optimizations implemented by afl-fuzz, most programs can be fuzzed as fast or even faster than possible with traditional tools.&lt;/p&gt; &#xA;&lt;p&gt;The correct way to recompile the target program may vary depending on the specifics of the build process, but a nearly-universal approach would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CC=/path/to/afl/afl-gcc ./configure&#xA;$ make clean all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For C++ programs, you&#39;d would also want to set &lt;code&gt;CXX=/path/to/afl/afl-g++&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The clang wrappers (afl-clang and afl-clang++) can be used in the same way; clang users may also opt to leverage a higher-performance instrumentation mode, as described in llvm_mode/README.llvm.&lt;/p&gt; &#xA;&lt;p&gt;When testing libraries, you need to find or write a simple program that reads data from stdin or from a file and passes it to the tested library. In such a case, it is essential to link this executable against a static version of the instrumented library, or to make sure that the correct .so file is loaded at runtime (usually by setting &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;). The simplest option is a static build, usually possible via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CC=/path/to/afl/afl-gcc ./configure --disable-shared&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;AFL_HARDEN=1&lt;/code&gt; when calling &#39;make&#39; will cause the CC wrapper to automatically enable code hardening options that make it easier to detect simple memory bugs. Libdislocator, a helper library included with AFL (see libdislocator/README.dislocator) can help uncover heap corruption issues, too.&lt;/p&gt; &#xA;&lt;p&gt;PS. ASAN users are advised to review &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/notes_for_asan.txt&#34;&gt;notes_for_asan.txt&lt;/a&gt; file for important caveats.&lt;/p&gt; &#xA;&lt;h2&gt;4) Instrumenting binary-only apps&lt;/h2&gt; &#xA;&lt;p&gt;When source code is &lt;em&gt;NOT&lt;/em&gt; available, the fuzzer offers experimental support for fast, on-the-fly instrumentation of black-box binaries. This is accomplished with a version of QEMU running in the lesser-known &#34;user space emulation&#34; mode.&lt;/p&gt; &#xA;&lt;p&gt;QEMU is a project separate from AFL, but you can conveniently build the feature by doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd qemu_mode&#xA;$ ./build_qemu_support.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For additional instructions and caveats, see qemu_mode/README.qemu.&lt;/p&gt; &#xA;&lt;p&gt;The mode is approximately 2-5x slower than compile-time instrumentation, is less conducive to parallelization, and may have some other quirks.&lt;/p&gt; &#xA;&lt;h2&gt;5) Choosing initial test cases&lt;/h2&gt; &#xA;&lt;p&gt;To operate correctly, the fuzzer requires one or more starting file that contains a good example of the input data normally expected by the targeted application. There are two basic rules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep the files small. Under 1 kB is ideal, although not strictly necessary. For a discussion of why size matters, see &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/perf_tips.txt&#34;&gt;perf_tips.txt&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use multiple test cases only if they are functionally different from each other. There is no point in using fifty different vacation photos to fuzz an image library.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can find many good examples of starting files in the testcases/ subdirectory that comes with this tool.&lt;/p&gt; &#xA;&lt;p&gt;PS. If a large corpus of data is available for screening, you may want to use the afl-cmin utility to identify a subset of functionally distinct files that exercise different code paths in the target binary.&lt;/p&gt; &#xA;&lt;h2&gt;6) Fuzzing binaries&lt;/h2&gt; &#xA;&lt;p&gt;The fuzzing process itself is carried out by the afl-fuzz utility. This program requires a read-only directory with initial test cases, a separate place to store its findings, plus a path to the binary to test.&lt;/p&gt; &#xA;&lt;p&gt;For target binaries that accept input directly from stdin, the usual syntax is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For programs that take input from a file, use &#39;@@&#39; to mark the location in the target&#39;s command line where the input file name should be placed. The fuzzer will substitute this for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use the -f option to have the mutated data written to a specific file. This is useful if the program expects a particular file extension or so.&lt;/p&gt; &#xA;&lt;p&gt;Non-instrumented binaries can be fuzzed in the QEMU mode (add -Q in the command line) or in a traditional, blind-fuzzer mode (specify -n).&lt;/p&gt; &#xA;&lt;p&gt;You can use -t and -m to override the default timeout and memory limit for the executed process; rare examples of targets that may need these settings touched include compilers and video decoders.&lt;/p&gt; &#xA;&lt;p&gt;Tips for optimizing fuzzing performance are discussed in &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/perf_tips.txt&#34;&gt;perf_tips.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that afl-fuzz starts by performing an array of deterministic fuzzing steps, which can take several days, but tend to produce neat test cases. If you want quick &amp;amp; dirty results right away - akin to zzuf and other traditional fuzzers - add the -d option to the command line.&lt;/p&gt; &#xA;&lt;h2&gt;7) Interpreting output&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/status_screen.txt&#34;&gt;status_screen.txt&lt;/a&gt; file for information on how to interpret the displayed stats and monitor the health of the process. Be sure to consult this file especially if any UI elements are highlighted in red.&lt;/p&gt; &#xA;&lt;p&gt;The fuzzing process will continue until you press Ctrl-C. At minimum, you want to allow the fuzzer to complete one queue cycle, which may take anywhere from a couple of hours to a week or so.&lt;/p&gt; &#xA;&lt;p&gt;There are three subdirectories created within the output directory and updated in real time:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;queue/ - test cases for every distinctive execution path, plus all the starting files given by the user. This is the synthesized corpus mentioned in section 2. Before using this corpus for any other purposes, you can shrink it to a smaller size using the afl-cmin tool. The tool will find a smaller subset of files offering equivalent edge coverage.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;crashes/ - unique test cases that cause the tested program to receive a fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are grouped by the received signal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;hangs/ - unique test cases that cause the tested program to time out. The default time limit before something is classified as a hang is the larger of 1 second and the value of the -t parameter. The value can be fine-tuned by setting AFL_HANG_TMOUT, but this is rarely necessary.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Crashes and hangs are considered &#34;unique&#34; if the associated execution paths involve any state transitions not seen in previously-recorded faults. If a single bug can be reached in multiple ways, there will be some count inflation early in the process, but this should quickly taper off.&lt;/p&gt; &#xA;&lt;p&gt;The file names for crashes and hangs are correlated with parent, non-faulting queue entries. This should help with debugging.&lt;/p&gt; &#xA;&lt;p&gt;When you can&#39;t reproduce a crash found by afl-fuzz, the most likely cause is that you are not setting the same memory limit as used by the tool. Try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ LIMIT_MB=50&#xA;$ ( ulimit -Sv $[LIMIT_MB &amp;lt;&amp;lt; 10]; /path/to/tested_binary ... )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change LIMIT_MB to match the -m parameter passed to afl-fuzz. On OpenBSD, also change -Sv to -Sd.&lt;/p&gt; &#xA;&lt;p&gt;Any existing output directory can be also used to resume aborted jobs; try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-fuzz -i- -o existing_output_dir [...etc...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have gnuplot installed, you can also generate some pretty graphs for any active fuzzing task using afl-plot. For an example of how this looks like, see &lt;a href=&#34;http://lcamtuf.coredump.cx/afl/plot/&#34;&gt;http://lcamtuf.coredump.cx/afl/plot/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;8) Parallelized fuzzing&lt;/h2&gt; &#xA;&lt;p&gt;Every instance of afl-fuzz takes up roughly one core. This means that on multi-core systems, parallelization is necessary to fully utilize the hardware. For tips on how to fuzz a common target on multiple cores or multiple networked machines, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/parallel_fuzzing.txt&#34;&gt;parallel_fuzzing.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The parallel fuzzing mode also offers a simple way for interfacing AFL to other fuzzers, to symbolic or concolic execution engines, and so forth; again, see the last section of &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/parallel_fuzzing.txt&#34;&gt;parallel_fuzzing.txt&lt;/a&gt; for tips.&lt;/p&gt; &#xA;&lt;h2&gt;9) Fuzzer dictionaries&lt;/h2&gt; &#xA;&lt;p&gt;By default, afl-fuzz mutation engine is optimized for compact data formats - say, images, multimedia, compressed data, regular expression syntax, or shell scripts. It is somewhat less suited for languages with particularly verbose and redundant verbiage - notably including HTML, SQL, or JavaScript.&lt;/p&gt; &#xA;&lt;p&gt;To avoid the hassle of building syntax-aware tools, afl-fuzz provides a way to seed the fuzzing process with an optional dictionary of language keywords, magic headers, or other special tokens associated with the targeted data type -- and use that to reconstruct the underlying grammar on the go:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html&#34;&gt;http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To use this feature, you first need to create a dictionary in one of the two formats discussed in dictionaries/README.dictionaries; and then point the fuzzer to it via the -x option in the command line.&lt;/p&gt; &#xA;&lt;p&gt;(Several common dictionaries are already provided in that subdirectory, too.)&lt;/p&gt; &#xA;&lt;p&gt;There is no way to provide more structured descriptions of the underlying syntax, but the fuzzer will likely figure out some of this based on the instrumentation feedback alone. This actually works in practice, say:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html&#34;&gt;http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;PS. Even when no explicit dictionary is given, afl-fuzz will try to extract existing syntax tokens in the input corpus by watching the instrumentation very closely during deterministic byte flips. This works for some types of parsers and grammars, but isn&#39;t nearly as good as the -x mode.&lt;/p&gt; &#xA;&lt;p&gt;If a dictionary is really hard to come by, another option is to let AFL run for a while, and then use the token capture library that comes as a companion utility with AFL. For that, see libtokencap/README.tokencap.&lt;/p&gt; &#xA;&lt;h2&gt;10) Crash triage&lt;/h2&gt; &#xA;&lt;p&gt;The coverage-based grouping of crashes usually produces a small data set that can be quickly triaged manually or with a very simple GDB or Valgrind script. Every crash is also traceable to its parent non-crashing test case in the queue, making it easier to diagnose faults.&lt;/p&gt; &#xA;&lt;p&gt;Having said that, it&#39;s important to acknowledge that some fuzzing crashes can be difficult to quickly evaluate for exploitability without a lot of debugging and code analysis work. To assist with this task, afl-fuzz supports a very unique &#34;crash exploration&#34; mode enabled with the -C flag.&lt;/p&gt; &#xA;&lt;p&gt;In this mode, the fuzzer takes one or more crashing test cases as the input, and uses its feedback-driven fuzzing strategies to very quickly enumerate all code paths that can be reached in the program while keeping it in the crashing state.&lt;/p&gt; &#xA;&lt;p&gt;Mutations that do not result in a crash are rejected; so are any changes that do not affect the execution path.&lt;/p&gt; &#xA;&lt;p&gt;The output is a small corpus of files that can be very rapidly examined to see what degree of control the attacker has over the faulting address, or whether it is possible to get past an initial out-of-bounds read - and see what lies beneath.&lt;/p&gt; &#xA;&lt;p&gt;Oh, one more thing: for test case minimization, give afl-tmin a try. The tool can be operated in a very simple way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tool works with crashing and non-crashing test cases alike. In the crash mode, it will happily accept instrumented and non-instrumented binaries. In the non-crashing mode, the minimizer relies on standard AFL instrumentation to make the file simpler without altering the execution path.&lt;/p&gt; &#xA;&lt;p&gt;The minimizer accepts the -m, -t, -f and @@ syntax in a manner compatible with afl-fuzz.&lt;/p&gt; &#xA;&lt;p&gt;Another recent addition to AFL is the afl-analyze tool. It takes an input file, attempts to sequentially flip bytes, and observes the behavior of the tested program. It then color-codes the input based on which sections appear to be critical, and which are not; while not bulletproof, it can often offer quick insights into complex file formats. More info about its operation can be found near the end of &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/technical_details.txt&#34;&gt;technical_details.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;11) Going beyond crashes&lt;/h2&gt; &#xA;&lt;p&gt;Fuzzing is a wonderful and underutilized technique for discovering non-crashing design and implementation errors, too. Quite a few interesting bugs have been found by modifying the target programs to call abort() when, say:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Two bignum libraries produce different outputs when given the same fuzzer-generated input,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;An image library produces different outputs when asked to decode the same input image several times in a row,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A serialization / deserialization library fails to produce stable outputs when iteratively serializing and deserializing fuzzer-supplied data,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A compression library produces an output inconsistent with the input file when asked to compress and then decompress a particular blob.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Implementing these or similar sanity checks usually takes very little time; if you are the maintainer of a particular package, you can make this code conditional with &lt;code&gt;#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION&lt;/code&gt; (a flag also shared with libfuzzer) or &lt;code&gt;#ifdef __AFL_COMPILER&lt;/code&gt; (this one is just for AFL).&lt;/p&gt; &#xA;&lt;h2&gt;12) Common-sense risks&lt;/h2&gt; &#xA;&lt;p&gt;Please keep in mind that, similarly to many other computationally-intensive tasks, fuzzing may put strain on your hardware and on the OS. In particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Your CPU will run hot and will need adequate cooling. In most cases, if cooling is insufficient or stops working properly, CPU speeds will be automatically throttled. That said, especially when fuzzing on less suitable hardware (laptops, smartphones, etc), it&#39;s not entirely impossible for something to blow up.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Targeted programs may end up erratically grabbing gigabytes of memory or filling up disk space with junk files. AFL tries to enforce basic memory limits, but can&#39;t prevent each and every possible mishap. The bottom line is that you shouldn&#39;t be fuzzing on systems where the prospect of data loss is not an acceptable risk.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fuzzing involves billions of reads and writes to the filesystem. On modern systems, this will be usually heavily cached, resulting in fairly modest &#34;physical&#34; I/O - but there are many factors that may alter this equation. It is your responsibility to monitor for potential trouble; with very heavy I/O, the lifespan of many HDDs and SSDs may be reduced.&lt;/p&gt; &lt;p&gt;A good way to monitor disk I/O on Linux is the &#39;iostat&#39; command:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    $ iostat -d 3 -x -k [...optional disk ID...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;13) Known limitations &amp;amp; areas for improvement&lt;/h2&gt; &#xA;&lt;p&gt;Here are some of the most important caveats for AFL:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;AFL detects faults by checking for the first spawned process dying due to a signal (SIGSEGV, SIGABRT, etc). Programs that install custom handlers for these signals may need to have the relevant code commented out. In the same vein, faults in child processed spawned by the fuzzed target may evade detection unless you manually add some code to catch that.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;As with any other brute-force tool, the fuzzer offers limited coverage if encryption, checksums, cryptographic signatures, or compression are used to wholly wrap the actual data format to be tested.&lt;/p&gt; &lt;p&gt;To work around this, you can comment out the relevant checks (see experimental/libpng_no_checksum/ for inspiration); if this is not possible, you can also write a postprocessor, as explained in experimental/post_library/.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There are some unfortunate trade-offs with ASAN and 64-bit binaries. This isn&#39;t due to any specific fault of afl-fuzz; see &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/notes_for_asan.txt&#34;&gt;notes_for_asan.txt&lt;/a&gt; for tips.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There is no direct support for fuzzing network services, background daemons, or interactive apps that require UI interaction to work. You may need to make simple code changes to make them behave in a more traditional way. Preeny may offer a relatively simple option, too - see: &lt;a href=&#34;https://github.com/zardus/preeny&#34;&gt;https://github.com/zardus/preeny&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Some useful tips for modifying network-based services can be also found at: &lt;a href=&#34;https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop&#34;&gt;https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;AFL doesn&#39;t output human-readable coverage data. If you want to monitor coverage, use afl-cov from Michael Rash: &lt;a href=&#34;https://github.com/mrash/afl-cov&#34;&gt;https://github.com/mrash/afl-cov&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Occasionally, sentient machines rise against their creators. If this happens to you, please consult &lt;a href=&#34;http://lcamtuf.coredump.cx/prep/&#34;&gt;http://lcamtuf.coredump.cx/prep/&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Beyond this, see INSTALL for platform-specific tips.&lt;/p&gt; &#xA;&lt;h2&gt;14) Special thanks&lt;/h2&gt; &#xA;&lt;p&gt;Many of the improvements to afl-fuzz wouldn&#39;t be possible without feedback, bug reports, or patches from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  Jann Horn                             Hanno Boeck&#xA;  Felix Groebert                        Jakub Wilk&#xA;  Richard W. M. Jones                   Alexander Cherepanov&#xA;  Tom Ritter                            Hovik Manucharyan&#xA;  Sebastian Roschke                     Eberhard Mattes&#xA;  Padraig Brady                         Ben Laurie&#xA;  @dronesec                             Luca Barbato&#xA;  Tobias Ospelt                         Thomas Jarosch&#xA;  Martin Carpenter                      Mudge Zatko&#xA;  Joe Zbiciak                           Ryan Govostes&#xA;  Michael Rash                          William Robinet&#xA;  Jonathan Gray                         Filipe Cabecinhas&#xA;  Nico Weber                            Jodie Cunningham&#xA;  Andrew Griffiths                      Parker Thompson&#xA;  Jonathan Neuschfer                    Tyler Nighswander&#xA;  Ben Nagy                              Samir Aguiar&#xA;  Aidan Thornton                        Aleksandar Nikolich&#xA;  Sam Hakim                             Laszlo Szekeres&#xA;  David A. Wheeler                      Turo Lamminen&#xA;  Andreas Stieger                       Richard Godbee&#xA;  Louis Dassy                           teor2345&#xA;  Alex Moneger                          Dmitry Vyukov&#xA;  Keegan McAllister                     Kostya Serebryany&#xA;  Richo Healey                          Martijn Bogaard&#xA;  rc0r                                  Jonathan Foote&#xA;  Christian Holler                      Dominique Pelle&#xA;  Jacek Wielemborek                     Leo Barnes&#xA;  Jeremy Barnes                         Jeff Trull&#xA;  Guillaume Endignoux                   ilovezfs&#xA;  Daniel Godas-Lopez                    Franjo Ivancic&#xA;  Austin Seipp                          Daniel Komaromy&#xA;  Daniel Binderman                      Jonathan Metzman&#xA;  Vegard Nossum                         Jan Kneschke&#xA;  Kurt Roeckx                           Marcel Bohme&#xA;  Van-Thuan Pham                        Abhik Roychoudhury&#xA;  Joshua J. Drake                       Toby Hutton&#xA;  Rene Freingruber                      Sergey Davidoff&#xA;  Sami Liedes                           Craig Young&#xA;  Andrzej Jackowski                     Daniel Hodson&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Thank you!&lt;/p&gt; &#xA;&lt;h2&gt;15) Contact&lt;/h2&gt; &#xA;&lt;p&gt;Questions? Concerns? Bug reports? Please use GitHub.&lt;/p&gt; &#xA;&lt;p&gt;There is also a mailing list for the project; to join, send a mail to &lt;a href=&#34;mailto:afl-users+subscribe@googlegroups.com&#34;&gt;afl-users+subscribe@googlegroups.com&lt;/a&gt;. Or, if you prefer to browse archives first, try: &lt;a href=&#34;https://groups.google.com/group/afl-users&#34;&gt;https://groups.google.com/group/afl-users&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>apache/cloudberry</title>
    <updated>2024-12-01T01:41:03Z</updated>
    <id>tag:github.com,2024-12-01:/apache/cloudberry</id>
    <link href="https://github.com/apache/cloudberry" rel="alternate"></link>
    <summary type="html">&lt;p&gt;One advanced and mature open-source MPP (Massively Parallel Processing) database. Open source alternative to Greenplum Database.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apache Cloudberry (Incubating)&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;./.github/full_color_black.svg&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;./.github/full_color_white.svg&#34;&gt; &#xA;  &lt;img alt=&#34;Cloudberry Database Logo&#34; src=&#34;https://raw.githubusercontent.com/apache/cloudberry/main/.github/full_color_black.svg?sanitize=true&#34; width=&#34;400px&#34;&gt; &#xA; &lt;/picture&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cloudberry.apache.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Website-eebc46&#34; alt=&#34;Website&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cloudberry.apache.org/docs&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Documentation-acd94a&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://inviter.co/apache-cloudberry&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Join_Slack-6a32c9&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/ASFCloudberry&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/ASFCloudberry&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cloudberry.apache.org/community/wechat&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/WeChat-eebc46&#34; alt=&#34;WeChat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://youtube.com/@ApacheCloudberry&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Youtube-gebc46&#34; alt=&#34;Youtube&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/apache/cloudberry/discussions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/discussions/apache/cloudberry&#34; alt=&#34;GitHub Discussions&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/commit-activity/m/apache/cloudberry&#34; alt=&#34;GitHub commit activity(branch)&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/contributors/apache/cloudberry&#34; alt=&#34;GitHub contributors&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/apache/cloudberry&#34; alt=&#34;GitHub License&#34;&gt; &lt;a href=&#34;https://github.com/apache/cloudberry/actions/workflows/build-cloudberry.yml&#34;&gt;&lt;img src=&#34;https://github.com/apache/cloudberry/actions/workflows/build-cloudberry.yml/badge.svg?sanitize=true&#34; alt=&#34;Apache Cloudberry Build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Apache Cloudberry (Incubating), created by the original developers of Greenplum Database, is one advanced and mature open-source Massively Parallel Processing (MPP) database, which evolves from the open-source version of the Pivotal Greenplum Database¬ÆÔ∏è but features a newer PostgreSQL kernel and more advanced enterprise capabilities. It can serve as a data warehouse and can also be used for large-scale analytics and AI/ML workloads.&lt;/p&gt; &#xA;&lt;h2&gt;Build and try out&lt;/h2&gt; &#xA;&lt;h3&gt;Build from source&lt;/h3&gt; &#xA;&lt;p&gt;You can follow &lt;a href=&#34;https://raw.githubusercontent.com/apache/cloudberry/main/deploy/build&#34;&gt;these guides&lt;/a&gt; to build Cloudberry on Linux OS (including RHEL/Rocky Linux, and Ubuntu) and macOS.&lt;/p&gt; &#xA;&lt;h3&gt;Try out quickly&lt;/h3&gt; &#xA;&lt;p&gt;Welcome to try out Cloudberry via building &lt;a href=&#34;https://github.com/apache/cloudberry-bootcamp&#34;&gt;one Docker-based Sandbox&lt;/a&gt;, which is tailored to help you gain a basic understanding of Cloudberry&#39;s capabilities and features a range of materials, including tutorials, sample code, and crash courses.&lt;/p&gt; &#xA;&lt;h2&gt;Repositories&lt;/h2&gt; &#xA;&lt;p&gt;This is the main repository for Apache Cloudberry (Incubating). Alongside this, there are several ecosystem repositories for Cloudberry, including the website, extensions, connectors, adapters, and other utilities.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/cloudberry-site&#34;&gt;apache/cloudberry-site&lt;/a&gt;: website and documentation sources.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/cloudberry-bootcamp&#34;&gt;apache/cloudberry-bootcamp&lt;/a&gt;: help you quickly try out Cloudberry via one Docker-based Sandbox.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/cloudberry-gpbackup&#34;&gt;apache/cloudberry-gpbackup&lt;/a&gt;: backup utility for Cloudberry.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/cloudberry-go-libs&#34;&gt;apache/cloudberry-go-libs&lt;/a&gt;: go-libs for Cloudberry.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/cloudberry-gpbackup-s3-plugin&#34;&gt;apache/cloudberry-gpbackup-s3-plugin&lt;/a&gt;: S3 plugin for use with Cloudberry backup utility.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/cloudberry-pxf&#34;&gt;apache/cloudberry-pxf&lt;/a&gt;: Platform Extension Framework (PXF) for Cloudberry.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Community &amp;amp; Support&lt;/h2&gt; &#xA;&lt;p&gt;We have many channels for community members to discuss, ask for help, feedback, and chat:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Slack&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://inviter.co/apache-cloudberry&#34;&gt;Click to Join&lt;/a&gt; the real-time chat on Slack for QA, Dev, Events, and more. Don&#39;t miss out! Check out the &lt;a href=&#34;https://cloudberry.apache.org/community/slack&#34;&gt;Slack guide&lt;/a&gt; to learn more.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Q&amp;amp;A&lt;/td&gt; &#xA;   &lt;td&gt;Ask for help when running/developing Cloudberry, visit &lt;a href=&#34;https://github.com/apache/cloudberry/discussions/categories/q-a&#34;&gt;GitHub Discussions - QA&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;New ideas / Feature Requests&lt;/td&gt; &#xA;   &lt;td&gt;Share ideas for new features, visit &lt;a href=&#34;https://github.com/apache/cloudberry/discussions/categories/ideas-feature-requests&#34;&gt;GitHub Discussions - Ideas&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Report bugs&lt;/td&gt; &#xA;   &lt;td&gt;Problems and issues in Apache Cloudberry core. If you find bugs, welcome to submit them &lt;a href=&#34;https://github.com/apache/cloudberrydb/issues&#34;&gt;here&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Report a security vulnerability&lt;/td&gt; &#xA;   &lt;td&gt;View our &lt;a href=&#34;https://github.com/apache/cloudberry/security/policy&#34;&gt;security policy&lt;/a&gt; to learn how to report and contact us.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Community events&lt;/td&gt; &#xA;   &lt;td&gt;Including meetups, webinars, conferences, and more events, visit the &lt;a href=&#34;https://cloudberry.apache.org/community/events&#34;&gt;Events page&lt;/a&gt; and subscribe events calendar.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Documentation&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://cloudberry.apache.org/docs/&#34;&gt;Official documentation&lt;/a&gt; for Cloudberry. You can explore it to discover more details about us.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Contributions can be diverse, such as code enhancements, bug fixes, feature proposals, documents, marketing, and so on. No contribution is too small, we encourage all types of contributions. Cloudberry community welcomes contributions from anyone, new and experienced! Our &lt;a href=&#34;https://cloudberry.apache.org/contribute&#34;&gt;contribution guide&lt;/a&gt; will help you get started with the contribution.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Code contribution&lt;/td&gt; &#xA;   &lt;td&gt;Learn how to contribute code to the Cloudberry, including coding preparation, conventions, workflow, review, and checklist following the &lt;a href=&#34;https://cloudberry.apache.org/contribute/code&#34;&gt;code contribution guide&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Submit the proposal&lt;/td&gt; &#xA;   &lt;td&gt;Proposing major changes to Cloudberry through &lt;a href=&#34;https://cloudberry.apache.org/contribute/proposal&#34;&gt;proposal guide&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Doc contribution&lt;/td&gt; &#xA;   &lt;td&gt;We need you to join us to help us improve the documentation, see the &lt;a href=&#34;https://cloudberry.apache.org/contribute/doc&#34;&gt;doc contribution guide&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;You can check our &lt;a href=&#34;https://github.com/orgs/cloudberrydb/discussions/369&#34;&gt;Cloudberry Roadmap 2024&lt;/a&gt; out to see the product plans and goals we want to achieve in 2024. Welcome to share your thoughts and ideas to join us in shaping the future of Apache Cloudberry (Incubating). (We will update the Roadmap after entering the Incubator.)&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgment&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt;, &lt;a href=&#34;https://greenplum.org/&#34;&gt;Greenplum Database&lt;/a&gt; and other great open source projects to make Apache Cloudberry has a sound foundation.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Cloudberry is licensed under the Apache License, Version 2.0. For details, see the &lt;a href=&#34;https://raw.githubusercontent.com/apache/cloudberry/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;ASF Incubator disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;Apache Cloudberry is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required for all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.&lt;/p&gt;</summary>
  </entry>
</feed>