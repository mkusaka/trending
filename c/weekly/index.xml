<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-02-23T01:40:22Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>espressif/esp32-camera</title>
    <updated>2025-02-23T01:40:22Z</updated>
    <id>tag:github.com,2025-02-23:/espressif/esp32-camera</id>
    <link href="https://github.com/espressif/esp32-camera" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ESP32 Camera Driver&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/espressif/esp32-camera/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/espressif/esp32-camera/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build examples&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://components.espressif.com/components/espressif/esp32-camera&#34;&gt;&lt;img src=&#34;https://components.espressif.com/components/espressif/esp32-camera/badge.svg?sanitize=true&#34; alt=&#34;Component Registry&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;General Information&lt;/h2&gt; &#xA;&lt;p&gt;This repository hosts ESP32 series Soc compatible driver for image sensors. Additionally it provides a few tools, which allow converting the captured frame data to the more common BMP and JPEG formats.&lt;/p&gt; &#xA;&lt;h3&gt;Supported Soc&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ESP32&lt;/li&gt; &#xA; &lt;li&gt;ESP32-S2&lt;/li&gt; &#xA; &lt;li&gt;ESP32-S3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Supported Sensor&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;model&lt;/th&gt; &#xA;   &lt;th&gt;max resolution&lt;/th&gt; &#xA;   &lt;th&gt;color type&lt;/th&gt; &#xA;   &lt;th&gt;output format&lt;/th&gt; &#xA;   &lt;th&gt;Len Size&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;1600 x 1200&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV(422/420)/YCbCr422&lt;br&gt;RGB565/555&lt;br&gt;8-bit compressed data&lt;br&gt;8/10-bit Raw RGB data&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV3660&lt;/td&gt; &#xA;   &lt;td&gt;2048 x 1536&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;raw RGB data&lt;br&gt;RGB565/555/444&lt;br&gt;CCIR656&lt;br&gt;YCbCr422&lt;br&gt;compression&lt;/td&gt; &#xA;   &lt;td&gt;1/5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV5640&lt;/td&gt; &#xA;   &lt;td&gt;2592 x 1944&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;RAW RGB&lt;br&gt;RGB565/555/444&lt;br&gt;CCIR656&lt;br&gt;YUV422/420&lt;br&gt;YCbCr422&lt;br&gt;compression&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV7670&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;Raw Bayer RGB&lt;br&gt;Processed Bayer RGB&lt;br&gt;YUV/YCbCr422&lt;br&gt;GRB422&lt;br&gt;RGB565/555&lt;/td&gt; &#xA;   &lt;td&gt;1/6&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV7725&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;Raw RGB&lt;br&gt;GRB 422&lt;br&gt;RGB565/555/444&lt;br&gt;YCbCr 422&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NT99141&lt;/td&gt; &#xA;   &lt;td&gt;1280 x 720&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YCbCr 422&lt;br&gt;RGB565/555/444&lt;br&gt;Raw&lt;br&gt;CCIR656&lt;br&gt;JPEG compression&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GC032A&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;/td&gt; &#xA;   &lt;td&gt;1/10&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GC0308&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;br&gt;Grayscale&lt;/td&gt; &#xA;   &lt;td&gt;1/6.5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GC2145&lt;/td&gt; &#xA;   &lt;td&gt;1600 x 1200&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;/td&gt; &#xA;   &lt;td&gt;1/5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BF3005&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;RGB565&lt;/td&gt; &#xA;   &lt;td&gt;1/4&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BF20A6&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;br&gt;Only Y&lt;/td&gt; &#xA;   &lt;td&gt;1/10&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SC101IOT&lt;/td&gt; &#xA;   &lt;td&gt;1280 x 720&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;Raw RGB&lt;/td&gt; &#xA;   &lt;td&gt;1/4.2&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SC030IOT&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;color&lt;/td&gt; &#xA;   &lt;td&gt;YUV/YCbCr422&lt;br&gt;RAW Bayer&lt;/td&gt; &#xA;   &lt;td&gt;1/6.5&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SC031GS&lt;/td&gt; &#xA;   &lt;td&gt;640 x 480&lt;/td&gt; &#xA;   &lt;td&gt;monochrome&lt;/td&gt; &#xA;   &lt;td&gt;RAW MONO&lt;br&gt;Grayscale&lt;/td&gt; &#xA;   &lt;td&gt;1/6&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Important to Remember&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Except when using CIF or lower resolution with JPEG, the driver requires PSRAM to be installed and activated.&lt;/li&gt; &#xA; &lt;li&gt;Using YUV or RGB puts a lot of strain on the chip because writing to PSRAM is not particularly fast. The result is that image data might be missing. This is particularly true if WiFi is enabled. If you need RGB data, it is recommended that JPEG is captured and then turned into RGB using &lt;code&gt;fmt2rgb888&lt;/code&gt; or &lt;code&gt;fmt2bmp&lt;/code&gt;/&lt;code&gt;frame2bmp&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;When 1 frame buffer is used, the driver will wait for the current frame to finish (VSYNC) and start I2S DMA. After the frame is acquired, I2S will be stopped and the frame buffer returned to the application. This approach gives more control over the system, but results in longer time to get the frame.&lt;/li&gt; &#xA; &lt;li&gt;When 2 or more frame bufers are used, I2S is running in continuous mode and each frame is pushed to a queue that the application can access. This approach puts more strain on the CPU/Memory, but allows for double the frame rate. Please use only with JPEG.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation Instructions&lt;/h2&gt; &#xA;&lt;h3&gt;Using with ESP-IDF&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add a dependency on &lt;code&gt;espressif/esp32-camera&lt;/code&gt; component: &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;idf.py add-dependency &#34;espressif/esp32-camera&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; (or add it manually in idf_component.yml of your project)&lt;/li&gt; &#xA; &lt;li&gt;Enable PSRAM in &lt;code&gt;menuconfig&lt;/code&gt; (also set Flash and PSRAM frequiencies to 80MHz)&lt;/li&gt; &#xA; &lt;li&gt;Include &lt;code&gt;esp_camera.h&lt;/code&gt; in your code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These instructions also work for PlatformIO, if you are using &lt;code&gt;framework=espidf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using with Arduino&lt;/h3&gt; &#xA;&lt;h4&gt;Arduino IDE&lt;/h4&gt; &#xA;&lt;p&gt;If you are using the arduino-esp32 core in Arduino IDE, no installation is needed! You can use esp32-camera right away.&lt;/p&gt; &#xA;&lt;h4&gt;PlatformIO&lt;/h4&gt; &#xA;&lt;p&gt;The easy way -- on the &lt;code&gt;env&lt;/code&gt; section of &lt;code&gt;platformio.ini&lt;/code&gt;, add the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[env]&#xA;lib_deps =&#xA;  esp32-camera&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the &lt;code&gt;esp_camera.h&lt;/code&gt; is available to be included:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable PSRAM on &lt;code&gt;menuconfig&lt;/code&gt; or type it direclty on &lt;code&gt;sdkconfig&lt;/code&gt;. Check the &lt;a href=&#34;https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-esp32-spiram-support&#34;&gt;official doc&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CONFIG_ESP32_SPIRAM_SUPPORT=y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;This component comes with a basic example illustrating how to get frames from the camera. You can try out the example using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;idf.py create-project-from-example &#34;espressif/esp32-camera:camera_example&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command will download the example into &lt;code&gt;camera_example&lt;/code&gt; directory. It comes already pre-configured with the correct settings in menuconfig.&lt;/p&gt; &#xA;&lt;h3&gt;Initialization&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;&#xA;//WROVER-KIT PIN Map&#xA;#define CAM_PIN_PWDN    -1 //power down is not used&#xA;#define CAM_PIN_RESET   -1 //software reset will be performed&#xA;#define CAM_PIN_XCLK    21&#xA;#define CAM_PIN_SIOD    26&#xA;#define CAM_PIN_SIOC    27&#xA;&#xA;#define CAM_PIN_D7      35&#xA;#define CAM_PIN_D6      34&#xA;#define CAM_PIN_D5      39&#xA;#define CAM_PIN_D4      36&#xA;#define CAM_PIN_D3      19&#xA;#define CAM_PIN_D2      18&#xA;#define CAM_PIN_D1       5&#xA;#define CAM_PIN_D0       4&#xA;#define CAM_PIN_VSYNC   25&#xA;#define CAM_PIN_HREF    23&#xA;#define CAM_PIN_PCLK    22&#xA;&#xA;static camera_config_t camera_config = {&#xA;    .pin_pwdn  = CAM_PIN_PWDN,&#xA;    .pin_reset = CAM_PIN_RESET,&#xA;    .pin_xclk = CAM_PIN_XCLK,&#xA;    .pin_sccb_sda = CAM_PIN_SIOD,&#xA;    .pin_sccb_scl = CAM_PIN_SIOC,&#xA;&#xA;    .pin_d7 = CAM_PIN_D7,&#xA;    .pin_d6 = CAM_PIN_D6,&#xA;    .pin_d5 = CAM_PIN_D5,&#xA;    .pin_d4 = CAM_PIN_D4,&#xA;    .pin_d3 = CAM_PIN_D3,&#xA;    .pin_d2 = CAM_PIN_D2,&#xA;    .pin_d1 = CAM_PIN_D1,&#xA;    .pin_d0 = CAM_PIN_D0,&#xA;    .pin_vsync = CAM_PIN_VSYNC,&#xA;    .pin_href = CAM_PIN_HREF,&#xA;    .pin_pclk = CAM_PIN_PCLK,&#xA;&#xA;    .xclk_freq_hz = 20000000,//EXPERIMENTAL: Set to 16MHz on ESP32-S2 or ESP32-S3 to enable EDMA mode&#xA;    .ledc_timer = LEDC_TIMER_0,&#xA;    .ledc_channel = LEDC_CHANNEL_0,&#xA;&#xA;    .pixel_format = PIXFORMAT_JPEG,//YUV422,GRAYSCALE,RGB565,JPEG&#xA;    .frame_size = FRAMESIZE_UXGA,//QQVGA-UXGA, For ESP32, do not use sizes above QVGA when not JPEG. The performance of the ESP32-S series has improved a lot, but JPEG mode always gives better frame rates.&#xA;&#xA;    .jpeg_quality = 12, //0-63, for OV series camera sensors, lower number means higher quality&#xA;    .fb_count = 1, //When jpeg mode is used, if fb_count more than one, the driver will work in continuous mode.&#xA;    .grab_mode = CAMERA_GRAB_WHEN_EMPTY//CAMERA_GRAB_LATEST. Sets when buffers should be filled&#xA;};&#xA;&#xA;esp_err_t camera_init(){&#xA;    //power up the camera if PWDN pin is defined&#xA;    if(CAM_PIN_PWDN != -1){&#xA;        pinMode(CAM_PIN_PWDN, OUTPUT);&#xA;        digitalWrite(CAM_PIN_PWDN, LOW);&#xA;    }&#xA;&#xA;    //initialize the camera&#xA;    esp_err_t err = esp_camera_init(&amp;amp;camera_config);&#xA;    if (err != ESP_OK) {&#xA;        ESP_LOGE(TAG, &#34;Camera Init Failed&#34;);&#xA;        return err;&#xA;    }&#xA;&#xA;    return ESP_OK;&#xA;}&#xA;&#xA;esp_err_t camera_capture(){&#xA;    //acquire a frame&#xA;    camera_fb_t * fb = esp_camera_fb_get();&#xA;    if (!fb) {&#xA;        ESP_LOGE(TAG, &#34;Camera Capture Failed&#34;);&#xA;        return ESP_FAIL;&#xA;    }&#xA;    //replace this with your own function&#xA;    process_image(fb-&amp;gt;width, fb-&amp;gt;height, fb-&amp;gt;format, fb-&amp;gt;buf, fb-&amp;gt;len);&#xA;  &#xA;    //return the frame buffer back to the driver for reuse&#xA;    esp_camera_fb_return(fb);&#xA;    return ESP_OK;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JPEG HTTP Capture&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;#include &#34;esp_http_server.h&#34;&#xA;#include &#34;esp_timer.h&#34;&#xA;&#xA;typedef struct {&#xA;        httpd_req_t *req;&#xA;        size_t len;&#xA;} jpg_chunking_t;&#xA;&#xA;static size_t jpg_encode_stream(void * arg, size_t index, const void* data, size_t len){&#xA;    jpg_chunking_t *j = (jpg_chunking_t *)arg;&#xA;    if(!index){&#xA;        j-&amp;gt;len = 0;&#xA;    }&#xA;    if(httpd_resp_send_chunk(j-&amp;gt;req, (const char *)data, len) != ESP_OK){&#xA;        return 0;&#xA;    }&#xA;    j-&amp;gt;len += len;&#xA;    return len;&#xA;}&#xA;&#xA;esp_err_t jpg_httpd_handler(httpd_req_t *req){&#xA;    camera_fb_t * fb = NULL;&#xA;    esp_err_t res = ESP_OK;&#xA;    size_t fb_len = 0;&#xA;    int64_t fr_start = esp_timer_get_time();&#xA;&#xA;    fb = esp_camera_fb_get();&#xA;    if (!fb) {&#xA;        ESP_LOGE(TAG, &#34;Camera capture failed&#34;);&#xA;        httpd_resp_send_500(req);&#xA;        return ESP_FAIL;&#xA;    }&#xA;    res = httpd_resp_set_type(req, &#34;image/jpeg&#34;);&#xA;    if(res == ESP_OK){&#xA;        res = httpd_resp_set_hdr(req, &#34;Content-Disposition&#34;, &#34;inline; filename=capture.jpg&#34;);&#xA;    }&#xA;&#xA;    if(res == ESP_OK){&#xA;        if(fb-&amp;gt;format == PIXFORMAT_JPEG){&#xA;            fb_len = fb-&amp;gt;len;&#xA;            res = httpd_resp_send(req, (const char *)fb-&amp;gt;buf, fb-&amp;gt;len);&#xA;        } else {&#xA;            jpg_chunking_t jchunk = {req, 0};&#xA;            res = frame2jpg_cb(fb, 80, jpg_encode_stream, &amp;amp;jchunk)?ESP_OK:ESP_FAIL;&#xA;            httpd_resp_send_chunk(req, NULL, 0);&#xA;            fb_len = jchunk.len;&#xA;        }&#xA;    }&#xA;    esp_camera_fb_return(fb);&#xA;    int64_t fr_end = esp_timer_get_time();&#xA;    ESP_LOGI(TAG, &#34;JPG: %uKB %ums&#34;, (uint32_t)(fb_len/1024), (uint32_t)((fr_end - fr_start)/1000));&#xA;    return res;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JPEG HTTP Stream&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;#include &#34;esp_http_server.h&#34;&#xA;#include &#34;esp_timer.h&#34;&#xA;&#xA;#define PART_BOUNDARY &#34;123456789000000000000987654321&#34;&#xA;static const char* _STREAM_CONTENT_TYPE = &#34;multipart/x-mixed-replace;boundary=&#34; PART_BOUNDARY;&#xA;static const char* _STREAM_BOUNDARY = &#34;\r\n--&#34; PART_BOUNDARY &#34;\r\n&#34;;&#xA;static const char* _STREAM_PART = &#34;Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n&#34;;&#xA;&#xA;esp_err_t jpg_stream_httpd_handler(httpd_req_t *req){&#xA;    camera_fb_t * fb = NULL;&#xA;    esp_err_t res = ESP_OK;&#xA;    size_t _jpg_buf_len;&#xA;    uint8_t * _jpg_buf;&#xA;    char * part_buf[64];&#xA;    static int64_t last_frame = 0;&#xA;    if(!last_frame) {&#xA;        last_frame = esp_timer_get_time();&#xA;    }&#xA;&#xA;    res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);&#xA;    if(res != ESP_OK){&#xA;        return res;&#xA;    }&#xA;&#xA;    while(true){&#xA;        fb = esp_camera_fb_get();&#xA;        if (!fb) {&#xA;            ESP_LOGE(TAG, &#34;Camera capture failed&#34;);&#xA;            res = ESP_FAIL;&#xA;            break;&#xA;        }&#xA;        if(fb-&amp;gt;format != PIXFORMAT_JPEG){&#xA;            bool jpeg_converted = frame2jpg(fb, 80, &amp;amp;_jpg_buf, &amp;amp;_jpg_buf_len);&#xA;            if(!jpeg_converted){&#xA;                ESP_LOGE(TAG, &#34;JPEG compression failed&#34;);&#xA;                esp_camera_fb_return(fb);&#xA;                res = ESP_FAIL;&#xA;            }&#xA;        } else {&#xA;            _jpg_buf_len = fb-&amp;gt;len;&#xA;            _jpg_buf = fb-&amp;gt;buf;&#xA;        }&#xA;&#xA;        if(res == ESP_OK){&#xA;            res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));&#xA;        }&#xA;        if(res == ESP_OK){&#xA;            size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);&#xA;&#xA;            res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);&#xA;        }&#xA;        if(res == ESP_OK){&#xA;            res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);&#xA;        }&#xA;        if(fb-&amp;gt;format != PIXFORMAT_JPEG){&#xA;            free(_jpg_buf);&#xA;        }&#xA;        esp_camera_fb_return(fb);&#xA;        if(res != ESP_OK){&#xA;            break;&#xA;        }&#xA;        int64_t fr_end = esp_timer_get_time();&#xA;        int64_t frame_time = fr_end - last_frame;&#xA;        last_frame = fr_end;&#xA;        frame_time /= 1000;&#xA;        ESP_LOGI(TAG, &#34;MJPG: %uKB %ums (%.1ffps)&#34;,&#xA;            (uint32_t)(_jpg_buf_len/1024),&#xA;            (uint32_t)frame_time, 1000.0 / (uint32_t)frame_time);&#xA;    }&#xA;&#xA;    last_frame = 0;&#xA;    return res;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;BMP HTTP Capture&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;esp_camera.h&#34;&#xA;#include &#34;esp_http_server.h&#34;&#xA;#include &#34;esp_timer.h&#34;&#xA;&#xA;esp_err_t bmp_httpd_handler(httpd_req_t *req){&#xA;    camera_fb_t * fb = NULL;&#xA;    esp_err_t res = ESP_OK;&#xA;    int64_t fr_start = esp_timer_get_time();&#xA;&#xA;    fb = esp_camera_fb_get();&#xA;    if (!fb) {&#xA;        ESP_LOGE(TAG, &#34;Camera capture failed&#34;);&#xA;        httpd_resp_send_500(req);&#xA;        return ESP_FAIL;&#xA;    }&#xA;&#xA;    uint8_t * buf = NULL;&#xA;    size_t buf_len = 0;&#xA;    bool converted = frame2bmp(fb, &amp;amp;buf, &amp;amp;buf_len);&#xA;    esp_camera_fb_return(fb);&#xA;    if(!converted){&#xA;        ESP_LOGE(TAG, &#34;BMP conversion failed&#34;);&#xA;        httpd_resp_send_500(req);&#xA;        return ESP_FAIL;&#xA;    }&#xA;&#xA;    res = httpd_resp_set_type(req, &#34;image/x-windows-bmp&#34;)&#xA;       || httpd_resp_set_hdr(req, &#34;Content-Disposition&#34;, &#34;inline; filename=capture.bmp&#34;)&#xA;       || httpd_resp_send(req, (const char *)buf, buf_len);&#xA;    free(buf);&#xA;    int64_t fr_end = esp_timer_get_time();&#xA;    ESP_LOGI(TAG, &#34;BMP: %uKB %ums&#34;, (uint32_t)(buf_len/1024), (uint32_t)((fr_end - fr_start)/1000));&#xA;    return res;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>xiph/flac</title>
    <updated>2025-02-23T01:40:22Z</updated>
    <id>tag:github.com,2025-02-23:/xiph/flac</id>
    <link href="https://github.com/xiph/flac" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Free Lossless Audio Codec&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Free Lossless Audio Codec (FLAC)&lt;/h1&gt; &#xA;&lt;p&gt;FLAC is open source software that can reduce the amount of storage space needed to store digital audio signals without needing to remove information in doing so.&lt;/p&gt; &#xA;&lt;p&gt;The files read and produced by this software are called FLAC files. As these files (which follow the &lt;a href=&#34;https://xiph.org/flac/format.html&#34;&gt;FLAC format&lt;/a&gt;) can be read from and written to by other software as well, this software is often referred to as the FLAC reference implementation.&lt;/p&gt; &#xA;&lt;p&gt;FLAC has been developed by volunteers. If you want to help out, see CONTRIBUTING.md for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Components&lt;/h2&gt; &#xA;&lt;p&gt;FLAC is comprised of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;libFLAC, a library which implements reference encoders and decoders for native FLAC and Ogg FLAC, and a metadata interface&lt;/li&gt; &#xA; &lt;li&gt;libFLAC++, a C++ object wrapper library around libFLAC&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;flac&lt;/code&gt;, a command-line program for encoding and decoding files&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metaflac&lt;/code&gt;, a command-line program for viewing and editing FLAC metadata&lt;/li&gt; &#xA; &lt;li&gt;user and API documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The libraries (libFLAC, libFLAC++) are licensed under Xiph.org&#39;s BSD-like license (see COPYING.Xiph). All other programs and plugins are licensed under the GNU General Public License (see COPYING.GPL). The documentation is licensed under the GNU Free Documentation License (see COPYING.FDL).&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;For documentation of the &lt;code&gt;flac&lt;/code&gt; and &lt;code&gt;metaflac&lt;/code&gt; command line tools, see the directory man, which contains the files flac.md and metaflac.md&lt;/p&gt; &#xA;&lt;p&gt;The API documentation is in html and is generated by Doxygen. It can be found in the directory doc/html/api. It is included in a release tarball and must be build with Doxygen when the source is taken directly from git.&lt;/p&gt; &#xA;&lt;p&gt;The directory examples contains example source code on using libFLAC and libFLAC++.&lt;/p&gt; &#xA;&lt;p&gt;Documentation concerning the FLAC format itself (which can be used to create software reading and writing FLAC software independent from libFLAC) was included in previous releases, but can now be found on &lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-cellar-flac/&#34;&gt;https://datatracker.ietf.org/doc/draft-ietf-cellar-flac/&lt;/a&gt; Additionally a set of files for conformance testing called the FLAC decoder testbench can be found at &lt;a href=&#34;https://github.com/ietf-wg-cellar/flac-test-files&#34;&gt;https://github.com/ietf-wg-cellar/flac-test-files&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have questions about FLAC that this document does not answer, please submit them at the following tracker so this document can be improved:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/xiph/flac/issues&#34;&gt;https://github.com/xiph/flac/issues&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building FLAC&lt;/h2&gt; &#xA;&lt;p&gt;All components of the FLAC project can be build with a variety of compilers (including GCC, Clang, Visual Studio, Intel C++ Compiler) on many architectures (inluding x86, x86_64, ARMv7, ARMv8 and PowerPC) for many different operating systems.&lt;/p&gt; &#xA;&lt;p&gt;To do this, FLAC provides two build systems: one using GNU&#39;s autotools and one with CMake. Both differ slighly in configuration options, but should be considered equivalent for most use cases.&lt;/p&gt; &#xA;&lt;p&gt;FLAC used to provide files specifically for building with Visual Studio, but these have been removed in favor of using CMake.&lt;/p&gt; &#xA;&lt;h2&gt;Building with CMake&lt;/h2&gt; &#xA;&lt;p&gt;CMake is a cross-platform build system. FLAC can be built on Windows, Linux, Mac OS X using CMake.&lt;/p&gt; &#xA;&lt;p&gt;You can use either CMake&#39;s CLI or GUI. We recommend you to have a separate build folder outside the repository in order to not spoil it with generated files. It is possible however to do a so-called in-tree build, in that case /path/to/flac-build in the following examples is equal to /path/to/flac-source.&lt;/p&gt; &#xA;&lt;h3&gt;CMake CLI&lt;/h3&gt; &#xA;&lt;p&gt;Go to your build folder and run something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or e.g. in Windows shell&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\path\to\flac-build&amp;gt; cmake \path\to\flac-source&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(provided that cmake is in your %PATH% variable)&lt;/p&gt; &#xA;&lt;p&gt;That will generate build scripts for the default build system (e.g. Makefiles for UNIX). After that you start build with a command like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And afterwards you can run tests or install the built libraries and headers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ make test&#xA;/path/to/flac-build$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want use a build system other than default add -G flag to cmake, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -GNinja&#xA;/path/to/flac-build$ ninja&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -GXcode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use cmake --help to see the list of available generators.&lt;/p&gt; &#xA;&lt;p&gt;By default CMake will search for OGG. If CMake fails to find it you can help CMake by specifying the exact path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -DOGG_ROOT=/path/to/ogg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you would like CMake to build OGG alongside FLAC, you can place the ogg sources directly in the flac source directory as a subdirectory with the name ogg, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-source/ogg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to build flac with OGG support you can tell CMake not to look for OGG:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -DWITH_OGG=OFF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other FLAC&#39;s options (e.g. building C++ lib or docs) can also be put to cmake through -D flag. If you want to know what options are available, use -LH:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -LH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CMake GUI (for Visual Studio)&lt;/h3&gt; &#xA;&lt;p&gt;It is likely that you would prefer to use the CMake GUI if you use Visual Studio to build FLAC. It&#39;s in essence the same process as building using CLI.&lt;/p&gt; &#xA;&lt;p&gt;Open cmake-gui. In the window select a source directory (the repository&#39;s root), a build directory (some other directory outside the repository). Then press button &#34;Configure&#34;. CMake will ask you which build system you prefer. Choose that version of Visual Studio which you have on your system, choose whether you want to build for Win32 or x64. Press OK.&lt;/p&gt; &#xA;&lt;p&gt;After CMake finishes you can change the configuration to your liking and if you change anything, run Configure again. With the &#34;Generate&#34; button, CMake creates Visual Studio files, which can be opened from Visual Studio. With the button &#34;Open Project&#34; CMake will launch Visual Studio and open the generated solution. You can use the project files as usual but remember that they were generated by CMake. That means that your changes (e.g. some additional compile flags) will be lost when you run CMake next time.&lt;/p&gt; &#xA;&lt;p&gt;CMake searches by default for OGG on your system and returns an error if it cannot find it. If you want to build OGG alongside FLAC, you can download the OGG sources and extract them in a subdirectory of the FLAC source directory with the name ogg (i.e. /path/to/flac-source/ogg) before running CMake. If you don&#39;t want to build FLAC with OGG support, untick the box following WITH_OGG flag in the list of variables in cmake-gui window and run &#34;Configure&#34; again.&lt;/p&gt; &#xA;&lt;p&gt;If CMake fails to find MSVC compiler then running cmake-gui from MS Developer comand prompt should help.&lt;/p&gt; &#xA;&lt;h2&gt;Building with GNU autotools&lt;/h2&gt; &#xA;&lt;p&gt;FLAC uses autoconf and libtool for configuring and building. To configure a build, open a commmand line/terminal and run &lt;code&gt;./configure&lt;/code&gt; You can provide options to this command, which are listed by running &lt;code&gt;./configure --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In case the configure script is not present (for example when building from git and not from a release tarball), it can be generated by running &lt;code&gt;./autogen.sh&lt;/code&gt;. This may require a libtool development package though.&lt;/p&gt; &#xA;&lt;p&gt;After configuration, build with &lt;code&gt;make&lt;/code&gt;, verify the build with &lt;code&gt;make check&lt;/code&gt; and install with &lt;code&gt;make install&lt;/code&gt;. Installation might require administrator priviledged, i.e. &lt;code&gt;sudo make install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &#39;make check&#39; step is optional; omit it to skip all the tests, which can take about an hour to complete. Even though it will stop with an explicit message on any failure, it does print out a lot of stuff so you might want to capture the output to a file if you&#39;re having a problem. Also, don&#39;t run &#39;make check&#39; as root because it confuses some of the tests.&lt;/p&gt; &#xA;&lt;p&gt;Summarizing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./configure&#xA;make &amp;amp;&amp;amp; make check&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Note to embedded developers&lt;/h2&gt; &#xA;&lt;p&gt;libFLAC has grown larger over time as more functionality has been included, but much of it may be unnecessary for a particular embedded implementation. Unused parts may be pruned by some simple editing of configure.ac and src/libFLAC/Makefile.am; the following dependency graph shows which modules may be pruned without breaking things further down:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;metadata.h&#xA;    stream_decoder.h&#xA;    format.h&#xA;&#xA;stream_encoder.h&#xA;    stream_decoder.h&#xA;    format.h&#xA;&#xA;stream_decoder.h&#xA;    format.h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, for pure decoding applications, both the stream encoder and metadata editing interfaces can be safely removed. Note that this is specific to building the libraries for embedded use. The command line tools do not provide such compartmentalization, and require a complete libFLAC build to function.&lt;/p&gt; &#xA;&lt;p&gt;There is a section dedicated to embedded use in the libFLAC API HTML documentation (see doc/html/api/index.html).&lt;/p&gt; &#xA;&lt;p&gt;Also, there are several places in the libFLAC code with comments marked with &#34;OPT:&#34; where a #define can be changed to enable code that might be faster on a specific platform. Experimenting with these can yield faster binaries.&lt;/p&gt;</summary>
  </entry>
</feed>