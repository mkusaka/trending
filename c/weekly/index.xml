<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-30T01:43:52Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>robertdavidgraham/masscan</title>
    <updated>2022-10-30T01:43:52Z</updated>
    <id>tag:github.com,2022-10-30:/robertdavidgraham/masscan</id>
    <link href="https://github.com/robertdavidgraham/masscan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;TCP port scanner, spews SYN packets asynchronously, scanning entire Internet in under 5 minutes.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/robertdavidgraham/masscan.svg&#34;&gt;&lt;img src=&#34;https://travis-ci.org/robertdavidgraham/masscan.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;MASSCAN: Mass IP port scanner&lt;/h1&gt; &#xA;&lt;p&gt;This is an Internet-scale port scanner. It can scan the entire Internet in under 5 minutes, transmitting 10 million packets per second, from a single machine.&lt;/p&gt; &#xA;&lt;p&gt;Its usage (parameters, output) is similar to &lt;code&gt;nmap&lt;/code&gt;, the most famous port scanner. When in doubt, try one of those features -- features that support widespread scanning of many machines are supported, while in-depth scanning of single machines aren&#39;t.&lt;/p&gt; &#xA;&lt;p&gt;Internally, it uses asynchronous transmission, similar to port scanners like &lt;code&gt;scanrand&lt;/code&gt;, &lt;code&gt;unicornscan&lt;/code&gt;, and &lt;code&gt;ZMap&lt;/code&gt;. It&#39;s more flexible, allowing arbitrary port and address ranges.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: masscan uses its own &lt;strong&gt;ad hoc TCP/IP stack&lt;/strong&gt;. Anything other than simple port scans may cause conflict with the local TCP/IP stack. This means you need to use either the &lt;code&gt;--src-ip&lt;/code&gt; option to run from a different IP address, or use &lt;code&gt;--src-port&lt;/code&gt; to configure which source ports masscan uses, then also configure the internal firewall (like &lt;code&gt;pf&lt;/code&gt; or &lt;code&gt;iptables&lt;/code&gt;) to firewall those ports from the rest of the operating system.&lt;/p&gt; &#xA;&lt;p&gt;This tool is free, but consider contributing money to its development: Bitcoin wallet address: 1MASSCANaHUiyTtR3bJ2sLGuMw5kDBaj4T&lt;/p&gt; &#xA;&lt;h1&gt;Building&lt;/h1&gt; &#xA;&lt;p&gt;On Debian/Ubuntu, it goes something like the following. It doesn&#39;t really have any dependencies other than a C compiler (such as &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get --assume-yes install git make gcc&#xA;git clone https://github.com/robertdavidgraham/masscan&#xA;cd masscan&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This puts the program in the &lt;code&gt;masscan/bin&lt;/code&gt; subdirectory. To install it (on Linux) run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The source consists of a lot of small files, so building goes a lot faster by using the multi-threaded build. This requires more than 2gigs on a Raspberry Pi (and breaks), so you might use a smaller number, like &lt;code&gt;-j4&lt;/code&gt; rather than all possible threads.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make -j&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While Linux is the primary target platform, the code runs well on many other systems (Windows, macOS, etc.). Here&#39;s some additional build info:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows w/ Visual Studio: use the VS10 project&lt;/li&gt; &#xA; &lt;li&gt;Windows w/ MinGW: just type &lt;code&gt;make&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Windows w/ cygwin: won&#39;t work&lt;/li&gt; &#xA; &lt;li&gt;Mac OS X /w XCode: use the XCode4 project&lt;/li&gt; &#xA; &lt;li&gt;Mac OS X /w cmdline: just type &lt;code&gt;make&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;FreeBSD: type &lt;code&gt;gmake&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;other: try just compiling all the files together, &lt;code&gt;cc src/*.c -o bin/masscan&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;On macOS, the x86 binaries seem to work just as fast under ARM emulation.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Usage is similar to &lt;code&gt;nmap&lt;/code&gt;. To scan a network segment for some ports:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan -p80,8000-8100 10.0.0.0/8 2603:3001:2d00:da00::/112&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;scan the &lt;code&gt;10.x.x.x&lt;/code&gt; subnet, and &lt;code&gt;2603:3001:2d00:da00::x&lt;/code&gt; subnets&lt;/li&gt; &#xA; &lt;li&gt;scans port 80 and the range 8000 to 8100, or 102 ports total, on both subnets&lt;/li&gt; &#xA; &lt;li&gt;print output to &lt;code&gt;&amp;lt;stdout&amp;gt;&lt;/code&gt; that can be redirected to a file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To see the complete list of options, use the &lt;code&gt;--echo&lt;/code&gt; feature. This dumps the current configuration and exits. This output can be used as input back into the program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan -p80,8000-8100 10.0.0.0/8 2603:3001:2d00:da00::/112 --echo &amp;gt; xxx.conf&#xA;# masscan -c xxx.conf --rate 1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Banner checking&lt;/h2&gt; &#xA;&lt;p&gt;Masscan can do more than just detect whether ports are open. It can also complete the TCP connection and interaction with the application at that port in order to grab simple &#34;banner&#34; information.&lt;/p&gt; &#xA;&lt;p&gt;Masscan supports banner checking on the following protocols:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FTP&lt;/li&gt; &#xA; &lt;li&gt;HTTP&lt;/li&gt; &#xA; &lt;li&gt;IMAP4&lt;/li&gt; &#xA; &lt;li&gt;memcached&lt;/li&gt; &#xA; &lt;li&gt;POP3&lt;/li&gt; &#xA; &lt;li&gt;SMTP&lt;/li&gt; &#xA; &lt;li&gt;SSH&lt;/li&gt; &#xA; &lt;li&gt;SSL&lt;/li&gt; &#xA; &lt;li&gt;SMBv1&lt;/li&gt; &#xA; &lt;li&gt;SMBv2&lt;/li&gt; &#xA; &lt;li&gt;Telnet&lt;/li&gt; &#xA; &lt;li&gt;RDP&lt;/li&gt; &#xA; &lt;li&gt;VNC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The problem with this is that masscan contains its own TCP/IP stack separate from the system you run it on. When the local system receives a SYN-ACK from the probed target, it responds with a RST packet that kills the connection before masscan can grab the banner.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to prevent this is to assign masscan a separate IP address. This would look like one of the following examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan 10.0.0.0/8 -p80 --banners --source-ip 192.168.1.200&#xA;  # masscan 2a00:1450:4007:810::/112 -p80 --banners --source-ip 2603:3001:2d00:da00:91d7:b54:b498:859d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The address you choose has to be on the local subnet and not otherwise be used by another system. Masscan will warn you that you&#39;ve made a mistake, but you might&#39;ve messed up the other machine&#39;s communications for several minutes, so be careful.&lt;/p&gt; &#xA;&lt;p&gt;In some cases, such as WiFi, this isn&#39;t possible. In those cases, you can firewall the port that masscan uses. This prevents the local TCP/IP stack from seeing the packet, but masscan still sees it since it bypasses the local stack. For Linux, this would look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# iptables -A INPUT -p tcp --dport 61000 -j DROP&#xA;# masscan 10.0.0.0/8 -p80 --banners --source-port 61000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You probably want to pick ports that don&#39;t conflict with ports Linux might otherwise choose for source-ports. You can see the range Linux uses, and reconfigure that range, by looking in the file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/proc/sys/net/ipv4/ip_local_port_range&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On the latest version of Kali Linux (2018-August), that range is 32768 to 60999, so you should choose ports either below 32768 or 61000 and above.&lt;/p&gt; &#xA;&lt;p&gt;Setting an &lt;code&gt;iptables&lt;/code&gt; rule only lasts until the next reboot. You need to lookup how to save the configuration depending upon your distro, such as using &lt;code&gt;iptables-save&lt;/code&gt; and/or &lt;code&gt;iptables-persistent&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On Mac OS X and BSD, there are similar steps. To find out the ranges to avoid, use a command like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# sysctl net.inet.ip.portrange.first net.inet.ip.portrange.last&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On FreeBSD and older MacOS, use an &lt;code&gt;ipfw&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# sudo ipfw add 1 deny tcp from any to any 40000 in&#xA;# masscan 10.0.0.0/8 -p80 --banners --source-port 40000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On newer MacOS and OpenBSD, use the &lt;code&gt;pf&lt;/code&gt; packet-filter utility. Edit the file &lt;code&gt;/etc/pf.conf&lt;/code&gt; to add a line like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;block in proto tcp from any to any port 40000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then to enable the firewall, run the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# pfctrl -E    &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the firewall is already running, then either reboot or reload the rules with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# pfctl -f /etc/pf.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Windows doesn&#39;t respond with RST packets, so neither of these techniques are necessary. However, masscan is still designed to work best using its own IP address, so you should run that way when possible, even when it is not strictly necessary.&lt;/p&gt; &#xA;&lt;p&gt;The same thing is needed for other checks, such as the &lt;code&gt;--heartbleed&lt;/code&gt; check, which is just a form of banner checking.&lt;/p&gt; &#xA;&lt;h2&gt;How to scan the entire Internet&lt;/h2&gt; &#xA;&lt;p&gt;While useful for smaller, internal networks, the program is really designed with the entire Internet in mind. It might look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan 0.0.0.0/0 -p0-65535&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scanning the entire Internet is bad. For one thing, parts of the Internet react badly to being scanned. For another thing, some sites track scans and add you to a ban list, which will get you firewalled from useful parts of the Internet. Therefore, you want to exclude a lot of ranges. To blacklist or exclude ranges, you want to use the following syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan 0.0.0.0/0 -p0-65535 --excludefile exclude.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This just prints the results to the command-line. You probably want them saved to a file instead. Therefore, you want something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan 0.0.0.0/0 -p0-65535 -oX scan.xml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This saves the results in an XML file, allowing you to easily dump the results in a database or something.&lt;/p&gt; &#xA;&lt;p&gt;But, this only goes at the default rate of 100 packets/second, which will take forever to scan the Internet. You need to speed it up as so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan 0.0.0.0/0 -p0-65535 --max-rate 100000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This increases the rate to 100,000 packets/second, which will scan the entire Internet (minus excludes) in about 10 hours per port (or 655,360 hours if scanning all ports).&lt;/p&gt; &#xA;&lt;p&gt;The thing to notice about this command-line is that these are all &lt;code&gt;nmap&lt;/code&gt; compatible options. In addition, &#34;invisible&#34; options compatible with &lt;code&gt;nmap&lt;/code&gt; are also set for you: &lt;code&gt;-sS -Pn -n --randomize-hosts --send-eth&lt;/code&gt;. Likewise, the format of the XML file is inspired by &lt;code&gt;nmap&lt;/code&gt;. There are, of course, a lot of differences, because the &lt;em&gt;asynchronous&lt;/em&gt; nature of the program leads to a fundamentally different approach to the problem.&lt;/p&gt; &#xA;&lt;p&gt;The above command-line is a bit cumbersome. Instead of putting everything on the command-line, it can be stored in a file instead. The above settings would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# My Scan&#xA;rate =  100000.00&#xA;output-format = xml&#xA;output-status = all&#xA;output-filename = scan.xml&#xA;ports = 0-65535&#xA;range = 0.0.0.0-255.255.255.255&#xA;excludefile = exclude.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use this configuration file, use the &lt;code&gt;-c&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan -c myscan.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This also makes things easier when you repeat a scan.&lt;/p&gt; &#xA;&lt;p&gt;By default, masscan first loads the configuration file &lt;code&gt;/etc/masscan/masscan.conf&lt;/code&gt;. Any later configuration parameters override what&#39;s in this default configuration file. That&#39;s where I put my &#34;excludefile&#34; parameter so that I don&#39;t ever forget it. It just works automatically.&lt;/p&gt; &#xA;&lt;h2&gt;Getting output&lt;/h2&gt; &#xA;&lt;p&gt;By default, masscan produces fairly large text files, but it&#39;s easy to convert them into any other format. There are five supported output formats:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;xml: Just use the parameter &lt;code&gt;-oX &amp;lt;filename&amp;gt;&lt;/code&gt;. Or, use the parameters &lt;code&gt;--output-format xml&lt;/code&gt; and &lt;code&gt;--output-filename &amp;lt;filename&amp;gt;&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;binary: This is the masscan builtin format. It produces much smaller files so that when I scan the Internet my disk doesn&#39;t fill up. They need to be parsed, though. The command-line option &lt;code&gt;--readscan&lt;/code&gt; will read binary scan files. Using &lt;code&gt;--readscan&lt;/code&gt; with the &lt;code&gt;-oX&lt;/code&gt; option will produce an XML version of the results file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;grepable: This is an implementation of the Nmap -oG output that can be easily parsed by command-line tools. Just use the parameter &lt;code&gt;-oG &amp;lt;filename&amp;gt;&lt;/code&gt;. Or, use the parameters &lt;code&gt;--output-format grepable&lt;/code&gt; and &lt;code&gt;--output-filename &amp;lt;filename&amp;gt;&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;json: This saves the results in JSON format. Just use the parameter &lt;code&gt;-oJ &amp;lt;filename&amp;gt;&lt;/code&gt;. Or, use the parameters &lt;code&gt;--output-format json&lt;/code&gt; and &lt;code&gt;--output-filename &amp;lt;filename&amp;gt;&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;list: This is a simple list with one host and port pair per line. Just use the parameter &lt;code&gt;-oL &amp;lt;filename&amp;gt;&lt;/code&gt;. Or, use the parameters &lt;code&gt;--output-format list&lt;/code&gt; and &lt;code&gt;--output-filename &amp;lt;filename&amp;gt;&lt;/code&gt;. The format is:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;port state&amp;gt; &amp;lt;protocol&amp;gt; &amp;lt;port number&amp;gt; &amp;lt;IP address&amp;gt; &amp;lt;POSIX timestamp&amp;gt;  &#xA;open tcp 80 XXX.XXX.XXX.XXX 1390380064&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Comparison with Nmap&lt;/h2&gt; &#xA;&lt;p&gt;Where reasonable, every effort has been taken to make the program familiar to &lt;code&gt;nmap&lt;/code&gt; users, even though it&#39;s fundamentally different. Masscan is tuned for wide range scanning of a lot of machines, whereas nmap is designed for intensive scanning of a single machine or a small range.&lt;/p&gt; &#xA;&lt;p&gt;Two important differences are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;no default ports to scan, you must specify &lt;code&gt;-p &amp;lt;ports&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;target hosts are IP addresses or simple ranges, not DNS names, nor the funky subnet ranges &lt;code&gt;nmap&lt;/code&gt; can use (like &lt;code&gt;10.0.0-255.0-255&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can think of &lt;code&gt;masscan&lt;/code&gt; as having the following settings permanently enabled:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-sS&lt;/code&gt;: this does SYN scan only (currently, will change in the future)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Pn&lt;/code&gt;: doesn&#39;t ping hosts first, which is fundamental to the async operation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-n&lt;/code&gt;: no DNS resolution happens&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--randomize-hosts&lt;/code&gt;: scan completely randomized, always, you can&#39;t change this&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--send-eth&lt;/code&gt;: sends using raw &lt;code&gt;libpcap&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want a list of additional &lt;code&gt;nmap&lt;/code&gt; compatible settings, use the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# masscan --nmap&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transmit rate (IMPORTANT!!)&lt;/h2&gt; &#xA;&lt;p&gt;This program spews out packets very fast. On Windows, or from VMs, it can do 300,000 packets/second. On Linux (no virtualization) it&#39;ll do 1.6 million packets-per-second. That&#39;s fast enough to melt most networks.&lt;/p&gt; &#xA;&lt;p&gt;Note that it&#39;ll only melt your own network. It randomizes the target IP addresses so that it shouldn&#39;t overwhelm any distant network.&lt;/p&gt; &#xA;&lt;p&gt;By default, the rate is set to 100 packets/second. To increase the rate to a million use something like &lt;code&gt;--rate 1000000&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When scanning the IPv4 Internet, you&#39;ll be scanning lots of subnets, so even though there&#39;s a high rate of packets going out, each target subnet will receive a small rate of incoming packets.&lt;/p&gt; &#xA;&lt;p&gt;However, with IPv6 scanning, you&#39;ll tend to focus on a single target subnet with billions of addresses. Thus, your default behavior will overwhelm the target network. Networks often crash under the load that masscan can generate.&lt;/p&gt; &#xA;&lt;h1&gt;Design&lt;/h1&gt; &#xA;&lt;p&gt;This section describes the major design issues of the program.&lt;/p&gt; &#xA;&lt;h2&gt;Code Layout&lt;/h2&gt; &#xA;&lt;p&gt;The file &lt;code&gt;main.c&lt;/code&gt; contains the &lt;code&gt;main()&lt;/code&gt; function, as you&#39;d expect. It also contains the &lt;code&gt;transmit_thread()&lt;/code&gt; and &lt;code&gt;receive_thread()&lt;/code&gt; functions. These functions have been deliberately flattened and heavily commented so that you can read the design of the program simply by stepping line-by-line through each of these.&lt;/p&gt; &#xA;&lt;h2&gt;Asynchronous&lt;/h2&gt; &#xA;&lt;p&gt;This is an &lt;em&gt;asynchronous&lt;/em&gt; design. In other words, it is to &lt;code&gt;nmap&lt;/code&gt; what the &lt;code&gt;nginx&lt;/code&gt; web-server is to &lt;code&gt;Apache&lt;/code&gt;. It has separate transmit and receive threads that are largely independent from each other. It&#39;s the same sort of design found in &lt;code&gt;scanrand&lt;/code&gt;, &lt;code&gt;unicornscan&lt;/code&gt;, and &lt;code&gt;ZMap&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Because it&#39;s asynchronous, it runs as fast as the underlying packet transmit allows.&lt;/p&gt; &#xA;&lt;h2&gt;Randomization&lt;/h2&gt; &#xA;&lt;p&gt;A key difference between Masscan and other scanners is the way it randomizes targets.&lt;/p&gt; &#xA;&lt;p&gt;The fundamental principle is to have a single index variable that starts at zero and is incremented by one for every probe. In C code, this is expressed as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;for (i = 0; i &amp;lt; range; i++) {&#xA;    scan(i);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have to translate the index into an IP address. Let&#39;s say that you want to scan all &#34;private&#34; IP addresses. That would be the table of ranges like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;192.168.0.0/16&#xA;10.0.0.0/8&#xA;172.16.0.0/12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, the first 64k indexes are appended to 192.168.x.x to form the target address. Then, the next 16-million are appended to 10.x.x.x. The remaining indexes in the range are applied to 172.16.x.x.&lt;/p&gt; &#xA;&lt;p&gt;In this example, we only have three ranges. When scanning the entire Internet, we have in practice more than 100 ranges. That&#39;s because you have to blacklist or exclude a lot of sub-ranges. This chops up the desired range into hundreds of smaller ranges.&lt;/p&gt; &#xA;&lt;p&gt;This leads to one of the slowest parts of the code. We transmit 10 million packets per second and have to convert an index variable to an IP address for each and every probe. We solve this by doing a &#34;binary search&#34; in a small amount of memory. At this packet rate, cache efficiencies start to dominate over algorithm efficiencies. There are a lot of more efficient techniques in theory, but they all require so much memory as to be slower in practice.&lt;/p&gt; &#xA;&lt;p&gt;We call the function that translates from an index into an IP address the &lt;code&gt;pick()&lt;/code&gt; function. In use, it looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;for (i = 0; i &amp;lt; range; i++) {&#xA;    ip = pick(addresses, i);&#xA;    scan(ip);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Masscan supports not only IP address ranges, but also port ranges. This means we need to pick from the index variable both an IP address and a port. This is fairly straightforward:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;range = ip_count * port_count;&#xA;for (i = 0; i &amp;lt; range; i++) {&#xA;    ip   = pick(addresses, i / port_count);&#xA;    port = pick(ports,     i % port_count);&#xA;    scan(ip, port);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This leads to another expensive part of the code. The division/modulus instructions are around 90 clock cycles, or 30 nanoseconds, on x86 CPUs. When transmitting at a rate of 10 million packets/second, we have only 100 nanoseconds per packet. I see no way to optimize this any better. Luckily, though, two such operations can be executed simultaneously, so doing two of these, as shown above, is no more expensive than doing one.&lt;/p&gt; &#xA;&lt;p&gt;There are actually some easy optimizations for the above performance problems, but they all rely upon &lt;code&gt;i++&lt;/code&gt;, the fact that the index variable increases one by one through the scan. Actually, we need to randomize this variable. We need to randomize the order of IP addresses that we scan or we&#39;ll blast the heck out of target networks that aren&#39;t built for this level of speed. We need to spread our traffic evenly over the target.&lt;/p&gt; &#xA;&lt;p&gt;The way we randomize is simply by encrypting the index variable. By definition, encryption is random and creates a 1-to-1 mapping between the original index variable and the output. This means that while we linearly go through the range, the output IP addresses are completely random. In code, this looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;range = ip_count * port_count;&#xA;for (i = 0; i &amp;lt; range; i++) {&#xA;    x = encrypt(i);&#xA;    ip   = pick(addresses, x / port_count);&#xA;    port = pick(ports,     x % port_count);&#xA;    scan(ip, port);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This also has a major cost. Since the range is an unpredictable size instead of a nice even power of 2, we can&#39;t use cheap binary techniques like AND (&amp;amp;) and XOR (^). Instead, we have to use expensive operations like MODULUS (%). In my current benchmarks, it&#39;s taking 40 nanoseconds to encrypt the variable.&lt;/p&gt; &#xA;&lt;p&gt;This architecture allows for lots of cool features. For example, it supports &#34;shards&#34;. You can set up 5 machines each doing a fifth of the scan or &lt;code&gt;range / shard_count&lt;/code&gt;. Shards can be multiple machines, or simply multiple network adapters on the same machine, or even (if you want) multiple IP source addresses on the same network adapter.&lt;/p&gt; &#xA;&lt;p&gt;Or, you can use a &#39;seed&#39; or &#39;key&#39; to the encryption function, so that you get a different order each time you scan, like &lt;code&gt;x = encrypt(seed, i)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We can also pause the scan by exiting out of the program, and simply remembering the current value of &lt;code&gt;i&lt;/code&gt;, and restart it later. I do that a lot during development. I see something going wrong with my Internet scan, so I hit &#xA; &lt;ctrl-c&gt;&#xA;   to stop the scan, then restart it after I&#39;ve fixed the bug.&#xA; &lt;/ctrl-c&gt;&lt;/p&gt; &#xA;&lt;p&gt;Another feature is retransmits/retries. Packets sometimes get dropped on the Internet, so you can send two packets back-to-back. However, something that drops one packet may drop the immediately following packet. Therefore, you want to send the copy about 1 second apart. This is simple. We already have a &#39;rate&#39; variable, which is the number of packets-per-second rate we are transmitting at, so the retransmit function is simply to use &lt;code&gt;i + rate&lt;/code&gt; as the index. One of these days I&#39;m going to do a study of the Internet, and differentiate &#34;back-to-back&#34;, &#34;1 second&#34;, &#34;10 second&#34;, and &#34;1 minute&#34; retransmits this way in order to see if there is any difference in what gets dropped.&lt;/p&gt; &#xA;&lt;h2&gt;C10 Scalability&lt;/h2&gt; &#xA;&lt;p&gt;The asynchronous technique is known as a solution to the &#34;c10k problem&#34;. Masscan is designed for the next level of scalability, the &#34;C10M problem&#34;.&lt;/p&gt; &#xA;&lt;p&gt;The C10M solution is to bypass the kernel. There are three primary kernel bypasses in Masscan:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;custom network driver&lt;/li&gt; &#xA; &lt;li&gt;user-mode TCP stack&lt;/li&gt; &#xA; &lt;li&gt;user-mode synchronization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Masscan can use the PF_RING DNA driver. This driver DMAs packets directly from user-mode memory to the network driver with zero kernel involvement. That allows software, even with a slow CPU, to transmit packets at the maximum rate the hardware allows. If you put 8 10-gbps network cards in a computer, this means it could transmit at 100-million packets/second.&lt;/p&gt; &#xA;&lt;p&gt;Masscan has its own built-in TCP stack for grabbing banners from TCP connections. This means it can easily support 10 million concurrent TCP connections, assuming of course that the computer has enough memory.&lt;/p&gt; &#xA;&lt;p&gt;Masscan has no &#34;mutex&#34;. Modern mutexes (aka. futexes) are mostly user-mode, but they have two problems. The first problem is that they cause cache-lines to bounce quickly back-and-forth between CPUs. The second is that when there is contention, they&#39;ll do a system call into the kernel, which kills performance. A mutex on the fast path of a program severely limits scalability. Instead, Masscan uses &#34;rings&#34; to synchronize things, such as when the user-mode TCP stack in the receive thread needs to transmit a packet without interfering with the transmit thread.&lt;/p&gt; &#xA;&lt;h2&gt;Portability&lt;/h2&gt; &#xA;&lt;p&gt;The code runs well on Linux, Windows, and Mac OS X. All the important bits are in standard C (C90). Therefore, it compiles on Visual Studio with Microsoft&#39;s compiler, the Clang/LLVM compiler on Mac OS X, and GCC on Linux.&lt;/p&gt; &#xA;&lt;p&gt;Windows and Macs aren&#39;t tuned for packet transmit, and get only about 300,000 packets-per-second, whereas Linux can do 1,500,000 packets/second. That&#39;s probably faster than you want anyway.&lt;/p&gt; &#xA;&lt;h2&gt;Safe code&lt;/h2&gt; &#xA;&lt;p&gt;A bounty is offered for vulnerabilities, see the VULNINFO.md file for more information.&lt;/p&gt; &#xA;&lt;p&gt;This project uses safe functions like &lt;code&gt;strcpy_s()&lt;/code&gt; instead of unsafe functions like &lt;code&gt;strcpy()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This project has automated unit regression tests (&lt;code&gt;make regress&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;A lot of effort has gone into making the input/output look like &lt;code&gt;nmap&lt;/code&gt;, which everyone who does port scans is (or should be) familiar with.&lt;/p&gt; &#xA;&lt;h2&gt;IPv6 and IPv4 coexistence&lt;/h2&gt; &#xA;&lt;p&gt;Masscan supports IPv6, but there is no special mode, both are supported at the same time. (There is no &lt;code&gt;-6&lt;/code&gt; option -- it&#39;s always available).&lt;/p&gt; &#xA;&lt;p&gt;In any example you see of masscan usage, simply put an IPv6 address where you see an IPv4 address. You can include IPv4 and IPv6 addresses simultaneously in the same scan. Output includes the appropriate address at the same location, with no special marking.&lt;/p&gt; &#xA;&lt;p&gt;Just remember that IPv6 address space is really big. You probably don&#39;t want to scan for big ranges, except maybe the first 64k addresses of a subnet that were assigned via DHCPv6.&lt;/p&gt; &#xA;&lt;p&gt;Instead, you&#39;ll probably want to scan large lists of addresses stored in a file (&lt;code&gt;--include-file filename.txt&lt;/code&gt;) that you got from other sources. Like everywhere else, this file can contain lists of both IPv4 and IPv6 addresses. The test file I use contains 8 million addresses. Files of that size need a couple extra seconds to be read on startup (masscan sorts the addresses and removes duplicates before scanning).&lt;/p&gt; &#xA;&lt;p&gt;Remember that masscan contains its own network stack. Thus, the local machine you run masscan from does not need to be IPv6 enabled -- though the local network needs to be able to route IPv6 packets.&lt;/p&gt; &#xA;&lt;h2&gt;PF_RING&lt;/h2&gt; &#xA;&lt;p&gt;To get beyond 2 million packets/second, you need an Intel 10-gbps Ethernet adapter and a special driver known as &lt;a href=&#34;http://www.ntop.org/products/packet-capture/pf_ring/pf_ring-zc-zero-copy/&#34;&gt;&#34;PF_RING ZC&#34; from ntop&lt;/a&gt;. Masscan doesn&#39;t need to be rebuilt in order to use PF_RING. To use PF_RING, you need to build the following components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;libpfring.so&lt;/code&gt; (installed in /usr/lib/libpfring.so)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pf_ring.ko&lt;/code&gt; (their kernel driver)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ixgbe.ko&lt;/code&gt; (their version of the Intel 10-gbps Ethernet driver)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You don&#39;t need to build their version of &lt;code&gt;libpcap.so&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When Masscan detects that an adapter is named something like &lt;code&gt;zc:enp1s0&lt;/code&gt; instead of something like &lt;code&gt;enp1s0&lt;/code&gt;, it&#39;ll automatically switch to PF_RING ZC mode.&lt;/p&gt; &#xA;&lt;p&gt;A more detail discussion can be found in &lt;strong&gt;PoC||GTFO 0x15&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Regression testing&lt;/h2&gt; &#xA;&lt;p&gt;The project contains a built-in unit test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make test&#xA;bin/masscan --selftest&#xA;selftest: success!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tests a lot of tricky bits of the code. You should do this after building.&lt;/p&gt; &#xA;&lt;h2&gt;Performance testing&lt;/h2&gt; &#xA;&lt;p&gt;To test performance, run something like the following to a throw-away address, to avoid overloading your local router:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bin/masscan 0.0.0.0/4 -p80 --rate 100000000 --router-mac 66-55-44-33-22-11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bogus &lt;code&gt;--router-mac&lt;/code&gt; keeps packets on the local network segments so that they won&#39;t go out to the Internet.&lt;/p&gt; &#xA;&lt;p&gt;You can also test in &#34;offline&#34; mode, which is how fast the program runs without the transmit overhead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bin/masscan 0.0.0.0/4 -p80 --rate 100000000 --offline&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This second benchmark shows roughly how fast the program would run if it were using PF_RING, which has near zero overhead.&lt;/p&gt; &#xA;&lt;p&gt;By the way, the randomization algorithm makes heavy use of &#34;integer arithmetic&#34;, a chronically slow operation on CPUs. Modern CPUs have doubled the speed at which they perform this calculation, making &lt;code&gt;masscan&lt;/code&gt; much faster.&lt;/p&gt; &#xA;&lt;h1&gt;Authors&lt;/h1&gt; &#xA;&lt;p&gt;This tool created by Robert Graham: email: &lt;a href=&#34;mailto:robert_david_graham@yahoo.com&#34;&gt;robert_david_graham@yahoo.com&lt;/a&gt; twitter: @ErrataRob&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pjreddie/darknet</title>
    <updated>2022-10-30T01:43:52Z</updated>
    <id>tag:github.com,2022-10-30:/pjreddie/darknet</id>
    <link href="https://github.com/pjreddie/darknet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Convolutional Neural Networks&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;http://pjreddie.com/media/files/darknet-black-small.png&#34; alt=&#34;Darknet Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Darknet&lt;/h1&gt; &#xA;&lt;p&gt;Darknet is an open source neural network framework written in C and CUDA. It is fast, easy to install, and supports CPU and GPU computation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Discord&lt;/strong&gt; invite link for for communication and questions: &lt;a href=&#34;https://discord.gg/zSq8rtW&#34;&gt;https://discord.gg/zSq8rtW&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;YOLOv7:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;paper&lt;/strong&gt; - YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors: &lt;a href=&#34;https://arxiv.org/abs/2207.02696&#34;&gt;https://arxiv.org/abs/2207.02696&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;source code - Pytorch (use to reproduce results):&lt;/strong&gt; &lt;a href=&#34;https://github.com/WongKinYiu/yolov7&#34;&gt;https://github.com/WongKinYiu/yolov7&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Official YOLOv7 is more accurate and faster than YOLOv5 by &lt;strong&gt;120%&lt;/strong&gt; FPS, than YOLOX by &lt;strong&gt;180%&lt;/strong&gt; FPS, than Dual-Swin-T by &lt;strong&gt;1200%&lt;/strong&gt; FPS, than ConvNext by &lt;strong&gt;550%&lt;/strong&gt; FPS, than SWIN-L by &lt;strong&gt;500%&lt;/strong&gt; FPS.&lt;/p&gt; &#xA;&lt;p&gt;YOLOv7 surpasses all known object detectors in both speed and accuracy in the range from 5 FPS to 160 FPS and has the highest accuracy 56.8% AP among all known real-time object detectors with 30 FPS or higher on GPU V100, batch=1.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;YOLOv7-e6 (55.9% AP, 56 FPS V100 b=1) by &lt;code&gt;+500%&lt;/code&gt; FPS faster than SWIN-L Cascade-Mask R-CNN (53.9% AP, 9.2 FPS A100 b=1)&lt;/li&gt; &#xA; &lt;li&gt;YOLOv7-e6 (55.9% AP, 56 FPS V100 b=1) by &lt;code&gt;+550%&lt;/code&gt; FPS faster than ConvNeXt-XL C-M-RCNN (55.2% AP, 8.6 FPS A100 b=1)&lt;/li&gt; &#xA; &lt;li&gt;YOLOv7-w6 (54.6% AP, 84 FPS V100 b=1) by &lt;code&gt;+120%&lt;/code&gt; FPS faster than YOLOv5-X6-r6.1 (55.0% AP, 38 FPS V100 b=1)&lt;/li&gt; &#xA; &lt;li&gt;YOLOv7-w6 (54.6% AP, 84 FPS V100 b=1) by &lt;code&gt;+1200%&lt;/code&gt; FPS faster than Dual-Swin-T C-M-RCNN (53.6% AP, 6.5 FPS V100 b=1)&lt;/li&gt; &#xA; &lt;li&gt;YOLOv7x (52.9% AP, 114 FPS V100 b=1) by &lt;code&gt;+150%&lt;/code&gt; FPS faster than PPYOLOE-X (51.9% AP, 45 FPS V100 b=1)&lt;/li&gt; &#xA; &lt;li&gt;YOLOv7 (51.2% AP, 161 FPS V100 b=1) by &lt;code&gt;+180%&lt;/code&gt; FPS faster than YOLOX-X (51.1% AP, 58 FPS V100 b=1)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/179425274-f55a36d4-8450-4471-816b-8c105841effd.jpg&#34; alt=&#34;more5&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/177675030-a929ee00-0eba-4d93-95c2-225231d0fd61.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/177688869-d75e0c36-63af-46ec-bdbd-81dbb281f257.png&#34; alt=&#34;yolov7_640_1280&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Scaled-YOLOv4:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;paper (CVPR 2021)&lt;/strong&gt;: &lt;a href=&#34;https://openaccess.thecvf.com/content/CVPR2021/html/Wang_Scaled-YOLOv4_Scaling_Cross_Stage_Partial_Network_CVPR_2021_paper.html&#34;&gt;https://openaccess.thecvf.com/content/CVPR2021/html/Wang_Scaled-YOLOv4_Scaling_Cross_Stage_Partial_Network_CVPR_2021_paper.html&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;source code - Pytorch (use to reproduce results):&lt;/strong&gt; &lt;a href=&#34;https://github.com/WongKinYiu/ScaledYOLOv4&#34;&gt;https://github.com/WongKinYiu/ScaledYOLOv4&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;source code - Darknet:&lt;/strong&gt; &lt;a href=&#34;https://github.com/AlexeyAB/darknet&#34;&gt;https://github.com/AlexeyAB/darknet&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Medium:&lt;/strong&gt; &lt;a href=&#34;https://alexeyab84.medium.com/scaled-yolo-v4-is-the-best-neural-network-for-object-detection-on-ms-coco-dataset-39dfa22fa982?source=friends_link&amp;amp;sk=c8553bfed861b1a7932f739d26f487c8&#34;&gt;https://alexeyab84.medium.com/scaled-yolo-v4-is-the-best-neural-network-for-object-detection-on-ms-coco-dataset-39dfa22fa982?source=friends_link&amp;amp;sk=c8553bfed861b1a7932f739d26f487c8&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;YOLOv4:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;paper:&lt;/strong&gt; &lt;a href=&#34;https://arxiv.org/abs/2004.10934&#34;&gt;https://arxiv.org/abs/2004.10934&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;source code:&lt;/strong&gt; &lt;a href=&#34;https://github.com/AlexeyAB/darknet&#34;&gt;https://github.com/AlexeyAB/darknet&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Wiki:&lt;/strong&gt; &lt;a href=&#34;https://github.com/AlexeyAB/darknet/wiki&#34;&gt;https://github.com/AlexeyAB/darknet/wiki&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;useful links:&lt;/strong&gt; &lt;a href=&#34;https://medium.com/@alexeyab84/yolov4-the-most-accurate-real-time-neural-network-on-ms-coco-dataset-73adfd3602fe?source=friends_link&amp;amp;sk=6039748846bbcf1d960c3061542591d7&#34;&gt;https://medium.com/@alexeyab84/yolov4-the-most-accurate-real-time-neural-network-on-ms-coco-dataset-73adfd3602fe?source=friends_link&amp;amp;sk=6039748846bbcf1d960c3061542591d7&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more information see the &lt;a href=&#34;http://pjreddie.com/darknet&#34;&gt;Darknet project website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt; &lt;b&gt;Expand&lt;/b&gt; &lt;/summary&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/146988929-1ed0cbec-1e01-4ad0-b42c-808dcef32994.png&#34; alt=&#34;yolo_progress&#34;&gt; &lt;a href=&#34;https://paperswithcode.com/sota/object-detection-on-coco&#34;&gt;https://paperswithcode.com/sota/object-detection-on-coco&lt;/a&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/112776361-281d8380-9048-11eb-8083-8728b12dcd55.png&#34; alt=&#34;scaled_yolov4&#34;&gt; AP50:95 - FPS (Tesla V100) Paper: &lt;a href=&#34;https://arxiv.org/abs/2011.08036&#34;&gt;https://arxiv.org/abs/2011.08036&lt;/a&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/101363015-e5c21200-38b1-11eb-986f-b3e516e05977.png&#34; alt=&#34;YOLOv4Tiny&#34;&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/90338826-06114c80-dff5-11ea-9ba2-8eb63a7409b3.png&#34; alt=&#34;YOLOv4&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4096485/90338805-e5e18d80-dff4-11ea-8a68-5710956256ff.png&#34; alt=&#34;OpenCV_TRT&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;@misc{https://doi.org/10.48550/arxiv.2207.02696,&#xA;  doi = {10.48550/ARXIV.2207.02696},&#xA;  url = {https://arxiv.org/abs/2207.02696},&#xA;  author = {Wang, Chien-Yao and Bochkovskiy, Alexey and Liao, Hong-Yuan Mark},&#xA;  keywords = {Computer Vision and Pattern Recognition (cs.CV), FOS: Computer and information sciences, FOS: Computer and information sciences},&#xA;  title = {YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors},&#xA;  publisher = {arXiv},&#xA;  year = {2022}, &#xA;  copyright = {arXiv.org perpetual, non-exclusive license}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;@misc{bochkovskiy2020yolov4,&#xA;      title={YOLOv4: Optimal Speed and Accuracy of Object Detection}, &#xA;      author={Alexey Bochkovskiy and Chien-Yao Wang and Hong-Yuan Mark Liao},&#xA;      year={2020},&#xA;      eprint={2004.10934},&#xA;      archivePrefix={arXiv},&#xA;      primaryClass={cs.CV}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;@InProceedings{Wang_2021_CVPR,&#xA;    author    = {Wang, Chien-Yao and Bochkovskiy, Alexey and Liao, Hong-Yuan Mark},&#xA;    title     = {{Scaled-YOLOv4}: Scaling Cross Stage Partial Network},&#xA;    booktitle = {Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)},&#xA;    month     = {June},&#xA;    year      = {2021},&#xA;    pages     = {13029-13038}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>guanzhi/GmSSL</title>
    <updated>2022-10-30T01:43:52Z</updated>
    <id>tag:github.com,2022-10-30:/guanzhi/GmSSL</id>
    <link href="https://github.com/guanzhi/GmSSL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;支持国密SM2/SM3/SM4/SM9/SSL的密码工具箱&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GmSSL&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/guanzhi/GmSSL/actions/workflows/cmake.yml&#34;&gt;&lt;img src=&#34;https://github.com/guanzhi/GmSSL/workflows/CMake/badge.svg?sanitize=true&#34; alt=&#34;CMake&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;GmSSL是由由北京大学自主开发的国产商用密码开源库，实现了对国密算法、标准和安全通信协议的全面功能覆盖，支持包括移动端在内的主流操作系统和处理器，支持密码钥匙、密码卡等典型国产密码硬件，提供功能丰富的命令行工具及多种编译语言编程接口。&lt;/p&gt; &#xA;&lt;h2&gt;主要特性&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;超轻量：GmSSL 3.0大幅度降低了内存需求和二进制代码体积，不依赖动态内存，可以用于无操作系统的低功耗嵌入式环境(MCU、SOC等)，开发者也可以更容易地将国密算法和SSL协议嵌入到现有的项目中。&lt;/li&gt; &#xA; &lt;li&gt;更合规：GmSSL 3.0 可以配置为仅包含国密算法和国密协议(TLCP协议)，依赖GmSSL 的密码应用更容易满足密码产品型号检测的要求，避免由于混杂非国密算法、不安全算法等导致的安全问题和合规问题。&lt;/li&gt; &#xA; &lt;li&gt;更安全：TLS 1.3在安全性和通信延迟上相对之前的TLS协议有巨大的提升，GmSSL 3.0支持TLS 1.3协议和RFC 8998的国密套件。GmSSL 3.0默认支持密钥的加密保护，提升了密码算法的抗侧信道攻击能力。&lt;/li&gt; &#xA; &lt;li&gt;跨平台：GmSSL 3.0更容易跨平台，构建系统不再依赖Perl，默认的CMake构建系统可以容易地和Visual Studio、Android NDK等默认编译工具配合使用，开发者也可以手工编写Makefile在特殊环境中编译、剪裁。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;下载&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GmSSL的主分支开发中版本为 &lt;a href=&#34;https://github.com/guanzhi/GmSSL/archive/refs/heads/master.zip&#34;&gt;GmSSL-3.1.0-dev&lt;/a&gt;，主要增加跨平台特性，特别是对Windows/Visual Studio的支持，Windows、Android、iOS平台的开发者需要使用该版本。&lt;/li&gt; &#xA; &lt;li&gt;GmSSL当前稳定版本为 &lt;a href=&#34;https://github.com/guanzhi/GmSSL/releases/tag/v3.0.0&#34;&gt;GmSSL-3.0.0&lt;/a&gt;。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;编译与安装&lt;/h2&gt; &#xA;&lt;p&gt;GmSSL 3.0 采用了cmake构建系统。下载源代码后将其解压缩，进入源码目录，执行：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build&#xA;cd build&#xA;cmake ..&#xA;make&#xA;make test&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Visual Studio环境编译&lt;/h3&gt; &#xA;&lt;p&gt;在Visual Studio命令提示符下执行：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build&#xA;cd build&#xA;cmake .. -G &#34;NMake Makefiles&#34;&#xA;nmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;iOS编译&lt;/h3&gt; &#xA;&lt;p&gt;下载 &lt;a href=&#34;https://github.com/leetal/ios-cmake&#34;&gt;https://github.com/leetal/ios-cmake&lt;/a&gt; ，将&lt;code&gt;ios.toolchain.cmake&lt;/code&gt;文件复制到&lt;code&gt;build&lt;/code&gt;目录。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build; cd build&#xA;cmake .. -G Xcode -DCMAKE_TOOLCHAIN_FILE=../ios.toolchain.cmake -DPLATFORM=OS64&#xA;cmake --build . --config Release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果出现“error: Signing for &#34;gmssl&#34; requires a development team.”错误，可以用Xcode打开工程文件，在Signing配置中设置Development Team。&lt;/p&gt; &#xA;&lt;h3&gt;Android编译&lt;/h3&gt; &#xA;&lt;p&gt;下载Android NDK，执行&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build; cd build&#xA;cmake .. -DCMAKE_TOOLCHAIN_FILE=$NDK/build/cmake/android.toolchain.cmake  -DANDROID_ABI=arm64-v8a  -DANDROID_PLATFORM=android-23&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;主要功能&lt;/h2&gt; &#xA;&lt;h3&gt;密码算法&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;分组密码：SM4 (CBC/CTR/GCM), AES (CBC/CTR/GCM)&lt;/li&gt; &#xA; &lt;li&gt;序列密码：ZUC/ZUC-256, ChaCha20, RC4&lt;/li&gt; &#xA; &lt;li&gt;哈希函数: SM3, SHA-224/256/384/512, SHA-1, MD5&lt;/li&gt; &#xA; &lt;li&gt;公钥密码：SM2加密/签名, SM9加密/签名&lt;/li&gt; &#xA; &lt;li&gt;MAC算法：HMAC, GHASH&lt;/li&gt; &#xA; &lt;li&gt;密钥导出函数：PBKDF2、HKDF&lt;/li&gt; &#xA; &lt;li&gt;随机数生成器：Intel RDRAND, HASH_DRBG (NIST.SP.800-90A)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;证书和数字信封&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;数字证书：X.509证书, CRL证书注销列表, CSR (PKCS #10) 证书签名请求&lt;/li&gt; &#xA; &lt;li&gt;私钥加密：基于SM4/SM3口令加密的PEM格式私钥 (PKCS #8)&lt;/li&gt; &#xA; &lt;li&gt;数字信封：SM2密码消息 (GM/T 0010-2012)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;SSL协议&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TLCP 1.1，支持密码套&lt;code&gt;TLS_ECC_SM4_CBC_SM3 {0xE0,0x13}&lt;/code&gt; (GB/T 38636-2020、GM/T 0024-2014)&lt;/li&gt; &#xA; &lt;li&gt;TLS 1.2，支持密码套件&lt;code&gt;TLS_ECDHE_SM4_CBC_SM3 {0xE0,0x11}&lt;/code&gt; (GB/T 38636-2020、GM/T 0024-2014)&lt;/li&gt; &#xA; &lt;li&gt;TLS 1.3，支持密码套件&lt;code&gt;TLS_SM4_GCM_SM3 {0x00,0xC6}&lt;/code&gt; (RFC 8998)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;典型应用&lt;/h2&gt; &#xA;&lt;h4&gt;Nginx-with-GmSSL3.0&lt;/h4&gt; &#xA;&lt;p&gt;GmSSL支持Nginx的适配，并提供了Docker实现，具体参见&lt;a href=&#34;https://github.com/zhaoxiaomeng/Nginx-with-GmSSLv3&#34;&gt;Nginx-with-GmSSL3.0&lt;/a&gt; 项目。&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add Windows Visual Studio support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add Windows MinGW support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add iOS support and iOS demo App&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add Android support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;Version 3.1.0 release&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add GCC specific optimization&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add X86_64 assembly implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add GPU implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add performance benchmark tool&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add GCM cipher suites&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Release official open interfaces&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;Version 3.2.0 release&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>