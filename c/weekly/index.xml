<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-21T03:25:02Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>skywind3000/kcp</title>
    <updated>2024-04-21T03:25:02Z</updated>
    <id>tag:github.com,2024-04-21:/skywind3000/kcp</id>
    <link href="https://github.com/skywind3000/kcp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;⚡ KCP - A Fast and Reliable ARQ Protocol&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KCP - A Fast and Reliable ARQ Protocol&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp&#34;&gt;&lt;img src=&#34;https://github.com/skywind3000/kcp/raw/master/kcp.svg?sanitize=true&#34; alt=&#34;Powered&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/skywind3000/kcp&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/skywind3000/kcp.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/skywind3000/kcp/master/#backers&#34;&gt;&lt;img src=&#34;https://opencollective.com/kcp/backers/badge.svg?sanitize=true&#34; alt=&#34;Backers on Open Collective&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/skywind3000/kcp/master/#sponsors&#34;&gt;&lt;img src=&#34;https://opencollective.com/kcp/sponsors/badge.svg?sanitize=true&#34; alt=&#34;Sponsors on Open Collective&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/raw/master/README.en.md&#34;&gt;README in English&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;简介&lt;/h1&gt; &#xA;&lt;p&gt;KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。&lt;/p&gt; &#xA;&lt;p&gt;整个协议只有 ikcp.h, ikcp.c两个源文件，可以方便的集成到用户自己的协议栈中。也许你实现了一个P2P，或者某个基于 UDP的协议，而缺乏一套完善的ARQ可靠协议实现，那么简单的拷贝这两个文件到现有项目中，稍微编写两行代码，即可使用。&lt;/p&gt; &#xA;&lt;h1&gt;技术特性&lt;/h1&gt; &#xA;&lt;p&gt;TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果：&lt;/p&gt; &#xA;&lt;h4&gt;RTO翻倍vs不翻倍：&lt;/h4&gt; &#xA;&lt;p&gt;TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。&lt;/p&gt; &#xA;&lt;h4&gt;选择性重传 vs 全部重传：&lt;/h4&gt; &#xA;&lt;p&gt;TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。&lt;/p&gt; &#xA;&lt;h4&gt;快速重传：&lt;/h4&gt; &#xA;&lt;p&gt;发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。&lt;/p&gt; &#xA;&lt;h4&gt;延迟ACK vs 非延迟ACK：&lt;/h4&gt; &#xA;&lt;p&gt;TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。&lt;/p&gt; &#xA;&lt;h4&gt;UNA vs ACK+UNA：&lt;/h4&gt; &#xA;&lt;p&gt;ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。&lt;/p&gt; &#xA;&lt;h4&gt;非退让流控：&lt;/h4&gt; &#xA;&lt;p&gt;KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。&lt;/p&gt; &#xA;&lt;h1&gt;快速安装&lt;/h1&gt; &#xA;&lt;p&gt;您可以使用&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;库管理器下载并安装kcp:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Microsoft/vcpkg.git&#xA;cd vcpkg&#xA;./bootstrap-vcpkg.sh&#xA;./vcpkg integrate install&#xA;./vcpkg install kcp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;vcpkg中的kcp库由Microsoft团队成员和社区贡献者保持最新状态。如果版本过时，请在vcpkg存储库上&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;创建issue或提出PR&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h1&gt;基本使用&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;创建 KCP对象：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 初始化 kcp对象，conv为一个表示会话编号的整数，和tcp的 conv一样，通信双&#xA;// 方需保证 conv相同，相互的数据包才能够被认可，user是一个给回调函数的指针&#xA;ikcpcb *kcp = ikcp_create(conv, user);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;设置回调函数：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// KCP的下层协议输出函数，KCP需要发送数据时会调用它&#xA;// buf/len 表示缓存和长度&#xA;// user指针为 kcp对象创建时传入的值，用于区别多个 KCP对象&#xA;int udp_output(const char *buf, int len, ikcpcb *kcp, void *user)&#xA;{&#xA;  ....&#xA;}&#xA;// 设置回调函数&#xA;kcp-&amp;gt;output = udp_output;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;循环调用 update：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 以一定频率调用 ikcp_update来更新 kcp状态，并且传入当前时钟（毫秒单位）&#xA;// 如 10ms调用一次，或用 ikcp_check确定下次调用 update的时间不必每次调用&#xA;ikcp_update(kcp, millisec);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;输入一个下层数据包：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 收到一个下层数据包（比如UDP包）时需要调用：&#xA;ikcp_input(kcp, received_udp_packet, received_udp_size);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;处理了下层协议的输出/输入后 KCP协议就可以正常工作了，使用 ikcp_send 来向 远端发送数据。而另一端使用 ikcp_recv(kcp, ptr, size)来接收数据。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;协议配置&lt;/h1&gt; &#xA;&lt;p&gt;协议默认模式是一个标准的 ARQ，需要通过配置打开各项加速开关：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;工作模式：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;nodelay ：是否启用 nodelay模式，0不启用；1启用。&lt;/li&gt; &#xA;   &lt;li&gt;interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms&lt;/li&gt; &#xA;   &lt;li&gt;resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）&lt;/li&gt; &#xA;   &lt;li&gt;nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。&lt;/li&gt; &#xA;   &lt;li&gt;普通模式： ikcp_nodelay(kcp, 0, 40, 0, 0);&lt;/li&gt; &#xA;   &lt;li&gt;极速模式： ikcp_nodelay(kcp, 1, 10, 2, 1);&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;最大窗口：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;最大传输单元：&lt;/p&gt; &lt;p&gt;纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;最小RTO：&lt;/p&gt; &lt;p&gt;不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;kcp-&amp;gt;rx_minrto = 10;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;文档索引&lt;/h1&gt; &#xA;&lt;p&gt;协议的使用和配置都是很简单的，大部分情况看完上面的内容基本可以使用了。如果你需要进一步进行精细的控制，比如改变 KCP的内存分配器，或者你需要更有效的大规模调度 KCP链接（比如 3500个以上），或者如何更好的同 TCP结合，那么可以继续延伸阅读：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki&#34;&gt;Wiki Home&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/KCP-Best-Practice&#34;&gt;KCP 最佳实践&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Cooperate-With-Tcp-Server&#34;&gt;同现有TCP服务器集成&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Network-Encryption&#34;&gt;传输数据加密&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Flow-Control-for-Users&#34;&gt;应用层流量控制&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/KCP-Benchmark&#34;&gt;性能评测&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;开源案例&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xtaci/kcptun&#34;&gt;kcptun&lt;/a&gt;: 基于 kcp-go做的高速远程端口转发(隧道) ，配合ssh -D，可以比 shadowsocks 更流畅的看在线视频。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vzex/dog-tunnel&#34;&gt;dog-tunnel&lt;/a&gt;: GO开发的网络隧道，使用 KCP极大的改进了传输速度，并移植了一份 GO版本 KCP&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.v2ray.com&#34;&gt;v2ray&lt;/a&gt;: 著名代理软件，Shadowsocks 代替者，1.17后集成了 kcp协议，使用UDP传输，无数据包特征。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ldcsaa/HP-Socket&#34;&gt;HP-Socket&lt;/a&gt;: 高性能网络通信框架 HP-Socket。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fatedier/frp&#34;&gt;frp&lt;/a&gt;: 高性能内网穿透的反向代理软件，可将将内网服务暴露映射到外网服务器。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/libinzhangyuan/asio_kcp&#34;&gt;asio-kcp&lt;/a&gt;: 使用 KCP的完整 UDP网络库，完整实现了基于 UDP的链接状态管理，会话控制，KCP协议调度等&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hkspirt/kcp-java&#34;&gt;kcp-java&lt;/a&gt;: Java版本 KCP协议实现。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/szhnet/kcp-netty&#34;&gt;kcp-netty&lt;/a&gt;: kcp的Java语言实现，基于netty。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/l42111996/java-Kcp&#34;&gt;java-kcp&lt;/a&gt;: JAVA版本KCP,基于netty实现(包含fec功能)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/l42111996/csharp-kcp&#34;&gt;csharp-kcp&lt;/a&gt;: csharp版本KCP,基于dotNetty实现(包含fec功能)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Unit-X/kcp-cpp&#34;&gt;kcp-cpp&lt;/a&gt;: KCP 的多平台（Windows、MacOS、Linux）C++ 实现作为应用程序中的简单库。包含适用于所有平台的套接字处理和辅助函数。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Homqyy/kcp-perl&#34;&gt;kcp-perl&lt;/a&gt;: kcp的Perl实现，其是面向对象的，Perl-Like的。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xtaci/kcp-go&#34;&gt;kcp-go&lt;/a&gt;: 高安全性的kcp的 GO语言实现，包含 UDP会话管理的简单实现，可以作为后续开发的基础库。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/limpo1989/kcp-csharp&#34;&gt;kcp-csharp&lt;/a&gt;: kcp的 csharp移植，同时包含一份回话管理，可以连接上面kcp-go的服务端。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KumoKyaku/KCP&#34;&gt;kcp-csharp&lt;/a&gt;: 新版本 Kcp的 csharp移植。线程安全，运行时无alloc，对gc无压力。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vis2k/kcp2k/&#34;&gt;kcp2k&lt;/a&gt;: Line-by-line translation to C#, with optional Server/Client on top.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/en/kcp-rs&#34;&gt;kcp-rs&lt;/a&gt;: KCP的 rust移植&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Matrix-Zhang/kcp&#34;&gt;kcp-rust&lt;/a&gt;：新版本 KCP的 rust 移植&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Matrix-Zhang/tokio_kcp&#34;&gt;tokio-kcp&lt;/a&gt;：rust tokio 的 kcp 集成&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/b23r0/kcp-rust-native&#34;&gt;kcp-rust-native&lt;/a&gt;：rust 的 kcp bindings&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/linxiaolong/lua-kcp&#34;&gt;lua-kcp&lt;/a&gt;: KCP的 Lua扩展，用于 Lua服务器&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/leenjewel/node-kcp&#34;&gt;node-kcp&lt;/a&gt;: node-js 的 KCP 接口&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyyd/nysocks&#34;&gt;nysocks&lt;/a&gt;: 基于libuv实现的&lt;a href=&#34;https://nodejs.org/api/addons.html&#34;&gt;node-addon&lt;/a&gt;，提供nodejs版本的代理服务，客户端接入支持SOCKS5和ss两种协议&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-android&#34;&gt;shadowsocks-android&lt;/a&gt;: Shadowsocks for android 集成了 kcptun 使用 kcp协议加速 shadowsocks，效果不错&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/elisaday/kcpuv&#34;&gt;kcpuv&lt;/a&gt;: 使用 libuv开发的kcpuv库，目前还在 Demo阶段&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://getlantern.org/&#34;&gt;Lantern&lt;/a&gt;：更好的 VPN，Github 50000 星，使用 kcpgo 加速&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/smallnest/rpcx&#34;&gt;rpcx&lt;/a&gt; ：RPC 框架，1000+ 星，使用 kcpgo 加速 RPC&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/liudf0716/xkcptun&#34;&gt;xkcptun&lt;/a&gt;: c语言实现的kcptun，主要用于&lt;a href=&#34;https://github.com/openwrt/openwrt&#34;&gt;OpenWrt&lt;/a&gt;, &lt;a href=&#34;https://github.com/lede-project/source&#34;&gt;LEDE&lt;/a&gt;开发的路由器项目上&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egametang/ET&#34;&gt;et-frame&lt;/a&gt;: C#前后端框架(前端unity3d)，统一用C#开发游戏，实现了前后端kcp协议&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yasio/yasio&#34;&gt;yasio&lt;/a&gt;: 一个跨平台专注于任意客户端程序的异步socket库, 易于使用，相同的API操作KCP/TCP/UDP, 性能测试结果: &lt;a href=&#34;https://github.com/yasio/yasio/raw/master/benchmark.md&#34;&gt;benchmark-pump&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shaoyuan1943/gouxp&#34;&gt;gouxp&lt;/a&gt;: 用Go实现基于回调方式的KCP开发包，包含加解密和FEC支持，简单易用。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xboss/skcp&#34;&gt;skcp&lt;/a&gt;: 基于libev实现的库，具备传输加密及基本的连接管理能力。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/enkiller/pykcp&#34;&gt;pykcp&lt;/a&gt;: Python 版本的 KCP 实现&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;商业案例&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ys.mihoyo.com/&#34;&gt;原神&lt;/a&gt;：米哈游的《原神》使用 KCP 降低游戏消息的传输耗时，提升操作的体验。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://improbable.io/spatialOS&#34;&gt;SpatialOS&lt;/a&gt;: 大型多人分布式游戏服务端引擎，BigWorld 的后继者，使用 KCP 加速数据传输。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.xishanju.com/&#34;&gt;西山居&lt;/a&gt;：使用 KCP 进行游戏数据加速。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://cc.163.com/&#34;&gt;CC&lt;/a&gt;：网易 CC 使用 kcp 加速视频推流，有效提高流畅性&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://bobo.163.com/&#34;&gt;BOBO&lt;/a&gt;：网易 BOBO 使用 kcp 加速主播推流&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://uu.163.com&#34;&gt;UU&lt;/a&gt;：网易 UU 加速器使用 KCP/KCPTUN 经行远程传输加速。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cn.aliyun.com/&#34;&gt;阿里云&lt;/a&gt;：阿里云的视频传输加速服务 GRTN 使用 KCP 进行音视频数据传输优化，动态加速产品也使用 KCP。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.yfcloud.com/&#34;&gt;云帆加速&lt;/a&gt;：使用 KCP 加速文件传输和视频推流，优化了台湾主播推流的流畅度。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.taptap.com/app/50664&#34;&gt;明日帝国&lt;/a&gt;：Game K17 的 《明日帝国》 （Google Play），使用 KCP 加速游戏消息，让全球玩家流畅联网&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.taptap.com/app/27242&#34;&gt;仙灵大作战&lt;/a&gt;：4399 的 MOBA游戏，使用 KCP 优化游戏同步&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;KCP 成功的运行在多个用户规模上亿的项目上，为他们提供了更加灵敏和丝滑网络体验。&lt;/p&gt; &#xA;&lt;p&gt;欢迎告知更多案例&lt;/p&gt; &#xA;&lt;h1&gt;协议比较&lt;/h1&gt; &#xA;&lt;p&gt;如果网络永远不卡，那 KCP/TCP 表现类似，但是网络本身就是不可靠的，丢包和抖动无法避免（否则还要各种可靠协议干嘛）。在内网这种几乎理想的环境里直接比较，大家都差不多，但是放到公网上，放到3G/4G网络情况下，或者使用内网丢包模拟，差距就很明显了。公网在高峰期有平均接近10%的丢包，wifi/3g/4g下更糟糕，这些都会让传输变卡。&lt;/p&gt; &#xA;&lt;p&gt;感谢 &lt;a href=&#34;https://github.com/libinzhangyuan/asio_kcp&#34;&gt;asio-kcp&lt;/a&gt; 的作者 &lt;a href=&#34;https://github.com/libinzhangyuan&#34;&gt;zhangyuan&lt;/a&gt; 对 KCP 与 enet, udt做过的一次横向评测，结论如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ASIO-KCP &lt;strong&gt;has good performace in wifi and phone network(3G, 4G)&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The kcp is the &lt;strong&gt;first choice for realtime pvp game&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The lag is less than 1 second when network lag happen. &lt;strong&gt;3 times better than enet&lt;/strong&gt; when lag happen.&lt;/li&gt; &#xA; &lt;li&gt;The enet is a good choice if your game allow 2 second lag.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;UDT is a bad idea&lt;/strong&gt;. It always sink into badly situation of more than serval seconds lag. And the recovery is not expected.&lt;/li&gt; &#xA; &lt;li&gt;enet has the problem of lack of doc. And it has lots of functions that you may intrest.&lt;/li&gt; &#xA; &lt;li&gt;kcp&#39;s doc is chinese. Good thing is the function detail which is writen in code is english. And you can use asio_kcp which is a good wrap.&lt;/li&gt; &#xA; &lt;li&gt;The kcp is a simple thing. You will write more code if you want more feature.&lt;/li&gt; &#xA; &lt;li&gt;UDT has a perfect doc. UDT may has more bug than others as I feeling.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;具体见：&lt;a href=&#34;https://github.com/libinzhangyuan/reliable_udp_bench_mark&#34;&gt;横向比较&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/KCP-Benchmark&#34;&gt;评测数据&lt;/a&gt;，为犹豫选择的人提供了更多指引。&lt;/p&gt; &#xA;&lt;p&gt;大型多人游戏服务端引擎 &lt;a href=&#34;https://improbable.io/spatialOS&#34;&gt;SpatialOS&lt;/a&gt; 在集成 KCP 协议后做了同 TCP/RakNet 的评测：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/skywind3000/kcp/raw/master/images/spatialos-50.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;对比了在服务端刷新率为 60 Hz 同时维护 50 个角色时的响应时间，详细对比报告见：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://improbable.io/blog/kcp-a-new-low-latency-secure-network-stack&#34;&gt;Kcp a new low latency secure network stack&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;关于协议&lt;/h1&gt; &#xA;&lt;p&gt;近年来，网络游戏和各类社交网络都在成几何倍数的增长，不管网络游戏还是各类互动社交网络，交互性和复杂度都在迅速提高，都需要在极短的时间内将数据同时投递给大量用户，因此传输技术自然变为未来制约发展的一个重要因素，而开源界里各种著名的传输协议，如 raknet/enet 之类，一发布都是整套协议栈一起发布，这种形式是不利于多样化的，我的项目只能选择用或者不用你，很难选择 “部分用你”，然而你一套协议栈设计的再好，是非常难以满足不同角度的各种需求的。&lt;/p&gt; &#xA;&lt;p&gt;因此 KCP 的方式是把协议栈 “拆开”，让大家可以根据项目需求进行灵活的调整和组装，你可以下面加一层 reed solomon 的纠删码做 FEC，上面加一层类 RC4/Salsa20 做流加密，握手处再设计一套非对称密钥交换，底层 UDP 传输层再做一套动态路由系统，同时探测多条路径，选最好路径进行传输。这些不同的 “协议单元” 可以像搭建积木一般根据需要自由组合，保证 “简单性” 和 “可拆分性”，这样才能灵活适配多变的业务需求，哪个模块不好，换了就是。&lt;/p&gt; &#xA;&lt;p&gt;未来传输方面的解决方案必然是根据使用场景深度定制的，因此给大家一个可以自由组合的 “协议单元” ，方便大家集成在自己的协议栈中。&lt;/p&gt; &#xA;&lt;p&gt;For more information, please see the &lt;a href=&#34;https://github.com/skywind3000/kcp/wiki/Success-Stories&#34;&gt;Success Stories&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;关于作者&lt;/h1&gt; &#xA;&lt;p&gt;作者：林伟 (skywind3000)&lt;/p&gt; &#xA;&lt;p&gt;欢迎关注我的：&lt;a href=&#34;https://twitter.com/skywind3000&#34;&gt;twitter&lt;/a&gt; 和 &lt;a href=&#34;https://www.zhihu.com/people/skywind3000&#34;&gt;zhihu&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;我在多年的开发经历中，一直都喜欢研究解决程序中的一些瓶颈问题，早年喜欢游戏开发，照着《VGA编程》来做游戏图形，读 Michael Abrash 的《图形程序开发人员指南》做软渲染器，爱好摆弄一些能够榨干 CPU 能够运行更快的代码，参加工作后，兴趣转移到服务端和网络相关的技术。&lt;/p&gt; &#xA;&lt;p&gt;2007 年时做了几个传统游戏后开始研究快速动作游戏的同步问题，期间写过不少文章，算是国内比较早研究同步问题的人，然而发现不管怎么解决同步都需要在网络传输方面有所突破，后来离开游戏转行互联网后也发现不少领域有这方面的需求，于是开始花时间在网络传输这个领域上，尝试基于 UDP 实现一些保守的可靠协议，仿照 BSD Lite 4.4 的代码实现一些类 TCP 协议，觉得比较有意思，又接着实现一些 P2P 和动态路由网相关的玩具。KCP 协议诞生于 2011 年，基本算是自己传输方面做的几个玩具中的一个。&lt;/p&gt; &#xA;&lt;p&gt;Kcptun 的作者 xtaci 是我的大学同学，我俩都是学通信的，经常在一起研究如何进行传输优化。&lt;/p&gt; &#xA;&lt;h1&gt;欢迎捐赠&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/skywind3000/kcp/master/images/donation.png&#34; alt=&#34;欢迎使用支付宝对该项目进行捐赠&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;欢迎使用支付宝手扫描上面的二维码，对该项目进行捐赠。捐赠款项将用于持续优化 KCP协议以及完善文档。&lt;/p&gt; &#xA;&lt;p&gt;感谢：明明、星仔、进、帆、颁钊、斌铨、晓丹、余争、虎、晟敢、徐玮、王川、赵刚强、胡知锋、万新朝、何新超、刘旸、侯宪辉、吴佩仪、华斌、如涛、胡坚。。。（早先的名单实在不好意思没记录下来）等同学的捐助与支持。&lt;/p&gt; &#xA;&lt;p&gt;欢迎关注&lt;/p&gt; &#xA;&lt;p&gt;KCP交流群：364933586（QQ群号），KCP集成，调优，网络传输以及相关技术讨论&lt;/p&gt; &#xA;&lt;p&gt;Gitter 群：&lt;a href=&#34;https://gitter.im/skywind3000/KCP&#34;&gt;https://gitter.im/skywind3000/KCP&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;blog: &lt;a href=&#34;http://www.skywind.me&#34;&gt;http://www.skywind.me&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;This project exists thanks to all the people who contribute. &lt;a href=&#34;https://github.com/skywind3000/kcp/graphs/contributors&#34;&gt;&lt;img src=&#34;https://opencollective.com/kcp/contributors.svg?width=890&amp;amp;button=false&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>xiph/rnnoise</title>
    <updated>2024-04-21T03:25:02Z</updated>
    <id>tag:github.com,2024-04-21:/xiph/rnnoise</id>
    <link href="https://github.com/xiph/rnnoise" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Recurrent neural network for audio noise reduction&lt;/p&gt;&lt;hr&gt;&lt;p&gt;RNNoise is a noise suppression library based on a recurrent neural network. A description of the algorithm is provided in the following paper:&lt;/p&gt; &#xA;&lt;p&gt;J.-M. Valin, A Hybrid DSP/Deep Learning Approach to Real-Time Full-Band Speech Enhancement, Proceedings of IEEE Multimedia Signal Processing (MMSP) Workshop, arXiv:1709.08243, 2018. &lt;a href=&#34;https://arxiv.org/pdf/1709.08243.pdf&#34;&gt;https://arxiv.org/pdf/1709.08243.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An interactive demo is available at: &lt;a href=&#34;https://jmvalin.ca/demo/rnnoise/&#34;&gt;https://jmvalin.ca/demo/rnnoise/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To compile, just type: % ./autogen.sh % ./configure % make&lt;/p&gt; &#xA;&lt;p&gt;Optionally: % make install&lt;/p&gt; &#xA;&lt;p&gt;It is recommended to either set -march= in the CFLAGS to an architecture with AVX2 support or to add --enable-x86-rtcd to the configure script so that AVX2 (or SSE4.1) can at least be used as an option. Note that the autogen.sh script will automatically download the model files from the Xiph.Org servers, since those are too large to put in Git.&lt;/p&gt; &#xA;&lt;p&gt;While it is meant to be used as a library, a simple command-line tool is provided as an example. It operates on RAW 16-bit (machine endian) mono PCM files sampled at 48 kHz. It can be used as:&lt;/p&gt; &#xA;&lt;p&gt;% ./examples/rnnoise_demo &#xA; &lt;noisy speech&gt; &#xA;  &lt;output denoised&gt;&lt;/output&gt;&#xA; &lt;/noisy&gt;&lt;/p&gt; &#xA;&lt;p&gt;The output is also a 16-bit raw PCM file. NOTE AGAIN, THE INPUT and OUTPUT ARE IN RAW FORMAT, NOT WAV.&lt;/p&gt; &#xA;&lt;p&gt;The latest version of the source is available from &lt;a href=&#34;https://gitlab.xiph.org/xiph/rnnoise&#34;&gt;https://gitlab.xiph.org/xiph/rnnoise&lt;/a&gt; . The GitHub repository is a convenience copy.&lt;/p&gt; &#xA;&lt;p&gt;== Training ==&lt;/p&gt; &#xA;&lt;p&gt;The models distributed with RNNoise are now trained using only the publicly available datasets listed below and using the training precedure described here. Exact results will still depend on the the exact mix us data used, on how long the training is performed and on the various random seeds involved.&lt;/p&gt; &#xA;&lt;p&gt;To train an RNNoise model, you need both clean speech data, and noise data. Both need to be sampled at 48 kHz, in 16-bit PCM format (machine endian). Clean speech data can be obtained from the datasets listed in the datasets.txt file, or by downloaded the already-concatenation of those files in &lt;a href=&#34;https://media.xiph.org/rnnoise/data/tts_speech_48k.sw&#34;&gt;https://media.xiph.org/rnnoise/data/tts_speech_48k.sw&lt;/a&gt; For noise data, we suggest concatenating the 48 kHz noise data from DEMAND at &lt;a href=&#34;https://zenodo.org/records/1227121&#34;&gt;https://zenodo.org/records/1227121&lt;/a&gt; with contrib_noise.sw and synthetic_noise.sw noise files from &lt;a href=&#34;https://media.xiph.org/rnnoise/data/&#34;&gt;https://media.xiph.org/rnnoise/data/&lt;/a&gt; To balance out the data, we recommend using multiple (e.g. 5) copies of the contrib_noise.sw and synthetic_noise.sw noise files.&lt;/p&gt; &#xA;&lt;p&gt;The first step is to take the speech and noise, and mix them in a variety of ways to simulate real life conditions (including pauses, filtering and more). Assuming the files are called speech.pcm and noise.pcm, start by generating the training feature data with:&lt;/p&gt; &#xA;&lt;p&gt;% ./dump_features speech.pcm noise.pcm features.f32 &#xA; &lt;count&gt;&#xA;   where &#xA;  &lt;count&gt;&#xA;    is the number of sequences to process. The number of sequences should be at least 10000, but the more the better (200000 or more is recommended).&#xA;  &lt;/count&gt;&#xA; &lt;/count&gt;&lt;/p&gt; &#xA;&lt;p&gt;Optionally, training can also simulate reverberation, in which case room impulse responses (RIR) are also needed. Limited RIR data is available at: &lt;a href=&#34;https://media.xiph.org/rnnoise/data/measured_rirs-v2.tar.gz&#34;&gt;https://media.xiph.org/rnnoise/data/measured_rirs-v2.tar.gz&lt;/a&gt; The format for those is raw 32-bit floating-point (files are little endian). Assuming a list of all the RIR files is contained in a rir_list.txt file, the training feature data can be generated with:&lt;/p&gt; &#xA;&lt;p&gt;% ./dump_features -rir_list rir_list.txt speech.pcm noise.pcm features.f32 &#xA; &lt;count&gt;&lt;/count&gt;&lt;/p&gt; &#xA;&lt;p&gt;To make the feature generation faster, you can use the script provided in script/dump_features_parallel.sh (you will need to modify the script if you want to add RIR augmentation).&lt;/p&gt; &#xA;&lt;p&gt;To use it: % script/dump_features_parallel.sh ./dump_features speech.pcm noise.pcm features.f32 &#xA; &lt;count&gt;&#xA;   &amp;lt;nb_processes&amp;gt; which will run nb_processes processes, each for count sequences, and concatenate the output to a single file.&#xA; &lt;/count&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once the feature file is computed, you can start the training with: % python3 train_rnnoise.py features.f32 output_directory&lt;/p&gt; &#xA;&lt;p&gt;Choose a number of epochs (using --epochs) that leads to about 75000 weight updates. The training will produce .pth files, e.g. rnnoise_50.pth . The next step is to convert the model to C files using:&lt;/p&gt; &#xA;&lt;p&gt;% python3 dump_rnnoise_weights.py --quantize rnnoise_50.pth rnnoise_c&lt;/p&gt; &#xA;&lt;p&gt;which will produce the rnnoise_data.c and rnnoise_data.h files in the rnnoise_c directory.&lt;/p&gt; &#xA;&lt;p&gt;Copy these files to src/ and then build RNNoise using the instructions above.&lt;/p&gt; &#xA;&lt;p&gt;For slightly better results, a trained model can be used to remove any noise from the &#34;clean&#34; training speech, before restaring the denoising process again (no need to do that more than once).&lt;/p&gt; &#xA;&lt;p&gt;== Loadable Models ==&lt;/p&gt; &#xA;&lt;p&gt;The model format has changed since v0.1.1. Models now use a binary &#34;machine endian&#34; format. To output a model in that format, build RNNoise with that model and use the dump_weights_blob executable to output a weights_blob.bin binary file. That file can then be used with the rnnoise_model_from_file() API call. Note that the model object MUST NOT be deleted while the RNNoise state is active and the file MUST NOT be closed.&lt;/p&gt; &#xA;&lt;p&gt;To avoid including the default model in the build (e.g. to reduce download size) and rely only on model loading, add -DUSE_WEIGHTS_FILE to the CFLAGS. To be able to load different models, the model size (and header file) needs to patch the size use during build. Otherwise the model will not load We provide a &#34;little&#34; model with half as an alternative. To use the smaller model, rename rnnoise_data_little.c to rnnoise_data.c. It is possible to build both the regular and little binary weights and load any of them at run time since the little model has the same size as the regular one (except for the increased sparsity).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>n64decomp/sm64</title>
    <updated>2024-04-21T03:25:02Z</updated>
    <id>tag:github.com,2024-04-21:/n64decomp/sm64</id>
    <link href="https://github.com/n64decomp/sm64" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Super Mario 64 decompilation, brought to you by a bunch of clever folks.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Super Mario 64&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This repo contains a full decompilation of Super Mario 64 of the following releases: Japan (jp), North America (us), Europe (eu), Shindou (sh) and iQue Player (cn).&lt;/li&gt; &#xA; &lt;li&gt;Naming and documentation of the source code and data structures are in progress.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It builds the following ROMs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;sm64.jp.z64 &lt;code&gt;sha1: 8a20a5c83d6ceb0f0506cfc9fa20d8f438cafe51&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sm64.us.z64 &lt;code&gt;sha1: 9bef1128717f958171a4afac3ed78ee2bb4e86ce&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sm64.eu.z64 &lt;code&gt;sha1: 4ac5721683d0e0b6bbb561b58a71740845dceea9&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sm64.sh.z64 &lt;code&gt;sha1: 3f319ae697533a255a1003d09202379d78d5a2e0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sm64.cn.z64 &lt;code&gt;sha1: 2e1db2780985a1f068077dc0444b685f39cd90ec&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repo does not include all assets necessary for compiling the ROMs. A prior copy of the game is required to extract the assets.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start (for Ubuntu)&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install prerequisites: &lt;code&gt;sudo apt install -y binutils-mips-linux-gnu build-essential git pkgconf python3&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Clone the repo from within Linux: &lt;code&gt;git clone https://github.com/n64decomp/sm64.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Place a Super Mario 64 ROM called &lt;code&gt;baserom.&amp;lt;VERSION&amp;gt;.z64&lt;/code&gt; into the project folder for asset extraction, where &lt;code&gt;VERSION&lt;/code&gt; can be &lt;code&gt;jp&lt;/code&gt;, &lt;code&gt;us&lt;/code&gt;, &lt;code&gt;eu&lt;/code&gt;, &lt;code&gt;sh&lt;/code&gt;, or &lt;code&gt;cn&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;make&lt;/code&gt; to build. Specify the version through &lt;code&gt;make VERSION=&amp;lt;VERSION&amp;gt;&lt;/code&gt;. Add &lt;code&gt;-j4&lt;/code&gt; to improve build speed (hardware dependent).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Ensure the repo path length does not exceed 255 characters. Long path names result in build errors.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;Install WSL and a distro of your choice following &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/wsl/install-win10&#34;&gt;Windows Subsystem for Linux Installation Guide for Windows 10.&lt;/a&gt; We recommend either Debian or Ubuntu 18.04 Linux distributions under WSL. Note: WSL1 does not currently support Ubuntu 20.04.&lt;/p&gt; &#xA;&lt;p&gt;Next, clone the SM64 repo from within the Linux shell: &lt;code&gt;git clone https://github.com/n64decomp/sm64.git&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then continue following the directions in the &lt;a href=&#34;https://raw.githubusercontent.com/n64decomp/sm64/master/#linux&#34;&gt;Linux&lt;/a&gt; installation section below.&lt;/p&gt; &#xA;&lt;h3&gt;Linux&lt;/h3&gt; &#xA;&lt;p&gt;There are 3 steps to set up a working build.&lt;/p&gt; &#xA;&lt;h4&gt;Step 1: Install dependencies&lt;/h4&gt; &#xA;&lt;p&gt;The build system has the following package requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;binutils-mips&lt;/li&gt; &#xA; &lt;li&gt;pkgconf&lt;/li&gt; &#xA; &lt;li&gt;python3 &amp;gt;= 3.6&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Dependency installation instructions for common Linux distros are provided below:&lt;/p&gt; &#xA;&lt;h5&gt;Debian / Ubuntu&lt;/h5&gt; &#xA;&lt;p&gt;To install build dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install -y binutils-mips-linux-gnu build-essential git pkgconf python3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Arch Linux&lt;/h5&gt; &#xA;&lt;p&gt;To install build dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo pacman -S base-devel python&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install the following AUR packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aur.archlinux.org/packages/mips64-elf-binutils&#34;&gt;mips64-elf-binutils&lt;/a&gt; (AUR)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Other Linux distributions&lt;/h5&gt; &#xA;&lt;p&gt;Most modern Linux distributions should have equivalent packages to the other two listed above. You may have to use a different version of GNU binutils. Listed below are fully compatible binutils distributions with support in the makefile, and examples of distros that offer them:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;mips64-elf-&lt;/code&gt; (Arch AUR)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mips-linux-gnu-&lt;/code&gt; (Ubuntu and other Debian-based distros)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mips64-linux-gnu-&lt;/code&gt; (RHEL/CentOS/Fedora)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You may also use &lt;a href=&#34;https://raw.githubusercontent.com/n64decomp/sm64/master/#docker-installation&#34;&gt;Docker&lt;/a&gt; to handle installing an image with minimal dependencies.&lt;/p&gt; &#xA;&lt;h4&gt;Step 2: Copy baserom(s) for asset extraction&lt;/h4&gt; &#xA;&lt;p&gt;For each version (jp/us/eu/sh/cn) for which you want to build a ROM, put an existing ROM at &lt;code&gt;./baserom.&amp;lt;VERSION&amp;gt;.z64&lt;/code&gt; for asset extraction.&lt;/p&gt; &#xA;&lt;h5&gt;Step 3: Build the ROM&lt;/h5&gt; &#xA;&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt; to build the ROM (defaults to &lt;code&gt;VERSION=us&lt;/code&gt;). Other examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make VERSION=jp -j4       # build (J) version instead with 4 jobs&#xA;make VERSION=eu COMPARE=0 # build (EU) version but do not compare ROM hashes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Resulting artifacts can be found in the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;The full list of configurable variables are listed below, with the default being the first listed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;VERSION&lt;/code&gt;: &lt;code&gt;jp&lt;/code&gt;, &lt;code&gt;us&lt;/code&gt;, &lt;code&gt;eu&lt;/code&gt;, &lt;code&gt;sh&lt;/code&gt;, &lt;code&gt;cn&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GRUCODE&lt;/code&gt;: &lt;code&gt;f3d_old&lt;/code&gt;, &lt;code&gt;f3d_new&lt;/code&gt;, &lt;code&gt;f3dex&lt;/code&gt;, &lt;code&gt;f3dex2&lt;/code&gt;, &lt;code&gt;f3dzex&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;COMPARE&lt;/code&gt;: &lt;code&gt;1&lt;/code&gt; (compare ROM hash), &lt;code&gt;0&lt;/code&gt; (do not compare ROM hash)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NON_MATCHING&lt;/code&gt;: Use functionally equivalent C implementations for non-matchings. Also will avoid instances of undefined behavior.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CROSS&lt;/code&gt;: Cross-compiler tool prefix (Example: &lt;code&gt;mips64-elf-&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;macOS&lt;/h3&gt; &#xA;&lt;p&gt;With macOS, you may either use Homebrew or &lt;a href=&#34;https://raw.githubusercontent.com/n64decomp/sm64/master/#docker-installation&#34;&gt;Docker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Homebrew&lt;/h4&gt; &#xA;&lt;h4&gt;Step 1: Install dependencies&lt;/h4&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; and the following dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew update&#xA;brew install coreutils make pkg-config tehzz/n64-dev/mips64-elf-binutils&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Step 2: Copy baserom(s) for asset extraction&lt;/h4&gt; &#xA;&lt;p&gt;For each version (jp/us/eu/sh/cn) for which you want to build a ROM, put an existing ROM at &lt;code&gt;./baserom.&amp;lt;VERSION&amp;gt;.z64&lt;/code&gt; for asset extraction.&lt;/p&gt; &#xA;&lt;h5&gt;Step 3: Build the ROM&lt;/h5&gt; &#xA;&lt;p&gt;Use Homebrew&#39;s GNU make because the version included with macOS is too old.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gmake VERSION=jp -j4       # build (J) version instead with 4 jobs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Docker Installation&lt;/h3&gt; &#xA;&lt;h4&gt;Create Docker image&lt;/h4&gt; &#xA;&lt;p&gt;After installing and starting Docker, create the docker image. This only needs to be done once.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker build -t sm64 .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Build&lt;/h4&gt; &#xA;&lt;p&gt;To build, mount the local filesystem into the Docker container and build the ROM with &lt;code&gt;docker run sm64 make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;macOS example for (U):&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --rm --mount type=bind,source=&#34;$(pwd)&#34;,destination=/sm64 sm64 make VERSION=us -j4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Linux example for (U):&lt;/h5&gt; &#xA;&lt;p&gt;For a Linux host, Docker needs to be instructed which user should own the output files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --rm --mount type=bind,source=&#34;$(pwd)&#34;,destination=/sm64 --user $UID:$GID sm64 make VERSION=us -j4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Resulting artifacts can be found in the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Project Structure&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;sm64&#xA;├── actors: object behaviors, geo layout, and display lists&#xA;├── asm: handwritten assembly code, rom header&#xA;│   └── non_matchings: asm for non-matching sections&#xA;├── assets: animation and demo data&#xA;│   ├── anims: animation data&#xA;│   └── demos: demo data&#xA;├── bin: C files for ordering display lists and textures&#xA;├── build: output directory&#xA;├── data: behavior scripts, misc. data&#xA;├── doxygen: documentation infrastructure&#xA;├── enhancements: example source modifications&#xA;├── include: header files&#xA;├── levels: level scripts, geo layout, and display lists&#xA;├── lib: SDK library code&#xA;├── rsp: audio and Fast3D RSP assembly code&#xA;├── sound: sequences, sound samples, and sound banks&#xA;├── src: C source code for game&#xA;│   ├── audio: audio code&#xA;│   ├── buffers: stacks, heaps, and task buffers&#xA;│   ├── engine: script processing engines and utils&#xA;│   ├── game: behaviors and rest of game source&#xA;│   ├── goddard: Mario intro screen&#xA;│   └── menu: title screen and file, act, and debug level selection menus&#xA;├── text: dialog, level names, act names&#xA;├── textures: skybox and generic texture data&#xA;└── tools: build tools&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;clang-format&lt;/code&gt; on your code to ensure it meets the project&#39;s coding standards.&lt;/p&gt; &#xA;&lt;p&gt;Official Discord: &lt;a href=&#34;https://discord.gg/DuYH3Fh&#34;&gt;discord.gg/DuYH3Fh&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>