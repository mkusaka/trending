<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-31T01:44:02Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>stephane/libmodbus</title>
    <updated>2024-03-31T01:44:02Z</updated>
    <id>tag:github.com,2024-03-31:/stephane/libmodbus</id>
    <link href="https://github.com/stephane/libmodbus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Modbus library for Linux, Mac OS, FreeBSD and Windows&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A groovy modbus library&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/stephane/libmodbus/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;libmodbus is a free software library to send/receive data with a device which respects the Modbus protocol. This library can use a serial port or an Ethernet connection.&lt;/p&gt; &#xA;&lt;p&gt;The functions included in the library have been derived from the Modicon Modbus Protocol Reference Guide which can be obtained from &lt;a href=&#34;http://www.modbus.org&#34;&gt;www.modbus.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The license of libmodbus is &lt;em&gt;LGPL v2.1 or later&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The official website is &lt;a href=&#34;http://www.libmodbus.org&#34;&gt;www.libmodbus.org&lt;/a&gt;. The website contains the latest version of the documentation.&lt;/p&gt; &#xA;&lt;p&gt;The library is written in C and designed to run on Linux, Mac OS X, FreeBSD, Embox, QNX and Windows.&lt;/p&gt; &#xA;&lt;p&gt;You can use the library on MCUs with Embox RTOS.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You will only need to install automake, autoconf, libtool and a C compiler (gcc or clang) to compile the library and asciidoc and xmlto to generate the documentation (optional).&lt;/p&gt; &#xA;&lt;p&gt;To install, just run the usual dance, &lt;code&gt;./configure &amp;amp;&amp;amp; make install&lt;/code&gt;. Run &lt;code&gt;./autogen.sh&lt;/code&gt; first to generate the &lt;code&gt;configure&lt;/code&gt; script if required.&lt;/p&gt; &#xA;&lt;p&gt;You can change installation directory with prefix option, eg. &lt;code&gt;./configure --prefix=/usr/local/&lt;/code&gt;. You have to check that the installation library path is properly set up on your system (&lt;em&gt;/etc/ld.so.conf.d&lt;/em&gt;) and library cache is up to date (run &lt;code&gt;ldconfig&lt;/code&gt; as root if required).&lt;/p&gt; &#xA;&lt;p&gt;The library provides a &lt;em&gt;libmodbus.pc&lt;/em&gt; file to use with &lt;code&gt;pkg-config&lt;/code&gt; to ease your program compilation and linking.&lt;/p&gt; &#xA;&lt;p&gt;If you want to compile with Microsoft Visual Studio, you should follow the instructions in &lt;code&gt;./src/win32/README.md&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To compile under Windows, install &lt;a href=&#34;http://www.mingw.org/&#34;&gt;MinGW&lt;/a&gt; and MSYS then select the common packages (gcc, automake, libtool, etc). The directory &lt;em&gt;./src/win32/&lt;/em&gt; contains a Visual C project.&lt;/p&gt; &#xA;&lt;p&gt;To compile under OS X with &lt;a href=&#34;http://mxcl.github.com/homebrew/&#34;&gt;homebrew&lt;/a&gt;, you will need to install the following dependencies first: &lt;code&gt;brew install autoconf automake libtool&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To build under Embox, you have to use its build system.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Some tests are provided in &lt;em&gt;tests&lt;/em&gt; directory, you can freely edit the source code to fit your needs (it&#39;s Free Software :).&lt;/p&gt; &#xA;&lt;p&gt;See &lt;em&gt;tests/README&lt;/em&gt; for a description of each program.&lt;/p&gt; &#xA;&lt;p&gt;For a quick test of libmodbus, you can run the following programs in two shells:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;./unit-test-server&lt;/li&gt; &#xA; &lt;li&gt;./unit-test-client&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;By default, all TCP unit tests will be executed (see --help for options).&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also possible to run the unit tests with &lt;code&gt;make check&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;To report a bug or to contribute&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/stephane/libmodbus/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;You can serve the local documentation with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install mkdocs-material&#xA;mkdocs serve&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>cecio/USBvalve</title>
    <updated>2024-03-31T01:44:02Z</updated>
    <id>tag:github.com,2024-03-31:/cecio/USBvalve</id>
    <link href="https://github.com/cecio/USBvalve" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Expose USB activity on the fly&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img width=&#34;300&#34; alt=&#34;logo, landscape, dark text, transparent background&#34; src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/USBvalve_logo_scaled.png&#34;&gt;&lt;/h1&gt; &#xA;&lt;h3&gt;&lt;em&gt;Expose USB activity on the fly&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/versions.png&#34; alt=&#34;The two models&#34; width=&#34;30%&#34; height=&#34;30%&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/USBvalve_PIWATCH.png&#34; alt=&#34;The Watch&#34; width=&#34;26%&#34; height=&#34;26%&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/version1_2.png&#34; alt=&#34;1.2&#34; width=&#34;26%&#34; height=&#34;26%&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;I&#39;m sure that, like me, you were asked to put your USB drive in an &lt;em&gt;unknown&lt;/em&gt; device...and then the doubt:&lt;/p&gt; &#xA;&lt;p&gt;what happened to my poor dongle, behind the scene? Stealing my files? Encrypting them? Or &lt;em&gt;just&lt;/em&gt; installing a malware? With &lt;strong&gt;USBvalve&lt;/strong&gt; you can spot this out in seconds: built on super cheap off-the-shelf hardware you can quickly test any USB file system activity and understand what is going on before it&#39;s too late!&lt;/p&gt; &#xA;&lt;p&gt;With &lt;strong&gt;USBvalve&lt;/strong&gt; you can have an immediate feedback about what happen to the drive; the screen will show you if the &lt;em&gt;fake&lt;/em&gt; filesystem built on the device is accessed, read or written:&lt;/p&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/selftest.png&#34; alt=&#34;Selftest&#34; width=&#34;15%&#34; height=&#34;15%&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/readme.png&#34; alt=&#34;Readme&#34; width=&#34;15%&#34; height=&#34;15%&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;and from version &lt;code&gt;0.8.0&lt;/code&gt; you can also use it as USB Host to detect &lt;em&gt;BADUSB&lt;/em&gt; devices:&lt;/p&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/hid.png&#34; alt=&#34;HID&#34; width=&#34;15%&#34; height=&#34;15%&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;This is an example of the &lt;em&gt;BADUSB&lt;/em&gt; debugger available on serial port:&lt;/p&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;a href=&#34;https://asciinema.org/a/NWfC9Mvzzpj3eZfsC7s5Dz1sJ&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/NWfC9Mvzzpj3eZfsC7s5Dz1sJ.svg?sanitize=true&#34; width=&#34;65%&#34; height=&#34;65%&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;If you prefer videos, you can also have a look to my &lt;a href=&#34;https://www.youtube.com/watch?v=jy1filtQY4w&#34;&gt;Insomni&#39;hack Presentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;USBvalve Watch&lt;/h2&gt; &#xA;&lt;p&gt;Starting from version &lt;code&gt;0.15.0&lt;/code&gt; a new &lt;em&gt;Pi Pico Watch&lt;/em&gt; version is supported. To compile the new version you have to uncomment the &lt;code&gt;#define PIWATCH&lt;/code&gt; line at the beginning of the code. The hardware is a RP2040-based 1.28-inch TFT display and watch board. You can find some more info &lt;a href=&#34;https://www.raspberrypi.com/news/how-to-build-your-own-raspberry-pi-watch/&#34;&gt;here&lt;/a&gt;. This is also fully compatible with the &lt;a href=&#34;https://www.waveshare.com/wiki/RP2040-LCD-1.28&#34;&gt;Waveshare RP2040-LCD-1.28&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Repository Structure&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;docs&lt;/code&gt;: documentation about the project, with a presentation where you can have a look to all the features&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;firmware&lt;/code&gt;: pre-built firmware for the Raspberry Pi Pico. You can just use these and flash them on the board. I prepared the two versions for 32 and 64 OLED versions&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PCB&lt;/code&gt;: Gerber file if you want to print the custom PCB . It&#39;s not mandatory, you can use your own or build it on a breadboard&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;USBvalve&lt;/code&gt;: sources, if you want to modify and build the firmware by yourself&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;utils&lt;/code&gt;: some utilities you may use to build a custom FS&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pictures&lt;/code&gt;: images and resources used in this doc&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;STL&lt;/code&gt;: STL files for enclosure. In &lt;code&gt;1.1&lt;/code&gt; and &lt;code&gt;1.2&lt;/code&gt; folders there are full enclosures (thanks to &lt;a href=&#34;https://github.com/WhistleMaster&#34;&gt;WhistleMaster&lt;/a&gt;). If you want something lighter to protect the LCD you can go with &lt;code&gt;USBvalve_sliding_cover.stl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Build USBvalve&lt;/h2&gt; &#xA;&lt;h3&gt;Part list&lt;/h3&gt; &#xA;&lt;p&gt;If you want to build your own, you need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A Raspberry Pi Pico (or another RP2040 based board, like Arduino Nano RP2040)&lt;/li&gt; &#xA; &lt;li&gt;an I2C OLED screen 128x64 or 128x32&lt;/li&gt; &#xA; &lt;li&gt;(optional) a &lt;strong&gt;USBvalve&lt;/strong&gt; PCB or a breadboard&lt;/li&gt; &#xA; &lt;li&gt;(optional) a 3D printed spacer to isolate the screen from the board (&lt;a href=&#34;https://www.thingiverse.com/thing:4748043&#34;&gt;https://www.thingiverse.com/thing:4748043&lt;/a&gt;), but you can use a piece of electrical tape instead&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building instructions&lt;/h3&gt; &#xA;&lt;p&gt;Almost all the job is done directly on the board by the software, so you just need to arrange the connection with the OLED for output.&lt;/p&gt; &#xA;&lt;p&gt;Starting from version 0.8.0 of the firmware, &lt;strong&gt;USBvalve&lt;/strong&gt; can detect HID devices (used to detect &lt;em&gt;BADUSB&lt;/em&gt;). This require an additional USB port behaving as Host. If you are not interested in this, you can use the old instructions &lt;a href=&#34;https://github.com/cecio/USBvalve/raw/main/docs/BUILDING-1.1.md&#34;&gt;in docs folder&lt;/a&gt; and use PCB version &lt;code&gt;1.1&lt;/code&gt;. Otherwise go ahead with PCB version &lt;code&gt;1.2&lt;/code&gt; (we have version for USB-A or USB-B, see folder).&lt;/p&gt; &#xA;&lt;h4&gt;With USBvalve PCB&lt;/h4&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/USB_valve_1-2_front.png&#34; width=&#34;25%&#34; height=&#34;25%&#34;&gt; &lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/USB_valve_1-2_back.png&#34; width=&#34;24%&#34; height=&#34;24%&#34;&gt; &lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;solder a USB female port in &lt;code&gt;USBH&lt;/code&gt; area. This is for version &lt;code&gt;A&lt;/code&gt;, but there is a version for USB &lt;code&gt;Micro-B&lt;/code&gt; as well if you prefer&lt;/li&gt; &#xA; &lt;li&gt;place the Raspberry Pi Pico on the silk screen on the front&lt;/li&gt; &#xA; &lt;li&gt;you don&#39;t need to solder all the PINs. Just the following: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;D4 and D5 (left side)&lt;/li&gt; &#xA;   &lt;li&gt;D14 and D15 (left side)&lt;/li&gt; &#xA;   &lt;li&gt;GND (right side, third pin from the top)&lt;/li&gt; &#xA;   &lt;li&gt;GND (right side, third pin from the bottom)&lt;/li&gt; &#xA;   &lt;li&gt;3v3_OUT (right side)&lt;/li&gt; &#xA;   &lt;li&gt;VBUS (right side)&lt;/li&gt; &#xA;   &lt;li&gt;the 3 DEBUG pin on the bottom: SWCLK, GND and SWDIO&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;place the 3D printer spacer or a piece of tape on the parts of the OLED that my touch the Raspberry&lt;/li&gt; &#xA; &lt;li&gt;solder the OLED (with a header) on the 4 PIN space&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some of the OLEDs have the GND and VCC PINs swapped, so I built the PCB to be compatible with both versions:&lt;/p&gt; &#xA;&lt;p&gt;For example if your OLED has GND on PIN1 and VCC on PIN2 like this:&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/usb_valve_oled.png&#34; width=&#34;35%&#34; height=&#34;35%&#34;&gt; &#xA;&lt;p&gt;You have to place a blob of solder on these two pads on the back of the PCB:&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/usb_valve_pads.png&#34; width=&#34;15%&#34; height=&#34;15%&#34;&gt; &#xA;&lt;p&gt;Otherwise you should the opposite and place the solder on the other PADs:&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/usb_valve_pads_2.png&#34; width=&#34;15%&#34; height=&#34;15%&#34;&gt; &#xA;&lt;h4&gt;Without USBvalve PCB&lt;/h4&gt; &#xA;&lt;img src=&#34;https://github.com/cecio/USBvalve/raw/main/pictures/pico-pinout.svg?sanitize=true&#34; alt=&#34;Pico Pi&#34; width=&#34;85%&#34; height=&#34;85%&#34;&gt; &#xA;&lt;p&gt;If you are using a breadboard or just wiring, all you have to do is to ensure to connect the proper PINs at the OLED screen and to the Host USB port.&lt;/p&gt; &#xA;&lt;p&gt;The mapping is the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PIN6 of Pi --&amp;gt; OLED SDA&lt;/li&gt; &#xA; &lt;li&gt;PIN7 of Pi --&amp;gt; OLED SCL&lt;/li&gt; &#xA; &lt;li&gt;PIN19 of Pi --&amp;gt; D+ of USB Host&lt;/li&gt; &#xA; &lt;li&gt;PIN20 of Pi --&amp;gt; D- of USB Host&lt;/li&gt; &#xA; &lt;li&gt;PIN23 (GND) of Pi --&amp;gt; GND of USB Host&lt;/li&gt; &#xA; &lt;li&gt;PIN38 (GND) of Pi --&amp;gt; OLED GND&lt;/li&gt; &#xA; &lt;li&gt;PIN36 (3V3OUT) of Pi --&amp;gt; OLED VCC&lt;/li&gt; &#xA; &lt;li&gt;PIN40 (VBUS) of Pi --&amp;gt; VCC of USB Host&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to use the DEBUG functions, you can also place a header on the 3 SWD PINs at the bottom of the board.&lt;/p&gt; &#xA;&lt;h3&gt;Flash Firmware&lt;/h3&gt; &#xA;&lt;p&gt;To flash the firmware, follow these steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Connect the Raspberry Pi Pico with the USB cable, by keeping the &lt;em&gt;BOOTSEL&lt;/em&gt; button pressed (the big white button on the board)&lt;/li&gt; &#xA; &lt;li&gt;release the button&lt;/li&gt; &#xA; &lt;li&gt;you will see a new drive on the system, named &lt;code&gt;RPI-RP2&lt;/code&gt; (in Linux envs you may have to manually mount it)&lt;/li&gt; &#xA; &lt;li&gt;copy the proper firmware file (with extension &lt;code&gt;uf2&lt;/code&gt;) in the folder, depending on the OLED you used&lt;/li&gt; &#xA; &lt;li&gt;wait few seconds until the mounted folder disappear&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It&#39;s done!&lt;/p&gt; &#xA;&lt;h3&gt;Anti-Detection&lt;/h3&gt; &#xA;&lt;p&gt;I don&#39;t know if it will ever be the case, but you may want to customize the firmware in order to avoid detection done by &lt;em&gt;USBvalve-aware&lt;/em&gt; malware :-)&lt;/p&gt; &#xA;&lt;p&gt;I grouped most of the variables you may want to modify in this section (&lt;a href=&#34;https://github.com/cecio/USBvalve#dockerfile&#34;&gt;see Dockerfile below for rebuilding&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Anti-Detection settings.&#xA;//&#xA;// Set USB IDs strings and numbers, to avoid possible detections.&#xA;// Remember that you can cusotmize FAKE_DISK_BLOCK_NUM as well&#xA;// for the same reason. Also DISK_LABEL in ramdisk.h can be changed.&#xA;//&#xA;// You can see here for inspiration: https://the-sz.com/products/usbid/&#xA;//&#xA;// Example:&#xA;//             0x0951 0x16D5    VENDORID_STR: Kingston   PRODUCTID_STR: DataTraveler&#xA;//&#xA;#define USB_VENDORID 0x0951               // This override the Pi Pico default 0x2E8A&#xA;#define USB_PRODUCTID 0x16D5              // This override the Pi Pico default 0x000A&#xA;#define USB_DESCRIPTOR &#34;DataTraveler&#34;     // This override the Pi Pico default &#34;Pico&#34;&#xA;#define USB_MANUF &#34;Kingston&#34;              // This override the Pi Pico default &#34;Raspberry Pi&#34;&#xA;#define USB_SERIAL &#34;123456789A&#34;           // This override the Pi Pico default. Disabled by default. \&#xA;                                          // See &#34;setSerialDescriptor&#34; in setup() if needed&#xA;#define USB_VENDORID_STR &#34;Kingston&#34;       // Up to 8 chars&#xA;#define USB_PRODUCTID_STR &#34;DataTraveler&#34;  // Up to 16 chars&#xA;#define USB_VERSION_STR &#34;1.0&#34;             // Up to 4 chars&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building your firmware&lt;/h3&gt; &#xA;&lt;p&gt;Obviously you can also build your own firmware. To build the &lt;em&gt;standard&lt;/em&gt; one I used:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Arduino IDE &lt;code&gt;2.3.2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Adafruit TinyUSB Library&lt;/code&gt; version &lt;code&gt;3.1.1&lt;/code&gt;, &lt;code&gt;Pico-PIO-USB&lt;/code&gt; version &lt;code&gt;0.5.2&lt;/code&gt;, Board &lt;code&gt;Raspberry Pi RP2040 (3.7.2)&lt;/code&gt; setting Tools=&amp;gt;CPU Speed at &lt;code&gt;120MHz&lt;/code&gt; and Tools=&amp;gt;USB Stack to &lt;code&gt;Adafruit TinyUSB&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ssd1306&lt;/code&gt; OLED library version &lt;code&gt;1.8.3&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to re-create a new fake filesystem, you may want to have a look to the &lt;code&gt;utils&lt;/code&gt; folder, where I placed some utilities to build a new one.&lt;/p&gt; &#xA;&lt;h4&gt;Dockerfile&lt;/h4&gt; &#xA;&lt;p&gt;If you want to build your own firmware, after you customized it, I provide a &lt;code&gt;Dockerfile&lt;/code&gt; which builds a complete &lt;strong&gt;Arduino&lt;/strong&gt; environment and compile the firmware. Enter the following commands in the main &lt;code&gt;USBvalve&lt;/code&gt; folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker build -t usbvalve/arduino-cli .&#xA;docker run --rm --name usbvalve -v $PWD:/mnt usbvalve/arduino-cli /mnt/USBvalve &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The firmware will be placed with extension &lt;code&gt;uf2&lt;/code&gt; in folder &lt;code&gt;USBvalve_out&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Contribute&lt;/h3&gt; &#xA;&lt;p&gt;If you have ideas or improvements in your mind, I encourage you to open an issue so that we can improve the project together! Thanks!&lt;/p&gt; &#xA;&lt;h3&gt;Support&lt;/h3&gt; &#xA;&lt;p&gt;If you have question or need support you can open an &lt;code&gt;Issue&lt;/code&gt; here or reach me out on Twitter/X &lt;a href=&#34;https://twitter.com/red5heep&#34;&gt;@red5heep&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;SAFETY WARNING&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;ve received a lot of questions about &lt;strong&gt;USBvalve&lt;/strong&gt; and &lt;em&gt;USB killer devices&lt;/em&gt;. &lt;strong&gt;USBvalve&lt;/strong&gt; is not built to test these devices, it has not any kind of insulation or protection, so if you have the suspect you are dealing with one of these devices, test it with something else, NOT with &lt;strong&gt;USBvalve&lt;/strong&gt; or you may damage the device, yourself or objects near to you.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>spdk/spdk</title>
    <updated>2024-03-31T01:44:02Z</updated>
    <id>tag:github.com,2024-03-31:/spdk/spdk</id>
    <link href="https://github.com/spdk/spdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Storage Performance Development Kit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Storage Performance Development Kit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/spdk/spdk/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/spdk/spdk?style=flat-square&amp;amp;color=blue&amp;amp;label=License&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/spdk/spdk&#34;&gt;&lt;img src=&#34;https://travis-ci.org/spdk/spdk.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://godoc.org/github.com/spdk/spdk/go/rpc&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/godoc-reference-blue.svg?sanitize=true&#34; alt=&#34;Go Doc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/spdk/spdk/go/rpc&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/spdk/spdk/go/rpc&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;NOTE: The SPDK mailing list has moved to a new location. Please visit &lt;a href=&#34;https://lists.linuxfoundation.org/mailman/listinfo/spdk&#34;&gt;this URL&lt;/a&gt; to subscribe at the new location. Subscribers from the old location will not be automatically migrated to the new location.&lt;/p&gt; &#xA;&lt;p&gt;The Storage Performance Development Kit (&lt;a href=&#34;http://www.spdk.io&#34;&gt;SPDK&lt;/a&gt;) provides a set of tools and libraries for writing high performance, scalable, user-mode storage applications. It achieves high performance by moving all of the necessary drivers into userspace and operating in a polled mode instead of relying on interrupts, which avoids kernel context switches and eliminates interrupt handling overhead.&lt;/p&gt; &#xA;&lt;p&gt;The development kit currently includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.spdk.io/doc/nvme.html&#34;&gt;NVMe driver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.spdk.io/doc/ioat.html&#34;&gt;I/OAT (DMA engine) driver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.spdk.io/doc/nvmf.html&#34;&gt;NVMe over Fabrics target&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.spdk.io/doc/iscsi.html&#34;&gt;iSCSI target&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.spdk.io/doc/vhost.html&#34;&gt;vhost target&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.spdk.io/doc/virtio.html&#34;&gt;Virtio-SCSI driver&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;In this readme&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#prerequisites&#34;&gt;Prerequisites&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#source&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#libraries&#34;&gt;Build&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#tests&#34;&gt;Unit Tests&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#vagrant&#34;&gt;Vagrant&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#aws&#34;&gt;AWS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#advanced&#34;&gt;Advanced Build Options&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#shared&#34;&gt;Shared libraries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#huge&#34;&gt;Hugepages and Device Binding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#examples&#34;&gt;Example Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spdk/spdk/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a id=&#34;documentation&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.spdk.io/doc/&#34;&gt;Doxygen API documentation&lt;/a&gt; is available, as well as a &lt;a href=&#34;http://www.spdk.io/doc/porting.html&#34;&gt;Porting Guide&lt;/a&gt; for porting SPDK to different frameworks and operating systems.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;source&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Source Code&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;git clone https://github.com/spdk/spdk&#xA;cd spdk&#xA;git submodule update --init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;prerequisites&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;The dependencies can be installed automatically by &lt;code&gt;scripts/pkgdep.sh&lt;/code&gt;. The &lt;code&gt;scripts/pkgdep.sh&lt;/code&gt; script will automatically install the bare minimum dependencies required to build SPDK. Use &lt;code&gt;--help&lt;/code&gt; to see information on installing dependencies for optional components&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./scripts/pkgdep.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;libraries&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./configure&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;FreeBSD: Note: Make sure you have the matching kernel source in /usr/src/ and also note that CONFIG_COVERAGE option is not available right now for FreeBSD builds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./configure&#xA;gmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;tests&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Unit Tests&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./test/unit/unittest.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will see several error messages when running the unit tests, but they are part of the test suite. The final message at the end of the script indicates success or failure.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;vagrant&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Vagrant&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://www.vagrantup.com/downloads.html&#34;&gt;Vagrant&lt;/a&gt; setup is also provided to create a Linux VM with a virtual NVMe controller to get up and running quickly. Currently this has been tested on MacOS, Ubuntu 16.04.2 LTS and Ubuntu 18.04.3 LTS with the VirtualBox and Libvirt provider. The &lt;a href=&#34;https://www.virtualbox.org/wiki/Downloads&#34;&gt;VirtualBox Extension Pack&lt;/a&gt; or [Vagrant Libvirt] (&lt;a href=&#34;https://github.com/vagrant-libvirt/vagrant-libvirt&#34;&gt;https://github.com/vagrant-libvirt/vagrant-libvirt&lt;/a&gt;) must also be installed in order to get the required NVMe support.&lt;/p&gt; &#xA;&lt;p&gt;Details on the Vagrant setup can be found in the &lt;a href=&#34;http://spdk.io/doc/vagrant.html&#34;&gt;SPDK Vagrant documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;aws&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;AWS&lt;/h2&gt; &#xA;&lt;p&gt;The following setup is known to work on AWS: Image: Ubuntu 18.04 Before running &lt;code&gt;setup.sh&lt;/code&gt;, run &lt;code&gt;modprobe vfio-pci&lt;/code&gt; then: &lt;code&gt;DRIVER_OVERRIDE=vfio-pci ./setup.sh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;advanced&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Advanced Build Options&lt;/h2&gt; &#xA;&lt;p&gt;Optional components and other build-time configuration are controlled by settings in the Makefile configuration file in the root of the repository. &lt;code&gt;CONFIG&lt;/code&gt; contains the base settings for the &lt;code&gt;configure&lt;/code&gt; script. This script generates a new file, &lt;code&gt;mk/config.mk&lt;/code&gt;, that contains final build settings. For advanced configuration, there are a number of additional options to &lt;code&gt;configure&lt;/code&gt; that may be used, or &lt;code&gt;mk/config.mk&lt;/code&gt; can simply be created and edited by hand. A description of all possible options is located in &lt;code&gt;CONFIG&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Boolean (on/off) options are configured with a &#39;y&#39; (yes) or &#39;n&#39; (no). For example, this line of &lt;code&gt;CONFIG&lt;/code&gt; controls whether the optional RDMA (libibverbs) support is enabled:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;CONFIG_RDMA?=n&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To enable RDMA, this line may be added to &lt;code&gt;mk/config.mk&lt;/code&gt; with a &#39;y&#39; instead of &#39;n&#39;. For the majority of options this can be done using the &lt;code&gt;configure&lt;/code&gt; script. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./configure --with-rdma&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, &lt;code&gt;CONFIG&lt;/code&gt; options may also be overridden on the &lt;code&gt;make&lt;/code&gt; command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;make CONFIG_RDMA=y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Users may wish to use a version of DPDK different from the submodule included in the SPDK repository. Note, this includes the ability to build not only from DPDK sources, but also just with the includes and libraries installed via the dpdk and dpdk-devel packages. To specify an alternate DPDK installation, run configure with the --with-dpdk option. For example:&lt;/p&gt; &#xA;&lt;p&gt;Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./configure --with-dpdk=/path/to/dpdk/x86_64-native-linuxapp-gcc&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;FreeBSD:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./configure --with-dpdk=/path/to/dpdk/x86_64-native-bsdapp-clang&#xA;gmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The options specified on the &lt;code&gt;make&lt;/code&gt; command line take precedence over the values in &lt;code&gt;mk/config.mk&lt;/code&gt;. This can be useful if you, for example, generate a &lt;code&gt;mk/config.mk&lt;/code&gt; using the &lt;code&gt;configure&lt;/code&gt; script and then have one or two options (i.e. debug builds) that you wish to turn on and off frequently.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;shared&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Shared libraries&lt;/h2&gt; &#xA;&lt;p&gt;By default, the build of the SPDK yields static libraries against which the SPDK applications and examples are linked. Configure option &lt;code&gt;--with-shared&lt;/code&gt; provides the ability to produce SPDK shared libraries, in addition to the default static ones. Use of this flag also results in the SPDK executables linked to the shared versions of libraries. SPDK shared libraries by default, are located in &lt;code&gt;./build/lib&lt;/code&gt;. This includes the single SPDK shared lib encompassing all of the SPDK static libs (&lt;code&gt;libspdk.so&lt;/code&gt;) as well as individual SPDK shared libs corresponding to each of the SPDK static ones.&lt;/p&gt; &#xA;&lt;p&gt;In order to start a SPDK app linked with SPDK shared libraries, make sure to do the following steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;run ldconfig specifying the directory containing SPDK shared libraries&lt;/li&gt; &#xA; &lt;li&gt;provide proper &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If DPDK shared libraries are used, you may also need to add DPDK shared libraries to &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;./configure --with-shared&#xA;make&#xA;ldconfig -v -n ./build/lib&#xA;LD_LIBRARY_PATH=./build/lib/:./dpdk/build/lib/ ./build/bin/spdk_tgt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;huge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hugepages and Device Binding&lt;/h2&gt; &#xA;&lt;p&gt;Before running an SPDK application, some hugepages must be allocated and any NVMe and I/OAT devices must be unbound from the native kernel drivers. SPDK includes a script to automate this process on both Linux and FreeBSD. This script should be run as root.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;sudo scripts/setup.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Users may wish to configure a specific memory size. Below is an example of configuring 8192MB memory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;sudo HUGEMEM=8192 scripts/setup.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a lot of other environment variables that can be set to configure setup.sh for advanced users. To see the full list, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{.sh}&#34;&gt;scripts/setup.sh --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;targets&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Target applications&lt;/h2&gt; &#xA;&lt;p&gt;After completing the build process, SPDK target applications can be found in &lt;code&gt;spdk/build/bin&lt;/code&gt; directory:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://spdk.io/doc/nvmf.html&#34;&gt;nvmf_tgt&lt;/a&gt; - SPDK NVMe over Fabrics target presents block devices over a fabrics,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://spdk.io/doc/iscsi.html&#34;&gt;iscsi_tgt&lt;/a&gt; - SPDK iSCSI target runs I/O operations remotely with TCP/IP protocol,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://spdk.io/doc/vhost.html&#34;&gt;vhost&lt;/a&gt; - A vhost target provides a local storage service as a process running on a local machine,&lt;/li&gt; &#xA; &lt;li&gt;spdk_tgt - combines capabilities of all three applications.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SPDK runs in a polled mode, which means it continuously checks for operation completions. This approach assures faster response than interrupt mode, but also lessens usefulness of tools like &lt;code&gt;top&lt;/code&gt;, which only shows 100% CPU usage for SPDK assigned cores. &lt;a href=&#34;https://spdk.io/doc/spdk_top.html&#34;&gt;spdk_top&lt;/a&gt; is a program which simulates &lt;code&gt;top&lt;/code&gt; application and uses SPDK&#39;s &lt;a href=&#34;https://spdk.io/doc/jsonrpc.html&#34;&gt;JSON RPC&lt;/a&gt; interface to present statistics about SPDK threads, pollers and CPU cores as an interactive list.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;examples&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example Code&lt;/h2&gt; &#xA;&lt;p&gt;Example code is located in the examples directory. The examples are compiled automatically as part of the build process. Simply call any of the examples with no arguments to see the help output. You&#39;ll likely need to run the examples as a privileged user (root) unless you&#39;ve done additional configuration to grant your user permission to allocate huge pages and map devices through vfio.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;contributing&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;For additional details on how to get more involved in the community, including &lt;a href=&#34;http://www.spdk.io/development&#34;&gt;contributing code&lt;/a&gt; and participating in discussions and other activities, please refer to &lt;a href=&#34;http://www.spdk.io/community&#34;&gt;spdk.io&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>