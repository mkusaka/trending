<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-09T01:49:13Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>DoctorWkt/acwj</title>
    <updated>2023-04-09T01:49:13Z</updated>
    <id>tag:github.com,2023-04-09:/DoctorWkt/acwj</id>
    <link href="https://github.com/DoctorWkt/acwj" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Compiler Writing Journey&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A Compiler Writing Journey&lt;/h1&gt; &#xA;&lt;p&gt;In this Github repository, I&#39;m documenting my journey to write a self-compiling compiler for a subset of the C language. I&#39;m also writing out the details so that, if you want to follow along, there will be an explanation of what I did, why, and with some references back to the theory of compilers.&lt;/p&gt; &#xA;&lt;p&gt;But not too much theory, I want this to be a practical journey.&lt;/p&gt; &#xA;&lt;p&gt;Here are the steps I&#39;ve taken so far:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/00_Introduction/Readme.md&#34;&gt;Part 0&lt;/a&gt;: Introduction to the Journey&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/01_Scanner/Readme.md&#34;&gt;Part 1&lt;/a&gt;: Introduction to Lexical Scanning&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/02_Parser/Readme.md&#34;&gt;Part 2&lt;/a&gt;: Introduction to Parsing&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/03_Precedence/Readme.md&#34;&gt;Part 3&lt;/a&gt;: Operator Precedence&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/04_Assembly/Readme.md&#34;&gt;Part 4&lt;/a&gt;: An Actual Compiler&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/05_Statements/Readme.md&#34;&gt;Part 5&lt;/a&gt;: Statements&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/06_Variables/Readme.md&#34;&gt;Part 6&lt;/a&gt;: Variables&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/07_Comparisons/Readme.md&#34;&gt;Part 7&lt;/a&gt;: Comparison Operators&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/08_If_Statements/Readme.md&#34;&gt;Part 8&lt;/a&gt;: If Statements&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/09_While_Loops/Readme.md&#34;&gt;Part 9&lt;/a&gt;: While Loops&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/10_For_Loops/Readme.md&#34;&gt;Part 10&lt;/a&gt;: For Loops&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/11_Functions_pt1/Readme.md&#34;&gt;Part 11&lt;/a&gt;: Functions, part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/12_Types_pt1/Readme.md&#34;&gt;Part 12&lt;/a&gt;: Types, part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/13_Functions_pt2/Readme.md&#34;&gt;Part 13&lt;/a&gt;: Functions, part 2&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/14_ARM_Platform/Readme.md&#34;&gt;Part 14&lt;/a&gt;: Generating ARM Assembly Code&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/15_Pointers_pt1/Readme.md&#34;&gt;Part 15&lt;/a&gt;: Pointers, part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/16_Global_Vars/Readme.md&#34;&gt;Part 16&lt;/a&gt;: Declaring Global Variables Properly&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/17_Scaling_Offsets/Readme.md&#34;&gt;Part 17&lt;/a&gt;: Better Type Checking and Pointer Offsets&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/18_Lvalues_Revisited/Readme.md&#34;&gt;Part 18&lt;/a&gt;: Lvalues and Rvalues Revisited&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/19_Arrays_pt1/Readme.md&#34;&gt;Part 19&lt;/a&gt;: Arrays, part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/20_Char_Str_Literals/Readme.md&#34;&gt;Part 20&lt;/a&gt;: Character and String Literals&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/21_More_Operators/Readme.md&#34;&gt;Part 21&lt;/a&gt;: More Operators&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/22_Design_Locals/Readme.md&#34;&gt;Part 22&lt;/a&gt;: Design Ideas for Local Variables and Function Calls&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/23_Local_Variables/Readme.md&#34;&gt;Part 23&lt;/a&gt;: Local Variables&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/24_Function_Params/Readme.md&#34;&gt;Part 24&lt;/a&gt;: Function Parameters&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/25_Function_Arguments/Readme.md&#34;&gt;Part 25&lt;/a&gt;: Function Calls and Arguments&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/26_Prototypes/Readme.md&#34;&gt;Part 26&lt;/a&gt;: Function Prototypes&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/27_Testing_Errors/Readme.md&#34;&gt;Part 27&lt;/a&gt;: Regression Testing and a Nice Surprise&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/28_Runtime_Flags/Readme.md&#34;&gt;Part 28&lt;/a&gt;: Adding More Run-time Flags&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/29_Refactoring/Readme.md&#34;&gt;Part 29&lt;/a&gt;: A Bit of Refactoring&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/30_Design_Composites/Readme.md&#34;&gt;Part 30&lt;/a&gt;: Designing Structs, Unions and Enums&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/31_Struct_Declarations/Readme.md&#34;&gt;Part 31&lt;/a&gt;: Implementing Structs, Part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/32_Struct_Access_pt1/Readme.md&#34;&gt;Part 32&lt;/a&gt;: Accessing Members in a Struct&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/33_Unions/Readme.md&#34;&gt;Part 33&lt;/a&gt;: Implementing Unions and Member Access&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/34_Enums_and_Typedefs/Readme.md&#34;&gt;Part 34&lt;/a&gt;: Enums and Typedefs&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/35_Preprocessor/Readme.md&#34;&gt;Part 35&lt;/a&gt;: The C Pre-Processor&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/36_Break_Continue/Readme.md&#34;&gt;Part 36&lt;/a&gt;: &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/37_Switch/Readme.md&#34;&gt;Part 37&lt;/a&gt;: Switch Statements&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/38_Dangling_Else/Readme.md&#34;&gt;Part 38&lt;/a&gt;: Dangling Else and More&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/39_Var_Initialisation_pt1/Readme.md&#34;&gt;Part 39&lt;/a&gt;: Variable Initialisation, part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/40_Var_Initialisation_pt2/Readme.md&#34;&gt;Part 40&lt;/a&gt;: Global Variable Initialisation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/41_Local_Var_Init/Readme.md&#34;&gt;Part 41&lt;/a&gt;: Local Variable Initialisation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/42_Casting/Readme.md&#34;&gt;Part 42&lt;/a&gt;: Type Casting and NULL&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/43_More_Operators/Readme.md&#34;&gt;Part 43&lt;/a&gt;: Bugfixes and More Operators&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/44_Fold_Optimisation/Readme.md&#34;&gt;Part 44&lt;/a&gt;: Constant Folding&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/45_Globals_Again/Readme.md&#34;&gt;Part 45&lt;/a&gt;: Global Variable Declarations, revisited&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/46_Void_Functions/Readme.md&#34;&gt;Part 46&lt;/a&gt;: Void Function Parameters and Scanning Changes&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/47_Sizeof/Readme.md&#34;&gt;Part 47&lt;/a&gt;: A Subset of &lt;code&gt;sizeof&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/48_Static/Readme.md&#34;&gt;Part 48&lt;/a&gt;: A Subset of &lt;code&gt;static&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/49_Ternary/Readme.md&#34;&gt;Part 49&lt;/a&gt;: The Ternary Operator&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/50_Mop_up_pt1/Readme.md&#34;&gt;Part 50&lt;/a&gt;: Mopping Up, part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/51_Arrays_pt2/Readme.md&#34;&gt;Part 51&lt;/a&gt;: Arrays, part 2&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/52_Pointers_pt2/Readme.md&#34;&gt;Part 52&lt;/a&gt;: Pointers, part 2&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/53_Mop_up_pt2/Readme.md&#34;&gt;Part 53&lt;/a&gt;: Mopping Up, part 2&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/54_Reg_Spills/Readme.md&#34;&gt;Part 54&lt;/a&gt;: Spilling Registers&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/55_Lazy_Evaluation/Readme.md&#34;&gt;Part 55&lt;/a&gt;: Lazy Evaluation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/56_Local_Arrays/Readme.md&#34;&gt;Part 56&lt;/a&gt;: Local Arrays&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/57_Mop_up_pt3/Readme.md&#34;&gt;Part 57&lt;/a&gt;: Mopping Up, part 3&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/58_Ptr_Increments/Readme.md&#34;&gt;Part 58&lt;/a&gt;: Fixing Pointer Increments/Decrements&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/59_WDIW_pt1/Readme.md&#34;&gt;Part 59&lt;/a&gt;: Why Doesn&#39;t It Work, part 1&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/60_TripleTest/Readme.md&#34;&gt;Part 60&lt;/a&gt;: Passing the Triple Test&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/61_What_Next/Readme.md&#34;&gt;Part 61&lt;/a&gt;: What&#39;s Next?&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/62_Cleanup/Readme.md&#34;&gt;Part 62&lt;/a&gt;: Code Cleanup&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DoctorWkt/acwj/master/63_QBE/Readme.md&#34;&gt;Part 63&lt;/a&gt;: A New Backend using QBE&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There isn&#39;t a schedule or timeline for the future parts, so just keep checking back here to see if I&#39;ve written any more.&lt;/p&gt; &#xA;&lt;h2&gt;Copyrights&lt;/h2&gt; &#xA;&lt;p&gt;I have borrowed some of the code, and lots of ideas, from the &lt;a href=&#34;http://www.t3x.org/subc/&#34;&gt;SubC&lt;/a&gt; compiler written by Nils M Holm. His code is in the public domain. I think that my code is substantially different enough that I can apply a different license to my code.&lt;/p&gt; &#xA;&lt;p&gt;Unless otherwise noted,&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;all source code and scripts are (c) Warren Toomey under the GPL3 license.&lt;/li&gt; &#xA; &lt;li&gt;all non-source code documents (e.g. English documents, image files) are (c) Warren Toomey under the Creative Commons BY-NC-SA 4.0 license.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>peng-zhihui/Dummy-Robot</title>
    <updated>2023-04-09T01:49:13Z</updated>
    <id>tag:github.com,2023-04-09:/peng-zhihui/Dummy-Robot</id>
    <link href="https://github.com/peng-zhihui/Dummy-Robot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;我的超迷你机械臂机器人项目。&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Dummy-Robot: Super compact smart robotic-arm&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;我的超迷你机械臂机器人项目。&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;视频介绍：&lt;a href=&#34;https://www.bilibili.com/video/BV12341117rG&#34;&gt;【自制】我造了一台 钢 铁 侠 的 机 械 臂 ！【硬核】&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;Video : &lt;a href=&#34;https://www.youtube.com/watch?v=F29vrvUwqS4&#34;&gt;I made a DUMMY ROBOTIC ARM from scratch！ - YouTube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/Dummy-Robot/main/5.Docs/1.Images/dummy1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/Dummy-Robot/main/5.Docs/1.Images/case.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;资料说明（更新日期22-2-9）&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;已添加3D模型设计源文件。&lt;/li&gt; &#xA; &lt;li&gt;已添加夹爪硬件设计文件和LED灯环PCB&lt;/li&gt; &#xA; &lt;li&gt;已添加无线空间定位控制器PCB文件&lt;/li&gt; &#xA; &lt;li&gt;已添加无线示教器Peak软硬件工程（作为submodule）&lt;/li&gt; &#xA; &lt;li&gt;已添加REF的硬件设计文件&lt;/li&gt; &#xA; &lt;li&gt;已添加DummyStudio上位机&lt;/li&gt; &#xA; &lt;li&gt;已添加Dummy核心控制器的固件源代码（使用说明见后文）&lt;/li&gt; &#xA; &lt;li&gt;已添加42步进电机驱动器硬件工程&lt;/li&gt; &#xA; &lt;li&gt;已添加20步进电机驱动器硬件工程&lt;/li&gt; &#xA; &lt;li&gt;已添加42/20步进电机驱动的固件源代码&lt;/li&gt; &#xA; &lt;li&gt;已添加命令行调试工具reftool（基于odrivetool框架）&lt;/li&gt; &#xA; &lt;li&gt;已添加便携手提箱的模型文件&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;这是视频中原版机械臂的完整设计方案，该方案成本和制作难度都比较高，因此想复现的同学建议再等等我后面会发布的&lt;strong&gt;Dummy青春版&lt;/strong&gt;，该版本会有如下改进：&lt;/p&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;整机重新设计结构，改用3D打印作为制造方案（原版为铝CNC），大幅降低制造成本&lt;/li&gt; &#xA;  &lt;li&gt;采用我自己设计的小型摆线针轮减速器替代原版的谐波减速器，大幅降低零件成本&lt;/li&gt; &#xA;  &lt;li&gt;所有软件和固件和原版通用，功能也完全一致&lt;/li&gt; &#xA;  &lt;li&gt;添加我自己设计的PC端上位机和手机端APP（争取把用户初始化设置引导加进去）&lt;/li&gt; &#xA;  &lt;li&gt;改进原版电机驱动器的走线方式，原版电源走线采用焊接的形式，不便于安装和拆卸，后面的青春版会使用4p接插件（电源+CAN总线）连接&lt;/li&gt; &#xA;  &lt;li&gt;整机成本争取做到2000以内&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;最重要的，会找人出一个保姆级的视频教程！&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;关于结构设计&lt;/h2&gt; &#xA;&lt;p&gt;我视频中原版设计使用的&lt;code&gt;步进电机&lt;/code&gt;+Harmonic的&lt;code&gt;谐波减速模组&lt;/code&gt;，其中后者成本较高（我买的二手大概是600元一个），因此为了能让大家尽量复现本项目，我后期会添加一个&lt;code&gt;自制摆线针轮减速器&lt;/code&gt;+&lt;code&gt;3D打印&lt;/code&gt;的低成本方案。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;目前摆线减速器已经设计好了正在验证，预期会使用PC（或者亚克力）切割结合3D打印制作，精度有所下降但是功能都保持不变，整机硬件成本希望控制在2000元以内。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;设计好的摆线减速器见我的另一个仓库：&lt;a href=&#34;https://github.com/peng-zhihui/CycloidAcuratorNano&#34;&gt;peng-zhihui/CycloidAcuratorNano &lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/Dummy-Robot/main/5.Docs/1.Images/cycliod-nano.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;关于电路模块&lt;/h2&gt; &#xA;&lt;p&gt;电路为了实现主要的机械臂运动控制功能其实核心就4块板子：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;REF核心板&lt;/li&gt; &#xA; &lt;li&gt;REF底板（也就是机械臂底座里面的控制器电路板）&lt;/li&gt; &#xA; &lt;li&gt;步进电机驱动&lt;/li&gt; &#xA; &lt;li&gt;Peak示教器&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;其中前两者和Peak我都开源了，步进驱动设计的时候参考了： &lt;a href=&#34;https://github.com/unlir/XDrive&#34;&gt;https://github.com/unlir/XDrive&lt;/a&gt; 这个项目，这是我一个朋友开源的闭环驱动，基于STM32。该驱动分为开源版和闭源版，闭源版基于分立MOSFET性能极其强劲且功能很完善，开源版用的ADC+斩波驱动芯片，具备基础功能，不带CAN协议。&lt;/p&gt; &#xA;&lt;p&gt;我重新设计了驱动器的PCB电路（本项目分别用到20、42步进，57的文件只是供大家扩展使用），添加了CAN总线的硬件支持，也对原版核心代码进行了完全重构，&lt;strong&gt;提供编译好的二进制文件可以直接烧录：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/Dummy-Robot/main/5.Docs/1.Images/fw2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;主要改进如下：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;使用C++11重构了代码，引入很多高级语言特性，同时底层部分用C混编，不影响代码性能&lt;/li&gt; &#xA; &lt;li&gt;对硬件依赖完全解耦了，可以方便以后移植到其他平台的MCU，去除了冗余代码代码也结构化逻辑更加清晰&lt;/li&gt; &#xA; &lt;li&gt;添加了CAN协议和UART协议的自定义模板&lt;/li&gt; &#xA; &lt;li&gt;添加了模拟EEPROM的参数储存，可以断电保存数据&lt;/li&gt; &#xA; &lt;li&gt;添加了任意位置设置为零点，且保证双向半圈内归零（而不是单向归零）&lt;/li&gt; &#xA; &lt;li&gt;完全兼容STM32-HAL库，可以使用STM32CubeMX直接生成配置代码&lt;/li&gt; &#xA; &lt;li&gt;其他改进，大家二次开发仅需关注UserApp文件夹下的文件即可&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Ctrl-Step驱动的使用方式比较简单，下载好固件后，第一次上电电机会进行编码器校准，如果成功则下次上电后按下按键1会进入闭环模式，通过CAN或者串口发送指令即可控制电机，关于指令的说明见源代码&lt;code&gt;UserApp&lt;/code&gt;文件夹的&lt;code&gt;interface_can.cpp&lt;/code&gt;和&lt;code&gt;interface_uart.cpp&lt;/code&gt;：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/Dummy-Robot/main/5.Docs/1.Images/fw3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;其他按键的作用：&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;同时按住两个按键上电，会自动进行编码器校准，如果首次校准失败可以通过这个方式重新校准&lt;/li&gt; &#xA;  &lt;li&gt;短按按键1在&lt;strong&gt;使能闭环/失能闭环&lt;/strong&gt;间切换&lt;/li&gt; &#xA;  &lt;li&gt;长按按键1板子重启&lt;/li&gt; &#xA;  &lt;li&gt;短按按键2清除堵转保护&lt;/li&gt; &#xA;  &lt;li&gt;长按按键2将目标值归零（比如如果是在位置模式那位置会归零）&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;其他的功能要通过代码或者通信协议设置，比如设置&lt;strong&gt;home零点&lt;/strong&gt;、&lt;strong&gt;PID参数&lt;/strong&gt;、CAN节点ID、&lt;strong&gt;各种运动参数&lt;/strong&gt;等等，可以自己研究代码。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;当然另一种方式是大家也可以自行使用GRBL类的驱动器改装用来驱动本机械臂，这样方案的问题在于，grbl固件耦合性比较强（毕竟不是针对机械臂而是CNC类应用设计的）不便于扩展，另外脉冲形式的控制方式使得走线极其不优雅（每一个关节都要单独拉&lt;code&gt;step/dir&lt;/code&gt;线到控制器，导致最后几个关节走线很长）。&lt;/p&gt; &#xA;&lt;p&gt;而我用一体闭环的方式则可以以串联的形式把所有电机连起来即可，走CAN总线使得整体走线只需要四根线（电源正负两根，CAN信号线两根），此外总线模型使得电机可以工作在&lt;code&gt;力矩&lt;/code&gt;、&lt;code&gt;速度&lt;/code&gt;、&lt;code&gt;位置&lt;/code&gt;、&lt;code&gt;轨迹&lt;/code&gt;模式下，而脉冲模式只能工作在位置和轨迹模式，无法进行复杂控制。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Peak的话我之前已经软硬件都开源了，可以去SubModules文件夹里面看那边的README说明。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;关于核心固件&lt;/h2&gt; &#xA;&lt;p&gt;这个机械臂的固件核心就是运动学姿态解算，&lt;del&gt;这块我还在整理，后面会封装得更完善一些进行开源&lt;/del&gt;，&lt;strong&gt;已开源&lt;/strong&gt;，现在写死的很多参数会设计成可配置的，&lt;strong&gt;方便大家用本项目学习完后迁移到自己设计的机械臂中&lt;/strong&gt;；同时我把固件从LiteOS框架移植到大家更熟悉的FreeRTOS，方便做二次开发。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;REF的固件使用说明：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;固件主要包括几大功能模块：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;BSP驱动：板载的各种硬件驱动比如OLED、IMU、LED、蜂鸣器、非易失储存等等&lt;/li&gt; &#xA; &lt;li&gt;3rdParty库：包括U8G2的图形库和Fibre的序列化/反序列化库&lt;/li&gt; &#xA; &lt;li&gt;Core：ST官方的HAL库&lt;/li&gt; &#xA; &lt;li&gt;Driver：ARM的CMSIS驱动&lt;/li&gt; &#xA; &lt;li&gt;Midwares：FreeRTOS支持包&lt;/li&gt; &#xA; &lt;li&gt;Robot：核心机器人库，包括各种算法和驱动代码&lt;/li&gt; &#xA; &lt;li&gt;UserApp：上层应用，可以基于我提供的API接口自行开发其他应用&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;其中OLED使用Arduino的U8G2库移植而来，可以方便地现实各种调试和系统信息，另外由于STM32的硬件I2C又BUG这里使用了软件I2C驱动屏幕，实测帧率比硬件I2C更高。&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;DummyRobot&lt;/code&gt;类是Dummy的完整定义所在，初始化的时候需要设置好&lt;strong&gt;步进电机驱动的信息&lt;/strong&gt;以及&lt;strong&gt;自身的DH参数&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/Dummy-Robot/main/5.Docs/1.Images/fw1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;其中驱动器信息包含：CAN节点ID、&lt;strong&gt;是否反向&lt;/strong&gt;、减速器的减速比、&lt;strong&gt;运动限制范围&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;p&gt;而DH参数的含义如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/Dummy-Robot/main/5.Docs/1.Images/fw2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;机械臂的构型需要满足Pieper判据（机器人的三个相邻关节轴交于一点或三轴线平行），才能得出解析解，所以大家可以根据Dummy的结构进行修改，然后自己替换DH参数即可以移植我的代码。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;关于位置的记忆，和上电零点校准：&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;由于绝对值编码器的位置只在一圈内有效，工业机械臂经过减速后为了获取绝对位置一般是做输出端编码，但是这样精度就降低了30倍（减速比），所以更合理的是做&lt;code&gt;双编码器&lt;/code&gt;或者低&lt;code&gt;功耗编码器+电池&lt;/code&gt;；而我这个项目中双编码器影响结构紧凑设计，所以用了更巧妙的方式：利用电机驱动的电流环控制上电后进行低力矩的无零点定向运动，碰到机械臂限位之后确认粗零点（无限位开关归零），然后根据单圈绝对值编码器的位置精调零点。这个方式的零点是没有误差的，而且几乎不受加工精度影响，因为在12度（360/30）内都是绝对值编码器的有效精度范围。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Peak的固件说明：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Peak基于X-Track项目，大家可以去Peak仓库查看。&lt;/p&gt; &#xA;&lt;h2&gt;关于上位机&lt;/h2&gt; &#xA;&lt;p&gt;视频中的软件仿真基于RoboDK，我在视频中开发了连接Dummy的Driver（驱动部分官方document有介绍的，原版是基于TCP网络接口，我修改成了串口并兼容dummy的协议）。不过由于这个软件是收费的，因此我也基于Unity3D开发了自己的上位机，已经发布在仓库。&lt;/p&gt; &#xA;&lt;p&gt;上位机目前暂时没有计划开源，因为还有很多功能要添加，我也是希望最后能做成一个类似RoboDK的通用软件，大家以后自己做机械臂也能用上，当然软件肯定会是免费的。&lt;/p&gt; &#xA;&lt;h2&gt;关于控制算法&lt;/h2&gt; &#xA;&lt;p&gt;首先运动学部分是已经实现了的，正逆解都是传统DH参数计算的，正解（关节角求末端位姿）是唯一解比较好办，逆解（末端位姿求关节角）的话会涉及多解（一般是8个），我这里使用的算法是&lt;strong&gt;求解上一姿态和目标姿态中6个关节变化最大角里面最小的那一组作为逆解采用的config&lt;/strong&gt;。这样可以保证机械臂始终以最小转角进行姿态切换。&lt;/p&gt; &#xA;&lt;p&gt;然后关节角到电机驱动器输入信号的转换这一块，我使用的是梯形加减速曲线进行速度位置规划。举个例子在MoveJ指令中，当收到一个关节角运动指令，控制器会进行运动角度差分计算，得到6个运动差分角度，然后取6个差分角中最大的角θ，同时根据设置的JointSpeed参数计算运动θ角需要的时间（考虑上加减速），把这一时间作为其余5个电机的运动参数计算各自的加减速度&amp;amp;最高速度，然后6个电机根据计算的参数同步运动，就可以保证其同步性和流畅性了。&lt;/p&gt; &#xA;&lt;p&gt;另外六个电机使用CAN总线连接，每个电机接受两个ID号的信息（自己的ID、0号ID），0号ID作为信息广播和同步用。电机接收到运动指令后将信息储存在影子寄存器中，待收到广播的同步信号后开始运动，这样能进一步保证电机同步性。&lt;/p&gt; &#xA;&lt;p&gt;最后，动力学部分还在开发中，这块暂时没有完全实现。上&lt;strong&gt;述的运动学和动力学算法都强烈建议去看一下《机器人学导论》这本书&lt;/strong&gt;，里面写得非常详细。&lt;/p&gt; &#xA;&lt;h2&gt;指令模式&lt;/h2&gt; &#xA;&lt;p&gt;Dummy固件支持三种不同的指令模式（指令可以由USB、串口、CAN接收），不同模式的特性有所区别，见下表：&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;指令发送频率&lt;/th&gt; &#xA;   &lt;th&gt;指令执行方式&lt;/th&gt; &#xA;   &lt;th&gt;可被新指令打断&lt;/th&gt; &#xA;   &lt;th&gt;指令间停顿&lt;/th&gt; &#xA;   &lt;th&gt;适合场景&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SEQ（顺序指令）&lt;/td&gt; &#xA;   &lt;td&gt;随机，低（&amp;lt;5Hz）&lt;/td&gt; &#xA;   &lt;td&gt;FIFO队列依次执行&lt;/td&gt; &#xA;   &lt;td&gt;否&lt;/td&gt; &#xA;   &lt;td&gt;有&lt;/td&gt; &#xA;   &lt;td&gt;一次性发送几个关键点位姿，等待依次执行，可以确保关键点到达；但是由于关键点之间存在减速到0的过程所以存在一定停顿；适合场景例如&lt;strong&gt;视觉抓取、码垛等应用&lt;/strong&gt;。&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;INT（实时指令）&lt;/td&gt; &#xA;   &lt;td&gt;随机，频率不限&lt;/td&gt; &#xA;   &lt;td&gt;指令覆盖，立即执行&lt;/td&gt; &#xA;   &lt;td&gt;是&lt;/td&gt; &#xA;   &lt;td&gt;无&lt;/td&gt; &#xA;   &lt;td&gt;用于实时控制，新指令会覆盖正在执行的指令得到立即响应；但是如果一次性发送一系列指令的话则效果会是只执行最后一条；适合场景例如&lt;strong&gt;动作同步&lt;/strong&gt;。&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ToDo&lt;/code&gt;TRJ（轨迹跟踪）&lt;/td&gt; &#xA;   &lt;td&gt;固定，高（200Hz）&lt;/td&gt; &#xA;   &lt;td&gt;自动插值，固定周期执行&lt;/td&gt; &#xA;   &lt;td&gt;否&lt;/td&gt; &#xA;   &lt;td&gt;无&lt;/td&gt; &#xA;   &lt;td&gt;适合用于需要进行精确轨迹跟踪的应用，速度会放慢；示例场景比如&lt;strong&gt;3D打印、雕刻、绘画等&lt;/strong&gt;。&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;hr&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;感谢以下项目作者：&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/unlir/XDrive&#34;&gt;unlir/XDrive: Stepper motor with multi-function interface and closed loop function. 具有多功能接口和闭环功能的步进电机。 (github.com)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/odriverobotics/ODrive&#34;&gt;odriverobotics/ODrive: High performance motor control (github.com)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/olikraus/u8g2&#34;&gt;olikraus/u8g2: U8glib library for monochrome displays, version 2 (github.com)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/samuelsadok/fibre&#34;&gt;samuelsadok/fibre: Abstraction layer for painlessly building object oriented distributed systems that just work (github.com)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
  <entry>
    <title>RT-Thread/rt-thread</title>
    <updated>2023-04-09T01:49:13Z</updated>
    <id>tag:github.com,2023-04-09:/RT-Thread/rt-thread</id>
    <link href="https://github.com/RT-Thread/rt-thread" rel="alternate"></link>
    <summary type="html">&lt;p&gt;RT-Thread is an open source IoT real-time operating system (RTOS).&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/figures/logo.png&#34; width=&#34;60%&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;English&lt;/strong&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/README_zh.md&#34;&gt;中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/README_es.md&#34;&gt;Español&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/README_de.md&#34;&gt;Deutsch&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/RT-Thread/rt-thread/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/RT-Thread/rt-thread?style=flat-square&amp;amp;logo=GitHub&#34; alt=&#34;GitHubStars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitee.com/rtthread/rt-thread/stargazers&#34;&gt;&lt;img src=&#34;https://gitee.com/rtthread/rt-thread/badge/star.svg?theme=gvp&#34; alt=&#34;GiteeStars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/RT-Thread/rt-thread/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/RT-Thread/rt-thread.svg?sanitize=true&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/RT-Thread/rt-thread/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/RT-Thread/rt-thread.svg?sanitize=true&#34; alt=&#34;GitHub release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/RT-Thread/rt-thread?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/RT-Thread/rt-thread/pulls&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues-pr/RT-Thread/rt-thread.svg?sanitize=true&#34; alt=&#34;GitHub pull-requests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/RT-Thread/rt-thread/pulls&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat&#34; alt=&#34;PRs Welcome&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;RT-Thread&lt;/h1&gt; &#xA;&lt;p&gt;RT-Thread was born in 2006, it is an open source, neutral, and community-based real-time operating system (RTOS).&lt;/p&gt; &#xA;&lt;p&gt;RT-Thread is mainly written in C language, easy to understand and easy to port(can be quickly port to a wide range of mainstream MCUs and module chips). It applies object-oriented programming methods to real-time system design, making the code elegant, structured, modular, and very tailorable.&lt;/p&gt; &#xA;&lt;p&gt;RT-Thread has Standard version and Nano version. For resource-constrained microcontroller (MCU) systems, the Nano version that requires only 3KB Flash and 1.2KB RAM memory resources can be tailored with easy-to-use tools. For resource-rich IoT devices, RT-Thread can use the on-line software package management tool, together with system configuration tools, to achieve intuitive and rapid modular cutting, seamlessly import rich software packages; thus, achieving complex functions like Android&#39;s graphical interface and touch sliding effects, smart voice interaction effects, and so on.&lt;/p&gt; &#xA;&lt;h2&gt;RT-Thread Architecture&lt;/h2&gt; &#xA;&lt;p&gt;RT-Thread has not only a real-time kernel, but also rich components. Its architecture is as follows:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/figures/architecture.png&#34; alt=&#34;architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Kernel layer: RT-Thread kernel, the core part of RT-Thread, includes the implementation of objects in the kernel system, such as multi-threading and its scheduling, semaphore, mailbox, message queue, memory management, timer, etc.; libcpu/BSP (Chip Migration Related Files/Board Support Package) is closely related to hardware and consists of peripheral drivers and CPU porting.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Components and Service Layer: Components are based on upper-level software on top of the RT-Thread kernel, such as virtual file systems, FinSH command-line interfaces, network frameworks, device frameworks, and more. Its modular design allows for high internal cohesion inside the components and low coupling between components.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://packages.rt-thread.org/en/index.html&#34;&gt;RT-Thread software package&lt;/a&gt;: A general-purpose software component running on the RT-Thread IoT operating system platform for different application areas, consisting of description information, source code or library files. RT-Thread provides an open package platform with officially available or developer-supplied packages that provide developers with a choice of reusable packages that are an important part of the RT-Thread ecosystem. The package ecosystem is critical to the choice of an operating system because these packages are highly reusable and modular, making it easy for application developers to build the system they want in the shortest amount of time. RT-Thread supports 450+ software packages.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;RT-Thread Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Designed for resource-constrained devices, the minimum kernel requires only 1.2KB of RAM and 3 KB of Flash.&lt;/li&gt; &#xA; &lt;li&gt;A variety of standard interfaces, such as POSIX, CMSIS, C++ application environment.&lt;/li&gt; &#xA; &lt;li&gt;Has rich components and a prosperous and fast growing package ecosystem.&lt;/li&gt; &#xA; &lt;li&gt;Elegant code style, easy to use, read and master.&lt;/li&gt; &#xA; &lt;li&gt;High Scalability. RT-Thread has high-quality scalable software architecture, loose coupling, modularity, is easy to tailor and expand.&lt;/li&gt; &#xA; &lt;li&gt;Supports high-performance applications.&lt;/li&gt; &#xA; &lt;li&gt;Supports all mainstream compiling tools such as GCC, Keil and IAR.&lt;/li&gt; &#xA; &lt;li&gt;Supports a wide range of &lt;a href=&#34;https://www.rt-thread.io/board.html&#34;&gt;architectures and chips&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Code Catalogue&lt;/h2&gt; &#xA;&lt;p&gt;RT-Thread source code catalog is shown as follow:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BSP&lt;/td&gt; &#xA;   &lt;td&gt;Board Support Package based on the porting of various development boards&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;components&lt;/td&gt; &#xA;   &lt;td&gt;Components, such as finsh shell, file system, protocol stack etc.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;documentation&lt;/td&gt; &#xA;   &lt;td&gt;Related documents, like coding style, doxygen etc.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;examples&lt;/td&gt; &#xA;   &lt;td&gt;Related sample code&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;include&lt;/td&gt; &#xA;   &lt;td&gt;Head files of RT-Thread kernel&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;libcpu&lt;/td&gt; &#xA;   &lt;td&gt;CPU porting code such as ARM/MIPS/RISC-V etc.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;src&lt;/td&gt; &#xA;   &lt;td&gt;The source files for the RT-Thread kernel.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tools&lt;/td&gt; &#xA;   &lt;td&gt;The script files for the RT-Thread command build tool.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;RT-Thread has now been ported for nearly 200 development boards, most BSPs support MDK, IAR development environment and GCC compiler, and have provided default MDK and IAR project, which allows users to add their own application code directly based on the project. Each BSP has a similar directory structure, and most BSPs provide a README.md file, which is a markdown-format file that contains the basic introduction of BSP, and introduces how to simply start using BSP.&lt;/p&gt; &#xA;&lt;h1&gt;Resources&lt;/h1&gt; &#xA;&lt;h2&gt;Supported Architectures&lt;/h2&gt; &#xA;&lt;p&gt;RT-Thread supports many architectures, and has covered the major architectures in current applications. Architecture and chip manufacturer involved:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-M0/M0+&lt;/strong&gt;：manufacturers like ST&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-M3&lt;/strong&gt;：manufacturers like ST、Winner Micro、MindMotion, ect.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-M4&lt;/strong&gt;：manufacturers like ST、Infineon、Nuvoton、NXP、&lt;a href=&#34;https://github.com/RT-Thread/rt-thread/tree/master/bsp/nrf5x&#34;&gt;Nordic&lt;/a&gt;、GigaDevice、Realtek、Ambiq Micro, ect.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-M7&lt;/strong&gt;：manufacturers like ST、NXP&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-M23&lt;/strong&gt;：manufacturers like GigaDevice&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-M33&lt;/strong&gt;：manufacturers like ST&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-R4&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM Cortex-A8/A9&lt;/strong&gt;：manufacturers like NXP&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM7&lt;/strong&gt;：manufacturers like Samsung&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM9&lt;/strong&gt;：manufacturers like Allwinner、Xilinx 、GOKE&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARM11&lt;/strong&gt;：manufacturers like Fullhan&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;MIPS32&lt;/strong&gt;：manufacturers like loongson、Ingenic&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;RISC-V RV32E/RV32I[F]/RV64[D]&lt;/strong&gt;：manufacturers like sifive、&lt;a href=&#34;https://github.com/RT-Thread/rt-thread/tree/master/bsp/k210&#34;&gt;Canaan Kendryte&lt;/a&gt;、&lt;a href=&#34;https://github.com/RT-Thread/rt-thread/tree/master/bsp/bouffalo_lab&#34;&gt;bouffalo_lab&lt;/a&gt;、&lt;a href=&#34;https://nucleisys.com/&#34;&gt;Nuclei&lt;/a&gt;、&lt;a href=&#34;https://www.t-head.cn/&#34;&gt;T-Head&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARC&lt;/strong&gt;：manufacturers like SYNOPSYS&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;DSP&lt;/strong&gt;：manufacturers like TI&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;C-Sky&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;x86&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported IDE and Compiler&lt;/h2&gt; &#xA;&lt;p&gt;The main IDE/compilers supported by RT-Thread are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RT-Thread Studio IDE&lt;/li&gt; &#xA; &lt;li&gt;MDK KEIL&lt;/li&gt; &#xA; &lt;li&gt;IAR&lt;/li&gt; &#xA; &lt;li&gt;GCC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;RT-Thread Studio IDE&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.rt-thread.io/document/site/rtthread-studio/um/studio-user-manual/&#34;&gt;User Manual&lt;/a&gt; | &lt;a href=&#34;https://youtu.be/ucq5eJgZIQg&#34;&gt;Tutorial Videos&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;RT-Thread Studio IDE (a.k.a. RT-Studio) is a one-stop intergrated development environment built by RT-Thread team. It has a easy-to-use graphical configuration system and a wealth of software packages and components resources. RT-Studio has the features of project creation, configuration and management,as well as code editing, SDK management, build configuration, debugging configuration, program download and debug. We&#39;re looking to make the use of RT-Studio as intuitive as possible, reducing the duplication of work and improving the development efficiency.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/figures/studio.gif&#34; alt=&#34;studio&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Env Tool&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/env/env/&#34;&gt;User Manual&lt;/a&gt; | &lt;a href=&#34;https://www.youtube.com/watch?v=dEK94o_YoSo&#34;&gt;Tutorial Videos&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the early stage, RT-Thread team also created an auxiliary tool called Env. It is an auxiliary tool with a TUI (Text-based user interface). Developers can use Env tool to configure and generate the GCC, Keil MDK, and IAR projects.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/figures/env.png&#34; alt=&#34;env&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Getting Started&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.rt-thread.io/document/site/tutorial/quick-start/introduction/introduction/&#34;&gt;RT-Thread Programming Guide&lt;/a&gt; | &lt;a href=&#34;https://www.rt-thread.io/studio.html&#34;&gt;RT-Thread Studio IDE&lt;/a&gt; | &lt;a href=&#34;https://github.com/RT-Thread-packages/kernel-sample&#34;&gt;Kernel Sample&lt;/a&gt; | &lt;a href=&#34;https://www.youtube.com/watch?v=ZMi1O-Rr7yc&amp;amp;list=PLXUV89C_M3G5KVw2IerI-pqApdSM_IaZo&#34;&gt;RT-Thread Beginners Guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Based on &lt;a href=&#34;https://github.com/RT-Thread/rt-thread/tree/master/bsp/stm32/stm32f103-blue-pill&#34;&gt;STM32F103 BluePill&lt;/a&gt; | &lt;a href=&#34;https://github.com/RT-Thread/rt-thread/tree/master/bsp/raspberry-pico&#34;&gt;Raspberry Pi Pico&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Simulator&lt;/h2&gt; &#xA;&lt;p&gt;RT-Thread BSP can be compiled directly and downloaded to the corresponding development board for use. In addition, RT-Thread also provides qemu-vexpress-a9 BSP, which can be used without hardware platform. See the getting started guide below for details. Getting Started of QEMU with Env: &lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/quick-start/quick_start_qemu/quick_start_qemu.md&#34;&gt;Windows&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/quick-start/quick_start_qemu/quick_start_qemu_linux.md&#34;&gt;Linux Ubuntu&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/quick-start/quick_start_qemu/quick_start_qemu_macos.md&#34;&gt;Mac OS&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;RT-Thread follows the Apache License 2.0 free software license. It&#39;s completely open-source, can be used in commercial applications for free, does not require the disclosure of code, and has no potential commercial risk. License information and copyright information can generally be seen at the beginning of the code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Copyright (c) 2006-2018, RT-Thread Development Team&#xA; *&#xA; * SPDX-License-Identifier: Apache-2.0&#xA; * ...&#xA; */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Community&lt;/h1&gt; &#xA;&lt;p&gt;RT-Thread is very grateful for the support from all community developers, and if you have any ideas, suggestions or questions in the process of using RT-Thread, RT-Thread can be reached by the following means, and we are also updating RT-Thread in real time on these channels. At the same time, any questions can be asked in the &lt;a href=&#34;https://github.com/RT-Thread/rt-thread/issues&#34;&gt;issue section of RT-Thread repository&lt;/a&gt; or &lt;a href=&#34;https://club.rt-thread.io/&#34;&gt;RT-Thread forum&lt;/a&gt;, and community members will answer them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.rt-thread.io&#34;&gt;Website&lt;/a&gt; | &lt;a href=&#34;https://github.com/RT-Thread/rt-thread&#34;&gt;Github&lt;/a&gt; | &lt;a href=&#34;https://twitter.com/rt_thread&#34;&gt;Twitter&lt;/a&gt; | &lt;a href=&#34;https://www.linkedin.com/company/rt-thread-iot-os/posts/?feedView=all&#34;&gt;LinkedIn&lt;/a&gt; | &lt;a href=&#34;https://www.youtube.com/channel/UCdDHtIfSYPq4002r27ffqPw&#34;&gt;Youtube&lt;/a&gt; | &lt;a href=&#34;https://www.facebook.com/RT-Thread-IoT-OS-110395723808463/?modal=admin_todo_tour&#34;&gt;Facebook&lt;/a&gt; | &lt;a href=&#34;https://rt-thread.medium.com/&#34;&gt;Medium&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Contribution&lt;/h1&gt; &#xA;&lt;p&gt;If you are interested in RT-Thread and want to join in the development of RT-Thread and become a code contributor,please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/RT-Thread/rt-thread/master/documentation/contribution_guide/contribution_guide.md&#34;&gt;Code Contribution Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks for the following contributors!&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/RT-Thread/rt-thread/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=RT-Thread/rt-thread&#34;&gt; &lt;/a&gt;</summary>
  </entry>
</feed>