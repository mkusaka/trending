<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-26T01:47:46Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ruby/prism</title>
    <updated>2023-11-26T01:47:46Z</updated>
    <id>tag:github.com,2023-11-26:/ruby/prism</id>
    <link href="https://github.com/ruby/prism" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Prism Ruby parser&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;Prism Ruby parser&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img alt=&#34;Prism Ruby parser&#34; height=&#34;256px&#34; src=&#34;https://github.com/ruby/prism/raw/main/doc/images/prism.png?raw=true&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;This is a parser for the Ruby programming language. It is designed to be portable, error tolerant, and maintainable. It is written in C99 and has no dependencies. It is currently being integrated into &lt;a href=&#34;https://github.com/ruby/ruby&#34;&gt;CRuby&lt;/a&gt;, &lt;a href=&#34;https://github.com/jruby/jruby&#34;&gt;JRuby&lt;/a&gt;, &lt;a href=&#34;https://github.com/oracle/truffleruby&#34;&gt;TruffleRuby&lt;/a&gt;, &lt;a href=&#34;https://github.com/sorbet/sorbet&#34;&gt;Sorbet&lt;/a&gt;, and &lt;a href=&#34;https://github.com/ruby-syntax-tree/syntax_tree&#34;&gt;Syntax Tree&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The repository contains the infrastructure for both a shared library (libprism) and a native CRuby extension. The shared library has no bindings to CRuby itself, and so can be used by other projects. The native CRuby extension links against &lt;code&gt;ruby.h&lt;/code&gt;, and so is suitable in the context of CRuby.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.&#xA;├── Makefile              configuration to compile the shared library and native tests&#xA;├── Rakefile              configuration to compile the native extension and run the Ruby tests&#xA;├── bin&#xA;│&amp;nbsp;&amp;nbsp; ├── lex               runs the lexer on a file or string, prints the tokens, and compares to ripper&#xA;│&amp;nbsp;&amp;nbsp; └── parse             runs the parser on a file or string and prints the syntax tree&#xA;├── config.yml            specification for tokens and nodes in the tree&#xA;├── docs                  documentation about the project&#xA;├── ext&#xA;│&amp;nbsp;&amp;nbsp; └── prism&#xA;│&amp;nbsp;&amp;nbsp;     ├── extconf.rb    configuration to generate the Makefile for the native extension&#xA;│&amp;nbsp;&amp;nbsp;     └── extension.c   the native extension that interacts with libprism&#xA;├── fuzz                  files related to fuzz testing&#xA;├── include&#xA;│&amp;nbsp;&amp;nbsp; ├── prism             header files for the shared library&#xA;│&amp;nbsp;&amp;nbsp; └── prism.h           main header file for the shared library&#xA;├── java                  Java bindings for the shared library&#xA;├── lib&#xA;│&amp;nbsp;&amp;nbsp; ├── prism             Ruby library files&#xA;│&amp;nbsp;&amp;nbsp; └── prism.rb          main entrypoint for the Ruby library&#xA;├── rakelib               various Rake tasks for the project&#xA;├── rust&#xA;│&amp;nbsp;&amp;nbsp; ├── prism             Rustified crate for the shared library&#xA;│&amp;nbsp;&amp;nbsp; └── prism-sys         FFI binding for Rust&#xA;├── src&#xA;│&amp;nbsp;&amp;nbsp; ├── enc               various encoding files&#xA;│&amp;nbsp;&amp;nbsp; ├── util              various utility files&#xA;│&amp;nbsp;&amp;nbsp; └── prism.c           main entrypoint for the shared library&#xA;├── templates             contains ERB templates generated by templates/template.rb&#xA;│&amp;nbsp;&amp;nbsp; └── template.rb       generates code from the nodes and tokens configured by config.yml&#xA;└── test&#xA;    └── prism&#xA;        ├── fixtures      Ruby code used for testing&#xA;        └── snapshots     snapshots of generated syntax trees corresponding to fixtures&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;To compile the shared library, you will need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A C99 compiler&lt;/li&gt; &#xA; &lt;li&gt;autotools (autoconf, automake, libtool)&lt;/li&gt; &#xA; &lt;li&gt;make&lt;/li&gt; &#xA; &lt;li&gt;Ruby 3.3.0-preview1 or later&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once you have these dependencies, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to fetch the Ruby dependencies. Finally, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rake compile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to compile the shared library. It will be built in the &lt;code&gt;build&lt;/code&gt; directory. To test that everything is working, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bin/parse -e &#34;1 + 2&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to see the syntax tree for the expression &lt;code&gt;1 + 2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; file for more information. We additionally have documentation about the overall design of the project as well as various subtopics.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/building.md&#34;&gt;Building&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/configuration.md&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/design.md&#34;&gt;Design&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/encoding.md&#34;&gt;Encoding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/fuzzing.md&#34;&gt;Fuzzing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/heredocs.md&#34;&gt;Heredocs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/javascript.md&#34;&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/local_variable_depth.md&#34;&gt;Local variable depth&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/mapping.md&#34;&gt;Mapping&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/releasing.md&#34;&gt;Releasing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/ripper.md&#34;&gt;Ripper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/ruby_api.md&#34;&gt;Ruby API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/serialization.md&#34;&gt;Serialization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/prism/main/docs/testing.md&#34;&gt;Testing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>karpathy/llama2.c</title>
    <updated>2023-11-26T01:47:46Z</updated>
    <id>tag:github.com,2023-11-26:/karpathy/llama2.c</id>
    <link href="https://github.com/karpathy/llama2.c" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Inference Llama 2 in one file of pure C&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;llama2.c&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/assets/llama_cute.jpg&#34; width=&#34;300&#34; height=&#34;300&#34; alt=&#34;Cute Llama&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Have you ever wanted to inference a baby &lt;a href=&#34;https://ai.meta.com/llama/&#34;&gt;Llama 2&lt;/a&gt; model in pure C? No? Well, now you can!&lt;/p&gt; &#xA;&lt;p&gt;Train the Llama 2 LLM architecture in PyTorch then inference it with one simple 700-line C file (&lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/run.c&#34;&gt;run.c&lt;/a&gt;). You might think that you need many billion parameter LLMs to do anything useful, but in fact very small LLMs can have surprisingly strong performance if you make the domain narrow enough (ref: &lt;a href=&#34;https://huggingface.co/datasets/roneneldan/TinyStories&#34;&gt;TinyStories&lt;/a&gt; paper). This repo is a &#34;fullstack&#34; train + inference solution for Llama 2 LLM, with focus on minimalism and simplicity.&lt;/p&gt; &#xA;&lt;p&gt;As the architecture is identical, you can also load and inference Meta&#39;s Llama 2 models. However, the current code only inferences models in fp32, so you will most likely not be able to productively load models larger than 7B. Work on model quantization is currently ongoing.&lt;/p&gt; &#xA;&lt;p&gt;Please note that this repo started recently as a fun weekend project: I took my earlier &lt;a href=&#34;https://github.com/karpathy/nanoGPT&#34;&gt;nanoGPT&lt;/a&gt;, tuned it to implement the Llama-2 architecture instead of GPT-2, and the meat of it was writing the C inference engine in &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/run.c&#34;&gt;run.c&lt;/a&gt;. So the project is young and moving quickly. Hat tip to the awesome &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;llama.cpp&lt;/a&gt; for inspiring this project. Compared to llama.cpp, I wanted something super simple, minimal, and educational so I chose to hard-code the Llama 2 architecture and just roll one inference file of pure C with no dependencies.&lt;/p&gt; &#xA;&lt;h2&gt;feel the magic&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://colab.research.google.com/github/karpathy/llama2.c/blob/master/run.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;First, navigate to the folder where you keep your projects and clone this repository to this folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/karpathy/llama2.c.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, open the repository folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd llama2.c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, let&#39;s just run a baby Llama 2 model in C. You need a model checkpoint. Download this 15M parameter model I trained on the &lt;a href=&#34;https://huggingface.co/datasets/roneneldan/TinyStories&#34;&gt;TinyStories&lt;/a&gt; dataset (~60MB download):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compile and run the C code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make run&#xA;./run stories15M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll see the text stream a sample. On my M1 MacBook Air this runs at ~110 tokens/s. See &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/#performance&#34;&gt;performance&lt;/a&gt; or the Makefile for compile flags that can significantly speed this up. We can also try a bit bigger 42M parameter model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin&#xA;./run stories42M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This still runs at interactive rates and samples more coherent and diverse stories:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Once upon a time, there was a little girl named Lily. She loved playing with her toys on top of her bed. One day, she decided to have a tea party with her stuffed animals. She poured some tea into a tiny teapot and put it on top of the teapot. Suddenly, her little brother Max came into the room and wanted to join the tea party too. Lily didn&#39;t want to share her tea and she told Max to go away. Max started to cry and Lily felt bad. She decided to yield her tea party to Max and they both shared the teapot. But then, something unexpected happened. The teapot started to shake and wiggle. Lily and Max were scared and didn&#39;t know what to do. Suddenly, the teapot started to fly towards the ceiling and landed on the top of the bed. Lily and Max were amazed and they hugged each other. They realized that sharing was much more fun than being selfish. From that day on, they always shared their tea parties and toys.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can also prompt the model with a prefix or a number of additional command line arguments, e.g. to sample at temperature 0.8 for 256 steps and with a prompt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./run stories42M.bin -t 0.8 -n 256 -i &#34;One day, Lily met a Shoggoth&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;One day, Lily met a Shoggoth. He was very shy, but was also very generous. Lily said “Hello Shoggy! Can I be your friend?” Shoggy was happy to have a friend and said “Yes, let’s explore the universe together!” So they set off on a journey to explore the universe. As they travelled, Shoggy was happy to explain to Lily about all the wonderful things in the universe. At the end of the day, Lily and Shoggy had gathered lots of wonderful things from the universe, and they both felt very proud. They promised to explore the universe as one big pair and to never stop being generous to each other.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There is also an even better 110M param model available, see &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/#models&#34;&gt;models&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Quick note on sampling, the recommendation for ~best results is to sample with &lt;code&gt;-t 1.0 -p 0.9&lt;/code&gt;, i.e. temperature 1.0 (default) but also top-p sampling at 0.9 (default). Intuitively, top-p ensures that tokens with tiny probabilities do not get sampled, so we can&#39;t get &#34;unlucky&#34; during sampling, and we are less likely to go &#34;off the rails&#34; afterwards. More generally, to control the diversity of samples use either the temperature (i.e. vary &lt;code&gt;-t&lt;/code&gt; between 0 and 1 and keep top-p off with &lt;code&gt;-p 0&lt;/code&gt;) or the top-p value (i.e. vary &lt;code&gt;-p&lt;/code&gt; between 0 and 1 and keep &lt;code&gt;-t 1&lt;/code&gt;), but not both. Nice explainers on LLM sampling strategies include &lt;a href=&#34;https://peterchng.com/blog/2023/05/02/token-selection-strategies-top-k-top-p-and-temperature/&#34;&gt;this&lt;/a&gt;, &lt;a href=&#34;https://docs.cohere.com/docs/controlling-generation-with-top-k-top-p&#34;&gt;this&lt;/a&gt; or &lt;a href=&#34;https://huggingface.co/blog/how-to-generate&#34;&gt;this&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Meta&#39;s Llama 2 models&lt;/h2&gt; &#xA;&lt;p&gt;As the neural net architecture is identical, we can also inference the Llama 2 models released by Meta. Sadly there is a bit of friction here due to licensing (I can&#39;t directly upload the checkpoints, I think). So Step 1, get the Llama 2 checkpoints by following the &lt;a href=&#34;https://github.com/facebookresearch/llama&#34;&gt;Meta instructions&lt;/a&gt;. Once we have those checkpoints, we have to convert them into the llama2.c format. For this we need to install the python dependencies (&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;) and then use the &lt;code&gt;export.py&lt;/code&gt; file, e.g. for 7B model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python export.py llama2_7b.bin --meta-llama path/to/llama/model/7B&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The export will take ~10 minutes or so and generate a 26GB file (the weights of the 7B model in float32) called &lt;code&gt;llama2_7b.bin&lt;/code&gt; in the current directory. It has been &lt;a href=&#34;https://github.com/karpathy/llama2.c/pull/85&#34;&gt;reported&lt;/a&gt; that despite efforts. I would not attempt to run anything above 7B right now for two reasons: first, 13B+ currently doesn&#39;t work because of integer flow in pointer arithmetic, which is yet to be fixed, and second, even if it were fixed, this repo is doing float32 inference right now, so it would be fairly unusably slow. Once the export is done, we can run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./run llama2_7b.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ran at about 4 tokens/s compiled with &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/#OpenMP&#34;&gt;OpenMP&lt;/a&gt; on 96 threads on my CPU Linux box in the cloud. (On my MacBook Air M1, currently it&#39;s closer to 30 seconds per token if you just build with &lt;code&gt;make runfast&lt;/code&gt;.) Example output:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The purpose of this document is to highlight the state-of-the-art of CoO generation technologies, both recent developments and those in commercial use. The focus is on the technologies with the highest merit to become the dominating processes of the future and therefore to be technologies of interest to S&amp;amp;T ... R&amp;amp;D. As such, CoO generation technologies developed in Russia, Japan and Europe are described in some depth. The document starts with an introduction to cobalt oxides as complex products and a short view on cobalt as an essential material. The document continues with the discussion of the available CoO generation processes with respect to energy and capital consumption as well as to environmental damage.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;base models... ¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯. Since we can inference the base model, it should be possible to also inference the chat model quite easily, and have a conversation with it. And if we can find a way to run 7B more efficiently, we can start adding LoRA to our training script, and going wild with finetunes all within the repo!&lt;/p&gt; &#xA;&lt;p&gt;You can also chat with the Llama Chat models. Export the chat model exactly as above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python export.py llama2_7b_chat.bin --meta-llama /path/to/7B-chat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then chat with it by specifying the chat mode using the &lt;code&gt;-m&lt;/code&gt; flag, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./run llama2_7b_chat.bin -m chat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also try Meta&#39;s Code Llama models even if support for them is incomplete. In particular, some hyperparameters changed (e.g. the constant in RoPE layer), so the inference is not exactly correct and a bit buggy right now. Looking into fixes. Make sure to build the tokenizer for the plain and instruct variants and pass it when doing inference.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python export.py codellama2_7b.bin --meta-llama /path/to/CodeLlama-7b&#xA;python tokenizer.py --tokenizer-model=/path/to/CodeLlama-7b/tokenizer.model&#xA;./run codellama2_7b.bin -z /path/to/CodeLlama-7b/tokenizer.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Chat with Code Llama Instruct:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python export.py codellama2_7b_instruct.bin --meta-llama /path/to/CodeLlama-7b-Instruct&#xA;python tokenizer.py --tokenizer-model=/path/to/CodeLlama-7b-Instruct/tokenizer.model&#xA;./run codellama2_7b_instruct.bin -m chat -z /path/to/CodeLlama-7b-Instruct/tokenizer.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;int8 quantization&lt;/h2&gt; &#xA;&lt;p&gt;The (default) script &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/run.c&#34;&gt;run.c&lt;/a&gt;, above, uses a float32 forward pass, where the entire calculation of the forward pass is kept in fp32. This is very easy to understand as far as reference code goes, but it has the following downsides: the model checkpoint files are very large (it takes 4 bytes per every individual weight), and the forward pass is relatively slow. The (very) common inference optimization employed in practice is to quantize the model parameters to lower precision, giving up a little bit of correctness in return for smaller checkpoint sizes and faster forward passes (as most of the inference uses integer arithmetic). Empirically, LLMs can tolerate precisions as low as 4-bit (or even lower), but we use int8 here because it is a &#34;safe&#34; setting that gets us the benefits but doesn&#39;t sacrifice too much of the model accuracy. Only the weights that participate in matmuls are quantized. All the other parameters (e.g. especially the scale and bias in RMSNorm) are kept in float32, because these layers are very sensitive. Now, if all you&#39;re after is reduction in checkpoint sizes, you could quantize the weights, save the checkpoint, and then dequantize them in run.c, and do float32 inference as normal and call it a day. This is totally fine. But here, we go one step further (as is standard practice) and additionally quantize the activations in the forward pass. This requires us to dynamically quantize and dequantize between float32 and int8 at runtime, which adds overhead. But the benefit is that now the majority of the calculations (the matmuls especially!) are using pure integer arithmetic, where both weights and activations enter as int8. This is where the speedups can fundamentally come from. The version we use is the &#34;Q8_0&#34; quantization (llama.cpp terminology), where the 0 means that the weight quantization is symmetric around 0, quantizing to the range [-127, 127].&lt;/p&gt; &#xA;&lt;p&gt;The quantized forward pass is implemented in &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/runq.c&#34;&gt;runq.c&lt;/a&gt;. To use it, we have to export the model in the quantized format. For example, the float32 version of Llama 2 7B was exported as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python export.py llama2_7b.bin --meta-llama path/to/llama/model/7B&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates a 26GB file, because each one of 7B parameters is 4 bytes (fp32). To export it quantized, we instead use version 2 export:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python export.py llama2_7b_q80.bin --version 2 --meta-llama path/to/llama/model/7B&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs for a few minutes, but now creates only a 6.7GB file. For exporting non-meta checkpoints you would use the --checkpoint arg instead of --meta-llama arg (more docs on this later, below). Now let&#39;s inference them. I like to use OMP here because these are big models, so e.g. on my Linux box:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make runomp&#xA;OMP_NUM_THREADS=64 ./run llama2_7b.bin -n 40&#xA;OMP_NUM_THREADS=64 ./runq llama2_7b_q80.bin -n 40&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs 40 steps just to get a timing. The float32 version for me runs at 4.6 tok/s, and the int8 version at 14 tok/s. So we achieved a 3X speedup while reducing the checkpoint size by 4X. However, the forward pass is quantized to int8, and therefore silently very slightly lower quality.&lt;/p&gt; &#xA;&lt;h2&gt;huggingface models&lt;/h2&gt; &#xA;&lt;p&gt;We can load any huggingface models that use the Llama 2 architecture. See the script &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/export.py&#34;&gt;export.py&lt;/a&gt; and the &lt;code&gt;--hf&lt;/code&gt; flag to export the model .bin file.&lt;/p&gt; &#xA;&lt;h2&gt;models&lt;/h2&gt; &#xA;&lt;p&gt;For the sake of examples of smaller, from-scratch models, I trained a small model series on TinyStories. All of these trained in a few hours on my training setup (4X A100 40GB GPUs). The 110M took around 24 hours. I am hosting them on huggingface hub &lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas&#34;&gt;tinyllamas&lt;/a&gt;, both in the original PyTorch .pt, and also in the llama2.c format .bin:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;model&lt;/th&gt; &#xA;   &lt;th&gt;dim&lt;/th&gt; &#xA;   &lt;th&gt;n_layers&lt;/th&gt; &#xA;   &lt;th&gt;n_heads&lt;/th&gt; &#xA;   &lt;th&gt;n_kv_heads&lt;/th&gt; &#xA;   &lt;th&gt;max context length&lt;/th&gt; &#xA;   &lt;th&gt;parameters&lt;/th&gt; &#xA;   &lt;th&gt;val loss&lt;/th&gt; &#xA;   &lt;th&gt;download&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;260K&lt;/td&gt; &#xA;   &lt;td&gt;64&lt;/td&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;512&lt;/td&gt; &#xA;   &lt;td&gt;260K&lt;/td&gt; &#xA;   &lt;td&gt;1.297&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/tree/main/stories260K&#34;&gt;stories260K&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OG&lt;/td&gt; &#xA;   &lt;td&gt;288&lt;/td&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;256&lt;/td&gt; &#xA;   &lt;td&gt;15M&lt;/td&gt; &#xA;   &lt;td&gt;1.072&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin&#34;&gt;stories15M.bin&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;42M&lt;/td&gt; &#xA;   &lt;td&gt;512&lt;/td&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;1024&lt;/td&gt; &#xA;   &lt;td&gt;42M&lt;/td&gt; &#xA;   &lt;td&gt;0.847&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin&#34;&gt;stories42M.bin&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;110M&lt;/td&gt; &#xA;   &lt;td&gt;768&lt;/td&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;   &lt;td&gt;1024&lt;/td&gt; &#xA;   &lt;td&gt;110M&lt;/td&gt; &#xA;   &lt;td&gt;0.760&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/resolve/main/stories110M.bin&#34;&gt;stories110M.bin&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;You&#39;ll notice that the 110M model is equivalent to GPT-1 in size. Alternatively, this is also the smallest model in the GPT-2 series (&lt;code&gt;GPT-2 small&lt;/code&gt;), except the max context length is only 1024 instead of 2048. The only notable changes from GPT-1/2 architecture is that Llama uses RoPE relatively positional embeddings instead of absolute/learned positional embeddings, a bit more fancy SwiGLU non-linearity in the MLP, RMSNorm instead of LayerNorm, bias=False on all Linear layers, and is optionally multiquery (but this is not yet supported in llama2.c).&lt;/p&gt; &#xA;&lt;h2&gt;training&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s see how we can train a baby Llama 2 from scratch using the code in this repo. First let&#39;s download and pretokenize some source dataset, e.g. I like &lt;a href=&#34;https://huggingface.co/datasets/roneneldan/TinyStories&#34;&gt;TinyStories&lt;/a&gt; so this is the only example currently available in this repo. But it should be very easy to add datasets, see the code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python tinystories.py download&#xA;python tinystories.py pretokenize&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then train our model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python train.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;brief training guide&lt;/strong&gt;. See the train.py script for more exotic launches and hyperparameter overrides. Here is a brief guide to how to set the parameters. Look at the table at the very end of the &lt;a href=&#34;https://arxiv.org/abs/2203.15556&#34;&gt;Chinchilla paper&lt;/a&gt; to get a sense of how the Transformer parameters (dim, n_layers, n_heads) grow or shrink together. Extrapolate/interpolate this pattern to get bigger or smaller transformers. Set the max context length however you wish, depending on the problem: this should be the max number of tokens that matter to predict the next token. E.g. Llama 2 uses 2048. Next, you want the &lt;em&gt;total&lt;/em&gt; batch size per update (printed by the script as &#34;tokens per iteration will be:&#34;) to be somewhere around 100K tokens for medium-sized applications. For tiny applications it could be lower, for large training (e.g. GPTs/LLamas) it is usually ~0.5M, or even more. You get there by first maxing out the batch_size to whatever your system allows (e.g. mine was 16 in a recent run because after that my GPU runs out of memory), and then you want to increase gradient_accumulation_steps to be as high as necessary to reach the total batch size of ~100K. Finally, you want to tune your learning_rate (LR). You want this to be as high as your training allows. Very small networks can get away with a large LR (e.g. 1e-3 or even higher). Large networks need lower LRs. 3e-4 is a safe choice in most medium-sized applications, but can be too low for small networks, so try to increase it! Finally, max_iters is the length of training. Play with different settings. I mostly only ever tune these parameters and leave most of the others unchanged. Here is an example of how I trained the 110M model, which I don&#39;t think is anywhere near optimal, but looked sensible to me: dim 768, n_layers 12, n_heads 12 (so size of each head is 768 / 12 = 64 channels), seq len of 1024, batch size 16 (this is the most that fit my A100 40GB GPU), gradient_accumulation_steps = 8 was needed to get total tokens batch size to be 16 batch size * 1024 tokens in sequence * 8 grad_accum = 131,072 tokens per update. Good. Learning rate 4e-4 (probably a little too low). max_iters 200K (probably a bit too high). Dropout 0.1, as that usually helps a bit at medium size. That was it. I ran using Distributed Data Parallel (DDP) on 4 GPUs on my cloud machine, training took ~day or so.&lt;/p&gt; &#xA;&lt;p&gt;Totally understand if you want to skip model training, for simple demo just download one of the pretrained models (see &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/#models&#34;&gt;models&lt;/a&gt; section), e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once we have the model.bin file, we can inference in C. Compile the C code first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now run it simply as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./run stories15M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Watch the tokens stream by, fun! We can also run the PyTorch inference script for a comparison. Download one of the models again from huggingface hub and point the &lt;code&gt;sample.py&lt;/code&gt; script at it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.pt -P out15M&#xA;python sample.py --checkpoint=out15M/stories15M.pt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which gives the same results.&lt;/p&gt; &#xA;&lt;h2&gt;custom tokenizers&lt;/h2&gt; &#xA;&lt;p&gt;In everything above, we&#39;ve assumed the custom Lllama 2 tokenizer with 32,000 tokens. However, in many boutique LLMs, using vocabulary this big might be an overkill. If you have a small application you have in mind, you might be much better off training your own tokenizers. This can make everything nicer - with smaller vocabs your model has fewer parameters (because the token embedding table is a lot smaller), the inference is faster (because there are fewer tokens to predict), and your average sequence length per example could also get smaller (because the compression is a lot more efficient on your data). So let&#39;s see how we train a custom tokenizer.&lt;/p&gt; &#xA;&lt;p&gt;By default, to pretokenize the tinystories dataset we had to run, in order:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python tinystories.py download&#xA;python tinystories.py pretokenize&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;pretokenize&lt;/code&gt; stage here loads the Llama 2 tokenizer (vocab size 32,000) and uses it to convert the downloaded text into integers, and saves that to file. We now change this as follows, to train an example 4096-token tokenizer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python tinystories.py download&#xA;python tinystories.py train_vocab --vocab_size=4096&#xA;python tinystories.py pretokenize --vocab_size=4096&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;train_vocab&lt;/code&gt; stage will call the &lt;code&gt;sentencepiece&lt;/code&gt; library to train the tokenizer, storing it in a new file &lt;code&gt;data/tok4096.model&lt;/code&gt;. I tried to reproduce as well as I could the settings that (I think) Meta used to train their vocabulary. This uses the Byte Pair Encoding algorithm that starts out with raw utf8 byte sequences of the text data and then iteratively merges the most common consecutive pairs of tokens to form the vocabulary. Inspect the &lt;code&gt;tinystories.py&lt;/code&gt; file - the custom tokenizers are stored in a special directory structure indexed by the vocab size.&lt;/p&gt; &#xA;&lt;p&gt;A quick note of interest is that vocab size of 4096 trained specifically on tinystories creates integer sequences with about the same sequence length per example as the default Llama 2 tokenizer of 32000 tokens! This means that our custom, tailored tokenizer is a lot better adapted to our specific text, and can compress it very effectively. So our trained models are smaller and faster.&lt;/p&gt; &#xA;&lt;p&gt;Now that we have pretokenized the dataset with our custom tokenizer, we can train the model. The training script &lt;code&gt;train.py&lt;/code&gt; doesn&#39;t care about the exact tokens, it only cares about the vocabulary size so it can correctly initialize the model. So when training your model, make sure to pass in&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python train.py --vocab_source=custom --vocab_size=4096&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(The defaults are &lt;code&gt;llama2&lt;/code&gt; and &lt;code&gt;32000&lt;/code&gt; respectively, which indicates the default Llama 2 tokenizer). This trains the model. Finally we are ready to run inference with our &lt;code&gt;run.c&lt;/code&gt; script. For that we need two things. Number one, we have to export our tokenizer in the &lt;code&gt;.bin&lt;/code&gt; format, do that with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python tokenizer.py --tokenizer-model=data/tok4096.model&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This writes the tokenizer to &lt;code&gt;data/tok4096.bin&lt;/code&gt;. Now we can run inference, pointing it to this tokenizer using the &lt;code&gt;-z&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./run out/model.bin -z data/tok4096.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should print the samples. If you leave out the &lt;code&gt;-z&lt;/code&gt; flag, it will use the default Llama 2 tokenizer, which would generate a good sequence of integers, but they would get translated using a different vocabulary to text, so it would look like gibberish.&lt;/p&gt; &#xA;&lt;h2&gt;performance&lt;/h2&gt; &#xA;&lt;p&gt;There are many ways to potentially speed up this code depending on your system. Have a look at the &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/Makefile&#34;&gt;Makefile&lt;/a&gt;, which contains a lot of notes. The &lt;code&gt;make run&lt;/code&gt; command currently uses the &lt;code&gt;-O3&lt;/code&gt; optimization by default, i.e.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -O3 -o run run.c -lm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;-O3 includes optimizations that are expensive in terms of compile time and memory usage. Including vectorization, loop unrolling, and predicting branches.&lt;/p&gt; &#xA;&lt;p&gt;To get a much better performance, try to compile with &lt;code&gt;make runfast&lt;/code&gt;. This turns on the &lt;code&gt;-Ofast&lt;/code&gt; flag, which includes additional optimizations that may break compliance with the C/IEEE specifications, in addition to &lt;code&gt;-O3&lt;/code&gt;. See &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&#34;&gt;the GCC docs&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;Try &lt;code&gt;-march=native&lt;/code&gt; to compile the program to use the architecture of the machine you&#39;re compiling on rather than a more generic CPU. This may enable additional optimizations and hardware-specific tuning such as improved vector instructions/width.&lt;/p&gt; &#xA;&lt;p&gt;The fastest throughput I saw so far on my MacBook Air (M1) so far is with &lt;code&gt;make runfast&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also experiment with replacing &lt;code&gt;gcc&lt;/code&gt; with &lt;code&gt;clang&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If compiling with gcc, try experimenting with &lt;code&gt;-funroll-all-loops&lt;/code&gt;, see PR &lt;a href=&#34;https://github.com/karpathy/llama2.c/pull/183&#34;&gt;#183&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;OpenMP&lt;/strong&gt;. Big improvements can also be achieved by compiling with OpenMP, which &#34;activates&#34; the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; inside the matmul and attention, allowing the work in the loops to be split up over multiple processors. You&#39;ll need to install the OpenMP library and the clang compiler first (e.g. &lt;code&gt;apt install clang libomp-dev&lt;/code&gt; on ubuntu). Then you can compile with &lt;code&gt;make runomp&lt;/code&gt;, which does:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clang -Ofast -fopenmp -march=native run.c  -lm  -o run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you run inference make sure to use OpenMP flags to set the number of threads, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;OMP_NUM_THREADS=4 ./run out/model.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Depending on your system resources you may want to tweak these hyperparameters and use more threads. But more is not always better, usually this is a bit U shaped. In particular, if your CPU has SMT (multithreading), try setting the number of threads to the number of physical cores rather than logical cores. The performance difference can be large due to cache thrashing and communication overhead. The PyTorch documentation &lt;a href=&#34;https://pytorch.org/tutorials/recipes/recipes/tuning_guide.html#cpu-specific-optimizations&#34;&gt;CPU specific optimizations &lt;/a&gt; has some good information that applies here too.&lt;/p&gt; &#xA;&lt;h2&gt;platforms&lt;/h2&gt; &#xA;&lt;p&gt;On &lt;strong&gt;Windows&lt;/strong&gt;, use &lt;code&gt;build_msvc.bat&lt;/code&gt; in a Visual Studio Command Prompt to build with msvc, or you can use &lt;code&gt;make win64&lt;/code&gt; to use mingw compiler toolchain from linux or windows to build the windows target. MSVC build will automatically use openmp and max threads appropriate for your CPU unless you set &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt; env.&lt;/p&gt; &#xA;&lt;p&gt;On &lt;strong&gt;Centos 7&lt;/strong&gt;, &lt;strong&gt;Amazon Linux 2018&lt;/strong&gt; use &lt;code&gt;rungnu&lt;/code&gt; Makefile target: &lt;code&gt;make rungnu&lt;/code&gt; or &lt;code&gt;make runompgnu&lt;/code&gt; to use openmp.&lt;/p&gt; &#xA;&lt;p&gt;On &lt;strong&gt;Mac&lt;/strong&gt;, use clang from brew for openmp build. Install clang as &lt;code&gt;brew install llvm&lt;/code&gt; and use the installed clang binary to compile with openmp: &lt;code&gt;make runomp CC=/opt/homebrew/opt/llvm/bin/clang&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;tests&lt;/h2&gt; &#xA;&lt;p&gt;You can run tests simply with pytest:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install pytest&#xA;$ pytest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will currently invoke two tests inside &lt;code&gt;test_all.py&lt;/code&gt;, which forward the model in both C and Python for 200 steps and check the output against a known good expected output. The tests currently run in only a few seconds, but will have to download and cache the stories260K models in a temporary &lt;code&gt;test&lt;/code&gt; directory (only ~2MB download).&lt;/p&gt; &#xA;&lt;p&gt;There are also some tests in C, in the file &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/test.c&#34;&gt;test.c&lt;/a&gt;. You can run these with &lt;code&gt;make testcc&lt;/code&gt;, or to see more stuff printed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make testcc VERBOSITY=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Call for help: help add more tests.&lt;/p&gt; &#xA;&lt;h2&gt;ack&lt;/h2&gt; &#xA;&lt;p&gt;I trained the llama2.c storyteller models on a 4X A100 40GB box graciously provided by the excellent &lt;a href=&#34;https://lambdalabs.com/service/gpu-cloud&#34;&gt;Lambda labs&lt;/a&gt;, thank you.&lt;/p&gt; &#xA;&lt;h2&gt;discord&lt;/h2&gt; &#xA;&lt;p&gt;Figured it&#39;s possible to reuse my existing discord channel (that I use for my &lt;a href=&#34;https://karpathy.ai/zero-to-hero.html&#34;&gt;zero to hero youtube series&lt;/a&gt;), see #llama2c channel on &lt;a href=&#34;https://discord.gg/3zy8kqD9Cp&#34;&gt;discord&lt;/a&gt;, for any quick questions, related discussions, etc.&lt;/p&gt; &#xA;&lt;h2&gt;contributing&lt;/h2&gt; &#xA;&lt;p&gt;A few words on this repo and the kinds of PRs that are likely to be accepted. What is the goal of this repo? Basically I think there will be a lot of interest in training or finetuning custom micro-LLMs (think ~100M - ~1B params, but let&#39;s say up to ~10B params) across a large diversity of applications, and deploying them in edge-adjacent environments (think MCUs, phones, web browsers, laptops, etc.). I&#39;d like this repo to be the simplest, smallest, most hackable repo to support this workflow, both training and inference. In particular, this repo is not a complex framework with a 1000 knobs controlling inscrutible code across a nested directory structure of hundreds of files. Instead, I expect most applications will wish to create a fork of this repo and hack it to their specific needs and deployment platforms.&lt;/p&gt; &#xA;&lt;p&gt;People who care about deployment efficiency above all else should look at &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;llama.cpp&lt;/a&gt;. This repo still cares about efficiency, but not at the cost of simplicity, readability or portability. Basically, I expect that a lot of people come to this repo because the training code is 2 readable .py files and the inference code is 500 lines of C. So I&#39;d like this to continue to be a kind of simplest &#34;reference implementation&#34; that can be easily hacked in a separate fork into whatever downstream application people are excited about. It shouldn&#39;t be full-featured. It shouldn&#39;t take 100 different options or settings. It shouldn&#39;t be the most efficient. A few examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;someone re-ordered two loops to improve data locality for a small efficieny win =&amp;gt; instant merge.&lt;/li&gt; &#xA; &lt;li&gt;someone added the one line &#34;pragma omp parallel for&#34;, which allows you to compile with OpenMP and dramatically speed up the code, or acts as just a comment if you don&#39;t compile it that way =&amp;gt; instant merge.&lt;/li&gt; &#xA; &lt;li&gt;bug fixes and touchups etc. =&amp;gt; happy to merge&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A few examples of PRs are that are not an excellent fit:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;adding more than several #ifdefs all over the place in code. If they are localized / few, might be okay.&lt;/li&gt; &#xA; &lt;li&gt;adding a lot of code that is very specific to some specific platform (e.g. MCUs, or some special version of linux or processor). These may be a better fit for forks of the project, and I am very happy to maintain a list of these forks in section below.&lt;/li&gt; &#xA; &lt;li&gt;adding hundreds of lines of code to run.c that are only active in specific scenarios or platforms.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If your candidate PRs have elements of these it doesn&#39;t mean they won&#39;t get merged, it just means they will make it into the gray territory. TLDR: I am eager to merge any mostly small, mostly localized, broadly applicable, clean changes that improve the efficiency and portability of the repo, while keep its hackability and readability. I appreciate all PRs seeking to help me improve the project, thank you! &amp;lt;3.&lt;/p&gt; &#xA;&lt;h2&gt;notable forks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Rust &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/gaxler/llama2.rs&#34;&gt;llama2.rs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/gaxler&#34;&gt;gaxler&lt;/a&gt;: a Rust port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/leo-du/llama2.rs&#34;&gt;llama2.rs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/leo-du&#34;&gt;leo-du&lt;/a&gt;: A Rust port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/danielgrittner/llama2-rs&#34;&gt;llama2-rs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/danielgrittner&#34;&gt;danielgrittner&lt;/a&gt;: a Rust port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/lintian06/llama2.rs&#34;&gt;llama2.rs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/lintian06&#34;&gt;lintian06&lt;/a&gt;: A Rust port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/rahoua/pecca-rs&#34;&gt;pecca.rs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/rahoua&#34;&gt;rahoua&lt;/a&gt;: A Rust port leveraging &lt;a href=&#34;https://github.com/rust-ndarray/ndarray&#34;&gt;ndarray&lt;/a&gt;, supports BLAS.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/flaneur2020/llama2.rs&#34;&gt;llama2.rs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/flaneur2020&#34;&gt;flaneur2020&lt;/a&gt;: A Rust port of this project.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Go &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/tmc/go-llama2&#34;&gt;go-llama2&lt;/a&gt; by @&lt;a href=&#34;https://github.com/tmc&#34;&gt;tmc&lt;/a&gt;: a Go port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/nikolaydubina/llama2.go&#34;&gt;llama2.go&lt;/a&gt; by @&lt;a href=&#34;https://github.com/nikolaydubina&#34;&gt;nikolaydubina&lt;/a&gt;: a Go port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/haormj/llama2.go&#34;&gt;llama2.go&lt;/a&gt; by @&lt;a href=&#34;https://github.com/haormj&#34;&gt;haormj&lt;/a&gt;: a Go port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/saracen/llama2.go&#34;&gt;llama2.go&lt;/a&gt; by @&lt;a href=&#34;https://github.com/saracen&#34;&gt;saracen&lt;/a&gt;: a Go port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Android &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Manuel030/llama2.c-android&#34;&gt;llama2.c-android&lt;/a&gt;: by @&lt;a href=&#34;https://github.com/Manuel030&#34;&gt;Manuel030&lt;/a&gt;: adds Android binaries of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/celikin/llama2.c-android-wrapper&#34;&gt;llama2.c-android-wrapper&lt;/a&gt;: by @&lt;a href=&#34;https://github.com/celikin&#34;&gt;celikin&lt;/a&gt;: added JNI wrapper, PoC&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;C++ &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/leloykun/llama2.cpp&#34;&gt;llama2.cpp&lt;/a&gt; by @&lt;a href=&#34;https://github.com/leloykun&#34;&gt;leloykun&lt;/a&gt;: a C++ port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;JavaScript &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/epicure/llama2.js&#34;&gt;llama2.js&lt;/a&gt; by @&lt;a href=&#34;https://github.com/epicure&#34;&gt;epicure&lt;/a&gt;: a JavaScript port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/agershun/llamajs&#34;&gt;llamajs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/agershun&#34;&gt;agershun&lt;/a&gt;: a JavaScript port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/wizzard0/llama2.ts&#34;&gt;llama2.ts&lt;/a&gt; by @&lt;a href=&#34;https://twitter.com/oleksandr_now&#34;&gt;oleksandr_now&lt;/a&gt;: a TypeScript port of this project. Full Llama2-7B capable.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/gohai/llama2.c-emscripten&#34;&gt;llama2.c-emscripten&lt;/a&gt; by @&lt;a href=&#34;https://github.com/gohai&#34;&gt;gohai&lt;/a&gt;: Emscripten (JavaScript) port, based on @ggerganov&#39;s initial prototype&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Zig &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/cgbur/llama2.zig&#34;&gt;llama2.zig&lt;/a&gt; by @&lt;a href=&#34;https://github.com/cgbur&#34;&gt;cgbur&lt;/a&gt;: A Zig port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/vodkaslime/llama2.zig&#34;&gt;llama2.zig&lt;/a&gt; by @&lt;a href=&#34;https://github.com/vodkaslime&#34;&gt;vodkaslime&lt;/a&gt;: a Zig port of this project&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/clebert/llama2.zig&#34;&gt;llama2.zig&lt;/a&gt; by @&lt;a href=&#34;https://github.com/clebert&#34;&gt;clebert&lt;/a&gt;: a Zig port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Julia &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/juvi21/llama2.jl&#34;&gt;llama2.jl&lt;/a&gt; by @&lt;a href=&#34;https://github.com/juvi21&#34;&gt;juvi21&lt;/a&gt;: a Julia port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Scala &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/jrudolph/llama2.scala&#34;&gt;llama2.scala&lt;/a&gt; by @&lt;a href=&#34;https://github.com/jrudolph&#34;&gt;jrudolph&lt;/a&gt;: a Scala port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Java &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/mukel/llama2.java&#34;&gt;llama2.java&lt;/a&gt; by @&lt;a href=&#34;https://github.com/mukel&#34;&gt;mukel&lt;/a&gt;: a Java port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Kotlin &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/madroidmaq/llama2.kt&#34;&gt;llama2.kt&lt;/a&gt; by @&lt;a href=&#34;https://github.com/madroidmaq&#34;&gt;madroidmaq&lt;/a&gt;: a Kotlin port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Python &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/tairov/llama2.py&#34;&gt;llama2.py&lt;/a&gt; by @&lt;a href=&#34;https://github.com/tairov&#34;&gt;tairov&lt;/a&gt;: a simple one file pure Python port of this project with zero dependencies&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;C# &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/trrahul/llama2.cs&#34;&gt;llama2.cs&lt;/a&gt; by @&lt;a href=&#34;https://github.com/trrahul&#34;&gt;trrahul&lt;/a&gt;: a C# port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Dart &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/yiminghan/llama2.dart&#34;&gt;llama2.dart&lt;/a&gt; by @&lt;a href=&#34;https://github.com/yiminghan/llama2.dart&#34;&gt;yiminghan&lt;/a&gt;: one-file dart port of this project, works with Flutter!&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Web &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/dmarcos/llama2.c-web&#34;&gt;llama2c-web&lt;/a&gt; by @&lt;a href=&#34;https://github.com/dmarcos&#34;&gt;dmarcos&lt;/a&gt;: Super simple way to build unmodified llama2.c to WASM and run it in the browser. &lt;a href=&#34;https://diegomarcos.com/llama2.c-web/&#34;&gt;Demo&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;WebAssembly &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/icppWorld/icpp-llm&#34;&gt;icpp-llm&lt;/a&gt;: LLMs for the Internet Computer&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Fortran &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/rbitr/llama2.f90&#34;&gt;llama2.f90&lt;/a&gt;: a Fortran port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Mojo &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/tairov/llama2.mojo&#34;&gt;llama2.🔥&lt;/a&gt; by @&lt;a href=&#34;https://github.com/tairov&#34;&gt;tairov&lt;/a&gt;: pure Mojo port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;OCaml &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/jackpeck/llama2.ml&#34;&gt;llama2.ml&lt;/a&gt; by @&lt;a href=&#34;https://github.com/jackpeck&#34;&gt;jackpeck&lt;/a&gt;: an OCaml port of this project&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/trholding/llama2.c&#34;&gt;llama2.c - Llama 2 Everywhere&lt;/a&gt; by @&lt;a href=&#34;https://github.com/trholding&#34;&gt;trholding&lt;/a&gt;: Standalone, Bootable &amp;amp; Portable Binary Llama 2&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chenyangMl/llama2.c-zh&#34;&gt;llama2.c-zh - Bilingual Chinese and English&lt;/a&gt; by @&lt;a href=&#34;https://github.com/chenyangMl&#34;&gt;chenyangMl&lt;/a&gt;: Expand tokenizer to support training and inference in both Chinese and English&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;unsorted todos&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;add support in run.c of reading version 1+ files from export, later deprecate &#34;version 0&#34;&lt;/li&gt; &#xA; &lt;li&gt;run.cu (CUDA) investigate and merge&lt;/li&gt; &#xA; &lt;li&gt;add more tests inside &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/test.c&#34;&gt;test.c&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;add Engine class for use in sample.py that does efficient inference in PyTorch, e.g. KV cache keeping&lt;/li&gt; &#xA; &lt;li&gt;make it easier to add a new dataset with not too much pain&lt;/li&gt; &#xA; &lt;li&gt;(LoRA) finetuning and export of Llama 2 models&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>eclipse/mosquitto</title>
    <updated>2023-11-26T01:47:46Z</updated>
    <id>tag:github.com,2023-11-26:/eclipse/mosquitto</id>
    <link href="https://github.com/eclipse/mosquitto" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Eclipse Mosquitto - An open source MQTT broker&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Eclipse Mosquitto&lt;/h1&gt; &#xA;&lt;p&gt;Mosquitto is an open source implementation of a server for version 5.0, 3.1.1, and 3.1 of the MQTT protocol. It also includes a C and C++ client library, and the &lt;code&gt;mosquitto_pub&lt;/code&gt; and &lt;code&gt;mosquitto_sub&lt;/code&gt; utilities for publishing and subscribing.&lt;/p&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;p&gt;See the following links for more information on MQTT:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Community page: &lt;a href=&#34;http://mqtt.org/&#34;&gt;http://mqtt.org/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;MQTT v3.1.1 standard: &lt;a href=&#34;https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html&#34;&gt;https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;MQTT v5.0 standard: &lt;a href=&#34;https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html&#34;&gt;https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Mosquitto project information is available at the following locations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Main homepage: &lt;a href=&#34;https://mosquitto.org/&#34;&gt;https://mosquitto.org/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Find existing bugs or submit a new bug: &lt;a href=&#34;https://github.com/eclipse/mosquitto/issues&#34;&gt;https://github.com/eclipse/mosquitto/issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Source code repository: &lt;a href=&#34;https://github.com/eclipse/mosquitto&#34;&gt;https://github.com/eclipse/mosquitto&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is also a public test server available at &lt;a href=&#34;https://test.mosquitto.org/&#34;&gt;https://test.mosquitto.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://mosquitto.org/download/&#34;&gt;https://mosquitto.org/download/&lt;/a&gt; for details on installing binaries for various platforms.&lt;/p&gt; &#xA;&lt;h2&gt;Quick start&lt;/h2&gt; &#xA;&lt;p&gt;If you have installed a binary package the broker should have been started automatically. If not, it can be started with a basic configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mosquitto&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use &lt;code&gt;mosquitto_sub&lt;/code&gt; to subscribe to a topic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mosquitto_sub -t &#39;test/topic&#39; -v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to publish a message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mosquitto_pub -t &#39;test/topic&#39; -m &#39;hello world&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation for the broker, clients and client library API can be found in the man pages, which are available online at &lt;a href=&#34;https://mosquitto.org/man/&#34;&gt;https://mosquitto.org/man/&lt;/a&gt;. There are also pages with an introduction to the features of MQTT, the &lt;code&gt;mosquitto_passwd&lt;/code&gt; utility for dealing with username/passwords, and a description of the configuration file options available for the broker.&lt;/p&gt; &#xA;&lt;p&gt;Detailed client library API documentation can be found at &lt;a href=&#34;https://mosquitto.org/api/&#34;&gt;https://mosquitto.org/api/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building from source&lt;/h2&gt; &#xA;&lt;p&gt;To build from source the recommended route for end users is to download the archive from &lt;a href=&#34;https://mosquitto.org/download/&#34;&gt;https://mosquitto.org/download/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On Windows and Mac, use &lt;code&gt;cmake&lt;/code&gt; to build. On other platforms, just run &lt;code&gt;make&lt;/code&gt; to build. For Windows, see also &lt;code&gt;README-windows.md&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are building from the git repository then the documentation will not already be built. Use &lt;code&gt;make binary&lt;/code&gt; to skip building the man pages, or install &lt;code&gt;docbook-xsl&lt;/code&gt; on Debian/Ubuntu systems.&lt;/p&gt; &#xA;&lt;h3&gt;Build Dependencies&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;c-ares (libc-ares-dev on Debian based systems) - only when compiled with &lt;code&gt;make WITH_SRV=yes&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;cJSON - for client JSON output support. Disable with &lt;code&gt;make WITH_CJSON=no&lt;/code&gt; Auto detected with CMake.&lt;/li&gt; &#xA; &lt;li&gt;libwebsockets (libwebsockets-dev) - enable with &lt;code&gt;make WITH_WEBSOCKETS=yes&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;openssl (libssl-dev on Debian based systems) - disable with &lt;code&gt;make WITH_TLS=no&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;pthreads - for client library thread support. This is required to support the &lt;code&gt;mosquitto_loop_start()&lt;/code&gt; and &lt;code&gt;mosquitto_loop_stop()&lt;/code&gt; functions. If compiled without pthread support, the library isn&#39;t guaranteed to be thread safe.&lt;/li&gt; &#xA; &lt;li&gt;uthash / utlist - bundled versions of these headers are provided, disable their use with &lt;code&gt;make WITH_BUNDLED_DEPS=no&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;xsltproc (xsltproc and docbook-xsl on Debian based systems) - only needed when building from git sources - disable with &lt;code&gt;make WITH_DOCS=no&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Equivalent options for enabling/disabling features are available when using the CMake build.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Mosquitto was written by Roger Light &lt;a href=&#34;mailto:roger@atchoo.org&#34;&gt;roger@atchoo.org&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>