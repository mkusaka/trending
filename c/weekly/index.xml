<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-27T01:42:48Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>strongswan/strongswan</title>
    <updated>2025-04-27T01:42:48Z</updated>
    <id>tag:github.com,2025-04-27:/strongswan/strongswan</id>
    <link href="https://github.com/strongswan/strongswan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;strongSwan - IPsec-based VPN&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;strongSwan Configuration&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;strongSwan is an OpenSource IPsec-based VPN solution.&lt;/p&gt; &#xA;&lt;p&gt;This document is just a short introduction of the strongSwan &lt;strong&gt;swanctl&lt;/strong&gt; command which uses the modern &lt;a href=&#34;https://raw.githubusercontent.com/strongswan/strongswan/master/src/libcharon/plugins/vici/README.md&#34;&gt;&lt;strong&gt;vici&lt;/strong&gt;&lt;/a&gt; &lt;em&gt;Versatile IKE Configuration Interface&lt;/em&gt;. The deprecated &lt;strong&gt;ipsec&lt;/strong&gt; command using the legacy &lt;strong&gt;stroke&lt;/strong&gt; configuration interface is described &lt;a href=&#34;https://raw.githubusercontent.com/strongswan/strongswan/master/README_LEGACY.md&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;. For more detailed information consult the man pages, our new &lt;a href=&#34;https://docs.strongswan.org&#34;&gt;&lt;strong&gt;documentation site&lt;/strong&gt;&lt;/a&gt; and the legacy &lt;a href=&#34;https://wiki.strongswan.org&#34;&gt;&lt;strong&gt;wiki&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Certificates for users, hosts and gateways are issued by a fictitious strongSwan CA. In our example scenarios the CA certificate &lt;code&gt;strongswanCert.pem&lt;/code&gt; must be present on all VPN endpoints in order to be able to authenticate the peers. For your particular VPN application you can either use certificates from any third-party CA or generate the needed private keys and certificates yourself with the strongSwan &lt;strong&gt;pki&lt;/strong&gt; tool, the use of which will be explained in one of the sections following below.&lt;/p&gt; &#xA;&lt;h3&gt;Site-to-Site Case&lt;/h3&gt; &#xA;&lt;p&gt;In this scenario two security gateways &lt;em&gt;moon&lt;/em&gt; and &lt;em&gt;sun&lt;/em&gt; will connect the two subnets &lt;em&gt;moon-net&lt;/em&gt; and &lt;em&gt;sun-net&lt;/em&gt; with each other through a VPN tunnel set up between the two gateways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | 192.168.0.2 | -- 10.2.0.0/16&#xA;  moon-net          moon                 sun           sun-net&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        net-net {&#xA;            remote_addrs = 192.168.0.2&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=sun.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    remote_ts = 10.2.0.0/16&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;sun&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/sunCert.pem&#xA;/etc/swanctl/private/sunKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        net-net {&#xA;            remote_addrs = 192.168.0.1&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = sunCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=moon.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.2.0.0/16&#xA;                    remote_ts = 10.1.0.0/16&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The local and remote identities used in this scenario are the &lt;em&gt;subjectDistinguishedNames&lt;/em&gt; contained in the end entity certificates. The certificates and private keys are loaded into the &lt;strong&gt;charon&lt;/strong&gt; daemon with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-creds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;whereas&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-conns&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;loads the connections defined in &lt;code&gt;swanctl.conf&lt;/code&gt;. With &lt;code&gt;start_action = trap&lt;/code&gt; the IPsec connection is automatically set up with the first plaintext payload IP packet wanting to go through the tunnel.&lt;/p&gt; &#xA;&lt;h3&gt;Host-to-Host Case&lt;/h3&gt; &#xA;&lt;p&gt;This is a setup between two single hosts which don&#39;t have a subnet behind them. Although IPsec transport mode would be sufficient for host-to-host connections we will use the default IPsec tunnel mode.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;| 192.168.0.1 | === | 192.168.0.2 |&#xA;     moon                sun&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on host &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        host-host {&#xA;            remote_addrs = 192.168.0.2&#xA;&#xA;            local {&#xA;                auth=pubkey&#xA;                certs = moonCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=sun.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on host &lt;em&gt;sun&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/sunCert.pem&#xA;/etc/swanctl/private/sunKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        host-host {&#xA;            remote_addrs = 192.168.0.1&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = sunCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=moon.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                host-host {&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Roadwarrior Case&lt;/h3&gt; &#xA;&lt;p&gt;This is a very common case where a strongSwan gateway serves an arbitrary number of remote VPN clients usually having dynamic IP addresses.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x |&#xA;  moon-net          moon              carol&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/carolCert.pem&#xA;/etc/swanctl/private/carolKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = carolCert.pem&#xA;                id = carol@strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;remote_addrs&lt;/code&gt; the hostname &lt;code&gt;moon.strongswan.org&lt;/code&gt; was chosen which will be resolved by DNS at runtime into the corresponding IP destination address. In this scenario the identity of the roadwarrior &lt;code&gt;carol&lt;/code&gt; is the email address &lt;code&gt;carol@strongswan.org&lt;/code&gt; which must be included as a &lt;em&gt;subjectAlternativeName&lt;/em&gt; in the roadwarrior certificate &lt;code&gt;carolCert.pem&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Roadwarrior Case with Virtual IP&lt;/h3&gt; &#xA;&lt;p&gt;Roadwarriors usually have dynamic IP addresses assigned by the ISP they are currently attached to. In order to simplify the routing from &lt;em&gt;moon-net&lt;/em&gt; back to the remote access client &lt;em&gt;carol&lt;/em&gt; it would be desirable if the roadwarrior had an inner IP address chosen from a pre-defined pool.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x | -- 10.3.0.1&#xA;  moon-net          moon              carol       virtual IP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In our example the virtual IP address is chosen from the address pool &lt;code&gt;10.3.0.0/16&lt;/code&gt; which can be configured by adding the section&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pools {&#xA;    rw_pool {&#xA;        addrs = 10.3.0.0/16&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to the gateway&#39;s &lt;code&gt;swanctl.conf&lt;/code&gt; from where they are loaded into the &lt;strong&gt;charon&lt;/strong&gt; daemon using the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-pools&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To request an IP address from this pool a roadwarrior can use IKEv1 mode config or IKEv2 configuration payloads. The configuration for both is the same&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vips = 0.0.0.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            pools = rw_pool&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    pools {&#xA;        rw_pool {&#xA;            addrs = 10.30.0.0/16&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/carolCert.pem&#xA;/etc/swanctl/private/carolKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;            vips = 0.0.0.0&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = carolCert.pem&#xA;                id = carol@strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Roadwarrior Case with EAP Authentication&lt;/h3&gt; &#xA;&lt;p&gt;This is a very common case where a strongSwan gateway serves an arbitrary number of remote VPN clients which authenticate themselves via a password based &lt;em&gt;Extended Authentication Protocol&lt;/em&gt; as e.g. &lt;em&gt;EAP-MD5&lt;/em&gt; or &lt;em&gt;EAP-MSCHAPv2&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x |&#xA;  moon-net          moon              carol&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = eap-md5&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;            send_certreq = no&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;swanctl.conf&lt;/code&gt; file additionally contains a &lt;code&gt;secrets&lt;/code&gt; section defining all client credentials&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    secrets {&#xA;        eap-carol {&#xA;            id = carol@strongswan.org&#xA;            secret = Ar3etTnp&#xA;        }&#xA;        eap-dave {&#xA;            id = dave@strongswan.org&#xA;            secret = W7R0g3do&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;&#xA;            local {&#xA;                auth = eap&#xA;                id = carol@strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    secrets {&#xA;        eap-carol {&#xA;            id = carol@strongswan.org&#xA;            secret = Ar3etTnp&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Roadwarrior Case with EAP Identity&lt;/h3&gt; &#xA;&lt;p&gt;Often a client EAP identity is exchanged via EAP which differs from the external IKEv2 identity. In this example the IKEv2 identity defaults to the IPv4 address of the client.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x |&#xA;  moon-net          moon              carol&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = eap-md5&#xA;                eap_id = %any&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;            send_certreq = no&#xA;        }&#xA;    }&#xA;&#xA;    secrets {&#xA;        eap-carol {&#xA;            id = carol&#xA;            secret = Ar3etTnp&#xA;        }&#xA;        eap-dave {&#xA;            id = dave&#xA;            secret = W7R0g3do&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;&#xA;            local {&#xA;                auth = eap&#xA;                eap_id = carol&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    secrets {&#xA;        eap-carol {&#xA;            id = carol&#xA;            secret = Ar3etTnp&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Generating Certificates and CRLs&lt;/h2&gt; &#xA;&lt;p&gt;This section is not a full-blown tutorial on how to use the strongSwan &lt;strong&gt;pki&lt;/strong&gt; tool. It just lists a few points that are relevant if you want to generate your own certificates and CRLs for use with strongSwan.&lt;/p&gt; &#xA;&lt;h3&gt;Generating a CA Certificate&lt;/h3&gt; &#xA;&lt;p&gt;The pki statement&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --gen --type ed25519 --outform pem &amp;gt; strongswanKey.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;generates an elliptic Edwards-Curve key with a cryptographic strength of 128 bits. The corresponding public key is packed into a self-signed CA certificate with a lifetime of 10 years (3652 days)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --self --ca --lifetime 3652 --in strongswanKey.pem \&#xA;           --dn &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34; \&#xA;           --outform pem &amp;gt; strongswanCert.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which can be listed with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --print --in strongswanCert.pem&#xA;&#xA;subject:  &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;issuer:   &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;validity:  not before May 18 08:32:06 2017, ok&#xA;           not after  May 18 08:32:06 2027, ok (expires in 3651 days)&#xA;serial:    57:e0:6b:3a:9a:eb:c6:e0&#xA;flags:     CA CRLSign self-signed&#xA;subjkeyId: 2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;pubkey:    ED25519 256 bits&#xA;keyid:     a7:e1:6a:3f:e7:6f:08:9d:89:ec:23:92:a9:a1:14:3c:78:a8:7a:f7&#xA;subjkey:   2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you prefer the CA private key and X.509 certificate to be in binary DER format then just omit the &lt;code&gt;--outform pem&lt;/code&gt; option. The directory &lt;code&gt;/etc/swanctl/x509ca&lt;/code&gt; contains all required CA certificates either in binary DER or in Base64 PEM format. Irrespective of the file suffix the correct format will be determined by strongSwan automagically.&lt;/p&gt; &#xA;&lt;h3&gt;Generating a Host or User End Entity Certificate&lt;/h3&gt; &#xA;&lt;p&gt;Again we are using the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --gen --type ed25519 --outform pem &amp;gt; moonKey.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to generate an Ed25519 private key for the host &lt;code&gt;moon&lt;/code&gt;. Alternatively you could type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --gen --type rsa --size 3072 &amp;gt; moonKey.der&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to generate a traditional 3072 bit RSA key and store it in binary DER format. As an alternative a &lt;strong&gt;TPM 2.0&lt;/strong&gt; &lt;em&gt;Trusted Platform Module&lt;/em&gt; available on every recent Intel platform could be used as a virtual smartcard to securely store an RSA or ECDSA private key. For details, refer to the TPM 2.0 &lt;a href=&#34;https://docs.strongswan.org/docs/latest/tpm/tpm2.html&#34;&gt;HOWTO&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In a next step the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --req --type priv --in moonKey.pem \&#xA;          --dn &#34;C=CH, O=strongswan, CN=moon.strongswan.org&#34; \&#xA;          --san moon.strongswan.org --outform pem &amp;gt; moonReq.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;creates a PKCS#10 certificate request that has to be signed by the CA. Through the [multiple] use of the &lt;code&gt;--san&lt;/code&gt; parameter any number of desired &lt;em&gt;subjectAlternativeNames&lt;/em&gt; can be added to the request. These can be of the form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--san sun.strongswan.org     # fully qualified host name&#xA;--san carol@strongswan.org   # RFC822 user email address&#xA;--san 192.168.0.1            # IPv4 address&#xA;--san fec0::1                # IPv6 address&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Based on the certificate request the CA issues a signed end entity certificate with the following command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --issue --cacert strongswanCert.pem --cakey strongswanKey.pem \&#xA;            --type pkcs10 --in moonReq.pem --serial 01 --lifetime 1826 \&#xA;            --outform pem &amp;gt; moonCert.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the &lt;code&gt;--serial&lt;/code&gt; parameter with a hexadecimal argument is omitted then a random serial number is generated. Some third party VPN clients require that a VPN gateway certificate contains the &lt;em&gt;TLS Server Authentication&lt;/em&gt; Extended Key Usage (EKU) flag which can be included with the following option&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--flag serverAuth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use the dynamic CRL fetching feature described in one of the following sections then you may include one or several &lt;em&gt;crlDistributionPoints&lt;/em&gt; in your end entity certificates using the &lt;code&gt;--crl&lt;/code&gt; parameter&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--crl  http://crl.strongswan.org/strongswan.crl&#xA;--crl &#34;ldap://ldap.strongswan.org/cn=strongSwan Root CA, o=strongSwan,c=CH?certificateRevocationList&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The issued host certificate can be listed with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --print --in moonCert.pem&#xA;&#xA;subject:  &#34;C=CH, O=strongSwan, CN=moon.strongswan.org&#34;&#xA;issuer:   &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;validity:  not before May 19 10:28:19 2017, ok&#xA;           not after  May 19 10:28:19 2022, ok (expires in 1825 days)&#xA;serial:    01&#xA;altNames:  moon.strongswan.org&#xA;flags:     serverAuth&#xA;CRL URIs:  http://crl.strongswan.org/strongswan.crl&#xA;authkeyId: 2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;subjkeyId: 60:9d&lt;span&gt;🇩🇪&lt;/span&gt;30:a6:ca:b9:8e:87:bb:33:23:61:19:18:b8:c4:7e:23:8f&#xA;pubkey:    ED25519 256 bits&#xA;keyid:     39:1b:b3:c2:34:72:1a:01:08:40:ce:97:75:b8:be:ce:24:30:26:29&#xA;subjkey:   60:9d&lt;span&gt;🇩🇪&lt;/span&gt;30:a6:ca:b9:8e:87:bb:33:23:61:19:18:b8:c4:7e:23:8f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Usually, a Windows, OSX, Android or iOS based VPN client needs its private key, its host or user certificate and the CA certificate. The most convenient way to load this information is to put everything into a PKCS#12 container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;openssl pkcs12 -export -inkey carolKey.pem \&#xA;               -in carolCert.pem -name &#34;carol&#34; \&#xA;               -certfile strongswanCert.pem -caname &#34;strongSwan Root CA&#34; \&#xA;               -out carolCert.p12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The strongSwan &lt;strong&gt;pki&lt;/strong&gt; tool currently is not able to create PKCS#12 containers so that &lt;strong&gt;openssl&lt;/strong&gt; must be used.&lt;/p&gt; &#xA;&lt;h3&gt;Generating a CRL&lt;/h3&gt; &#xA;&lt;p&gt;An empty CRL that is signed by the CA can be generated with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --signcrl --cacert strongswanCert.pem --cakey strongswanKey.pem \&#xA;              --lifetime 30 &amp;gt; strongswan.crl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you omit the &lt;code&gt;--lifetime&lt;/code&gt; option then the default value of 15 days is used. CRLs can either be uploaded to a HTTP or LDAP server or put in binary DER or Base64 PEM format into the &lt;code&gt;/etc/swanctl/x509crl&lt;/code&gt; directory from where they are loaded into the &lt;strong&gt;charon&lt;/strong&gt; daemon with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-creds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Revoking a Certificate&lt;/h3&gt; &#xA;&lt;p&gt;A specific end entity certificate is revoked with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --signcrl --cacert strongswanCert.pem --cakey strongswanKey.pem \&#xA;              --lifetime 30 --lastcrl strongswan.crl \&#xA;              --reason key-compromise --cert moonCert.pem &amp;gt; new.crl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of the certificate file (in our example moonCert.pem), the serial number of the certificate to be revoked can be indicated using the &lt;code&gt;--serial&lt;/code&gt; parameter. The &lt;code&gt;pki --signcrl --help&lt;/code&gt; command documents all possible revocation reasons but the &lt;code&gt;--reason&lt;/code&gt; parameter can also be omitted. The content of the new CRL file can be listed with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --print --type crl --in new.crl&#xA;&#xA;issuer:   &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;update:    this on May 19 11:13:01 2017, ok&#xA;           next on Jun 18 11:13:01 2017, ok (expires in 29 days)&#xA;serial:    02&#xA;authKeyId: 2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;1 revoked certificate:&#xA;  01: May 19 11:13:01 2017, key compromise&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Local Caching of CRLs&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;strongswan.conf&lt;/code&gt; option&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;charon {&#xA;    cache_crls = yes&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;activates the local caching of CRLs that were dynamically fetched from an HTTP or LDAP server. Cached copies are stored in &lt;code&gt;/etc/swanctl/x509crl&lt;/code&gt; using a unique filename formed from the issuer&#39;s &lt;em&gt;subjectKeyIdentifier&lt;/em&gt; and the suffix &lt;code&gt;.crl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With the cached copy the CRL is immediately available after startup. When the local copy has become stale, an updated CRL is automatically fetched from one of the defined CRL distribution points during the next IKEv2 authentication.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>xiph/opus</title>
    <updated>2025-04-27T01:42:48Z</updated>
    <id>tag:github.com,2025-04-27:/xiph/opus</id>
    <link href="https://github.com/xiph/opus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern audio compression for the internet.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;== Opus audio codec ==&lt;/p&gt; &#xA;&lt;p&gt;Opus is a codec for interactive speech and audio transmission over the Internet.&lt;/p&gt; &#xA;&lt;p&gt;Opus can handle a wide range of interactive audio applications, including Voice over IP, videoconferencing, in-game chat, and even remote live music performances. It can scale from low bit-rate narrowband speech to very high quality stereo music.&lt;/p&gt; &#xA;&lt;p&gt;Opus, when coupled with an appropriate container format, is also suitable for non-realtime stored-file applications such as music distribution, game soundtracks, portable music players, jukeboxes, and other applications that have historically used high latency formats such as MP3, AAC, or Vorbis.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;                Opus is specified by IETF RFC 6716:&#xA;                https://tools.ietf.org/html/rfc6716&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Opus format and this implementation of it are subject to the royalty- free patent and copyright licenses specified in the file COPYING.&lt;/p&gt; &#xA;&lt;p&gt;This package implements a shared library for encoding and decoding raw Opus bitstreams. Raw Opus bitstreams should be used over RTP according to &lt;a href=&#34;https://tools.ietf.org/html/rfc7587&#34;&gt;https://tools.ietf.org/html/rfc7587&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The package also includes a number of test tools used for testing the correct operation of the library. The bitstreams read/written by these tools should not be used for Opus file distribution: They include additional debugging data and cannot support seeking.&lt;/p&gt; &#xA;&lt;p&gt;Opus stored in files should use the Ogg encapsulation for Opus which is described at: &lt;a href=&#34;https://tools.ietf.org/html/rfc7845&#34;&gt;https://tools.ietf.org/html/rfc7845&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An opus-tools package is available which provides encoding and decoding of Ogg encapsulated Opus files and includes a number of useful features.&lt;/p&gt; &#xA;&lt;p&gt;Opus-tools can be found at: &lt;a href=&#34;https://gitlab.xiph.org/xiph/opus-tools.git&#34;&gt;https://gitlab.xiph.org/xiph/opus-tools.git&lt;/a&gt; or on the main Opus website: &lt;a href=&#34;https://opus-codec.org/&#34;&gt;https://opus-codec.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;== Deep Learning and Opus ==&lt;/p&gt; &#xA;&lt;p&gt;Lossy networks continue to be a challenge for real-time communications. While the original implementation of Opus provides an excellent packet loss concealment mechanism, the team has continued to advance the methodology used to improve audio quality in challenge network environments.&lt;/p&gt; &#xA;&lt;p&gt;In Opus 1.5, we added a deep learning based redundancy encoder that enhances audio in lossy networks by embedding one second of recovery data in the padding data of each packet. The underlying algorithm behind encoding and decoding the recovery data is called the deep redundancy (DRED) algorithm. By leveraging the padding data within the packet, Opus 1.5 is fully backward compatible with prior revisions of Opus. Please see the README under the &#34;dnn&#34; subdirectory to understand DRED.&lt;/p&gt; &#xA;&lt;p&gt;DRED was developed by a team that Amazon Web Services initially sponsored, who open-sourced the implementation as well as began the standardization process at the IETF: &lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-mlcodec-opus-extension/&#34;&gt;https://datatracker.ietf.org/doc/draft-ietf-mlcodec-opus-extension/&lt;/a&gt; The license behind Opus or the intellectual property position of Opus does not change with Opus 1.5.&lt;/p&gt; &#xA;&lt;p&gt;== Compiling libopus ==&lt;/p&gt; &#xA;&lt;p&gt;To build from a distribution tarball, you only need to do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% ./configure&#xA;% make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build from the git repository, the following steps are necessary:&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Set up a development environment:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;On an Ubuntu or Debian family Linux distribution:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% sudo apt-get install git autoconf automake libtool gcc make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On a Fedora/Redhat based Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% sudo dnf install git autoconf automake libtool gcc make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or for older Redhat/Centos Linux releases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% sudo yum install git autoconf automake libtool gcc make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Apple macOS, install Xcode and brew.sh, then in the Terminal enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% brew install autoconf automake libtool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone the repository:&lt;/p&gt; &lt;p&gt;% git clone &lt;a href=&#34;https://gitlab.xiph.org/xiph/opus.git&#34;&gt;https://gitlab.xiph.org/xiph/opus.git&lt;/a&gt; % cd opus&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Compiling the source&lt;/p&gt; &lt;p&gt;% ./autogen.sh % ./configure % make&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;On x86, it&#39;s a good idea to use a -march= option that allows the use of AVX2.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the codec libraries (optional)&lt;/p&gt; &lt;p&gt;% sudo make install&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Once you have compiled the codec, there will be a opus_demo executable in the top directory.&lt;/p&gt; &#xA;&lt;p&gt;Usage: opus_demo [-e] &#xA; &lt;application&gt;&#xA;   &amp;lt;sampling rate (Hz)&amp;gt; &amp;lt;channels (1/2)&amp;gt; &#xA;  &lt;bits per second&gt;&#xA;    [options] &#xA;   &lt;input&gt; &#xA;   &lt;output&gt; opus_demo -d &amp;lt;sampling rate (Hz)&amp;gt; &amp;lt;channels (1/2)&amp;gt; [options] &lt;input&gt; &lt;output&gt;&lt;/output&gt;&lt;/output&gt;&#xA;  &lt;/bits&gt;&#xA; &lt;/application&gt;&lt;/p&gt; &#xA;&lt;p&gt;mode: voip | audio | restricted-lowdelay options: -e : only runs the encoder (output the bit-stream) -d : only runs the decoder (reads the bit-stream as input) -cbr : enable constant bitrate; default: variable bitrate -cvbr : enable constrained variable bitrate; default: unconstrained -bandwidth &amp;lt;NB|MB|WB|SWB|FB&amp;gt; : audio bandwidth (from narrowband to fullband); default: sampling rate -framesize &amp;lt;2.5|5|10|20|40|60&amp;gt; : frame size in ms; default: 20 -max_payload &#xA; &lt;bytes&gt;&#xA;   : maximum payload size in bytes, default: 1024 -complexity &#xA;  &lt;comp&gt;&#xA;    : complexity, 0 (lowest) ... 10 (highest); default: 10 -inbandfec : enable SILK inband FEC -forcemono : force mono encoding, even for stereo input -dtx : enable SILK DTX -loss &#xA;   &lt;perc&gt;&#xA;     : simulate packet loss, in percent (0-100); default: 0&#xA;   &lt;/perc&gt;&#xA;  &lt;/comp&gt;&#xA; &lt;/bytes&gt;&lt;/p&gt; &#xA;&lt;p&gt;input and output are little-endian signed 16-bit PCM files or opus bitstreams with simple opus_demo proprietary framing.&lt;/p&gt; &#xA;&lt;p&gt;== Testing ==&lt;/p&gt; &#xA;&lt;p&gt;This package includes a collection of automated unit and system tests which SHOULD be run after compiling the package especially the first time it is run on a new platform.&lt;/p&gt; &#xA;&lt;p&gt;To run the integrated tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also collection of standard test vectors which are not included in this package for size reasons but can be obtained from: &lt;a href=&#34;https://opus-codec.org/docs/opus_testvectors-rfc8251.tar.gz&#34;&gt;https://opus-codec.org/docs/opus_testvectors-rfc8251.tar.gz&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To run compare the code to these test vectors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% curl -OL https://opus-codec.org/docs/opus_testvectors-rfc8251.tar.gz&#xA;% tar -zxf opus_testvectors-rfc8251.tar.gz&#xA;% ./tests/run_vectors.sh ./ opus_newvectors 48000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;== Compiling libopus for Windows and alternative build systems ==&lt;/p&gt; &#xA;&lt;p&gt;See cmake/README.md or meson/README.md.&lt;/p&gt; &#xA;&lt;p&gt;== Portability notes ==&lt;/p&gt; &#xA;&lt;p&gt;This implementation uses floating-point by default but can be compiled to use only fixed-point arithmetic by setting --enable-fixed-point (if using autoconf) or by defining the FIXED_POINT macro (if building manually). The fixed point implementation has somewhat lower audio quality and is slower on platforms with fast FPUs, it is normally only used in embedded environments.&lt;/p&gt; &#xA;&lt;p&gt;The implementation can be compiled with either a C89 or a C99 compiler. While it does not rely on any &lt;em&gt;undefined behavior&lt;/em&gt; as defined by C89 or C99, it relies on common &lt;em&gt;implementation-defined behavior&lt;/em&gt; for two&#39;s complement architectures:&lt;/p&gt; &#xA;&lt;p&gt;o Right shifts of negative values are consistent with two&#39;s complement arithmetic, so that a&amp;gt;&amp;gt;b is equivalent to floor(a/(2^b)),&lt;/p&gt; &#xA;&lt;p&gt;o For conversion to a signed integer of N bits, the value is reduced modulo 2^N to be within range of the type,&lt;/p&gt; &#xA;&lt;p&gt;o The result of integer division of a negative value is truncated towards zero, and&lt;/p&gt; &#xA;&lt;p&gt;o The compiler provides a 64-bit integer type (a C99 requirement which is supported by most C89 compilers).&lt;/p&gt;</summary>
  </entry>
</feed>