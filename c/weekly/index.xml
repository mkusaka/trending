<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-18T01:42:44Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jart/blink</title>
    <updated>2022-12-18T01:42:44Z</updated>
    <id>tag:github.com,2022-12-18:/jart/blink</id>
    <link href="https://github.com/jart/blink" rel="alternate"></link>
    <summary type="html">&lt;p&gt;tiniest x86-64-linux emulator&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jart/blink/master/blink/blink-gcc.png&#34; alt=&#34;Screenshot of Blink running GCC 9.4.0&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;blink&lt;/h1&gt; &#xA;&lt;p&gt;blink is a virtual machine for running statically-compiled x86-64-linux programs on different operating systems and hardware architectures. It&#39;s designed to do the same thing as the &lt;code&gt;qemu-x86_64&lt;/code&gt; command, except (a) rather than being a 4mb binary, Blink only has a ~158kb footprint; and (b) Blink goes faster than Qemu on some benchmarks, such as emulating GCC. The tradeoff is Blink doesn&#39;t have as many systems integrations as Qemu. Blink is a great fit when you want a virtual machine that&#39;s embeddable, readable, hackable, and easy to compile. For further details on the motivations for this tool, please read &lt;a href=&#34;https://justine.lol/ape.html&#34;&gt;https://justine.lol/ape.html&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Caveat Emptor&lt;/h2&gt; &#xA;&lt;p&gt;Welcome everyone from the Hacker News, Lobsters, and Reddit communities! This project is a work in progress. Please don&#39;t use this for production yet. If you try this be sure to calibrate your expectations accordingly.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;You can compile Blink on x86-64 Linux, Darwin, FreeBSD, NetBSD, OpenBSD, Apple Silicon, and Raspberry Pi using your operating system&#39;s toolchain.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# for all x86-64 platforms&#xA;$ build/bootstrap/make.com -j8 o//blink/blink&#xA;&#xA;# for apple m1 arm silicon&#xA;# don&#39;t use the ancient version of gnu make that comes with xcode&#xA;$ make -j8 o//blink/blink&#xA;&#xA;# for linux raspberry pi&#xA;$ build/bootstrap/blink-linux-aarch64 build/bootstrap/make.com -j8 o//blink/blink&#xA;&#xA;# run actually portable executable in virtual machine&#xA;$ o//blink/blink third_party/cosmo/hello.com&#xA;hello world&#xA;&#xA;# run static elf binary in virtual machine&#xA;$ o//blink/blink third_party/cosmo/tinyhello.elf&#xA;hello world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s a terminal interface for debugging:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ build/bootstrap/make.com -j8 o//blink/tui&#xA;$ o//blink/tui third_party/cosmo/tinyhello.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run our test executables to check your local platform build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com -j8 check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For maximum performance, use &lt;code&gt;MODE=rel&lt;/code&gt; or &lt;code&gt;MODE=opt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com MODE=opt -j8 check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For maximum tinyness, use &lt;code&gt;MODE=tiny&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ build/bootstrap/make.com MODE=tiny -j8 check&#xA;$ strip o/tiny/blink/blink&#xA;$ ls -hal o/tiny/blink/blink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can sanitize using &lt;code&gt;MODE=asan&lt;/code&gt;, &lt;code&gt;MODE=ubsan&lt;/code&gt;, &lt;code&gt;MODE=tsan&lt;/code&gt;, and &lt;code&gt;MODE=msan&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re building your code on an x86-64 Linux machine, then the following command will cross-compile blink for i386, arm, m68k, riscv, mips, s390x. Then it&#39;ll launch all the cross-compiled binaries in qemu to ensure the test programs above work on all architectures.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com -j8 emulates&#xA;$ o/third_party/qemu/qemu-aarch64 o//aarch64/blink/blink third_party/cosmo/hello.com&#xA;hello world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Technical Details&lt;/h2&gt; &#xA;&lt;p&gt;blink is an x86-64 interpreter for POSIX platforms that&#39;s written in ANSI C11 that&#39;s compatible with C++ compilers. Instruction decoding is done using our trimmed-down version of Intel&#39;s disassembler Xed.&lt;/p&gt; &#xA;&lt;p&gt;The prime directive of this project is to act as a virtual machine for userspace binaries compiled by Cosmopolitan Libc. However we&#39;ve also had success virtualizing programs compiled with Glibc and Musl Libc, such as GCC and Qemu. Blink supports more than a hundred Linux system call ABIs, including fork() and clone(). The SSE2, SSE3, SSSE3, POPCNT, CLMUL, RDTSCP, and RDRND hardware ISAs are supported. Blink&#39;s legacy x87 FPU currently only supports double (64-bit) precision, just like Windows.&lt;/p&gt; &#xA;&lt;p&gt;Blink uses just-in-time compilation, which is supported on x86_64 and aarch64. Blink takes the appropriate steps to work around restrictions relating to JIT, on platforms like Apple and OpenBSD. We generate JIT code using a printf-style domain-specific language. The JIT works by generating functions at runtime which call the micro-op functions the compiler created. To make micro-operations go faster, Blink determines the byte length of the compiled function at runtime by scanning for a RET instruction. Blink will then copy the compiled function into the function that the JIT is generating. This works in most cases, however some tools can cause problems. For example, OpenBSD RetGuard inserts static memory relocations into every compiled function, which Blink&#39;s JIT currently doesn&#39;t understand; so we need to use compiler flags to disable that type of magic. In the event other such magic slips through, Blink has a runtime check which will catch obvious problems, and then gracefully fall back to using a CALL instruction. Since no JIT can be fully perfect on all platforms, the &lt;code&gt;o//blink/blink -j&lt;/code&gt; flag may be passed to disable Blink&#39;s JIT. Please note that disabling JIT makes Blink go 10x slower. With the &lt;code&gt;o//blink/tui&lt;/code&gt; command, the &lt;code&gt;-j&lt;/code&gt; flag takes on the opposite meaning, where it instead &lt;em&gt;enables&lt;/em&gt; JIT. This can be useful for troubleshooting the JIT, because the TUI display has a feature that lets JIT path formation be visualized. Blink currently only enables the JIT for programs running in long mode (64-bit) but we may support JITing 16-bit programs in the future.&lt;/p&gt; &#xA;&lt;p&gt;Blink virtualizes memory using the same PML4T approach as the hardware itself, where memory lookups are indirected through a four-level radix tree. Since performing four separate page table lookups on every memory access can be slow, Blink checks a translation lookaside buffer, which contains the sixteen most recently used page table entries. The PML4T allows all memory lookups in Blink to be &#34;safe&#34; but it still doesn&#39;t offer the best possible performance. Therefore, on systems with a huge address space (i.e. petabytes of virtual memory) Blink relies on itself being loaded to a random location, and then identity maps guest memory using a simple linear translation. For example, if the guest virtual address is &lt;code&gt;0x400000&lt;/code&gt; then the host address might be &lt;code&gt;0x400000+0x088800000000&lt;/code&gt;. This means that each time a memory operation is executed, only a simple addition needs to be performed. This goes extremely fast, however it may present issues for programs that use &lt;code&gt;MAP_FIXED&lt;/code&gt;. Some systems, such as modern Raspberry Pi, actually have a larger address space than x86-64, which lets Blink offer the guest the complete address space. However on some platforms, like 32-bit ones, only a limited number of identity mappings are possible. There&#39;s also compiler tools like TSAN which lay claim to much of the fixed address space. Blink&#39;s solution is designed to meet the needs of Cosmopolitan Libc, while working around Apple&#39;s restriction on 32-bit addresses, and still remain fully compatible with ASAN&#39;s restrictions. In the event that this translation scheme doesn&#39;t work on your system, the &lt;code&gt;blink -m&lt;/code&gt; flag may be passed to disable the linear translation optimization, and instead use only the memory safe full virtualization approach of the PML4T and TLB.&lt;/p&gt; &#xA;&lt;p&gt;Blink has an xterm-compatible ANSI teletypewriter display implementation which allows Blink&#39;s TUI interface to host other TUI programs, within an embedded terminal display. For example, it&#39;s possible to use Antirez&#39;s Kilo text editor inside Blink&#39;s TUI.&lt;/p&gt; &#xA;&lt;p&gt;Blink supports 16-bit BIOS programs, such as SectorLISP. To boot real mode programs in Blink, the &lt;code&gt;o//blink/tui -r&lt;/code&gt; flag may be passed, which puts the virtual machine in i8086 mode. Currently only a limited set of BIOS APIs are available. For example, Blink supports IBM PC Serial UART, CGA display, and the MDA display APIs which are rendered using block characters in the TUI interface. We hope to expand our real mode support in the near future, in order to run operating systems like ELKS.&lt;/p&gt; &#xA;&lt;p&gt;Blink supports troubleshooting operating system bootloaders. Blink was designed for Cosmopolitan Libc, which embeds an operating system in each binary it compiles. Blink has helped us debug our bare metal support, since Blink is capable of running in the 16-bit, 32-bit, and 64-bit modes a bootloader requires at various stages. In order to do that, we needed to implement some ring0 hardware instructions. Blink has enough to support Cosmopolitan, but it&#39;ll take much more time to get Blink to a point where it can boot something like Windows.&lt;/p&gt; &#xA;&lt;p&gt;Blink supports several different executable formats, all of which are static. You can run:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Actually Portable Executables, which have either the &lt;code&gt;MZqFpD&lt;/code&gt; or &lt;code&gt;jartsr&lt;/code&gt; magic.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Statically-compiled x86-64-linux ELF executables, so long as they don&#39;t use PIC/PIE or require a interpreter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Flat executables, which must end with the file extension &lt;code&gt;.bin&lt;/code&gt;. In this case, you can make executables as small as 10 bytes in size, since they&#39;re treated as raw x86-64 code. Blink always loads flat executables to the address &lt;code&gt;0x400000&lt;/code&gt; and automatically appends 16mb of BSS memory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Real mode executables, which are loaded to the address &lt;code&gt;0x7c00&lt;/code&gt;. These programs must be run using the &lt;code&gt;tui&lt;/code&gt; command with the &lt;code&gt;-r&lt;/code&gt; flag.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ExpressLRS/ExpressLRS</title>
    <updated>2022-12-18T01:42:44Z</updated>
    <id>tag:github.com,2022-12-18:/ExpressLRS/ExpressLRS</id>
    <link href="https://github.com/ExpressLRS/ExpressLRS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;STM32/ESP32/ESP8285-based High-Performance Radio Link for RC applications&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/ExpressLRS/ExpressLRS-Hardware/raw/master/img/banner.png?raw=true&#34; alt=&#34;Banner&#34;&gt;&lt;/p&gt; &#xA;&lt;center&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ExpressLRS/ExpressLRS/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/ExpressLRS/ExpressLRS?style=flat-square&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ExpressLRS/ExpressLRS/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/ExpressLRS/ExpressLRS/Build%20ExpressLRS?logo=github&amp;amp;style=flat-square&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ExpressLRS/ExpressLRS/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/ExpressLRS/ExpressLRS?style=flat-square&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ExpressLRS/ExpressLRS/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/ExpressLRS/ExpressLRS?style=flat-square&#34; alt=&#34;Stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/expresslrs&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/596350022191415318?color=%235865F2&amp;amp;logo=discord&amp;amp;logoColor=%23FFFFFF&amp;amp;style=flat-square&#34; alt=&#34;Chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/center&gt; &#xA;&lt;h2&gt;Support ExpressLRS&lt;/h2&gt; &#xA;&lt;p&gt;You can support ExpressLRS by contributing code, testing new features, sharing your ideas, or helping others get started. We are exceptionally grateful for those who donate their time to our passion.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t have time to lend a hand in that way but still want to have an impact, consider donating. Donations are used for infrastructure costs and to buy test equipment needed to further the project and make it securely accessible. ExpressLRS accepts donations through Open Collective, which provides recognition of donors and transparency on how that support is utilized.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opencollective.com/expresslrs&#34;&gt;&lt;img src=&#34;https://img.shields.io/opencollective/backers/expresslrs?label=Open%20Collective%20backers&amp;amp;style=flat-square&#34; alt=&#34;Open Collective backers&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We appreciate all forms of contribution and hope you will join us on Discord!&lt;/p&gt; &#xA;&lt;h2&gt;Website&lt;/h2&gt; &#xA;&lt;p&gt;For general information on the project please refer to our guides on the &lt;a href=&#34;https://www.expresslrs.org/&#34;&gt;website&lt;/a&gt;, and our &lt;a href=&#34;https://www.expresslrs.org/2.0/faq/&#34;&gt;FAQ&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;ExpressLRS is an open source Radio Link for Radio Control applications. Designed to be the best FPV Racing link, it is based on the fantastic Semtech &lt;strong&gt;SX127x&lt;/strong&gt;/&lt;strong&gt;SX1280&lt;/strong&gt; LoRa hardware combined with an Espressif or STM32 Processor. Using LoRa modulation as well as reduced packet size it achieves best in class range and latency. It achieves this using a highly optimized over-the-air packet structure, giving simultaneous range and latency advantages. It supports both 900 MHz and 2.4 GHz links, each with their own benefits. 900 MHz supports a maximum of 200 Hz packet rate, with higher penetration. 2.4 GHz supports a blistering fast 1000 Hz on &lt;a href=&#34;http://edgetx.org/&#34;&gt;EdgeTX&lt;/a&gt;. With over 60 different hardware targets and 13 hardware manufacuturers, the choice of hardware is ever growing, with different hardware suited to different requirements.&lt;/p&gt; &#xA;&lt;h2&gt;Configurator&lt;/h2&gt; &#xA;&lt;p&gt;To configure your ExpressLRS hardware, the ExpressLRS Configurator can be used, which is found here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ExpressLRS/ExpressLRS-Configurator/releases/&#34;&gt;https://github.com/ExpressLRS/ExpressLRS-Configurator/releases/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;We have both a &lt;a href=&#34;https://discord.gg/expresslrs&#34;&gt;Discord Server&lt;/a&gt; and &lt;a href=&#34;https://www.facebook.com/groups/636441730280366&#34;&gt;Facebook Group&lt;/a&gt;, which have great support for new users and constant ongoing development discussion&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;ExpressLRS has the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;1000 Hz Packet Rate&lt;/li&gt; &#xA; &lt;li&gt;Telemetry (Betaflight Lua Compatibility)&lt;/li&gt; &#xA; &lt;li&gt;Wifi Updates&lt;/li&gt; &#xA; &lt;li&gt;Bluetooth Sim Joystick&lt;/li&gt; &#xA; &lt;li&gt;Oled &amp;amp; TFT Displays&lt;/li&gt; &#xA; &lt;li&gt;2.4 GHz or 900 MHz RC Link&lt;/li&gt; &#xA; &lt;li&gt;Ceramic Antenna - allows for easier installation into micros&lt;/li&gt; &#xA; &lt;li&gt;VTX and VRX Frequency adjustments from the Lua&lt;/li&gt; &#xA; &lt;li&gt;Bind Phrases - no need for button binding&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;with many more features on the way!&lt;/p&gt; &#xA;&lt;h2&gt;Supported Hardware&lt;/h2&gt; &#xA;&lt;p&gt;ExpressLRS currently supports hardware from the following manufacturers: AxisFlying, BETAFPV, Flywoo, FrSky, HappyModel, HiYounger, HGLRC, ImmersionRC, iFlight, JHEMCU, Jumper, Matek, NamimnoRC, QuadKopters and SIYI.&lt;/p&gt; &#xA;&lt;p&gt;For an exhaustive list of hardware targets and their user guides, check out the &lt;a href=&#34;https://www.expresslrs.org/2.0/hardware/supported-hardware/&#34;&gt;Supported Hardware&lt;/a&gt; and &lt;a href=&#34;https://www.expresslrs.org/2.0/hardware/receiver-selection/&#34;&gt;Receiver Selection&lt;/a&gt; pages on the website. We do not manufacture any of our hardware, so we can only provide limited support on defective hardware.&lt;/p&gt; &#xA;&lt;h2&gt;Developers&lt;/h2&gt; &#xA;&lt;p&gt;If you are a developer and would like to contribute to the project, feel free to join the &lt;a href=&#34;https://discord.gg/expresslrs&#34;&gt;discord&lt;/a&gt; and chat about bugs and issues. You can also look for issues at the &lt;a href=&#34;https://github.com/ExpressLRS/ExpressLRS/issues&#34;&gt;GitHub Issue Tracker&lt;/a&gt;. The best thing to do is to a submit a Pull Request to the GitHub Repository.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ExpressLRS/ExpressLRS-Hardware/raw/master/img/community.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cpq/bare-metal-programming-guide</title>
    <updated>2022-12-18T01:42:44Z</updated>
    <id>tag:github.com,2022-12-18:/cpq/bare-metal-programming-guide</id>
    <link href="https://github.com/cpq/bare-metal-programming-guide" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A bare metal programming guide on STM32 microcontroller&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A bare metal programming guide&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/cpq/bare-metal-programming-guide/actions&#34;&gt;&lt;img src=&#34;https://github.com/cpq/bare-metal-programming-guide/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This guide is written for developers who wish to start programming microcontrollers using GCC compiler and a datasheet - nothing else! The fundamentals explained in this guide, will help you understand better how frameworks like Cube, Keil, Arduino - and others, work.&lt;/p&gt; &#xA;&lt;p&gt;The guide covers the following topics: memory and registers, interrupt vector table, startup code, linker script, build automation using &lt;code&gt;make&lt;/code&gt;, GPIO peripheral and LED blinky, SysTick timer, UART peripheral and debug output, &lt;code&gt;printf&lt;/code&gt; redirect to UART (IO retargeting), debugging with Segger Ozone, system clock setup, and web server implementation with device dashboard.&lt;/p&gt; &#xA;&lt;p&gt;Throughout the guide, we will be using a &lt;a href=&#34;https://www.st.com/en/evaluation-tools/nucleo-f429zi.html&#34;&gt;Nucleo-F429ZI&lt;/a&gt; development board (&lt;a href=&#34;https://eu.mouser.com/ProductDetail/STMicroelectronics/NUCLEO-F429ZI?qs=mKNKSX85ZJcE6FU0UkiXTA%3D%3D&#34;&gt;buy on Mouser&lt;/a&gt;). Every chapter in this guide has an associated project, and they gradually progress in functionality and completeness. The last (web server) project is the most complete, and can be used as a skeleton for the project of your own, dear reader. Therefore, that last example project is provided for the other boards, too:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-7-webserver/nucleo-f429zi/&#34;&gt;STM32 Nucleo-F429ZI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-7-webserver/ek-tm4c1294xl/&#34;&gt;TI EK-TM4C1294XL&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Support for other boards is in progress - file an issue to suggest the board you work with.&lt;/p&gt; &#xA;&lt;h2&gt;Tools setup&lt;/h2&gt; &#xA;&lt;p&gt;To proceed, the following tools are required:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ARM GCC, &lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;https://launchpad.net/gcc-arm-embedded&lt;/a&gt; - for compiling and linking&lt;/li&gt; &#xA; &lt;li&gt;GNU make, &lt;a href=&#34;http://www.gnu.org/software/make/&#34;&gt;http://www.gnu.org/software/make/&lt;/a&gt; - for build automation&lt;/li&gt; &#xA; &lt;li&gt;ST link, &lt;a href=&#34;https://github.com/stlink-org/stlink&#34;&gt;https://github.com/stlink-org/stlink&lt;/a&gt; - for flashing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Setup instructions for Mac&lt;/h3&gt; &#xA;&lt;p&gt;Start a terminal, and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ /bin/bash -c &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&#34;&#xA;$ brew install gcc-arm-embedded make stlink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setup instructions for Linux (Ubuntu)&lt;/h3&gt; &#xA;&lt;p&gt;Start a terminal, and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo apt -y install gcc-arm-none-eabi make stlink-tools&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setup instructions for Windows&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download and install &lt;a href=&#34;https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&amp;amp;hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C&#34;&gt;gcc-arm-none-eabi-10.3-2021.10-win32.exe&lt;/a&gt;. Enable &#34;Add path to environment variable&#34; during the installation&lt;/li&gt; &#xA; &lt;li&gt;Create &lt;code&gt;c:\tools&lt;/code&gt; folder&lt;/li&gt; &#xA; &lt;li&gt;Download &lt;a href=&#34;https://github.com/stlink-org/stlink/releases/download/v1.7.0/stlink-1.7.0-x86_64-w64-mingw32.zip&#34;&gt;stlink-1.7.0-x86_64-w64-mingw32.zip&lt;/a&gt; and unpack &lt;code&gt;bin/st-flash.exe&lt;/code&gt; into &lt;code&gt;c:\tools&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Download &lt;a href=&#34;https://sourceforge.net/projects/ezwinports/files/make-4.4-without-guile-w32-bin.zip/download&#34;&gt;make-4.4-without-guile-w32-bin.zip&lt;/a&gt; and unpack &lt;code&gt;bin/make.exe&lt;/code&gt; into &lt;code&gt;c:\tools&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;c:\tools&lt;/code&gt; to the &lt;code&gt;Path&lt;/code&gt; environment variable&lt;/li&gt; &#xA; &lt;li&gt;Verify installation: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Download and unzip &lt;a href=&#34;https://github.com/cpq/bare-metal-programming-guide/archive/refs/heads/main.zip&#34;&gt;this repository&lt;/a&gt; into &lt;code&gt;c:\&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Start command prompt, and execute the following:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;pre style=&#34;color: silver;&#34;&gt;&#xA;C:\Users\YOURNAME&amp;gt; &lt;b style=&#34;color: black;&#34;&gt;cd \&lt;/b&gt;&#xA;C:\&amp;gt; &lt;b style=&#34;color: black;&#34;&gt;cd bare-metal-programming-guide-main\step-0-minimal&lt;/b&gt;&#xA;C:\bare-metal-programming-guide-main\step-0-minimal&amp;gt; &lt;b style=&#34;color: black;&#34;&gt;make&lt;/b&gt;&#xA;arm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror ...&#xA;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Required datasheets&lt;/h3&gt; &#xA;&lt;p&gt;Download and open the following datasheets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/resource/en/reference_manual/dm00031020-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf&#34;&gt;STM32F429 MCU datasheet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/resource/en/user_manual/dm00244518-stm32-nucleo144-boards-mb1137-stmicroelectronics.pdf&#34;&gt;Nucleo-F429ZI board datasheet&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;A microcontroller (uC, or MCU) is a small computer. Typically it has CPU, RAM, flash to store firmware code, and a bunch of pins that stick out. Some pins are used to power the MCU, usually marked as GND (ground) and VCC pins. Other pins are used to communicate with the MCU, by means of high/low voltage applied to those pins. One of the simplest ways of communication is an LED attached to a pin: one LED contact is attached to the ground pin (GND), and another contact is attached to a signal pin via a current-limiting resistor. A firmware code can set high or low voltage on a signal pin, making LED blink:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/mcu.svg?sanitize=true&#34; height=&#34;200&#34;&gt; &#xA;&lt;h3&gt;Memory and registers&lt;/h3&gt; &#xA;&lt;p&gt;The 32-bit address space of the MCU is divided by regions. For example, some region of memory is mapped to the internal MCU flash at a specific address. Firmware code instructions are read and executed by reading from that memory region. Another region is RAM, which is also mapped to a specific address. We can read and write any values to the RAM region.&lt;/p&gt; &#xA;&lt;p&gt;From STM32F429 datasheet, we can take a look at section 2.3.1 and learn that RAM region starts at address 0x20000000 and has size of 192KB. From section 2.4 we can learn that flash is mapped at address 0x08000000. Our MCU has 2MB flash, so flash and RAM regions are located like this:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/mem.svg?sanitize=true&#34;&gt; &#xA;&lt;p&gt;From the datasheet we can also learn that there are many more memory regions. Their address ranges are given in the section 2.3 &#34;Memory Map&#34;. For example, there is a &#34;GPIOA&#34; region that starts at 0x40020000 and has length of 1KB.&lt;/p&gt; &#xA;&lt;p&gt;These memory regions correspond to a different &#34;peripherals&#34; inside the MCU - a piece of silicon circuitry that make certain pins behave in a special way. A peripheral memory region is a collection of 32-bit &lt;strong&gt;registers&lt;/strong&gt;. Each register is a 4-byte memory range at a certain address, that maps to a certain function of the given peripheral. By writing values into a register - in other words, by writing a 32-bit value at a certain memory address, we can control how given peripheral should behave. By reading registers, we can read back peripheral&#39;s data or configuration.&lt;/p&gt; &#xA;&lt;p&gt;There are many different peripherals. One of the simpler ones are GPIO (General Purpose Input Output), which allow user to set MCU pins into &#34;output mode&#34; and set high or low voltage on them. Or, set pins into an &#34;input mode&#34; and read voltage values from them. There is a UART peripheral which can transmit and receive serial data over two pins using serial protocol. There are many other peripherals.&lt;/p&gt; &#xA;&lt;p&gt;Often, there are multiple &#34;instances&#34; of the same peripheral, for example GPIOA, GPIOB, ... which control different set of MCU pins. Likewise, there could be UART1, UART2, ... which allow to implement multiple UART channels. On Nucleo-F429, there are several GPIO and UART peripherals.&lt;/p&gt; &#xA;&lt;p&gt;For example, GPIOA peripheral starts at 0x40020000, and we can find GPIO register description in section 8.4. The datasheet says that &lt;code&gt;GPIOA_MODER&lt;/code&gt; register has offset 0, that means that it&#39;s address is &lt;code&gt;0x40020000 + 0&lt;/code&gt;, and this is the format of the register:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/moder.png&#34; style=&#34;max-width: 100%&#34;&gt; &#xA;&lt;p&gt;The datasheet shows that the 32-bit MODER register is a collection of 2-bit values, 16 in total. Therefore, one MODER register controls 16 physical pins, Bits 0-1 control pin 0, bits 2-3 control pin 1, and so on. The 2-bit value encodes pin mode: 0 means input, 1 means output, 2 means &#34;alternate function&#34; - some specific behavior described elsewhere, and 3 means analog. Since the peripheral name is &#34;GPIOA&#34;, then pins are named &#34;A0&#34;, &#34;A1&#34;, etc. For peripheral &#34;GPIOB&#34;, pin naming would be &#34;B0&#34;, &#34;B1&#34;, ...&lt;/p&gt; &#xA;&lt;p&gt;If we write 32-bit value &lt;code&gt;0&lt;/code&gt; to the register MODER, we&#39;ll set all 16 pins, from A0 to A15, to input mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  * (volatile uint32_t *) (0x40020000 + 0) = 0;  // Set A0-A15 to input mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By setting individual bits, we can selectively set specific pins to a desired mode. For example, this snippet sets pin A3 to output mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  * (volatile uint32_t *) (0x40020000 + 0) &amp;amp;= ~(3 &amp;lt;&amp;lt; 6);  // CLear bit range 6-7&#xA;  * (volatile uint32_t *) (0x40020000 + 0) |= 1 &amp;lt;&amp;lt; 6;     // Set bit range 6-7 to 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let me explain those bit operations. Our goal is to set bits 6-7, which are responsible for the pin 3 of GPIOA peripheral, to a specific value (1, in our case). This is done in two steps. First, we must clear the current value of bits 6-7, because it may hold some value already. Then we must set bits 6-7 to the value we want.&lt;/p&gt; &#xA;&lt;p&gt;So, first, we must set bit range 6-7 to zero. How do we set a number of bits to zero? In four steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get a number that has N contiguous bits set: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;1 for 1 bit: &lt;code&gt;0b1&lt;/code&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;3 for 2 bits: &lt;code&gt;0b11&lt;/code&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;7 for 3 bits: &lt;code&gt;0b111&lt;/code&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;15 for 4 bits: &lt;code&gt;0b1111&lt;/code&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;and so on: generally, for N bits, the number is &lt;code&gt;2^N - 1&lt;/code&gt; So, for 2 bits it is number &lt;code&gt;3&lt;/code&gt;, or &lt;code&gt;0b00000000000000000000000000000011&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Shift that number left. If we need to set bits X-Y, then shift on X positions left. In our case, shift on a 6 positions left: &lt;code&gt;(3 &amp;lt;&amp;lt; 6)&lt;/code&gt;, or &lt;code&gt;0b00000000000000000000000011000000&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Invert the number: turn zeros to ones, and ones to zeroes: &lt;code&gt;~(3 &amp;lt;&amp;lt; 6)&lt;/code&gt;, or &lt;code&gt;0xb11111111111111111111111100111111&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Now, perform a &#34;logical AND&#34; operation of the register with our number. Bits 6-7, AND-ed with 0, will give zero - that&#39;s what we want! All other bits, AND-ed with 1, will retain their current value: &lt;code&gt;REG &amp;amp;= ~(3 &amp;lt;&amp;lt; 6)&lt;/code&gt;. Retaining values of all other bits is important: we don&#39;t want to change other settings in other bit ranges!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So, in general, if we want to clear bits X-Y (set them to zero), do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;PERIPHERAL-&amp;gt;REGISTER &amp;amp;= ~(NUMBER_WITH_N_BITS &amp;lt;&amp;lt; X);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, finally, we want to set a given bit range to the value we want. We shift that value X positions left, and OR with the current value of the whole register:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;PERIPHERAL-&amp;gt;REGISTER |= VALUE &amp;lt;&amp;lt; X;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, it should be clear to you, dear reader, the meaning of these two lines, which set bits 6-7 of the GPIOA MODER register to the value of 1 (output).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  * (volatile uint32_t *) (0x40020000 + 0) &amp;amp;= ~(3 &amp;lt;&amp;lt; 6);  // CLear bit range 6-7&#xA;  * (volatile uint32_t *) (0x40020000 + 0) |= 1 &amp;lt;&amp;lt; 6;     // Set bit range 6-7 to 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some registers are not mapped to the MCU peripherals, but they are mapped to the ARM CPU configuration and control. For example, there is a &#34;Reset at clock control&#34; unit (RCC), described in section 6 of the datasheet. It describes registers that allow to set systems clock and other things.&lt;/p&gt; &#xA;&lt;h2&gt;Human-readable peripherals programming&lt;/h2&gt; &#xA;&lt;p&gt;In the previous section we have learned that we can read and write peripheral register by direct accessing certain memory addresses. Let&#39;s look at the snippet that sets pin A3 to output mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  * (volatile uint32_t *) (0x40020000 + 0) &amp;amp;= ~(3 &amp;lt;&amp;lt; 6);  // CLear bit range 6-7&#xA;  * (volatile uint32_t *) (0x40020000 + 0) |= 1 &amp;lt;&amp;lt; 6;     // Set bit range 6-7 to 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is pretty cryptic. Without extensive comments, such code would be quite hard to understand. We can rewrite this code to a much more readable form. The idea is to represent the whole peripheral as a structure that contains 32-bit fields. Let&#39;s see what registers exist for the GPIO peripheral in the section 8.4 of the datasheet. They are MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR. Their offsets are with offsets 0, 4, 8, etc... . That means we can represent them as a structure with 32-bit fields, and make a define for GPIOA:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct gpio {&#xA;  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];&#xA;};&#xA;&#xA;#define GPIOA ((struct gpio *) 0x40020000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, for setting GPIO pin mode, we can define a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Enum values are per datasheet: 0, 1, 2, 3&#xA;enum {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG};&#xA;&#xA;static inline void gpio_set_mode(struct gpio *gpio, uint8_t pin, uint8_t mode) {&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (pin * 2));        // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (pin * 2);   // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we can rewrite the snippet for A3 like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gpio_set_mode(GPIOA, 3 /* pin */, GPIO_MODE_OUTPUT);  // Set A3 to output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our MCU has several GPIO peripherals (also called &#34;banks&#34;): A, B, C, ... K. From section 2.3 we can see that they are 1KB away from each other: GPIOA is at address 0x40020000, GPIOB is at 0x40020400, and so on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can create pin numbering that includes the bank and the pin number. To do that, we use 2-byte &lt;code&gt;uint16_t&lt;/code&gt; value, where upper byte indicates GPIO bank, and lower byte indicates pin number:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define PIN(bank, num) ((((bank) - &#39;A&#39;) &amp;lt;&amp;lt; 8) | (num))&#xA;#define PINNO(pin) (pin &amp;amp; 255)&#xA;#define PINBANK(pin) (pin &amp;gt;&amp;gt; 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way, we can specify pins for any GPIO bank:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint16_t pin1 = PIN(&#39;A&#39;, 3);    // A3   - GPIOA pin 3&#xA;  uint16_t pin2 = PIN(&#39;G&#39;, 11);   // G11  - GPIOG pin 11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s rewrite the &lt;code&gt;gpio_set_mode()&lt;/code&gt; function to take our pin specification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin)); // GPIO bank&#xA;  uint8_t n = PINNO(pin);                 // Pin number&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (n * 2));        // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (n * 2);   // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the code for A3 is self-explanatory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint16_t pin = PIN(&#39;A&#39;, 3);            // Pin A3&#xA;  gpio_set_mode(pin, GPIO_MODE_OUTPUT);  // Set to output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we have created a useful initial API for the GPIO peripheral. Other peripherals, like UART (serial communication) and others - can be implemented in a similar way. This is a good programming practice that makes code self-explanatory and human readable.&lt;/p&gt; &#xA;&lt;h2&gt;MCU boot and vector table&lt;/h2&gt; &#xA;&lt;p&gt;When STM32F429 MCU boots, it reads a so-called &#34;vector table&#34; from the beginning of flash memory. A vector table is a concept common to all ARM MCUs. That is a array of 32-bit addresses of interrupt handlers. First 16 entries are reserved by ARM and are common to all ARM MCUs. The rest of interrupt handlers are specific to the given MCU - these are interrupt handlers for peripherals. Simpler MCUs with few peripherals have few interrupt handlers, and more complex MCUs have many.&lt;/p&gt; &#xA;&lt;p&gt;Vector table for STM32F429 is documented in Table 62. From there we can learn that there are 91 peripheral handlers, in addition to the standard 16.&lt;/p&gt; &#xA;&lt;p&gt;At this point, we are interested in the first two entries of the vector table, because they play a key role in the MCU boot process. Those two first values are: initial stack pointer, and an address of the boot function to execute (a firmware entry point).&lt;/p&gt; &#xA;&lt;p&gt;So now we know, that we must make sure that our firmware should be composed in a way that the 2nd 32-bit value in the flash should contain an address of out boot function. When MCU boots, it&#39;ll read that address from flash, and jump to our boot function.&lt;/p&gt; &#xA;&lt;h2&gt;Minimal firmware&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s create a file &lt;code&gt;main.c&lt;/code&gt;, and specify our boot function that initially does nothing (falls into infinite loop), and specify a vector table that contains 16 standard entries and 91 STM32 entries. In your editor of choice, create &lt;code&gt;main.c&lt;/code&gt; file and copy/paste the following into &lt;code&gt;main.c&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Startup code&#xA;__attribute__((naked, noreturn)) void _reset(void) {&#xA;  for (;;) (void) 0;  // Infinite loop&#xA;}&#xA;&#xA;extern void _estack(void);  // Defined in link.ld&#xA;&#xA;// 16 standard and 91 STM32-specific handlers&#xA;__attribute__((section(&#34;.vectors&#34;))) void (*tab[16 + 91])(void) = {&#xA;  _estack, _reset&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For function &lt;code&gt;_reset()&lt;/code&gt;, we have used GCC-specific attributes &lt;code&gt;naked&lt;/code&gt; and &lt;code&gt;noreturn&lt;/code&gt; - they mean, standard function&#39;s prologue and epilogue should not be created by the compiler, and that function does not return.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;void (*tab[16 + 91])(void)&lt;/code&gt; expression means: define an array of 16 + 91 pointers to functions, that return nothing (void) and take to arguments. Each such function is an IRQ handler (Interrupt ReQuest handler). An array of those handlers is called a vector table.&lt;/p&gt; &#xA;&lt;p&gt;The vector table &lt;code&gt;tab&lt;/code&gt; we put in a separate section called &lt;code&gt;.vectors&lt;/code&gt; - that we need later to tell the linker to put that section right at the beginning of the generated firmware - and consecutively, at the beginning of flash memory. The first two entries are: the value of the stack pointer register, and the firmware&#39;s entry point. We leave the rest of vector table filled with zeroes.&lt;/p&gt; &#xA;&lt;h3&gt;Compilation&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s compile our code. Start a terminal (or a command prompt on Windows) and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-gcc -mcpu=cortex-m4 main.c -c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That works! The compilation produced a file &lt;code&gt;main.o&lt;/code&gt; which contains our minimal firmware that does nothing. The &lt;code&gt;main.o&lt;/code&gt; file is in ELF binary format, which contains several sections. Let&#39;s see them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-objdump -h main.o&#xA;...&#xA;Sections:&#xA;Idx Name          Size      VMA       LMA       File off  Algn&#xA;  0 .text         00000002  00000000  00000000  00000034  2**1&#xA;                  CONTENTS, ALLOC, LOAD, READONLY, CODE&#xA;  1 .data         00000000  00000000  00000000  00000036  2**0&#xA;                  CONTENTS, ALLOC, LOAD, DATA&#xA;  2 .bss          00000000  00000000  00000000  00000036  2**0&#xA;                  ALLOC&#xA;  3 .vectors      000001ac  00000000  00000000  00000038  2**2&#xA;                  CONTENTS, ALLOC, LOAD, RELOC, DATA&#xA;  4 .comment      0000004a  00000000  00000000  000001e4  2**0&#xA;                  CONTENTS, READONLY&#xA;  5 .ARM.attributes 0000002e  00000000  00000000  0000022e  2**0&#xA;                  CONTENTS, READONLY&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that VMA/LMA addresses for sections are set to 0 - meaning, &lt;code&gt;main.o&lt;/code&gt; is not yet a complete firmware, because it does not contain the information where those section should be loaded in the address space. We need to use a linker to produce a full firmware &lt;code&gt;firmware.elf&lt;/code&gt; from &lt;code&gt;main.o&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The section .text contains firmware code, in our case it is just a _reset() function, 2-bytes long - a jump instruction to its own address. There is an empty &lt;code&gt;.data&lt;/code&gt; section and an empty &lt;code&gt;.bss&lt;/code&gt; section (data that is initialized to zero) . Our firmware will be copied to the flash region at offset 0x8000000, but our data section should reside in RAM - therefore our &lt;code&gt;_reset()&lt;/code&gt; function should copy the contents of the &lt;code&gt;.data&lt;/code&gt; section to RAM. Also it has to write zeroes to the whole &lt;code&gt;.bss&lt;/code&gt; section. Our &lt;code&gt;.data&lt;/code&gt; and &lt;code&gt;.bss&lt;/code&gt; sections are empty, but let&#39;s modify our &lt;code&gt;_reset()&lt;/code&gt; function anyway to handle them properly.&lt;/p&gt; &#xA;&lt;p&gt;In order to do all that, we must know where stack starts, and where data and bss section start. This we can specify in the &#34;linker script&#34;, which is a file with the instructions to the linker, where to put various sections in the address space, and which symbols to create.&lt;/p&gt; &#xA;&lt;h3&gt;Linker script&lt;/h3&gt; &#xA;&lt;p&gt;Create a minimal linker script &lt;code&gt;link.ld&lt;/code&gt;, and copy-paste contents from &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-0-minimal/link.ld&#34;&gt;step-0-minimal/link.ld&lt;/a&gt;. Below is the explanation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ENTRY(_reset);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This line tells the linker the value of the &#34;entry point&#34; attribute in the generated ELF header - so this is a duplicate to what a vector table has. This is an aid for a debugger (like Ozone, described below) that helps to set a breakpoint at the beginning of the firmware. A debugger does not know about a vector table, so it relies on the ELF header.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;MEMORY {&#xA;  flash(rx)  : ORIGIN = 0x08000000, LENGTH = 2048k&#xA;  sram(rwx) : ORIGIN = 0x20000000, LENGTH = 192k  /* remaining 64k in a separate address space */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tells the linker that we have two memory regions in the address space, their addresses and sizes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;_estack     = ORIGIN(sram) + LENGTH(sram);    /* stack points to end of SRAM */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tell a linker to create a symbol &lt;code&gt;estack&lt;/code&gt; with value at the very end of the RAM memory region. That will be our initial stack value!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  .vectors  : { KEEP(*(.vectors)) }   &amp;gt; flash&#xA;  .text     : { *(.text*) }           &amp;gt; flash&#xA;  .rodata   : { *(.rodata*) }         &amp;gt; flash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These lines tell the linker to put vectors table on flash first, followed by &lt;code&gt;.text&lt;/code&gt; section (firmware code), followed by the read only data &lt;code&gt;.rodata&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The next goes &lt;code&gt;.data&lt;/code&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  .data : {&#xA;    _sdata = .;   /* .data section start */&#xA;    *(.first_data)&#xA;    *(.data SORT(.data.*))&#xA;    _edata = .;  /* .data section end */&#xA;  } &amp;gt; sram AT &amp;gt; flash&#xA;  _sidata = LOADADDR(.data);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we tell linker to create &lt;code&gt;_sdata&lt;/code&gt; and &lt;code&gt;_edata&lt;/code&gt; symbols. We&#39;ll use them to copy data section to RAM in the &lt;code&gt;_reset()&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Same for &lt;code&gt;.bss&lt;/code&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  .bss : {&#xA;    _sbss = .;              /* .bss section start */&#xA;    *(.bss SORT(.bss.*) COMMON)&#xA;    _ebss = .;              /* .bss section end */&#xA;  } &amp;gt; sram&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Startup code&lt;/h3&gt; &#xA;&lt;p&gt;Now we can update our &lt;code&gt;_reset()&lt;/code&gt; function. We copy &lt;code&gt;.data&lt;/code&gt; section to RAM, and initialise bss section to zeroes. Then, we call main() function - and fall into infinite loop in case if main() returns:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(void) {&#xA;  return 0; // Do nothing so far&#xA;}&#xA;&#xA;// Startup code&#xA;__attribute__((naked, noreturn)) void _reset(void) {&#xA;  // memset .bss to zero, and copy .data section to RAM region&#xA;  extern long _sbss, _ebss, _sdata, _edata, _sidata;&#xA;  for (long *src = &amp;amp;_sbss; src &amp;lt; &amp;amp;_ebss; src++) *src = 0;&#xA;  for (long *src = &amp;amp;_sdata, *dst = &amp;amp;_sidata; src &amp;lt; &amp;amp;_edata;) *src++ = *dst++;&#xA;&#xA;  main();             // Call main()&#xA;  for (;;) (void) 0;  // Infinite loop in the case if main() returns&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following diagram visualises how &lt;code&gt;_reset()&lt;/code&gt; initialises .data and .bss:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/mem2.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;firmware.bin&lt;/code&gt; file is just a concatenation of the three sections: &lt;code&gt;.vectors&lt;/code&gt; (IRQ vector table), &lt;code&gt;.text&lt;/code&gt; (code) and &lt;code&gt;.data&lt;/code&gt; (data). Those sections were built according to the linker script: &lt;code&gt;.vectors&lt;/code&gt; lies at the very beginning of flash, then &lt;code&gt;.text&lt;/code&gt; follows immediately after, and &lt;code&gt;.data&lt;/code&gt; lies far above. Addresses in &lt;code&gt;.text&lt;/code&gt; are in the flash region, and addresses in &lt;code&gt;.data&lt;/code&gt; are in the RAM region. If some function has address e.g. &lt;code&gt;0x8000100&lt;/code&gt;, then it it located exactly at that address on flash. But if the code accesses some variable in the &lt;code&gt;.data&lt;/code&gt; section by the address e.g. &lt;code&gt;0x20000200&lt;/code&gt;, then there is nothing at that address, because at boot, &lt;code&gt;.data&lt;/code&gt; section in the &lt;code&gt;firmware.bin&lt;/code&gt; resides in flash! That&#39;s why the startup code must relocate &lt;code&gt;.data&lt;/code&gt; section from flash region to the RAM region.&lt;/p&gt; &#xA;&lt;p&gt;Now we are ready to produce a full firmware file &lt;code&gt;firmware.elf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-gcc -T link.ld -nostdlib main.o -o firmware.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s examine sections in firmware.elf:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-objdump -h firmware.elf&#xA;...&#xA;Sections:&#xA;Idx Name          Size      VMA       LMA       File off  Algn&#xA;  0 .vectors      000001ac  08000000  08000000  00010000  2**2&#xA;                  CONTENTS, ALLOC, LOAD, DATA&#xA;  1 .text         00000058  080001ac  080001ac  000101ac  2**2&#xA;                  CONTENTS, ALLOC, LOAD, READONLY, CODE&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can see that the .vectors section will reside at the very beginning of flash memory at address 0x8000000, then the .text section right after it, at 0x80001ac. Our code does not create any variables, so there is no data section.&lt;/p&gt; &#xA;&lt;h2&gt;Flash firmware&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re ready to flash this firmware! First, extract sections from the firmware.elf into a single contiguous binary blob:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ arm-none-eabi-objcopy -O binary firmware.elf firmware.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use &lt;code&gt;st-link&lt;/code&gt; utility to flash the firmware.bin. Plug your board to the USB, and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ st-flash --reset write firmware.bin 0x8000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Done! We&#39;ve flashed a firmware that does nothing.&lt;/p&gt; &#xA;&lt;h2&gt;Makefile: build automation&lt;/h2&gt; &#xA;&lt;p&gt;Instead of typing those compilation, linking and flashing commands, we can use &lt;code&gt;make&lt;/code&gt; command line tool to automate the whole process. &lt;code&gt;make&lt;/code&gt; utility uses a configuration file named &lt;code&gt;Makefile&lt;/code&gt; where it reads instructions how to execute actions. This automation is great because it also documents the process of building firmware, used compilation flags, etc.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Makefile&lt;/code&gt; format is simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;action1:&#xA;&#x9;command ...     # Comments can go after hash symbol&#xA;&#x9;command ....    # IMPORTANT: command must be preceded with the TAB character&#xA;&#xA;action2:&#xA;&#x9;command ...     # Don&#39;t forget about TAB. Spaces won&#39;t work!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we can invoke &lt;code&gt;make&lt;/code&gt; with the action name (also called &lt;em&gt;target&lt;/em&gt;) to execute a corresponding action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make action1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible to define variables and use them in commands. Also, actions can be file names that needs to be created:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;firmware.elf:&#xA;&#x9;COMPILATION COMMAND .....&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, any action can have a list of dependencies. For example, &lt;code&gt;firmware.elf&lt;/code&gt; depends on our source file &lt;code&gt;main.c&lt;/code&gt;. Whenever &lt;code&gt;main.c&lt;/code&gt; file changes, the &lt;code&gt;make build&lt;/code&gt; command rebuilds &lt;code&gt;firmware.elf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;build: firmware.elf&#xA;&#xA;firmware.elf: main.c&#xA;&#x9;COMPILATION COMMAND&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we are ready to write a Makefile for our firmware. We define a &lt;code&gt;build&lt;/code&gt; action / target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;CFLAGS  ?=  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion \&#xA;            -Wformat-truncation -fno-common -Wconversion \&#xA;            -g3 -Os -ffunction-sections -fdata-sections -I. \&#xA;            -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 $(EXTRA_CFLAGS)&#xA;LDFLAGS ?= -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=$@.map&#xA;SOURCES = main.c &#xA;&#xA;build: firmware.elf&#xA;&#xA;firmware.elf: $(SOURCES)&#xA;&#x9;arm-none-eabi-gcc $(SOURCES) $(CFLAGS) $(LDFLAGS) -o $@&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There, we define compilation flags. The &lt;code&gt;?=&lt;/code&gt; means that&#39;s a default value; we could override them from the command line like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make build CFLAGS=&#34;-O2 ....&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We specify &lt;code&gt;CFLAGS&lt;/code&gt;, &lt;code&gt;LDFLAGS&lt;/code&gt; and &lt;code&gt;SOURCES&lt;/code&gt; variables. Then we tell &lt;code&gt;make&lt;/code&gt;: if you&#39;re told to &lt;code&gt;build&lt;/code&gt;, then create a &lt;code&gt;firmware.elf&lt;/code&gt; file. It depends on the &lt;code&gt;main.c&lt;/code&gt; file, and to create it, start &lt;code&gt;arm-none-eabi-gcc&lt;/code&gt; compiler with a given flags. &lt;code&gt;$@&lt;/code&gt; special variable expands to a target name - in our case, &lt;code&gt;firmware.elf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s call &lt;code&gt;make&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make build&#xA;arm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion -Wformat-truncation -fno-common -Wconversion -g3 -Os -ffunction-sections -fdata-sections -I. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16  -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=firmware.elf.map -o firmware.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we run it again:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make build&#xA;make: Nothing to be done for `build&#39;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;make&lt;/code&gt; utility examines modification times for &lt;code&gt;main.c&lt;/code&gt; dependency and &lt;code&gt;firmware.elf&lt;/code&gt; - and does not do anything if &lt;code&gt;firmware.elf&lt;/code&gt; is up to date. But if we change &lt;code&gt;main.c&lt;/code&gt;, then next &lt;code&gt;make build&lt;/code&gt; will recompile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ touch main.c # Simulate changes in main.c&#xA;$ make build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, what is left - is the &lt;code&gt;flash&lt;/code&gt; target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;firmware.bin: firmware.elf&#xA;&#x9;$(DOCKER) $(CROSS)-objcopy -O binary $&amp;lt; $@&#xA;&#xA;flash: firmware.bin&#xA;&#x9;st-flash --reset write $(TARGET).bin 0x8000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! Now, &lt;code&gt;make flash&lt;/code&gt; terminal command creates a &lt;code&gt;firmware.bin&lt;/code&gt; file, and flashes it to the board. It&#39;ll recompile the firmware if &lt;code&gt;main.c&lt;/code&gt; changes, because &lt;code&gt;firmware.bin&lt;/code&gt; depends on &lt;code&gt;firmware.elf&lt;/code&gt;, and it in turn depends on &lt;code&gt;main.c&lt;/code&gt;. So, now the development cycle would be these two actions in a loop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Develop code in main.c&#xA;$ make flash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is a good idea to add a clean target to remove build artifacts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;clean:&#xA;&#x9;rm -rf firmware.*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-0-minimal&#34;&gt;step-0-minimal&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Blinky LED&lt;/h2&gt; &#xA;&lt;p&gt;Now as we have the whole build / flash infrastructure set up, it is time to teach our firmware to do something useful. Something useful is of course blinking an LED. A Nucleo-F429ZI board has three built-in LEDs. In a Nucleo board datasheet section 6.5 we can see which pins built-in LEDs are attached to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PB0: green LED&lt;/li&gt; &#xA; &lt;li&gt;PB7: blue LED&lt;/li&gt; &#xA; &lt;li&gt;PB14: red LED&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s modify &lt;code&gt;main.c&lt;/code&gt; file and add our definitions for PIN, &lt;code&gt;gpio_set_mode()&lt;/code&gt;. In the main() function, we set the blue LED to output mode, and start an infinite loop. First, let&#39;s copy the definitions for pins and GPIO we have discussed earlier. Note we also add a convenience macro &lt;code&gt;BIT(position)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;inttypes.h&amp;gt;&#xA;#include &amp;lt;stdbool.h&amp;gt;&#xA;&#xA;#define BIT(x) (1UL &amp;lt;&amp;lt; (x))&#xA;#define PIN(bank, num) ((((bank) - &#39;A&#39;) &amp;lt;&amp;lt; 8) | (num))&#xA;#define PINNO(pin) (pin &amp;amp; 255)&#xA;#define PINBANK(pin) (pin &amp;gt;&amp;gt; 8)&#xA;&#xA;struct gpio {&#xA;  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];&#xA;};&#xA;#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))&#xA;&#xA;// Enum values are per datasheet: 0, 1, 2, 3&#xA;enum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };&#xA;&#xA;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (n * 2));         // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (n * 2);    // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some microcontrollers, when they are powered, have all their peripherals powered and enabled, automatically. STM32 MCUs, however, by default have their peripherals disabled in order to save power. In order to enable a GPIO peripheral, it should be enabled (clocked) via the RCC (Reset and Clock Control) unit. In the datasheet section 7.3.10 we find that the AHB1ENR (AHB1 peripheral clock enable register) is responsible to turn GPIO banks on or off. First we add a definition for the whole RCC unit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct rcc {&#xA;  volatile uint32_t CR, PLLCFGR, CFGR, CIR, AHB1RSTR, AHB2RSTR, AHB3RSTR,&#xA;      RESERVED0, APB1RSTR, APB2RSTR, RESERVED1[2], AHB1ENR, AHB2ENR, AHB3ENR,&#xA;      RESERVED2, APB1ENR, APB2ENR, RESERVED3[2], AHB1LPENR, AHB2LPENR,&#xA;      AHB3LPENR, RESERVED4, APB1LPENR, APB2LPENR, RESERVED5[2], BDCR, CSR,&#xA;      RESERVED6[2], SSCGR, PLLI2SCFGR;&#xA;};&#xA;#define RCC ((struct rcc *) 0x40023800)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the AHB1ENR register documentation we see that bits from 0 to 8 inclusive set the clock for GPIO banks GPIOA - GPIOE:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(void) {&#xA;  uint16_t led = PIN(&#39;B&#39;, 7);            // Blue LED&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(PINBANK(led));     // Enable GPIO clock for LED&#xA;  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode&#xA;  for (;;) asm volatile(&#34;nop&#34;);          // Infinite loop&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, what is left to do, is to find out how to set a GPIO pin on and off, and then modify the main loop to set an LED pin on, delay, off, delay. Looking at the datasheet section 8.4.7, wee see that the register BSRR is responsible for setting voltage high or low. The low 16 bit are used to set the ODR register (i.e. set pin high), and high 16 bit are used to reset the ODR register (i.e. set pin low). Let&#39;s define an API function for that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_write(uint16_t pin, bool val) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));&#xA;  gpio-&amp;gt;BSRR |= (1U &amp;lt;&amp;lt; PINNO(pin)) &amp;lt;&amp;lt; (val ? 0 : 16);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next we need to implement a delay function. We do not require an accurate delay at this moment, so let&#39;s define a function &lt;code&gt;spin()&lt;/code&gt; that just executes a NOP instruction a given number of times:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void spin(volatile uint32_t count) {&#xA;  while (count--) asm(&#34;nop&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, we&#39;re ready to modify our main loop to implement LED blinking:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  for (;;) {&#xA;    gpio_write(pin, true);&#xA;    spin(999999);&#xA;    gpio_write(pin, false);&#xA;    spin(999999);&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;make flash&lt;/code&gt; and enjoy blue LED flashing. A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-1-blinky&#34;&gt;step-1-blinky&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Blinky with SysTick interrupt&lt;/h2&gt; &#xA;&lt;p&gt;In order to implement an accurate time keeping, we should enable ARM&#39;s SysTick interrupt. SysTick a 24-bit hardware counter, and is part of ARM core, therefore it is documented by the ARM datasheet. Looking at the datasheet, we see that SysTick has four registers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CTRL - used to enable/disable systick&lt;/li&gt; &#xA; &lt;li&gt;LOAD - an initial counter value&lt;/li&gt; &#xA; &lt;li&gt;VAL - a current counter value, decremented on each clock cycle&lt;/li&gt; &#xA; &lt;li&gt;CALIB - calibration register&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Every time VAL drops to zero, a SysTick interrupt is generated. The SysTick interrupt index in the vector table is 15, so we need to set it. Upon boot, our board Nucleo-F429ZI runs at 16Mhz. We can configure the SysTick counter to trigger interrupt each millisecond.&lt;/p&gt; &#xA;&lt;p&gt;First, let&#39;s define a SysTick peripheral. We know 4 registers, and from the datasheet we can learn that the SysTick address is 0xe000e010. So:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct systick {&#xA;  volatile uint32_t CTRL, LOAD, VAL, CALIB;&#xA;};&#xA;#define SYSTICK ((struct systick *) 0xe000e010)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, add an API function that configures it. We need to enable SysTick in the &lt;code&gt;SYSTICK-&amp;gt;CTRL&lt;/code&gt; register, and also we must clock it via the &lt;code&gt;RCC-&amp;gt;APB2ENR&lt;/code&gt;, described in the section 7.4.14:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define BIT(x) (1UL &amp;lt;&amp;lt; (x))&#xA;static inline void systick_init(uint32_t ticks) {&#xA;  if ((ticks - 1) &amp;gt; 0xffffff) return;  // Systick timer is 24 bit&#xA;  SYSTICK-&amp;gt;LOAD = ticks - 1;&#xA;  SYSTICK-&amp;gt;VAL = 0;&#xA;  SYSTICK-&amp;gt;CTRL = BIT(0) | BIT(1) | BIT(2);  // Enable systick&#xA;  RCC-&amp;gt;APB2ENR |= BIT(14);                   // Enable SYSCFG&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, Nucleo-F429ZI board runs at 16Mhz. That means, if we call &lt;code&gt;systick_init(16000000 / 1000);&lt;/code&gt;, then SysTick interrupt will be generated every millisecond. We should have interrupt handler function defined - here it is, we simply increment a 32-bit millisecond counter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static volatile uint32_t s_ticks;&#xA;void SysTick_Handler(void) {&#xA;  s_ticks++;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And we should add this handler to the vector table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__attribute__((section(&#34;.vectors&#34;))) void (*tab[16 + 91])(void) = {&#xA;    0, _reset, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SysTick_Handler};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we have a precise millisecond clock! Let&#39;s create a helper function for arbitrary periodic timers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// t: expiration time, prd: period, now: current time. Return true if expired&#xA;bool timer_expired(uint32_t *t, uint64_t prd, uint64_t now) {&#xA;  if (now + prd &amp;lt; *t) *t = 0;                    // Time wrapped? Reset timer&#xA;  if (*t == 0) *t = now + prd;                   // First poll? Set expiration&#xA;  if (*t &amp;gt; now) return false;                    // Not expired yet, return&#xA;  *t = (now - *t) &amp;gt; prd ? now + prd : *t + prd;  // Next expiration time&#xA;  return true;                                   // Expired, return true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we are ready to update our main loop and use a precise timer for LED blink. For example, let&#39;s use 250 milliseconds blinking interval:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint32_t timer, period = 250;          // Declare timer and 250ms period&#xA;  for (;;) {&#xA;    if (timer_expired(&amp;amp;timer, period, s_ticks)) {&#xA;      static bool on;       // This block is executed&#xA;      gpio_write(led, on);  // Every `period` milliseconds&#xA;      on = !on;             // Toggle LED state&#xA;    }&#xA;    // Here we could perform other activities!&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that using SysTick, and a helper &lt;code&gt;timer_expired()&lt;/code&gt; function, we made our main loop (also called superloop) non-blocking. That means that inside that loop we can perform many actions - for example, have different timers with different periods, and they all will be triggered in time.&lt;/p&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-2-systick&#34;&gt;step-2-systick&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Add UART debug output&lt;/h2&gt; &#xA;&lt;p&gt;Now it&#39;s time to add a human-readable diagnostics to our firmware. One of the MCU peripherals is a serial UART interface. Looking at the datasheet section 2.3, we see that there are several UART/USART controllers - i.e. pieces of circuitry inside MCU that, properly configured, can exchange data via certain pins. A mimimal UART setup uses two pins, RX (receive) and TX (transmit).&lt;/p&gt; &#xA;&lt;p&gt;In a Nucleo board datasheet section 6.9 we see that one of the controllers, USART3, is using pins PD8 (TX) and PD9 (RX) and is connected to the on-board ST-LINK debugger. That means that if we configure USART3 and output data via the PD9 pin, we can see it on our workstation via the ST-LINK USB connection.&lt;/p&gt; &#xA;&lt;p&gt;Thus, let us create a handy API for the UART, the way we did it for GPIO. Datasheet section 30.6 summarises UART registers - so here is our UART struct:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct uart {&#xA;  volatile uint32_t SR, DR, BRR, CR1, CR2, CR3, GTPR;&#xA;};&#xA;#define UART1 ((struct uart *) 0x40011000)&#xA;#define UART2 ((struct uart *) 0x40004400)&#xA;#define UART3 ((struct uart *) 0x40004800)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To configure UART, we need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enable UART clock by setting appropriate bit in &lt;code&gt;RCC-&amp;gt;APB2ENR&lt;/code&gt; register&lt;/li&gt; &#xA; &lt;li&gt;Set &#34;alternate function&#34; pin mode for RX and TX pins. There can be several alternate functions (AF) for any given pin, depending on the peripheral that is used. The AF list can be found in the &lt;a href=&#34;https://www.st.com/resource/en/datasheet/stm32f429zi.pdf&#34;&gt;STM32F429ZI&lt;/a&gt; table 12&lt;/li&gt; &#xA; &lt;li&gt;Set baud rate (receive/transmit clock frequency) via the BRR register&lt;/li&gt; &#xA; &lt;li&gt;Enable the peripheral, receive and transmit via the CR1 register&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We already know how to set a GPIO pin into a specific mode. If a pin is in the AF mode, we also need to specify the &#34;function number&#34;, i.e. which exactly peripheral takes control. This can be done via the &#34;alternate function register&#34;, &lt;code&gt;AFR&lt;/code&gt;, of the GPIO peripheral. Reading the AFR register description in the datasheet, we can see that the AF number occupies 4 bits, thus the whole setup for 16 pins occupies 2 registers. If a p&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_set_af(uint16_t pin, uint8_t af_num) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  gpio-&amp;gt;AFR[n &amp;gt;&amp;gt; 3] &amp;amp;= ~(15UL &amp;lt;&amp;lt; ((n &amp;amp; 7) * 4));&#xA;  gpio-&amp;gt;AFR[n &amp;gt;&amp;gt; 3] |= ((uint32_t) af_num) &amp;lt;&amp;lt; ((n &amp;amp; 7) * 4);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to completely hide register-specific code from the GPIO API, let&#39;s move the GPIO clock init to the &lt;code&gt;gpio_set_mode()&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(PINBANK(pin));       // Enable GPIO clock&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we&#39;re ready to create a UART initialization API function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define FREQ 16000000  // CPU frequency, 16 Mhz&#xA;static inline void uart_init(struct uart *uart, unsigned long baud) {&#xA;  // https://www.st.com/resource/en/datasheet/stm32f429zi.pdf&#xA;  uint8_t af = 0;           // Alternate function&#xA;  uint16_t rx = 0, tx = 0;  // pins&#xA;&#xA;  if (uart == UART1) RCC-&amp;gt;APB2ENR |= BIT(4);&#xA;  if (uart == UART2) RCC-&amp;gt;APB1ENR |= BIT(17);&#xA;  if (uart == UART3) RCC-&amp;gt;APB1ENR |= BIT(18);&#xA;&#xA;  if (uart == UART1) af = 4, tx = PIN(&#39;A&#39;, 9), rx = PIN(&#39;A&#39;, 10);&#xA;  if (uart == UART2) af = 4, tx = PIN(&#39;A&#39;, 2), rx = PIN(&#39;A&#39;, 3);&#xA;  if (uart == UART3) af = 7, tx = PIN(&#39;D&#39;, 8), rx = PIN(&#39;D&#39;, 9);&#xA;&#xA;  gpio_set_mode(tx, GPIO_MODE_AF);&#xA;  gpio_set_af(tx, af);&#xA;  gpio_set_mode(rx, GPIO_MODE_AF);&#xA;  gpio_set_af(rx, af);&#xA;  uart-&amp;gt;CR1 = 0;                           // Disable this UART&#xA;  uart-&amp;gt;BRR = FREQ / baud;                 // FREQ is a CPU frequency &#xA;  uart-&amp;gt;CR1 |= BIT(13) | BIT(2) | BIT(3);  // Set UE, RE, TE&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, finally, functions for reading and writing to the UART. The datasheet section 30.6.1 tells us that the status register SR tells us whether data is ready:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline int uart_read_ready(struct uart *uart) {&#xA;  return uart-&amp;gt;SR &amp;amp; BIT(5);  // If RXNE bit is set, data is ready&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The data byte itself can be fetched from the data register DR:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline uint8_t uart_read_byte(struct uart *uart) {&#xA;  return (uint8_t) (uart-&amp;gt;DR &amp;amp; 255);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Transmitting a single byte can be done via the data register too. After setting a byte to write, we need to wait for the transmission to end, indicated via bit 7 in the status register:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void uart_write_byte(struct uart *uart, uint8_t byte) {&#xA;  uart-&amp;gt;DR = byte;&#xA;  while ((uart-&amp;gt;SR &amp;amp; BIT(7)) == 0) spin(1);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And writing a buffer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void uart_write_buf(struct uart *uart, char *buf, size_t len) {&#xA;  while (len-- &amp;gt; 0) uart_write_byte(uart, *(uint8_t *) buf++);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, initialise UART in our main() function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  ...&#xA;  uart_init(UART3, 115200);              // Initialise UART&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we&#39;re ready to print a message &#34;hi\r\n&#34; every time LED blinks!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (timer_expired(&amp;amp;timer, period, s_ticks)) {&#xA;      ...&#xA;      uart_write_buf(UART3, &#34;hi\r\n&#34;, 4);  // Write message&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rebuild, reflash, and attach a terminal program to the ST-LINK port. On my Mac workstation, I use &lt;code&gt;cu&lt;/code&gt;. It also can be used on Linux. On Windows, using &lt;code&gt;putty&lt;/code&gt; utility can be a good idea. Run a terminal and see the messages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cu -l /dev/cu.YOUR_SERIAL_PORT -s 115200&#xA;hi&#xA;hi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-3-uart&#34;&gt;step-3-uart&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Redirect printf() to UART&lt;/h2&gt; &#xA;&lt;p&gt;In this section, we replace &lt;code&gt;uart_write_buf()&lt;/code&gt; call by &lt;code&gt;printf()&lt;/code&gt; call, which gives us an ability to do formatted output - and increase our abilities to print diagnostic information, implemeting so called &#34;printf-style debugging&#34;.&lt;/p&gt; &#xA;&lt;p&gt;A GNU ARM toolchain that we&#39;re using comes not only with a GCC compiler and other tools, but with a C library called newlib, &lt;a href=&#34;https://sourceware.org/newlib&#34;&gt;https://sourceware.org/newlib&lt;/a&gt;. A newlib library was developed by RedHat for embedded systems.&lt;/p&gt; &#xA;&lt;p&gt;If our firmware calls a standard C library function, for example &lt;code&gt;strcmp()&lt;/code&gt;, then a newlib code will be added to our firmware by the GCC linker.&lt;/p&gt; &#xA;&lt;p&gt;Some of the standard C functions that newlib implements, specifically, file input/output (IO) operations, implemented by the newlib is a special fashion: those functions eventually call a set of low-level IO functions called &#34;sycalls&#34;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;fopen()&lt;/code&gt; eventually calls &lt;code&gt;_open()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fread()&lt;/code&gt; eventually calls a low level &lt;code&gt;_read()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fwrite()&lt;/code&gt;, &lt;code&gt;fprintf()&lt;/code&gt;, &lt;code&gt;printf()&lt;/code&gt; eventually call a low level &lt;code&gt;_write()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;malloc()&lt;/code&gt; eventually calls &lt;code&gt;_sbrk()&lt;/code&gt;, and so on.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thus, by modifying a &lt;code&gt;_write()&lt;/code&gt; syscall, we can redirect printf() to whatever we want. That mechanism is called &#34;IO retargeting&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Note: STM32 Cube also uses ARM GCC with newlib, that&#39;s why Cube projects typically include &lt;code&gt;syscalls.c&lt;/code&gt; file. Other toolchains, like TI&#39;s CCS, Keil&#39;s CC, might use a different C library with a bit different retargeting mechanism. We use newlib, so let&#39;s modify &lt;code&gt;_write()&lt;/code&gt; syscall to print to the UART3.&lt;/p&gt; &#xA;&lt;p&gt;Before that, let&#39;s organise our source code in the following way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;move all API definitions to the file &lt;code&gt;mcu.h&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;move startup code to &lt;code&gt;startup.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;create an empty file &lt;code&gt;syscalls.c&lt;/code&gt; for newlib &#34;syscalls&#34;&lt;/li&gt; &#xA; &lt;li&gt;modify Makefile to add &lt;code&gt;syscalls.c&lt;/code&gt; and &lt;code&gt;startup.c&lt;/code&gt; to the build&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After moving all API definitions to the &lt;code&gt;mcu.h&lt;/code&gt;, our &lt;code&gt;main.c&lt;/code&gt; file becomes quite compact. Note that it does not have any mention of the low-level registers, just a high level API functions that are easy to understand:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;mcu.h&#34;&#xA;&#xA;static volatile uint32_t s_ticks;&#xA;void SysTick_Handler(void) {&#xA;  s_ticks++;&#xA;}&#xA;&#xA;int main(void) {&#xA;  uint16_t led = PIN(&#39;B&#39;, 7);            // Blue LED&#xA;  systick_init(16000000 / 1000);         // Tick every 1 ms&#xA;  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode&#xA;  uart_init(UART3, 115200);              // Initialise UART&#xA;  uint32_t timer = 0, period = 250;      // Declare timer and 250ms period&#xA;  for (;;) {&#xA;    if (timer_expired(&amp;amp;timer, period, s_ticks)) {&#xA;      static bool on;                      // This block is executed&#xA;      gpio_write(led, on);                 // Every `period` milliseconds&#xA;      on = !on;                            // Toggle LED state&#xA;      uart_write_buf(UART3, &#34;hi\r\n&#34;, 4);  // Write message&#xA;    }&#xA;    // Here we could perform other activities!&#xA;  }&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Great, now let&#39;s retarget printf to the UART3. In the empty syscalls.c, copy/paste the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;mcu.h&#34;&#xA;&#xA;int _write(int fd, char *ptr, int len) {&#xA;  (void) fd, (void) ptr, (void) len;&#xA;  if (fd == 1) uart_write_buf(UART3, ptr, (size_t) len);&#xA;  return -1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we say: if the file descriptor we&#39;re writing to is 1 (which is a standard output descriptor), then write the buffer to the UART3. Otherwise, ignore. This is the essence of retargeting!&lt;/p&gt; &#xA;&lt;p&gt;Rebuilding this firmware results in a bunch of linker errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-sbrkr.o): in function `_sbrk_r&#39;:&#xA;sbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk&#39;&#xA;closer.c:(.text._close_r+0xc): undefined reference to `_close&#39;&#xA;lseekr.c:(.text._lseek_r+0x10): undefined reference to `_lseek&#39;&#xA;readr.c:(.text._read_r+0x10): undefined reference to `_read&#39;&#xA;fstatr.c:(.text._fstat_r+0xe): undefined reference to `_fstat&#39;&#xA;isattyr.c:(.text._isatty_r+0xc): undefined reference to `_isatty&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since we&#39;ve used a newlib stdio function, we need to supply newlib with the rest of syscalls. Let&#39;s add just a simple stubs that do nothing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int _fstat(int fd, struct stat *st) {&#xA;  (void) fd, (void) st;&#xA;  return -1;&#xA;}&#xA;&#xA;void *_sbrk(int incr) {&#xA;  (void) incr;&#xA;  return NULL;&#xA;}&#xA;&#xA;int _close(int fd) {&#xA;  (void) fd;&#xA;  return -1;&#xA;}&#xA;&#xA;int _isatty(int fd) {&#xA;  (void) fd;&#xA;  return 1;&#xA;}&#xA;&#xA;int _read(int fd, char *ptr, int len) {&#xA;  (void) fd, (void) ptr, (void) len;&#xA;  return -1;&#xA;}&#xA;&#xA;int _lseek(int fd, int ptr, int dir) {&#xA;  (void) fd, (void) ptr, (void) dir;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, rebuild gives no errors. Last step: replace the &lt;code&gt;uart_write_buf()&lt;/code&gt; call in the &lt;code&gt;main()&lt;/code&gt; function with &lt;code&gt;printf()&lt;/code&gt; call that prints something useful, e.g. a LED status and a current value of systick:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&#34;LED: %d, tick: %lu\r\n&#34;, on, s_ticks);  // Write message&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The serial output looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;LED: 1, tick: 250&#xA;LED: 0, tick: 500&#xA;LED: 1, tick: 750&#xA;LED: 0, tick: 1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Congratulations! We learned how IO retargeting works, and can now printf-debug our firmware. A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-4-printf&#34;&gt;step-4-printf&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Debug with Segger Ozone&lt;/h2&gt; &#xA;&lt;p&gt;What if our firmware is stuck somewhere and printf debug does not work? What if even a startup code does not work? We would need a debugger. There are many options, but I&#39;d recommend using an Ozone debugger from Segger. Why? Because it is stand-alone. It does not need any IDE set up. We can feed our &lt;code&gt;firmware.elf&lt;/code&gt; directly to Ozone, and it&#39;ll pick up our source files.&lt;/p&gt; &#xA;&lt;p&gt;So, &lt;a href=&#34;https://www.segger.com/products/development-tools/ozone-j-link-debugger/&#34;&gt;download Ozone&lt;/a&gt; from the Segger website. Before we can use it with our Nucleo board, we need to convert ST-LINK firmware on the onboard debugger to the jlink firmware that Ozone understands. Follow the &lt;a href=&#34;https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/&#34;&gt;instructions&lt;/a&gt; on the Segger site.&lt;/p&gt; &#xA;&lt;p&gt;Now, run Ozone. Choose our device in the wizard:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone1.png&#34; width=&#34;50%&#34;&gt; &#xA;&lt;p&gt;Select a debugger we&#39;re going to use - that should be a ST-LINK:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone2.png&#34; width=&#34;50%&#34;&gt; &#xA;&lt;p&gt;Choose our firmware.elf file:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone3.png&#34; width=&#34;50%&#34;&gt; &#xA;&lt;p&gt;Leave the defaults on the next screen, click Finish, and we&#39;ve got our debugger loaded (note the mcu.h source code is picked up):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Click the green button to download, run the firmware, and we&#39;re stopped here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now we can single-step through code, set breakpoints, and do the usual debugging stuff. One thing that could be noted, is a handy Ozone peripheral view:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Using it, we can directly examine or set the state of the peripherals. For example, let&#39;s turn on a green on-board LED (PB0):&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We need to clock GPIOB first. Find Peripherals -&amp;gt; RCC -&amp;gt; AHB1ENR, and enable GPIOBEN bit - set it to 1:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone7.png&#34; width=&#34;75%&#34;&gt; 2. Find Peripherals -&amp;gt; GPIO -&amp;gt; GPIOB -&amp;gt; MODER, set MODER0 to 1 (output): &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone8.png&#34; width=&#34;75%&#34;&gt; 3. Find Peripherals -&amp;gt; GPIO -&amp;gt; GPIOB -&amp;gt; ODR, set ODR0 to 1 (on): &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/images/ozone9.png&#34; width=&#34;75%&#34;&gt; &#xA;&lt;p&gt;Now, a green LED should be on! Happy debugging.&lt;/p&gt; &#xA;&lt;h2&gt;Vendor CMSIS headers&lt;/h2&gt; &#xA;&lt;p&gt;In the previous sections, we have developed the firmware using only datasheets, editor, and GCC compiler. We have created peripheral structure definitions manually, using datasheets.&lt;/p&gt; &#xA;&lt;p&gt;Now as you know how it all works, it is time to introduce CMSIS headers. What is it ? These are header files with all definitions, created and supplied by the MCU vendor. They contain definitions for everything that MCU contains, therefore they rather big.&lt;/p&gt; &#xA;&lt;p&gt;CMSIS stands for Common Microcontroller Software Interface Standard, thus it is a common ground for the MCU manufacturers to specify peripheral API. Since CMSIS is an ARM standard, and since CMSIS headers are supplied by the MCU vendor, they are the source of authority. Therefore, using vendor headers is is a preferred way, rather than writing definitions manually.&lt;/p&gt; &#xA;&lt;p&gt;In this section, we will replace our API functions in the &lt;code&gt;mcu.h&lt;/code&gt; by the CMSIS vendor header, and leave the rest of the firmware intact.&lt;/p&gt; &#xA;&lt;p&gt;STM32 CMSIS headers for F4 family can be found at &lt;a href=&#34;https://github.com/STMicroelectronics/cmsis_device_f4&#34;&gt;https://github.com/STMicroelectronics/cmsis_device_f4&lt;/a&gt; repo. From there, copy the following files into our firmware directory, &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-5-cmsis&#34;&gt;step-5-cmsis&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f4/master/Include/stm32f429xx.h&#34;&gt;stm32f429xx.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f4/master/Include/system_stm32f4xx.h&#34;&gt;system_stm32f4xx.h&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Those two files depend on a standard ARM CMSIS includes, download them too:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/core_cm4.h&#34;&gt;core_cm4.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_gcc.h&#34;&gt;cmsis_gcc.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_version.h&#34;&gt;cmsis_version.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_compiler.h&#34;&gt;cmsis_compiler.h&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/mpu_armv7.h&#34;&gt;mpu_armv7.h&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;From the &lt;code&gt;mcu.h&lt;/code&gt;, remove all peripheral API and definitions, and leave only standard C inludes, vendor CMSIS include, defines to PIN, BIT, FREQ, and &lt;code&gt;timer_expired()&lt;/code&gt; helper function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#pragma once&#xA;&#xA;#include &amp;lt;inttypes.h&amp;gt;&#xA;#include &amp;lt;stdbool.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;sys/stat.h&amp;gt;&#xA;&#xA;#include &#34;stm32f429xx.h&#34;&#xA;&#xA;#define FREQ 16000000  // CPU frequency, 16 Mhz&#xA;#define BIT(x) (1UL &amp;lt;&amp;lt; (x))&#xA;#define PIN(bank, num) ((((bank) - &#39;A&#39;) &amp;lt;&amp;lt; 8) | (num))&#xA;#define PINNO(pin) (pin &amp;amp; 255)&#xA;#define PINBANK(pin) (pin &amp;gt;&amp;gt; 8)&#xA;&#xA;static inline void spin(volatile uint32_t count) {&#xA;  while (count--) asm(&#34;nop&#34;);&#xA;}&#xA;&#xA;static inline bool timer_expired(uint32_t *t, uint32_t prd, uint32_t now) {&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we try to rebuild the firmware - &lt;code&gt;make clean build&lt;/code&gt;, then GCC will fail complaining about missing &lt;code&gt;systick_init()&lt;/code&gt;, &lt;code&gt;GPIO_MODE_OUTPUT&lt;/code&gt;, &lt;code&gt;uart_init()&lt;/code&gt;, and &lt;code&gt;UART3&lt;/code&gt;. Let&#39;s add those using STM32 CMSIS files.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s start from &lt;code&gt;systick_init()&lt;/code&gt;. The &lt;code&gt;core_cm4.h&lt;/code&gt; header defines &lt;code&gt;SysTick_Type&lt;/code&gt; structure which is identical to our &lt;code&gt;struct systick&lt;/code&gt;, and has an appropriate #define for &lt;code&gt;SysTick&lt;/code&gt; peripheral. Also, &lt;code&gt;stm32f429xx.h&lt;/code&gt; has a &lt;code&gt;RCC_TypeDef&lt;/code&gt; structure and appropriate #define for the &lt;code&gt;RCC&lt;/code&gt;. Therefore our &lt;code&gt;systick_init()&lt;/code&gt; function remains almost unchanged: we only have to replace &lt;code&gt;SYSTICK&lt;/code&gt; with &lt;code&gt;SysTick&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void systick_init(uint32_t ticks) {&#xA;  if ((ticks - 1) &amp;gt; 0xffffff) return;  // Systick timer is 24 bit&#xA;  SysTick-&amp;gt;LOAD = ticks - 1;&#xA;  SysTick-&amp;gt;VAL = 0;&#xA;  SysTick-&amp;gt;CTRL = BIT(0) | BIT(1) | BIT(2);  // Enable systick&#xA;  RCC-&amp;gt;APB2ENR |= BIT(14);                   // Enable SYSCFG&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next goes &lt;code&gt;gpio_set_mode()&lt;/code&gt; function. The &lt;code&gt;stm32f429xx.h&lt;/code&gt; header has &lt;code&gt;GPIO_TypeDef&lt;/code&gt; structure, identical to our &lt;code&gt;struct gpio&lt;/code&gt;. Let&#39;s use it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define GPIO(bank) ((GPIO_TypeDef *) (GPIOA_BASE + 0x400 * (bank)))&#xA;enum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };&#xA;&#xA;static inline void gpio_set_mode(uint16_t pin, uint8_t mode) {&#xA;  GPIO_TypeDef *gpio = GPIO(PINBANK(pin));  // GPIO bank&#xA;  int n = PINNO(pin);                      // Pin number&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(PINBANK(pin));       // Enable GPIO clock&#xA;  gpio-&amp;gt;MODER &amp;amp;= ~(3U &amp;lt;&amp;lt; (n * 2));         // Clear existing setting&#xA;  gpio-&amp;gt;MODER |= (mode &amp;amp; 3) &amp;lt;&amp;lt; (n * 2);    // Set new mode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;gpio_set_af()&lt;/code&gt; and &lt;code&gt;gpio_write()&lt;/code&gt; functions is also trivial - simply replace &lt;code&gt;struct gpio&lt;/code&gt; with &lt;code&gt;GPIO_TypeDef&lt;/code&gt;, and that&#39;s all.&lt;/p&gt; &#xA;&lt;p&gt;Next goes UART. There is a &lt;code&gt;USART_TypeDef&lt;/code&gt;, and defines for USART1, USART2, USART3. Let&#39;s use them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define UART1 USART1&#xA;#define UART2 USART2&#xA;#define UART3 USART3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;code&gt;uart_init()&lt;/code&gt; and the rest of UART functions, change &lt;code&gt;struct uart&lt;/code&gt; to &lt;code&gt;USART_TypeDef&lt;/code&gt;. The rest stays the same!&lt;/p&gt; &#xA;&lt;p&gt;And we are done. Rebuild, reflash the firmware. The LED blinks, the UART shows the output. Congratulations, we have adopted our firmware code to use vendor CMSIS header files. Now let&#39;s reorganise the repository a bit by moving all standard files into &lt;code&gt;include&lt;/code&gt; directory and updating Makefile to let GCC know about it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;...&#xA;  -g3 -Os -ffunction-sections -fdata-sections -I. -Iinclude \&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have left with a project template that can be reused for the future projects. A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-5-cmsis&#34;&gt;step-5-cmsis&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Setting up clocks&lt;/h2&gt; &#xA;&lt;p&gt;After boot, Nucleo-F429ZI CPU runs at 16MHz. The maximum frequency is 180MHz. Note that system clock frequency is not the only factor we need to care about. Peripherals are attached to different buses, APB1 and APB2 which are clocked differently. Their clock speeds are configured by the frequency prescaler values, set in the RCC. The main CPU clock source can also be different - we can use either an external crystal oscillator (HSE) or an internal oscillator (HSI). In our case, we&#39;ll use HSI.&lt;/p&gt; &#xA;&lt;p&gt;When CPU executes instructions from flash, a flash read speed (which is around 25MHz) becomes a bottleneck if CPU clock gets higher. There are several tricks that can help. Instruction prefetch is one. Also, we can give a clue to the flash controller, how faster the system clock is: that value is called flash latency. For 180MHz system clock, the &lt;code&gt;FLASH_LATENCY&lt;/code&gt; value is 5. Bits 8 and 9 in the flash controller enable instruction and data caches:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  FLASH-&amp;gt;ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash latency, caches&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The clock source (HSI or HSE) goes through a piece of hardware called PLL, which multiplies source frequency by a certain value. Then, a set of frequency dividers are used to set the system clock and APB1, APB2 clocks. In order to obtain the maximum system clock of 180MHz, multiple values of PLL dividers and APB prescalers are possible. Section 6.3.3 of the datasheet tells us the maximum values for APB1 clock: &amp;lt;= 45MHz, and the APB2 clock: &amp;lt;= 90MHz. That narrows down the list of possible combinations. Here we chose the values manually. Note that tools like CubeMX can automate the process and make it easy and visual.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum { APB1_PRE = 5 /* AHB clock / 4 */, APB2_PRE = 4 /* AHB clock / 2 */ };&#xA;enum { PLL_HSI = 16, PLL_M = 8, PLL_N = 180, PLL_P = 2 };  // Run at 180 Mhz&#xA;#define PLL_FREQ (PLL_HSI * PLL_N / PLL_M / PLL_P)&#xA;#define FREQ (PLL_FREQ * 1000000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we&#39;re ready for a simple algorithm to set up the clock for CPU and peripheral buses may look like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optionally, enable FPU&lt;/li&gt; &#xA; &lt;li&gt;Set flash latency&lt;/li&gt; &#xA; &lt;li&gt;Decide on a clock source, and PLL, APB1 and APB2 prescalers&lt;/li&gt; &#xA; &lt;li&gt;Configure RCC by setting respective values:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void clock_init(void) {                 // Set clock frequency&#xA;  SCB-&amp;gt;CPACR |= ((3UL &amp;lt;&amp;lt; 10 * 2) | (3UL &amp;lt;&amp;lt; 11 * 2));  // Enable FPU&#xA;  FLASH-&amp;gt;ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash latency, caches&#xA;  RCC-&amp;gt;PLLCFGR &amp;amp;= ~((BIT(17) - 1));                   // Clear PLL multipliers&#xA;  RCC-&amp;gt;PLLCFGR |= (((PLL_P - 2) / 2) &amp;amp; 3) &amp;lt;&amp;lt; 16;      // Set PLL_P&#xA;  RCC-&amp;gt;PLLCFGR |= PLL_M | (PLL_N &amp;lt;&amp;lt; 6);               // Set PLL_M and PLL_N&#xA;  RCC-&amp;gt;CR |= BIT(24);                                 // Enable PLL&#xA;  while ((RCC-&amp;gt;CR &amp;amp; BIT(25)) == 0) spin(1);           // Wait until done&#xA;  RCC-&amp;gt;CFGR = (APB1_PRE &amp;lt;&amp;lt; 10) | (APB2_PRE &amp;lt;&amp;lt; 13);    // Set prescalers&#xA;  RCC-&amp;gt;CFGR |= 2;                                     // Set clock source to PLL&#xA;  while ((RCC-&amp;gt;CFGR &amp;amp; 12) == 0) spin(1);              // Wait until done&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What is left, is to call &lt;code&gt;clock_init()&lt;/code&gt; from main, then rebuild and reflash. And our board runs at its maximum speed, 180MHz! A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-6-clock&#34;&gt;step-6-clock&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Web server with device dashboard&lt;/h2&gt; &#xA;&lt;p&gt;The Nucleo-F429ZI comes with Ethernet on-board. Ethernet hardware needs two components: a PHY (which transmits/receives electrical signals to the media like copper, optical cable, etc) and MAC (which drives PHY controller). On our Nucleo, the MAC controller is built-in, and the PHY is external (specifically, is is Microchip&#39;s LAN8720a).&lt;/p&gt; &#xA;&lt;p&gt;MAC and PHY can talk several interfaces, we&#39;ll use RMII. For that, a bunch of pins must be configured to use their Alternative Function (AF). To implement a web server, we need 3 software components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a network driver, which sends/receives Ethernet frames to/from MAC controller&lt;/li&gt; &#xA; &lt;li&gt;a network stack, that parses frames and understands TCP/IP&lt;/li&gt; &#xA; &lt;li&gt;a network library that understands HTTP&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We will use &lt;a href=&#34;https://github.com/cesanta/mongoose&#34;&gt;Mongoose Network Library&lt;/a&gt; which implements all of that in a single file. It is a dual-licensed library (GPLv2/commercial) that was designed to make network embedded development fast and easy.&lt;/p&gt; &#xA;&lt;p&gt;So, copy &lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.c&#34;&gt;mongoose.c&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.h&#34;&gt;mongoose.h&lt;/a&gt; to our project. Now we have a driver, a network stack, and a library at hand. Mongoose also provides a large set of examples, and one of them is a &lt;a href=&#34;https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard&#34;&gt;device dashboard example&lt;/a&gt;. It implements lots of things - like dashboard login, real-time data exchange over WebSocket, embedded file system, MQTT communication, etcetera. So let&#39;s use that example. Copy two extra files:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/net.c&#34;&gt;net.c&lt;/a&gt; - implements dashboard functionality&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/packed_fs.c&#34;&gt;packed_fs.c&lt;/a&gt; - contains HTML/CSS/JS GUI files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What we need is to tell Mongoose which functionality to enable. That can be done via compilation flags, by setting preprocessor constants. Alternatively, the same constants can be set in the &lt;code&gt;mongoose_custom.h&lt;/code&gt; file. Let&#39;s go the second way. Create &lt;code&gt;mongoose_custom.h&lt;/code&gt; file with the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#pragma once&#xA;#define MG_ARCH MG_ARCH_NEWLIB&#xA;#define MG_ENABLE_MIP 1&#xA;#define MG_ENABLE_PACKED_FS 1&#xA;#define MG_IO_SIZE 512&#xA;#define MG_ENABLE_CUSTOM_MILLIS 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now it&#39;s time to add some networking code to main.c. We &lt;code&gt;#include &#34;mongoose.c&#34;&lt;/code&gt;, initialise Ethernet RMII pins and enable Ethernet in the RCC:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  uint16_t pins[] = {PIN(&#39;A&#39;, 1),  PIN(&#39;A&#39;, 2),  PIN(&#39;A&#39;, 7),&#xA;                     PIN(&#39;B&#39;, 13), PIN(&#39;C&#39;, 1),  PIN(&#39;C&#39;, 4),&#xA;                     PIN(&#39;C&#39;, 5),  PIN(&#39;G&#39;, 11), PIN(&#39;G&#39;, 13)};&#xA;  for (size_t i = 0; i &amp;lt; sizeof(pins) / sizeof(pins[0]); i++) {&#xA;    gpio_init(pins[i], GPIO_MODE_AF, GPIO_OTYPE_PUSH_PULL, GPIO_SPEED_INSANE,&#xA;              GPIO_PULL_NONE, 11);&#xA;  }&#xA;  nvic_enable_irq(61);                          // Setup Ethernet IRQ handler&#xA;  RCC-&amp;gt;APB2ENR |= BIT(14);                      // Enable SYSCFG&#xA;  SYSCFG-&amp;gt;PMC |= BIT(23);                       // Use RMII. Goes first!&#xA;  RCC-&amp;gt;AHB1ENR |= BIT(25) | BIT(26) | BIT(27);  // Enable Ethernet clocks&#xA;  RCC-&amp;gt;AHB1RSTR |= BIT(25);                     // ETHMAC force reset&#xA;  RCC-&amp;gt;AHB1RSTR &amp;amp;= ~BIT(25);                    // ETHMAC release reset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mongoose&#39;s driver uses Ethernet interrupt, thus we need to update &lt;code&gt;startup.c&lt;/code&gt; and add &lt;code&gt;ETH_IRQHandler&lt;/code&gt; to the vector table. Let&#39;s reorganise vector table definition in &lt;code&gt;startup.c&lt;/code&gt; in a way that does not require any modification to add an interrupt handler function. The idea is to use a &#34;weak symbol&#34; concept.&lt;/p&gt; &#xA;&lt;p&gt;A function can be marked &#34;weak&#34; and it works like a normal function. The difference comes when a source code defines a function with the same name elsewhere. Normally, two functions with the same name make a build fail. However if one function is marked weak, then a build succeeds and linker selects a non-weak function. This gives an ability to provide a &#34;default&#34; function in a boilerplate, with an ability to override it by simply creating a function with the same name elsewhere in the code.&lt;/p&gt; &#xA;&lt;p&gt;Here how it works in our case. We want to fill a vector table with default handlers, but give user an ability to override any handler. For that, we create a function &lt;code&gt;DefaultIRQHandler()&lt;/code&gt; and mark it weak. Then, for every IRQ handler, we declare a handler name and make it an alias to &lt;code&gt;DefaultIRQHandler()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __attribute__((weak)) DefaultIRQHandler(void) {&#xA;  for (;;) (void) 0;&#xA;}&#xA;#define WEAK_ALIAS __attribute__((weak, alias(&#34;DefaultIRQHandler&#34;)))&#xA;&#xA;WEAK_ALIAS void NMI_Handler(void);&#xA;WEAK_ALIAS void HardFault_Handler(void);&#xA;WEAK_ALIAS void MemManage_Handler(void);&#xA;...&#xA;__attribute__((section(&#34;.vectors&#34;))) void (*tab[16 + 91])(void) = {&#xA;    0, _reset, NMI_Handler, HardFault_Handler, MemManage_Handler,&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we can define any IRQ handler in our code, and it will replace the default one. This is what happens in our case: there is a &lt;code&gt;ETH_IRQHandler()&lt;/code&gt; defined by the Mongoose&#39;s STM32 driver which replaces a default handler.&lt;/p&gt; &#xA;&lt;p&gt;The next step is to initialise Mongoose library: create an event manager, setup network driver, and start a listening HTTP connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  struct mg_mgr mgr;        // Initialise Mongoose event manager&#xA;  mg_mgr_init(&amp;amp;mgr);        // and attach it to the MIP interface&#xA;  mg_log_set(MG_LL_DEBUG);  // Set log level&#xA;&#xA;  struct mip_driver_stm32 driver_data = {.mdc_cr = 4};  // See driver_stm32.h&#xA;  struct mip_if mif = {&#xA;      .mac = {2, 0, 1, 2, 3, 5},&#xA;      .use_dhcp = true,&#xA;      .driver = &amp;amp;mip_driver_stm32,&#xA;      .driver_data = &amp;amp;driver_data,&#xA;  };&#xA;  mip_init(&amp;amp;mgr, &amp;amp;mif);&#xA;  extern void device_dashboard_fn(struct mg_connection *, int, void *, void *);&#xA;  mg_http_listen(&amp;amp;mgr, &#34;http://0.0.0.0&#34;, device_dashboard_fn, &amp;amp;mgr);&#xA;  MG_INFO((&#34;Init done, starting main loop&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What is left, is to add a &lt;code&gt;mg_mgr_poll()&lt;/code&gt; call into the main loop.&lt;/p&gt; &#xA;&lt;p&gt;Now, add &lt;code&gt;mongoose.c&lt;/code&gt;, &lt;code&gt;net.c&lt;/code&gt; and &lt;code&gt;packed_fs.c&lt;/code&gt; files to the Makefile. Rebuild, reflash the board. Attach a serial console to the debug output, observe that the board obtains an IP address over DHCP:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;847 3 mongoose.c:6784:arp_cache_add     ARP cache: added 0xc0a80001 @ 90:5c:44:55:19:8b&#xA;84e 2 mongoose.c:6817:onstatechange     READY, IP: 192.168.0.24&#xA;854 2 mongoose.c:6818:onstatechange            GW: 192.168.0.1&#xA;859 2 mongoose.c:6819:onstatechange            Lease: 86363 sec&#xA;LED: 1, tick: 2262&#xA;LED: 0, tick: 2512&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fire up a browser at that IP address, and get a working dashboard, with real-time graph over WebSocket, with MQTT, authentication, and other things! See &lt;a href=&#34;https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard&#34;&gt;full description&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/screenshots/dashboard.png&#34; alt=&#34;Device dashboard&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A complete project source code you can find in &lt;a href=&#34;https://raw.githubusercontent.com/cpq/bare-metal-programming-guide/main/step-7-webserver&#34;&gt;step-7-webserver&lt;/a&gt; directory.&lt;/p&gt;</summary>
  </entry>
</feed>