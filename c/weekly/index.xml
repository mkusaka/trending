<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-19T02:03:48Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tr3ee/CVE-2022-23222</title>
    <updated>2022-06-19T02:03:48Z</updated>
    <id>tag:github.com,2022-06-19:/tr3ee/CVE-2022-23222</id>
    <link href="https://github.com/tr3ee/CVE-2022-23222" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CVE-2022-23222: Linux Kernel eBPF Local Privilege Escalation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CVE-2022-23222&lt;/h1&gt; &#xA;&lt;p&gt;Chinese writeup: &lt;a href=&#34;https://tr3e.ee/posts/cve-2022-23222-linux-kernel-ebpf-lpe.txt&#34;&gt;https://tr3e.ee/posts/cve-2022-23222-linux-kernel-ebpf-lpe.txt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For educational/research purposes only. Use at your own risk.&lt;/p&gt; &#xA;&lt;h2&gt;Build &amp;amp; Run&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make&#xA;cc -I include -static -w -o exploit exploit.c&#xA;$ ./exploit &#xA;[*] phase(1/8) &#39;create bpf map(s)&#39; running&#xA;[+] phase(1/8) &#39;create bpf map(s)&#39; done&#xA;[*] phase(2/8) &#39;do some leak&#39; running&#xA;[+] phase(2/8) &#39;do some leak&#39; done&#xA;[*] phase(3/8) &#39;prepare arbitrary rw&#39; running&#xA;[+] phase(3/8) &#39;prepare arbitrary rw&#39; done&#xA;[*] phase(4/8) &#39;spawn processes&#39; running&#xA;[+] phase(4/8) &#39;spawn processes&#39; done&#xA;[*] phase(5/8) &#39;find cred (slow)&#39; running&#xA;[+] phase(5/8) &#39;find cred (slow)&#39; done&#xA;[*] phase(6/8) &#39;overwrite cred&#39; running&#xA;[+] phase(6/8) &#39;overwrite cred&#39; done&#xA;[*] phase(7/8) &#39;spawn root shell&#39; running&#xA;[+] Enjoy root!&#xA;# id&#xA;uid=0(root) gid=0(root) groups=65534(nobody)&#xA;# exit&#xA;[+] phase(7/8) &#39;spawn root shell&#39; done&#xA;[*] phase(8/8) &#39;clean up the mess&#39; running&#xA;[+] phase(8/8) &#39;clean up the mess&#39; done&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>rui314/chibicc</title>
    <updated>2022-06-19T02:03:48Z</updated>
    <id>tag:github.com,2022-06-19:/rui314/chibicc</id>
    <link href="https://github.com/rui314/chibicc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small C compiler&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;chibicc: A Small C Compiler&lt;/h1&gt; &#xA;&lt;p&gt;(The old master has moved to &lt;a href=&#34;https://github.com/rui314/chibicc/tree/historical/old&#34;&gt;historical/old&lt;/a&gt; branch. This is a new one uploaded in September 2020.)&lt;/p&gt; &#xA;&lt;p&gt;chibicc is yet another small C compiler that implements most C11 features. Even though it still probably falls into the &#34;toy compilers&#34; category just like other small compilers do, chibicc can compile several real-world programs, including &lt;a href=&#34;https://git-scm.com/&#34;&gt;Git&lt;/a&gt;, &lt;a href=&#34;https://sqlite.org&#34;&gt;SQLite&lt;/a&gt;, &lt;a href=&#34;http://www.libpng.org/pub/png/libpng.html&#34;&gt;libpng&lt;/a&gt; and chibicc itself, without making modifications to the compiled programs. Generated executables of these programs pass their corresponding test suites. So, chibicc actually supports a wide variety of C11 features and is able to compile hundreds of thousands of lines of real-world C code correctly.&lt;/p&gt; &#xA;&lt;p&gt;chibicc is developed as the reference implementation for a book I&#39;m currently writing about the C compiler and the low-level programming. The book covers the vast topic with an incremental approach; in the first chapter, readers will implement a &#34;compiler&#34; that accepts just a single number as a &#34;language&#34;, which will then gain one feature at a time in each section of the book until the language that the compiler accepts matches what the C11 spec specifies. I took this incremental approach from &lt;a href=&#34;http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf&#34;&gt;the paper&lt;/a&gt; by Abdulaziz Ghuloum.&lt;/p&gt; &#xA;&lt;p&gt;Each commit of this project corresponds to a section of the book. For this purpose, not only the final state of the project but each commit was carefully written with readability in mind. Readers should be able to learn how a C language feature can be implemented just by reading one or a few commits of this project. For example, this is how &lt;a href=&#34;https://github.com/rui314/chibicc/commit/773115ab2a9c4b96f804311b95b20e9771f0190a&#34;&gt;while&lt;/a&gt;, &lt;a href=&#34;https://github.com/rui314/chibicc/commit/75fbd3dd6efde12eac8225d8b5723093836170a5&#34;&gt;[]&lt;/a&gt;, &lt;a href=&#34;https://github.com/rui314/chibicc/commit/1d0e942fd567a35d296d0f10b7693e98b3dd037c&#34;&gt;?:&lt;/a&gt;, and &lt;a href=&#34;https://github.com/rui314/chibicc/commit/79644e54cc1805e54428cde68b20d6d493b76d34&#34;&gt;thread-local variable&lt;/a&gt; are implemented. If you have plenty of spare time, it might be fun to read it from the &lt;a href=&#34;https://github.com/rui314/chibicc/commit/0522e2d77e3ab82d3b80a5be8dbbdc8d4180561c&#34;&gt;first commit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you like this project, please consider purchasing a copy of the book when it becomes available! ðŸ˜€ I publish the source code here to give people early access to it, because I was planing to do that anyway with a permissive open-source license after publishing the book. If I don&#39;t charge for the source code, it doesn&#39;t make much sense to me to keep it private. I hope to publish the book in 2021. You can sign up &lt;a href=&#34;https://forms.gle/sgrMWHGeGjeeEJcX7&#34;&gt;here&lt;/a&gt; to receive a notification when a free chapter is available online or the book is published.&lt;/p&gt; &#xA;&lt;p&gt;I pronounce chibicc as &lt;em&gt;chee bee cee cee&lt;/em&gt;. &#34;chibi&#34; means &#34;mini&#34; or &#34;small&#34; in Japanese. &#34;cc&#34; stands for C compiler.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;chibicc supports almost all mandatory features and most optional features of C11 as well as a few GCC language extensions.&lt;/p&gt; &#xA;&lt;p&gt;Features that are often missing in a small compiler but supported by chibicc include (but not limited to):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Preprocessor&lt;/li&gt; &#xA; &lt;li&gt;float, double and long double (x87 80-bit floating point numbers)&lt;/li&gt; &#xA; &lt;li&gt;Bit-fields&lt;/li&gt; &#xA; &lt;li&gt;alloca()&lt;/li&gt; &#xA; &lt;li&gt;Variable-length arrays&lt;/li&gt; &#xA; &lt;li&gt;Compound literals&lt;/li&gt; &#xA; &lt;li&gt;Thread-local variables&lt;/li&gt; &#xA; &lt;li&gt;Atomic variables&lt;/li&gt; &#xA; &lt;li&gt;Common symbols&lt;/li&gt; &#xA; &lt;li&gt;Designated initializers&lt;/li&gt; &#xA; &lt;li&gt;L, u, U and u8 string literals&lt;/li&gt; &#xA; &lt;li&gt;Functions that take or return structs as values, as specified by the x86-64 SystemV ABI&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;chibicc does not support complex numbers, K&amp;amp;R-style function prototypes and GCC-style inline assembly. Digraphs and trigraphs are intentionally left out.&lt;/p&gt; &#xA;&lt;p&gt;chibicc outputs a simple but nice error message when it finds an error in source code.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s no optimization pass. chibicc emits terrible code which is probably twice or more slower than GCC&#39;s output. I have a plan to add an optimization pass once the frontend is done.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m using Ubuntu 20.04 for x86-64 as a development platform. I made a few small changes so that chibicc works on Ubuntu 18.04, Fedora 32 and Gentoo 2.6, but portability is not my goal at this moment. It may or may not work on systems other than Ubuntu 20.04.&lt;/p&gt; &#xA;&lt;h2&gt;Internals&lt;/h2&gt; &#xA;&lt;p&gt;chibicc consists of the following stages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Tokenize: A tokenizer takes a string as an input, breaks it into a list of tokens and returns them.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Preprocess: A preprocessor takes as an input a list of tokens and output a new list of macro-expanded tokens. It interprets preprocessor directives while expanding macros.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Parse: A recursive descendent parser constructs abstract syntax trees from the output of the preprocessor. It also adds a type to each AST node.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Codegen: A code generator emits an assembly text for given AST nodes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;When I find a bug in this compiler, I go back to the original commit that introduced the bug and rewrite the commit history as if there were no such bug from the beginning. This is an unusual way of fixing bugs, but as a part of a book, it is important to keep every commit bug-free.&lt;/p&gt; &#xA;&lt;p&gt;Thus, I do not take pull requests in this repo. You can send me a pull request if you find a bug, but it is very likely that I will read your patch and then apply that to my previous commits by rewriting history. I&#39;ll credit your name somewhere, but your changes will be rewritten by me before submitted to this repository.&lt;/p&gt; &#xA;&lt;p&gt;Also, please assume that I will occasionally force-push my local repository to this public one to rewrite history. If you clone this project and make local commits on top of it, your changes will have to be rebased by hand when I force-push new commits.&lt;/p&gt; &#xA;&lt;h2&gt;Design principles&lt;/h2&gt; &#xA;&lt;p&gt;chibicc&#39;s core value is its simplicity and the reability of its source code. To achieve this goal, I was careful not to be too clever when writing code. Let me explain what that means.&lt;/p&gt; &#xA;&lt;p&gt;Oftentimes, as you get used to the code base, you are tempted to &lt;em&gt;improve&lt;/em&gt; the code using more abstractions and clever tricks. But that kind of &lt;em&gt;improvements&lt;/em&gt; don&#39;t always improve readability for first-time readers and can actually hurts it. I tried to avoid the pitfall as much as possible. I wrote this code not for me but for first-time readers.&lt;/p&gt; &#xA;&lt;p&gt;If you take a look at the source code, you&#39;ll find a couple of dumb-looking pieces of code. These are written intentionally that way (but at some places I might be actually missing something, though). Here is a few notable examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The recursive descendent parser contains many similar-looking functions for similar-looking generative grammar rules. You might be tempted to &lt;em&gt;improve&lt;/em&gt; it to reduce the duplication using higher-order functions or macros, but I thought that that&#39;s too complicated. It&#39;s better to allow small duplications instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;chibicc doesn&#39;t try too hard to save memory. An entire input source file is read to memory first before the tokenizer kicks in, for example.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Slow algorithms are fine if we know that n isn&#39;t too big. For example, we use a linked list as a set in the preprocessor, so the membership check takes O(n) where n is the size of the set. But that&#39;s fine because we know n is usually very small. And even if n can be very big, I stick with a simple slow algorithm until it is proved by benchmarks that that&#39;s a bottleneck.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Each AST node type uses only a few members of the &lt;code&gt;Node&lt;/code&gt; struct members. Other unused &lt;code&gt;Node&lt;/code&gt; members are just a waste of memory at runtime. We could save memory using unions, but I decided to simply put everything in the same struct instead. I believe the inefficiency is negligible. Even if it matters, we can always change the code to use unions at any time. I wanted to avoid premature optimization.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;chibicc always allocates heap memory using &lt;code&gt;calloc&lt;/code&gt;, which is a variant of &lt;code&gt;malloc&lt;/code&gt; that clears memory with zero. &lt;code&gt;calloc&lt;/code&gt; is slightly slower than &lt;code&gt;malloc&lt;/code&gt;, but that should be neligible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Last but not least, chibicc allocates memory using &lt;code&gt;calloc&lt;/code&gt; but never calls &lt;code&gt;free&lt;/code&gt;. Allocated heap memory is not freed until the process exits. I&#39;m sure that this memory management policy (or lack thereof) looks very odd, but it makes sense for short-lived programs such as compilers. DMD, a compiler for the D programming language, uses the same memory management scheme for the same reason, for example [1].&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About the Author&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;m Rui Ueyama. I&#39;m the creator of &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt;, which is a hobby C compiler, and also the original creator of the current version of &lt;a href=&#34;https://lld.llvm.org&#34;&gt;LLVM lld&lt;/a&gt; linker, which is a production-quality linker used by various operating systems and large-scale build systems.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://bellard.org/tcc/&#34;&gt;tcc&lt;/a&gt;: A small C compiler written by Fabrice Bellard. I learned a lot from this compiler, but the design of tcc and chibicc are different. In particular, tcc is a one-pass compiler, while chibicc is a multi-pass one.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/drh/lcc&#34;&gt;lcc&lt;/a&gt;: Another small C compiler. The creators wrote a &lt;a href=&#34;https://sites.google.com/site/lccretargetablecompiler/&#34;&gt;book&lt;/a&gt; about the internals of lcc, which I found a good resource to see how a compiler is implemented.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf&#34;&gt;An Incremental Approach to Compiler Construction&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://users.ece.utexas.edu/~adnan/pike.html&#34;&gt;Rob Pike&#39;s 5 Rules of Programming&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[1] &lt;a href=&#34;https://www.drdobbs.com/cpp/increasing-compiler-speed-by-over-75/240158941&#34;&gt;https://www.drdobbs.com/cpp/increasing-compiler-speed-by-over-75/240158941&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;DMD does memory allocation in a bit of a sneaky way. Since compilers are short-lived programs, and speed is of the essence, DMD just mallocs away, and never frees.&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
  <entry>
    <title>jart/cosmopolitan</title>
    <updated>2022-06-19T02:03:48Z</updated>
    <id>tag:github.com,2022-06-19:/jart/cosmopolitan</id>
    <link href="https://github.com/jart/cosmopolitan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;build-once run-anywhere c library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jart/cosmopolitan/master/usr/share/img/honeybadger.png&#34; alt=&#34;Cosmopolitan Honeybadger&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Cosmopolitan&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://justine.lol/cosmopolitan/index.html&#34;&gt;Cosmopolitan Libc&lt;/a&gt; makes C a build-once run-anywhere language, like Java, except it doesn&#39;t need an interpreter or virtual machine. Instead, it reconfigures stock GCC and Clang to output a POSIX-approved polyglot format that runs natively on Linux + Mac + Windows + FreeBSD + OpenBSD + NetBSD + BIOS with the best possible performance and the tiniest footprint imaginable.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;For an introduction to this project, please read the &lt;a href=&#34;https://justine.lol/ape.html&#34;&gt;Î±cÏ„ÂµÎ±lly pÎ´rÏ„Î±blÎµ ÎµxÎµcÂµÏ„Î±blÎµ&lt;/a&gt; blog post and &lt;a href=&#34;https://justine.lol/cosmopolitan/index.html&#34;&gt;cosmopolitan libc&lt;/a&gt; website. We also have &lt;a href=&#34;https://justine.lol/cosmopolitan/documentation.html&#34;&gt;API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re doing your development work on Linux or BSD then you need just five files to get started. Here&#39;s what you do on Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget https://justine.lol/cosmopolitan/cosmopolitan.zip&#xA;unzip cosmopolitan.zip&#xA;printf &#39;main() { printf(&#34;hello world\\n&#34;); }\n&#39; &amp;gt;hello.c&#xA;gcc -g -Os -static -nostdlib -nostdinc -fno-pie -no-pie -mno-red-zone \&#xA;  -fno-omit-frame-pointer -pg -mnop-mcount \&#xA;  -o hello.com.dbg hello.c -fuse-ld=bfd -Wl,-T,ape.lds \&#xA;  -include cosmopolitan.h crt.o ape-no-modify-self.o cosmopolitan.a&#xA;objcopy -S -O binary hello.com.dbg hello.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You now have a portable program.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./hello.com&#xA;bash -c &#39;./hello.com&#39;  # zsh/fish workaround (we patched them in 2021)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since we used the &lt;code&gt;ape-no-modify-self.o&lt;/code&gt; bootloader (rather than &lt;code&gt;ape.o&lt;/code&gt;) your executable will not modify itself when it&#39;s run. What it&#39;ll instead do, is extract a 4kb program to &lt;code&gt;${TMPDIR:-/tmp}&lt;/code&gt; that maps your program into memory without needing to copy it. It&#39;s possible to install the APE loader systemwide as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# (1) linux systems that want binfmt_misc&#xA;ape/apeinstall.sh&#xA;&#xA;# (2) for linux/freebsd/netbsd/openbsd systems&#xA;cp build/bootstrap/ape.elf /usr/bin/ape&#xA;&#xA;# (3) for mac os x systems&#xA;cp build/bootstrap/ape.macho /usr/bin/ape&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you followed steps (2) and (3) then there&#39;s going to be a slight constant-time startup latency each time you run an APE binary. Your system might also prevent your APE program from being installed to a system directory as a setuid binary or a script interpreter. To solve that, you can use the following flag to turn your binary into the platform local format (ELF or Mach-O):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ file hello.com&#xA;hello.com: DOS/MBR boot sector&#xA;./hello.com --assimilate&#xA;$ file hello.com&#xA;hello.com: ELF 64-bit LSB executable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s also some other useful flags that get baked into your binary by default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./hello.com --strace   # log system calls to stderr&#xA;./hello.com --ftrace   # log function calls to stderr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want your &lt;code&gt;hello.com&lt;/code&gt; program to be much tinier, more on the order of 16kb rather than 60kb, then all you have to do is use &lt;a href=&#34;https://justine.lol/cosmopolitan/cosmopolitan-tiny.zip&#34;&gt;https://justine.lol/cosmopolitan/cosmopolitan-tiny.zip&lt;/a&gt; instead. See &lt;a href=&#34;https://justine.lol/cosmopolitan/download.html&#34;&gt;https://justine.lol/cosmopolitan/download.html&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;MacOS&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re developing on MacOS you can install the GNU compiler collection for x86_64-elf via homebrew:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install x86_64-elf-gcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in the above scripts just replace &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;objcopy&lt;/code&gt; with &lt;code&gt;x86_64-elf-gcc&lt;/code&gt; and &lt;code&gt;x86_64-elf-objcopy&lt;/code&gt; to compile your APE binary.&lt;/p&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re developing on Windows then you need to download an x86_64-pc-linux-gnu toolchain beforehand. See the &lt;a href=&#34;https://justine.lol/cosmopolitan/windows-compiling.html&#34;&gt;Compiling on Windows&lt;/a&gt; tutorial. It&#39;s needed because the ELF object format is what makes universal binaries possible.&lt;/p&gt; &#xA;&lt;p&gt;Cosmopolitan officially only builds on Linux. However, one highly experimental (and currently broken) thing you could try, is building the entire cosmo repository from source using the cross9 toolchain.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkdir -p o/third_party&#xA;rm -rf o/third_party/gcc&#xA;wget https://justine.lol/linux-compiler-on-windows/cross9.zip&#xA;unzip cross9.zip&#xA;mv cross9 o/third_party/gcc&#xA;build/bootstrap/make.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Source Builds&lt;/h2&gt; &#xA;&lt;p&gt;Cosmopolitan can be compiled from source on any Linux distro. First, you need to download or clone the repository.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget https://justine.lol/cosmopolitan/cosmopolitan.tar.gz&#xA;tar xf cosmopolitan.tar.gz  # see releases page&#xA;cd cosmopolitan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will build the entire repository and run all the tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;build/bootstrap/make.com -j16&#xA;o//examples/hello.com&#xA;find o -name \*.com | xargs ls -rShal | less&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you get an error running make.com then it&#39;s probably because you have WINE installed to &lt;code&gt;binfmt_misc&lt;/code&gt;. You can fix that by installing the the APE loader as an interpreter. It&#39;ll improve build performance too!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ape/apeinstall.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since the Cosmopolitan repository is very large, you might only want to build a particular thing. Cosmopolitan&#39;s build config does a good job at having minimal deterministic builds. For example, if you wanted to build only hello.com then you could do that as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;build/bootstrap/make.com -j16 o//examples/hello.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes it&#39;s desirable to build a subset of targets, without having to list out each individual one. You can do that by asking make to build a directory name. For example, if you wanted to build only the targets and subtargets of the chibicc package including its tests, you would say:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;build/bootstrap/make.com -j16 o//third_party/chibicc&#xA;o//third_party/chibicc/chibicc.com --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Cosmopolitan provides a variety of build modes. For example, if you want really tiny binaries (as small as 12kb in size) then you&#39;d say:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;build/bootstrap/make.com -j16 MODE=tiny&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s some other build modes you can try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;build/bootstrap/make.com -j16 MODE=dbg       # asan + ubsan + debug&#xA;build/bootstrap/make.com -j16 MODE=asan      # production memory safety&#xA;build/bootstrap/make.com -j16 MODE=opt       # -march=native optimizations&#xA;build/bootstrap/make.com -j16 MODE=rel       # traditional release binaries&#xA;build/bootstrap/make.com -j16 MODE=optlinux  # optimal linux-only performance&#xA;build/bootstrap/make.com -j16 MODE=tinylinux # tiniest linux-only 4kb binaries&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For further details, see &lt;a href=&#34;https://raw.githubusercontent.com/jart/cosmopolitan/master/build/config.mk&#34;&gt;//build/config.mk&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;GDB&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s the recommended &lt;code&gt;~/.gdbinit&lt;/code&gt; config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;set host-charset UTF-8&#xA;set target-charset UTF-8&#xA;set target-wide-charset UTF-8&#xA;set osabi none&#xA;set complaints 0&#xA;set confirm off&#xA;set history save on&#xA;set history filename ~/.gdb_history&#xA;define asm&#xA;  layout asm&#xA;  layout reg&#xA;end&#xA;define src&#xA;  layout src&#xA;  layout reg&#xA;end&#xA;src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You normally run the &lt;code&gt;.com.dbg&lt;/code&gt; file under gdb. If you need to debug the &lt;code&gt;.com&lt;/code&gt; file itself, then you can load the debug symbols independently as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gdb foo.com -ex &#39;add-symbol-file foo.com.dbg 0x401000&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support Vector&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Platform&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Min Version&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Circa&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;AMD&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;K8 Venus&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2005&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Intel&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;Core&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2006&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;New Technology&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;Vista&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2006&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;GNU/Systemd&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2.6.18&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2007&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;XNU&#39;s Not UNIX!&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;15.6&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;FreeBSD&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;13&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2020&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;OpenBSD&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6.4&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;NetBSD&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;9.2&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2021&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>