<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-14T02:05:11Z</updated>
  <subtitle>Weekly Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>peng-zhihui/L-ink_Card</title>
    <updated>2022-08-14T02:05:11Z</updated>
    <id>tag:github.com,2022-08-14:/peng-zhihui/L-ink_Card</id>
    <link href="https://github.com/peng-zhihui/L-ink_Card" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Smart NFC &amp; ink-Display Card&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;[L-ink]电子墨水屏NFC智能卡片&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;这是为了解决个人使用IC卡时遇到的一些痛点设计的一个迷你NFC智能卡片，基于STM32L051和ST25DV。&lt;/p&gt; &#xA; &lt;p&gt;想着既然要自制这玩意那就往炫酷了做，于是很自觉地把电子墨水屏也加上了，顺手也写了个配套APP用于显示内容定制。&lt;/p&gt; &#xA; &lt;p&gt;总之是个比较有意思的小项目，方案不算复杂，第一版设计也存在一些值得改进的地方，后续有空会继续优化方案设计的。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/L-ink_V0.5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;演示视频&lt;/h2&gt; &#xA;&lt;p&gt;B站指路：&lt;a href=&#34;https://www.bilibili.com/video/BV1Cf4y1y7KT/&#34;&gt;https://www.bilibili.com/video/BV1Cf4y1y7KT/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;项目文件说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hardware&lt;/strong&gt;：source里面是电路原理图和PCB文件，使用Altium Designer打开；release里面是gerber文件可以直接发给厂家打样，也包含了元器件BOM表（部分IC不太常用可能要单独购买）。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Firmware&lt;/strong&gt;：STM32L051的固件，我提供了Clion和Keil两个版本的工程文件，源码内容是一致的，分两个版本只是因为个人对Clion爱得深沉。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;3D Model&lt;/strong&gt;：屏幕架和外壳的3D文件，step格式一般3D建模软件都能打开编辑，STL格式用于直接3D打印。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;DAP-Link&lt;/strong&gt;：自己设计的下载调试器的硬件和固件源码，也包括预编译的hex固件，如果你有J-Link或者ST-Link之类的下载器就不用这个了。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Android&lt;/strong&gt;：配套的APP安装包。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;固件编译说明&lt;/h2&gt; &#xA;&lt;p&gt;STM32因为使用了L0系列的MCU，所以如果你是第一次在你的电脑上开发STM32L0，那么需要先装一下L0的固件支持包，有两种方式：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;使用STM32CubMX安装：&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;使用Keil的Package Installer安装：&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/bsp4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;然后就不会报头文件的错误了。&lt;/p&gt; &#xA;&lt;p&gt;有几点注意的：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;如果想在Clion中编译工程的话可以参考我这篇教程：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/145801160&#34;&gt;https://zhuanlan.zhihu.com/p/145801160&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Clion中OpenOCD默认是使用ST-Link下载，其他下载器自己修改工程目录下的stlink.cfg文件&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;关于硬件方案&lt;/h2&gt; &#xA;&lt;p&gt;硬件方案比较简单，主要IC就两个--STM32和ST25DV，电子墨水屏是200x200的单色屏幕，我是买的微雪的（注意如果是买的几年前的库存，那驱动芯片会有点区别导致代码不通用，只要是新款的应该都没问题）。&lt;/p&gt; &#xA;&lt;p&gt;ST25DV作为NFC的PHY通过I2C总线和STM32通信，主要作用有两个：能量采集以及NFC通信。注意，ST25DV只是负责和手机进行NFC通信，而不负责IC卡的读写功能，因为&lt;strong&gt;ST25DV只支持ISO 15693的RFID协议，而我们常用的IC卡（M1卡）是ISO 14443协议的&lt;/strong&gt;，所以并不能直接使用这颗芯片进行IC卡模拟。&lt;/p&gt; &#xA;&lt;p&gt;IC卡的模拟功能这一版中实现得比较简单，就是直接集成了多颗UID芯片（很便宜，1~2元一片），然后和ST25DV共用NFC天线，卡片的切换是通过拨轮换挡实现的。好处在于，你可以把L-ink当作多张独立卡片的合集处理，复制和刷卡都是很直接的（使用PM3或者PN532等模块读取原卡信息并写入L-link）。当然缺点就是添加的卡片一多，按键的数量就要增加（因为每一档对应一张卡）。&lt;/p&gt; &#xA;&lt;p&gt;所以我也在改进方案，后面可能会使用支持ISO 14443协议的ST95或者ST25T系列的芯片来实现软件层面的IC卡模拟功能。&lt;/p&gt; &#xA;&lt;p&gt;另外下一个版本的硬件方案&lt;strong&gt;我会把黑白的电子墨水屏换成彩色的&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;关于配套APP&lt;/h2&gt; &#xA;&lt;p&gt;Android APP目前只是实现了功能，这是基于我以前做的一个算法验证框架APP改的，UI还没有重新做设计，可以等后续更新。&lt;/p&gt; &#xA;&lt;p&gt;工程文件的话我后面可以把其中的核心功能模块封装成Module，然后给个Sample Project供参考使用，工作太忙等我缓过这阵子先~&lt;/p&gt; &#xA;&lt;h2&gt;教程整理中...&lt;/h2&gt; &#xA;&lt;p&gt;有问题先看Issue（包括已经close的），另外&lt;/p&gt; &#xA;&lt;h4&gt;跟项目工程无关的问题不要发在Issues里面！跟项目工程无关的问题不要发在Issues里面！跟项目工程无关的问题不要发在Issues里面！&lt;/h4&gt; &#xA;&lt;p&gt;聊天内容可以给我发评论或者私信（B站、知乎），我看到的话基本都会回复，issue里面发的话所有watch项目的人都会收到邮件，会对大家产生困扰的！&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;以下是&lt;a href=&#34;https://github.com/simonire&#34;&gt;simonire&lt;/a&gt;修改的版本，适配新款的屏幕驱动，修改拨轮为五维按键，有需要的可以参考：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/simonire/L-ink_Card&#34;&gt;https://github.com/simonire/L-ink_Card&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/L-ink_Card/master/Image/TruePic.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hepingood/mpu6050</title>
    <updated>2022-08-14T02:05:11Z</updated>
    <id>tag:github.com,2022-08-14:/hepingood/mpu6050</id>
    <link href="https://github.com/hepingood/mpu6050" rel="alternate"></link>
    <summary type="html">&lt;p&gt;mpu6050 full function driver&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/README_zh-Hans.md&#34;&gt; 简体中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/README_zh-Hant.md&#34;&gt;繁體中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/README_ja.md&#34;&gt;日本語&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/README_de.md&#34;&gt;Deutsch&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/README_ko.md&#34;&gt;한국어&lt;/a&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/doc/image/logo.png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;LibDriver MPU6050&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/misra/README.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/misra-compliant-brightgreen.svg?sanitize=true&#34; alt=&#34;MISRA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.libdriver.com/docs/mpu6050/index.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/api-reference-blue.svg?sanitize=true&#34; alt=&#34;API&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-brightgreen.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The MPU6050 is the world’s first integrated 6-axis MotionTracking device that combines a 3-axis gyroscope, 3-axis accelerometer, and a Digital Motion Processor™ (DMP) all in a small 4x4x0.9mm package. With its dedicated I2C sensor bus, it directly accepts inputs from an external 3-axis compass to provide a complete 9-axis MotionFusion™ output. The MPU6050 MotionTracking device, with its 6-axis integration, on-board MotionFusion™, and run-time calibration firmware, enables manufacturers to eliminate the costly and complex selection, qualification, and system level integration of discrete devices, guaranteeing optimal motion performance for consumers. The MPU6050 is also designed to interface with multiple non-inertial digital sensors, such as pressure sensors, on its auxiliary I2C port. The MPU6050 is footprint compatible with the MPU30X0 family.The MPU6050 features three 16-bit analog-to-digital converters (ADCs) for digitizing the gyroscope outputs and three 16-bit ADCs for digitizing the accelerometer outputs. For precision tracking of both fast and slow motions, the parts feature a user-programmable gyroscope full-scale range of ±250, ±500, ±1000, and ±2000°/sec (dps) and a user-programmable accelerometer full-scale range of ±2g, ±4g, ±8g, and ±16g.&lt;/p&gt; &#xA;&lt;p&gt;LibDriver MPU6050 is the full function driver of mpu6050 launched by LibDriver. It provides acceleration reading, angular velocity reading, attitude angle reading, dmp reading, tap detection and other functions. LibDriver is MISRA compliant.&lt;/p&gt; &#xA;&lt;h3&gt;Table of Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#Instruction&#34;&gt;Instruction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#Install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#Usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#example-basic&#34;&gt;example basic&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#example-fifo&#34;&gt;example fifo&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#example-dmp&#34;&gt;example dmp&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#Document&#34;&gt;Document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#Contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#License&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mpu6050/master/#Contact-Us&#34;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Instruction&lt;/h3&gt; &#xA;&lt;p&gt;/src includes LibDriver MPU6050 source files.&lt;/p&gt; &#xA;&lt;p&gt;/interface includes LibDriver MPU6050 IIC platform independent template。&lt;/p&gt; &#xA;&lt;p&gt;/test includes LibDriver MPU6050 driver test code and this code can test the chip necessary function simply。&lt;/p&gt; &#xA;&lt;p&gt;/example includes LibDriver MPU6050 sample code.&lt;/p&gt; &#xA;&lt;p&gt;/doc includes LibDriver MPU6050 offline document.&lt;/p&gt; &#xA;&lt;p&gt;/datasheet includes MPU6050 datasheet。&lt;/p&gt; &#xA;&lt;p&gt;/project includes the common Linux and MCU development board sample code. All projects use the shell script to debug the driver and the detail instruction can be found in each project&#39;s README.md.&lt;/p&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;p&gt;Reference /interface IIC platform independent template and finish your platform IIC driver.&lt;/p&gt; &#xA;&lt;p&gt;Add /src, /interface and /example to your project.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h4&gt;example basic&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;uint8_t res;&#xA;uint32_t i;&#xA;uint32_t times;&#xA;float g[3];&#xA;float dps[3];&#xA;float degrees;&#xA;mpu6050_address_t addr;&#xA;&#xA;/* init */&#xA;addr = MPU6050_ADDRESS_AD0_LOW;&#xA;res = mpu6050_basic_init(addr);&#xA;if (res != 0)&#xA;{&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* read all */&#xA;times = 3;&#xA;for (i = 0; i &amp;lt; times; i++)&#xA;{&#xA;    /* read */&#xA;    if (mpu6050_basic_read(g, dps) != 0)&#xA;    {&#xA;        (void)mpu6050_basic_deinit();&#xA;&#xA;        return 1;&#xA;    }&#xA;&#xA;    ...&#xA;        &#xA;    if (mpu6050_basic_read_temperature(&amp;amp;degrees) != 0)&#xA;    {&#xA;        (void)mpu6050_basic_deinit();&#xA;&#xA;        return 1;&#xA;    }&#xA;&#xA;    ...&#xA;        &#xA;    /* output */&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: %d/%d.\n&#34;, i + 1, times);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc x is %0.2fg.\n&#34;, g[0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc y is %0.2fg.\n&#34;, g[1]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc z is %0.2fg.\n&#34;, g[2]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro x is %0.2fdps.\n&#34;, dps[0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro y is %0.2fdps.\n&#34;, dps[1]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro z is %0.2fdps.\n&#34;, dps[2]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: temperature %0.2fC.\n&#34;, degrees);&#xA;&#xA;    ...&#xA;        &#xA;    /* delay 1000 ms */&#xA;    mpu6050_interface_delay_ms(1000);&#xA;&#xA;    ...&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* deinit */&#xA;(void)mpu6050_basic_deinit();&#xA;&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;example fifo&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;uint32_t i;&#xA;uint32_t times;&#xA;uint16_t len;&#xA;uint8_t (*g_gpio_irq)(void) = NULL;&#xA;static int16_t gs_accel_raw[128][3];&#xA;static float gs_accel_g[128][3];&#xA;static int16_t gs_gyro_raw[128][3];&#xA;static float gs_gyro_dps[128][3];&#xA;mpu6050_address_t addr;&#xA;&#xA;/* gpio init */&#xA;if (gpio_interrupt_init() != 0)&#xA;{&#xA;    return 1;&#xA;}&#xA;g_gpio_irq = mpu6050_fifo_irq_handler;&#xA;&#xA;/* init */&#xA;addr = MPU6050_ADDRESS_AD0_LOW;&#xA;if (mpu6050_fifo_init(addr) != 0)&#xA;{&#xA;    g_gpio_irq = NULL;&#xA;    (void)gpio_interrupt_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;/* delay 100 ms */&#xA;mpu6050_interface_delay_ms(100);&#xA;&#xA;...&#xA;&#xA;times = 3;&#xA;for (i = 0; i &amp;lt; times; i++)&#xA;{&#xA;    len = 128;&#xA;&#xA;    /* read */&#xA;    if (mpu6050_fifo_read(gs_accel_raw, gs_accel_g,&#xA;                          gs_gyro_raw, gs_gyro_dps, &amp;amp;len) != 0)&#xA;    {&#xA;        (void)mpu6050_fifo_deinit();&#xA;        g_gpio_irq = NULL;&#xA;        (void)gpio_interrupt_deinit();&#xA;&#xA;        return 1;&#xA;    }&#xA;    &#xA;    ...&#xA;        &#xA;    /* output */&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: %d/%d.\n&#34;, i + 1, times);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: fifo %d.\n&#34;, len);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc x[0] is %0.2fg.\n&#34;, gs_accel_g[0][0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc y[0] is %0.2fg.\n&#34;, gs_accel_g[0][1]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc z[0] is %0.2fg.\n&#34;, gs_accel_g[0][2]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro x[0] is %0.2fdps.\n&#34;, gs_gyro_dps[0][0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro y[0] is %0.2fdps.\n&#34;, gs_gyro_dps[0][1]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro z[0] is %0.2fdps.\n&#34;, gs_gyro_dps[0][2]);&#xA;    &#xA;    ...&#xA;        &#xA;    /* delay 100 ms */&#xA;    mpu6050_interface_delay_ms(100);&#xA;    &#xA;    ...&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* deinit */&#xA;(void)mpu6050_fifo_deinit();&#xA;g_gpio_irq = NULL;&#xA;(void)gpio_interrupt_deinit();&#xA;&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;example dmp&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;uint32_t i;&#xA;uint32_t times;&#xA;uint32_t cnt;&#xA;uint16_t len;&#xA;uint8_t (*g_gpio_irq)(void) = NULL;&#xA;static int16_t gs_accel_raw[128][3];&#xA;static float gs_accel_g[128][3];&#xA;static int16_t gs_gyro_raw[128][3];      &#xA;static float gs_gyro_dps[128][3];        &#xA;static int32_t gs_quat[128][4];          &#xA;static float gs_pitch[128];              &#xA;static float gs_roll[128];                &#xA;static float gs_yaw[128];                  &#xA;static int32_t gs_quat[128][4];         &#xA;static float gs_pitch[128];             &#xA;static float gs_roll[128];             &#xA;static float gs_yaw[128];     &#xA;mpu6050_address_t addr;&#xA;&#xA;static void a_receive_callback(uint8_t type)&#xA;{&#xA;    switch (type)&#xA;    {&#xA;        case MPU6050_INTERRUPT_MOTION :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: irq motion.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_INTERRUPT_FIFO_OVERFLOW :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: irq fifo overflow.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_INTERRUPT_I2C_MAST :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: irq i2c master.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_INTERRUPT_DMP :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: irq dmp\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_INTERRUPT_DATA_READY :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: irq data ready\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        default :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: irq unknown code.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;static void a_dmp_tap_callback(uint8_t count, uint8_t direction)&#xA;{&#xA;    switch (direction)&#xA;    {&#xA;        case MPU6050_DMP_TAP_X_UP :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: tap irq x up with %d.\n&#34;, count);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_TAP_X_DOWN :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: tap irq x down with %d.\n&#34;, count);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_TAP_Y_UP :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: tap irq y up with %d.\n&#34;, count);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_TAP_Y_DOWN :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: tap irq y down with %d.\n&#34;, count);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_TAP_Z_UP :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: tap irq z up with %d.\n&#34;, count);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_TAP_Z_DOWN :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: tap irq z down with %d.\n&#34;, count);&#xA;            &#xA;            break;&#xA;        }&#xA;        default :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: tap irq unknown code.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;static void a_dmp_orient_callback(uint8_t orientation)&#xA;{&#xA;    switch (orientation)&#xA;    {&#xA;        case MPU6050_DMP_ORIENT_PORTRAIT :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: orient irq portrait.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_ORIENT_LANDSCAPE :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: orient irq landscape.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_ORIENT_REVERSE_PORTRAIT :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: orient irq reverse portrait.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        case MPU6050_DMP_ORIENT_REVERSE_LANDSCAPE :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: orient irq reverse landscape.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;        default :&#xA;        {&#xA;            mpu6050_interface_debug_print(&#34;mpu6050: orient irq unknown code.\n&#34;);&#xA;            &#xA;            break;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;/* init */&#xA;if (gpio_interrupt_init() != 0)&#xA;{&#xA;    return 1;&#xA;}&#xA;g_gpio_irq = mpu6050_dmp_irq_handler;&#xA;&#xA;/* run dmp function */&#xA;if (mpu6050_dmp_init(addr, a_receive_callback, &#xA;                     a_dmp_tap_callback, a_dmp_orient_callback) != 0)&#xA;{&#xA;    g_gpio_irq = NULL;&#xA;    (void)gpio_interrupt_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;/* delay 500 ms */&#xA;mpu6050_interface_delay_ms(500);&#xA;&#xA;...&#xA;    &#xA;times = 3;&#xA;for (i = 0; i &amp;lt; times; i++)&#xA;{&#xA;    len = 128;&#xA;&#xA;    /* read */&#xA;    if (mpu6050_dmp_read_all(gs_accel_raw, gs_accel_g,&#xA;                             gs_gyro_raw, gs_gyro_dps, &#xA;                             gs_quat,&#xA;                             gs_pitch, gs_roll, gs_yaw,&#xA;                             &amp;amp;len) != 0)&#xA;    {&#xA;        (void)mpu6050_dmp_deinit();&#xA;        g_gpio_irq = NULL;&#xA;        (void)gpio_interrupt_deinit();&#xA;&#xA;        return 1;&#xA;    }&#xA;&#xA;    /* output */&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: %d/%d.\n&#34;, i + 1, times);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: fifo %d.\n&#34;, len);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: pitch[0] is %0.2fdps.\n&#34;, gs_pitch[0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: roll[0] is %0.2fdps.\n&#34;, gs_roll[0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: yaw[0] is %0.2fdps.\n&#34;, gs_yaw[0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc x[0] is %0.2fg.\n&#34;, gs_accel_g[0][0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc y[0] is %0.2fg.\n&#34;, gs_accel_g[0][1]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: acc z[0] is %0.2fg.\n&#34;, gs_accel_g[0][2]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro x[0] is %0.2fdps.\n&#34;, gs_gyro_dps[0][0]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro y[0] is %0.2fdps.\n&#34;, gs_gyro_dps[0][1]);&#xA;    mpu6050_interface_debug_print(&#34;mpu6050: gyro z[0] is %0.2fdps.\n&#34;, gs_gyro_dps[0][2]);&#xA;&#xA;    /* delay 500 ms */&#xA;    mpu6050_interface_delay_ms(500);&#xA;    &#xA;    ....&#xA;        &#xA;    /* get the pedometer step count */&#xA;    res = mpu6050_dmp_get_pedometer_counter(&amp;amp;cnt);&#xA;    if (res != 0)&#xA;    {&#xA;        (void)mpu6050_dmp_deinit();&#xA;        g_gpio_irq = NULL;&#xA;        (void)gpio_interrupt_deinit();&#xA;&#xA;        return 1;&#xA;    }&#xA;    &#xA;    ...&#xA;}&#xA;&#xA;...&#xA;&#xA;/* deinit */&#xA;(void)mpu6050_dmp_deinit();&#xA;g_gpio_irq = NULL;&#xA;(void)gpio_interrupt_deinit();&#xA;&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Document&lt;/h3&gt; &#xA;&lt;p&gt;Online documents: &lt;a href=&#34;https://www.libdriver.com/docs/mpu6050/index.html&#34;&gt;https://www.libdriver.com/docs/mpu6050/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Offline documents: /doc/html/index.html&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;Please sent an e-mail to &lt;a href=&#34;mailto:lishifenging@outlook.com&#34;&gt;lishifenging@outlook.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;Copyright (c) 2015 - present LibDriver All rights reserved&lt;/p&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy&lt;/p&gt; &#xA;&lt;p&gt;of this software and associated documentation files (the &#34;Software&#34;), to deal&lt;/p&gt; &#xA;&lt;p&gt;in the Software without restriction, including without limitation the rights&lt;/p&gt; &#xA;&lt;p&gt;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&lt;/p&gt; &#xA;&lt;p&gt;copies of the Software, and to permit persons to whom the Software is&lt;/p&gt; &#xA;&lt;p&gt;furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all&lt;/p&gt; &#xA;&lt;p&gt;copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&lt;/p&gt; &#xA;&lt;p&gt;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&lt;/p&gt; &#xA;&lt;p&gt;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&lt;/p&gt; &#xA;&lt;p&gt;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&lt;/p&gt; &#xA;&lt;p&gt;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&lt;/p&gt; &#xA;&lt;p&gt;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&lt;/p&gt; &#xA;&lt;p&gt;SOFTWARE.&lt;/p&gt; &#xA;&lt;h3&gt;Contact Us&lt;/h3&gt; &#xA;&lt;p&gt;Please sent an e-mail to &lt;a href=&#34;mailto:lishifenging@outlook.com&#34;&gt;lishifenging@outlook.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>huangz1990/redis-3.0-annotated</title>
    <updated>2022-08-14T02:05:11Z</updated>
    <id>tag:github.com,2022-08-14:/huangz1990/redis-3.0-annotated</id>
    <link href="https://github.com/huangz1990/redis-3.0-annotated" rel="alternate"></link>
    <summary type="html">&lt;p&gt;带有详细注释的 Redis 3.0 代码（annotated Redis 3.0 source code）。&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Redis 3.0 源码注释&lt;/h1&gt; &#xA;&lt;p&gt;本项目是注释版的 Redis 3.0 源码， 原始代码来自： &lt;a href=&#34;https://github.com/antirez/redis&#34;&gt;https://github.com/antirez/redis&lt;/a&gt; 。&lt;/p&gt; &#xA;&lt;p&gt;这份注释是我在创作新版《Redis 设计与实现》期间， 为了了解 Redis 的内部实现而制作的， 所有在书中有介绍的内容， 在源码中都进行了相应的注释。&lt;/p&gt; &#xA;&lt;p&gt;在注释的过程中， 除了少量空格和空行方面的调整外， 没有对原始代码进行任何其他改动， 最大程度地保证了代码的“原汁原味”。&lt;/p&gt; &#xA;&lt;p&gt;希望这份注释源码能给大家学习和了解 Redis 带来一点帮助。&lt;/p&gt; &#xA;&lt;p&gt;另外， &lt;code&gt;新版《Redis 设计与实现》 &amp;lt;http://RedisBook.com&amp;gt;&lt;/code&gt;_\ 正在各大网店发售中， 希望大家可以多多支持这本书。&lt;/p&gt; &#xA;&lt;p&gt;Have fun!&lt;/p&gt; &#xA;&lt;p&gt;| 黄健宏（huangz） | 2014 年 6 月 28 日&lt;/p&gt; &#xA;&lt;h2&gt;附录：各个源码文件的作用简介&lt;/h2&gt; &#xA;&lt;p&gt;+-------------------------------------------------------------------+-------------------------------------------------------------------+ | 文件 | 作用 | +===================================================================+===================================================================+ | &lt;code&gt;adlist.c&lt;/code&gt; 、 &lt;code&gt;adlist.h&lt;/code&gt; | 双端链表数据结构的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;ae.c&lt;/code&gt; 、 &lt;code&gt;ae.h&lt;/code&gt; 、 &lt;code&gt;ae_epoll.c&lt;/code&gt; 、 &lt;code&gt;ae_evport.c&lt;/code&gt; 、 | 事件处理器，以及各个具体实现。 | | &lt;code&gt;ae_kqueue.c&lt;/code&gt; 、 &lt;code&gt;ae_select.c&lt;/code&gt; | | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;anet.c&lt;/code&gt; 、 &lt;code&gt;anet.h&lt;/code&gt; | Redis 的异步网络框架，内容主要为对 socket 库的包装。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;aof.c&lt;/code&gt; | AOF 功能的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;asciilogo.h&lt;/code&gt; | 保存了 Redis 的 ASCII LOGO 。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;bio.c&lt;/code&gt; 、 &lt;code&gt;bio.h&lt;/code&gt; | Redis 的后台 I/O 程序，用于将 I/O 操作放到子线程里面执行， | | | 减少 I/O 操作对主线程的阻塞。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;bitops.c&lt;/code&gt; | 二进制位操作命令的实现文件。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;blocked.c&lt;/code&gt; | 用于实现 BLPOP 命令和 WAIT 命令的阻塞效果。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;cluster.c&lt;/code&gt; 、 &lt;code&gt;cluster.h&lt;/code&gt; | Redis 的集群实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;config.c&lt;/code&gt; 、 &lt;code&gt;config.h&lt;/code&gt; | Redis 的配置管理实现，负责读取并分析配置文件， | | | 然后根据这些配置修改 Redis 服务器的各个选项。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;crc16.c&lt;/code&gt; 、 &lt;code&gt;crc64.c&lt;/code&gt; 、 &lt;code&gt;crc64.h&lt;/code&gt; | 计算 CRC 校验和。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;db.c&lt;/code&gt; | 数据库实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;debug.c&lt;/code&gt; | 调试实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;dict.c&lt;/code&gt; 、 &lt;code&gt;dict.h&lt;/code&gt; | 字典数据结构的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;endianconv.c&lt;/code&gt; 、 &lt;code&gt;endianconv.h&lt;/code&gt; | 二进制的大端、小端转换函数。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;fmacros.h&lt;/code&gt; | 一些移植性方面的宏。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;help.h&lt;/code&gt; | &lt;code&gt;utils/generate-command-help.rb&lt;/code&gt; 程序自动生成的命令帮助信息。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;hyperloglog.c&lt;/code&gt; | HyperLogLog 数据结构的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;intset.c&lt;/code&gt; 、 &lt;code&gt;intset.h&lt;/code&gt; | 整数集合数据结构的实现，用于优化 SET 类型。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;lzf_c.c&lt;/code&gt; 、 &lt;code&gt;lzf_d.c&lt;/code&gt; 、 &lt;code&gt;lzf.h&lt;/code&gt; 、 &lt;code&gt;lzfP.h&lt;/code&gt; | Redis 对字符串和 RDB 文件进行压缩时使用的 LZF 压缩算法的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;Makefile&lt;/code&gt; 、 &lt;code&gt;Makefile.dep&lt;/code&gt; | 构建文件。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;memtest.c&lt;/code&gt; | 内存测试。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;mkreleasehdr.sh&lt;/code&gt; | 用于生成释出信息的脚本。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;multi.c&lt;/code&gt; | Redis 的事务实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;networking.c&lt;/code&gt; | Redis 的客户端网络操作库， | | | 用于实现命令请求接收、发送命令回复等工作， | | | 文件中的函数大多为 write 、 read 、 close 等函数的包装， | | | 以及各种协议的分析和构建函数。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;notify.c&lt;/code&gt; | Redis 的数据库通知实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;object.c&lt;/code&gt; | Redis 的对象系统实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;pqsort.c&lt;/code&gt; 、 &lt;code&gt;pqsort.h&lt;/code&gt; | 快速排序（QuickSort）算法的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;pubsub.c&lt;/code&gt; | 发布与订阅功能的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;rand.c&lt;/code&gt; 、 &lt;code&gt;rand.h&lt;/code&gt; | 伪随机数生成器。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;rdb.c&lt;/code&gt; 、 &lt;code&gt;rdb.h&lt;/code&gt; | RDB 持久化功能的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;redisassert.h&lt;/code&gt; | Redis 自建的断言系统。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;redis-benchmark.c&lt;/code&gt; | Redis 的性能测试程序。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;redis.c&lt;/code&gt; | 负责服务器的启动、维护和关闭等事项。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;redis-check-aof.c&lt;/code&gt; 、 &lt;code&gt;redis-check-dump.c&lt;/code&gt; | RDB 文件和 AOF 文件的合法性检查程序。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;redis-cli.c&lt;/code&gt; | Redis 客户端的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;redis.h&lt;/code&gt; | Redis 的主要头文件，记录了 Redis 中的大部分数据结构， | | | 包括服务器状态和客户端状态。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;redis-trib.rb&lt;/code&gt; | Redis 集群的管理程序。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;release.c&lt;/code&gt; 、 &lt;code&gt;release.h&lt;/code&gt; | 记录和生成 Redis 的释出版本信息。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;replication.c&lt;/code&gt; | 复制功能的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;rio.c&lt;/code&gt; 、 &lt;code&gt;rio.h&lt;/code&gt; | Redis 对文件 I/O 函数的包装， | | | 在普通 I/O 函数的基础上增加了显式缓存、以及计算校验和等功能。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;scripting.c&lt;/code&gt; | 脚本功能的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;sds.c&lt;/code&gt; 、 &lt;code&gt;sds.h&lt;/code&gt; | SDS 数据结构的实现，SDS 为 Redis 的默认字符串表示。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;sentinel.c&lt;/code&gt; | Redis Sentinel 的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;setproctitle.c&lt;/code&gt; | 进程环境设置函数。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;sha1.c&lt;/code&gt; 、 &lt;code&gt;sha1.h&lt;/code&gt; | SHA1 校验和计算函数。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;slowlog.c&lt;/code&gt; 、 &lt;code&gt;slowlog.h&lt;/code&gt; | 慢查询功能的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;solarisfixes.h&lt;/code&gt; | 针对 Solaris 系统的补丁。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;sort.c&lt;/code&gt; | SORT 命令的实现。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;syncio.c&lt;/code&gt; | 同步 I/O 操作。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;testhelp.h&lt;/code&gt; | 测试辅助宏。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;t_hash.c&lt;/code&gt; 、 &lt;code&gt;t_list.c&lt;/code&gt; 、 &lt;code&gt;t_set.c&lt;/code&gt; 、 &lt;code&gt;t_string.c&lt;/code&gt; 、 | 定义了 Redis 的各种数据类型，以及这些数据类型的命令。 | | &lt;code&gt;t_zset.c&lt;/code&gt; | | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;util.c&lt;/code&gt; 、 &lt;code&gt;util.h&lt;/code&gt; | 各种辅助函数。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;valgrind.sup&lt;/code&gt; | valgrind 的suppression文件。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;version.h&lt;/code&gt; | 记录了 Redis 的版本号。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;ziplist.c&lt;/code&gt; 、 &lt;code&gt;ziplist.h&lt;/code&gt; | ZIPLIST 数据结构的实现，用于优化 LIST 类型。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;zipmap.c&lt;/code&gt; 、 &lt;code&gt;zipmap.h&lt;/code&gt; | ZIPMAP 数据结构的实现，在 Redis 2.6 以前用与优化 HASH 类型， | | | Redis 2.6 开始已经废弃。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+ | &lt;code&gt;zmalloc.c&lt;/code&gt; 、 &lt;code&gt;zmalloc.h&lt;/code&gt; | 内存管理程序。 | +-------------------------------------------------------------------+-------------------------------------------------------------------+&lt;/p&gt;</summary>
  </entry>
</feed>