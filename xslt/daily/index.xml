<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub XSLT Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-20T01:45:58Z</updated>
  <subtitle>Daily Trending of XSLT in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>flowerwind/AutoGenerateXalanPayload</title>
    <updated>2023-01-20T01:45:58Z</updated>
    <id>tag:github.com,2023-01-20:/flowerwind/AutoGenerateXalanPayload</id>
    <link href="https://github.com/flowerwind/AutoGenerateXalanPayload" rel="alternate"></link>
    <summary type="html">&lt;p&gt;cve-2022-34169 延伸出的Jdk Xalan的payload自动生成工具，可根据不同的Jdk生成出其所对应的xslt文件&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AutoGenerateXalanPayload&lt;/h1&gt; &#xA;&lt;h3&gt;简介&lt;/h3&gt; &#xA;&lt;p&gt;这是一款根据cve-2022-34169漏洞延伸出的一个针对jdk xalan溢出漏洞的payload自动化生成工具。由于发现不同版本的Jdk所需要的溢出payload不同，所以这个自动化的生成工具诞生了，只需要用不同版本的JDK运行这个工程就可以生成出不同的xslt利用文件。&lt;/p&gt; &#xA;&lt;h3&gt;使用说明&lt;/h3&gt; &#xA;&lt;p&gt;复制select.bak.xslt为select.xslt，修改自己要执行的命令&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/flowerwind/AutoGenerateXalanPayload/master/images/image-20230117143738105.png&#34; alt=&#34;image-20230117143738105&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;然后运行java -jar AutoGenerateXalanPayload.jar即可，过程中又一些错误抛出，忽略即可。程序运行完毕后得到的select.xslt即为符合该jdk版本的xalan溢出命令执行的payload&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/flowerwind/AutoGenerateXalanPayload/master/images/image-20230117144434703.png&#34; alt=&#34;image-20230117144434703&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;改造思路&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/xxAtjFvk9RxWiY-pwGf8Ow&#34;&gt;https://mp.weixin.qq.com/s/xxAtjFvk9RxWiY-pwGf8Ow&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JDK版本对比&lt;/h3&gt; &#xA;&lt;p&gt;由于JDK小版本太多，因此我使用了二分法对比了jdk1.6-jdk1.8的版本。用测试1.7版本举例子，先测jdk1.7最高的小版本,得到一个xslt，设定这个xslt内容为A类型。再测试jdk1.7最低的小版本，得到一个xslt，如果这个xslt和1.7最高的小版本生成的内容完全一样，则表示jdk1.7最低到最高之间全部都通用一个A类型的payload。如果不一样的话，那我再取jdk1.7的中间版本测，就这样一直二分，这是我想到的测的最快的方式了，不用全部都安装测试又能覆盖到全部。举一个下面测试好的实例，Jdk-8u301为A类型payload，Jdk-8u202为A类型payload，那Jdk-8u221是这两位的中间版本，他不可能是B类型的payload吧？&lt;/p&gt; &#xA;&lt;p&gt;下面是我所测试得到的成果，得出jdk1.6到1.8之间有六种payload。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;jdk版本&lt;/th&gt; &#xA;   &lt;th&gt;xsls类型&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk-8u301&lt;/td&gt; &#xA;   &lt;td&gt;A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk-8u202&lt;/td&gt; &#xA;   &lt;td&gt;A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk-8u162&lt;/td&gt; &#xA;   &lt;td&gt;A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u152&lt;/td&gt; &#xA;   &lt;td&gt;A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u151&lt;/td&gt; &#xA;   &lt;td&gt;B&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u144&lt;/td&gt; &#xA;   &lt;td&gt;B&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u131&lt;/td&gt; &#xA;   &lt;td&gt;B&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u121&lt;/td&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u111&lt;/td&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u102&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u101&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u91&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u60&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk8u20&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk7u40&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk7u21&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk7u10&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk7u05&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk7u04&lt;/td&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk7u03&lt;/td&gt; &#xA;   &lt;td&gt;E&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Idk7u02&lt;/td&gt; &#xA;   &lt;td&gt;E&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk7u0&lt;/td&gt; &#xA;   &lt;td&gt;E&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk6u45&lt;/td&gt; &#xA;   &lt;td&gt;E&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk6u20&lt;/td&gt; &#xA;   &lt;td&gt;E&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk6u17&lt;/td&gt; &#xA;   &lt;td&gt;F&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk6u15&lt;/td&gt; &#xA;   &lt;td&gt;F&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk6u10&lt;/td&gt; &#xA;   &lt;td&gt;F&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jdk6u0&lt;/td&gt; &#xA;   &lt;td&gt;F&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;参考&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://blog.noah.360.net/xalan-j-integer-truncation-reproduce-cve-2022-34169/&#34;&gt;https://blog.noah.360.net/xalan-j-integer-truncation-reproduce-cve-2022-34169/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>