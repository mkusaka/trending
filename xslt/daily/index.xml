<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub XSLT Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-25T01:49:44Z</updated>
  <subtitle>Daily Trending of XSLT in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>invisibleXML/ixml</title>
    <updated>2023-01-25T01:49:44Z</updated>
    <id>tag:github.com,2023-01-25:/invisibleXML/ixml</id>
    <link href="https://github.com/invisibleXML/ixml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Invisible XML&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ixml&lt;/h1&gt; &#xA;&lt;h1&gt;Invisible XML&lt;/h1&gt; &#xA;&lt;p&gt;Data is an abstraction: there is no essential difference between the JSON&lt;/p&gt; &#xA;&lt;pre&gt;{&#34;temperature&#34;: {&#34;scale&#34;: &#34;C&#34;, &#34;value&#34;: 21}}&lt;/pre&gt; &#xA;&lt;p&gt;and an equivalent XML&lt;/p&gt; &#xA;&lt;pre&gt;&amp;lt;temperature scale=&#34;C&#34; value=&#34;21&#34;/&amp;gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&amp;lt;temperature&amp;gt;&#xA;   &amp;lt;scale&amp;gt;C&amp;lt;/scale&amp;gt;&#xA;   &amp;lt;value&amp;gt;21&amp;lt;/value&amp;gt;&#xA;&amp;lt;/temperature&amp;gt;&lt;/pre&gt; &#xA;&lt;p&gt;since the underlying abstractions being represented are the same. &lt;/p&gt; &#xA;&lt;p&gt;We choose which representations of our data to use, JSON, CSV, XML, or whatever, depending on habit, convenience, or the context we want to use that data in. On the other hand, having an interoperable generic toolchain such as that provided by XML to process data is of immense value. How do we resolve the conflicting requirements of convenience, habit, and context, and still enable a generic toolchain? &lt;/p&gt; &#xA;&lt;p&gt;Invisible XML (ixml) is a method for treating non-XML documents as if they were XML, enabling authors to write documents and data in a format they prefer while providing XML for processes that are more effective with XML content. For example, it can turn CSS code like&lt;/p&gt; &#xA;&lt;pre&gt;body {color: blue; font-weight: bold}&lt;/pre&gt; &#xA;&lt;p&gt;into XML like&lt;/p&gt; &#xA;&lt;pre&gt;&amp;lt;css&amp;gt;&#xA;   &amp;lt;rule&amp;gt;&#xA;      &amp;lt;simple-selector name=&#34;body&#34;/&amp;gt;&#xA;      &amp;lt;block&amp;gt;&#xA;         &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;color&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;blue&amp;lt;/value&amp;gt;&#xA;         &amp;lt;/property&amp;gt;&#xA;         &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;font-weight&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;bold&amp;lt;/value&amp;gt;&#xA;         &amp;lt;/property&amp;gt;&#xA;      &amp;lt;/block&amp;gt;&#xA;   &amp;lt;/rule&amp;gt;&#xA;&amp;lt;/css&amp;gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&amp;lt;css&amp;gt;&#xA;   &amp;lt;rule&amp;gt;&#xA;      &amp;lt;selector&amp;gt;body&amp;lt;/selector&amp;gt;&#xA;      &amp;lt;block&amp;gt;&#xA;         &amp;lt;property name=&#34;color&#34; value=&#34;blue&#34;/&amp;gt;&#xA;         &amp;lt;property name=&#34;font-weight&#34; value=&#34;bold&#34;/&amp;gt;&#xA;      &amp;lt;/block&amp;gt;&#xA;   &amp;lt;/rule&amp;gt;&#xA;&amp;lt;/css&amp;gt;&lt;/pre&gt; &#xA;&lt;p&gt;depending on choice.&lt;/p&gt; &#xA;&lt;p&gt;This is an ongoing project to provide software that lets you treat any parsable format as if it were XML, without the need for markup. &lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The (draft) &lt;a href=&#34;https://raw.githubusercontent.com/invisibleXML/ixml/master/ixml-specification.html&#34;&gt;Specification for Invisible XML&lt;/a&gt; formally describes the language.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;http://www.cwi.nl/~steven/ixml/tutorial/&#34;&gt;hands-on tutorial&lt;/a&gt; shows you how to use it.&lt;/li&gt; &#xA; &lt;li&gt;The ixml grammar &lt;a href=&#34;https://raw.githubusercontent.com/invisibleXML/ixml/master/ixml.ixml&#34;&gt;in ixml serialization&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The ixml grammar &lt;a href=&#34;https://raw.githubusercontent.com/invisibleXML/ixml/master/ixml.xml&#34;&gt;in XML serialization&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are five papers on the development:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html&#34;&gt;Invisible XML&lt;/a&gt;: Introduces the concepts, and develops a notation to support them. &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.cwi.nl/~steven/Talks/2016/02-12-prague/data.html&#34;&gt;Data just wants to be (format) neutral&lt;/a&gt;: Discusses issues with automatic serialisation, and the relationship between Invisible XML grammars and data schemas. &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.cwi.nl/~steven/Talks/2016/06-05-london/xml-london.html&#34;&gt;Parse Earley, Parse Often: How to parse anything to XML&lt;/a&gt;: Discusses issues around grammar design, and in particular parsing algorithms used to recognise any document, and converting the resultant parse-tree into XML, and gives a new perspective on a classic algorithm. &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://archive.xmlprague.cz/2017/files/xmlprague-2017-proceedings.pdf#page=155&#34;&gt;On the Descriptions of Data: The Usability of Notations&lt;/a&gt;: Discusses changes to the design following experience with using it, giving examples of its use to develop data descriptions, and in passing, suggests other output formats. &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://archive.xmlprague.cz/2019/files/xmlprague-2019-proceedings.pdf#page=425&#34;&gt;On the Specification of Invisible XML&lt;/a&gt;: Describes decisions made during the production of the specification of ixml. &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Software to support ixml will be made available at a later date, but it is already usable via a link; see &lt;a href=&#34;http://www.cwi.nl/~steven/ixml/tutorial/&#34;&gt;the tutorial&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>http-tests/cache-tests</title>
    <updated>2023-01-25T01:49:44Z</updated>
    <id>tag:github.com,2023-01-25:/http-tests/cache-tests</id>
    <link href="https://github.com/http-tests/cache-tests" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tests for HTTP Caches&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Tests for HTTP Caches&lt;/h1&gt; &#xA;&lt;p&gt;This is a test suite for the behaviours of &lt;a href=&#34;https://httpwg.org/specs/rfc9111.html&#34;&gt;HTTP caches&lt;/a&gt;, including browsers, proxy caches and CDNs. Its public results are available at &lt;a href=&#34;https://cache-tests.fyi&#34;&gt;cache-tests.fyi&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#goals&#34;&gt;Goals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#installing-from-npm&#34;&gt;Installing from NPM&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#running-the-test-server&#34;&gt;Running the Test Server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#testing-reverse-proxies-and-cdns&#34;&gt;Testing Reverse Proxies and CDNs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#testing-from-the-command-line&#34;&gt;Testing from the Command Line&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#testing-with-docker&#34;&gt;Testing with Docker&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#testing-browser-caches&#34;&gt;Testing Browser Caches&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#interpreting-the-results&#34;&gt;Interpreting the Results&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#test-results-faq&#34;&gt;Test Results FAQ&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#getting-your-results-onto-cache-testsfyi&#34;&gt;Getting your results onto cache-tests.fyi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/#creating-new-tests&#34;&gt;Creating new tests&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;p&gt;Overall, the goal of these tests is to identify variances in the behaviour, both from the normative specifications and between implementations. This in turn can help avoid situations where they act in surprising ways.&lt;/p&gt; &#xA;&lt;p&gt;The underlying aim is to provide a basis for discussion about how HTTP caches -- especially in CDNs and reverse proxies -- should behave, so that over time we can adapt the tests and align implementations to behave more consistently.&lt;/p&gt; &#xA;&lt;p&gt;In other words, &lt;strong&gt;passing all of the tests currently means nothing&lt;/strong&gt; -- this is not a conformance test suite, it&#39;s just the start of a conversation, and a &lt;strong&gt;tool to assess how a cache behaves&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Therefore, if you believe a test should change (based upon common behaviour or your interpretation of the specifications), or have additional tests, please &lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/.github/CONTRIBUTING.md&#34;&gt;contribute&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The tests require a recent version of &lt;a href=&#34;https://nodejs.org/&#34;&gt;NodeJS&lt;/a&gt; (10.8.0 or greater), which includes the &lt;code&gt;npm&lt;/code&gt; package manager.&lt;/p&gt; &#xA;&lt;p&gt;To install the most recent source from GitHub (&lt;em&gt;recommended; things are moving fast&lt;/em&gt;):&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;git clone &lt;a href=&#34;https://github.com/http-tests/cache-tests.git&#34;&gt;https://github.com/http-tests/cache-tests.git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;and then install dependencies:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;cd cache-tests; npm i&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Installing from NPM&lt;/h3&gt; &#xA;&lt;p&gt;Alternatively, for the most recent release:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;npm i --legacy-bundling http-cache-tests&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Running the Test Server&lt;/h2&gt; &#xA;&lt;p&gt;First, start the server-side by running:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;npm run server&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;inside the directory (the repository&#39;s directory if you cloned from git, or &lt;code&gt;node_modules/http-cache-tests&lt;/code&gt; if you installed from npm).&lt;/p&gt; &#xA;&lt;p&gt;By default, the server runs on port 8000; to choose a different port, use the &lt;code&gt;--port&lt;/code&gt; argument; e.g.,&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;npm run server --port=8080&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to run an HTTPS origin, you&#39;ll need to specify the &lt;code&gt;protocol&lt;/code&gt;, &lt;code&gt;keyfile&lt;/code&gt; and &lt;code&gt;certfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;npm run server --protocol=https --keyfile=/path/to/key.pem --certfile=/path-to-cert.pem&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Note that the default port for HTTPS is still 8000.&lt;/p&gt; &#xA;&lt;p&gt;Make sure that the browser is not configured to use a proxy cache, and that the network being tested upon does not use an intercepting proxy cache.&lt;/p&gt; &#xA;&lt;h2&gt;Testing Reverse Proxies and CDNs&lt;/h2&gt; &#xA;&lt;h3&gt;Testing from the Command Line&lt;/h3&gt; &#xA;&lt;p&gt;To test a reverse proxy or CDN from the command line::&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;npm run --silent cli --base=&lt;a href=&#34;http://server-url.example.org:8000/&#34;&gt;http://server-url.example.org:8000/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;... using the URL of the server you want to test. This will output the test results in JSON to STDOUT, suitable for inclusion in the &lt;code&gt;results&lt;/code&gt; directory. See &lt;code&gt;lib/summary.mjs&lt;/code&gt; for details of how to interpret that.&lt;/p&gt; &#xA;&lt;p&gt;To run a single test, use:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;npm run cli --base=&lt;a href=&#34;http://server-url.example.org:8000/&#34;&gt;http://server-url.example.org:8000/&lt;/a&gt; --id=test-id&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;... where &lt;code&gt;test-id&lt;/code&gt; is the identifier for the test. This will output the request and response headers as seen by the client and server, along with the results. This is useful for debugging a particular failure.&lt;/p&gt; &#xA;&lt;h3&gt;Testing with Docker&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;s also a docker image, &lt;code&gt;mnot/proxy-cache-tests&lt;/code&gt;, that can be used to test reverse proxy caches. Once you have docker running, you can run the CLI tests against a given proxy like this:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;./test-docker.sh squid&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To run an individual test case, try:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;./test-docker.sh -i freshness-none nginx&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Testing Browser Caches&lt;/h2&gt; &#xA;&lt;p&gt;To test a browser, just point it at &lt;code&gt;https://{hostname:port}/test-browser.html&lt;/code&gt; after setting up the server.&lt;/p&gt; &#xA;&lt;p&gt;On OSX, you can use &lt;code&gt;test-browser.sh&lt;/code&gt; to automate this.&lt;/p&gt; &#xA;&lt;h2&gt;Interpreting the Results&lt;/h2&gt; &#xA;&lt;p&gt;HTTP caching by its nature is an optimisation; implementations aren&#39;t required to cache everything. However, when they do cache, their behaviour is constrained by &lt;a href=&#34;https://httpwg.org/specs/rfc9111.html&#34;&gt;the specification&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As a result, there are a few different kinds of test results (note that the HTML results use similar but slightly different symbols):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;✅ - The test was successful.&lt;/li&gt; &#xA; &lt;li&gt;⛔️ - The test failed, and likely indicates a specification conformance problem.&lt;/li&gt; &#xA; &lt;li&gt;⚠️ - The cache didn&#39;t behave in an optimal fashion (usually, it didn&#39;t use a stored response when it could have), but this is not a conformance problem.&lt;/li&gt; &#xA; &lt;li&gt;● / ○ - These are tests to see how deployed caches behave; we use them to gather information for future specification work. &#34;yes&#34; and &#34;no&#34; respectively.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some additional results might pop up from time to time:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;⁉️ - The test harness failed; this is an internal error, please &lt;a href=&#34;https://github.com/http-tests/cache-tests/issues/&#34;&gt;file a bug if one doesn&#39;t exist&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;🔹 - The test failed during setup; something interfered with the harness&#39;s communication between the client and server. See below.&lt;/li&gt; &#xA; &lt;li&gt;↻ - The cache retried a request; this means the test result needs to be interpreted manually, as it may or may not have behaved correctly.&lt;/li&gt; &#xA; &lt;li&gt;⚪️ - Another test that this test depends on has failed; we use dependencies to help assure that we&#39;re actually testing the behaviour in question.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&lt;/code&gt; - Not tested; usually because the test isn&#39;t applicable to this cache.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When you&#39;re testing with a browser, each test has a &lt;code&gt;uuid&lt;/code&gt; that identifies that specific test run; this can be used to find its requests in the browser developer tools or proxy logs. Click ⚙︎ to copy it to the clipboard.&lt;/p&gt; &#xA;&lt;h3&gt;Test Results FAQ&lt;/h3&gt; &#xA;&lt;p&gt;If you see a lot of failures, it might be one of a few different issues:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If you see lots of grey circles at the top (dependency failures), it&#39;s probably because the cache will store and reuse a response without explicit freshness or a validator. While this is technically legal in HTTP, it interferes with the tests. Disabling &#34;default caching&#34; or similar usually fixes this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you see lots of blue diamonds (setup failures), it&#39;s likely that the cache is refusing &lt;code&gt;PUT&lt;/code&gt; requests. Enable them to clear this; the tests use PUT to synchronise state between the client and the server.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting your results onto cache-tests.fyi&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cache-tests.fyi&#34;&gt;cache-tests.fyi&lt;/a&gt; collects results from caches in browsers, reverse proxies, and CDNs. Its purpose is to gather information about how HTTP caching works &#34;in the wild&#34;, to help the &lt;a href=&#34;https://httpwg.org&#34;&gt;HTTP Working Group&lt;/a&gt; make decisions about how to evolve the specification.&lt;/p&gt; &#xA;&lt;p&gt;If your implementation isn&#39;t listed and you want it to be, please file an issue, or contact &lt;a href=&#34;mailto:mnot@mnot.net&#34;&gt;Mark Nottingham&lt;/a&gt;. Both open source and proprietary implementations are welcome; if there are commercial concerns about disclosing your results, your identity can be anonymised (e.g., &#34;CDN A&#34;), and will not be disclosed to anyone.&lt;/p&gt; &#xA;&lt;p&gt;Right now, all of the reverse proxy and CDN implementations are run by a script on a server, using the command-line client; to keep results up-to-date as the tests evolve, it&#39;s most helpful if you can provide an endpoint to test (for reverse proxies and CDNs).&lt;/p&gt; &#xA;&lt;h2&gt;Creating new tests&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/http-tests/cache-tests/main/.github/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>