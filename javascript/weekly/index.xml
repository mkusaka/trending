<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-05T01:53:48Z</updated>
  <subtitle>Weekly Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yetone/bob-plugin-openai-translator</title>
    <updated>2023-03-05T01:53:48Z</updated>
    <id>tag:github.com,2023-03-05:/yetone/bob-plugin-openai-translator</id>
    <link href="https://github.com/yetone/bob-plugin-openai-translator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;基于 ChatGPT API 的文本翻译、文本润色、语法纠错 Bob 插件，让我们一起迎接不需要巴别塔的新时代！&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;OpenAI Translator Bob Plugin&lt;/h2&gt; &#xA;&lt;h1&gt;使用截图&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1206493/221086195-f1ed941d-4dfa-4aa0-9d47-56c258a8f854.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;简介&lt;/h1&gt; &#xA;&lt;p&gt;ChatGPT 向我们展示了 GPT 模型的伟大之处，所以我使用 OpenAI 的 API 实现了这个 Bob 的翻译 + 润色 + 语法修改插件，效果拔群！&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;重要更新：此插件已支持使用 ChatGPT API 对句子进行润色和语法修改，只需要把目标语言选成跟源语言一样即可，全面替代 Grammarly！而且理论上任何语言都可以润色，不只是英语。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;重要更新：非 macOS 用户可以使用我开发的基于 ChatGPT API 的划词翻译浏览器插件 &lt;a href=&#34;https://github.com/yetone/openai-translator&#34;&gt;openai-translator&lt;/a&gt; 以解燃眉之急。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;如果你不喜欢翻译功能和文本润色功能放在一起，这里单独拆分出了一个专门用来文本润色和语法纠错的插件: &lt;a href=&#34;https://github.com/yetone/bob-plugin-openai-polisher&#34;&gt;bob-plugin-openai-polisher&lt;/a&gt;，这个润色插件具有更高级的润色功能，比如解释修改原因等。&lt;/p&gt; &#xA;&lt;p&gt;要使用 ChatGPT 的 API 需要在 Bob 的设置页面把此插件的模型改为 &lt;code&gt;gpt-3.5-turbo-0301&lt;/code&gt; 或者 &lt;code&gt;gpt-3.5-turbo&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1206493/222339607-d8f05042-4b65-495c-af58-849891de7434.png&#34; alt=&#34;how to use ChatGPT API&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;我这只是个小小的 Bob 插件，强大的是 Bob 本身，向它的开发者 &lt;a href=&#34;https://github.com/ripperhe&#34;&gt;ripperhe&lt;/a&gt; 致敬！&lt;/p&gt; &#xA;&lt;h1&gt;使用方法&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;安装 &lt;a href=&#34;https://bobtranslate.com/guide/#%E5%AE%89%E8%A3%85&#34;&gt;Bob&lt;/a&gt; (版本 &amp;gt;= 0.50)&lt;/li&gt; &#xA; &lt;li&gt;下载此插件: &lt;a href=&#34;https://github.com/yetone/bob-plugin-openai-translator/releases&#34;&gt;openai-translator.bobplugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;安装此插件:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1206493/219937302-6be8d362-1520-4906-b8d6-284d01012837.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;去 &lt;a href=&#34;https://platform.openai.com/account/api-keys&#34;&gt;OpenAI&lt;/a&gt; 获取你的 API KEY&lt;/li&gt; &#xA; &lt;li&gt;把 API KEY 填入 Bob 此插件配置界面的 API KEY 输入框中&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1206493/219937398-8e5bb8d2-7dc8-404a-96e7-a937e08c939f.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;安装 &lt;a href=&#34;https://bobtranslate.com/guide/integration/popclip.html&#34;&gt;PopClip&lt;/a&gt; 实现划词后鼠标附近出现小图标&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1206493/219933584-d0c2b6cf-8fa0-40a6-858f-8f4bf05f38ef.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;请作者喝一杯咖啡&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img height=&#34;360&#34; src=&#34;https://user-images.githubusercontent.com/1206493/220753437-90e4039c-d95f-4b6a-9a08-b3d6de13211f.png&#34;&gt; &#xA; &lt;img height=&#34;360&#34; src=&#34;https://user-images.githubusercontent.com/1206493/220756036-d9ac4512-0375-4a32-8c2e-8697021058a2.png&#34;&gt; &#xA;&lt;/div&gt;</summary>
  </entry>
  <entry>
    <title>serverless-stack/sst</title>
    <updated>2023-03-05T01:53:48Z</updated>
    <id>tag:github.com,2023-03-05:/serverless-stack/sst</id>
    <link href="https://github.com/serverless-stack/sst" rel="alternate"></link>
    <summary type="html">&lt;p&gt;💥 SST makes it easy to build full-stack serverless apps.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://sst.dev/&#34;&gt; &lt;img alt=&#34;SST&#34; src=&#34;https://raw.githubusercontent.com/serverless-stack/identity/main/variants/sst-full.svg?sanitize=true&#34; width=&#34;300&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://sst.dev/discord&#34;&gt;&lt;img alt=&#34;Discord&#34; src=&#34;https://img.shields.io/discord/983865673656705025?style=flat-square&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/sst&#34;&gt;&lt;img alt=&#34;npm&#34; src=&#34;https://img.shields.io/npm/v/sst.svg?style=flat-square&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/serverless-stack/sst/actions/workflows/test.yml&#34;&gt;&lt;img alt=&#34;Build status&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/serverless-stack/sst/test.yml?style=flat-square&amp;amp;branch=master&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;SST makes it easy to build modern full-stack applications on AWS.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npx create-sst@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.sst.dev/quick-start&#34;&gt;Take a quick tour of SST&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Start With Your Frontend&lt;/h3&gt; &#xA;&lt;p&gt;Deploy Next.js, Remix, Astro, Solid, or any static site to AWS.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/NextjsSite&#34;&gt;&lt;strong&gt;Next.js&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/RemixSite&#34;&gt;&lt;strong&gt;Remix&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/AstroSite&#34;&gt;&lt;strong&gt;Astro&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/SolidStartSite&#34;&gt;&lt;strong&gt;Solid&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/StaticSite&#34;&gt;&lt;strong&gt;Static site&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Add any backend feature&lt;/h3&gt; &#xA;&lt;p&gt;SST gives you the full power of AWS. Making it easy to add any feature to your product.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/RDS&#34;&gt;Databases&lt;/a&gt; — Use a serverless SQL or NoSQL database to power your app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/Api&#34;&gt;APIs&lt;/a&gt; — Add a GraphQL or a simple REST API to your app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/Auth&#34;&gt;Auth&lt;/a&gt; — Authenticate your users through any auth provider.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/Bucket&#34;&gt;File uploads&lt;/a&gt; — Upload files to S3 and manage them through the SST console.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/Cron&#34;&gt;Jobs&lt;/a&gt; — Run cron jobs or long running jobs powered by serverless functions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.sst.dev/constructs/Queue&#34;&gt;Queues&lt;/a&gt; — Work with serverless queues without any infrastructure.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Collaborate with your team&lt;/h3&gt; &#xA;&lt;p&gt;Finally, you can &lt;code&gt;git push&lt;/code&gt; to deploy using &lt;a href=&#34;https://seed.run&#34;&gt;&lt;em&gt;&lt;strong&gt;Seed&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;, a service built by the team behind SST. And you can work on your apps together with your team with automatic preview environments.&lt;/p&gt; &#xA;&lt;h2&gt;Learn more&lt;/h2&gt; &#xA;&lt;p&gt;To learn more, &lt;a href=&#34;https://docs.sst.dev&#34;&gt;&lt;strong&gt;head over to our docs&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Join our community&lt;/strong&gt; &lt;a href=&#34;https://sst.dev/discord&#34;&gt;Discord&lt;/a&gt; | &lt;a href=&#34;https://www.youtube.com/c/sst-dev&#34;&gt;YouTube&lt;/a&gt; | &lt;a href=&#34;https://twitter.com/SST_dev&#34;&gt;Twitter&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/serverless-stack/sst/master/CONTRIBUTING.md&#34;&gt;Contribute&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/swissgl</title>
    <updated>2023-03-05T01:53:48Z</updated>
    <id>tag:github.com,2023-03-05:/google/swissgl</id>
    <link href="https://github.com/google/swissgl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SwissGL is a minimalistic wrapper on top of WebGL2 JS API. It&#39;s designed to reduce the amount of boilerplate code required to manage GLSL shaders, textures and framebuffers when making procedural visualizations or simulations.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwissGL: Swiss Army knife for WebGL2&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://google.github.io/swissgl&#34;&gt;DEMO&lt;/a&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/docs/API.md&#34;&gt;API&lt;/a&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/docs/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;SwissGL is a minimalistic wrapper on top of WebGL2 JS API. It&#39;s designed to reduce the amount of boilerplate code required to manage GLSL shaders, textures and framebuffers when making GPGPU-style procedural visualizations or simulations. See the &lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/demo/&#34;&gt;demos&lt;/a&gt; for examples of using SwissGL. As of now the library consists of a standalone ~600 loc .js file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt; This is not an officially supported Google product. SwissGL is an early stage experiment, incomplete and unstable. It&#39;s an invitation to discuss compact and expressive graphics library design, which I hope is relevant in light of the upcoming arrival of WebGPU.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;As of now, the library API consists of a single function object that does everything (like a Swiss Army knife). Here is a minimal example of using it to draw an animated gradient quad:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;script src=&#34;swissgl.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;canvas id=&#34;c&#34; width=&#34;600&#34; height=&#34;400&#34;&amp;gt;&amp;lt;/canvas&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    const canvas = document.getElementById(&#39;c&#39;);&#xA;    const glsl = SwissGL(canvas);&#xA;&#xA;    function render(t) {&#xA;        t /= 1000; // ms to sec&#xA;        glsl({t}, `UV,cos(t*TAU),1`);&#xA;        requestAnimationFrame(render);&#xA;    }&#xA;    render(0.0);&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/quad.png&#34; alt=&#34;SwissGL quad gradient&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This line creates a SwissGL library instance that wraps a WebGL2 context of a given &lt;code&gt;canvas&lt;/code&gt; element (you can also pass a WebGL2 context):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const glsl = SwissGL(canvas);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can already draw something:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;glsl({t}, `UV,cos(t*10.0),1`);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This line, called during the animation loop, creates a shader that evaluates the given expression string into RGBA-color for every pixel on the canvas. &lt;code&gt;vec2 UV&lt;/code&gt; variable provides &lt;code&gt;[0,1]&lt;/code&gt;-range normalized coordinates of the current pixel, and &lt;code&gt;ivec2 I&lt;/code&gt; can be used to get integer coordinates. The shader is compiled and cached during the first call and reused later.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;glsl&lt;/code&gt; function has at most three arguments, some of which can be omitted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;glsl(params, code, target);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/docs/API.md&#34;&gt;API reference&lt;/a&gt; for the detailed explanation of their function. Let&#39;s now have a look at the more elaborate example of using SwissGL to implement a particle simulation.&lt;/p&gt; &#xA;&lt;h2&gt;Particle Life&lt;/h2&gt; &#xA;&lt;p&gt;Inspired by the &lt;a href=&#34;https://youtu.be/p4YirERTVF0?t=481&#34;&gt;beautiful video&lt;/a&gt; by Tom Mohr, let&#39;s try reproduce the &#34;snake&#34; pattern shown there. Particle Life is made of particles of a few different types. All particles repel when they are closer than some distance $r$, but at around $2r$ the resulting (potentially non-symmetric) force is described by the special force matrix $F_{i,j}$, where $i,j$ are types of two particles. Positive $F$ corresponds to attraction and negative to repulsion. Let&#39;s create a texture that stores such a matrix. We can create an array on the JS side and pass it to SwissGL, but it&#39;s even easier to populate matrix values right on GPU:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const K = 6; // number of particle types&#xA;const F = glsl(`&#xA;    float(I.x==I.y) + 0.1*float(I.x==I.y+1)`,&#xA;    {size:[K,K], format:&#39;r16f&#39;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates a single channel float16 texture of size &lt;code&gt;[width,height]==[6,6]&lt;/code&gt; and populates its values by evaluating the expression. &lt;code&gt;I&lt;/code&gt; is a special variable of type &lt;code&gt;ivec2&lt;/code&gt; that contains coordinates of the pixel being evaluated.&lt;/p&gt; &#xA;&lt;p&gt;We can easily visualize the resulting texture to make sure everything is ok:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;glsl({F}, `F(I/20).x*3.0`);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/F.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Uniform textures can be accessed with usual GLSL functions, or with a helper macro that has the same name as the texture uniform. Passing &lt;code&gt;ivec2&lt;/code&gt; as parameter makes it call &lt;code&gt;texelFetch()&lt;/code&gt; to get a texel using the integer coordinates, passing &lt;code&gt;vec2&lt;/code&gt; uses &lt;code&gt;texture()&lt;/code&gt;, with filtering and wrapping.&lt;/p&gt; &#xA;&lt;p&gt;The next step is to create a list of textures that is going to contain particle positions. Each pixel will contain a single particle position and type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const points = glsl({size:[30,10], story:3, format:&#39;rgba32f&#39;, tag:&#39;points&#39;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We are going to simulate 30*10=300 particles. Textures will have 4 channels (RGBA) of type float32. The &lt;code&gt;story:3&lt;/code&gt; argument says that we need to create a cyclic buffer of three textures of the same format, so that we can read two consecutive states of the particle system (for momentum) to produce the third. We don&#39;t provide shader &lt;code&gt;code&lt;/code&gt; to the SwissGL call, so we must specify the storage &lt;code&gt;tag&lt;/code&gt;. Now we can initialize these textures:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;for (let i=0; i&amp;lt;2; ++i) {&#xA;    glsl({K, seed:123}, `&#xA;        vec2 pos = (hash(ivec3(I, seed)).xy-0.5)*10.0;&#xA;        float color = floor(UV.x*K);&#xA;        out0 = vec4(pos, 0.0, color);`,&#xA;        points);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The shader code above uses &#34;multiline&#34; shader &lt;code&gt;code&lt;/code&gt; format instead of a single expression. The output must be written to a global variable &lt;code&gt;out0&lt;/code&gt;. Variable &lt;code&gt;UV&lt;/code&gt; has type &lt;code&gt;vec2&lt;/code&gt; and provides &lt;code&gt;[0,1]&lt;/code&gt;-range normalized coordinates of the current pixel. It is used to assign one of &lt;code&gt;K&lt;/code&gt; &#34;colors&#34; to each particle. For convenience SwissGL provides a &lt;a href=&#34;https://github.com/google/swissgl/raw/536c9f43c9f7a7bc59646d6fe1f3cb89bb5862b8/swissgl.js#L157&#34;&gt;simple hash&lt;/a&gt; function &lt;code&gt;vec3 hash(ivec3)&lt;/code&gt; that can be used as a deterministic random number generator.&lt;/p&gt; &#xA;&lt;p&gt;Note that we are writing the same particle positions two times, which means that particles have zero velocity at initialization. Now &lt;code&gt;points[0]&lt;/code&gt; and &lt;code&gt;points[1]&lt;/code&gt; contain the same values, and &lt;code&gt;points[2]&lt;/code&gt; is uninitialized and is going to be overwritten at the first simulation step.&lt;/p&gt; &#xA;&lt;p&gt;Before we start modeling the particle dynamics it&#39;s a good idea to implement visualization. So far we&#39;ve already seen &#34;expression&#34; and &#34;multiline&#34; shortcut &lt;code&gt;code&lt;/code&gt; formats. Now we are going to write a &lt;code&gt;full&lt;/code&gt; vertex-fragment shader pair:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;glsl({K, worldExtent,  // uniforms&#xA;      // reading the last state of &#39;points&#39; texture&#xA;      points: points[0], &#xA;      // render a quad instance for every &#39;points&#39; texel&#xA;      Grid: points[0].size,&#xA;      // preserve the scale of xy-axes by fitting&#xA;      // [-1..1]x[-1..1] box into the view&#xA;      Aspect:&#39;fit&#39;,&#xA;      // blend primitives using alpha transparency&#xA;      Blend: &#39;d*(1-sa)+s*sa&#39;}, `&#xA;&#xA;// the code below is available in both&#xA;// vertex and fragment shaders&#xA;varying vec3 color;&#xA;&#xA;//VERT  start of vertex-only section&#xA;// vertex function is called &#xA;vec4 vertex() {&#xA;    // get current particle data&#xA;    vec4 d = points(ID);&#xA;    // populate varyings to use in fragment shader&#xA;    color = cos((d.w/K+vec3(0,0.33,0.66))*TAU)*0.5+0.5;&#xA;    // emit normalized on-screen vertex position&#xA;    // &#39;vec2 XY&#39; is contains coordinates of the quad vertex in -1..1 range&#xA;    return vec4(2.0*(d.xy+XY/8.0)/worldExtent, 0.0, 1.0);&#xA;}&#xA;&#xA;//FRAG  start of fragment-only section&#xA;void fragment() {&#xA;    // Compute the fragment transparency depending&#xA;    // on the distance from the quad center.&#xA;    // Interpolated XY is also available in the fragment shader.&#xA;    float alpha = smoothstep(1.0, 0.6, length(XY));&#xA;    // set the fragment color&#xA;    out0 = vec4(color, alpha);&#xA;}`); // &#39;target&#39; is omitted, so rendering to canvas&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running this code in the drawing loop produces the following image:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/init_particles.png&#34; alt=&#34;Initial particles&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The vertex shader computes WebGL &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#clip_space&#34;&gt;Clip Space&lt;/a&gt; coordinates for each corner of each particle quad. We map particle positions from &lt;code&gt;[-worldExtent/2, worldExtent/2]&lt;/code&gt; range to &lt;code&gt;[-1,1]&lt;/code&gt; box. This shader also computes particle color using &lt;a href=&#34;https://iquilezles.org/articles/palettes/&#34;&gt;cosine palettes trick&lt;/a&gt; and passes it to the fragment shader along with the corner offset vector. The fragment shader calculates pixel opacity &lt;code&gt;alpha&lt;/code&gt; using the distance form the particle center and sets &lt;code&gt;out0&lt;/code&gt; variable. This way we can use low-level GLSL as an expressive, flexible and performant tool to render large numbers of primitives.&lt;/p&gt; &#xA;&lt;p&gt;Now we can set particles in motion by writing the update shader that computes new particle positions each frame.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;glsl({F, worldExtent, repulsion, inertia, dt, // uniforms&#xA;      // The current state of the system is implicitly&#xA;      // available to the shader as &#39;Src&#39; uniform if&#xA;      // the target has history (is an array of textures).&#xA;      // Here we explicitly pass the state one step at the past&#xA;      past:points[1]}, `&#xA;// this function wraps positions and velocities to&#xA;// [-worldExtent/2, worldExtent/2] range&#xA;vec3 wrap(vec3 p) {&#xA;    return (fract(p/worldExtent+0.5)-0.5)*worldExtent;&#xA;}&#xA;void fragment() {&#xA;    // read the current particle state&#xA;    out0 = Src(I);&#xA;    vec3 force=vec3(0); // force accumulator&#xA;    // iterate over particles&#xA;    for (int y=0; y&amp;lt;ViewSize.y; ++y)&#xA;    for (int x=0; x&amp;lt;ViewSize.x; ++x) {&#xA;        // reading the state of another particle&#xA;        vec4 data1 = Src(ivec2(x,y));&#xA;        vec3 dpos = wrap(data1.xyz-out0.xyz);&#xA;        // calculate distance&#xA;        float r = length(dpos);&#xA;        if (r&amp;gt;3.0) continue;&#xA;        dpos /= r+1e-8;&#xA;        // calculate repulsion and interaction forces&#xA;        float rep = max(1.0-r, 0.0)*repulsion;&#xA;        float f = F(ivec2(out0.w, data1.w)).x;&#xA;        float inter = f*max(1.0-abs(r-2.0), 0.0);&#xA;        force += dpos*(inter-rep);&#xA;    }&#xA;    // fetch the past state to compute velocity&#xA;    vec3 vel = wrap(out0.xyz-past(I).xyz)*pow(inertia, dt);&#xA;    // update particle position&#xA;    out0.xyz = wrap(out0.xyz+vel+0.5*force*(dt*dt));&#xA;}&#xA;`, points);  // using &#39;points&#39; as the target&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Soon randomly scattered particles self-assemble into a nice colorful snake! The simulation is happening on the GPU and is quite fast for the quadratic complexity algorithm (that iterates all particle pairs). Even mobile phones can run hundreds of steps per second. Thanks to SwissGL, orchestrating this computation, managing shaders and framebuffers takes minimal amount of boilerplate code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/particle_snake.png&#34; alt=&#34;Partilce Snake&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;p&gt;Sources of wisdom:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://iquilezles.org/&#34;&gt;Inigo Quilez&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://acko.net/&#34;&gt;Steven Wittens&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://webglfundamentals.org/&#34;&gt;WebGL&lt;/a&gt; / &lt;a href=&#34;https://webgl2fundamentals.org/&#34;&gt;WebGL2&lt;/a&gt; fundamentals&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Playgrounds:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.shadertoy.com/&#34;&gt;ShaderToy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twigl.app/&#34;&gt;twigl&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.vertexshaderart.com/&#34;&gt;vertexshaderart&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Libraries&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://threejs.org/&#34;&gt;three.js&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://usegpu.live/&#34;&gt;Use.GPU&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/unconed/mathbox&#34;&gt;MathBox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twgljs.org/&#34;&gt;twgljs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/regl-project/regl&#34;&gt;regl&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/amandaghassaei/gpu-io&#34;&gt;gpu-io&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://luma.gl/&#34;&gt;luma.gl&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>