<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-17T01:32:12Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>randyisback/ask-for-a-date</title>
    <updated>2024-03-17T01:32:12Z</updated>
    <id>tag:github.com,2024-03-17:/randyisback/ask-for-a-date</id>
    <link href="https://github.com/randyisback/ask-for-a-date" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Js project troll.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ask For A Date&lt;/h1&gt; &#xA;&lt;h2&gt;Proje Hakkında&lt;/h2&gt; &#xA;&lt;p&gt;Ask For A Date, kullanıcıya basit bir etkileşimli deneyim sunan bir JavaScript uygulamasıdır. Bu uygulama, Çıkma teklifi etmek için bir senaryo sunar ve kullanıcının yanlış bir tuşa basması durumunda eğlenceli bir tepki verir.&lt;/p&gt; &#xA;&lt;h2&gt;Nasıl Çalışır?&lt;/h2&gt; &#xA;&lt;p&gt;Kullanıcı ekranda &#34;Evet&#34; ve &#34;Hayır&#34; butonlarına sahip bir kutu görür. Kullanıcı &#34;Tab&#34; tuşuna bastığında, &#34;Hayır&#34; butonu bir patlama animasyonu ile kaybolur, başlık metni değişir ve &#34;Evet&#34; butonu kalır. Ardından, başlık metni tekrar orijinal haline döner.&lt;/p&gt; &#xA;&lt;h2&gt;Nasıl Kullanılır?&lt;/h2&gt; &#xA;&lt;p&gt;Proje dosyalarını bilgisayarınıza klonlayın veya indirin. Daha sonra, HTML dosyasını bir tarayıcıda açarak uygulamayı görüntüleyebilirsiniz.&lt;/p&gt; &#xA;&lt;h2&gt;Örnek Kod Parçası&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.addEventListener(&#39;keydown&#39;, function (event) {&#xA;    if (event.key === &#39;Tab&#39;) {&#xA;        const noButton = document.querySelector(&#39;.btnNo&#39;); // noButton değişkenini tanımla&#xA;        if (!noButton.dataset.tabPressed) { // Eğer tab daha önce basılmadıysa devam et&#xA;            noButton.dataset.tabPressed = true; // tab basıldı olarak işaretle&#xA;            noButton.style.animation = &#39;explode 0.5s forwards&#39;; // Patlama animasyonunu etkinleştir&#xA;            setTimeout(() =&amp;gt; noButton.style.display = &#39;none&#39;, 500); // Butonu 0.5 saniye sonra gizle&#xA;            event.preventDefault(); // Tab tuşunun varsayılan davranışını engelle&#xA;&#xA;            // &#34;title&#34; içindeki span öğelerini gizle&#xA;            const titleSpans = document.querySelectorAll(&#39;.title span&#39;);&#xA;            titleSpans.forEach(span =&amp;gt; {&#xA;                span.style.opacity = &#39;0&#39;;&#xA;            });&#xA;&#xA;            // &#34;title&#34; içindeki &#34;h1&#34; öğesini göster&#xA;            const titleH1 = document.querySelector(&#39;.title h1&#39;);&#xA;            titleH1.style.opacity = &#39;1&#39;;&#xA;&#xA;            // &#34;title&#34; içindeki &#34;h1&#34; öğesinin metnini değiştir&#xA;            titleH1.textContent = &#39;Hile yapmak yok :)&#39;;&#xA;&#xA;            // Orijinal başlığa geri dön&#xA;            setTimeout(() =&amp;gt; {&#xA;                titleH1.textContent = &#39;Çıkalım mı artık?&#39;;&#xA;            }, 2000);&#xA;        }&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🤝 Katkıda Bulunma&lt;/h2&gt; &#xA;&lt;p&gt;Katkılarınız benim için önemli. Herhangi bir hata bulursanız veya önerileriniz varsa, lütfen benimle iletişime geçin.&lt;/p&gt; &#xA;&lt;h2&gt;Lisans&lt;/h2&gt; &#xA;&lt;p&gt;Bu proje MIT Lisansı altında lisanslanmıştır. Daha fazla bilgi için &lt;a href=&#34;https://raw.githubusercontent.com/randyisback/ask-for-a-date/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; dosyasına bakın. İyi çalışmalar dilerim ^^&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.instagram.com/kodlama.dili/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Instagram-%23E4405F.svg?&amp;amp;style=flat-square&amp;amp;logo=instagram&amp;amp;logoColor=white&#34; alt=&#34;Instagram&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sxei/chrome-plugin-demo</title>
    <updated>2024-03-17T01:32:12Z</updated>
    <id>tag:github.com,2024-03-17:/sxei/chrome-plugin-demo</id>
    <link href="https://github.com/sxei/chrome-plugin-demo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;《Chrome插件开发全攻略》配套完整Demo，欢迎clone体验&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;写在前面&lt;/h1&gt; &#xA;&lt;p&gt;我花了将近一个多月的时间断断续续写下这篇博文，并精心写下完整demo，所以转载务必保留 &lt;a href=&#34;http://blog.haoji.me/chrome-plugin-develop.html&#34;&gt;http://blog.haoji.me/chrome-plugin-develop.html&lt;/a&gt; 。本文所有涉及到的大部分代码均在这个demo里面：&lt;a href=&#34;https://github.com/sxei/chrome-plugin-demo&#34;&gt;https://github.com/sxei/chrome-plugin-demo&lt;/a&gt; ，大家可以直接下载下来运行。&lt;/p&gt; &#xA;&lt;p&gt;另外，本文图片较多，请耐心等待加载完毕。&lt;/p&gt; &#xA;&lt;p&gt;本文目录：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201707/20170710_222547_735_9922.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;demo部分截图：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201707/20170710_223150_516_6129.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;鉴于有很多网友有交流学习Chrome插件的诉求，所以最近建了一个插件开发交流群，仅仅是为了提供一个互相交流学习的平台：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.alicdn.com/tfs/TB1rvUrJpY7gK0jSZKzXXaikpXa-1582-740.png&#34; alt=&#34;W791xH370&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;仓库说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;full-chrome-plugin-demo&lt;/code&gt;：大部分demo代码都在这个仓库；&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;simple-chrome-plugin-demo&lt;/code&gt;：最精简的Chrome仓库模板，当需要快速写一个简单仓库时可以基于这个模板；&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;page-action-demo&lt;/code&gt;：关于&lt;code&gt;page-action&lt;/code&gt;部分的demo代码，由于这部分代码和&lt;code&gt;full-chrome-plugin-demo&lt;/code&gt;冲突，所以单独拿出来；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;前言&lt;/h1&gt; &#xA;&lt;h2&gt;什么是Chrome插件&lt;/h2&gt; &#xA;&lt;p&gt;严格来讲，我们正在说的东西应该叫Chrome扩展(&lt;code&gt;Chrome Extension&lt;/code&gt;)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。&lt;/p&gt; &#xA;&lt;p&gt;Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个&lt;a href=&#34;https://developer.chrome.com/extensions/crx&#34;&gt;.crx&lt;/a&gt;后缀的压缩包.&lt;/p&gt; &#xA;&lt;p&gt;个人猜测&lt;code&gt;crx&lt;/code&gt;可能是&lt;code&gt;Chrome Extension&lt;/code&gt;如下3个字母的简写：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170619_114836_364_3616.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170626_112802_406_9027.png&#34; alt=&#34;360抢票王插件dll截图&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;学习Chrome插件开发有什么意义&lt;/h2&gt; &#xA;&lt;p&gt;增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。&lt;/p&gt; &#xA;&lt;p&gt;Chrome插件提供了很多实用API供我们使用，包括但不限于：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;书签控制；&lt;/li&gt; &#xA; &lt;li&gt;下载控制；&lt;/li&gt; &#xA; &lt;li&gt;窗口控制；&lt;/li&gt; &#xA; &lt;li&gt;标签控制；&lt;/li&gt; &#xA; &lt;li&gt;网络请求控制，各类事件监听；&lt;/li&gt; &#xA; &lt;li&gt;自定义原生菜单；&lt;/li&gt; &#xA; &lt;li&gt;完善的通信机制；&lt;/li&gt; &#xA; &lt;li&gt;等等；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;为什么是Chrome插件而不是Firefox插件&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Chrome占有率更高，更多人用；&lt;/li&gt; &#xA; &lt;li&gt;开发更简单；&lt;/li&gt; &#xA; &lt;li&gt;应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等；&lt;/li&gt; &#xA; &lt;li&gt;除此之外，Firefox浏览器也对Chrome插件的运行提供了一定的支持；&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;开发与调试&lt;/h1&gt; &#xA;&lt;p&gt;Chrome插件没有严格的项目结构要求，只要保证本目录有一个&lt;code&gt;manifest.json&lt;/code&gt;即可，也不需要专门的IDE，普通的web开发工具即可。&lt;/p&gt; &#xA;&lt;p&gt;从右上角菜单-&amp;gt;更多工具-&amp;gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 &lt;a href=&#34;chrome://extensions/&#34;&gt;chrome://extensions&lt;/a&gt; 访问。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170620_195047_992_5668.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;勾选&lt;code&gt;开发者模式&lt;/code&gt;即可以文件夹的形式直接加载插件，否则只能安装&lt;code&gt;.crx&lt;/code&gt;格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把&lt;code&gt;crx&lt;/code&gt;文件解压，然后通过开发者模式直接加载。&lt;/p&gt; &#xA;&lt;p&gt;开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下&lt;code&gt;Ctrl+R&lt;/code&gt;即可，以防万一最好还把页面刷新一下。&lt;/p&gt; &#xA;&lt;h1&gt;核心介绍&lt;/h1&gt; &#xA;&lt;h2&gt;manifest.json&lt;/h2&gt; &#xA;&lt;p&gt;这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，&lt;code&gt;manifest_version&lt;/code&gt;、&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;version&lt;/code&gt;3个是必不可少的，&lt;code&gt;description&lt;/code&gt;和&lt;code&gt;icons&lt;/code&gt;是推荐的。&lt;/p&gt; &#xA;&lt;p&gt;下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳&lt;a href=&#34;https://developer.chrome.com/extensions/manifest&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;// 清单文件的版本，这个必须写，而且必须是2&#xA;&#x9;&#34;manifest_version&#34;: 2,&#xA;&#x9;// 插件的名称&#xA;&#x9;&#34;name&#34;: &#34;demo&#34;,&#xA;&#x9;// 插件的版本&#xA;&#x9;&#34;version&#34;: &#34;1.0.0&#34;,&#xA;&#x9;// 插件描述&#xA;&#x9;&#34;description&#34;: &#34;简单的Chrome扩展demo&#34;,&#xA;&#x9;// 图标，一般偷懒全部用一个尺寸的也没问题&#xA;&#x9;&#34;icons&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;&#34;16&#34;: &#34;img/icon.png&#34;,&#xA;&#x9;&#x9;&#34;48&#34;: &#34;img/icon.png&#34;,&#xA;&#x9;&#x9;&#34;128&#34;: &#34;img/icon.png&#34;&#xA;&#x9;},&#xA;&#x9;// 会一直常驻的后台JS或后台页面&#xA;&#x9;&#34;background&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;// 2种指定方式，如果指定JS，那么会自动生成一个背景页&#xA;&#x9;&#x9;&#34;page&#34;: &#34;background.html&#34;&#xA;&#x9;&#x9;//&#34;scripts&#34;: [&#34;js/background.js&#34;]&#xA;&#x9;},&#xA;&#x9;// 浏览器右上角图标设置，browser_action、page_action、app必须三选一&#xA;&#x9;&#34;browser_action&#34;: &#xA;&#x9;{&#xA;&#x9;&#x9;&#34;default_icon&#34;: &#34;img/icon.png&#34;,&#xA;&#x9;&#x9;// 图标悬停时的标题，可选&#xA;&#x9;&#x9;&#34;default_title&#34;: &#34;这是一个示例Chrome插件&#34;,&#xA;&#x9;&#x9;&#34;default_popup&#34;: &#34;popup.html&#34;&#xA;&#x9;},&#xA;&#x9;// 当某些特定页面打开才显示的图标&#xA;&#x9;/*&#34;page_action&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;&#34;default_icon&#34;: &#34;img/icon.png&#34;,&#xA;&#x9;&#x9;&#34;default_title&#34;: &#34;我是pageAction&#34;,&#xA;&#x9;&#x9;&#34;default_popup&#34;: &#34;popup.html&#34;&#xA;&#x9;},*/&#xA;&#x9;// 需要直接注入页面的JS&#xA;&#x9;&#34;content_scripts&#34;: &#xA;&#x9;[&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//&#34;matches&#34;: [&#34;http://*/*&#34;, &#34;https://*/*&#34;],&#xA;&#x9;&#x9;&#x9;// &#34;&amp;lt;all_urls&amp;gt;&#34; 表示匹配所有地址&#xA;&#x9;&#x9;&#x9;&#34;matches&#34;: [&#34;&amp;lt;all_urls&amp;gt;&#34;],&#xA;&#x9;&#x9;&#x9;// 多个JS按顺序注入&#xA;&#x9;&#x9;&#x9;&#34;js&#34;: [&#34;js/jquery-1.8.3.js&#34;, &#34;js/content-script.js&#34;],&#xA;&#x9;&#x9;&#x9;// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式&#xA;&#x9;&#x9;&#x9;&#34;css&#34;: [&#34;css/custom.css&#34;],&#xA;&#x9;&#x9;&#x9;// 代码注入的时间，可选值： &#34;document_start&#34;, &#34;document_end&#34;, or &#34;document_idle&#34;，最后一个表示页面空闲时，默认document_idle&#xA;&#x9;&#x9;&#x9;&#34;run_at&#34;: &#34;document_start&#34;&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;// 这里仅仅是为了演示content-script可以配置多个规则&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#34;matches&#34;: [&#34;*://*/*.png&#34;, &#34;*://*/*.jpg&#34;, &#34;*://*/*.gif&#34;, &#34;*://*/*.bmp&#34;],&#xA;&#x9;&#x9;&#x9;&#34;js&#34;: [&#34;js/show-image-content-size.js&#34;]&#xA;&#x9;&#x9;}&#xA;&#x9;],&#xA;&#x9;// 权限申请&#xA;&#x9;&#34;permissions&#34;:&#xA;&#x9;[&#xA;&#x9;&#x9;&#34;contextMenus&#34;, // 右键菜单&#xA;&#x9;&#x9;&#34;tabs&#34;, // 标签&#xA;&#x9;&#x9;&#34;notifications&#34;, // 通知&#xA;&#x9;&#x9;&#34;webRequest&#34;, // web请求&#xA;&#x9;&#x9;&#34;webRequestBlocking&#34;,&#xA;&#x9;&#x9;&#34;storage&#34;, // 插件本地存储&#xA;&#x9;&#x9;&#34;http://*/*&#34;, // 可以通过executeScript或者insertCSS访问的网站&#xA;&#x9;&#x9;&#34;https://*/*&#34; // 可以通过executeScript或者insertCSS访问的网站&#xA;&#x9;],&#xA;&#x9;// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的&#xA;&#x9;&#34;web_accessible_resources&#34;: [&#34;js/inject.js&#34;],&#xA;&#x9;// 插件主页，这个很重要，不要浪费了这个免费广告位&#xA;&#x9;&#34;homepage_url&#34;: &#34;https://www.baidu.com&#34;,&#xA;&#x9;// 覆盖浏览器默认页面&#xA;&#x9;&#34;chrome_url_overrides&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;// 覆盖浏览器默认的新标签页&#xA;&#x9;&#x9;&#34;newtab&#34;: &#34;newtab.html&#34;&#xA;&#x9;},&#xA;&#x9;// Chrome40以前的插件配置页写法&#xA;&#x9;&#34;options_page&#34;: &#34;options.html&#34;,&#xA;&#x9;// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个&#xA;&#x9;&#34;options_ui&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;&#34;page&#34;: &#34;options.html&#34;,&#xA;&#x9;&#x9;// 添加一些默认的样式，推荐使用&#xA;&#x9;&#x9;&#34;chrome_style&#34;: true&#xA;&#x9;},&#xA;&#x9;// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字&#xA;&#x9;&#34;omnibox&#34;: { &#34;keyword&#34; : &#34;go&#34; },&#xA;&#x9;// 默认语言&#xA;&#x9;&#34;default_locale&#34;: &#34;zh_CN&#34;,&#xA;&#x9;// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件&#xA;&#x9;&#34;devtools_page&#34;: &#34;devtools.html&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;content-scripts&lt;/h2&gt; &#xA;&lt;p&gt;所谓&lt;a href=&#34;https://developer.chrome.com/extensions/content_scripts&#34;&gt;content-scripts&lt;/a&gt;，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助&lt;code&gt;content-scripts&lt;/code&gt;我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。&lt;/p&gt; &#xA;&lt;p&gt;示例配置：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;// 需要直接注入页面的JS&#xA;&#x9;&#34;content_scripts&#34;: &#xA;&#x9;[&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//&#34;matches&#34;: [&#34;http://*/*&#34;, &#34;https://*/*&#34;],&#xA;&#x9;&#x9;&#x9;// &#34;&amp;lt;all_urls&amp;gt;&#34; 表示匹配所有地址&#xA;&#x9;&#x9;&#x9;&#34;matches&#34;: [&#34;&amp;lt;all_urls&amp;gt;&#34;],&#xA;&#x9;&#x9;&#x9;// 多个JS按顺序注入&#xA;&#x9;&#x9;&#x9;&#34;js&#34;: [&#34;js/jquery-1.8.3.js&#34;, &#34;js/content-script.js&#34;],&#xA;&#x9;&#x9;&#x9;// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式&#xA;&#x9;&#x9;&#x9;&#34;css&#34;: [&#34;css/custom.css&#34;],&#xA;&#x9;&#x9;&#x9;// 代码注入的时间，可选值： &#34;document_start&#34;, &#34;document_end&#34;, or &#34;document_idle&#34;，最后一个表示页面空闲时，默认document_idle&#xA;&#x9;&#x9;&#x9;&#34;run_at&#34;: &#34;document_start&#34;&#xA;&#x9;&#x9;}&#xA;&#x9;],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;特别注意，如果没有主动指定&lt;code&gt;run_at&lt;/code&gt;为&lt;code&gt;document_start&lt;/code&gt;（默认为&lt;code&gt;document_idle&lt;/code&gt;），下面这种代码是不会生效的：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function()&#xA;{&#xA;&#x9;console.log(&#39;我被执行了！&#39;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;content-scripts&lt;/code&gt;和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过&lt;code&gt;injected js&lt;/code&gt;来实现。&lt;code&gt;content-scripts&lt;/code&gt;不能访问绝大部分&lt;code&gt;chrome.xxx.api&lt;/code&gt;，除了下面这4种：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)&lt;/li&gt; &#xA; &lt;li&gt;chrome.i18n&lt;/li&gt; &#xA; &lt;li&gt;chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)&lt;/li&gt; &#xA; &lt;li&gt;chrome.storage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。&lt;/p&gt; &#xA;&lt;p&gt;好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。&lt;/p&gt; &#xA;&lt;h2&gt;background&lt;/h2&gt; &#xA;&lt;p&gt;后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。&lt;/p&gt; &#xA;&lt;p&gt;background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置&lt;code&gt;CORS&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;经过测试，其实不止是background，所有的直接通过&lt;code&gt;chrome-extension://id/xx.html&lt;/code&gt;这种方式打开的网页都可以无限制跨域。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;配置中，&lt;code&gt;background&lt;/code&gt;可以通过&lt;code&gt;page&lt;/code&gt;指定一张网页，也可以通过&lt;code&gt;scripts&lt;/code&gt;直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;// 会一直常驻的后台JS或后台页面&#xA;&#x9;&#34;background&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;// 2种指定方式，如果指定JS，那么会自动生成一个背景页&#xA;&#x9;&#x9;&#34;page&#34;: &#34;background.html&#34;&#xA;&#x9;&#x9;//&#34;scripts&#34;: [&#34;js/background.js&#34;]&#xA;&#x9;},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;需要特别说明的是，虽然你可以通过&lt;code&gt;chrome-extension://xxx/background.html&lt;/code&gt;直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个&lt;code&gt;background.html&lt;/code&gt;，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。&lt;/p&gt; &#xA;&lt;h2&gt;event-pages&lt;/h2&gt; &#xA;&lt;p&gt;这里顺带介绍一下&lt;a href=&#34;https://developer.chrome.com/extensions/event_pages&#34;&gt;event-pages&lt;/a&gt;，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个&lt;code&gt;event-pages&lt;/code&gt;，在配置文件上，它与background的唯一区别就是多了一个&lt;code&gt;persistent&lt;/code&gt;参数：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;background&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;&#34;scripts&#34;: [&#34;event-page.js&#34;],&#xA;&#x9;&#x9;&#34;persistent&#34;: false&#xA;&#x9;},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。&lt;/p&gt; &#xA;&lt;p&gt;除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。&lt;/p&gt; &#xA;&lt;h2&gt;popup&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;popup&lt;/code&gt;是点击&lt;code&gt;browser_action&lt;/code&gt;或者&lt;code&gt;page_action&lt;/code&gt;图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170619_161102_335_9254.png&#34; alt=&#34;博客园网摘插件popup效果&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;popup&lt;/code&gt;可以包含任意你想要的HTML内容，并且会自适应大小。可以通过&lt;code&gt;default_popup&lt;/code&gt;字段来指定popup页面，也可以调用&lt;code&gt;setPopup()&lt;/code&gt;方法。&lt;/p&gt; &#xA;&lt;p&gt;配置方式：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;browser_action&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;&#34;default_icon&#34;: &#34;img/icon.png&#34;,&#xA;&#x9;&#x9;// 图标悬停时的标题，可选&#xA;&#x9;&#x9;&#34;default_title&#34;: &#34;这是一个示例Chrome插件&#34;,&#xA;&#x9;&#x9;&#34;default_popup&#34;: &#34;popup.html&#34;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_172243_007_2793.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。&lt;/p&gt; &#xA;&lt;p&gt;在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过&lt;code&gt;chrome.extension.getBackgroundPage()&lt;/code&gt;获取background的window对象。&lt;/p&gt; &#xA;&lt;h2&gt;injected-script&lt;/h2&gt; &#xA;&lt;p&gt;这里的&lt;code&gt;injected-script&lt;/code&gt;是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？&lt;/p&gt; &#xA;&lt;p&gt;这是因为&lt;code&gt;content-script&lt;/code&gt;有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用&lt;code&gt;content-script&lt;/code&gt;中的代码（包括直接写&lt;code&gt;onclick&lt;/code&gt;和&lt;code&gt;addEventListener&lt;/code&gt;2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。&lt;/p&gt; &#xA;&lt;p&gt;在&lt;code&gt;content-script&lt;/code&gt;中通过DOM方式向页面注入&lt;code&gt;inject-script&lt;/code&gt;代码示例：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 向页面注入JS&#xA;function injectCustomJs(jsPath)&#xA;{&#xA;&#x9;jsPath = jsPath || &#39;js/inject.js&#39;;&#xA;&#x9;var temp = document.createElement(&#39;script&#39;);&#xA;&#x9;temp.setAttribute(&#39;type&#39;, &#39;text/javascript&#39;);&#xA;&#x9;// 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js&#xA;&#x9;temp.src = chrome.extension.getURL(jsPath);&#xA;&#x9;temp.onload = function()&#xA;&#x9;{&#xA;&#x9;&#x9;// 放在页面不好看，执行完后移除掉&#xA;&#x9;&#x9;this.parentNode.removeChild(this);&#xA;&#x9;};&#xA;&#x9;document.head.appendChild(temp);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;你以为这样就行了？执行一下你会看到如下报错：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Denying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的&#xA;&#x9;&#34;web_accessible_resources&#34;: [&#34;js/inject.js&#34;],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;至于&lt;code&gt;inject-script&lt;/code&gt;如何调用&lt;code&gt;content-script&lt;/code&gt;中的代码，后面我会在专门的一个消息通信章节详细介绍。&lt;/p&gt; &#xA;&lt;h2&gt;homepage_url&lt;/h2&gt; &#xA;&lt;p&gt;开发者或者插件主页设置，一般会在如下2个地方显示：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_105821_586_0442.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_105907_256_9087.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Chrome插件的8种展示形式&lt;/h1&gt; &#xA;&lt;h2&gt;browserAction(浏览器右上角)&lt;/h2&gt; &#xA;&lt;p&gt;通过配置&lt;code&gt;browser_action&lt;/code&gt;可以在浏览器的右上角增加一个图标，一个&lt;code&gt;browser_action&lt;/code&gt;可以拥有一个图标，一个&lt;code&gt;tooltip&lt;/code&gt;，一个&lt;code&gt;badge&lt;/code&gt;和一个&lt;code&gt;popup&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;示例配置如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&#34;browser_action&#34;:&#xA;{&#xA;&#x9;&#34;default_icon&#34;: &#34;img/icon.png&#34;,&#xA;&#x9;&#34;default_title&#34;: &#34;这是一个示例Chrome插件&#34;,&#xA;&#x9;&#34;default_popup&#34;: &#34;popup.html&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;图标&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;browser_action&lt;/code&gt;图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中&lt;code&gt;default_icon&lt;/code&gt;字段配置，也可以调用setIcon()方法。&lt;/p&gt; &#xA;&lt;h3&gt;tooltip&lt;/h3&gt; &#xA;&lt;p&gt;修改&lt;code&gt;browser_action&lt;/code&gt;的manifest中&lt;code&gt;default_title&lt;/code&gt;字段，或者调用&lt;code&gt;setTitle()&lt;/code&gt;方法。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_170829_477_1329.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;badge&lt;/h3&gt; &#xA;&lt;p&gt;所谓&lt;code&gt;badge&lt;/code&gt;就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用&lt;code&gt;setBadgeText()&lt;/code&gt;和&lt;code&gt;setBadgeBackgroundColor()&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.browserAction.setBadgeText({text: &#39;new&#39;});&#xA;chrome.browserAction.setBadgeBackgroundColor({color: [255, 0, 0, 255]});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;效果：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_171447_912_1165.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;pageAction(地址栏右侧)&lt;/h2&gt; &#xA;&lt;p&gt;所谓&lt;code&gt;pageAction&lt;/code&gt;，指的是只有当某些特定页面打开才显示的图标，它和&lt;code&gt;browserAction&lt;/code&gt;最大的区别是一个始终都显示，一个只在特定情况才显示。&lt;/p&gt; &#xA;&lt;p&gt;需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_103311_849_4399.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_104038_208_9352.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;调整之后的&lt;code&gt;pageAction&lt;/code&gt;我们可以简单地把它看成是可以置灰的&lt;code&gt;browserAction&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;chrome.pageAction.show(tabId) 显示图标；&lt;/li&gt; &#xA; &lt;li&gt;chrome.pageAction.hide(tabId) 隐藏图标；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;示例(只有打开百度才显示图标)：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// manifest.json&#xA;{&#xA;&#x9;&#34;page_action&#34;:&#xA;&#x9;{&#xA;&#x9;&#x9;&#34;default_icon&#34;: &#34;img/icon.png&#34;,&#xA;&#x9;&#x9;&#34;default_title&#34;: &#34;我是pageAction&#34;,&#xA;&#x9;&#x9;&#34;default_popup&#34;: &#34;popup.html&#34;&#xA;&#x9;},&#xA;&#x9;&#34;permissions&#34;: [&#34;declarativeContent&#34;]&#xA;}&#xA;&#xA;// background.js&#xA;chrome.runtime.onInstalled.addListener(function(){&#xA;&#x9;chrome.declarativeContent.onPageChanged.removeRules(undefined, function(){&#xA;&#x9;&#x9;chrome.declarativeContent.onPageChanged.addRules([&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;conditions: [&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// 只有打开百度才显示pageAction&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;new chrome.declarativeContent.PageStateMatcher({pageUrl: {urlContains: &#39;baidu.com&#39;}})&#xA;&#x9;&#x9;&#x9;&#x9;],&#xA;&#x9;&#x9;&#x9;&#x9;actions: [new chrome.declarativeContent.ShowPageAction()]&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;]);&#xA;&#x9;});&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;效果图：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_174018_541_0451.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;右键菜单&lt;/h2&gt; &#xA;&lt;p&gt;通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过&lt;code&gt;chrome.contextMenus&lt;/code&gt;API实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_151134_967_0243.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;最简单的右键菜单示例&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// manifest.json&#xA;{&#34;permissions&#34;: [&#34;contextMenus&#34;]}&#xA;&#xA;// background.js&#xA;chrome.contextMenus.create({&#xA;&#x9;title: &#34;测试右键菜单&#34;,&#xA;&#x9;onclick: function(){alert(&#39;您点击了右键菜单！&#39;);}&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;效果：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_145957_183_0527.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;添加右键百度搜索&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// manifest.json&#xA;{&#34;permissions&#34;: [&#34;contextMenus&#34;， &#34;tabs&#34;]}&#xA;&#xA;// background.js&#xA;chrome.contextMenus.create({&#xA;&#x9;title: &#39;使用度娘搜索：%s&#39;, // %s表示选中的文字&#xA;&#x9;contexts: [&#39;selection&#39;], // 只有当选中文字时才会出现此右键菜单&#xA;&#x9;onclick: function(params)&#xA;&#x9;{&#xA;&#x9;&#x9;// 注意不能使用location.href，因为location是属于background的window对象&#xA;&#x9;&#x9;chrome.tabs.create({url: &#39;https://www.baidu.com/s?ie=utf-8&amp;amp;wd=&#39; + encodeURI(params.selectionText)});&#xA;&#x9;}&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;效果如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_160358_202_7248.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;语法说明&lt;/h3&gt; &#xA;&lt;p&gt;这里只是简单列举一些常用的，完整API参见：&lt;a href=&#34;https://developer.chrome.com/extensions/contextMenus&#34;&gt;https://developer.chrome.com/extensions/contextMenus&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.contextMenus.create({&#xA;&#x9;type: &#39;normal&#39;， // 类型，可选：[&#34;normal&#34;, &#34;checkbox&#34;, &#34;radio&#34;, &#34;separator&#34;]，默认 normal&#xA;&#x9;title: &#39;菜单的名字&#39;, // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本&#xA;&#x9;contexts: [&#39;page&#39;], // 上下文环境，可选：[&#34;all&#34;, &#34;page&#34;, &#34;frame&#34;, &#34;selection&#34;, &#34;link&#34;, &#34;editable&#34;, &#34;image&#34;, &#34;video&#34;, &#34;audio&#34;]，默认page&#xA;&#x9;onclick: function(){}, // 单击时触发的方法&#xA;&#x9;parentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单&#xA;&#x9;documentUrlPatterns: &#39;https://*.baidu.com/*&#39; // 只在某些页面显示此右键菜单&#xA;});&#xA;// 删除某一个菜单项&#xA;chrome.contextMenus.remove(menuItemId)；&#xA;// 删除所有自定义右键菜单&#xA;chrome.contextMenus.removeAll();&#xA;// 更新某一个菜单项&#xA;chrome.contextMenus.update(menuItemId, updateProperties);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;override(覆盖特定页面)&lt;/h2&gt; &#xA;&lt;p&gt;使用&lt;code&gt;override&lt;/code&gt;页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。&lt;/p&gt; &#xA;&lt;p&gt;扩展可以替代如下页面：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 &lt;a href=&#34;chrome://history&#34;&gt;chrome://history&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 &lt;a href=&#34;chrome://newtab&#34;&gt;chrome://newtab&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;书签：浏览器的书签，或者直接输入 &lt;a href=&#34;chrome://bookmarks&#34;&gt;chrome://bookmarks&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;注意：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;一个扩展只能替代一个页面；&lt;/li&gt; &#xA; &lt;li&gt;不能替代隐身窗口的新标签页；&lt;/li&gt; &#xA; &lt;li&gt;网页必须设置title，否则用户可能会看到网页的URL，造成困扰；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;下面的截图是默认的新标签页和被扩展替换掉的新标签页。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_180326_487_3396.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;代码（注意，一个插件只能替代一个默认页，以下仅为演示）：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#34;chrome_url_overrides&#34;:&#xA;{&#xA;&#x9;&#34;newtab&#34;: &#34;newtab.html&#34;,&#xA;&#x9;&#34;history&#34;: &#34;history.html&#34;,&#xA;&#x9;&#34;bookmarks&#34;: &#34;bookmarks.html&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;devtools(开发者工具)&lt;/h2&gt; &#xA;&lt;h3&gt;预热&lt;/h3&gt; &#xA;&lt;p&gt;使用过vue的应该见过这种类型的插件：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170605_181456_375_7033.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;自定义一个和多个和&lt;code&gt;Elements&lt;/code&gt;、&lt;code&gt;Console&lt;/code&gt;、&lt;code&gt;Sources&lt;/code&gt;等同级别的面板；&lt;/li&gt; &#xA; &lt;li&gt;自定义侧边栏(sidebar)，目前只能自定义&lt;code&gt;Elements&lt;/code&gt;面板的侧边栏；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;先来看2张简单的demo截图，自定义面板（判断当前页面是否使用了jQuery）：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170613_220126_669_2411.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;自定义侧边栏（获取当前页面所有图片）：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170605_175952_228_8829.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;devtools扩展介绍&lt;/h3&gt; &#xA;&lt;p&gt;主页：&lt;a href=&#34;https://developer.chrome.com/extensions/devtools&#34;&gt;https://developer.chrome.com/extensions/devtools&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;来一张官方图片：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170606_170623_349_6923.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的&lt;code&gt;DevTools API&lt;/code&gt;以及有限的扩展API，这组特有的&lt;code&gt;DevTools API&lt;/code&gt;只有devtools页面才可以访问，background都无权访问，这些API包括：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;chrome.devtools.panels&lt;/code&gt;：面板相关；&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chrome.devtools.inspectedWindow&lt;/code&gt;：获取被审查窗口的有关信息；&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chrome.devtools.network&lt;/code&gt;：获取有关网络请求的信息；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;大部分扩展API都无法直接被&lt;code&gt;DevTools&lt;/code&gt;页面调用，但它可以像&lt;code&gt;content-script&lt;/code&gt;一样直接调用&lt;code&gt;chrome.extension&lt;/code&gt;和&lt;code&gt;chrome.runtime&lt;/code&gt;API，同时它也可以像&lt;code&gt;content-script&lt;/code&gt;一样使用Message交互的方式与background页面进行通信。&lt;/p&gt; &#xA;&lt;h3&gt;实例：创建一个devtools扩展&lt;/h3&gt; &#xA;&lt;p&gt;首先，要针对开发者工具开发插件，需要在清单文件声明如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;// 只能指向一个HTML文件，不能是JS文件&#xA;&#x9;&#34;devtools_page&#34;: &#34;devtools.html&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;这个&lt;code&gt;devtools.html&lt;/code&gt;里面一般什么都没有，就引入一个js：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&#x9;&amp;lt;script type=&#34;text/javascript&#34; src=&#34;js/devtools.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;可以看出来，其实真正代码是&lt;code&gt;devtools.js&lt;/code&gt;，html文件是“多余”的，所以这里觉得有点坑，&lt;code&gt;devtools_page&lt;/code&gt;干嘛不允许直接指定JS呢？&lt;/p&gt; &#xA;&lt;p&gt;再来看devtools.js的代码：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 创建自定义面板，同一个插件可以创建多个自定义面板&#xA;// 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调&#xA;chrome.devtools.panels.create(&#39;MyPanel&#39;, &#39;img/icon.png&#39;, &#39;mypanel.html&#39;, function(panel)&#xA;{&#xA;&#x9;console.log(&#39;自定义面板创建成功！&#39;); // 注意这个log一般看不到&#xA;});&#xA;&#xA;// 创建自定义侧边栏&#xA;chrome.devtools.panels.elements.createSidebarPane(&#34;Images&#34;, function(sidebar)&#xA;{&#xA;&#x9;// sidebar.setPage(&#39;../sidebar.html&#39;); // 指定加载某个页面&#xA;&#x9;sidebar.setExpression(&#39;document.querySelectorAll(&#34;img&#34;)&#39;, &#39;All Images&#39;); // 通过表达式来指定&#xA;&#x9;//sidebar.setObject({aaa: 111, bbb: &#39;Hello World!&#39;}); // 直接设置显示某个对象&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;setPage时的效果：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170613_194023_184_1728.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;以下截图示例的代码：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170613_220345_133_1766.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 检测jQuery&#xA;document.getElementById(&#39;check_jquery&#39;).addEventListener(&#39;click&#39;, function()&#xA;{&#xA;&#x9;// 访问被检查的页面DOM需要使用inspectedWindow&#xA;&#x9;// 简单例子：检测被检查页面是否使用了jQuery&#xA;&#x9;chrome.devtools.inspectedWindow.eval(&#34;jQuery.fn.jquery&#34;, function(result, isException)&#xA;&#x9;{&#xA;&#x9;&#x9;var html = &#39;&#39;;&#xA;&#x9;&#x9;if (isException) html = &#39;当前页面没有使用jQuery。&#39;;&#xA;&#x9;&#x9;else html = &#39;当前页面使用了jQuery，版本为：&#39;+result;&#xA;&#x9;&#x9;alert(html);&#xA;&#x9;});&#xA;});&#xA;&#xA;// 打开某个资源&#xA;document.getElementById(&#39;open_resource&#39;).addEventListener(&#39;click&#39;, function()&#xA;{&#xA;&#x9;chrome.devtools.inspectedWindow.eval(&#34;window.location.href&#34;, function(result, isException)&#xA;&#x9;{&#xA;&#x9;&#x9;chrome.devtools.panels.openResource(result, 20, function()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;console.log(&#39;资源打开成功！&#39;);&#xA;&#x9;&#x9;});&#xA;&#x9;});&#xA;});&#xA;&#xA;// 审查元素&#xA;document.getElementById(&#39;test_inspect&#39;).addEventListener(&#39;click&#39;, function()&#xA;{&#xA;&#x9;chrome.devtools.inspectedWindow.eval(&#34;inspect(document.images[0])&#34;, function(result, isException){});&#xA;});&#xA;&#xA;// 获取所有资源&#xA;document.getElementById(&#39;get_all_resources&#39;).addEventListener(&#39;click&#39;, function()&#xA;{&#xA;&#x9;chrome.devtools.inspectedWindow.getResources(function(resources)&#xA;&#x9;{&#xA;&#x9;&#x9;alert(JSON.stringify(resources));&#xA;&#x9;});&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;调试技巧&lt;/h3&gt; &#xA;&lt;p&gt;修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下&lt;code&gt;Ctrl+R&lt;/code&gt;重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。&lt;/p&gt; &#xA;&lt;p&gt;由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 &lt;code&gt;chrome-extension://extid/devtools.html&#34;&lt;/code&gt;的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。&lt;/p&gt; &#xA;&lt;h2&gt;option(选项页)&lt;/h2&gt; &#xA;&lt;p&gt;所谓&lt;code&gt;options&lt;/code&gt;页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_170046_846_5529.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_115902_196_9130.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。&lt;/p&gt; &#xA;&lt;p&gt;我们先看老版的&lt;a href=&#34;https://developer.chrome.com/extensions/options&#34;&gt;options&lt;/a&gt;：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;// Chrome40以前的插件配置页写法&#xA;&#x9;&#34;options_page&#34;: &#34;options.html&#34;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个&lt;code&gt;选项&lt;/code&gt;按钮入口，点进去就是打开一个网页，没啥好讲的。&lt;/p&gt; &#xA;&lt;p&gt;效果:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_115705_433_5886.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;再来看新版的&lt;a href=&#34;https://developer.chrome.com/extensions/optionsV2&#34;&gt;optionsV2&lt;/a&gt;：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;options_ui&#34;:&#xA;&#x9;{&#xA;    &#x9;&#34;page&#34;: &#34;options.html&#34;,&#xA;&#x9;&#x9;// 添加一些默认的样式，推荐使用&#xA;    &#x9;&#34;chrome_style&#34;: true&#xA;&#x9;},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;options.html&lt;/code&gt;的代码我们没有任何改动，只是配置文件改了，之后效果如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_115809_750_1163.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;看起来是不是高大上了？&lt;/p&gt; &#xA;&lt;p&gt;几点注意：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式；&lt;/li&gt; &#xA; &lt;li&gt;新版options中不能使用alert；&lt;/li&gt; &#xA; &lt;li&gt;数据存储建议用chrome.storage，因为会随用户自动同步；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;omnibox&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;omnibox&lt;/code&gt;是向用户提供搜索建议的一种方式。先来看个&lt;code&gt;gif&lt;/code&gt;图以便了解一下这东西到底是个什么鬼：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_155455_980_5359.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。&lt;/p&gt; &#xA;&lt;p&gt;首先，配置文件如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字&#xA;&#x9;&#34;omnibox&#34;: { &#34;keyword&#34; : &#34;go&#34; },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;然后&lt;code&gt;background.js&lt;/code&gt;中注册监听事件：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// omnibox 演示&#xA;chrome.omnibox.onInputChanged.addListener((text, suggest) =&amp;gt; {&#xA;&#x9;console.log(&#39;inputChanged: &#39; + text);&#xA;&#x9;if(!text) return;&#xA;&#x9;if(text == &#39;美女&#39;) {&#xA;&#x9;&#x9;suggest([&#xA;&#x9;&#x9;&#x9;{content: &#39;中国&#39; + text, description: &#39;你要找“中国美女”吗？&#39;},&#xA;&#x9;&#x9;&#x9;{content: &#39;日本&#39; + text, description: &#39;你要找“日本美女”吗？&#39;},&#xA;&#x9;&#x9;&#x9;{content: &#39;泰国&#39; + text, description: &#39;你要找“泰国美女或人妖”吗？&#39;},&#xA;&#x9;&#x9;&#x9;{content: &#39;韩国&#39; + text, description: &#39;你要找“韩国美女”吗？&#39;}&#xA;&#x9;&#x9;]);&#xA;&#x9;}&#xA;&#x9;else if(text == &#39;微博&#39;) {&#xA;&#x9;&#x9;suggest([&#xA;&#x9;&#x9;&#x9;{content: &#39;新浪&#39; + text, description: &#39;新浪&#39; + text},&#xA;&#x9;&#x9;&#x9;{content: &#39;腾讯&#39; + text, description: &#39;腾讯&#39; + text},&#xA;&#x9;&#x9;&#x9;{content: &#39;搜狐&#39; + text, description: &#39;搜索&#39; + text},&#xA;&#x9;&#x9;]);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;suggest([&#xA;&#x9;&#x9;&#x9;{content: &#39;百度搜索 &#39; + text, description: &#39;百度搜索 &#39; + text},&#xA;&#x9;&#x9;&#x9;{content: &#39;谷歌搜索 &#39; + text, description: &#39;谷歌搜索 &#39; + text},&#xA;&#x9;&#x9;]);&#xA;&#x9;}&#xA;});&#xA;&#xA;// 当用户接收关键字建议时触发&#xA;chrome.omnibox.onInputEntered.addListener((text) =&amp;gt; {&#xA;    console.log(&#39;inputEntered: &#39; + text);&#xA;&#x9;if(!text) return;&#xA;&#x9;var href = &#39;&#39;;&#xA;    if(text.endsWith(&#39;美女&#39;)) href = &#39;http://image.baidu.com/search/index?tn=baiduimage&amp;amp;ie=utf-8&amp;amp;word=&#39; + text;&#xA;&#x9;else if(text.startsWith(&#39;百度搜索&#39;)) href = &#39;https://www.baidu.com/s?ie=UTF-8&amp;amp;wd=&#39; + text.replace(&#39;百度搜索 &#39;, &#39;&#39;);&#xA;&#x9;else if(text.startsWith(&#39;谷歌搜索&#39;)) href = &#39;https://www.google.com.tw/search?q=&#39; + text.replace(&#39;谷歌搜索 &#39;, &#39;&#39;);&#xA;&#x9;else href = &#39;https://www.baidu.com/s?ie=UTF-8&amp;amp;wd=&#39; + text;&#xA;&#x9;openUrlCurrentTab(href);&#xA;});&#xA;// 获取当前选项卡ID&#xA;function getCurrentTabId(callback)&#xA;{&#xA;&#x9;chrome.tabs.query({active: true, currentWindow: true}, function(tabs)&#xA;&#x9;{&#xA;&#x9;&#x9;if(callback) callback(tabs.length ? tabs[0].id: null);&#xA;&#x9;});&#xA;}&#xA;&#xA;// 当前标签打开某个链接&#xA;function openUrlCurrentTab(url)&#xA;{&#xA;&#x9;getCurrentTabId(tabId =&amp;gt; {&#xA;&#x9;&#x9;chrome.tabs.update(tabId, {url: url});&#xA;&#x9;})&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;桌面通知&lt;/h2&gt; &#xA;&lt;p&gt;Chrome提供了一个&lt;code&gt;chrome.notifications&lt;/code&gt;API以便插件推送桌面通知，暂未找到&lt;code&gt;chrome.notifications&lt;/code&gt;和HTML5自带的&lt;code&gt;Notification&lt;/code&gt;的显著区别及优势。&lt;/p&gt; &#xA;&lt;p&gt;在后台JS中，无论是使用&lt;code&gt;chrome.notifications&lt;/code&gt;还是&lt;code&gt;Notification&lt;/code&gt;都不需要申请权限（HTML5方式需要申请权限），直接使用即可。&lt;/p&gt; &#xA;&lt;p&gt;最简单的通知：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_193633_369_0274.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;代码：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.notifications.create(null, {&#xA;&#x9;type: &#39;basic&#39;,&#xA;&#x9;iconUrl: &#39;img/icon.png&#39;,&#xA;&#x9;title: &#39;这是标题&#39;,&#xA;&#x9;message: &#39;您刚才点击了自定义右键菜单！&#39;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;通知的样式可以很丰富：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201705/20170531_193836_583_4450.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;这个没有深入研究，有需要的可以去看官方文档。&lt;/p&gt; &#xA;&lt;h1&gt;5种类型的JS对比&lt;/h1&gt; &#xA;&lt;p&gt;Chrome插件的JS主要可以分为这5类：&lt;code&gt;injected script&lt;/code&gt;、&lt;code&gt;content-script&lt;/code&gt;、&lt;code&gt;popup js&lt;/code&gt;、&lt;code&gt;background js&lt;/code&gt;和&lt;code&gt;devtools js&lt;/code&gt;，&lt;/p&gt; &#xA;&lt;h2&gt;权限对比&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;JS种类&lt;/th&gt; &#xA;   &lt;th&gt;可访问的API&lt;/th&gt; &#xA;   &lt;th&gt;DOM访问情况&lt;/th&gt; &#xA;   &lt;th&gt;JS访问情况&lt;/th&gt; &#xA;   &lt;th&gt;直接跨域&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;injected script&lt;/td&gt; &#xA;   &lt;td&gt;和普通JS无任何差别，不能访问任何扩展API&lt;/td&gt; &#xA;   &lt;td&gt;可以访问&lt;/td&gt; &#xA;   &lt;td&gt;可以访问&lt;/td&gt; &#xA;   &lt;td&gt;不可以&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;content script&lt;/td&gt; &#xA;   &lt;td&gt;只能访问 extension、runtime等部分API&lt;/td&gt; &#xA;   &lt;td&gt;可以访问&lt;/td&gt; &#xA;   &lt;td&gt;不可以&lt;/td&gt; &#xA;   &lt;td&gt;不可以&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;popup js&lt;/td&gt; &#xA;   &lt;td&gt;可访问绝大部分API，除了devtools系列&lt;/td&gt; &#xA;   &lt;td&gt;不可直接访问&lt;/td&gt; &#xA;   &lt;td&gt;不可以&lt;/td&gt; &#xA;   &lt;td&gt;可以&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;background js&lt;/td&gt; &#xA;   &lt;td&gt;可访问绝大部分API，除了devtools系列&lt;/td&gt; &#xA;   &lt;td&gt;不可直接访问&lt;/td&gt; &#xA;   &lt;td&gt;不可以&lt;/td&gt; &#xA;   &lt;td&gt;可以&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;devtools js&lt;/td&gt; &#xA;   &lt;td&gt;只能访问 devtools、extension、runtime等部分API&lt;/td&gt; &#xA;   &lt;td&gt;可以&lt;/td&gt; &#xA;   &lt;td&gt;可以&lt;/td&gt; &#xA;   &lt;td&gt;不可以&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;调试方式对比&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;JS类型&lt;/th&gt; &#xA;   &lt;th&gt;调试方式&lt;/th&gt; &#xA;   &lt;th&gt;图片说明&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;injected script&lt;/td&gt; &#xA;   &lt;td&gt;直接普通的F12即可&lt;/td&gt; &#xA;   &lt;td&gt;懒得截图&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;content-script&lt;/td&gt; &#xA;   &lt;td&gt;打开Console,如图切换&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;http://image.liuxianan.com/201612/20161220_105526_629_8533.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;popup-js&lt;/td&gt; &#xA;   &lt;td&gt;popup页面右键审查元素&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;http://image.liuxianan.com/201612/20161220_105716_178_6900.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;background&lt;/td&gt; &#xA;   &lt;td&gt;插件管理页点击背景页即可&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;http://image.liuxianan.com/201612/20161220_105811_922_5621.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;devtools-js&lt;/td&gt; &#xA;   &lt;td&gt;暂未找到有效方法&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;消息通信&lt;/h1&gt; &#xA;&lt;p&gt;通信主页：&lt;a href=&#34;https://developer.chrome.com/extensions/messaging&#34;&gt;https://developer.chrome.com/extensions/messaging&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。&lt;/p&gt; &#xA;&lt;h2&gt;互相通信概览&lt;/h2&gt; &#xA;&lt;p&gt;注：&lt;code&gt;-&lt;/code&gt;表示不存在或者无意义，或者待验证。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;injected-script&lt;/th&gt; &#xA;   &lt;th&gt;content-script&lt;/th&gt; &#xA;   &lt;th&gt;popup-js&lt;/th&gt; &#xA;   &lt;th&gt;background-js&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;injected-script&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;window.postMessage&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;content-script&lt;/td&gt; &#xA;   &lt;td&gt;window.postMessage&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;chrome.runtime.sendMessage chrome.runtime.connect&lt;/td&gt; &#xA;   &lt;td&gt;chrome.runtime.sendMessage chrome.runtime.connect&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;popup-js&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;chrome.tabs.sendMessage chrome.tabs.connect&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;chrome.extension. getBackgroundPage()&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;background-js&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;chrome.tabs.sendMessage chrome.tabs.connect&lt;/td&gt; &#xA;   &lt;td&gt;chrome.extension.getViews&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;devtools-js&lt;/td&gt; &#xA;   &lt;td&gt;chrome.devtools. inspectedWindow.eval&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;chrome.runtime.sendMessage&lt;/td&gt; &#xA;   &lt;td&gt;chrome.runtime.sendMessage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;通信详细介绍&lt;/h2&gt; &#xA;&lt;h3&gt;popup和background&lt;/h3&gt; &#xA;&lt;p&gt;popup可以直接调用background中的JS方法，也可以直接访问background的DOM：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// background.js&#xA;function test()&#xA;{&#xA;&#x9;alert(&#39;我是background！&#39;);&#xA;}&#xA;&#xA;// popup.js&#xA;var bg = chrome.extension.getBackgroundPage();&#xA;bg.test(); // 访问bg的函数&#xA;alert(bg.document.body.innerHTML); // 访问bg的DOM&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;至于&lt;code&gt;background&lt;/code&gt;访问&lt;code&gt;popup&lt;/code&gt;如下（前提是&lt;code&gt;popup&lt;/code&gt;已经打开）：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var views = chrome.extension.getViews({type:&#39;popup&#39;});&#xA;if(views.length &amp;gt; 0) {&#xA;&#x9;console.log(views[0].location.href);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;popup或者bg向content主动发送消息&lt;/h3&gt; &#xA;&lt;p&gt;background.js或者popup.js：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function sendMessageToContentScript(message, callback)&#xA;{&#xA;&#x9;chrome.tabs.query({active: true, currentWindow: true}, function(tabs)&#xA;&#x9;{&#xA;&#x9;&#x9;chrome.tabs.sendMessage(tabs[0].id, message, function(response)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(callback) callback(response);&#xA;&#x9;&#x9;});&#xA;&#x9;});&#xA;}&#xA;sendMessageToContentScript({cmd:&#39;test&#39;, value:&#39;你好，我是popup！&#39;}, function(response)&#xA;{&#xA;&#x9;console.log(&#39;来自content的回复：&#39;+response);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;content-script.js&lt;/code&gt;接收：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)&#xA;{&#xA;&#x9;// console.log(sender.tab ?&#34;from a content script:&#34; + sender.tab.url :&#34;from the extension&#34;);&#xA;&#x9;if(request.cmd == &#39;test&#39;) alert(request.value);&#xA;&#x9;sendResponse(&#39;我收到了你的消息！&#39;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;网上有些老代码中用的是&lt;code&gt;chrome.extension.onMessage&lt;/code&gt;，没有完全查清二者的区别(貌似是别名)，但是建议统一使用&lt;code&gt;chrome.runtime.onMessage&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;content-script主动发消息给后台&lt;/h3&gt; &#xA;&lt;p&gt;content-script.js：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.runtime.sendMessage({greeting: &#39;你好，我是content-script呀，我主动发消息给后台！&#39;}, function(response) {&#xA;&#x9;console.log(&#39;收到来自后台的回复：&#39; + response);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;background.js 或者 popup.js：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 监听来自content-script的消息&#xA;chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)&#xA;{&#xA;&#x9;console.log(&#39;收到来自content-script的消息：&#39;);&#xA;&#x9;console.log(request, sender, sendResponse);&#xA;&#x9;sendResponse(&#39;我是后台，我已收到你的消息：&#39; + JSON.stringify(request));&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;注意事项：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;content_scripts向&lt;code&gt;popup&lt;/code&gt;主动发消息的前提是popup必须打开！否则需要利用background作中转；&lt;/li&gt; &#xA; &lt;li&gt;如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;injected script和content-script&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;content-script&lt;/code&gt;和页面内的脚本（&lt;code&gt;injected-script&lt;/code&gt;自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;可以通过&lt;code&gt;window.postMessage&lt;/code&gt;和&lt;code&gt;window.addEventListener&lt;/code&gt;来实现二者消息通讯；&lt;/li&gt; &#xA; &lt;li&gt;通过自定义DOM事件来实现；&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;第一种方法（推荐）：&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;injected-script&lt;/code&gt;中：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.postMessage({&#34;test&#34;: &#39;你好！&#39;}, &#39;*&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;content script中：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.addEventListener(&#34;message&#34;, function(e)&#xA;{&#xA;&#x9;console.log(e.data);&#xA;}, false);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;第二种方法：&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;injected-script&lt;/code&gt;中：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var customEvent = document.createEvent(&#39;Event&#39;);&#xA;customEvent.initEvent(&#39;myCustomEvent&#39;, true, true);&#xA;function fireCustomEvent(data) {&#xA;&#x9;hiddenDiv = document.getElementById(&#39;myCustomEventDiv&#39;);&#xA;&#x9;hiddenDiv.innerText = data&#xA;&#x9;hiddenDiv.dispatchEvent(customEvent);&#xA;}&#xA;fireCustomEvent(&#39;你好，我是普通JS！&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;content-script.js&lt;/code&gt;中：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var hiddenDiv = document.getElementById(&#39;myCustomEventDiv&#39;);&#xA;if(!hiddenDiv) {&#xA;&#x9;hiddenDiv = document.createElement(&#39;div&#39;);&#xA;&#x9;hiddenDiv.style.display = &#39;none&#39;;&#xA;&#x9;document.body.appendChild(hiddenDiv);&#xA;}&#xA;hiddenDiv.addEventListener(&#39;myCustomEvent&#39;, function() {&#xA;&#x9;var eventData = document.getElementById(&#39;myCustomEventDiv&#39;).innerText;&#xA;&#x9;console.log(&#39;收到自定义事件消息：&#39; + eventData);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;长连接和短连接&lt;/h2&gt; &#xA;&lt;p&gt;其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（&lt;code&gt;chrome.tabs.sendMessage&lt;/code&gt;和&lt;code&gt;chrome.runtime.sendMessage&lt;/code&gt;），一个是长连接（&lt;code&gt;chrome.tabs.connect&lt;/code&gt;和&lt;code&gt;chrome.runtime.connect&lt;/code&gt;）。&lt;/p&gt; &#xA;&lt;p&gt;短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似&lt;code&gt;WebSocket&lt;/code&gt;会一直建立连接，双方可以随时互发消息。&lt;/p&gt; &#xA;&lt;p&gt;短连接上面已经有代码示例了，这里只讲一下长连接。&lt;/p&gt; &#xA;&lt;p&gt;popup.js：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;getCurrentTabId((tabId) =&amp;gt; {&#xA;&#x9;var port = chrome.tabs.connect(tabId, {name: &#39;test-connect&#39;});&#xA;&#x9;port.postMessage({question: &#39;你是谁啊？&#39;});&#xA;&#x9;port.onMessage.addListener(function(msg) {&#xA;&#x9;&#x9;alert(&#39;收到消息：&#39;+msg.answer);&#xA;&#x9;&#x9;if(msg.answer &amp;amp;&amp;amp; msg.answer.startsWith(&#39;我是&#39;))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;port.postMessage({question: &#39;哦，原来是你啊！&#39;});&#xA;&#x9;&#x9;}&#xA;&#x9;});&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;content-script.js：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 监听长连接&#xA;chrome.runtime.onConnect.addListener(function(port) {&#xA;&#x9;console.log(port);&#xA;&#x9;if(port.name == &#39;test-connect&#39;) {&#xA;&#x9;&#x9;port.onMessage.addListener(function(msg) {&#xA;&#x9;&#x9;&#x9;console.log(&#39;收到长连接消息：&#39;, msg);&#xA;&#x9;&#x9;&#x9;if(msg.question == &#39;你是谁啊？&#39;) port.postMessage({answer: &#39;我是你爸！&#39;});&#xA;&#x9;&#x9;});&#xA;&#x9;}&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;其它补充&lt;/h1&gt; &#xA;&lt;h2&gt;动态注入或执行JS&lt;/h2&gt; &#xA;&lt;p&gt;虽然在&lt;code&gt;background&lt;/code&gt;和&lt;code&gt;popup&lt;/code&gt;中无法直接访问页面DOM，但是可以通过&lt;code&gt;chrome.tabs.executeScript&lt;/code&gt;来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。&lt;/p&gt; &#xA;&lt;p&gt;示例&lt;code&gt;manifest.json&lt;/code&gt;配置：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;name&#34;: &#34;动态JS注入演示&#34;,&#xA;&#x9;...&#xA;&#x9;&#34;permissions&#34;: [&#xA;&#x9;&#x9;&#34;tabs&#34;, &#34;http://*/*&#34;, &#34;https://*/*&#34;&#xA;&#x9;],&#xA;&#x9;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JS：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 动态执行JS代码&#xA;chrome.tabs.executeScript(tabId, {code: &#39;document.body.style.backgroundColor=&#34;red&#34;&#39;});&#xA;// 动态执行JS文件&#xA;chrome.tabs.executeScript(tabId, {file: &#39;some-script.js&#39;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;动态注入CSS&lt;/h2&gt; &#xA;&lt;p&gt;示例&lt;code&gt;manifest.json&lt;/code&gt;配置：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;name&#34;: &#34;动态CSS注入演示&#34;,&#xA;&#x9;...&#xA;&#x9;&#34;permissions&#34;: [&#xA;&#x9;&#x9;&#34;tabs&#34;, &#34;http://*/*&#34;, &#34;https://*/*&#34;&#xA;&#x9;],&#xA;&#x9;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JS代码：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 动态执行CSS代码，TODO，这里有待验证&#xA;chrome.tabs.insertCSS(tabId, {code: &#39;xxx&#39;});&#xA;// 动态执行CSS文件&#xA;chrome.tabs.insertCSS(tabId, {file: &#39;some-style.css&#39;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;获取当前窗口ID&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.windows.getCurrent(function(currentWindow)&#xA;{&#xA;&#x9;console.log(&#39;当前窗口ID：&#39; + currentWindow.id);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;获取当前标签页ID&lt;/h2&gt; &#xA;&lt;p&gt;一般有2种方法：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 获取当前选项卡ID&#xA;function getCurrentTabId(callback)&#xA;{&#xA;&#x9;chrome.tabs.query({active: true, currentWindow: true}, function(tabs)&#xA;&#x9;{&#xA;&#x9;&#x9;if(callback) callback(tabs.length ? tabs[0].id: null);&#xA;&#x9;});&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 获取当前选项卡ID&#xA;function getCurrentTabId2()&#xA;{&#xA;&#x9;chrome.windows.getCurrent(function(currentWindow)&#xA;&#x9;{&#xA;&#x9;&#x9;chrome.tabs.query({active: true, windowId: currentWindow.id}, function(tabs)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(callback) callback(tabs.length ? tabs[0].id: null);&#xA;&#x9;&#x9;});&#xA;&#x9;});&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;本地存储&lt;/h2&gt; &#xA;&lt;p&gt;本地存储建议用&lt;code&gt;chrome.storage&lt;/code&gt;而不是普通的&lt;code&gt;localStorage&lt;/code&gt;，区别有好几点，个人认为最重要的2点区别是：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;chrome.storage&lt;/code&gt;是针对插件全局的，即使你在&lt;code&gt;background&lt;/code&gt;中保存的数据，在&lt;code&gt;content-script&lt;/code&gt;也能获取到；&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chrome.storage.sync&lt;/code&gt;可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;需要声明&lt;code&gt;storage&lt;/code&gt;权限，有&lt;code&gt;chrome.storage.sync&lt;/code&gt;和&lt;code&gt;chrome.storage.local&lt;/code&gt;2种方式可供选择，使用示例如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 读取数据，第一个参数是指定要读取的key以及设置默认值&#xA;chrome.storage.sync.get({color: &#39;red&#39;, age: 18}, function(items) {&#xA;&#x9;console.log(items.color, items.age);&#xA;});&#xA;// 保存数据&#xA;chrome.storage.sync.set({color: &#39;blue&#39;}, function() {&#xA;&#x9;console.log(&#39;保存成功！&#39;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;webRequest&lt;/h2&gt; &#xA;&lt;p&gt;通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过&lt;code&gt;beforeRequest&lt;/code&gt;来简单演示一下它的冰山一角：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//manifest.json&#xA;{&#xA;&#x9;// 权限申请&#xA;&#x9;&#34;permissions&#34;:&#xA;&#x9;[&#xA;&#x9;&#x9;&#34;webRequest&#34;, // web请求&#xA;&#x9;&#x9;&#34;webRequestBlocking&#34;, // 阻塞式web请求&#xA;&#x9;&#x9;&#34;storage&#34;, // 插件本地存储&#xA;&#x9;&#x9;&#34;http://*/*&#34;, // 可以通过executeScript或者insertCSS访问的网站&#xA;&#x9;&#x9;&#34;https://*/*&#34; // 可以通过executeScript或者insertCSS访问的网站&#xA;&#x9;],&#xA;}&#xA;&#xA;&#xA;// background.js&#xA;// 是否显示图片&#xA;var showImage;&#xA;chrome.storage.sync.get({showImage: true}, function(items) {&#xA;&#x9;showImage = items.showImage;&#xA;});&#xA;// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking&#xA;chrome.webRequest.onBeforeRequest.addListener(details =&amp;gt; {&#xA;&#x9;// cancel 表示取消本次请求&#xA;&#x9;if(!showImage &amp;amp;&amp;amp; details.type == &#39;image&#39;) return {cancel: true};&#xA;&#x9;// 简单的音视频检测&#xA;&#x9;// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义&#xA;&#x9;if(details.type == &#39;media&#39;) {&#xA;&#x9;&#x9;chrome.notifications.create(null, {&#xA;&#x9;&#x9;&#x9;type: &#39;basic&#39;,&#xA;&#x9;&#x9;&#x9;iconUrl: &#39;img/icon.png&#39;,&#xA;&#x9;&#x9;&#x9;title: &#39;检测到音视频&#39;,&#xA;&#x9;&#x9;&#x9;message: &#39;音视频地址：&#39; + details.url,&#xA;&#x9;&#x9;});&#xA;&#x9;}&#xA;}, {urls: [&#34;&amp;lt;all_urls&amp;gt;&#34;]}, [&#34;blocking&#34;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;国际化&lt;/h2&gt; &#xA;&lt;p&gt;插件根目录新建一个名为&lt;code&gt;_locales&lt;/code&gt;的文件夹，再在下面新建一些语言的文件夹，如&lt;code&gt;en&lt;/code&gt;、&lt;code&gt;zh_CN&lt;/code&gt;、&lt;code&gt;zh_TW&lt;/code&gt;，然后再在每个文件夹放入一个&lt;code&gt;messages.json&lt;/code&gt;，同时必须在清单文件中设置&lt;code&gt;default_locale&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;_locales\en\messages.json&lt;/code&gt;内容：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;pluginDesc&#34;: {&#34;message&#34;: &#34;A simple chrome extension demo&#34;},&#xA;&#x9;&#34;helloWorld&#34;: {&#34;message&#34;: &#34;Hello World!&#34;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;_locales\zh_CN\messages.json&lt;/code&gt;内容：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;pluginDesc&#34;: {&#34;message&#34;: &#34;一个简单的Chrome插件demo&#34;},&#xA;&#x9;&#34;helloWorld&#34;: {&#34;message&#34;: &#34;你好啊，世界！&#34;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在&lt;code&gt;manifest.json&lt;/code&gt;和&lt;code&gt;CSS&lt;/code&gt;文件中通过&lt;code&gt;__MSG_messagename__&lt;/code&gt;引入，如：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;&#x9;&#34;description&#34;: &#34;__MSG_pluginDesc__&#34;,&#xA;&#x9;// 默认语言&#xA;&#x9;&#34;default_locale&#34;: &#34;zh_CN&#34;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JS中则直接&lt;code&gt;chrome.i18n.getMessage(&#34;helloWorld&#34;)&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;测试时，通过给chrome建立一个不同的快捷方式&lt;code&gt;chrome.exe --lang=en&lt;/code&gt;来切换语言，如：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_180606_759_2394.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;英文效果：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_175733_172_5903.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;中文效果：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_175621_269_0466.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;API总结&lt;/h2&gt; &#xA;&lt;p&gt;比较常用用的一些API系列：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;chrome.tabs&lt;/li&gt; &#xA; &lt;li&gt;chrome.runtime&lt;/li&gt; &#xA; &lt;li&gt;chrome.webRequest&lt;/li&gt; &#xA; &lt;li&gt;chrome.window&lt;/li&gt; &#xA; &lt;li&gt;chrome.storage&lt;/li&gt; &#xA; &lt;li&gt;chrome.contextMenus&lt;/li&gt; &#xA; &lt;li&gt;chrome.devtools&lt;/li&gt; &#xA; &lt;li&gt;chrome.extension&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;经验总结&lt;/h1&gt; &#xA;&lt;h2&gt;查看已安装插件路径&lt;/h2&gt; &#xA;&lt;p&gt;已安装的插件源码路径：&lt;code&gt;C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions&lt;/code&gt;，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170601_100200_647_6507.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170601_100408_338_3095.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;特别注意background的报错&lt;/h2&gt; &#xA;&lt;p&gt;很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。&lt;/p&gt; &#xA;&lt;h2&gt;如何让popup页面不关闭&lt;/h2&gt; &#xA;&lt;p&gt;在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！&lt;/p&gt; &#xA;&lt;h2&gt;不支持内联JavaScript的执行&lt;/h2&gt; &#xA;&lt;p&gt;也就是不支持将js直接写在html中，比如：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input id=&#34;btn&#34; type=&#34;button&#34; value=&#34;收藏&#34; onclick=&#34;test()&#34;/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;报错如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Refused to execute inline event handler because it violates the following Content Security Policy directive: &#34;script-src &#39;self&#39; blob: filesystem: chrome-extension-resource:&#34;. Either the &#39;unsafe-inline&#39; keyword, a hash (&#39;sha256-...&#39;), or a nonce (&#39;nonce-...&#39;) is required to enable inline execution.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;解决方法就是用JS绑定事件：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;#btn&#39;).on(&#39;click&#39;, function(){alert(&#39;测试&#39;)});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;另外，对于A标签，这样写&lt;code&gt;href=&#34;javascript:;&#34;&lt;/code&gt;然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成&lt;code&gt;href=&#34;#&#34;&lt;/code&gt;了。&lt;/p&gt; &#xA;&lt;p&gt;如果这样写：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&#34;javascript:;&#34; id=&#34;get_secret&#34;&amp;gt;请求secret&amp;lt;/a&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;报错如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Refused to execute JavaScript URL because it violates the following Content Security Policy directive: &#34;script-src &#39;self&#39; blob: filesystem: chrome-extension-resource:&#34;. Either the &#39;unsafe-inline&#39; keyword, a hash (&#39;sha256-...&#39;), or a nonce (&#39;nonce-...&#39;) is required to enable inline execution.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;注入CSS的时候必须小心&lt;/h2&gt; &#xA;&lt;p&gt;由于通过&lt;code&gt;content_scripts&lt;/code&gt;注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。&lt;/p&gt; &#xA;&lt;p&gt;之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170620_175530_598_9800.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;打包与发布&lt;/h1&gt; &#xA;&lt;p&gt;打包的话直接在插件管理页有一个打包按钮：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170621_181130_362_3360.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;然后会生成一个&lt;code&gt;.crx&lt;/code&gt;文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201707/20170710_221653_875_3099.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;参考&lt;/h1&gt; &#xA;&lt;h2&gt;官方资料&lt;/h2&gt; &#xA;&lt;p&gt;推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.chrome.com/extensions&#34;&gt;Chrome插件官方文档主页&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.chrome.com/extensions/samples&#34;&gt;Chrome插件官方示例&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.chrome.com/extensions/manifest&#34;&gt;manifest清单文件&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.chrome.com/extensions/permissions&#34;&gt;permissions权限&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.chrome.com/extensions/api_index&#34;&gt;chrome.xxx.api文档&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.chrome.com/extensions/match_patterns&#34;&gt;模糊匹配规则语法详解&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;第三方资料&lt;/h2&gt; &#xA;&lt;p&gt;部分中文资料，不是特别推荐：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://open.se.360.cn/open/extension_dev/overview.html&#34;&gt;360安全浏览器开发文档&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://open.chrome.360.cn/extension_dev/overview.html&#34;&gt;360极速浏览器Chrome扩展开发文档&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/champagne/p/&#34;&gt;Chrome扩展开发极客系列博客&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;附图&lt;/h2&gt; &#xA;&lt;p&gt;附图：Chrome高清png格式logo：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://image.liuxianan.com/201706/20170619_113331_710_1132.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>