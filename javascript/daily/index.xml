<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-17T01:32:14Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>porsager/postgres</title>
    <updated>2023-10-17T01:32:14Z</updated>
    <id>tag:github.com,2023-10-17:/porsager/postgres</id>
    <link href="https://github.com/porsager/postgres" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Postgres.js - The Fastest full featured PostgreSQL client for Node.js, Deno, Bun and CloudFlare&lt;/p&gt;&lt;hr&gt;&lt;img align=&#34;left&#34; width=&#34;440&#34; height=&#34;180&#34; alt=&#34;Fastest full PostgreSQL nodejs client&#34; src=&#34;https://raw.githubusercontent.com/porsager/postgres/master/postgresjs.svg?sanitize=true&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/porsager/postgres-benchmarks#results&#34;&gt;üöÄ Fastest full-featured node &amp;amp; deno client&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üè∑ ES6 Tagged Template Strings at the core&lt;/li&gt; &#xA; &lt;li&gt;üèÑ‚Äç‚ôÄÔ∏è Simple surface API&lt;/li&gt; &#xA; &lt;li&gt;üñäÔ∏è Dynamic query support&lt;/li&gt; &#xA; &lt;li&gt;üí¨ Chat and help on &lt;a href=&#34;https://gitter.im/porsager/postgres&#34;&gt;Gitter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üê¶ Follow on &lt;a href=&#34;https://twitter.com/rporsager&#34;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;img height=&#34;220&#34; width=&#34;458&#34; alt=&#34;Good UX with Postgres.js&#34; src=&#34;https://raw.githubusercontent.com/porsager/postgres/master/demo.gif&#34;&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npm install postgres&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Create your &lt;code&gt;sql&lt;/code&gt; database instance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// db.js&#xA;import postgres from &#39;postgres&#39;&#xA;&#xA;const sql = postgres({ /* options */ }) // will use psql environment variables&#xA;&#xA;export default sql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Simply import for use elsewhere&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// users.js&#xA;import sql from &#39;./db.js&#39;&#xA;&#xA;async function getUsersOver(age) {&#xA;  const users = await sql`&#xA;    select&#xA;      name,&#xA;      age&#xA;    from users&#xA;    where age &amp;gt; ${ age }&#xA;  `&#xA;  // users = Result [{ name: &#34;Walter&#34;, age: 80 }, { name: &#39;Murray&#39;, age: 68 }, ...]&#xA;  return users&#xA;}&#xA;&#xA;&#xA;async function insertUser({ name, age }) {&#xA;  const users = await sql`&#xA;    insert into users&#xA;      (name, age)&#xA;    values&#xA;      (${ name }, ${ age })&#xA;    returning name, age&#xA;  `&#xA;  // users = Result [{ name: &#34;Murray&#34;, age: 68 }]&#xA;  return users&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#connection&#34;&gt;Connection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#queries&#34;&gt;Queries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#building-queries&#34;&gt;Building queries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#advanced-query-methods&#34;&gt;Advanced query methods&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#transactions&#34;&gt;Transactions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#data-transformation&#34;&gt;Data Transformation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#listen--notify&#34;&gt;Listen &amp;amp; notify&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#realtime-subscribe&#34;&gt;Realtime subscribe&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#numbers-bigint-numeric&#34;&gt;Numbers, bigint, numeric&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#result-array&#34;&gt;Result Array&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#connection-details&#34;&gt;Connection details&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#custom-types&#34;&gt;Custom Types&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#teardown--cleanup&#34;&gt;Teardown / Cleanup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#error-handling&#34;&gt;Error handling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#typescript-support&#34;&gt;TypeScript support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#reserving-connections&#34;&gt;Reserving connections&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Connection&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;postgres([url], [options])&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can use either a &lt;code&gt;postgres://&lt;/code&gt; url connection string or the options to define your database connection properties. Options in the object will override any present in the url. Options will fall back to the same environment variables as psql.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres(&#39;postgres://username:password@host:port/database&#39;, {&#xA;  host                 : &#39;&#39;,            // Postgres ip address[s] or domain name[s]&#xA;  port                 : 5432,          // Postgres server port[s]&#xA;  database             : &#39;&#39;,            // Name of database to connect to&#xA;  username             : &#39;&#39;,            // Username of database user&#xA;  password             : &#39;&#39;,            // Password of database user&#xA;  ...and more&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More options can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#connection-details&#34;&gt;Connection details section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Queries&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;await sql`...` -&amp;gt; Result[]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Postgres.js utilizes &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates&#34;&gt;Tagged template functions&lt;/a&gt; to process query parameters &lt;strong&gt;before&lt;/strong&gt; interpolation. Using tagged template literals benefits developers by:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Enforcing&lt;/strong&gt; safe query generation&lt;/li&gt; &#xA; &lt;li&gt;Giving the &lt;code&gt;sql``&lt;/code&gt; function powerful &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#dynamic-inserts&#34;&gt;utility&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#building-queries&#34;&gt;query building&lt;/a&gt; features.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Any generic value will be serialized according to an inferred type, and replaced by a PostgreSQL protocol placeholder &lt;code&gt;$1, $2, ...&lt;/code&gt;. The parameters are then sent separately to the database which handles escaping &amp;amp; casting.&lt;/p&gt; &#xA;&lt;p&gt;All queries will return a &lt;code&gt;Result&lt;/code&gt; array, with objects mapping column names to each row.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const xs = await sql`&#xA;  insert into users (&#xA;    name, age&#xA;  ) values (&#xA;    &#39;Murray&#39;, 68&#xA;  )&#xA;&#xA;  returning *&#xA;`&#xA;&#xA;// xs = [{ user_id: 1, name: &#39;Murray&#39;, age: 68 }]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Please note that queries are first executed when &lt;code&gt;awaited&lt;/code&gt; ‚Äì or instantly by using &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#execute&#34;&gt;&lt;code&gt;.execute()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Query parameters&lt;/h3&gt; &#xA;&lt;p&gt;Parameters are automatically extracted and handled by the database so that SQL injection isn&#39;t possible. No special handling is necessary, simply use tagged template literals as usual.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const name = &#39;Mur&#39;&#xA;    , age = 60&#xA;&#xA;const users = await sql`&#xA;  select&#xA;    name,&#xA;    age&#xA;  from users&#xA;  where&#xA;    name like ${ name + &#39;%&#39; }&#xA;    and age &amp;gt; ${ age }&#xA;`&#xA;// users = [{ name: &#39;Murray&#39;, age: 68 }]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Be careful with quotation marks here. Because Postgres infers column types, you do not need to wrap your interpolated parameters in quotes like &lt;code&gt;&#39;${name}&#39;&lt;/code&gt;. This will cause an error because the tagged template replaces &lt;code&gt;${name}&lt;/code&gt; with &lt;code&gt;$1&lt;/code&gt; in the query string, leaving Postgres to do the interpolation. If you wrap that in a string, Postgres will see &lt;code&gt;&#39;$1&#39;&lt;/code&gt; and interpret it as a string as opposed to a parameter.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Dynamic column selection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const columns = [&#39;name&#39;, &#39;age&#39;]&#xA;&#xA;sql`&#xA;  select&#xA;    ${ sql(columns) }&#xA;  from users&#xA;`&#xA;&#xA;// Which results in:&#xA;select &#34;name&#34;, &#34;age&#34; from users&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic inserts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const user = {&#xA;  name: &#39;Murray&#39;,&#xA;  age: 68&#xA;}&#xA;&#xA;await sql`&#xA;  insert into users ${&#xA;    sql(user, &#39;name&#39;, &#39;age&#39;)&#xA;  }&#xA;`&#xA;&#xA;// Which results in:&#xA;insert into users (&#34;name&#34;, &#34;age&#34;) values ($1, $2)&#xA;&#xA;// The columns can also be given with an array&#xA;const columns = [&#39;name&#39;, &#39;age&#39;]&#xA;&#xA;await sql`&#xA;  insert into users ${&#xA;    sql(user, columns)&#xA;  }&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;You can omit column names and simply execute &lt;code&gt;sql(user)&lt;/code&gt; to get all the fields from the object as columns&lt;/strong&gt;. Be careful not to allow users to supply columns that you do not want to be inserted.&lt;/p&gt; &#xA;&lt;h4&gt;Multiple inserts in one query&lt;/h4&gt; &#xA;&lt;p&gt;If you need to insert multiple rows at the same time it&#39;s also much faster to do it with a single &lt;code&gt;insert&lt;/code&gt;. Simply pass an array of objects to &lt;code&gt;sql()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const users = [{&#xA;  name: &#39;Murray&#39;,&#xA;  age: 68,&#xA;  garbage: &#39;ignore&#39;&#xA;},&#xA;{&#xA;  name: &#39;Walter&#39;,&#xA;  age: 80&#xA;}]&#xA;&#xA;sql`insert into users ${ sql(users, &#39;name&#39;, &#39;age&#39;) }`&#xA;&#xA;// Is translated to:&#xA;insert into users (&#34;name&#34;, &#34;age&#34;) values ($1, $2), ($3, $4)&#xA;&#xA;// Here you can also omit column names which will use object keys as columns&#xA;sql`insert into users ${ sql(users) }`&#xA;&#xA;// Which results in:&#xA;insert into users (&#34;name&#34;, &#34;age&#34;) values ($1, $2), ($3, $4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic columns in updates&lt;/h3&gt; &#xA;&lt;p&gt;This is also useful for update queries&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const user = {&#xA;  id: 1,&#xA;  name: &#39;Murray&#39;,&#xA;  age: 68&#xA;}&#xA;&#xA;await sql`&#xA;  update users set ${&#xA;    sql(user, &#39;name&#39;, &#39;age&#39;)&#xA;  }&#xA;  where user_id = ${ user.id }&#xA;`&#xA;&#xA;// Which results in:&#xA;update users set &#34;name&#34; = $1, &#34;age&#34; = $2 where user_id = $3&#xA;&#xA;// The columns can also be given with an array&#xA;const columns = [&#39;name&#39;, &#39;age&#39;]&#xA;&#xA;await sql`&#xA;  update users set ${&#xA;    sql(user, columns)&#xA;  }&#xA;  where user_id = ${ user.id }&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple updates in one query&lt;/h3&gt; &#xA;&lt;p&gt;To create multiple updates in a single query, it is necessary to use arrays instead of objects to ensure that the order of the items correspond with the column names.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const users = [&#xA;  [1, &#39;John&#39;, 34],&#xA;  [2, &#39;Jane&#39;, 27],&#xA;]&#xA;&#xA;sql`&#xA;  update users set name = update_data.name, (age = update_data.age)::int&#xA;  from (values ${sql(users)}) as update_data (id, name, age)&#xA;  where users.id = (update_data.id)::int&#xA;  returning users.id, users.name, users.age&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic values and &lt;code&gt;where in&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Value lists can also be created dynamically, making &lt;code&gt;where in&lt;/code&gt; queries simple too.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const users = await sql`&#xA;  select&#xA;    *&#xA;  from users&#xA;  where age in ${ sql([68, 75, 23]) }&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const [{ a, b, c }] =&amp;gt; await sql`&#xA;  select&#xA;    *&#xA;  from (values ${ sql([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) }) as x(a, b, c)&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building queries&lt;/h2&gt; &#xA;&lt;p&gt;Postgres.js features a simple dynamic query builder by conditionally appending/omitting query fragments. It works by nesting &lt;code&gt;sql``&lt;/code&gt; fragments within other &lt;code&gt;sql``&lt;/code&gt; calls or fragments. This allows you to build dynamic queries safely without risking sql injections through usual string concatenation.&lt;/p&gt; &#xA;&lt;h3&gt;Partial queries&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const olderThan = x =&amp;gt; sql`and age &amp;gt; ${ x }`&#xA;&#xA;const filterAge = true&#xA;&#xA;sql`&#xA;  select&#xA;   *&#xA;  from users&#xA;  where name is not null ${&#xA;    filterAge&#xA;      ? olderThan(50)&#xA;      : sql``&#xA;  }&#xA;`&#xA;// Which results in:&#xA;select * from users where name is not null&#xA;// Or&#xA;select * from users where name is not null and age &amp;gt; 50&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic filters&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;sql`&#xA;  select&#xA;    *&#xA;  from users ${&#xA;    id&#xA;      ? sql`where user_id = ${ id }`&#xA;      : sql``&#xA;  }&#xA;`&#xA;&#xA;// Which results in:&#xA;select * from users&#xA;// Or&#xA;select * from users where user_id = $1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SQL functions&lt;/h3&gt; &#xA;&lt;p&gt;Using keywords or calling functions dynamically is also possible by using &lt;code&gt;sql``&lt;/code&gt; fragments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const date = null&#xA;&#xA;sql`&#xA;  update users set updated_at = ${ date || sql`now()` }&#xA;`&#xA;&#xA;// Which results in:&#xA;update users set updated_at = now()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Table names&lt;/h3&gt; &#xA;&lt;p&gt;Dynamic identifiers like table names and column names is also supported like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const table = &#39;users&#39;&#xA;    , column = &#39;id&#39;&#xA;&#xA;sql`&#xA;  select ${ sql(column) } from ${ sql(table) }&#xA;`&#xA;&#xA;// Which results in:&#xA;select &#34;id&#34; from &#34;users&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Quick primer on interpolation&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s a quick oversight over all the ways to do interpolation in a query template string:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Interpolation syntax&lt;/th&gt; &#xA;   &lt;th&gt;Usage&lt;/th&gt; &#xA;   &lt;th&gt;Example&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;${ sql`` }&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;for keywords or sql fragments&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sql`SELECT * FROM users ${sql`order by age desc` }` &lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;${ sql(string) }&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;for identifiers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sql`SELECT * FROM ${sql(&#39;table_name&#39;)` &lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;${ sql([] or {}, ...) }&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;for helpers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sql`INSERT INTO users ${sql({ name: &#39;Peter&#39;})}` &lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;${ &#39;somevalue&#39; }&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;for values&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sql`SELECT * FROM users WHERE age = ${42}` &lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Advanced query methods&lt;/h2&gt; &#xA;&lt;h3&gt;Cursors&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql``.cursor([rows = 1], [fn])&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use cursors if you need to throttle the amount of rows being returned from a query. You can use a cursor either as an &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of&#34;&gt;async iterable&lt;/a&gt; or with a callback function. For a callback function new results won&#39;t be requested until the promise / async callback function has resolved.&lt;/p&gt; &#xA;&lt;h5&gt;callback function&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await sql`&#xA;  select&#xA;    *&#xA;  from generate_series(1,4) as x&#xA;`.cursor(async([row]) =&amp;gt; {&#xA;  // row = { x: 1 }&#xA;  await http.request(&#39;https://example.com/wat&#39;, { row })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;for await...of&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// for await...of&#xA;const cursor = sql`select * from generate_series(1,4) as x`.cursor()&#xA;&#xA;for await (const [row] of cursor) {&#xA;  // row = { x: 1 }&#xA;  await http.request(&#39;https://example.com/wat&#39;, { row })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A single row will be returned by default, but you can also request batches by setting the number of rows desired in each batch as the first argument to &lt;code&gt;.cursor&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await sql`&#xA;  select&#xA;    *&#xA;  from generate_series(1,1000) as x&#xA;`.cursor(10, async rows =&amp;gt; {&#xA;  // rows = [{ x: 1 }, { x: 2 }, ... ]&#xA;  await Promise.all(rows.map(row =&amp;gt;&#xA;    http.request(&#39;https://example.com/wat&#39;, { row })&#xA;  ))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If an error is thrown inside the callback function no more rows will be requested and the outer promise will reject with the thrown error.&lt;/p&gt; &#xA;&lt;p&gt;You can close the cursor early either by calling &lt;code&gt;break&lt;/code&gt; in the &lt;code&gt;for await...of&lt;/code&gt; loop, or by returning the token &lt;code&gt;sql.CLOSE&lt;/code&gt; from the callback function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await sql`&#xA;  select * from generate_series(1,1000) as x&#xA;`.cursor(row =&amp;gt; {&#xA;  return Math.random() &amp;gt; 0.9 &amp;amp;&amp;amp; sql.CLOSE // or sql.END&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Instant iteration&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql``.forEach(fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If you want to handle rows returned by a query one by one, you can use &lt;code&gt;.forEach&lt;/code&gt; which returns a promise that resolves once there are no more rows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await sql`&#xA;  select created_at, name from events&#xA;`.forEach(row =&amp;gt; {&#xA;  // row = { created_at: &#39;2019-11-22T14:22:00Z&#39;, name: &#39;connected&#39; }&#xA;})&#xA;&#xA;// No more rows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Query Descriptions&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql``.describe() -&amp;gt; Result[]&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Rather than executing a given query, &lt;code&gt;.describe&lt;/code&gt; will return information utilized in the query process. This information can include the query identifier, column types, etc.&lt;/p&gt; &#xA;&lt;p&gt;This is useful for debugging and analyzing your Postgres queries. Furthermore, &lt;strong&gt;&lt;code&gt;.describe&lt;/code&gt; will give you access to the final generated query string that would be executed.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Rows as Array of Values&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;sql``.values()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Using &lt;code&gt;.values&lt;/code&gt; will return rows as an array of values for each column, instead of objects.&lt;/p&gt; &#xA;&lt;p&gt;This can be useful to receive identically named columns, or for specific performance/transformation reasons. The column definitions are still included on the result array, plus access to parsers for each column.&lt;/p&gt; &#xA;&lt;h3&gt;Rows as Raw Array of Buffers&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;sql``.raw()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Using &lt;code&gt;.raw&lt;/code&gt; will return rows as an array with &lt;code&gt;Buffer&lt;/code&gt; values for each column, instead of objects.&lt;/p&gt; &#xA;&lt;p&gt;This can be useful for specific performance/transformation reasons. The column definitions are still included on the result array, plus access to parsers for each column.&lt;/p&gt; &#xA;&lt;h3&gt;Queries in Files&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql.file(path, [args], [options]) -&amp;gt; Result[]&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Using a file for a query is also supported with optional parameters to use if the file includes &lt;code&gt;$1, $2, etc&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const result = await sql.file(&#39;query.sql&#39;, [&#39;Murray&#39;, 68])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple statements in one query&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql``.simple()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The postgres wire protocol supports &lt;a href=&#34;https://www.postgresql.org/docs/current/protocol-flow.html#id-1.10.6.7.4&#34;&gt;&#34;simple&#34;&lt;/a&gt; and &lt;a href=&#34;https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&#34;&gt;&#34;extended&#34;&lt;/a&gt; queries. &#34;simple&#34; queries supports multiple statements, but does not support any dynamic parameters. &#34;extended&#34; queries support parameters but only one statement. To use &#34;simple&#34; queries you can use &lt;code&gt;sql``.simple()&lt;/code&gt;. That will create it as a simple query.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await sql`select 1; select 2;`.simple()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Copy to/from as Streams&lt;/h3&gt; &#xA;&lt;p&gt;Postgres.js supports &lt;a href=&#34;https://www.postgresql.org/docs/14/sql-copy.html&#34;&gt;&lt;code&gt;COPY ...&lt;/code&gt;&lt;/a&gt; queries, which are exposed as &lt;a href=&#34;https://nodejs.org/api/stream.html&#34;&gt;Node.js streams&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql`copy ... from stdin`.writable() -&amp;gt; Writable&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { pipeline } from &#39;node:stream/promises&#39;&#xA;&#xA;// Stream of users with the default tab delimitated cells and new-line delimitated rows&#xA;const userStream = Readable.from([&#xA;  &#39;Murray\t68\n&#39;,&#xA;  &#39;Walter\t80\n&#39;&#xA;])&#xA;&#xA;const query = await sql`copy users (name, age) from stdin`.writable()&#xA;await pipeline(userStream, query);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql`copy ... to stdout`.readable() -&amp;gt; Readable&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;h5&gt;Using Stream Pipeline&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { pipeline } from &#39;node:stream/promises&#39;&#xA;import { createWriteStream } from &#39;node:fs&#39;&#xA;&#xA;const readableStream = await sql`copy users (name, age) to stdout`.readable()&#xA;await pipeline(readableStream, createWriteStream(&#39;output.tsv&#39;))&#xA;// output.tsv content: `Murray\t68\nWalter\t80\n`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Using &lt;code&gt;for await...of&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const readableStream = await sql`&#xA;  copy (&#xA;    select name, age &#xA;    from users &#xA;    where age = 68&#xA;  ) to stdout&#xA;`.readable()&#xA;for await (const chunk of readableStream) {&#xA;  // chunk.toString() === `Murray\t68\n`&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; This is a low-level API which does not provide any type safety. To make this work, you must match your &lt;a href=&#34;https://www.postgresql.org/docs/14/sql-copy.html&#34;&gt;&lt;code&gt;copy query&lt;/code&gt; parameters&lt;/a&gt; correctly to your &lt;a href=&#34;https://nodejs.org/api/stream.html&#34;&gt;Node.js stream read or write&lt;/a&gt; code. Ensure &lt;a href=&#34;https://nodejs.org/en/docs/guides/backpressuring-in-streams/&#34;&gt;Node.js stream backpressure&lt;/a&gt; is handled correctly to avoid memory exhaustion.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Canceling Queries in Progress&lt;/h3&gt; &#xA;&lt;p&gt;Postgres.js supports, &lt;a href=&#34;https://www.postgresql.org/docs/7.1/protocol-protocol.html#AEN39000&#34;&gt;canceling queries in progress&lt;/a&gt;. It works by opening a new connection with a protocol level startup message to cancel the current query running on a specific connection. That means there is no guarantee that the query will be canceled, and due to the possible race conditions it might even result in canceling another query. This is fine for long running queries, but in the case of high load and fast queries it might be better to simply ignore results instead of canceling.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const query = sql`select pg_sleep 100`.execute()&#xA;setTimeout(() =&amp;gt; query.cancel(), 100)&#xA;const result = await query&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Execute&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;await sql``.execute()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The lazy Promise implementation in Postgres.js is what allows it to distinguish &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#building-queries&#34;&gt;Nested Fragments&lt;/a&gt; from the main outer query. This also means that queries are always executed at the earliest in the following tick. If you have a specific need to execute the query in the same tick, you can call &lt;code&gt;.execute()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Unsafe raw string queries&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Advanced unsafe use cases&lt;/summary&gt; &#xA; &lt;h3&gt;&lt;code&gt;await sql.unsafe(query, [args], [options]) -&amp;gt; Result[]&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;If you know what you&#39;re doing, you can use &lt;code&gt;unsafe&lt;/code&gt; to pass any string you&#39;d like to postgres. Please note that this can lead to SQL injection if you&#39;re not careful.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;sql.unsafe(&#39;select &#39; + danger + &#39; from users where id = &#39; + dragons)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can also nest &lt;code&gt;sql.unsafe&lt;/code&gt; within a safe &lt;code&gt;sql&lt;/code&gt; expression. This is useful if only part of your fraction has unsafe elements.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const triggerName = &#39;friend_created&#39;&#xA;const triggerFnName = &#39;on_friend_created&#39;&#xA;const eventType = &#39;insert&#39;&#xA;const schema_name = &#39;app&#39;&#xA;const table_name = &#39;friends&#39;&#xA;&#xA;await sql`&#xA;  create or replace trigger ${sql(triggerName)}&#xA;  after ${sql.unsafe(eventType)} on ${sql.unsafe(`${schema_name}.${table_name}`)}&#xA;  for each row&#xA;  execute function ${sql(triggerFnName)}()&#xA;`&#xA;&#xA;await sql`&#xA;  create role friend_service with login password ${sql.unsafe(`&#39;${password}&#39;`)}&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Transactions&lt;/h2&gt; &#xA;&lt;h4&gt;BEGIN / COMMIT &lt;code&gt;await sql.begin([options = &#39;&#39;], fn) -&amp;gt; fn()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;sql.begin&lt;/code&gt; to start a new transaction. Postgres.js will reserve a connection for the transaction and supply a scoped &lt;code&gt;sql&lt;/code&gt; instance for all transaction uses in the callback function. &lt;code&gt;sql.begin&lt;/code&gt; will resolve with the returned value from the callback function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;BEGIN&lt;/code&gt; is automatically sent with the optional options, and if anything fails &lt;code&gt;ROLLBACK&lt;/code&gt; will be called so the connection can be released and execution can continue.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const [user, account] = await sql.begin(async sql =&amp;gt; {&#xA;  const [user] = await sql`&#xA;    insert into users (&#xA;      name&#xA;    ) values (&#xA;      &#39;Murray&#39;&#xA;    )&#xA;  returning *&#xA;  `&#xA;&#xA;  const [account] = await sql`&#xA;    insert into accounts (&#xA;      user_id&#xA;    ) values (&#xA;      ${ user.user_id }&#xA;    )&#xA;  returning *&#xA;  `&#xA;&#xA;  return [user, account]&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Do note that you can often achieve the same result using &lt;a href=&#34;https://www.postgresql.org/docs/current/queries-with.html&#34;&gt;&lt;code&gt;WITH&lt;/code&gt; queries (Common Table Expressions)&lt;/a&gt; instead of using transactions.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also possible to pipeline the requests in a transaction if needed by returning an array with queries from the callback function like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const result = await sql.begin(sql =&amp;gt; [&#xA;  sql`update ...`,&#xA;  sql`update ...`,&#xA;  sql`insert ...`&#xA;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SAVEPOINT &lt;code&gt;await sql.savepoint([name], fn) -&amp;gt; fn()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;sql.begin(&#39;read write&#39;, async sql =&amp;gt; {&#xA;  const [user] = await sql`&#xA;    insert into users (&#xA;      name&#xA;    ) values (&#xA;      &#39;Murray&#39;&#xA;    )&#xA;  `&#xA;&#xA;  const [account] = (await sql.savepoint(sql =&amp;gt;&#xA;    sql`&#xA;      insert into accounts (&#xA;        user_id&#xA;      ) values (&#xA;        ${ user.user_id }&#xA;      )&#xA;    `&#xA;  ).catch(err =&amp;gt; {&#xA;    // Account could not be created. ROLLBACK SAVEPOINT is called because we caught the rejection.&#xA;  })) || []&#xA;&#xA;  return [user, account]&#xA;})&#xA;.then(([user, account]) =&amp;gt; {&#xA;  // great success - COMMIT succeeded&#xA;})&#xA;.catch(() =&amp;gt; {&#xA;  // not so good - ROLLBACK was called&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;PREPARE TRANSACTION &lt;code&gt;await sql.prepare([name]) -&amp;gt; fn()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Indicates that the transactions should be prepared using the &lt;a href=&#34;https://www.postgresql.org/docs/current/sql-prepare-transaction.html&#34;&gt;&lt;code&gt;PREPARE TRANSACTION [NAME]&lt;/code&gt;&lt;/a&gt; statement instead of being committed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;sql.begin(&#39;read write&#39;, async sql =&amp;gt; {&#xA;  const [user] = await sql`&#xA;    insert into users (&#xA;      name&#xA;    ) values (&#xA;      &#39;Murray&#39;&#xA;    )&#xA;  `&#xA;    &#xA;  await sql.prepare(&#39;tx1&#39;)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Data Transformation&lt;/h2&gt; &#xA;&lt;p&gt;Postgres.js allows for transformation of the data passed to or returned from a query by using the &lt;code&gt;transform&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;Built in transformation functions are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For camelCase - &lt;code&gt;postgres.camel&lt;/code&gt;, &lt;code&gt;postgres.toCamel&lt;/code&gt;, &lt;code&gt;postgres.fromCamel&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For PascalCase - &lt;code&gt;postgres.pascal&lt;/code&gt;, &lt;code&gt;postgres.toPascal&lt;/code&gt;, &lt;code&gt;postgres.fromPascal&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For Kebab-Case - &lt;code&gt;postgres.kebab&lt;/code&gt;, &lt;code&gt;postgres.toKebab&lt;/code&gt;, &lt;code&gt;postgres.fromKebab&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These built in transformations will only convert to/from snake_case. For example, using &lt;code&gt;{ transform: postgres.toCamel }&lt;/code&gt; will convert the column names to camelCase only if the column names are in snake_case to begin with. &lt;code&gt;{ transform: postgres.fromCamel }&lt;/code&gt; will convert camelCase only to snake_case.&lt;/p&gt; &#xA;&lt;p&gt;By default, using &lt;code&gt;postgres.camel&lt;/code&gt;, &lt;code&gt;postgres.pascal&lt;/code&gt; and &lt;code&gt;postgres.kebab&lt;/code&gt; will perform a two-way transformation - both the data passed to the query and the data returned by the query will be transformed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Transform the column names to and from camel case&#xA;const sql = postgres({ transform: postgres.camel })&#xA;&#xA;await sql`CREATE TABLE IF NOT EXISTS camel_case (a_test INTEGER, b_test TEXT)`&#xA;await sql`INSERT INTO camel_case ${ sql([{ aTest: 1, bTest: 1 }]) }`&#xA;const data = await sql`SELECT ${ sql(&#39;aTest&#39;, &#39;bTest&#39;) } FROM camel_case`&#xA;&#xA;console.log(data) // [ { aTest: 1, bTest: &#39;1&#39; } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To only perform half of the transformation (eg. only the transformation &lt;strong&gt;to&lt;/strong&gt; or &lt;strong&gt;from&lt;/strong&gt; camel case), use the other transformation functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Transform the column names only to camel case&#xA;// (for the results that are returned from the query)&#xA;postgres({ transform: postgres.toCamel })&#xA;&#xA;await sql`CREATE TABLE IF NOT EXISTS camel_case (a_test INTEGER)`&#xA;await sql`INSERT INTO camel_case ${ sql([{ a_test: 1 }]) }`&#xA;const data = await sql`SELECT a_test FROM camel_case`&#xA;&#xA;console.log(data) // [ { aTest: 1 } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Transform the column names only from camel case&#xA;// (for interpolated inserts, updates, and selects)&#xA;const sql = postgres({ transform: postgres.fromCamel })&#xA;&#xA;await sql`CREATE TABLE IF NOT EXISTS camel_case (a_test INTEGER)`&#xA;await sql`INSERT INTO camel_case ${ sql([{ aTest: 1 }]) }`&#xA;const data = await sql`SELECT ${ sql(&#39;aTest&#39;) } FROM camel_case`&#xA;&#xA;console.log(data) // [ { a_test: 1 } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that Postgres.js does not rewrite the static parts of the tagged template strings. So to transform column names in your queries, the &lt;code&gt;sql()&lt;/code&gt; helper must be used - eg. &lt;code&gt;${ sql(&#39;columnName&#39;) }&lt;/code&gt; as in the examples above.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Transform &lt;code&gt;undefined&lt;/code&gt; Values&lt;/h3&gt; &#xA;&lt;p&gt;By default, Postgres.js will throw the error &lt;code&gt;UNDEFINED_VALUE: Undefined values are not allowed&lt;/code&gt; when undefined values are passed&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Transform the column names to and from camel case&#xA;const sql = postgres({&#xA;  transform: {&#xA;    undefined: null&#xA;  }&#xA;})&#xA;&#xA;await sql`CREATE TABLE IF NOT EXISTS transform_undefined (a_test INTEGER)`&#xA;await sql`INSERT INTO transform_undefined ${ sql([{ a_test: undefined }]) }`&#xA;const data = await sql`SELECT a_test FROM transform_undefined`&#xA;&#xA;console.log(data) // [ { a_test: null } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To combine with the built in transform functions, spread the transform in the &lt;code&gt;transform&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Transform the column names to and from camel case&#xA;const sql = postgres({&#xA;  transform: {&#xA;    ...postgres.camel,&#xA;    undefined: null&#xA;  }&#xA;})&#xA;&#xA;await sql`CREATE TABLE IF NOT EXISTS transform_undefined (a_test INTEGER)`&#xA;await sql`INSERT INTO transform_undefined ${ sql([{ aTest: undefined }]) }`&#xA;const data = await sql`SELECT ${ sql(&#39;aTest&#39;) } FROM transform_undefined`&#xA;&#xA;console.log(data) // [ { aTest: null } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom Transform Functions&lt;/h3&gt; &#xA;&lt;p&gt;To specify your own transformation functions, you can use the &lt;code&gt;column&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;row&lt;/code&gt; options inside of &lt;code&gt;transform&lt;/code&gt;, each an object possibly including &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt; keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;to&lt;/code&gt;: The function to transform the outgoing query column name to, i.e &lt;code&gt;SELECT ${ sql(&#39;aName&#39;) }&lt;/code&gt; to &lt;code&gt;SELECT a_name&lt;/code&gt; when using &lt;code&gt;postgres.toCamel&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;from&lt;/code&gt;: The function to transform the incoming query result column name to, see example below.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Both parameters are optional, if not provided, the default transformation function will be used.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Implement your own functions, look at postgres.toCamel, etc&#xA;// as a reference:&#xA;// https://github.com/porsager/postgres/blob/4241824ffd7aa94ffb482e54ca9f585d9d0a4eea/src/types.js#L310-L328&#xA;function transformColumnToDatabase() { /* ... */ }&#xA;function transformColumnFromDatabase() { /* ... */ }&#xA;&#xA;const sql = postgres({&#xA;  transform: {&#xA;    column: {&#xA;      to: transformColumnToDatabase,&#xA;      from: transformColumnFromDatabase,&#xA;    },&#xA;    value: { /* ... */ },&#xA;    row: { /* ... */ }&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Listen &amp;amp; notify&lt;/h2&gt; &#xA;&lt;p&gt;When you call &lt;code&gt;.listen&lt;/code&gt;, a dedicated connection will be created to ensure that you receive notifications instantly. This connection will be used for any further calls to &lt;code&gt;.listen&lt;/code&gt;. The connection will automatically reconnect according to a backoff reconnection pattern to not overload the database server.&lt;/p&gt; &#xA;&lt;h3&gt;Listen &lt;code&gt;await sql.listen(channel, onnotify, [onlisten]) -&amp;gt; { state }&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;.listen&lt;/code&gt; takes the channel name, a function to handle each notify, and an optional function to run every time listen is registered and ready (happens on initial connect and reconnects). It returns a promise which resolves once the &lt;code&gt;LISTEN&lt;/code&gt; query to Postgres completes, or if there is already a listener active.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await sql.listen(&#39;news&#39;, payload =&amp;gt; {&#xA;  const json = JSON.parse(payload)&#xA;  console.log(json.this) // logs &#39;is&#39;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The optional &lt;code&gt;onlisten&lt;/code&gt; method is great to use for a very simply queue mechanism:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await sql.listen(&#xA;  &#39;jobs&#39;, &#xA;  (x) =&amp;gt; run(JSON.parse(x)),&#xA;  ( ) =&amp;gt; sql`select unfinished_jobs()`.forEach(run)&#xA;)&#xA;&#xA;function run(job) {&#xA;  // And here you do the work you please&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Notify &lt;code&gt;await sql.notify(channel, payload) -&amp;gt; Result[]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Notify can be done as usual in SQL, or by using the &lt;code&gt;sql.notify&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;sql.notify(&#39;news&#39;, JSON.stringify({ no: &#39;this&#39;, is: &#39;news&#39; }))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Realtime subscribe&lt;/h2&gt; &#xA;&lt;p&gt;Postgres.js implements the logical replication protocol of PostgreSQL to support subscription to real-time updates of &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operations.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; To make this work you must &lt;a href=&#34;https://www.postgresql.org/docs/current/sql-createpublication.html&#34;&gt;create the proper publications in your database&lt;/a&gt;, enable logical replication by setting &lt;code&gt;wal_level = logical&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; and connect using either a replication or superuser.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Quick start&lt;/h3&gt; &#xA;&lt;h4&gt;Create a publication (eg. in migration)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE PUBLICATION alltables FOR ALL TABLES&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Subscribe to updates&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres({ publications: &#39;alltables&#39; })&#xA;&#xA;const { unsubscribe } = await sql.subscribe(&#xA;  &#39;insert:events&#39;, &#xA;  (row, { command, relation, key, old }) =&amp;gt; {&#xA;    // Callback function for each row change&#xA;    // tell about new event row over eg. websockets or do something else&#xA;  },&#xA;  () =&amp;gt; {&#xA;    // Callback on initial connect and potential reconnects&#xA;  }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Subscribe pattern&lt;/h3&gt; &#xA;&lt;p&gt;You can subscribe to specific operations, tables, or even rows with primary keys.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;operation&lt;/code&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;schema&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;table&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;primary_key&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;operation&lt;/code&gt;&lt;/strong&gt; is one of &lt;code&gt;* | insert | update | delete&lt;/code&gt; and defaults to &lt;code&gt;*&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/strong&gt; defaults to &lt;code&gt;public&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;table&lt;/code&gt;&lt;/strong&gt; is a specific table name and defaults to &lt;code&gt;*&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;primary_key&lt;/code&gt;&lt;/strong&gt; can be used to only subscribe to specific rows&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;sql.subscribe(&#39;*&#39;,                () =&amp;gt; /* everything */ )&#xA;sql.subscribe(&#39;insert&#39;,           () =&amp;gt; /* all inserts */ )&#xA;sql.subscribe(&#39;*:users&#39;,          () =&amp;gt; /* all operations on the public.users table */ )&#xA;sql.subscribe(&#39;delete:users&#39;,     () =&amp;gt; /* all deletes on the public.users table */ )&#xA;sql.subscribe(&#39;update:users=1&#39;,   () =&amp;gt; /* all updates on the users row with a primary key = 1 */ )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Numbers, bigint, numeric&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Number&lt;/code&gt; in javascript is only able to represent 2&lt;sup&gt;53&lt;/sup&gt;-1 safely which means that types in PostgreSQLs like &lt;code&gt;bigint&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; won&#39;t fit into &lt;code&gt;Number&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Since Node.js v10.4 we can use &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt&#34;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; to match the PostgreSQL type &lt;code&gt;bigint&lt;/code&gt; which is returned for eg. &lt;code&gt;count(*)&lt;/code&gt;. Unfortunately, it doesn&#39;t work with &lt;code&gt;JSON.stringify&lt;/code&gt; out of the box, so Postgres.js will return it as a string.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use &lt;code&gt;BigInt&lt;/code&gt; you can add this custom type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres({&#xA;  types: {&#xA;    bigint: postgres.BigInt&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is currently no guaranteed way to handle &lt;code&gt;numeric&lt;/code&gt; / &lt;code&gt;decimal&lt;/code&gt; types in native Javascript. &lt;strong&gt;These [and similar] types will be returned as a &lt;code&gt;string&lt;/code&gt;&lt;/strong&gt;. The best way in this case is to use &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#custom-types&#34;&gt;custom types&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Result Array&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Result&lt;/code&gt; Array returned from queries is a custom array allowing for easy destructuring or passing on directly to JSON.stringify or general Array usage. It includes the following properties.&lt;/p&gt; &#xA;&lt;h3&gt;.count&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;count&lt;/code&gt; property is the number of affected rows returned by the database. This is usefull for insert, update and delete operations to know the number of rows since .length will be 0 in these cases if not using &lt;code&gt;RETURNING ...&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;.command&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;command&lt;/code&gt; run by the query - eg. one of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;.columns&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;columns&lt;/code&gt; returned by the query useful to determine types, or map to the result values when using &lt;code&gt;.values()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  name  : String,    // Column name,&#xA;  type  : oid,       // PostgreSQL oid column type&#xA;  parser: Function   // The function used by Postgres.js for parsing&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.statement&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;statement&lt;/code&gt; contains information about the statement implicitly created by Postgres.js.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  name    : String,  // The auto generated statement name&#xA;  string  : String,  // The actual query string executed&#xA;  types   : [oid],   // An array of oid expected as input parameters&#xA;  columns : [Column] // Array of columns - same as Result.columns&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.state&lt;/h3&gt; &#xA;&lt;p&gt;This is the state &lt;code&gt;{ pid, secret }&lt;/code&gt; of the connection that executed the query.&lt;/p&gt; &#xA;&lt;h2&gt;Connection details&lt;/h2&gt; &#xA;&lt;h3&gt;All Postgres options&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres(&#39;postgres://username:password@host:port/database&#39;, {&#xA;  host                 : &#39;&#39;,            // Postgres ip address[es] or domain name[s]&#xA;  port                 : 5432,          // Postgres server port[s]&#xA;  path                 : &#39;&#39;,            // unix socket path (usually &#39;/tmp&#39;)&#xA;  database             : &#39;&#39;,            // Name of database to connect to&#xA;  username             : &#39;&#39;,            // Username of database user&#xA;  password             : &#39;&#39;,            // Password of database user&#xA;  ssl                  : false,         // true, prefer, require, tls.connect options&#xA;  max                  : 10,            // Max number of connections&#xA;  max_lifetime         : null,          // Max lifetime in seconds (more info below)&#xA;  idle_timeout         : 0,             // Idle connection timeout in seconds&#xA;  connect_timeout      : 30,            // Connect timeout in seconds&#xA;  prepare              : true,          // Automatic creation of prepared statements&#xA;  types                : [],            // Array of custom types, see more below&#xA;  onnotice             : fn,            // Default console.log, set false to silence NOTICE&#xA;  onparameter          : fn,            // (key, value) when server param change&#xA;  debug                : fn,            // Is called with (connection, query, params, types)&#xA;  socket               : fn,            // fn returning custom socket to use&#xA;  transform            : {&#xA;    undefined          : undefined,     // Transforms undefined values (eg. to null)&#xA;    column             : fn,            // Transforms incoming column names&#xA;    value              : fn,            // Transforms incoming row values&#xA;    row                : fn             // Transforms entire rows&#xA;  },&#xA;  connection           : {&#xA;    application_name   : &#39;postgres.js&#39;, // Default application_name&#xA;    ...                                 // Other connection parameters&#xA;  },&#xA;  target_session_attrs : null,          // Use &#39;read-write&#39; with multiple hosts to&#xA;                                        // ensure only connecting to primary&#xA;  fetch_types          : true,          // Automatically fetches types on connect&#xA;                                        // on initial connection.&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;max_lifetime = 60 * (30 + Math.random() * 30)&lt;/code&gt; by default. This resolves to an interval between 45 and 90 minutes to optimize for the benefits of prepared statements &lt;strong&gt;and&lt;/strong&gt; working nicely with Linux&#39;s OOM killer.&lt;/p&gt; &#xA;&lt;h3&gt;SSL&lt;/h3&gt; &#xA;&lt;p&gt;Although &lt;a href=&#34;https://security.stackexchange.com/a/229297/174913&#34;&gt;vulnerable to MITM attacks&lt;/a&gt;, a common configuration for the &lt;code&gt;ssl&lt;/code&gt; option for some cloud providers is to set &lt;code&gt;rejectUnauthorized&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; (if &lt;code&gt;NODE_ENV&lt;/code&gt; is &lt;code&gt;production&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql =&#xA;  process.env.NODE_ENV === &#39;production&#39;&#xA;    ? // &#34;Unless you&#39;re using a Private or Shield Heroku Postgres database, Heroku Postgres does not currently support verifiable certificates&#34;&#xA;      // https://help.heroku.com/3DELT3RK/why-can-t-my-third-party-utility-connect-to-heroku-postgres-with-ssl&#xA;      postgres({ ssl: { rejectUnauthorized: false } })&#xA;    : postgres()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information regarding &lt;code&gt;ssl&lt;/code&gt; with &lt;code&gt;postgres&lt;/code&gt;, check out the &lt;a href=&#34;https://nodejs.org/dist/latest-v16.x/docs/api/tls.html#new-tlstlssocketsocket-options&#34;&gt;Node.js documentation for tls&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Multi-host connections - High Availability (HA)&lt;/h3&gt; &#xA;&lt;p&gt;Multiple connection strings can be passed to &lt;code&gt;postgres()&lt;/code&gt; in the form of &lt;code&gt;postgres(&#39;postgres://localhost:5432,localhost:5433&#39;, ...)&lt;/code&gt;. This works the same as native the &lt;code&gt;psql&lt;/code&gt; command. Read more at &lt;a href=&#34;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-MULTIPLE-HOSTS&#34;&gt;multiple host URIs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Connections will be attempted in order of the specified hosts/ports. On a successful connection, all retries will be reset. This ensures that hosts can come up and down seamlessly.&lt;/p&gt; &#xA;&lt;p&gt;If you specify &lt;code&gt;target_session_attrs: &#39;primary&#39;&lt;/code&gt; or &lt;code&gt;PGTARGETSESSIONATTRS=primary&lt;/code&gt; Postgres.js will only connect to the primary host, allowing for zero downtime failovers.&lt;/p&gt; &#xA;&lt;h3&gt;The Connection Pool&lt;/h3&gt; &#xA;&lt;p&gt;Connections are created lazily once a query is created. This means that simply doing const &lt;code&gt;sql = postgres(...)&lt;/code&gt; won&#39;t have any effect other than instantiating a new &lt;code&gt;sql&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;No connection will be made until a query is made.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres() // no connections are opened&#xA;&#xA;await sql`...` // one connection is now opened&#xA;await sql`...` // previous opened connection is reused&#xA;&#xA;// two connections are opened now&#xA;await Promise.all([&#xA;  sql`...`,&#xA;  sql`...`&#xA;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;When there are high amount of concurrent queries, &lt;code&gt;postgres&lt;/code&gt; will open as many connections as needed up until &lt;code&gt;max&lt;/code&gt; number of connections is reached. By default &lt;code&gt;max&lt;/code&gt; is 10. This can be changed by setting &lt;code&gt;max&lt;/code&gt; in the &lt;code&gt;postgres()&lt;/code&gt; call. Example - &lt;code&gt;postgres(&#39;connectionURL&#39;, { max: 20 })&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This means that we get a much simpler story for error handling and reconnections. Queries will be sent over the wire immediately on the next available connection in the pool. Connections are automatically taken out of the pool if you start a transaction using &lt;code&gt;sql.begin()&lt;/code&gt;, and automatically returned to the pool once your transaction is done.&lt;/p&gt; &#xA;&lt;p&gt;Any query which was already sent over the wire will be rejected if the connection is lost. It&#39;ll automatically defer to the error handling you have for that query, and since connections are lazy it&#39;ll automatically try to reconnect the next time a query is made. The benefit of this is no weird generic &#34;onerror&#34; handler that tries to get things back to normal, and also simpler application code since you don&#39;t have to handle errors out of context.&lt;/p&gt; &#xA;&lt;p&gt;There are no guarantees about queries executing in order unless using a transaction with &lt;code&gt;sql.begin()&lt;/code&gt; or setting &lt;code&gt;max: 1&lt;/code&gt;. Of course doing a series of queries, one awaiting the other will work as expected, but that&#39;s just due to the nature of js async/promise handling, so it&#39;s not necessary for this library to be concerned with ordering.&lt;/p&gt; &#xA;&lt;p&gt;Since this library automatically creates prepared statements, it also has a default max lifetime for connections to prevent memory bloat on the database itself. This is a random interval for each connection between 45 and 90 minutes. This allows multiple connections to independently come up and down without affecting the service.&lt;/p&gt; &#xA;&lt;h3&gt;Connection timeout&lt;/h3&gt; &#xA;&lt;p&gt;By default, connections will not close until &lt;code&gt;.end()&lt;/code&gt; is called. However, it may be useful to have them close automatically when:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;re-instantiating multiple &lt;code&gt;sql``&lt;/code&gt; instances&lt;/li&gt; &#xA; &lt;li&gt;using Postgres.js in a Serverless environment (Lambda, etc.)&lt;/li&gt; &#xA; &lt;li&gt;using Postgres.js with a database service that automatically closes connections after some time (see &lt;a href=&#34;https://github.com/porsager/postgres/issues/179&#34;&gt;&lt;code&gt;ECONNRESET&lt;/code&gt; issue&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This can be done using the &lt;code&gt;idle_timeout&lt;/code&gt; or &lt;code&gt;max_lifetime&lt;/code&gt; options. These configuration options specify the number of seconds to wait before automatically closing an idle connection and the maximum time a connection can exist, respectively.&lt;/p&gt; &#xA;&lt;p&gt;For example, to close a connection that has either been idle for 20 seconds or existed for more than 30 minutes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres({&#xA;  idle_timeout: 20,&#xA;  max_lifetime: 60 * 30&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cloudflare Workers support&lt;/h3&gt; &#xA;&lt;p&gt;Postgres.js has built-in support for the &lt;a href=&#34;https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/&#34;&gt;TCP socket API&lt;/a&gt; in Cloudflare Workers, which is &lt;a href=&#34;https://github.com/wintercg/proposal-sockets-api&#34;&gt;on-track&lt;/a&gt; to be standardized and adopted in Node.js and other JavaScript runtimes, such as Deno.&lt;/p&gt; &#xA;&lt;p&gt;You can use Postgres.js directly in a Worker, or to benefit from connection pooling and query caching, via the &lt;a href=&#34;https://developers.cloudflare.com/hyperdrive/learning/connect-to-postgres/#driver-examples&#34;&gt;Hyperdrive&lt;/a&gt; service available to Workers by passing the Hyperdrive &lt;code&gt;connectionString&lt;/code&gt; when creating a new &lt;code&gt;postgres&lt;/code&gt; client as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// Requires Postgres.js 3.4.0 or later&#xA;import postgres from &#39;postgres&#39;&#xA;&#xA;interface Env {&#xA;    HYPERDRIVE: Hyperdrive;&#xA;}&#xA;&#xA;export default async fetch(req: Request, env: Env, ctx: ExecutionContext) {&#xA;    // The Postgres.js library accepts a connection string directly&#xA;    const sql = postgres(env.HYPERDRIVE.connectionString)&#xA;    const results = await sql`SELECT * FROM users LIMIT 10`&#xA;    return Response.json(results)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In &lt;code&gt;wrangler.toml&lt;/code&gt; you will need to enable &lt;code&gt;node_compat&lt;/code&gt; to allow Postgres.js to operate in the Workers environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;node_compat = true # required for database drivers to function&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Auto fetching of array types&lt;/h3&gt; &#xA;&lt;p&gt;Postgres.js will automatically fetch table/array-type information when it first connects to a database.&lt;/p&gt; &#xA;&lt;p&gt;If you have revoked access to &lt;code&gt;pg_catalog&lt;/code&gt; this feature will no longer work and will need to be disabled.&lt;/p&gt; &#xA;&lt;p&gt;You can disable this feature by setting &lt;code&gt;fetch_types&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Environmental variables&lt;/h3&gt; &#xA;&lt;p&gt;It is also possible to connect to the database without a connection string or any options. Postgres.js will fall back to the common environment variables used by &lt;code&gt;psql&lt;/code&gt; as in the table below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Option&lt;/th&gt; &#xA;   &lt;th&gt;Environment Variables&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;host&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PGHOST&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;port&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;database&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PGDATABASE&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;username&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PGUSERNAME&lt;/code&gt; or &lt;code&gt;PGUSER&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;password&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PGPASSWORD&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;idle_timeout&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PGIDLE_TIMEOUT&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;connect_timeout&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PGCONNECT_TIMEOUT&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Prepared statements&lt;/h3&gt; &#xA;&lt;p&gt;Prepared statements will automatically be created for any queries where it can be inferred that the query is static. This can be disabled by using the &lt;code&gt;prepare: false&lt;/code&gt; option. For instance ‚Äî this is useful when &lt;a href=&#34;https://github.com/porsager/postgres/issues/93#issuecomment-656290493&#34;&gt;using PGBouncer in &lt;code&gt;transaction mode&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Types&lt;/h2&gt; &#xA;&lt;p&gt;You can add ergonomic support for custom types, or simply use &lt;code&gt;sql.typed(value, type)&lt;/code&gt; inline, where type is the PostgreSQL &lt;code&gt;oid&lt;/code&gt; for the type and the correctly serialized string. &lt;em&gt;(&lt;code&gt;oid&lt;/code&gt; values for types can be found in the &lt;code&gt;pg_catalog.pg_type&lt;/code&gt; table.)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Adding Query helpers is the cleanest approach which can be done like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sql = postgres({&#xA;  types: {&#xA;    rect: {&#xA;      // The pg_types oid to pass to the db along with the serialized value.&#xA;      to        : 1337,&#xA;&#xA;      // An array of pg_types oids to handle when parsing values coming from the db.&#xA;      from      : [1337],&#xA;&#xA;      //Function that transform values before sending them to the db.&#xA;      serialize : ({ x, y, width, height }) =&amp;gt; [x, y, width, height],&#xA;&#xA;      // Function that transforms values coming from the db.&#xA;      parse     : ([x, y, width, height]) =&amp;gt; { x, y, width, height }&#xA;    }&#xA;  }&#xA;})&#xA;&#xA;// Now you can use sql.typed.rect() as specified above&#xA;const [custom] = sql`&#xA;  insert into rectangles (&#xA;    name,&#xA;    rect&#xA;  ) values (&#xA;    &#39;wat&#39;,&#xA;    ${ sql.typed.rect({ x: 13, y: 37, width: 42, height: 80 }) }&#xA;  )&#xA;  returning *&#xA;`&#xA;&#xA;// custom = { name: &#39;wat&#39;, rect: { x: 13, y: 37, width: 42, height: 80 } }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom socket&lt;/h3&gt; &#xA;&lt;p&gt;Easily do in-process ssh tunneling to your database by providing a custom socket for Postgres.js to use. The function (optionally async) must return a socket-like duplex stream.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a sample using &lt;a href=&#34;https://github.com/mscdex/ssh2&#34;&gt;ssh2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import ssh2 from &#39;ssh2&#39;&#xA;&#xA;const sql = postgres({&#xA;  ...options,&#xA;  socket: ({ host: [host], port: [port] }) =&amp;gt; new Promise((resolve, reject) =&amp;gt; {&#xA;    const ssh = new ssh2.Client()&#xA;    ssh&#xA;    .on(&#39;error&#39;, reject)&#xA;    .on(&#39;ready&#39;, () =&amp;gt; &#xA;      ssh.forwardOut(&#39;127.0.0.1&#39;, 12345, host, port, &#xA;        (err, socket) =&amp;gt; err ? reject(err) : resolve(socket)&#xA;      )&#xA;    )&#xA;    .connect(sshOptions)&#xA;  })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Teardown / Cleanup&lt;/h2&gt; &#xA;&lt;p&gt;To ensure proper teardown and cleanup on server restarts use &lt;code&gt;await sql.end()&lt;/code&gt; before &lt;code&gt;process.exit()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;sql.end()&lt;/code&gt; will reject new queries and return a Promise which resolves when all queries are finished and the underlying connections are closed. If a &lt;code&gt;{ timeout }&lt;/code&gt; option is provided any pending queries will be rejected once the timeout (in seconds) is reached and the connections will be destroyed.&lt;/p&gt; &#xA;&lt;h4&gt;Sample shutdown using &lt;a href=&#34;https://github.com/porsager/prexit&#34;&gt;Prexit&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import prexit from &#39;prexit&#39;&#xA;&#xA;prexit(async () =&amp;gt; {&#xA;  await sql.end({ timeout: 5 })&#xA;  await new Promise(r =&amp;gt; server.close(r))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reserving connections&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;await sql.reserve()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;reserve&lt;/code&gt; method pulls out a connection from the pool, and returns a client that wraps the single connection. This can be used for running queries on an isolated connection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const reserved = await sql.reserve()&#xA;await reserved`select * from users`&#xA;await reserved.release()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;reserved.release()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Once you have finished with the reserved connection, call &lt;code&gt;release&lt;/code&gt; to add it back to the pool.&lt;/p&gt; &#xA;&lt;h2&gt;Error handling&lt;/h2&gt; &#xA;&lt;p&gt;Errors are all thrown to related queries and never globally. Errors coming from database itself are always in the &lt;a href=&#34;https://www.postgresql.org/docs/current/errcodes-appendix.html&#34;&gt;native Postgres format&lt;/a&gt;, and the same goes for any &lt;a href=&#34;https://nodejs.org/api/errors.html#errors_common_system_errors&#34;&gt;Node.js errors&lt;/a&gt; eg. coming from the underlying connection.&lt;/p&gt; &#xA;&lt;p&gt;Query errors will contain a stored error with the origin of the query to aid in tracing errors.&lt;/p&gt; &#xA;&lt;p&gt;Query errors will also contain the &lt;code&gt;query&lt;/code&gt; string and the &lt;code&gt;parameters&lt;/code&gt;. These are not enumerable to avoid accidentally leaking confidential information in logs. To log these it is required to specifically access &lt;code&gt;error.query&lt;/code&gt; and &lt;code&gt;error.parameters&lt;/code&gt;, or set &lt;code&gt;debug: true&lt;/code&gt; in options.&lt;/p&gt; &#xA;&lt;p&gt;There are also the following errors specifically for this library.&lt;/p&gt; &#xA;&lt;h5&gt;UNSAFE_TRANSACTION&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Only use sql.begin or max: 1&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To ensure statements in a transaction runs on the same connection (which is required for them to run inside the transaction), you must use &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#transactions&#34;&gt;&lt;code&gt;sql.begin(...)&lt;/code&gt;&lt;/a&gt; or only allow a single connection in options (&lt;code&gt;max: 1&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h5&gt;UNDEFINED_VALUE&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Undefined values are not allowed&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Postgres.js won&#39;t accept &lt;code&gt;undefined&lt;/code&gt; as values in tagged template queries since it becomes ambiguous what to do with the value. If you want to set something to null, use &lt;code&gt;null&lt;/code&gt; explicitly.&lt;/p&gt; &#xA;&lt;h5&gt;MESSAGE_NOT_SUPPORTED&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;X (X) is not supported&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Whenever a message is received from Postgres which is not supported by this library. Feel free to file an issue if you think something is missing.&lt;/p&gt; &#xA;&lt;h5&gt;MAX_PARAMETERS_EXCEEDED&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Max number of parameters (65534) exceeded&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The postgres protocol doesn&#39;t allow more than 65534 (16bit) parameters. If you run into this issue there are various workarounds such as using &lt;code&gt;sql([...])&lt;/code&gt; to escape values instead of passing them as parameters.&lt;/p&gt; &#xA;&lt;h5&gt;SASL_SIGNATURE_MISMATCH&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Message type X not supported&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;When using SASL authentication the server responds with a signature at the end of the authentication flow which needs to match the one on the client. This is to avoid &lt;a href=&#34;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&#34;&gt;man-in-the-middle attacks&lt;/a&gt;. If you receive this error the connection was canceled because the server did not reply with the expected signature.&lt;/p&gt; &#xA;&lt;h5&gt;NOT_TAGGED_CALL&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Query not called as a tagged template literal&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Making queries has to be done using the sql function as a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates&#34;&gt;tagged template&lt;/a&gt;. This is to ensure parameters are serialized and passed to Postgres as query parameters with correct types and to avoid SQL injection.&lt;/p&gt; &#xA;&lt;h5&gt;AUTH_TYPE_NOT_IMPLEMENTED&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Auth type X not implemented&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Postgres supports many different authentication types. This one is not supported.&lt;/p&gt; &#xA;&lt;h5&gt;CONNECTION_CLOSED&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;write CONNECTION_CLOSED host:port&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This error is thrown if the connection was closed without an error. This should not happen during normal operations, so please create an issue if this was unexpected.&lt;/p&gt; &#xA;&lt;h5&gt;CONNECTION_ENDED&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;write CONNECTION_ENDED host:port&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This error is thrown if the user has called &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#teardown--cleanup&#34;&gt;&lt;code&gt;sql.end()&lt;/code&gt;&lt;/a&gt; and performed a query afterward.&lt;/p&gt; &#xA;&lt;h5&gt;CONNECTION_DESTROYED&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;write CONNECTION_DESTROYED host:port&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This error is thrown for any queries that were pending when the timeout to &lt;a href=&#34;https://raw.githubusercontent.com/porsager/postgres/master/#teardown--cleanup&#34;&gt;&lt;code&gt;sql.end({ timeout: X })&lt;/code&gt;&lt;/a&gt; was reached.&lt;/p&gt; &#xA;&lt;h5&gt;CONNECTION_CONNECT_TIMEOUT&lt;/h5&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;write CONNECTION_CONNECT_TIMEOUT host:port&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This error is thrown if the startup phase of the connection (tcp, protocol negotiation, and auth) took more than the default 30 seconds or what was specified using &lt;code&gt;connect_timeout&lt;/code&gt; or &lt;code&gt;PGCONNECT_TIMEOUT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;TypeScript support&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;postgres&lt;/code&gt; has TypeScript support. You can pass a row list type for your queries in this way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;interface User {&#xA;  id: number&#xA;  name: string&#xA;}&#xA;&#xA;const users = await sql&amp;lt;User[]&amp;gt;`SELECT * FROM users`&#xA;users[0].id // ok =&amp;gt; number&#xA;users[1].name // ok =&amp;gt; string&#xA;users[0].invalid // fails: `invalid` does not exists on `User`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, be sure to check the array length to avoid accessing properties of &lt;code&gt;undefined&lt;/code&gt; rows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const users = await sql&amp;lt;User[]&amp;gt;`SELECT * FROM users WHERE id = ${id}`&#xA;if (!users.length)&#xA;  throw new Error(&#39;Not found&#39;)&#xA;return users[0]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also prefer destructuring when you only care about a fixed number of rows. In this case, we recommend you to prefer using tuples to handle &lt;code&gt;undefined&lt;/code&gt; properly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const [user]: [User?] = await sql`SELECT * FROM users WHERE id = ${id}`&#xA;if (!user) // =&amp;gt; User | undefined&#xA;  throw new Error(&#39;Not found&#39;)&#xA;return user // =&amp;gt; User&#xA;&#xA;// NOTE:&#xA;const [first, second]: [User?] = await sql`SELECT * FROM users WHERE id = ${id}` // fails: `second` does not exist on `[User?]`&#xA;const [first, second] = await sql&amp;lt;[User?]&amp;gt;`SELECT * FROM users WHERE id = ${id}` // don&#39;t fail : `second: User | undefined`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We do our best to type all the public API, however types are not always updated when features are added or changed. Feel free to open an issue if you have trouble with types.&lt;/p&gt; &#xA;&lt;h2&gt;Migration tools&lt;/h2&gt; &#xA;&lt;p&gt;Postgres.js doesn&#39;t come with any migration solution since it&#39;s way out of scope, but here are some modules that support Postgres.js for migrations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/porsager/postgres-shift&#34;&gt;https://github.com/porsager/postgres-shift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lukeed/ley&#34;&gt;https://github.com/lukeed/ley&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JAForbes/pgmg&#34;&gt;https://github.com/JAForbes/pgmg&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thank you&lt;/h2&gt; &#xA;&lt;p&gt;A really big thank you to &lt;a href=&#34;https://twitter.com/jmsfbs&#34;&gt;@JAForbes&lt;/a&gt; who introduced me to Postgres and still holds my hand navigating all the great opportunities we have.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://twitter.com/andreacoiutti&#34;&gt;@ACXgit&lt;/a&gt; for initial tests and dogfooding.&lt;/p&gt; &#xA;&lt;p&gt;Also thanks to &lt;a href=&#34;https://github.com/ry&#34;&gt;Ryan Dahl&lt;/a&gt; for letting me have the &lt;code&gt;postgres&lt;/code&gt; npm package name.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hkirat/docker-roadmap</title>
    <updated>2023-10-17T01:32:14Z</updated>
    <id>tag:github.com,2023-10-17:/hkirat/docker-roadmap</id>
    <link href="https://github.com/hkirat/docker-roadmap" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>inrl-official/inrl-bot-md</title>
    <updated>2023-10-17T01:32:14Z</updated>
    <id>tag:github.com,2023-10-17:/inrl-official/inrl-bot-md</id>
    <link href="https://github.com/inrl-official/inrl-bot-md" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple Whatsapp Bot&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;INRL Multi Device Whatsapp Bot.&lt;/h2&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;SETUP&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Fork The Repo &lt;br&gt; &lt;a href=&#34;https://github.com/inrl-official/inrl-bot-md/fork&#34;&gt;&lt;img title=&#34;INRL-MD&#34; src=&#34;https://img.shields.io/badge/FORK INRL-MD-h?color=black&amp;amp;style=for-the-badge&amp;amp;logo=stackshare&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Scan Qr &lt;br&gt; &lt;a href=&#34;https://inrl-web.onrender.com/viwe/friendpage&#34;&gt;&lt;img title=&#34;SCAN QR&#34; src=&#34;https://img.shields.io/badge/SCAN QR CODE-h?color=black&amp;amp;style=for-the-badge&amp;amp;logo=msi&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;INRL-MD Deploy Methods&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Deploy To Heroku&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://inrl-web.onrender.com/deploy/heroku&#34;&gt;&lt;img title=&#34;INRL-MD Deploy Heroku&#34; src=&#34;https://img.shields.io/badge/DEPLOY HEROKU-h?color=black&amp;amp;style=for-the-badge&amp;amp;logo=heroku&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Deploy To Railway&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://inrl-web.onrender.com/info/deploy/railway&#34;&gt;&lt;img title=&#34;INRL-MD Deploy Railway&#34; src=&#34;https://img.shields.io/badge/DEPLOY RAILWAY-h?color=black&amp;amp;style=for-the-badge&amp;amp;logo=Railway&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Deploy To Koyeb&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://inrl-web.onrender.com/info/deploy/koyeb&#34;&gt;&lt;img title=&#34;INRL-MD Deploy Koyeb&#34; src=&#34;https://img.shields.io/badge/DEPLOY KOYEB-h?color=black&amp;amp;style=for-the-badge&amp;amp;logo=koyeb&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Deploy To Replit&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://replit.com/github/inrl-official/INRL-MD&#34;&gt;&lt;img title=&#34;INRL-MD Deploy Replit&#34; src=&#34;https://img.shields.io/badge/DEPLOY REPLIT-h?color=black&amp;amp;style=for-the-badge&amp;amp;logo=Replit&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Termux Guide&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;termux-setup-storage&#xA;apt update&#xA;apt upgrade&#xA;pkg update &amp;amp;&amp;amp; pkg upgrade&#xA;pkg install python&#xA;pkg install python2&#xA;pkg install bash&#xA;pkg install libwebp&#xA;pkg install git -y&#xA;pkg install nodejs -y &#xA;pkg install ffmpeg -y &#xA;pkg install wget&#xA;pkg install imagemagick -y&#xA;git clone Your Forked Github Url&#xA;cd inrl-bot-md&#xA;npm i&#xA;npm start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Support&lt;/h3&gt; &#xA;&lt;p&gt;SUPPORT GROUP&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://chat.whatsapp.com/F6VWuK677vB1kxXbV8m5II&#34;&gt;&lt;img alt=&#34;WhatsApp&#34; src=&#34;https://camo.githubusercontent.com/2157131829ac512183ee8f8b6c6f803688a4cc66a2e686602844e80478401a7c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a6f696e2047726f75702d3235443336363f7374796c653d666f722d7468652d6261646765266c6f676f3d7768617473617070266c6f676f436f6c6f723d7768697465&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;EXTERNAL PLUGINS&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/inrl-official/externel-plugins&#34;&gt;Click Here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt;</summary>
  </entry>
</feed>