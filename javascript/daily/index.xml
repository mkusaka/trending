<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-26T01:39:59Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tundeph/rev-mobile-app</title>
    <updated>2023-01-26T01:39:59Z</updated>
    <id>tag:github.com,2023-01-26:/tundeph/rev-mobile-app</id>
    <link href="https://github.com/tundeph/rev-mobile-app" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tasks mobile apps with React Native&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>TradeDoge/Crypto-Bot</title>
    <updated>2023-01-26T01:39:59Z</updated>
    <id>tag:github.com,2023-01-26:/TradeDoge/Crypto-Bot</id>
    <link href="https://github.com/TradeDoge/Crypto-Bot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Trading-Bot&lt;/p&gt;&lt;hr&gt;&lt;p&gt;trading-bot&lt;/p&gt; &#xA;&lt;p&gt;feel free to fork and improve or whatever. if you fork and modify please give credit. This is a tutorial to help run the crypto bot (javascript version)&lt;/p&gt; &#xA;&lt;p&gt;Letâ€™s get started.&lt;/p&gt; &#xA;&lt;p&gt;Part 1. Editing the settings.&lt;/p&gt; &#xA;&lt;p&gt;Open the bots main folder and find &#34;config.js&#34; file and open it with a text-editor:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/122376751/211582493-8a2b232f-1082-41c0-ac95-f445b614f17e.png&#34; alt=&#34;confige&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;1.Set your public address and private key or your wallet seed if you have a wallet that does not give you the private key&lt;/p&gt; &#xA;&lt;p&gt;2.Set the Network 1 = ETH , 2 = BNB , 3 = POLYGON&lt;/p&gt; &#xA;&lt;p&gt;3.Save config.js&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/122376751/211582535-70ad689e-da4a-453c-8b72-e19d8a38a622.png&#34; alt=&#34;itrunning&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;4.Open index.html in any web-browser.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/122376751/211582664-83dc42d4-7a0d-48dd-b91c-64190dcba8f4.jpg&#34; alt=&#34;results&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>TheAppleTucker/backend-GPT</title>
    <updated>2023-01-26T01:39:59Z</updated>
    <id>tag:github.com,2023-01-26:/TheAppleTucker/backend-GPT</id>
    <link href="https://github.com/TheAppleTucker/backend-GPT" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GPT is all you need for the backend&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/TheAppleTucker/backend-GPT/main/LLM-IS-BACKEND.jpeg&#34; alt=&#34;Galaxy brain meme (a) Writing a backend (b) hiring a backend engineer (c) Asking ChatGPT for a backend (d) The LLM is the backend&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;People have been saying Github Copilot will replace programmers. We think that&#39;s wrong. We have all powerful models and we want to restrict them to writing code? All code has bugs!&lt;/p&gt; &#xA;&lt;p&gt;Code is not the ideal way to encode business logic. Code must be reviewed, and it does what you tell it, not what you want. The proper format for business logic is human intelligence.&lt;/p&gt; &#xA;&lt;p&gt;So we thought, who needs python and ec2s and biz logic and postgres?&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ve built a entire Backend+Database powered by an LLM. It infers business logic based on the name of the API call and can persist a kilobyte of state!&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s the experience of the future:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Instruct the LLM on the purpose of the backend (i.e. &#34;This is a todo list app&#34;)&lt;/li&gt; &#xA; &lt;li&gt;Write the initial json blob for the database state (i.e. {todo_items: [{title: &#34;eat breakfast&#34;, completed: true}, {title: &#34;go to school&#34;, completed: false}]}&lt;/li&gt; &#xA; &lt;li&gt;Start making API calls! You now have infinite backend endpoints that will infer their own business logic and update the persistent state!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;p&gt;This is the future we imagine&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;You can iterate on your frontend without knowing exactly what the backend needs to look like.&lt;/li&gt; &#xA; &lt;li&gt;Backend gives you the wrong format? &lt;code&gt;https://backend-gpt.com/chess/get_board_state()&lt;/code&gt; -&amp;gt; &lt;code&gt;https://backend-gpt.com/chess/get_board_state_as_fen()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Mistype an API name? It doesn&#39;t matter!&lt;/li&gt; &#xA; &lt;li&gt;Serverless w/o the cold start: The only difference between your server and someone elses is the 1KB of state and the LLM instructions, these can be swapped out in milliseconds&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Still don&#39;t get it?&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s how it works in Parker&#39;s words&lt;/p&gt; &#xA;&lt;p&gt;We basically used GPT to handle all the backend logic for a todo-list app. We represented the state of the app as a json with some prepopulated entries which helped define the schema. Then we pass the prompt, the current state, and some user-inputted instruction/API call in and extract a response to the client + the new state. So the idea is that instead of writing backend routes, the LLM can handle all the basic CRUD logic for a simple app so instead of writing specific routes, you can input commands like add_five_housework_todos() or delete_last_two_todos() or sort_todos_alphabetically() . It tends to work better when the commands are expressed as functions/pseudo function calls but natural language instructions like delete last todos also work.&lt;/p&gt;</summary>
  </entry>
</feed>