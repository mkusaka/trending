<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-17T01:39:08Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>andersontr15/clean-code-javascript-es</title>
    <updated>2023-02-17T01:39:08Z</updated>
    <id>tag:github.com,2023-02-17:/andersontr15/clean-code-javascript-es</id>
    <link href="https://github.com/andersontr15/clean-code-javascript-es" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clean Code traducido al Español&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Repositorio original: &lt;a href=&#34;https://github.com/ryanmcdermott/clean-code-javascript&#34;&gt;ryanmcdermott/clean-code-javascript&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;clean-code-javascript&lt;/h1&gt; &#xA;&lt;h2&gt;Contenido&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#introducci%C3%B3n&#34;&gt;Introducción&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#variables&#34;&gt;Variables&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#funciones&#34;&gt;Funciones&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#objetos-y-estructuras-de-data&#34;&gt;Objetos y estructuras de data&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#clases&#34;&gt;Clases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#solid&#34;&gt;SOLID&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#pruebas&#34;&gt;Pruebas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#concurrencia&#34;&gt;Concurrencia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#resolver-los-errores&#34;&gt;Resolver los errores&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#formatear&#34;&gt;Formatear&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#comentarios&#34;&gt;Comentarios&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Introducción&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://www.osnews.com/images/comics/wtfm.jpg&#34; alt=&#34;Imagen gracioso de la estimación de la calidad de software como una cifra de cuantos expletivos que uno puede gritar al leer programas&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Los principios de la ingeniería de software, del libro de Robert C. Martin &lt;a href=&#34;https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882&#34;&gt;&lt;em&gt;Clean Code&lt;/em&gt;&lt;/a&gt;, adaptado para JavaScript. Esta no es una guía de estilo, en cambio, es una guía para crear software que sea reutilizable, comprensible y que se pueda mejorar con el tiempo.&lt;/p&gt; &#xA;&lt;p&gt;No hay que seguir tan estrictamente todos los principios en este libro, y vale la pena mencionar que hacia muchos de ellos habrá controversia en cuanto al consentimiento. Estas son reflexiones hechas después de muchos años de experiencia colectiva de los autores de &lt;em&gt;Clean Code&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Nuestra obra de ingeniería de software lleva poco más que 50 años como negocio, y aún estamos aprendiendo. Cuando la arquitectura de software llegue a ser tan vieja como la arquitectura en sí misma, quizás tengamos reglas más estrictas para seguir. Hasta entonces, dejemos que estas guías sirvan como ejemplo para medir la calidad del código en JavaScript que tú y tu equipo producen.&lt;/p&gt; &#xA;&lt;p&gt;Una cosa más: saber esto no te hará un mejor ingeniero inmediatamente, y tampoco trabajar con estas herramientas durante muchos años garantiza que nunca te equivocarás. Cualquier código empieza primero como un borrador, como arcilla mojada moldeándose en su forma final. Por último, arreglamos las imperfecciones cuando lo repasamos con nuestros compañeros de trabajo. No seas tan duro contigo mismo por los borradores iniciales que aún necesitan mejorar. ¡Trabaja más duro para mejorar el programa!&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Variables&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Utiliza nombres significativos y pronunciables para las variables&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const yyyymmdstr = moment().format(&#39;YYYY/MM/DD&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const fechaActual = moment().format(&#39;YYYY/MM/DD&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Utiliza el vocabulario igual para las variables del mismo tipo&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;conseguirInfoUsuario();&#xA;conseguirDataDelCliente();&#xA;conseguirRecordDelCliente();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;conseguirUsuario();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Utiliza nombres buscables&lt;/h3&gt; &#xA;&lt;p&gt;Nosotros leemos mucho más código que jamás escribiremos. Es importante que el código que escribimos sea legible y buscable. Cuando faltamos nombrar a las variables de manera buscable y legible, acabamos confundiendo a nuestros lectores. Echa un vistazo a las herramientas para ayudarte: &lt;a href=&#34;https://github.com/danielstjules/buddy.js&#34;&gt;buddy.js&lt;/a&gt; y &lt;a href=&#34;https://github.com/eslint/eslint/raw/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md&#34;&gt;ESLint&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Para qué rayos sirve 86400000? &#xA;setTimeout(hastaLaInfinidadYMasAlla, 86400000);&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Decláralos como variables globales de &#39;const&#39;.&#xA;const MILISEGUNDOS_EN_UN_DIA = 8640000;&#xA;&#xA;setTimeout(hastaLaInfinidadYMasAlla, MILISEGUNDOS_EN_UN_DIA);&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Utiliza variables explicativas&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const direccion = &#39;One Infinite Loop, Cupertino 95014&#39;;&#xA;const codigoPostalRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;&#xA;saveCityZipCode(direccion.match(codigoPostalRegex)[1], direccion.match(codigoPostalRegex)[2]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const direccion = &#39;One Infinite Loop, Cupertino 95014&#39;;&#xA;const codigoPostalRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;&#xA;const [, ciudad, codigoPostal] = direccion.match(codigoPostalRegex) || [];&#xA;guardarcodigoPostal(ciudad, codigoPostal);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar el mapeo mental&lt;/h3&gt; &#xA;&lt;p&gt;El explícito es mejor que el implícito.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const ubicaciones = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];&#xA;ubicaciones.forEach((u) =&amp;gt; {&#xA;  hazUnaCosa();&#xA;  hasMasCosas()&#xA;  // ...&#xA;  // ...&#xA;  // ...&#xA;  // Espera, para qué existe la &#39;u&#39;?&#xA;  ejecuta(u);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const ubicaciones = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];&#xA;ubicaciones.forEach((ubicacion) =&amp;gt; {&#xA;  hazUnaCosa();&#xA;  hazMasCosas()&#xA;  // ...&#xA;  // ...&#xA;  // ...&#xA;  ejecuta(ubicacion);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;No incluyas contexto innecesario&lt;/h3&gt; &#xA;&lt;p&gt;Si el nombre de tu clase/objeto te dice algo, no lo repitas de nuevo en el nombre de variable.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Coche = {&#xA;  cocheMarca: &#39;Honda&#39;,&#xA;  cocheModelo: &#39;Accord&#39;,&#xA;  cocheColor: &#39;Blue&#39;&#xA;};&#xA;&#xA;function pintarCoche(coche) {&#xA;  coche.cocheColor = &#39;Red&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Coche = {&#xA;  marca: &#39;Honda&#39;,&#xA;  modelo: &#39;Accord&#39;,&#xA;  color: &#39;Blue&#39;&#xA;};&#xA;&#xA;function pintarCoche(coche) {&#xA;  coche.color = &#39;Red&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Utiliza argumentos predefinidos en vez de utilizar condicionales&lt;/h3&gt; &#xA;&lt;p&gt;Los argumentos predefinidos muchas veces son más organizados que utilizar los condicionales. Se consciente que si tú los usas, tu función sólo tendrá valores para los argumentos de &lt;code&gt;undefined&lt;/code&gt;. Los demás valores de &#39;falso&#39; como &lt;code&gt;&#39;&#39;&lt;/code&gt;, &lt;code&gt;&#34;&#34;&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, y &lt;code&gt;NaN&lt;/code&gt;, no se reemplazan con un valor predefinido.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function crearMicroCerveceria(nombre) {&#xA;  const nombreDelMicroCerveceria = nombre || &#39;Hipster Brew Co.&#39;;&#xA;  // ...&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function crearMicroCerveceria(nombreDelMicroCerveceria = &#39;Hipster Brew Co.&#39;) {&#xA;  // ...&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Funciones&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Argumentos de funciones (2 o menos idealmente)&lt;/h3&gt; &#xA;&lt;p&gt;Limitar la cantidad de parámetros de tus funciones es increíblemente importante ya que hace que tus pruebas del código sean más fáciles. Al pasar los 3 argumentos, llegarás a un escenario de una explosión combinatoria en que hay que comprobar con pruebas muchos casos únicos con un argumento separado.&lt;/p&gt; &#xA;&lt;p&gt;Uno o dos argumentos es la situación ideal, y más que eso uno debe evitar si es posible. Todo lo que se puede consolidar se debe consolidar. Normalmente, si tienes más que dos argumentos, tu función sirve para hacer demasiado. En otros casos, es mejor refactorizar y hacerlo un objeto para encapsular las funciones extras.&lt;/p&gt; &#xA;&lt;p&gt;Ya que JavaScript te deja crear objetos cuando quieras sin incorporar la arquitectura de &#39;clases&#39;, se puede usar un objeto si necesitas muchos argumentos.&lt;/p&gt; &#xA;&lt;p&gt;Para hacerlo más obvio cuáles argumentos espera la función, se puede usar la sintaxis de ES2015/ES6: &#39;destructuración&#39;. Esta sintaxis tiene varias ventajas:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Cuando alguien se fija en el firme de la función, es inmediatamente claro cuáles argumentos se usan.&lt;/li&gt; &#xA; &lt;li&gt;Destructurar también copia los valores específicos y primitivos del objeto argumento que se le pasa a la función. Esto puede evitar los efectos extras. Ojo: objetos y arreglos que se destructuran del objeto argumento NO se copian.&lt;/li&gt; &#xA; &lt;li&gt;Los &#39;linters&#39; te pueden avisar cuales argumentos / propiedades no se usan, lo cual sería imposible sin destructurar.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function crearMenu(titulo, contexto, textoDelBoton, cancelable) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function crearMenu({ titulo, contexto, textoDelBoton, cancelable }) {&#xA;  // ...&#xA;}&#xA;&#xA;crearMenu({&#xA;  titulo: &#39;Foo&#39;,&#xA;  contexto: &#39;Bar&#39;,&#xA;  textoDelBoton: &#39;Baz&#39;,&#xA;  cancelable: true&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Las funciones deben tener una sola responsabilidad&lt;/h3&gt; &#xA;&lt;p&gt;Esta regla por mucho es la más importante en la ingeniería de software. Cuando las funciones sirven para hacer más que una sola cosa, se dificultan las pruebas, la composición y el entender. Cuando puedes aislar una función hasta tener solo una acción, se pueden mejorar más fácil y tu código llegue a ser mucho más limpio. Si solamente entiendes una cosa de esta guía, entiende esta regla y estarás adelantado de muchos desarrolladores.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function escribirClientes(clients) {&#xA;  clientes.forEach((cliente) =&amp;gt; {&#xA;    const recordDelCliente = database.busca(cliente);&#xA;    if (recordDelCliente.esActivo()) {&#xA;      escribir(cliente);&#xA;    }&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function escribirClientes(clientes) {&#xA;  clientes&#xA;    .filter(esActivoElCliente)&#xA;    .forEach(email);&#xA;}&#xA;&#xA;function esActivoElCliente(cliente) {&#xA;  const recordDelCliente = database.busca(cliente);&#xA;  return recordDelCliente.esActivo();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Los nombres de las funciones deben explicar lo que hacen&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function adelantarLaFechaPorUnDia(fecha, mes) {&#xA;  // ...&#xA;}&#xA;&#xA;const fecha = new Date();&#xA;// Es difícil entender del nombre lo que hace la función &#xA;adelantarLaFechaPorUnDia(fecha, 1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function agregarMesAlDia(mes, fecha) {&#xA;  // ...&#xA;}&#xA;&#xA;const fecha = new Date();&#xA;agregarMesAlDia(1, fecha);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Las funciones deben tener solo un nivel de abstracción&lt;/h3&gt; &#xA;&lt;p&gt;Cuando tienes más que un nivel de abstracción tu función suele servir para hacer demasiado. Crear varias funciones más pequeñas se debe a mejor reutilización y comprobación más fácil.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function parseBetterJSAlternative(code) {&#xA;  const REGEXES = [&#xA;    // ...&#xA;  ];&#xA;&#xA;  const statements = code.split(&#39; &#39;);&#xA;  const tokens = [];&#xA;  REGEXES.forEach((REGEX) =&amp;gt; {&#xA;    statements.forEach((statement) =&amp;gt; {&#xA;      // ...&#xA;    });&#xA;  });&#xA;&#xA;  const ast = [];&#xA;  tokens.forEach((token) =&amp;gt; {&#xA;    // lex...&#xA;  });&#xA;&#xA;  ast.forEach((node) =&amp;gt; {&#xA;    // parse...&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function tokenize(code) {&#xA;  const REGEXES = [&#xA;    // ...&#xA;  ];&#xA;&#xA;  const statements = code.split(&#39; &#39;);&#xA;  const tokens = [];&#xA;  REGEXES.forEach((REGEX) =&amp;gt; {&#xA;    statements.forEach((statement) =&amp;gt; {&#xA;      tokens.push( /* ... */ );&#xA;    });&#xA;  });&#xA;&#xA;  return tokens;&#xA;}&#xA;&#xA;function lexer(tokens) {&#xA;  const ast = [];&#xA;  tokens.forEach((token) =&amp;gt; {&#xA;    ast.push( /* ... */ );&#xA;  });&#xA;&#xA;  return ast;&#xA;}&#xA;&#xA;function parseBetterJSAlternative(code) {&#xA;  const tokens = tokenize(code);&#xA;  const ast = lexer(tokens);&#xA;  ast.forEach((node) =&amp;gt; {&#xA;    // parse...&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Eliminar el código duplicado&lt;/h3&gt; &#xA;&lt;p&gt;Haz tanto como puedas para evitar código duplicado. El código duplicado es malo ya que significa que hay varios lugares donde hay que actualizar algo si un cambio es necesario en tu lógico.&lt;/p&gt; &#xA;&lt;p&gt;Imagínate que estás en un restaurante y necesitas organizar tu inventario: todos tus tomates, cebolla, pimientos y tal. Si tienes varias listas donde organizas el inventario, cada lista se tendrá que actualizar en cuanto se baja tu inventario. En cambio, si logras tener una sola lista, solo se actualizará en un lugar a la hora de apuntar el inventario.&lt;/p&gt; &#xA;&lt;p&gt;Muchas veces tienes código duplicado se debe al hecho de tener dos o más cosas semejantes. Estos archivos pueden comparten varias cosas, pero sus diferencias te obligan separarlos para tener dos o más funciones que hacen cosas muy similares. Remover el código duplicado significa que se puede hacer la misma cosa que un solo función/módulo/clase.&lt;/p&gt; &#xA;&lt;p&gt;Obtener la abstracción correcta es crítica y por eso debes de adherir a los principios de SOLID que se explican en la sección de Clases. Las malas abstracciones pueden ser aún peores que el código duplicado, ¡así que ten cuidado! Es decir, si puedes hacer una buena abstracción, ¡hazla! No te repitas, si no te darás cuenta de que andas actualizando mucho código en varios lugares a la hora de implementar un cambio.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function showDeveloperList(developers) {&#xA;  developers.forEach((developer) =&amp;gt; {&#xA;    const expectedSalary = developer.calculateExpectedSalary();&#xA;    const experience = developer.getExperience();&#xA;    const githubLink = developer.getGithubLink();&#xA;    const data = {&#xA;      expectedSalary,&#xA;      experience,&#xA;      githubLink&#xA;    };&#xA;&#xA;    render(data);&#xA;  });&#xA;}&#xA;&#xA;function showManagerList(managers) {&#xA;  managers.forEach((manager) =&amp;gt; {&#xA;    const expectedSalary = manager.calculateExpectedSalary();&#xA;    const experience = manager.getExperience();&#xA;    const portfolio = manager.getMBAProjects();&#xA;    const data = {&#xA;      expectedSalary,&#xA;      experience,&#xA;      portfolio&#xA;    };&#xA;&#xA;    render(data);&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function showEmployeeList(employees) {&#xA;  employees.forEach((employee) =&amp;gt; {&#xA;    const expectedSalary = employee.calculateExpectedSalary();&#xA;    const experience = employee.getExperience();&#xA;&#xA;    let portfolio = employee.getGithubLink();&#xA;&#xA;    if (employee.type === &#39;manager&#39;) {&#xA;      portfolio = employee.getMBAProjects();&#xA;    }&#xA;&#xA;    const data = {&#xA;      expectedSalary,&#xA;      experience,&#xA;      portfolio&#xA;    };&#xA;&#xA;    render(data);&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Crear objetos predefinidos con Object.assign&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const menuConfig = {&#xA;  title: null,&#xA;  body: &#39;Bar&#39;,&#xA;  buttonText: null,&#xA;  cancellable: true&#xA;};&#xA;&#xA;function createMenu(config) {&#xA;  config.title = config.title || &#39;Foo&#39;;&#xA;  config.body = config.body || &#39;Bar&#39;;&#xA;  config.buttonText = config.buttonText || &#39;Baz&#39;;&#xA;  config.cancellable = config.cancellable === undefined ? config.cancellable : true;&#xA;}&#xA;&#xA;createMenu(menuConfig);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const menuConfig = {&#xA;  title: &#39;Order&#39;,&#xA;  // El usuario no tenía la clave &#39;body&#39;&#xA;  buttonText: &#39;Send&#39;,&#xA;  cancellable: true&#xA;};&#xA;&#xA;function createMenu(config) {&#xA;  config = Object.assign({&#xA;    title: &#39;Foo&#39;,&#xA;    body: &#39;Bar&#39;,&#xA;    buttonText: &#39;Baz&#39;,&#xA;    cancellable: true&#xA;  }, config);&#xA;  // el variable &#39;config&#39; ahora iguala: {title: &#34;Order&#34;, body: &#34;Bar&#34;, buttonText: &#34;Send&#34;, cancellable: true}&#xA;  // ...&#xA;}&#xA;&#xA;createMenu(menuConfig);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;No utilices &#39;marcadores&#39; como parámetros de las funciones&lt;/h3&gt; &#xA;&lt;p&gt;Los marcadores existen para decirle a tu usuario que esta función hace más que una sola cosa. Como se ha mencionado antes las funciones deben hacer una sola cosa. Divide tus funciones en varias funciones más pequeñas si se adhieren a distintos métodos basados en un booleano.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function createFile(name, temp) {&#xA;  if (temp) {&#xA;    fs.create(`./temp/${name}`);&#xA;  } else {&#xA;    fs.create(name);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function createFile(name) {&#xA;  fs.create(name);&#xA;}&#xA;&#xA;function createTempFile(name) {&#xA;  createFile(`./temp/${name}`);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar que las funciones produzcan efectos extras (parte 1)&lt;/h3&gt; &#xA;&lt;p&gt;Una función produce un efecto extra si hace cualquier cosa más que solo tomar un valor y volverlo/los). Un efecto extra podría ser escribir a un archivo, modificar un variable global, o accidentalmente enviar todo tu dinero a un desconfiado.&lt;/p&gt; &#xA;&lt;p&gt;Bueno, las funciones necesitan tener efectos extras a menudo. Como el ejemplo anterior, puede que sea necesario escribir hasta un archivo. En ese caso, hay que centralizar en el &#39;por qué&#39; de lo que estás haciendo. No tengas varias funciones y clases que escriben hasta un archivo particular. En cambio, crea un &#39;servicio&#39; que se dedica a eso: uno y solo un servicio.&lt;/p&gt; &#xA;&lt;p&gt;El punto clave aquí es evitar las equivocaciones comunes como compartir &#39;estado&#39; entre objeto sin ninguna estructura, utilizar tipos de data mutables que se pueden escribir hasta lo que sea, y no centralizar donde se ocurren los efectos extras. Si puedes conseguir esto, serás más feliz que la mayoría de los demás programadores.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Global variable referenced by following function.&#xA;// If we had another function that used this name, now it&#39;d be an array and it could break it.&#xA;let name = &#39;Ryan McDermott&#39;;&#xA;&#xA;function splitIntoFirstAndLastName() {&#xA;  name = name.split(&#39; &#39;);&#xA;}&#xA;&#xA;splitIntoFirstAndLastName();&#xA;&#xA;console.log(name); // [&#39;Ryan&#39;, &#39;McDermott&#39;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function splitIntoFirstAndLastName(name) {&#xA;  return name.split(&#39; &#39;);&#xA;}&#xA;&#xA;const name = &#39;Ryan McDermott&#39;;&#xA;const newName = splitIntoFirstAndLastName(name);&#xA;&#xA;console.log(name); // &#39;Ryan McDermott&#39;;&#xA;console.log(newName); // [&#39;Ryan&#39;, &#39;McDermott&#39;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar los efectos extras(parte 2)&lt;/h3&gt; &#xA;&lt;p&gt;En JavaScript, los primitivos se pasan por valores y los objetos/arrays se pasan por referencia. En el caso de los objetos y los array, si tu función hace un cambio en la shopping cart array, por ejemplo, con agregar una cosa a la hora de comprar, resulta que todas las demás funciones que utilizan este array estarán afectadas. Esto puede ser bueno o malo. Imaginemos una situación mala:&lt;/p&gt; &#xA;&lt;p&gt;El usuario le da click a &#34;Comprar&#34;, un botón que invoca la función de &#34;comprar&#34;. Esta función hace una solicitud del red y envía el array de &#39;cart&#39; hasta el servidor. Debido a la conexión mala del red, la función sigue intentando invocarse para mandar la solicitud. Ahora, que pasa mientras tanto cuando el usuario le da click otra vez al botón en una cosa que no querían antes de que empezase la solicitud del red? Bueno, si pasa eso y comienza la solicitud del red, la función de &#39;comprar&#39; mandara sin querer la cosa que estaba agregada accidentalmente ya que tiene una referencia al array de &#39;shopping cart&#39; que la función &#39;addItemToCart&#39; modifico con agregar una cosa no deseada.&lt;/p&gt; &#xA;&lt;p&gt;Una buena solución seria que la función &#39;addItemToCart&#39; siempre copiara la &#39;carta&#39;, editarla, y devolvérsela a la copia. Esto asegura que ninguna otra función relacionada se afectará por estos cambios.&lt;/p&gt; &#xA;&lt;p&gt;Dos cosas para mencionar con esta solución:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Puede que existan escenarios donde de verdad quieres modificar el objeto de input, pero cuando adoptas esta práctica de programar, te darás cuentas de que estos casos son bastante únicos.&lt;/li&gt; &#xA; &lt;li&gt;Copiar objetos grandes pueden ser muy caros en cuanto a la velocidad y calidad de tu programa. Afortunadamente, no hay mucho problema con esto ya que existen muchas &lt;a href=&#34;https://facebook.github.io/immutable-js/&#34;&gt;recursos&lt;/a&gt; que nos dejan lograr el copiar de objetos y arrays sin perder actuación.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const addItemToCart = (cart, item) =&amp;gt; {&#xA;  cart.push({ item, date: Date.now() });&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const addItemToCart = (cart, item) =&amp;gt; {&#xA;  return [...cart, { item, date : Date.now() }];&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;No intentes cambiar las funciones globales&lt;/h3&gt; &#xA;&lt;p&gt;Polucionar las construcciones globales no es buen costumbre en JavaScript ya que se puede afrontar con otra biblioteca y el usuario de tu API no se daría cuenta hasta que reciba una excepción cuando ya está en producción el código. Pensemos en un ejemplo: que pasaría si quisieras extender los métodos nativos de la clase Array para tener un método de &#39;diff&#39; en que se podría mostrar la diferencia entre dos arrays? Podrías escribir una nueva función hasta el prototipo del &lt;code&gt;Array.prototype&lt;/code&gt;, pero eso también podría causar problemas con otra biblioteca que contenía el método igual. Bueno, ¿qué pasaría si la otra biblioteca solamente usaba ‘diff’ para averiguar la diferencia entre el primer elemento y el último elemento del array? Por eso hay que utilizar las clases de ES2015/ES6 y extender el global de &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array.prototype.diff = function diff(comparisonArray) {&#xA;  const hash = new Set(comparisonArray);&#xA;  return this.filter(elem =&amp;gt; !hash.has(elem));&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class SuperArray extends Array {&#xA;  diff(comparisonArray) {&#xA;    const hash = new Set(comparisonArray);&#xA;    return this.filter(elem =&amp;gt; !hash.has(elem));&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Favorece a la programación funcional en vez de la programación imperativa&lt;/h3&gt; &#xA;&lt;p&gt;JavaScript no es un idioma funcional tal como es Haskell, pero tiene su propio sabor funcional. Los idiomas funcionales son más limpios y fáciles de comprobar. Favorece este estilo de programar cuando puedes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const programmerOutput = [&#xA;  {&#xA;    name: &#39;Uncle Bobby&#39;,&#xA;    linesOfCode: 500&#xA;  }, {&#xA;    name: &#39;Suzie Q&#39;,&#xA;    linesOfCode: 1500&#xA;  }, {&#xA;    name: &#39;Jimmy Gosling&#39;,&#xA;    linesOfCode: 150&#xA;  }, {&#xA;    name: &#39;Gracie Hopper&#39;,&#xA;    linesOfCode: 1000&#xA;  }&#xA;];&#xA;&#xA;let totalOutput = 0;&#xA;&#xA;for (let i = 0; i &amp;lt; programmerOutput.length; i++) {&#xA;  totalOutput += programmerOutput[i].linesOfCode;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const programmerOutput = [&#xA;  {&#xA;    name: &#39;Uncle Bobby&#39;,&#xA;    linesOfCode: 500&#xA;  }, {&#xA;    name: &#39;Suzie Q&#39;,&#xA;    linesOfCode: 1500&#xA;  }, {&#xA;    name: &#39;Jimmy Gosling&#39;,&#xA;    linesOfCode: 150&#xA;  }, {&#xA;    name: &#39;Gracie Hopper&#39;,&#xA;    linesOfCode: 1000&#xA;  }&#xA;];&#xA;&#xA;const INITIAL_VALUE = 0;&#xA;&#xA;const totalOutput = programmerOutput&#xA;  .map((programmer) =&amp;gt; programmer.linesOfCode)&#xA;  .reduce((acc, linesOfCode) =&amp;gt; acc + linesOfCode, INITIAL_VALUE);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Encapsular los condicionales&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (fsm.state === &#39;fetching&#39; &amp;amp;&amp;amp; isEmpty(listNode)) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function shouldShowSpinner(fsm, listNode) {&#xA;  return fsm.state === &#39;fetching&#39; &amp;amp;&amp;amp; isEmpty(listNode);&#xA;}&#xA;&#xA;if (shouldShowSpinner(fsmInstance, listNodeInstance)) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar los condicionales negativos&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function isDOMNodeNotPresent(node) {&#xA;  // ...&#xA;}&#xA;&#xA;if (!isDOMNodeNotPresent(node)) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function isDOMNodePresent(node) {&#xA;  // ...&#xA;}&#xA;&#xA;if (isDOMNodePresent(node)) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar los condicionales&lt;/h3&gt; &#xA;&lt;p&gt;Esto parece ser un reto imposible. Al escuchar esto por primera vez, la mayoría de la gente dirá: &#34;como se supone que hago sin una declaración de &#39;if&#39;?&#34; Bueno, la respuesta es que puedes utilizar para lograr los mismos retos en muchos escenarios. La segunda pregunta suele ser: &#34;bueno, eso está bien, pero por qué voy a querer hacer eso?&#34; La respuesta yace en un concepto anterior que ya hemos aprendido: una función solo debe hacer una sola cosa. Cuando tienes clases y funciones que contienen declaraciones de &lt;code&gt;if&lt;/code&gt;, le dices al usuario que tu función hace más que una sola cosa. Recuerda, solo haz una cosa.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Airplane {&#xA;  // ...&#xA;  getCruisingAltitude() {&#xA;    switch (this.type) {&#xA;      case &#39;777&#39;:&#xA;        return this.getMaxAltitude() - this.getPassengerCount();&#xA;      case &#39;Air Force One&#39;:&#xA;        return this.getMaxAltitude();&#xA;      case &#39;Cessna&#39;:&#xA;        return this.getMaxAltitude() - this.getFuelExpenditure();&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Airplane {&#xA;  // ...&#xA;}&#xA;&#xA;class Boeing777 extends Airplane {&#xA;  // ...&#xA;  getCruisingAltitude() {&#xA;    return this.getMaxAltitude() - this.getPassengerCount();&#xA;  }&#xA;}&#xA;&#xA;class AirForceOne extends Airplane {&#xA;  // ...&#xA;  getCruisingAltitude() {&#xA;    return this.getMaxAltitude();&#xA;  }&#xA;}&#xA;&#xA;class Cessna extends Airplane {&#xA;  // ...&#xA;  getCruisingAltitude() {&#xA;    return this.getMaxAltitude() - this.getFuelExpenditure();&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar la comprobación de tipos (parte 1)&lt;/h3&gt; &#xA;&lt;p&gt;JavaScript es un idioma no tecleado, por lo cual significa que tus funciones pueden aceptar cualquier tipo de argumento. A veces te aprovechas de esta libertad y tienes ganas de hacer comprobación de &lt;code&gt;tipos&lt;/code&gt; dentro de tus funciones. Hay muchas maneras de evitar tener que hacer esto. La primeras cosas para considerar son APIs consistentes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function travelToTexas(vehicle) {&#xA;  if (vehicle instanceof Bicycle) {&#xA;    vehicle.pedal(this.currentLocation, new Location(&#39;texas&#39;));&#xA;  } else if (vehicle instanceof Car) {&#xA;    vehicle.drive(this.currentLocation, new Location(&#39;texas&#39;));&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function travelToTexas(vehicle) {&#xA;  vehicle.move(this.currentLocation, new Location(&#39;texas&#39;));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar la comprobación de tipos (parte 2)&lt;/h3&gt; &#xA;&lt;p&gt;Si estás trabajando con los valores primitivos básicos como &lt;code&gt;strings&lt;/code&gt;, enteros y arrays y que no puedes utilizar polimorfismo, pero existe la necesidad de comprobar los &lt;code&gt;tipos&lt;/code&gt;, debes considerar utilizando TypeScript. Es un alternativo excelente a JavaScript, y te provee con los tipos estáticos encima del sintaxis estándar de JavaScript. El problema con comprobar los tipos en JavaScript es que para hacerlo bien resulta en mucho más verbos que no vale la pena al lado de la legibilidad disminuida que viene a junto con esta solución. Intenta mantener limpio tu código de JavaScript, escribe buenas pruebas, y haz buenas revisiones de código. Eso dicho, haz todo lo de arriba, pero con TypeScript (por lo cual, como dije, es buen alternativo).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function combine(val1, val2) {&#xA;  if (typeof val1 === &#39;number&#39; &amp;amp;&amp;amp; typeof val2 === &#39;number&#39; ||&#xA;      typeof val1 === &#39;string&#39; &amp;amp;&amp;amp; typeof val2 === &#39;string&#39;) {&#xA;    return val1 + val2;&#xA;  }&#xA;&#xA;  throw new Error(&#39;Must be of type String or Number&#39;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function combine(val1, val2) {&#xA;  return val1 + val2;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;No optimices demasiado&lt;/h3&gt; &#xA;&lt;p&gt;Los navegadores modernos hacen mucha optimización en el fondo a la hora de ejecutar. Muchas veces, malgastas tu tiempo si optimizas. &lt;a href=&#34;https://github.com/petkaantonov/bluebird/wiki/Optimization-killers&#34;&gt;Hay buenos recursos para esto&lt;/a&gt; para ver donde carece de optimizar tu código. Enfócate en esos huecos donde puedes optimizar, hasta que se puedan arreglar si es posible.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#xA;// On old browsers, each iteration with uncached `list.length` would be costly&#xA;// because of `list.length` recomputation. In modern browsers, this is optimized.&#xA;for (let i = 0, len = list.length; i &amp;lt; len; i++) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (let i = 0; i &amp;lt; list.length; i++) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Eliminar el código muerto&lt;/h3&gt; &#xA;&lt;p&gt;El código muerto es tan elegante como el código duplicado. No hay razón para guardarlo. Si no se usa, ¡elimínalo! Aun estará en tu historia del control versión si de verdad lo necesitas.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function oldRequestModule(url) {&#xA;  // ...&#xA;}&#xA;&#xA;function newRequestModule(url) {&#xA;  // ...&#xA;}&#xA;&#xA;const req = newRequestModule;&#xA;inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function newRequestModule(url) {&#xA;  // ...&#xA;}&#xA;&#xA;const req = newRequestModule;&#xA;inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Objetos y estructuras de data&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Utiliza getters y setters&lt;/h3&gt; &#xA;&lt;p&gt;Utilizar los getters y setters para acceder data dentro de los objetos puede ser mejor que simplemente buscar una propiedad. &#34;Por qué?&#34; Bueno, aquí te dejo con una lista desorganizada de las razones:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cuando quieres hacer algo más allá de acceder una propiedad de objeto, no tienes qué buscar todos los accesorios en tu programa.&lt;/li&gt; &#xA; &lt;li&gt;Hace que implementar validación sea más fácil cuando construyes un &lt;code&gt;set&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Encapsula la representación internal&lt;/li&gt; &#xA; &lt;li&gt;Facilita la incorporación de apuntar errores de acceder y crear&lt;/li&gt; &#xA; &lt;li&gt;Puedes cargar de manera vaga las propiedades del objeto, digamos de un servidor por ejemplo&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function makeBankAccount() {&#xA;  // ...&#xA;&#xA;  return {&#xA;    balance: 0,&#xA;    // ...&#xA;  };&#xA;}&#xA;&#xA;const account = makeBankAccount();&#xA;account.balance = 100;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function makeBankAccount() {&#xA;  // this one is private&#xA;  let balance = 0;&#xA;&#xA;  // a &#34;getter&#34;, made public via the returned object below&#xA;  function getBalance() {&#xA;    return balance;&#xA;  }&#xA;&#xA;  // a &#34;setter&#34;, made public via the returned object below&#xA;  function setBalance(amount) {&#xA;    // ... validate before updating the balance&#xA;    balance = amount;&#xA;  }&#xA;&#xA;  return {&#xA;    // ...&#xA;    getBalance,&#xA;    setBalance,&#xA;  };&#xA;}&#xA;&#xA;const account = makeBankAccount();&#xA;account.setBalance(100);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Haz que los objetos tengan miembros privados&lt;/h3&gt; &#xA;&lt;p&gt;Esto se puede lograr con &lt;code&gt;closures&lt;/code&gt; (con ES5 y antes)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#xA;const Employee = function(name) {&#xA;  this.name = name;&#xA;};&#xA;&#xA;Employee.prototype.getName = function getName() {&#xA;  return this.name;&#xA;};&#xA;&#xA;const employee = new Employee(&#39;John Doe&#39;);&#xA;console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe&#xA;delete employee.name;&#xA;console.log(`Employee name: ${employee.getName()}`); // Employee name: undefined&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function makeEmployee(name) {&#xA;  return {&#xA;    getName() {&#xA;      return name;&#xA;    },&#xA;  };&#xA;}&#xA;&#xA;const employee = makeEmployee(&#39;John Doe&#39;);&#xA;console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe&#xA;delete employee.name;&#xA;console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Clases&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Prefiere ES2015/ES6 clases en vez de funciones normales de ES5&lt;/h3&gt; &#xA;&lt;p&gt;Es muy difícil para obtener una herencia legible de las clases, las construcción y las definiciones de los métodos para las clases de ES5. Si necesitas la herencia (y puede que no la vayas a necesitar), entonces prefiere a las clases de ES2015/ES6. Sin embargo, prefiere funciones pequeñas hasta que necesites objetos más grandes y complejos.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Animal = function(age) {&#xA;  if (!(this instanceof Animal)) {&#xA;    throw new Error(&#39;Instantiate Animal with `new`&#39;);&#xA;  }&#xA;&#xA;  this.age = age;&#xA;};&#xA;&#xA;Animal.prototype.move = function move() {};&#xA;&#xA;const Mammal = function(age, furColor) {&#xA;  if (!(this instanceof Mammal)) {&#xA;    throw new Error(&#39;Instantiate Mammal with `new`&#39;);&#xA;  }&#xA;&#xA;  Animal.call(this, age);&#xA;  this.furColor = furColor;&#xA;};&#xA;&#xA;Mammal.prototype = Object.create(Animal.prototype);&#xA;Mammal.prototype.constructor = Mammal;&#xA;Mammal.prototype.liveBirth = function liveBirth() {};&#xA;&#xA;const Human = function(age, furColor, languageSpoken) {&#xA;  if (!(this instanceof Human)) {&#xA;    throw new Error(&#39;Instantiate Human with `new`&#39;);&#xA;  }&#xA;&#xA;  Mammal.call(this, age, furColor);&#xA;  this.languageSpoken = languageSpoken;&#xA;};&#xA;&#xA;Human.prototype = Object.create(Mammal.prototype);&#xA;Human.prototype.constructor = Human;&#xA;Human.prototype.speak = function speak() {};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Animal {&#xA;  constructor(age) {&#xA;    this.age = age;&#xA;  }&#xA;&#xA;  move() { /* ... */ }&#xA;}&#xA;&#xA;class Mammal extends Animal {&#xA;  constructor(age, furColor) {&#xA;    super(age);&#xA;    this.furColor = furColor;&#xA;  }&#xA;&#xA;  liveBirth() { /* ... */ }&#xA;}&#xA;&#xA;class Human extends Mammal {&#xA;  constructor(age, furColor, languageSpoken) {&#xA;    super(age, furColor);&#xA;    this.languageSpoken = languageSpoken;&#xA;  }&#xA;&#xA;  speak() { /* ... */ }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Utiliza la agregación de métodos&lt;/h3&gt; &#xA;&lt;p&gt;Este modelo es muy útil en JavaScript y puede que lo veas en muchas bibliotecas como jQuery y Lodash. También permite que tu código sea expresivo y menos verboso. Por eso, digo, utiliza el encadenamiento de métodos y échale un vistazo a lo limpio que llega a ser tu código. En tus funciones de clases, simplemente devuelve el &lt;code&gt;this&lt;/code&gt; al final de cada función y asi puedes seguir encadenando los metodos de tu clase.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Car {&#xA;  constructor() {&#xA;    this.make = &#39;Honda&#39;;&#xA;    this.model = &#39;Accord&#39;;&#xA;    this.color = &#39;white&#39;;&#xA;  }&#xA;&#xA;  setMake(make) {&#xA;    this.make = make;&#xA;  }&#xA;&#xA;  setModel(model) {&#xA;    this.model = model;&#xA;  }&#xA;&#xA;  setColor(color) {&#xA;    this.color = color;&#xA;  }&#xA;&#xA;  save() {&#xA;    console.log(this.make, this.model, this.color);&#xA;  }&#xA;}&#xA;&#xA;const car = new Car();&#xA;car.setColor(&#39;pink&#39;);&#xA;car.setMake(&#39;Ford&#39;);&#xA;car.setModel(&#39;F-150&#39;);&#xA;car.save();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Car {&#xA;  constructor() {&#xA;    this.make = &#39;Honda&#39;;&#xA;    this.model = &#39;Accord&#39;;&#xA;    this.color = &#39;white&#39;;&#xA;  }&#xA;&#xA;  setMake(make) {&#xA;    this.make = make;&#xA;    // NOTE: Returning this for chaining&#xA;    return this;&#xA;  }&#xA;&#xA;  setModel(model) {&#xA;    this.model = model;&#xA;    // NOTE: Returning this for chaining&#xA;    return this;&#xA;  }&#xA;&#xA;  setColor(color) {&#xA;    this.color = color;&#xA;    // NOTE: Returning this for chaining&#xA;    return this;&#xA;  }&#xA;&#xA;  save() {&#xA;    console.log(this.make, this.model, this.color);&#xA;    // NOTE: Returning this for chaining&#xA;    return this;&#xA;  }&#xA;}&#xA;&#xA;const car = new Car()&#xA;  .setColor(&#39;pink&#39;)&#xA;  .setMake(&#39;Ford&#39;)&#xA;  .setModel(&#39;F-150&#39;)&#xA;  .save();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Prefiere composición en vez de la herencia&lt;/h3&gt; &#xA;&lt;p&gt;Como se ha dicho antes famosamente en el libro de &lt;a href=&#34;https://en.wikipedia.org/wiki/Design_Patterns&#34;&gt;&lt;em&gt;Design Patterns&lt;/em&gt;&lt;/a&gt; escrito por el &lt;code&gt;Gang of Four&lt;/code&gt;, debes preferir composición en vez de la herencia cuando puedas. Hay muchas razones para utilizar estos dos modelos. El punto importante aquí es que tu mente naturalmente quiere utilizar la herencia, así que intenta pensar si composición también podría resolver tu problema. En algunos casos, puede que sea la solución.&lt;/p&gt; &#xA;&lt;p&gt;Puede que te preguntes, ¿”cuando debería de utilizar la herencia?&#34; Bueno, depende de tu problema del momento, pero esta sería una lista decente de cuando tiene más sentido utilizarla que la composición&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Tu herencia representa una relación de &#34;es-un&#34; y no un &#34;tener-un&#34; (Humano-&amp;gt;Animal vs Usuario-&amp;gt;Detalles del Usuario)&lt;/li&gt; &#xA; &lt;li&gt;Puedes reutilizar tu código de las clases bases (Los humanos pueden moverse como todos los animales)&lt;/li&gt; &#xA; &lt;li&gt;Quieres hacer cambios globales a las clases derivadas con cambiar una clase base. (Cambiar el gasto calórico de todos los animales cuando se mueven)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Employee {&#xA;  constructor(name, email) {&#xA;    this.name = name;&#xA;    this.email = email;&#xA;  }&#xA;&#xA;  // ...&#xA;}&#xA;&#xA;// Bad because Employees &#34;have&#34; tax data. EmployeeTaxData is not a type of Employee&#xA;class EmployeeTaxData extends Employee {&#xA;  constructor(ssn, salary) {&#xA;    super();&#xA;    this.ssn = ssn;&#xA;    this.salary = salary;&#xA;  }&#xA;&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class EmployeeTaxData {&#xA;  constructor(ssn, salary) {&#xA;    this.ssn = ssn;&#xA;    this.salary = salary;&#xA;  }&#xA;&#xA;  // ...&#xA;}&#xA;&#xA;class Employee {&#xA;  constructor(name, email) {&#xA;    this.name = name;&#xA;    this.email = email;&#xA;  }&#xA;&#xA;  setTaxData(ssn, salary) {&#xA;    this.taxData = new EmployeeTaxData(ssn, salary);&#xA;  }&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;SOLID&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;El principio único de responsabilidad (SRP)&lt;/h3&gt; &#xA;&lt;p&gt;Como se menciona en &lt;em&gt;Clean Code&lt;/em&gt;, &#34;Nunca debe existir más que una sola razón para cambiar una clase&#34;. Vale la pena decir que es normal querer llenar una &#39;clase&#39; con muchas funciones, igual que cuando solo te permiten llevar una maleta en el vuelo. El problema existe en que tu &#39;clase&#39; no estará cohesiva conceptualmente y existirá muchas razones para cambiarse. Minimizar la cantidad de veces que necesitas cambiar una clase es importante. Es importante ya que con demasiada funcionalidad viene dificultad de modificarlo y entender cómo afecta a otros módulos dependientes en tu programa.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class UserSettings {&#xA;  constructor(user) {&#xA;    this.user = user;&#xA;  }&#xA;&#xA;  changeSettings(settings) {&#xA;    if (this.verifyCredentials()) {&#xA;      // ...&#xA;    }&#xA;  }&#xA;&#xA;  verifyCredentials() {&#xA;    // ...&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class UserAuth {&#xA;  constructor(user) {&#xA;    this.user = user;&#xA;  }&#xA;&#xA;  verifyCredentials() {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;&#xA;class UserSettings {&#xA;  constructor(user) {&#xA;    this.user = user;&#xA;    this.auth = new UserAuth(user);&#xA;  }&#xA;&#xA;  changeSettings(settings) {&#xA;    if (this.auth.verifyCredentials()) {&#xA;      // ...&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Principio de abierto/cerrado (OCP)&lt;/h3&gt; &#xA;&lt;p&gt;Como dijo Bertrand Meyer, &#34;las entidades de software (clases, módulos, funciones, etc.) deben abrirse para extensión, pero cerrarse para modificación. ¿Qué significa eso? Bueno, este principio básicamente nos dice que debes permitir que tus usuarios introduzcan nuevas funcionalidades sin cambiar el código existente.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class AjaxAdapter extends Adapter {&#xA;  constructor() {&#xA;    super();&#xA;    this.name = &#39;ajaxAdapter&#39;;&#xA;  }&#xA;}&#xA;&#xA;class NodeAdapter extends Adapter {&#xA;  constructor() {&#xA;    super();&#xA;    this.name = &#39;nodeAdapter&#39;;&#xA;  }&#xA;}&#xA;&#xA;class HttpRequester {&#xA;  constructor(adapter) {&#xA;    this.adapter = adapter;&#xA;  }&#xA;&#xA;  fetch(url) {&#xA;    if (this.adapter.name === &#39;ajaxAdapter&#39;) {&#xA;      return makeAjaxCall(url).then((response) =&amp;gt; {&#xA;        // transform response and return&#xA;      });&#xA;    } else if (this.adapter.name === &#39;httpNodeAdapter&#39;) {&#xA;      return makeHttpCall(url).then((response) =&amp;gt; {&#xA;        // transform response and return&#xA;      });&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;function makeAjaxCall(url) {&#xA;  // request and return promise&#xA;}&#xA;&#xA;function makeHttpCall(url) {&#xA;  // request and return promise&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class AjaxAdapter extends Adapter {&#xA;  constructor() {&#xA;    super();&#xA;    this.name = &#39;ajaxAdapter&#39;;&#xA;  }&#xA;&#xA;  request(url) {&#xA;    // request and return promise&#xA;  }&#xA;}&#xA;&#xA;class NodeAdapter extends Adapter {&#xA;  constructor() {&#xA;    super();&#xA;    this.name = &#39;nodeAdapter&#39;;&#xA;  }&#xA;&#xA;  request(url) {&#xA;    // request and return promise&#xA;  }&#xA;}&#xA;&#xA;class HttpRequester {&#xA;  constructor(adapter) {&#xA;    this.adapter = adapter;&#xA;  }&#xA;&#xA;  fetch(url) {&#xA;    return this.adapter.request(url).then((response) =&amp;gt; {&#xA;      // transform response and return&#xA;    });&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;El principio de sustitución de Liskov (LSP)&lt;/h3&gt; &#xA;&lt;p&gt;Este es un término espantoso para un concepto muy simple. Formalmente se define como &#34;Si S es un subtipo de T que los objetos de T se reemplazan con los objetos de tipo S&#34;. (Es decir, los objetos de tipo S se pueden substituir con los objetos de tipo T sin alterar las propiedades deseables del programa (precisión, actuación, etc.). Esa si es una definición aún más espantosa.&lt;/p&gt; &#xA;&lt;p&gt;La mejor explanación para este concepto es si tienes una clase &lt;code&gt;padre&lt;/code&gt; y una clase &lt;code&gt;hijo&lt;/code&gt;, luego la clase base y la clase &lt;code&gt;hijo&lt;/code&gt; se pueden intercambiar sin tener resultados que carecen de precisión. Puede que aun estas confundido, así que miremos al modelo clásico de rectángulo-cuadro. Matemáticamente, un cuadro es un rectángulo, pero si lo modelas como una relación de &#34;es-un&#34; con la herencia, te meterás en problemas rápidamente.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Rectangle {&#xA;  constructor() {&#xA;    this.width = 0;&#xA;    this.height = 0;&#xA;  }&#xA;&#xA;  setColor(color) {&#xA;    // ...&#xA;  }&#xA;&#xA;  render(area) {&#xA;    // ...&#xA;  }&#xA;&#xA;  setWidth(width) {&#xA;    this.width = width;&#xA;  }&#xA;&#xA;  setHeight(height) {&#xA;    this.height = height;&#xA;  }&#xA;&#xA;  getArea() {&#xA;    return this.width * this.height;&#xA;  }&#xA;}&#xA;&#xA;class Square extends Rectangle {&#xA;  setWidth(width) {&#xA;    this.width = width;&#xA;    this.height = width;&#xA;  }&#xA;&#xA;  setHeight(height) {&#xA;    this.width = height;&#xA;    this.height = height;&#xA;  }&#xA;}&#xA;&#xA;function renderLargeRectangles(rectangles) {&#xA;  rectangles.forEach((rectangle) =&amp;gt; {&#xA;    rectangle.setWidth(4);&#xA;    rectangle.setHeight(5);&#xA;    const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20.&#xA;    rectangle.render(area);&#xA;  });&#xA;}&#xA;&#xA;const rectangles = [new Rectangle(), new Rectangle(), new Square()];&#xA;renderLargeRectangles(rectangles);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Shape {&#xA;  setColor(color) {&#xA;    // ...&#xA;  }&#xA;&#xA;  render(area) {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;class Rectangle extends Shape {&#xA;  constructor(width, height) {&#xA;    super();&#xA;    this.width = width;&#xA;    this.height = height;&#xA;  }&#xA;&#xA;  getArea() {&#xA;    return this.width * this.height;&#xA;  }&#xA;}&#xA;&#xA;class Square extends Shape {&#xA;  constructor(length) {&#xA;    super();&#xA;    this.length = length;&#xA;  }&#xA;&#xA;  getArea() {&#xA;    return this.length * this.length;&#xA;  }&#xA;}&#xA;&#xA;function renderLargeShapes(shapes) {&#xA;  shapes.forEach((shape) =&amp;gt; {&#xA;    const area = shape.getArea();&#xA;    shape.render(area);&#xA;  });&#xA;}&#xA;&#xA;const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];&#xA;renderLargeShapes(shapes);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;El principio de segregación en cuanto a los interfaces (ISP)&lt;/h3&gt; &#xA;&lt;p&gt;JavaScript no tiene interfaces así que este principio no se aplica tanto como en otros idiomas. Sin embargo, es importante y es relevante, aunque JavaScript no tenga un sistema de &lt;code&gt;tipos&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;ISP declara que &#34;Los clientes no se deben forzar para depender en interfaces que no implementan&#34;. Los interfaces son contratos implícitos en JavaScript debido al &lt;code&gt;teclear de duck&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Un buen ejemplo que demuestra este principio en JavaScript es para las clases que necesitan objetos grandes de composición. Con no requerir que los clientes se encarguen de muchas opciones, puedes beneficiar ya que la mayoría del tiempo no hace falta todo lo extra. Cuando haces que las opciones del contratos sean opcionales, evitas un &#34;interfaz gordo&#34;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class DOMTraverser {&#xA;  constructor(settings) {&#xA;    this.settings = settings;&#xA;    this.setup();&#xA;  }&#xA;&#xA;  setup() {&#xA;    this.rootNode = this.settings.rootNode;&#xA;    this.animationModule.setup();&#xA;  }&#xA;&#xA;  traverse() {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;const $ = new DOMTraverser({&#xA;  rootNode: document.getElementsByTagName(&#39;body&#39;),&#xA;  animationModule() {} // Most of the time, we won&#39;t need to animate when traversing.&#xA;  // ...&#xA;});&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class DOMTraverser {&#xA;  constructor(settings) {&#xA;    this.settings = settings;&#xA;    this.options = settings.options;&#xA;    this.setup();&#xA;  }&#xA;&#xA;  setup() {&#xA;    this.rootNode = this.settings.rootNode;&#xA;    this.setupOptions();&#xA;  }&#xA;&#xA;  setupOptions() {&#xA;    if (this.options.animationModule) {&#xA;      // ...&#xA;    }&#xA;  }&#xA;&#xA;  traverse() {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;const $ = new DOMTraverser({&#xA;  rootNode: document.getElementsByTagName(&#39;body&#39;),&#xA;  options: {&#xA;    animationModule() {}&#xA;  }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;El principio de la inversión de las dependencias (DIP)&lt;/h3&gt; &#xA;&lt;p&gt;Este principio declara dos cosas esenciales:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Los módulos de nivel alto no deben depender en los módulos de nivel bajo. Los dos deben dependerse en las abstracciones.&lt;/li&gt; &#xA; &lt;li&gt;Las abstracciones no deben dependerse en las detalles. Las detalles deben dependerse en las abstracciones.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Esto ha de entender la primera vez, pero si has trabajado con AngularJS, has visto una implementación de este principio en la forma de la inyección de dependencias (DI). Mientras que no son conceptos idénticos, el DIP mantiene que los módulos de nivel alto no sepan las detalles de los módulos de nivel bajo y también se encarga de ellos. Esto se puede conseguir con DI. Un beneficio enorme de esto es que reduce la convivencia entre los módulos. La convivencia es un modelo muy malo en cuanto al desarrollo de software ya dificulta la posibilidad de refactorizar.&lt;/p&gt; &#xA;&lt;p&gt;Como se ha mencionado previamente, JavaScript no tiene interfaces así que las abstracciones de las que se dependen son contratos implícitos. Es decir, los métodos y las propiedades que un objeto/clase expone hasta otro objeto/clase. En el ejemplo más abajo, el contrato implícito es que cualquier módulo de Request que utilizar el &lt;code&gt;InventoryTracker&lt;/code&gt; debe tener un método de &lt;code&gt;requestItems&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class InventoryRequester {&#xA;  constructor() {&#xA;    this.REQ_METHODS = [&#39;HTTP&#39;];&#xA;  }&#xA;&#xA;  requestItem(item) {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;class InventoryTracker {&#xA;  constructor(items) {&#xA;    this.items = items;&#xA;&#xA;    // BAD: We have created a dependency on a specific request implementation.&#xA;    // We should just have requestItems depend on a request method: `request`&#xA;    this.requester = new InventoryRequester();&#xA;  }&#xA;&#xA;  requestItems() {&#xA;    this.items.forEach((item) =&amp;gt; {&#xA;      this.requester.requestItem(item);&#xA;    });&#xA;  }&#xA;}&#xA;&#xA;const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;]);&#xA;inventoryTracker.requestItems();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class InventoryTracker {&#xA;  constructor(items, requester) {&#xA;    this.items = items;&#xA;    this.requester = requester;&#xA;  }&#xA;&#xA;  requestItems() {&#xA;    this.items.forEach((item) =&amp;gt; {&#xA;      this.requester.requestItem(item);&#xA;    });&#xA;  }&#xA;}&#xA;&#xA;class InventoryRequesterV1 {&#xA;  constructor() {&#xA;    this.REQ_METHODS = [&#39;HTTP&#39;];&#xA;  }&#xA;&#xA;  requestItem(item) {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;class InventoryRequesterV2 {&#xA;  constructor() {&#xA;    this.REQ_METHODS = [&#39;WS&#39;];&#xA;  }&#xA;&#xA;  requestItem(item) {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;// By constructing our dependencies externally and injecting them, we can easily&#xA;// substitute our request module for a fancy new one that uses WebSockets.&#xA;const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;], new InventoryRequesterV2());&#xA;inventoryTracker.requestItems();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Pruebas&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Comprobar nuestro código es más importante que enviarlo. Si no tienes pruebas o tienes una cantidad inadecuada, cada vez que envías tu código tendrás dudas en cuanto el saber de cuantos errores aún existen en tus programas. Deducir en lo que constituye una cantidad adecuada es la responsabilidad del equipo, pero tener cobertura 100% (todos las declaraciones y ramos) es como se logra una confianza alta y una tranquilidad de mente. Esto significa que encima de utilizar una estructura de pruebas, también necesitas usar una buena herramienta de cobertura.&lt;/p&gt; &#xA;&lt;p&gt;No existe excusa para no escribir pruebas. Hay muchas estructuras buenas de pruebas para JS, así que busca una que le guste tu equipo. Cuando encuentras una que tu equipo le gusta, enfócate en siempre escribir pruebas para cada nueva característica/módulo que introduces. Si tu método preferido es el Test Driven Development (TDD), eso está bien, pero el punto principal es que te aseguras de llegar a tus objetivos de cobertura antes de enviar el código o refactorizar una prueba ya existente.&lt;/p&gt; &#xA;&lt;h3&gt;Un solo concepto para cada prueba&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import assert from &#39;assert&#39;;&#xA;&#xA;describe(&#39;MakeMomentJSGreatAgain&#39;, () =&amp;gt; {&#xA;  it(&#39;handles date boundaries&#39;, () =&amp;gt; {&#xA;    let date;&#xA;&#xA;    date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);&#xA;    date.addDays(30);&#xA;    assert.equal(&#39;1/31/2015&#39;, date);&#xA;&#xA;    date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);&#xA;    date.addDays(28);&#xA;    assert.equal(&#39;02/29/2016&#39;, date);&#xA;&#xA;    date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);&#xA;    date.addDays(28);&#xA;    assert.equal(&#39;03/01/2015&#39;, date);&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import assert from &#39;assert&#39;;&#xA;&#xA;describe(&#39;MakeMomentJSGreatAgain&#39;, () =&amp;gt; {&#xA;  it(&#39;handles 30-day months&#39;, () =&amp;gt; {&#xA;    const date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);&#xA;    date.addDays(30);&#xA;    assert.equal(&#39;1/31/2015&#39;, date);&#xA;  });&#xA;&#xA;  it(&#39;handles leap year&#39;, () =&amp;gt; {&#xA;    const date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);&#xA;    date.addDays(28);&#xA;    assert.equal(&#39;02/29/2016&#39;, date);&#xA;  });&#xA;&#xA;  it(&#39;handles non-leap year&#39;, () =&amp;gt; {&#xA;    const date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);&#xA;    date.addDays(28);&#xA;    assert.equal(&#39;03/01/2015&#39;, date);&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Concurrencia&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Utiliza las promesas y no utilices los callbacks&lt;/h3&gt; &#xA;&lt;p&gt;Los callbacks no son limpos y utilizan una cantidad excesiva de encajamiento. Con ES2015/ES6, las Promesas son un tipo ya nativo del idioma. Utilizalas!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { get } from &#39;request&#39;;&#xA;import { writeFile } from &#39;fs&#39;;&#xA;&#xA;get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;, (requestErr, response) =&amp;gt; {&#xA;  if (requestErr) {&#xA;    console.error(requestErr);&#xA;  } else {&#xA;    writeFile(&#39;article.html&#39;, response.body, (writeErr) =&amp;gt; {&#xA;      if (writeErr) {&#xA;        console.error(writeErr);&#xA;      } else {&#xA;        console.log(&#39;File written&#39;);&#xA;      }&#xA;    });&#xA;  }&#xA;});&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { get } from &#39;request&#39;;&#xA;import { writeFile } from &#39;fs&#39;;&#xA;&#xA;get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)&#xA;  .then((response) =&amp;gt; {&#xA;    return writeFile(&#39;article.html&#39;, response);&#xA;  })&#xA;  .then(() =&amp;gt; {&#xA;    console.log(&#39;File written&#39;);&#xA;  })&#xA;  .catch((err) =&amp;gt; {&#xA;    console.error(err);&#xA;  });&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Async/Await son aún más limpios que las Promesas&lt;/h3&gt; &#xA;&lt;p&gt;Las Promesas son una alternativa muy limpia a los callbacks, pero ES2017/E8 incluye &lt;code&gt;async&lt;/code&gt; y &lt;code&gt;await&lt;/code&gt; que ofrecen una solución aún más limpia. Todo lo que necesitas es una función que empieza con la palabra &lt;code&gt;async&lt;/code&gt;, y luego puedes escribir tu lógico imperativamente sin una fila de funciones de &lt;code&gt;then&lt;/code&gt;. Utiliza esto si puedes aprovecharte de los beneficios de ES2017/E8 hoy!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { get } from &#39;request-promise&#39;;&#xA;import { writeFile } from &#39;fs-promise&#39;;&#xA;&#xA;get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)&#xA;  .then((response) =&amp;gt; {&#xA;    return writeFile(&#39;article.html&#39;, response);&#xA;  })&#xA;  .then(() =&amp;gt; {&#xA;    console.log(&#39;File written&#39;);&#xA;  })&#xA;  .catch((err) =&amp;gt; {&#xA;    console.error(err);&#xA;  });&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { get } from &#39;request-promise&#39;;&#xA;import { writeFile } from &#39;fs-promise&#39;;&#xA;&#xA;async function getCleanCodeArticle() {&#xA;  try {&#xA;    const response = await get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;);&#xA;    await writeFile(&#39;article.html&#39;, response);&#xA;    console.log(&#39;File written&#39;);&#xA;  } catch(err) {&#xA;    console.error(err);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Resolver los errores&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;¡Los errores que emergen en tus programas son buenos! Significan que tu ejecución ha tenido éxito a la hora de identificar un error en tu programa y te avisa con detener la ejecución del &#39;stack&#39; actual, matando el proceso (en Node), y notificarse en el &#39;console&#39; con un reporte de &#39;stack trace&#39;&lt;/p&gt; &#xA;&lt;h3&gt;No les ignores a los errores pillados&lt;/h3&gt; &#xA;&lt;p&gt;Hacer nada cuando existe un error pillado no te da la habilidad de arreglar o resolverlo. Apuntar el error al console (&lt;code&gt;console.log&lt;/code&gt;) no es mucho mejor ya que muchas veces se puede perder en un mar de cosas que se apuntan al console. Si metes tu código en un &lt;code&gt;try/catch&lt;/code&gt; significa que un error puede ocurrir allí y así que deberías de tener un plan, o crear una solución por si acaso.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {&#xA;  functionThatMightThrow();&#xA;} catch (error) {&#xA;  console.log(error);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {&#xA;  functionThatMightThrow();&#xA;} catch (error) {&#xA;  // One option (more noisy than console.log):&#xA;  console.error(error);&#xA;  // Another option:&#xA;  notifyUserOfError(error);&#xA;  // Another option:&#xA;  reportErrorToService(error);&#xA;  // OR do all three!&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;No le ignores a las promesas rechazadas&lt;/h3&gt; &#xA;&lt;p&gt;Igual que no debes ignorar a los errores no pillados de un &#39;try/catch&#39;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;getdata()&#xA;  .then((data) =&amp;gt; {&#xA;    functionThatMightThrow(data);&#xA;  })&#xA;  .catch((error) =&amp;gt; {&#xA;    console.log(error);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;getdata()&#xA;  .then((data) =&amp;gt; {&#xA;    functionThatMightThrow(data);&#xA;  })&#xA;  .catch((error) =&amp;gt; {&#xA;     // Una opción (más ruidoso que console.log):&#xA;    console.error(error);&#xA;    // Otra opción:&#xA;    notifyUserOfError(error);&#xA;    // Otra opción&#xA;    reportErrorToService(error);&#xA;    // O haz las tres!&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Formatear&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Formatear es subjetivo. Como muchas reglas en esta guía, no hay que seguirlas 100%. El punto clave es: NO DISCUTAS sobre formatear. Hay muchas &lt;a href=&#34;http://standardjs.com/rules.html&#34;&gt;herramientas&lt;/a&gt; para facilitar esto. ¡Utiliza una de estas herramientas! Te desperdicias de tu propio tiempo y el tiempo de los demás cuando discuten sobre formatear.&lt;/p&gt; &#xA;&lt;p&gt;Para las cosas que no tienen relevancia al formateo automático (indentación, tabulos y espacios, comillas dobles y sencillas, etc.), busca aquí para aconsejarte.&lt;/p&gt; &#xA;&lt;h3&gt;Utiliza capitalización consistente&lt;/h3&gt; &#xA;&lt;p&gt;JavaScript es un idioma no tecleado, así que la capitalización puede decirte muchas cosas sobre tus variables, funciones, etc. Estas reglas son subjetivas, así que tu equipo puede escoger lo que quiera. El punto es, sin importar lo que escojas, se consistente.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DAYS_IN_WEEK = 7;&#xA;const daysInMonth = 30;&#xA;&#xA;const songs = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];&#xA;const Artists = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];&#xA;&#xA;function eraseDatabase() {}&#xA;function restore_database() {}&#xA;&#xA;class animal {}&#xA;class Alpaca {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DAYS_IN_WEEK = 7;&#xA;const DAYS_IN_MONTH = 30;&#xA;&#xA;const songs = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];&#xA;const artists = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];&#xA;&#xA;function eraseDatabase() {}&#xA;function restoreDatabase() {}&#xA;&#xA;class Animal {}&#xA;class Alpaca {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Los llamadores y llamantes de las funciones deben existir cercas&lt;/h3&gt; &#xA;&lt;p&gt;Si una función le llama a otra, mantiene esa funcionas verticalmente cerca en su archivo de fuente. Idealmente, mantiene el llamador justo encima del llamante. Solemos leer código arriba-abajo, como un periódico. Debido a esto, haz que tus programas sean legibles así.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class PerformanceReview {&#xA;  constructor(employee) {&#xA;    this.employee = employee;&#xA;  }&#xA;&#xA;  lookupPeers() {&#xA;    return db.lookup(this.employee, &#39;peers&#39;);&#xA;  }&#xA;&#xA;  lookupManager() {&#xA;    return db.lookup(this.employee, &#39;manager&#39;);&#xA;  }&#xA;&#xA;  getPeerReviews() {&#xA;    const peers = this.lookupPeers();&#xA;    // ...&#xA;  }&#xA;&#xA;  perfReview() {&#xA;    this.getPeerReviews();&#xA;    this.getManagerReview();&#xA;    this.getSelfReview();&#xA;  }&#xA;&#xA;  getManagerReview() {&#xA;    const manager = this.lookupManager();&#xA;  }&#xA;&#xA;  getSelfReview() {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;const review = new PerformanceReview(user);&#xA;review.perfReview();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class PerformanceReview {&#xA;  constructor(employee) {&#xA;    this.employee = employee;&#xA;  }&#xA;&#xA;  perfReview() {&#xA;    this.getPeerReviews();&#xA;    this.getManagerReview();&#xA;    this.getSelfReview();&#xA;  }&#xA;&#xA;  getPeerReviews() {&#xA;    const peers = this.lookupPeers();&#xA;    // ...&#xA;  }&#xA;&#xA;  lookupPeers() {&#xA;    return db.lookup(this.employee, &#39;peers&#39;);&#xA;  }&#xA;&#xA;  getManagerReview() {&#xA;    const manager = this.lookupManager();&#xA;  }&#xA;&#xA;  lookupManager() {&#xA;    return db.lookup(this.employee, &#39;manager&#39;);&#xA;  }&#xA;&#xA;  getSelfReview() {&#xA;    // ...&#xA;  }&#xA;}&#xA;&#xA;const review = new PerformanceReview(employee);&#xA;review.perfReview();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Comentarios&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Solamente comenta las cosas que tienen lógico complejo.&lt;/h3&gt; &#xA;&lt;p&gt;Los comentarios existen para pedir perdón, pero no son un requisito. El código bueno más que nada se documenta sí mismo.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function hashIt(data) {&#xA;  // El hash&#xA;  let hash = 0;&#xA;&#xA;  // Length of string&#xA;  const length = data.length;&#xA;  // Iterar cada caracter en la data&#xA;  for (let i = 0; i &amp;lt; length; i++) {&#xA;     // Conseguir el código del caracter&#xA;    const char = data.charCodeAt(i);&#xA;    // Crear el hash &#xA;    hash = ((hash &amp;lt;&amp;lt; 5) - hash) + char;&#xA;    // Conviertelo hasta 32-bit&#xA;    hash &amp;amp;= hash;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#xA;function hashIt(data) {&#xA;  let hash = 0;&#xA;  const length = data.length;&#xA;&#xA;  for (let i = 0; i &amp;lt; length; i++) {&#xA;    const char = data.charCodeAt(i);&#xA;    hash = ((hash &amp;lt;&amp;lt; 5) - hash) + char;&#xA;    hash &amp;amp;= hash;&#xA;  }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;No dejes código inutilizado en tus archivos&lt;/h3&gt; &#xA;&lt;p&gt;El control de versión existe para una razón. Deja el código viejo en tu historia (git).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#xA;hazAlgo()&#xA;// hazMasCosas();&#xA;// hazAunMasCosas();&#xA;// hazTantasOtrasCosas();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;doStuff();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;No escribas comentarios de jornada&lt;/h3&gt; &#xA;&lt;p&gt;Ojo: ¡utiliza el control de versión (git)! No hay necesidad para el código no utilizado, comentado, y especialmente comentarios de jornada. En cambio, utiliza &#39;git log&#39; para recuperar una historia de lo que has hecho.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**&#xA; * 2016-12-20: Remover monads, no los entendia bien (RM)&#xA; * 2016-10-01: Mejorar utilizando los monads especiales (JP)&#xA; * 2016-02-03: Remover la comprobacion de tipos de data (LI)&#xA; * 2015-03-14: Agregar la funcion combinar (JR)&#xA; */&#xA;function combinar(a, b) {&#xA;  return a + b;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function combinar(a, b) {&#xA;  return a + b;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Evitar los marcadores posicionales&lt;/h3&gt; &#xA;&lt;p&gt;Los marcadores posicionales suelen dificultar las cosas. Deja que las funciones, los nombres de tus variables, la indentación adecuada y el formatear creen una estructura visual para tu código.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mal hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;////////////////////////////////////////////////////////////////////////////////&#xA;// Instanciacion del modelo de Scope&#xA;////////////////////////////////////////////////////////////////////////////////&#xA;$scope.modelo = {&#xA;  menu: &#39;foo&#39;,&#xA;  nav: &#39;bar&#39;&#xA;};&#xA;&#xA;////////////////////////////////////////////////////////////////////////////////&#xA;// Iniciar de acciones &#xA;////////////////////////////////////////////////////////////////////////////////&#xA;const acciones = function() {&#xA;  // ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bien hecho:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$scope.modelo = {&#xA;  menu: &#39;foo&#39;,&#xA;  nav: &#39;bar&#39;&#xA;};&#xA;&#xA;const acciones = function() {&#xA;  // ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/andersontr15/clean-code-javascript-es/master/#contenido&#34;&gt;⬆ vuelve hasta arriba&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>notplu/Nullify</title>
    <updated>2023-02-17T01:39:08Z</updated>
    <id>tag:github.com,2023-02-17:/notplu/Nullify</id>
    <link href="https://github.com/notplu/Nullify" rel="alternate"></link>
    <summary type="html">&lt;p&gt;One of the BEST up to date iReady hacks. Similar to iReady Overload.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;Nullify&lt;/h1&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt;The BEST i-Ready hack.&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt;By &lt;a href=&#34;https://github.com/wang-fr&#34;&gt;wang-fr&lt;/a&gt;, &lt;a href=&#34;https://github.com/notplu&#34;&gt;notplu&lt;/a&gt;, &lt;a href=&#34;https://github.com/TonicGaro&#34;&gt;TonicGaro&lt;/a&gt;, &lt;a href=&#34;https://github.com/flowingsalt&#34;&gt;flowingsalt&lt;/a&gt;, and &lt;a href=&#34;https://github.com/Uveltt&#34;&gt;Uveltt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt;&lt;a href=&#34;https://discord.gg/UHYAnP7wrW&#34;&gt;Nullify Discord&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;212&#34; height=&#34;212&#34; src=&#34;https://res.cloudinary.com/dodofguiy/image/upload/v1671071889/icon_f6pwnj.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Welcome to Nullify, the best i-Ready hack!&lt;br&gt;&lt;br&gt; With this hack you can completely remove the stress and torture that comes with i-Ready and breeze through your lessons with ease.&lt;/p&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt;How to setup:&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Copy the code below and login to i-Ready.&lt;br&gt;&lt;br&gt; Do Ctrl + Shift + J to open the console and paste the code, then hit Enter to run it.&lt;br&gt;&lt;br&gt; If your school blocks the console then make a new bookmark and in the URL section paste the code there. Click the bookmark anytime to run the code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;javascript:fetch(&#39;https://raw.githubusercontent.com/notplu/Nullify/main/Data/main.js&#39;).then(r =&amp;gt; r.text()).then(r =&amp;gt; eval(r))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt;Misc&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Credits to ArjhanToteck, cupiditys, H and wang for originally making this, (but they deleted their project/repo).&lt;br&gt;&lt;br&gt; HUGE credit to wang-fr for creating the Lesson Skipper. This hack wouldn&#39;t be as great as it is without his help.&lt;br&gt;&lt;br&gt; Nullify is under the GNU General Public License v3.0. Learn more &lt;a href=&#34;https://github.com/notplu/Nullify/raw/main/LICENSE&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>elementor/elementor</title>
    <updated>2023-02-17T01:39:08Z</updated>
    <id>tag:github.com,2023-02-17:/elementor/elementor</id>
    <link href="https://github.com/elementor/elementor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The most advanced frontend drag &amp; drop page builder. Create high-end, pixel perfect websites at record speeds. Any theme, any page, any design.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;p&gt;&lt;a href=&#34;https://elementor.com/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;&lt;img src=&#34;https://i.imgur.com/0Guj2pn.png?1&#34; alt=&#34;Elementor Website Builder&#34;&gt;&lt;/a&gt;&lt;/p&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Welcome to the Elementor GitHub repository. Elementor is the most advanced frontend drag &amp;amp; drop website builder. Create high-end, pixel perfect websites at record speeds. Any theme, any page, any design.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elementor.com/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;&lt;img src=&#34;https://ps.w.org/elementor/assets/screenshot-1.gif&#34; alt=&#34;Elementor Website Builder&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Introducing a WordPress website builder, with no limits of design. A website builder that delivers high-end page designs and advanced capabilities, never before seen on WordPress.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s time for &lt;strong&gt;&lt;a href=&#34;https://elementor.com/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Elementor Website Builder&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;The leading website builder for any purpose&lt;/h3&gt; &#xA;&lt;p&gt;Whether you’re a web designer looking for a way to achieve pixel-perfect websites, a marketer looking to get online fast or a developer who wants to expand their capabilities, Elementor’s website builder has what you need - intuitive drag-and-drop Editor, advanced design features and a full open-source approach.&lt;/p&gt; &#xA;&lt;p&gt;There are many other &lt;a href=&#34;https://elementor.com/features/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;features&lt;/a&gt; to help you build better websites. Join the elite web professionals who enjoy &lt;a href=&#34;https://elementor.com/pro/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Elementor Pro&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Developer API&lt;/h2&gt; &#xA;&lt;p&gt;Elementor website builder is free and open source. It’s the perfect plugin to be extended and integrated further. It was created and developed with the developer in mind, and we have already seen some truly remarkable addons being developed.&lt;/p&gt; &#xA;&lt;p&gt;To help you get started and learn just how to integrate with Elementor, we have created the official &lt;a href=&#34;https://developers.elementor.com/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Elementor Developers Center&lt;/a&gt;. Check the &lt;a href=&#34;https://developers.elementor.com/blog/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Developers Blog&lt;/a&gt; to discover the latest information from the programmers working on the newest Elementor versions, or visit the &lt;a href=&#34;https://developers.elementor.com/docs/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Developers Docs&lt;/a&gt; to learn how to extend Elementor core and create your own addons.&lt;/p&gt; &#xA;&lt;h2&gt;Be a contributor&lt;/h2&gt; &#xA;&lt;p&gt;Community contributions are always welcome and help us remain the Number 1 WordPress Website Builder, feel free to answering questions on GitHub and within the various Elementor communities.&lt;/p&gt; &#xA;&lt;p&gt;There are many ways to contribute to Elementor:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bug Report&lt;/strong&gt;: If you find a bug in the source code, you can help us by &lt;a href=&#34;https://github.com/elementor/elementor/issues/new?template=Bug_report.md&#34;&gt;submitting a bug report&lt;/a&gt;. Even better, you can &lt;a href=&#34;https://github.com/elementor/elementor/raw/master/.github/CONTRIBUTING.md#before-submitting-a-pr&#34;&gt;submit a Pull Request&lt;/a&gt; with a fix.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Security Report&lt;/strong&gt;: We run a &lt;a href=&#34;https://bugcrowd.com/elementor&#34;&gt;managed security Bug Bounty program&lt;/a&gt;, utilizing the community power by enabling 24/7/365 crowdsourced vulnerability detection. The program contains all the needed information about which features and endpoints are considered ‘in scope’, details of the rewards we offer and the full terms and conditions of our program.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Feature Request&lt;/strong&gt;: Provide feedback and suggestions on enhancements by &lt;a href=&#34;https://github.com/elementor/elementor/issues/new?template=Feature_request.md&#34;&gt;open a feature request&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Translate&lt;/strong&gt;: You can also add a new language via &lt;a href=&#34;https://translate.wordpress.org/projects/wp-plugins/elementor&#34;&gt;translate.wordpress.org&lt;/a&gt;. We&#39;ve built a short guide explaining &lt;a href=&#34;https://go.elementor.com/translate/&#34;&gt;how to translate and localize the plugin&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;Please &lt;strong&gt;DO NOT&lt;/strong&gt; open issues for general support questions as we want to keep GitHub issues for bug reports and feature requests. You&#39;ve got much better chances of getting your question answered on one of the proper support channels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For documentation and tutorials go to our &lt;a href=&#34;https://docs.elementor.com/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Documentation&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you have any more questions, visit our support on the &lt;a href=&#34;https://wordpress.org/support/plugin/elementor&#34;&gt;Plugin&#39;s Forum&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For more information about features, FAQs and documentation, check out our website at &lt;a href=&#34;https://elementor.com/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Elementor website Builder&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Join &lt;a href=&#34;https://www.facebook.com/groups/Elementors/&#34;&gt;Elementor Community&lt;/a&gt; on Facebook&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you have purchased &lt;a href=&#34;https://elementor.com/pro/?utm_source=github-repo&amp;amp;utm_medium=link&amp;amp;utm_campaign=readme&#34;&gt;Elementor Pro&lt;/a&gt;, you are entitled for personal support, please see your Elementor account for details.&lt;/p&gt; &#xA;&lt;h2&gt;Liked Elementor?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Join our &lt;a href=&#34;https://www.facebook.com/groups/Elementors/&#34;&gt;Facebook Group&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Learn from our tutorials on &lt;a href=&#34;https://www.youtube.com/c/elementor&#34;&gt;YouTube Channel&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Or rate us on &lt;a href=&#34;https://wordpress.org/support/plugin/elementor/reviews/?filter=5/#new-post&#34;&gt;WordPress&lt;/a&gt; :)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>