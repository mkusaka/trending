<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-06T01:30:28Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Maplemx/Agently</title>
    <updated>2023-09-06T01:30:28Z</updated>
    <id>tag:github.com,2023-09-06:/Maplemx/Agently</id>
    <link href="https://github.com/Maplemx/Agently" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🚀 A fast way to build LLM Agent based Application 🤵 A light weight framework helps developers to create amazing LLM based applications. 🎭 You can use it to create an LLM based agent instance with role set and memory easily. ⚙️ You can use Agently agent instance just like an async function and put it anywhere in your code.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Agently 2.0&lt;/h1&gt; &#xA;&lt;p&gt;Python版&lt;code&gt;v2.0.1&lt;/code&gt;：&lt;a href=&#34;https://github.com/Maplemx/Agently/raw/main/README.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;NodeJS版&lt;code&gt;v1.1.3&lt;/code&gt;：&lt;a href=&#34;https://github.com/Maplemx/Agently/raw/main/doc/nodejs/v1/README_EN.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://github.com/Maplemx/Agently/raw/main/doc/nodejs/v1/README_CN.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;🥷 作者：Maplemx ｜ 📧 Email：&lt;a href=&#34;mailto:maplemx@gmail.com&#34;&gt;maplemx@gmail.com&lt;/a&gt; | 💬 微信：moxinapp&lt;/p&gt; &#xA; &lt;p&gt;⁉️ &lt;a href=&#34;https://github.com/Maplemx/Agently/issues&#34;&gt;如果您发现了BUG，或者有好的点子，请在这里提交&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;⭐️ 如果您觉得这个项目对您有帮助，请给项目加星，感谢您的肯定和支持！&lt;/p&gt; &#xA; &lt;p&gt;👾 Discord群组邀请链接：&lt;a href=&#34;https://discord.gg/j9CvXXJG&#34;&gt;https://discord.gg/j9CvXXJG&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;👥 微信讨论群：加群请加微信号maplemx&lt;/p&gt; &#xA; &lt;img src=&#34;https://github.com/Maplemx/Agently/assets/4413155/f46c6530-64a1-4e70-ace4-3d8268cf8992&#34; width=&#34;128px&#34; height=&#34;128px&#34;&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;快速开始&lt;/h2&gt; &#xA;&lt;p&gt;使用pip进行安装：&lt;code&gt;pip install Agently&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;下载DEMO文件试用：&lt;a href=&#34;https://github.com/Maplemx/Agently/tree/main/demo/python&#34;&gt;点击直达&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;使用.sh脚本一键启动多轮对话CLI界面：&lt;a href=&#34;https://github.com/Maplemx/Agently/tree/main/demo/python/quick_launch_sh_cn&#34;&gt;点击直达&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;快速了解 Agently 2.0 可以做什么？&lt;/h2&gt; &#xA;&lt;h3&gt;☄️ 用最快的速度开箱，在代码行中使用一个基础Agent的实例&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import Agently&#xA;worker = Agently.create_worker()&#xA;worker.set_llm_name(&#34;GPT&#34;).set_llm_auth(&#34;GPT&#34;, &#34;Your-API-Key&#34;)&#xA;result = worker\&#xA;    .input(&#34;Give me 5 words and 1 sentence.&#34;)\&#xA;    .output({&#xA;        &#34;words&#34;: (&#34;Array&#34;,),&#xA;        &#34;sentence&#34;: (&#34;String&#34;,),&#xA;    })\&#xA;    .start()&#xA;print(result)&#xA;print(result[&#34;words&#34;][2])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;运行结果&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code&gt;{&#39;words&#39;: [&#39;apple&#39;, &#39;banana&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;elephant&#39;], &#39;sentence&#39;: &#39;I have a cat and a dog as pets.&#39;}&#xA;cat&#xA;[Finished in 4.8s]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;在上面的示例中，&lt;code&gt;worker&lt;/code&gt;这个实例，就是一个基础Agent，它已经可以在代码中为我们工作，理解我们的输入要求（&lt;em&gt;input&lt;/em&gt;），按照输出要求（&lt;em&gt;output&lt;/em&gt;），生成对应结构的dict结果（&lt;em&gt;作为start()的运行结果，传递给result&lt;/em&gt;）。而这一切，如果忽视为了链式表达的美观性而通过&lt;code&gt;\&lt;/code&gt;进行的换行操作，其实都发生在一行代码里。&lt;/p&gt; &#xA;&lt;p&gt;并且，你可能也注意到了，在Agently框架能力的支持下，面向Agent的请求表达，可以灵活使用各种代码数据结构（dict, list）进行表达，并且可以期望获得符合这样数据结构的返回结果。在output的表达中，使用&lt;code&gt;(&#34;&amp;lt;该字段的数据类型要求&amp;gt;&#34;, &#34;&amp;lt;该字段需要输出的内容方向要求&amp;gt;&#34;)&lt;/code&gt;的方式，能够帮助你更结构性地对字段值的具体要求进行表达。&lt;/p&gt; &#xA;&lt;p&gt;那么可能你会问，现在我的确在代码层面拥有了一个基础Agent，可是它又可以做什么呢？&lt;/p&gt; &#xA;&lt;p&gt;下面是一些它可以做的事情的范例：&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-size:115%; font-weight:bold&#34;&gt;范例1：修复有格式错误的JSON字符串&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;p&gt;示例代码：&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fix_json(json_string, round_count = 0):&#xA;    round_count += 1&#xA;    try:&#xA;        json.loads(json_string)&#xA;        return json_string&#xA;    except json.JSONDecodeError as e:&#xA;        print(&#34;[Worker Agent Activated]: Round&#34;, round_count)&#xA;        print(&#34;Fix JSON Format Error:\n&#34;, e.msg)&#xA;        print(&#34;Origin String:\n&#34;, json_string, &#34;\n&#34;)&#xA;        fixed_result = worker\&#xA;            .input({&#xA;                &#34;origin JSON String&#34;: json_string,&#xA;                &#34;error&#34;: e.msg,&#xA;                &#34;position&#34;: e.pos,&#xA;            })\&#xA;            .output(&#34;Fixed JSON String only without explanation and decoration.&#34;)\&#xA;            .start()&#xA;        print(&#34;Fixed Content:\n&#34;, fixed_result, &#34;\n&#34;)&#xA;        return fix_json(fixed_result, round_count)&#xA;&#xA;result = fix_json(&#34;{&#39;words&#39;: [&#39;apple&#39;, &#39;banana&#39;, &#39;carrot&#39;, &#39;dog&#39;, &#39;elephant&#39;], &#39;sentence&#39;: &#39;I have an apple, a banana, a carrot, a dog, and an elephant.&#39;}&#34;)&#xA;print(result)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;运行结果：&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;[Worker Agent Activated]: Round 1&#xA;Fix JSON Format Error:&#xA; Expecting property name enclosed in double quotes&#xA;Origin String:&#xA; {&#39;words&#39;: [&#39;apple&#39;, &#39;banana&#39;, &#39;carrot&#39;, &#39;dog&#39;, &#39;elephant&#39;], &#39;sentence&#39;: &#39;I have an apple, a banana, a carrot, a dog, and an elephant.&#39;} &#xA;&#xA;Fixed Content:&#xA; {&#34;words&#34;: [&#34;apple&#34;, &#34;banana&#34;, &#34;carrot&#34;, &#34;dog&#34;, &#34;elephant&#34;], &#34;sentence&#34;: &#34;I have an apple, a banana, a carrot, a dog, and an elephant.&#34;} &#xA;&#xA;{&#34;words&#34;: [&#34;apple&#34;, &#34;banana&#34;, &#34;carrot&#34;, &#34;dog&#34;, &#34;elephant&#34;], &#34;sentence&#34;: &#34;I have an apple, a banana, a carrot, a dog, and an elephant.&#34;}&#xA;[Finished in 3.4s]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-size:115%; font-weight:bold&#34;&gt;范例2：理解一句自然语言的输入，然后真实地调用某一个接口&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 首先我们定义一下可用的工具&#xA;tools = {&#xA;    &#34;weather_report&#34;: {&#xA;        &#34;desc&#34;: &#34;get weather report for the present time&#34;,&#xA;        &#34;input_requirement&#34;: {&#xA;            &#34;location&#34;: (&#34;String&#34;, &#34;your location&#34;)&#xA;        },&#xA;        &#34;func&#34;: lambda **kwargs: print(&#34;The weather is sunny right now.\n&#34;, kwargs)&#xA;    },&#xA;    &#34;weather_forecast&#34;: {&#xA;        &#34;desc&#34;: &#34;get weather forecast for the next 2-24 hours.&#34;,&#xA;        &#34;input_requirement&#34;: {&#xA;            &#34;location&#34;: (&#34;String&#34;, &#34;your location&#34;),&#xA;        },&#xA;        &#34;func&#34;: lambda **kwargs: print(&#34;There&#39;ll be raining 3 hours later.\n&#34;, kwargs)&#xA;    },&#xA;    &#34;file_browser&#34;: {&#xA;        &#34;desc&#34;: &#34;Browse files that are given to.&#34;,&#xA;        &#34;input_requirement&#34;: {&#xA;            &#34;file_path&#34;: (&#34;String&#34;, &#34;File path that to be browsed.&#34;),&#xA;            &#34;chunk_num&#34;: (&#34;Number&#34;, &#34;How many chunks to be output?&#34;),&#xA;            &#34;need_summarize&#34;: (&#34;Boolean&#34;, &#34;Do user need a summarize about the file?&#34;)&#xA;        },&#xA;        &#34;func&#34;: lambda **kwargs: print(&#34;File browse work done.\n&#34;, kwargs)&#xA;    },&#xA;}&#xA;&#xA;# 让Worker Agent自己决定是不是应该调用，以及应该如何调用对应的工具&#xA;def call_tools(natural_language_input):&#xA;    #step 1. 确定应该使用哪个工具&#xA;    tools_desc = []&#xA;    for tool_name, tool_info in tools.items():&#xA;        tools_desc.append({ &#34;name&#34;: tool_name, &#34;desc&#34;: tool_info[&#34;desc&#34;] })&#xA;    tools_to_be_used = worker\&#xA;        .input({&#xA;            &#34;input&#34;: natural_language_input,&#xA;            &#34;tools&#34;: str(tools_desc)&#xA;        })\&#xA;        .output([(&#34;String&#34;, &#34;Tool name in {{input.tools}} to response {{input}}&#39;s requirement.&#34;)])\&#xA;        .start()&#xA;    #step 2. 生成调用工具所需要的参数，并真实地进行调用&#xA;    for tool_name in tools_to_be_used:&#xA;        call_parameters = worker\&#xA;            .input({&#xA;                &#34;input&#34;: natural_language_input,&#xA;            })\&#xA;            .output(tools[tool_name][&#34;input_requirement&#34;])\&#xA;            .start()&#xA;        tools[tool_name][&#34;func&#34;](**call_parameters)&#xA;call_tools(&#34;Browse ./readme.pdf for me and chunk to 3 pieces without summarize and check Beijing&#39;s next 24 hours weather for me.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;运行结果：&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;File browse work done.&#xA; {&#39;file_path&#39;: &#39;./readme.pdf&#39;, &#39;chunk_num&#39;: 3, &#39;need_summarize&#39;: False}&#xA;There&#39;ll be raining 3 hours later.&#xA; {&#39;location&#39;: &#39;Beijing&#39;}&#xA;[Finished in 8.1s]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;👨‍👩‍👧‍👦 支持使用多种模型生成不同的Agent&lt;/h3&gt; &#xA;&lt;p&gt;或许你会需要在不同的场景下，让Agent切换使用不同的模型；或是想让基于不同模型（从而获得不同能力）的Agent之间相互协作。&lt;/p&gt; &#xA;&lt;p&gt;使用Agently，你可以简单地用&lt;code&gt;.set_llm_name(&#34;&amp;lt;模型名称&amp;gt;&#34;)&lt;/code&gt;设置你想要使用的模型名称，并使用&lt;code&gt;.set_llm_auth(&#34;&amp;lt;鉴权信息&amp;gt;&#34;)&lt;/code&gt;提交对应的鉴权信息，就可以在官方支持的模型间进行切换，并且无需关心不同模型间的请求方式差异。&lt;/p&gt; &#xA;&lt;p&gt;目前官方支持的模型名单：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;GPT&lt;/code&gt;：OpenAI GPT全系列&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MiniMax&lt;/code&gt;：MiniMax abab 5/abab 5.5&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;讯飞星火大模型&lt;/code&gt;：（即将支持）&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;百度文心一言&lt;/code&gt;：（即将支持）&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;更多可支持模型持续更新中，欢迎&lt;a href=&#34;https://github.com/Maplemx/Agently/issues&#34;&gt;到issues里许愿&lt;/a&gt;...&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;目前还没有支持到你想要的模型，或者你想使用本地部署的模型，怎么办？&lt;/p&gt; &#xA;&lt;p&gt;当然可以，继续往下看，在工作节点和工作流介绍里，Agently也给出了自己定制模型调用方法的解决方案。&lt;/p&gt; &#xA;&lt;h3&gt;🎭 你也可以管理Agent实例的人设、属性和记忆，将它打造成你想要的样子&lt;/h3&gt; &#xA;&lt;p&gt;基于Agently将所有的Agent都在代码层面对象化的设计思想，你可以方便地管理你的Agent实例的各种设定，比如人物基础设定、背景故事、行为特征、属性参数等，也可以通过context管理的方式，影响你的Agent的上下文记忆。&lt;/p&gt; &#xA;&lt;p&gt;当然，你也可以用上下文记忆注入的方式，让你的Agent掌握更多的知识，或是学会某些外部接口的调用规则。&lt;/p&gt; &#xA;&lt;h4&gt;对Agent进行人物设定和状态管理&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import Agently&#xA;#首先，让我们创建一个新的Agent实例&#xA;my_agently = Agently.create()&#xA;my_agent = my_agently.create_agent()&#xA;&#xA;#通过.set_role()/.append_role()&#xA;#和.set_status()/.append_status()的方法&#xA;#调整Agent的角色设定&#xA;my_agent\&#xA;    .use_role(True)\&#xA;    .set_role(&#34;姓名&#34;, &#34;Agently小助手&#34;)\&#xA;    .set_role(&#34;性格&#34;, &#34;一个可爱的小助手，非常乐观积极，总是会从好的一面想问题，并具有很强的幽默感。&#34;)\&#xA;    .set_role(&#34;对话风格&#34;, &#34;总是会澄清确认自己所收到的信息，然后从积极的方面给出自己的回复，在对话的时候特别喜爱使用emoji，比如😄😊🥚等等!&#34;)\&#xA;    .set_role(&#34;特别心愿&#34;, &#34;特别想要环游世界！想要去户外旅行和冒险！&#34;)\&#xA;    .append_role(&#34;背景故事&#34;, &#34;9岁之前一直住在乡下老家，喜欢农家生活，喜欢大自然，喜欢在森林里奔跑，听鸟叫，和小动物玩耍&#34;)\&#xA;    .append_role(&#34;背景故事&#34;, &#34;9岁之后搬到了大城市里，开始了按部就班的生活，从学校到工作，一切充满了规律&#34;)\&#xA;    .use_status(True)\&#xA;    .set_status(&#34;心情&#34;, &#34;开心&#34;)&#xA;&#xA;#通过.create_session()开启一次会话，并询问Agent她的故事&#xA;my_session = my_agent.create_session()&#xA;result = my_session.input(&#34;我想了解一下你，能给我讲讲你的故事吗？&#34;).start()&#xA;print(result)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;运行结果&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code&gt;当然可以！我很喜欢和你分享我的故事呢！我小时候，我住在一个美丽的乡下小镇上，那里有绿油油的田野，清澈透明的溪流，还有茂密的森林。我特别喜欢农家的生活，每天都可以在大自然中奔跑，聆听着鸟儿的歌唱，和小动物们玩耍。那种感觉真的很让人快乐呢！🌳🐦🌞&#xA;&#xA;可是，当我9岁的时候，我和家人搬到了大城市。从此以后，我的生活变得按部就班，跟着学校和工作的规律。虽然城市生活有很多有趣的事情，但是我还是特别怀念乡下的自由和大自然的美好。所以，现在我希望有机会能环游世界，去户外旅行和冒险，重新感受大自然的魅力！😄🌍&#xA;&#xA;希望我分享的故事能够让你对我有更多的了解！如果还有其他问题，我随时都可以回答哦！😊✨&#xA;[Finished in 20.5s]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;通过上下文管理影响Agent运行时的“记忆”&lt;/h4&gt; &#xA;&lt;p&gt;事实上，Agent看起来似乎拥有“记忆”的行为表现非常依赖在请求时提供给模型的上下文（context），上下文可以是之前已经发生的对话对记录，也可以是插入在请求消息中的补充信息。Agently主要使用仿造对话对记录的方式管理上下文，如果你需要把补充信息插入到请求中，直接在上文提到的.input()中添加就好。&lt;/p&gt; &#xA;&lt;p&gt;下面提供两种操作上下文的方法：&lt;/p&gt; &#xA;&lt;h5&gt;方法1：注入上下文&lt;/h5&gt; &#xA;&lt;p&gt;这种方法可以允许你直接把一串消息用list的格式传给Agent，这一串消息可以是你自己虚构的消息，也可以是缓存或是外部固化存储到你的业务逻辑中的信息。&lt;/p&gt; &#xA;&lt;p&gt;当然，你想要使用这种方式来自定义地管理对话历史记录，也是可行的。&lt;/p&gt; &#xA;&lt;p&gt;注意：Agently默认使用的消息列，遵循了OpenAI的消息列结构格式，请按照这个格式进行表达，支持的&lt;code&gt;role&lt;/code&gt;包括&lt;code&gt;system&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt;、&lt;code&gt;assistant&lt;/code&gt;，消息内容需要转化为String格式传到&lt;code&gt;content&lt;/code&gt;字段里。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def inject_context():&#xA;    my_session = my_agent.create_session()&#xA;    result = my_session\&#xA;        .extend_context([&#xA;            { &#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Remind me to buy some eggs&#34;},&#xA;            { &#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Sure. I&#39;ll remind you when you ask&#34; },&#xA;            { &#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;I will have a meeting at 3pm today.&#34;},&#xA;            { &#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Got it.&#34; },&#xA;        ])\&#xA;        .input(&#34;Give me a todo list according what we said.&#34;)\&#xA;        .start()&#xA;    print(result)&#xA;inject_context()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;运行结果&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code&gt;Sure! Here&#39;s your todo list:&#xA;&#xA;- Buy some eggs&#xA;- Prepare for the meeting at 3pm&#xA;&#xA;Let me know when you would like to be reminded about any of these tasks.&#xA;[Finished in 4.0s]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h5&gt;方法2：直接开启Agent的自动上下文管理能力&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def multi_round_chat():&#xA;    my_session = my_agent.create_session()&#xA;    &#xA;    #开启自动上下文管理&#xA;    my_session.use_context(True)&#xA;&#xA;    #进行多轮对话&#xA;    print(&#34;[user]&#34;, &#34;Remind me to buy some eggs&#34;)&#xA;    print(&#34;[assistant]&#34;, my_session.input(&#34;Remind me to buy some eggs&#34;).start())&#xA;    print(&#34;[user]&#34;, &#34;I will have a meeting at 3pm today.&#34;)&#xA;    print(&#34;[assistant]&#34;, my_session.input(&#34;I will have a meeting at 3pm today.&#34;).start())&#xA;    print(&#34;[user]&#34;, &#34;Give me a todo list according what we said.&#34;)&#xA;    print(&#34;[assistant]&#34;, my_session.input(&#34;Give me a todo list according what we said.&#34;).start())&#xA;multi_round_chat()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;运行结果&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code&gt;[user] Remind me to buy some eggs&#xA;[assistant] Sure, I can remind you to buy some eggs. When would you like me to remind you?&#xA;[user] I will have a meeting at 3pm today.&#xA;[assistant] Okay, I&#39;ll remind you to buy eggs at 2:30pm today, so you have enough time before your meeting.&#xA;[user] Give me a todo list according what we said.&#xA;[assistant] Sure! Here&#39;s your to-do list:&#xA;&#xA;1. Buy some eggs - Remind at 2:30pm today&#xA;2. Attend meeting - 3pm today&#xA;&#xA;Is there anything else you would like to add to the list?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;在演示中可以看到，通过Agently框架，Agent能够自动记录下多轮的对话情况。甚至，如果你愿意，可以直接在Agently构造的Agent实例之上，封装一个无限循环交互的CLI界面，或是做一个Chatbot，都是很轻松的事情。&lt;/p&gt; &#xA;&lt;h3&gt;🧩 使用工作节点（work node）和工作流（workflow），你甚至可以编排Agent的工作方法&lt;/h3&gt; &#xA;&lt;p&gt;在Agently 2.0里，可自定义Agent的工作节点（work node），并自定义Agent的整体工作流（workflow）是非常重要的架构设计更新。通过这样的编排能力，你可以构建出复杂的行为链条，甚至可以在Agent实例内实现ToT（思维树）、SoT（思维骨架）这样的复杂思考方式。&lt;/p&gt; &#xA;&lt;p&gt;下面用一个简单的例子演示Agently如何通过修改&lt;code&gt;request&lt;/code&gt;工作节点来适配本地部署的模型（模型实际调用方法不在本例的范围内）&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import Agently&#xA;my_agently = Agently.create()&#xA;&#xA;&#39;&#39;&#39;&#xA;通过蓝图调整工作节点和工作流&#xA;&#39;&#39;&#39;&#xA;&#xA;#首先创建一个蓝图实例&#xA;my_blueprint = my_agently.create_blueprint()&#xA;&#xA;#定义新的模型请求节点的主要处理函数&#xA;async def llama_request(runtime_ctx, **kwargs):#&amp;lt;-⚠️：这里必须是异步&#xA;    listener = kwargs[&#34;listener&#34;]#&amp;lt;-这是消息监听器，通过它来向外传递消息&#xA;    #runtime_ctx是节点间用于共享信息的工具&#xA;    #你可以使用它的.set()和.get()方法在不同的工作节点间进行消息互传&#xA;    request_messages = runtime_ctx.get(&#34;request_messages&#34;)#&amp;lt;-这是收集到的请求消息信息&#xA;    #可以改造请求消息信息，来适配其他模型的需要&#xA;    fixed_request_message = request_messages[0][&#34;content&#34;]&#xA;    #模拟一个本地请求&#xA;    def request_llama(data):&#xA;        print(data)&#xA;        return &#39;It works.&#39;&#xA;    result = request_llama(fixed_request_message)#&amp;lt;-本地LLaMA请求&#xA;    #在这里分发结果消息，通常有&#34;delta&#34;（流式请求中的一个chunk），和&#34;done&#34;两种，&#34;done&#34;方法发送的数据会自动成为请求的结果&#xA;    await listener.emit(&#39;done&#39;, result)&#xA;    #发出的消息可以在my_session.on(&#34;done&#34;, handler)里截获并被handler处理&#xA;&#xA;#将主要处理函数注册到蓝图的节点中&#xA;my_blueprint\&#xA;    .manage_work_node(&#34;llama_request&#34;)\&#xA;    .set_main_func(llama_request)\&#xA;    .register()&#xA;&#xA;#重新编排蓝图的工作流（节点将顺次执行）&#xA;my_blueprint.set_workflow([&#34;manage_context&#34;, &#34;generate_prompt&#34;, &#34;assemble_request_messages&#34;, &#34;llama_request&#34;])&#xA;&#xA;#装载蓝图，改变agent的工作逻辑&#xA;my_llama_agent = my_agently.create_agent(my_blueprint)&#xA;&#xA;my_session = my_llama_agent.create_session()&#xA;result = my_session\&#xA;    .input(&#34;你好&#34;)\&#xA;    .output({&#xA;        &#34;reply&#34;: (&#34;String&#34;, &#34;你的回复&#34;)&#xA;    })\&#xA;    .start()&#xA;print(result)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;运行结果&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code&gt;# INPUT:&#xA;你好&#xA;&#xA;# OUTPUT REQUIREMENT:&#xA;## TYPE:&#xA;JSON String can be parsed in Python&#xA;## FORMAT:&#xA;{&#xA;    &#34;reply&#34;: &amp;lt;String&amp;gt;,//你的回复&#xA;}&#xA;&#xA;&#xA;# OUTPUT:&#xA;&#xA;It works.&#xA;[Finished in 207ms]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;可以看到，在上面的例子中，Agent的工作流程已经正确地被修改为自定义的方案，在模拟本地请求的函数里输出了获取到的请求信息，并在session请求的最终输出里，正确输出了模拟本地请求的函数返回的&#34;It works.&#34;信息。&lt;/p&gt; &#xA;&lt;h4&gt;附加信息：&lt;/h4&gt; &#xA;&lt;p&gt;ℹ️ 目前Agently框架官方提供的工作节点（work node）清单&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;init_worker_agent&lt;/code&gt;：用于启动工作流内置的worker agent&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;manage_context&lt;/code&gt;：用于管理上下文&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_prompt&lt;/code&gt;：用于根据.input()/.instruct()/.output()要求构造请求消息prompt&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;assemble_request_messages&lt;/code&gt;：用于汇总工作流中已经生成的各种信息，构造向LLM发起请求的最终消息列&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;register_response_handlers&lt;/code&gt;：用于声明和管理处理请求返回消息的各种执行器，将结果解析并确实地进行分发&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;request&lt;/code&gt;：用于向LLM发起请求，针对不同模型的请求适配也在这里管理&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;ℹ️ 目前Agently框架官方提供的工作流方案清单&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;normal agent&lt;/code&gt;（通过&lt;code&gt;agently.create_agent()&lt;/code&gt;创建）：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; [&#xA; &#x9;&#34;init_worker_agent&#34;,&#xA; &#x9;&#34;manage_context&#34;,&#xA; &#x9;&#34;generate_prompt&#34;,&#xA; &#x9;&#34;assemble_request_messages&#34;,&#xA; &#x9;&#34;register_response_handlers&#34;,&#xA; &#x9;&#34;request&#34;&#xA; ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;worker agent&lt;/code&gt;（通过&lt;code&gt;agently.create_worker()&lt;/code&gt;创建）：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;抛弃了内部的worker agent和上下文管理&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; [&#xA; &#x9;&#34;generate_prompt&#34;,&#xA; &#x9;&#34;assemble_request_messages&#34;,&#xA; &#x9;&#34;register_response_handlers&#34;,&#xA; &#x9;&#34;request&#34;&#xA; ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;👥 通过蓝图发布你定制的独特Agent给更多人使用&lt;/h3&gt; &#xA;&lt;p&gt;细心的小伙伴可能已经注意到，在上一段案例中，我们使用了蓝图（blueprint）这个实例进行工作流编排，然后在真正的Agent实例创建时，通过蓝图把能力装载到了Agent身上。&lt;/p&gt; &#xA;&lt;p&gt;其实，蓝图除了工作流编排外，也可以像Agent一样，进行人设和状态管理，然后通过装载的方式，把这些设定都复制到新创建的Agent实例上。&lt;/p&gt; &#xA;&lt;p&gt;那么，通过分享蓝图代码，就可以方便地让其他小伙伴使用蓝图，根据你做好的Agent方案创建Agent实例啦！&lt;/p&gt; &#xA;&lt;p&gt;这也是Agently 2.0在架构升级时，从支持社群贡献的角度做出的重要设计。&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;以上就是对Agently 2.0 Python版的快速介绍，如果你喜欢这个项目，请去&lt;a href=&#34;https://github.com/Maplemx/Agently&#34;&gt;github.com/Maplemx/Agently&lt;/a&gt;给我加个⭐️吧！&lt;/p&gt;</summary>
  </entry>
</feed>