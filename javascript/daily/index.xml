<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-27T01:37:52Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cruip/tailwind-dashboard-template</title>
    <updated>2023-02-27T01:37:52Z</updated>
    <id>tag:github.com,2023-02-27:/cruip/tailwind-dashboard-template</id>
    <link href="https://github.com/cruip/tailwind-dashboard-template" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mosaic Lite is a free admin dashboard template built on top of Tailwind CSS and fully coded in React. Made by&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Free Tailwind dashboard template&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/2683512/115404502-ad322d80-a1ed-11eb-91c0-1aa79b0949f0.png&#34; alt=&#34;Mosaic TailwindCSS template preview&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mosaic Lite&lt;/strong&gt; is a responsive dashboard template built on top of TailwindCSS and fully coded in React. It comes with several pre-coded charts (built with Chart.js 3) and widgets, and it&#39;s a great starting for anyone who wants to create a user interface for SaaS products, administrator dashboards, modern web apps, and more.&lt;/p&gt; &#xA;&lt;p&gt;Use it for whatever you want, and be sure to reach us out on &lt;a href=&#34;https://twitter.com/Cruip_com&#34;&gt;Twitter&lt;/a&gt; if you build anything cool/useful with it.&lt;/p&gt; &#xA;&lt;p&gt;Created and maintained with ‚ù§Ô∏è by &lt;a href=&#34;https://cruip.com/&#34;&gt;Cruip.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Live demo&lt;/h2&gt; &#xA;&lt;p&gt;Check the live demo here üëâÔ∏è &lt;a href=&#34;https://mosaic.cruip.com/&#34;&gt;https://mosaic.cruip.com/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Mosaic Pro&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cruip.com/mosaic/&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/2683512/151177026-3d063355-976d-4fdb-a5ed-9c1501c58af2.png&#34; alt=&#34;Mosaic Pro&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Design files&lt;/h2&gt; &#xA;&lt;p&gt;If you need the design files, you can download them from Figma&#39;s Community üëâ &lt;a href=&#34;https://bit.ly/3sigqHe&#34;&gt;https://bit.ly/3sigqHe&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#project-setup&#34;&gt;Project setup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#compiles-and-hot-reloads-for-development&#34;&gt;Compiles and hot-reloads for development&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#compiles-and-minifies-for-production&#34;&gt;Compiles and minifies for production&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#customize-configuration&#34;&gt;Customize configuration&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#support-notes&#34;&gt;Support notes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#terms-and-license&#34;&gt;Terms and License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#about-us&#34;&gt;About Us&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cruip/tailwind-dashboard-template/main/#stay-in-the-loop&#34;&gt;Stay in the loop&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;This project was bootstrapped with &lt;a href=&#34;https://vitejs.dev/&#34;&gt;Vite&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Project setup&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Compiles and hot-reloads for development&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Compiles and minifies for production&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm run build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Customize configuration&lt;/h4&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://vitejs.dev/guide/&#34;&gt;Configuration Reference&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Support notes&lt;/h3&gt; &#xA;&lt;p&gt;We are shipping our templates with a very basic React configuration to let you quickly get into the development process, but we don&#39;t discourage you from using any other configuration or framework built on the top of React. So, please note that any request dealing with React (e.g. extra features, customisations, et cetera) is to be considered out of the support scope.&lt;/p&gt; &#xA;&lt;p&gt;For more information about what support covers, please see our (FAQs)[https://cruip.com/faq/].&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nucleoapp.com/&#34;&gt;Nucleo&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Terms and License&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Released under the &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.html&#34;&gt;GPL&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Copyright 2020 &lt;a href=&#34;https://cruip.com/&#34;&gt;Cruip&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Use it for personal and commercial projects, but please don‚Äôt republish, redistribute, or resell the template.&lt;/li&gt; &#xA; &lt;li&gt;Attribution is not required, although it is really appreciated.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About Us&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re an Italian developer/designer duo creating high-quality design/code resources for developers, makers, and startups.&lt;/p&gt; &#xA;&lt;h2&gt;Stay in the loop&lt;/h2&gt; &#xA;&lt;p&gt;If you would like to know when we release new resources, you can follow us on &lt;a href=&#34;https://twitter.com/Cruip_com&#34;&gt;Twitter&lt;/a&gt;, or you can subscribe to our monthly &lt;a href=&#34;https://cruip.com/#subscribe&#34;&gt;newsletter&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/swissgl</title>
    <updated>2023-02-27T01:37:52Z</updated>
    <id>tag:github.com,2023-02-27:/google/swissgl</id>
    <link href="https://github.com/google/swissgl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SwissGL is a minimalistic wrapper on top of WebGL2 JS API. It&#39;s designed to reduce the amount of boilerplate code required to manage GLSL shaders, textures and framebuffers when making procedural visualizations or simulations.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwissGL: Swiss Army knife for WebGL2&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://google.github.io/swissgl&#34;&gt;DEMO&lt;/a&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/docs/API.md&#34;&gt;API&lt;/a&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/docs/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;SwissGL is a minimalistic wrapper on top of WebGL2 JS API. It&#39;s designed to reduce the amount of boilerplate code required to manage GLSL shaders, textures and framebuffers when making GPGPU-style procedural visualizations or simulations. See the &lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/demo/&#34;&gt;demos&lt;/a&gt; for examples of using SwissGL. As of now the library consists of a standalone ~500 loc .js file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt; This is not an officially supported Google product. SwissGL is an early stage experiment, incomplete and unstable. It&#39;s an invitation to discuss compact and expressive graphics library design, which I hope is relevant in light of the upcoming arrival of WebGPU.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;As of now, the library API consists of a single function object that does everything (like a Swiss Army knife). Here is a minimal example of using it to draw an animated gradient quad:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;script src=&#34;swissgl.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;canvas id=&#34;c&#34; width=&#34;600&#34; height=&#34;400&#34;&amp;gt;&amp;lt;/canvas&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    const canvas = document.getElementById(&#39;c&#39;);&#xA;    const glsl = SwissGL(canvas);&#xA;&#xA;    function render(t) {&#xA;        t /= 1000; // ms to sec&#xA;        glsl({t}, `UV,cos(t*TAU),1`);&#xA;        requestAnimationFrame(render);&#xA;    }&#xA;    render(0.0);&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/quad.png&#34; alt=&#34;SwissGL quad gradient&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This line creates a SwissGL library instance that wraps a WebGL2 context of a given &lt;code&gt;canvas&lt;/code&gt; element (you can also pass a WebGL2 context):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const glsl = SwissGL(canvas);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can already draw something:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;glsl({t}, `UV,cos(t*10.0),1`);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This line, called during the animation loop, creates a shader that evaluates the given expression string into RGBA-color for every pixel on the canvas. &lt;code&gt;vec2 UV&lt;/code&gt; variable provides &lt;code&gt;[0,1]&lt;/code&gt;-range normalized coordinates of the current pixel, and &lt;code&gt;ivec2 I&lt;/code&gt; can be used to get integer coordinates. The shader is compiled and cached during the first call and reused later.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;glsl&lt;/code&gt; function has at most three arguments, some of which can be omitted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;glsl(params, code, target);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/docs/API.md&#34;&gt;API reference&lt;/a&gt; for the detailed explanation of their function. Let&#39;s now have a look at the more elaborate example of using SwissGL to implement a particle simulation.&lt;/p&gt; &#xA;&lt;h2&gt;Particle Life&lt;/h2&gt; &#xA;&lt;p&gt;Inspired by the &lt;a href=&#34;https://youtu.be/p4YirERTVF0?t=481&#34;&gt;beautiful video&lt;/a&gt; by Tom Mohr, let&#39;s try reproduce the &#34;snake&#34; pattern shown there. Particle Life is made of particles of a few different types. All particles repel when they are closer than some distance $r$, but at around $2r$ the resulting (potentially non-symmetric) force is described by the special force matrix $F_{i,j}$, where $i,j$ are types of two particles. Positive $F$ corresponds to attraction and negative to repulsion. Let&#39;s create a texture that stores such a matrix. We can create an array on the JS side and pass it to SwissGL, but it&#39;s even easier to populate matrix values right on GPU:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const K = 6; // number of particle types&#xA;const F = glsl(`&#xA;    float(I.x==I.y) + 0.1*float(I.x==I.y+1)`,&#xA;    {size:[K,K], format:&#39;r16f&#39;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates a single channel float16 texture of size &lt;code&gt;[width,height]==[6,6]&lt;/code&gt; and populates its values by evaluating the expression. &lt;code&gt;I&lt;/code&gt; is a special variable of type &lt;code&gt;ivec2&lt;/code&gt; that contains coordinates of the pixel being evaluated.&lt;/p&gt; &#xA;&lt;p&gt;We can easily visualize the resulting texture to make sure everything is ok:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;glsl({F}, `F(I/20).x*3.0`);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/F.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Uniform textures can be accessed with usual GLSL functions, or with a helper macro that has the same name as the texture uniform. Passing &lt;code&gt;ivec2&lt;/code&gt; as parameter makes it call &lt;code&gt;texelFetch()&lt;/code&gt; to get a texel using the integer coordinates, passing &lt;code&gt;vec2&lt;/code&gt; uses &lt;code&gt;texture()&lt;/code&gt;, with filtering and wrapping.&lt;/p&gt; &#xA;&lt;p&gt;The next step is to create a list of textures that is going to contain particle positions. Each pixel will contain a single particle position and type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const points = glsl({size:[30,10], story:3, format:&#39;rgba32f&#39;, tag:&#39;points&#39;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We are going to simulate 30*10=300 particles. Textures will have 4 channels (RGBA) of type float32. The &lt;code&gt;story:3&lt;/code&gt; argument says that we need to create a cyclic buffer of three textures of the same format, so that we can read two consecutive states of the particle system (for momentum) to produce the third. We don&#39;t provide shader &lt;code&gt;code&lt;/code&gt; to the SwissGL call, so we must specify the storage &lt;code&gt;tag&lt;/code&gt;. Now we can initialize these textures:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;for (let i=0; i&amp;lt;2; ++i) {&#xA;    glsl({K, seed:123}, `&#xA;        vec2 pos = (hash(ivec3(I, seed)).xy-0.5)*10.0;&#xA;        float color = floor(UV.x*K);&#xA;        out0 = vec4(pos, 0.0, color);`,&#xA;        points);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The shader code above uses &#34;multiline&#34; shader &lt;code&gt;code&lt;/code&gt; format instead of a single expression. The output must be written to a global variable &lt;code&gt;out0&lt;/code&gt;. Variable &lt;code&gt;UV&lt;/code&gt; has type &lt;code&gt;vec2&lt;/code&gt; and provides &lt;code&gt;[0,1]&lt;/code&gt;-range normalized coordinates of the current pixel. It is used to assign one of &lt;code&gt;K&lt;/code&gt; &#34;colors&#34; to each particle. For convenience SwissGL provides a &lt;a href=&#34;https://raw.githubusercontent.com/google/swissgl/main/TODO&#34;&gt;simple hash&lt;/a&gt; function &lt;code&gt;vec3 hash(ivec3)&lt;/code&gt; that can be used as a deterministic random number generator.&lt;/p&gt; &#xA;&lt;p&gt;Note that we are writing the same particle positions two times, which means that particles have zero velocity at initialization. Now &lt;code&gt;points[0]&lt;/code&gt; and &lt;code&gt;points[1]&lt;/code&gt; contain the same values, and &lt;code&gt;points[2]&lt;/code&gt; is uninitialized and is going to be overwritten at the first simulation step.&lt;/p&gt; &#xA;&lt;p&gt;Before we start modeling the particle dynamics it&#39;s a good idea to implement visualization. So far we&#39;ve already seen &#34;expression&#34; and &#34;multiline&#34; shortcut &lt;code&gt;code&lt;/code&gt; formats. Now we are going to write a &lt;code&gt;full&lt;/code&gt; vertex-fragment shader pair:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;glsl({K, worldExtent,  // uniforms&#xA;      // reading the last state of &#39;points&#39; texture&#xA;      points: points[0], &#xA;      // render a quad instance for every &#39;points&#39; texel&#xA;      Grid: points[0].size,&#xA;      // preserve the scale of xy-axes by fitting&#xA;      // [-1..1]x[-1..1] box into the view&#xA;      Aspect:&#39;fit&#39;,&#xA;      // blend primitives using alpha transparency&#xA;      Blend: &#39;d*(1-sa)+s*sa&#39;}, `&#xA;&#xA;// the code below is available in both&#xA;// vertex and fragment shaders&#xA;varying vec3 color;&#xA;&#xA;//VERT  start of vertex-only section&#xA;// vertex function is called &#xA;vec4 vertex() {&#xA;    // get current particle data&#xA;    vec4 d = points(ID);&#xA;    // populate varyings to use in fragment shader&#xA;    color = cos((d.w/K+vec3(0,0.33,0.66))*TAU)*0.5+0.5;&#xA;    // emit normalized on-screen vertex position&#xA;    // &#39;vec2 XY&#39; is contains coordinates of the quad vertex in -1..1 range&#xA;    return vec4(2.0*(d.xy+XY/8.0)/worldExtent, 0.0, 1.0);&#xA;}&#xA;&#xA;//FRAG  start of fragment-only section&#xA;void fragment() {&#xA;    // Compute the fragment transparency depending&#xA;    // on the distance from the quad center.&#xA;    // Interpolated XY is also available in the fragment shader.&#xA;    float alpha = smoothstep(1.0, 0.6, length(XY));&#xA;    // set the fragment color&#xA;    out0 = vec4(color, alpha);&#xA;}`); // &#39;target&#39; is omitted, so rendering to canvas&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running this code in the drawing loop produces the following image:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/init_particles.png&#34; alt=&#34;Initial particles&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The vertex shader computes WebGL &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#clip_space&#34;&gt;Clip Space&lt;/a&gt; coordinates for each corner of each particle quad. We map particle positions from &lt;code&gt;[-worldExtent/2, worldExtent/2]&lt;/code&gt; range to &lt;code&gt;[-1,1]&lt;/code&gt; box. This shader also computes particle color using &lt;a href=&#34;https://iquilezles.org/articles/palettes/&#34;&gt;cosine palettes trick&lt;/a&gt; and passes it to the fragment shader along with the corner offset vector. The fragment shader calculates pixel opacity &lt;code&gt;alpha&lt;/code&gt; using the distance form the particle center and sets &lt;code&gt;out0&lt;/code&gt; variable. This way we can use low-level GLSL as an expressive, flexible and performant tool to render large numbers of primitives.&lt;/p&gt; &#xA;&lt;p&gt;Now we can set particles in motion by writing the update shader that computes new particle positions each frame.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;glsl({F, worldExtent, repulsion, inertia, dt, // uniforms&#xA;      // The current state of the system is implicitly&#xA;      // available to the shader as &#39;Src&#39; uniform if&#xA;      // the target has history (is an array of textures).&#xA;      // Here we explicitly pass the state one step at the past&#xA;      past:points[1]}, `&#xA;// this function wraps positions and velocities to&#xA;// [-worldExtent/2, worldExtent/2] range&#xA;vec3 wrap(vec3 p) {&#xA;    return (fract(p/worldExtent+0.5)-0.5)*worldExtent;&#xA;}&#xA;void fragment() {&#xA;    // read the current particle state&#xA;    out0 = Src(I);&#xA;    vec3 force=vec3(0); // force accumulator&#xA;    // iterate over particles&#xA;    for (int y=0; y&amp;lt;ViewSize.y; ++y)&#xA;    for (int x=0; x&amp;lt;ViewSize.x; ++x) {&#xA;        // reading the state of another particle&#xA;        vec4 data1 = Src(ivec2(x,y));&#xA;        vec3 dpos = wrap(data1.xyz-out0.xyz);&#xA;        // calculate distance&#xA;        float r = length(dpos);&#xA;        if (r&amp;gt;3.0) continue;&#xA;        dpos /= r+1e-8;&#xA;        // calculate repulsion and interaction forces&#xA;        float rep = max(1.0-r, 0.0)*repulsion;&#xA;        float f = F(ivec2(out0.w, data1.w)).x;&#xA;        float inter = f*max(1.0-abs(r-2.0), 0.0);&#xA;        force += dpos*(inter-rep);&#xA;    }&#xA;    // fetch the past state to compute velocity&#xA;    vec3 vel = wrap(out0.xyz-past(I).xyz)*pow(inertia, dt);&#xA;    // update particle position&#xA;    out0.xyz = wrap(out0.xyz+vel+0.5*force*(dt*dt));&#xA;}&#xA;`, points);  // using &#39;points&#39; as the target&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Soon randomly scattered particles self-assemble into a nice colorful snake! The simulation is happening on the GPU and is quite fast for the quadratic complexity algorithm (that iterates all particle pairs). Even mobile phones can run hundreds of steps per second. Thanks to SwissGL, orchestrating this computation, managing shaders and framebuffers takes minimal amount of boilerplate code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/swissgl/main/images/particle_snake.png&#34; alt=&#34;Partilce Snake&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;p&gt;Sources of wisdom:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://iquilezles.org/&#34;&gt;Inigo Quilez&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://acko.net/&#34;&gt;Steven Wittens&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://webglfundamentals.org/&#34;&gt;WebGL&lt;/a&gt; / &lt;a href=&#34;https://webgl2fundamentals.org/&#34;&gt;WebGL2&lt;/a&gt; fundamentals&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Playgrounds:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.shadertoy.com/&#34;&gt;ShaderToy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twigl.app/&#34;&gt;twigl&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.vertexshaderart.com/&#34;&gt;vertexshaderart&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Libraries&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://threejs.org/&#34;&gt;three.js&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://usegpu.live/&#34;&gt;Use.GPU&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/unconed/mathbox&#34;&gt;MathBox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twgljs.org/&#34;&gt;twgljs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/regl-project/regl&#34;&gt;regl&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/amandaghassaei/gpu-io&#34;&gt;gpu-io&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://luma.gl/&#34;&gt;luma.gl&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>MHSanaei/3x-ui</title>
    <updated>2023-02-27T01:37:52Z</updated>
    <id>tag:github.com,2023-02-27:/MHSanaei/3x-ui</id>
    <link href="https://github.com/MHSanaei/3x-ui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Xray panel supporting multi-protocol multi-user expire day &amp; traffic (Vmess &amp; Vless &amp; Trojan)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;3x-ui&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/mhsanaei/3x-ui.svg?sanitize=true&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/mhsanaei/3x-ui/release.yml.svg?sanitize=true&#34; alt=&#34;&#34;&gt; &lt;a href=&#34;https://img.shields.io/github/go-mod/go-version/mhsanaei/3x-ui&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/go-mod/go-version/mhsanaei/3x-ui.svg?sanitize=true&#34; alt=&#34;GO Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://img.shields.io/github/downloads/mhsanaei/3x-ui/total&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/mhsanaei/3x-ui/total.svg?sanitize=true&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.en.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL%20V3-blue.svg?longCache=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Disclaimer: This project is only for personal learning and communication, please do not use it for illegal purposes, please do not use it in a production environment&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;xray panel supporting multi-protocol, &lt;strong&gt;Multi-lang (English,Farsi,Chinese)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Install &amp;amp; Upgrade&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;bash &amp;lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;SSL&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get install certbot -y&#xA;certbot certonly --standalone --agree-tos --register-unsafely-without-email -d yourdomain.com&#xA;certbot renew --dry-run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you think this project is helpful to you, you may wish to give a&lt;/strong&gt; &lt;span&gt;üåü&lt;/span&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Default settings&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Port: 2053&lt;/li&gt; &#xA; &lt;li&gt;username and password will be generated randomly you can see them after you install it (x-ui &#34;7&#34;)&lt;/li&gt; &#xA; &lt;li&gt;database path: /etc/x-ui/x-ui.db&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;before you set ssl on settings&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;http:// ip or domain:2053/xui&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After you set ssl on settings&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://yourdomain:2053/xui&#34;&gt;https://yourdomain:2053/xui&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;for enable traffic for users you should do :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;xray Configuration :&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &#34;policy&#34;: {&#xA;    &#34;levels&#34;: {&#xA;      &#34;0&#34;: {&#xA;        &#34;statsUserUplink&#34;: true,&#xA;        &#34;statsUserDownlink&#34;: true&#xA;      }&#xA;    },&#xA;&#xA;    &#34;system&#34;: {&#xA;      &#34;statsInboundDownlink&#34;: true,&#xA;      &#34;statsInboundUplink&#34;: true&#xA;    }&#xA;  },&#xA;  &#34;routing&#34;: {&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;suggestion system&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ubuntu 20.04+&lt;/li&gt; &#xA; &lt;li&gt;Debian 10&lt;/li&gt; &#xA; &lt;li&gt;CentOS 8&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;pic&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MHSanaei/3x-ui/main/media/1.png&#34; alt=&#34;1&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MHSanaei/3x-ui/main/media/2.png&#34; alt=&#34;2&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MHSanaei/3x-ui/main/media/3.png&#34; alt=&#34;3&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MHSanaei/3x-ui/main/media/4.png&#34; alt=&#34;4&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;a special thanks to&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vaxilu/&#34;&gt;vaxilu&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/HexaSoftwareTech/&#34;&gt;HexaSoftwareTech&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/diditra/&#34;&gt;diditra&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/FranzKafkaYu&#34;&gt;FranzKafkaYu&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alireza0/&#34;&gt;alireza0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Stargazers over time&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://starchart.cc/MHSanaei/3x-ui&#34;&gt;&lt;img src=&#34;https://starchart.cc/MHSanaei/3x-ui.svg?sanitize=true&#34; alt=&#34;Stargazers over time&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>