<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-02T01:26:47Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>polyfillpolyfill/fetch</title>
    <updated>2024-03-02T01:26:47Z</updated>
    <id>tag:github.com,2024-03-02:/polyfillpolyfill/fetch</id>
    <link href="https://github.com/polyfillpolyfill/fetch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A window.fetch JavaScript polyfill.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;window.fetch polyfill&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://securityscorecards.dev/viewer/?uri=github.com/JakeChampion/fetch&#34;&gt;&lt;img src=&#34;https://api.securityscorecards.dev/projects/github.com/JakeChampion/fetch/badge&#34; alt=&#34;OpenSSF Scorecard&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;fetch()&lt;/code&gt; function is a Promise-based mechanism for programmatically making web requests in the browser. This project is a polyfill that implements a subset of the standard &lt;a href=&#34;https://fetch.spec.whatwg.org&#34;&gt;Fetch specification&lt;/a&gt;, enough to make &lt;code&gt;fetch&lt;/code&gt; a viable replacement for most uses of XMLHttpRequest in traditional web applications.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#read-this-first&#34;&gt;Read this first&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#importing&#34;&gt;Importing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#html&#34;&gt;HTML&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#json&#34;&gt;JSON&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#response-metadata&#34;&gt;Response metadata&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#post-form&#34;&gt;Post form&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#post-json&#34;&gt;Post JSON&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#file-upload&#34;&gt;File upload&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#caveats&#34;&gt;Caveats&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#handling-http-error-statuses&#34;&gt;Handling HTTP error statuses&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#sending-cookies&#34;&gt;Sending cookies&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#receiving-cookies&#34;&gt;Receiving cookies&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#redirect-modes&#34;&gt;Redirect modes&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#obtaining-the-response-url&#34;&gt;Obtaining the Response URL&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#aborting-requests&#34;&gt;Aborting requests&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#browser-support&#34;&gt;Browser Support&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Read this first&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If you believe you found a bug with how &lt;code&gt;fetch&lt;/code&gt; behaves in your browser, please &lt;strong&gt;don&#39;t open an issue in this repository&lt;/strong&gt; unless you are testing in an old version of a browser that doesn&#39;t support &lt;code&gt;window.fetch&lt;/code&gt; natively. Make sure you read this &lt;em&gt;entire&lt;/em&gt; readme, especially the &lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#caveats&#34;&gt;Caveats&lt;/a&gt; section, as there&#39;s probably a known work-around for an issue you&#39;ve found. This project is a &lt;em&gt;polyfill&lt;/em&gt;, and since all modern browsers now implement the &lt;code&gt;fetch&lt;/code&gt; function natively, &lt;strong&gt;no code from this project&lt;/strong&gt; actually takes any effect there. See &lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#browser-support&#34;&gt;Browser support&lt;/a&gt; for detailed information.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you have trouble &lt;strong&gt;making a request to another domain&lt;/strong&gt; (a different subdomain or port number also constitutes another domain), please familiarize yourself with all the intricacies and limitations of &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&#34; title=&#34;Cross-origin resource sharing&#34;&gt;CORS&lt;/a&gt; requests. Because CORS requires participation of the server by implementing specific HTTP response headers, it is often nontrivial to set up or debug. CORS is exclusively handled by the browser&#39;s internal mechanisms which this polyfill cannot influence.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;This project &lt;strong&gt;doesn&#39;t work under Node.js environments&lt;/strong&gt;. It&#39;s meant for web browsers only. You should ensure that your application doesn&#39;t try to package and run this on the server.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you have an idea for a new feature of &lt;code&gt;fetch&lt;/code&gt;, &lt;strong&gt;submit your feature requests&lt;/strong&gt; to the &lt;a href=&#34;https://github.com/whatwg/fetch/issues&#34;&gt;specification&#39;s repository&lt;/a&gt;. We only add features and APIs that are part of the &lt;a href=&#34;https://fetch.spec.whatwg.org&#34;&gt;Fetch specification&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm install whatwg-fetch --save&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will also need a Promise polyfill for &lt;a href=&#34;https://caniuse.com/promises&#34;&gt;older browsers&lt;/a&gt;. We recommend &lt;a href=&#34;https://github.com/taylorhakes/promise-polyfill&#34;&gt;taylorhakes/promise-polyfill&lt;/a&gt; for its small size and Promises/A+ compatibility.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Importing&lt;/h3&gt; &#xA;&lt;p&gt;Importing will automatically polyfill &lt;code&gt;window.fetch&lt;/code&gt; and related APIs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import &#39;whatwg-fetch&#39;&#xA;&#xA;window.fetch(...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If for some reason you need to access the polyfill implementation, it is available via exports:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {fetch as fetchPolyfill} from &#39;whatwg-fetch&#39;&#xA;&#xA;window.fetch(...)   // use native browser version&#xA;fetchPolyfill(...)  // use polyfill implementation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This approach can be used to, for example, use &lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#aborting-requests&#34;&gt;abort functionality&lt;/a&gt; in browsers that implement a native but outdated version of fetch that doesn&#39;t support aborting.&lt;/p&gt; &#xA;&lt;p&gt;For use with webpack, add this package in the &lt;code&gt;entry&lt;/code&gt; configuration option before your application entry point:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;entry: [&#39;whatwg-fetch&#39;, ...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTML&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#39;/users.html&#39;)&#xA;  .then(function(response) {&#xA;    return response.text()&#xA;  }).then(function(body) {&#xA;    document.body.innerHTML = body&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JSON&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#39;/users.json&#39;)&#xA;  .then(function(response) {&#xA;    return response.json()&#xA;  }).then(function(json) {&#xA;    console.log(&#39;parsed json&#39;, json)&#xA;  }).catch(function(ex) {&#xA;    console.log(&#39;parsing failed&#39;, ex)&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Response metadata&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#39;/users.json&#39;).then(function(response) {&#xA;  console.log(response.headers.get(&#39;Content-Type&#39;))&#xA;  console.log(response.headers.get(&#39;Date&#39;))&#xA;  console.log(response.status)&#xA;  console.log(response.statusText)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Post form&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var form = document.querySelector(&#39;form&#39;)&#xA;&#xA;fetch(&#39;/users&#39;, {&#xA;  method: &#39;POST&#39;,&#xA;  body: new FormData(form)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Post JSON&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#39;/users&#39;, {&#xA;  method: &#39;POST&#39;,&#xA;  headers: {&#xA;    &#39;Content-Type&#39;: &#39;application/json&#39;&#xA;  },&#xA;  body: JSON.stringify({&#xA;    name: &#39;Hubot&#39;,&#xA;    login: &#39;hubot&#39;,&#xA;  })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;File upload&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var input = document.querySelector(&#39;input[type=&#34;file&#34;]&#39;)&#xA;&#xA;var data = new FormData()&#xA;data.append(&#39;file&#39;, input.files[0])&#xA;data.append(&#39;user&#39;, &#39;hubot&#39;)&#xA;&#xA;fetch(&#39;/avatars&#39;, {&#xA;  method: &#39;POST&#39;,&#xA;  body: data&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Caveats&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The Promise returned from &lt;code&gt;fetch()&lt;/code&gt; &lt;strong&gt;won&#39;t reject on HTTP error status&lt;/strong&gt; even if the response is an HTTP 404 or 500. Instead, it will resolve normally, and it will only reject on network failure or if anything prevented the request from completing.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For maximum browser compatibility when it comes to sending &amp;amp; receiving cookies, always supply the &lt;code&gt;credentials: &#39;same-origin&#39;&lt;/code&gt; option instead of relying on the default. See &lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#sending-cookies&#34;&gt;Sending cookies&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Not all Fetch standard options are supported in this polyfill. For instance, &lt;a href=&#34;https://raw.githubusercontent.com/polyfillpolyfill/fetch/main/#redirect-modes&#34;&gt;&lt;code&gt;redirect&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;cache&lt;/code&gt; directives are ignored.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;keepalive&lt;/code&gt; is not supported because it would involve making a synchronous XHR, which is something this project is not willing to do. See &lt;a href=&#34;https://github.com/github/fetch/issues/700#issuecomment-484188326&#34;&gt;issue #700&lt;/a&gt; for more information.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Handling HTTP error statuses&lt;/h4&gt; &#xA;&lt;p&gt;To have &lt;code&gt;fetch&lt;/code&gt; Promise reject on HTTP error statuses, i.e. on any non-2xx status, define a custom response handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function checkStatus(response) {&#xA;  if (response.status &amp;gt;= 200 &amp;amp;&amp;amp; response.status &amp;lt; 300) {&#xA;    return response&#xA;  } else {&#xA;    var error = new Error(response.statusText)&#xA;    error.response = response&#xA;    throw error&#xA;  }&#xA;}&#xA;&#xA;function parseJSON(response) {&#xA;  return response.json()&#xA;}&#xA;&#xA;fetch(&#39;/users&#39;)&#xA;  .then(checkStatus)&#xA;  .then(parseJSON)&#xA;  .then(function(data) {&#xA;    console.log(&#39;request succeeded with JSON response&#39;, data)&#xA;  }).catch(function(error) {&#xA;    console.log(&#39;request failed&#39;, error)&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Sending cookies&lt;/h4&gt; &#xA;&lt;p&gt;For &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&#34; title=&#34;Cross-origin resource sharing&#34;&gt;CORS&lt;/a&gt; requests, use &lt;code&gt;credentials: &#39;include&#39;&lt;/code&gt; to allow sending credentials to other domains:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#39;https://example.com:1234/users&#39;, {&#xA;  credentials: &#39;include&#39;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default value for &lt;code&gt;credentials&lt;/code&gt; is &#34;same-origin&#34;.&lt;/p&gt; &#xA;&lt;p&gt;The default for &lt;code&gt;credentials&lt;/code&gt; wasn&#39;t always the same, though. The following versions of browsers implemented an older version of the fetch specification where the default was &#34;omit&#34;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Firefox 39-60&lt;/li&gt; &#xA; &lt;li&gt;Chrome 42-67&lt;/li&gt; &#xA; &lt;li&gt;Safari 10.1-11.1.2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you target these browsers, it&#39;s advisable to always specify &lt;code&gt;credentials: &#39;same-origin&#39;&lt;/code&gt; explicitly with all fetch requests instead of relying on the default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#39;/users&#39;, {&#xA;  credentials: &#39;same-origin&#39;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: due to &lt;a href=&#34;https://github.com/github/fetch/pull/56#issuecomment-68835992&#34;&gt;limitations of XMLHttpRequest&lt;/a&gt;, using &lt;code&gt;credentials: &#39;omit&#39;&lt;/code&gt; is not respected for same domains in browsers where this polyfill is active. Cookies will always be sent to same domains in older browsers.&lt;/p&gt; &#xA;&lt;h4&gt;Receiving cookies&lt;/h4&gt; &#xA;&lt;p&gt;As with XMLHttpRequest, the &lt;code&gt;Set-Cookie&lt;/code&gt; response header returned from the server is a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name&#34;&gt;forbidden header name&lt;/a&gt; and therefore can&#39;t be programmatically read with &lt;code&gt;response.headers.get()&lt;/code&gt;. Instead, it&#39;s the browser&#39;s responsibility to handle new cookies being set (if applicable to the current URL). Unless they are HTTP-only, new cookies will be available through &lt;code&gt;document.cookie&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Redirect modes&lt;/h4&gt; &#xA;&lt;p&gt;The Fetch specification defines these values for &lt;a href=&#34;https://fetch.spec.whatwg.org/#concept-request-redirect-mode&#34;&gt;the &lt;code&gt;redirect&lt;/code&gt; option&lt;/a&gt;: &#34;follow&#34; (the default), &#34;error&#34;, and &#34;manual&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Due to limitations of XMLHttpRequest, only the &#34;follow&#34; mode is available in browsers where this polyfill is active.&lt;/p&gt; &#xA;&lt;h4&gt;Obtaining the Response URL&lt;/h4&gt; &#xA;&lt;p&gt;Due to limitations of XMLHttpRequest, the &lt;code&gt;response.url&lt;/code&gt; value might not be reliable after HTTP redirects on older browsers.&lt;/p&gt; &#xA;&lt;p&gt;The solution is to configure the server to set the response HTTP header &lt;code&gt;X-Request-URL&lt;/code&gt; to the current URL after any redirect that might have happened. It should be safe to set it unconditionally.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Ruby on Rails controller example&#xA;response.headers[&#39;X-Request-URL&#39;] = request.url&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This server workaround is necessary if you need reliable &lt;code&gt;response.url&lt;/code&gt; in Firefox &amp;lt; 32, Chrome &amp;lt; 37, Safari, or IE.&lt;/p&gt; &#xA;&lt;h4&gt;Aborting requests&lt;/h4&gt; &#xA;&lt;p&gt;This polyfill supports &lt;a href=&#34;https://developers.google.com/web/updates/2017/09/abortable-fetch&#34;&gt;the abortable fetch API&lt;/a&gt;. However, aborting a fetch requires use of two additional DOM APIs: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/AbortController&#34;&gt;AbortController&lt;/a&gt; and &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal&#34;&gt;AbortSignal&lt;/a&gt;. Typically, browsers that do not support fetch will also not support AbortController or AbortSignal. Consequently, you will need to include &lt;a href=&#34;https://www.npmjs.com/package/yet-another-abortcontroller-polyfill&#34;&gt;an additional polyfill&lt;/a&gt; for these APIs to abort fetches:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import &#39;yet-another-abortcontroller-polyfill&#39;&#xA;import {fetch} from &#39;whatwg-fetch&#39;&#xA;&#xA;// use native browser implementation if it supports aborting&#xA;const abortableFetch = (&#39;signal&#39; in new Request(&#39;&#39;)) ? window.fetch : fetch&#xA;&#xA;const controller = new AbortController()&#xA;&#xA;abortableFetch(&#39;/avatars&#39;, {&#xA;  signal: controller.signal&#xA;}).catch(function(ex) {&#xA;  if (ex.name === &#39;AbortError&#39;) {&#xA;    console.log(&#39;request aborted&#39;)&#xA;  }&#xA;})&#xA;&#xA;// some time later...&#xA;controller.abort()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Browser Support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Chrome&lt;/li&gt; &#xA; &lt;li&gt;Firefox&lt;/li&gt; &#xA; &lt;li&gt;Safari 6.1+&lt;/li&gt; &#xA; &lt;li&gt;Internet Explorer 10+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: modern browsers such as Chrome, Firefox, Microsoft Edge, and Safari contain native implementations of &lt;code&gt;window.fetch&lt;/code&gt;, therefore the code from this polyfill doesn&#39;t have any effect on those browsers. If you believe you&#39;ve encountered an error with how &lt;code&gt;window.fetch&lt;/code&gt; is implemented in any of these browsers, you should file an issue with that browser vendor instead of this project.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cyu/rack-cors</title>
    <updated>2024-03-02T01:26:47Z</updated>
    <id>tag:github.com,2024-03-02:/cyu/rack-cors</id>
    <link href="https://github.com/cyu/rack-cors" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rack Middleware for handling Cross-Origin Resource Sharing (CORS), which makes cross-origin AJAX possible.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rack CORS Middleware &lt;a href=&#34;https://github.com/cyu/rack-cors/actions&#34;&gt;&lt;img src=&#34;https://github.com/cyu/rack-cors/actions/workflows/ci.yaml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;Rack::Cors&lt;/code&gt; provides support for Cross-Origin Resource Sharing (CORS) for Rack compatible web applications.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://www.w3.org/TR/cors/&#34;&gt;CORS spec&lt;/a&gt; allows web applications to make cross domain AJAX calls without using workarounds such as JSONP. See &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;further explanations on MDN&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the gem:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;gem install rack-cors&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Or in your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;rack-cors&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Rails Configuration&lt;/h3&gt; &#xA;&lt;p&gt;For Rails, you&#39;ll need to add this middleware on application startup. A practical way to do this is with an initializer file. For example, the following will allow GET, POST, PATCH, or PUT requests from any origin on any resource:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/cors.rb&#xA;&#xA;Rails.application.config.middleware.insert_before 0, Rack::Cors do&#xA;  allow do&#xA;    origins &#39;*&#39;&#xA;    resource &#39;*&#39;, headers: :any, methods: [:get, :post, :patch, :put]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: If you create application with &lt;code&gt;--api&lt;/code&gt; option, configuration is automatically generated in &lt;code&gt;config/initializers/cors.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We use &lt;code&gt;insert_before&lt;/code&gt; to make sure &lt;code&gt;Rack::Cors&lt;/code&gt; runs at the beginning of the stack to make sure it isn&#39;t interfered with by other middleware (see &lt;code&gt;Rack::Cache&lt;/code&gt; note in &lt;strong&gt;Common Gotchas&lt;/strong&gt; section). Basic setup examples for Rails 5 &amp;amp; Rails 6 can be found in the examples/ directory.&lt;/p&gt; &#xA;&lt;p&gt;See The &lt;a href=&#34;http://guides.rubyonrails.org/rails_on_rack.html&#34;&gt;Rails Guide to Rack&lt;/a&gt; for more details on rack middlewares or watch the &lt;a href=&#34;http://railscasts.com/episodes/151-rack-middleware&#34;&gt;railscast&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Read more about it here in the &lt;a href=&#34;https://guides.rubyonrails.org/configuring.html#configuring-middleware&#34;&gt;Rails Guides&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Rack Configuration&lt;/h3&gt; &#xA;&lt;p&gt;NOTE: If you&#39;re running Rails, adding &lt;code&gt;config/initializers/cors.rb&lt;/code&gt; should be enough. There is no need to update &lt;code&gt;config.ru&lt;/code&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;config.ru&lt;/code&gt;, configure &lt;code&gt;Rack::Cors&lt;/code&gt; by passing a block to the &lt;code&gt;use&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;use Rack::Cors do&#xA;  allow do&#xA;    origins &#39;localhost:3000&#39;, &#39;127.0.0.1:3000&#39;,&#xA;            /\Ahttp:\/\/192\.168\.0\.\d{1,3}(:\d+)?\z/&#xA;            # regular expressions can be used here&#xA;&#xA;    resource &#39;/file/list_all/&#39;, :headers =&amp;gt; &#39;x-domain-token&#39;&#xA;    resource &#39;/file/at/*&#39;,&#xA;        methods: [:get, :post, :delete, :put, :patch, :options, :head],&#xA;        headers: &#39;x-domain-token&#39;,&#xA;        expose: [&#39;Some-Custom-Response-Header&#39;],&#xA;        max_age: 600&#xA;        # headers to expose&#xA;  end&#xA;&#xA;  allow do&#xA;    origins &#39;*&#39;&#xA;    resource &#39;/public/*&#39;, headers: :any, methods: :get&#xA;&#xA;    # Only allow a request for a specific host&#xA;    resource &#39;/api/v1/*&#39;,&#xA;        headers: :any,&#xA;        methods: :get,&#xA;        if: proc { |env| env[&#39;HTTP_HOST&#39;] == &#39;api.example.com&#39; }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration Reference&lt;/h3&gt; &#xA;&lt;h4&gt;Middleware Options&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;debug&lt;/strong&gt; (boolean): Enables debug logging and &lt;code&gt;X-Rack-CORS&lt;/code&gt; HTTP headers for debugging.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;logger&lt;/strong&gt; (Object or Proc): Specify the logger to log to. If a proc is provided, it will be called when a logger is needed. This is helpful in cases where the logger is initialized after &lt;code&gt;Rack::Cors&lt;/code&gt; is initially configured, like &lt;code&gt;Rails.logger&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Origin&lt;/h4&gt; &#xA;&lt;p&gt;Origins can be specified as a string, a regular expression, or as &#39;*&#39; to allow all origins.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;*SECURITY NOTE:&lt;/strong&gt; Be careful when using regular expressions to not accidentally be too inclusive. For example, the expression &lt;code&gt;/https:\/\/example\.com/&lt;/code&gt; will match the domain &lt;em&gt;example.com.randomdomainname.co.uk&lt;/em&gt;. It is recommended that any regular expression be enclosed with start &amp;amp; end string anchors, like &lt;code&gt;\Ahttps:\/\/example\.com\z&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, origins can be specified dynamically via a block of the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  origins { |source, env| true || false }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A Resource path can be specified as exact string match (&lt;code&gt;/path/to/file.txt&lt;/code&gt;) or with a &#39;*&#39; wildcard (&lt;code&gt;/all/files/in/*&lt;/code&gt;). A resource can take the following options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;methods&lt;/strong&gt; (string or array or &lt;code&gt;:any&lt;/code&gt;): The HTTP methods allowed for the resource.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;headers&lt;/strong&gt; (string or array or &lt;code&gt;:any&lt;/code&gt;): The HTTP headers that will be allowed in the CORS resource request. Use &lt;code&gt;:any&lt;/code&gt; to allow for any headers in the actual request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;expose&lt;/strong&gt; (string or array): The HTTP headers in the resource response can be exposed to the client.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;credentials&lt;/strong&gt; (boolean, default: &lt;code&gt;false&lt;/code&gt;): Sets the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header. &lt;strong&gt;Note:&lt;/strong&gt; If a wildcard (&lt;code&gt;*&lt;/code&gt;) origin is specified, this option cannot be set to &lt;code&gt;true&lt;/code&gt;. Read this &lt;a href=&#34;http://web-in-security.blogspot.de/2017/07/cors-misconfigurations-on-large-scale.html&#34;&gt;security article&lt;/a&gt; for more information.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;max_age&lt;/strong&gt; (number): Sets the &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; response header.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;if&lt;/strong&gt; (Proc): If the result of the proc is true, will process the request as a valid CORS request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;vary&lt;/strong&gt; (string or array): A list of HTTP headers to add to the &#39;Vary&#39; header.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Common Gotchas&lt;/h2&gt; &#xA;&lt;h3&gt;Origin Matching&lt;/h3&gt; &#xA;&lt;p&gt;When specifying an origin, make sure that it does not have a trailing slash.&lt;/p&gt; &#xA;&lt;h3&gt;Testing Postman and/or cURL&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Make sure you&#39;re passing in an &lt;code&gt;Origin:&lt;/code&gt; header. That header is required to trigger a CORS response. Here&#39;s &lt;a href=&#34;https://stackoverflow.com/questions/12173990/how-can-you-debug-a-cors-request-with-curl&#34;&gt;a good SO post&lt;/a&gt; about using cURL for testing CORS.&lt;/li&gt; &#xA; &lt;li&gt;Make sure your origin does not have a trailing slash.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Positioning in the Middleware Stack&lt;/h3&gt; &#xA;&lt;p&gt;Positioning of &lt;code&gt;Rack::Cors&lt;/code&gt; in the middleware stack is very important. In the Rails example above we put it above all other middleware which, in our experience, provides the most consistent results.&lt;/p&gt; &#xA;&lt;p&gt;Here are some scenarios where incorrect positioning have created issues:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Serving static files.&lt;/strong&gt; Insert before &lt;code&gt;ActionDispatch::Static&lt;/code&gt; so that static files are served with the proper CORS headers. &lt;strong&gt;NOTE:&lt;/strong&gt; this might not work in production as static files are usually served from the web server (Nginx, Apache) and not the Rails container.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Caching in the middleware.&lt;/strong&gt; Insert before &lt;code&gt;Rack::Cache&lt;/code&gt; so that the proper CORS headers are written and not cached ones.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Authentication via Warden&lt;/strong&gt; Warden will return immediately if a resource that requires authentication is accessed without authentication. If &lt;code&gt;Warden::Manager&lt;/code&gt;is in the stack before &lt;code&gt;Rack::Cors&lt;/code&gt;, it will return without the correct CORS headers being applied, resulting in a failed CORS request.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can run the following command to see what the middleware stack looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec rake middleware&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the middleware stack is different in production. For example, the &lt;code&gt;ActionDispatch::Static&lt;/code&gt; middleware will not be part of the stack if &lt;code&gt;config.serve_static_assets = false&lt;/code&gt;. You can run this to see what your middleware stack looks like in production:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RAILS_ENV=production bundle exec rake middleware&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serving static files&lt;/h3&gt; &#xA;&lt;p&gt;If you trying to serve CORS headers on static assets (like CSS, JS, Font files), keep in mind that static files are usually served directly from web servers and never runs through the Rails container (including the middleware stack where &lt;code&gt;Rack::Cors&lt;/code&gt; resides).&lt;/p&gt; &#xA;&lt;p&gt;In Heroku, you can serve static assets through the Rails container by setting &lt;code&gt;config.serve_static_assets = true&lt;/code&gt; in &lt;code&gt;production.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Protocols (chrome-extension://, ionic://, etc.)&lt;/h3&gt; &#xA;&lt;p&gt;Prior to 2.0.0, &lt;code&gt;http://&lt;/code&gt;, &lt;code&gt;https://&lt;/code&gt;, and &lt;code&gt;file://&lt;/code&gt; are the only protocols supported in the &lt;code&gt;origins&lt;/code&gt; list. If you wish to specify an origin that has a custom protocol (&lt;code&gt;chrome-extension://&lt;/code&gt;, &lt;code&gt;ionic://&lt;/code&gt;, etc.) simply exclude the protocol. &lt;a href=&#34;https://github.com/cyu/rack-cors/issues/100&#34;&gt;See issue.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For example, instead of specifying &lt;code&gt;chrome-extension://aomjjhallfgjeglblehebfpbcfeobpga&lt;/code&gt; specify &lt;code&gt;aomjjhallfgjeglblehebfpbcfeobpga&lt;/code&gt; in &lt;code&gt;origins&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As of 2.0.0 (currently in RC1), you can specify origins with a custom protocol.&lt;/p&gt; &#xA;&lt;h3&gt;Rails 6 Host Matching&lt;/h3&gt; &#xA;&lt;p&gt;Rails 6 will block requests from unauthorized hosts, and this issue can be confused as a CORS related error. So in development, if you&#39;re making requests using something other than localhost or 127.0.0.1, make sure the server host has been authorized. &lt;a href=&#34;https://guides.rubyonrails.org/configuring.html#actiondispatch-hostauthorization&#34;&gt;More info here&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>HumanAIGC/emote-portrait-alive</title>
    <updated>2024-03-02T01:26:47Z</updated>
    <id>tag:github.com,2024-03-02:/HumanAIGC/emote-portrait-alive</id>
    <link href="https://github.com/HumanAIGC/emote-portrait-alive" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://humanaigc.github.io/emote-portrait-alive/&#34;&gt;https://humanaigc.github.io/emote-portrait-alive/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>