<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-05T01:37:26Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nock/nock</title>
    <updated>2023-05-05T01:37:26Z</updated>
    <id>tag:github.com,2023-05-05:/nock/nock</id>
    <link href="https://github.com/nock/nock" rel="alternate"></link>
    <summary type="html">&lt;p&gt;HTTP server mocking and expectations library for Node.js&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nock&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/nock&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/nock.svg?sanitize=true&#34; alt=&#34;npm&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/nock/nock&#34;&gt;&lt;img src=&#34;https://travis-ci.org/nock/nock.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;http://img.shields.io/badge/coverage-100%25-brightgreen.svg?sanitize=true&#34; alt=&#34;Coverage Status&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#backers&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/backers/badge.svg?sanitize=true&#34; alt=&#34;Backers on Open Collective&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#sponsors&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsors/badge.svg?sanitize=true&#34; alt=&#34;Sponsors on Open Collective&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;HTTP server mocking and expectations library for Node.js&lt;/p&gt; &#xA;&lt;p&gt;Nock can be used to test modules that perform HTTP requests in isolation.&lt;/p&gt; &#xA;&lt;p&gt;For instance, if a module performs HTTP requests to a CouchDB server or makes HTTP requests to the Amazon API, you can test that module in isolation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;!-- toc --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#how-does-it-work&#34;&gt;How does it work?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#install&#34;&gt;Install&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#node-version-support&#34;&gt;Node version support&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#read-this---about-interceptors&#34;&gt;READ THIS! - About interceptors&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-hostname&#34;&gt;Specifying hostname&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-path&#34;&gt;Specifying path&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-request-body&#34;&gt;Specifying request body&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-request-query-string&#34;&gt;Specifying request query string&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-replies&#34;&gt;Specifying replies&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#access-original-request-and-headers&#34;&gt;Access original request and headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#replying-with-errors&#34;&gt;Replying with errors&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-headers&#34;&gt;Specifying headers&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#header-field-names-are-case-insensitive&#34;&gt;Header field names are case-insensitive&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-request-headers&#34;&gt;Specifying Request Headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#specifying-reply-headers&#34;&gt;Specifying Reply Headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#default-reply-headers&#34;&gt;Default Reply Headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#including-content-length-header-automatically&#34;&gt;Including Content-Length Header Automatically&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#including-date-header-automatically&#34;&gt;Including Date Header Automatically&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#http-verbs&#34;&gt;HTTP Verbs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#support-for-http-and-https&#34;&gt;Support for HTTP and HTTPS&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#non-standard-ports&#34;&gt;Non-standard ports&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#repeat-response-n-times&#34;&gt;Repeat response n times&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#delay-the-response&#34;&gt;Delay the response&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#delay-the-connection&#34;&gt;Delay the connection&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#technical-details&#34;&gt;Technical Details&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#delay-the-response-body&#34;&gt;Delay the response body&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#technical-details-1&#34;&gt;Technical Details&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#chaining&#34;&gt;Chaining&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#scope-filtering&#34;&gt;Scope filtering&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#conditional-scope-filtering&#34;&gt;Conditional scope filtering&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#path-filtering&#34;&gt;Path filtering&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#request-body-filtering&#34;&gt;Request Body filtering&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#request-headers-matching&#34;&gt;Request Headers Matching&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#optional-requests&#34;&gt;Optional Requests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#allow-unmocked-requests-on-a-mocked-hostname&#34;&gt;Allow &lt;strong&gt;unmocked&lt;/strong&gt; requests on a mocked hostname&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#expectations&#34;&gt;Expectations&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#isdone&#34;&gt;.isDone()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#cleanall&#34;&gt;.cleanAll()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#abortpendingrequests&#34;&gt;.abortPendingRequests()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#persist&#34;&gt;.persist()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#pendingmocks&#34;&gt;.pendingMocks()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#activemocks&#34;&gt;.activeMocks()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#isactive&#34;&gt;.isActive()&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#restoring&#34;&gt;Restoring&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#activating&#34;&gt;Activating&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#turning-nock-off-experimental&#34;&gt;Turning Nock Off (experimental!)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#enabledisable-real-http-requests&#34;&gt;Enable/Disable real HTTP requests&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#disabling-requests&#34;&gt;Disabling requests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#enabling-requests&#34;&gt;Enabling requests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#resetting-netconnect&#34;&gt;Resetting NetConnect&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#recording&#34;&gt;Recording&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#dont_print-option&#34;&gt;&lt;code&gt;dont_print&lt;/code&gt; option&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#output_objects-option&#34;&gt;&lt;code&gt;output_objects&lt;/code&gt; option&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#enable_reqheaders_recording-option&#34;&gt;&lt;code&gt;enable_reqheaders_recording&lt;/code&gt; option&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#logging-option&#34;&gt;&lt;code&gt;logging&lt;/code&gt; option&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#use_separator-option&#34;&gt;&lt;code&gt;use_separator&lt;/code&gt; option&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#removeinterceptor&#34;&gt;.removeInterceptor()&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#events&#34;&gt;Events&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#global-no-match-event&#34;&gt;Global no match event&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#nock-back&#34;&gt;Nock Back&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#setup&#34;&gt;Setup&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#options&#34;&gt;Options&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#usage-1&#34;&gt;Usage&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#options-1&#34;&gt;Options&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#modes&#34;&gt;Modes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#common-issues&#34;&gt;Common issues&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#axios&#34;&gt;Axios&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#memory-issues-with-jest&#34;&gt;Memory issues with Jest&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#debugging&#34;&gt;Debugging&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#contributors&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#sponsors&#34;&gt;Sponsors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- tocstop --&gt; &#xA;&lt;h2&gt;How does it work?&lt;/h2&gt; &#xA;&lt;p&gt;Nock works by overriding Node&#39;s &lt;code&gt;http.request&lt;/code&gt; function. Also, it overrides &lt;code&gt;http.ClientRequest&lt;/code&gt; too to cover for modules that use it directly.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm install --save-dev nock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Node version support&lt;/h3&gt; &#xA;&lt;p&gt;The latest version of nock supports all currently maintained Node versions, see &lt;a href=&#34;https://github.com/nodejs/Release#release-schedule&#34;&gt;Node Release Schedule&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here is a list of past nock versions with respective node version support&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;node&lt;/th&gt; &#xA;   &lt;th&gt;nock&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.10&lt;/td&gt; &#xA;   &lt;td&gt;up to 8.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.11&lt;/td&gt; &#xA;   &lt;td&gt;up to 8.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.12&lt;/td&gt; &#xA;   &lt;td&gt;up to 8.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;up to 9.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;up to 8.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;up to 10.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;   &lt;td&gt;up to 9.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;up to 11.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9&lt;/td&gt; &#xA;   &lt;td&gt;up to 9.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;On your test, you can setup your mocking object like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const nock = require(&#39;nock&#39;)&#xA;&#xA;const scope = nock(&#39;https://api.github.com&#39;)&#xA;  .get(&#39;/repos/atom/atom/license&#39;)&#xA;  .reply(200, {&#xA;    license: {&#xA;      key: &#39;mit&#39;,&#xA;      name: &#39;MIT License&#39;,&#xA;      spdx_id: &#39;MIT&#39;,&#xA;      url: &#39;https://api.github.com/licenses/mit&#39;,&#xA;      node_id: &#39;MDc6TGljZW5zZTEz&#39;,&#xA;    },&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This setup says that we will intercept every HTTP call to &lt;code&gt;https://api.github.com&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It will intercept an HTTPS GET request to &lt;code&gt;/repos/atom/atom/license&lt;/code&gt;, reply with a status 200, and the body will contain a (partial) response in JSON.&lt;/p&gt; &#xA;&lt;h3&gt;READ THIS! - About interceptors&lt;/h3&gt; &#xA;&lt;p&gt;When you setup an interceptor for a URL and that interceptor is used, it is removed from the interceptor list. This means that you can intercept 2 or more calls to the same URL and return different things on each of them. It also means that you must setup one interceptor for each request you are going to have, otherwise nock will throw an error because that URL was not present in the interceptor list. If you don’t want interceptors to be removed as they are used, you can use the &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#persist&#34;&gt;.persist()&lt;/a&gt; method.&lt;/p&gt; &#xA;&lt;h3&gt;Specifying hostname&lt;/h3&gt; &#xA;&lt;p&gt;The request hostname can be a string, URL, or a RegExp.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;)&#xA;  .get(&#39;/resource&#39;)&#xA;  .reply(200, &#39;domain matched&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(new URL(&#39;http://www.example.com&#39;))&#xA;  .get(&#39;/resource&#39;)&#xA;  .reply(200, &#39;domain matched&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(/example\.com/)&#xA;  .get(&#39;/resource&#39;)&#xA;  .reply(200, &#39;domain regex matched&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: You can choose to include or not the protocol in the hostname matching.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Specifying path&lt;/h3&gt; &#xA;&lt;p&gt;The request path can be a string, a RegExp or a filter function and you can use any &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#http-verbs&#34;&gt;HTTP verb&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Using a string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;)&#xA;  .get(&#39;/resource&#39;)&#xA;  .reply(200, &#39;path matched&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using a regular expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;)&#xA;  .get(/source$/)&#xA;  .reply(200, &#39;path using regex matched&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;)&#xA;  .get(uri =&amp;gt; uri.includes(&#39;cats&#39;))&#xA;  .reply(200, &#39;path using function matched&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying request body&lt;/h3&gt; &#xA;&lt;p&gt;You can specify the request body to be matched as the second argument to the &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; specifications. There are five types of second argument allowed:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;: nock will exact match the stringified request body with the provided string&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.example.com&#39;)&#xA;  .post(&#39;/login&#39;, &#39;username=pgte&amp;amp;password=123456&#39;)&#xA;  .reply(200, { id: &#39;123ABC&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Buffer&lt;/strong&gt;: nock will exact match the stringified request body with the provided buffer&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.example.com&#39;)&#xA;  .post(&#39;/login&#39;, Buffer.from([0xff, 0x11]))&#xA;  .reply(200, { id: &#39;123ABC&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;RegExp&lt;/strong&gt;: nock will test the stringified request body against the provided RegExp&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.example.com&#39;)&#xA;  .post(&#39;/login&#39;, /username=\w+/gi)&#xA;  .reply(200, { id: &#39;123ABC&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON object&lt;/strong&gt;: nock will exact match the request body with the provided object. In order to increase flexibility, nock also supports RegExp as an attribute value for the keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.example.com&#39;)&#xA;  .post(&#39;/login&#39;, { username: &#39;pgte&#39;, password: /.+/i })&#xA;  .reply(200, { id: &#39;123ABC&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt;: nock will evaluate the function providing the request body object as first argument. Return true if it should be considered a match:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.example.com&#39;)&#xA;  .post(&#39;/login&#39;, body =&amp;gt; body.username &amp;amp;&amp;amp; body.password)&#xA;  .reply(200, { id: &#39;123ABC&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case you need to perform a partial matching on a complex, nested request body you should have a look at libraries like &lt;a href=&#34;https://lodash.com/docs/#matches&#34;&gt;lodash.matches&lt;/a&gt;. Indeed, partial matching can be achieved as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.example.com&#39;)&#xA;  .post(&#39;/user&#39;, _.matches({ address: { country: &#39;US&#39; } }))&#xA;  .reply(200, { id: &#39;123ABC&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying request query string&lt;/h3&gt; &#xA;&lt;p&gt;Nock understands query strings. Search parameters can be included as part of the path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://example.com&#39;).get(&#39;/users?foo=bar&#39;).reply(200)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of placing the entire URL, you can specify the query part as an object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://example.com&#39;)&#xA;  .get(&#39;/users&#39;)&#xA;  .query({ name: &#39;pedro&#39;, surname: &#39;teixeira&#39; })&#xA;  .reply(200, { results: [{ id: &#39;pgte&#39; }] })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nock supports array-style/object-style query parameters. The encoding format matches with request module.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://example.com&#39;)&#xA;  .get(&#39;/users&#39;)&#xA;  .query({&#xA;    names: [&#39;alice&#39;, &#39;bob&#39;],&#xA;    tags: {&#xA;      alice: [&#39;admin&#39;, &#39;tester&#39;],&#xA;      bob: [&#39;tester&#39;],&#xA;    },&#xA;  })&#xA;  .reply(200, { results: [{ id: &#39;pgte&#39; }] })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;URLSearchParams&lt;/code&gt; instance can be provided.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const params = new URLSearchParams({ foo: &#39;bar&#39; })&#xA;&#xA;nock(&#39;http://example.com&#39;).get(&#39;/&#39;).query(params).reply(200)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nock supports passing a function to query. The function determines if the actual query matches or not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://example.com&#39;)&#xA;  .get(&#39;/users&#39;)&#xA;  .query(actualQueryObject =&amp;gt; {&#xA;    // do some compare with the actual Query Object&#xA;    // return true for matched&#xA;    // return false for not matched&#xA;    return true&#xA;  })&#xA;  .reply(200, { results: [{ id: &#39;pgte&#39; }] })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To mock the entire url regardless of the passed query string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://example.com&#39;)&#xA;  .get(&#39;/users&#39;)&#xA;  .query(true)&#xA;  .reply(200, { results: [{ id: &#39;pgte&#39; }] })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A query string that is already &lt;a href=&#34;https://en.wikipedia.org/wiki/Percent-encoding&#34;&gt;URL encoded&lt;/a&gt; can be matched by passing the &lt;code&gt;encodedQueryParams&lt;/code&gt; flag in the options when creating the Scope.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://example.com&#39;, { encodedQueryParams: true })&#xA;  .get(&#39;/users&#39;)&#xA;  .query(&#39;foo%5Bbar%5D%3Dhello%20world%21&#39;)&#xA;  .reply(200, { results: [{ id: &#39;pgte&#39; }] })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying replies&lt;/h3&gt; &#xA;&lt;p&gt;You can specify the return status code for a path on the first argument of reply like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://myapp.iriscouch.com&#39;).get(&#39;/users/1&#39;).reply(404)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify the reply body as a string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.google.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, &#39;Hello from Google!&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or as a JSON-encoded object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://myapp.iriscouch.com&#39;).get(&#39;/&#39;).reply(200, {&#xA;  username: &#39;pgte&#39;,&#xA;  email: &#39;pedro.teixeira@gmail.com&#39;,&#xA;  _id: &#39;4324243fsd&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or even as a file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://myapp.iriscouch.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .replyWithFile(200, __dirname + &#39;/replies/user.json&#39;, {&#xA;    &#39;Content-Type&#39;: &#39;application/json&#39;,&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of an object or a buffer you can also pass in a callback to be evaluated for the value of the response body:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.google.com&#39;)&#xA;  .post(&#39;/echo&#39;)&#xA;  .reply(201, (uri, requestBody) =&amp;gt; requestBody)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Nock 11.x it was possible to invoke &lt;code&gt;.reply()&lt;/code&gt; with a status code and a function that returns an array containing a status code and body. (The status code from the array would take precedence over the one passed directly to reply.) This is no longer allowed. In Nock 12 and later, either call &lt;code&gt;.reply()&lt;/code&gt; with a status code and a function that returns the body, or call it with a single argument: a function that returns an array containing both the status code and body.&lt;/p&gt; &#xA;&lt;p&gt;An asynchronous function that gets an error-first callback as its last argument also works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.google.com&#39;)&#xA;  .post(&#39;/echo&#39;)&#xA;  .reply(201, (uri, requestBody, cb) =&amp;gt; {&#xA;    fs.readFile(&#39;cat-poems.txt&#39;, cb) // Error-first callback&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Nock 11 and later, if an error is passed to the callback, Nock will rethrow it as a programmer error. In Nock 10 and earlier, the error was sent in the response body, with a 500 HTTP response status code.&lt;/p&gt; &#xA;&lt;p&gt;You can also return the status code and body using just one function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.google.com&#39;)&#xA;  .post(&#39;/echo&#39;)&#xA;  .reply((uri, requestBody) =&amp;gt; {&#xA;    return [&#xA;      201,&#xA;      &#39;THIS IS THE REPLY BODY&#39;,&#xA;      { header: &#39;value&#39; }, // optional headers&#xA;    ]&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, use an error-first callback that also gets the status code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.google.com&#39;)&#xA;  .post(&#39;/echo&#39;)&#xA;  .reply((uri, requestBody, cb) =&amp;gt; {&#xA;    setTimeout(() =&amp;gt; cb(null, [201, &#39;THIS IS THE REPLY BODY&#39;]), 1000)&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A Stream works too:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.google.com&#39;)&#xA;  .get(&#39;/cat-poems&#39;)&#xA;  .reply(200, (uri, requestBody) =&amp;gt; {&#xA;    return fs.createReadStream(&#39;cat-poems.txt&#39;)&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Access original request and headers&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re using the reply callback style, you can access the original client request using &lt;code&gt;this.req&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.google.com&#39;)&#xA;  .get(&#39;/cat-poems&#39;)&#xA;  .reply(function (uri, requestBody) {&#xA;    console.log(&#39;path:&#39;, this.req.path)&#xA;    console.log(&#39;headers:&#39;, this.req.headers)&#xA;    // ...&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Remember to use normal &lt;code&gt;function&lt;/code&gt; in that case, as arrow functions are using enclosing scope for &lt;code&gt;this&lt;/code&gt; binding.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Replying with errors&lt;/h4&gt; &#xA;&lt;p&gt;You can reply with an error like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.google.com&#39;)&#xA;  .get(&#39;/cat-poems&#39;)&#xA;  .replyWithError(&#39;something awful happened&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JSON error responses are allowed too:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://www.google.com&#39;).get(&#39;/cat-poems&#39;).replyWithError({&#xA;  message: &#39;something awful happened&#39;,&#xA;  code: &#39;AWFUL_ERROR&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: This will emit an &lt;code&gt;error&lt;/code&gt; event on the &lt;code&gt;request&lt;/code&gt; object, not the reply.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Specifying headers&lt;/h3&gt; &#xA;&lt;h4&gt;Header field names are case-insensitive&lt;/h4&gt; &#xA;&lt;p&gt;Per &lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2&#34;&gt;HTTP/1.1 4.2 Message Headers&lt;/a&gt; specification, all message headers are case insensitive and thus internally Nock uses lower-case for all field names even if some other combination of cases was specified either in mocking specification or in mocked requests themselves.&lt;/p&gt; &#xA;&lt;h4&gt;Specifying Request Headers&lt;/h4&gt; &#xA;&lt;p&gt;You can specify the request headers like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;, {&#xA;  reqheaders: {&#xA;    authorization: &#39;Basic Auth&#39;,&#xA;  },&#xA;})&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use a regular expression or function to check the header values. The function will be passed the header value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;, {&#xA;  reqheaders: {&#xA;    &#39;X-My-Headers&#39;: headerValue =&amp;gt; headerValue.includes(&#39;cats&#39;),&#xA;    &#39;X-My-Awesome-Header&#39;: /Awesome/i,&#xA;  },&#xA;})&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;reqheaders&lt;/code&gt; is not specified or if &lt;code&gt;host&lt;/code&gt; is not part of it, Nock will automatically add &lt;code&gt;host&lt;/code&gt; value to request header.&lt;/p&gt; &#xA;&lt;p&gt;If no request headers are specified for mocking then Nock will automatically skip matching of request headers. Since the &lt;code&gt;host&lt;/code&gt; header is a special case which may get automatically inserted by Nock, its matching is skipped unless it was &lt;em&gt;also&lt;/em&gt; specified in the request being mocked.&lt;/p&gt; &#xA;&lt;p&gt;You can also have Nock fail the request if certain headers are present:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;, {&#xA;  badheaders: [&#39;cookie&#39;, &#39;x-forwarded-for&#39;],&#xA;})&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When invoked with this option, Nock will not match the request if any of the &lt;code&gt;badheaders&lt;/code&gt; are present.&lt;/p&gt; &#xA;&lt;p&gt;Basic authentication can be specified as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.example.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .basicAuth({ user: &#39;john&#39;, pass: &#39;doe&#39; })&#xA;  .reply(200)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Specifying Reply Headers&lt;/h4&gt; &#xA;&lt;p&gt;You can specify the reply headers like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;https://api.github.com&#39;)&#xA;  .get(&#39;/repos/atom/atom/license&#39;)&#xA;  .reply(200, { license: &#39;MIT&#39; }, { &#39;X-RateLimit-Remaining&#39;: 4999 })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use a function to generate the headers values. The function will be passed the request, response, and response body (if available). The body will be either a buffer, a stream, or undefined.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.headdy.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, &#39;Hello World!&#39;, {&#xA;    &#39;Content-Length&#39;: (req, res, body) =&amp;gt; body.length,&#xA;    ETag: () =&amp;gt; `${Date.now()}`,&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Default Reply Headers&lt;/h4&gt; &#xA;&lt;p&gt;You can also specify default reply headers for all responses like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.headdy.com&#39;)&#xA;  .defaultReplyHeaders({&#xA;    &#39;X-Powered-By&#39;: &#39;Rails&#39;,&#xA;    &#39;Content-Type&#39;: &#39;application/json&#39;,&#xA;  })&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, &#39;The default headers should come too&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use a function to generate the default headers values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.headdy.com&#39;)&#xA;  .defaultReplyHeaders({&#xA;    &#39;Content-Length&#39;: (req, res, body) =&amp;gt; body.length,&#xA;  })&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, &#39;The default headers should come too&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Including Content-Length Header Automatically&lt;/h4&gt; &#xA;&lt;p&gt;When using &lt;code&gt;interceptor.reply()&lt;/code&gt; to set a response body manually, you can have the &lt;code&gt;Content-Length&lt;/code&gt; header calculated automatically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.headdy.com&#39;)&#xA;  .replyContentLength()&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, { hello: &#39;world&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; this does not work with streams or other advanced means of specifying the reply body.&lt;/p&gt; &#xA;&lt;h4&gt;Including Date Header Automatically&lt;/h4&gt; &#xA;&lt;p&gt;You can automatically append a &lt;code&gt;Date&lt;/code&gt; header to your mock reply:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.headdy.com&#39;)&#xA;  .replyDate()&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, { hello: &#39;world&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or provide your own &lt;code&gt;Date&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://www.headdy.com&#39;)&#xA;  .replyDate(new Date(2015, 0, 1))&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, { hello: &#39;world&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTTP Verbs&lt;/h3&gt; &#xA;&lt;p&gt;Nock supports any HTTP verb, and it has convenience methods for the GET, POST, PUT, HEAD, DELETE, PATCH, OPTIONS and MERGE HTTP verbs.&lt;/p&gt; &#xA;&lt;p&gt;You can intercept any HTTP verb using &lt;code&gt;.intercept(path, verb [, requestBody [, options]])&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://my.domain.com&#39;)&#xA;  .intercept(&#39;/path&#39;, &#39;PATCH&#39;)&#xA;  .reply(304)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Support for HTTP and HTTPS&lt;/h3&gt; &#xA;&lt;p&gt;By default nock assumes HTTP. If you need to use HTTPS you can specify the &lt;code&gt;https://&lt;/code&gt; prefix like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;https://secure.my.server.com&#39;)&#xA;// ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Non-standard ports&lt;/h3&gt; &#xA;&lt;p&gt;You are able to specify a non-standard port like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://my.server.com:8081&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Repeat response n times&lt;/h3&gt; &#xA;&lt;p&gt;You are able to specify the number of times to repeat the same response.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; When request times is more than the number you specified, you will get an error before cleaning this interceptor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://zombo.com&#39;).get(&#39;/&#39;).times(4).reply(200, &#39;Ok&#39;)&#xA;&#xA;http.get(&#39;http://zombo.com/&#39;) // respond body &#34;Ok&#34;&#xA;http.get(&#39;http://zombo.com/&#39;) // respond body &#34;Ok&#34;&#xA;http.get(&#39;http://zombo.com/&#39;) // respond body &#34;Ok&#34;&#xA;http.get(&#39;http://zombo.com/&#39;) // respond body &#34;Ok&#34;&#xA;&#xA;// This code will get an error with message:&#xA;// Nock: No match for request&#xA;http.get(&#39;http://zombo.com/&#39;)&#xA;&#xA;// clean your interceptor&#xA;nock.cleanAll()&#xA;&#xA;http.get(&#39;http://zombo.com/&#39;) // real respond with zombo.com result&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sugar syntax&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://zombo.com&#39;).get(&#39;/&#39;).once().reply(200, &#39;Ok&#39;)&#xA;nock(&#39;http://zombo.com&#39;).get(&#39;/&#39;).twice().reply(200, &#39;Ok&#39;)&#xA;nock(&#39;http://zombo.com&#39;).get(&#39;/&#39;).thrice().reply(200, &#39;Ok&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To repeat this response for as long as nock is active, use &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#persist&#34;&gt;.persist()&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Delay the response&lt;/h3&gt; &#xA;&lt;p&gt;Nock can simulate response latency to allow you to test timeouts, race conditions, an other timing related scenarios.&lt;br&gt; You are able to specify the number of milliseconds that your reply should be delayed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://my.server.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .delay(2000) // 2 seconds delay will be applied to the response header.&#xA;  .reply(200, &#39;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;delay(1000)&lt;/code&gt; is an alias for &lt;code&gt;delayConnection(1000).delayBody(0)&lt;/code&gt;&lt;br&gt; &lt;code&gt;delay({ head: 1000, body: 2000 })&lt;/code&gt; is an alias for &lt;code&gt;delayConnection(1000).delayBody(2000)&lt;/code&gt;&lt;br&gt; Both of which are covered in detail below.&lt;/p&gt; &#xA;&lt;h4&gt;Delay the connection&lt;/h4&gt; &#xA;&lt;p&gt;You are able to specify the number of milliseconds that your connection should be idle before it starts to receive the response.&lt;/p&gt; &#xA;&lt;p&gt;To simulate a socket timeout, provide a larger value than the timeout setting on the request.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://my.server.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .delayConnection(2000) // 2 seconds&#xA;  .reply(200, &#39;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&#39;)&#xA;&#xA;req = http.request(&#39;http://my.server.com&#39;, { timeout: 1000 })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nock emits timeout events almost immediately by comparing the requested connection delay to the timeout parameter passed to &lt;code&gt;http.request()&lt;/code&gt; or &lt;code&gt;http.ClientRequest#setTimeout()&lt;/code&gt;.&lt;br&gt; This allows you to test timeouts without using fake timers or slowing down your tests. If the client chooses to &lt;em&gt;not&lt;/em&gt; take an action (e.g. abort the request), the request and response will continue on as normal, after real clock time has passed.&lt;/p&gt; &#xA;&lt;h5&gt;Technical Details&lt;/h5&gt; &#xA;&lt;p&gt;Following the &lt;code&gt;&#39;finish&#39;&lt;/code&gt; event being emitted by &lt;code&gt;ClientRequest&lt;/code&gt;, Nock will wait for the next event loop iteration before checking if the request has been aborted. At this point, any connection delay value is compared against any request timeout setting and a &lt;a href=&#34;https://nodejs.org/api/http.html#http_event_timeout&#34;&gt;&lt;code&gt;&#39;timeout&#39;&lt;/code&gt;&lt;/a&gt; is emitted when appropriate from the socket and the request objects. A Node timeout timer is then registered with any connection delay value to delay real time before checking again if the request has been aborted and the &lt;a href=&#34;http://nodejs.org/api/http.html#http_event_response&#34;&gt;&lt;code&gt;&#39;response&#39;&lt;/code&gt;&lt;/a&gt; is emitted by the request.&lt;/p&gt; &#xA;&lt;p&gt;A similar method, &lt;code&gt;.socketDelay()&lt;/code&gt; was removed in version 13. It was thought that having two methods so subtlety similar was confusing.&lt;br&gt; The discussion can be found at &lt;a href=&#34;https://github.com/nock/nock/pull/1974&#34;&gt;https://github.com/nock/nock/pull/1974&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Delay the response body&lt;/h4&gt; &#xA;&lt;p&gt;You are able to specify the number of milliseconds that the response body should be delayed.&lt;br&gt; This is the time between the headers being received and the body starting to be received.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://my.server.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .delayBody(2000) // 2 seconds&#xA;  .reply(200, &#39;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Technical Details&lt;/h5&gt; &#xA;&lt;p&gt;Following the &lt;a href=&#34;http://nodejs.org/api/http.html#http_event_response&#34;&gt;&lt;code&gt;&#39;response&#39;&lt;/code&gt;&lt;/a&gt; being emitted by &lt;code&gt;ClientRequest&lt;/code&gt;, Nock will register a timeout timer with the body delay value to delay real time before the &lt;a href=&#34;http://nodejs.org/api/http.html#http_http_incomingmessage&#34;&gt;IncomingMessage&lt;/a&gt; emits its first &lt;code&gt;&#39;data&#39;&lt;/code&gt; or the &lt;code&gt;&#39;end&#39;&lt;/code&gt; event.&lt;/p&gt; &#xA;&lt;h3&gt;Chaining&lt;/h3&gt; &#xA;&lt;p&gt;You can chain behaviour like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://myapp.iriscouch.com&#39;)&#xA;  .get(&#39;/users/1&#39;)&#xA;  .reply(404)&#xA;  .post(&#39;/users&#39;, {&#xA;    username: &#39;pgte&#39;,&#xA;    email: &#39;pedro.teixeira@gmail.com&#39;,&#xA;  })&#xA;  .reply(201, {&#xA;    ok: true,&#xA;    id: &#39;123ABC&#39;,&#xA;    rev: &#39;946B7D1C&#39;,&#xA;  })&#xA;  .get(&#39;/users/123ABC&#39;)&#xA;  .reply(200, {&#xA;    _id: &#39;123ABC&#39;,&#xA;    _rev: &#39;946B7D1C&#39;,&#xA;    username: &#39;pgte&#39;,&#xA;    email: &#39;pedro.teixeira@gmail.com&#39;,&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scope filtering&lt;/h3&gt; &#xA;&lt;p&gt;You can filter the scope (protocol, domain or port) of nock through a function. The filtering function is accepted at the &lt;code&gt;filteringScope&lt;/code&gt; field of the &lt;code&gt;options&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;p&gt;This can be useful if you have a node module that randomly changes subdomains to which it sends requests, e.g., the Dropbox node module behaves like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;https://api.dropbox.com&#39;, {&#xA;  filteringScope: scope =&amp;gt; /^https:\/\/api[0-9]*.dropbox.com/.test(scope),&#xA;})&#xA;  .get(&#39;/1/metadata/auto/Photos?include_deleted=false&amp;amp;list=true&#39;)&#xA;  .reply(200)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Conditional scope filtering&lt;/h3&gt; &#xA;&lt;p&gt;You can also choose to filter out a scope based on your system environment (or any external factor). The filtering function is accepted at the &lt;code&gt;conditionally&lt;/code&gt; field of the &lt;code&gt;options&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;p&gt;This can be useful if you only want certain scopes to apply depending on how your tests are executed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;https://api.myservice.com&#39;, {&#xA;  conditionally: () =&amp;gt; true,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Path filtering&lt;/h3&gt; &#xA;&lt;p&gt;You can also filter the URLs based on a function.&lt;/p&gt; &#xA;&lt;p&gt;This can be useful, for instance, if you have random or time-dependent data in your URL.&lt;/p&gt; &#xA;&lt;p&gt;You can use a regexp for replacement, just like String.prototype.replace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  .filteringPath(/password=[^&amp;amp;]*/g, &#39;password=XXX&#39;)&#xA;  .get(&#39;/users/1?password=XXX&#39;)&#xA;  .reply(200, &#39;user&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  .filteringPath(path =&amp;gt; &#39;/ABC&#39;)&#xA;  .get(&#39;/ABC&#39;)&#xA;  .reply(200, &#39;user&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;scope.filteringPath&lt;/code&gt; is not cumulative: it should only be used once per scope.&lt;/p&gt; &#xA;&lt;h3&gt;Request Body filtering&lt;/h3&gt; &#xA;&lt;p&gt;You can also filter the request body based on a function.&lt;/p&gt; &#xA;&lt;p&gt;This can be useful, for instance, if you have random or time-dependent data in your request body.&lt;/p&gt; &#xA;&lt;p&gt;You can use a regexp for replacement, just like String.prototype.replace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  .filteringRequestBody(/password=[^&amp;amp;]*/g, &#39;password=XXX&#39;)&#xA;  .post(&#39;/users/1&#39;, &#39;data=ABC&amp;amp;password=XXX&#39;)&#xA;  .reply(201, &#39;OK&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use a function to transform the body:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  .filteringRequestBody(body =&amp;gt; &#39;ABC&#39;)&#xA;  .post(&#39;/&#39;, &#39;ABC&#39;)&#xA;  .reply(201, &#39;OK&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to match the request body you should omit the &lt;code&gt;body&lt;/code&gt; argument from the method function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  .post(&#39;/some_uri&#39;) // no body argument&#xA;  .reply(200, &#39;OK&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Request Headers Matching&lt;/h3&gt; &#xA;&lt;p&gt;If you need to match requests only if certain request headers match, you can.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  // Interceptors created after here will only match when the header `accept` equals `application/json`.&#xA;  .matchHeader(&#39;accept&#39;, &#39;application/json&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, {&#xA;    data: &#39;hello world&#39;,&#xA;  })&#xA;  .get(&#39;/&#39;)&#xA;  // Only this interceptor will match the header value `x-my-action` with `MyFirstAction`&#xA;  .matchHeader(&#39;x-my-action&#39;, &#39;MyFirstAction&#39;)&#xA;  .reply(200, {&#xA;    data: &#39;FirstActionResponse&#39;,&#xA;  })&#xA;  .get(&#39;/&#39;)&#xA;  // Only this interceptor will match the header value `x-my-action` with `MySecondAction`&#xA;  .matchHeader(&#39;x-my-action&#39;, &#39;MySecondAction&#39;)&#xA;  .reply(200, {&#xA;    data: &#39;SecondActionResponse&#39;,&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use a regexp for the header body.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  .matchHeader(&#39;User-Agent&#39;, /Mozilla\/.*/)&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, {&#xA;    data: &#39;hello world&#39;,&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use a function for the header body.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://api.myservice.com&#39;)&#xA;  .matchHeader(&#39;content-length&#39;, val =&amp;gt; val &amp;gt;= 1000)&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, {&#xA;    data: &#39;hello world&#39;,&#xA;  })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Optional Requests&lt;/h3&gt; &#xA;&lt;p&gt;By default every mocked request is expected to be made exactly once, and until it is it&#39;ll appear in &lt;code&gt;scope.pendingMocks()&lt;/code&gt;, and &lt;code&gt;scope.isDone()&lt;/code&gt; will return false (see &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#expectations&#34;&gt;expectations&lt;/a&gt;). In many cases this is fine, but in some (especially cross-test setup code) it&#39;s useful to be able to mock a request that may or may not happen. You can do this with &lt;code&gt;optionally()&lt;/code&gt;. Optional requests are consumed just like normal ones once matched, but they do not appear in &lt;code&gt;pendingMocks()&lt;/code&gt;, and &lt;code&gt;isDone()&lt;/code&gt; will return true for scopes with only optional requests pending.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const example = nock(&#39;http://example.com&#39;)&#xA;example.pendingMocks() // []&#xA;example.get(&#39;/pathA&#39;).reply(200)&#xA;example.pendingMocks() // [&#34;GET http://example.com:80/path&#34;]&#xA;&#xA;// ...After a request to example.com/pathA:&#xA;example.pendingMocks() // []&#xA;&#xA;example.get(&#39;/pathB&#39;).optionally().reply(200)&#xA;example.pendingMocks() // []&#xA;&#xA;// You can also pass a boolean argument to `optionally()`. This&#xA;// is useful if you want to conditionally make a mocked request&#xA;// optional.&#xA;const getMock = optional =&amp;gt;&#xA;  example.get(&#39;/pathC&#39;).optionally(optional).reply(200)&#xA;&#xA;getMock(true)&#xA;example.pendingMocks() // []&#xA;getMock(false)&#xA;example.pendingMocks() // [&#34;GET http://example.com:80/pathC&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Allow &lt;strong&gt;unmocked&lt;/strong&gt; requests on a mocked hostname&lt;/h3&gt; &#xA;&lt;p&gt;If you need some request on the same host name to be mocked and some others to &lt;strong&gt;really&lt;/strong&gt; go through the HTTP stack, you can use the &lt;code&gt;allowUnmocked&lt;/code&gt; option like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://my.existing.service.com&#39;, { allowUnmocked: true })&#xA;  .get(&#39;/my/url&#39;)&#xA;  .reply(200, &#39;OK!&#39;)&#xA;&#xA;// GET /my/url =&amp;gt; goes through nock&#xA;// GET /other/url =&amp;gt; actually makes request to the server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: When applying &lt;code&gt;{allowUnmocked: true}&lt;/code&gt;, if the request is made to the real server, no interceptor is removed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Expectations&lt;/h2&gt; &#xA;&lt;p&gt;Every time an HTTP request is performed for a scope that is mocked, Nock expects to find a handler for it. If it doesn&#39;t, it will throw an error.&lt;/p&gt; &#xA;&lt;p&gt;Calls to nock() return a scope which you can assert by calling &lt;code&gt;scope.done()&lt;/code&gt;. This will assert that all specified calls on that scope were performed.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://google.com&#39;)&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, &#39;Hello from Google!&#39;)&#xA;&#xA;// do some stuff&#xA;&#xA;setTimeout(() =&amp;gt; {&#xA;  // Will throw an assertion error if meanwhile a &#34;GET http://google.com&#34; was&#xA;  // not performed.&#xA;  scope.done()&#xA;}, 5000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.isDone()&lt;/h3&gt; &#xA;&lt;p&gt;You can call &lt;code&gt;isDone()&lt;/code&gt; on a single expectation to determine if the expectation was met:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://google.com&#39;).get(&#39;/&#39;).reply(200)&#xA;&#xA;scope.isDone() // will return false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also available in the global scope, which will determine if all expectations have been met:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.isDone()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.cleanAll()&lt;/h3&gt; &#xA;&lt;p&gt;You can cleanup all the prepared mocks (could be useful to cleanup some state after a failed test) like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.cleanAll()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.abortPendingRequests()&lt;/h3&gt; &#xA;&lt;p&gt;You can abort all current pending request like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.abortPendingRequests()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.persist()&lt;/h3&gt; &#xA;&lt;p&gt;You can make all the interceptors for a scope persist by calling &lt;code&gt;.persist()&lt;/code&gt; on it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://example.com&#39;)&#xA;  .persist()&#xA;  .get(&#39;/&#39;)&#xA;  .reply(200, &#39;Persisting all the way&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that while a persisted scope will always intercept the requests, it is considered &#34;done&#34; after the first interception.&lt;/p&gt; &#xA;&lt;p&gt;If you want to stop persisting an individual persisted mock you can call &lt;code&gt;persist(false)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const scope = nock(&#39;http://example.com&#39;).persist().get(&#39;/&#39;).reply(200, &#39;ok&#39;)&#xA;&#xA;// Do some tests ...&#xA;&#xA;scope.persist(false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use &lt;code&gt;nock.cleanAll()&lt;/code&gt; which removes all mocks, including persistent mocks.&lt;/p&gt; &#xA;&lt;p&gt;To specify an exact number of times that nock should repeat the response, use &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#repeat-response-n-times&#34;&gt;.times()&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;.pendingMocks()&lt;/h3&gt; &#xA;&lt;p&gt;If a scope is not done, you can inspect the scope to infer which ones are still pending using the &lt;code&gt;scope.pendingMocks()&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (!scope.isDone()) {&#xA;  console.error(&#39;pending mocks: %j&#39;, scope.pendingMocks())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also available in the global scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.error(&#39;pending mocks: %j&#39;, nock.pendingMocks())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.activeMocks()&lt;/h3&gt; &#xA;&lt;p&gt;You can see every mock that is currently active (i.e. might potentially reply to requests) in a scope using &lt;code&gt;scope.activeMocks()&lt;/code&gt;. A mock is active if it is pending, optional but not yet completed, or persisted. Mocks that have intercepted their requests and are no longer doing anything are the only mocks which won&#39;t appear here.&lt;/p&gt; &#xA;&lt;p&gt;You probably don&#39;t need to use this - it mainly exists as a mechanism to recreate the previous (now-changed) behavior of &lt;code&gt;pendingMocks()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.error(&#39;active mocks: %j&#39;, scope.activeMocks())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also available in the global scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.error(&#39;active mocks: %j&#39;, nock.activeMocks())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.isActive()&lt;/h3&gt; &#xA;&lt;p&gt;Your tests may sometimes want to deactivate the nock interceptor. Once deactivated, nock needs to be re-activated to work. You can check if nock interceptor is active or not by using &lt;code&gt;nock.isActive()&lt;/code&gt;. Sample:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (!nock.isActive()) {&#xA;  nock.activate()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Restoring&lt;/h2&gt; &#xA;&lt;p&gt;You can restore the HTTP interceptor to the normal unmocked behaviour by calling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.restore()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;note 1&lt;/strong&gt;: restore does not clear the interceptor list. Use &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#cleanall&#34;&gt;nock.cleanAll()&lt;/a&gt; if you expect the interceptor list to be empty.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;note 2&lt;/strong&gt;: restore will also remove the http interceptor itself. You need to run &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#activating&#34;&gt;nock.activate()&lt;/a&gt; to re-activate the http interceptor. Without re-activation, nock will not intercept any calls.&lt;/p&gt; &#xA;&lt;h2&gt;Activating&lt;/h2&gt; &#xA;&lt;p&gt;Only for cases where nock has been deactivated using &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#restoring&#34;&gt;nock.restore()&lt;/a&gt;, you can reactivate the HTTP interceptor to start intercepting HTTP calls using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.activate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;: To check if nock HTTP interceptor is active or inactive, use &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#isactive&#34;&gt;nock.isActive()&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Turning Nock Off (experimental!)&lt;/h2&gt; &#xA;&lt;p&gt;You can bypass Nock completely by setting the &lt;code&gt;NOCK_OFF&lt;/code&gt; environment variable to &lt;code&gt;&#34;true&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This way you can have your tests hit the real servers just by switching on this environment variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ NOCK_OFF=true node my_test.js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Enable/Disable real HTTP requests&lt;/h2&gt; &#xA;&lt;p&gt;By default, any requests made to a host that is not mocked will be executed normally. If you want to block these requests, nock allows you to do so.&lt;/p&gt; &#xA;&lt;h3&gt;Disabling requests&lt;/h3&gt; &#xA;&lt;p&gt;For disabling real http requests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.disableNetConnect()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, if you try to request any host not &#39;nocked&#39;, it will throw a &lt;code&gt;NetConnectNotAllowedError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.disableNetConnect()&#xA;const req = http.get(&#39;http://google.com/&#39;)&#xA;req.on(&#39;error&#39;, err =&amp;gt; {&#xA;  console.log(err)&#xA;})&#xA;// The returned `http.ClientRequest` will emit an error event (or throw if you&#39;re not listening for it)&#xA;// This code will log a NetConnectNotAllowedError with message:&#xA;// Nock: Disallowed net connect for &#34;google.com:80&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enabling requests&lt;/h3&gt; &#xA;&lt;p&gt;For enabling any real HTTP requests (the default behavior):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.enableNetConnect()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could allow real HTTP requests for certain host names by providing a string or a regular expression for the hostname, or a function that accepts the hostname and returns true or false:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Using a string&#xA;nock.enableNetConnect(&#39;amazon.com&#39;)&#xA;&#xA;// Or a RegExp&#xA;nock.enableNetConnect(/(amazon|github)\.com/)&#xA;&#xA;// Or a Function&#xA;nock.enableNetConnect(&#xA;  host =&amp;gt; host.includes(&#39;amazon.com&#39;) || host.includes(&#39;github.com&#39;)&#xA;)&#xA;&#xA;http.get(&#39;http://www.amazon.com/&#39;)&#xA;http.get(&#39;http://github.com/&#39;)&#xA;&#xA;http.get(&#39;http://google.com/&#39;)&#xA;// This will throw NetConnectNotAllowedError with message:&#xA;// Nock: Disallowed net connect for &#34;google.com:80&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A common use case when testing local endpoints would be to disable all but localhost, then add in additional nocks for external requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.disableNetConnect()&#xA;// Allow localhost connections so we can test local routes and mock servers.&#xA;nock.enableNetConnect(&#39;127.0.0.1&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resetting NetConnect&lt;/h3&gt; &#xA;&lt;p&gt;When you&#39;re done with the test, you probably want to set everything back to normal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.cleanAll()&#xA;nock.enableNetConnect()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Recording&lt;/h2&gt; &#xA;&lt;p&gt;This is a cool feature:&lt;/p&gt; &#xA;&lt;p&gt;Guessing what the HTTP calls are is a mess, especially if you are introducing nock on your already-coded tests.&lt;/p&gt; &#xA;&lt;p&gt;For these cases where you want to mock an existing live system you can record and playback the HTTP calls like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.recorder.rec()&#xA;// Some HTTP calls happen and the nock code necessary to mock&#xA;// those calls will be outputted to console&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Recording relies on intercepting real requests and responses and then persisting them for later use.&lt;/p&gt; &#xA;&lt;p&gt;In order to stop recording you should call &lt;code&gt;nock.restore()&lt;/code&gt; and recording will stop.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ATTENTION!:&lt;/strong&gt; when recording is enabled, nock does no validation, nor will any mocks be enabled. Please be sure to turn off recording before attempting to use any mocks in your tests.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;dont_print&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;If you just want to capture the generated code into a var as an array you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.recorder.rec({&#xA;  dont_print: true,&#xA;})&#xA;// ... some HTTP calls&#xA;const nockCalls = nock.recorder.play()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;nockCalls&lt;/code&gt; var will contain an array of strings representing the generated code you need.&lt;/p&gt; &#xA;&lt;p&gt;Copy and paste that code into your tests, customize at will, and you&#39;re done! You can call &lt;code&gt;nock.recorder.clear()&lt;/code&gt; to remove already recorded calls from the array that &lt;code&gt;nock.recorder.play()&lt;/code&gt; returns.&lt;/p&gt; &#xA;&lt;p&gt;(Remember that you should do this one test at a time).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;output_objects&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;In case you want to generate the code yourself or use the test data in some other way, you can pass the &lt;code&gt;output_objects&lt;/code&gt; option to &lt;code&gt;rec&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.recorder.rec({&#xA;  output_objects: true,&#xA;})&#xA;// ... some HTTP calls&#xA;const nockCallObjects = nock.recorder.play()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The returned call objects have the following properties:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;scope&lt;/code&gt; - the scope of the call including the protocol and non-standard ports (e.g. &lt;code&gt;&#39;https://github.com:12345&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;method&lt;/code&gt; - the HTTP verb of the call (e.g. &lt;code&gt;&#39;GET&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;path&lt;/code&gt; - the path of the call (e.g. &lt;code&gt;&#39;/pgte/nock&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;body&lt;/code&gt; - the body of the call, if any&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;status&lt;/code&gt; - the HTTP status of the reply (e.g. &lt;code&gt;200&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;response&lt;/code&gt; - the body of the reply which can be a JSON, string, hex string representing binary buffers or an array of such hex strings (when handling &lt;code&gt;content-encoded&lt;/code&gt; in reply header)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;headers&lt;/code&gt; - the headers of the reply&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;reqheader&lt;/code&gt; - the headers of the request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you save this as a JSON file, you can load them directly through &lt;code&gt;nock.load(path)&lt;/code&gt;. Then you can post-process them before using them in the tests. For example, to add request body filtering (shown here fixing timestamps to match the ones captured during recording):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nocks = nock.load(pathToJson)&#xA;nocks.forEach(function (nock) {&#xA;  nock.filteringRequestBody = (body, aRecordedBody) =&amp;gt; {&#xA;    if (typeof body !== &#39;string&#39; || typeof aRecordedBody !== &#39;string&#39;) {&#xA;      return body&#xA;    }&#xA;&#xA;    const recordedBodyResult = /timestamp:([0-9]+)/.exec(aRecordedBody)&#xA;    if (recordedBodyResult) {&#xA;      const recordedTimestamp = recordedBodyResult[1]&#xA;      return body.replace(&#xA;        /(timestamp):([0-9]+)/g,&#xA;        function (match, key, value) {&#xA;          return key + &#39;:&#39; + recordedTimestamp&#xA;        }&#xA;      )&#xA;    } else {&#xA;      return body&#xA;    }&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, if you need to pre-process the captured nock definitions before using them (e.g. to add scope filtering) then you can use &lt;code&gt;nock.loadDefs(path)&lt;/code&gt; and &lt;code&gt;nock.define(nockDefs)&lt;/code&gt;. Shown here is scope filtering for Dropbox node module which constantly changes the subdomain to which it sends the requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//  Pre-process the nock definitions as scope filtering has to be defined before the nocks are defined (due to its very hacky nature).&#xA;const nockDefs = nock.loadDefs(pathToJson)&#xA;nockDefs.forEach(def =&amp;gt; {&#xA;  //  Do something with the definition object e.g. scope filtering.&#xA;  def.options = {&#xA;    ...def.options,&#xA;    filteringScope: scope =&amp;gt; /^https:\/\/api[0-9]*.dropbox.com/.test(scope),&#xA;  }&#xA;})&#xA;&#xA;//  Load the nocks from pre-processed definitions.&#xA;const nocks = nock.define(nockDefs)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;enable_reqheaders_recording&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;Recording request headers by default is deemed more trouble than it&#39;s worth as some of them depend on the timestamp or other values that may change after the tests have been recorded thus leading to complex postprocessing of recorded tests. Thus by default the request headers are not recorded.&lt;/p&gt; &#xA;&lt;p&gt;The genuine use cases for recording request headers (e.g. checking authorization) can be handled manually or by using &lt;code&gt;enable_reqheaders_recording&lt;/code&gt; in &lt;code&gt;recorder.rec()&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.recorder.rec({&#xA;  dont_print: true,&#xA;  output_objects: true,&#xA;  enable_reqheaders_recording: true,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that even when request headers recording is enabled Nock will never record &lt;code&gt;user-agent&lt;/code&gt; headers. &lt;code&gt;user-agent&lt;/code&gt; values change with the version of Node and underlying operating system and are thus useless for matching as all that they can indicate is that the user agent isn&#39;t the one that was used to record the tests.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;logging&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;Nock will print using &lt;code&gt;console.log&lt;/code&gt; by default (assuming that &lt;code&gt;dont_print&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). If a different function is passed into &lt;code&gt;logging&lt;/code&gt;, nock will send the log string (or object, when using &lt;code&gt;output_objects&lt;/code&gt;) to that function. Here&#39;s a basic example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const appendLogToFile = content =&amp;gt; {&#xA;  fs.appendFile(&#39;record.txt&#39;, content)&#xA;}&#xA;nock.recorder.rec({&#xA;  logging: appendLogToFile,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;use_separator&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;By default, nock will wrap its output with the separator string &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;-- cut here --&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; before and after anything it prints, whether to the console or a custom log function given with the &lt;code&gt;logging&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;To disable this, set &lt;code&gt;use_separator&lt;/code&gt; to false.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.recorder.rec({&#xA;  use_separator: false,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.removeInterceptor()&lt;/h3&gt; &#xA;&lt;p&gt;This allows removing a specific interceptor. This can be either an interceptor instance or options for a url. It&#39;s useful when there&#39;s a list of common interceptors shared between tests, where an individual test requires one of the shared interceptors to behave differently.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.removeInterceptor({&#xA;  hostname: &#39;localhost&#39;,&#xA;  path: &#39;/mockedResource&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.removeInterceptor({&#xA;  hostname: &#39;localhost&#39;,&#xA;  path: &#39;/login&#39;,&#xA;  method: &#39;POST&#39;,&#xA;  proto: &#39;https&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const interceptor = nock(&#39;http://example.org&#39;).get(&#39;somePath&#39;)&#xA;nock.removeInterceptor(interceptor)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; &lt;code&gt;.reply(...)&lt;/code&gt; method returns Scope, not Interceptor, and so it is not a valid argument for &lt;code&gt;nock.removeInterceptor&lt;/code&gt;. So if your method chain ends with &lt;code&gt;.reply&lt;/code&gt; to be used with &lt;code&gt;nock.removeInterceptor&lt;/code&gt; the chain need to be break in between:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// this will NOT work&#xA;const interceptor = nock(&#39;http://example.org&#39;).get(&#39;somePath&#39;).reply(200, &#39;OK&#39;)&#xA;nock.removeInterceptor(interceptor)&#xA;// this is how it should be&#xA;const interceptor = nock(&#39;http://example.org&#39;).get(&#39;somePath&#39;)&#xA;interceptor.reply(200, &#39;OK&#39;)&#xA;nock.removeInterceptor(interceptor)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Events&lt;/h2&gt; &#xA;&lt;p&gt;A scope emits the following events:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;emit(&#39;request&#39;, function(req, interceptor, body))&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;emit(&#39;replied&#39;, function(req, interceptor))&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Global no match event&lt;/h3&gt; &#xA;&lt;p&gt;You can also listen for no match events like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock.emitter.on(&#39;no match&#39;, req =&amp;gt; {})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Nock Back&lt;/h2&gt; &#xA;&lt;p&gt;Fixture recording support and playback.&lt;/p&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;You must specify a fixture directory before using, for example:&lt;/p&gt; &#xA;&lt;p&gt;In your test helper&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const nockBack = require(&#39;nock&#39;).back&#xA;&#xA;nockBack.fixtures = &#39;/path/to/fixtures/&#39;&#xA;nockBack.setMode(&#39;record&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Options&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nockBack.fixtures&lt;/code&gt; : path to fixture directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nockBack.setMode()&lt;/code&gt; : the mode to use&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;By default if the fixture doesn&#39;t exist, a &lt;code&gt;nockBack&lt;/code&gt; will create a new fixture and save the recorded output for you. The next time you run the test, if the fixture exists, it will be loaded in.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;this&lt;/code&gt; context of the callback function will have a property &lt;code&gt;scopes&lt;/code&gt; to access all of the loaded nock scopes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const nockBack = require(&#39;nock&#39;).back&#xA;const request = require(&#39;request&#39;)&#xA;nockBack.setMode(&#39;record&#39;)&#xA;&#xA;nockBack.fixtures = __dirname + &#39;/nockFixtures&#39; //this only needs to be set once in your test helper&#xA;&#xA;// recording of the fixture&#xA;nockBack(&#39;zomboFixture.json&#39;, nockDone =&amp;gt; {&#xA;  request.get(&#39;http://zombo.com&#39;, (err, res, body) =&amp;gt; {&#xA;    nockDone()&#xA;&#xA;    // usage of the created fixture&#xA;    nockBack(&#39;zomboFixture.json&#39;, function (nockDone) {&#xA;      http.get(&#39;http://zombo.com/&#39;).end() // respond body &#34;Ok&#34;&#xA;&#xA;      this.assertScopesFinished() //throws an exception if all nocks in fixture were not satisfied&#xA;      http.get(&#39;http://zombo.com/&#39;).end() // throws exception because someFixture.json only had one call&#xA;&#xA;      nockDone() //never gets here&#xA;    })&#xA;  })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your tests are using promises then use &lt;code&gt;nockBack&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;return nockBack(&#39;promisedFixture.json&#39;).then(({ nockDone, context }) =&amp;gt; {&#xA;  //  do your tests returning a promise and chain it with&#xA;  //  `.then(nockDone)`&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, with async/await:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const { nockDone, context } = await nockBack(&#39;promisedFixture.json&#39;)&#xA;//  your test code&#xA;nockDone()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Options&lt;/h4&gt; &#xA;&lt;p&gt;As an optional second parameter you can pass the following options&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;before&lt;/code&gt;: a preprocessing function, gets called before nock.define&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;after&lt;/code&gt;: a postprocessing function, gets called after nock.define&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;afterRecord&lt;/code&gt;: a postprocessing function, gets called after recording. Is passed the array of scopes recorded and should return the intact array, a modified version of the array, or if custom formatting is desired, a stringified version of the array to save to the fixture&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;recorder&lt;/code&gt;: custom options to pass to the recorder&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Example&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function prepareScope(scope) {&#xA;  scope.filteringRequestBody = (body, aRecordedBody) =&amp;gt; {&#xA;    if (typeof body !== &#39;string&#39; || typeof aRecordedBody !== &#39;string&#39;) {&#xA;      return body&#xA;    }&#xA;&#xA;    const recordedBodyResult = /timestamp:([0-9]+)/.exec(aRecordedBody)&#xA;    if (recordedBodyResult) {&#xA;      const recordedTimestamp = recordedBodyResult[1]&#xA;      return body.replace(&#xA;        /(timestamp):([0-9]+)/g,&#xA;        (match, key, value) =&amp;gt; `${key}:${recordedTimestamp}`&#xA;      )&#xA;    } else {&#xA;      return body&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;nockBack(&#39;exampleFixture.json&#39;, { before: prepareScope }, nockDone =&amp;gt; {&#xA;  request.get(&#39;http://example.com&#39;, function (err, res, body) {&#xA;    // do your tests&#xA;    nockDone()&#xA;  })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Modes&lt;/h3&gt; &#xA;&lt;p&gt;To set the mode call &lt;code&gt;nockBack.setMode(mode)&lt;/code&gt; or run the tests with the &lt;code&gt;NOCK_BACK_MODE&lt;/code&gt; environment variable set before loading nock. If the mode needs to be changed programmatically, the following is valid: &lt;code&gt;nockBack.setMode(nockBack.currentMode)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;wild: all requests go out to the internet, don&#39;t replay anything, doesn&#39;t record anything&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;dryrun: The default, use recorded nocks, allow http calls, doesn&#39;t record anything, useful for writing new tests&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;record: use recorded nocks, record new nocks&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;update: remove recorded nocks, record nocks&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;lockdown: use recorded nocks, disables all http calls even when not nocked, doesn&#39;t record&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Common issues&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;&#34;No match for response&#34; when using got with error responses&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sindresorhus/got&#34;&gt;Got&lt;/a&gt; automatically retries failed requests twice. That means if you have a test which mocks a 4xx or 5xx response, got will immediately reissue it. At that point, the mock will have been consumed and the second request will error out with &lt;strong&gt;Nock: No match for request&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The same is true for &lt;code&gt;.replyWithError()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Adding &lt;code&gt;{ retry: 0 }&lt;/code&gt; to the &lt;code&gt;got&lt;/code&gt; invocations will disable retrying, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await got(&#39;http://example.test/&#39;, { retry: 0 })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to do this in all your tests, you can create a module &lt;code&gt;got_client.js&lt;/code&gt; which exports a custom got instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const got = require(&#39;got&#39;)&#xA;&#xA;module.exports = got.extend({ retry: 0 })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is how it&#39;s handled in Nock itself (see &lt;a href=&#34;https://github.com/nock/nock/issues/1523&#34;&gt;#1523&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Axios&lt;/h3&gt; &#xA;&lt;p&gt;To use Nock with &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;Axios&lt;/a&gt;, you may need to configure Axios to use the Node adapter as in the example below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import axios from &#39;axios&#39;&#xA;import nock from &#39;nock&#39;&#xA;import test from &#39;ava&#39; // You can use any test framework.&#xA;&#xA;// If you are using jsdom, axios will default to using the XHR adapter which&#xA;// can&#39;t be intercepted by nock. So, configure axios to use the node adapter.&#xA;//&#xA;// References:&#xA;// https://github.com/axios/axios/pull/5277&#xA;&#xA;axios.defaults.adapter = &#39;http&#39;&#xA;&#xA;test(&#39;can fetch test response&#39;, async t =&amp;gt; {&#xA;  // Set up the mock request.&#xA;  const scope = nock(&#39;http://localhost&#39;)&#xA;    .get(&#39;/test&#39;)&#xA;    .reply(200, &#39;test response&#39;)&#xA;&#xA;  // Make the request. Note that the hostname must match exactly what is passed&#xA;  // to `nock()`. Alternatively you can set `axios.defaults.host = &#39;http://localhost&#39;`&#xA;  // and run `axios.get(&#39;/test&#39;)`.&#xA;  await axios.get(&#39;http://localhost/test&#39;)&#xA;&#xA;  // Assert that the expected request was made.&#xA;  scope.done()&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Nock + Axios + Jest to work, you&#39;ll have to also adapt your jest.config.js, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const config = {&#xA;  moduleNameMapper: {&#xA;    // Force CommonJS build for http adapter to be available.&#xA;    // via https://github.com/axios/axios/issues/5101#issuecomment-1276572468&#xA;    &#39;^axios$&#39;: require.resolve(&#39;axios&#39;),&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Memory issues with Jest&lt;/h3&gt; &#xA;&lt;p&gt;Memory issues can be avoided by calling &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#restoring&#34;&gt;&lt;code&gt;nock.restore()&lt;/code&gt;&lt;/a&gt; after each test suite.&lt;br&gt; One of the core principles of &lt;a href=&#34;https://jestjs.io/&#34;&gt;Jest&lt;/a&gt; is that it runs tests in isolation. It does this by manipulating the modules cache of Node in a way that conflicts with how Nock monkey patches the builtin &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;https&lt;/code&gt; modules. &lt;a href=&#34;https://github.com/nock/nock/issues/1817&#34;&gt;Related issue with more details&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;Nock uses &lt;a href=&#34;https://github.com/visionmedia/debug&#34;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt;, so just run with environmental variable &lt;code&gt;DEBUG&lt;/code&gt; set to &lt;code&gt;nock.*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;user@local$ DEBUG=nock.* node my_test.js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each step in the matching process is logged this way and can be useful when determining why a request was not intercepted by Nock.&lt;/p&gt; &#xA;&lt;p&gt;For example the following shows that matching failed because the request had an extra search parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;nock(&#39;http://example.com&#39;).get(&#39;/&#39;).query({ foo: &#39;bar&#39; }).reply()&#xA;&#xA;await got(&#39;http://example.com/?foo=bar&amp;amp;baz=foz&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;user@local$ DEBUG=nock.scope:example.com node my_test.js&#xA;...&#xA;nock.scope:example.com Interceptor queries: {&#34;foo&#34;:&#34;bar&#34;} +1ms&#xA;nock.scope:example.com     Request queries: {&#34;foo&#34;:&#34;bar&#34;,&#34;baz&#34;:&#34;foz&#34;} +0ms&#xA;nock.scope:example.com query matching failed +0ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Thanks for wanting to contribute! Take a look at our &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/CONTRIBUTING.md&#34;&gt;Contributing Guide&lt;/a&gt; for notes on our commit message conventions and how to run tests.&lt;/p&gt; &#xA;&lt;p&gt;Please note that this project is released with a &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/CODE_OF_CONDUCT.md&#34;&gt;Contributor Code of Conduct&lt;/a&gt;. By participating in this project you agree to abide by its terms.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Thanks goes to these wonderful people (&lt;a href=&#34;https://github.com/all-contributors/all-contributors#emoji-key&#34;&gt;emoji key&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section --&gt; &#xA;&lt;!-- prettier-ignore-start --&gt; &#xA;&lt;!-- markdownlint-disable --&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;http://pgte.me&#34;&gt;&lt;img src=&#34;https://avatars1.githubusercontent.com/u/47910?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Pedro Teixeira&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=pgte&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#maintenance-pgte&#34; title=&#34;Maintenance&#34;&gt;🚧&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/n30n0v&#34;&gt;&lt;img src=&#34;https://avatars3.githubusercontent.com/u/10771967?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;n30n0v&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=n30n0v&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://burntfen.com&#34;&gt;&lt;img src=&#34;https://avatars3.githubusercontent.com/u/910753?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Richard Littauer&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#maintenance-RichardLitt&#34; title=&#34;Maintenance&#34;&gt;🚧&lt;/a&gt; &lt;a href=&#34;https://github.com/nock/nock/commits?author=RichardLitt&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#blog-RichardLitt&#34; title=&#34;Blogposts&#34;&gt;📝&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;http://ianwsperber.com&#34;&gt;&lt;img src=&#34;https://avatars1.githubusercontent.com/u/3731165?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Ian Walker-Sperber&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=ianwsperber&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;http://ilovacha.com&#34;&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/1505203?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Ivan Erceg&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=ierceg&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#maintenance-ierceg&#34; title=&#34;Maintenance&#34;&gt;🚧&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://twitter.com/paulmelnikow&#34;&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/1487036?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Paul Melnikow&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=paulmelnikow&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#maintenance-paulmelnikow&#34; title=&#34;Maintenance&#34;&gt;🚧&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://twitter.com/gr2m&#34;&gt;&lt;img src=&#34;https://avatars3.githubusercontent.com/u/39992?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Gregor Martynus&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=gr2m&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#maintenance-gr2m&#34; title=&#34;Maintenance&#34;&gt;🚧&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#business-gr2m&#34; title=&#34;Business development&#34;&gt;💼&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#financial-gr2m&#34; title=&#34;Financial&#34;&gt;💵&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#blog-gr2m&#34; title=&#34;Blogposts&#34;&gt;📝&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://gitlab.com/hutson&#34;&gt;&lt;img src=&#34;https://avatars1.githubusercontent.com/u/6701030?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Hutson Betts&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#financial-hutson&#34; title=&#34;Financial&#34;&gt;💵&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;http://lilja.io&#34;&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/6105119?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Jonas Lilja&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#financial-jlilja&#34; title=&#34;Financial&#34;&gt;💵&lt;/a&gt; &lt;a href=&#34;https://github.com/nock/nock/commits?author=jlilja&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/benrki&#34;&gt;&lt;img src=&#34;https://avatars0.githubusercontent.com/u/4446950?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Benjamin Ki&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#financial-benrki&#34; title=&#34;Financial&#34;&gt;💵&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;http://chadf.ca&#34;&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/3250463?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Chad Fawcett&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/#financial-chadfawcett&#34; title=&#34;Financial&#34;&gt;💵&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;http://www.laurencemyers.com.au&#34;&gt;&lt;img src=&#34;https://avatars.githubusercontent.com/u/6336048?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Laurence Dougal Myers&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=laurence-myers&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/Beretta1979&#34;&gt;&lt;img src=&#34;https://avatars.githubusercontent.com/u/10073962?v=4?s=100&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt;&lt;br&gt;&lt;sub&gt;&lt;b&gt;Sébastien Van Bruaene&lt;/b&gt;&lt;/sub&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/nock/nock/commits?author=Beretta1979&#34; title=&#34;Code&#34;&gt;💻&lt;/a&gt; &lt;a href=&#34;https://github.com/nock/nock/commits?author=Beretta1979&#34; title=&#34;Tests&#34;&gt;⚠️&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;!-- markdownlint-restore --&gt; &#xA;&lt;!-- prettier-ignore-end --&gt; &#xA;&lt;!-- ALL-CONTRIBUTORS-LIST:END --&gt; &#xA;&lt;p&gt;This project follows the &lt;a href=&#34;https://github.com/all-contributors/all-contributors&#34;&gt;all-contributors&lt;/a&gt; specification. Contributions of any kind welcome!&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;Support this project by becoming a sponsor. Your logo will show up here with a link to your website. [&lt;a href=&#34;https://opencollective.com/nock#sponsor&#34;&gt;Become a sponsor&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opencollective.com/nock/sponsor/0/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/0/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/1/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/1/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/2/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/2/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/3/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/3/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/4/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/4/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/5/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/5/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/6/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/6/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/7/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/7/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/8/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/8/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/nock/sponsor/9/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/nock/sponsor/9/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nock/nock/main/LICENSE&#34;&gt;MIT&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2011–2019 &lt;a href=&#34;http://about.me/pedroteixeira&#34;&gt;Pedro Teixeira&lt;/a&gt; and other &lt;a href=&#34;https://github.com/nock/nock/graphs/contributors&#34;&gt;contributors&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>