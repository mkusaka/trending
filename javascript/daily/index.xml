<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-14T01:32:11Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fchollet/ARC-AGI</title>
    <updated>2024-06-14T01:32:11Z</updated>
    <id>tag:github.com,2024-06-14:/fchollet/ARC-AGI</id>
    <link href="https://github.com/fchollet/ARC-AGI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Abstraction and Reasoning Corpus&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Abstraction and Reasoning Corpus for Artificial General Intelligence (ARC-AGI)&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the ARC-AGI task data, as well as a browser-based interface for humans to try their hand at solving the tasks manually.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&#34;ARC can be seen as a general artificial intelligence benchmark, as a program synthesis benchmark, or as a psychometric intelligence test. It is targeted at both humans and artificially intelligent systems that aim at emulating a human-like form of general fluid intelligence.&#34;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;A complete description of the dataset, its goals, and its underlying logic, can be found in: &lt;a href=&#34;https://arxiv.org/abs/1911.01547&#34;&gt;On the Measure of Intelligence&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As a reminder, a test-taker is said to solve a task when, upon seeing the task for the first time, they are able to produce the correct output grid for &lt;em&gt;all&lt;/em&gt; test inputs in the task (this includes picking the dimensions of the output grid). For each test input, the test-taker is allowed 3 trials (this holds for all test-takers, either humans or AI).&lt;/p&gt; &#xA;&lt;h2&gt;Task file format&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;data&lt;/code&gt; directory contains two subdirectories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;data/training&lt;/code&gt;: contains the task files for training (400 tasks). Use these to prototype your algorithm or to train your algorithm to acquire ARC-relevant cognitive priors.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;data/evaluation&lt;/code&gt;: contains the task files for evaluation (400 tasks). Use these to evaluate your final algorithm. To ensure fair evaluation results, do not leak information from the evaluation set into your algorithm (e.g. by looking at the evaluation tasks yourself during development, or by repeatedly modifying an algorithm while using its evaluation score as feedback).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The tasks are stored in JSON format. Each task JSON file contains a dictionary with two fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;train&#34;&lt;/code&gt;: demonstration input/output pairs. It is a list of &#34;pairs&#34; (typically 3 pairs).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;test&#34;&lt;/code&gt;: test input/output pairs. It is a list of &#34;pairs&#34; (typically 1 pair).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A &#34;pair&#34; is a dictionary with two fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;input&#34;&lt;/code&gt;: the input &#34;grid&#34; for the pair.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;output&#34;&lt;/code&gt;: the output &#34;grid&#34; for the pair.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A &#34;grid&#34; is a rectangular matrix (list of lists) of integers between 0 and 9 (inclusive). The smallest possible grid size is 1x1 and the largest is 30x30.&lt;/p&gt; &#xA;&lt;p&gt;When looking at a task, a test-taker has access to inputs &amp;amp; outputs of the demonstration pairs, plus the input(s) of the test pair(s). The goal is to construct the output grid(s) corresponding to the test input grid(s), using 3 trials for each test input. &#34;Constructing the output grid&#34; involves picking the height and width of the output grid, then filling each cell in the grid with a symbol (integer between 0 and 9, which are visualized as colors). Only &lt;em&gt;exact&lt;/em&gt; solutions (all cells match the expected answer) can be said to be correct.&lt;/p&gt; &#xA;&lt;h2&gt;Usage of the testing interface&lt;/h2&gt; &#xA;&lt;p&gt;The testing interface is located at &lt;code&gt;apps/testing_interface.html&lt;/code&gt;. Open it in a web browser (Chrome recommended). It will prompt you to select a task JSON file.&lt;/p&gt; &#xA;&lt;p&gt;After loading a task, you will enter the test space, which looks like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://arc-benchmark.s3.amazonaws.com/figs/arc_test_space.png&#34; alt=&#34;test space&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;On the left, you will see the input/output pairs demonstrating the nature of the task. In the middle, you will see the current test input grid. On the right, you will see the controls you can use to construct the corresponding output grid.&lt;/p&gt; &#xA;&lt;p&gt;You have access to the following tools:&lt;/p&gt; &#xA;&lt;h3&gt;Grid controls&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resize: input a grid size (e.g. &#34;10x20&#34; or &#34;4x4&#34;) and click &#34;Resize&#34;. This preserves existing grid content (in the top left corner).&lt;/li&gt; &#xA; &lt;li&gt;Copy from input: copy the input grid to the output grid. This is useful for tasks where the output consists of some modification of the input.&lt;/li&gt; &#xA; &lt;li&gt;Reset grid: fill the grid with 0s.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Symbol controls&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Edit: select a color (symbol) from the color picking bar, then click on a cell to set its color.&lt;/li&gt; &#xA; &lt;li&gt;Select: click and drag on either the output grid or the input grid to select cells. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;After selecting cells on the output grid, you can select a color from the color picking to set the color of the selected cells. This is useful to draw solid rectangles or lines.&lt;/li&gt; &#xA;   &lt;li&gt;After selecting cells on either the input grid or the output grid, you can press C to copy their content. After copying, you can select a cell on the output grid and press &#34;V&#34; to paste the copied content. You should select the cell in the top left corner of the zone you want to paste into.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Floodfill: click on a cell from the output grid to color all connected cells to the selected color. &#34;Connected cells&#34; are contiguous cells with the same color.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Answer validation&lt;/h3&gt; &#xA;&lt;p&gt;When your output grid is ready, click the green &#34;Submit!&#34; button to check your answer. We do not enforce the 3-trials rule.&lt;/p&gt; &#xA;&lt;p&gt;After you&#39;ve obtained the correct answer for the current test input grid, you can switch to the next test input grid for the task using the &#34;Next test input&#34; button (if there is any available; most tasks only have one test input).&lt;/p&gt; &#xA;&lt;p&gt;When you&#39;re done with a task, use the &#34;load task&#34; button to open a new task.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>paulmillr/chokidar</title>
    <updated>2024-06-14T01:32:11Z</updated>
    <id>tag:github.com,2024-06-14:/paulmillr/chokidar</id>
    <link href="https://github.com/paulmillr/chokidar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimal and efficient cross-platform file watching library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Chokidar &lt;a href=&#34;https://github.com/paulmillr/chokidar&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/dw/chokidar.svg?sanitize=true&#34; alt=&#34;Weekly downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/paulmillr/chokidar&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/dy/chokidar.svg?sanitize=true&#34; alt=&#34;Yearly downloads&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Minimal and efficient cross-platform file watching library&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/chokidar&#34;&gt;&lt;img src=&#34;https://nodei.co/npm/chokidar.png&#34; alt=&#34;NPM&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;Node.js &lt;code&gt;fs.watch&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Doesn&#39;t report filenames on MacOS.&lt;/li&gt; &#xA; &lt;li&gt;Doesn&#39;t report events at all when using editors like Sublime on MacOS.&lt;/li&gt; &#xA; &lt;li&gt;Often reports events twice.&lt;/li&gt; &#xA; &lt;li&gt;Emits most changes as &lt;code&gt;rename&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Does not provide an easy way to recursively watch file trees.&lt;/li&gt; &#xA; &lt;li&gt;Does not support recursive watching on Linux.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Node.js &lt;code&gt;fs.watchFile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Almost as bad at event handling.&lt;/li&gt; &#xA; &lt;li&gt;Also does not provide any recursive watching.&lt;/li&gt; &#xA; &lt;li&gt;Results in high CPU utilization.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Chokidar resolves these problems.&lt;/p&gt; &#xA;&lt;p&gt;Initially made for &lt;strong&gt;&lt;a href=&#34;https://brunch.io/&#34;&gt;Brunch&lt;/a&gt;&lt;/strong&gt; (an ultra-swift web app build tool), it is now used in &lt;a href=&#34;https://github.com/microsoft/vscode&#34;&gt;Microsoft&#39;s Visual Studio Code&lt;/a&gt;, &lt;a href=&#34;https://github.com/gulpjs/gulp/&#34;&gt;gulp&lt;/a&gt;, &lt;a href=&#34;https://karma-runner.github.io/&#34;&gt;karma&lt;/a&gt;, &lt;a href=&#34;https://github.com/Unitech/PM2&#34;&gt;PM2&lt;/a&gt;, &lt;a href=&#34;http://browserify.org/&#34;&gt;browserify&lt;/a&gt;, &lt;a href=&#34;https://webpack.github.io/&#34;&gt;webpack&lt;/a&gt;, &lt;a href=&#34;https://www.browsersync.io/&#34;&gt;BrowserSync&lt;/a&gt;, and &lt;a href=&#34;https://www.npmjs.com/browse/depended/chokidar&#34;&gt;many others&lt;/a&gt;. It has proven itself in production environments.&lt;/p&gt; &#xA;&lt;p&gt;Version 3 is out! Check out our blog post about it: &lt;a href=&#34;https://paulmillr.com/posts/chokidar-3-save-32tb-of-traffic/&#34;&gt;Chokidar 3: How to save 32TB of traffic every week&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How?&lt;/h2&gt; &#xA;&lt;p&gt;Chokidar does still rely on the Node.js core &lt;code&gt;fs&lt;/code&gt; module, but when using &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; for watching, it normalizes the events it receives, often checking for truth by getting file stats and/or dir contents.&lt;/p&gt; &#xA;&lt;p&gt;On MacOS, chokidar by default uses a native extension exposing the Darwin &lt;code&gt;FSEvents&lt;/code&gt; API. This provides very efficient recursive watching compared with implementations like &lt;code&gt;kqueue&lt;/code&gt; available on most *nix platforms. Chokidar still does have to do some work to normalize the events received that way as well.&lt;/p&gt; &#xA;&lt;p&gt;On most other platforms, the &lt;code&gt;fs.watch&lt;/code&gt;-based implementation is the default, which avoids polling and keeps CPU usage down. Be advised that chokidar will initiate watchers recursively for everything within scope of the paths that have been specified, so be judicious about not wasting system resources by watching much more than needed.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Install with npm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install chokidar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then &lt;code&gt;require&lt;/code&gt; and use it in your code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const chokidar = require(&#39;chokidar&#39;);&#xA;&#xA;// One-liner for current directory&#xA;chokidar.watch(&#39;.&#39;).on(&#39;all&#39;, (event, path) =&amp;gt; {&#xA;  console.log(event, path);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Example of a more typical implementation structure&#xA;&#xA;// Initialize watcher.&#xA;const watcher = chokidar.watch(&#39;file, dir, glob, or array&#39;, {&#xA;  ignored: /(^|[\/\\])\../, // ignore dotfiles&#xA;  persistent: true&#xA;});&#xA;&#xA;// Something to use when events are received.&#xA;const log = console.log.bind(console);&#xA;// Add event listeners.&#xA;watcher&#xA;  .on(&#39;add&#39;, path =&amp;gt; log(`File ${path} has been added`))&#xA;  .on(&#39;change&#39;, path =&amp;gt; log(`File ${path} has been changed`))&#xA;  .on(&#39;unlink&#39;, path =&amp;gt; log(`File ${path} has been removed`));&#xA;&#xA;// More possible events.&#xA;watcher&#xA;  .on(&#39;addDir&#39;, path =&amp;gt; log(`Directory ${path} has been added`))&#xA;  .on(&#39;unlinkDir&#39;, path =&amp;gt; log(`Directory ${path} has been removed`))&#xA;  .on(&#39;error&#39;, error =&amp;gt; log(`Watcher error: ${error}`))&#xA;  .on(&#39;ready&#39;, () =&amp;gt; log(&#39;Initial scan complete. Ready for changes&#39;))&#xA;  .on(&#39;raw&#39;, (event, path, details) =&amp;gt; { // internal&#xA;    log(&#39;Raw event info:&#39;, event, path, details);&#xA;  });&#xA;&#xA;// &#39;add&#39;, &#39;addDir&#39; and &#39;change&#39; events also receive stat() results as second&#xA;// argument when available: https://nodejs.org/api/fs.html#fs_class_fs_stats&#xA;watcher.on(&#39;change&#39;, (path, stats) =&amp;gt; {&#xA;  if (stats) console.log(`File ${path} changed size to ${stats.size}`);&#xA;});&#xA;&#xA;// Watch new files.&#xA;watcher.add(&#39;new-file&#39;);&#xA;watcher.add([&#39;new-file-2&#39;, &#39;new-file-3&#39;, &#39;**/other-file*&#39;]);&#xA;&#xA;// Get list of actual paths being watched on the filesystem&#xA;var watchedPaths = watcher.getWatched();&#xA;&#xA;// Un-watch some files.&#xA;await watcher.unwatch(&#39;new-file*&#39;);&#xA;&#xA;// Stop watching.&#xA;// The method is async!&#xA;watcher.close().then(() =&amp;gt; console.log(&#39;closed&#39;));&#xA;&#xA;// Full list of options. See below for descriptions.&#xA;// Do not use this example!&#xA;chokidar.watch(&#39;file&#39;, {&#xA;  persistent: true,&#xA;&#xA;  ignored: &#39;*.txt&#39;,&#xA;  ignoreInitial: false,&#xA;  followSymlinks: true,&#xA;  cwd: &#39;.&#39;,&#xA;  disableGlobbing: false,&#xA;&#xA;  usePolling: false,&#xA;  interval: 100,&#xA;  binaryInterval: 300,&#xA;  alwaysStat: false,&#xA;  depth: 99,&#xA;  awaitWriteFinish: {&#xA;    stabilityThreshold: 2000,&#xA;    pollInterval: 100&#xA;  },&#xA;&#xA;  ignorePermissionErrors: false,&#xA;  atomic: true // or a custom &#39;atomicity delay&#39;, in milliseconds (default 100)&#xA;});&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;chokidar.watch(paths, [options])&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;paths&lt;/code&gt; (string or array of strings). Paths to files, dirs to be watched recursively, or glob patterns. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Note: globs must not contain windows separators (&lt;code&gt;\&lt;/code&gt;), because that&#39;s how they work by the standard — you&#39;ll need to replace them with forward slashes (&lt;code&gt;/&lt;/code&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;Note 2: for additional glob documentation, check out low-level library: &lt;a href=&#34;https://github.com/micromatch/picomatch&#34;&gt;picomatch&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; (object) Options object as defined below:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Persistence&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;persistent&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;). Indicates whether the process should continue to run as long as files are being watched. If set to &lt;code&gt;false&lt;/code&gt; when using &lt;code&gt;fsevents&lt;/code&gt; to watch, no more events will be emitted after &lt;code&gt;ready&lt;/code&gt;, even if the process continues to run.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Path filtering&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ignored&lt;/code&gt; (&lt;a href=&#34;https://github.com/es128/anymatch&#34;&gt;anymatch&lt;/a&gt;-compatible definition) Defines files/paths to be ignored. The whole relative or absolute path is tested, not just filename. If a function with two arguments is provided, it gets called twice per path - once with a single argument (the path), second time with two arguments (the path and the &lt;a href=&#34;https://nodejs.org/api/fs.html#fs_class_fs_stats&#34;&gt;&lt;code&gt;fs.Stats&lt;/code&gt;&lt;/a&gt; object of that path).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignoreInitial&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;). If set to &lt;code&gt;false&lt;/code&gt; then &lt;code&gt;add&lt;/code&gt;/&lt;code&gt;addDir&lt;/code&gt; events are also emitted for matching paths while instantiating the watching as chokidar discovers these file paths (before the &lt;code&gt;ready&lt;/code&gt; event).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;followSymlinks&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;). When &lt;code&gt;false&lt;/code&gt;, only the symlinks themselves will be watched for changes instead of following the link references and bubbling events through the link&#39;s path.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cwd&lt;/code&gt; (no default). The base directory from which watch &lt;code&gt;paths&lt;/code&gt; are to be derived. Paths emitted with events will be relative to this.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;disableGlobbing&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;). If set to &lt;code&gt;true&lt;/code&gt; then the strings passed to &lt;code&gt;.watch()&lt;/code&gt; and &lt;code&gt;.add()&lt;/code&gt; are treated as literal path names, even if they look like globs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Performance&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;usePolling&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;). Whether to use fs.watchFile (backed by polling), or fs.watch. If polling leads to high CPU utilization, consider setting this to &lt;code&gt;false&lt;/code&gt;. It is typically necessary to &lt;strong&gt;set this to &lt;code&gt;true&lt;/code&gt; to successfully watch files over a network&lt;/strong&gt;, and it may be necessary to successfully watch files in other non-standard situations. Setting to &lt;code&gt;true&lt;/code&gt; explicitly on MacOS overrides the &lt;code&gt;useFsEvents&lt;/code&gt; default. You may also set the CHOKIDAR_USEPOLLING env variable to true (1) or false (0) in order to override this option.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Polling-specific settings&lt;/em&gt; (effective when &lt;code&gt;usePolling: true&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;interval&lt;/code&gt; (default: &lt;code&gt;100&lt;/code&gt;). Interval of file system polling, in milliseconds. You may also set the CHOKIDAR_INTERVAL env variable to override this option.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;binaryInterval&lt;/code&gt; (default: &lt;code&gt;300&lt;/code&gt;). Interval of file system polling for binary files. (&lt;a href=&#34;https://github.com/sindresorhus/binary-extensions/raw/master/binary-extensions.json&#34;&gt;see list of binary extensions&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;useFsEvents&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt; on MacOS). Whether to use the &lt;code&gt;fsevents&lt;/code&gt; watching interface if available. When set to &lt;code&gt;true&lt;/code&gt; explicitly and &lt;code&gt;fsevents&lt;/code&gt; is available this supercedes the &lt;code&gt;usePolling&lt;/code&gt; setting. When set to &lt;code&gt;false&lt;/code&gt; on MacOS, &lt;code&gt;usePolling: true&lt;/code&gt; becomes the default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;alwaysStat&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;). If relying upon the &lt;a href=&#34;https://nodejs.org/api/fs.html#fs_class_fs_stats&#34;&gt;&lt;code&gt;fs.Stats&lt;/code&gt;&lt;/a&gt; object that may get passed with &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;addDir&lt;/code&gt;, and &lt;code&gt;change&lt;/code&gt; events, set this to &lt;code&gt;true&lt;/code&gt; to ensure it is provided even in cases where it wasn&#39;t already available from the underlying watch events.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;depth&lt;/code&gt; (default: &lt;code&gt;undefined&lt;/code&gt;). If set, limits how many levels of subdirectories will be traversed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;awaitWriteFinish&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;). By default, the &lt;code&gt;add&lt;/code&gt; event will fire when a file first appears on disk, before the entire file has been written. Furthermore, in some cases some &lt;code&gt;change&lt;/code&gt; events will be emitted while the file is being written. In some cases, especially when watching for large files there will be a need to wait for the write operation to finish before responding to a file creation or modification. Setting &lt;code&gt;awaitWriteFinish&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; (or a truthy value) will poll file size, holding its &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;change&lt;/code&gt; events until the size does not change for a configurable amount of time. The appropriate duration setting is heavily dependent on the OS and hardware. For accurate detection this parameter should be relatively high, making file watching much less responsive. Use with caution. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;em&gt;&lt;code&gt;options.awaitWriteFinish&lt;/code&gt; can be set to an object in order to adjust timing params:&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;awaitWriteFinish.stabilityThreshold&lt;/code&gt; (default: 2000). Amount of time in milliseconds for a file size to remain constant before emitting its event.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;awaitWriteFinish.pollInterval&lt;/code&gt; (default: 100). File size polling interval, in milliseconds.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Errors&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ignorePermissionErrors&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;). Indicates whether to watch files that don&#39;t have read permissions if possible. If watching fails due to &lt;code&gt;EPERM&lt;/code&gt; or &lt;code&gt;EACCES&lt;/code&gt; with this set to &lt;code&gt;true&lt;/code&gt;, the errors will be suppressed silently.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;atomic&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;useFsEvents&lt;/code&gt; and &lt;code&gt;usePolling&lt;/code&gt; are &lt;code&gt;false&lt;/code&gt;). Automatically filters out artifacts that occur when using editors that use &#34;atomic writes&#34; instead of writing directly to the source file. If a file is re-added within 100 ms of being deleted, Chokidar emits a &lt;code&gt;change&lt;/code&gt; event rather than &lt;code&gt;unlink&lt;/code&gt; then &lt;code&gt;add&lt;/code&gt;. If the default of 100 ms does not work well for you, you can override it by setting &lt;code&gt;atomic&lt;/code&gt; to a custom value, in milliseconds.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Methods &amp;amp; Events&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;chokidar.watch()&lt;/code&gt; produces an instance of &lt;code&gt;FSWatcher&lt;/code&gt;. Methods of &lt;code&gt;FSWatcher&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.add(path / paths)&lt;/code&gt;: Add files, directories, or glob patterns for tracking. Takes an array of strings or just one string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.on(event, callback)&lt;/code&gt;: Listen for an FS event. Available events: &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;addDir&lt;/code&gt;, &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, &lt;code&gt;unlinkDir&lt;/code&gt;, &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;. Additionally &lt;code&gt;all&lt;/code&gt; is available which gets emitted with the underlying event name and path for every event other than &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt;, and &lt;code&gt;error&lt;/code&gt;. &lt;code&gt;raw&lt;/code&gt; is internal, use it carefully.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.unwatch(path / paths)&lt;/code&gt;: Stop watching files, directories, or glob patterns. Takes an array of strings or just one string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.close()&lt;/code&gt;: &lt;strong&gt;async&lt;/strong&gt; Removes all listeners from watched files. Asynchronous, returns Promise. Use with &lt;code&gt;await&lt;/code&gt; to ensure bugs don&#39;t happen.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.getWatched()&lt;/code&gt;: Returns an object representing all the paths on the file system being watched by this &lt;code&gt;FSWatcher&lt;/code&gt; instance. The object&#39;s keys are all the directories (using absolute paths unless the &lt;code&gt;cwd&lt;/code&gt; option was used), and the values are arrays of the names of the items contained in each directory.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;CLI&lt;/h2&gt; &#xA;&lt;p&gt;If you need a CLI interface for your file watching, check out &lt;a href=&#34;https://github.com/open-cli-tools/chokidar-cli&#34;&gt;chokidar-cli&lt;/a&gt;, allowing you to execute a command on each change, or get a stdio stream of change events.&lt;/p&gt; &#xA;&lt;h2&gt;Install Troubleshooting&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;npm WARN optional dep failed, continuing fsevents@n.n.n&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This message is normal part of how &lt;code&gt;npm&lt;/code&gt; handles optional dependencies and is not indicative of a problem. Even if accompanied by other related error messages, Chokidar should function properly.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;TypeError: fsevents is not a constructor&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Update chokidar by doing &lt;code&gt;rm -rf node_modules package-lock.json yarn.lock &amp;amp;&amp;amp; npm install&lt;/code&gt;, or update your dependency that uses chokidar.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Chokidar is producing &lt;code&gt;ENOSP&lt;/code&gt; error on Linux, like this:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;bash: cannot set terminal process group (-1): Inappropriate ioctl for device bash: no job control in this shell&lt;/code&gt; &lt;code&gt;Error: watch /home/ ENOSPC&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;This means Chokidar ran out of file handles and you&#39;ll need to increase their count by executing the following command in Terminal: &lt;code&gt;echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;amp;&amp;amp; sudo sysctl -p&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;For more detailed changelog, see &lt;a href=&#34;https://raw.githubusercontent.com/paulmillr/chokidar/master/.github/full_changelog.md&#34;&gt;&lt;code&gt;full_changelog.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;v3.5 (Jan 6, 2021):&lt;/strong&gt; Support for ARM Macs with Apple Silicon. Fixes for deleted symlinks.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v3.4 (Apr 26, 2020):&lt;/strong&gt; Support for directory-based symlinks. Fixes for macos file replacement.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v3.3 (Nov 2, 2019):&lt;/strong&gt; &lt;code&gt;FSWatcher#close()&lt;/code&gt; method became async. That fixes IO race conditions related to close method.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v3.2 (Oct 1, 2019):&lt;/strong&gt; Improve Linux RAM usage by 50%. Race condition fixes. Windows glob fixes. Improve stability by using tight range of dependency versions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v3.1 (Sep 16, 2019):&lt;/strong&gt; dotfiles are no longer filtered out by default. Use &lt;code&gt;ignored&lt;/code&gt; option if needed. Improve initial Linux scan time by 50%.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v3 (Apr 30, 2019):&lt;/strong&gt; massive CPU &amp;amp; RAM consumption improvements; reduces deps / package size by a factor of 17x and bumps Node.js requirement to v8.16 and higher.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v2 (Dec 29, 2017):&lt;/strong&gt; Globs are now posix-style-only; without windows support. Tons of bugfixes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v1 (Apr 7, 2015):&lt;/strong&gt; Glob support, symlink support, tons of bugfixes. Node 0.8+ is supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;v0.1 (Apr 20, 2012):&lt;/strong&gt; Initial release, extracted from &lt;a href=&#34;https://github.com/brunch/brunch/raw/9847a065aea300da99bd0753f90354cde9de1261/src/helpers.coffee#L66&#34;&gt;Brunch&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Also&lt;/h2&gt; &#xA;&lt;p&gt;Why was chokidar named this way? What&#39;s the meaning behind it?&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Chowkidar is a transliteration of a Hindi word meaning &#39;watchman, gatekeeper&#39;, चौकीदार. This ultimately comes from Sanskrit _ चतुष्क_ (crossway, quadrangle, consisting-of-four). This word is also used in other languages like Urdu as (چوکیدار) which is widely used in Pakistan and India.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT (c) Paul Miller (&lt;a href=&#34;https://paulmillr.com&#34;&gt;https://paulmillr.com&lt;/a&gt;), see &lt;a href=&#34;https://raw.githubusercontent.com/paulmillr/chokidar/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
</feed>