<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub JavaScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-14T01:32:04Z</updated>
  <subtitle>Daily Trending of JavaScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>evalstate/fast-agent</title>
    <updated>2025-05-14T01:32:04Z</updated>
    <id>tag:github.com,2025-05-14:/evalstate/fast-agent</id>
    <link href="https://github.com/evalstate/fast-agent" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Define, Prompt and Test MCP enabled Agents and Workflows&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://pypi.org/project/fast-agent-mcp/&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/v/fast-agent-mcp?color=%2334D058&amp;amp;label=pypi&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/evalstate/fast-agent/main/#&#34;&gt;&lt;img src=&#34;https://github.com/evalstate/fast-agent/actions/workflows/main-checks.yml/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/evalstate/fast-agent/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues-raw/evalstate/fast-agent&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/xg5cJ7ndN6&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1358470293990936787&#34; alt=&#34;discord&#34;&gt;&lt;/a&gt; &lt;img alt=&#34;Pepy Total Downloads&#34; src=&#34;https://img.shields.io/pepy/dt/fast-agent-mcp?label=pypi%20%7C%20downloads&#34;&gt; &lt;a href=&#34;https://github.com/evalstate/fast-agent-mcp/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/l/fast-agent-mcp&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] Documentation site is in production here : &lt;a href=&#34;https://fast-agent.ai&#34;&gt;https://fast-agent.ai&lt;/a&gt;. Feel free to feed back what&#39;s helpful and what&#39;s not. There is also an LLMs.txt &lt;a href=&#34;https://fast-agent.ai/llms.txt&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;fast-agent&lt;/code&gt;&lt;/strong&gt; enables you to create and interact with sophisticated Agents and Workflows in minutes. It is the first framework with complete, end-to-end tested MCP Feature support including Sampling. Both Anthropic (Haiku, Sonnet, Opus) and OpenAI models (gpt-4o/gpt-4.1 family, o1/o3 family) are supported.&lt;/p&gt; &#xA;&lt;p&gt;The simple declarative syntax lets you concentrate on composing your Prompts and MCP Servers to &lt;a href=&#34;https://www.anthropic.com/research/building-effective-agents&#34;&gt;build effective agents&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fast-agent&lt;/code&gt; is multi-modal, supporting Images and PDFs for both Anthropic and OpenAI endpoints via Prompts, Resources and MCP Tool Call results. The inclusion of passthrough and playback LLMs enable rapid development and test of Python glue-code for your applications.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;fast-agent&lt;/code&gt; The fast-agent documentation repo is here: &lt;a href=&#34;https://github.com/evalstate/fast-agent-docs&#34;&gt;https://github.com/evalstate/fast-agent-docs&lt;/a&gt;. Please feel free to submit PRs for documentation, experience reports or other content you think others may find helpful. All help and feedback warmly received.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Agent Application Development&lt;/h3&gt; &#xA;&lt;p&gt;Prompts and configurations that define your Agent Applications are stored in simple files, with minimal boilerplate, enabling simple management and version control.&lt;/p&gt; &#xA;&lt;p&gt;Chat with individual Agents and Components before, during and after workflow execution to tune and diagnose your application. Agents can request human input to get additional context for task completion.&lt;/p&gt; &#xA;&lt;p&gt;Simple model selection makes testing Model &amp;lt;-&amp;gt; MCP Server interaction painless. You can read more about the motivation behind this project &lt;a href=&#34;https://llmindset.co.uk/resources/fast-agent/&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/8f6dbb69-43e3-4633-8e12-5572e9614728&#34; alt=&#34;2025-03-23-fast-agent&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Get started:&lt;/h2&gt; &#xA;&lt;p&gt;Start by installing the &lt;a href=&#34;https://docs.astral.sh/uv/&#34;&gt;uv package manager&lt;/a&gt; for Python. Then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;uv pip install fast-agent-mcp          # install fast-agent!&#xA;&#xA;uv run fast-agent setup                # create an example agent and config files&#xA;uv run agent.py                        # run your first agent&#xA;uv run agent.py --model=o3-mini.low    # specify a model&#xA;uv run fast-agent quickstart workflow  # create &#34;building effective agents&#34; examples&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other quickstart examples include a Researcher Agent (with Evaluator-Optimizer workflow) and Data Analysis Agent (similar to the ChatGPT experience), demonstrating MCP Roots support.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] Windows Users - there are a couple of configuration changes needed for the Filesystem and Docker MCP Servers - necessary changes are detailed within the configuration files.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Basic Agents&lt;/h3&gt; &#xA;&lt;p&gt;Defining an agent is as simple as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.agent(&#xA;  instruction=&#34;Given an object, respond only with an estimate of its size.&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can then send messages to the Agent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;async with fast.run() as agent:&#xA;  moon_size = await agent(&#34;the moon&#34;)&#xA;  print(moon_size)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or start an interactive chat with the Agent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;async with fast.run() as agent:&#xA;  await agent.interactive()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is the complete &lt;code&gt;sizer.py&lt;/code&gt; Agent application, with boilerplate code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import asyncio&#xA;from mcp_agent.core.fastagent import FastAgent&#xA;&#xA;# Create the application&#xA;fast = FastAgent(&#34;Agent Example&#34;)&#xA;&#xA;@fast.agent(&#xA;  instruction=&#34;Given an object, respond only with an estimate of its size.&#34;&#xA;)&#xA;async def main():&#xA;  async with fast.run() as agent:&#xA;    await agent.interactive()&#xA;&#xA;if __name__ == &#34;__main__&#34;:&#xA;    asyncio.run(main())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Agent can then be run with &lt;code&gt;uv run sizer.py&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Specify a model with the &lt;code&gt;--model&lt;/code&gt; switch - for example &lt;code&gt;uv run sizer.py --model sonnet&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Combining Agents and using MCP Servers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;To generate examples use &lt;code&gt;fast-agent quickstart workflow&lt;/code&gt;. This example can be run with &lt;code&gt;uv run workflow/chaining.py&lt;/code&gt;. fast-agent looks for configuration files in the current directory before checking parent directories recursively.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Agents can be chained to build a workflow, using MCP Servers defined in the &lt;code&gt;fastagent.config.yaml&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.agent(&#xA;    &#34;url_fetcher&#34;,&#xA;    &#34;Given a URL, provide a complete and comprehensive summary&#34;,&#xA;    servers=[&#34;fetch&#34;], # Name of an MCP Server defined in fastagent.config.yaml&#xA;)&#xA;@fast.agent(&#xA;    &#34;social_media&#34;,&#xA;    &#34;&#34;&#34;&#xA;    Write a 280 character social media post for any given text.&#xA;    Respond only with the post, never use hashtags.&#xA;    &#34;&#34;&#34;,&#xA;)&#xA;@fast.chain(&#xA;    name=&#34;post_writer&#34;,&#xA;    sequence=[&#34;url_fetcher&#34;, &#34;social_media&#34;],&#xA;)&#xA;async def main():&#xA;    async with fast.run() as agent:&#xA;        # using chain workflow&#xA;        await agent.post_writer(&#34;http://llmindset.co.uk&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All Agents and Workflows respond to &lt;code&gt;.send(&#34;message&#34;)&lt;/code&gt; or &lt;code&gt;.prompt()&lt;/code&gt; to begin a chat session.&lt;/p&gt; &#xA;&lt;p&gt;Saved as &lt;code&gt;social.py&lt;/code&gt; we can now run this workflow from the command line with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;uv run workflow/chaining.py --agent post_writer --message &#34;&amp;lt;url&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the &lt;code&gt;--quiet&lt;/code&gt; switch to disable progress and message display and return only the final response - useful for simple automations.&lt;/p&gt; &#xA;&lt;h2&gt;Workflows&lt;/h2&gt; &#xA;&lt;h3&gt;Chain&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;chain&lt;/code&gt; workflow offers a more declarative approach to calling Agents in sequence:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;@fast.chain(&#xA;  &#34;post_writer&#34;,&#xA;   sequence=[&#34;url_fetcher&#34;,&#34;social_media&#34;]&#xA;)&#xA;&#xA;# we can them prompt it directly:&#xA;async with fast.run() as agent:&#xA;  await agent.post_writer()&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This starts an interactive session, which produces a short social media post for a given URL. If a &lt;em&gt;chain&lt;/em&gt; is prompted it returns to a chat with last Agent in the chain. You can switch the agent to prompt by typing &lt;code&gt;@agent-name&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Chains can be incorporated in other workflows, or contain other workflow elements (including other Chains). You can set an &lt;code&gt;instruction&lt;/code&gt; to precisely describe it&#39;s capabilities to other workflow steps if needed.&lt;/p&gt; &#xA;&lt;h3&gt;Human Input&lt;/h3&gt; &#xA;&lt;p&gt;Agents can request Human Input to assist with a task or get additional context:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.agent(&#xA;    instruction=&#34;An AI agent that assists with basic tasks. Request Human Input when needed.&#34;,&#xA;    human_input=True,&#xA;)&#xA;&#xA;await agent(&#34;print the next number in the sequence&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example &lt;code&gt;human_input.py&lt;/code&gt;, the Agent will prompt the User for additional information to complete the task.&lt;/p&gt; &#xA;&lt;h3&gt;Parallel&lt;/h3&gt; &#xA;&lt;p&gt;The Parallel Workflow sends the same message to multiple Agents simultaneously (&lt;code&gt;fan-out&lt;/code&gt;), then uses the &lt;code&gt;fan-in&lt;/code&gt; Agent to process the combined content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.agent(&#34;translate_fr&#34;, &#34;Translate the text to French&#34;)&#xA;@fast.agent(&#34;translate_de&#34;, &#34;Translate the text to German&#34;)&#xA;@fast.agent(&#34;translate_es&#34;, &#34;Translate the text to Spanish&#34;)&#xA;&#xA;@fast.parallel(&#xA;  name=&#34;translate&#34;,&#xA;  fan_out=[&#34;translate_fr&#34;,&#34;translate_de&#34;,&#34;translate_es&#34;]&#xA;)&#xA;&#xA;@fast.chain(&#xA;  &#34;post_writer&#34;,&#xA;   sequence=[&#34;url_fetcher&#34;,&#34;social_media&#34;,&#34;translate&#34;]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t specify a &lt;code&gt;fan-in&lt;/code&gt; agent, the &lt;code&gt;parallel&lt;/code&gt; returns the combined Agent results verbatim.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;parallel&lt;/code&gt; is also useful to ensemble ideas from different LLMs.&lt;/p&gt; &#xA;&lt;p&gt;When using &lt;code&gt;parallel&lt;/code&gt; in other workflows, specify an &lt;code&gt;instruction&lt;/code&gt; to describe its operation.&lt;/p&gt; &#xA;&lt;h3&gt;Evaluator-Optimizer&lt;/h3&gt; &#xA;&lt;p&gt;Evaluator-Optimizers combine 2 agents: one to generate content (the &lt;code&gt;generator&lt;/code&gt;), and the other to judge that content and provide actionable feedback (the &lt;code&gt;evaluator&lt;/code&gt;). Messages are sent to the generator first, then the pair run in a loop until either the evaluator is satisfied with the quality, or the maximum number of refinements is reached. The final result from the Generator is returned.&lt;/p&gt; &#xA;&lt;p&gt;If the Generator has &lt;code&gt;use_history&lt;/code&gt; off, the previous iteration is returned when asking for improvements - otherwise conversational context is used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.evaluator_optimizer(&#xA;  name=&#34;researcher&#34;,&#xA;  generator=&#34;web_searcher&#34;,&#xA;  evaluator=&#34;quality_assurance&#34;,&#xA;  min_rating=&#34;EXCELLENT&#34;,&#xA;  max_refinements=3&#xA;)&#xA;&#xA;async with fast.run() as agent:&#xA;  await agent.researcher.send(&#34;produce a report on how to make the perfect espresso&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When used in a workflow, it returns the last &lt;code&gt;generator&lt;/code&gt; message as the result.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;code&gt;evaluator.py&lt;/code&gt; workflow example, or &lt;code&gt;fast-agent quickstart researcher&lt;/code&gt; for a more complete example.&lt;/p&gt; &#xA;&lt;h3&gt;Router&lt;/h3&gt; &#xA;&lt;p&gt;Routers use an LLM to assess a message, and route it to the most appropriate Agent. The routing prompt is automatically generated based on the Agent instructions and available Servers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.router(&#xA;  name=&#34;route&#34;,&#xA;  agents=[&#34;agent1&#34;,&#34;agent2&#34;,&#34;agent3&#34;]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Look at the &lt;code&gt;router.py&lt;/code&gt; workflow for an example.&lt;/p&gt; &#xA;&lt;h3&gt;Orchestrator&lt;/h3&gt; &#xA;&lt;p&gt;Given a complex task, the Orchestrator uses an LLM to generate a plan to divide the task amongst the available Agents. The planning and aggregation prompts are generated by the Orchestrator, which benefits from using more capable models. Plans can either be built once at the beginning (&lt;code&gt;plantype=&#34;full&#34;&lt;/code&gt;) or iteratively (&lt;code&gt;plantype=&#34;iterative&#34;&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.orchestrator(&#xA;  name=&#34;orchestrate&#34;,&#xA;  agents=[&#34;task1&#34;,&#34;task2&#34;,&#34;task3&#34;]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;code&gt;orchestrator.py&lt;/code&gt; or &lt;code&gt;agent_build.py&lt;/code&gt; workflow example.&lt;/p&gt; &#xA;&lt;h2&gt;Agent Features&lt;/h2&gt; &#xA;&lt;h3&gt;Calling Agents&lt;/h3&gt; &#xA;&lt;p&gt;All definitions allow omitting the name and instructions arguments for brevity:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.agent(&#34;You are a helpful agent&#34;)          # Create an agent with a default name.&#xA;@fast.agent(&#34;greeter&#34;,&#34;Respond cheerfully!&#34;)    # Create an agent with the name &#34;greeter&#34;&#xA;&#xA;moon_size = await agent(&#34;the moon&#34;)             # Call the default (first defined agent) with a message&#xA;&#xA;result = await agent.greeter(&#34;Good morning!&#34;)   # Send a message to an agent by name using dot notation&#xA;result = await agent.greeter.send(&#34;Hello!&#34;)     # You can call &#39;send&#39; explicitly&#xA;&#xA;await agent.greeter()                           # If no message is specified, a chat session will open&#xA;await agent.greeter.prompt()                    # that can be made more explicit&#xA;await agent.greeter.prompt(default_prompt=&#34;OK&#34;) # and supports setting a default prompt&#xA;&#xA;agent[&#34;greeter&#34;].send(&#34;Good Evening!&#34;)          # Dictionary access is supported if preferred&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Defining Agents&lt;/h3&gt; &#xA;&lt;h4&gt;Basic Agent&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.agent(&#xA;  name=&#34;agent&#34;,                          # name of the agent&#xA;  instruction=&#34;You are a helpful Agent&#34;, # base instruction for the agent&#xA;  servers=[&#34;filesystem&#34;],                # list of MCP Servers for the agent&#xA;  model=&#34;o3-mini.high&#34;,                  # specify a model for the agent&#xA;  use_history=True,                      # agent maintains chat history&#xA;  request_params=RequestParams(temperature= 0.7), # additional parameters for the LLM (or RequestParams())&#xA;  human_input=True,                      # agent can request human input&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Chain&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.chain(&#xA;  name=&#34;chain&#34;,                          # name of the chain&#xA;  sequence=[&#34;agent1&#34;, &#34;agent2&#34;, ...],    # list of agents in execution order&#xA;  instruction=&#34;instruction&#34;,             # instruction to describe the chain for other workflows&#xA;  cumulative=False,                      # whether to accumulate messages through the chain&#xA;  continue_with_final=True,              # open chat with agent at end of chain after prompting&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Parallel&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.parallel(&#xA;  name=&#34;parallel&#34;,                       # name of the parallel workflow&#xA;  fan_out=[&#34;agent1&#34;, &#34;agent2&#34;],          # list of agents to run in parallel&#xA;  fan_in=&#34;aggregator&#34;,                   # name of agent that combines results (optional)&#xA;  instruction=&#34;instruction&#34;,             # instruction to describe the parallel for other workflows&#xA;  include_request=True,                  # include original request in fan-in message&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Evaluator-Optimizer&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.evaluator_optimizer(&#xA;  name=&#34;researcher&#34;,                     # name of the workflow&#xA;  generator=&#34;web_searcher&#34;,              # name of the content generator agent&#xA;  evaluator=&#34;quality_assurance&#34;,         # name of the evaluator agent&#xA;  min_rating=&#34;GOOD&#34;,                     # minimum acceptable quality (EXCELLENT, GOOD, FAIR, POOR)&#xA;  max_refinements=3,                     # maximum number of refinement iterations&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Router&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.router(&#xA;  name=&#34;route&#34;,                          # name of the router&#xA;  agents=[&#34;agent1&#34;, &#34;agent2&#34;, &#34;agent3&#34;], # list of agent names router can delegate to&#xA;  model=&#34;o3-mini.high&#34;,                  # specify routing model&#xA;  use_history=False,                     # router maintains conversation history&#xA;  human_input=False,                     # whether router can request human input&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Orchestrator&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@fast.orchestrator(&#xA;  name=&#34;orchestrator&#34;,                   # name of the orchestrator&#xA;  instruction=&#34;instruction&#34;,             # base instruction for the orchestrator&#xA;  agents=[&#34;agent1&#34;, &#34;agent2&#34;],           # list of agent names this orchestrator can use&#xA;  model=&#34;o3-mini.high&#34;,                  # specify orchestrator planning model&#xA;  use_history=False,                     # orchestrator doesn&#39;t maintain chat history (no effect).&#xA;  human_input=False,                     # whether orchestrator can request human input&#xA;  plan_type=&#34;full&#34;,                      # planning approach: &#34;full&#34; or &#34;iterative&#34;&#xA;  max_iterations=5,                      # maximum number of full plan attempts, or iterations&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multimodal Support&lt;/h3&gt; &#xA;&lt;p&gt;Add Resources to prompts using either the inbuilt &lt;code&gt;prompt-server&lt;/code&gt; or MCP Types directly. Convenience class are made available to do so simply, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  summary: str =  await agent.with_resource(&#xA;      &#34;Summarise this PDF please&#34;,&#xA;      &#34;mcp_server&#34;,&#xA;      &#34;resource://fast-agent/sample.pdf&#34;,&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;MCP Tool Result Conversion&lt;/h4&gt; &#xA;&lt;p&gt;LLM APIs have restrictions on the content types that can be returned as Tool Calls/Function results via their Chat Completions API&#39;s:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OpenAI supports Text&lt;/li&gt; &#xA; &lt;li&gt;Anthropic supports Text and Image&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For MCP Tool Results, &lt;code&gt;ImageResources&lt;/code&gt; and &lt;code&gt;EmbeddedResources&lt;/code&gt; are converted to User Messages and added to the conversation.&lt;/p&gt; &#xA;&lt;h3&gt;Prompts&lt;/h3&gt; &#xA;&lt;p&gt;MCP Prompts are supported with &lt;code&gt;apply_prompt(name,arguments)&lt;/code&gt;, which always returns an Assistant Message. If the last message from the MCP Server is a &#39;User&#39; message, it is sent to the LLM for processing. Prompts applied to the Agent&#39;s Context are retained - meaning that with &lt;code&gt;use_history=False&lt;/code&gt;, Agents can act as finely tuned responders.&lt;/p&gt; &#xA;&lt;p&gt;Prompts can also be applied interactively through the interactive interface by using the &lt;code&gt;/prompt&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;h3&gt;Sampling&lt;/h3&gt; &#xA;&lt;p&gt;Sampling LLMs are configured per Client/Server pair. Specify the model name in fastagent.config.yaml as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;mcp:&#xA;  servers:&#xA;    sampling_resource:&#xA;      command: &#34;uv&#34;&#xA;      args: [&#34;run&#34;, &#34;sampling_resource_server.py&#34;]&#xA;      sampling:&#xA;        model: &#34;haiku&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Secrets File&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] fast-agent will look recursively for a fastagent.secrets.yaml file, so you only need to manage this at the root folder of your agent definitions.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Interactive Shell&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/3e692103-bf97-489a-b519-2d0fee036369&#34; alt=&#34;fast-agent&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Project Notes&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;fast-agent&lt;/code&gt; builds on the &lt;a href=&#34;https://github.com/lastmile-ai/mcp-agent&#34;&gt;&lt;code&gt;mcp-agent&lt;/code&gt;&lt;/a&gt; project by Sarmad Qadri.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;Contributions and PRs are welcome - feel free to raise issues to discuss. Full guidelines for contributing and roadmap coming very soon. Get in touch!&lt;/p&gt;</summary>
  </entry>
</feed>