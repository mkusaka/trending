<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-01T02:08:35Z</updated>
  <subtitle>Monthly Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wieslawsoltes/ChatGPT</title>
    <updated>2023-04-01T02:08:35Z</updated>
    <id>tag:github.com,2023-04-01:/wieslawsoltes/ChatGPT</id>
    <link href="https://github.com/wieslawsoltes/ChatGPT" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A ChatGPT C# client for MacOS, Windows, Linux, Android, iOS and Browser. Powered by Avalonia UI framework.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ChatGPT&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wieslawsoltes/ChatGPT/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/wieslawsoltes/ChatGPT/actions/workflows/build.yml/badge.svg?branch=main&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/ChatGPT&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/ChatGPT.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/ChatGPT&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/ChatGPT.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A ChatGPT C# client for graphical user interface runs on MacOS, Windows, Linux, Android, iOS and Browser. Powered by &lt;a href=&#34;https://avaloniaui.net/&#34;&gt;Avalonia UI&lt;/a&gt; framework.&lt;/p&gt; &#xA;&lt;p&gt;To make the app work, you need to set the &lt;a href=&#34;https://beta.openai.com/account/api-keys&#34;&gt;OpenAI API key&lt;/a&gt; as the &lt;code&gt;OPENAI_API_KEY&lt;/code&gt; environment variable or set API key directly in app settings.&lt;/p&gt; &#xA;&lt;p&gt;You can try client using browser version &lt;a href=&#34;https://wieslawsoltes.github.io/ChatGPT/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/2297442/224843834-a58190df-3bdb-4722-b737-94e7adc87805.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Shortcuts&lt;/h1&gt; &#xA;&lt;h3&gt;Main Window&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ctrl+Shift+A - Toggle between transparent and acrylic blur window style.&lt;/li&gt; &#xA; &lt;li&gt;Ctrl+Shift+S - Toggle between visible and hidden window state.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message Prompt&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enter - Send prompt.&lt;/li&gt; &#xA; &lt;li&gt;Escape - Cancel edit.&lt;/li&gt; &#xA; &lt;li&gt;F2 - Edit prompt.&lt;/li&gt; &#xA; &lt;li&gt;Shift+Enter, Alt+Enter - Insert new line.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Build&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://dotnet.microsoft.com/en-us/download/dotnet/7.0&#34;&gt;.NET 7.0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;dotnet workload install ios android wasm-tools&lt;/code&gt; command&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dotnet publish -c Release&lt;/code&gt; command inside project directory (mobile/desktop) or &lt;code&gt;dotnet run&lt;/code&gt; for desktop to just run&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AvaloniaUI/Avalonia&#34;&gt;Avalonia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/whistyun/Markdown.Avalonia&#34;&gt;Markdown.Avalonia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AvaloniaUI/Avalonia.HtmlRenderer&#34;&gt;Avalonia.HtmlRenderer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/CommunityToolkit/dotnet&#34;&gt;CommunityToolkit.Mvvm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection/&#34;&gt;Microsoft.Extensions.DependencyInjection&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;.NET tool&lt;/h1&gt; &#xA;&lt;p&gt;Install:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet tool install --global ChatGPT.CLI --version 1.0.0-preview.8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Uninstall:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet tool uninstall --global ChatGPT.CLI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/ChatGPT.CLI&#34;&gt;ChatGPT.CLI&lt;/a&gt; - An .NET ChatGPT tool.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;ChatGPT.CLI:&#xA;An .NET ChatGPT tool.&#xA;&#xA;Usage:&#xA;ChatGPT.CLI [options]&#xA;&#xA;Options:&#xA;-f, --inputFiles &amp;lt;inputfiles&amp;gt;              The relative or absolute path to the input files&#xA;-d, --inputDirectory &amp;lt;inputdirectory&amp;gt;      The relative or absolute path to the input directory&#xA;-o, --outputDirectory &amp;lt;outputdirectory&amp;gt;    The relative or absolute path to the output directory&#xA;--outputFiles &amp;lt;outputfiles&amp;gt;                The relative or absolute path to the output files&#xA;-p, --pattern &amp;lt;pattern&amp;gt;                    The search string to match against the names of files in the input directory&#xA;-r, --recursive                            Recurse into subdirectories of input directory search&#xA;-e, --extension &amp;lt;extension&amp;gt;                The output file extension&#xA;-s, --settingsFile &amp;lt;settingsfile&amp;gt;          The relative or absolute path to the settings file&#xA;--temperature &amp;lt;temperature&amp;gt;                What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.&#xA;--topP &amp;lt;topp&amp;gt;                              An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.&#xA;--presencePenalty &amp;lt;presencepenalty&amp;gt;        Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model&#39;s likelihood to talk about new topics.&#xA;--frequencyPenalty &amp;lt;frequencypenalty&amp;gt;      Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model&#39;s likelihood to repeat the same line verbatim.&#xA;--maxTokens &amp;lt;maxtokens&amp;gt;                    The maximum number of tokens to generate in the chat completion.&#xA;--apiKey &amp;lt;apikey&amp;gt;                          Override OpenAI api key. By default OPENAI_API_KEY environment variable is used.&#xA;--model &amp;lt;model&amp;gt;                            ID of the model to use. See the model endpoint compatibility table for details on which models work with the Chat API.&#xA;--directions &amp;lt;directions&amp;gt;                  The system message (directions) helps set the behavior of the assistant. Typically, a conversation is formatted with a system message first, followed by alternating user and assistant messages.&#xA;-t, --threads &amp;lt;threads&amp;gt;                    The number of parallel job threads&#xA;--quiet                                    Set verbosity level to quiet&#xA;--version                                  Show version information&#xA;-?, -h, --help                             Show help and usage information&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using .NET tool &lt;code&gt;chat&lt;/code&gt; command:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C# to VB&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chat -d ./ -e vb -p *.cs --directions &#34;You are C# to VB conversion expert. Convert input code from C# to VB. Write only converted code.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;C# to F#&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chat -d ./ -e fs -p *.cs --directions &#34;You are C# to F# conversion expert. Convert input code from C# to F#. Write only code.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refactor C# code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chat -d ./ -e cs -p *.cs --directions &#34;You are C# expert. Refactor C# code to use fluent api. Write only code.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Write API documentation&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chat -d ./ -e md -p *.cs --directions &#34;You are a technical documentation writer. Write API documentation for C# code. If XML docs are missing write them.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run from source&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C# to VB&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet run -- -d ./ -e vb -p *.cs --directions &#34;You are C# to VB conversion expert. Convert input code from C# to VB. Write only converted code.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;C# to F#&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet run -- -d ./ -e fs -p *.cs --directions &#34;You are C# to F# conversion expert. Convert input code from C# to F#. Write only code.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Write API documentation&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet run -- -d ./ -e md -p *.cs --directions &#34;You are a technical documentation writer. Write API documentation for C# code. If XML docs are missing write them.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Settings file format&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;temperature&#34;: 0.7,&#xA;    &#34;top_p&#34;: 1,&#xA;    &#34;presence_penalty&#34;: 0,&#xA;    &#34;frequency_penalty&#34;: 0,&#xA;    &#34;maxTokens&#34;: 2000,&#xA;    &#34;apiKey&#34;: &#34;&#34;,&#xA;    &#34;model&#34;: &#34;gpt-3.5-turbo&#34;,&#xA;    &#34;directions&#34;: &#34;You are a helpful assistant.&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;NuGet&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/ChatGPT&#34;&gt;ChatGPT&lt;/a&gt; - An OpenAI api library for .NET.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/ChatGPT.Core&#34;&gt;ChatGPT.Core&lt;/a&gt; - An OpenAI client core library for .NET.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/ChatGPT.UI&#34;&gt;ChatGPT.UI&lt;/a&gt; - An OpenAI client user interface library for .NET.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Docs&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://platform.openai.com/docs/guides/chat&#34;&gt;Guide Chat completions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://platform.openai.com/docs/api-reference/chat&#34;&gt;API Reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;ChatGPT is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/wieslawsoltes/ChatGPT/main/LICENSE&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Cysharp/UniTask</title>
    <updated>2023-04-01T02:08:35Z</updated>
    <id>tag:github.com,2023-04-01:/Cysharp/UniTask</id>
    <link href="https://github.com/Cysharp/UniTask" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Provides an efficient allocation free async/await integration for Unity.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;UniTask&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Cysharp/UniTask/actions&#34;&gt;&lt;img src=&#34;https://github.com/Cysharp/UniTask/workflows/Build-Debug/badge.svg?sanitize=true&#34; alt=&#34;GitHub Actions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Cysharp/UniTask/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/Cysharp/UniTask.svg?sanitize=true&#34; alt=&#34;Releases&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Cysharp/UniTask/raw/master/README_CN.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/UniTask-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3-red&#34; alt=&#34;Readme_CN&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Provides an efficient allocation free async/await integration for Unity.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Struct based &lt;code&gt;UniTask&amp;lt;T&amp;gt;&lt;/code&gt; and custom AsyncMethodBuilder to achieve zero allocation&lt;/li&gt; &#xA; &lt;li&gt;Makes all Unity AsyncOperations and Coroutines awaitable&lt;/li&gt; &#xA; &lt;li&gt;PlayerLoop based task(&lt;code&gt;UniTask.Yield&lt;/code&gt;, &lt;code&gt;UniTask.Delay&lt;/code&gt;, &lt;code&gt;UniTask.DelayFrame&lt;/code&gt;, etc..) that enable replacing all coroutine operations&lt;/li&gt; &#xA; &lt;li&gt;MonoBehaviour Message Events and uGUI Events as awaitable/async-enumerable&lt;/li&gt; &#xA; &lt;li&gt;Runs completely on Unity&#39;s PlayerLoop so doesn&#39;t use threads and runs on WebGL, wasm, etc.&lt;/li&gt; &#xA; &lt;li&gt;Asynchronous LINQ, with Channel and AsyncReactiveProperty&lt;/li&gt; &#xA; &lt;li&gt;TaskTracker window to prevent memory leaks&lt;/li&gt; &#xA; &lt;li&gt;Highly compatible behaviour with Task/ValueTask/IValueTaskSource&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For technical details, see blog post: &lt;a href=&#34;https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd&#34;&gt;UniTask v2 — Zero Allocation async/await for Unity, with Asynchronous LINQ &lt;/a&gt;&lt;br&gt; For advanced tips, see blog post: &lt;a href=&#34;https://medium.com/@neuecc/extends-unitywebrequest-via-async-decorator-pattern-advanced-techniques-of-unitask-ceff9c5ee846&#34;&gt;Extends UnityWebRequest via async decorator pattern — Advanced Techniques of UniTask&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#getting-started&#34;&gt;Getting started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#basics-of-unitask-and-asyncoperation&#34;&gt;Basics of UniTask and AsyncOperation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#cancellation-and-exception-handling&#34;&gt;Cancellation and Exception handling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#timeout-handling&#34;&gt;Timeout handling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#progress&#34;&gt;Progress&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#playerloop&#34;&gt;PlayerLoop&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#async-void-vs-async-unitaskvoid&#34;&gt;async void vs async UniTaskVoid&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#unitasktracker&#34;&gt;UniTaskTracker&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#external-assets&#34;&gt;External Assets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#asyncenumerable-and-async-linq&#34;&gt;AsyncEnumerable and Async LINQ&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#awaitable-events&#34;&gt;Awaitable Events&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#channel&#34;&gt;Channel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#for-unit-testing&#34;&gt;For Unit Testing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#threadpool-limitation&#34;&gt;ThreadPool limitation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#ienumeratortounitask-limitation&#34;&gt;IEnumerator.ToUniTask limitation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#for-unityeditor&#34;&gt;For UnityEditor&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#compare-with-standard-task-api&#34;&gt;Compare with Standard Task API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#pooling-configuration&#34;&gt;Pooling Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#allocation-on-profiler&#34;&gt;Allocation on Profiler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#unitasksynchronizationcontext&#34;&gt;UniTaskSynchronizationContext&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#api-references&#34;&gt;API References&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#upm-package&#34;&gt;UPM Package&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#install-via-git-url&#34;&gt;Install via git URL&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#install-via-openupm&#34;&gt;Install via OpenUPM&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#net-core&#34;&gt;.NET Core&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Install via &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#upm-package&#34;&gt;UPM package&lt;/a&gt; or asset package(&lt;code&gt;UniTask.*.*.*.unitypackage&lt;/code&gt;) available in &lt;a href=&#34;https://github.com/Cysharp/UniTask/releases&#34;&gt;UniTask/releases&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// extension awaiter/methods can be used by this namespace&#xA;using Cysharp.Threading.Tasks;&#xA;&#xA;// You can return type as struct UniTask&amp;lt;T&amp;gt;(or UniTask), it is unity specialized lightweight alternative of Task&amp;lt;T&amp;gt;&#xA;// zero allocation and fast excution for zero overhead async/await integrate with Unity&#xA;async UniTask&amp;lt;string&amp;gt; DemoAsync()&#xA;{&#xA;    // You can await Unity&#39;s AsyncObject&#xA;    var asset = await Resources.LoadAsync&amp;lt;TextAsset&amp;gt;(&#34;foo&#34;);&#xA;    var txt = (await UnityWebRequest.Get(&#34;https://...&#34;).SendWebRequest()).downloadHandler.text;&#xA;    await SceneManager.LoadSceneAsync(&#34;scene2&#34;);&#xA;&#xA;    // .WithCancellation enables Cancel, GetCancellationTokenOnDestroy synchornizes with lifetime of GameObject&#xA;    var asset2 = await Resources.LoadAsync&amp;lt;TextAsset&amp;gt;(&#34;bar&#34;).WithCancellation(this.GetCancellationTokenOnDestroy());&#xA;&#xA;    // .ToUniTask accepts progress callback(and all options), Progress.Create is a lightweight alternative of IProgress&amp;lt;T&amp;gt;&#xA;    var asset3 = await Resources.LoadAsync&amp;lt;TextAsset&amp;gt;(&#34;baz&#34;).ToUniTask(Progress.Create&amp;lt;float&amp;gt;(x =&amp;gt; Debug.Log(x)));&#xA;&#xA;    // await frame-based operation like a coroutine&#xA;    await UniTask.DelayFrame(100); &#xA;&#xA;    // replacement of yield return new WaitForSeconds/WaitForSecondsRealtime&#xA;    await UniTask.Delay(TimeSpan.FromSeconds(10), ignoreTimeScale: false);&#xA;    &#xA;    // yield any playerloop timing(PreUpdate, Update, LateUpdate, etc...)&#xA;    await UniTask.Yield(PlayerLoopTiming.PreLateUpdate);&#xA;&#xA;    // replacement of yield return null&#xA;    await UniTask.Yield();&#xA;    await UniTask.NextFrame();&#xA;&#xA;    // replacement of WaitForEndOfFrame(requires MonoBehaviour(CoroutineRunner))&#xA;    await UniTask.WaitForEndOfFrame(this); // this is MonoBehaviour&#xA;&#xA;    // replacement of yield return new WaitForFixedUpdate(same as UniTask.Yield(PlayerLoopTiming.FixedUpdate))&#xA;    await UniTask.WaitForFixedUpdate();&#xA;    &#xA;    // replacement of yield return WaitUntil&#xA;    await UniTask.WaitUntil(() =&amp;gt; isActive == false);&#xA;&#xA;    // special helper of WaitUntil&#xA;    await UniTask.WaitUntilValueChanged(this, x =&amp;gt; x.isActive);&#xA;&#xA;    // You can await IEnumerator coroutines&#xA;    await FooCoroutineEnumerator();&#xA;&#xA;    // You can await a standard task&#xA;    await Task.Run(() =&amp;gt; 100);&#xA;&#xA;    // Multithreading, run on ThreadPool under this code&#xA;    await UniTask.SwitchToThreadPool();&#xA;&#xA;    /* work on ThreadPool */&#xA;&#xA;    // return to MainThread(same as `ObserveOnMainThread` in UniRx)&#xA;    await UniTask.SwitchToMainThread();&#xA;&#xA;    // get async webrequest&#xA;    async UniTask&amp;lt;string&amp;gt; GetTextAsync(UnityWebRequest req)&#xA;    {&#xA;        var op = await req.SendWebRequest();&#xA;        return op.downloadHandler.text;&#xA;    }&#xA;&#xA;    var task1 = GetTextAsync(UnityWebRequest.Get(&#34;http://google.com&#34;));&#xA;    var task2 = GetTextAsync(UnityWebRequest.Get(&#34;http://bing.com&#34;));&#xA;    var task3 = GetTextAsync(UnityWebRequest.Get(&#34;http://yahoo.com&#34;));&#xA;&#xA;    // concurrent async-wait and get results easily by tuple syntax&#xA;    var (google, bing, yahoo) = await UniTask.WhenAll(task1, task2, task3);&#xA;&#xA;    // shorthand of WhenAll, tuple can await directly&#xA;    var (google2, bing2, yahoo2) = await (task1, task2, task3);&#xA;&#xA;    // return async-value.(or you can use `UniTask`(no result), `UniTaskVoid`(fire and forget)).&#xA;    return (asset as TextAsset)?.text ?? throw new InvalidOperationException(&#34;Asset not found&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Basics of UniTask and AsyncOperation&lt;/h2&gt; &#xA;&lt;p&gt;UniTask features rely on C# 7.0(&lt;a href=&#34;https://github.com/dotnet/roslyn/raw/master/docs/features/task-types.md&#34;&gt;task-like custom async method builder feature&lt;/a&gt;) so the required Unity version is after &lt;code&gt;Unity 2018.3&lt;/code&gt;, the official lowest version supported is &lt;code&gt;Unity 2018.4.13f1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Why is UniTask(custom task-like object) required? Because Task is too heavy and not matched to Unity threading (single-thread). UniTask does not use threads and SynchronizationContext/ExecutionContext because Unity&#39;s asynchronous object is automaticaly dispatched by Unity&#39;s engine layer. It achieves faster and lower allocation, and is completely integrated with Unity.&lt;/p&gt; &#xA;&lt;p&gt;You can await &lt;code&gt;AsyncOperation&lt;/code&gt;, &lt;code&gt;ResourceRequest&lt;/code&gt;, &lt;code&gt;AssetBundleRequest&lt;/code&gt;, &lt;code&gt;AssetBundleCreateRequest&lt;/code&gt;, &lt;code&gt;UnityWebRequestAsyncOperation&lt;/code&gt;, &lt;code&gt;AsyncGPUReadbackRequest&lt;/code&gt;, &lt;code&gt;IEnumerator&lt;/code&gt; and others when &lt;code&gt;using Cysharp.Threading.Tasks;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;UniTask provides three pattern of extension methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;* await asyncOperation;&#xA;* .WithCancellation(CancellationToken);&#xA;* .ToUniTask(IProgress, PlayerLoopTiming, CancellationToken);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;WithCancellation&lt;/code&gt; is a simple version of &lt;code&gt;ToUniTask&lt;/code&gt;, both return &lt;code&gt;UniTask&lt;/code&gt;. For details of cancellation, see: &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#cancellation-and-exception-handling&#34;&gt;Cancellation and Exception handling&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: await directly is returned from native timing of PlayerLoop but WithCancellation and ToUniTask are returned from specified PlayerLoopTiming. For details of timing, see: &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/UniTask/master/#playerloop&#34;&gt;PlayerLoop&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: AssetBundleRequest has &lt;code&gt;asset&lt;/code&gt; and &lt;code&gt;allAssets&lt;/code&gt;, default await returns &lt;code&gt;asset&lt;/code&gt;. If you want to get &lt;code&gt;allAssets&lt;/code&gt;, you can use &lt;code&gt;AwaitForAllAssets()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The type of &lt;code&gt;UniTask&lt;/code&gt; can use utilities like &lt;code&gt;UniTask.WhenAll&lt;/code&gt;, &lt;code&gt;UniTask.WhenAny&lt;/code&gt;. They are like &lt;code&gt;Task.WhenAll&lt;/code&gt;/&lt;code&gt;Task.WhenAny&lt;/code&gt; but the return type is more useful. They return value tuples so you can deconstruct each result and pass multiple types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public async UniTaskVoid LoadManyAsync()&#xA;{&#xA;    // parallel load.&#xA;    var (a, b, c) = await UniTask.WhenAll(&#xA;        LoadAsSprite(&#34;foo&#34;),&#xA;        LoadAsSprite(&#34;bar&#34;),&#xA;        LoadAsSprite(&#34;baz&#34;));&#xA;}&#xA;&#xA;async UniTask&amp;lt;Sprite&amp;gt; LoadAsSprite(string path)&#xA;{&#xA;    var resource = await Resources.LoadAsync&amp;lt;Sprite&amp;gt;(path);&#xA;    return (resource as Sprite);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to convert a callback to UniTask, you can use &lt;code&gt;UniTaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt; which is a lightweight edition of &lt;code&gt;TaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public UniTask&amp;lt;int&amp;gt; WrapByUniTaskCompletionSource()&#xA;{&#xA;    var utcs = new UniTaskCompletionSource&amp;lt;int&amp;gt;();&#xA;&#xA;    // when complete, call utcs.TrySetResult();&#xA;    // when failed, call utcs.TrySetException();&#xA;    // when cancel, call utcs.TrySetCanceled();&#xA;&#xA;    return utcs.Task; //return UniTask&amp;lt;int&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can convert Task -&amp;gt; UniTask: &lt;code&gt;AsUniTask&lt;/code&gt;, &lt;code&gt;UniTask&lt;/code&gt; -&amp;gt; &lt;code&gt;UniTask&amp;lt;AsyncUnit&amp;gt;&lt;/code&gt;: &lt;code&gt;AsAsyncUnitUniTask&lt;/code&gt;, &lt;code&gt;UniTask&amp;lt;T&amp;gt;&lt;/code&gt; -&amp;gt; &lt;code&gt;UniTask&lt;/code&gt;: &lt;code&gt;AsUniTask&lt;/code&gt;. &lt;code&gt;UniTask&amp;lt;T&amp;gt;&lt;/code&gt; -&amp;gt; &lt;code&gt;UniTask&lt;/code&gt;&#39;s conversion cost is free.&lt;/p&gt; &#xA;&lt;p&gt;If you want to convert async to coroutine, you can use &lt;code&gt;.ToCoroutine()&lt;/code&gt;, this is useful if you want to only allow using the coroutine system.&lt;/p&gt; &#xA;&lt;p&gt;UniTask can not await twice. This is a similar constraint to the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask-1?view=netcore-3.1&#34;&gt;ValueTask/IValueTaskSource&lt;/a&gt; introduced in .NET Standard 2.1.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The following operations should never be performed on a ValueTask&#xA;  &lt;tresult&gt;&#xA;    instance:&#xA;  &lt;/tresult&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Awaiting the instance multiple times.&lt;/li&gt; &#xA;  &lt;li&gt;Calling AsTask multiple times.&lt;/li&gt; &#xA;  &lt;li&gt;Using .Result or .GetAwaiter().GetResult() when the operation hasn&#39;t yet completed, or using them multiple times.&lt;/li&gt; &#xA;  &lt;li&gt;Using more than one of these techniques to consume the instance.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;If you do any of the above, the results are undefined.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var task = UniTask.DelayFrame(10);&#xA;await task;&#xA;await task; // NG, throws Exception&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Store to the class field, you can use &lt;code&gt;UniTask.Lazy&lt;/code&gt; that supports calling multiple times. &lt;code&gt;.Preserve()&lt;/code&gt; allows for multiple calls (internally cached results). This is useful when there are multiple calls in a function scope.&lt;/p&gt; &#xA;&lt;p&gt;Also &lt;code&gt;UniTaskCompletionSource&lt;/code&gt; can await multiple times and await from many callers.&lt;/p&gt; &#xA;&lt;h2&gt;Cancellation and Exception handling&lt;/h2&gt; &#xA;&lt;p&gt;Some UniTask factory methods have a &lt;code&gt;CancellationToken cancellationToken = default&lt;/code&gt; parameter. Also some async operations for Unity have &lt;code&gt;WithCancellation(CancellationToken)&lt;/code&gt; and &lt;code&gt;ToUniTask(..., CancellationToken cancellation = default)&lt;/code&gt; extension methods.&lt;/p&gt; &#xA;&lt;p&gt;You can pass &lt;code&gt;CancellationToken&lt;/code&gt; to parameter by standard &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource&#34;&gt;&lt;code&gt;CancellationTokenSource&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cts = new CancellationTokenSource();&#xA;&#xA;cancelButton.onClick.AddListener(() =&amp;gt;&#xA;{&#xA;    cts.Cancel();&#xA;});&#xA;&#xA;await UnityWebRequest.Get(&#34;http://google.co.jp&#34;).SendWebRequest().WithCancellation(cts.Token);&#xA;&#xA;await UniTask.DelayFrame(1000, cancellationToken: cts.Token);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CancellationToken can be created by &lt;code&gt;CancellationTokenSource&lt;/code&gt; or MonoBehaviour&#39;s extension method &lt;code&gt;GetCancellationTokenOnDestroy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// this CancellationToken lifecycle is same as GameObject.&#xA;await UniTask.DelayFrame(1000, cancellationToken: this.GetCancellationTokenOnDestroy());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For propagate Cancellation, all async method recommend to accept &lt;code&gt;CancellationToken cancellationToken&lt;/code&gt; at last argument, and pass &lt;code&gt;CancellationToken&lt;/code&gt; from root to end.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await FooAsync(this.GetCancellationTokenOnDestroy());&#xA;&#xA;// ---&#xA;&#xA;async UniTask FooAsync(CancellationToken cancellationToken)&#xA;{&#xA;    await BarAsync(cancellationToken);&#xA;}&#xA;&#xA;async UniTask BarAsync(CancellationToken cancellationToken)&#xA;{&#xA;    await UniTask.Delay(TimeSpan.FromSeconds(3), cancellationToken);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;CancellationToken&lt;/code&gt; means lifecycle of async. You can hold your own lifecycle insteadof default CancellationTokenOnDestroy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyBehaviour : MonoBehaviour&#xA;{&#xA;    CancellationTokenSource disableCancellation = new CancellationTokenSource();&#xA;    CancellationTokenSource destroyCancellation = new CancellationTokenSource();&#xA;&#xA;    private void OnEnable()&#xA;    {&#xA;        if (disableCancellation != null)&#xA;        {&#xA;            disableCancellation.Dispose();&#xA;        }&#xA;        disableCancellation = new CancellationTokenSource();&#xA;    }&#xA;&#xA;    private void OnDisable()&#xA;    {&#xA;        disableCancellation.Cancel();&#xA;    }&#xA;&#xA;    private void OnDestroy()&#xA;    {&#xA;        destroyCancellation.Cancel();&#xA;        destroyCancellation.Dispose();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When cancellation is detected, all methods throw &lt;code&gt;OperationCanceledException&lt;/code&gt; and propagate upstream. When exception(not limited to &lt;code&gt;OperationCanceledException&lt;/code&gt;) is not handled in async method, it is propagated finally to &lt;code&gt;UniTaskScheduler.UnobservedTaskException&lt;/code&gt;. The default behaviour of received unhandled exception is to write log as exception. Log level can be changed using &lt;code&gt;UniTaskScheduler.UnobservedExceptionWriteLogType&lt;/code&gt;. If you want to use custom behaviour, set an action to &lt;code&gt;UniTaskScheduler.UnobservedTaskException.&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Andalso &lt;code&gt;OperationCanceledException&lt;/code&gt; is a special exception, this is silently ignored at &lt;code&gt;UnobservedTaskException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to cancel behaviour in an async UniTask method, throw &lt;code&gt;OperationCanceledException&lt;/code&gt; manually.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public async UniTask&amp;lt;int&amp;gt; FooAsync()&#xA;{&#xA;    await UniTask.Yield();&#xA;    throw new OperationCanceledException();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you handle an exception but want to ignore(propagate to global cancellation handling), use an exception filter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public async UniTask&amp;lt;int&amp;gt; BarAsync()&#xA;{&#xA;    try&#xA;    {&#xA;        var x = await FooAsync();&#xA;        return x * 2;&#xA;    }&#xA;    catch (Exception ex) when (!(ex is OperationCanceledException)) // when (ex is not OperationCanceledException) at C# 9.0&#xA;    {&#xA;        return -1;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;throws/catch &lt;code&gt;OperationCanceledException&lt;/code&gt; is slightly heavy, so if performance is a concern, use &lt;code&gt;UniTask.SuppressCancellationThrow&lt;/code&gt; to avoid OperationCanceledException throw. It returns &lt;code&gt;(bool IsCanceled, T Result)&lt;/code&gt; instead of throwing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var (isCanceled, _) = await UniTask.DelayFrame(10, cancellationToken: cts.Token).SuppressCancellationThrow();&#xA;if (isCanceled)&#xA;{&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Only suppress throws if you call directly into the most source method. Otherwise, the return value will be converted, but the entire pipeline will not suppress throws.&lt;/p&gt; &#xA;&lt;h2&gt;Timeout handling&lt;/h2&gt; &#xA;&lt;p&gt;Timeout is a variation of cancellation. You can set timeout by &lt;code&gt;CancellationTokenSouce.CancelAfterSlim(TimeSpan)&lt;/code&gt; and pass CancellationToken to async methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cts = new CancellationTokenSource();&#xA;cts.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.&#xA;&#xA;try&#xA;{&#xA;    await UnityWebRequest.Get(&#34;http://foo&#34;).SendWebRequest().WithCancellation(cts.Token);&#xA;}&#xA;catch (OperationCanceledException ex)&#xA;{&#xA;    if (ex.CancellationToken == cts.Token)&#xA;    {&#xA;        UnityEngine.Debug.Log(&#34;Timeout&#34;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;CancellationTokenSouce.CancelAfter&lt;/code&gt; is a standard api. However in Unity you should not use it because it depends threading timer. &lt;code&gt;CancelAfterSlim&lt;/code&gt; is UniTask&#39;s extension methods, it uses PlayerLoop instead.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to use timeout with other source of cancellation, use &lt;code&gt;CancellationTokenSource.CreateLinkedTokenSource&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cancelToken = new CancellationTokenSource();&#xA;cancelButton.onClick.AddListener(()=&amp;gt;&#xA;{&#xA;    cancelToken.Cancel(); // cancel from button click.&#xA;});&#xA;&#xA;var timeoutToken = new CancellationTokenSource();&#xA;timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.&#xA;&#xA;try&#xA;{&#xA;    // combine token&#xA;    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);&#xA;&#xA;    await UnityWebRequest.Get(&#34;http://foo&#34;).SendWebRequest().WithCancellation(linkedTokenSource.Token);&#xA;}&#xA;catch (OperationCanceledException ex)&#xA;{&#xA;    if (timeoutToken.IsCancellationRequested)&#xA;    {&#xA;        UnityEngine.Debug.Log(&#34;Timeout.&#34;);&#xA;    }&#xA;    else if (cancelToken.IsCancellationRequested)&#xA;    {&#xA;        UnityEngine.Debug.Log(&#34;Cancel clicked.&#34;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optimize for reduce allocation of CancellationTokenSource for timeout per call async method, you can use UniTask&#39;s &lt;code&gt;TimeoutController&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;TimeoutController timeoutController = new TimeoutController(); // setup to field for reuse.&#xA;&#xA;async UniTask FooAsync()&#xA;{&#xA;    try&#xA;    {&#xA;        // you can pass timeoutController.Timeout(TimeSpan) to cancellationToken.&#xA;        await UnityWebRequest.Get(&#34;http://foo&#34;).SendWebRequest()&#xA;            .WithCancellation(timeoutController.Timeout(TimeSpan.FromSeconds(5)));&#xA;        timeoutController.Reset(); // call Reset(Stop timeout timer and ready for reuse) when succeed.&#xA;    }&#xA;    catch (OperationCanceledException ex)&#xA;    {&#xA;        if (timeoutController.IsTimeout())&#xA;        {&#xA;            UnityEngine.Debug.Log(&#34;timeout&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use timeout with other source of cancellation, use &lt;code&gt;new TimeoutController(CancellationToken)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;TimeoutController timeoutController;&#xA;CancellationTokenSource clickCancelSource;&#xA;&#xA;void Start()&#xA;{&#xA;    this.clickCancelSource = new CancellationTokenSource();&#xA;    this.timeoutController = new TimeoutController(clickCancelSource);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: UniTask has &lt;code&gt;.Timeout&lt;/code&gt;, &lt;code&gt;.TimeoutWithoutException&lt;/code&gt; methods however, if possible, do not use these, please pass &lt;code&gt;CancellationToken&lt;/code&gt;. Because &lt;code&gt;.Timeout&lt;/code&gt; work from external of task, can not stop timeoutted task. &lt;code&gt;.Timeout&lt;/code&gt; means ignore result when timeout. If you pass a &lt;code&gt;CancellationToken&lt;/code&gt; to the method, it will act from inside of the task, so it is possible to stop a running task.&lt;/p&gt; &#xA;&lt;h2&gt;Progress&lt;/h2&gt; &#xA;&lt;p&gt;Some async operations for unity have &lt;code&gt;ToUniTask(IProgress&amp;lt;float&amp;gt; progress = null, ...)&lt;/code&gt; extension methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var progress = Progress.Create&amp;lt;float&amp;gt;(x =&amp;gt; Debug.Log(x));&#xA;&#xA;var request = await UnityWebRequest.Get(&#34;http://google.co.jp&#34;)&#xA;    .SendWebRequest()&#xA;    .ToUniTask(progress: progress);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should not use standard &lt;code&gt;new System.Progress&amp;lt;T&amp;gt;&lt;/code&gt;, because it causes allocation every time. Use &lt;code&gt;Cysharp.Threading.Tasks.Progress&lt;/code&gt; instead. This progress factory has two methods, &lt;code&gt;Create&lt;/code&gt; and &lt;code&gt;CreateOnlyValueChanged&lt;/code&gt;. &lt;code&gt;CreateOnlyValueChanged&lt;/code&gt; calls only when the progress value has changed.&lt;/p&gt; &#xA;&lt;p&gt;Implementing IProgress interface to caller is better as there is no lambda allocation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Foo : MonoBehaviour, IProgress&amp;lt;float&amp;gt;&#xA;{&#xA;    public void Report(float value)&#xA;    {&#xA;        UnityEngine.Debug.Log(value);&#xA;    }&#xA;&#xA;    public async UniTaskVoid WebRequest()&#xA;    {&#xA;        var request = await UnityWebRequest.Get(&#34;http://google.co.jp&#34;)&#xA;            .SendWebRequest()&#xA;            .ToUniTask(progress: this); // pass this&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;PlayerLoop&lt;/h2&gt; &#xA;&lt;p&gt;UniTask is run on a custom &lt;a href=&#34;https://docs.unity3d.com/ScriptReference/LowLevel.PlayerLoop.html&#34;&gt;PlayerLoop&lt;/a&gt;. UniTask&#39;s playerloop based methods (such as &lt;code&gt;Delay&lt;/code&gt;, &lt;code&gt;DelayFrame&lt;/code&gt;, &lt;code&gt;asyncOperation.ToUniTask&lt;/code&gt;, etc...) accept this &lt;code&gt;PlayerLoopTiming&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public enum PlayerLoopTiming&#xA;{&#xA;    Initialization = 0,&#xA;    LastInitialization = 1,&#xA;&#xA;    EarlyUpdate = 2,&#xA;    LastEarlyUpdate = 3,&#xA;&#xA;    FixedUpdate = 4,&#xA;    LastFixedUpdate = 5,&#xA;&#xA;    PreUpdate = 6,&#xA;    LastPreUpdate = 7,&#xA;&#xA;    Update = 8,&#xA;    LastUpdate = 9,&#xA;&#xA;    PreLateUpdate = 10,&#xA;    LastPreLateUpdate = 11,&#xA;&#xA;    PostLateUpdate = 12,&#xA;    LastPostLateUpdate = 13&#xA;    &#xA;#if UNITY_2020_2_OR_NEWER&#xA;    TimeUpdate = 14,&#xA;    LastTimeUpdate = 15,&#xA;#endif&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It indicates when to run, you can check &lt;a href=&#34;https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae&#34;&gt;PlayerLoopList.md&lt;/a&gt; to Unity&#39;s default playerloop and injected UniTask&#39;s custom loop.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PlayerLoopTiming.Update&lt;/code&gt; is similar to &lt;code&gt;yield return null&lt;/code&gt; in a coroutine, but it is called before Update(Update and uGUI events(button.onClick, etc...) are called on &lt;code&gt;ScriptRunBehaviourUpdate&lt;/code&gt;, yield return null is called on &lt;code&gt;ScriptRunDelayedDynamicFrameRate&lt;/code&gt;). &lt;code&gt;PlayerLoopTiming.FixedUpdate&lt;/code&gt; is similar to &lt;code&gt;WaitForFixedUpdate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;PlayerLoopTiming.LastPostLateUpdate&lt;/code&gt; is not equivalent to coroutine&#39;s &lt;code&gt;yield return new WaitForEndOfFrame()&lt;/code&gt;. Coroutine&#39;s WaitForEndOfFrame seems to run after the PlayerLoop is done. Some methods that require coroutine&#39;s end of frame(&lt;code&gt;Texture2D.ReadPixels&lt;/code&gt;, &lt;code&gt;ScreenCapture.CaptureScreenshotAsTexture&lt;/code&gt;, &lt;code&gt;CommandBuffer&lt;/code&gt;, etc) do not work correctly when replaced with async/await. In these cases, pass MonoBehaviour(coroutine runnner) to &lt;code&gt;UniTask.WaitForEndOfFrame&lt;/code&gt;. For example, &lt;code&gt;await UniTask.WaitForEndOfFrame(this);&lt;/code&gt; is lightweight allocation free alternative of &lt;code&gt;yield return new WaitForEndOfFrame()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;yield return null&lt;/code&gt; and &lt;code&gt;UniTask.Yield&lt;/code&gt; are similar but different. &lt;code&gt;yield return null&lt;/code&gt; always returns next frame but &lt;code&gt;UniTask.Yield&lt;/code&gt; returns next called. That is, call &lt;code&gt;UniTask.Yield(PlayerLoopTiming.Update)&lt;/code&gt; on &lt;code&gt;PreUpdate&lt;/code&gt;, it returns same frame. &lt;code&gt;UniTask.NextFrame()&lt;/code&gt; guarantees return next frame, you can expect this to behave exactly the same as &lt;code&gt;yield return null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;UniTask.Yield(without CancellationToken) is a special type, returns &lt;code&gt;YieldAwaitable&lt;/code&gt; and runs on YieldRunner. It is the most lightweight and fastest.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;AsyncOperation&lt;/code&gt; is returned from native timing. For example, await &lt;code&gt;SceneManager.LoadSceneAsync&lt;/code&gt; is returned from &lt;code&gt;EarlyUpdate.UpdatePreloading&lt;/code&gt; and after being called, the loaded scene&#39;s &lt;code&gt;Start&lt;/code&gt; is called from &lt;code&gt;EarlyUpdate.ScriptRunDelayedStartupFrame&lt;/code&gt;. Also &lt;code&gt;await UnityWebRequest&lt;/code&gt; is returned from &lt;code&gt;EarlyUpdate.ExecuteMainThreadJobs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In UniTask, await directly uses native timing, while &lt;code&gt;WithCancellation&lt;/code&gt; and &lt;code&gt;ToUniTask&lt;/code&gt; use specified timing. This is usually not a particular problem, but with &lt;code&gt;LoadSceneAsync&lt;/code&gt;, it causes a different order of Start and continuation after await. So it is recommended not to use &lt;code&gt;LoadSceneAsync.ToUniTask&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the stacktrace, you can check where it is running in playerloop.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/83735571-83caea80-a68b-11ea-8d22-5e22864f0d24.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;By default, UniTask&#39;s PlayerLoop is initialized at &lt;code&gt;[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The order in which methods are called in BeforeSceneLoad is nondeterministic, so if you want to use UniTask in other BeforeSceneLoad methods, you should try to initialize it before this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// AfterAssembliesLoaded is called before BeforeSceneLoad&#xA;[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]&#xA;public static void InitUniTaskLoop()&#xA;{&#xA;    var loop = PlayerLoop.GetCurrentPlayerLoop();&#xA;    Cysharp.Threading.Tasks.PlayerLoopHelper.Initialize(ref loop);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you import Unity&#39;s &lt;code&gt;Entities&lt;/code&gt; package, that resets the custom player loop to default at &lt;code&gt;BeforeSceneLoad&lt;/code&gt; and injects ECS&#39;s loop. When Unity calls ECS&#39;s inject method after UniTask&#39;s initialize method, UniTask will no longer work.&lt;/p&gt; &#xA;&lt;p&gt;To solve this issue, you can re-initialize the UniTask PlayerLoop after ECS is initialized.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Get ECS Loop.&#xA;var playerLoop = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;&#xA;&#xA;// Setup UniTask&#39;s PlayerLoop.&#xA;PlayerLoopHelper.Initialize(ref playerLoop);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can diagnose whether UniTask&#39;s player loop is ready by calling &lt;code&gt;PlayerLoopHelper.IsInjectedUniTaskPlayerLoop()&lt;/code&gt;. And also &lt;code&gt;PlayerLoopHelper.DumpCurrentPlayerLoop&lt;/code&gt; logs all current playerloops to console.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void Start()&#xA;{&#xA;    UnityEngine.Debug.Log(&#34;UniTaskPlayerLoop ready? &#34; + PlayerLoopHelper.IsInjectedUniTaskPlayerLoop());&#xA;    PlayerLoopHelper.DumpCurrentPlayerLoop();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can optimize loop cost slightly by remove unuse PlayerLoopTiming injection. You can call &lt;code&gt;PlayerLoopHelper.Initialize(InjectPlayerLoopTimings)&lt;/code&gt; on initialize.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var loop = PlayerLoop.GetCurrentPlayerLoop();&#xA;PlayerLoopHelper.Initialize(ref loop, InjectPlayerLoopTimings.Minimum); // minimum is Update | FixedUpdate | LastPostLateUpdate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;InjectPlayerLoopTimings&lt;/code&gt; has three preset, &lt;code&gt;All&lt;/code&gt; and &lt;code&gt;Standard&lt;/code&gt;(All without last except LastPostLateUpdate), &lt;code&gt;Minimum&lt;/code&gt;(&lt;code&gt;Update | FixedUpdate | LastPostLateUpdate&lt;/code&gt;). Default is All and you can combine custom inject timings like &lt;code&gt;InjectPlayerLoopTimings.Update | InjectPlayerLoopTimings.FixedUpdate | InjectPlayerLoopTimings.PreLateUpdate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can make error to use uninjected &lt;code&gt;PlayerLoopTiming&lt;/code&gt; by &lt;a href=&#34;https://github.com/dotnet/roslyn-analyzers/raw/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md&#34;&gt;Microsoft.CodeAnalysis.BannedApiAnalyzers&lt;/a&gt;. For example, you can setup &lt;code&gt;BannedSymbols.txt&lt;/code&gt; like this for &lt;code&gt;InjectPlayerLoopTimings.Minimum&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;F:Cysharp.Threading.Tasks.PlayerLoopTiming.Initialization; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.EarlyUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate; Isn&#39;t injected this PlayerLoop in this project.d&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastFixedUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreLateUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.PostLateUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.TimeUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastTimeUpdate; Isn&#39;t injected this PlayerLoop in this project.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can configure &lt;code&gt;RS0030&lt;/code&gt; severity to error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/109150837-bb933880-77ac-11eb-85ba-4fd15819dbd0.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;async void vs async UniTaskVoid&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;async void&lt;/code&gt; is a standard C# task system so it does not run on UniTask systems. It is better not to use it. &lt;code&gt;async UniTaskVoid&lt;/code&gt; is a lightweight version of &lt;code&gt;async UniTask&lt;/code&gt; because it does not have awaitable completion and reports errors immediately to &lt;code&gt;UniTaskScheduler.UnobservedTaskException&lt;/code&gt;. If you don&#39;t require awaiting (fire and forget), using &lt;code&gt;UniTaskVoid&lt;/code&gt; is better. Unfortunately to dismiss warning, you&#39;re required to call &lt;code&gt;Forget()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public async UniTaskVoid FireAndForgetMethod()&#xA;{&#xA;    // do anything...&#xA;    await UniTask.Yield();&#xA;}&#xA;&#xA;public void Caller()&#xA;{&#xA;    FireAndForgetMethod().Forget();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also UniTask has the &lt;code&gt;Forget&lt;/code&gt; method, it is similar to &lt;code&gt;UniTaskVoid&lt;/code&gt; and has the same effects. However &lt;code&gt;UniTaskVoid&lt;/code&gt; is more efficient if you completely don&#39;t use &lt;code&gt;await&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public async UniTask DoAsync()&#xA;{&#xA;    // do anything...&#xA;    await UniTask.Yield();&#xA;}&#xA;&#xA;public void Caller()&#xA;{&#xA;    DoAsync().Forget();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use an async lambda registered to an event, don&#39;t use &lt;code&gt;async void&lt;/code&gt;. Instead you can use &lt;code&gt;UniTask.Action&lt;/code&gt; or &lt;code&gt;UniTask.UnityAction&lt;/code&gt;, both of which create a delegate via &lt;code&gt;async UniTaskVoid&lt;/code&gt; lambda.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Action actEvent;&#xA;UnityAction unityEvent; // especially used in uGUI&#xA;&#xA;// Bad: async void&#xA;actEvent += async () =&amp;gt; { };&#xA;unityEvent += async () =&amp;gt; { };&#xA;&#xA;// Ok: create Action delegate by lambda&#xA;actEvent += UniTask.Action(async () =&amp;gt; { await UniTask.Yield(); });&#xA;unityEvent += UniTask.UnityAction(async () =&amp;gt; { await UniTask.Yield(); });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;UniTaskVoid&lt;/code&gt; can also be used in MonoBehaviour&#39;s &lt;code&gt;Start&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class Sample : MonoBehaviour&#xA;{&#xA;    async UniTaskVoid Start()&#xA;    {&#xA;        // async init code.&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;UniTaskTracker&lt;/h2&gt; &#xA;&lt;p&gt;useful for checking (leaked) UniTasks. You can open tracker window in &lt;code&gt;Window -&amp;gt; UniTask Tracker&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/83527073-4434bf00-a522-11ea-86e9-3b3975b26266.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enable AutoReload(Toggle) - Reload automatically.&lt;/li&gt; &#xA; &lt;li&gt;Reload - Reload view.&lt;/li&gt; &#xA; &lt;li&gt;GC.Collect - Invoke GC.Collect.&lt;/li&gt; &#xA; &lt;li&gt;Enable Tracking(Toggle) - Start to track async/await UniTask. Performance impact: low.&lt;/li&gt; &#xA; &lt;li&gt;Enable StackTrace(Toggle) - Capture StackTrace when task is started. Performance impact: high.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;UniTaskTracker is intended for debugging use only as enabling tracking and capturing stacktraces is useful but has a heavy performance impact. Recommended usage is to enable both tracking and stacktraces to find task leaks and to disable them both when done.&lt;/p&gt; &#xA;&lt;h2&gt;External Assets&lt;/h2&gt; &#xA;&lt;p&gt;By default, UniTask supports TextMeshPro(&lt;code&gt;BindTo(TMP_Text)&lt;/code&gt; and &lt;code&gt;TMP_InputField&lt;/code&gt; event extensions like standard uGUI &lt;code&gt;InputField&lt;/code&gt;), DOTween(&lt;code&gt;Tween&lt;/code&gt; as awaitable) and Addressables(&lt;code&gt;AsyncOperationHandle&lt;/code&gt; and &lt;code&gt;AsyncOperationHandle&amp;lt;T&amp;gt;&lt;/code&gt; as awaitable).&lt;/p&gt; &#xA;&lt;p&gt;There are defined in separated asmdefs like &lt;code&gt;UniTask.TextMeshPro&lt;/code&gt;, &lt;code&gt;UniTask.DOTween&lt;/code&gt;, &lt;code&gt;UniTask.Addressables&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;TextMeshPro and Addressables support are automatically enabled when importing their packages from package manager. However for DOTween support, it is required to import &lt;code&gt;com.demigiant.dotween&lt;/code&gt; from &lt;a href=&#34;https://openupm.com/packages/com.demigiant.dotween/&#34;&gt;OpenUPM&lt;/a&gt; or to define &lt;code&gt;UNITASK_DOTWEEN_SUPPORT&lt;/code&gt; to enable it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// sequential&#xA;await transform.DOMoveX(2, 10);&#xA;await transform.DOMoveZ(5, 20);&#xA;&#xA;// parallel with cancellation&#xA;var ct = this.GetCancellationTokenOnDestroy();&#xA;&#xA;await UniTask.WhenAll(&#xA;    transform.DOMoveX(10, 3).WithCancellation(ct),&#xA;    transform.DOScale(10, 3).WithCancellation(ct));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DOTween support&#39;s default behaviour(&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;WithCancellation&lt;/code&gt;, &lt;code&gt;ToUniTask&lt;/code&gt;) awaits tween is killed. It works on both Complete(true/false) and Kill(true/false). But if you want to reuse tweens (&lt;code&gt;SetAutoKill(false)&lt;/code&gt;), it does not work as expected. If you want to await for another timing, the following extension methods exist in Tween, &lt;code&gt;AwaitForComplete&lt;/code&gt;, &lt;code&gt;AwaitForPause&lt;/code&gt;, &lt;code&gt;AwaitForPlay&lt;/code&gt;, &lt;code&gt;AwaitForRewind&lt;/code&gt;, &lt;code&gt;AwaitForStepComplete&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;AsyncEnumerable and Async LINQ&lt;/h2&gt; &#xA;&lt;p&gt;Unity 2020.2 supports C# 8.0 so you can use &lt;code&gt;await foreach&lt;/code&gt;. This is the new Update notation in the async era.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Unity 2020.2, C# 8.0&#xA;await foreach (var _ in UniTaskAsyncEnumerable.EveryUpdate(token))&#xA;{&#xA;    Debug.Log(&#34;Update() &#34; + Time.frameCount);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a C# 7.3 environment, you can use the &lt;code&gt;ForEachAsync&lt;/code&gt; method to work in almost the same way.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// C# 7.3(Unity 2018.3~)&#xA;await UniTaskAsyncEnumerable.EveryUpdate(token).ForEachAsync(_ =&amp;gt;&#xA;{&#xA;    Debug.Log(&#34;Update() &#34; + Time.frameCount);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;UniTaskAsyncEnumerable implements asynchronous LINQ, similar to LINQ in &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; or Rx in &lt;code&gt;IObservable&amp;lt;T&amp;gt;&lt;/code&gt;. All standard LINQ query operators can be applied to asynchronous streams. For example, the following code shows how to apply a Where filter to a button-click asynchronous stream that runs once every two clicks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await okButton.OnClickAsAsyncEnumerable().Where((x, i) =&amp;gt; i % 2 == 0).ForEachAsync(_ =&amp;gt;&#xA;{&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fire and Forget style(for example, event handling), you can also use &lt;code&gt;Subscribe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;okButton.OnClickAsAsyncEnumerable().Where((x, i) =&amp;gt; i % 2 == 0).Subscribe(_ =&amp;gt;&#xA;{&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Async LINQ is enabled when &lt;code&gt;using Cysharp.Threading.Tasks.Linq;&lt;/code&gt;, and &lt;code&gt;UniTaskAsyncEnumerable&lt;/code&gt; is defined in &lt;code&gt;UniTask.Linq&lt;/code&gt; asmdef.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s closer to UniRx (Reactive Extensions), but UniTaskAsyncEnumerable is a pull-based asynchronous stream, whereas Rx was a push-based asynchronous stream. Note that although similar, the characteristics are different and the details behave differently along with them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;UniTaskAsyncEnumerable&lt;/code&gt; is the entry point like &lt;code&gt;Enumerable&lt;/code&gt;. In addition to the standard query operators, there are other generators for Unity such as &lt;code&gt;EveryUpdate&lt;/code&gt;, &lt;code&gt;Timer&lt;/code&gt;, &lt;code&gt;TimerFrame&lt;/code&gt;, &lt;code&gt;Interval&lt;/code&gt;, &lt;code&gt;IntervalFrame&lt;/code&gt;, and &lt;code&gt;EveryValueChanged&lt;/code&gt;. And also added additional UniTask original query operators like &lt;code&gt;Append&lt;/code&gt;, &lt;code&gt;Prepend&lt;/code&gt;, &lt;code&gt;DistinctUntilChanged&lt;/code&gt;, &lt;code&gt;ToHashSet&lt;/code&gt;, &lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;CombineLatest&lt;/code&gt;, &lt;code&gt;Do&lt;/code&gt;, &lt;code&gt;Never&lt;/code&gt;, &lt;code&gt;ForEachAsync&lt;/code&gt;, &lt;code&gt;Pairwise&lt;/code&gt;, &lt;code&gt;Publish&lt;/code&gt;, &lt;code&gt;Queue&lt;/code&gt;, &lt;code&gt;Return&lt;/code&gt;, &lt;code&gt;SkipUntil&lt;/code&gt;, &lt;code&gt;TakeUntil&lt;/code&gt;, &lt;code&gt;SkipUntilCanceled&lt;/code&gt;, &lt;code&gt;TakeUntilCanceled&lt;/code&gt;, &lt;code&gt;TakeLast&lt;/code&gt;, &lt;code&gt;Subscribe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The method with Func as an argument has three additional overloads, &lt;code&gt;***Await&lt;/code&gt;, &lt;code&gt;***AwaitWithCancellation&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Select(Func&amp;lt;T, TR&amp;gt; selector)&#xA;SelectAwait(Func&amp;lt;T, UniTask&amp;lt;TR&amp;gt;&amp;gt; selector)&#xA;SelectAwaitWithCancellation(Func&amp;lt;T, CancellationToken, UniTask&amp;lt;TR&amp;gt;&amp;gt; selector)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use the &lt;code&gt;async&lt;/code&gt; method inside the func, use the &lt;code&gt;***Await&lt;/code&gt; or &lt;code&gt;***AwaitWithCancellation&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;How to create an async iterator: C# 8.0 supports async iterator(&lt;code&gt;async yield return&lt;/code&gt;) but it only allows &lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; and of course requires C# 8.0. UniTask supports &lt;code&gt;UniTaskAsyncEnumerable.Create&lt;/code&gt; method to create custom async iterator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// IAsyncEnumerable, C# 8.0 version of async iterator. ( do not use this style, IAsyncEnumerable is not controled in UniTask).&#xA;public async IAsyncEnumerable&amp;lt;int&amp;gt; MyEveryUpdate([EnumeratorCancellation]CancellationToken cancelationToken = default)&#xA;{&#xA;    var frameCount = 0;&#xA;    await UniTask.Yield();&#xA;    while (!token.IsCancellationRequested)&#xA;    {&#xA;        yield return frameCount++;&#xA;        await UniTask.Yield();&#xA;    }&#xA;}&#xA;&#xA;// UniTaskAsyncEnumerable.Create and use `await writer.YieldAsync` instead of `yield return`.&#xA;public IUniTaskAsyncEnumerable&amp;lt;int&amp;gt; MyEveryUpdate()&#xA;{&#xA;    // writer(IAsyncWriter&amp;lt;T&amp;gt;) has `YieldAsync(value)` method.&#xA;    return UniTaskAsyncEnumerable.Create&amp;lt;int&amp;gt;(async (writer, token) =&amp;gt;&#xA;    {&#xA;        var frameCount = 0;&#xA;        await UniTask.Yield();&#xA;        while (!token.IsCancellationRequested)&#xA;        {&#xA;            await writer.YieldAsync(frameCount++); // instead of `yield return`&#xA;            await UniTask.Yield();&#xA;        }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Awaitable Events&lt;/h2&gt; &#xA;&lt;p&gt;All uGUI component implements &lt;code&gt;***AsAsyncEnumerable&lt;/code&gt; to convert asynchronous streams of events.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;async UniTask TripleClick()&#xA;{&#xA;    // In default, used button.GetCancellationTokenOnDestroy to manage lieftime of async&#xA;    await button.OnClickAsync();&#xA;    await button.OnClickAsync();&#xA;    await button.OnClickAsync();&#xA;    Debug.Log(&#34;Three times clicked&#34;);&#xA;}&#xA;&#xA;// more efficient way&#xA;async UniTask TripleClick()&#xA;{&#xA;    using (var handler = button.GetAsyncClickEventHandler())&#xA;    {&#xA;        await handler.OnClickAsync();&#xA;        await handler.OnClickAsync();&#xA;        await handler.OnClickAsync();&#xA;        Debug.Log(&#34;Three times clicked&#34;);&#xA;    }&#xA;}&#xA;&#xA;// use async LINQ&#xA;async UniTask TripleClick(CancellationToken token)&#xA;{&#xA;    await button.OnClickAsAsyncEnumerable().Take(3).Last();&#xA;    Debug.Log(&#34;Three times clicked&#34;);&#xA;}&#xA;&#xA;// use async LINQ2&#xA;async UniTask TripleClick(CancellationToken token)&#xA;{&#xA;    await button.OnClickAsAsyncEnumerable().Take(3).ForEachAsync(_ =&amp;gt;&#xA;    {&#xA;        Debug.Log(&#34;Every clicked&#34;);&#xA;    });&#xA;    Debug.Log(&#34;Three times clicked, complete.&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All MonoBehaviour message events can convert async-streams by &lt;code&gt;AsyncTriggers&lt;/code&gt; that can be enabled by &lt;code&gt;using Cysharp.Threading.Tasks.Triggers;&lt;/code&gt;. AsyncTrigger can be created using &lt;code&gt;GetAsync***Trigger&lt;/code&gt; and triggers itself as UniTaskAsyncEnumerable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var trigger = this.GetOnCollisionEnterAsyncHandler();&#xA;await trigger.OnCollisionEnterAsync();&#xA;await trigger.OnCollisionEnterAsync();&#xA;await trigger.OnCollisionEnterAsync();&#xA;&#xA;// every moves.&#xA;await this.GetAsyncMoveTrigger().ForEachAsync(axisEventData =&amp;gt;&#xA;{&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;AsyncReactiveProperty&lt;/code&gt;, &lt;code&gt;AsyncReadOnlyReactiveProperty&lt;/code&gt; is UniTask&#39;s version of ReactiveProperty. &lt;code&gt;BindTo&lt;/code&gt; extension method of &lt;code&gt;IUniTaskAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; for binding asynchronous stream values to Unity components(Text/Selectable/TMP/Text).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var rp = new AsyncReactiveProperty&amp;lt;int&amp;gt;(99);&#xA;&#xA;// AsyncReactiveProperty itself is IUniTaskAsyncEnumerable, you can query by LINQ&#xA;rp.ForEachAsync(x =&amp;gt;&#xA;{&#xA;    Debug.Log(x);&#xA;}, this.GetCancellationTokenOnDestroy()).Forget();&#xA;&#xA;rp.Value = 10; // push 10 to all subscriber&#xA;rp.Value = 11; // push 11 to all subscriber&#xA;&#xA;// WithoutCurrent ignore initial value&#xA;// BindTo bind stream value to unity components.&#xA;rp.WithoutCurrent().BindTo(this.textComponent);&#xA;&#xA;await rp.WaitAsync(); // wait until next value set&#xA;&#xA;// also exists ToReadOnlyAsyncReactiveProperty&#xA;var rp2 = new AsyncReactiveProperty&amp;lt;int&amp;gt;(99);&#xA;var rorp = rp.CombineLatest(rp2, (x, y) =&amp;gt; (x, y)).ToReadOnlyAsyncReactiveProperty(CancellationToken.None);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A pull-type asynchronous stream does not get the next values until the asynchronous processing in the sequence is complete. This could spill data from push-type events such as buttons.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// can not get click event during 3 seconds complete.&#xA;await button.OnClickAsAsyncEnumerable().ForEachAwaitAsync(async x =&amp;gt;&#xA;{&#xA;    await UniTask.Delay(TimeSpan.FromSeconds(3));&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is useful (prevent double-click) but not useful sometimes.&lt;/p&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;Queue()&lt;/code&gt; method will also queue events during asynchronous processing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// queued message in asynchronous processing&#xA;await button.OnClickAsAsyncEnumerable().Queue().ForEachAwaitAsync(async x =&amp;gt;&#xA;{&#xA;    await UniTask.Delay(TimeSpan.FromSeconds(3));&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or use &lt;code&gt;Subscribe&lt;/code&gt;, fire and forget style.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;button.OnClickAsAsyncEnumerable().Subscribe(async x =&amp;gt;&#xA;{&#xA;    await UniTask.Delay(TimeSpan.FromSeconds(3));&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Channel&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Channel&lt;/code&gt; is the same as &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.threading.channels?view=netcore-3.1&#34;&gt;System.Threading.Tasks.Channels&lt;/a&gt; which is similar to a GoLang Channel.&lt;/p&gt; &#xA;&lt;p&gt;Currently it only supports multiple-producer, single-consumer unbounded channels. It can create by &lt;code&gt;Channel.CreateSingleConsumerUnbounded&amp;lt;T&amp;gt;()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For producer(&lt;code&gt;.Writer&lt;/code&gt;), use &lt;code&gt;TryWrite&lt;/code&gt; to push value and &lt;code&gt;TryComplete&lt;/code&gt; to complete channel. For consumer(&lt;code&gt;.Reader&lt;/code&gt;), use &lt;code&gt;TryRead&lt;/code&gt;, &lt;code&gt;WaitToReadAsync&lt;/code&gt;, &lt;code&gt;ReadAsync&lt;/code&gt;, &lt;code&gt;Completion&lt;/code&gt; and &lt;code&gt;ReadAllAsync&lt;/code&gt; to read queued messages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ReadAllAsync&lt;/code&gt; returns &lt;code&gt;IUniTaskAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; so query LINQ operators. Reader only allows single-consumer but uses &lt;code&gt;.Publish()&lt;/code&gt; query operator to enable multicast message. For example, make pub/sub utility.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class AsyncMessageBroker&amp;lt;T&amp;gt; : IDisposable&#xA;{&#xA;    Channel&amp;lt;T&amp;gt; channel;&#xA;&#xA;    IConnectableUniTaskAsyncEnumerable&amp;lt;T&amp;gt; multicastSource;&#xA;    IDisposable connection;&#xA;&#xA;    public AsyncMessageBroker()&#xA;    {&#xA;        channel = Channel.CreateSingleConsumerUnbounded&amp;lt;T&amp;gt;();&#xA;        multicastSource = channel.Reader.ReadAllAsync().Publish();&#xA;        connection = multicastSource.Connect(); // Publish returns IConnectableUniTaskAsyncEnumerable.&#xA;    }&#xA;&#xA;    public void Publish(T value)&#xA;    {&#xA;        channel.Writer.TryWrite(value);&#xA;    }&#xA;&#xA;    public IUniTaskAsyncEnumerable&amp;lt;T&amp;gt; Subscribe()&#xA;    {&#xA;        return multicastSource;&#xA;    }&#xA;&#xA;    public void Dispose()&#xA;    {&#xA;        channel.Writer.TryComplete();&#xA;        connection.Dispose();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;For Unit Testing&lt;/h2&gt; &#xA;&lt;p&gt;Unity&#39;s &lt;code&gt;[UnityTest]&lt;/code&gt; attribute can test coroutine(IEnumerator) but can not test async. &lt;code&gt;UniTask.ToCoroutine&lt;/code&gt; bridges async/await to coroutine so you can test async methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[UnityTest]&#xA;public IEnumerator DelayIgnore() =&amp;gt; UniTask.ToCoroutine(async () =&amp;gt;&#xA;{&#xA;    var time = Time.realtimeSinceStartup;&#xA;&#xA;    Time.timeScale = 0.5f;&#xA;    try&#xA;    {&#xA;        await UniTask.Delay(TimeSpan.FromSeconds(3), ignoreTimeScale: true);&#xA;&#xA;        var elapsed = Time.realtimeSinceStartup - time;&#xA;        Assert.AreEqual(3, (int)Math.Round(TimeSpan.FromSeconds(elapsed).TotalSeconds, MidpointRounding.ToEven));&#xA;    }&#xA;    finally&#xA;    {&#xA;        Time.timeScale = 1.0f;&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;UniTask&#39;s own unit tests are written using Unity Test Runner and &lt;a href=&#34;https://github.com/Cysharp/RuntimeUnitTestToolkit&#34;&gt;Cysharp/RuntimeUnitTestToolkit&lt;/a&gt; to integrate with CI and check if IL2CPP is working.&lt;/p&gt; &#xA;&lt;h2&gt;ThreadPool limitation&lt;/h2&gt; &#xA;&lt;p&gt;Most UniTask methods run on a single thread (PlayerLoop), with only &lt;code&gt;UniTask.Run&lt;/code&gt;(&lt;code&gt;Task.Run&lt;/code&gt; equivalent) and &lt;code&gt;UniTask.SwitchToThreadPool&lt;/code&gt; running on a thread pool. If you use a thread pool, it won&#39;t work with WebGL and so on.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;UniTask.Run&lt;/code&gt; is now deprecated. You can use &lt;code&gt;UniTask.RunOnThreadPool&lt;/code&gt; instead. And also consider whether you can use &lt;code&gt;UniTask.Create&lt;/code&gt; or &lt;code&gt;UniTask.Void&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;IEnumerator.ToUniTask limitation&lt;/h2&gt; &#xA;&lt;p&gt;You can convert coroutine(IEnumerator) to UniTask(or await directly) but it has some limitations.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;WaitForEndOfFrame&lt;/code&gt;/&lt;code&gt;WaitForFixedUpdate&lt;/code&gt;/&lt;code&gt;Coroutine&lt;/code&gt; is not supported.&lt;/li&gt; &#xA; &lt;li&gt;Consuming loop timing is not the same as &lt;code&gt;StartCoroutine&lt;/code&gt;, it uses the specified &lt;code&gt;PlayerLoopTiming&lt;/code&gt; and the default &lt;code&gt;PlayerLoopTiming.Update&lt;/code&gt; is run before MonoBehaviour&#39;s &lt;code&gt;Update&lt;/code&gt; and &lt;code&gt;StartCoroutine&lt;/code&gt;&#39;s loop.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want fully compatible conversion from coroutine to async, use the &lt;code&gt;IEnumerator.ToUniTask(MonoBehaviour coroutineRunner)&lt;/code&gt; overload. It executes StartCoroutine on an instance of the argument MonoBehaviour and waits for it to complete in UniTask.&lt;/p&gt; &#xA;&lt;h2&gt;For UnityEditor&lt;/h2&gt; &#xA;&lt;p&gt;UniTask can run on Unity Editor like an Editor Coroutine. However, there are some limitations.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;UniTask.Delay&#39;s DelayType.DeltaTime, UnscaledDeltaTime do not work correctly because they can not get deltaTime in editor. Therefore run on EditMode, automatically change DelayType to &lt;code&gt;DelayType.Realtime&lt;/code&gt; that wait for the right time.&lt;/li&gt; &#xA; &lt;li&gt;All PlayerLoopTiming run on the timing &lt;code&gt;EditorApplication.update&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-batchmode&lt;/code&gt; with &lt;code&gt;-quit&lt;/code&gt; does not work because Unity does not run &lt;code&gt;EditorApplication.update&lt;/code&gt; and quit after a single frame. Instead, don&#39;t use &lt;code&gt;-quit&lt;/code&gt; and quit manually with &lt;code&gt;EditorApplication.Exit(0)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compare with Standard Task API&lt;/h2&gt; &#xA;&lt;p&gt;UniTask has many standard Task-like APIs. This table shows what the alternative apis are.&lt;/p&gt; &#xA;&lt;p&gt;Use standard type.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;.NET Type&lt;/th&gt; &#xA;   &lt;th&gt;UniTask Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IProgress&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;---&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CancellationToken&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;---&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CancellationTokenSource&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;---&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Use UniTask type.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;.NET Type&lt;/th&gt; &#xA;   &lt;th&gt;UniTask Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task&lt;/code&gt;/&lt;code&gt;ValueTask&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;/&lt;code&gt;ValueTask&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;async void&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;async UniTaskVoid&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;+= async () =&amp;gt; { }&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.Void&lt;/code&gt;, &lt;code&gt;UniTask.Action&lt;/code&gt;, &lt;code&gt;UniTask.UnityAction&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;---&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTaskCompletionSource&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt;/&lt;code&gt;AutoResetUniTaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ManualResetValueTaskSourceCore&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTaskCompletionSourceCore&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IValueTaskSource&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IUniTaskSource&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IValueTaskSource&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IUniTaskSource&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ValueTask.IsCompleted&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.Status.IsCompleted()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ValueTask&amp;lt;T&amp;gt;.IsCompleted&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask&amp;lt;T&amp;gt;.Status.IsCompleted()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;new Progress&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Progress.Create&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CancellationToken.Register(UnsafeRegister)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CancellationToken.RegisterWithoutCaptureExecutionContext&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CancellationTokenSource.CancelAfter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CancellationTokenSource.CancelAfterSlim&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Channel.CreateUnbounded&amp;lt;T&amp;gt;(false){ SingleReader = true }&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Channel.CreateSingleConsumerUnbounded&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IUniTaskAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IAsyncEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IUniTaskAsyncEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IAsyncDisposable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IUniTaskAsyncDisposable&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.Delay&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.Delay&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.Yield&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.Yield&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.Run&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.RunOnThreadPool&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.WhenAll&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.WhenAll&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.WhenAny&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.WhenAny&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.CompletedTask&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.CompletedTask&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.FromException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.FromException&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.FromResult&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.FromResult&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.FromCanceled&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.FromCanceled&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task.ContinueWith&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTask.ContinueWith&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TaskScheduler.UnobservedTaskException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UniTaskScheduler.UnobservedTaskException&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Pooling Configuration&lt;/h2&gt; &#xA;&lt;p&gt;UniTask aggressively caches async promise objects to achieve zero allocation (for technical details, see blog post &lt;a href=&#34;https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd&#34;&gt;UniTask v2 — Zero Allocation async/await for Unity, with Asynchronous LINQ&lt;/a&gt;). By default, it caches all promises but you can configure &lt;code&gt;TaskPool.SetMaxPoolSize&lt;/code&gt; to your value, the value indicates cache size per type. &lt;code&gt;TaskPool.GetCacheSizeInfo&lt;/code&gt; returns currently cached objects in pool.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;foreach (var (type, size) in TaskPool.GetCacheSizeInfo())&#xA;{&#xA;    Debug.Log(type + &#34;:&#34; + size);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Allocation on Profiler&lt;/h2&gt; &#xA;&lt;p&gt;In UnityEditor the profiler shows allocation of compiler generated AsyncStateMachine but it only occurs in debug(development) build. C# Compiler generates AsyncStateMachine as class on Debug build and as struct on Release build.&lt;/p&gt; &#xA;&lt;p&gt;Unity supports Code Optimization option starting in 2020.1 (right, footer).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/89967342-2f944600-dc8c-11ea-99fc-0b74527a16f6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can change C# compiler optimization to release to remove AsyncStateMachine allocation in development builds. This optimization option can also be set via &lt;code&gt;Compilation.CompilationPipeline-codeOptimization&lt;/code&gt;, and &lt;code&gt;Compilation.CodeOptimization&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;UniTaskSynchronizationContext&lt;/h2&gt; &#xA;&lt;p&gt;Unity&#39;s default SynchronizationContext(&lt;code&gt;UnitySynchronizationContext&lt;/code&gt;) is a poor implementation for performance. UniTask bypasses &lt;code&gt;SynchronizationContext&lt;/code&gt;(and &lt;code&gt;ExecutionContext&lt;/code&gt;) so it does not use it but if exists in &lt;code&gt;async Task&lt;/code&gt;, still used it. &lt;code&gt;UniTaskSynchronizationContext&lt;/code&gt; is a replacement of &lt;code&gt;UnitySynchronizationContext&lt;/code&gt; which is better for performance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class SyncContextInjecter&#xA;{&#xA;    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]&#xA;    public static void Inject()&#xA;    {&#xA;        SynchronizationContext.SetSynchronizationContext(new UniTaskSynchronizationContext());&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an optional choice and is not always recommended; &lt;code&gt;UniTaskSynchronizationContext&lt;/code&gt; is less performant than &lt;code&gt;async UniTask&lt;/code&gt; and is not a complete UniTask replacement. It also does not guarantee full behavioral compatibility with the &lt;code&gt;UnitySynchronizationContext&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;API References&lt;/h2&gt; &#xA;&lt;p&gt;UniTask&#39;s API References are hosted at &lt;a href=&#34;https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.html&#34;&gt;cysharp.github.io/UniTask&lt;/a&gt; by &lt;a href=&#34;https://dotnet.github.io/docfx/&#34;&gt;DocFX&lt;/a&gt; and &lt;a href=&#34;https://github.com/Cysharp/DocfxTemplate&#34;&gt;Cysharp/DocfXTemplate&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, UniTask&#39;s factory methods can be seen at &lt;a href=&#34;https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.UniTask.html#methods-1&#34;&gt;UniTask#methods&lt;/a&gt;. UniTaskAsyncEnumerable&#39;s factory/extension methods can be seen at &lt;a href=&#34;https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable.html#methods-1&#34;&gt;UniTaskAsyncEnumerable#methods&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;UPM Package&lt;/h2&gt; &#xA;&lt;h3&gt;Install via git URL&lt;/h3&gt; &#xA;&lt;p&gt;Requires a version of unity that supports path query parameter for git packages (Unity &amp;gt;= 2019.3.4f1, Unity &amp;gt;= 2020.1a21). You can add &lt;code&gt;https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask&lt;/code&gt; to Package Manager&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/79450714-3aadd100-8020-11ea-8aae-b8d87fc4d7be.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/83702872-e0f17c80-a648-11ea-8183-7469dcd4f810.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;or add &lt;code&gt;&#34;com.cysharp.unitask&#34;: &#34;https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask&#34;&lt;/code&gt; to &lt;code&gt;Packages/manifest.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to set a target version, UniTask uses the &lt;code&gt;*.*.*&lt;/code&gt; release tag so you can specify a version like &lt;code&gt;#2.1.0&lt;/code&gt;. For example &lt;code&gt;https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask#2.1.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Install via OpenUPM&lt;/h3&gt; &#xA;&lt;p&gt;The package is available on the &lt;a href=&#34;https://openupm.com&#34;&gt;openupm registry&lt;/a&gt;. It&#39;s recommended to install it via &lt;a href=&#34;https://github.com/openupm/openupm-cli&#34;&gt;openupm-cli&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;openupm add com.cysharp.unitask&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;.NET Core&lt;/h2&gt; &#xA;&lt;p&gt;For .NET Core, use NuGet.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;PM&amp;gt; Install-Package &lt;a href=&#34;https://www.nuget.org/packages/UniTask&#34;&gt;UniTask&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;UniTask of .NET Core version is a subset of Unity UniTask with PlayerLoop dependent methods removed.&lt;/p&gt; &#xA;&lt;p&gt;It runs at higher performance than the standard Task/ValueTask, but you should be careful to ignore the ExecutionContext/SynchronizationContext when using it. &lt;code&gt;AsyncLocal&lt;/code&gt; also does not work because it ignores ExecutionContext.&lt;/p&gt; &#xA;&lt;p&gt;If you use UniTask internally, but provide ValueTask as an external API, you can write it like the following(Inspired by &lt;a href=&#34;https://github.com/mgravell/PooledAwait&#34;&gt;PooledAwait&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class ZeroAllocAsyncAwaitInDotNetCore&#xA;{&#xA;    public ValueTask&amp;lt;int&amp;gt; DoAsync(int x, int y)&#xA;    {&#xA;        return Core(this, x, y);&#xA;&#xA;        static async UniTask&amp;lt;int&amp;gt; Core(ZeroAllocAsyncAwaitInDotNetCore self, int x, int y)&#xA;        {&#xA;            // do anything...&#xA;            await Task.Delay(TimeSpan.FromSeconds(x + y));&#xA;            await UniTask.Yield();&#xA;&#xA;            return 10;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// UniTask does not return to original SynchronizationContext but you can use helper `ReturnToCurrentSynchronizationContext`.&#xA;public ValueTask TestAsync()&#xA;{&#xA;    await using (UniTask.ReturnToCurrentSynchronizationContext())&#xA;    {&#xA;        await UniTask.SwitchToThreadPool();&#xA;        // do anything..&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;.NET Core version is intended to allow users to use UniTask as an interface when sharing code with Unity (such as &lt;a href=&#34;https://github.com/Cysharp/MagicOnion/&#34;&gt;Cysharp/MagicOnion&lt;/a&gt;). .NET Core version of UniTask enables smooth code sharing.&lt;/p&gt; &#xA;&lt;p&gt;Utility methods such as WhenAll which are equivalent to UniTask are provided as &lt;a href=&#34;https://github.com/Cysharp/ValueTaskSupplement&#34;&gt;Cysharp/ValueTaskSupplement&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is under the MIT License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>lay295/TwitchDownloader</title>
    <updated>2023-04-01T02:08:35Z</updated>
    <id>tag:github.com,2023-04-01:/lay295/TwitchDownloader</id>
    <link href="https://github.com/lay295/TwitchDownloader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Twitch VOD/Clip Downloader - Chat Download/Render/Replay&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/lay295/TwitchDownloader&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/TwitchDownloaderWPF/Images/Logo.png&#34; alt=&#34;Logo&#34; width=&#34;80&#34; height=&#34;80&#34;&gt; &lt;/a&gt; &lt;/p&gt;&#xA;&lt;h3 align=&#34;center&#34;&gt;Twitch Downloader&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Twitch VOD/Clip/Chat Downloader and Chat Renderer &lt;br&gt; &lt;br&gt; &lt;a href=&#34;https://github.com/lay295/TwitchDownloader/issues&#34;&gt;Report Bug&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Chat Render Example&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/1060681/197653099-c3fd12c2-f03a-4580-84e4-63ce3f36be8d.mp4&#34;&gt;https://user-images.githubusercontent.com/1060681/197653099-c3fd12c2-f03a-4580-84e4-63ce3f36be8d.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What can it do?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download Twitch VODs&lt;/li&gt; &#xA; &lt;li&gt;Download Twitch Clips&lt;/li&gt; &#xA; &lt;li&gt;Download chat for VODs and Clips, in either a &lt;a href=&#34;https://pastebin.com/raw/YDgRe6X4&#34;&gt;JSON with all the original information&lt;/a&gt;, a browser HTML file, or a &lt;a href=&#34;https://pastebin.com/raw/016azeQX&#34;&gt;plain text file&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Update the contents of a previously generated JSON chat file with an option to save as another format&lt;/li&gt; &#xA; &lt;li&gt;Use a previously generated JSON chat file to render the chat with Twitter Twemoji or Google Noto Color emojis and BTTV, FFZ, 7TV static and animated emotes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;GUI&lt;/h1&gt; &#xA;&lt;h2&gt;Windows WPF&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bLegxGX.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/TwitchDownloaderWPF/README.md&#34;&gt;See the full WPF documentation here&lt;/a&gt;.&lt;/h3&gt; &#xA;&lt;h3&gt;Functionality&lt;/h3&gt; &#xA;&lt;p&gt;The Windows WPF GUI implements all of the main functions of the program along with some extra quality of life functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Queue up multiple download/render jobs to run simultaneously&lt;/li&gt; &#xA; &lt;li&gt;Create a list of download jobs from a list of vod/clip links&lt;/li&gt; &#xA; &lt;li&gt;Search for and download multiple VODs/clips from any streamer without leaving the app&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Multi-language Support&lt;/h3&gt; &#xA;&lt;p&gt;The Windows WPF GUI is available in multiple languages thanks to community translations. See the &lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/TwitchDownloaderWPF/README.md#localization&#34;&gt;Localization section&lt;/a&gt; of the &lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/TwitchDownloaderWPF/README.md&#34;&gt;WPF README&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Theming&lt;/h3&gt; &#xA;&lt;p&gt;The Windows WPF GUI comes bundled with both light and dark themes, along with an option to update live according the current Windows theme. It also supports user created themes! See the &lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/TwitchDownloaderWPF/README.md#theming&#34;&gt;Theming section&lt;/a&gt; of the &lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/TwitchDownloaderWPF/README.md&#34;&gt;WPF README&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Video Demonstration&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=0W3MhfhnYjk&#34;&gt;https://www.youtube.com/watch?v=0W3MhfhnYjk&lt;/a&gt; (older version, same concept)&lt;/p&gt; &#xA;&lt;h2&gt;Linux?&lt;/h2&gt; &#xA;&lt;p&gt;Check twitch-downloader-gui on &lt;a href=&#34;https://github.com/mohad12211/twitch-downloader-gui&#34;&gt;github&lt;/a&gt; or on the &lt;a href=&#34;https://aur.archlinux.org/packages/twitch-downloader-gui&#34;&gt;AUR&lt;/a&gt; for a Linux GUI wrapper for the CLI.&lt;/p&gt; &#xA;&lt;h2&gt;MacOS?&lt;/h2&gt; &#xA;&lt;p&gt;No GUI is available for MacOS yet :(&lt;/p&gt; &#xA;&lt;h1&gt;CLI&lt;/h1&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/TwitchDownloaderCLI/README.md&#34;&gt;See the full CLI documentation here&lt;/a&gt;.&lt;/h3&gt; &#xA;&lt;p&gt;The CLI is cross-platform and implements the main functions of the program. It works on Windows, Linux, and MacOS&lt;sup&gt;*&lt;/sup&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sup&gt;*Only Intel Macs have been tested&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;With the CLI, it is possible to automate video processing using external scripts. For example, you could copy-paste the following code into a &lt;code&gt;.bat&lt;/code&gt; file on Windows to download a VOD and its chat, and then render the chat, all from a single input.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off&#xA;set /p vodid=&#34;Enter VOD ID: &#34;&#xA;TwitchDownloaderCLI.exe videodownload --id %vodid% --ffmpeg-path &#34;ffmpeg.exe&#34; -o %vodid%.mp4&#xA;TwitchDownloaderCLI.exe chatdownload --id %vodid% -o %vodid%_chat.json -E&#xA;TwitchDownloaderCLI.exe chatrender -i %vodid%_chat.json -h 1080 -w 422 --framerate 30 --update-rate 0 --font-size 18 -o %vodid%_chat.mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Windows - Getting started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://github.com/lay295/TwitchDownloader/releases/&#34;&gt;Releases&lt;/a&gt; and download the latest version for Windows or &lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/#building-from-source&#34;&gt;build from source&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Extract &lt;code&gt;TwitchDownloaderCLI.exe&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Browse to where you extracted the file in the terminal.&lt;/li&gt; &#xA; &lt;li&gt;If you do not have ffmpeg, you can install it via &lt;a href=&#34;https://community.chocolatey.org/&#34;&gt;Chocolatey package manager&lt;/a&gt;, or you can get it as a standalone file from &lt;a href=&#34;https://ffmpeg.org/download.html&#34;&gt;ffmpeg.org&lt;/a&gt; or by using TwitchDownloaderCLI:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;TwitchDownloaderCLI.exe ffmpeg --download&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;You can now start using the downloader, for example:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;TwitchDownloaderCLI.exe videodownload --id &amp;lt;vod-id-here&amp;gt; -o out.mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Linux – Getting started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Some distros, like Linux Alpine, lack fonts for some languages (Arabic, Persian, Thai, etc.) If this is the case for you, install additional fonts families such as &lt;a href=&#34;https://fonts.google.com/noto/specimen/Noto+Sans&#34;&gt;Noto&lt;/a&gt; or check your distro&#39;s wiki page on fonts as it may have an install command for this specific scenario, such as the &lt;a href=&#34;https://wiki.alpinelinux.org/wiki/Fonts&#34;&gt;Linux Alpine&lt;/a&gt; font page.&lt;/li&gt; &#xA; &lt;li&gt;Ensure both &lt;code&gt;fontconfig&lt;/code&gt; and &lt;code&gt;libfontconfig1&lt;/code&gt; are installed. &lt;code&gt;apt-get install fontconfig libfontconfig1&lt;/code&gt; on Ubuntu.&lt;/li&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://github.com/lay295/TwitchDownloader/releases/&#34;&gt;Releases&lt;/a&gt; and download the latest binary for Linux, grab the &lt;a href=&#34;https://aur.archlinux.org/packages/twitch-downloader-bin/&#34;&gt;AUR Package&lt;/a&gt; for Arch Linux, or &lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/#building-from-source&#34;&gt;build from source&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Extract &lt;code&gt;TwitchDownloaderCLI&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Browse to where you extracted the file and give it executable rights in the terminal:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo chmod +x TwitchDownloaderCLI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;a) If you do not have ffmpeg, you should install it via your distro package manager, however you can also get it as a standalone file from &lt;a href=&#34;https://ffmpeg.org/download.html&#34;&gt;ffmpeg.org&lt;/a&gt; or by using TwitchDownloaderCLI:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;./TwitchDownloaderCLI ffmpeg --download&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;b) If downloaded as a standalone file, you must also give it executable rights with:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo chmod +x ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;You can now start using the downloader, for example:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;./TwitchDownloaderCLI videodownload --id &amp;lt;vod-id-here&amp;gt; -o out.mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;MacOS – Getting started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://github.com/lay295/TwitchDownloader/releases/&#34;&gt;Releases&lt;/a&gt; and download the latest binary for MacOS or &lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/#building-from-source&#34;&gt;build from source&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Extract &lt;code&gt;TwitchDownloaderCLI&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Browse to where you extracted the file and give it executable rights in the terminal:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;chmod +x TwitchDownloaderCLI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;a) If you do not have ffmpeg, you can install it via &lt;a href=&#34;https://brew.sh/&#34;&gt;Homebrew package manager&lt;/a&gt;, or you can get it as a standalone file from &lt;a href=&#34;https://ffmpeg.org/download.html&#34;&gt;ffmpeg.org&lt;/a&gt; or by using TwitchDownloaderCLI:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;./TwitchDownloaderCLI ffmpeg --download&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;b) If downloaded as a standalone file, you must also give it executable rights with:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;chmod +x ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;You can now start using the downloader, for example:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;./TwitchDownloaderCLI videodownload --id &amp;lt;vod-id-here&amp;gt; -o out.mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Building from source&lt;/h1&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dotnet.microsoft.com/en-us/download/dotnet/6.0&#34;&gt;.NET 6.0.x SDK&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build Instructions&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the repository:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/lay295/TwitchDownloader.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Navigate to the solution folder:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd TwitchDownloader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Restore the solution:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet restore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;a) Build the GUI:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet publish TwitchDownloaderWPF -p:PublishProfile=Windows -p:DebugType=None -p:DebugSymbols=false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;b) Build the CLI:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet publish TwitchDownloaderCLI -p:PublishProfile=&amp;lt;Profile&amp;gt; -p:DebugType=None -p:DebugSymbols=false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Applicable Profiles: &lt;code&gt;Windows&lt;/code&gt;, &lt;code&gt;Linux&lt;/code&gt;, &lt;code&gt;LinuxAlpine&lt;/code&gt;, &lt;code&gt;LinuxArm&lt;/code&gt;, &lt;code&gt;MacOS&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;a) Navigate to the GUI build folder:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd TwitchDownloaderWPF/bin/Release/net6.0-windows/publish/win-x64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;b) Navigate to the CLI build folder:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd TwitchDownloaderCLI/bin/Release/net6.0/publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lay295/TwitchDownloader/master/LICENSE.txt&#34;&gt;MIT&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/googlefonts/noto-emoji&#34;&gt;Noto Color Emoji&lt;/a&gt; © Google and contributors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/twitter/twemoji&#34;&gt;Twemoji&lt;/a&gt; © Twitter and contributors.&lt;/p&gt;</summary>
  </entry>
</feed>