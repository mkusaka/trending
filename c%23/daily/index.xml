<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-18T01:31:47Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>StephenCleary/StructuredConcurrency</title>
    <updated>2023-04-18T01:31:47Z</updated>
    <id>tag:github.com,2023-04-18:/StephenCleary/StructuredConcurrency</id>
    <link href="https://github.com/StephenCleary/StructuredConcurrency" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Structured concurrency support for C#&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/StephenCleary/StructuredConcurrency/master/src/icon.png&#34; alt=&#34;Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Structured Concurrency &lt;a href=&#34;https://github.com/StephenCleary/StructuredConcurrency/actions?query=workflow%3ABuild&#34;&gt;&lt;img src=&#34;https://github.com/StephenCleary/StructuredConcurrency/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/StephenCleary/StructuredConcurrency&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/StephenCleary/StructuredConcurrency/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Nito.StructuredConcurrency&#34;&gt;&lt;img src=&#34;https://badge.fury.io/nu/Nito.StructuredConcurrency.svg?sanitize=true&#34; alt=&#34;NuGet version&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Structured Concurrency for C#.&lt;/p&gt; &#xA;&lt;h2&gt;Task Groups&lt;/h2&gt; &#xA;&lt;p&gt;A task group provides a scope in which work is done. At the end of that scope, the task group (asynchronously) waits for all of its work to complete.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var groupTask = TaskGroup.RunGroupAsync(default, group =&amp;gt;&#xA;{&#xA;    group.Run(async token =&amp;gt; await Task.Delay(TimeSpan.FromSeconds(1), token));&#xA;    group.Run(async token =&amp;gt; await Task.Delay(TimeSpan.FromSeconds(2), token));&#xA;});&#xA;await groupTask; // Completes after 2 seconds.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;TaskGroup&lt;/code&gt; is started with &lt;code&gt;TaskGroup.RunGroupAsync&lt;/code&gt;. The delegate passed to &lt;code&gt;RunGroupAsync&lt;/code&gt; is the first work item; it can do its own work and/or add other work items to that same group. When all the work items have completed, then the group scope closes, and the task returned from &lt;code&gt;RunGroupAsync&lt;/code&gt; completes.&lt;/p&gt; &#xA;&lt;p&gt;Work may be added to a task group at any time by calling &lt;code&gt;Run&lt;/code&gt;, as long as the scope has not completed. Conceptually, the task group scope ends with a kind of &lt;code&gt;Task.WhenAll&lt;/code&gt;, but with the important difference that more work may be added after the disposal begins. As long as the work is added before all other work completes, the task group will &#34;extend&#34; its logical &lt;code&gt;WhenAll&lt;/code&gt; to include the additional work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var groupTask = TaskGroup.RunGroupAsync(default, group =&amp;gt;&#xA;{&#xA;    // Any group work can kick off other group work.&#xA;    group.Run(async token =&amp;gt;&#xA;    {&#xA;        for (int i = 0; i != 3; ++i)&#xA;        {&#xA;            await Task.Delay(TimeSpan.FromSeconds(1), token));&#xA;            group.Run(async token =&amp;gt; await Task.Delay(TimeSpan.FromSeconds(1), token));&#xA;        }&#xA;    });&#xA;});&#xA;await groupTask; // Completes after 4 seconds.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exceptions&lt;/h3&gt; &#xA;&lt;p&gt;If any work throws an exception (except &lt;code&gt;OperationCanceledException&lt;/code&gt;), then that work is considered &#34;faulted&#34;. The task group immediately enters a canceled state (see below), cancelling all of its other work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var groupTask = TaskGroup.RunGroupAsync(default, group =&amp;gt;&#xA;{&#xA;    group.Run(async token =&amp;gt;&#xA;    {&#xA;        await Task.Delay(TimeSpan.FromSeconds(1), token);&#xA;        throw new Exception(&#34;oops&#34;);&#xA;    });&#xA;&#xA;    // This task would normally take 2 seconds, but is canceled after 1 second.&#xA;    group.Run(async token =&amp;gt; await Task.Delay(TimeSpan.FromSeconds(2), token));&#xA;});&#xA;await groupTask; // Completes after 1 second and raises Exception(&#34;oops&#34;).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At the end of the task group scope, the task group will still wait for all of its work to complete. Once all of the work has completed, then the task group task will re-raise the first exception from its faulted work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var groupTask = TaskGroup.RunGroupAsync(default, group =&amp;gt;&#xA;{&#xA;    group.Run(async token =&amp;gt;&#xA;    {&#xA;        await Task.Delay(TimeSpan.FromSeconds(1), token);&#xA;        throw new Exception(&#34;oops&#34;);&#xA;    });&#xA;&#xA;    // This task takes 2 seconds since it ignores cancellation.&#xA;    group.Run(async _ =&amp;gt; await Task.Delay(TimeSpan.FromSeconds(2)));&#xA;});&#xA;await groupTask; // Completes after 2 seconds and raises Exception(&#34;oops&#34;).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cancellation&lt;/h3&gt; &#xA;&lt;p&gt;Task groups always ignore any work that is cancelled (i.e., task groups catch and ignore &lt;code&gt;OperationCanceledException&lt;/code&gt;). Task groups provide &lt;code&gt;CancellationToken&lt;/code&gt; parameters to all of their work, and it is the work&#39;s responsibility to respond to that cancellation. The task group will cancel itself if any work item faults (with an exception other than &lt;code&gt;OperationCanceledException&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Task groups also take a &lt;code&gt;CancellationToken&lt;/code&gt; as parameter to the static &lt;code&gt;RunGroupAsync&lt;/code&gt; methods to enable cancellation from &#34;upstream&#34;; e.g., if the application is shutting down. Task groups can also be cancelled manually (via &lt;code&gt;TaskGroup.CancellationTokenSource&lt;/code&gt;) if the program logic wishes to stop the task group for any reason.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var groupTask = TaskGroup.RunGroupAsync(default, group =&amp;gt;&#xA;{&#xA;    // Apply a timeout for all work sent to this group.&#xA;    group.CancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(2));&#xA;&#xA;    group.Run(async token =&amp;gt; await Task.Delay(TimeSpan.FromSeconds(1), token));&#xA;    group.Run(async token =&amp;gt; await Task.Delay(Timeout.InfiniteTimeSpan, token));&#xA;});&#xA;await groupTask; // Completes after 2 seconds.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;A task group can own resources. These resources will be disposed by the task group after all its work is done.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var groupTask = TaskGroup.RunGroupAsync(default, async group =&amp;gt;&#xA;{&#xA;    await group.AddResourceAsync(myDisposableResource);&#xA;&#xA;    group.Run(async token =&amp;gt; await myDisposableResource.DoWorkAsync(token));&#xA;});&#xA;await groupTask; // First, waits for all tasks to complete; then, disposes myDisposableResource.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All exceptions raised by disposal of any resource are ignored.&lt;/p&gt; &#xA;&lt;h3&gt;Races&lt;/h3&gt; &#xA;&lt;p&gt;The usual pattern for task groups is to cancel on failure and ignore success. Sometimes, we want to &#34;race&#34; several work items to produce a result; in this case, we want the opposite: ignore failures and cancel on success.&lt;/p&gt; &#xA;&lt;p&gt;The usual pattern is to create a race child group via &lt;code&gt;TaskGroup.RaceGroupAsync&lt;/code&gt;. This creates a separate group along with a race result that are used for races. To race work, call &lt;code&gt;Race&lt;/code&gt; instead of &lt;code&gt;Run&lt;/code&gt;. The first successful &lt;code&gt;Race&lt;/code&gt; will cancel all the others. Once all races have completed (i.e., the race child group&#39;s scope is complete), then the results of the race are returned from &lt;code&gt;RaceGroupAsync&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var groupTask = TaskGroup.RaceGroupAsync&amp;lt;int&amp;gt;(default, group =&amp;gt;&#xA;{&#xA;    group.Race(async token =&amp;gt; { await Task.Delay(TimeSpan.FromSeconds(1), token); return 1; });&#xA;    group.Race(async token =&amp;gt; { await Task.Delay(TimeSpan.FromSeconds(2), token); return 2; });&#xA;    group.Race(async token =&amp;gt; { await Task.Delay(TimeSpan.FromSeconds(3), token); return 3; });&#xA;});&#xA;var result = await groupTask; // Returns `1` after 1 second.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Successful results that lose the race are treated as resources, but are disposed immediately rather than scoped to the race child group.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SebLague/Ray-Tracing</title>
    <updated>2023-04-18T01:31:47Z</updated>
    <id>tag:github.com,2023-04-18:/SebLague/Ray-Tracing</id>
    <link href="https://github.com/SebLague/Ray-Tracing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ray-Tracing&lt;/h1&gt; &#xA;&lt;p&gt;A very simple (and slow) ray tracer, coded in C# and HLSL in the Unity engine.&lt;br&gt; You can watch a video about the project &lt;a href=&#34;https://youtu.be/Qz0KTGYJtUk&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/Qz0KTGYJtUk&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SebLague/Images/master/Ray%20Tracing.jpg&#34; alt=&#34;Ray Tracing Video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://raytracing.github.io&#34;&gt;Ray Tracing in One Weekend&lt;/a&gt; and &lt;a href=&#34;https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/&#34;&gt;Casual Shadertoy Path Tracing&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>