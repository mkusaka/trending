<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-04T01:35:16Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OneXDeveloper/MapAssist</title>
    <updated>2022-06-04T01:35:16Z</updated>
    <id>tag:github.com,2022-06-04:/OneXDeveloper/MapAssist</id>
    <link href="https://github.com/OneXDeveloper/MapAssist" rel="alternate"></link>
    <summary type="html">&lt;p&gt;D2R MapHack&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://mapassist.github.io&#34;&gt;MapAssist&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Reveals the D2R map as a game overlay, includes: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Shows monsters, monster immunities, and distinguish different monster types with different colors&lt;/li&gt; &#xA;   &lt;li&gt;Lines to next area and other points of interest &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Including the correct tomb in Canyon of Magi and the right direction to Summoner in Arcane Sanctuary&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Waypoints&lt;/li&gt; &#xA;   &lt;li&gt;Party players, neutral players, hostile players, corpses&lt;/li&gt; &#xA;   &lt;li&gt;Player portals and red portal&lt;/li&gt; &#xA;   &lt;li&gt;Super chests&lt;/li&gt; &#xA;   &lt;li&gt;Shrines&lt;/li&gt; &#xA;   &lt;li&gt;Weapon and armor racks&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Built-in item filter with map icons and loot drop alerts&lt;/li&gt; &#xA; &lt;li&gt;Naturally boosts your magic find (strong anecdotal evidence)&lt;/li&gt; &#xA; &lt;li&gt;+300% chance to find Gem shrines (strong anecdotal evidence)&lt;/li&gt; &#xA; &lt;li&gt;Highly configurable with a built-in GUI&lt;/li&gt; &#xA; &lt;li&gt;Works online (user accepts all risks) and offline&lt;/li&gt; &#xA; &lt;li&gt;Multi-launcher compatible&lt;/li&gt; &#xA; &lt;li&gt;Active development (new features added regularly)&lt;/li&gt; &#xA; &lt;li&gt;Free technical support &lt;a href=&#34;https://discord.gg/uBftrtBE4j&#34;&gt;on our Discord channel&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Images&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1294559/151440355-6cfd64d5-94e0-4942-b144-9224e16d15c6.png&#34; alt=&#34;MapAssist&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/1294559/151440400-4c887af4-ca89-46cf-893b-9cdc8a1fcb5b.png&#34; alt=&#34;MapAssist&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/1294559/151440395-baecf57f-d7bd-4cbe-b78f-201ce3e0f464.png&#34; alt=&#34;MapAssist&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/1294559/151440410-452eada6-da24-458e-8c32-d86e18204642.png&#34; alt=&#34;MapAssist&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/1294559/151440415-fe92d5b1-068d-4734-b355-f47cfa9931df.png&#34; alt=&#34;MapAssist&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Disclosures&lt;/h2&gt; &#xA;&lt;p&gt;THE &#39;MapAssist&#39; TOOL AND CONTENTS THEREIN WERE INTENDED FOR INFORMATIONAL AND LEARNING PURPOSES ONLY.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to contribute a pull request with new features or fixes, the code is under GPL so make sure to please follow the license.&lt;/p&gt; &#xA;&lt;p&gt;The software is free and open source licensed under the GPLv3. You may download a copy of the source code and follow the instructions to build the software for yourself. In certain instances there may be direct links to precompiled versions of the software, you are free to use these as well. The best place to start looking is inside of the repository.&lt;/p&gt; &#xA;&lt;p&gt;Use at your own risk! The MapAssist team makes no expression of warranty or claim about the safety in regards to the usage of this program. We have done our best to provide an open project for learning and educational purposes only. The contents of the official source code are known to not contain any malicious or disingenuous code. If you have additional information in regards to the safety of this program please do not hesitate to raise a concern.&lt;/p&gt; &#xA;&lt;p&gt;All software projects are subject to their own licensing, and copyrights. All other product names and any registered and unregistered trademarks mentioned are used for identification purposes only and remain the exclusive property of their respective owners.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>migueldeicaza/gui.cs</title>
    <updated>2022-06-04T01:35:16Z</updated>
    <id>tag:github.com,2022-06-04:/migueldeicaza/gui.cs</id>
    <link href="https://github.com/migueldeicaza/gui.cs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Console-based user interface toolkit for .NET applications.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/migueldeicaza/gui.cs/workflows/.NET%20Core/badge.svg?branch=master&#34; alt=&#34;.NET Core&#34;&gt; &lt;img src=&#34;https://github.com/migueldeicaza/gui.cs/workflows/Code%20scanning%20-%20action/badge.svg?sanitize=true&#34; alt=&#34;Code scanning - action&#34;&gt; &lt;a href=&#34;https://www.nuget.org/packages/Terminal.Gui&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Terminal.Gui.svg?sanitize=true&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/migueldeicaza/90ef67a684cb71db1817921a970f8d27/raw/code-coverage.json&#34; alt=&#34;Code Coverage&#34;&gt; &lt;a href=&#34;https://www.nuget.org/packages/Terminal.Gui&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/Terminal.Gui&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/migueldeicaza/gui.cs/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/migueldeicaza/gui.cs.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/issues/migueldeicaza/gui.cs/bug&#34; alt=&#34;Bugs&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Terminal.Gui - Cross Platform Terminal UI toolkit for .NET&lt;/h1&gt; &#xA;&lt;p&gt;A toolkit for building rich console apps for .NET, .NET Core, and Mono that works on Windows, the Mac, and Linux/Unix.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/migueldeicaza/gui.cs/master/docfx/sample.gif&#34; alt=&#34;Sample app&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Controls and Views&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Terminal.Gui&lt;/em&gt; provides a rich set of views and controls for building terminal user interfaces:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Button.html&#34;&gt;Button&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.CheckBox.html&#34;&gt;CheckBox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ColorPicker.html&#34;&gt;ColorPicker&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ComboBox.html&#34;&gt;ComboBox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Dialog.html&#34;&gt;Dialog&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.OpenDialog.html&#34;&gt;OpenDialog&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.SaveDialog.html&#34;&gt;SaveDialog&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.FrameView.html&#34;&gt;FrameView&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.GraphView.html&#34;&gt;GraphView&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.HexView.html&#34;&gt;Hex viewer/editor&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Label.html&#34;&gt;Label&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ListView.html&#34;&gt;ListView&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.MenuBar.html&#34;&gt;Menu&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.MessageBox.html&#34;&gt;MessageBox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ProgressBar.html&#34;&gt;ProgressBar&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.RadioGroup.html&#34;&gt;Radio buttons&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TableView.html&#34;&gt;TableView&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TimeField.html&#34;&gt;Time &amp;amp; Date Fields&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TextField.html&#34;&gt;TextField&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TextValidateField.html&#34;&gt;TextValidateField&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TextView.html&#34;&gt;TextView (Text Editor)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TreeView.html&#34;&gt;TreeView&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ScrollView.html&#34;&gt;ScrollView&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ScrollBarView.html&#34;&gt;ScrollBarView&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.StatusBar.html&#34;&gt;StatusBar&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Window.html&#34;&gt;Window&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cross Platform&lt;/strong&gt; - Windows, Mac, and Linux. Terminal drivers for Curses, &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/issues/27&#34;&gt;Windows Console&lt;/a&gt;, and the .NET Console mean apps will work well on both color and monochrome terminals.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Keyboard and Mouse Input&lt;/strong&gt; - Both keyboard and mouse input are supported, including support for drag &amp;amp; drop.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/articles/overview.html#layout&#34;&gt;Flexible Layout&lt;/a&gt;&lt;/strong&gt; - Supports both &lt;em&gt;Absolute layout&lt;/em&gt; and an innovative &lt;em&gt;Computed Layout&lt;/em&gt; system. &lt;em&gt;Computed Layout&lt;/em&gt; makes it easy to layout controls relative to each other and enables dynamic terminal UIs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Clipboard support&lt;/strong&gt; - Cut, Copy, and Paste of text provided through the &lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Clipboard.html&#34;&gt;&lt;code&gt;Clipboard&lt;/code&gt;&lt;/a&gt; class.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.View.html&#34;&gt;Arbitrary Views&lt;/a&gt;&lt;/strong&gt; - All visible UI elements are subclasses of the &lt;code&gt;View&lt;/code&gt; class, and these in turn can contain an arbitrary number of sub-views.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Advanced App Features&lt;/strong&gt; - The &lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.MainLoop.html&#34;&gt;Mainloop&lt;/a&gt; supports processing events, idle handlers, timers, and monitoring file descriptors. Most classes are safe for threading.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Reactive Extensions&lt;/strong&gt; - Use &lt;a href=&#34;https://github.com/dotnet/reactive&#34;&gt;reactive extensions&lt;/a&gt; and benefit from increased code readability, and the ability to apply the MVVM pattern and &lt;a href=&#34;https://www.reactiveui.net/&#34;&gt;ReactiveUI&lt;/a&gt; data bindings. See the &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/tree/master/ReactiveExample&#34;&gt;source code&lt;/a&gt; of a sample app in order to learn how to achieve this.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Keyboard Input Handling&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Terminal.Gui&lt;/strong&gt; respects common Linux, Mac, and Windows keyboard idioms. For example, clipboard operations use the familiar &lt;code&gt;Control/Command-C, X, V&lt;/code&gt; model. &lt;code&gt;CTRL-Q&lt;/code&gt; is used for exiting views (and apps).&lt;/p&gt; &#xA;&lt;p&gt;The input handling of &lt;strong&gt;Terminal.Gui&lt;/strong&gt; is similar in some ways to Emacs and the Midnight Commander, so you can expect some of the special key combinations to be active.&lt;/p&gt; &#xA;&lt;p&gt;The key &lt;code&gt;ESC&lt;/code&gt; can act as an Alt modifier (or Meta in Emacs parlance), to allow input on terminals that do not have an alt key. So to produce the sequence &lt;code&gt;Alt-F&lt;/code&gt;, you can press either &lt;code&gt;Alt-F&lt;/code&gt;, or &lt;code&gt;ESC&lt;/code&gt; followed by the key &lt;code&gt;F&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To enter the key &lt;code&gt;ESC&lt;/code&gt;, you can either press &lt;code&gt;ESC&lt;/code&gt; and wait 100 milliseconds, or you can press &lt;code&gt;ESC&lt;/code&gt; twice.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ESC-0&lt;/code&gt;, and &lt;code&gt;ESC-1&lt;/code&gt; through &lt;code&gt;ESC-9&lt;/code&gt; have a special meaning, they map to &lt;code&gt;F10&lt;/code&gt;, and &lt;code&gt;F1&lt;/code&gt; to &lt;code&gt;F9&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;p&gt;Apps can change key bindings using the &lt;code&gt;AddKeyBinding&lt;/code&gt; API.&lt;/p&gt; &#xA;&lt;h3&gt;Driver Model&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Terminal.Gui&lt;/strong&gt; has support for &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/raw/master/Terminal.Gui/ConsoleDrivers/CursesDriver/CursesDriver.cs&#34;&gt;ncurses&lt;/a&gt;, &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/raw/master/Terminal.Gui/ConsoleDrivers/NetDriver.cs&#34;&gt;&lt;code&gt;System.Console&lt;/code&gt;&lt;/a&gt;, and a full &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/raw/master/Terminal.Gui/ConsoleDrivers/WindowsDriver.cs&#34;&gt;Win32 Console&lt;/a&gt; front-end.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ncurses&lt;/code&gt; is used on Mac/Linux/Unix with color support based on what your library is compiled with; the Windows driver supports full color and mouse, and an easy-to-debug &lt;code&gt;System.Console&lt;/code&gt; can be used on Windows and Unix, but lacks mouse support.&lt;/p&gt; &#xA;&lt;p&gt;You can force the use of &lt;code&gt;System.Console&lt;/code&gt; on Unix as well; see &lt;code&gt;Core.cs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Showcase &amp;amp; Examples&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/tree/master/UICatalog&#34;&gt;UI Catalog&lt;/a&gt;&lt;/strong&gt; - The UI Catalog project provides an easy to use and extend sample illustrating the capabilities of &lt;strong&gt;Terminal.Gui&lt;/strong&gt;. Run &lt;code&gt;dotnet run --project UICatalog&lt;/code&gt; to run the UI Catalog.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/tree/master/ReactiveExample&#34;&gt;Reactive Example&lt;/a&gt;&lt;/strong&gt; - A sample app that shows how to use &lt;code&gt;System.Reactive&lt;/code&gt; and &lt;code&gt;ReactiveUI&lt;/code&gt; with &lt;code&gt;Terminal.Gui&lt;/code&gt;. The app uses the MVVM architecture that may seem familiar to folks coming from WPF, Xamarin Forms, UWP, Avalonia, or Windows Forms. In this app, we implement the data bindings using ReactiveUI &lt;code&gt;WhenAnyValue&lt;/code&gt; syntax and &lt;a href=&#34;https://github.com/reactiveui/pharmacist&#34;&gt;Pharmacist&lt;/a&gt; — a tool that converts all events in a NuGet package into observable wrappers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/tree/master/Example&#34;&gt;Example (aka &lt;code&gt;demo.cs&lt;/code&gt;)&lt;/a&gt;&lt;/strong&gt; - Run &lt;code&gt;dotnet run&lt;/code&gt; in the &lt;code&gt;Example&lt;/code&gt; directory to run the simple demo.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/tree/master/StandaloneExample&#34;&gt;Standalone Example&lt;/a&gt;&lt;/strong&gt; - A trivial .NET core sample application can be found in the &lt;code&gt;StandaloneExample&lt;/code&gt; directory. Run &lt;code&gt;dotnet run&lt;/code&gt; in directory to test.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/tree/master/FSharpExample&#34;&gt;F# Example&lt;/a&gt;&lt;/strong&gt; - An example showing how to build a Terminal.Gui app using F#.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/PowerShell/GraphicalTools/raw/master/docs/Microsoft.PowerShell.ConsoleGuiTools/Out-ConsoleGridView.md&#34;&gt;PowerShell&#39;s &lt;code&gt;Out-ConsoleGridView&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; - &lt;code&gt;OCGV&lt;/code&gt; sends the output from a command to an interactive table.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/En3Tho/PoshRedisViewer&#34;&gt;PoshRedisViewer&lt;/a&gt;&lt;/strong&gt; - A compact Redis viewer module for PowerShell written in F# and Gui.cs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/articles/overview.html&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/articles/index.html&#34;&gt;Conceptual Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.html&#34;&gt;API Documentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/tree/master/Terminal.Gui&#34;&gt;&lt;code&gt;Terminal.Gui/&lt;/code&gt; README&lt;/a&gt; for an overview of how the library is structured. The &lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/articles/index.html&#34;&gt;Conceptual Documentation&lt;/a&gt; provides insight into core concepts.&lt;/p&gt; &#xA;&lt;h3&gt;Sample Usage&lt;/h3&gt; &#xA;&lt;p&gt;(This code uses C# 9.0 &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9#top-level-statements&#34;&gt;Top-level statements&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Terminal.Gui;&#xA;using NStack;&#xA;&#xA;Application.Init();&#xA;var top = Application.Top;&#xA;&#xA;// Creates the top-level window to show&#xA;var win = new Window(&#34;MyApp&#34;)&#xA;{&#xA;&#x9;X = 0,&#xA;&#x9;Y = 1, // Leave one row for the toplevel menu&#xA;&#xA;&#x9;// By using Dim.Fill(), it will automatically resize without manual intervention&#xA;&#x9;Width = Dim.Fill(),&#xA;&#x9;Height = Dim.Fill()&#xA;};&#xA;&#xA;top.Add(win);&#xA;&#xA;// Creates a menubar, the item &#34;New&#34; has a help menu.&#xA;var menu = new MenuBar(new MenuBarItem[] {&#xA;&#x9;&#x9;&#x9;new MenuBarItem (&#34;_File&#34;, new MenuItem [] {&#xA;&#x9;&#x9;&#x9;&#x9;new MenuItem (&#34;_New&#34;, &#34;Creates new file&#34;, null),&#xA;&#x9;&#x9;&#x9;&#x9;new MenuItem (&#34;_Close&#34;, &#34;&#34;,null),&#xA;&#x9;&#x9;&#x9;&#x9;new MenuItem (&#34;_Quit&#34;, &#34;&#34;, () =&amp;gt; { if (Quit ()) top.Running = false; })&#xA;&#x9;&#x9;&#x9;}),&#xA;&#x9;&#x9;&#x9;new MenuBarItem (&#34;_Edit&#34;, new MenuItem [] {&#xA;&#x9;&#x9;&#x9;&#x9;new MenuItem (&#34;_Copy&#34;, &#34;&#34;, null),&#xA;&#x9;&#x9;&#x9;&#x9;new MenuItem (&#34;C_ut&#34;, &#34;&#34;, null),&#xA;&#x9;&#x9;&#x9;&#x9;new MenuItem (&#34;_Paste&#34;, &#34;&#34;, null)&#xA;&#x9;&#x9;&#x9;})&#xA;&#x9;&#x9;});&#xA;top.Add(menu);&#xA;&#xA;static bool Quit()&#xA;{&#xA;&#x9;var n = MessageBox.Query(50, 7, &#34;Quit Demo&#34;, &#34;Are you sure you want to quit this demo?&#34;, &#34;Yes&#34;, &#34;No&#34;);&#xA;&#x9;return n == 0;&#xA;}&#xA;&#xA;var login = new Label(&#34;Login: &#34;) { X = 3, Y = 2 };&#xA;var password = new Label(&#34;Password: &#34;)&#xA;{&#xA;&#x9;X = Pos.Left(login),&#xA;&#x9;Y = Pos.Top(login) + 1&#xA;};&#xA;var loginText = new TextField(&#34;&#34;)&#xA;{&#xA;&#x9;X = Pos.Right(password),&#xA;&#x9;Y = Pos.Top(login),&#xA;&#x9;Width = 40&#xA;};&#xA;var passText = new TextField(&#34;&#34;)&#xA;{&#xA;&#x9;Secret = true,&#xA;&#x9;X = Pos.Left(loginText),&#xA;&#x9;Y = Pos.Top(password),&#xA;&#x9;Width = Dim.Width(loginText)&#xA;};&#xA;&#xA;// Add some controls, &#xA;win.Add(&#xA;&#x9;// The ones with my favorite layout system, Computed&#xA;&#x9;login, password, loginText, passText,&#xA;&#xA;&#x9;// The ones laid out like an australopithecus, with Absolute positions:&#xA;&#x9;new CheckBox(3, 6, &#34;Remember me&#34;),&#xA;&#x9;new RadioGroup(3, 8, new ustring[] { &#34;_Personal&#34;, &#34;_Company&#34; }, 0),&#xA;&#x9;new Button(3, 14, &#34;Ok&#34;),&#xA;&#x9;new Button(10, 14, &#34;Cancel&#34;),&#xA;&#x9;new Label(3, 18, &#34;Press F9 or ESC plus 9 to activate the menubar&#34;)&#xA;);&#xA;&#xA;Application.Run();&#xA;Application.Shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The example above shows adding views using both styles of layout supported by &lt;strong&gt;Terminal.Gui&lt;/strong&gt;: &lt;strong&gt;Absolute layout&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&#34;https://migueldeicaza.github.io/gui.cs/articles/overview.html#layout&#34;&gt;Computed layout&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can encapsulate the app behavior in a new &lt;code&gt;Window&lt;/code&gt;-derived class, say &lt;code&gt;App.cs&lt;/code&gt; containing the code above, and simplify your &lt;code&gt;Main&lt;/code&gt; method to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Terminal.Gui;&#xA;&#xA;class Demo {&#xA;&#x9;static void Main ()&#xA;&#x9;{&#xA;&#x9;&#x9;Application.Run&amp;lt;App&amp;gt; ();&#xA;&#x9;&#x9;Application.Shutdown ();&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;Use NuGet to install the &lt;code&gt;Terminal.Gui&lt;/code&gt; NuGet package: &lt;a href=&#34;https://www.nuget.org/packages/Terminal.Gui&#34;&gt;https://www.nuget.org/packages/Terminal.Gui&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Installation in .NET Core Projects&lt;/h3&gt; &#xA;&lt;p&gt;To install Terminal.Gui into a .NET Core project, use the &lt;code&gt;dotnet&lt;/code&gt; CLI tool with following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet add package Terminal.Gui&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running and Building&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows, Mac, and Linux - Build and run using the .NET SDK command line tools (&lt;code&gt;dotnet build&lt;/code&gt; in the root directory). Run &lt;code&gt;UICatalog&lt;/code&gt; with &lt;code&gt;dotnet run --project UICatalog&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Windows - Open &lt;code&gt;Terminal.Gui.sln&lt;/code&gt; with Visual Studio 2019.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Building in &lt;code&gt;Release&lt;/code&gt; requires the &lt;a href=&#34;https://git-scm.com/&#34;&gt;git command line tool&lt;/a&gt; (a dependency of the &lt;a href=&#34;https://github.com/adamralph/minver#can-i-disable-minver&#34;&gt;MinVer&lt;/a&gt; build tool)&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Debates on architecture and design can be found in Issues tagged with &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/issues?q=is%3Aopen+is%3Aissue+label%3Adesign&#34;&gt;design&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;This is an updated version of &lt;a href=&#34;http://tirania.org/blog/archive/2007/Apr-16.html&#34;&gt;gui.cs&lt;/a&gt; that Miguel wrote for &lt;a href=&#34;https://github.com/mono/mono-curses&#34;&gt;mono-curses&lt;/a&gt; in 2007.&lt;/p&gt; &#xA;&lt;p&gt;The original &lt;strong&gt;gui.cs&lt;/strong&gt; was a UI toolkit in a single file and tied to curses. This version tries to be console-agnostic and instead of having a container/widget model, only uses Views (which can contain subviews) and changes the rendering model to rely on damage regions instead of burdening each view with the details.&lt;/p&gt; &#xA;&lt;p&gt;A presentation of this was part of the &lt;a href=&#34;https://channel9.msdn.com/Events/dotnetConf/2018/S313&#34;&gt;Retro.NET&lt;/a&gt; talk at .NET Conf 2018 &lt;a href=&#34;https://tirania.org/Retro.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Release history can be found in the &lt;a href=&#34;https://github.com/migueldeicaza/gui.cs/raw/master/Terminal.Gui/Terminal.Gui.csproj&#34;&gt;Terminal.Gui.csproj&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;In 2019, 2020, and 2021, Charlie Kindel (&lt;a href=&#34;https://github.com/tig&#34;&gt;https://github.com/tig&lt;/a&gt;), @BDisp (&lt;a href=&#34;https://github.com/BDisp&#34;&gt;https://github.com/BDisp&lt;/a&gt;), and Thomas Nind (&lt;a href=&#34;https://github.com/tznind&#34;&gt;https://github.com/tznind&lt;/a&gt;) vastly extended, improved, polished and fixed gui.cs to what it is today.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mxgmn/MarkovJunior</title>
    <updated>2022-06-04T01:35:16Z</updated>
    <id>tag:github.com,2022-06-04:/mxgmn/MarkovJunior</id>
    <link href="https://github.com/mxgmn/MarkovJunior" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Probabilistic PL based on pattern matching and constraint propagation, 148 examples&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MarkovJunior&lt;/h1&gt; &#xA;&lt;p&gt;MarkovJunior is a probabilistic programming language where programs are combinations of rewrite rules and inference is performed via constraint propagation. MarkovJunior is named after mathematician &lt;a href=&#34;https://en.wikipedia.org/wiki/Andrey_Markov,_Jr.&#34;&gt;Andrey Andreyevich Markov&lt;/a&gt;, who defined and studied what is now called &lt;a href=&#34;https://en.wikipedia.org/wiki/Markov_algorithm&#34;&gt;Markov algorithms&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/top-iso.gif&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/top-mv.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;In its basic form, a MarkovJunior program is an ordered list of rewrite rules. For example, &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/MazeBacktracker.xml&#34;&gt;MazeBacktracker&lt;/a&gt; (animation on the left below) is a list of 2 rewrite rules:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;RBB=GGR&lt;/code&gt; or &#34;replace red-black-black with green-green-red&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RGG=WWR&lt;/code&gt; or &#34;replace red-green-green with white-white-red&#34;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;On each execution step MJ interpreter finds the first rule in the list that has a match on the grid, finds all matches for that rule and applies that rule for a random match. In the &lt;a href=&#34;https://en.wikipedia.org/wiki/Maze_generation_algorithm#Depth-first_search&#34;&gt;maze backtracker&lt;/a&gt; example, interpreter first applies a bunch of &lt;code&gt;RBB=GGR&lt;/code&gt; rules. But eventually the green self-avoiding walk gets stuck. At this point the first rule has no matches, so interpreter applies the second rule &lt;code&gt;RGG=WWR&lt;/code&gt; until the walk gets unstuck. Then it can apply the first rule again, and so on. Interpreter stops when there are no matches for any rule.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/MazeBacktracker.gif&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/multisokoban.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Probabilistic inference in MarkovJunior allows to impose constraints on the future state, and generate only those runs that lead to the constrained future. For example, inference in Sokoban rules &lt;code&gt;{RWB=BRW RB=BR}&lt;/code&gt; makes a group of (red) agents organize (white) crates into specified shapes.&lt;/p&gt; &#xA;&lt;p&gt;Using these ideas, we construct &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/&#34;&gt;many probabilistic generators&lt;/a&gt; of dungeons, architecture, puzzles and fun simulations.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/top-1764.png&#34;&gt;&lt;/a&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/top-882.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Higher resolution screenshots and more seeds: &lt;a href=&#34;https://github.com/mxgmn/Blog/raw/master/ModernHouse.md&#34;&gt;ModernHouse&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/Blog/raw/master/SeaVilla.md&#34;&gt;SeaVilla&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/Blog/raw/master/Apartemazements.md&#34;&gt;Apartemazements&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/Blog/raw/master/CarmaTower.md&#34;&gt;CarmaTower&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/Blog/raw/master/Escheresque.md&#34;&gt;Escheresque&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/Blog/raw/master/PillarsOfEternity.md&#34;&gt;PillarsOfEternity&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/Blog/raw/master/RandomSurface.md&#34;&gt;Surface&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/ExUtumno/status/895688856304992256&#34;&gt;Knots&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Markov algorithms&lt;/h2&gt; &#xA;&lt;p&gt;A Markov algorithm over an alphabet &lt;code&gt;A&lt;/code&gt; is an ordered list of rules. Each rule is a string of the form &lt;code&gt;x=y&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are words in &lt;code&gt;A&lt;/code&gt;, and some rules may be marked as halt rules. Application of a Markov algorithm to a word &lt;code&gt;w&lt;/code&gt; proceeds as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Find the first rule &lt;code&gt;x=y&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a substring of &lt;code&gt;w&lt;/code&gt;. If there are no such rules, then halt.&lt;/li&gt; &#xA; &lt;li&gt;Replace the leftmost &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;w&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If the found rule was a halt rule, then halt. Otherwise, go to step 1.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example, consider this Markov algorithm in the alphabet &lt;code&gt;{0, 1, x}&lt;/code&gt; (ε is the empty word):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1=0x&#xA;x0=0xx&#xA;0=ε&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we apply it to the string &lt;code&gt;110&lt;/code&gt; we get this sequence of strings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;110 -&amp;gt; 0x10 -&amp;gt; 0x0x0 -&amp;gt; 00xxx0 -&amp;gt; 00xx0xx -&amp;gt; 00x0xxxx -&amp;gt; 000xxxxxx -&amp;gt; 00xxxxxx -&amp;gt; 0xxxxxx -&amp;gt; xxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In general, this algorithm converts a binary representation of a number into its unary representation.&lt;/p&gt; &#xA;&lt;p&gt;Markov&#39;s student &lt;a href=&#34;https://lv.wikipedia.org/wiki/Vilnis_Detlovs&#34;&gt;Vilnis Detlovs&lt;/a&gt; &lt;a href=&#34;http://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;amp;jrnid=tm&amp;amp;paperid=1293&#34;&gt;proved&lt;/a&gt; that for any Turing machine there exists a Markov algorithm that computes the same function. In comparison, grammars are unordered sets of rewrite rules and L-systems are rewrite rules that are applied in parallel. For more interesting examples of Markov algorithms check &lt;a href=&#34;http://www.mathnet.ru/links/1543dd6e347b444e6f3e108fafaf9f2a/tm1178.pdf&#34;&gt;Markov&#39;s book&lt;/a&gt; or see the greatest common divisor example in the &lt;a href=&#34;https://github.com/mxgmn/test#comments&#34;&gt;comment section&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Markov_algorithm#Description&#34;&gt;multiplication example&lt;/a&gt; on Wikipedia.&lt;/p&gt; &#xA;&lt;p&gt;How would one generalize Markov algorithms to multiple dimensions? First, in multiple dimensions there are no natural ways to insert a string into another string, so the lefts and rights of our rewrite rules should have the same size. Second, there are no natural ways to choose &lt;em&gt;the leftmost&lt;/em&gt; match. Possible options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Choose a random match. This is what MJ&#39;s &lt;code&gt;(exists)&lt;/code&gt; nodes do.&lt;/li&gt; &#xA; &lt;li&gt;Choose all matches. There is a problem with this option however because different matches can overlap and have conflicts. Possible solutions are: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Greedily choose a maximal subset of non-conflicting matches. This is what MJ&#39;s &lt;code&gt;{forall}&lt;/code&gt; nodes do.&lt;/li&gt; &#xA;   &lt;li&gt;Consider all matches in superposition. That is, instead of separate values, keep waves in each grid cell - boolean vectors that tell which spacetime patterns are forbidden and which are not. And this is how MJ performs inference.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We lose Turing completeness because our new procedure is not deterministic, but practice shows that this formalism still allows to describe a huge range of interesting random processes.&lt;/p&gt; &#xA;&lt;h2&gt;Rewrite rules&lt;/h2&gt; &#xA;&lt;p&gt;The simplest MarkovJunior program is probably &lt;code&gt;(B=W)&lt;/code&gt;. It contains just a single rule &lt;code&gt;B=W&lt;/code&gt;. On each turn, this program converts a random black square into a white square.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Basic.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/Basic.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Growth.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/Growth.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/MazeGrowth.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/MazeGrowth.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/MazeGrowth.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/MazeGrowth.png&#34;&gt;&lt;/a&gt;&lt;br&gt; (B=W) | (WB=WW) | (WBB=WAW) | (WBB=WAW) &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Growth.xml&#34;&gt;Growth&lt;/a&gt; model &lt;code&gt;(WB=WW)&lt;/code&gt; is more interesting. On each turn it replaces a black-white pair of adjacent cells &lt;code&gt;BW&lt;/code&gt; with a white-white pair &lt;code&gt;WW&lt;/code&gt;. In other words, on each turn it picks a random black cell adjacent to some white cell and color it into white. This model is almost identical to the &lt;a href=&#34;http://digitalassets.lib.berkeley.edu/math/ucb/text/math_s4_v4_article-15.pdf&#34;&gt;Eden growth model&lt;/a&gt;: on each turn both models choose among the same set of black cells. They differ only in probability distributions: a uniform distribution over black cells adjacent to white cells is not the same as a uniform distribution over pairs of adjacent black and white cells.&lt;/p&gt; &#xA;&lt;p&gt;Model &lt;code&gt;(WBB=WAW)&lt;/code&gt; generates a maze, with a single line of code! Compare it with an &lt;a href=&#34;https://bl.ocks.org/mbostock/70a28267db0354261476&#34;&gt;implementation&lt;/a&gt; in a conventional language. Any MarkovJunior model can be run in any number of dimensions without changes. On the right you can see the end result of &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/MazeGrowth.xml&#34;&gt;MazeGrowth&lt;/a&gt; in 3d, rendered in &lt;a href=&#34;https://ephtracy.github.io/&#34;&gt;MagicaVoxel&lt;/a&gt;. By default, we use &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/resources/palette.xml&#34;&gt;PICO-8 palette&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/palette.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Model &lt;code&gt;(RBB=WWR)&lt;/code&gt; is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Self-avoiding_walk&#34;&gt;self-avoiding random walk&lt;/a&gt;. Note that self-avoiding walks in 3d are longer on average than in 2d. In general, comparing the behaviors of similar random processes in different dimensions is a fascinating topic. A &lt;a href=&#34;https://sites.math.washington.edu/~morrow/336_19/papers19/Legrand.pdf&#34;&gt;classic result&lt;/a&gt; of George Pólya says that a random walk in 2d returns to its initial position with probability one, while in 3d this is no longer the case.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/RegularSAW.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/RegularSAW.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/LoopErasedWalk.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/LoopErasedWalk.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Trail.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/Trail.gif&#34;&gt;&lt;/a&gt;&lt;br&gt; (RBB=WWR) | LoopErasedWalk | (RB=WR RW=WR) &lt;/p&gt; &#xA;&lt;p&gt;We can put several rules into one &lt;strong&gt;rulenode&lt;/strong&gt;. For example, &lt;code&gt;(RBB=WWR RBW=GWP PWG=PBU UWW=BBU UWP=BBR)&lt;/code&gt; is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Loop-erased_random_walk&#34;&gt;loop-erased random walk&lt;/a&gt;. Trail model &lt;code&gt;(RB=WR RW=WR)&lt;/code&gt; generates &lt;a href=&#34;https://blog.jrheard.com/procedural-dungeon-generation-drunkards-walk-in-clojurescript&#34;&gt;decent connected caves&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Model &lt;code&gt;(RBB=WWR R*W=W*R)&lt;/code&gt; is known as the &lt;a href=&#34;http://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm&#34;&gt;Aldous-Broder maze generation algorithm&lt;/a&gt;. The &lt;strong&gt;wildcard&lt;/strong&gt; symbol &lt;code&gt;*&lt;/code&gt; in the input means that &lt;em&gt;any&lt;/em&gt; color is allowed to be in the square. The wildcard symbol in the output means that the color doesn&#39;t change after the application of the rule. Aldous-Broder algorithm takes much more turns on average to generate a maze than MazeGrowth, for example, but it has a nice property that MazeGrowth doesn&#39;t have: each maze has the same probability to be generated. In other words, MazeTrail is an unbiased maze generation algorithm, or it samples mazes (or spanning trees) with the uniform distribution. &lt;a href=&#34;http://web.stanford.edu/~yuvalwig/math/teaching/UniformSpanningTrees.pdf&#34;&gt;Wilson&#39;s algorithm&lt;/a&gt; is a more efficient unbiased maze generation algorithm. Compare its &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/Wilson.gif&#34;&gt;MarkovJunior&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Wilson.xml&#34;&gt;implementation&lt;/a&gt; with an &lt;a href=&#34;https://bl.ocks.org/mbostock/11357811&#34;&gt;implementation&lt;/a&gt; in a conventional language!&lt;/p&gt; &#xA;&lt;h2&gt;Combining rulenodes&lt;/h2&gt; &#xA;&lt;p&gt;We can put several rulenodes into a &lt;strong&gt;sequence node&lt;/strong&gt;, to be run one after the other. In the &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/River.xml&#34;&gt;River&lt;/a&gt; model we first construct a stochastic &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Voronoi.xml&#34;&gt;Voronoi&lt;/a&gt; diagram with 2 sources, and use the boundary between the formed regions as a base for a river. Then we spawn a couple more Voronoi seeds to grow forests and simultaneously grow grass from the river. As a result, we get random river valleys!&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/River.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/River.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Apartemazements.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/Apartemazements.gif&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;In &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Apartemazements.xml&#34;&gt;Apartemazements&lt;/a&gt; we start with a WFC node and then do constructive postprocessing with rulenodes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Prepare constraints: mark bottom cells with a separate bottom color, mark the remaining border cells (sides and top) with a separate border color. Border cells should map to Empty, bottom cells should map to all tiles except Down.&lt;/li&gt; &#xA; &lt;li&gt;Run WFC &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/resources/tilesets/Paths.xml&#34;&gt;Paths&lt;/a&gt; tileset to generate closed stairy cycles.&lt;/li&gt; &#xA; &lt;li&gt;Randomize light sources.&lt;/li&gt; &#xA; &lt;li&gt;Drop columns from corners of flat tiles.&lt;/li&gt; &#xA; &lt;li&gt;Retract double columns, columns that touch ground and columns that touch stairs, except columns growing from corners of the Turn tiles.&lt;/li&gt; &#xA; &lt;li&gt;Grow windows between neighboring columns.&lt;/li&gt; &#xA; &lt;li&gt;Merge windows into bigger rectangles. We do this in several steps: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Detect uneven patterns of windows when window corners touch window midpoints.&lt;/li&gt; &#xA;   &lt;li&gt;Mark these patterns and propagate the markings through the whole lengths of window sides.&lt;/li&gt; &#xA;   &lt;li&gt;Merge unmarked pairs of window sides.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Turn the remaining 1x1 windows into walls.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;A more interesting way to combine nodes is to put them into a &lt;strong&gt;Markov node&lt;/strong&gt;. Markov nodes substantially expand what we can do, because they allow to return to past nodes. When a Markov node is active, interpreter finds its first child node that matches and applies it. On the next turn, it finds the first matching node in the list again, and so on. The simplest example of the Markov node use is &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/MazeBacktracker.xml&#34;&gt;MazeBacktracker&lt;/a&gt; explained in the top section.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/NystromDungeon.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/NystromDungeon.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Flowers.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/Flowers.gif&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;One of my favorite examples that motivated the development of MarkovJunior is &lt;a href=&#34;https://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/&#34;&gt;Bob Nystrom&#39;s dungeon generation algorithm&lt;/a&gt;. It goes as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Draw a grid &lt;code&gt;{PBB=**P}&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Spawn a bunch of rooms &lt;code&gt;(room.png)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Generate a maze on the rest of the grid. We can use any maze generation algorithm, but &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/MazeBacktracker.xml&#34;&gt;MazeBacktracker&lt;/a&gt; is preferred because it produces fewer branching points.&lt;/li&gt; &#xA; &lt;li&gt;Make the resulting configuration of rooms and corridors connected. This can be elegantly done with a Markov node &lt;code&gt;({GWW=**G}(GBW=*WG))&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Make some additional connections &lt;code&gt;(GBG=*W* #5)&lt;/code&gt;, so the resulting dungeon has cycles. Dungeons without cycles are pretty boring, since the player has to return through already explored zones.&lt;/li&gt; &#xA; &lt;li&gt;Retract dead ends &lt;code&gt;{BBB/BWB=BBB/BBB}&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Circuit.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/Circuit.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/DungeonGrowth.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/DungeonGrowth.gif&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Like in REFAL, Markov nodes can be nested: once we go into a child node, we ignore outer nodes until the child branch completes.&lt;/p&gt; &#xA;&lt;h2&gt;Inference&lt;/h2&gt; &#xA;&lt;p&gt;Probabilistic inference in MarkovJunior allows to impose constraints on the future state, and generate only those runs that lead to the constrained future. In other words, inference connects 2 given states (or partially observed states) with a chain of rewrite rules.&lt;/p&gt; &#xA;&lt;p&gt;The simplest example of inference use is connecting 2 points with a path. In the self-avoiding walk model &lt;code&gt;(RBB=WWR)&lt;/code&gt; we can &lt;strong&gt;observe&lt;/strong&gt; a given square on the grid to become &lt;code&gt;R&lt;/code&gt; red. Then the interpreter would generate only those walks that lead to the observed square. We can set the interpreter to follow the goal more strictly or less strictly by varying the &lt;strong&gt;temperature&lt;/strong&gt; parameter. By default, temperature is set to zero.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/coldest.gif&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/cold.gif&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/hot.gif&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/hottest.gif&#34;&gt;&lt;br&gt; Coldest | Cold | Hot | Hottest &lt;/p&gt; &#xA;&lt;p&gt;Another thing we can do is to observe &lt;em&gt;all&lt;/em&gt; odd grid squares becoming white or red. Then the interpreter would generate self-avoiding walks that cover the entire grid.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/CompleteSAW.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/CompleteSAW.gif&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/SokobanLevel1.xml&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/SokobanLevel1.gif&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;We can engage inference for any rewrite rules. For example, inference for &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/StairsPath.xml&#34;&gt;stair-drawing rules&lt;/a&gt; connects 2 points with a stairy path. Inference for rule &lt;code&gt;R**/**B=B**/**R&lt;/code&gt; generates paths that a chess knight can take. Inference in the &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/CrossCountry.xml&#34;&gt;CrossCountry&lt;/a&gt; model connects 2 points with a path taking terrain costs into account. Inference for the Sokoban ruleset &lt;code&gt;{RB=BR RWB=BRW}&lt;/code&gt; solves Sokoban puzzles or even &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/multisokoban.gif&#34;&gt;multiagent Sokoban puzzles&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/StairsPath.gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inference in MarkovJunior is done via unidirectional (fast) or bidirectional (slow, but more powerful) constraint propagation. Unidirectional constraint propagation for rewrite rules can be described equivalently in terms of &lt;strong&gt;rule propagation&lt;/strong&gt; fields which generalize Dijkstra fields for arbitrary rewrite rules. Dijkstra fields is a popular technique in grid-based procedural generation (&lt;a href=&#34;https://groups.google.com/forum/#!topic/rec.games.roguelike.development/6yNIuhSerpM&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps&#34;&gt;2&lt;/a&gt;, &lt;a href=&#34;http://www.roguebasin.com/index.php?title=Dijkstra_Maps_Visualized&#34;&gt;3&lt;/a&gt;). They in turn generalize &lt;a href=&#34;https://iquilezles.org/www/articles/distfunctions/distfunctions.htm&#34;&gt;distance fields&lt;/a&gt; used in computer graphics.&lt;/p&gt; &#xA;&lt;p&gt;If constraint propagation completes it doesn&#39;t necessarily mean that the goal state is achievable. But if the propagation fails then we know for sure that the goal is not achievable. This allows to catch states where a crate is pushed to the wrong wall in Sokoban, or where the grid-covering walk splits the grid into 2 disconnected parts. In addition to this boolean heuristic, it&#39;s worth looking at the minimal number of turns required for constraint propagation to complete. This integer-valued heuristic is &lt;a href=&#34;https://en.wikipedia.org/wiki/Admissible_heuristic&#34;&gt;admissible&lt;/a&gt;, and we use it in A* search to sample paths made of rewrite rules between 2 given states.&lt;/p&gt; &#xA;&lt;h2&gt;Open problems&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Program synthesis for procedural generation&lt;/strong&gt;. William Chyr&#39;s talk &lt;a href=&#34;https://youtu.be/ed2zmmcEryw?t=1298&#34;&gt;&#34;Level Design in Impossible Geometry&#34;&lt;/a&gt; is not at all about procedural generation, yet I find &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/images/ps-for-procgen.jpg&#34;&gt;one slide&lt;/a&gt; to be very characteristic for pcg practice. William compares his earlier and later approaches to level design. The earlier one produced chaotic levels, while the later approach produced more structured, more intentional levels based on one central idea. Later levels weren&#39;t simpler, yet they were more memorable and easier for players to perceive. To me, the left level looks like it was generated procedurally! It has a very similar feel to my &lt;a href=&#34;https://twitter.com/ExUtumno/status/971031987304763393&#34;&gt;procedural voxel puzzles&lt;/a&gt;. Can we make generators that produce levels that are more like the one on the right? This problem may seem AI-complete. But I&#39;d argue it is very similar to classic genetic programming problems like &lt;a href=&#34;https://pdfs.semanticscholar.org/555e/13cc2dd246e3d63ceb00590605f3ff59593d.pdf&#34;&gt;Koza&#39;s lawnmower problem&lt;/a&gt;. For example, take a simple procgen task of &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/CompleteSAW.xml&#34;&gt;generating Hamiltonian paths on the grid&lt;/a&gt;. Even for small grid sizes like 29x29 this task is already computationally demanding. But do we really need to sample from all possible paths in practice? If we give this task to a human, they would probably draw a spiral or a zigzag curve - these are much more memorable and intentional designs than a random Hamiltonian path, plus they generalize to any grid sizes. To summarize, we can ask the system either to find a random Hamiltonian path or to find a short program that generates Hamiltonian paths. In the first case the result would look like the left level on the slide, and in the second case like the right level. Solving the latter program synthesis problem would create more memorable and intentional generators.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Model synthesis from examples&lt;/strong&gt;. Markov algorithms seem to be a perfect environment for program/model synthesis: no variables, ifs or whiles, nodes can be easily moved around without breaking correctness, models are easy to make differentiable. Random MJ programs are often fun and can produce human-relatable results and behaviors. &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Can we synthesize a MJ model from a result, or a set of results?&lt;/li&gt; &#xA;   &lt;li&gt;Given a maze, is it possible to determine (or assign probabilities) whether it was generated by &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/MazeGrowth.xml&#34;&gt;MazeGrowth&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/MazeBacktracker.xml&#34;&gt;MazeBacktracker&lt;/a&gt;?&lt;/li&gt; &#xA;   &lt;li&gt;Solve the &lt;a href=&#34;https://www.kaggle.com/c/abstraction-and-reasoning-challenge&#34;&gt;Abstraction and Reasoning Challenge&lt;/a&gt; by inferring MarkovJunior models. Adjoint problem: use insights from the ARC challenge to build a better DSL for procedural generation on a grid.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Custom algorithms that run in the wave space&lt;/strong&gt;. To unite the advantages of constructive and constrained-based procedural generation. Related: custom algorithms (MJ rewrite rules) with custom energy functions like Ising energy or ConvChain energy.&lt;/li&gt; &#xA; &lt;li&gt;Generalize the notion of a pattern.&lt;/li&gt; &#xA; &lt;li&gt;Investigate MJ-like processes on other (possibly nonregular) grids or arbitrary graphs.&lt;/li&gt; &#xA; &lt;li&gt;Experiment with interactive extensions of Markov algorithms. It&#39;s possible to turn any MJ model into a game by assigning specific rewrite rules or nodes to key presses.&lt;/li&gt; &#xA; &lt;li&gt;Push the state of the art in grid-based procedural generation. &lt;a href=&#34;https://twitter.com/ExUtumno/status/1141354217774428160&#34;&gt;ModernHouse&lt;/a&gt; does not yet reach the structural variety of human-designed houses like &lt;a href=&#34;https://www.thesimsresource.com/downloads/browse/category/sims2-lots/featured/1/search/modern%20house/&#34;&gt;Sims 2 houses&lt;/a&gt;. Use more subtle constraints.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Comments&lt;/h2&gt; &#xA;&lt;p&gt;Compared to Turing machines and lambda calculus, Markov algorithms is probably the shortest and simplest way to rigorously define what an algorithm is.&lt;/p&gt; &#xA;&lt;p&gt;Exercise: prove that the following Markov algorithm finds the greatest common divisor of 2 numbers written in a unary representation. For example, if we apply it to &lt;code&gt;111111*1111111111&lt;/code&gt; we get &lt;code&gt;11&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1a=a1&#xA;1*1=a*&#xA;1*=*b&#xA;b=1&#xA;a=c&#xA;c=1&#xA;*=ε (halt)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fast pattern matching. MarkovJunior interpreter samples matches uniformly, but it doesn&#39;t scan the whole grid every turn. To keep pattern matching fast, the interpreter remembers previously found matches and searches only around the places that got changed. When a rulenode is encountered for the first time, MJ interpreter uses a multidimensional version of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm&#34;&gt;Boyer–Moore algorithm&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Stochastic relaxation. Markov nodes have a very nice representations as limits of differentiable nodes. Consider an unordered set of rewrite rules where each rule &lt;code&gt;r&lt;/code&gt; is assigned a weight &lt;code&gt;w(r)&lt;/code&gt;. On each step the interpreter finds all matches for all rules and chooses a random match according to the Boltzmann distribution &lt;code&gt;p(r) ~ exp(-w(r)/t)&lt;/code&gt;. Then in the freezing limit &lt;code&gt;t-&amp;gt;0&lt;/code&gt; we get a Markov node, ordered by weights. What&#39;s good about this construction, is that for any &lt;code&gt;t&amp;gt;0&lt;/code&gt; and for a typical score function, score&#39;s average on multiple runs would be a continuous (and smooth for practical purposes) function of weights. This means that one can find the optimal weights by gradient descent and then freeze the system to get the final discrete program.&lt;/p&gt; &#xA;&lt;p&gt;Read this &lt;a href=&#34;https://www.jstor.org/stable/27641983&#34;&gt;essay&lt;/a&gt; by &lt;a href=&#34;https://en.wikipedia.org/wiki/Boris_Kushner_(mathematician)&#34;&gt;Boris Kushner&lt;/a&gt; about A. A. Markov and his work in constructive mathematics.&lt;/p&gt; &#xA;&lt;h2&gt;Used work&lt;/h2&gt; &#xA;&lt;p&gt;Main used work:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Andrey A. Markov, &lt;a href=&#34;http://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;amp;jrnid=tm&amp;amp;paperid=1117&amp;amp;option_lang=eng&#34;&gt;The Theory of Algorithms&lt;/a&gt;, 1951. Markov used these ideas earlier in 1947 in his proof of the algorithmic undecidability of the word problem in semigroups. See also a later &lt;a href=&#34;http://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;amp;jrnid=tm&amp;amp;paperid=1178&amp;amp;option_lang=eng&#34;&gt;book&lt;/a&gt; with a more detailed treatment. I would be grateful for links to English translations in open access.&lt;/li&gt; &#xA; &lt;li&gt;Guilherme S. Tows, &lt;a href=&#34;https://zaratustra.itch.io/imagegram&#34;&gt;Imagegram&lt;/a&gt;, 2009. MarkovJunior takes forall-nodes from Imagegram.&lt;/li&gt; &#xA; &lt;li&gt;Valentin Turchin, &lt;a href=&#34;http://fprog.ru/2011/issue7/practice-fp-7-screen.pdf&#34;&gt;REFAL language&lt;/a&gt;, 1968. MJ takes the idea of nested Markov nodes from REFAL.&lt;/li&gt; &#xA; &lt;li&gt;Brian Walker et al., &lt;a href=&#34;https://groups.google.com/forum/#!topic/rec.games.roguelike.development/6yNIuhSerpM&#34;&gt;The incredible power of Dijkstra maps&lt;/a&gt;, 2010. A discussion in the the roguelike community that contains many techniques of using Dijkstra maps/distance fields for procedural generation and NPC AI. Later writeups: &lt;a href=&#34;http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://www.roguebasin.com/index.php?title=Dijkstra_Maps_Visualized&#34;&gt;2&lt;/a&gt;. We generalize Dijkstra maps to arbitrary rewrite rules.&lt;/li&gt; &#xA; &lt;li&gt;Pavlos S. Efraimidis, Paul Spirakis, &lt;a href=&#34;https://utopia.duth.gr/~pefraimi/research/data/2007EncOfAlg.pdf&#34;&gt;Weighted Random Sampling&lt;/a&gt;, 2005.&lt;/li&gt; &#xA; &lt;li&gt;Work used in custom nodes: &lt;a href=&#34;http://graphics.stanford.edu/~pmerrell/thesis.pdf&#34;&gt;Model Synthesis&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/WaveFunctionCollapse&#34;&gt;Wave Function Collapse Algorithm&lt;/a&gt;, &lt;a href=&#34;https://github.com/mxgmn/ConvChain&#34;&gt;ConvChain Algorithm&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Classic algorithms: &lt;a href=&#34;https://en.wikipedia.org/wiki/Local_consistency&#34;&gt;constraint propagation&lt;/a&gt;, &lt;a href=&#34;https://www.cs.ubc.ca/~mack/Publications/AI77.pdf&#34;&gt;constraint solving algorithms&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Graph_traversal&#34;&gt;graph traversal&lt;/a&gt;, &lt;a href=&#34;https://www.cs.auckland.ac.nz/courses/compsci709s2c/resources/Mike.d/astarNilsson.pdf&#34;&gt;A* search&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Related work:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Daniel Ritchie, &lt;a href=&#34;https://dritchie.github.io/pdf/thesis.pdf&#34;&gt;Probabilistic Programming for Procedural Modeling and Design&lt;/a&gt;, 2016.&lt;/li&gt; &#xA; &lt;li&gt;Lingfeng Yang, &lt;a href=&#34;https://stacks.stanford.edu/file/druid:kq822ym0815/et2si-reduced-opt-augmented.pdf&#34;&gt;From Execution Traces to Specialized Inference&lt;/a&gt;, 2015.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Sources of examples:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/BasicKeys.xml&#34;&gt;BasicKeys&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/Keys.xml&#34;&gt;Keys&lt;/a&gt; are adaptations of graph grammars formulated by Joris Dormans, &lt;a href=&#34;https://www.illc.uva.nl/Research/Publications/Dissertations/DS-2012-12.text.pdf&#34;&gt;Engineering Emergence: Applied Theory for Game Design&lt;/a&gt;, 2012. Which in turn are development of the earlier work by David Adams, &lt;a href=&#34;https://pdfs.semanticscholar.org/2502/0f8d955aee07b7dd49a3ec23b1f2a8cf1d06.pdf&#34;&gt;Automatic Generation of Dungeons for Computer Games&lt;/a&gt;, 2002. I use a variation of these models to generate key-lock-bridge puzzles in &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/SeaVilla.xml&#34;&gt;SeaVilla&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/CarmaTower.xml&#34;&gt;CarmaTower&lt;/a&gt; is a proceduralization of a &lt;a href=&#34;https://twitter.com/Sir_carma/status/851883489628704768&#34;&gt;voxel scene&lt;/a&gt; by Antoine Lendrevie.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/NystromDungeon.xml&#34;&gt;NystromDungeon&lt;/a&gt; model is a MarkovJunior port of &lt;a href=&#34;https://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/&#34;&gt;Bob Nystrom&#39;s dungeon generator&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/HamiltonianPath.xml&#34;&gt;HamiltonianPath&lt;/a&gt; algorithm is adapted from &lt;a href=&#34;http://aip.scitation.org/doi/pdf/10.1063/1.443937&#34;&gt;this&lt;/a&gt; article. Compare it with an &lt;a href=&#34;http://clisby.net/projects/hamiltonian_path/hamiltonian_path_v1.html&#34;&gt;implementation&lt;/a&gt; in a conventional language.&lt;/li&gt; &#xA; &lt;li&gt;Room shapes in &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/DungeonGrowth.xml&#34;&gt;DungeonGrowth&lt;/a&gt; are taken from the &lt;a href=&#34;https://old.reddit.com/r/proceduralgeneration/comments/3pa8a1/my_take_at_a_roguelike_level_generator_ft/&#34;&gt;r/proceduralgeneration post&lt;/a&gt;. Note that MJ interpreter automatically performs the optimizations described in the post.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Wilson.xml&#34;&gt;Wilson&lt;/a&gt; model is a rewrite rule formulation of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Loop-erased_random_walk#Uniform_spanning_tree&#34;&gt;Wilson&#39;s algorithm&lt;/a&gt;. Compare it with an &lt;a href=&#34;https://bl.ocks.org/mbostock/11357811&#34;&gt;implementation&lt;/a&gt; in a conventional language.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/MazeGrowth.xml&#34;&gt;MazeGrowth&lt;/a&gt; model is also known as maze generation via random traversal. Compare it with an &lt;a href=&#34;https://bl.ocks.org/mbostock/70a28267db0354261476&#34;&gt;implementation&lt;/a&gt; in a conventional language.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/Growth.xml&#34;&gt;Growth&lt;/a&gt; is closely related to the &lt;a href=&#34;http://digitalassets.lib.berkeley.edu/math/ucb/text/math_s4_v4_article-15.pdf&#34;&gt;Eden growth model&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/BernoulliPercolation.xml&#34;&gt;BernoulliPercolation&lt;/a&gt; is a well studied model in a &lt;a href=&#34;https://en.wikipedia.org/wiki/Percolation_theory&#34;&gt;percolation theory&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/NestedGrowth.xml&#34;&gt;NestedGrowth&lt;/a&gt; is taken from &lt;a href=&#34;https://zaratustra.itch.io/imagegram&#34;&gt;Imagegram&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/SmoothTrail.xml&#34;&gt;SmoothTrail&lt;/a&gt; is adapted from &lt;a href=&#34;https://twitter.com/128_mhz/status/953847394403205120&#34;&gt;128_mhz&#39;s tweet&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/SokobanLevel1.xml&#34;&gt;SokobanLevel1&lt;/a&gt; seems to be the first level from Hiroyuki Imabayashi&#39;s Sokoban puzzle. &lt;a href=&#34;https://raw.githubusercontent.com/mxgmn/MarkovJunior/main/models/SokobanLevel2.xml&#34;&gt;SokobanLevel2&lt;/a&gt; is the &lt;a href=&#34;https://www.sokobanonline.com/play/web-archive/razorflame/ionic-catalysts-xi/58022_ionic-catalysts-xi-452&#34;&gt;level 452&lt;/a&gt; from Ionic Catalysts XI set.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Voxel scenes were rendered in &lt;a href=&#34;https://ephtracy.github.io/&#34;&gt;MagicaVoxel&lt;/a&gt; by &lt;a href=&#34;https://github.com/ephtracy&#34;&gt;ephtracy&lt;/a&gt;. Special thanks to &lt;a href=&#34;https://github.com/unormal&#34;&gt;Brian Bucklew&lt;/a&gt; for demonstrating the power of Dijkstra fields to me in roguelike level generation and &lt;a href=&#34;https://github.com/kchapelier&#34;&gt;Kevin Chapelier&lt;/a&gt; for a number of good suggestions. The font used in GUI is &lt;a href=&#34;https://github.com/sunaku/tamzen-font&#34;&gt;Tamzen&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to build&lt;/h2&gt; &#xA;&lt;p&gt;MarkovJunior interpreter is a console application that depends only on the standard library. Get &lt;a href=&#34;https://dotnet.microsoft.com/download&#34;&gt;.NET Core&lt;/a&gt; for Windows, Linux or macOS and run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet run --configuration Release MarkovJunior.csproj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, download and run the latest &lt;a href=&#34;https://github.com/mxgmn/MarkovJunior/releases&#34;&gt;release&lt;/a&gt; for Windows.&lt;/p&gt; &#xA;&lt;p&gt;Generated results are put into the &lt;code&gt;output&lt;/code&gt; folder. Edit &lt;code&gt;models.xml&lt;/code&gt; to change model parameters. Open &lt;code&gt;.vox&lt;/code&gt; files with &lt;a href=&#34;https://ephtracy.github.io/&#34;&gt;MagicaVoxel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Funding&lt;/h2&gt; &#xA;&lt;p&gt;MarkovJunior development was &lt;a href=&#34;https://github.com/users/mxgmn/sponsorship&#34;&gt;funded&lt;/a&gt; by&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.embark-studios.com/&#34;&gt;Embark Studios&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/OskSta&#34;&gt;Oskar Stålberg&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.steampowered.com/app/333640/Caves_of_Qud/&#34;&gt;Freehold Games&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bobburrough.com/&#34;&gt;Bob Burrough&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>