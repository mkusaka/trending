<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-09T01:31:39Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OkGoDoIt/OpenAI-API-dotnet</title>
    <updated>2022-12-09T01:31:39Z</updated>
    <id>tag:github.com,2022-12-09:/OkGoDoIt/OpenAI-API-dotnet</id>
    <link href="https://github.com/OkGoDoIt/OpenAI-API-dotnet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A C#/.NET SDK for accessing the OpenAI GPT-3 API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;C#/.NET SDK for accessing the OpenAI GPT-3 API&lt;/h1&gt; &#xA;&lt;p&gt;A simple C# .NET wrapper library to use with OpenAI&#39;s GPT-3 API. More context &lt;a href=&#34;https://rogerpincombe.com/openai-dotnet-api&#34;&gt;on my blog&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var api = new OpenAI_API.OpenAIAPI(engine: Engine.Davinci);&#xA;&#xA;var result = await api.Completions.CreateCompletionAsync(&#34;One Two Three One Two&#34;, temperature: 0.1);&#xA;Console.WriteLine(result.ToString());&#xA;// should print something starting with &#34;Three&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var api = new OpenAI_API.OpenAIAPI(&#34;sk-myapikeyhere&#34;););&#xA;&#xA;var result = await api.Search.GetBestMatchAsync(&#34;Washington DC&#34;, &#34;Canada&#34;, &#34;China&#34;, &#34;USA&#34;, &#34;Spain&#34;);&#xA;Console.WriteLine(result);&#xA;// should print &#34;USA&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;This library is based on .NET Standard 2.0, so it should work across .NET Framework &amp;gt;=4.7.2 and .NET Core &amp;gt;= 3.0. It should work across console apps, winforms, wpf, asp.net, etc (although I have not yet tested with asp.net). It should work across Windows, Linux, and Mac, although I have only tested on Windows so far.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h3&gt;Install from NuGet&lt;/h3&gt; &#xA;&lt;p&gt;Install package &lt;a href=&#34;https://www.nuget.org/packages/OpenAI/&#34;&gt;&lt;code&gt;OpenAI&lt;/code&gt; from Nuget&lt;/a&gt;. Here&#39;s how via commandline:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Install-Package OpenAI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;p&gt;There are 3 ways to provide your API keys, in order of precedence:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Pass keys directly to &lt;code&gt;APIAuthentication(string key)&lt;/code&gt; constructor&lt;/li&gt; &#xA; &lt;li&gt;Set environment var for OPENAI_KEY&lt;/li&gt; &#xA; &lt;li&gt;Include a config file in the local directory or in your user directory named &lt;code&gt;.openai&lt;/code&gt; and containing the line:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;OPENAI_KEY=sk-aaaabbbbbccccddddd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You use the &lt;code&gt;APIAuthentication&lt;/code&gt; when you initialize the API as shown:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// for example&#xA;OpenAIAPI api = new OpenAIAPI(&#34;sk-mykeyhere&#34;); // shorthand&#xA;// or&#xA;OpenAIAPI api = new OpenAIAPI(new APIAuthentication(&#34;sk-secretkey&#34;)); // create object manually&#xA;// or&#xA;OpenAIAPI api = new OpenAIAPI(APIAuthentication LoadFromEnv()); // use env vars&#xA;// or&#xA;OpenAIAPI api = new OpenAIAPI(APIAuthentication LoadFromPath()); // use config file (can optionally specify where to look)&#xA;// or&#xA;OpenAIAPI api = new OpenAIAPI(); // uses default, env, or config file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Completions&lt;/h3&gt; &#xA;&lt;p&gt;The Completion API is accessed via &lt;code&gt;OpenAIAPI.Completions&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;CreateCompletionAsync(CompletionRequest request)&#xA;&#xA;// for example&#xA;var result = await api.Completions.CreateCompletionAsync(new CompletionRequest(&#34;One Two Three One Two&#34;, temperature: 0.1));&#xA;// or&#xA;var result = await api.Completions.CreateCompletionAsync(&#34;One Two Three One Two&#34;, temperature: 0.1);&#xA;// or other convenience overloads&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can create your &lt;code&gt;CompletionRequest&lt;/code&gt; ahead of time or use one of the helper overloads for convenience. It returns a &lt;code&gt;CompletionResult&lt;/code&gt; which is mostly metadata, so use its &lt;code&gt;.ToString()&lt;/code&gt; method to get the text if all you want is the completion.&lt;/p&gt; &#xA;&lt;h4&gt;Streaming&lt;/h4&gt; &#xA;&lt;p&gt;Streaming allows you to get results are they are generated, which can help your application feel more responsive, especially on slow models like Davinci.&lt;/p&gt; &#xA;&lt;p&gt;Using the new C# 8.0 async iterators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;IAsyncEnumerable&amp;lt;CompletionResult&amp;gt; StreamCompletionEnumerableAsync(CompletionRequest request)&#xA;&#xA;// for example&#xA;await foreach (var token in api.Completions.StreamCompletionEnumerableAsync(new CompletionRequest(&#34;My name is Roger and I am a principal software engineer at Salesforce.  This is my resume:&#34;, 200, 0.5, presencePenalty: 0.1, frequencyPenalty: 0.1)))&#xA;{&#xA;&#x9;Console.Write(token);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if using .NET framework or C# &amp;lt;8.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;StreamCompletionAsync(CompletionRequest request, Action&amp;lt;CompletionResult&amp;gt; resultHandler)&#xA;&#xA;// for example&#xA;await api.Completions.StreamCompletionAsync(&#xA;&#x9;new CompletionRequest(&#34;My name is Roger and I am a principal software engineer at Salesforce.  This is my resume:&#34;, 200, 0.5, presencePenalty: 0.1, frequencyPenalty: 0.1),&#xA;&#x9;res =&amp;gt; ResumeTextbox.Text += res.ToString());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Document Search&lt;/h3&gt; &#xA;&lt;p&gt;The Search API is accessed via &lt;code&gt;OpenAIAPI.Search&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;You can get all results as a dictionary using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;GetSearchResultsAsync(SearchRequest request)&#xA;&#xA;// for example&#xA;var request = new SearchRequest()&#xA;{&#xA;&#x9;Query = &#34;Washington DC&#34;,&#xA;&#x9;Documents = new List&amp;lt;string&amp;gt; { &#34;Canada&#34;, &#34;China&#34;, &#34;USA&#34;, &#34;Spain&#34; }&#xA;};&#xA;var result = await api.Search.GetSearchResultsAsync(request);&#xA;// result[&#34;USA&#34;] == 294.22&#xA;// result[&#34;Spain&#34;] == 73.81&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The returned dictionary maps documents to scores. You can create your &lt;code&gt;SearchRequest&lt;/code&gt; ahead of time or use one of the helper overloads for convenience, such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;GetSearchResultsAsync(string query, params string[] documents)&#xA;&#xA;// for example&#xA;var result = await api.Search.GetSearchResultsAsync(&#34;Washington DC&#34;, &#34;Canada&#34;, &#34;China&#34;, &#34;USA&#34;, &#34;Spain&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can get only the best match using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;GetBestMatchAsync(request)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And if you only want the best match but still want to know the score, use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;GetBestMatchWithScoreAsync(request)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each of those methods has similar convenience overloads to specify the request inline.&lt;/p&gt; &#xA;&lt;h3&gt;Finetuning&lt;/h3&gt; &#xA;&lt;p&gt;I don&#39;t yet have access to finetuning, but once I do I will add it to this SDK. Subscribe to this repo if you want to be alerted.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Every single class, method, and property has extensive XML documentation, so it should show up automatically in IntelliSense. That combined with the official OpenAI documentation should be enough to get started. Feel free to ping me on Twitter &lt;a href=&#34;https://twitter.com/OkGoDoIt&#34;&gt;@OkGoDoIt&lt;/a&gt; if you have any questions. Better documentation may come later.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://licensebuttons.net/p/zero/1.0/88x31.png&#34; alt=&#34;CC-0 Public Domain&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This library is licensed CC-0, in the public domain. You can use it for whatever you want, publicly or privately, without worrying about permission or licensing or whatever. It&#39;s just a wrapper around the OpenAI API, so you still need to get access to OpenAI from them directly. I am not affiliated with OpenAI and this library is not endorsed by them, I just have beta access and wanted to make a C# library to access it more easily. Hopefully others find this useful as well. Feel free to open a PR if there&#39;s anything you want to contribute.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ceramicskate0/SharpExchange</title>
    <updated>2022-12-09T01:31:39Z</updated>
    <id>tag:github.com,2022-12-09:/ceramicskate0/SharpExchange</id>
    <link href="https://github.com/ceramicskate0/SharpExchange" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C# Tool to interact with MS Exchange based on MS docs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SharpExchange&lt;/h1&gt; &#xA;&lt;p&gt;This command line POC that shows how C# can be used to interact with Microsoft Exchange (EWS). Showing that it can be done in other tooling other than Powershell. Yes this is a simple POC to show how it could be done. Its not 100%. You want to show off your l33t C# coder or red teamer skills open a pull request plz :) This is for educational purposes only. Dont use for evil or illegal things.&lt;/p&gt; &#xA;&lt;h2&gt;MS Documentation:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/microsoft.exchange.webservices.data.exchangeservice?view=exchange-ews-api&#34;&gt;https://learn.microsoft.com/en-us/dotnet/api/microsoft.exchange.webservices.data.exchangeservice?view=exchange-ews-api&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/exchange/client-developer/exchange-web-services/get-started-with-ews-managed-api-client-applications&#34;&gt;https://learn.microsoft.com/en-us/exchange/client-developer/exchange-web-services/get-started-with-ews-managed-api-client-applications&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/microsoft.exchange.webservices.data.mailbox?view=exchange-ews-api&#34;&gt;https://learn.microsoft.com/en-us/dotnet/api/microsoft.exchange.webservices.data.mailbox?view=exchange-ews-api&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Google &#34;Microsoft.Exchange.WebServices&#34; ;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Like the work dont forget to hit that Star Button&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;            &#xA;            Required Inputs (Must be in order shown):&#xA;&#xA;            ReadEmailExchange.exe WEBDomain DomainName Password InternalDomainName DUMPItem&#xA;                Example WEBDomain: webmail.domain.com&#xA;                Example DomainName: User1&#xA;                Example Password: SecretPassword&#xA;                Example InternalDomainName: domain&#xA;                &#xA;                Options for DUMPItem:&#xA;                    Inbox&#xA;                    Sent&#xA;                    Drafts&#xA;                    Deleted&#xA;                    Skype&#xA;                    Attachments (Will Download Atatchments from the Inbox, DeletedItems, and Sent Items folders)&#xA;                    SendEmail ToEmailAddress~Subject~Body(Body can be file path)~AttachmentLocalFilePath(optional)&#xA;                    All (All == will try to dump all the items above)(I would default to this if unsure)&#xA;&#xA;            Optional Inputs:&#xA;&#xA;            ReadEmailExchange.exe WEBDomain DomainName Password InternalDomainName DUMPItem NumberOfSearchResultsToReturn&#xA;                            Example NumberOfSearchResultsToReturn (will return a maximum of the number,default 10): 10&#xA;                            Note: NumberOfSearchResultsToReturn must be a int/whole number&#xA;&#xA;            Optional Inputs:&#xA;&#xA;            ReadEmailExchange.exe WEBDomain DomainName Password InternalDomainName DUMPItem NumberOfSearchResultsToReturn OutputFileNameOrPath&#xA;                Example OutputFileNameOrPath: C:\file.csv&#xA;                Note: Program needs permission to write to location&#xA;                &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dont use for evil or if not authorized to do so. This is for educational purposes only. Not an exploit.&lt;/h2&gt; &#xA;&lt;h2&gt;3rd Party Depend:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/zzzprojects/html-agility-pack&#34;&gt;https://github.com/zzzprojects/html-agility-pack&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Microsoft.Exchange.WebServices&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;If someone decides to use this (its already flagged by some A/V&#39;s on disk) here are some ideas for IOC:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Its C#, so AMSI is likely in play on modern systems where it is enabled&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Can write text file to disk&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Uses default .NET user agent string (For example: ... .NET CLR ...)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When Run the .NET exe could create the temp file in the user&#39;s account folder structure with its name.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GUID of app&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Many more opportunites exist if code is reviewed&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Stackover flow&lt;/li&gt; &#xA; &lt;li&gt;MS Docs&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>xljiulang/KestrelApp</title>
    <updated>2022-12-09T01:31:39Z</updated>
    <id>tag:github.com,2022-12-09:/xljiulang/KestrelApp</id>
    <link href="https://github.com/xljiulang/KestrelApp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;基于Kestrel的网络编程应用示例&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KestrelApp&lt;/h1&gt; &#xA;&lt;p&gt;基于Kestrel的网络编程应用示例&lt;/p&gt; &#xA;&lt;h3&gt;1 项目意图&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;了解网络编程不再需要从Socket开始&lt;/li&gt; &#xA; &lt;li&gt;了解网络编程不再需要第三方框架(包括Dotnetty)&lt;/li&gt; &#xA; &lt;li&gt;了解&lt;code&gt;telnet&lt;/code&gt; over &lt;code&gt;websocket&lt;/code&gt; over &lt;code&gt;tls&lt;/code&gt; over &lt;code&gt;xxx私有加密&lt;/code&gt; over &lt;code&gt;tcp&lt;/code&gt;的套娃网络编程&lt;/li&gt; &#xA; &lt;li&gt;能基于KestrelFramework开发网络应用&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;2 文档资料&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;内部文档&lt;/strong&gt;：&lt;a href=&#34;https://raw.githubusercontent.com/xljiulang/KestrelApp/master/docs&#34;&gt;docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;外部文档&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/zh-cn/dotnet/standard/io/pipelines&#34;&gt;Pipelines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/zh-cn/dotnet/standard/io/buffers&#34;&gt;Buffers&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;3 KestrelFramework&lt;/h3&gt; &#xA;&lt;p&gt;kestrel网络编程一些必要的基础库&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Kestrel中间件接口与中间注册&lt;/li&gt; &#xA; &lt;li&gt;System.Buffers: 缓冲区操作类&lt;/li&gt; &#xA; &lt;li&gt;System.IO: 流的操作类&lt;/li&gt; &#xA; &lt;li&gt;System.IO.Pipelines: 双工管道操作类&lt;/li&gt; &#xA; &lt;li&gt;Middleware: kestrel的一些中间件&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;4 KestrelApp&lt;/h3&gt; &#xA;&lt;p&gt;Kestrel应用程序，内容包括&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;监听的EndPoint的配置&lt;/li&gt; &#xA; &lt;li&gt;EndPoint使用的协议配置&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;5 KestrelApp.Middleware&lt;/h3&gt; &#xA;&lt;p&gt;KestrelApp的中间件类库&lt;/p&gt; &#xA;&lt;h4&gt;5.1 Echo&lt;/h4&gt; &#xA;&lt;p&gt;简单Echo应用协议的示例&lt;/p&gt; &#xA;&lt;h4&gt;5.2 FlowAnalyze&lt;/h4&gt; &#xA;&lt;p&gt;传输层流量统计中间件示例&lt;/p&gt; &#xA;&lt;h4&gt;5.3 FlowXor&lt;/h4&gt; &#xA;&lt;p&gt;传输层流量异或处理的中间件示例&lt;/p&gt; &#xA;&lt;h4&gt;5.4 HttpProxy&lt;/h4&gt; &#xA;&lt;p&gt;http代理应用协议的示例&lt;/p&gt; &#xA;&lt;h4&gt;5.5 Telnet&lt;/h4&gt; &#xA;&lt;p&gt;简单Telnet应用协议的示例&lt;/p&gt; &#xA;&lt;h4&gt;5.6 TelnetProxy&lt;/h4&gt; &#xA;&lt;p&gt;流量转发到telnet服务器的的示例&lt;/p&gt; &#xA;&lt;h4&gt;5.6 Redis&lt;/h4&gt; &#xA;&lt;p&gt;redis协议服务器，展示如何使用应用中间件的示例&lt;/p&gt; &#xA;&lt;h3&gt;开源有你更精彩&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xljiulang/KestrelApp/master/reward.png&#34; alt=&#34;打赏&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>