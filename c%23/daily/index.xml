<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-30T01:36:58Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Tichau/FileConverter</title>
    <updated>2022-07-30T01:36:58Z</updated>
    <id>tag:github.com,2022-07-30:/Tichau/FileConverter</id>
    <link href="https://github.com/Tichau/FileConverter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;File Converter is a very simple tool which allows you to convert and compress one or several file(s) using the context menu in windows explorer.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;File Converter&lt;/h1&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;File Converter&lt;/strong&gt; is a very simple tool which allows you to convert and compress one or several file(s) using the context menu of windows explorer.&lt;/p&gt; &#xA;&lt;p&gt;You can download it here: &lt;a href=&#34;https://file-converter.org/?from=readme.md&#34;&gt;www.file-converter.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can find more information about what&#39;s in File converter and how to use it on the &lt;a href=&#34;https://github.com/Tichau/FileConverter/wiki&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Donate&lt;/h2&gt; &#xA;&lt;p&gt;File Converter is a personal open source project started in 2014. I have put hundreds of hours adding, refining and tuning File Converter with the goal of making the conversion and compression of files an easy task for everyone.&lt;/p&gt; &#xA;&lt;p&gt;You can help me by &lt;a href=&#34;https://github.com/Tichau/FileConverter/wiki#contribute&#34;&gt;contributing to the project&lt;/a&gt;, by &lt;a href=&#34;https://www.paypal.com/donate/?cmd=_donations&amp;amp;business=3BDWQTYTTA3D8&amp;amp;item_name=File+Converter+Donations&amp;amp;currency_code=EUR&amp;amp;Z3JncnB0=&#34;&gt;making a donation&lt;/a&gt; or just by &lt;a href=&#34;https://saythanks.io/to/Tichau&#34;&gt;saying thanks​&lt;/a&gt; :).&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;If you encounter any problem with File Converter, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;See the already known problems in the &lt;a href=&#34;https://github.com/Tichau/FileConverter/wiki/Troubleshooting&#34;&gt;troubleshooting section of the documentation&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Or report an issue on the &lt;a href=&#34;https://github.com/Tichau/FileConverter/issues&#34;&gt;bug tracker&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When you report an issue, please join the following informations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Registry.xml&lt;/li&gt; &#xA; &lt;li&gt;Settings.user.xml&lt;/li&gt; &#xA; &lt;li&gt;The Diagnostics folder of the session that encountered the issue.&lt;/li&gt; &#xA; &lt;li&gt;A screenshot (if possible) and a description that shows/explain the issue.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You will find the xml files and diagnostics folder in &lt;code&gt;c:\Users\[UserName]\AppData\Local\FileConverter\&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup development environement&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;p&gt;For File Converter and its explorer extension:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Visual Studio 2017&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For the installer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://wixtoolset.org/&#34;&gt;Wix toolset build tool v3.11 and visual studio extension&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.microsoft.com/fr-fr/windows/downloads/windows-10-sdk&#34;&gt;Windows SDK Signing Tools for Desktop Apps&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to all the contributors of File Converter project.&lt;/p&gt; &#xA;&lt;h3&gt;Localization&lt;/h3&gt; &#xA;&lt;p&gt;Thanks to &lt;strong&gt;Khidreal&lt;/strong&gt; for the Portuguese localization. Thanks to &lt;strong&gt;Marhc&lt;/strong&gt; for the Brazilian localization. Thanks to &lt;strong&gt;Chachak&lt;/strong&gt; for the Spanish localization. Thanks to &lt;strong&gt;Davide&lt;/strong&gt; for the Italian localization.&lt;/p&gt; &#xA;&lt;h2&gt;Middlewares&lt;/h2&gt; &#xA;&lt;p&gt;File converter uses the following middlewares:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ffmpeg&lt;/strong&gt; as file conversion software. Thanks to ffmpeg devs for this awesome open source file conversion tool. &lt;a href=&#34;https://ffmpeg.org&#34;&gt;Web site link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ImageMagick&lt;/strong&gt; as image edition and conversion software. Thanks to image magick devs for this awesome open source image edition software suite. &lt;a href=&#34;http://imagemagick.net&#34;&gt;Web site link&lt;/a&gt; And thanks to dlemstra for the C# wrapper of this software. &lt;a href=&#34;https://github.com/ImageMagick/ImageMagick&#34;&gt;Github link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Ghostscript&lt;/strong&gt; as pdf edition software. Thanks to ghostscript devs. &lt;a href=&#34;https://www.ghostscript.com/download/gsdnld.html&#34;&gt;Download link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SharpShell&lt;/strong&gt; to easily create windows context menu extensions. Thanks to Dave Kerr for his work on SharpShell. &lt;a href=&#34;https://sharpshell.codeplex.com&#34;&gt;CodePlex link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Ripper&lt;/strong&gt; and &lt;strong&gt;yeti.mmedia&lt;/strong&gt; for CD Audio extraction. Thanks to Idael Cardoso for his work on CD Audio ripper. &lt;a href=&#34;https://www.codeproject.com/Articles/5458/C-Sharp-Ripper&#34;&gt;Code project link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Markdown.XAML&lt;/strong&gt; for markdown rendering in the wpf application. Thanks to Bevan Arps for his work on Markdown.XAML. &lt;a href=&#34;https://github.com/theunrepentantgeek/Markdown.XAML&#34;&gt;GitHub link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;WpfAnimatedGif&lt;/strong&gt; for animated gif rendering in the wpf application. Thanks to Thomas Levesque for his work on WpfAnimatedGif. &lt;a href=&#34;https://github.com/XamlAnimatedGif/WpfAnimatedGif&#34;&gt;GitHub link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;File Converter is licensed under the GPL version 3 License. For more information check the LICENSE.md file in your installation folder or the &lt;a href=&#34;https://www.gnu.org/licenses/gpl.html&#34;&gt;gnu website&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>quartznet/quartznet</title>
    <updated>2022-07-30T01:36:58Z</updated>
    <id>tag:github.com,2022-07-30:/quartznet/quartznet</id>
    <link href="https://github.com/quartznet/quartznet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Quartz Enterprise Scheduler .NET&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/quartznet/quartznet/main/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/Quartz&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/lahma/quartznet-6fcn8/branch/master&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/d9ahvu9u77qjhx9r/branch/master?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Quartz/&#34;&gt;&lt;img src=&#34;http://img.shields.io/nuget/v/Quartz.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Quartz/&#34;&gt;&lt;img src=&#34;http://img.shields.io/nuget/vpre/Quartz.svg?sanitize=true&#34; alt=&#34;NuGet pre-release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/quartznet/quartznet/main/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/myget/quartznet/vpre/Quartz&#34; alt=&#34;MyGet pre-release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/quartznet/quartznet?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/quartznet/quartznet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Quartz.NET - Enterprise Job Scheduler&lt;/h1&gt; &#xA;&lt;p&gt;Please visit &lt;a href=&#34;https://www.quartz-scheduler.net/&#34;&gt;https://www.quartz-scheduler.net/&lt;/a&gt; for up to date news and documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;Quartz.NET supports .NET Core/netstandard 2.0 and .NET Framework 4.6.2 and later.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages?q=owner%3AQuartz.NET&#34;&gt;Stable builds from NuGet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Pre-release builds from MyGet feed: &lt;a href=&#34;https://www.myget.org/F/quartznet/api/v3/index.json&#34;&gt;https://www.myget.org/F/quartznet/api/v3/index.json&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can build the code by running &lt;code&gt;build.cmd&lt;/code&gt; (Windows) or &lt;code&gt;build.sh&lt;/code&gt; (*nix platform)&lt;/li&gt; &#xA; &lt;li&gt;You need MSBuild 17 and .NET Core SDK 6.0 to build&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Following components are being used by core Quartz:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/damianh/LibLog&#34;&gt;LibLog&lt;/a&gt; (MIT) as bridge between different logging frameworks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For API documentation, please refer to &lt;a href=&#34;http://quartznet.sourceforge.net/apidoc/3.0/html/&#34;&gt;Quartz.NET site&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ldqk/Masuit.Tools</title>
    <updated>2022-07-30T01:36:58Z</updated>
    <id>tag:github.com,2022-07-30:/ldqk/Masuit.Tools</id>
    <link href="https://github.com/ldqk/Masuit.Tools" rel="alternate"></link>
    <summary type="html">&lt;p&gt;包含一些常用的操作类，大都是静态类，加密解密，反射操作，权重随机筛选算法，分布式短id，表达式树，linq扩展，文件压缩，多线程下载和FTP客户端，硬件信息，字符串扩展方法，日期时间扩展操作，中国农历，大文件拷贝，图像裁剪，验证码，断点续传，集合扩展、Excel导出等常用封装。诸多功能集一身，代码量不到2MB！&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Masuit.Tools&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/996icu/996.ICU/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-Anti%20996-blue.svg?sanitize=true&#34; alt=&#34;LICENSE&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Masuit.Tools.Core&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Masuit.Tools.Core.svg?sanitize=true&#34; alt=&#34;nuget&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Masuit.Tools.Core&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/Masuit.Tools.Core.svg?sanitize=true&#34; alt=&#34;nuget&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/languages/code-size/ldqk/Masuit.Tools.svg?sanitize=true&#34; alt=&#34;codeSize&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/languages/top/ldqk/Masuit.Tools.svg?sanitize=true&#34; alt=&#34;language&#34;&gt; &lt;a href=&#34;https://gitee.com/masuit/Masuit.Tools&#34;&gt;&lt;img src=&#34;https://gitee.com/static/images/logo-black.svg?sanitize=true&#34; height=&#34;24&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ldqk/Masuit.Tools&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Font_Awesome_5_brands_github.svg/54px-Font_Awesome_5_brands_github.svg.png&#34; height=&#34;24&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/GitHub_logo_2013.svg/128px-GitHub_logo_2013.svg.png&#34; height=&#34;24&#34;&gt;&lt;/a&gt;&lt;br&gt; 包含一些常用的操作类，大都是静态类，加密解密，反射操作，权重随机筛选算法，分布式短id，表达式树，linq扩展，文件压缩，多线程下载和FTP客户端，硬件信息，字符串扩展方法，日期时间扩展操作，中国农历，大文件拷贝，图像裁剪，验证码，断点续传，集合扩展、Excel导出等常用封装。&lt;strong&gt;诸多功能集一身，代码量不到2MB！&lt;/strong&gt;&lt;br&gt; &lt;a href=&#34;https://masuit.com/55&#34;&gt;官网教程&lt;/a&gt;&lt;br&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/20254980/177526856-519b432f-da03-421a-adea-208957bf26b0.png&#34; alt=&#34;Masuit Tools&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;项目开发模式：日常代码积累+网络搜集&lt;br&gt; ⭐⭐⭐喜欢这个项目的话就Star、Fork、Follow素质三连关♂注一下吧⭐⭐⭐&lt;br&gt; 关于本项目，如果你有任何不懂的地方或使用过程中遇到任何问题，可以直接提issue或私信联系我，我会为你提供&lt;strong&gt;完全免费&lt;/strong&gt;的技术指导，当然，如果你觉得不好意思接受免费的指导，想适当打赏我也是不会拒绝的！🤣🤣🤣&lt;/p&gt; &#xA;&lt;h2&gt;本项目已得到&lt;a href=&#34;https://www.jetbrains.com/shop/eform/opensource&#34;&gt;JetBrains&lt;/a&gt;的支持！&lt;/h2&gt; &#xA;&lt;img src=&#34;https://www.jetbrains.com/shop/static/images/jetbrains-logo-inv.svg?sanitize=true&#34; height=&#34;100&#34;&gt; &#xA;&lt;h2&gt;Star趋势&lt;/h2&gt; &#xA;&lt;img src=&#34;https://starchart.cc/ldqk/Masuit.Tools.svg?sanitize=true&#34;&gt; &#xA;&lt;h2&gt;请注意：&lt;/h2&gt; &#xA;&lt;p&gt;一旦使用本开源项目以及引用了本项目或包含本项目代码的公司因为违反劳动法（包括但不限定非法裁员、超时用工、雇佣童工等）在任何法律诉讼中败诉的，一经发现，本项目作者有权利追讨本项目的使用费（&lt;strong&gt;公司工商注册信息认缴金额的2-5倍作为本项目的授权费&lt;/strong&gt;），或者直接不允许使用任何包含本项目的源代码！任何性质的&lt;code&gt;外包公司&lt;/code&gt;或&lt;code&gt;996公司&lt;/code&gt;需要使用本类库，请联系作者进行商业授权！其他企业或个人可随意使用不受限。996那叫用人，也是废人。8小时工作制才可以让你有时间自我提升，将来有竞争力。反对996，人人有责！&lt;/p&gt; &#xA;&lt;h2&gt;建议开发环境&lt;/h2&gt; &#xA;&lt;p&gt;操作系统：Windows 10 1903及以上版本&lt;br&gt; 开发工具：VisualStudio2019 v16.5及以上版本&lt;br&gt; SDK：.Net Core 2.1.0及以上所有版本&lt;/p&gt; &#xA;&lt;h2&gt;安装程序包&lt;/h2&gt; &#xA;&lt;h3&gt;基础功能包&lt;/h3&gt; &#xA;&lt;h4&gt;.NET Framework ≥ 4.6.1&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PM&amp;gt; Install-Package Masuit.Tools.Net&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;.NET Standard ≥ 2.1 或只想使用一些基本功能&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PM&amp;gt; Install-Package Masuit.Tools.Abstraction&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;.NET Core ≥ 2.1&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PM&amp;gt; Install-Package Masuit.Tools.Core&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;.NET Framework 4.5特供版&lt;/h4&gt; &#xA;&lt;p&gt;请注意：&lt;code&gt;这是.NET Framework 4.5的专用版本，相比4.6.1及.NET Core的版本，阉割了Redis、HTML、文件压缩、ASP.NET扩展、硬件监测、Session扩展等一些功能。&lt;/code&gt;&lt;strong&gt;如果你的项目版本高于4.5，请务必使用上述版本的包，以享受完整的功能体验！&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PM&amp;gt; Install-Package Masuit.Tools.Net45&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;增值包&lt;/h3&gt; &#xA;&lt;h4&gt;Masuit.Tools.AspNetCore&lt;/h4&gt; &#xA;&lt;p&gt;ASP.NET Core Web专用包，包含Masuit.Tools.Core的全部功能，并且增加了一些对ASP.NET Core Web功能的额外支持。&lt;/p&gt; &#xA;&lt;h4&gt;Masuit.Tools.Excel&lt;/h4&gt; &#xA;&lt;p&gt;Excel导入导出的专用独立包&lt;/p&gt; &#xA;&lt;h4&gt;Masuit.Tools.NoSQL.MongoDBClient&lt;/h4&gt; &#xA;&lt;p&gt;mongodb的封装操作类独立包&lt;/p&gt; &#xA;&lt;h2&gt;为工具库注册配置&lt;/h2&gt; &#xA;&lt;p&gt;工具库需要用到外部配置节，.NET Framework项目配置在web.config/app.config的AppSettings配置节中，.NET Core项目配置在appsettings.json中：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;EmailDomainWhiteList，邮箱校验需要用到的白名单域名，英文逗号分隔，每个元素支持正则表达式，若未配置，则不启用邮箱校验白名单，示例: &lt;code&gt;&#34;^\\w{1,5}@qq.com,^\\w{1,5}@163.com,^\\w{1,5}@gmail.com,^\\w{1,5}@outlook.com&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;EmailDomainBlockList，邮箱校验需要用到的黑名单域名，英文逗号分隔，每个元素支持正则表达式，且黑名单优先级高于白名单，若未配置，则不启用邮箱校验黑白名单&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public Startup(IConfiguration configuration)&#xA;{&#xA;    configuration.AddToMasuitTools(); // 若未调用，则默认自动尝试加载appsettings.json&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;特色功能示例代码&lt;/h2&gt; &#xA;&lt;h3&gt;在线体验&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dotnetfiddle.net/jclU4y&#34;&gt;https://dotnetfiddle.net/jclU4y&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;1.检验字符串是否是Email、手机号、URL、IP地址、身份证号等&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;bool isEmail=&#34;337845818@qq.com&#34;.MatchEmail(); // 可在appsetting.json中添加EmailDomainWhiteList和EmailDomainBlockList配置邮箱域名黑白名单，逗号分隔，如&#34;EmailDomainBlockList&#34;: &#34;^\\w{1,5}@qq.com,^\\w{1,5}@163.com,^\\w{1,5}@gmail.com,^\\w{1,5}@outlook.com&#34;,&#xA;bool isInetAddress = &#34;114.114.114.114&#34;.MatchInetAddress();&#xA;bool isUrl = &#34;http://ldqk.org/20/history&#34;.MatchUrl();&#xA;bool isPhoneNumber = &#34;15205201520&#34;.MatchPhoneNumber();&#xA;bool isIdentifyCard = &#34;312000199502230660&#34;.MatchIdentifyCard();// 校验中国大陆身份证号&#xA;bool isCNPatentNumber = &#34;200410018477.9&#34;.MatchCNPatentNumber(); // 校验中国专利申请号或专利号，是否带校验位，校验位前是否带“.”，都可以校验，待校验的号码前不要带CN、ZL字样的前缀&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2.硬件监测(仅支持Windows)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;float load = SystemInfo.CpuLoad;// 获取CPU占用率&#xA;long physicalMemory = SystemInfo.PhysicalMemory;// 获取物理内存总数&#xA;long memoryAvailable = SystemInfo.MemoryAvailable;// 获取物理内存可用率&#xA;double freePhysicalMemory = SystemInfo.GetFreePhysicalMemory();// 获取可用物理内存&#xA;double temperature = SystemInfo.GetCPUTemperature();// 获取CPU温度&#xA;int cpuCount = SystemInfo.GetCpuCount();// 获取CPU核心数&#xA;IList&amp;lt;string&amp;gt; ipAddress = SystemInfo.GetIPAddress();// 获取本机所有IP地址&#xA;string localUsedIp = SystemInfo.GetLocalUsedIP();// 获取本机当前正在使用的IP地址&#xA;IList&amp;lt;string&amp;gt; macAddress = SystemInfo.GetMacAddress();// 获取本机所有网卡mac地址&#xA;string osVersion = SystemInfo.GetOsVersion();// 获取操作系统版本&#xA;RamInfo ramInfo = SystemInfo.GetRamInfo();// 获取内存信息&#xA;var cpuSN=SystemInfo.GetCpuInfo()[0].SerialNumber; // CPU序列号&#xA;var driveSN=SystemInfo.GetDiskInfo()[0].SerialNumber; // 硬盘序列号&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3.大文件操作&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;FileStream fs = new FileStream(@&#34;D:\boot.vmdk&#34;, FileMode.OpenOrCreate, FileAccess.ReadWrite);&#xA;{&#xA;        //fs.CopyToFile(@&#34;D:\1.bak&#34;);//同步复制大文件&#xA;        fs.CopyToFileAsync(@&#34;D:\1.bak&#34;);//异步复制大文件&#xA;        string md5 = fs.GetFileMD5Async().Result;//异步获取文件的MD5&#xA;        string sha1 = fs.GetFileSha1();//异步获取文件的SHA1&#xA;}&#xA;memoryStream.SaveFile(&#34;filename&#34;); // 将内存流转储成文件&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.html的防XSS处理：&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;string html = @&#34;&amp;lt;link href=&#39;/Content/font-awesome/css&#39; rel=&#39;stylesheet&#39;/&amp;gt;&#xA;        &amp;lt;!--[if IE 7]&amp;gt;&#xA;        &amp;lt;link href=&#39;/Content/font-awesome-ie7.min.css&#39; rel=&#39;stylesheet&#39;/&amp;gt;&#xA;        &amp;lt;![endif]--&amp;gt;&#xA;        &amp;lt;script src=&#39;/Scripts/modernizr&#39;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;div id=&#39;searchBox&#39; role=&#39;search&#39;&amp;gt;&#xA;        &amp;lt;form action=&#39;/packages&#39; method=&#39;get&#39;&amp;gt;&#xA;        &amp;lt;span class=&#39;user-actions&#39;&amp;gt;&amp;lt;a href=&#39;/users/account/LogOff&#39;&amp;gt;退出&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;input name=&#39;q&#39; id=&#39;searchBoxInput&#39;/&amp;gt;&#xA;        &amp;lt;input id=&#39;searchBoxSubmit&#39; type=&#39;submit&#39; value=&#39;Submit&#39; /&amp;gt;&#xA;        &amp;lt;/form&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#34;;&#xA;string s = html.HtmlSantinizerStandard();//清理后：&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;a href=&#34;/users/account/LogOff&#34;&amp;gt;退出&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;5.整理Windows系统的内存：&lt;/h3&gt; &#xA;&lt;p&gt;类似于各大系统优化软件的加速球功能&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Windows.ClearMemorySilent();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;6.任意进制转换&lt;/h3&gt; &#xA;&lt;p&gt;可用于生成短id，短hash，随机字符串等操作，纯数学运算。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;NumberFormater nf = new NumberFormater(36);//内置2-62进制的转换&#xA;//NumberFormater nf = new NumberFormater(&#34;0123456789abcdefghijklmnopqrstuvwxyz&#34;);// 自定义进制字符，可用于生成验证码&#xA;string s36 = nf.ToString(12345678);&#xA;long num = nf.FromString(&#34;7clzi&#34;);&#xA;Console.WriteLine(&#34;12345678的36进制是：&#34; + s36); // 7clzi&#xA;Console.WriteLine(&#34;36进制的7clzi是：&#34; + num); // 12345678&#xA;var s = new NumberFormater(62).ToString(new Random().Next(100000, int.MaxValue)); //配合随机数生成随机字符串&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;//扩展方法形式调用&#xA;var bin=12345678.ToBinary(36);//7clzi&#xA;var num=&#34;7clzi&#34;.FromBinary(36);//12345678&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;//超大数字的进制转换&#xA;var num = &#34;E6186159D38CD50E0463A55E596336BD&#34;.FromBinaryBig(16);&#xA;Console.WriteLine(num); // 十进制：305849028665645097422198928560410015421&#xA;Console.WriteLine(num.ToBinary(64)); // 64进制：3C665pQUPl3whzFlVpoPqZ，22位长度&#xA;Console.WriteLine(num.ToBinary(36)); // 36进制：dmed4dkd5bhcg4qdktklun0zh，25位长度&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;7.纳秒级性能计时器&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;HiPerfTimer timer = HiPerfTimer.StartNew();&#xA;for (int i = 0; i &amp;lt; 100000; i++)&#xA;{&#xA;    //todo&#xA;}&#xA;timer.Stop();&#xA;Console.WriteLine(&#34;执行for循环100000次耗时&#34;+timer.Duration+&#34;s&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;double time = HiPerfTimer.Execute(() =&amp;gt;&#xA;{&#xA;    for (int i = 0; i &amp;lt; 100000; i++)&#xA;    {&#xA;        //todo&#xA;    }&#xA;});&#xA;Console.WriteLine(&#34;执行for循环100000次耗时&#34;+time+&#34;s&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;8.单机产生唯一有序的短id&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var token=Stopwatch.GetTimestamp().ToBinary(36);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var set = new HashSet&amp;lt;string&amp;gt;();&#xA;double time = HiPerfTimer.Execute(() =&amp;gt;&#xA;{&#xA;    for (int i = 0; i &amp;lt; 1000000; i++)&#xA;    {&#xA;        set.Add(Stopwatch.GetTimestamp().ToBinary(36));&#xA;    }&#xA;});&#xA;Console.WriteLine(set.Count==1000000);//True&#xA;Console.WriteLine(&#34;产生100w个id耗时&#34;+time+&#34;s&#34;);//1.6639039s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;9.产生分布式唯一有序短id&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var sf = SnowFlake.GetInstance();&#xA;string token = sf.GetUniqueId();// rcofqodori0w&#xA;string shortId = sf.GetUniqueShortId(8);// qodw9728&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var set = new HashSet&amp;lt;string&amp;gt;();&#xA;double time = HiPerfTimer.Execute(() =&amp;gt;&#xA;{&#xA;    for (int i = 0; i &amp;lt; 1000000; i++)&#xA;    {&#xA;        set.Add(SnowFlake.GetInstance().GetUniqueId());&#xA;    }&#xA;});&#xA;Console.WriteLine(set.Count == 1000000); //True&#xA;Console.WriteLine(&#34;产生100w个id耗时&#34; + time + &#34;s&#34;); //2.6891495s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;10.农历转换&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;ChineseCalendar.CustomHolidays.Add(DateTime.Parse(&#34;2018-12-31&#34;),&#34;元旦节&#34;);//自定义节假日&#xA;ChineseCalendar today = new ChineseCalendar(DateTime.Parse(&#34;2018-12-31&#34;));&#xA;Console.WriteLine(today.ChineseDateString);// 二零一八年十一月廿五&#xA;Console.WriteLine(today.AnimalString);// 生肖：狗&#xA;Console.WriteLine(today.GanZhiDateString);// 干支：戊戌年甲子月丁酉日&#xA;Console.WriteLine(today.DateHoliday);// 获取按公历计算的节假日&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;11.Linq表达式树扩展&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Expression&amp;lt;Func&amp;lt;string, bool&amp;gt;&amp;gt; where1 = s =&amp;gt; s.StartsWith(&#34;a&#34;);&#xA;Expression&amp;lt;Func&amp;lt;string, bool&amp;gt;&amp;gt; where2 = s =&amp;gt; s.Length &amp;gt; 10;&#xA;Func&amp;lt;string, bool&amp;gt; func = where1.And(where2).Compile();&#xA;bool b=func(&#34;abcd12345678&#34;);//true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Expression&amp;lt;Func&amp;lt;string, bool&amp;gt;&amp;gt; where1 = s =&amp;gt; s.StartsWith(&#34;a&#34;);&#xA;Expression&amp;lt;Func&amp;lt;string, bool&amp;gt;&amp;gt; where2 = s =&amp;gt; s.Length &amp;gt; 10;&#xA;Func&amp;lt;string, bool&amp;gt; func = where1.Or(where2).Compile();&#xA;bool b=func(&#34;abc&#34;);// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;12.模版引擎&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var tmp = new Template(&#34;{{name}}，你好！&#34;);&#xA;tmp.Set(&#34;name&#34;, &#34;万金油&#34;);&#xA;string s = tmp.Render();//万金油，你好！&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var tmp = new Template(&#34;{{one}},{{two}},{{three}}&#34;);&#xA;string s = tmp.Set(&#34;one&#34;, &#34;1&#34;).Set(&#34;two&#34;, &#34;2&#34;).Set(&#34;three&#34;, &#34;3&#34;).Render();// 1,2,3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var tmp = new Template(&#34;{{name}}，{{greet}}！&#34;);&#xA;tmp.Set(&#34;name&#34;, &#34;万金油&#34;);&#xA;string s = tmp.Render();// throw 模版变量{{greet}}未被使用&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;13.List转Datatable&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var list = new List&amp;lt;MyClass&amp;gt;()&#xA;{&#xA;    new MyClass()&#xA;    {&#xA;        Name = &#34;张三&#34;,&#xA;        Age = 22&#xA;    },&#xA;    new MyClass()&#xA;    {&#xA;        Name = &#34;李四&#34;,&#xA;        Age = 21&#xA;    },&#xA;    new MyClass()&#xA;    {&#xA;        Name = &#34;王五&#34;,&#xA;        Age = 28&#xA;    }&#xA;};&#xA;var table = list.Select(c =&amp;gt; new{姓名=c.Name,年龄=c.Age}).ToDataTable();// 将自动填充列姓名和年龄&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;14.文件压缩解压&lt;/h3&gt; &#xA;&lt;p&gt;.NET Framework&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;MemoryStream ms = SevenZipCompressor.ZipStream(new List&amp;lt;string&amp;gt;()&#xA;{&#xA;    @&#34;D:\1.txt&#34;,&#xA;    &#34;http://ww3.sinaimg.cn/large/87c01ec7gy1fsq6rywto2j20je0d3td0.jpg&#34;,&#xA;});//压缩成内存流&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;SevenZipCompressor.Zip(new List&amp;lt;string&amp;gt;()&#xA;{&#xA;    @&#34;D:\1.txt&#34;,&#xA;    &#34;http://ww3.sinaimg.cn/large/87c01ec7gy1fsq6rywto2j20je0d3td0.jpg&#34;,&#xA;}, zip);//压缩成zip&#xA;SevenZipCompressor.UnRar(@&#34;D:\Download\test.rar&#34;, @&#34;D:\Download\&#34;);//解压rar&#xA;SevenZipCompressor.Decompress(@&#34;D:\Download\test.tar&#34;, @&#34;D:\Download\&#34;);//自动识别解压压缩包&#xA;SevenZipCompressor.Decompress(@&#34;D:\Download\test.7z&#34;, @&#34;D:\Download\&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ASP.NET Core&lt;/p&gt; &#xA;&lt;p&gt;Startup.cs&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;services.AddSevenZipCompressor();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;构造函数注入ISevenZipCompressor&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private readonly ISevenZipCompressor _sevenZipCompressor;&#xA;public Test(ISevenZipCompressor sevenZipCompressor)&#xA;{&#xA;    _sevenZipCompressor = sevenZipCompressor;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;使用方式同.NET Framework版本&lt;/p&gt; &#xA;&lt;h3&gt;15.日志组件&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;LogManager.LogDirectory=AppDomain.CurrentDomain.BaseDirectory+&#34;/logs&#34;;&#xA;LogManager.Event+=info =&amp;gt;&#xA;{&#xA;    //todo:注册一些事件操作&#xA;};&#xA;LogManager.Info(&#34;记录一次消息&#34;);&#xA;LogManager.Error(new Exception(&#34;异常消息&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;16.FTP客户端&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;FtpClient ftpClient = FtpClient.GetAnonymousClient(&#34;192.168.2.2&#34;);//创建一个匿名访问的客户端&#xA;//FtpClient ftpClient = FtpClient.GetClient(&#34;192.168.2.3&#34;,&#34;admin&#34;,&#34;123456&#34;);// 创建一个带用户名密码的客户端&#xA;ftpClient.Delete(&#34;/1.txt&#34;);// 删除文件&#xA;ftpClient.Download(&#34;/test/2.txt&#34;,&#34;D:\\test\\2.txt&#34;);// 下载文件&#xA;ftpClient.UploadFile(&#34;/test/22.txt&#34;,&#34;D:\\test\\22.txt&#34;,(sum, progress) =&amp;gt;&#xA;{&#xA;    Console.WriteLine(&#34;已上传：&#34;+progress*1.0/sum);&#xA;});//上传文件并检测进度&#xA;List&amp;lt;string&amp;gt; files = ftpClient.GetFiles(&#34;/&#34;);//列出ftp服务端文件列表&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;17.多线程后台下载&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var mtd = new MultiThreadDownloader(&#34;https://attachments-cdn.shimo.im/yXwC4kphjVQu06rH/KeyShot_Pro_7.3.37.7z&#34;,Environment.GetEnvironmentVariable(&#34;temp&#34;),&#34;E:\\Downloads\\KeyShot_Pro_7.3.37.7z&#34;,8);&#xA;mtd.Configure(req =&amp;gt;&#xA; {&#xA;     req.Referer = &#34;https://masuit.com&#34;;&#xA;     req.Headers.Add(&#34;Origin&#34;, &#34;https://baidu.com&#34;);&#xA;});&#xA;mtd.TotalProgressChanged+=(sender, e) =&amp;gt;&#xA;{&#xA;    var downloader = sender as MultiThreadDownloader;&#xA;    Console.WriteLine(&#34;下载进度：&#34;+downloader.TotalProgress+&#34;%&#34;);&#xA;    Console.WriteLine(&#34;下载速度：&#34;+downloader.TotalSpeedInBytes/1024/1024+&#34;MBps&#34;);&#xA;};&#xA;mtd.FileMergeProgressChanged+=(sender, e) =&amp;gt;&#xA;{&#xA;    Console.WriteLine(&#34;下载完成&#34;);&#xA;};&#xA;mtd.FileMergedComplete+=(sender,e)=&amp;gt;{&#xA;    Console.WriteLine(&#34;文件合并完成&#34;);&#xA;};&#xA;mtd.Start();//开始下载&#xA;//mtd.Pause(); // 暂停下载&#xA;//mtd.Resume(); // 继续下载&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;18.Socket客户端操作类&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var tcpClient = new TcpClient(AddressFamily.InterNetwork);&#xA;Socket socket = tcpClient.ConnectSocket(IPAddress.Any,5000);&#xA;socket.SendFile(&#34;D:\\test\\1.txt&#34;,false,i =&amp;gt;&#xA;{&#xA;    Console.WriteLine(&#34;已发送&#34;+i+&#34;%&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;19.加密解密&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var enc=&#34;123456&#34;.MDString();// MD5&#xA;var enc=&#34;123456&#34;.MDString(&#34;abc&#34;);// MD5加盐&#xA;var enc=&#34;123456&#34;.MDString2();// MD5两次&#xA;var enc=&#34;123456&#34;.MDString2(&#34;abc&#34;);// MD5两次加盐&#xA;var enc=&#34;123456&#34;.MDString3();// MD5三次&#xA;var enc=&#34;123456&#34;.MDString3(&#34;abc&#34;);// MD5三次加盐&#xA;&#xA;string aes = &#34;123456&#34;.AESEncrypt();// AES加密为密文&#xA;string s = aes.AESDecrypt(); //AES解密为明文&#xA;string aes = &#34;123456&#34;.AESEncrypt(&#34;abc&#34;);// AES密钥加密为密文&#xA;string s = aes.AESDecrypt(&#34;abc&#34;); //AES密钥解密为明文&#xA;&#xA;string enc = &#34;123456&#34;.DesEncrypt();// DES加密为密文&#xA;string s = enc.DesDecrypt(); //DES解密为明文&#xA;string enc = &#34;123456&#34;.DesEncrypt(&#34;abcdefgh&#34;);// DES密钥加密为密文&#xA;string s = enc.DesDecrypt(&#34;abcdefgh&#34;); //DES密钥解密为明文&#xA;&#xA;RsaKey rsaKey = RsaCrypt.GenerateRsaKeys();// 生成RSA密钥对&#xA;string encrypt = &#34;123456&#34;.RSAEncrypt(rsaKey.PublicKey);// 公钥加密&#xA;string s = encrypt.RSADecrypt(rsaKey.PrivateKey);// 私钥解密&#xA;&#xA;string s = &#34;123&#34;.Crc32();// 生成crc32摘要&#xA;string s = &#34;123&#34;.Crc64();// 生成crc64摘要&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;20.实体校验&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass&#xA;{&#xA;    [IsEmail] //可在appsetting.json中添加EmailDomainWhiteList配置邮箱域名白名单，逗号分隔&#xA;    public string Email { get; set; }&#xA;&#xA;    [IsPhone]&#xA;    public string PhoneNumber { get; set; }&#xA;&#xA;    [IsIPAddress]&#xA;    public string IP { get; set; }&#xA;&#xA;    [MinValue(0, ErrorMessage = &#34;年龄最小为0岁&#34;), MaxValue(100, ErrorMessage = &#34;年龄最大100岁&#34;)]&#xA;    public int Age { get; set; }&#xA;&#xA;    [ComplexPassword]//密码复杂度校验&#xA;    public string Password { get; set; }&#xA;    &#xA;    [EnumOf] // 检测是否是有效枚举值&#xA;    public MyEnum MyEnum { get; set; }&#xA;    &#xA;    [MinItemsCount(1)] // 检测集合元素最少1个&#xA;    public List&amp;lt;string&amp;gt; Strs { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;21.HTML操作&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;List&amp;lt;string&amp;gt; srcs = &#34;html&#34;.MatchImgSrcs().ToList();// 获取html字符串里所有的img标签的src属性&#xA;var imgTags = &#34;html&#34;.MatchImgTags();//获取html字符串里的所有的img标签&#xA;var str=&#34;html&#34;.RemoveHtmlTag(); // 去除html标签&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;22.DateTime扩展&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;double milliseconds = DateTime.Now.GetTotalMilliseconds();// 获取毫秒级时间戳&#xA;double microseconds = DateTime.Now.GetTotalMicroseconds();// 获取微秒级时间戳&#xA;double nanoseconds = DateTime.Now.GetTotalNanoseconds();// 获取纳秒级时间戳&#xA;double seconds = DateTime.Now.GetTotalSeconds();// 获取秒级时间戳&#xA;double minutes = DateTime.Now.GetTotalMinutes();// 获取分钟级时间戳&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;23.IP地址和URL&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;bool inRange = &#34;192.168.2.2&#34;.IpAddressInRange(&#34;192.168.1.1&#34;,&#34;192.168.3.255&#34;);// 判断IP地址是否在这个地址段里&#xA;bool isPrivateIp = &#34;172.16.23.25&#34;.IsPrivateIP();// 判断是否是私有地址&#xA;bool isExternalAddress = &#34;http://baidu.com&#34;.IsExternalAddress();// 判断是否是外网的URL&#xA;&#xA;//以下需要配置baiduAK&#xA;string isp = &#34;114.114.114.114&#34;.GetISP(); // 获取ISP运营商信息&#xA;PhysicsAddress physicsAddress = &#34;114.114.114.114&#34;.GetPhysicsAddressInfo().Result;// 获取详细地理信息对象&#xA;Tuple&amp;lt;string, List&amp;lt;string&amp;gt;&amp;gt; ipAddressInfo = &#34;114.114.114.114&#34;.GetIPAddressInfo().Result;// 获取详细地理信息集合&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;24.元素去重&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var list = new List&amp;lt;MyClass&amp;gt;()&#xA;{&#xA;    new MyClass()&#xA;    {&#xA;        Email = &#34;1@1.cn&#34;&#xA;    },&#xA;    new MyClass()&#xA;    {&#xA;        Email = &#34;1@1.cn&#34;&#xA;    },&#xA;    new MyClass()&#xA;    {&#xA;        Email = &#34;1@1.cn&#34;&#xA;    }&#xA;};&#xA;List&amp;lt;MyClass&amp;gt; classes = list.DistinctBy(c =&amp;gt; c.Email).ToList();&#xA;Console.WriteLine(classes.Count==1);//True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;25.枚举扩展&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public enum MyEnum&#xA;{&#xA;    [Display(Name = &#34;读&#34;)]&#xA;    [Description(&#34;读&#34;)]&#xA;    Read,&#xA;    &#xA;    [Display(Name = &#34;写&#34;)]&#xA;    [Description(&#34;写&#34;)]&#xA;    Write&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Dictionary&amp;lt;int, string&amp;gt; dic1 = typeof(MyEnum).GetDictionary();// 获取枚举值和字符串表示的字典映射&#xA;var dic2 = typeof(MyEnum).GetDescriptionAndValue();// 获取字符串表示和枚举值的字典映射&#xA;string desc = MyEnum.Read.GetDescription();// 获取Description标签&#xA;string display = MyEnum.Read.GetDisplay();// 获取Display标签的Name属性&#xA;var value = typeof(MyEnum).GetValue(&#34;Read&#34;);//获取字符串表示值对应的枚举值&#xA;string enumString = 0.ToEnumString(typeof(MyEnum));// 获取枚举值对应的字符串表示&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;26.定长队列和ConcurrentHashSet实现&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;如果是.NET5及以上，推荐使用框架自带的Channel实现该功能&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;LimitedQueue&amp;lt;string&amp;gt; queue = new LimitedQueue&amp;lt;string&amp;gt;(32);// 声明一个容量为32个元素的定长队列&#xA;ConcurrentLimitedQueue&amp;lt;string&amp;gt; queue = new ConcurrentLimitedQueue&amp;lt;string&amp;gt;(32);// 声明一个容量为32个元素的线程安全的定长队列&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var set = new ConcurrentHashSet&amp;lt;string&amp;gt;(); // 用法和hashset保持一致&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;27.反射操作&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;MyClass myClass = new MyClass();&#xA;PropertyInfo[] properties = myClass.GetProperties();// 获取属性列表&#xA;myClass.SetProperty(&#34;Email&#34;,&#34;1@1.cn&#34;);//给对象设置值&#xA;myClass.DeepClone(); // 对象深拷贝，带嵌套层级的&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;28.获取线程内唯一对象&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;CallContext&amp;lt;T&amp;gt;.SetData(&#34;db&#34;,dbContext);//设置线程内唯一对象&#xA;CallContext&amp;lt;T&amp;gt;.GetData(&#34;db&#34;);//获取线程内唯一对象&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;29.asp.net core 获取静态的HttpContext对象&lt;/h3&gt; &#xA;&lt;p&gt;Startup.cs&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void ConfigureServices(IServiceCollection services)&#xA;{&#xA;    // ...&#xA;    services.AddStaticHttpContext();&#xA;    // ...&#xA;}&#xA;&#xA;public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#xA;{&#xA;    // ...&#xA;    app.UseStaticHttpContext();&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public async Task&amp;lt;IActionResult&amp;gt; Index()&#xA;{&#xA;    HttpContext context = HttpContext2.Current;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;30.邮件发送&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;new Email()&#xA;{&#xA;    SmtpServer = &#34;smtp.masuit.com&#34;,// SMTP服务器&#xA;    SmtpPort = 25, // SMTP服务器端口&#xA;    EnableSsl = true,//使用SSL&#xA;    Username = &#34;admin@masuit.com&#34;,// 邮箱用户名&#xA;    Password = &#34;123456&#34;,// 邮箱密码&#xA;    Tos = &#34;10000@qq.com,10001@qq.com&#34;, //收件人&#xA;    Subject = &#34;测试邮件&#34;,//邮件标题&#xA;    Body = &#34;你好啊&#34;,//邮件内容&#xA;}.SendAsync(s =&amp;gt;&#xA;{&#xA;    Console.WriteLine(s);// 发送成功后的回调&#xA;});// 异步发送邮件&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;31.图像的简单处理&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;ImageUtilities.CompressImage(@&#34;F:\src\1.jpg&#34;, @&#34;F:\dest\2.jpg&#34;);//无损压缩图片&#xA;&#xA;&#34;base64&#34;.SaveDataUriAsImageFile();// 将Base64编码转换成图片&#xA;&#xA;Image image = Image.FromFile(@&#34;D:\1.jpg&#34;);&#xA;image.MakeThumbnail(@&#34;D:\2.jpg&#34;, 120, 80, ThumbnailCutMode.LockWidth);//生成缩略图&#xA;&#xA;Bitmap bmp = new Bitmap(@&#34;D:\1.jpg&#34;);&#xA;Bitmap newBmp = bmp.BWPic(bmp.Width, bmp.Height);//转换成黑白&#xA;Bitmap newBmp = bmp.CutAndResize(new Rectangle(0, 0, 1600, 900), 160, 90);//裁剪并缩放&#xA;bmp.RevPicLR(bmp.Width, bmp.Height);//左右镜像&#xA;bmp.RevPicUD(bmp.Width, bmp.Height);//上下镜像&#xA;&#xA;var marker=ImageWatermarker(stream);&#xA;stream=maker.AddWatermark(&#34;水印文字&#34;,&#34;字体文件&#34;,字体大小,color,水印位置,边距); // 给图片添加水印&#xA;stream=maker.AddWatermark(水印图片,水印位置,边距,字体大小,字体); // 给图片添加水印&#xA;&#xA;// 图像相似度对比&#xA;var hasher = new ImageHasher();&#xA;var hash1 = hasher.DifferenceHash256(&#34;图片1&#34;); // 使用差分哈希算法计算图像的256位哈希&#xA;var hash2 = hasher.DifferenceHash256(&#34;图片2&#34;); // 使用差分哈希算法计算图像的256位哈希&#xA;//var hash1 = hasher.AverageHash64(&#34;图片1&#34;); // 使用平均值算法计算图像的64位哈希&#xA;//var hash2 = hasher.AverageHash64(&#34;图片2&#34;); // 使用平均值算法计算图像的64位哈希&#xA;//var hash1 = hasher.DctHash(&#34;图片1&#34;); // 使用DCT算法计算图像的64位哈希&#xA;//var hash2 = hasher.DctHash(&#34;图片2&#34;); // 使用DCT算法计算图像的64位哈希&#xA;//var hash1 = hasher.MedianHash64(&#34;图片1&#34;); // 使用中值算法计算给定图像的64位哈希&#xA;//var hash2 = hasher.MedianHash64(&#34;图片2&#34;); // 使用中值算法计算给定图像的64位哈希&#xA;var sim=ImageHasher.Compare(hash1,hash2); // 图片的相似度，范围：[0,1]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;32.随机数&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Random rnd = new Random();&#xA;int num = rnd.StrictNext();//产生真随机数&#xA;double gauss = rnd.NextGauss(20,5);//产生正态高斯分布的随机数&#xA;var s = new NumberFormater(62).ToString(new Random().Next(100000, int.MaxValue));//生成随机字符串&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;33.权重筛选功能&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var data=new List&amp;lt;WeightedItem&amp;lt;string&amp;gt;&amp;gt;()&#xA;{&#xA;     new WeightedItem&amp;lt;string&amp;gt;(&#34;A&#34;, 1),&#xA;     new WeightedItem&amp;lt;string&amp;gt;(&#34;B&#34;, 3),&#xA;     new WeightedItem&amp;lt;string&amp;gt;(&#34;C&#34;, 4),&#xA;     new WeightedItem&amp;lt;string&amp;gt;(&#34;D&#34;, 4),&#xA;};&#xA;var item=data.WeightedItem();//按权重选出1个元素&#xA;var list=data.WeightedItems(2);//按权重选出2个元素&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var selector = new WeightedSelector&amp;lt;string&amp;gt;(new List&amp;lt;WeightedItem&amp;lt;string&amp;gt;&amp;gt;()&#xA;{&#xA;    new WeightedItem&amp;lt;string&amp;gt;(&#34;A&#34;, 1),&#xA;    new WeightedItem&amp;lt;string&amp;gt;(&#34;B&#34;, 3),&#xA;    new WeightedItem&amp;lt;string&amp;gt;(&#34;C&#34;, 4),&#xA;    new WeightedItem&amp;lt;string&amp;gt;(&#34;D&#34;, 4),&#xA;});&#xA;var item = selector.Select();//按权重选出1个元素&#xA;var list = selector.SelectMultiple(3);//按权重选出3个元素&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;34.EF Core支持AddOrUpdate方法&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;/// &amp;lt;summary&amp;gt;&#xA;/// 按Id添加或更新文章实体&#xA;/// &amp;lt;/summary&amp;gt;&#xA;public override Post SavePost(Post t)&#xA;{&#xA;    DataContext.Set&amp;lt;Post&amp;gt;().AddOrUpdate(t =&amp;gt; t.Id, t);&#xA;    return t;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;35.敏感信息掩码&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;&#34;13123456789&#34;.Mask(); // 131****5678&#xA;&#34;admin@masuit.com&#34;.MaskEmail(); // a****n@masuit.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;36.集合扩展&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var list = new List&amp;lt;string&amp;gt;()&#xA;{&#xA;    &#34;1&#34;,&#34;3&#34;,&#34;3&#34;,&#34;3&#34;&#xA;};&#xA;list.AddRangeIf(s =&amp;gt; s.Length &amp;gt; 1, &#34;1&#34;, &#34;11&#34;); // 将被添加元素中的长度大于1的元素添加到list&#xA;list.AddRangeIfNotContains(&#34;1&#34;, &#34;11&#34;); // 将被添加元素中不包含的元素添加到list&#xA;list.RemoveWhere(s =&amp;gt; s.Length&amp;lt;1); // 将集合中长度小于1的元素移除&#xA;list.InsertAfter(0, &#34;2&#34;); // 在第一个元素之后插入&#xA;list.InsertAfter(s =&amp;gt; s == &#34;1&#34;, &#34;2&#34;); // 在元素&#34;1&#34;后插入&#xA;var dic = list.ToDictionarySafety(s =&amp;gt; s); // 安全的转换成字典类型，当键重复时只添加一个键&#xA;var dic = list.ToConcurrentDictionary(s =&amp;gt; s); // 转换成并发字典类型，当键重复时只添加一个键&#xA;var dic = list.ToDictionarySafety(s =&amp;gt; s, s =&amp;gt; s.GetHashCode()); // 安全的转换成字典类型，当键重复时只添加一个键&#xA;dic.AddOrUpdate(&#34;4&#34;, 4); // 添加或更新键值对&#xA;dic.AddOrUpdate(new Dictionary&amp;lt;string, int&amp;gt;()&#xA;{&#xA;    [&#34;5&#34;] = 5,[&#34;55&#34;]=555&#xA;}); // 批量添加或更新键值对&#xA;dic.AddOrUpdate(&#34;5&#34;, 6, (s, i) =&amp;gt; 66); // 如果是添加，则值为6，若更新则值为66&#xA;dic.AddOrUpdate(&#34;5&#34;, 6, 666); // 如果是添加，则值为6，若更新则值为666&#xA;dic.GetOrAdd(&#34;7&#34;,77); // 字典获取或添加元素&#xA;dic.GetOrAdd(&#34;7&#34;,()=&amp;gt;77); // 字典获取或添加元素&#xA;dic.AsConcurrentDictionary(); // 普通字典转换成并发字典集合&#xA;var table=list.ToDataTable(); // 转换成DataTable类型&#xA;table.AddIdentityColumn(); //给DataTable增加一个自增列&#xA;table.HasRows(); // 检查DataTable 是否有数据行&#xA;table.ToList&amp;lt;T&amp;gt;(); // datatable转List&#xA;var set = list.ToHashSet(s=&amp;gt;s.Name);// 转HashSet&#xA;var cts = new CancellationTokenSource(100); //取消口令&#xA;await list.ForeachAsync(async i=&amp;gt;{&#xA;    await Task.Delay(100);&#xA;    Console.WriteLine(i);&#xA;},cts.Token); // 异步foreach&#xA;&#xA;await list.ForAsync(async (item,index)=&amp;gt;{&#xA;    await Task.Delay(100);&#xA;    Console.WriteLine(item+&#34;_&#34;+index);&#xA;},cts.Token); // 异步for，带索引编号&#xA;await list.SelectAsync(async i=&amp;gt;{&#xA;    await Task.Delay(100);&#xA;    return i*10;&#xA;}); // 异步Select&#xA;await list.SelectAsync(async (item,index)=&amp;gt;{&#xA;    await Task.Delay(100);&#xA;    return item*10;&#xA;}); // 异步Select，带索引编号&#xA;string s=list.Join(&#34;,&#34;);//将字符串集合连接成逗号分隔的单字符串&#xA;var max=list.MaxOrDefault(); // 取最大值，当集合为空的时候不会报错&#xA;var max=list.MaxOrDefault(selector); // 取最大值，当集合为空的时候不会报错&#xA;var max=list.MaxOrDefault(selector,default); // 取最大值，当集合为空的时候不会报错&#xA;var max=list.MinOrDefault(); // 取最小值，当集合为空的时候不会报错&#xA;var max=list.MinOrDefault(selector); // 取最小值，当集合为空的时候不会报错&#xA;var max=list.MinOrDefault(selector,default); // 取最小值，当集合为空的时候不会报错&#xA;var stdDev=list.Select(s=&amp;gt;s.ConvertTo&amp;lt;int&amp;gt;()).StandardDeviation(); // 求标准差&#xA;&#xA;var pages=queryable.ToPagedList(1,10); // 分页查询&#xA;var pages=await queryable.ToPagedListAsync(1,10); // 分页查询&#xA;&#xA;var nums=Enumerable.Range(1, 10).ExceptBy(Enumerable.Range(5, 10), i =&amp;gt; i); // 按字段取差集&#xA;var nums=Enumerable.Range(1, 10).IntersectBy(Enumerable.Range(5, 10), i =&amp;gt; i); // 按字段取交集&#xA;var nums=Enumerable.Range(1, 10).SequenceEqual(Enumerable.Range(5, 10), i =&amp;gt; i); // 判断序列相等&#xA;var nums=Enumerable.Range(1, 10).OrderByRandom(); // 随机排序&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;37.Mime类型&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var mimeMapper = new MimeMapper();&#xA;var mime = mimeMapper.GetExtensionFromMime(&#34;image/jpeg&#34;); // .jpg&#xA;var ext = mimeMapper.GetMimeFromExtension(&#34;.jpg&#34;); // image/jpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;38.日期时间扩展&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;DateTime.Now.GetTotalSeconds(); // 获取该时间相对于1970-01-01 00:00:00的秒数&#xA;DateTime.Now.GetTotalMilliseconds(); // 获取该时间相对于1970-01-01 00:00:00的毫秒数&#xA;DateTime.Now.GetTotalMicroseconds(); // 获取该时间相对于1970-01-01 00:00:00的微秒数&#xA;DateTime.Now.GetTotalNanoseconds(); // 获取该时间相对于1970-01-01 00:00:00的纳秒数&#xA;var indate=DateTime.Parse(&#34;2020-8-3&#34;).In(DateTime.Parse(&#34;2020-8-2&#34;),DateTime.Parse(&#34;2020-8-4&#34;));//true&#xA;DateTime time=&#34;2021-1-1 8:00:00&#34;.ToDateTime(); //字符串转DateTime&#xA;&#xA;//时间段计算工具&#xA;var range = new DateTimeRange(DateTime.Parse(&#34;2020-8-3&#34;), DateTime.Parse(&#34;2020-8-5&#34;));&#xA;range.Union(DateTime.Parse(&#34;2020-8-4&#34;), DateTime.Parse(&#34;2020-8-6&#34;)); //连接两个时间段，结果：2020-8-3~2020-8-6&#xA;range.In(DateTime.Parse(&#34;2020-8-3&#34;), DateTime.Parse(&#34;2020-8-6&#34;));//判断是否在某个时间段内，true&#xA;var (intersected,range2) = range.Intersect(DateTime.Parse(&#34;2020-8-4&#34;), DateTime.Parse(&#34;2020-8-6&#34;));//两个时间段是否相交，(true,2020-8-3~2020-8-4)&#xA;range.Contains(DateTime.Parse(&#34;2020-8-3&#34;), DateTime.Parse(&#34;2020-8-4&#34;));//判断是否包含某个时间段，true&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;39.流转换&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;stream.SaveAsMemoryStream(); // 任意流转换成内存流&#xA;stream.ToArray(); // 任意流转换成二进制数组&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;40.数值转换&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;1.2345678901.Digits8(); // 将小数截断为8位&#xA;1.23.ConvertTo&amp;lt;int&amp;gt;(); // 小数转int&#xA;1.23.ConvertTo&amp;lt;T&amp;gt;(); // 小数转T基本类型&#xA;bool b=1.23.TryConvertTo&amp;lt;T&amp;gt;(out result); // 小数转T基本类型&#xA;var num=1.2345.ToDecimal(2); //转decimal并保留两位小数&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;41.简繁转换&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var str=&#34;个体&#34;.ToTraditional(); // 转繁体&#xA;var str=&#34;個體&#34;.ToSimplified(); // 转简体&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;42.INI配置文件操作&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;INIFile ini=new INIFile(&#34;filename.ini&#34;);&#xA;ini.IniWriteValue(section,key,value); // 写值&#xA;ini.IniReadValue(section,key); // 读值&#xA;ini.ClearAllSection(); // 清空所有配置节&#xA;ini.ClearSection(section); // 清空配置节&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;43.雷达图计算引擎&lt;/h3&gt; &#xA;&lt;p&gt;应用场景：计算两个多边形的相似度，用户画像之类的&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var points=RadarChartEngine.ComputeIntersection(chart1,chart2); //获取两个多边形的相交区域&#xA;points.ComputeArea(); //计算多边形面积&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;44.树形结构实现&lt;/h3&gt; &#xA;&lt;p&gt;基本接口类：&lt;br&gt; ITreeChildren：带Children属性的接口&lt;br&gt; ITreeParent：带Parent属性的接口&lt;br&gt; ITree：继承ITreeParent和ITreeChildren，同时多了Name属性&lt;/p&gt; &#xA;&lt;p&gt;相关扩展方法：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;trees.Filter(func); // 从树形集合中过滤&#xA;trees.Flatten(); // 将数据平铺开&#xA;tree.AllChildren(); // 获取所有的子级&#xA;tree.AllParent(); // 获取所有的父级&#xA;tree.IsRoot(); // 是否是根节点&#xA;tree.IsLeaf(); // 是否是叶子节点&#xA;tree.Level(); // 所处深度/层级&#xA;tree.Path(); // 全路径&#xA;&#xA;var tree=list.ToTree(c =&amp;gt; c.Id, c =&amp;gt; c.Pid);//继承自ITreeParent&amp;lt;T&amp;gt;, ITreeChildren&amp;lt;T&amp;gt;的集合转换成树形结构&#xA;var tree=list.ToTreeGeneral(c =&amp;gt; c.Id, c =&amp;gt; c.Pid);//一般的集合转换成树形结构&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;45.简单的Excel导出&lt;/h3&gt; &#xA;&lt;p&gt;需要额外依赖包：&lt;code&gt;Masuit.Tools.Excel&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var stream=list.Select(item=&amp;gt;new{&#xA;    姓名=item.Name,&#xA;    年龄=item.Age,&#xA;    item.Gender,&#xA;    Avatar=Image.FromStream(filestream) //图片列&#xA;}).ToDataTable().ToExcel(&#34;Sheet1&#34;); //自定义列名导出&#xA;var stream=list.ToDataTable(&#34;Sheet1&#34;).ToExcel(&#34;文件密码&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;一些约定规则：&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;图片列支持Stream、Bitmap、IEnumerable&#xA;  &lt;stream&gt;&#xA;   、IEnumerable&#xA;   &lt;bitmap&gt;&#xA;    、IDictionary&amp;lt;string,Stream&amp;gt;、IDictionary&amp;lt;string,MemoryStream&amp;gt;、IDictionary&amp;lt;string,Bitmap&amp;gt;类型；&#xA;   &lt;/bitmap&gt;&#xA;  &lt;/stream&gt;&lt;/li&gt; &#xA; &lt;li&gt;其中，如果是IDictionary类型的图片列，字典的键为图片超链接的完整url；&lt;/li&gt; &#xA; &lt;li&gt;默认字段名作为列名导出；&lt;/li&gt; &#xA; &lt;li&gt;若list是一个具体的强类型，默认会先查找每个字段的Description标记，若有Description标记，则取Description标记作为列名显示&lt;/li&gt; &#xA; &lt;li&gt;ToExcel方法支持DataTable、List&#xA;  &lt;datatable&gt;&#xA;   、Dictionary&amp;lt;string, DataTable&amp;gt;类型的直接调用&#xA;  &lt;/datatable&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;46.EFCore实体对比功能&lt;/h3&gt; &#xA;&lt;p&gt;获取指定实体的变更&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var changes=dbContext.GetChanges&amp;lt;Post&amp;gt;();//获取变更字段信息&#xA;var added=dbContext.GetAdded&amp;lt;Post&amp;gt;();//获取添加的实体字段信息&#xA;var removed=dbContext.GetRemoved&amp;lt;Post&amp;gt;();//获取被移除的实体字段信息  &#xA;var allchanges=dbContext.GetAllChanges&amp;lt;Post&amp;gt;();//获取增删改的实体字段信息  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;获取所有实体的变更&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var changes=dbContext.GetChanges();//获取变更字段信息&#xA;var added=dbContext.GetAdded();//获取添加的实体字段信息&#xA;var removed=dbContext.GetRemoved();//获取被移除的实体字段信息  &#xA;var allchanges=dbContext.GetAllChanges();//获取增删改的实体字段信息  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;对比信息包含属性信息、旧值、新值、实体信息、键信息、变更状态等&lt;/p&gt; &#xA;&lt;h3&gt;47.任何类型支持链式调用&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;a.Next(func1).Next(func2).Next(func3);&#xA;&#34;123&#34;.Next(s=&amp;gt;s.ToInt32()).Next(x=&amp;gt;x*2).Next(x=&amp;gt;Math.Log(x));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;48.Newtonsoft.Json的只允许字段反序列化行为的契约解释器&lt;/h3&gt; &#xA;&lt;h4&gt;DeserializeOnlyContractResolver&lt;/h4&gt; &#xA;&lt;p&gt;该解释器针对类属性被DeserializeOnlyJsonPropertyAttribute标记的，在反序列化的时候生效，在序列化的时候忽略&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class ClassDto&#xA;    {&#xA;        [DeserializeOnlyJsonProperty]&#xA;        public string MyProperty { get; set; }&#xA;&#xA;        public int Num { get; set; }&#xA;    }&#xA;    &#xA;    JsonConvert.SerializeObject(new MyClass(),new JsonSerializerSettings()&#xA;&#x9;{&#xA;&#x9;&#x9;ContractResolver = new DeserializeOnlyContractResolver() // 配置使用DeserializeOnlyContractResolver解释器&#xA;&#x9;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果是WebAPI全局使用：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;&#x9;&#x9;//在Startup.ConfigureServices中&#xA;&#x9;&#x9;services.AddMvc().AddNewtonsoftJson(options =&amp;gt;&#xA;             {&#xA;                 var resolver = new DeserializeOnlyContractResolver();&#xA;                 resolver.NamingStrategy = new CamelCaseNamingStrategy();&#xA;                 options.SerializerSettings.ContractResolver = resolver;&#xA;             });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;FallbackJsonPropertyResolver&lt;/h4&gt; &#xA;&lt;p&gt;该解释器针对某个属性设置多个别名，反序列化时支持多个别名key进行绑定，弥补官方JsonProperty别名属性只能设置单一别名的不足&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;    public class ClassDto&#xA;    {&#xA;        [FallbackJsonProperty(&#34;MyProperty&#34;,&#34;a&#34;,&#34;b&#34;)]&#xA;        public string MyProperty { get; set; }&#xA;&#xA;        public int Num { get; set; }&#xA;    }&#xA;    &#xA;    JsonConvert.SerializeObject(new MyClass(),new JsonSerializerSettings()&#xA;&#x9;{&#xA;&#x9;&#x9;ContractResolver = new FallbackJsonPropertyResolver() // 配置使用FallbackJsonPropertyResolver解释器&#xA;&#x9;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;CompositeContractResolver&lt;/h4&gt; &#xA;&lt;p&gt;该解释器是DeserializeOnlyContractResolver和FallbackJsonPropertyResolver的融合版&lt;/p&gt; &#xA;&lt;h3&gt;49. ASP.NET Core Action同时支持queryString、表单和json请求类型的模型绑点器BodyOrDefaultModelBinder&lt;/h3&gt; &#xA;&lt;p&gt;用法：&lt;br&gt; 引入包：&lt;code&gt;Masuit.Tools.AspNetCore&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PM&amp;gt; Install-Package Masuit.Tools.AspNetCore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Startup配置：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;&#x9;services.AddMvc(options =&amp;gt;&#xA;        {&#xA;             options.ModelBinderProviders.InsertBodyOrDefaultBinding();&#xA;        })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在action的参数模型前打上标记：&lt;code&gt;[FromBodyOrDefault]&lt;/code&gt;即可，当然也可以省略，示例代码如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        [HttpGet(&#34;query&#34;),HttpPost(&#34;query&#34;)]&#xA;        public IActionResult Query([FromBodyOrDefault]QueryModel query)&#xA;        {&#xA;            return Ok(...);&#xA;        }&#xA;&#x9;&#xA;        [HttpGet(&#34;query&#34;),HttpPost(&#34;query&#34;)]&#xA;        public IActionResult Query([FromBodyOrDefault]int id,[FromBodyOrDefault]string name)&#xA;        {&#xA;            return Ok(...);&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;50. 字符串SimHash相似度算法&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var dis=&#34;12345678&#34;.HammingDistance(&#34;1234567&#34;);&#xA;var dis=new SimHash(&#34;12345678&#34;).HammingDistance(new SimHash(&#34;1234567&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Asp.Net MVC和Asp.Net Core的支持断点续传和多线程下载的ResumeFileResult&lt;/h1&gt; &#xA;&lt;p&gt;在ASP.NET Core中通过MVC/WebAPI应用程序传输文件数据时使用断点续传以及多线程下载支持。&lt;/p&gt; &#xA;&lt;p&gt;它提供了&lt;code&gt;ETag&lt;/code&gt;标头以及&lt;code&gt;Last-Modified&lt;/code&gt;标头。 它还支持以下前置条件标头：&lt;code&gt;If-Match&lt;/code&gt;，&lt;code&gt;If-None-Match&lt;/code&gt;，&lt;code&gt;If-Modified-Since&lt;/code&gt;，&lt;code&gt;If-Unmodified-Since&lt;/code&gt;，&lt;code&gt;If-Range&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;支持 ASP.NET Core 2.0+&lt;/h2&gt; &#xA;&lt;p&gt;从.NET Core2.0开始，ASP.NET Core内部支持断点续传。 因此只是对FileResult做了一些扩展。 只留下了“Content-Disposition” Inline的一部分。 所有代码都依赖于基础.NET类。&lt;/p&gt; &#xA;&lt;h2&gt;如何使用&lt;/h2&gt; &#xA;&lt;h3&gt;.NET Framework&lt;/h3&gt; &#xA;&lt;p&gt;在你的控制器中，你可以像在&lt;code&gt;FileResult&lt;/code&gt;一样的方式使用它。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Masuit.Tools.Mvc;&#xA;using Masuit.Tools.Mvc.ResumeFileResult;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private readonly MimeMapper mimeMapper=new MimeMapper(); // 推荐使用依赖注入&#xA;&#xA;public ActionResult ResumeFileResult()&#xA;{&#xA;    var path = Server.MapPath(&#34;~/Content/test.mp4&#34;);&#xA;    return new ResumeFileResult(path, mimeMapper.GetMimeFromPath(path), Request);&#xA;}&#xA;&#xA;public ActionResult ResumeFile()&#xA;{&#xA;    return this.ResumeFile(&#34;~/Content/test.mp4&#34;, mimeMapper.GetMimeFromPath(path), &#34;test.mp4&#34;);&#xA;}&#xA;&#xA;public ActionResult ResumePhysicalFile()&#xA;{&#xA;    return this.ResumePhysicalFile(@&#34;D:/test.mp4&#34;, mimeMapper.GetMimeFromPath(@&#34;D:/test.mp4&#34;), &#34;test.mp4&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Asp.Net Core&lt;/h3&gt; &#xA;&lt;p&gt;要使用ResumeFileResults，必须在&lt;code&gt;Startup.cs&lt;/code&gt;的&lt;code&gt;ConfigureServices&lt;/code&gt;方法调用中配置服务：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Masuit.Tools.AspNetCore.ResumeFileResults.Extensions;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void ConfigureServices(IServiceCollection services)&#xA;{&#xA;    services.AddResumeFileResult();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;然后在你的控制器中，你可以像在&lt;code&gt;FileResult&lt;/code&gt;一样的方式使用它。&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;点击查看代码&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Masuit.Tools.AspNetCore.ResumeFileResults.Extensions;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private const string EntityTag = &#34;\&#34;TestFile\&#34;&#34;;&#xA;&#xA;private readonly IHostingEnvironment _hostingEnvironment;&#xA;&#xA;private readonly DateTimeOffset _lastModified = new DateTimeOffset(2016, 1, 1, 0, 0, 0, TimeSpan.Zero);&#xA;&#xA;/// &amp;lt;summary&amp;gt;&#xA;/// &#xA;/// &amp;lt;/summary&amp;gt;&#xA;/// &amp;lt;param name=&#34;hostingEnvironment&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;public TestController(IHostingEnvironment hostingEnvironment)&#xA;{&#xA;    _hostingEnvironment = hostingEnvironment;&#xA;}&#xA;&#xA;[HttpGet(&#34;content/{fileName}/{etag}&#34;)]&#xA;public IActionResult FileContent(bool fileName, bool etag)&#xA;{&#xA;    string webRoot = _hostingEnvironment.WebRootPath;&#xA;    var content = System.IO.File.ReadAllBytes(Path.Combine(webRoot, &#34;TestFile.txt&#34;));&#xA;    ResumeFileContentResult result = this.ResumeFile(content, &#34;text/plain&#34;, fileName ? &#34;TestFile.txt&#34; : null, etag ? EntityTag : null);&#xA;    result.LastModified = _lastModified;&#xA;    return result;&#xA;}&#xA;&#xA;[HttpGet(&#34;content/{fileName}&#34;)]&#xA;public IActionResult FileContent(bool fileName)&#xA;{&#xA;    string webRoot = _hostingEnvironment.WebRootPath;&#xA;    var content = System.IO.File.ReadAllBytes(Path.Combine(webRoot, &#34;TestFile.txt&#34;));&#xA;    var result = new ResumeFileContentResult(content, &#34;text/plain&#34;)&#xA;    {&#xA;        FileInlineName = &#34;TestFile.txt&#34;,&#xA;        LastModified = _lastModified&#xA;    };&#xA;    return result;&#xA;}&#xA;&#xA;[HttpHead(&#34;file&#34;)]&#xA;public IActionResult FileHead()&#xA;{&#xA;    ResumeVirtualFileResult result = this.ResumeFile(&#34;TestFile.txt&#34;, &#34;text/plain&#34;, &#34;TestFile.txt&#34;, EntityTag);&#xA;    result.LastModified = _lastModified;&#xA;    return result;&#xA;}&#xA;&#xA;[HttpPut(&#34;file&#34;)]&#xA;public IActionResult FilePut()&#xA;{&#xA;    ResumeVirtualFileResult result = this.ResumeFile(&#34;TestFile.txt&#34;, &#34;text/plain&#34;, &#34;TestFile.txt&#34;, EntityTag);&#xA;    result.LastModified = _lastModified;&#xA;    return result;&#xA;}&#xA;&#xA;[HttpGet(&#34;stream/{fileName}/{etag}&#34;)]&#xA;public IActionResult FileStream(bool fileName, bool etag)&#xA;{&#xA;    string webRoot = _hostingEnvironment.WebRootPath;&#xA;    FileStream stream = System.IO.File.OpenRead(Path.Combine(webRoot, &#34;TestFile.txt&#34;));&#xA;&#xA;    ResumeFileStreamResult result = this.ResumeFile(stream, &#34;text/plain&#34;, fileName ? &#34;TestFile.txt&#34; : null, etag ? EntityTag : null);&#xA;    result.LastModified = _lastModified;&#xA;    return result;&#xA;}&#xA;&#xA;[HttpGet(&#34;stream/{fileName}&#34;)]&#xA;public IActionResult FileStream(bool fileName)&#xA;{&#xA;    string webRoot = _hostingEnvironment.WebRootPath;&#xA;    FileStream stream = System.IO.File.OpenRead(Path.Combine(webRoot, &#34;TestFile.txt&#34;));&#xA;&#xA;    var result = new ResumeFileStreamResult(stream, &#34;text/plain&#34;)&#xA;    {&#xA;        FileInlineName = &#34;TestFile.txt&#34;,&#xA;        LastModified = _lastModified&#xA;    };&#xA;&#xA;    return result;&#xA;}&#xA;&#xA;[HttpGet(&#34;physical/{fileName}/{etag}&#34;)]&#xA;public IActionResult PhysicalFile(bool fileName, bool etag)&#xA;{&#xA;    string webRoot = _hostingEnvironment.WebRootPath;&#xA;&#xA;    ResumePhysicalFileResult result = this.ResumePhysicalFile(Path.Combine(webRoot, &#34;TestFile.txt&#34;), &#34;text/plain&#34;, fileName ? &#34;TestFile.txt&#34; : null, etag ? EntityTag : null);&#xA;    result.LastModified = _lastModified;&#xA;    return result;&#xA;}&#xA;&#xA;[HttpGet(&#34;physical/{fileName}&#34;)]&#xA;public IActionResult PhysicalFile(bool fileName)&#xA;{&#xA;    string webRoot = _hostingEnvironment.WebRootPath;&#xA;&#xA;    var result = new ResumePhysicalFileResult(Path.Combine(webRoot, &#34;TestFile.txt&#34;), &#34;text/plain&#34;)&#xA;    {&#xA;        FileInlineName = &#34;TestFile.txt&#34;,&#xA;        LastModified = _lastModified&#xA;    };&#xA;&#xA;    return result;&#xA;}&#xA;&#xA;[HttpGet(&#34;virtual/{fileName}/{etag}&#34;)]&#xA;public IActionResult VirtualFile(bool fileName, bool etag)&#xA;{&#xA;    ResumeVirtualFileResult result = this.ResumeFile(&#34;TestFile.txt&#34;, &#34;text/plain&#34;, fileName ? &#34;TestFile.txt&#34; : null, etag ? EntityTag : null);&#xA;    result.LastModified = _lastModified;&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;以上示例将为您的数据提供“Content-Disposition：attachment”。 当没有提供fileName时，数据将作为“Content-Disposition：inline”提供。 另外，它可以提供&lt;code&gt;ETag&lt;/code&gt;和&lt;code&gt;LastModified&lt;/code&gt;标头。&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[HttpGet(&#34;virtual/{fileName}&#34;)]&#xA;public IActionResult VirtualFile(bool fileName)&#xA;{&#xA;    var result = new ResumeVirtualFileResult(&#34;TestFile.txt&#34;, &#34;text/plain&#34;)&#xA;    {&#xA;        FileInlineName = &#34;TestFile.txt&#34;,&#xA;        LastModified = _lastModified&#xA;    };&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;推荐项目&lt;/h3&gt; &#xA;&lt;p&gt;基于EntityFrameworkCore和Lucene.NET实现的全文检索搜索引擎：&lt;a href=&#34;https://github.com/ldqk/Masuit.LuceneEFCore.SearchEngine&#34; title=&#34;Masuit.LuceneEFCore.SearchEngine&#34;&gt;Masuit.LuceneEFCore.SearchEngine&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;开源博客系统：&lt;a href=&#34;https://github.com/ldqk/Masuit.MyBlogs&#34; title=&#34;Masuit.MyBlogs&#34;&gt;Masuit.MyBlogs&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>