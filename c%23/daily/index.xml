<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-06T01:35:40Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Demigiant/dotween</title>
    <updated>2022-08-06T01:35:40Z</updated>
    <id>tag:github.com,2022-08-06:/Demigiant/dotween</id>
    <link href="https://github.com/Demigiant/dotween" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Unity C# animation engine. HOTween v2&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DOTween&lt;/h1&gt; &#xA;&lt;p&gt;A Unity C# animation/tween engine. HOTween v2&lt;br&gt; Developed by Daniele Giardini - &lt;a href=&#34;http://www.demigiant.com&#34;&gt;http://www.demigiant.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Check the docs on DOTween&#39;s website - &lt;a href=&#34;http://dotween.demigiant.com&#34;&gt;http://dotween.demigiant.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Demigiant/dotween/develop/screenshots/splash_dotween.png&#34; alt=&#34;DOTween&#34; title=&#34;DOTween&#34;&gt;&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Demigiant/dotween/develop/screenshots/splash_shortcuts.png&#34; alt=&#34;DOTween&#34; title=&#34;DOTween&#34;&gt;&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Demigiant/dotween/develop/screenshots/splash_lambda.png&#34; alt=&#34;DOTween&#34; title=&#34;DOTween&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>borisdj/EFCore.BulkExtensions</title>
    <updated>2022-08-06T01:35:40Z</updated>
    <id>tag:github.com,2022-08-06:/borisdj/EFCore.BulkExtensions</id>
    <link href="https://github.com/borisdj/EFCore.BulkExtensions" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Entity Framework Core Bulk Batch Extensions in .Net for Insert Update Delete Read (CRUD), Truncate and SaveChanges operations on SQL Server, PostgreSQL, SQLite&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;EFCore.BulkExtensions&lt;/h1&gt; &#xA;&lt;p&gt;EntityFrameworkCore extensions: &lt;br&gt; -Bulk operations &lt;strong&gt;(Insert, Update, Delete, Read, Upsert, Sync, SaveChanges)&lt;/strong&gt;&lt;br&gt; -Batch ops (&lt;strong&gt;Delete, Update&lt;/strong&gt;) and &lt;strong&gt;Truncate&lt;/strong&gt;.&lt;br&gt; Library is Lightweight and very Efficient, having all mostly used &lt;a href=&#34;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&#34;&gt;CRUD&lt;/a&gt; operation.&lt;br&gt; Was selected in top 20 &lt;a href=&#34;https://docs.microsoft.com/en-us/ef/core/extensions/&#34;&gt;EF Core Extensions&lt;/a&gt; recommended by Microsoft.&lt;br&gt; Latest version is using EF Core 6 and targeting .Net 6.&lt;br&gt; At the moment supports Microsoft SQLServer(2012+) or SqlAzure, PostgreSQL(9.5+) and SQLite.&lt;br&gt; -SQLServer under the hood uses &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy.aspx&#34;&gt;SqlBulkCopy&lt;/a&gt; for Insert, for Update/Delete combines BulkInsert with raw Sql &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/t-sql/statements/merge-transact-sql&#34;&gt;MERGE&lt;/a&gt;.&lt;br&gt; -PostgreSQL is using &lt;a href=&#34;https://www.postgresql.org/docs/9.2/sql-copy.html&#34;&gt;COPY BINARY&lt;/a&gt; combined with &lt;a href=&#34;https://www.postgresql.org/docs/10/sql-insert.html#SQL-ON-CONFLICT&#34;&gt;ON CONFLICT&lt;/a&gt; for Update (supported from v6+).&lt;br&gt; -For SQLite there is no Copy tool, instead library uses plain SQL combined with &lt;a href=&#34;https://www.sqlite.org/lang_UPSERT.html&#34;&gt;UPSERT&lt;/a&gt;.&lt;br&gt; Bulk Tests can not have UseInMemoryDb because InMemoryProvider does not support Relational-specific methods.&lt;br&gt; Instead Test options are SqlServer(Developer or Express), LocalDb(&lt;a href=&#34;https://stackoverflow.com/questions/42885377/sql-server-2016-developer-version-can-not-connect-to-localdb-mssqllocaldb?noredirect=1&amp;amp;lq=1&#34;&gt;if alongside Developer v.&lt;/a&gt;), or for other adapters PostgreSQL/SQLite.&lt;/p&gt; &#xA;&lt;!--[![Button](https://img.shields.io/nuget/v/EFCore.BulkExtensions.svg)](https://www.nuget.org/packages/EFCore.BulkExtensions/)--&gt; &#xA;&lt;p&gt;Available on &lt;a href=&#34;https://www.nuget.org/packages/EFCore.BulkExtensions/&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/EFCore.BulkExtensions&#34;&gt;&lt;/a&gt;&lt;br&gt; Package manager console command for installation: &lt;em&gt;Install-Package EFCore.BulkExtensions&lt;/em&gt;&lt;br&gt; Its assembly is &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/strong-naming&#34;&gt;Strong-Named&lt;/a&gt; and &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/161&#34;&gt;Signed&lt;/a&gt; with a key.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Nuget&lt;/th&gt; &#xA;   &lt;th&gt;Target&lt;/th&gt; &#xA;   &lt;th&gt;Used EF v.&lt;/th&gt; &#xA;   &lt;th&gt;For projects targeting&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6.x&lt;/td&gt; &#xA;   &lt;td&gt;Net 6.0&lt;/td&gt; &#xA;   &lt;td&gt;EF Core 6.0&lt;/td&gt; &#xA;   &lt;td&gt;Net 6.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.x&lt;/td&gt; &#xA;   &lt;td&gt;NetStandard 2.1&lt;/td&gt; &#xA;   &lt;td&gt;EF Core 5.0&lt;/td&gt; &#xA;   &lt;td&gt;Net 5.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.x&lt;/td&gt; &#xA;   &lt;td&gt;NetStandard 2.0&lt;/td&gt; &#xA;   &lt;td&gt;EF Core 3.n&lt;/td&gt; &#xA;   &lt;td&gt;NetCore(3.0+) or NetFrm(4.6.1+) &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/271#issuecomment-567117488&#34;&gt;MoreInfo&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2.x&lt;/td&gt; &#xA;   &lt;td&gt;NetStandard 2.0&lt;/td&gt; &#xA;   &lt;td&gt;EF Core 2.n&lt;/td&gt; &#xA;   &lt;td&gt;NetCore(2.0+) or NetFrm(4.6.1+)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1.x&lt;/td&gt; &#xA;   &lt;td&gt;NetStandard 1.4&lt;/td&gt; &#xA;   &lt;td&gt;EF Core 1.0&lt;/td&gt; &#xA;   &lt;td&gt;NetCore(1.0+)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Prior versions (5 and lower) are no longer actively maintained.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you find this project useful you can mark it by leaving a Github &lt;strong&gt;Star&lt;/strong&gt; &lt;span&gt;⭐&lt;/span&gt;.&lt;br&gt; If you would like to support the Project by making a Donation (&lt;em&gt;#BuyMeACoffee&lt;/em&gt;), you are welcome to do so:&lt;br&gt; &lt;a href=&#34;https://borisdj.github.io/pages/donation/donate-btc.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/donate-Bitcoin-orange.svg?logo=bitcoin&#34; alt=&#34;Button&#34;&gt;&lt;span&gt;⚡&lt;/span&gt;&lt;/a&gt;&lt;br&gt; Please read &lt;a href=&#34;https://raw.githubusercontent.com/borisdj/EFCore.BulkExtensions/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; for details on code of conduct, and the process for submitting pull requests.&lt;br&gt; &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/l/express.svg?sanitize=true&#34; alt=&#34;Button&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://docs.google.com/forms/d/e/1FAIpQLSfcUe15zxZS_YI6zZIt-l3L0mpmQRPUsaoxylfgFTfSVu_gmg/viewform&#34;&gt;&lt;strong&gt;ContactForm&lt;/strong&gt;&lt;/a&gt; for Development &amp;amp; Consulting.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s pretty simple and straightforward.&lt;br&gt; &lt;strong&gt;Bulk&lt;/strong&gt; Extensions are made on &lt;em&gt;DbContext&lt;/em&gt; and are used with entities List (supported both regular and Async methods):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;context.BulkInsert(entities);                 context.BulkInsertAsync(entities);&#xA;context.BulkInsertOrUpdate(entities);         context.BulkInsertOrUpdateAsync(entities);         // Upsert&#xA;context.BulkInsertOrUpdateOrDelete(entities); context.BulkInsertOrUpdateOrDeleteAsync(entities); // Sync&#xA;context.BulkUpdate(entities);                 context.BulkUpdateAsync(entities);&#xA;context.BulkDelete(entities);                 context.BulkDeleteAsync(entities);&#xA;context.BulkRead(entities);                   context.BulkReadAsync(entities);&#xA;context.BulkSaveChanges();                    context.BulkSaveChangesAsync();                    // &amp;gt;= v6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;-SQLite&lt;/strong&gt; requires package: &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/data/sqlite/custom-versions?tabs=netcore-cli&#34;&gt;&lt;em&gt;SQLitePCLRaw.bundle_e_sqlite3&lt;/em&gt;&lt;/a&gt; with call to &lt;code&gt;SQLitePCL.Batteries.Init()&lt;/code&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Batch&lt;/strong&gt; Extensions are made on &lt;em&gt;IQueryable&lt;/em&gt; DbSet and can be used as in the following code segment.&lt;br&gt; They are done as pure sql and no check is done whether some are prior loaded in memory and are being Tracked.&lt;br&gt; (&lt;em&gt;updateColumns&lt;/em&gt; is optional param in which PropertyNames added explicitly when need update to it&#39;s default value)&lt;br&gt; Info about &lt;a href=&#34;https://docs.microsoft.com/en-us/troubleshoot/sql/performance/resolve-blocking-problems-caused-lock-escalation&#34;&gt;lock-escalation&lt;/a&gt; in SQL Server with Batch iteration example as a solution at the bottom of code segment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// Delete&#xA;context.Items.Where(a =&amp;gt; a.ItemId &amp;gt;  500).BatchDelete();&#xA;context.Items.Where(a =&amp;gt; a.ItemId &amp;gt;  500).BatchDeleteAsync();&#xA;&#xA;// Update (using Expression arg.) supports Increment/Decrement &#xA;context.Items.Where(a =&amp;gt; a.ItemId &amp;lt;= 500).BatchUpdate(a =&amp;gt; new Item { Quantity = a.Quantity + 100 });&#xA;context.Items.Where(a =&amp;gt; a.ItemId &amp;lt;= 500).BatchUpdateAsync(a =&amp;gt; new Item { Quantity = a.Quantity + 100 });&#xA;  // can be as value &#39;+100&#39; or as variable &#39;+incrementStep&#39; (int incrementStep = 100;)&#xA;  &#xA;// Update (via simple object)&#xA;context.Items.Where(a =&amp;gt; a.ItemId &amp;lt;= 500).BatchUpdate(new Item { Description = &#34;Updated&#34; });&#xA;context.Items.Where(a =&amp;gt; a.ItemId &amp;lt;= 500).BatchUpdateAsync(new Item { Description = &#34;Updated&#34; });&#xA;// Update (via simple object) - requires additional Argument for setting to Property default value&#xA;var updateCols = new List&amp;lt;string&amp;gt; { nameof(Item.Quantity) }; //Update &#39;Quantity&#39; to default value(&#39;0&#39;-zero)&#xA;var q = context.Items.Where(a =&amp;gt; a.ItemId &amp;lt;= 500);&#xA;int affected = q.BatchUpdate(new Item { Description=&#34;Updated&#34; }, updateCols); //result assigned to variable&#xA;&#xA;// Batch iteration (useful in same cases to avoid lock escalation)&#xA;do {&#xA;    rowsAffected = query.Take(chunkSize).BatchDelete();&#xA;} while (rowsAffected &amp;gt;= chunkSize);&#xA;&#xA;// Truncate&#xA;context.Truncate&amp;lt;Entity&amp;gt;();&#xA;context.TruncateAsync&amp;lt;Entity&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Bulk info&lt;/h2&gt; &#xA;&lt;p&gt;If Windows Authentication is used then in ConnectionString there should be &lt;em&gt;Trusted_Connection=True;&lt;/em&gt; because Sql credentials are required to stay in connection.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;When used directly each of these operations are separate transactions and are automatically committed.&lt;br&gt; And if we need multiple operations in single procedure then explicit transaction should be used, for example:&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;using (var transaction = context.Database.BeginTransaction())&#xA;{&#xA;    context.BulkInsert(entities1List);&#xA;    context.BulkInsert(entities2List);&#xA;    transaction.Commit();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;BulkInsertOrUpdate&lt;/strong&gt; method can be used when there is need for both operations but in one connection to database.&lt;br&gt; It makes Update when PK(PrimaryKey) is matched, otherwise does Insert.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;BulkInsertOrUpdateOrDelete&lt;/strong&gt; effectively &lt;a href=&#34;https://www.mssqltips.com/sqlservertip/1704/using-merge-in-sql-server-to-insert-update-and-delete-at-the-same-time/&#34;&gt;synchronizes&lt;/a&gt; table rows with input data.&lt;br&gt; Those in Db that are not found in the list will be deleted.&lt;br&gt; Partial Sync can be done on table subset using expression set on config with method:&lt;br&gt; &lt;code&gt;bulkConfig.SetSynchronizeFilter&amp;lt;Item&amp;gt;(a =&amp;gt; a.Quantity &amp;gt; 0);&lt;/code&gt;&lt;br&gt; Not supported for SQLite(Lite has only UPSERT statement) nor currently for PostgreSQL. Way to achieve there sync functionality is to Select or BulkRead existing data from DB, split list into sublists and call separately Bulk methods for BulkInsertOrUpdate and Delete.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;BulkRead&lt;/strong&gt; does SELECT and JOIN based on one or more Unique columns that are specified in Config &lt;code&gt;UpdateByProperties&lt;/code&gt;.&lt;br&gt; More info in the &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions#read-example&#34;&gt;Example&lt;/a&gt; at the bottom.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SaveChanges&lt;/strong&gt; uses Change Tracker to find all modified(CUD) entities and call proper BulkOperations for each table.&lt;br&gt; Because it needs tracking it is slower then pure BulkOps but stil much faster then regular SaveChanges.&lt;br&gt; With config &lt;em&gt;OnSaveChangesSetFK&lt;/em&gt; setting FKs can be controled depending on whether PKs are generated in Db or in memory.&lt;br&gt; Support for this method was added in version 6 of the library.&lt;br&gt; Before calling this method newly created should be added into Range:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;context.Items.AddRange(newEntities); // if newEntities is parent list it can have child sublists&#xA;context.BulkSaveChanges();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Practical general usage could be made in a way to override regular SaveChanges and if any list of Modified entities entries is greater then say 1000 to redirect to Bulk version.&lt;/p&gt; &#xA;&lt;p&gt;Note: Bulk ops have optional argument &lt;em&gt;Type type&lt;/em&gt; that can be set to type of Entity if list has dynamic runtime objects or is inhereted from Entity class.&lt;/p&gt; &#xA;&lt;h2&gt;BulkConfig arguments&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bulk&lt;/strong&gt; methods can have optional argument &lt;strong&gt;BulkConfig&lt;/strong&gt; with properties (bool, int, object, List&#xA; &lt;string&gt;&#xA;  ):&#xA;  &lt;br&gt;&#xA; &lt;/string&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;PROPERTY : DEFAULTvalue&#xA;-----------------------                           PropertiesToInclude: null,&#xA;PreserveInsertOrder: true,                        PropertiesToIncludeOnCompare: null,&#xA;SetOutputIdentity: false,&#x9;                  PropertiesToIncludeOnUpdate: null,&#xA;BatchSize: 2000,&#x9;                          PropertiesToExclude: null,&#xA;NotifyAfter: null,&#x9;                          PropertiesToExcludeOnCompare: null,&#xA;BulkCopyTimeout: null,&#x9;                          PropertiesToExcludeOnUpdate: null,&#xA;EnableStreaming: false,&#x9;                          UpdateByProperties: null,&#xA;UseTempDB: false,&#x9;                          EnableShadowProperties: false,&#xA;UniqueTableNameTempDb: true,&#x9;                  IncludeGraph: false,&#xA;CustomDestinationTableName: null,&#x9;          OmitClauseExistsExcept: false,&#xA;CustomSourceTableName: null,&#x9;                  DoNotUpdateIfTimeStampChanged: false,&#xA;CustomSourceDestinationMappingColumns: null,      SRID: 4326,&#xA;TrackingEntities: false,&#x9;                  DateTime2PrecisionForceRound: false,&#xA;WithHoldlock: true,&#x9;                          TemporalColumns: { &#34;PeriodStart&#34;, &#34;PeriodEnd&#34; },&#xA;CalculateStats: false,&#x9;                          EnableShadowProperties: false,&#xA;SqlBulkCopyOptions: Default,                      OnSaveChangesSetFK: true,&#xA;SqlBulkCopyColumnOrderHints: null,                IgnoreGlobalQueryFilters: false,&#xA;OnConflictUpdateWhereSql: null,&#xA;--------------------------------------------------------------------------------------&#xA;METHOD: SetSynchronizeFilter&amp;lt;T&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to change defaults, BulkConfig should be added explicitly with one or more bool properties set to true, and/or int props like &lt;strong&gt;BatchSize&lt;/strong&gt; to different number.&lt;br&gt; Config also has DelegateFunc for setting &lt;em&gt;Underlying-Connection/Transaction&lt;/em&gt;, e.g. in UnderlyingTest.&lt;br&gt; When doing update we can chose to exclude one or more properties by adding their names into &lt;strong&gt;PropertiesToExclude&lt;/strong&gt;, or if we need to update less then half column then &lt;strong&gt;PropertiesToInclude&lt;/strong&gt; can be used. Setting both Lists are not allowed.&lt;/p&gt; &#xA;&lt;p&gt;When using the &lt;strong&gt;BulkInsert_/OrUpdate&lt;/strong&gt; methods, you may also specify the &lt;strong&gt;PropertiesToIncludeOnCompare&lt;/strong&gt; and &lt;strong&gt;PropertiesToExcludeOnCompare&lt;/strong&gt; properties. By adding a column name to the &lt;em&gt;PropertiesToExcludeOnCompare&lt;/em&gt;, will allow it to be inserted and updated but will not update the row if any of the other columns in that row did not change. For example, if you are importing bulk data and want to keep an internal &lt;em&gt;CreateDate&lt;/em&gt; or &lt;em&gt;UpdateDate&lt;/em&gt;, you add those columns to the &lt;em&gt;PropertiesToExcludeOnCompare&lt;/em&gt;.&lt;br&gt; Another option that may be used in the same scenario are the &lt;strong&gt;PropertiesToIncludeOnUpdate&lt;/strong&gt; and &lt;strong&gt;PropertiesToExcludeOnUpdate&lt;/strong&gt; properties. These properties will allow you to specify insert-only columns such as &lt;em&gt;CreateDate&lt;/em&gt; and &lt;em&gt;CreatedBy&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If we want Insert only new and skip existing ones in Db (Insert_if_not_Exist) then use &lt;em&gt;BulkInsertOrUpdate&lt;/em&gt; with config &lt;code&gt;PropertiesToIncludeOnUpdate = new List&amp;lt;string&amp;gt; { &#34;&#34; }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additionaly there is &lt;strong&gt;UpdateByProperties&lt;/strong&gt; for specifying custom properties, by which we want update to be done.&lt;br&gt; When setting multiple props in UpdateByProps then match done by columns combined, like unique constrain based on those cols.&lt;br&gt; Using UpdateByProperties while also having Identity column requires that Id property be &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/131&#34;&gt;Excluded&lt;/a&gt;.&lt;br&gt; Also with PostgreSQL when matching is done it requires UniqueIndex so for custom UpdateByProperties that do not have Un.Ind., it is temporarily created in which case method can not be in transaction (throws: &lt;em&gt;current transaction is aborted; CREATE INDEX CONCURRENTLY cannot run inside a transaction block&lt;/em&gt;).&lt;br&gt; If &lt;strong&gt;NotifyAfter&lt;/strong&gt; is not set it will have same value as &lt;em&gt;BatchSize&lt;/em&gt; while &lt;strong&gt;BulkCopyTimeout&lt;/strong&gt; when not set has SqlBulkCopy default which is 30 seconds and if set to 0 it indicates no limit.&lt;br&gt;&lt;br&gt; &lt;em&gt;SetOutputIdentity&lt;/em&gt; have purpose only when PK has Identity (usually &lt;em&gt;int&lt;/em&gt; type with AutoIncrement), while if PK is Guid(sequential) created in Application there is no need for them.&lt;br&gt; Also Tables with Composite Keys have no Identity column so no functionality for them in that case either.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var bulkConfig = new BulkConfig { SetOutputIdentity = true, BatchSize = 4000 };&#xA;context.BulkInsert(entities, bulkConfig);&#xA;context.BulkInsertOrUpdate(entities, new BulkConfig { SetOutputIdentity = true });&#xA;context.BulkInsertOrUpdate(entities, b =&amp;gt; b.SetOutputIdentity = true); // e.g. BulkConfig with Action arg.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;PreserveInsertOrder&lt;/strong&gt; is &lt;strong&gt;true&lt;/strong&gt; by default and makes sure that entites are inserted to Db as ordered in entitiesList.&lt;br&gt; When table has Identity column (int autoincrement) with 0 values in list they will temporary be automatically changed from 0s into range -N:-1.&lt;br&gt; Or it can be manually set with proper values for order (Negative values used to skip conflict with existing ones in Db).&lt;br&gt; Here single Id value itself doesn&#39;t matter, db will change it to next in sequence, what matters is their mutual relationship for sorting.&lt;br&gt; Insertion order is implemented with &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/t-sql/queries/top-transact-sql&#34;&gt;TOP&lt;/a&gt; in conjuction with ORDER BY. &lt;a href=&#34;https://stackoverflow.com/questions/884187/merge-into-insertion-order&#34;&gt;stackoverflow:merge-into-insertion-order&lt;/a&gt;.&lt;br&gt; This config should remain true when &lt;em&gt;SetOutputIdentity&lt;/em&gt; is set to true on Entity containing NotMapped Property. &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/76&#34;&gt;issues/76&lt;/a&gt;&lt;br&gt; When using &lt;strong&gt;SetOutputIdentity&lt;/strong&gt; Id values will be updated to new ones from database.&lt;br&gt; With BulkInsertOrUpdate for those that will be updated it has to match with Id column, or other unique column(s) if using UpdateByProperties in which case &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/806&#34;&gt;orderBy is done with those props&lt;/a&gt; instead of ID.&lt;br&gt; For Sqlite combination of BulkInsertOrUpdate and IdentityId automatic set will not work properly since it does &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/556&#34;&gt;not have full MERGE&lt;/a&gt; capabilities like SqlServer. Instead list can be split into 2 lists, and call separately BulkInsert and BulkUpdate.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SetOutputIdentity&lt;/strong&gt; is useful when BulkInsert is done to multiple related tables, that have Identity column.&lt;br&gt; After Insert is done to first table, we need Id-s (if using Option 1) that were generated in Db because they are FK(ForeignKey) in second table.&lt;br&gt; It is implemented with &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/t-sql/queries/output-clause-transact-sql&#34;&gt;OUTPUT&lt;/a&gt; as part of MERGE Query, so in this case even the Insert is not done directly to TargetTable but to TempTable and then Merged with TargetTable.&lt;br&gt; When used Id-s will be updated in entitiesList, and if &lt;em&gt;PreserveInsertOrder&lt;/em&gt; is set to &lt;em&gt;false&lt;/em&gt; then entitiesList will be cleared and reloaded.&lt;br&gt; Example of &lt;em&gt;SetOutputIdentity&lt;/em&gt; with parent-child FK related tables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;int numberOfEntites = 1000;&#xA;var entities = new List&amp;lt;Item&amp;gt;();&#xA;var subEntities = new List&amp;lt;ItemHistory&amp;gt;();&#xA;for (int i = 1; i &amp;lt;= numberOfEntites; i++)&#xA;{&#xA;    var entity = new Item { Name = $&#34;Name {i}&#34; };&#xA;    entity.ItemHistories = new List&amp;lt;ItemHistory&amp;gt;()&#xA;    {&#xA;        new ItemHistory { Remark = $&#34;Info {i}.1&#34; },&#xA;        new ItemHistory { Remark = $&#34;Info {i}.2&#34; }&#xA;    };&#xA;    entities.Add(entity);&#xA;}&#xA;&#xA;// Option 1&#xA;using (var transaction = context.Database.BeginTransaction())&#xA;{&#xA;    context.BulkInsert(entities, new BulkConfig { SetOutputIdentity = true });&#xA;    foreach (var entity in entities) {&#xA;        foreach (var subEntity in entity.ItemHistories) {&#xA;            subEntity.ItemId = entity.ItemId; // sets FK to match its linked PK that was generated in DB&#xA;        }&#xA;        subEntities.AddRange(entity.ItemHistories);&#xA;    }&#xA;    context.BulkInsert(subEntities);&#xA;    transaction.Commit();&#xA;}&#xA;&#xA;// Option 2 using Graph (only for SQL Server)&#xA;// - all entities in relationship with main ones in list are BulkInsertUpdated&#xA;context.BulkInsert(entities, b =&amp;gt; b.IncludeGraph = true);&#xA;  &#xA;// Option 3 with BulkSaveChanges() - uses ChangeTracker so little slower then direct Bulk&#xA;context.Items.AddRange(entities);&#xA;context.BulkSaveChanges();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When &lt;strong&gt;CalculateStats&lt;/strong&gt; set to True the result returned in &lt;code&gt;BulkConfig.StatsInfo&lt;/code&gt; (&lt;em&gt;StatsNumber-Inserted/Updated/Deleted&lt;/em&gt;).&lt;br&gt; If used for pure Insert (with Batching) then SetOutputIdentity should also be configured because Merge is required.&lt;br&gt; &lt;strong&gt;TrackingEntities&lt;/strong&gt; can be set to True if we want to have tracking of entities from BulkRead or if SetOutputIdentity is set.&lt;br&gt; &lt;strong&gt;UseTempDB&lt;/strong&gt; when set then BulkOperation has to be &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/49&#34;&gt;inside Transaction&lt;/a&gt;.&lt;br&gt; &lt;strong&gt;UniqueTableNameTempDb&lt;/strong&gt; when changed to false temp table name will be only &#39;Temp&#39; without random numbers.&lt;br&gt; &lt;strong&gt;CustomDestinationTableName&lt;/strong&gt; can be set with &#39;TableName&#39; only or with &#39;Schema.TableName&#39;.&lt;br&gt; &lt;strong&gt;CustomSourceTableName&lt;/strong&gt; when set enables source data from specified table already in Db, so input list not used and can be empty.&lt;br&gt; &lt;strong&gt;CustomSourceDestinationMappingColumns&lt;/strong&gt; dict can be set only if CustomSourceTableName is configured and it is used for specifying Source-Destination column names when they are not the same. Example in test &lt;code&gt;DestinationAndSourceTableNameTest&lt;/code&gt;.&lt;br&gt; &lt;strong&gt;EnableShadowProperties&lt;/strong&gt; to add (normal) Shadow Property and persist value. Disables automatic discrimator, use manual method.&lt;br&gt; &lt;strong&gt;IncludeGraph&lt;/strong&gt; when set all entites that have relations with main ones from the list are also merged into theirs tables.&lt;br&gt; &lt;strong&gt;OmitClauseExistsExcept&lt;/strong&gt; removes the clause from Merge statement, required when having noncomparable types like XML, and useful when need to active triggers even for same data.&lt;br&gt; _ Also in some &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/641&#34;&gt;sql collation&lt;/a&gt; small and capital letters are considered same (case-insensitive) so for BulkUpdate set it false.&lt;br&gt; &lt;strong&gt;DoNotUpdateIfTimeStampChanged&lt;/strong&gt; if set checks TimeStamp for Concurrency, ones with conflict will &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/469#issuecomment-803662721&#34;&gt;not be updated&lt;/a&gt;.&lt;br&gt; &lt;strong&gt;SRID&lt;/strong&gt; Spatial Reference Identifier - for SQL Server with NetTopologySuite.&lt;br&gt; &lt;strong&gt;DateTime2PrecisionForceRound&lt;/strong&gt; If dbtype datetime2 has precision less then default 7, example &#39;datetime2(3)&#39; SqlBulkCopy does Floor instead of Round so when this Property is set then Rounding will be done in memory to make sure inserted values are same as with regular SaveChanges.&lt;br&gt; &lt;strong&gt;TemporalColumns&lt;/strong&gt; are shadow columns used for Temporal table. Default elements &#39;PeriodStart&#39; and &#39;PeriodEnd&#39; can be changed if those columns have custom names.&lt;br&gt; &lt;strong&gt;OnSaveChangesSetFK&lt;/strong&gt; is used only for BulkSaveChanges. When multiply entries have FK relationship which is Db generated, this set proper value after reading parent PK from Db. IF PK are generated in memory like are some Guid then this can be set to false for better efficiency.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SqlBulkCopyOptions&lt;/strong&gt; is Enum (only for SqlServer) with &lt;a href=&#34;https://stackoverflow.com/questions/8447/what-does-the-flags-enum-attribute-mean-in-c&#34;&gt;[Flags]&lt;/a&gt; attribute which enables specifying one or more options:&lt;br&gt; &lt;em&gt;Default, KeepIdentity, CheckConstraints, TableLock, KeepNulls, FireTriggers, UseInternalTransaction&lt;/em&gt;&lt;br&gt; If need to set Identity PK in memory, Not let DB do the autoincrement, then need to use &lt;strong&gt;KeepIdentity&lt;/strong&gt;:&lt;br&gt; &lt;code&gt;var bulkConfig = new BulkConfig { SqlBulkCopyOptions = SqlBulkCopyOptions.KeepIdentity };&lt;/code&gt;&lt;br&gt; Useful for example when copying from one Db to another.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SetSynchronizeFilter&#xA;  &lt;t&gt;&lt;/t&gt;&lt;/strong&gt; A method that receives and sets expresion filter on entities to delete when using BulkInsertOrUpdateOrDelete.&lt;br&gt; &lt;strong&gt;OnConflictUpdateWhereSql&#xA;  &lt;t&gt;&lt;/t&gt;&lt;/strong&gt; To define conditional updates on merges, receives (existingTable, insertedTable).&lt;br&gt; --Example: &lt;code&gt;bc.OnConflictUpdateWhereSql = (ex, in) =&amp;gt; $&#34;{in}.TimeUpdated &amp;gt; {ex}.TimeUpdated&#34;;&lt;/code&gt;&lt;br&gt; Last optional argument is &lt;strong&gt;Action progress&lt;/strong&gt; (Example in &lt;em&gt;EfOperationTest.cs&lt;/em&gt; &lt;em&gt;RunInsert()&lt;/em&gt; with &lt;em&gt;WriteProgress()&lt;/em&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;context.BulkInsert(entitiesList, null, (a) =&amp;gt; WriteProgress(a));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Library supports &lt;a href=&#34;https://docs.microsoft.com/en-us/ef/core/querying/filters&#34;&gt;Global Query Filters&lt;/a&gt; and &lt;a href=&#34;https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions&#34;&gt;Value Conversions&lt;/a&gt; as well.&lt;br&gt; Additionally BatchUpdate and named Property works with &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/397&#34;&gt;EnumToString Conversion&lt;/a&gt;.&lt;br&gt; It can map &lt;a href=&#34;https://docs.microsoft.com/en-us/ef/core/modeling/owned-entities&#34;&gt;OwnedTypes&lt;/a&gt;, also next are links with info how to achieve &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/167#issuecomment-476737959&#34;&gt;NestedOwnedTypes&lt;/a&gt; and &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/114#issuecomment-803462928&#34;&gt;OwnedInSeparateTable&lt;/a&gt;.&lt;br&gt; Table splitting are somewhat specific but could be configured in way &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/352#issuecomment-803674404&#34;&gt;Set TableSplit&lt;/a&gt;.&lt;br&gt; With &lt;a href=&#34;https://docs.microsoft.com/en-us/ef/core/modeling/relational/computed-columns&#34;&gt;Computed&lt;/a&gt; and &lt;a href=&#34;https://docs.microsoft.com/en-us/ef/core/modeling/concurrency&#34;&gt;Timestamp&lt;/a&gt; Columns it will work in a way that they are automatically excluded from Insert. And when combined with &lt;em&gt;SetOutputIdentity&lt;/em&gt; they will be Selected.&lt;br&gt; &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/relational-databases/spatial/spatial-data-types-overview?view=sql-server-ver15&#34;&gt;Spatial&lt;/a&gt; types, like Geometry, also supported and if Entity has one, clause &lt;em&gt;EXIST ... EXCEPT&lt;/em&gt; is skipped because it&#39;s not comparable.&lt;br&gt; Performance for bulk ops measured with &lt;code&gt;ActivitySources&lt;/code&gt; named: &#39;&lt;em&gt;BulkExecute&lt;/em&gt;&#39; (tags: &#39;&lt;em&gt;operationType&lt;/em&gt;&#39;, &#39;&lt;em&gt;entitiesCount&lt;/em&gt;&#39;)&lt;br&gt; Bulk Extension methods can be &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/56&#34;&gt;Overridden&lt;/a&gt; if required, for example to set AuditInfo.&lt;br&gt; If having problems with Deadlock there is useful info in &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/46&#34;&gt;issue/46&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;TPH inheritance&lt;/h2&gt; &#xA;&lt;p&gt;When having TPH (&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/inheritance&#34;&gt;Table-Per-Hierarchy&lt;/a&gt;) inheritance model it can be set in 2 ways.&lt;br&gt; First is automatically by Convention in which case Discriminator column is not directly in Entity but is &lt;a href=&#34;http://www.learnentityframeworkcore.com/model/shadow-properties&#34;&gt;Shadow&lt;/a&gt; Property.&lt;br&gt; And second is to explicitly define Discriminator property in Entity and configure it with &lt;code&gt;.HasDiscriminator()&lt;/code&gt;.&lt;br&gt; Important remark regarding the first case is that since we can not set directly Discriminator to certain value we need first to add list of entities to DbSet where it will be set and after that we can call Bulk operation. Note that SaveChanges are not called and we could optionally turn off TrackingChanges for performance. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public class Student : Person { ... }&#xA;context.Students.AddRange(entities); // adding to Context so that Shadow property &#39;Discriminator&#39; gets set&#xA;context.BulkInsert(entities);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;TPT&lt;/strong&gt; (Table-Per-Type) as of v5 is &lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/493&#34;&gt;partially supported&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Read example&lt;/h2&gt; &#xA;&lt;p&gt;When we need to Select from big List of some Unique Prop./Column use BulkRead (JOIN done in Sql) for Efficiency:&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// instead of WhereIN which will TimeOut for List with over around 40 K records&#xA;var entities = context.Items.Where(a =&amp;gt; itemsNames.Contains(a.Name)).AsNoTracking().ToList(); // SQL IN&#xA;// or JOIN in Memory that loads entire table&#xA;var entities = context.Items.Join(itemsNames, a =&amp;gt; a.Name, p =&amp;gt; p, (a, p) =&amp;gt; a).AsNoTracking().ToList();&#xA;&#xA;// USE&#xA;var items = itemsNames.Select(a =&amp;gt; new Item { Name = a }).ToList(); // Items list with only Name set&#xA;var bulkConfig = new BulkConfig { UpdateByProperties = new List&amp;lt;string&amp;gt; { nameof(Item.Name) } };&#xA;context.BulkRead(items, bulkConfig); // Items list will be loaded from Db with data(other properties)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/borisdj/EFCore.BulkExtensions/issues/733#issuecomment-1017417579&#34;&gt;Example&lt;/a&gt; of special use case when need to BulkRead child entities after BulkReading parent list.&lt;/p&gt; &#xA;&lt;h2&gt;Performances&lt;/h2&gt; &#xA;&lt;p&gt;Following are performances (in seconds)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For SQL Server (v. 2019):&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Ops\Rows&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;EF 100K&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Bulk 100K&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;EF 1 MIL.&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Bulk 1 MIL.&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Insert&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;11 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;60 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;15 s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Update&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;8 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;4 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;84 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;27 s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Delete&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;50 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;5340 s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;15 s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;TestTable has 6 columns (Guid, string, string, int, decimal?, DateTime).&lt;br&gt; All were inserted and 2 of them (string, DateTime) were updated.&lt;br&gt; Test done locally on configuration: INTEL i7-10510U CPU 2.30GHz, DDR3 16 GB, SSD SAMSUNG MZ 512 GB.&lt;br&gt; For small data sets there is an overhead since most Bulk ops need to create Temp table and also Drop it after finish.&lt;br&gt; _Probably good advice would be to use Bulk ops for sets greater than 1000.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>protobuf-net/protobuf-net</title>
    <updated>2022-08-06T01:35:40Z</updated>
    <id>tag:github.com,2022-08-06:/protobuf-net/protobuf-net</id>
    <link href="https://github.com/protobuf-net/protobuf-net" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Protocol Buffers library for idiomatic .NET&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://protogen.marcgravell.com/images/protobuf-net.svg?sanitize=true&#34; alt=&#34;protobuf-net logo&#34; width=&#34;45&#34; height=&#34;45&#34;&gt; protobuf-net&lt;/h1&gt; &#xA;&lt;p&gt;protobuf-net is a contract based serializer for .NET code, that happens to write data in the &#34;protocol buffers&#34; serialization format engineered by Google. The API, however, is very different to Google&#39;s, and follows typical .NET patterns (it is broadly comparable, in usage, to &lt;code&gt;XmlSerializer&lt;/code&gt;, &lt;code&gt;DataContractSerializer&lt;/code&gt;, etc). It should work for most .NET languages that write standard types and can use attributes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ci.appveyor.com/project/StackExchange/protobuf-net/branch/main&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/1pj6gk7h37bjn200/branch/main?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Release Notes&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://protobuf-net.github.io/protobuf-net/3_0&#34;&gt;v3 is here!&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://protobuf-net.github.io/protobuf-net/releasenotes&#34;&gt;Change history and pending changes are here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Supported Runtimes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.NET Framework 4.6.1+&lt;/li&gt; &#xA; &lt;li&gt;.NET Standard 2.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build tools&lt;/h2&gt; &#xA;&lt;p&gt;Build tools to help you use protobuf-net correctly are &lt;a href=&#34;https://protobuf-net.github.io/protobuf-net/build_tools&#34;&gt;available via &lt;code&gt;protobuf-net.BuildTools&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Runtime Installation&lt;/h2&gt; &#xA;&lt;p&gt;All stable and some pre-release packages are available on NuGet. CI Builds are available via MyGet (feed URL: &lt;code&gt;https://www.myget.org/F/protobuf-net/api/v3/index.json &lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;You can use the following command in the Package Manager Console:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ps&#34;&gt;Install-Package protobuf-net&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Package&lt;/th&gt; &#xA;   &lt;th&gt;NuGet Stable&lt;/th&gt; &#xA;   &lt;th&gt;NuGet Pre-release&lt;/th&gt; &#xA;   &lt;th&gt;Downloads&lt;/th&gt; &#xA;   &lt;th&gt;MyGet&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/protobuf-net/&#34;&gt;protobuf-net&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/protobuf-net/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/protobuf-net.svg?sanitize=true&#34; alt=&#34;protobuf-net&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/protobuf-net/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/protobuf-net.svg?sanitize=true&#34; alt=&#34;protobuf-net&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/protobuf-net/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/protobuf-net.svg?sanitize=true&#34; alt=&#34;protobuf-net&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.myget.org/feed/protobuf-net/package/nuget/protobuf-net&#34;&gt;&lt;img src=&#34;https://img.shields.io/myget/protobuf-net/vpre/protobuf-net.svg?sanitize=true&#34; alt=&#34;protobuf-net MyGet&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Basic usage&lt;/h2&gt; &#xA;&lt;h3&gt;1 First Decorate your classes&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ProtoContract]&#xA;class Person {&#xA;    [ProtoMember(1)]&#xA;    public int Id {get;set;}&#xA;    [ProtoMember(2)]&#xA;    public string Name {get;set;}&#xA;    [ProtoMember(3)]&#xA;    public Address Address {get;set;}&#xA;}&#xA;[ProtoContract]&#xA;class Address {&#xA;    [ProtoMember(1)]&#xA;    public string Line1 {get;set;}&#xA;    [ProtoMember(2)]&#xA;    public string Line2 {get;set;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that unlike XmlSerializer, the member-names are not encoded in the data - instead, you must pick an integer to identify each member. Additionally, to show intent it is necessary to show that we intend this type to be serialized (i.e. that it is a data contract).&lt;/p&gt; &#xA;&lt;h3&gt;2 Serialize your data&lt;/h3&gt; &#xA;&lt;p&gt;This writes a 32 byte file to &#34;person.bin&#34; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var person = new Person {&#xA;    Id = 12345, Name = &#34;Fred&#34;,&#xA;    Address = new Address {&#xA;        Line1 = &#34;Flat 1&#34;,&#xA;        Line2 = &#34;The Meadows&#34;&#xA;    }&#xA;};&#xA;using (var file = File.Create(&#34;person.bin&#34;)) {&#xA;    Serializer.Serialize(file, person);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3 Deserialize your data&lt;/h3&gt; &#xA;&lt;p&gt;This reads the data back from &#34;person.bin&#34; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Person newPerson;&#xA;using (var file = File.OpenRead(&#34;person.bin&#34;)) {&#xA;    newPerson = Serializer.Deserialize&amp;lt;Person&amp;gt;(file);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Notes&lt;/h3&gt; &#xA;&lt;h4&gt;Notes for Identifiers&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;they must be positive integers (for best portability, they should be &lt;code&gt;&amp;lt;= 536870911&lt;/code&gt; and not in the range &lt;code&gt;19000-19999&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;they must be unique within a single type but the same numbers can be re-used in sub-types if inheritance is enabled&lt;/li&gt; &#xA; &lt;li&gt;the identifiers must not conflict with any inheritance identifiers (discussed later)&lt;/li&gt; &#xA; &lt;li&gt;lower numbers take less space - don&#39;t start at 100,000,000&lt;/li&gt; &#xA; &lt;li&gt;the identifier is important; you can change the member-name, or shift it between a property and a field, but changing the identifier changes the data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Advanced subjects&lt;/h2&gt; &#xA;&lt;h3&gt;Inheritance&lt;/h3&gt; &#xA;&lt;p&gt;Inheritance must be explicitly declared, in a similar way that it must for XmlSerializer and DataContractSerializer. This is done via [ProtoInclude(...)] on each type with known sub-types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ProtoContract]&#xA;[ProtoInclude(7, typeof(SomeDerivedType))]&#xA;class SomeBaseType {...}&#xA;&#xA;[ProtoContract]&#xA;class SomeDerivedType {...}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is no special significance in the 7 above; it is an integer key, just like every [ProtoMember(...)]. It must be unique in terms of SomeBaseType (no other [ProtoInclude(...)] or [ProtoMember(...)] in SomeBaseType can use 7), but does not need to be unique globally.&lt;/p&gt; &#xA;&lt;h3&gt;.proto file&lt;/h3&gt; &#xA;&lt;p&gt;As an alternative to writing your classes and decorating them, You can generate your types from a .proto schema using &lt;a href=&#34;https://protogen.marcgravell.com/&#34;&gt;&lt;code&gt;protogen&lt;/code&gt;&lt;/a&gt;; the &lt;code&gt;protogen&lt;/code&gt; tool is available as a zip from that location, or &lt;a href=&#34;https://www.nuget.org/packages/protobuf-net.Protogen&#34;&gt;as a &#34;global tool&#34;&lt;/a&gt; (multi-platform).&lt;/p&gt; &#xA;&lt;h3&gt;Alternative to attributes&lt;/h3&gt; &#xA;&lt;p&gt;In v2+, everything that can be done with attributes can also be configured at runtime via &lt;code&gt;RuntimeTypeModel&lt;/code&gt;. The Serializer.* methods are basically just shortcuts to RuntimeTypeModel.Default.&lt;em&gt;, so to manipulate the behaviour of Serializer.&lt;/em&gt;, you must configure RuntimeTypeModel.Default.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;I try to be responsive to &lt;a href=&#34;https://stackoverflow.com/questions/tagged/protobuf-net&#34;&gt;Stack Overflow questions in the &lt;code&gt;protobuf-net&lt;/code&gt; tag&lt;/a&gt;, &lt;a href=&#34;https://github.com/protobuf-net/protobuf-net&#34;&gt;issues logged on GitHub&lt;/a&gt;, &lt;a href=&#34;mailto:marc.gravell@gmail.com&#34;&gt;email&lt;/a&gt;, etc. I don&#39;t currently offer a paid support channel. If I&#39;ve helped you, feel free to &lt;a href=&#34;https://buymeacoff.ee/marcgravell&#34;&gt;buy me a coffee&lt;/a&gt; or see the &#34;Sponsor&#34; link &lt;a href=&#34;https://github.com/protobuf-net/protobuf-net&#34;&gt;at the top of the GitHub page&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>