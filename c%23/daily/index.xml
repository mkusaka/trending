<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-28T01:34:17Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Live-Charts/Live-Charts</title>
    <updated>2022-09-28T01:34:17Z</updated>
    <id>tag:github.com,2022-09-28:/Live-Charts/Live-Charts</id>
    <link href="https://github.com/Live-Charts/Live-Charts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, flexible, interactive &amp; powerful charts, maps and gauges for .Net&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &amp;nbsp;&lt;a href=&#34;http://lvcharts.net/&#34;&gt;&lt;img src=&#34;http://lvcharts.net/Content/Images/LiveChartsWhite.gif&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h1&gt;This project will continue in another repo, please see &lt;a href=&#34;https://github.com/Live-Charts/LiveCharts2&#34;&gt;LiveCharts2&lt;/a&gt; for more info&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;del&gt;LiveCharts 1.0 is coming soon (ETA AprilSeptember 2018)!&lt;/del&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;del&gt;We are doing a full rewrite of the library with all the learned lessons, the new version is focused on:&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;* &lt;strong&gt;If you own the Geared package&lt;/strong&gt; the new high performance version is already yours! thank you very much for all your support!&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;* &lt;strong&gt;Portability&lt;/strong&gt;: In version 0.x it was hard keep WPF, UWP and Winforms versions up to date, in the new version we extracted all the math to a dotnet core project, then we are working on 4 different platfomrs WPF, Xamarin, UWP and the new high performance package.&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;* &lt;strong&gt;Performance&lt;/strong&gt;: when the library started, performance was not the target, as the library community grow, the Geared package was released (the current high performance version), and it works for many cases, but we want LiveCharts to be the fastest library out there, in the new high performance package we are scaping from WPF performance limitations and drawing everything using DirectX with the well know &lt;a href=&#34;http://sharpdx.org/&#34;&gt;SharpDx&lt;/a&gt; package.&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;* &lt;strong&gt;3d&lt;/strong&gt;: 0.x layout was not designed to draw 3d plots, version 1.0 is really flexible and lucky we will be on 3d soon.&lt;/del&gt; &lt;del&gt;* &lt;strong&gt;Keep it easy!&lt;/strong&gt;: Even somethings might change, the idea of the library is the same, we only want to add support for the missing features and/or a better code quality so we can fix issues faster for all the platforms, all the samples will be updated with the new version.&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;Check out our progress at &lt;a href=&#34;https://github.com/beto-rodriguez/Live-Charts/tree/v1.0&#34;&gt;v1.0 branch&lt;/a&gt;.&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/beto-rodriguez/Live-Charts/raw/master/LICENSE.TXT&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/beto-rodriguez/Live-Charts.svg?style=flat-square&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/beto-rodriguez/live-charts&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/707m8sye0ggbfrcq&#34; alt=&#34;AppVeyor&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/beto-rodriguez/Live-Charts/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues/beto-rodriguez/Live-Charts.svg?style=flat-square&#34; alt=&#34;GitHub issues&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/beto-rodriguez/Live-Charts?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://img.shields.io/gitter/room/beto-rodriguez/Live-Charts.svg?style=flat-square&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://isitmaintained.com/project/beto-rodriguez/live-charts&#34; title=&#34;Average time to resolve an issue&#34;&gt;&lt;img src=&#34;http://isitmaintained.com/badge/resolution/beto-rodriguez/live-charts.svg?sanitize=true&#34; alt=&#34;Average time to resolve an issue&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://isitmaintained.com/project/beto-rodriguez/live-charts&#34; title=&#34;Percentage of issues still open&#34;&gt;&lt;img src=&#34;http://isitmaintained.com/badge/open/beto-rodriguez/live-charts.svg?sanitize=true&#34; alt=&#34;Percentage of issues still open&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;http://lvcharts.net/App/examples/wpf/start&#34;&gt;Get Started Here&lt;/a&gt;&lt;/strong&gt;, this repository has many examples also.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://gitter.im/beto-rodriguez/Live-Charts&#34;&gt;Chat&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Questions and support?&lt;/strong&gt;, we are always happy to help you at our chat, if you require so you can also try &lt;a href=&#34;http://stackoverflow.com/questions/tagged/livecharts&#34;&gt;Stack Overflow&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;LiveCharts is&lt;/h3&gt; &#xA;&lt;h1&gt;Flexible, Customizable&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;images in this section are built with LiveCharts, but designed by &lt;a href=&#34;https://dribbble.com/Kingyo&#34;&gt;Kingyo&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;http://lvcharts.net/Content/Images/materialcards.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;http://lvcharts.net/Content/Images/energy.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;http://lvcharts.net/Content/Images/solid.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;it is also&lt;/h3&gt; &#xA;&lt;h1&gt;Simple, Interactive&lt;/h1&gt; &#xA;&lt;p&gt;As easy as manipulating any generic list in .Net, LiveCharts updates and animates as your data changes in real time, charts are also sensitive to size changes.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://lvcharts.net/Content/Images/Banner/linq.gif&#34;&gt; &lt;img src=&#34;https://lvcharts.net/Content/Images/Banner/responsive.gif&#34;&gt; &lt;img src=&#34;https://lvcharts.net/Content/Images/Banner/doughnut.gif&#34;&gt;/ &lt;img src=&#34;https://lvcharts.net/Content/Images/Banner/constant.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;and of course it also is&lt;/h3&gt; &#xA;&lt;h1&gt;Powerful&lt;/h1&gt; &#xA;&lt;p&gt;LiveCharts is not just beauty charts, this example contains 100,000 points, and the chart is being refreshed constantly, we support zooming, panning, multiple axes, sections, merged UIelemnts and much more!&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://lvcharts.net/Content/Images/scrll.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;But that is not all, we try to support as many charts as possible, bars, lines, heat maps, gauges, maps:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://lvcharts.net/content/images/darkpanel.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Road Map&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;del&gt;Build at least all the features any other charting library does, in WPF and WinForms&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;[In progress]&lt;/strong&gt; Build High performance algorithms&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;[In progress]&lt;/strong&gt; Expand the library to: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;del&gt;WPF&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;del&gt;WinForms&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; UWP &lt;strong&gt;[In progress]&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Xamarin&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Release 1.0 in WPF and WinForms, the other platforms will be beta, in case something went wrong.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Support&lt;/h3&gt; &#xA;&lt;p&gt;WPF and Winforms, currenlty the library is in the process to become a cross net library...&lt;/p&gt; &#xA;&lt;h3&gt;Net Version&lt;/h3&gt; &#xA;&lt;p&gt;.Net 4.0 or greater&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://lvcharts.net/App/examples/wpf/Install&#34;&gt;Wpf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://lvcharts.net/App/examples/wf/Install&#34;&gt;WinForms&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Migrating from older versions?&lt;/h3&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/beto-rodriguez/Live-Charts/releases&#34;&gt;https://github.com/beto-rodriguez/Live-Charts/releases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;How to Contribute&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Star&lt;/strong&gt; this repo&lt;/li&gt; &#xA; &lt;li&gt;Try it&lt;/li&gt; &#xA; &lt;li&gt;Report Issues and Improvements&lt;/li&gt; &#xA; &lt;li&gt;Pull request are well received&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also buy me a beer&lt;/p&gt; &#xA;&lt;form action=&#34;https://www.paypal.com/cgi-bin/webscr&#34; method=&#34;post&#34; target=&#34;_top&#34;&gt; &#xA; &lt;input type=&#34;hidden&#34; name=&#34;cmd&#34; value=&#34;_s-xclick&#34;&gt; &#xA; &lt;input type=&#34;hidden&#34; name=&#34;hosted_button_id&#34; value=&#34;J86WDLSS9PWGL&#34;&gt; &#xA; &lt;input type=&#34;image&#34; src=&#34;https://www.paypalobjects.com/en_GB/i/btn/btn_donate_LG.gif&#34; border=&#34;0&#34; name=&#34;submit&#34; alt=&#34;PayPal â€“ The safer, easier way to pay online.&#34;&gt; &#xA; &lt;img alt=&#34;&#34; border=&#34;0&#34; src=&#34;https://www.paypalobjects.com/es_XC/i/scr/pixel.gif&#34; width=&#34;1&#34; height=&#34;1&#34;&gt; &#xA;&lt;/form&gt; [paypal](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;amp;hosted_button_id=J86WDLSS9PWGL) &#xA;&lt;h3&gt;Examples?&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://lvcharts.net/App/examples/wpf/start&#34;&gt;web site&lt;/a&gt; has a nice set, they are also built in the examples folder up here ^^^^&lt;/p&gt; &#xA;&lt;h3&gt;Special thanks to&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/&#34;&gt;JetBrains&lt;/a&gt;, for the resharper license.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/beto-rodriguez/Live-Charts/graphs/contributors&#34;&gt;Contributors&lt;/a&gt; and any one brave enough to report any new issue&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>chronoxor/NetCoreServer</title>
    <updated>2022-09-28T01:34:17Z</updated>
    <id>tag:github.com,2022-09-28:/chronoxor/NetCoreServer</id>
    <link href="https://github.com/chronoxor/NetCoreServer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ultra fast and low latency asynchronous socket server &amp; client C# .NET Core library with support TCP, SSL, UDP, HTTP, HTTPS, WebSocket protocols and 10K connections problem solution&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NetCoreServer&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/quozd/awesome-dotnet&#34;&gt;&lt;img src=&#34;https://awesome.re/badge.svg?sanitize=true&#34; alt=&#34;Awesome .NET&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/actions/workflows/build-linux.yml&#34;&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/actions/workflows/build-linux.yml/badge.svg?sanitize=true&#34; alt=&#34;Linux&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/actions/workflows/build-macos.yml&#34;&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/actions/workflows/build-macos.yml/badge.svg?sanitize=true&#34; alt=&#34;MacOS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/actions/workflows/build-windows.yml&#34;&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/actions/workflows/build-windows.yml/badge.svg?sanitize=true&#34; alt=&#34;Windows (Visual Studio)&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://www.nuget.org/packages/NetCoreServer&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/NetCoreServer&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ultra fast and low latency asynchronous socket server &amp;amp; client C# .NET Core library with support TCP, SSL, UDP, Unix Domain Socket, HTTP, HTTPS, WebSocket protocols and &lt;a href=&#34;https://en.wikipedia.org/wiki/C10k_problem&#34;&gt;10K connections problem&lt;/a&gt; solution.&lt;/p&gt; &#xA;&lt;p&gt;Has integration with high-level message protocol based on &lt;a href=&#34;https://github.com/chronoxor/FastBinaryEncoding&#34;&gt;Fast Binary Encoding&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://chronoxor.github.io/NetCoreServer&#34;&gt;NetCoreServer documentation&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/releases&#34;&gt;NetCoreServer downloads&lt;/a&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#how-to-build&#34;&gt;How to build?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#examples&#34;&gt;Examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-tcp-chat-server&#34;&gt;Example: TCP chat server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-tcp-chat-client&#34;&gt;Example: TCP chat client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-ssl-chat-server&#34;&gt;Example: SSL chat server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-ssl-chat-client&#34;&gt;Example: SSL chat client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-udp-echo-server&#34;&gt;Example: UDP echo server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-udp-echo-client&#34;&gt;Example: UDP echo client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-udp-multicast-server&#34;&gt;Example: UDP multicast server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-udp-multicast-client&#34;&gt;Example: UDP multicast client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-unix-domain-socket-chat-server&#34;&gt;Example: Unix Domain Socket chat server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-unix-domain-socket-chat-client&#34;&gt;Example: Unix Domain Socket chat client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-simple-protocol&#34;&gt;Example: Simple protocol&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-simple-protocol-server&#34;&gt;Example: Simple protocol server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-simple-protocol-client&#34;&gt;Example: Simple protocol client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-http-server&#34;&gt;Example: HTTP server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-http-client&#34;&gt;Example: HTTP client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-https-server&#34;&gt;Example: HTTPS server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-https-client&#34;&gt;Example: HTTPS client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-websocket-chat-server&#34;&gt;Example: WebSocket chat server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-websocket-chat-client&#34;&gt;Example: WebSocket chat client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-websocket-secure-chat-server&#34;&gt;Example: WebSocket secure chat server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-websocket-secure-chat-client&#34;&gt;Example: WebSocket secure chat client&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#performance&#34;&gt;Performance&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#benchmark-round-trip&#34;&gt;Benchmark: Round-Trip&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#tcp-echo-server&#34;&gt;TCP echo server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#ssl-echo-server&#34;&gt;SSL echo server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#udp-echo-server&#34;&gt;UDP echo server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#unix-domain-socket-echo-server&#34;&gt;Unix Domain Socket echo server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#simple-protocol-server&#34;&gt;Simple protocol server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#websocket-echo-server&#34;&gt;WebSocket echo server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#websocket-secure-echo-server&#34;&gt;WebSocket secure echo server&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#benchmark-multicast&#34;&gt;Benchmark: Multicast&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#tcp-multicast-server&#34;&gt;TCP multicast server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#ssl-multicast-server&#34;&gt;SSL multicast server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#udp-multicast-server&#34;&gt;UDP multicast server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#unix-domain-socket-multicast-server&#34;&gt;Unix Domain Socket multicast server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#websocket-multicast-server&#34;&gt;WebSocket multicast server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#websocket-secure-multicast-server&#34;&gt;WebSocket secure multicast server&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#benchmark-web-server&#34;&gt;Benchmark: Web Server&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#http-trace-server&#34;&gt;HTTP Trace server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#https-trace-server&#34;&gt;HTTPS Trace server&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#openssl-certificates&#34;&gt;OpenSSL certificates&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#production&#34;&gt;Production&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#development&#34;&gt;Development&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#certificate-authority&#34;&gt;Certificate Authority&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#ssl-server-certificate&#34;&gt;SSL Server certificate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#ssl-client-certificate&#34;&gt;SSL Client certificate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#diffie-hellman-key-exchange&#34;&gt;Diffie-Hellman key exchange&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cross platform (Linux, MacOS, Windows)&lt;/li&gt; &#xA; &lt;li&gt;Asynchronous communication&lt;/li&gt; &#xA; &lt;li&gt;Supported transport protocols: &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-tcp-chat-server&#34;&gt;TCP&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-ssl-chat-server&#34;&gt;SSL&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-udp-echo-server&#34;&gt;UDP&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-udp-multicast-server&#34;&gt;UDP multicast&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-unix-domain-socket-chat-server&#34;&gt;Unix Domain Socket&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Supported Web protocols: &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-http-server&#34;&gt;HTTP&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-https-server&#34;&gt;HTTPS&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-websocket-chat-server&#34;&gt;WebSocket&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/chronoxor/NetCoreServer/master/#example-websocket-secure-chat-server&#34;&gt;WebSocket secure&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Supported &lt;a href=&#34;https://swagger.io/specification/&#34;&gt;Swagger OpenAPI&lt;/a&gt; iterative documentation&lt;/li&gt; &#xA; &lt;li&gt;Supported message protocol based on &lt;a href=&#34;https://github.com/chronoxor/FastBinaryEncoding&#34;&gt;Fast Binary Encoding&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux&lt;/li&gt; &#xA; &lt;li&gt;MacOS&lt;/li&gt; &#xA; &lt;li&gt;Windows&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dotnet.microsoft.com/en-us/download/dotnet/6.0&#34;&gt;.NET 6.0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.7-zip.org&#34;&gt;7-Zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.cmake.org&#34;&gt;cmake&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://git-scm.com&#34;&gt;git&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.visualstudio.com&#34;&gt;Visual Studio&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Optional:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/rider&#34;&gt;Rider&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to build?&lt;/h1&gt; &#xA;&lt;h3&gt;Setup repository&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/chronoxor/NetCoreServer.git&#xA;cd NetCoreServer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Linux&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd build&#xA;./unix.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MacOS&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd build&#xA;./unix.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows (Visual Studio)&lt;/h3&gt; &#xA;&lt;p&gt;Open and build &lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/NetCoreServer.sln&#34;&gt;NetCoreServer.sln&lt;/a&gt; or run the build script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd build&#xA;vs.bat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The build script will create &#34;release&#34; directory with zip files:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NetCoreServer.zip - C# Server assembly&lt;/li&gt; &#xA; &lt;li&gt;Benchmarks.zip - C# Server benchmarks&lt;/li&gt; &#xA; &lt;li&gt;Examples.zip - C# Server examples&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;h2&gt;Example: TCP chat server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the TCP chat server. It handles multiple TCP client sessions and multicast received message from any session to all ones. Also it is possible to send admin message directly from the server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace TcpChatServer&#xA;{&#xA;    class ChatSession : TcpSession&#xA;    {&#xA;        public ChatSession(TcpServer server) : base(server) {}&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat TCP session with Id {Id} connected!&#34;);&#xA;&#xA;            // Send invite message&#xA;            string message = &#34;Hello from TCP chat! Please send a message or &#39;!&#39; to disconnect the client!&#34;;&#xA;            SendAsync(message);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat TCP session with Id {Id} disconnected!&#34;);&#xA;        }&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            string message = Encoding.UTF8.GetString(buffer, (int)offset, (int)size);&#xA;            Console.WriteLine(&#34;Incoming: &#34; + message);&#xA;&#xA;            // Multicast message to all connected sessions&#xA;            Server.Multicast(message);&#xA;&#xA;            // If the buffer starts with &#39;!&#39; the disconnect the current session&#xA;            if (message == &#34;!&#34;)&#xA;                Disconnect();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat TCP session caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class ChatServer : TcpServer&#xA;    {&#xA;        public ChatServer(IPAddress address, int port) : base(address, port) {}&#xA;&#xA;        protected override TcpSession CreateSession() { return new ChatSession(this); }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat TCP server caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // TCP server port&#xA;            int port = 1111;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;&#xA;            Console.WriteLine($&#34;TCP server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new TCP chat server&#xA;            var server = new ChatServer(IPAddress.Any, port);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Multicast admin message to all sessions&#xA;                line = &#34;(admin) &#34; + line;&#xA;                server.Multicast(line);&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: TCP chat client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the TCP chat client. It connects to the TCP chat server and allows to send message to it and receive new messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using TcpClient = NetCoreServer.TcpClient;&#xA;&#xA;namespace TcpChatClient&#xA;{&#xA;    class ChatClient : TcpClient&#xA;    {&#xA;        public ChatClient(string address, int port) : base(address, port) {}&#xA;&#xA;        public void DisconnectAndStop()&#xA;        {&#xA;            _stop = true;&#xA;            DisconnectAsync();&#xA;            while (IsConnected)&#xA;                Thread.Yield();&#xA;        }&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat TCP client connected a new session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat TCP client disconnected a session with Id {Id}&#34;);&#xA;&#xA;            // Wait for a while...&#xA;            Thread.Sleep(1000);&#xA;&#xA;            // Try to connect again&#xA;            if (!_stop)&#xA;                ConnectAsync();&#xA;        }&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine(Encoding.UTF8.GetString(buffer, (int)offset, (int)size));&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat TCP client caught an error with code {error}&#34;);&#xA;        }&#xA;&#xA;        private bool _stop;&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // TCP server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // TCP server port&#xA;            int port = 1111;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;TCP server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;TCP server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new TCP chat client&#xA;            var client = new ChatClient(address, port);&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.ConnectAsync();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Disconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client disconnecting...&#34;);&#xA;                    client.DisconnectAsync();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Send the entered text to the chat server&#xA;                client.SendAsync(line);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: SSL chat server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the SSL chat server. It handles multiple SSL client sessions and multicast received message from any session to all ones. Also it is possible to send admin message directly from the server.&lt;/p&gt; &#xA;&lt;p&gt;This example is very similar to the TCP one except the code that prepares SSL context and handshake handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Security.Authentication;&#xA;using System.Security.Cryptography.X509Certificates;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace SslChatServer&#xA;{&#xA;    class ChatSession : SslSession&#xA;    {&#xA;        public ChatSession(SslServer server) : base(server) {}&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL session with Id {Id} connected!&#34;);&#xA;        }&#xA;&#xA;        protected override void OnHandshaked()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL session with Id {Id} handshaked!&#34;);&#xA;&#xA;            // Send invite message&#xA;            string message = &#34;Hello from SSL chat! Please send a message or &#39;!&#39; to disconnect the client!&#34;;&#xA;            Send(message);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL session with Id {Id} disconnected!&#34;);&#xA;        }&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            string message = Encoding.UTF8.GetString(buffer, (int)offset, (int)size);&#xA;            Console.WriteLine(&#34;Incoming: &#34; + message);&#xA;&#xA;            // Multicast message to all connected sessions&#xA;            Server.Multicast(message);&#xA;&#xA;            // If the buffer starts with &#39;!&#39; the disconnect the current session&#xA;            if (message == &#34;!&#34;)&#xA;                Disconnect();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL session caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class ChatServer : SslServer&#xA;    {&#xA;        public ChatServer(SslContext context, IPAddress address, int port) : base(context, address, port) {}&#xA;&#xA;        protected override SslSession CreateSession() { return new ChatSession(this); }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL server caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // SSL server port&#xA;            int port = 2222;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;&#xA;            Console.WriteLine($&#34;SSL server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create and prepare a new SSL server context&#xA;            var context = new SslContext(SslProtocols.Tls12, new X509Certificate2(&#34;server.pfx&#34;, &#34;qwerty&#34;));&#xA;&#xA;            // Create a new SSL chat server&#xA;            var server = new ChatServer(context, IPAddress.Any, port);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Multicast admin message to all sessions&#xA;                line = &#34;(admin) &#34; + line;&#xA;                server.Multicast(line);&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: SSL chat client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the SSL chat client. It connects to the SSL chat server and allows to send message to it and receive new messages.&lt;/p&gt; &#xA;&lt;p&gt;This example is very similar to the TCP one except the code that prepares SSL context and handshake handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net.Sockets;&#xA;using System.Security.Authentication;&#xA;using System.Security.Cryptography.X509Certificates;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using NetCoreServer;&#xA;&#xA;namespace SslChatClient&#xA;{&#xA;    class ChatClient : SslClient&#xA;    {&#xA;        public ChatClient(SslContext context, string address, int port) : base(context, address, port) {}&#xA;&#xA;        public void DisconnectAndStop()&#xA;        {&#xA;            _stop = true;&#xA;            DisconnectAsync();&#xA;            while (IsConnected)&#xA;                Thread.Yield();&#xA;        }&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL client connected a new session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnHandshaked()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL client handshaked a new session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL client disconnected a session with Id {Id}&#34;);&#xA;&#xA;            // Wait for a while...&#xA;            Thread.Sleep(1000);&#xA;&#xA;            // Try to connect again&#xA;            if (!_stop)&#xA;                ConnectAsync();&#xA;        }&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine(Encoding.UTF8.GetString(buffer, (int)offset, (int)size));&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat SSL client caught an error with code {error}&#34;);&#xA;        }&#xA;&#xA;        private bool _stop;&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // SSL server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // SSL server port&#xA;            int port = 2222;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;SSL server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;SSL server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create and prepare a new SSL client context&#xA;            var context = new SslContext(SslProtocols.Tls12, new X509Certificate2(&#34;client.pfx&#34;, &#34;qwerty&#34;), (sender, certificate, chain, sslPolicyErrors) =&amp;gt; true);&#xA;&#xA;            // Create a new SSL chat client&#xA;            var client = new ChatClient(context, address, port);&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.ConnectAsync();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Disconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client disconnecting...&#34;);&#xA;                    client.DisconnectAsync();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Send the entered text to the chat server&#xA;                client.SendAsync(line);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: UDP echo server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the UDP echo server. It receives a datagram mesage from any UDP client and resend it back without any changes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace UdpEchoServer&#xA;{&#xA;    class EchoServer : UdpServer&#xA;    {&#xA;        public EchoServer(IPAddress address, int port) : base(address, port) {}&#xA;&#xA;        protected override void OnStarted()&#xA;        {&#xA;            // Start receive datagrams&#xA;            ReceiveAsync();&#xA;        }&#xA;&#xA;        protected override void OnReceived(EndPoint endpoint, byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine(&#34;Incoming: &#34; + Encoding.UTF8.GetString(buffer, (int)offset, (int)size));&#xA;&#xA;            // Echo the message back to the sender&#xA;            SendAsync(endpoint, buffer, 0, size);&#xA;        }&#xA;&#xA;        protected override void OnSent(EndPoint endpoint, long sent)&#xA;        {&#xA;            // Continue receive datagrams&#xA;            ReceiveAsync();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Echo UDP server caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // UDP server port&#xA;            int port = 3333;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;&#xA;            Console.WriteLine($&#34;UDP server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new UDP echo server&#xA;            var server = new EchoServer(IPAddress.Any, port);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                }&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: UDP echo client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the UDP echo client. It sends user datagram message to UDP server and listen for response.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using UdpClient = NetCoreServer.UdpClient;&#xA;&#xA;namespace UdpEchoClient&#xA;{&#xA;    class EchoClient : UdpClient&#xA;    {&#xA;        public EchoClient(string address, int port) : base(address, port) {}&#xA;&#xA;        public void DisconnectAndStop()&#xA;        {&#xA;            _stop = true;&#xA;            Disconnect();&#xA;            while (IsConnected)&#xA;                Thread.Yield();&#xA;        }&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Echo UDP client connected a new session with Id {Id}&#34;);&#xA;&#xA;            // Start receive datagrams&#xA;            ReceiveAsync();&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Echo UDP client disconnected a session with Id {Id}&#34;);&#xA;&#xA;            // Wait for a while...&#xA;            Thread.Sleep(1000);&#xA;&#xA;            // Try to connect again&#xA;            if (!_stop)&#xA;                Connect();&#xA;        }&#xA;&#xA;        protected override void OnReceived(EndPoint endpoint, byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine(&#34;Incoming: &#34; + Encoding.UTF8.GetString(buffer, (int)offset, (int)size));&#xA;&#xA;            // Continue receive datagrams&#xA;            ReceiveAsync();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Echo UDP client caught an error with code {error}&#34;);&#xA;        }&#xA;&#xA;        private bool _stop;&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // UDP server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // UDP server port&#xA;            int port = 3333;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;UDP server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;UDP server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new TCP chat client&#xA;            var client = new EchoClient(address, port);&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.Connect();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Disconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client disconnecting...&#34;);&#xA;                    client.Disconnect();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Send the entered text to the chat server&#xA;                client.Send(line);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: UDP multicast server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the UDP multicast server. It use multicast IP address to multicast datagram messages to all client that joined corresponding UDP multicast group.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using NetCoreServer;&#xA;&#xA;namespace UdpMulticastServer&#xA;{&#xA;    class MulticastServer : UdpServer&#xA;    {&#xA;        public MulticastServer(IPAddress address, int port) : base(address, port) {}&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Multicast UDP server caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // UDP multicast address&#xA;            string multicastAddress = &#34;239.255.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                multicastAddress = args[0];&#xA;&#xA;            // UDP multicast port&#xA;            int multicastPort = 3334;&#xA;            if (args.Length &amp;gt; 1)&#xA;                multicastPort = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;UDP multicast address: {multicastAddress}&#34;);&#xA;            Console.WriteLine($&#34;UDP multicast port: {multicastPort}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new UDP multicast server&#xA;            var server = new MulticastServer(IPAddress.Any, 0);&#xA;&#xA;            // Start the multicast server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start(multicastAddress, multicastPort);&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Multicast admin message to all sessions&#xA;                line = &#34;(admin) &#34; + line;&#xA;                server.Multicast(line);&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: UDP multicast client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the UDP multicast client. It use multicast IP address and joins UDP multicast group in order to receive multicasted datagram messages from UDP server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using UdpClient = NetCoreServer.UdpClient;&#xA;&#xA;namespace UdpMulticastClient&#xA;{&#xA;    class MulticastClient : UdpClient&#xA;    {&#xA;        public string Multicast;&#xA;&#xA;        public MulticastClient(string address, int port) : base(address, port) {}&#xA;&#xA;        public void DisconnectAndStop()&#xA;        {&#xA;            _stop = true;&#xA;            Disconnect();&#xA;            while (IsConnected)&#xA;                Thread.Yield();&#xA;        }&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Multicast UDP client connected a new session with Id {Id}&#34;);&#xA;&#xA;            // Join UDP multicast group&#xA;            JoinMulticastGroup(Multicast);&#xA;&#xA;            // Start receive datagrams&#xA;            ReceiveAsync();&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Multicast UDP client disconnected a session with Id {Id}&#34;);&#xA;&#xA;            // Wait for a while...&#xA;            Thread.Sleep(1000);&#xA;&#xA;            // Try to connect again&#xA;            if (!_stop)&#xA;                Connect();&#xA;        }&#xA;&#xA;        protected override void OnReceived(EndPoint endpoint, byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine(&#34;Incoming: &#34; + Encoding.UTF8.GetString(buffer, (int)offset, (int)size));&#xA;&#xA;            // Continue receive datagrams&#xA;            ReceiveAsync();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Multicast UDP client caught an error with code {error}&#34;);&#xA;        }&#xA;&#xA;        private bool _stop;&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // UDP listen address&#xA;            string listenAddress = &#34;0.0.0.0&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                listenAddress = args[0];&#xA;&#xA;            // UDP multicast address&#xA;            string multicastAddress = &#34;239.255.0.1&#34;;&#xA;            if (args.Length &amp;gt; 1)&#xA;                multicastAddress = args[1];&#xA;&#xA;            // UDP multicast port&#xA;            int multicastPort = 3334;&#xA;            if (args.Length &amp;gt; 2)&#xA;                multicastPort = int.Parse(args[2]);&#xA;&#xA;            Console.WriteLine($&#34;UDP listen address: {listenAddress}&#34;);&#xA;            Console.WriteLine($&#34;UDP multicast address: {multicastAddress}&#34;);&#xA;            Console.WriteLine($&#34;UDP multicast port: {multicastPort}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new TCP chat client&#xA;            var client = new MulticastClient(listenAddress, multicastPort);&#xA;            client.SetupMulticast(true);&#xA;            client.Multicast = multicastAddress;&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.Connect();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Disconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client disconnecting...&#34;);&#xA;                    client.Disconnect();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: Unix Domain Socket chat server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the Unix Domain Socket chat server. It handles multiple Unix Domain Socket client sessions and multicast received message from any session to all ones. Also it is possible to send admin message directly from the server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.IO;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace UdsChatServer&#xA;{&#xA;    class ChatSession : UdsSession&#xA;    {&#xA;        public ChatSession(UdsServer server) : base(server) {}&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat Unix Domain Socket session with Id {Id} connected!&#34;);&#xA;&#xA;            // Send invite message&#xA;            string message = &#34;Hello from Unix Domain Socket chat! Please send a message or &#39;!&#39; to disconnect the client!&#34;;&#xA;            SendAsync(message);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat Unix Domain Socket session with Id {Id} disconnected!&#34;);&#xA;        }&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            string message = Encoding.UTF8.GetString(buffer, (int)offset, (int)size);&#xA;            Console.WriteLine(&#34;Incoming: &#34; + message);&#xA;&#xA;            // Multicast message to all connected sessions&#xA;            Server.Multicast(message);&#xA;&#xA;            // If the buffer starts with &#39;!&#39; the disconnect the current session&#xA;            if (message == &#34;!&#34;)&#xA;                Disconnect();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat Unix Domain Socket session caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class ChatServer : UdsServer&#xA;    {&#xA;        public ChatServer(string path) : base(path) {}&#xA;&#xA;        protected override UdsSession CreateSession() { return new ChatSession(this); }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat Unix Domain Socket server caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // Unix Domain Socket path&#xA;            string path = Path.Combine(Path.GetTempPath(), &#34;chat.sock&#34;);&#xA;            if (args.Length &amp;gt; 0)&#xA;                path = args[0];&#xA;&#xA;            Console.WriteLine($&#34;Unix Domain Socket server path: {path}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new Unix Domain Socket chat server&#xA;            var server = new ChatServer(path);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Multicast admin message to all sessions&#xA;                line = &#34;(admin) &#34; + line;&#xA;                server.Multicast(line);&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: Unix Domain Socket chat client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the Unix Domain Socket chat client. It connects to the Unix Domain Socket chat server and allows to send message to it and receive new messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.IO;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using UdsClient = NetCoreServer.UdsClient;&#xA;&#xA;namespace UdsChatClient&#xA;{&#xA;    class ChatClient : UdsClient&#xA;    {&#xA;        public ChatClient(string path) : base(path) {}&#xA;&#xA;        public void DisconnectAndStop()&#xA;        {&#xA;            _stop = true;&#xA;            DisconnectAsync();&#xA;            while (IsConnected)&#xA;                Thread.Yield();&#xA;        }&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat Unix Domain Socket client connected a new session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat Unix Domain Socket client disconnected a session with Id {Id}&#34;);&#xA;&#xA;            // Wait for a while...&#xA;            Thread.Sleep(1000);&#xA;&#xA;            // Try to connect again&#xA;            if (!_stop)&#xA;                ConnectAsync();&#xA;        }&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine(Encoding.UTF8.GetString(buffer, (int)offset, (int)size));&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat Unix Domain Socket client caught an error with code {error}&#34;);&#xA;        }&#xA;&#xA;        private bool _stop;&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // Unix Domain Socket path&#xA;            string path = Path.Combine(Path.GetTempPath(), &#34;chat.sock&#34;);&#xA;            if (args.Length &amp;gt; 0)&#xA;                path = args[0];&#xA;&#xA;            Console.WriteLine($&#34;Unix Domain Socket server path: {path}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new Unix Domain Socket chat client&#xA;            var client = new ChatClient(path);&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.ConnectAsync();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Disconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client disconnecting...&#34;);&#xA;                    client.DisconnectAsync();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Send the entered text to the chat server&#xA;                client.SendAsync(line);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: Simple protocol&lt;/h2&gt; &#xA;&lt;p&gt;Simple protocol is defined in &lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/proto/simple.fbe&#34;&gt;simple.fbe&lt;/a&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;/*&#xA;   Simple Fast Binary Encoding protocol for CppServer&#xA;   https://github.com/chronoxor/FastBinaryEncoding&#xA;&#xA;   Generate protocol command: fbec --csharp --proto --input=simple.fbe --output=.&#xA;*/&#xA;&#xA;// Domain declaration&#xA;domain com.chronoxor&#xA;&#xA;// Package declaration&#xA;package simple&#xA;&#xA;// Protocol version&#xA;version 1.0&#xA;&#xA;// Simple request message&#xA;[request]&#xA;[response(SimpleResponse)]&#xA;[reject(SimpleReject)]&#xA;message SimpleRequest&#xA;{&#xA;    // Request Id&#xA;    uuid [id] = uuid1;&#xA;    // Request message&#xA;    string Message;&#xA;}&#xA;&#xA;// Simple response&#xA;message SimpleResponse&#xA;{&#xA;    // Response Id&#xA;    uuid [id] = uuid1;&#xA;    // Calculated message length&#xA;    uint32 Length;&#xA;    // Calculated message hash&#xA;    uint32 Hash;&#xA;}&#xA;&#xA;// Simple reject&#xA;message SimpleReject&#xA;{&#xA;    // Reject Id&#xA;    uuid [id] = uuid1;&#xA;    // Error message&#xA;    string Error;&#xA;}&#xA;&#xA;// Simple notification&#xA;message SimpleNotify&#xA;{&#xA;    // Server notification&#xA;    string Notification;&#xA;}&#xA;&#xA;// Disconnect request message&#xA;[request]&#xA;message DisconnectRequest&#xA;{&#xA;    // Request Id&#xA;    uuid [id] = uuid1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: Simple protocol server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the simple protocol server. It process client requests, answer with corresponding responses and send server notifications back to clients.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using NetCoreServer;&#xA;&#xA;using com.chronoxor.simple;&#xA;using com.chronoxor.simple.FBE;&#xA;&#xA;namespace ProtoServer&#xA;{&#xA;    public class SimpleProtoSessionSender : Sender, ISenderListener&#xA;    {&#xA;        public SimpleProtoSession Session { get; }&#xA;&#xA;        public SimpleProtoSessionSender(SimpleProtoSession session) { Session = session; }&#xA;&#xA;        public long OnSend(byte[] buffer, long offset, long size)&#xA;        {&#xA;            return Session.SendAsync(buffer, offset, size) ? size : 0;&#xA;        }&#xA;    }&#xA;&#xA;    public class SimpleProtoSessionReceiver : Receiver, IReceiverListener&#xA;    {&#xA;        public SimpleProtoSession Session { get; }&#xA;&#xA;        public SimpleProtoSessionReceiver(SimpleProtoSession session) { Session = session; }&#xA;&#xA;        public void OnReceive(DisconnectRequest request) { Session.OnReceive(request); }&#xA;        public void OnReceive(SimpleRequest request) { Session.OnReceive(request); }&#xA;    }&#xA;&#xA;    public class SimpleProtoSession : TcpSession&#xA;    {&#xA;        public SimpleProtoSessionSender Sender { get; }&#xA;        public SimpleProtoSessionReceiver Receiver { get; }&#xA;&#xA;        public SimpleProtoSession(TcpServer server) : base(server)&#xA;        {&#xA;            Sender = new SimpleProtoSessionSender(this);&#xA;            Receiver = new SimpleProtoSessionReceiver(this);&#xA;        }&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol session with Id &#39;{Id}&#39; connected to remote address &#39;{(Socket.RemoteEndPoint as IPEndPoint)?.Address}&#39; and port {(Socket.RemoteEndPoint as IPEndPoint)?.Port}&#34;);&#xA;&#xA;            // Send invite notification&#xA;            SimpleNotify notify = SimpleNotify.Default;&#xA;            notify.Notification = &#34;Hello from Simple protocol server! Please send a message or &#39;!&#39; to disconnect the client!&#34;;&#xA;            Sender.Send(notify);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol session with Id &#39;{Id}&#39; disconnected&#34;);&#xA;        }&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Receiver.Receive(buffer, offset, size);&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol session with Id &#39;{Id}&#39; caught a socket error: {error}&#34;);&#xA;        }&#xA;&#xA;        // Protocol handlers&#xA;        public void OnReceive(DisconnectRequest request) { Disconnect(); }&#xA;        public void OnReceive(SimpleRequest request)&#xA;        {&#xA;            Console.WriteLine($&#34;Received: {request}&#34;);&#xA;&#xA;            // Validate request&#xA;            if (string.IsNullOrEmpty(request.Message))&#xA;            {&#xA;                // Send reject&#xA;                SimpleReject reject = SimpleReject.Default;&#xA;                reject.id = request.id;&#xA;                reject.Error = &#34;Request message is empty!&#34;;&#xA;                Sender.Send(reject);&#xA;                return;&#xA;            }&#xA;&#xA;            // Send response&#xA;            SimpleResponse response = SimpleResponse.Default;&#xA;            response.id = request.id;&#xA;            response.Hash = (uint)request.Message.GetHashCode();&#xA;            response.Length = (uint)request.Message.Length;&#xA;            Sender.Send(response);&#xA;        }&#xA;    }&#xA;&#xA;    public class SimpleProtoSender : Sender, ISenderListener&#xA;    {&#xA;        public SimpleProtoServer Server { get; }&#xA;&#xA;        public SimpleProtoSender(SimpleProtoServer server) { Server = server; }&#xA;&#xA;        public long OnSend(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Server.Multicast(buffer, offset, size);&#xA;            return size;&#xA;        }&#xA;    }&#xA;&#xA;    public class SimpleProtoServer : TcpServer&#xA;    {&#xA;        public SimpleProtoSender Sender { get; }&#xA;&#xA;        public SimpleProtoServer(IPAddress address, int port) : base(address, port)&#xA;        {&#xA;            Sender = new SimpleProtoSender(this);&#xA;        }&#xA;&#xA;        protected override TcpSession CreateSession() { return new SimpleProtoSession(this); }&#xA;&#xA;        protected override void OnStarted()&#xA;        {&#xA;            Console.WriteLine($&#34;Simple protocol server with Id &#39;{Id}&#39; started!&#34;);&#xA;        }&#xA;&#xA;        protected override void OnStopped()&#xA;        {&#xA;            Console.WriteLine($&#34;Simple protocol server with Id &#39;{Id}&#39; stopped!&#34;);&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Simple protocol server with Id &#39;{Id}&#39; caught an error: {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // Simple protocol server port&#xA;            int port = 4444;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;&#xA;            Console.WriteLine($&#34;Simple protocol server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new simple protocol server&#xA;            var server = new SimpleProtoServer(IPAddress.Any, port);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Multicast admin notification to all sessions&#xA;                SimpleNotify notify = SimpleNotify.Default;&#xA;                notify.Notification = &#34;(admin) &#34; + line;&#xA;                server.Sender.Send(notify);&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: Simple protocol client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the simple protocol client. It connects to the simple protocol server and allows to send requests to it and receive corresponding responses.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net.Sockets;&#xA;using System.Threading;&#xA;using TcpClient = NetCoreServer.TcpClient;&#xA;&#xA;using com.chronoxor.simple;&#xA;using com.chronoxor.simple.FBE;&#xA;&#xA;namespace ProtoClient&#xA;{&#xA;    public class TcpProtoClient : TcpClient&#xA;    {&#xA;        public TcpProtoClient(string address, int port) : base(address, port) {}&#xA;&#xA;        public bool ConnectAndStart()&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol client starting a new session with Id &#39;{Id}&#39;...&#34;);&#xA;&#xA;            StartReconnectTimer();&#xA;            return ConnectAsync();&#xA;        }&#xA;&#xA;        public bool DisconnectAndStop()&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol client stopping the session with Id &#39;{Id}&#39;...&#34;);&#xA;&#xA;            StopReconnectTimer();&#xA;            DisconnectAsync();&#xA;            return true;&#xA;        }&#xA;&#xA;        public override bool Reconnect()&#xA;        {&#xA;            return ReconnectAsync();&#xA;        }&#xA;&#xA;        private Timer _reconnectTimer;&#xA;&#xA;        public void StartReconnectTimer()&#xA;        {&#xA;            // Start the reconnect timer&#xA;            _reconnectTimer = new Timer(state =&amp;gt;&#xA;            {&#xA;                Console.WriteLine($&#34;TCP reconnect timer connecting the client session with Id &#39;{Id}&#39;...&#34;);&#xA;                ConnectAsync();&#xA;            }, null, Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);&#xA;        }&#xA;&#xA;        public void StopReconnectTimer()&#xA;        {&#xA;            // Stop the reconnect timer&#xA;            _reconnectTimer?.Dispose();&#xA;            _reconnectTimer = null;&#xA;        }&#xA;&#xA;        public delegate void ConnectedHandler();&#xA;        public event ConnectedHandler Connected = () =&amp;gt; {};&#xA;&#xA;        protected override void OnConnected()&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol client connected a new session with Id &#39;{Id}&#39; to remote address &#39;{Address}&#39; and port {Port}&#34;);&#xA;&#xA;            Connected?.Invoke();&#xA;        }&#xA;&#xA;        public delegate void DisconnectedHandler();&#xA;        public event DisconnectedHandler Disconnected = () =&amp;gt; {};&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol client disconnected the session with Id &#39;{Id}&#39;&#34;);&#xA;&#xA;            // Setup and asynchronously wait for the reconnect timer&#xA;            _reconnectTimer?.Change(TimeSpan.FromSeconds(1), Timeout.InfiniteTimeSpan);&#xA;&#xA;            Disconnected?.Invoke();&#xA;        }&#xA;&#xA;        public delegate void ReceivedHandler(byte[] buffer, long offset, long size);&#xA;        public event ReceivedHandler Received = (buffer, offset, size) =&amp;gt; {};&#xA;&#xA;        protected override void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Received?.Invoke(buffer, offset, size);&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;TCP protocol client caught a socket error: {error}&#34;);&#xA;        }&#xA;&#xA;        #region IDisposable implementation&#xA;&#xA;        // Disposed flag.&#xA;        private bool _disposed;&#xA;&#xA;        protected override void Dispose(bool disposingManagedResources)&#xA;        {&#xA;            if (!_disposed)&#xA;            {&#xA;                if (disposingManagedResources)&#xA;                {&#xA;                    // Dispose managed resources here...&#xA;                    StopReconnectTimer();&#xA;                }&#xA;&#xA;                // Dispose unmanaged resources here...&#xA;&#xA;                // Set large fields to null here...&#xA;&#xA;                // Mark as disposed.&#xA;                _disposed = true;&#xA;            }&#xA;&#xA;            // Call Dispose in the base class.&#xA;            base.Dispose(disposingManagedResources);&#xA;        }&#xA;&#xA;        // The derived class does not have a Finalize method&#xA;        // or a Dispose method without parameters because it inherits&#xA;        // them from the base class.&#xA;&#xA;        #endregion&#xA;    }&#xA;&#xA;    public class SimpleProtoClient : Client, ISenderListener, IReceiverListener, IDisposable&#xA;    {&#xA;        private readonly TcpProtoClient _tcpProtoClient;&#xA;&#xA;        public Guid Id =&amp;gt; _tcpProtoClient.Id;&#xA;        public bool IsConnected =&amp;gt; _tcpProtoClient.IsConnected;&#xA;&#xA;        public SimpleProtoClient(string address, int port)&#xA;        {&#xA;            _tcpProtoClient = new TcpProtoClient(address, port);&#xA;            _tcpProtoClient.Connected += OnConnected;&#xA;            _tcpProtoClient.Disconnected += OnDisconnected;&#xA;            _tcpProtoClient.Received += OnReceived;&#xA;            ReceivedResponse_DisconnectRequest += HandleDisconnectRequest;&#xA;            ReceivedResponse_SimpleResponse += HandleSimpleResponse;&#xA;            ReceivedResponse_SimpleReject += HandleSimpleReject;&#xA;            ReceivedResponse_SimpleNotify += HandleSimpleNotify;&#xA;        }&#xA;&#xA;        private void DisposeClient()&#xA;        {&#xA;            _tcpProtoClient.Connected -= OnConnected;&#xA;            _tcpProtoClient.Connected -= OnDisconnected;&#xA;            _tcpProtoClient.Received -= OnReceived;&#xA;            ReceivedResponse_DisconnectRequest -= HandleDisconnectRequest;&#xA;            ReceivedResponse_SimpleResponse -= HandleSimpleResponse;&#xA;            ReceivedResponse_SimpleReject -= HandleSimpleReject;&#xA;            ReceivedResponse_SimpleNotify -= HandleSimpleNotify;&#xA;            _tcpProtoClient.Dispose();&#xA;        }&#xA;&#xA;        public bool ConnectAndStart() { return _tcpProtoClient.ConnectAndStart(); }&#xA;        public bool DisconnectAndStop() { return _tcpProtoClient.DisconnectAndStop(); }&#xA;        public bool Reconnect() { return _tcpProtoClient.Reconnect(); }&#xA;&#xA;        private bool _watchdog;&#xA;        private Thread _watchdogThread;&#xA;&#xA;        public bool StartWatchdog()&#xA;        {&#xA;            if (_watchdog)&#xA;                return false;&#xA;&#xA;            Console.WriteLine(&#34;Watchdog thread starting...&#34;);&#xA;&#xA;            // Start the watchdog thread&#xA;            _watchdog = true;&#xA;            _watchdogThread = new Thread(WatchdogThread);&#xA;&#xA;            Console.WriteLine(&#34;Watchdog thread started!&#34;);&#xA;&#xA;            return true;&#xA;        }&#xA;&#xA;        public bool StopWatchdog()&#xA;        {&#xA;            if (!_watchdog)&#xA;                return false;&#xA;&#xA;            Console.WriteLine(&#34;Watchdog thread stopping...&#34;);&#xA;&#xA;            // Stop the watchdog thread&#xA;            _watchdog = false;&#xA;            _watchdogThread.Join();&#xA;&#xA;            Console.WriteLine(&#34;Watchdog thread stopped!&#34;);&#xA;&#xA;            return true;&#xA;        }&#xA;&#xA;        public static void WatchdogThread(object obj)&#xA;        {&#xA;            var instance = obj as SimpleProtoClient;&#xA;            if (instance == null)&#xA;                return;&#xA;&#xA;            try&#xA;            {&#xA;                // Watchdog loop...&#xA;                while (instance._watchdog)&#xA;                {&#xA;                    var utc = DateTime.UtcNow;&#xA;&#xA;                    // Watchdog the client&#xA;                    instance.Watchdog(utc);&#xA;&#xA;                    // Sleep for a while...&#xA;                    Thread.Sleep(1000);&#xA;                }&#xA;            }&#xA;            catch (Exception e)&#xA;            {&#xA;                Console.WriteLine($&#34;Config client watchdog thread terminated: {e}&#34;);&#xA;            }&#xA;        }&#xA;&#xA;        #region Connection handlers&#xA;&#xA;        public delegate void ConnectedHandler();&#xA;        public event ConnectedHandler Connected = () =&amp;gt; {};&#xA;&#xA;        private void OnConnected()&#xA;        {&#xA;            // Reset FBE protocol buffers&#xA;            Reset();&#xA;&#xA;            Connected?.Invoke();&#xA;        }&#xA;&#xA;        public delegate void DisconnectedHandler();&#xA;        public event DisconnectedHandler Disconnected = () =&amp;gt; {};&#xA;&#xA;        private void OnDisconnected()&#xA;        {&#xA;            Disconnected?.Invoke();&#xA;        }&#xA;&#xA;        public long OnSend(byte[] buffer, long offset, long size)&#xA;        {&#xA;            return _tcpProtoClient.SendAsync(buffer, offset, size) ? size : 0;&#xA;        }&#xA;&#xA;        public void OnReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Receive(buffer, offset, size);&#xA;        }&#xA;&#xA;        #endregion&#xA;&#xA;        #region Protocol handlers&#xA;&#xA;        private void HandleDisconnectRequest(DisconnectRequest request) { Console.WriteLine($&#34;Received: {request}&#34;); _tcpProtoClient.DisconnectAsync(); }&#xA;        private void HandleSimpleResponse(SimpleResponse response) { Console.WriteLine($&#34;Received: {response}&#34;); }&#xA;        private void HandleSimpleReject(SimpleReject reject) { Console.WriteLine($&#34;Received: {reject}&#34;); }&#xA;        private void HandleSimpleNotify(SimpleNotify notify) { Console.WriteLine($&#34;Received: {notify}&#34;); }&#xA;&#xA;        #endregion&#xA;&#xA;        #region IDisposable implementation&#xA;&#xA;        // Disposed flag.&#xA;        private bool _disposed;&#xA;&#xA;        // Implement IDisposable.&#xA;        public void Dispose()&#xA;        {&#xA;            Dispose(true);&#xA;            GC.SuppressFinalize(this);&#xA;        }&#xA;&#xA;        protected virtual void Dispose(bool disposingManagedResources)&#xA;        {&#xA;            // The idea here is that Dispose(Boolean) knows whether it is&#xA;            // being called to do explicit cleanup (the Boolean is true)&#xA;            // versus being called due to a garbage collection (the Boolean&#xA;            // is false). This distinction is useful because, when being&#xA;            // disposed explicitly, the Dispose(Boolean) method can safely&#xA;            // execute code using reference type fields that refer to other&#xA;            // objects knowing for sure that these other objects have not been&#xA;            // finalized or disposed of yet. When the Boolean is false,&#xA;            // the Dispose(Boolean) method should not execute code that&#xA;            // refer to reference type fields because those objects may&#xA;            // have already been finalized.&#34;&#xA;&#xA;            if (!_disposed)&#xA;            {&#xA;                if (disposingManagedResources)&#xA;                {&#xA;                    // Dispose managed resources here...&#xA;                    DisposeClient();&#xA;                }&#xA;&#xA;                // Dispose unmanaged resources here...&#xA;&#xA;                // Set large fields to null here...&#xA;&#xA;                // Mark as disposed.&#xA;                _disposed = true;&#xA;            }&#xA;        }&#xA;&#xA;        #endregion&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // Simple protocol server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // Simple protocol server port&#xA;            int port = 4444;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;Simple protocol server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;Simple protocol server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new simple protocol chat client&#xA;            var client = new SimpleProtoClient(address, port);&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.ConnectAndStart();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Disconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client disconnecting...&#34;);&#xA;                    client.Reconnect();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Send request to the simple protocol server&#xA;                SimpleRequest request = SimpleRequest.Default;&#xA;                request.Message = line;&#xA;                var response = client.Request(request).Result;&#xA;&#xA;                // Show string hash calculation result&#xA;                Console.WriteLine($&#34;Hash of &#39;{line}&#39; = 0x{response.Hash:X8}&#34;);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: HTTP server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the HTTP cache server. It allows to manipulate cache data with HTTP methods (GET, POST, PUT and DELETE).&lt;/p&gt; &#xA;&lt;p&gt;Use the following link to open &lt;a href=&#34;https://swagger.io/specification/&#34;&gt;Swagger OpenAPI&lt;/a&gt; iterative documentation: &lt;a href=&#34;http://localhost:8080/api/index.html&#34;&gt;http://localhost:8080/api/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/images/openapi-http.png&#34; alt=&#34;OpenAPI-HTTP&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Collections.Concurrent;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace HttpServer&#xA;{&#xA;    class CommonCache&#xA;    {&#xA;        public static CommonCache GetInstance()&#xA;        {&#xA;            if (_instance == null)&#xA;                _instance = new CommonCache();&#xA;            return _instance;&#xA;        }&#xA;&#xA;        public string GetAllCache()&#xA;        {&#xA;            var result = new StringBuilder();&#xA;            result.Append(&#34;[\n&#34;);&#xA;            foreach (var item in _cache)&#xA;            {&#xA;                result.Append(&#34;  {\n&#34;);&#xA;                result.AppendFormat($&#34;    \&#34;key\&#34;: \&#34;{item.Key}\&#34;,\n&#34;);&#xA;                result.AppendFormat($&#34;    \&#34;value\&#34;: \&#34;{item.Value}\&#34;,\n&#34;);&#xA;                result.Append(&#34;  },\n&#34;);&#xA;            }&#xA;            result.Append(&#34;]\n&#34;);&#xA;            return result.ToString();&#xA;        }&#xA;&#xA;        public bool GetCacheValue(string key, out string value)&#xA;        {&#xA;            return _cache.TryGetValue(key, out value);&#xA;        }&#xA;&#xA;        public void PutCacheValue(string key, string value)&#xA;        {&#xA;            _cache[key] = value;&#xA;        }&#xA;&#xA;        public bool DeleteCacheValue(string key, out string value)&#xA;        {&#xA;            return _cache.TryRemove(key, out value);&#xA;        }&#xA;&#xA;        private readonly ConcurrentDictionary&amp;lt;string, string&amp;gt; _cache = new ConcurrentDictionary&amp;lt;string, string&amp;gt;();&#xA;        private static CommonCache _instance;&#xA;    }&#xA;&#xA;    class HttpCacheSession : HttpSession&#xA;    {&#xA;        public HttpCacheSession(NetCoreServer.HttpServer server) : base(server) {}&#xA;&#xA;        protected override void OnReceivedRequest(HttpRequest request)&#xA;        {&#xA;            // Show HTTP request content&#xA;            Console.WriteLine(request);&#xA;&#xA;            // Process HTTP request methods&#xA;            if (request.Method == &#34;HEAD&#34;)&#xA;                SendResponseAsync(Response.MakeHeadResponse());&#xA;            else if (request.Method == &#34;GET&#34;)&#xA;            {&#xA;                string key = request.Url;&#xA;&#xA;                // Decode the key value&#xA;                key = Uri.UnescapeDataString(key);&#xA;                key = key.Replace(&#34;/api/cache&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;                key = key.Replace(&#34;?key=&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;&#xA;                if (string.IsNullOrEmpty(key))&#xA;                {&#xA;                    // Response with all cache values&#xA;                    SendResponseAsync(Response.MakeGetResponse(CommonCache.GetInstance().GetAllCache(), &#34;application/json; charset=UTF-8&#34;));&#xA;                }&#xA;                // Get the cache value by the given key&#xA;                else if (CommonCache.GetInstance().GetCacheValue(key, out var value))&#xA;                {&#xA;                    // Response with the cache value&#xA;                    SendResponseAsync(Response.MakeGetResponse(value));&#xA;                }&#xA;                else&#xA;                    SendResponseAsync(Response.MakeErrorResponse(404, &#34;Required cache value was not found for the key: &#34; + key));&#xA;            }&#xA;            else if ((request.Method == &#34;POST&#34;) || (request.Method == &#34;PUT&#34;))&#xA;            {&#xA;                string key = request.Url;&#xA;                string value = request.Body;&#xA;&#xA;                // Decode the key value&#xA;                key = Uri.UnescapeDataString(key);&#xA;                key = key.Replace(&#34;/api/cache&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;                key = key.Replace(&#34;?key=&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;&#xA;                // Put the cache value&#xA;                CommonCache.GetInstance().PutCacheValue(key, value);&#xA;&#xA;                // Response with the cache value&#xA;                SendResponseAsync(Response.MakeOkResponse());&#xA;            }&#xA;            else if (request.Method == &#34;DELETE&#34;)&#xA;            {&#xA;                string key = request.Url;&#xA;&#xA;                // Decode the key value&#xA;                key = Uri.UnescapeDataString(key);&#xA;                key = key.Replace(&#34;/api/cache&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;                key = key.Replace(&#34;?key=&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;&#xA;                // Delete the cache value&#xA;                if (CommonCache.GetInstance().DeleteCacheValue(key, out var value))&#xA;                {&#xA;                    // Response with the cache value&#xA;                    SendResponseAsync(Response.MakeGetResponse(value));&#xA;                }&#xA;                else&#xA;                    SendResponseAsync(Response.MakeErrorResponse(404, &#34;Deleted cache value was not found for the key: &#34; + key));&#xA;            }&#xA;            else if (request.Method == &#34;OPTIONS&#34;)&#xA;                SendResponseAsync(Response.MakeOptionsResponse());&#xA;            else if (request.Method == &#34;TRACE&#34;)&#xA;                SendResponseAsync(Response.MakeTraceResponse(request.Cache.Data));&#xA;            else&#xA;                SendResponseAsync(Response.MakeErrorResponse(&#34;Unsupported HTTP method: &#34; + request.Method));&#xA;        }&#xA;&#xA;        protected override void OnReceivedRequestError(HttpRequest request, string error)&#xA;        {&#xA;            Console.WriteLine($&#34;Request error: {error}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;HTTP session caught an error: {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class HttpCacheServer : NetCoreServer.HttpServer&#xA;    {&#xA;        public HttpCacheServer(IPAddress address, int port) : base(address, port) {}&#xA;&#xA;        protected override TcpSession CreateSession() { return new HttpCacheSession(this); }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;HTTP session caught an error: {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // HTTP server port&#xA;            int port = 8080;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;            // HTTP server content path&#xA;            string www = &#34;../../../../../www/api&#34;;&#xA;            if (args.Length &amp;gt; 1)&#xA;                www = args[1];&#xA;&#xA;            Console.WriteLine($&#34;HTTP server port: {port}&#34;);&#xA;            Console.WriteLine($&#34;HTTP server static content path: {www}&#34;);&#xA;            Console.WriteLine($&#34;HTTP server website: http://localhost:{port}/api/index.html&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new HTTP server&#xA;            var server = new HttpCacheServer(IPAddress.Any, port);&#xA;            server.AddStaticContent(www, &#34;/api&#34;);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                }&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: HTTP client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the HTTP client. It allows to send HTTP requests (GET, POST, PUT and DELETE) and receive HTTP responses.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using NetCoreServer;&#xA;&#xA;namespace HttpClient&#xA;{&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // HTTP server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // HTTP server port&#xA;            int port = 8080;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;HTTP server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;HTTP server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new HTTP client&#xA;            var client = new HttpClientEx(address, port);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Reconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client reconnecting...&#34;);&#xA;                    if (client.IsConnected)&#xA;                        client.ReconnectAsync();&#xA;                    else&#xA;                        client.ConnectAsync();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                var commands = line.Split(&#39; &#39;);&#xA;                if (commands.Length &amp;lt; 2)&#xA;                {&#xA;                    Console.WriteLine(&#34;HTTP method and URL must be entered!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                if (commands[0].ToUpper() == &#34;HEAD&#34;)&#xA;                {&#xA;                    var response = client.SendHeadRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;GET&#34;)&#xA;                {&#xA;                    var response = client.SendGetRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;POST&#34;)&#xA;                {&#xA;                    if (commands.Length &amp;lt; 3)&#xA;                    {&#xA;                        Console.WriteLine(&#34;HTTP method, URL and body must be entered!&#34;);&#xA;                        continue;&#xA;                    }&#xA;&#xA;                    var response = client.SendPostRequest(commands[1], commands[2]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;PUT&#34;)&#xA;                {&#xA;                    if (commands.Length &amp;lt; 3)&#xA;                    {&#xA;                        Console.WriteLine(&#34;HTTP method, URL and body must be entered!&#34;);&#xA;                        continue;&#xA;                    }&#xA;&#xA;                    var response = client.SendPutRequest(commands[1], commands[2]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;DELETE&#34;)&#xA;                {&#xA;                    var response = client.SendDeleteRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;OPTIONS&#34;)&#xA;                {&#xA;                    var response = client.SendOptionsRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;TRACE&#34;)&#xA;                {&#xA;                    var response = client.SendTraceRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else&#xA;                    Console.WriteLine(&#34;Unknown HTTP method&#34;);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.Disconnect();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: HTTPS server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the HTTPS cache server. It allows to manipulate cache data with HTTP methods (GET, POST, PUT and DELETE) with secured transport protocol.&lt;/p&gt; &#xA;&lt;p&gt;Use the following link to open &lt;a href=&#34;https://swagger.io/specification/&#34;&gt;Swagger OpenAPI&lt;/a&gt; iterative documentation: &lt;a href=&#34;https://localhost:8443/api/index.html&#34;&gt;https://localhost:8443/api/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/images/openapi-https.png&#34; alt=&#34;OpenAPI-HTTPS&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Collections.Concurrent;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Security.Authentication;&#xA;using System.Security.Cryptography.X509Certificates;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace HttpsServer&#xA;{&#xA;    class CommonCache&#xA;    {&#xA;        public static CommonCache GetInstance()&#xA;        {&#xA;            if (_instance == null)&#xA;                _instance = new CommonCache();&#xA;            return _instance;&#xA;        }&#xA;&#xA;        public string GetAllCache()&#xA;        {&#xA;            var result = new StringBuilder();&#xA;            result.Append(&#34;[\n&#34;);&#xA;            foreach (var item in _cache)&#xA;            {&#xA;                result.Append(&#34;  {\n&#34;);&#xA;                result.AppendFormat($&#34;    \&#34;key\&#34;: \&#34;{item.Key}\&#34;,\n&#34;);&#xA;                result.AppendFormat($&#34;    \&#34;value\&#34;: \&#34;{item.Value}\&#34;,\n&#34;);&#xA;                result.Append(&#34;  },\n&#34;);&#xA;            }&#xA;            result.Append(&#34;]\n&#34;);&#xA;            return result.ToString();&#xA;        }&#xA;&#xA;        public bool GetCacheValue(string key, out string value)&#xA;        {&#xA;            return _cache.TryGetValue(key, out value);&#xA;        }&#xA;&#xA;        public void PutCacheValue(string key, string value)&#xA;        {&#xA;            _cache[key] = value;&#xA;        }&#xA;&#xA;        public bool DeleteCacheValue(string key, out string value)&#xA;        {&#xA;            return _cache.TryRemove(key, out value);&#xA;        }&#xA;&#xA;        private readonly ConcurrentDictionary&amp;lt;string, string&amp;gt; _cache = new ConcurrentDictionary&amp;lt;string, string&amp;gt;();&#xA;        private static CommonCache _instance;&#xA;    }&#xA;&#xA;    class HttpsCacheSession : HttpsSession&#xA;    {&#xA;        public HttpsCacheSession(NetCoreServer.HttpsServer server) : base(server) {}&#xA;&#xA;        protected override void OnReceivedRequest(HttpRequest request)&#xA;        {&#xA;            // Show HTTP request content&#xA;            Console.WriteLine(request);&#xA;&#xA;            // Process HTTP request methods&#xA;            if (request.Method == &#34;HEAD&#34;)&#xA;                SendResponseAsync(Response.MakeHeadResponse());&#xA;            else if (request.Method == &#34;GET&#34;)&#xA;            {&#xA;                string key = request.Url;&#xA;&#xA;                // Decode the key value&#xA;                key = Uri.UnescapeDataString(key);&#xA;                key = key.Replace(&#34;/api/cache&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;                key = key.Replace(&#34;?key=&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;&#xA;                if (string.IsNullOrEmpty(key))&#xA;                {&#xA;                    // Response with all cache values&#xA;                    SendResponseAsync(Response.MakeGetResponse(CommonCache.GetInstance().GetAllCache(), &#34;application/json; charset=UTF-8&#34;));&#xA;                }&#xA;                // Get the cache value by the given key&#xA;                else if (CommonCache.GetInstance().GetCacheValue(key, out var value))&#xA;                {&#xA;                    // Response with the cache value&#xA;                    SendResponseAsync(Response.MakeGetResponse(value));&#xA;                }&#xA;                else&#xA;                    SendResponseAsync(Response.MakeErrorResponse(404, &#34;Required cache value was not found for the key: &#34; + key));&#xA;            }&#xA;            else if ((request.Method == &#34;POST&#34;) || (request.Method == &#34;PUT&#34;))&#xA;            {&#xA;                string key = request.Url;&#xA;                string value = request.Body;&#xA;&#xA;                // Decode the key value&#xA;                key = Uri.UnescapeDataString(key);&#xA;                key = key.Replace(&#34;/api/cache&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;                key = key.Replace(&#34;?key=&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;&#xA;                // Put the cache value&#xA;                CommonCache.GetInstance().PutCacheValue(key, value);&#xA;&#xA;                // Response with the cache value&#xA;                SendResponseAsync(Response.MakeOkResponse());&#xA;            }&#xA;            else if (request.Method == &#34;DELETE&#34;)&#xA;            {&#xA;                string key = request.Url;&#xA;&#xA;                // Decode the key value&#xA;                key = Uri.UnescapeDataString(key);&#xA;                key = key.Replace(&#34;/api/cache&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;                key = key.Replace(&#34;?key=&#34;, &#34;&#34;, StringComparison.InvariantCultureIgnoreCase);&#xA;&#xA;                // Delete the cache value&#xA;                if (CommonCache.GetInstance().DeleteCacheValue(key, out var value))&#xA;                {&#xA;                    // Response with the cache value&#xA;                    SendResponseAsync(Response.MakeGetResponse(value));&#xA;                }&#xA;                else&#xA;                    SendResponseAsync(Response.MakeErrorResponse(404, &#34;Deleted cache value was not found for the key: &#34; + key));&#xA;            }&#xA;            else if (request.Method == &#34;OPTIONS&#34;)&#xA;                SendResponseAsync(Response.MakeOptionsResponse());&#xA;            else if (request.Method == &#34;TRACE&#34;)&#xA;                SendResponseAsync(Response.MakeTraceResponse(request.Cache));&#xA;            else&#xA;                SendResponseAsync(Response.MakeErrorResponse(&#34;Unsupported HTTP method: &#34; + request.Method));&#xA;        }&#xA;&#xA;        protected override void OnReceivedRequestError(HttpRequest request, string error)&#xA;        {&#xA;            Console.WriteLine($&#34;Request error: {error}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;HTTPS session caught an error: {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class HttpsCacheServer : NetCoreServer.HttpsServer&#xA;    {&#xA;        public HttpsCacheServer(SslContext context, IPAddress address, int port) : base(context, address, port) {}&#xA;&#xA;        protected override SslSession CreateSession() { return new HttpsCacheSession(this); }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;HTTPS server caught an error: {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // HTTPS server port&#xA;            int port = 8443;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;            // HTTPS server content path&#xA;            string www = &#34;../../../../../www/api&#34;;&#xA;            if (args.Length &amp;gt; 1)&#xA;                www = args[1];&#xA;&#xA;            Console.WriteLine($&#34;HTTPS server port: {port}&#34;);&#xA;            Console.WriteLine($&#34;HTTPS server static content path: {www}&#34;);&#xA;            Console.WriteLine($&#34;HTTPS server website: https://localhost:{port}/api/index.html&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create and prepare a new SSL server context&#xA;            var context = new SslContext(SslProtocols.Tls12, new X509Certificate2(&#34;server.pfx&#34;, &#34;qwerty&#34;));&#xA;&#xA;            // Create a new HTTP server&#xA;            var server = new HttpsCacheServer(context, IPAddress.Any, port);&#xA;            server.AddStaticContent(www, &#34;/api&#34;);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                }&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: HTTPS client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the HTTPS client. It allows to send HTTP requests (GET, POST, PUT and DELETE) and receive HTTP responses with secured transport protocol.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Security.Authentication;&#xA;using System.Security.Cryptography.X509Certificates;&#xA;using NetCoreServer;&#xA;&#xA;namespace HttpsClient&#xA;{&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // HTTPS server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // HTTPS server port&#xA;            int port = 8443;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;HTTPS server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;HTTPS server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create and prepare a new SSL client context&#xA;            var context = new SslContext(SslProtocols.Tls12, new X509Certificate2(&#34;client.pfx&#34;, &#34;qwerty&#34;), (sender, certificate, chain, sslPolicyErrors) =&amp;gt; true);&#xA;&#xA;            // Create a new HTTPS client&#xA;            var client = new HttpsClientEx(context, address, port);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Reconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client reconnecting...&#34;);&#xA;                    if (client.IsConnected)&#xA;                        client.ReconnectAsync();&#xA;                    else&#xA;                        client.ConnectAsync();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                var commands = line.Split(&#39; &#39;);&#xA;                if (commands.Length &amp;lt; 2)&#xA;                {&#xA;                    Console.WriteLine(&#34;HTTP method and URL must be entered!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                if (commands[0].ToUpper() == &#34;HEAD&#34;)&#xA;                {&#xA;                    var response = client.SendHeadRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;GET&#34;)&#xA;                {&#xA;                    var response = client.SendGetRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;POST&#34;)&#xA;                {&#xA;                    if (commands.Length &amp;lt; 3)&#xA;                    {&#xA;                        Console.WriteLine(&#34;HTTP method, URL and body must be entered!&#34;);&#xA;                        continue;&#xA;                    }&#xA;&#xA;                    var response = client.SendPostRequest(commands[1], commands[2]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;PUT&#34;)&#xA;                {&#xA;                    if (commands.Length &amp;lt; 3)&#xA;                    {&#xA;                        Console.WriteLine(&#34;HTTP method, URL and body must be entered!&#34;);&#xA;                        continue;&#xA;                    }&#xA;&#xA;                    var response = client.SendPutRequest(commands[1], commands[2]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;DELETE&#34;)&#xA;                {&#xA;                    var response = client.SendDeleteRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;OPTIONS&#34;)&#xA;                {&#xA;                    var response = client.SendOptionsRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else if (commands[0].ToUpper() == &#34;TRACE&#34;)&#xA;                {&#xA;                    var response = client.SendTraceRequest(commands[1]).Result;&#xA;                    Console.WriteLine(response);&#xA;                }&#xA;                else&#xA;                    Console.WriteLine(&#34;Unknown HTTP method&#34;);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.Disconnect();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: WebSocket chat server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the WebSocket chat server. It handles multiple WebSocket client sessions and multicast received message from any session to all ones. Also it is possible to send admin message directly from the server.&lt;/p&gt; &#xA;&lt;p&gt;Use the following link to open WebSocket chat server example: &lt;a href=&#34;http://localhost:8080/chat/index.html&#34;&gt;http://localhost:8080/chat/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/images/ws-chat.png&#34; alt=&#34;ws-chat&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace WsChatServer&#xA;{&#xA;    class ChatSession : WsSession&#xA;    {&#xA;        public ChatSession(WsServer server) : base(server) {}&#xA;&#xA;        public override void OnWsConnected(HttpRequest request)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket session with Id {Id} connected!&#34;);&#xA;&#xA;            // Send invite message&#xA;            string message = &#34;Hello from WebSocket chat! Please send a message or &#39;!&#39; to disconnect the client!&#34;;&#xA;            SendTextAsync(message);&#xA;        }&#xA;&#xA;        public override void OnWsDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket session with Id {Id} disconnected!&#34;);&#xA;        }&#xA;&#xA;        public override void OnWsReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            string message = Encoding.UTF8.GetString(buffer, (int)offset, (int)size);&#xA;            Console.WriteLine(&#34;Incoming: &#34; + message);&#xA;&#xA;            // Multicast message to all connected sessions&#xA;            ((WsServer)Server).MulticastText(message);&#xA;&#xA;            // If the buffer starts with &#39;!&#39; the disconnect the current session&#xA;            if (message == &#34;!&#34;)&#xA;                Close(1000);&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket session caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class ChatServer : WsServer&#xA;    {&#xA;        public ChatServer(IPAddress address, int port) : base(address, port) {}&#xA;&#xA;        protected override TcpSession CreateSession() { return new ChatSession(this); }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket server caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // WebSocket server port&#xA;            int port = 8080;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;            // WebSocket server content path&#xA;            string www = &#34;../../../../../www/ws&#34;;&#xA;            if (args.Length &amp;gt; 1)&#xA;                www = args[1];&#xA;&#xA;            Console.WriteLine($&#34;WebSocket server port: {port}&#34;);&#xA;            Console.WriteLine($&#34;WebSocket server static content path: {www}&#34;);&#xA;            Console.WriteLine($&#34;WebSocket server website: http://localhost:{port}/chat/index.html&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new WebSocket server&#xA;            var server = new ChatServer(IPAddress.Any, port);&#xA;            server.AddStaticContent(www, &#34;/chat&#34;);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                }&#xA;&#xA;                // Multicast admin message to all sessions&#xA;                line = &#34;(admin) &#34; + line;&#xA;                server.MulticastText(line);&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: WebSocket chat client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the WebSocket chat client. It connects to the WebSocket chat server and allows to send message to it and receive new messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net.Sockets;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using NetCoreServer;&#xA;&#xA;namespace WsChatClient&#xA;{&#xA;    class ChatClient : WsClient&#xA;    {&#xA;        public ChatClient(string address, int port) : base(address, port) {}&#xA;&#xA;        public void DisconnectAndStop()&#xA;        {&#xA;            _stop = true;&#xA;            CloseAsync(1000);&#xA;            while (IsConnected)&#xA;                Thread.Yield();&#xA;        }&#xA;&#xA;        public override void OnWsConnecting(HttpRequest request)&#xA;        {&#xA;            request.SetBegin(&#34;GET&#34;, &#34;/&#34;);&#xA;            request.SetHeader(&#34;Host&#34;, &#34;localhost&#34;);&#xA;            request.SetHeader(&#34;Origin&#34;, &#34;http://localhost&#34;);&#xA;            request.SetHeader(&#34;Upgrade&#34;, &#34;websocket&#34;);&#xA;            request.SetHeader(&#34;Connection&#34;, &#34;Upgrade&#34;);&#xA;            request.SetHeader(&#34;Sec-WebSocket-Key&#34;, Convert.ToBase64String(WsNonce));&#xA;            request.SetHeader(&#34;Sec-WebSocket-Protocol&#34;, &#34;chat, superchat&#34;);&#xA;            request.SetHeader(&#34;Sec-WebSocket-Version&#34;, &#34;13&#34;);&#xA;            request.SetBody();&#xA;        }&#xA;&#xA;        public override void OnWsConnected(HttpResponse response)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket client connected a new session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        public override void OnWsDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket client disconnected a session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        public override void OnWsReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine($&#34;Incoming: {Encoding.UTF8.GetString(buffer, (int)offset, (int)size)}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            base.OnDisconnected();&#xA;&#xA;            Console.WriteLine($&#34;Chat WebSocket client disconnected a session with Id {Id}&#34;);&#xA;&#xA;            // Wait for a while...&#xA;            Thread.Sleep(1000);&#xA;&#xA;            // Try to connect again&#xA;            if (!_stop)&#xA;                ConnectAsync();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket client caught an error with code {error}&#34;);&#xA;        }&#xA;&#xA;        private bool _stop;&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // WebSocket server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // WebSocket server port&#xA;            int port = 8080;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;WebSocket server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;WebSocket server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create a new TCP chat client&#xA;            var client = new ChatClient(address, port);&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.ConnectAsync();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Disconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client disconnecting...&#34;);&#xA;                    client.DisconnectAsync();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Send the entered text to the chat server&#xA;                client.SendTextAsync(line);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: WebSocket secure chat server&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the WebSocket secure chat server. It handles multiple WebSocket secure client sessions and multicast received message from any session to all ones. Also it is possible to send admin message directly from the server.&lt;/p&gt; &#xA;&lt;p&gt;This example is very similar to the WebSocket one except the code that prepares WebSocket secure context and handshake handler.&lt;/p&gt; &#xA;&lt;p&gt;Use the following link to open WebSocket secure chat server example: &lt;a href=&#34;https://localhost:8443/chat/index.html&#34;&gt;https://localhost:8443/chat/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/images/wss-chat.png&#34; alt=&#34;wss-chat&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Security.Authentication;&#xA;using System.Security.Cryptography.X509Certificates;&#xA;using System.Text;&#xA;using NetCoreServer;&#xA;&#xA;namespace WssChatServer&#xA;{&#xA;    class ChatSession : WssSession&#xA;    {&#xA;        public ChatSession(WssServer server) : base(server) {}&#xA;&#xA;        public override void OnWsConnected(HttpRequest request)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket session with Id {Id} connected!&#34;);&#xA;&#xA;            // Send invite message&#xA;            string message = &#34;Hello from WebSocket chat! Please send a message or &#39;!&#39; to disconnect the client!&#34;;&#xA;            SendTextAsync(message);&#xA;        }&#xA;&#xA;        public override void OnWsDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket session with Id {Id} disconnected!&#34;);&#xA;        }&#xA;&#xA;        public override void OnWsReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            string message = Encoding.UTF8.GetString(buffer, (int)offset, (int)size);&#xA;            Console.WriteLine(&#34;Incoming: &#34; + message);&#xA;&#xA;            // Multicast message to all connected sessions&#xA;            ((WssServer)Server).MulticastText(message);&#xA;&#xA;            // If the buffer starts with &#39;!&#39; the disconnect the current session&#xA;            if (message == &#34;!&#34;)&#xA;                Close(1000);&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket session caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class ChatServer : WssServer&#xA;    {&#xA;        public ChatServer(SslContext context, IPAddress address, int port) : base(context, address, port) {}&#xA;&#xA;        protected override SslSession CreateSession() { return new ChatSession(this); }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket server caught an error with code {error}&#34;);&#xA;        }&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // WebSocket server port&#xA;            int port = 8443;&#xA;            if (args.Length &amp;gt; 0)&#xA;                port = int.Parse(args[0]);&#xA;            // WebSocket server content path&#xA;            string www = &#34;../../../../../www/wss&#34;;&#xA;            if (args.Length &amp;gt; 1)&#xA;                www = args[1];&#xA;&#xA;            Console.WriteLine($&#34;WebSocket server port: {port}&#34;);&#xA;            Console.WriteLine($&#34;WebSocket server static content path: {www}&#34;);&#xA;            Console.WriteLine($&#34;WebSocket server website: https://localhost:{port}/chat/index.html&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create and prepare a new SSL server context&#xA;            var context = new SslContext(SslProtocols.Tls12, new X509Certificate2(&#34;server.pfx&#34;, &#34;qwerty&#34;));&#xA;&#xA;            // Create a new WebSocket server&#xA;            var server = new ChatServer(context, IPAddress.Any, port);&#xA;            server.AddStaticContent(www, &#34;/chat&#34;);&#xA;&#xA;            // Start the server&#xA;            Console.Write(&#34;Server starting...&#34;);&#xA;            server.Start();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the server or &#39;!&#39; to restart the server...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Restart the server&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Server restarting...&#34;);&#xA;                    server.Restart();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                }&#xA;&#xA;                // Multicast admin message to all sessions&#xA;                line = &#34;(admin) &#34; + line;&#xA;                server.MulticastText(line);&#xA;            }&#xA;&#xA;            // Stop the server&#xA;            Console.Write(&#34;Server stopping...&#34;);&#xA;            server.Stop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: WebSocket secure chat client&lt;/h2&gt; &#xA;&lt;p&gt;Here comes the example of the WebSocket secure chat client. It connects to the WebSocket secure chat server and allows to send message to it and receive new messages.&lt;/p&gt; &#xA;&lt;p&gt;This example is very similar to the WebSocket one except the code that prepares WebSocket secure context and handshake handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;&#xA;using System.Net.Sockets;&#xA;using System.Security.Authentication;&#xA;using System.Security.Cryptography.X509Certificates;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using NetCoreServer;&#xA;&#xA;namespace WssChatClient&#xA;{&#xA;    class ChatClient : WssClient&#xA;    {&#xA;        public ChatClient(SslContext context, string address, int port) : base(context, address, port) {}&#xA;&#xA;        public void DisconnectAndStop()&#xA;        {&#xA;            _stop = true;&#xA;            CloseAsync(1000);&#xA;            while (IsConnected)&#xA;                Thread.Yield();&#xA;        }&#xA;&#xA;        public override void OnWsConnecting(HttpRequest request)&#xA;        {&#xA;            request.SetBegin(&#34;GET&#34;, &#34;/&#34;);&#xA;            request.SetHeader(&#34;Host&#34;, &#34;localhost&#34;);&#xA;            request.SetHeader(&#34;Origin&#34;, &#34;http://localhost&#34;);&#xA;            request.SetHeader(&#34;Upgrade&#34;, &#34;websocket&#34;);&#xA;            request.SetHeader(&#34;Connection&#34;, &#34;Upgrade&#34;);&#xA;            request.SetHeader(&#34;Sec-WebSocket-Key&#34;, Convert.ToBase64String(WsNonce));&#xA;            request.SetHeader(&#34;Sec-WebSocket-Protocol&#34;, &#34;chat, superchat&#34;);&#xA;            request.SetHeader(&#34;Sec-WebSocket-Version&#34;, &#34;13&#34;);&#xA;            request.SetBody();&#xA;        }&#xA;&#xA;        public override void OnWsConnected(HttpResponse response)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket client connected a new session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        public override void OnWsDisconnected()&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket client disconnected a session with Id {Id}&#34;);&#xA;        }&#xA;&#xA;        public override void OnWsReceived(byte[] buffer, long offset, long size)&#xA;        {&#xA;            Console.WriteLine($&#34;Incoming: {Encoding.UTF8.GetString(buffer, (int)offset, (int)size)}&#34;);&#xA;        }&#xA;&#xA;        protected override void OnDisconnected()&#xA;        {&#xA;            base.OnDisconnected();&#xA;&#xA;            Console.WriteLine($&#34;Chat WebSocket client disconnected a session with Id {Id}&#34;);&#xA;&#xA;            // Wait for a while...&#xA;            Thread.Sleep(1000);&#xA;&#xA;            // Try to connect again&#xA;            if (!_stop)&#xA;                ConnectAsync();&#xA;        }&#xA;&#xA;        protected override void OnError(SocketError error)&#xA;        {&#xA;            Console.WriteLine($&#34;Chat WebSocket client caught an error with code {error}&#34;);&#xA;        }&#xA;&#xA;        private bool _stop;&#xA;    }&#xA;&#xA;    class Program&#xA;    {&#xA;        static void Main(string[] args)&#xA;        {&#xA;            // WebSocket server address&#xA;            string address = &#34;127.0.0.1&#34;;&#xA;            if (args.Length &amp;gt; 0)&#xA;                address = args[0];&#xA;&#xA;            // WebSocket server port&#xA;            int port = 8443;&#xA;            if (args.Length &amp;gt; 1)&#xA;                port = int.Parse(args[1]);&#xA;&#xA;            Console.WriteLine($&#34;WebSocket server address: {address}&#34;);&#xA;            Console.WriteLine($&#34;WebSocket server port: {port}&#34;);&#xA;&#xA;            Console.WriteLine();&#xA;&#xA;            // Create and prepare a new SSL client context&#xA;            var context = new SslContext(SslProtocols.Tls12, new X509Certificate2(&#34;client.pfx&#34;, &#34;qwerty&#34;), (sender, certificate, chain, sslPolicyErrors) =&amp;gt; true);&#xA;&#xA;            // Create a new TCP chat client&#xA;            var client = new ChatClient(context, address, port);&#xA;&#xA;            // Connect the client&#xA;            Console.Write(&#34;Client connecting...&#34;);&#xA;            client.ConnectAsync();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;&#xA;            Console.WriteLine(&#34;Press Enter to stop the client or &#39;!&#39; to reconnect the client...&#34;);&#xA;&#xA;            // Perform text input&#xA;            for (;;)&#xA;            {&#xA;                string line = Console.ReadLine();&#xA;                if (string.IsNullOrEmpty(line))&#xA;                    break;&#xA;&#xA;                // Reconnect the client&#xA;                if (line == &#34;!&#34;)&#xA;                {&#xA;                    Console.Write(&#34;Client reconnecting...&#34;);&#xA;                    if (client.IsConnected)&#xA;                        client.ReconnectAsync();&#xA;                    else&#xA;                        client.ConnectAsync();&#xA;                    Console.WriteLine(&#34;Done!&#34;);&#xA;                    continue;&#xA;                }&#xA;&#xA;                // Send the entered text to the chat server&#xA;                client.SendTextAsync(line);&#xA;            }&#xA;&#xA;            // Disconnect the client&#xA;            Console.Write(&#34;Client disconnecting...&#34;);&#xA;            client.DisconnectAndStop();&#xA;            Console.WriteLine(&#34;Done!&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;Here comes several communication scenarios with timing measurements.&lt;/p&gt; &#xA;&lt;p&gt;Benchmark environment is the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CPU architecutre: Intel(R) Core(TM) i7-4790K CPU @ 4.00GHz&#xA;CPU logical cores: 8&#xA;CPU physical cores: 4&#xA;CPU clock speed: 3.998 GHz&#xA;CPU Hyper-Threading: enabled&#xA;RAM total: 31.962 GiB&#xA;RAM free: 24.011 GiB&#xA;&#xA;OS version: Microsoft Windows 8 Enterprise Edition (build 9200), 64-bit&#xA;OS bits: 64-bit&#xA;Process bits: 64-bit&#xA;Process configuaraion: release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Benchmark: Round-Trip&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/images/round-trip.png&#34; alt=&#34;Round-trip&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This scenario sends lots of messages from several clients to a server. The server responses to each message and resend the similar response to the client. The benchmark measures total round-trip time to send all messages and receive all responses, messages &amp;amp; data throughput, count of errors.&lt;/p&gt; &#xA;&lt;h3&gt;TCP echo server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpEchoServer/Program.cs&#34;&gt;TcpEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpEchoClient/Program.cs&#34;&gt;TcpEchoClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 1111&#xA;Working clients: 1&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.024 s&#xA;Total data: 2.831 GiB&#xA;Total messages: 94369133&#xA;Data throughput: 287.299 MiB/s&#xA;Message latency: 106 ns&#xA;Message throughput: 9413997 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpEchoServer/Program.cs&#34;&gt;TcpEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpEchoClient/Program.cs&#34;&gt;TcpEchoClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 1111&#xA;Working clients: 100&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.189 s&#xA;Total data: 1.794 GiB&#xA;Total messages: 59585544&#xA;Data throughput: 178.463 MiB/s&#xA;Message latency: 171 ns&#xA;Message throughput: 5847523 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SSL echo server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslEchoServer/Program.cs&#34;&gt;SslEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslEchoClient/Program.cs&#34;&gt;SslEchoClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 2222&#xA;Working clients: 1&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 2.645 s&#xA;Total data: 373.329 MiB&#xA;Total messages: 12233021&#xA;Data throughput: 141.095 MiB/s&#xA;Message latency: 216 ns&#xA;Message throughput: 4623352 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslEchoServer/Program.cs&#34;&gt;SslEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslEchoClient/Program.cs&#34;&gt;SslEchoClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 2222&#xA;Working clients: 100&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.060 s&#xA;Total data: 1.472 GiB&#xA;Total messages: 49029133&#xA;Data throughput: 148.741 MiB/s&#xA;Message latency: 205 ns&#xA;Message throughput: 4873398 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;UDP echo server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpEchoServer/Program.cs&#34;&gt;UdpEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpEchoClient/Program.cs&#34;&gt;UdpEchoClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 3333&#xA;Working clients: 1&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.032 s&#xA;Total data: 33.994 MiB&#xA;Total messages: 1113182&#xA;Data throughput: 3.395 MiB/s&#xA;Message latency: 9.012 mcs&#xA;Message throughput: 110960 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpEchoServer/Program.cs&#34;&gt;UdpEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpEchoClient/Program.cs&#34;&gt;UdpEchoClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 3333&#xA;Working clients: 100&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.635 s&#xA;Total data: 20.355 MiB&#xA;Total messages: 666791&#xA;Data throughput: 1.934 MiB/s&#xA;Message latency: 15.950 mcs&#xA;Message throughput: 62693 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unix Domain Socket echo server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsEchoServer/Program.cs&#34;&gt;UdsEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsEchoClient/Program.cs&#34;&gt;UdsEchoClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server Unix Domain Socket path: C:\Users\chronoxor\AppData\Local\Temp\echo.sock&#xA;Working clients: 1&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.016 s&#xA;Total data: 208.657 MiB&#xA;Total messages: 6836769&#xA;Data throughput: 20.850 MiB/s&#xA;Message latency: 1.465 mcs&#xA;Message throughput: 682575 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsEchoServer/Program.cs&#34;&gt;UdsEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsEchoClient/Program.cs&#34;&gt;UdsEchoClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server Unix Domain Socket path: C:\Users\chronoxor\AppData\Local\Temp\echo.sock&#xA;Working clients: 100&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 12.253 s&#xA;Total data: 602.320 MiB&#xA;Total messages: 19736578&#xA;Data throughput: 49.157 MiB/s&#xA;Message latency: 620 ns&#xA;Message throughput: 1610666 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Simple protocol server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/ProtoServer/Program.cs&#34;&gt;ProtoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/ProtoClient/Program.cs&#34;&gt;ProtoClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 4444&#xA;Working clients: 1&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.015 s&#xA;Total data: 100.568 MiB&#xA;Total messages: 3294993&#xA;Data throughput: 10.040 MiB/s&#xA;Message latency: 3.039 mcs&#xA;Message throughput: 328978 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/ProtoServer/Program.cs&#34;&gt;ProtoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/ProtoClient/Program.cs&#34;&gt;ProtoClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 4444&#xA;Working clients: 100&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 12.530 s&#xA;Total data: 207.994 MiB&#xA;Total messages: 6814785&#xA;Data throughput: 16.611 MiB/s&#xA;Message latency: 1.838 mcs&#xA;Message throughput: 543858 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;WebSocket echo server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsEchoServer/Program.cs&#34;&gt;WsEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsEchoClient/Program.cs&#34;&gt;WsEchoClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8080&#xA;Working clients: 1&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 3.037 s&#xA;Total data: 105.499 MiB&#xA;Total messages: 3456618&#xA;Data throughput: 34.742 MiB/s&#xA;Message latency: 878 ns&#xA;Message throughput: 1137864 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsEchoServer/Program.cs&#34;&gt;WsEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsEchoClient/Program.cs&#34;&gt;WsEchoClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8080&#xA;Working clients: 100&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.078 s&#xA;Total data: 426.803 MiB&#xA;Total messages: 13984888&#xA;Data throughput: 42.353 MiB/s&#xA;Message latency: 720 ns&#xA;Message throughput: 1387555 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;WebSocket secure echo server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssEchoServer/Program.cs&#34;&gt;WssEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssEchoClient/Program.cs&#34;&gt;WssEchoClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8443&#xA;Working clients: 1&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.030 s&#xA;Total data: 198.103 MiB&#xA;Total messages: 6491390&#xA;Data throughput: 19.767 MiB/s&#xA;Message latency: 1.545 mcs&#xA;Message throughput: 647153 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssEchoServer/Program.cs&#34;&gt;WssEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssEchoClient/Program.cs&#34;&gt;WssEchoClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8443&#xA;Working clients: 100&#xA;Working messages: 1000&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.112 s&#xA;Total data: 405.286 MiB&#xA;Total messages: 13280221&#xA;Data throughput: 40.078 MiB/s&#xA;Message latency: 761 ns&#xA;Message throughput: 1313228 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Benchmark: Multicast&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/images/multicast.png&#34; alt=&#34;Multicast&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In this scenario server multicasts messages to all connected clients. The benchmark counts total messages received by all clients for all the working time and measures messages &amp;amp; data throughput, count of errors.&lt;/p&gt; &#xA;&lt;h3&gt;TCP multicast server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpMulticastServer/Program.cs&#34;&gt;TcpMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpMulticastClient/Program.cs&#34;&gt;TcpMulticastClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 1111&#xA;Working clients: 1&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.022 s&#xA;Total data: 407.023 MiB&#xA;Total messages: 13337326&#xA;Data throughput: 40.625 MiB/s&#xA;Message latency: 751 ns&#xA;Message throughput: 1330734 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpMulticastServer/Program.cs&#34;&gt;TcpMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/TcpMulticastClient/Program.cs&#34;&gt;TcpMulticastClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 1111&#xA;Working clients: 100&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.112 s&#xA;Total data: 421.348 MiB&#xA;Total messages: 13806493&#xA;Data throughput: 41.681 MiB/s&#xA;Message latency: 732 ns&#xA;Message throughput: 1365280 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SSL multicast server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslMulticastServer/Program.cs&#34;&gt;SslMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslMulticastClient/Program.cs&#34;&gt;SslMulticastClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 2222&#xA;Working clients: 1&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.024 s&#xA;Total data: 325.225 MiB&#xA;Total messages: 10656801&#xA;Data throughput: 32.453 MiB/s&#xA;Message latency: 940 ns&#xA;Message throughput: 1063075 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslMulticastServer/Program.cs&#34;&gt;SslMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/SslMulticastClient/Program.cs&#34;&gt;SslMulticastClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 2222&#xA;Working clients: 100&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.144 s&#xA;Total data: 343.460 MiB&#xA;Total messages: 11254173&#xA;Data throughput: 33.876 MiB/s&#xA;Message latency: 901 ns&#xA;Message throughput: 1109393 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;UDP multicast server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpMulticastServer/Program.cs&#34;&gt;UdpMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpMulticastClient/Program.cs&#34;&gt;UdpMulticastClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 239.255.0.1&#xA;Server port: 3333&#xA;Working clients: 1&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.026 s&#xA;Total data: 13.225 MiB&#xA;Total messages: 433202&#xA;Data throughput: 1.326 MiB/s&#xA;Message latency: 23.145 mcs&#xA;Message throughput: 43205 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpMulticastServer/Program.cs&#34;&gt;UdpMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdpMulticastClient/Program.cs&#34;&gt;UdpMulticastClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 239.255.0.1&#xA;Server port: 3333&#xA;Working clients: 100&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.035 s&#xA;Total data: 28.684 MiB&#xA;Total messages: 939408&#xA;Data throughput: 2.877 MiB/s&#xA;Message latency: 10.682 mcs&#xA;Message throughput: 93606 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unix Domain Socket multicast server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsMulticastServer/Program.cs&#34;&gt;UdsMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsMulticastClient/Program.cs&#34;&gt;UdsMulticastClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server Unix Domain Socket path: C:\Users\chronoxor\AppData\Local\Temp\multicast.sock&#xA;Working clients: 1&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.015 s&#xA;Total data: 204.127 MiB&#xA;Total messages: 6688763&#xA;Data throughput: 20.390 MiB/s&#xA;Message latency: 1.497 mcs&#xA;Message throughput: 667869 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsMulticastServer/Program.cs&#34;&gt;UdsMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/UdsMulticastClient/Program.cs&#34;&gt;UdsMulticastClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server Unix Domain Socket path: C:\Users\chronoxor\AppData\Local\Temp\multicast.sock&#xA;Working clients: 100&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.033 s&#xA;Total data: 124.463 MiB&#xA;Total messages: 4078051&#xA;Data throughput: 12.413 MiB/s&#xA;Message latency: 2.460 mcs&#xA;Message throughput: 406451 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;WebSocket multicast server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsMulticastServer/Program.cs&#34;&gt;WsMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsMulticastClient/Program.cs&#34;&gt;WsMulticastClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8080&#xA;Working clients: 1&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.048 s&#xA;Total data: 183.108 MiB&#xA;Total messages: 6000000&#xA;Data throughput: 18.228 MiB/s&#xA;Message latency: 1.674 mcs&#xA;Message throughput: 597121 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsMulticastServer/Program.cs&#34;&gt;WsMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WsMulticastClient/Program.cs&#34;&gt;WsMulticastClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8080&#xA;Working clients: 100&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.227 s&#xA;Total data: 125.957 MiB&#xA;Total messages: 4126627&#xA;Data throughput: 12.320 MiB/s&#xA;Message latency: 2.478 mcs&#xA;Message throughput: 403466 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;WebSocket secure multicast server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssMulticastServer/Program.cs&#34;&gt;WssMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssMulticastClient/Program.cs&#34;&gt;WssMulticastClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8443&#xA;Working clients: 1&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.034 s&#xA;Total data: 184.159 MiB&#xA;Total messages: 6034421&#xA;Data throughput: 18.359 MiB/s&#xA;Message latency: 1.662 mcs&#xA;Message throughput: 601338 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssMulticastServer/Program.cs&#34;&gt;WssMulticastServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/WssMulticastClient/Program.cs&#34;&gt;WssMulticastClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8443&#xA;Working clients: 100&#xA;Message size: 32&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.171 s&#xA;Total data: 315.306 MiB&#xA;Total messages: 10331721&#xA;Data throughput: 30.1022 MiB/s&#xA;Message latency: 984 ns&#xA;Message throughput: 1015763 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Benchmark: Web Server&lt;/h2&gt; &#xA;&lt;h3&gt;HTTP Trace server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpTraceServer/Program.cs&#34;&gt;HttpTraceServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpTraceClient/Program.cs&#34;&gt;HttpTraceClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8080&#xA;Working clients: 1&#xA;Working messages: 1&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.023 s&#xA;Total data: 10.987 MiB&#xA;Total messages: 108465&#xA;Data throughput: 1.096 MiB/s&#xA;Message latency: 92.414 mcs&#xA;Message throughput: 10820 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpTraceServer/Program.cs&#34;&gt;HttpTraceServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpTraceClient/Program.cs&#34;&gt;HttpTraceClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8080&#xA;Working clients: 100&#xA;Working messages: 1&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 10.085 s&#xA;Total data: 40.382 MiB&#xA;Total messages: 401472&#xA;Data throughput: 4.003 MiB/s&#xA;Message latency: 25.120 mcs&#xA;Message throughput: 39807 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTTPS Trace server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpsTraceServer/Program.cs&#34;&gt;HttpsTraceServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpsTraceClient/Program.cs&#34;&gt;HttpsTraceClient&lt;/a&gt; --clients 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8443&#xA;Working clients: 1&#xA;Working messages: 1&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 595.214 ms&#xA;Total data: 627.842 KiB&#xA;Total messages: 6065&#xA;Data throughput: 1.030 MiB/s&#xA;Message latency: 98.139 mcs&#xA;Message throughput: 10189 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpsTraceServer/Program.cs&#34;&gt;HttpsTraceServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chronoxor/NetCoreServer/raw/master/performance/HttpsTraceClient/Program.cs&#34;&gt;HttpsTraceClient&lt;/a&gt; --clients 100&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Server address: 127.0.0.1&#xA;Server port: 8443&#xA;Working clients: 100&#xA;Working messages: 1&#xA;Seconds to benchmarking: 10&#xA;&#xA;Errors: 0&#xA;&#xA;Total time: 3.548 s&#xA;Total data: 17.948 MiB&#xA;Total messages: 179111&#xA;Data throughput: 5.052 MiB/s&#xA;Message latency: 19.813 mcs&#xA;Message throughput: 50471 msg/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;OpenSSL certificates&lt;/h1&gt; &#xA;&lt;p&gt;In order to create OpenSSL based server and client you should prepare a set of SSL certificates.&lt;/p&gt; &#xA;&lt;h2&gt;Production&lt;/h2&gt; &#xA;&lt;p&gt;Depending on your project, you may need to purchase a traditional SSL certificate signed by a Certificate Authority. If you, for instance, want some else&#39;s web browser to talk to your WebSocket project, you&#39;ll need a traditional SSL certificate.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;The commands below entered in the order they are listed will generate a self-signed certificate for development or testing purposes.&lt;/p&gt; &#xA;&lt;h2&gt;Certificate Authority&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create CA private key&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl genrsa -passout pass:qwerty -out ca-secret.key 4096&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Remove passphrase&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl rsa -passin pass:qwerty -in ca-secret.key -out ca.key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create CA self-signed certificate&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl req -new -x509 -days 3650 -subj &#39;/C=BY/ST=Belarus/L=Minsk/O=Example root CA/OU=Example CA unit/CN=example.com&#39; -key ca.key -out ca.crt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert CA self-signed certificate to PFX&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl pkcs12 -export -passout pass:qwerty -inkey ca.key -in ca.crt -out ca.pfx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert CA self-signed certificate to PEM&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in ca.pfx -out ca.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;SSL Server certificate&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create private key for the server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl genrsa -passout pass:qwerty -out server-secret.key 4096&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Remove passphrase&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl rsa -passin pass:qwerty -in server-secret.key -out server.key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create CSR for the server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl req -new -subj &#39;/C=BY/ST=Belarus/L=Minsk/O=Example server/OU=Example server unit/CN=server.example.com&#39; -key server.key -out server.csr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create certificate for the server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert the server certificate to PFX&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl pkcs12 -export -passout pass:qwerty -inkey server.key -in server.crt -out server.pfx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert the server certificate to PEM&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in server.pfx -out server.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;SSL Client certificate&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create private key for the client&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl genrsa -passout pass:qwerty -out client-secret.key 4096&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Remove passphrase&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl rsa -passin pass:qwerty -in client-secret.key -out client.key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create CSR for the client&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl req -new -subj &#39;/C=BY/ST=Belarus/L=Minsk/O=Example client/OU=Example client unit/CN=client.example.com&#39; -key client.key -out client.csr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create the client certificate&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl x509 -req -days 3650 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert the client certificate to PFX&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl pkcs12 -export -passout pass:qwerty -inkey client.key -in client.crt -out client.pfx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert the client certificate to PEM&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in client.pfx -out client.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Diffie-Hellman key exchange&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create DH parameters&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl dhparam -out dh4096.pem 4096&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>mini-software/MiniWord</title>
    <updated>2022-09-28T01:34:17Z</updated>
    <id>tag:github.com,2022-09-28:/mini-software/MiniWord</id>
    <link href="https://github.com/mini-software/MiniWord" rel="alternate"></link>
    <summary type="html">&lt;p&gt;.NET Word(docx) exporting template engine without COM+ &amp; interop (support Linux and Mac)&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/MiniWord&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/MiniWord.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/MiniWord&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/MiniWord.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mini-software/MiniWord&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/mini-software/MiniWord?logo=github&#34; alt=&#34;GitHub stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/MiniWord&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/.NET-%3E%3D%204.5-red.svg?sanitize=true&#34; alt=&#34;version&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mini-software/MiniWord/main/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/mini-software/MiniWord/main/README.zh-CN.md&#34;&gt;ç®€ä½“ä¸­æ–‡&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/mini-software/MiniWord/main/README.zh-Hant.md&#34;&gt;ç¹é«”ä¸­æ–‡&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA;  Your &#xA; &lt;a href=&#34;https://github.com/mini-software/MiniWord&#34;&gt;Star&lt;/a&gt; and &#xA; &lt;a href=&#34;https://miniexcel.github.io&#34;&gt;dotnate&lt;/a&gt; can make MiniWord better &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;MiniWord is an easy and effective .NET Word Template library.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12729184/190835307-6cd87982-b5f3-4a79-9682-bdd1cc02a4ea.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;nuget link : &lt;a href=&#34;https://www.nuget.org/packages/MiniWord&#34;&gt;https://www.nuget.org/packages/MiniWord&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Packge xml &lt;code&gt;&amp;lt;PackageReference Include=&#34;MiniWord&#34; Version=&#34;0.4.0&#34; /&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Or .NET CLI : &lt;code&gt;dotnet add package MiniWord --version 0.4.0&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Quick Start&lt;/h3&gt; &#xA;&lt;p&gt;Template follow &#34;WHAT you see is what you get&#34; designï¼Œand the template tag styles are completely preserved.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new Dictionary&amp;lt;string, object&amp;gt;(){[&#34;title&#34;] = &#34;Hello MiniWord&#34;};&#xA;MiniSoftware.MiniWord.SaveAsByTemplate(outputPath, templatePath, value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12729184/190875707-6c5639ab-9518-4dc1-85d8-81e20af465e8.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Input, Output&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Input support file path, byte[]&lt;/li&gt; &#xA; &lt;li&gt;Output support file path, byte[], stream&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;SaveAsByTemplate(string path, string templatePath, Dictionary&amp;lt;string, object&amp;gt; value)&#xA;SaveAsByTemplate(string path, byte[] templateBytes, Dictionary&amp;lt;string, object&amp;gt; value)&#xA;SaveAsByTemplate(this Stream stream, string templatePath, Dictionary&amp;lt;string, object&amp;gt; value)&#xA;SaveAsByTemplate(this Stream stream, byte[] templateBytes, Dictionary&amp;lt;string, object&amp;gt; value)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tags&lt;/h2&gt; &#xA;&lt;p&gt;MiniWord template format string like Vue, React &lt;code&gt;{{tag}}&lt;/code&gt;ï¼Œusers only need to make sure tag and value parameter key same then system will replace them automatically.&lt;/p&gt; &#xA;&lt;h3&gt;Text&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;{{tag}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Example&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new Dictionary&amp;lt;string, object&amp;gt;()&#xA;{&#xA;    [&#34;Name&#34;] = &#34;Jack&#34;,&#xA;    [&#34;Department&#34;] = &#34;IT Department&#34;,&#xA;    [&#34;Purpose&#34;] = &#34;Shanghai site needs a new system to control HR system.&#34;,&#xA;    [&#34;StartDate&#34;] = DateTime.Parse(&#34;2022-09-07 08:30:00&#34;),&#xA;    [&#34;EndDate&#34;] = DateTime.Parse(&#34;2022-09-15 15:30:00&#34;),&#xA;    [&#34;Approved&#34;] = true,&#xA;    [&#34;Total_Amount&#34;] = 123456,&#xA;};&#xA;MiniWord.SaveAsByTemplate(path, templatePath, value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Template&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12729184/190834360-39b4b799-d523-4b7e-9331-047a61fd5eb9.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Result&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12729184/190834455-ba065211-0f9d-41d1-9b7a-5d9e96ac2eff.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Image&lt;/h3&gt; &#xA;&lt;p&gt;Value type is &lt;code&gt;MiniWordPicture&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Example&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new Dictionary&amp;lt;string, object&amp;gt;()&#xA;{&#xA;    [&#34;Logo&#34;] = new MiniWordPicture() { Path= PathHelper.GetFile(&#34;DemoLogo.png&#34;), Width= 180, Height= 180 }&#xA;};&#xA;MiniWord.SaveAsByTemplate(path, templatePath, value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Template&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;C:%5CUsers%5CWei%5CDownloads%5C190647953-6f9da393-e666-4658-a56d-b3a7f13c0ea1.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Result&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;C:%5CUsers%5CWei%5CDownloads%5C190648179-30258d82-723d-4266-b711-43f132d1842d.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;List&lt;/h3&gt; &#xA;&lt;p&gt;tag value is &lt;code&gt;string[]&lt;/code&gt; or &lt;code&gt;IList&amp;lt;string&amp;gt;&lt;/code&gt; type&lt;/p&gt; &#xA;&lt;h5&gt;Example&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new Dictionary&amp;lt;string, object&amp;gt;()&#xA;{&#xA;    [&#34;managers&#34;] = new[] { &#34;Jack&#34; ,&#34;Alan&#34;},&#xA;    [&#34;employees&#34;] = new[] { &#34;Mike&#34; ,&#34;Henry&#34;},&#xA;};&#xA;MiniWord.SaveAsByTemplate(path, templatePath, value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Template&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;C:%5CUsers%5CWei%5CDownloads%5C190645513-230c54f3-d38f-47af-b844-0c8c1eff2f52.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Result&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;C:%5CUsers%5CWei%5CDownloads%5C190645704-1f6405e9-71e3-45b9-aa99-2ba52e5e1519.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Table&lt;/h3&gt; &#xA;&lt;p&gt;Tag value is &lt;code&gt;IEmerable&amp;lt;Dictionary&amp;lt;string,object&amp;gt;&amp;gt;&lt;/code&gt; type&lt;/p&gt; &#xA;&lt;h5&gt;Example&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new Dictionary&amp;lt;string, object&amp;gt;()&#xA;{&#xA;    [&#34;TripHs&#34;] = new List&amp;lt;Dictionary&amp;lt;string, object&amp;gt;&amp;gt;&#xA;    {&#xA;        new Dictionary&amp;lt;string, object&amp;gt;&#xA;        {&#xA;            { &#34;sDate&#34;,DateTime.Parse(&#34;2022-09-08 08:30:00&#34;)},&#xA;            { &#34;eDate&#34;,DateTime.Parse(&#34;2022-09-08 15:00:00&#34;)},&#xA;            { &#34;How&#34;,&#34;Discussion requirement part1&#34;},&#xA;            { &#34;Photo&#34;,new MiniWordPicture() { Path = PathHelper.GetFile(&#34;DemoExpenseMeeting02.png&#34;), Width = 160, Height = 90 }},&#xA;        },&#xA;        new Dictionary&amp;lt;string, object&amp;gt;&#xA;        {&#xA;            { &#34;sDate&#34;,DateTime.Parse(&#34;2022-09-09 08:30:00&#34;)},&#xA;            { &#34;eDate&#34;,DateTime.Parse(&#34;2022-09-09 17:00:00&#34;)},&#xA;            { &#34;How&#34;,&#34;Discussion requirement part2 and development&#34;},&#xA;            { &#34;Photo&#34;,new MiniWordPicture() { Path = PathHelper.GetFile(&#34;DemoExpenseMeeting01.png&#34;), Width = 160, Height = 90 }},&#xA;        },&#xA;    }&#xA;};&#xA;MiniWord.SaveAsByTemplate(path, templatePath, value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Template&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;C:%5CUsers%5CWei%5CDownloads%5C190843632-05bb6459-f1c1-4bdc-a79b-54889afdfeea.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Result&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;C:%5CUsers%5CWei%5CDownloads%5C190843663-c00baf16-21f2-4579-9d08-996a2c8c549b.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Other&lt;/h2&gt; &#xA;&lt;h3&gt;POCO or dynamic parameter&lt;/h3&gt; &#xA;&lt;p&gt;v0.5.0 support POCO or dynamic parameter&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new { title = &#34;Hello MiniWord&#34; };&#xA;MiniWord.SaveAsByTemplate(outputPath, templatePath, value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FontColor and HighlightColor&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new&#xA;{&#xA;    Company_Name = new MiniWordColorText { Text = &#34;MiniSofteware&#34;, FontColor = &#34;#eb70AB&#34; },&#xA;    Name = new MiniWordColorText { Text = &#34;Jack&#34;, HighlightColor = &#34;#eb70AB&#34; },&#xA;    CreateDate = new MiniWordColorText { Text = new DateTime(2021, 01, 01).ToString(), HighlightColor = &#34;#eb70AB&#34;, FontColor = &#34;#ffffff&#34; },&#xA;    VIP = true,&#xA;    Points = 123,&#xA;    APP = &#34;Demo APP&#34;,&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HyperLink&lt;/h3&gt; &#xA;&lt;p&gt;If value type is &lt;code&gt;MiniWordHyperLink&lt;/code&gt; system will replace template string by hyperlink.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Urlï¼š HyperLink URI target path&lt;/li&gt; &#xA; &lt;li&gt;Textï¼šDescription&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var value = new &#xA;{&#xA;    [&#34;Name&#34;] = new MiniWordHyperLink(){&#xA;        Url = &#34;https://google.com&#34;,&#xA;        Text = &#34;Test Link!!&#34;&#xA;    },&#xA;    [&#34;Company_Name&#34;] = &#34;MiniSofteware&#34;,&#xA;    [&#34;CreateDate&#34;] = new DateTime(2021, 01, 01),&#xA;    [&#34;VIP&#34;] = true,&#xA;    [&#34;Points&#34;] = 123,&#xA;    [&#34;APP&#34;] = &#34;Demo APP&#34;,&#xA;};&#xA;MiniWord.SaveAsByTemplate(path, templatePath, value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h4&gt;ASP.NET Core 3.1 API Export&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;using Microsoft.AspNetCore.Builder;&#xA;using Microsoft.AspNetCore.Hosting;&#xA;using Microsoft.AspNetCore.Mvc;&#xA;using Microsoft.Extensions.DependencyInjection;&#xA;using Microsoft.Extensions.Hosting;&#xA;using System;&#xA;using System.Collections.Generic;&#xA;using System.IO;&#xA;using System.Net;&#xA;using MiniSoftware;&#xA;&#xA;public class Program&#xA;{&#xA;    public static void Main(string[] args) =&amp;gt; CreateHostBuilder(args).Build().Run();&#xA;&#xA;    public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args).ConfigureWebHostDefaults(webBuilder =&amp;gt; webBuilder.UseStartup&amp;lt;Startup&amp;gt;());&#xA;}&#xA;&#xA;public class Startup&#xA;{&#xA;    public void ConfigureServices(IServiceCollection services) =&amp;gt; services.AddMvc();&#xA;    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#xA;    {&#xA;        app.UseStaticFiles();&#xA;        app.UseRouting();&#xA;        app.UseEndpoints(endpoints =&amp;gt;&#xA;        {&#xA;            endpoints.MapControllerRoute(&#xA;                name: &#34;default&#34;,&#xA;                pattern: &#34;{controller=api}/{action=Index}/{id?}&#34;);&#xA;        });&#xA;    }&#xA;}&#xA;&#xA;public class ApiController : Controller&#xA;{&#xA;    public IActionResult Index()&#xA;    {&#xA;        return new ContentResult&#xA;        {&#xA;            ContentType = &#34;text/html&#34;,&#xA;            StatusCode = (int)HttpStatusCode.OK,&#xA;            Content = @&#34;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&#xA;&amp;lt;a href=&#39;api/DownloadWordFromTemplatePath&#39;&amp;gt;DownloadWordFromTemplatePath&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&#xA;&amp;lt;a href=&#39;api/DownloadWordFromTemplateBytes&#39;&amp;gt;DownloadWordFromTemplateBytes&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&#xA;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#34;&#xA;        };&#xA;    }&#xA;&#xA;    static Dictionary&amp;lt;string, object&amp;gt; defaultValue = new Dictionary&amp;lt;string, object&amp;gt;()&#xA;    {&#xA;        [&#34;title&#34;] = &#34;FooCompany&#34;,&#xA;        [&#34;managers&#34;] = new List&amp;lt;Dictionary&amp;lt;string, object&amp;gt;&amp;gt; {&#xA;            new Dictionary&amp;lt;string, object&amp;gt;{{&#34;name&#34;,&#34;Jack&#34;},{ &#34;department&#34;, &#34;HR&#34; } },&#xA;            new Dictionary&amp;lt;string, object&amp;gt; {{ &#34;name&#34;, &#34;Loan&#34;},{ &#34;department&#34;, &#34;IT&#34; } }&#xA;        },&#xA;        [&#34;employees&#34;] = new List&amp;lt;Dictionary&amp;lt;string, object&amp;gt;&amp;gt; {&#xA;            new Dictionary&amp;lt;string, object&amp;gt;{{ &#34;name&#34;, &#34;Wade&#34; },{ &#34;department&#34;, &#34;HR&#34; } },&#xA;            new Dictionary&amp;lt;string, object&amp;gt; {{ &#34;name&#34;, &#34;Felix&#34; },{ &#34;department&#34;, &#34;HR&#34; } },&#xA;            new Dictionary&amp;lt;string, object&amp;gt;{{ &#34;name&#34;, &#34;Eric&#34; },{ &#34;department&#34;, &#34;IT&#34; } },&#xA;            new Dictionary&amp;lt;string, object&amp;gt; {{ &#34;name&#34;, &#34;Keaton&#34; },{ &#34;department&#34;, &#34;IT&#34; } }&#xA;        }&#xA;    };&#xA;&#xA;    public IActionResult DownloadWordFromTemplatePath()&#xA;    {&#xA;        string templatePath = &#34;TestTemplateComplex.docx&#34;;&#xA;&#xA;        Dictionary&amp;lt;string, object&amp;gt; value = defaultValue;&#xA;&#xA;        MemoryStream memoryStream = new MemoryStream();&#xA;        MiniWord.SaveAsByTemplate(memoryStream, templatePath, value);&#xA;        memoryStream.Seek(0, SeekOrigin.Begin);&#xA;        return new FileStreamResult(memoryStream, &#34;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#34;)&#xA;        {&#xA;            FileDownloadName = &#34;demo.docx&#34;&#xA;        };&#xA;    }&#xA;&#xA;    private static Dictionary&amp;lt;string, Byte[]&amp;gt; TemplateBytesCache = new Dictionary&amp;lt;string, byte[]&amp;gt;();&#xA;&#xA;    static ApiController()&#xA;    {&#xA;        string templatePath = &#34;TestTemplateComplex.docx&#34;;&#xA;        byte[] bytes = System.IO.File.ReadAllBytes(templatePath);&#xA;        TemplateBytesCache.Add(templatePath, bytes);&#xA;    }&#xA;&#xA;    public IActionResult DownloadWordFromTemplateBytes()&#xA;    {&#xA;        byte[] bytes = TemplateBytesCache[&#34;TestTemplateComplex.docx&#34;];&#xA;&#xA;        Dictionary&amp;lt;string, object&amp;gt; value = defaultValue;&#xA;&#xA;        MemoryStream memoryStream = new MemoryStream();&#xA;        MiniWord.SaveAsByTemplate(memoryStream, bytes, value);&#xA;        memoryStream.Seek(0, SeekOrigin.Begin);&#xA;        return new FileStreamResult(memoryStream, &#34;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#34;)&#xA;        {&#xA;            FileDownloadName = &#34;demo.docx&#34;&#xA;        };&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support : &lt;a href=&#34;https://miniexcel.github.io/&#34;&gt;Donate Link&lt;/a&gt;&lt;/h2&gt;</summary>
  </entry>
</feed>