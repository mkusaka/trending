<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-25T01:30:43Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>WeakKnight/GDC23_PracticalMobileRendering</title>
    <updated>2023-03-25T01:30:43Z</updated>
    <id>tag:github.com,2023-03-25:/WeakKnight/GDC23_PracticalMobileRendering</id>
    <link href="https://github.com/WeakKnight/GDC23_PracticalMobileRendering" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Demo for Practical High-Performance Rendering on Mobile Platforms (GDC 2023)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Practical High-Performance Rendering on Mobile Platforms (GDC 2023)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12985760/226530860-dfdbb68e-ed00-40d3-8c3b-035e9b24179e.png&#34; alt=&#34;Teaser&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;This repo includes the demo project for the following GDC 2023 talk&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Practical High-Performance Rendering on Mobile Platforms&lt;br&gt; &lt;a href=&#34;https://schedule.gdconf.com/session/practical-high-performance-rendering-on-mobile-platforms/890038&#34;&gt;https://schedule.gdconf.com/session/practical-high-performance-rendering-on-mobile-platforms/890038&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This project contains three parts: a &lt;strong&gt;Scriptable Render Pipeline&lt;/strong&gt; named &lt;strong&gt;PMRP&lt;/strong&gt;, a &lt;strong&gt;Visibility Baking Tool&lt;/strong&gt;, and a &lt;strong&gt;Lightmapper&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project Members&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/guoxx&#34;&gt;guoxx&lt;/a&gt; - &lt;strong&gt;Xiaoxin Guo&lt;/strong&gt; &amp;lt;&lt;a href=&#34;mailto:guoxx@me.com&#34;&gt;guoxx@me.com&lt;/a&gt;&amp;gt; (he/him)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/weakknight&#34;&gt;weakknight&lt;/a&gt; - &lt;strong&gt;Tianyu Li&lt;/strong&gt; &amp;lt;&lt;a href=&#34;mailto:ltyucb@gmail.com&#34;&gt;ltyucb@gmail.com&lt;/a&gt;&amp;gt; (he/him)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Frame Dissecting&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12985760/226530905-2fe9cad7-292f-4e45-a42a-547c9fdaa8ae.gif&#34; alt=&#34;LightingComponents&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Render Pipeline&lt;/h2&gt; &#xA;&lt;h4&gt;Feature&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Highly optimized for &lt;strong&gt;Mobile Platforms&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Specular Occlusion&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Platform-agnostic &lt;strong&gt;Shadow Bias&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Visibility Tool (Will Be Available Soon)&lt;/h2&gt; &#xA;&lt;h4&gt;Feature&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Visibility Baking&lt;/strong&gt; with least square vertex optimization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Lightmapper&lt;/h2&gt; &#xA;&lt;h4&gt;Feature&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://cs.dartmouth.edu/wjarosz/publications/seyb20uberbake.html&#34;&gt;Dynamic Baking&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/12985760/226519094-62041dce-ac77-4e8b-b786-c23ef7421bd9.mp4&#34;&gt;https://user-images.githubusercontent.com/12985760/226519094-62041dce-ac77-4e8b-b786-c23ef7421bd9.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightmap&lt;/strong&gt; and &lt;strong&gt;Volumetric Lightmap&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Path Tracing&lt;/strong&gt; integrator with &lt;strong&gt;Resampled Importance Sampling&lt;/strong&gt; + &lt;strong&gt;Light BVH&lt;/strong&gt; + &lt;strong&gt;Irradiance Caching&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Including &lt;strong&gt;Specular-To-Diffuse&lt;/strong&gt; light paths&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;How-to-use&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12985760/226530960-0d412391-b300-4962-b008-8d721c85096b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://unity.com/releases/editor/beta/2023.1.0b6&#34;&gt;Unity 2023.1.0b6&lt;/a&gt; or newer&lt;/li&gt; &#xA; &lt;li&gt;Windows 10 SDK version 10.0.19041.1 or newer&lt;/li&gt; &#xA; &lt;li&gt;Graphics card with raytracing support&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>SteveSandersonMS/DotNetIsolator</title>
    <updated>2023-03-25T01:30:43Z</updated>
    <id>tag:github.com,2023-03-25:/SteveSandersonMS/DotNetIsolator</id>
    <link href="https://github.com/SteveSandersonMS/DotNetIsolator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for running isolated .NET runtimes inside .NET&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DotNetIsolator [EXPERIMENTAL]&lt;/h1&gt; &#xA;&lt;p&gt;Lets your .NET code run other .NET code in an isolated environment easily.&lt;/p&gt; &#xA;&lt;p&gt;Basic concept:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create as many &lt;code&gt;IsolatedRuntime&lt;/code&gt; instances as you like. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Each one is actually a WebAssembly sandbox built with &lt;a href=&#34;https://github.com/dotnet/dotnet-wasi-sdk&#34;&gt;dotnet-wasi-sdk&lt;/a&gt; and running on &lt;a href=&#34;https://github.com/bytecodealliance/wasmtime-dotnet&#34;&gt;Wasmtime&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Each one has a completely separate memory space and no direct access to the host machine&#39;s disk/network/OS/etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Make .NET calls into &lt;code&gt;IsolatedRuntime&lt;/code&gt; instances. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Either create &lt;code&gt;IsolatedObject&lt;/code&gt; instances within those runtimes then invoke their methods&lt;/li&gt; &#xA;   &lt;li&gt;... or just call a lambda method directly&lt;/li&gt; &#xA;   &lt;li&gt;You can pass/capture/return arbitrary values across the boundary, and they will be serialized automatically via Messagepack&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This is &lt;strong&gt;experimental&lt;/strong&gt; and &lt;strong&gt;unsupported&lt;/strong&gt;. It may or may not be developed any further. There will definitely be functional gaps. There are no guarantees &lt;a href=&#34;https://raw.githubusercontent.com/SteveSandersonMS/DotNetIsolator/main/#security-notes&#34;&gt;about security&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;First, install the package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet add package DotNetIsolator --prerelease&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now try this code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;// Set up an isolated runtime&#xA;using var host = new IsolatedRuntimeHost().WithBinDirectoryAssemblyLoader();&#xA;using var runtime = new IsolatedRuntime(host);&#xA;&#xA;// Output: I&#39;m running on X64&#xA;Console.WriteLine($&#34;I&#39;m running on {RuntimeInformation.OSArchitecture}&#34;);&#xA;&#xA;runtime.Invoke(() =&amp;gt;&#xA;{&#xA;    // Output: I&#39;m running on Wasm&#xA;    Console.WriteLine($&#34;I&#39;m running on {RuntimeInformation.OSArchitecture}&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, for a more involved example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;// Set up the runtime&#xA;using var host = new IsolatedRuntimeHost().WithBinDirectoryAssemblyLoader();&#xA;using var isolatedRuntime = new IsolatedRuntime(host);&#xA;&#xA;// Evaluate the environment info in both the host runtime and the isolated one&#xA;var realInfo = GetEnvironmentInfo();&#xA;var isolatedInfo = isolatedRuntime.Invoke(GetEnvironmentInfo);&#xA;Console.WriteLine($&#34;Real env: {realInfo}&#34;);&#xA;Console.WriteLine($&#34;Isolated env: {isolatedInfo}&#34;);&#xA;&#xA;static EnvInfo GetEnvironmentInfo()&#xA;{&#xA;    var sysRoot = Environment.GetEnvironmentVariable(&#34;SystemRoot&#34;) ?? &#34;(Not set)&#34;;&#xA;    return new EnvInfo(&#xA;        Environment.GetEnvironmentVariables().Count,&#xA;        $&#34;SystemRoot={sysRoot}&#34;);&#xA;}&#xA;&#xA;// Demonstrates that you can return arbitrarily-typed objects&#xA;record EnvInfo(int NumEnvVars, string ExampleEnvVar)&#xA;{&#xA;    public override string ToString() =&amp;gt; $&#34;{NumEnvVars} entries, including {ExampleEnvVar}&#34;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Output, which will differ slighly on macOS/Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Real env: 64 entries, including SystemRoot=C:\WINDOWS&#xA;Isolated env: 0 entries, including SystemRoot=(Not set)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API guides&lt;/h2&gt; &#xA;&lt;h3&gt;Creating an &lt;code&gt;IsolatedRuntimeHost&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;First you must create an &lt;code&gt;IsolatedRuntimeHost&lt;/code&gt;. These host objects can be shared across users, since they don&#39;t hold any per-runtime state. If you&#39;re using DI, you could register it as a singleton.&lt;/p&gt; &#xA;&lt;p&gt;The purpose of this is to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Start up &lt;a href=&#34;https://github.com/bytecodealliance/wasmtime-dotnet&#34;&gt;Wasmtime&lt;/a&gt;. This takes ~400ms so you only want to do it once and not every time you instantiate an &lt;code&gt;IsolatedRuntime&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Configure assembly loading&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Configuring assembly loading&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The isolated .NET runtime instances need to load .NET assemblies in order to do anything useful. This package includes a WebAssembly-specific .NET base class library (BCL) for low-level .NET types such as &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;Dictionary&amp;lt;T, U&amp;gt;&lt;/code&gt;, etc. Isolated runtimes always have permission to load these prebundled BCL assemblies.&lt;/p&gt; &#xA;&lt;p&gt;You will almost always also want to load application-specific assemblies into your isolated runtimes, so that you can run your own code. The easiest way to configure assembly loading is to use &lt;code&gt;WithBinDirectoryAssemblyLoader&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;using var host = new IsolatedRuntimeHost()&#xA;    .WithBinDirectoryAssemblyLoader();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This grants permission to load .NET assemblies from your host application&#39;s &lt;code&gt;bin&lt;/code&gt; directory. This makes it possible to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke lambda methods (since the code for those methods is inside the DLLs in your &lt;code&gt;bin&lt;/code&gt; directory)&lt;/li&gt; &#xA; &lt;li&gt;Instantiate objects of arbitrary types inside isolated runtimes&lt;/li&gt; &#xA; &lt;li&gt;Pass/return types declared in your own application or other packages that you reference&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;WithBinDirectoryAssemblyLoader&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; allow the guest code to escape from its sandbox. Even though it can load assemblies from the host application, it can only use them within its sandbox.&lt;/p&gt; &#xA;&lt;p&gt;If you want to impose stricter controls over assembly loading, then instead of &lt;code&gt;WithBinDirectoryAssemblyLoader&lt;/code&gt;, you can use &lt;code&gt;WithAssemblyLoader&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;using var host = new IsolatedRuntimeHost()&#xA;    .WithAssemblyLoader(assemblyName =&amp;gt;&#xA;    {&#xA;        switch (assemblyName)&#xA;        {&#xA;            case &#34;MyAssembly&#34;:&#xA;                return File.ReadAllBytes(&#34;some/path/to/MyAssembly.dll&#34;);&#xA;        }&#xA;&#xA;        return null; // Unknown assembly. Maybe another loader will find it.&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can register as many assembly loaders as you wish.&lt;/p&gt; &#xA;&lt;h3&gt;Creating an &lt;code&gt;IsolatedRuntime&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Once you have an &lt;code&gt;IsolatedRuntimeHost&lt;/code&gt;, it&#39;s trivial to create as many runtimes as you like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;using var runtime1 = new IsolatedRuntime(host);&#xA;using var runtime2 = new IsolatedRuntime(host);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently, each runtime takes ~8ms to instantiate.&lt;/p&gt; &#xA;&lt;h3&gt;Calling lambdas&lt;/h3&gt; &#xA;&lt;p&gt;Once you have an &lt;code&gt;IsolatedRuntime&lt;/code&gt;, you can dispatch calls into them by using &lt;code&gt;Invoke&lt;/code&gt; and lambda methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var person1 = new Person(3);&#xA;var person2 = new Person(9);&#xA;&#xA;var sumOfAges = runtime.Invoke(() =&amp;gt;&#xA;{&#xA;    // This runs inside the isolated runtime.&#xA;    // Notice that we can use closure-captured values/objects too.&#xA;    // They will be serialized in using MessagePack.&#xA;    return person1.Age + person2.Age;&#xA;});&#xA;&#xA;// Output: The isolated runtime calculated the result: 12&#xA;Console.WriteLine($&#34;The isolated runtime calculated the result: {sumOfAges}&#34;);&#xA;&#xA;record Person(int Age);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if the lambda mutates the value of captured objects or static fields, those changes will only take effect inside the isolated runtime. It cannot affect objects in the host runtime, since there is no direct sharing of memory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public static int StaticCounter = 0;&#xA;&#xA;private static void Main(string[] args)&#xA;{&#xA;    using var host = new IsolatedRuntimeHost().WithBinDirectoryAssemblyLoader();&#xA;    using var runtime = new IsolatedRuntime(host);&#xA;&#xA;    int localValue = 0;&#xA;&#xA;    runtime.Invoke(() =&amp;gt;&#xA;    {&#xA;        StaticCounter++;&#xA;        localValue++;&#xA;        Console.WriteLine($&#34;(isolated) StaticCounter={StaticCounter}, localValue={localValue}&#34;);&#xA;    });&#xA;&#xA;    Console.WriteLine($&#34;(host)     StaticCounter={StaticCounter}, localValue={localValue}&#34;);&#xA;&#xA;    // The output is:&#xA;    // (isolated) StaticCounter=1, localValue=1&#xA;    // (host)     StaticCounter=0, localValue=0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Instantiating isolated objects&lt;/h3&gt; &#xA;&lt;p&gt;Using lambdas is convenient, but only works if the isolated runtime is allowed to load the assemblies from your &lt;code&gt;bin&lt;/code&gt; directory (because that&#39;s where the code is).&lt;/p&gt; &#xA;&lt;p&gt;As an alternative, you can manually instantiate isolated objects inside the isolated runtime, then call methods on them. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;// Generic API&#xA;IsolatedObject obj1 = runtime.CreateObject&amp;lt;Person&amp;gt;();&#xA;&#xA;// String-based API (useful if the host app doesn&#39;t reference the assembly containing the type)&#xA;IsolatedObject obj2 = runtime.CreateObject(&#34;MyAssembly&#34;, &#34;MyNamespace&#34;, &#34;Person&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;CreateObject&lt;/code&gt; requires the object type to have a parameterless constructor. Support for constructor parameters isn&#39;t yet implemented (but would be simple to do).&lt;/p&gt; &#xA;&lt;h3&gt;Calling methods on isolated objects&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;Invoke&lt;/code&gt; or &lt;code&gt;InvokeVoid&lt;/code&gt; to find a method and invoke it in a single step. For example, if the object has a method &lt;code&gt;void DoSomething(int value)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;isolatedObject.InvokeVoid(&#34;DoSomething&#34;, 123);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If it has a return value, you must specify the type as a generic parameter. For example, if the object has a method &lt;code&gt;TimeSpan GetAge(bool includeGestation)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;TimeSpan result = isolatedObject.Invoke&amp;lt;bool, TimeSpan&amp;gt;(&#34;GetAge&#34;, /* includeGestation */ true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively you can capture a reference to an &lt;code&gt;IsolateMethod&lt;/code&gt; so you can invoke it later. This is similar to a &lt;code&gt;MethodInfo&lt;/code&gt; so it isn&#39;t bound to a specific target object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var getAgeMethod = isolatedObject.FindMethod(&#34;GetAge&#34;);&#xA;&#xA;// ... then later:&#xA;var age = getAgeMethod.Invoke&amp;lt;bool, TimeSpan&amp;gt;(isolatedObject, /* includeGestation */ true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also find methods without having to instantiate any objects first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var getAgeMethod = isolatedRuntime.GetMethod(typeof(Person), &#34;GetAge&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Security notes&lt;/h2&gt; &#xA;&lt;p&gt;If you want to rely on this isolation as a critical security boundary in your application, you should bear in mind that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;This is an experimental prerelease package&lt;/strong&gt;. No security review has taken place. There could be defects that allow guest code to cause unintentional effects on the host.&lt;/li&gt; &#xA; &lt;li&gt;WebAssembly itself defines an extremely well-proven sandbox (browsers run untrusted WebAssembly modules from any website, and have done so for years with a solid track record), but: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Wasmtime is a different implementation than what runs inside your browser. Learn more at &lt;a href=&#34;https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime&#34;&gt;Security and Correctness in Wasmtime&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;The security model for WebAssembly doesn&#39;t directly address side-channel attacks (e.g., &lt;a href=&#34;https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)&#34;&gt;spectre&lt;/a&gt;). There are robust solutions for this but it&#39;s outside the scope of this repo.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In summary:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you used this as one layer in a multi-layered security model, it would be a pretty good layer! But nobody&#39;s promising it&#39;s bulletproof on its own.&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re not running potentially hostile code, and are merely using this to manage the isolation of your own code, most of the above considerations don&#39;t apply.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Support and feedback&lt;/h2&gt; &#xA;&lt;p&gt;This is completely unsupported. There are no promises that this will be developed any further. It is published only to help people explore what they could do with this sort of capability.&lt;/p&gt; &#xA;&lt;p&gt;You are free to &lt;a href=&#34;https://github.com/SteveSandersonMS/DotNetIsolator/issues&#34;&gt;report issues&lt;/a&gt; but please don&#39;t assume you&#39;ll get any response, much less a fix.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vu-ls/Crassus</title>
    <updated>2023-03-25T01:30:43Z</updated>
    <id>tag:github.com,2023-03-25:/vu-ls/Crassus</id>
    <link href="https://github.com/vu-ls/Crassus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Crassus Windows privilege escalation discovery tool&lt;/h1&gt; &#xA;&lt;h1&gt;Quick start&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;Process Monitor&lt;/a&gt;, select the &lt;code&gt;Enable Boot Logging&lt;/code&gt; option. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/procmon_boot_log.png&#34; alt=&#34;&amp;quot;Process Monitor Boot Logging option&amp;quot;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Reboot.&lt;/li&gt; &#xA; &lt;li&gt;Once you have logged in and Windows has settled, run Process Monitor once again.&lt;/li&gt; &#xA; &lt;li&gt;When prompted, save the boot log, e.g., to &lt;code&gt;raw.PML&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Reset the default Process Monitor filter using &lt;code&gt;Ctrl-R&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Save this log file, e.g., to &lt;code&gt;boot.PML&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;Crassus.exe boot.PML&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Investigate any green colored results and the corresponding entries in &lt;code&gt;results.csv&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#why-crassus&#34;&gt;Why &#34;Crassus&#34;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#did-you-really-make-yet-another-privilege-escalation-discovery-tool&#34;&gt;Did you really make yet another privilege escalation discovery tool?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#flowchart&#34;&gt;Flowchart&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#screenshots&#34;&gt;Screenshots&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#Crassus-execution&#34;&gt;Crassus Execution&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#csv-output&#34;&gt;CSV Output&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#output-exports&#34;&gt;Exports&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#export-dll-functions&#34;&gt;Export DLL Functions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#export-dll-ordinals&#34;&gt;Export DLL Ordinals&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#getting-crassusexe&#34;&gt;Getting Crassus.exe&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#building-with-visual-studio&#34;&gt;Building with Visual studio&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#using-precompiled-crassusexe&#34;&gt;Using precompiled Crassus.exe&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#execution-flow&#34;&gt;Execution Flow&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#command-line-arguments&#34;&gt;Command Line Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#proxy-dll-template&#34;&gt;Proxy DLL Template&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#openssl-template&#34;&gt;openssl.cnf Template&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#compiling-proxy-dlls&#34;&gt;Compiling Proxy DLLs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#visual-studio&#34;&gt;Visual Studio&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#mingw&#34;&gt;MinGW&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#real-world-examples&#34;&gt;Real World Examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#acronis-true-image&#34;&gt;Acronis True Image&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#atlassian-bitbucket&#34;&gt;Atlassian Bitbucket&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#mcafee&#34;&gt;McAfee&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#microsoft-sql-server-2022&#34;&gt;Microsoft SQL Server 2022&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#missing-file-not-executed&#34;&gt;Missing files not loaded&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#code-executed-with-unexpected-privileges&#34;&gt;Code executed with unexpected privileges&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#findings-disappear-on-reboot&#34;&gt;Findings disappear on reboot&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#contributions&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Why &#34;Crassus&#34;?&lt;/h1&gt; &#xA;&lt;p&gt;Accenture made a tool called &lt;a href=&#34;https://github.com/Accenture/Spartacus&#34;&gt;Spartacus&lt;/a&gt;, which finds DLL hijacking opportunities on Windows. Using Spartacus as a starting point, we created Crassus to extend Windows privilege escalation finding capabilities beyond simply looking for missing files. The ACLs used by files and directories of privileged processes can find more than just &lt;a href=&#34;https://vuls.cert.org/confluence/display/Wiki/2021/06/21/Finding+Privilege+Escalation+Vulnerabilities+in+Windows+using+Process+Monitor&#34;&gt;looking for missing files&lt;/a&gt; to achieve the goal.&lt;/p&gt; &#xA;&lt;h2&gt;Did you really make yet another privilege escalation discovery tool?&lt;/h2&gt; &#xA;&lt;p&gt;...but with a twist as Crassus is utilizing the &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;SysInternals Process Monitor&lt;/a&gt; and is parsing raw PML log files. Typical usage is to generate a boot log using Process Monitor and then parse it with Crassus. It will also automatically generate source code for proxy DLLs with all relevant exports for vulnerable DLLs.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Parsing ProcMon PML files natively. The log (PML) parser has been implemented by porting partial functionality to C# from &lt;a href=&#34;https://github.com/eronnen/procmon-parser/&#34;&gt;https://github.com/eronnen/procmon-parser/&lt;/a&gt;. You can find the format specification &lt;a href=&#34;https://github.com/eronnen/procmon-parser/tree/master/docs&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Crassus will create source code for proxy DLLs for all missing DLLs that were identified. For instance, if an application is vulnerable to DLL Hijacking via &lt;code&gt;version.dll&lt;/code&gt;, Crassus will create &lt;code&gt;version.cpp&lt;/code&gt; and &lt;code&gt;version.def&lt;/code&gt; files for you with all the exports included in it. By default the proxy DLLs will launch &lt;code&gt;calc.exe&lt;/code&gt;. Build scripts are included to build the DLLs on Visual Studio or MinGW.&lt;/li&gt; &#xA; &lt;li&gt;For other events of interest, such as creating a process or loading a library, the ability for unprivileged users to modify the file or any parts of the path to the file is investigated.&lt;/li&gt; &#xA; &lt;li&gt;Able to process large PML files and store all events of interest in an output CSV file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Flowchart&lt;/h2&gt; &#xA;&lt;p&gt;The general gist of how Crassus works can be summarized in this flowchart: &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/Crassus_flowchart.png&#34; alt=&#34;Crassus flowchart&#34; title=&#34;Crassus flowchart&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Screenshots&lt;/h1&gt; &#xA;&lt;h2&gt;Crassus Execution&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/runtime.png&#34; alt=&#34;Running Crassus&#34; title=&#34;Running Crassus&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CSV Output&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/output.png&#34; alt=&#34;CSV Output&#34; title=&#34;CSV Output&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Output Exports&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/exports.png&#34; alt=&#34;Exports&#34; title=&#34;Exports&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Export DLL Functions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/exports-version.png&#34; alt=&#34;DLL Functions&#34; title=&#34;DLL Functions&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Export DLL Ordinals&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/exports-def.png&#34; alt=&#34;DLL Ordinals&#34; title=&#34;DLL Ordinals&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Getting Crassus.exe&lt;/h1&gt; &#xA;&lt;h2&gt;Building with Visual Studio&lt;/h2&gt; &#xA;&lt;p&gt;Crassus was developed as a Visual Studio 2019 project. To build &lt;code&gt;Crassus.exe&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open &lt;code&gt;Crassus.sln&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Press &lt;code&gt;Ctrl+Shift+B&lt;/code&gt; on your keyboard&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Using precompiled Crassus.exe&lt;/h2&gt; &#xA;&lt;p&gt;If you trust running other people&#39;s code without knowing what it does, &lt;code&gt;Crassus.exe&lt;/code&gt; is &lt;a href=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/binaries/Crassus.exe&#34;&gt;provided in this repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;Execution Flow&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;Process Monitor&lt;/a&gt;, select the &lt;code&gt;Enable Boot Logging&lt;/code&gt; option. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/procmon_boot_log.png&#34; alt=&#34;&amp;quot;Process Monitor Boot Logging option&amp;quot;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Reboot.&lt;/li&gt; &#xA; &lt;li&gt;Once you have logged in and Windows has settled, optionally also run &lt;a href=&#34;https://gist.github.com/wdormann/8afe4edf605627ee4f203861b6cc3a1c&#34;&gt;scheduled tasks that may be configured to run with privileges&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run Process Monitor once again.&lt;/li&gt; &#xA; &lt;li&gt;When prompted, save the boot log.&lt;/li&gt; &#xA; &lt;li&gt;Reset the default Process Monitor filter using &lt;code&gt;Ctrl-R&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Save this log file, e.g., to &lt;code&gt;boot.PML&lt;/code&gt;. The reason for re-saving the log file is twofold: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Older versions of Process Monitor do not save boot logs as a single file.&lt;/li&gt; &#xA;   &lt;li&gt;Boot logs by default will be unfiltered, which may contain extra noise, such as a local-user DLL hijacking in the launching of of Process Monitor itself.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Command Line Arguments&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Argument&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&amp;lt;PMLFILE&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Location (file) of the existing ProcMon event log file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--verbose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable verbose output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--debug&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable debug output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Parse the Process Monitor boot log saved in &lt;code&gt;boot.PML&lt;/code&gt;. All vulnerable paths will be saved as &lt;code&gt;results.csv&lt;/code&gt; and all proxy DLL source files in the &lt;code&gt;stubs&lt;/code&gt; subdirectory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\tmp&amp;gt; Crassus.exe boot.PML&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Proxy DLL Template&lt;/h2&gt; &#xA;&lt;p&gt;Below is the template that is used when generating proxy DLLs., For DLLs that are found by Crassus, the proxy DLL will contain the same export names as specified in &lt;code&gt;%_EXPORTS_%&lt;/code&gt;, as well as the same ordinals as specified in the &lt;code&gt;.def&lt;/code&gt; file. Crassus will detect whether the DLL needs to be built as a 32-bit library or a 64-bit library by looking at the architecture of the parent process, and tagging the source code in the &lt;code&gt;%_BUILD_AS_%&lt;/code&gt; field accordingly.&lt;/p&gt; &#xA;&lt;p&gt;If the real DLL cannot be found using the Process Monitor log, or if the export name is problematic, the build scripts will fall back to creating a DLL without specified exports.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once&#xA;    &#xA;//%_BUILD_AS%&#xA;&#xA;#include &amp;lt;windows.h&amp;gt;;&#xA;&#xA;extern &#34;C&#34; {&#xA;&#xA;  VOID Payload() {&#xA;      // Run your payload here.&#xA;      WinExec(&#34;calc.exe&#34;, 1);&#xA;  }&#xA;&#xA;  BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)&#xA;  {&#xA;      switch (fdwReason)&#xA;      {&#xA;      case DLL_PROCESS_ATTACH:&#xA;          Payload();&#xA;          break;&#xA;      case DLL_THREAD_ATTACH:&#xA;          break;&#xA;      case DLL_THREAD_DETACH:&#xA;          break;&#xA;      case DLL_PROCESS_DETACH:&#xA;          break;&#xA;      }&#xA;      return TRUE;&#xA;  }&#xA;&#xA;&#xA;  #ifdef ADD_EXPORTS&#xA;  %_EXPORTS_%&#xA;  #endif&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;openssl.cnf Template&lt;/h2&gt; &#xA;&lt;p&gt;For applications that unsafely use the &lt;code&gt;OPENSSLDIR&lt;/code&gt; variable value, a crafted &lt;code&gt;openssl.cnf&lt;/code&gt; file can be placed in the noted location. For this example, the software will load &lt;code&gt;C:\tmp\calc.dll&lt;/code&gt;. Be sure to use a 32-bit library to target 32-bit processes, and a 64-bit library to target 64-bit processes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-openssl_conf&#34;&gt;[openssl_init]&#xA;# This will attempt to load the file c:\tmp\calc.dll as part of OpenSSL initialization&#xA;# Build scripts should detect whether the calc.dll library needs to be built as 32-bit or 64-bit&#xA;/tmp/calc = asdf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Compiling Proxy DLLs&lt;/h1&gt; &#xA;&lt;h2&gt;Visual Studio&lt;/h2&gt; &#xA;&lt;p&gt;Compilation is possible using the &lt;code&gt;cl.exe&lt;/code&gt; binary included with Visual Studio. Specifically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cl.exe /DADD_EXPORTS /D_USRDLL /D_WINDLL &amp;lt;target&amp;gt;.cpp /LD /Fe&amp;lt;target&amp;gt;.dll /link /DEF:&amp;lt;target&amp;gt;.def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To automate the build process, including specifying whether the library should be 64-bit or 32-bit:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open the Visual Studio Developer Command Prompt.&lt;/li&gt; &#xA; &lt;li&gt;Build the DLLs with the &lt;code&gt;build.bat&lt;/code&gt; script.&lt;/li&gt; &#xA; &lt;li&gt;Rename the compiled file as necessary if the vulnerable file name ends with something other than &lt;code&gt;.dll&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Due to an unfortunate behavior with &lt;code&gt;vcvarsall.bat&lt;/code&gt;, which is &lt;a href=&#34;https://developercommunity.visualstudio.com/t/vcvarsallbat-reports-the-input-line-is-too-long-if/257260#T-N258712&#34;&gt;definitely not a bug&lt;/a&gt;, you may encounter trouble attempting to run &lt;code&gt;build.bat&lt;/code&gt; more than once in the same Visual Studio Developer Command Prompt session. If you encounter an error, simply close the window and launch it again.&lt;/p&gt; &#xA;&lt;h2&gt;MinGW&lt;/h2&gt; &#xA;&lt;p&gt;If Visual Studio isn&#39;t readily available, proxy DLLs can be compiled with &lt;a href=&#34;https://www.mingw-w64.org/&#34;&gt;MinGW-w64&lt;/a&gt; instead. On an Ubuntu platform for example, MinGW can be installed via the following: &lt;code&gt;sudo apt install g++-mingw-w64-x86-64-win32 g++-mingw-w64-i686-win32&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Create a 32-bit DLL&#xA;i686-w64-mingw32-g++ -c -o &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.cpp -D ADD_EXPORTS&#xA;i686-w64-mingw32-g++ -o &amp;lt;target&amp;gt;.dll &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.def -s -shared -Wl,--subsystem,windows&#xA;&#xA;# Create a 64-bit DLL&#xA;x86_64-w64-mingw32-g++ -c -o &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.cpp -D ADD_EXPORTS&#xA;x86_64-w64-mingw32-g++ -o &amp;lt;target&amp;gt;.dll &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.def -s -shared -Wl,--subsystem,windows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To automate the build process, including specifying whether the library should be 64-bit or 32-bit:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open a terminal.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;bash ./build.sh&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Rename the compiled file as necessary if the vulnerable file name ends with something other than &lt;code&gt;.dll&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Real World Examples&lt;/h1&gt; &#xA;&lt;h2&gt;Acronis True Image&lt;/h2&gt; &#xA;&lt;h3&gt;Crassus Analysis&lt;/h3&gt; &#xA;&lt;p&gt;As outlined in &lt;a href=&#34;https://kb.cert.org/vuls/id/114757&#34;&gt;VU#114757&lt;/a&gt;, older Acronis software contains multiple privilege escalation vulnerabilities.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Placement of &lt;code&gt;openssl.cnf&lt;/code&gt; in a unprivileged-user-creatable location.&lt;/li&gt; &#xA; &lt;li&gt;Inappropriate ACLs in the &lt;code&gt;C:\ProgramData\Acronis&lt;/code&gt; directory.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Crassus finds both of these issues automatically. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/acronis.png&#34; alt=&#34;Crassus output for Acronis&#34; title=&#34;Crassus output for Acronis&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;DLL Hijacking&lt;/h3&gt; &#xA;&lt;p&gt;By planting our compiled &lt;code&gt;curl.dll&lt;/code&gt; file in the &lt;code&gt;C:\ProgramData\Acronis\Agent\var\atp-downloader\&lt;/code&gt; directory and rebooting with a new Process Monitor boot log we can see that our payload that runs calc.exe runs, with SYSTEM privileges. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/acronis_planted.png&#34; alt=&#34;&amp;quot;Process Monitor log of planted curl.dll&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;openssl.cnf Placement&lt;/h3&gt; &#xA;&lt;p&gt;The vulnerable Acronis software attempts to load &lt;code&gt;openssl.cnf&lt;/code&gt; from two different locations. We&#39;ll place our template &lt;code&gt;openssl.cnf&lt;/code&gt; file in &lt;code&gt;c:\jenkins_agent\workspace\tp-openssl-win-vs2013\17\product\out\standard\vs_2013_release\openssl\ssl&lt;/code&gt;, and a 32-bit &lt;code&gt;calc.dll&lt;/code&gt; payload in &lt;code&gt;c:\tmp&lt;/code&gt;. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/acronis_openssl.png&#34; alt=&#34;&amp;quot;Process Monitor log of planted openssl.cnf&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Atlassian Bitbucket&lt;/h2&gt; &#xA;&lt;h3&gt;Crassus Analysis&lt;/h3&gt; &#xA;&lt;p&gt;As outlined in &lt;a href=&#34;https://kb.cert.org/vuls/id/240785&#34;&gt;VU#240785&lt;/a&gt;, older Atlassian Bitbucket software is vulnerable to privilege escalation due to weak ACLs of the installation directory. As with any Windows software that installs to a location outside of &lt;code&gt;C:\Program Files\&lt;/code&gt; or other ACL-restricted locations, it is up to the software installer to explicitly set ACLs on the target directory.&lt;/p&gt; &#xA;&lt;p&gt;Crassus finds many ways to achieve privilege escalation with this software, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Placement of missing DLLs in user-writable locations.&lt;/li&gt; &#xA; &lt;li&gt;Placement of missing EXEs in user-writable locations.&lt;/li&gt; &#xA; &lt;li&gt;Renaming the directory of a privileged EXE to allow user placement of an EXE of the same name.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/bitbucket.png&#34; alt=&#34;Crassus output for Atlassian Bitbucket&#34; title=&#34;Crassus output for Atlassian Bitbucket&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;EXE Hijacking&lt;/h3&gt; &#xA;&lt;p&gt;In the Crassus output, we can see that &lt;code&gt;c:\atlassian\bitbucket\7.9.1\elasticsearch\bin\elasticsearch-service-x64.exe&lt;/code&gt; is privileged, but since it&#39;s running we cannot simply replace it. However, we can use another trick to hijack it. We may be able to simply rename the directory that it lives in, create a new directory of the same name, and plant our payload there as the same name. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/bitbucket_rename_dir.png&#34; alt=&#34;&amp;quot;Rename the directory that a privileged process is running from&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once we reboot with a Process monitor boot log, we can see that our planted &lt;code&gt;elasticsearch-service-x64.exe&lt;/code&gt; file is running instead of the real one, based on the Windows Calculator icon. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/elasticsearch_planted.png&#34; alt=&#34;&amp;quot;Planted calc.exe as elasticsearch-service-x64.exe&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;McAfee&lt;/h2&gt; &#xA;&lt;p&gt;As outlined in &lt;a href=&#34;https://kb.cert.org/vuls/id/287178&#34;&gt;VU#287178&lt;/a&gt;, older versions of McAfee software are vulnerable to privilege escalation via &lt;code&gt;openssl.cnf&lt;/code&gt;. Let&#39;s have a look: &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/mcafee.png&#34; alt=&#34;Crassus output for Mcafee&#34; title=&#34;Crassus output for McAfee&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To see why there are two different references to &lt;code&gt;openssl.cnf&lt;/code&gt; in this boot log, we can refer to the &lt;code&gt;results.csv&lt;/code&gt; file: &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/mcafee_results.png&#34; alt=&#34;results.csv for Mcafee&#34; title=&#34;results.csv for McAfee&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that the loading of the &lt;code&gt;openssl.cnf&lt;/code&gt; file from the &lt;code&gt;D:\&lt;/code&gt; path will require further manual investigation, as the feasibility of loading such a path depends on the platform in question, and what access to the system is available. It may be possible to create an optical disk that provides an &lt;code&gt;openssl.cnf&lt;/code&gt; file that also refers to a path that resolves to the optical drive as well.&lt;/p&gt; &#xA;&lt;h2&gt;Microsoft SQL Server 2022&lt;/h2&gt; &#xA;&lt;p&gt;SQL Server 2022 isn&#39;t obviously vulnerable to privilege escalation due to weak ACLs &lt;strong&gt;unless&lt;/strong&gt; it is installed to a non-standard location. If it is installed to a location outside of &lt;code&gt;C:\Program Files&lt;/code&gt;, Crassus will uncover several possibilities for privilege escalation. Most Windows applications that include a privileged component appear to be exploitable in this manner if they are installed to a directory that doesn&#39;t already have inherently secure ACLs. &lt;img src=&#34;https://raw.githubusercontent.com/vu-ls/Crassus/main/screenshots/sqlserver2022.png&#34; alt=&#34;&amp;quot;Microsoft SQL Server 2022 installed to an insecure directory&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Troubleshooting&lt;/h1&gt; &#xA;&lt;h2&gt;Missing file not executed&lt;/h2&gt; &#xA;&lt;p&gt;If Crassus reports the privileged loading of a file that a user can plant or modify, this doesn&#39;t necessarily mean that it&#39;s an exploitable scenario. While Crassus looks for &lt;strong&gt;potentially&lt;/strong&gt; interesting file types, a Process Monitor log file will not directly indicate what the associated process &lt;strong&gt;would have&lt;/strong&gt; done with the file with it if it were there. It could be as simple as extracting a program icon. Investigating the call stack of the file operation in Process Monitor may give a hint as to what would have been done. Or simply place the file and investigate the behavior with a new Process Monitor boot log, if you prefer the easier brute force path. You may also encounter a missing library where either Crassus cannot find the library to know what exports should be present, or that the exports that Crassus found conflict in a way that prevents proper DLL compilation. In such cases, Crassus will fall back to creating a DLL that does not export any function names. Depending on how the target application loads the library, the absence of expected function names and/or ordinal numbers may prevent the target application from successfully loading the library. This scenario will require manual effort to determine what the proxy DLL should look like.&lt;/p&gt; &#xA;&lt;h2&gt;Code executed with unexpected privileges&lt;/h2&gt; &#xA;&lt;p&gt;Crassus will look for privileged file operations to discover paths of interest. You may encounter a scenario where both a privileged and an unprivileged process access a path, but only the non-privileged process is the one that does the execution of what may be present. Alternatively, you may encounter a scenario where a parent process does run with privileges, but it may explicitly spawn child processes with lower privileges.&lt;/p&gt; &#xA;&lt;h2&gt;Findings disappear on reboot&lt;/h2&gt; &#xA;&lt;p&gt;Especially when installing software for the first time, or when installing updates, Process Monitor may log a file operation that looks to be exploitable but does not occur every time that the system boots. Exploiting these operations may be possible on the first reboot after such an event happens. To avoid such edge cases, confirm that subsequent boot logs contain the same reported file operations on subsequent reboots.&lt;/p&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;Whether it&#39;s a typo, a bug, or a new feature, Crassus is very open to contributions as long as we agree on the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You are OK with the MIT license of this project.&lt;/li&gt; &#xA; &lt;li&gt;Before creating a pull request, create an issue so it could be discussed before doing any work as internal development is not tracked via the public GitHub repository. Otherwise, you risk having a pull request rejected if for example we are already working on the same/similar feature, or for any other reason.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eronnen/procmon-parser/&#34;&gt;https://github.com/eronnen/procmon-parser/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>