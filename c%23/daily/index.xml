<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-27T01:33:59Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Sergio0694/PolySharp</title>
    <updated>2022-10-27T01:33:59Z</updated>
    <id>tag:github.com,2022-10-27:/Sergio0694/PolySharp</id>
    <link href="https://github.com/Sergio0694/PolySharp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PolySharp provides generated, source-only polyfills for C# language features, to easily use all runtime-agnostic features downlevel. Add a reference, set your C# version to latest and have fun! üöÄ&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/10199417/197341200-3810e13c-9104-4911-90fc-b8add0862458.png&#34; alt=&#34;image&#34;&gt; &lt;a href=&#34;https://github.com/Sergio0694/PolySharp/actions&#34;&gt;&lt;img src=&#34;https://github.com/Sergio0694/PolySharp/workflows/.NET/badge.svg?sanitize=true&#34; alt=&#34;.NET&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/stats/packages/PolySharp?groupby=Version&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/PolySharp.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/PolySharp/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/PolySharp.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;What is it? üöÄ&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;PolySharp&lt;/strong&gt; provides generated, source-only polyfills for C# language features, to easily use all runtime-agnostic features downlevel. The package is distributed as a source generator, so that it will automatically detect which polyfills are needed depending on the target framework and project in use: just add a reference to &lt;strong&gt;PolySharp&lt;/strong&gt;, set your C# language version to latest, and have fun!&lt;/p&gt; &#xA;&lt;h1&gt;Documentation üìñ&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;PolySharp&lt;/strong&gt; includes the following polyfills:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Nullability attributes (for &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/nullable-references&#34;&gt;nullable reference types&lt;/a&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;[AllowNull]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[DisallowNull]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[DoesNotReturn]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[DoesNotReturnIf]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[MaybeNull]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[MaybeNullWhen]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[MemberNotNull]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[MemberNotNullWhen]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[NotNull]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[NotNullIfNotNull]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[NotNullWhen]&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Index&lt;/code&gt; and &lt;code&gt;Range&lt;/code&gt; (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/whats-new/tutorials/ranges-indexes&#34;&gt;indices and ranges&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[UnscopedRef]&lt;/code&gt; (see &lt;a href=&#34;https://github.com/dotnet/csharplang/raw/main/proposals/low-level-struct-improvements.md&#34;&gt;low-level struct improvements&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Required members (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/required&#34;&gt;required modifier&lt;/a&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;[RequiredMember]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[SetsRequiredMembers]&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[CompilerFeatureRequired]&lt;/code&gt; (needed to support several features)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[IsExternalInit]&lt;/code&gt; (needed for &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/init&#34;&gt;init-only properties&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[SkipLocalsInit]&lt;/code&gt; (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/language-reference/attributes/general#skiplocalsinit-attribute&#34;&gt;docs&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Interpolated string handlers (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/whats-new/tutorials/interpolated-string-handler&#34;&gt;docs&lt;/a&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;[InterpolatedStringHandler]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[InterpolatedStringHandlerArgument]&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[CallerArgumentExpression]&lt;/code&gt; (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-10.0/caller-argument-expression&#34;&gt;docs&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[RequiresPreviewFeatures]&lt;/code&gt; (needed for &lt;a href=&#34;https://github.com/dotnet/designs/raw/main/accepted/2021/preview-features/preview-features.md&#34;&gt;preview features&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[AsyncMethodBuilder]&lt;/code&gt; (needed for &lt;a href=&#34;https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-10.0/async-method-builders&#34;&gt;custom method builder types&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[StringSyntax]&lt;/code&gt; (needed to enable &lt;a href=&#34;https://github.com/dotnet/runtime/issues/62505&#34;&gt;syntax highlight in the IDE&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To leverage them, make sure to bump your C# language version. You can do this by setting the &lt;code&gt;&amp;lt;LangVersion&amp;gt;&lt;/code&gt; MSBuild property in your project. For instance, by adding &lt;code&gt;&amp;lt;LangVersion&amp;gt;11.0&amp;lt;/LangVersion&amp;gt;&lt;/code&gt; (or your desired C# version) to the first &lt;code&gt;&amp;lt;PropertyGroup&amp;gt;&lt;/code&gt; of your .csproj file. For more info on this, &lt;a href=&#34;https://sergiopedri.medium.com/enabling-and-using-c-9-features-on-older-and-unsupported-runtimes-ce384d8debb&#34;&gt;see here&lt;/a&gt;, but remember that you don&#39;t need to manually copy polyfills anymore: simply adding a reference to &lt;strong&gt;PolySharp&lt;/strong&gt; will do this for you automatically.&lt;/p&gt; &#xA;&lt;p&gt;It also includes the following optional runtime-supported polyfills:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Reflection annotation attributes (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/core/deploying/trimming/prepare-libraries-for-trimming&#34;&gt;docs&lt;/a&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;[DynamicallyAccessedMembers]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[DynamicDependency]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[RequiresUnreferencedCode]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[UnconditionalSuppressMessage]&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[StackTraceHidden]&lt;/code&gt; (see &lt;a href=&#34;https://makolyte.com/csharp-exclude-exception-throw-helper-methods-from-the-stack-trace/&#34;&gt;here&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[UnmanagedCallersOnly]&lt;/code&gt; (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.unmanagedcallersonlyattribute&#34;&gt;docs&lt;/a&gt;))&lt;/li&gt; &#xA; &lt;li&gt;Platform support annotation attributes (see &lt;a href=&#34;https://learn.microsoft.com/dotnet/standard/analyzers/platform-compat-analyzer&#34;&gt;docs&lt;/a&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;[ObsoletedOSPlatform]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[SupportedOSPlatform]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[SupportedOSPlatformGuard]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[TargetPlatform]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[UnsupportedOSPlatform]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;[UnsupportedOSPlatformGuard]&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Options ‚öôÔ∏è&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;PolySharp&lt;/strong&gt;&#39;s generation can be configured through some MSBuild properties to set in consuming projects.&lt;/p&gt; &#xA;&lt;p&gt;The following properties are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;PolySharpUsePublicAccessibilityForGeneratedTypes&#34;: makes all generated types public.&lt;/li&gt; &#xA; &lt;li&gt;&#34;PolySharpIncludeRuntimeSupportedAttributes&#34;: enables polyfills for (dummy) runtime-supported attributes too.&lt;/li&gt; &#xA; &lt;li&gt;&#34;PolySharpExcludeGeneratedTypes&#34;: excludes specific types from generation (&#39;;&#39; or &#39;,&#39; separated type names).&lt;/li&gt; &#xA; &lt;li&gt;&#34;PolySharpIncludeGeneratedTypes&#34;: only includes specific types for generation (&#39;;&#39; or &#39;,&#39; separated type names).&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>