<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-08T01:30:17Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SteveDunn/Vogen</title>
    <updated>2025-06-08T01:30:17Z</updated>
    <id>tag:github.com,2025-06-08:/SteveDunn/Vogen</id>
    <link href="https://github.com/SteveDunn/Vogen" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A semi-opinionated library which is a source generator and a code analyser. It Source generates Value Objects&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SteveDunn/Vogen/main/assets/cavey.png&#34; alt=&#34;Picture of caveman holding the number &#39;1&#39;&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/Vogen/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Vogen?color=ff4081&amp;amp;label=nuget%20version&amp;amp;logo=nuget&amp;amp;style=flat-square&#34; alt=&#34;Nuget version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Vogen/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/Vogen?color=ff4081&amp;amp;label=nuget%20downloads&amp;amp;logo=nuget&amp;amp;style=flat-square&#34; alt=&#34;Nuget downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/stevedunn/vogen/actions/workflows/build.yaml/badge.svg?sanitize=true&#34; alt=&#34;Build&#34;&gt; &lt;a href=&#34;https://GitHub.com/stevedunn/vogen/releases/&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/stevedunn/vogen.svg?sanitize=true&#34; alt=&#34;GitHub release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/SteveDunn/Vogen/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/stevedunn/vogen.svg?sanitize=true&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://GitHub.com/stevedunn/vogen/issues/&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues/Naereen/StrapDown.js.svg?sanitize=true&#34; alt=&#34;GitHub issues&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://GitHub.com/stevedunn/vogen/issues?q=is%3Aissue+is%3Aclosed&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues-closed/Naereen/StrapDown.js.svg?sanitize=true&#34; alt=&#34;GitHub issues-closed&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://stars.medv.io/stevedunn/vogen&#34;&gt;&lt;img src=&#34;https://stars.medv.io/stevedunn/vogen.svg?sanitize=true&#34; alt=&#34;Sparkline&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Give a Star! &lt;span&gt;‚≠ê&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;If you like or are using this project please give it a star. Thanks!&lt;/p&gt; &#xA;&lt;h1&gt;Vogen: cure your Primitive Obsession&lt;/h1&gt; &#xA;&lt;p&gt;Vogen (&lt;em&gt;pronounced &#34;Voh Jen&#34;&lt;/em&gt;) is a .NET Source Generator and analyzer. It turns your primitives (ints, decimals etc.) into value objects that represent domain concepts (CustomerId, AccountBalance etc.)&lt;/p&gt; &#xA;&lt;p&gt;It adds new C# compilation errors to help stop the creation of invalid value objects.&lt;/p&gt; &#xA;&lt;p&gt;This readme covers some of the functionality. Please see the &lt;a href=&#34;https://stevedunn.github.io/Vogen/vogen.html&#34;&gt;Wiki&lt;/a&gt; for more detailed information, such as getting started, tutorials, and how-tos.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The source generator generates strongly typed &lt;strong&gt;domain concepts&lt;/strong&gt;. You provide this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject&amp;lt;int&amp;gt;]&#xA;public partial struct CustomerId;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... and Vogen generates source similar to this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public partial struct CustomerId : &#xA;    System.IEquatable&amp;lt;CustomerId&amp;gt;, &#xA;    System.IComparable&amp;lt;CustomerId&amp;gt;, System.IComparable &#xA;{&#xA;    private readonly int _value;&#xA;&#xA;    public readonly int Value =&amp;gt; _value;&#xA;&#xA;    public CustomerId() {&#xA;        throw new Vogen.ValueObjectValidationException(&#xA;            &#34;Validation skipped by attempting to use the default constructor...&#34;);&#xA;    }&#xA;&#xA;    private CustomerId(int value) =&amp;gt; _value = value;&#xA;&#xA;    public static CustomerId From(int value) {&#xA;        CustomerId instance = new CustomerId(value);&#xA;        return instance;&#xA;    }&#xA;&#xA;    public readonly bool Equals(CustomerId other) ...&#xA;    public readonly bool Equals(int primitive) ...&#xA;    public readonly override bool Equals(object obj) ...&#xA;    public static bool operator ==(CustomerId left, CustomerId right) ...&#xA;    public static bool operator !=(CustomerId left, CustomerId right) ...&#xA;    public static bool operator ==(CustomerId left, int right) ...&#xA;    public static bool operator !=(CustomerId left, int right) ...&#xA;    public static bool operator ==(int left, CustomerId right) ...&#xA;    public static bool operator !=(int left, CustomerId right) ...&#xA;&#xA;    public readonly override int GetHashCode() ...&#xA;&#xA;    public readonly override string ToString() ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You then use &lt;code&gt;CustomerId&lt;/code&gt; instead of &lt;code&gt;int&lt;/code&gt; in your domain in the full knowledge that it is valid and safe to use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;CustomerId customerId = CustomerId.From(123);&#xA;SendInvoice(customerId);&#xA;...&#xA;&#xA;public void SendInvoice(CustomerId customerId) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;(you&#39;ll see the default public constructor is created, but the analyzer stops you from using it, as described in a bit...)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;int&lt;/code&gt; is the default type for value objects. It is generally a good idea to explicitly declare each type for clarity. You can also - individually or globally - configure them to be other types. See the Configuration section later in the document.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s some other examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject&amp;lt;decimal&amp;gt;] &#xA;public partial struct AccountBalance;&#xA;&#xA;[ValueObject&amp;lt;string&amp;gt;]&#xA;public partial class LegalEntityName;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The main goal of Vogen is to &lt;strong&gt;ensure the validity of your value objects&lt;/strong&gt;, the code analyser helps you to avoid mistakes which might leave you with uninitialized value objects in your domain.&lt;/p&gt; &#xA;&lt;p&gt;It does this by &lt;strong&gt;adding new constraints in the form of new C# compilation errors&lt;/strong&gt;. There are a few ways you could end up with uninitialized value objects. One way is by giving your type constructors. Providing your own constructors could mean that you forget to set a value, so &lt;strong&gt;Vogen doesn&#39;t allow you to have user defined constructors&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject]&#xA;public partial struct CustomerId &#xA;{&#xA;    // Vogen deliberately generates this so that you can&#39;t create your own:&#xA;    // error CS0111: Type &#39;CustomerId&#39; already defines a member called &#39;CustomerId&#39; &#xA;    // with the same parameter type&#xA;    public CustomerId() { }&#xA;&#xA;    // error VOG008: Cannot have user defined constructors, &#xA;    // please use the From method for creation.&#xA;    public CustomerId(int value) { }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, Vogen will spot issues when &lt;strong&gt;creating&lt;/strong&gt; or &lt;strong&gt;consuming&lt;/strong&gt; value objects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// catches object creation expressions&#xA;var c = new CustomerId(); // error VOG010: Type &#39;CustomerId&#39; cannot be constructed with &#39;new&#39; as it is prohibited&#xA;CustomerId c = default; // error VOG009: Type &#39;CustomerId&#39; cannot be constructed with default as it is prohibited.&#xA;&#xA;var c = default(CustomerId); // error VOG009: Type &#39;CustomerId&#39; cannot be constructed with default as it is prohibited.&#xA;var c = GetCustomerId(); // error VOG010: Type &#39;CustomerId&#39; cannot be constructed with &#39;new&#39; as it is prohibited&#xA;&#xA;var c = Activator.CreateInstance&amp;lt;CustomerId&amp;gt;(); // error VOG025: Type &#39;CustomerId&#39; cannot be constructed via Reflection as it is prohibited.&#xA;var c = Activator.CreateInstance(&amp;lt;CustomerId&amp;gt;); // error VOG025: Type &#39;MyVo&#39; cannot be constructed via Reflection as &#xA;it is prohibited&#xA;&#xA;// catches lambda expressions&#xA;Func&amp;lt;CustomerId&amp;gt; f = () =&amp;gt; default; // error VOG009: Type &#39;CustomerId&#39; cannot be constructed with default as it is prohibited.&#xA;&#xA;// catches method / local function return expressions&#xA;CustomerId GetCustomerId() =&amp;gt; default; // error VOG009: Type &#39;CustomerId&#39; cannot be constructed with default as it is prohibited.&#xA;CustomerId GetCustomerId() =&amp;gt; new CustomerId(); // error VOG010: Type &#39;CustomerId&#39; cannot be constructed with &#39;new&#39; as it is prohibited&#xA;CustomerId GetCustomerId() =&amp;gt; new(); // error VOG010: Type &#39;CustomerId&#39; cannot be constructed with &#39;new&#39; as it is prohibited&#xA;&#xA;// catches argument / parameter expressions&#xA;Task&amp;lt;CustomerId&amp;gt; t = Task.FromResult&amp;lt;CustomerId&amp;gt;(new()); // error VOG010: Type &#39;CustomerId&#39; cannot be constructed with &#39;new&#39; as it is prohibited&#xA;&#xA;void Process(CustomerId customerId = default) { } // error VOG009: Type &#39;CustomerId&#39; cannot be constructed with default as it is prohibited.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One of the main goals of this project is to achieve &lt;strong&gt;almost the same speed and memory performance as using primitives directly&lt;/strong&gt;. Put another way, if your &lt;code&gt;decimal&lt;/code&gt; primitive represents an Account Balance, then there is &lt;strong&gt;extremely&lt;/strong&gt; low overhead of using an &lt;code&gt;AccountBalance&lt;/code&gt; value object instead. Please see the &lt;a href=&#34;https://raw.githubusercontent.com/SteveDunn/Vogen/main/#Performance&#34;&gt;performance metrics below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Vogen is a &lt;a href=&#34;https://www.nuget.org/packages/Vogen&#34;&gt;Nuget package&lt;/a&gt;. Install it with:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;dotnet add package Vogen&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;When added to your project, the &lt;strong&gt;source generator&lt;/strong&gt; generates the wrappers for your primitives and the &lt;strong&gt;code analyser&lt;/strong&gt; will let you know if you try to create invalid value objects.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Think about your &lt;em&gt;domain concepts&lt;/em&gt; and how you use primitives to represent them, e.g. instead of this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void HandlePayment(int customerId, int accountId, decimal paymentAmount)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... have this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void HandlePayment(CustomerId customerId, AccountId accountId, PaymentAmount paymentAmount)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s as simple as creating types like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject] &#xA;public partial struct CustomerId;&#xA;&#xA;[ValueObject] &#xA;public partial struct AccountId;&#xA;&#xA;[ValueObject&amp;lt;decimal&amp;gt;] &#xA;public partial struct PaymentAmount;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More on Primitive Obsession&lt;/h2&gt; &#xA;&lt;p&gt;The source generator generates &lt;a href=&#34;https://wiki.c2.com/?ValueObject&#34;&gt;value objects&lt;/a&gt;. value objects help combat Primitive Obsession by wrapping simple primitives such as &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; etc. in a strongly-typed type.&lt;/p&gt; &#xA;&lt;p&gt;Primitive Obsession (AKA StringlyTyped) means being obsessed with primitives. It is a Code Smell that degrades the quality of software.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;&lt;em&gt;Primitive Obsession is using primitive data types to represent domain ideas&lt;/em&gt;&#34; &lt;a href=&#34;https://wiki.c2.com/?PrimitiveObsession&#34;&gt;#&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Some examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;instead of &lt;code&gt;int age&lt;/code&gt; - we&#39;d have &lt;code&gt;Age age&lt;/code&gt;. &lt;code&gt;Age&lt;/code&gt; might have validation that it couldn&#39;t be negative&lt;/li&gt; &#xA; &lt;li&gt;instead of &lt;code&gt;string postcode&lt;/code&gt; - we&#39;d have &lt;code&gt;Postcode postcode&lt;/code&gt;. &lt;code&gt;Postcode&lt;/code&gt; might have validation on the format of the text&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The source generator is opinionated. The opinions help ensure consistency. The opinions are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A value object (VO) is constructed via a factory method named &lt;code&gt;From&lt;/code&gt;, e.g. &lt;code&gt;Age.From(12)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;A VO is equatable (&lt;code&gt;Age.From(12) == Age.From(12)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;A VO, if validated, is validated with a static method named &lt;code&gt;Validate&lt;/code&gt; that returns a &lt;code&gt;Validation&lt;/code&gt; result&lt;/li&gt; &#xA; &lt;li&gt;Any validation that is not &lt;code&gt;Validation.Ok&lt;/code&gt; results in a &lt;code&gt;ValueObjectValidationException&lt;/code&gt; being thrown&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is common to represent domain ideas as primitives, but primitives might not be able to fully describe the domain idea.&lt;br&gt; To use value objects instead of primitives, we simply swap code like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class CustomerInfo {&#xA;    private int _id;&#xA;    public CustomerInfo(int id) =&amp;gt; _id = id;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;.. to this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class CustomerInfo {&#xA;    private CustomerId _id;&#xA;    public CustomerInfo(CustomerId id) =&amp;gt; _id = id;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tell me more about the Code Smell&lt;/h2&gt; &#xA;&lt;p&gt;There&#39;s a blog post &lt;a href=&#34;https://dunnhq.com/posts/2021/primitive-obsession/&#34;&gt;here&lt;/a&gt; that describes it, but to summarise:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Primitive Obsession is being &lt;em&gt;obsessed&lt;/em&gt; with the &lt;em&gt;seemingly&lt;/em&gt; &lt;strong&gt;convenient&lt;/strong&gt; way that primitives, such as &lt;code&gt;ints&lt;/code&gt; and &lt;code&gt;strings&lt;/code&gt;, allow us to represent domain objects and ideas.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;It is &lt;strong&gt;this&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int customerId = 42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What&#39;s wrong with that?&lt;/p&gt; &#xA;&lt;p&gt;A customer ID likely cannot be &lt;em&gt;fully&lt;/em&gt; represented by an &lt;code&gt;int&lt;/code&gt;. An &lt;code&gt;int&lt;/code&gt; can be negative or zero, but it&#39;s unlikely a customer ID can be. So, we have &lt;strong&gt;constraints&lt;/strong&gt; on a customer ID. We can&#39;t &lt;em&gt;represent&lt;/em&gt; or &lt;em&gt;enforce&lt;/em&gt; those constraints on an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;So, we need some validation to ensure the &lt;strong&gt;constraints&lt;/strong&gt; of a customer ID are met. Because it&#39;s in &lt;code&gt;int&lt;/code&gt;, we can&#39;t be sure if it&#39;s been checked beforehand, so we need to check it every time we use it. Because it&#39;s a primitive, someone might&#39;ve changed the value, so even if we&#39;re 100% sure we&#39;ve checked it before, it still might need checking again.&lt;/p&gt; &#xA;&lt;p&gt;So far, we&#39;ve used as an example, a customer ID of value &lt;code&gt;42&lt;/code&gt;. In C#, it may come as no surprise that &#34;&lt;code&gt;42 == 42&lt;/code&gt;&#34; (&lt;em&gt;I haven&#39;t checked that in JavaScript!&lt;/em&gt;). But, in our &lt;strong&gt;domain&lt;/strong&gt;, should &lt;code&gt;42&lt;/code&gt; always equal &lt;code&gt;42&lt;/code&gt;? Probably not if you&#39;re comparing a Supplier ID of &lt;code&gt;42&lt;/code&gt; to a Customer ID of &lt;code&gt;42&lt;/code&gt;! But primitives won&#39;t help you here (remember, &lt;code&gt;42 == 42&lt;/code&gt;!).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;(42 == 42) // true&#xA;(SuppliedId.From(42) == SupplierId.From(42)) // true&#xA;(SuppliedId.From(42) == VendorId.From(42)) // compilation error&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But sometimes, we need to denote that a value object isn&#39;t valid or has not been set. We don&#39;t want anyone &lt;em&gt;outside&lt;/em&gt; of the object doing this as it could be used accidentally. It&#39;s common to have &lt;code&gt;Unspecified&lt;/code&gt; instances, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Person {&#xA;    public Age Age { get; } = Age.Unspecified;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can do that with an &lt;code&gt;Instance&lt;/code&gt; attribute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  [ValueObject]&#xA;  [Instance(&#34;Unspecified&#34;, -1)]&#xA;  public readonly partial struct Age {&#xA;      public static Validation Validate(int value) =&amp;gt;&#xA;          value &amp;gt; 0 ? Validation.Ok : Validation.Invalid(&#34;Must be greater than zero.&#34;);&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This generates &lt;code&gt;public static Age Unspecified = new Age(-1);&lt;/code&gt;. The constructor is &lt;code&gt;private&lt;/code&gt;, so only this type can (deliberately) create &lt;em&gt;invalid&lt;/em&gt; instances.&lt;/p&gt; &#xA;&lt;p&gt;Now, when we use &lt;code&gt;Age&lt;/code&gt;, our validation becomes clearer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void Process(Person person) {&#xA;    if(person.Age == Age.Unspecified) {&#xA;        // age not specified.&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also specify other instance properties:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject&amp;lt;float&amp;gt;]&#xA;[Instance(&#34;Freezing&#34;, 0)]&#xA;[Instance(&#34;Boiling&#34;, 100)]&#xA;public readonly partial struct Celsius {&#xA;    public static Validation Validate(float value) =&amp;gt;&#xA;        value &amp;gt;= -273 ? Validation.Ok : Validation.Invalid(&#34;Cannot be colder than absolute zero&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Each value object can have its own &lt;em&gt;optional&lt;/em&gt; configuration. Configuration includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The underlying type&lt;/li&gt; &#xA; &lt;li&gt;Any &#39;conversions&#39; (Dapper, System.Text.Json, Newtonsoft.Json, etc.) - see &lt;a href=&#34;https://stevedunn.github.io/Vogen/integration.html&#34;&gt;the Integrations page&lt;/a&gt; in the wiki for more information&lt;/li&gt; &#xA; &lt;li&gt;The type of the exception that is thrown when validation fails&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If any of those above are not specified, then global configuration is inferred. It looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: VogenDefaults(&#xA;    underlyingType: typeof(int), &#xA;    conversions: Conversions.Default, &#xA;    throws: typeof(ValueObjectValidationException))]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Those again are optional. If they&#39;re not specified, then they are defaulted to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Underlying type = &lt;code&gt;typeof(int)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Conversions = &lt;code&gt;Conversions.Default&lt;/code&gt; (&lt;code&gt;TypeConverter&lt;/code&gt; and &lt;code&gt;System.Text.Json&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Validation exception type = &lt;code&gt;typeof(ValueObjectValidationException)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are several code analysis warnings for invalid configuration, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;when you specify an exception that does not derive from &lt;code&gt;System.Exception&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;when your exception does not have 1 public constructor that takes an int&lt;/li&gt; &#xA; &lt;li&gt;when the combination of conversions does not match an entry&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;(to run these yourself: &lt;code&gt;dotnet run -c Release --framework net9.0 -- --job short --filter *&lt;/code&gt; in the &lt;code&gt;Vogen.Benchmarks&lt;/code&gt; folder)&lt;/p&gt; &#xA;&lt;p&gt;As mentioned previously, the goal of Vogen is to achieve very similar performance compare to using primitives themselves. Here&#39;s a benchmark comparing the use of a validated value object with underlying type of int vs using an int natively (&lt;em&gt;primitively&lt;/em&gt; ü§ì)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;BenchmarkDotNet=v0.13.2, OS=Windows 11 (10.0.22621.1194)&#xA;AMD Ryzen 9 5950X, 1 CPU, 32 logical and 16 physical cores&#xA;.NET SDK=7.0.102&#xA;  [Host]   : .NET 7.0.2 (7.0.222.60605), X64 RyuJIT AVX2&#xA;  ShortRun : .NET 7.0.2 (7.0.222.60605), X64 RyuJIT AVX2&#xA;Job=ShortRun  IterationCount=3  LaunchCount=1  &#xA;WarmupCount=3    &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Method&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Mean&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Error&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;StdDev&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Ratio&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;RatioSD&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Gen0&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Allocated&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;UsingIntNatively&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;14.55 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.443 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.079 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.00&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.00&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;UsingValueObjectStruct&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;14.88 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3.639 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.199 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.02&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.02&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;There is no discernible difference between using a native int and a VO struct; both are pretty much the same in terms of speed and memory.&lt;/p&gt; &#xA;&lt;p&gt;The next most common scenario is using a VO class to represent a native &lt;code&gt;String&lt;/code&gt;. These results are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;BenchmarkDotNet=v0.13.2, OS=Windows 11 (10.0.22621.1194)&#xA;AMD Ryzen 9 5950X, 1 CPU, 32 logical and 16 physical cores&#xA;.NET SDK=7.0.102&#xA;  [Host]   : .NET 7.0.2 (7.0.222.60605), X64 RyuJIT AVX2&#xA;  ShortRun : .NET 7.0.2 (7.0.222.60605), X64 RyuJIT AVX2&#xA;Job=ShortRun  IterationCount=3  LaunchCount=1  &#xA;WarmupCount=3 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th&gt;Mean&lt;/th&gt; &#xA;   &lt;th&gt;Error&lt;/th&gt; &#xA;   &lt;th&gt;StdDev&lt;/th&gt; &#xA;   &lt;th&gt;Ratio&lt;/th&gt; &#xA;   &lt;th&gt;RatioSD&lt;/th&gt; &#xA;   &lt;th&gt;Gen0&lt;/th&gt; &#xA;   &lt;th&gt;Allocated&lt;/th&gt; &#xA;   &lt;th&gt;Alloc Ratio&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UsingStringNatively&lt;/td&gt; &#xA;   &lt;td&gt;151.8 ns&lt;/td&gt; &#xA;   &lt;td&gt;32.19&lt;/td&gt; &#xA;   &lt;td&gt;1.76&lt;/td&gt; &#xA;   &lt;td&gt;1.00&lt;/td&gt; &#xA;   &lt;td&gt;0.00&lt;/td&gt; &#xA;   &lt;td&gt;0.0153&lt;/td&gt; &#xA;   &lt;td&gt;256 B&lt;/td&gt; &#xA;   &lt;td&gt;1.00&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UsingValueObjectAsStruct&lt;/td&gt; &#xA;   &lt;td&gt;184.8 ns&lt;/td&gt; &#xA;   &lt;td&gt;12.19&lt;/td&gt; &#xA;   &lt;td&gt;0.67&lt;/td&gt; &#xA;   &lt;td&gt;1.22&lt;/td&gt; &#xA;   &lt;td&gt;0.02&lt;/td&gt; &#xA;   &lt;td&gt;0.0153&lt;/td&gt; &#xA;   &lt;td&gt;256 B&lt;/td&gt; &#xA;   &lt;td&gt;1.00&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;There is a tiny amount of performance overhead, but these measurements are incredibly small. There is no memory overhead.&lt;/p&gt; &#xA;&lt;h2&gt;Serialisation and type conversion&lt;/h2&gt; &#xA;&lt;p&gt;By default, each VO is decorated with a &lt;code&gt;TypeConverter&lt;/code&gt; and &lt;code&gt;System.Text.Json&lt;/code&gt; (STJ) serializer. There are other converters/serializer for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Newtonsoft.Json (NSJ)&lt;/li&gt; &#xA; &lt;li&gt;Dapper&lt;/li&gt; &#xA; &lt;li&gt;EFCore&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/linq2db/linq2db&#34;&gt;LINQ to DB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;protobuf-net (see the FAQ section below)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;They are controlled by the &lt;code&gt;Conversions&lt;/code&gt; enum. The following has serializers for NSJ and STJ:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject&amp;lt;float&amp;gt;(conversions: Conversions.NewtonsoftJson | Conversions.SystemTextJson)]&#xA;public readonly partial struct Celsius;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want any conversions, then specify &lt;code&gt;Conversions.None&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want your own conversion, then again specify none, and implement them yourself, just like any other type. But be aware that even serializers will get the same compilation errors for &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; when trying to create VOs.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use Dapper, remember to register it - something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;SqlMapper.AddTypeHandler(new Customer.DapperTypeHandler());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the examples folder for more information.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;What follows is an excerpt from the &lt;a href=&#34;https://stevedunn.github.io/Vogen/faq.html&#34;&gt;full FAQ page in the Wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Is there a Wiki for this project?&lt;/h3&gt; &#xA;&lt;p&gt;Yes, it&#39;s here: &lt;a href=&#34;https://stevedunn.github.io/Vogen/vogen.html&#34;&gt;https://stevedunn.github.io/Vogen/vogen.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;What versions of .NET are supported?&lt;/h3&gt; &#xA;&lt;p&gt;The source generator is .NET Standard 2.0. The code it generates supports all C# language versions from 6.0 and onwards&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re using the generator in a .NET Framework project and using the old style projects (the one before the &#39;SDK style&#39; projects), then you&#39;ll need to do a few things differently:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;add the reference using &lt;code&gt;PackageReference&lt;/code&gt; in the .csproj file:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;ItemGroup&amp;gt;&#xA;  &amp;lt;PackageReference Include=&#34;Vogen&#34; &#xA;                    Version=&#34;[LATEST_VERSION_HERE - E.G. 1.0.18]&#34; &#xA;                    PrivateAssets=&#34;all&#34; /&amp;gt;&#xA;&amp;lt;/ItemGroup&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;set the language version to &lt;code&gt;latest&lt;/code&gt; (or anything &lt;code&gt;8&lt;/code&gt; or more):&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;PropertyGroup&amp;gt;&#xA;‚û°Ô∏è&amp;lt;LangVersion&amp;gt;latest&amp;lt;/LangVersion&amp;gt;&#xA;  &amp;lt;Configuration Condition=&#34; &#39;$(Configuration)&#39; == &#39;&#39; &#34;&amp;gt;Debug&amp;lt;/Configuration&amp;gt;&#xA;&amp;lt;/PropertyGroup&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Why are they called &#39;value objects&#39;?&lt;/h3&gt; &#xA;&lt;p&gt;The term value object represents a small object who&#39;s equality is based on value and not identity. From &lt;a href=&#34;https://en.wikipedia.org/wiki/Value_object&#34;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;In computer science, a value object is a small object that represents a simple entity whose equality is not based on identity: i.e. two value objects are equal when they have the same value, not necessarily being the same object.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In DDD, a value object is (again, from &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks&#34;&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;... a value object is an immutable object that contains attributes but has no conceptual identity&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Why can&#39;t I just use &lt;code&gt;public record struct CustomerId(int Value);&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;That doesn&#39;t give you validation. To validate &lt;code&gt;Value&lt;/code&gt;, you can&#39;t use the shorthand syntax (Primary Constructor). So you&#39;d need to do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public record struct CustomerId&#xA;{&#xA;    public CustomerId(int value) {&#xA;        if(value &amp;lt;=0) throw new Exception(...)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might also provide other constructors which might not validate the data, thereby &lt;em&gt;allowing invalid data into your domain&lt;/em&gt;. Those other constructors might not throw exception, or might throw different exceptions. One of the opinions in Vogen is that any invalid data given to a value object throws a &lt;code&gt;ValueObjectValidationException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You could also use &lt;code&gt;default(CustomerId)&lt;/code&gt; to evade validation. In Vogen, there are analysers that catch this and fail the build, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// error VOG009: Type &#39;CustomerId&#39; cannot be constructed with default as it is prohibited.&#xA;CustomerId c = default;&#xA;&#xA;// error VOG009: Type &#39;CustomerId&#39; cannot be constructed with default as it is prohibited.&#xA;var c2 = default(CustomerId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Can I serialize and deserialize them?&lt;/h3&gt; &#xA;&lt;p&gt;Yes. By default, each VO is decorated with a &lt;code&gt;TypeConverter&lt;/code&gt; and &lt;code&gt;System.Text.Json&lt;/code&gt; (STJ) serializer. There are other converters/serializers for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Newtonsoft.Json (NSJ)&lt;/li&gt; &#xA; &lt;li&gt;Dapper&lt;/li&gt; &#xA; &lt;li&gt;EFCore&lt;/li&gt; &#xA; &lt;li&gt;LINQ to DB&lt;/li&gt; &#xA; &lt;li&gt;MongoDB/BSON&lt;/li&gt; &#xA; &lt;li&gt;Orleans&lt;/li&gt; &#xA; &lt;li&gt;ServiceStack.Text&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Can I use them in EFCore?&lt;/h3&gt; &#xA;&lt;p&gt;Yes, although there are certain considerations. &lt;a href=&#34;https://stevedunn.github.io/Vogen/efcoreintegrationhowto.html&#34;&gt;Please see the EFCore page on the Wiki&lt;/a&gt; (and some other &lt;a href=&#34;https://stevedunn.github.io/Vogen/efcore-tips.html&#34;&gt;EFCore tips&lt;/a&gt;), but the TL;DR is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You need a conversion to be generated, e.g. &lt;code&gt;[ValueObject&amp;lt;string&amp;gt;(conversions: Conversions.EfCoreValueConverter)]&lt;/code&gt; and you need to tell EFCore to use that converter in the &lt;code&gt;OnModelCreating&lt;/code&gt; method, e.g.:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;builder.Entity&amp;lt;SomeEntity&amp;gt;(b =&amp;gt;&#xA;{&#xA;    b.Property(e =&amp;gt; e.Name).HasConversion(new Name.EfCoreValueConverter());&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;It seems like a lot of overhead; I can validate the value myself when I use it!&lt;/h3&gt; &#xA;&lt;p&gt;You could, but to ensure consistency throughout your domain, you&#39;d have to &lt;strong&gt;validate everywhere&lt;/strong&gt;. And Shallow&#39;s Law says that that&#39;s not possible:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚öñÔ∏è &lt;strong&gt;Shalloway&#39;s Law&lt;/strong&gt; &lt;em&gt;&#34;when N things need to change and N &amp;gt; 1, Shalloway will find at most N - 1 of these things.&#34;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Concretely: &lt;em&gt;&#34;When 5 things need to change, Shalloway will find at most, 4 of these things.&#34;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;If my VO is a &lt;code&gt;struct&lt;/code&gt;, can I prohibit the use of &lt;code&gt;CustomerId customerId = default(CustomerId);&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Yes&lt;/strong&gt;. The analyzer generates a compilation error.&lt;/p&gt; &#xA;&lt;h3&gt;If my VO is a &lt;code&gt;struct&lt;/code&gt;, can I prohibit the use of &lt;code&gt;CustomerId customerId = new(CustomerId);&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Yes&lt;/strong&gt;. The analyzer generates a compilation error.&lt;/p&gt; &#xA;&lt;h3&gt;If my VO is a struct, can I have my own constructor?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;No&lt;/strong&gt;. The parameter-less constructor is generated automatically, and the constructor that takes the underlying value is also generated automatically.&lt;/p&gt; &#xA;&lt;p&gt;If you add further constructors, then you will get a compilation error from the code generator, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject&amp;lt;int&amp;gt;)]&#xA;public partial struct CustomerId {&#xA;    // Vogen already generates this as a private constructor:&#xA;    // error CS0111: Type &#39;CustomerId&#39; already defines a member called &#39;CustomerId&#39; with the same parameter type&#xA;    public CustomerId() { }&#xA;&#xA;    // error VOG008: Cannot have user defined constructors, please use the From method for creation.&#xA;    public CustomerId(int value) { }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;If my VO is a struct, can I have my own fields?&lt;/h3&gt; &#xA;&lt;p&gt;You &lt;em&gt;could&lt;/em&gt;, but you&#39;d get compiler warning &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0282&#34;&gt;CS0282-There is no defined ordering between fields in multiple declarations of partial class or struct &#39;type&#39;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Can I normalize the value when a VO is created?&lt;/h3&gt; &#xA;&lt;p&gt;I&#39;d like normalize/sanitize the values used, for example, trimming the input. Is this possible?&lt;/p&gt; &#xA;&lt;p&gt;Yes, add NormalizeInput method, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;    private static string NormalizeInput(string input) =&amp;gt; input.Trim();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://stevedunn.github.io/Vogen/normalizationhowto.html&#34;&gt;wiki&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Why isn&#39;t this concept part of the C# language?&lt;/h3&gt; &#xA;&lt;p&gt;It would be great if it was, but it&#39;s not currently. I &lt;a href=&#34;https://dunnhq.com/posts/2022/non-defaultable-value-types/&#34;&gt;wrote an article about it&lt;/a&gt;, but in summary, there is a &lt;a href=&#34;https://github.com/dotnet/csharplang/issues/146&#34;&gt;long-standing language proposal&lt;/a&gt; focusing on non-defaultable value types. Having non-defaultable value types is a great first step, but it would also be handy to have something in the language to enforce validate. So I added a &lt;a href=&#34;https://github.com/dotnet/csharplang/discussions/5574&#34;&gt;language proposal for invariant records&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;One of the responses in the proposal says that the language team decided that validation policies should not be part of C#, but provided by source generators.&lt;/p&gt; &#xA;&lt;h3&gt;What alternatives are there?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/andrewlock/StronglyTypedId&#34;&gt;StronglyTypedId&lt;/a&gt; This is focused more on IDs. Vogen is focused more of &#39;Domain Concepts&#39; and the constraints associated with those concepts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/stevedunn/stringlytyped&#34;&gt;StringlyTyped&lt;/a&gt; This is my first attempt and is NON source-generated. There is memory overhead because the base type is a class. There are also no analyzers. It is now marked as deprecated in favor of Vogen.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mcintyre321/ValueOf&#34;&gt;ValueOf&lt;/a&gt; Similar to StringlyTyped - non source-generated and no analysers. This is also more relaxed and allows composite &#39;underlying&#39; types.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/RyotaMurohoshi/ValueObjectGenerator&#34;&gt;ValueObjectGenerator&lt;/a&gt; Similar to Vogen, but less focused on validation and no code analyzer.&lt;/p&gt; &#xA;&lt;h3&gt;What primitive types are supported?&lt;/h3&gt; &#xA;&lt;p&gt;Any type can be wrapped. Serialisation and type conversions have implementations for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;string&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;int&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;long&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;short&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;byte&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;float (Single)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;decimal&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;double&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;DateTime&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;DateOnly&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;TimeOnly&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;DateTimeOffset&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Guid&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bool&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For other types, a generic type conversion and serializer is applied. If you are supplying your own converters for type conversion and serialization, then specify &lt;code&gt;None&lt;/code&gt; for converters and decorate your type with attributes for your own types, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject&amp;lt;SpecialPrimitive&amp;gt;(conversions: Conversions.None)]&#xA;[System.Text.Json.Serialization.JsonConverter(typeof(SpecialPrimitiveJsonConverter))]&#xA;[System.ComponentModel.TypeConverter(typeof(SpecialPrimitiveTypeConverter))]&#xA;public partial struct SpecialMeasurement;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Can I get it to throw my own exception?&lt;/h3&gt; &#xA;&lt;p&gt;Yes, by specifying the exception type in either the &lt;code&gt;ValueObject&lt;/code&gt; attribute, or globally, with &lt;code&gt;VogenConfiguration&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;I get an error from Linq2DB when I use a ValueObject that wraps a &lt;code&gt;TimeOnly&lt;/code&gt; saying that &lt;code&gt;DateTime&lt;/code&gt; cannot be converted to &lt;code&gt;TimeOnly&lt;/code&gt; - what should I do?&lt;/h3&gt; &#xA;&lt;p&gt;Linq2DB 4.0 or greater supports &lt;code&gt;DateOnly&lt;/code&gt; and &lt;code&gt;TimeOnly&lt;/code&gt;. Vogen generates value converters for Linq2DB; for &lt;code&gt;DateOnly&lt;/code&gt;, it just works, but for `TimeOnly, you need to add this to your application:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MappingSchema.Default.SetConverter&amp;lt;DateTime, TimeOnly&amp;gt;(dt =&amp;gt; TimeOnly.FromDateTime(dt));&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Can I use protobuf-net?&lt;/h3&gt; &#xA;&lt;p&gt;Yes. Add a dependency to protobuf-net and set a surrogate attribute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ValueObject&amp;lt;string&amp;gt;]&#xA;[ProtoContract(Surrogate = typeof(string))]&#xA;public partial class BoxId {&#xA;//...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;BoxId type now will be serialized as a string in all messages/grpc calls. If one is generating .proto files for other applications from C# code, proto files will include Surrogate type as the type. &lt;em&gt;thank you to &lt;a href=&#34;https://github.com/DomasM&#34;&gt;@DomasM&lt;/a&gt; for this information&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to all the people who have contributed!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/stevedunn/vogen/graphs/contributors&#34;&gt;&lt;img src=&#34;https://contributors-img.web.app/image?repo=stevedunn/vogen&#34; alt=&#34;contributors&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Attribution&lt;/h2&gt; &#xA;&lt;p&gt;I took a lot of inspiration from &lt;a href=&#34;https://github.com/andrewlock&#34;&gt;Andrew Lock&#39;s&lt;/a&gt; &lt;a href=&#34;https://github.com/andrewlock/StronglyTypedId&#34;&gt;StronglyTypedId&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;I also got some great ideas from &lt;a href=&#34;https://github.com/meziantou&#34;&gt;G√©rald Barr√©&#39;s&lt;/a&gt; &lt;a href=&#34;https://github.com/meziantou/Meziantou.Analyzer&#34;&gt;Meziantou.Analyzer&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>