<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-09T01:27:08Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bezzad/Downloader</title>
    <updated>2023-12-09T01:27:08Z</updated>
    <id>tag:github.com,2023-12-09:/bezzad/Downloader</id>
    <link href="https://github.com/bezzad/Downloader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast, cross-platform and reliable multipart downloader with asynchronous progress events for .NET applications.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/bezzad/Downloader/actions/workflows/dotnet-windows.yml&#34;&gt;&lt;img src=&#34;https://github.com/bezzad/Downloader/workflows/Windows%20x64/badge.svg?sanitize=true&#34; alt=&#34;Windows x64&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bezzad/Downloader/actions/workflows/dotnet-ubuntu.yml&#34;&gt;&lt;img src=&#34;https://github.com/bezzad/Downloader/workflows/Ubuntu%20x64/badge.svg?sanitize=true&#34; alt=&#34;Ubuntu x64&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/bezzad/downloader&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/github/bezzad/downloader?branch=master&amp;amp;svg=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/bezzad/downloader&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/bezzad/downloader/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/downloader&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/downloader.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/downloader&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/downloader.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codefactor.io/repository/github/bezzad/downloader/overview/master&#34;&gt;&lt;img src=&#34;https://www.codefactor.io/repository/github/bezzad/downloader/badge/master&#34; alt=&#34;CodeFactor&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codacy.com/gh/bezzad/Downloader/dashboard?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=bezzad/Downloader&amp;amp;utm_campaign=Badge_Grade&#34;&gt;&lt;img src=&#34;https://app.codacy.com/project/badge/Grade/f7cd6e24f75c45c28e5e6fab2ef8d219&#34; alt=&#34;Codacy Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bezzad/downloader/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/bezzad/downloader.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bezzad/Downloader&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/support-.Net_Framework-blue.svg?sanitize=true&#34; alt=&#34;Generic badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bezzad/Downloader&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/support-.Net_Core-blue.svg?sanitize=true&#34; alt=&#34;Generic badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bezzad/Downloader&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/support-.Net_Standard-blue.svg?sanitize=true&#34; alt=&#34;Generic badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Downloader&lt;/h1&gt; &#xA;&lt;p&gt;&lt;span&gt;🚀&lt;/span&gt; Fast, cross-platform and reliable multipart downloader with &lt;strong&gt;.Net Core&lt;/strong&gt; supporting &lt;span&gt;🚀&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;Downloader is a modern, fluent, asynchronous, testable and portable library for .NET. This is a multipart downloader with asynchronous progress events. This library can added in your &lt;code&gt;.Net Core v2&lt;/code&gt; and later or &lt;code&gt;.Net Framework v4.5&lt;/code&gt; or later projects.&lt;/p&gt; &#xA;&lt;p&gt;Downloader is compatible with .NET Standard 2.0 and above, running on Windows, Linux, and macOS, in full .NET Framework or .NET Core.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For a complete example see &lt;a href=&#34;https://github.com/bezzad/Downloader/raw/master/src/Samples/Downloader.Sample/Program.cs&#34;&gt;Downloader.Sample&lt;/a&gt; project from this repository.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Sample Console Application&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/bezzad/Downloader/raw/master/sample.gif&#34; alt=&#34;sample-project&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Features at a glance&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple interface to make download request.&lt;/li&gt; &#xA; &lt;li&gt;Download files async and non-blocking.&lt;/li&gt; &#xA; &lt;li&gt;Download any type of files like image, video, pdf, apk and etc.&lt;/li&gt; &#xA; &lt;li&gt;Cross-platform library to download any files with any size.&lt;/li&gt; &#xA; &lt;li&gt;Get real-time progress info of each block.&lt;/li&gt; &#xA; &lt;li&gt;Download file multipart as parallel.&lt;/li&gt; &#xA; &lt;li&gt;Handle all the client-side and server-side exceptions non-stopping.&lt;/li&gt; &#xA; &lt;li&gt;Config your &lt;code&gt;ChunkCount&lt;/code&gt; to define the parts count of the download file.&lt;/li&gt; &#xA; &lt;li&gt;Download file multipart as &lt;code&gt;in-memory&lt;/code&gt; or &lt;code&gt;on-disk&lt;/code&gt; mode.&lt;/li&gt; &#xA; &lt;li&gt;Chunks are saved in parallel on the final file and not on the temp files.&lt;/li&gt; &#xA; &lt;li&gt;The file size is pre-allocated before the download starts.&lt;/li&gt; &#xA; &lt;li&gt;Store download package object to resume the download when you want.&lt;/li&gt; &#xA; &lt;li&gt;Get download speed or progress percentage in each progress event.&lt;/li&gt; &#xA; &lt;li&gt;Get download progress events per chunk downloads.&lt;/li&gt; &#xA; &lt;li&gt;Fast Pause and Resume downloads asynchronously.&lt;/li&gt; &#xA; &lt;li&gt;Stop and Resume downloads whenever you want with the package object.&lt;/li&gt; &#xA; &lt;li&gt;Supports large file download.&lt;/li&gt; &#xA; &lt;li&gt;Set a dynamic speed limit on downloads (changeable speed limitation on the go).&lt;/li&gt; &#xA; &lt;li&gt;Download files without storing on disk and get a memory stream for each downloaded file.&lt;/li&gt; &#xA; &lt;li&gt;Serializable download package (to/from &lt;code&gt;JSON&lt;/code&gt; or &lt;code&gt;Binary&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Live streaming support, suitable for playing music at the same time as downloading.&lt;/li&gt; &#xA; &lt;li&gt;Ability to download just a certain range of bytes of a large file.&lt;/li&gt; &#xA; &lt;li&gt;Code is tiny, fast and does not depend on external libraries.&lt;/li&gt; &#xA; &lt;li&gt;Control the amount of system memroy (RAM) that the Downloader consumes during downloading.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Installing via &lt;a href=&#34;https://www.nuget.org/packages/Downloader&#34;&gt;NuGet&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package Downloader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing via the .NET Core command line interface&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet add package Downloader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;How to use&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Step 1&lt;/strong&gt;: Create your custom configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Simple Configuration&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var downloadOpt = new DownloadConfiguration()&#xA;{&#xA;    ChunkCount = 8, // file parts to download, default value is 1&#xA;    ParallelDownload = true // download parts of file as parallel or not. Default value is false&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Complex Configuration&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;em&gt;Do not use all of the below options in your applications, just add which one you need.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var downloadOpt = new DownloadConfiguration()&#xA;{&#xA;    // usually, hosts support max to 8000 bytes, default values is 8000&#xA;    BufferBlockSize = 10240,&#xA;    // file parts to download, default value is 1&#xA;    ChunkCount = 8,             &#xA;    // download speed limited to 2MB/s, default values is zero or unlimited&#xA;    MaximumBytesPerSecond = 1024*1024*2, &#xA;    // the maximum number of times to fail&#xA;    MaxTryAgainOnFailover = 5,    &#xA;    // release memory buffer after each 50 MB&#xA;    MaximumMemoryBufferBytes = 1024 * 1024 * 50, &#xA;    // download parts of file as parallel or not. Default value is false&#xA;    ParallelDownload = true,&#xA;    // number of parallel downloads. The default value is the same as the chunk count&#xA;    ParallelCount = 4,    &#xA;    // timeout (millisecond) per stream block reader, default values is 1000&#xA;    Timeout = 1000,      &#xA;    // set true if you want to download just a specific range of bytes of a large file&#xA;    RangeDownload = false,&#xA;    // floor offset of download range of a large file&#xA;    RangeLow = 0,&#xA;    // ceiling offset of download range of a large file&#xA;    RangeHigh = 0, &#xA;    // clear package chunks data when download completed with failure, default value is false&#xA;    ClearPackageOnCompletionWithFailure = true, &#xA;    // minimum size of chunking to download a file in multiple parts, default value is 512&#xA;    MinimumSizeOfChunking = 1024, &#xA;    // Before starting the download, reserve the storage space of the file as file size, default value is false&#xA;    ReserveStorageSpaceBeforeStartingDownload = true; &#xA;    // config and customize request headers&#xA;    RequestConfiguration = &#xA;    {        &#xA;        Accept = &#34;*/*&#34;,&#xA;        CookieContainer = cookies,&#xA;        Headers = new WebHeaderCollection(), // { your custom headers }&#xA;        KeepAlive = true, // default value is false&#xA;        ProtocolVersion = HttpVersion.Version11, // default value is HTTP 1.1&#xA;        UseDefaultCredentials = false,&#xA;        // your custom user agent or your_app_name/app_version.&#xA;        UserAgent = &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&#34;,&#xA;        Proxy = new WebProxy() {&#xA;           Address = new Uri(&#34;http://YourProxyServer/proxy.pac&#34;),&#xA;           UseDefaultCredentials = false,&#xA;           Credentials = System.Net.CredentialCache.DefaultNetworkCredentials,&#xA;           BypassProxyOnLocal = true&#xA;        }&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Step 2&lt;/strong&gt;: Create download service instance per download and pass your config&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var downloader = new DownloadService(downloadOpt);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Step 3&lt;/strong&gt;: Handle download events&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Provide `FileName` and `TotalBytesToReceive` at the start of each downloads&#xA;downloader.DownloadStarted += OnDownloadStarted;&#xA;&#xA;// Provide any information about chunker downloads, &#xA;// like progress percentage per chunk, speed, &#xA;// total received bytes and received bytes array to live streaming.&#xA;downloader.ChunkDownloadProgressChanged += OnChunkDownloadProgressChanged;&#xA;&#xA;// Provide any information about download progress, &#xA;// like progress percentage of sum of chunks, total speed, &#xA;// average speed, total received bytes and received bytes array &#xA;// to live streaming.&#xA;downloader.DownloadProgressChanged += OnDownloadProgressChanged;&#xA;&#xA;// Download completed event that can include occurred errors or &#xA;// cancelled or download completed successfully.&#xA;downloader.DownloadFileCompleted += OnDownloadFileCompleted;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Step 4&lt;/strong&gt;: Start the download with the url and file name&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;string file = @&#34;Your_Path\fileName.zip&#34;;&#xA;string url = @&#34;https://file-examples.com/fileName.zip&#34;;&#xA;await downloader.DownloadFileTaskAsync(url, file);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Step 4b&lt;/strong&gt;: Start the download without file name&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;DirectoryInfo path = new DirectoryInfo(&#34;Your_Path&#34;);&#xA;string url = @&#34;https://file-examples.com/fileName.zip&#34;;&#xA;// download into &#34;Your_Path\fileName.zip&#34;&#xA;await downloader.DownloadFileTaskAsync(url, path); &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Step 4c&lt;/strong&gt;: Download in MemoryStream&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// After download completion, it gets a MemoryStream&#xA;Stream destinationStream = await downloader.DownloadFileTaskAsync(url); &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;How to &lt;strong&gt;pause&lt;/strong&gt; and &lt;strong&gt;resume&lt;/strong&gt; downloads quickly&lt;/h2&gt; &#xA;&lt;p&gt;When you want to resume a download quickly after pausing a few seconds. You can call the &lt;code&gt;Pause&lt;/code&gt; function of the downloader service. This way, streams stay alive and are only suspended by a locker to be released and resumed whenever you want.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Pause the download&#xA;DownloadService.Pause();&#xA;&#xA;// Resume the download&#xA;DownloadService.Resume();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;How to &lt;strong&gt;stop&lt;/strong&gt; and &lt;strong&gt;resume&lt;/strong&gt; downloads other time&lt;/h2&gt; &#xA;&lt;p&gt;The ‍&lt;code&gt;DownloadService&lt;/code&gt; class has a property called &lt;code&gt;Package&lt;/code&gt; that stores each step of the download. To stopping the download you must call the &lt;code&gt;CancelAsync&lt;/code&gt; method. Now, if you want to continue again, you must call the same &lt;code&gt;DownloadFileTaskAsync&lt;/code&gt; function with the &lt;code&gt;Package&lt;/code&gt; parameter to resume your download. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// At first, keep and store the Package file to resume &#xA;// your download from the last download position:&#xA;DownloadPackage pack = downloader.Package;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Stop or cancel download:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// This function breaks your stream and cancels progress.&#xA;downloader.CancelAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Resuming download after cancelation:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await downloader.DownloadFileTaskAsync(pack);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So that you can even save your large downloads with a very small amount in the Package and after restarting the program, restore it again and start continuing your download. The packages are your snapshot of the download instance. Only the downloaded file addresses will be included in the package and you can resume it whenever you want. For more detail see &lt;a href=&#34;https://github.com/bezzad/Downloader/raw/master/src/Downloader.Test/IntegrationTests/DownloadIntegrationTest.cs#L115&#34;&gt;StopResumeDownloadTest&lt;/a&gt; method&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Sometimes a server does not support downloading in a specific range. That time, we can&#39;t resume downloads after canceling. So, the downloader starts from the beginning.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Fluent download builder usage&lt;/h2&gt; &#xA;&lt;p&gt;For easy and fluent use of the downloader, you can use the &lt;code&gt;DownloadBuilder&lt;/code&gt; class. Consider the following examples:&lt;/p&gt; &#xA;&lt;p&gt;Simple usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await DownloadBuilder.New()&#xA;    .WithUrl(@&#34;https://host.com/test-file.zip&#34;)&#xA;    .WithDirectory(@&#34;C:\temp&#34;)&#xA;    .Build()&#xA;    .StartAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Complex usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;IDownload download = DownloadBuilder.New()&#xA;    .WithUrl(@&#34;https://host.com/test-file.zip&#34;)&#xA;    .WithDirectory(@&#34;C:\temp&#34;)&#xA;    .WithFileName(&#34;test-file.zip&#34;)&#xA;    .WithConfiguration(new DownloadConfiguration())&#xA;    .Build();&#xA;&#xA;download.DownloadProgressChanged += DownloadProgressChanged;&#xA;download.DownloadFileCompleted += DownloadFileCompleted;&#xA;download.DownloadStarted += DownloadStarted;&#xA;download.ChunkDownloadProgressChanged += ChunkDownloadProgressChanged;&#xA;&#xA;await download.StartAsync();&#xA;&#xA;download.Stop(); // cancel current download&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Resume the existing download package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await DownloadBuilder.Build(package).StartAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Resume the existing download package with a new configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await DownloadBuilder.Build(package, config).StartAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bezzad/Downloader/raw/master/src/Downloader.Test/UnitTests/DownloadBuilderTest.cs#L110&#34;&gt;Pause and Resume quickly&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var download = DownloadBuilder.New()&#xA;     .Build()&#xA;     .WithUrl(url)&#xA;     .WithFileLocation(path);&#xA;await download.StartAsync();&#xA;&#xA;download.Pause(); // pause current download quickly&#xA;&#xA;download.Resume(); // continue current download quickly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;When does Downloader fail to download in multiple chunks?&lt;/h2&gt; &#xA;&lt;h3&gt;Content-Length:&lt;/h3&gt; &#xA;&lt;p&gt;If your URL server does not provide the file size in the response header (&lt;code&gt;Content-Length&lt;/code&gt;). The Downloader cannot split the file into multiple parts and continues its work with one chunk.&lt;/p&gt; &#xA;&lt;h3&gt;Accept-Ranges:&lt;/h3&gt; &#xA;&lt;p&gt;If the server return &lt;code&gt;Accept-Ranges: none&lt;/code&gt; in the responses header then that means the server does not support download in range and the Downloader cannot use multiple chunking and continues its work with one chunk.&lt;/p&gt; &#xA;&lt;h3&gt;Content-Range:&lt;/h3&gt; &#xA;&lt;p&gt;At first, the Downloader sends a GET request to the server to fetch the file&#39;s size in the range. If the server does not provide &lt;code&gt;Content-Range&lt;/code&gt; in the header then that means the server does not support download in range. Therefore, the Downloader has to continue its work with one chunk.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;How to serialize and deserialize downloader package&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;strong&gt;What is Serialization?&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Serialization is the process of converting an object&#39;s state into information that can be stored for later retrieval or that can be sent to another system. For example, you may have an object that represents a document that you wish to save. This object could be serialized to a stream of binary information and stored as a file on disk. Later the binary data can be retrieved from the file and deserialized into objects that are exact copies of the original information. As a second example, you may have an object containing the details of a transaction that you wish to send to a non-.NET system. This information could be serialised to XML before being transmitted. The receiving system would convert the XML into a format that it could understand.&lt;/p&gt; &#xA;&lt;p&gt;In this section, we want to show how to serialize download packages to &lt;code&gt;JSON&lt;/code&gt; text or &lt;code&gt;Binary&lt;/code&gt;, after stopping download to keep download data and resuming that every time you want. You can serialize packages even using memory storage for caching download data which is used &lt;code&gt;MemoryStream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;JSON Serialization&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Serializing the package to &lt;a href=&#34;https://www.newtonsoft.com&#34;&gt;&lt;code&gt;JSON&lt;/code&gt;&lt;/a&gt; is very simple like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var packageJson = JsonConvert.SerializeObject(package);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Deserializing into the new package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var newPack = JsonConvert.DeserializeObject&amp;lt;DownloadPackage&amp;gt;(packageJson);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more detail see &lt;a href=&#34;https://github.com/bezzad/Downloader/raw/46167082b8de99d8e6ad21329c3a32a6e26cfd3e/src/Downloader.Test/DownloadPackageTest.cs#L34&#34;&gt;PackageSerializationTest&lt;/a&gt; method&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Binary Serialization&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;To serialize or deserialize the package into a binary file, first you need serialize to JSON and next save it with &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/system.io.binarywriter&#34;&gt;BinaryWriter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter&#34;&gt;BinaryFormatter&lt;/a&gt; type is dangerous and is not recommended for data processing. Applications should stop using &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter&#34;&gt;BinaryFormatter&lt;/a&gt; as soon as possible, even if they believe the data they&#39;re processing to be trustworthy. &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter&#34;&gt;BinaryFormatter&lt;/a&gt; is insecure and can&#39;t be made secure. So, &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter&#34;&gt;BinaryFormatter&lt;/a&gt; is deprecated and we can no longer support it. &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide&#34;&gt;Reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Instructions for Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Welcome to contribute, feel free to change and open a &lt;a href=&#34;http://help.github.com/pull-requests/&#34;&gt;&lt;strong&gt;PullRequest&lt;/strong&gt;&lt;/a&gt; to develop branch. You can use either the latest version of Visual Studio or Visual Studio Code and .NET CLI for Windows, Mac and Linux.&lt;/p&gt; &#xA;&lt;p&gt;For GitHub workflow, check out our Git workflow below this paragraph. We are following the excellent GitHub Flow process, and would like to make sure you have all of the information needed to be a world-class contributor!&lt;/p&gt; &#xA;&lt;h2&gt;Git Workflow&lt;/h2&gt; &#xA;&lt;p&gt;The general process for working with Downloader is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://help.github.com/forking/&#34;&gt;Fork&lt;/a&gt; on GitHub&lt;/li&gt; &#xA; &lt;li&gt;Make sure your line endings are correctly configured and fix your line endings!&lt;/li&gt; &#xA; &lt;li&gt;Clone your fork locally&lt;/li&gt; &#xA; &lt;li&gt;Configure the upstream repo (&lt;code&gt;git remote add upstream git://github.com/bezzad/downloader&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Switch to the latest development branch (eg vX.Y.Z, using &lt;code&gt;git checkout vX.Y.Z&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create a local branch from that (&lt;code&gt;git checkout -b myBranch&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Work on your feature&lt;/li&gt; &#xA; &lt;li&gt;Rebase if required&lt;/li&gt; &#xA; &lt;li&gt;Push the branch up to GitHub (&lt;code&gt;git push origin myBranch&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Send a Pull Request on GitHub - the PR should target (have as base branch) the latest development branch (eg &lt;code&gt;vX.Y.Z&lt;/code&gt;) rather than &lt;code&gt;master&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We accept pull requests from the community. But, you should &lt;strong&gt;never&lt;/strong&gt; work on a clone of master, and you should &lt;strong&gt;never&lt;/strong&gt; send a pull request from master - always from a branch. Please be sure to branch from the head of the latest vX.Y.Z &lt;code&gt;develop&lt;/code&gt; branch (rather than &lt;code&gt;master&lt;/code&gt;) when developing contributions.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Licensed under the terms of the &lt;a href=&#34;https://raw.githubusercontent.com/bezzad/Downloader/master/LICENSE&#34;&gt;MIT License&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.fossa.com/projects/git%2Bgithub.com%2Fbezzad%2FDownloader?ref=badge_large&#34;&gt;&lt;img src=&#34;https://app.fossa.com/api/projects/git%2Bgithub.com%2Fbezzad%2FDownloader.svg?type=large&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;Thanks go to these wonderful people (List made with &lt;a href=&#34;https://contrib.rocks&#34;&gt;contrib.rocks&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;a href=&#34;https://github.com/bezzad/downloader/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=bezzad/downloader&#34;&gt; &lt;/a&gt;</summary>
  </entry>
</feed>