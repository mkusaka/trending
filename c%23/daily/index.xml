<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-10T01:35:30Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>XINCGer/Unity3DTraining</title>
    <updated>2022-06-10T01:35:30Z</updated>
    <id>tag:github.com,2022-06-10:/XINCGer/Unity3DTraining</id>
    <link href="https://github.com/XINCGer/Unity3DTraining" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unity的练习项目&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Unity3D--Training&lt;/h1&gt; &#xA;&lt;p&gt;【Unity杂货铺】unity大杂烩~&lt;br&gt; 本项目由&lt;a href=&#34;https://www.jetbrains.com/?from=Unity3DTraining&#34;&gt;JetBranins&lt;/a&gt;赞助相关开发工具&lt;br&gt; &lt;a href=&#34;https://www.jetbrains.com/?from=Unity3DTraining&#34;&gt;&lt;img src=&#34;https://github.com/XINCGer/Unity3DTraining/raw/master/Doc/images/jetbrains.png&#34; width=&#34;150&#34; height=&#34;150&#34; div align=&#34;center&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;目录&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/3rdPlugins&#34;&gt;1.收集整理一些第三方库和插件&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/3DMoonRunner&#34;&gt;2.月光跑酷3D版&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/Notification&#34;&gt;3.Android和iOS端的消息推送&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/NetWorkAndResources&#34;&gt;4.网络与资源数据操作&lt;/a&gt; &amp;nbsp;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/OverCallControl/&#34;&gt;5.unity开发项目整体把控规划与管理&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/Pathfinding&#34;&gt;6.寻路相关&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/SpaceShooter&#34;&gt;7.太空大战&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/UGUITraining&#34;&gt;8.UGUI相关&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/ARTraining&#34;&gt;9.AR小DEMO&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/PhysicsStudy&#34;&gt;10.游戏中的物理研究&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/Doc&#34;&gt;11.一些文档&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/SomeTest&#34;&gt;12.一些小测试&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/DoTweenTraining&#34;&gt;13.DoTween插件练习&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/Engine&#34;&gt;14.引擎研究&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/BezierTest&#34;&gt;15.贝塞尔曲线研究&lt;/a&gt; &amp;nbsp;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/FURIOUS_MOTORSPORT&#34;&gt;16.激情飞车&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/Minecraft&#34;&gt;17.仿写《我的世界》&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/UnityEditorExtension&#34;&gt;18.Unity编辑器拓展&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/ECS&#34;&gt;19.ESC实体组件系统&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/Unit4Unity&#34;&gt;20.单元测试的艺术&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/Effective%20C%23&#34;&gt;21.Effective C# U3D高效C#技法训练&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/I18N_Localization&#34;&gt;22.I18N 国际化（本地化）&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/MemoryPool_ObjectPool&#34;&gt;23.内存池和对象池&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/DesignPatterns&#34;&gt;24.Unity游戏开发之常用设计模式&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/Fruit_Ninja&#34;&gt;25.切水果游戏&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/SDK&#34;&gt;26.SDK接入研究&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/ToolKits&#34;&gt;27.工具类&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/PerformanceOptimization&#34;&gt;28.性能优化相关&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/ColaFrameWork&#34;&gt;29.自研客户端架构&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/egametang/Egametang&#34;&gt;30.【外链】Unity3d客户端与C#分布式服务端游戏框架&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/ProtoBufDemo&#34;&gt;31.ProtoBuf练习&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/AboutCamera&#34;&gt;32.相机管理&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/LearningOpenGL&#34;&gt;33.学习OpenGL与计算机图形学&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/CircusGameOnFC&#34;&gt;34.仿写FC上的马戏团&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/HotUpdate&#34;&gt;35.热更新与AssetBundle专题&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/BubbleShooter&#34;&gt;36.马三毕设-天天萌泡泡&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/XINCGer/Unity3DTraining/tree/master/XlsxTools&#34;&gt;37.转表工具&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/PacMan&#34;&gt;38.仿写FC上的吃豆人&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/AutomationTesting&#34;&gt;39.Unity手游自动化测试探索&lt;/a&gt; &amp;nbsp;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/GuideSystem&#34;&gt;40.新手引导功能&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/TypeScript&#34;&gt;41.TypeScript资料收集&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/MacanimSystem&#34;&gt;42.Macanim动画系统&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/DynamicBones&#34;&gt;43.动力学骨骼研究(仿王者荣耀头发、衣物飘动效果)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/AboutSkill&#34;&gt;44.技能系统相关知识收集 &lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/OpenSourceGame&#34;&gt;45.开源游戏收集整理&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/CutsceneTimeline&#34;&gt;46.剧情动画与Timeline研究&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/2DPlatformer&#34;&gt;47.2D原生平台游戏&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/lua&#34;&gt;48.Lua的相关知识点和总结记录&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/AI&#34;&gt;49.游戏人工智能&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/InputAndTouch&#34;&gt;50.设备输入&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/CI&#34;&gt;51.持续集成CI(Continuous Integration)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/ServerDevlop&#34;&gt;52.电商与后端开发等相关的不错的资料&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/Crack&#34;&gt;53.游戏加密与破解研究&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/xasset_doc&#34;&gt;54.xasset 公开文档收集和整理&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/CPlusPlus&#34;&gt;55.C++ 实用仓库&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/PythonInGame&#34;&gt;56.Python在游戏中的实用库&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/XINCGer/Unity3DTraining/master/AboutJob&#34;&gt;57.求职工作培训与养生等&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;友情链接&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xasset/xasset&#34;&gt;xasset 快速强大的Unity资源系统&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/killop/anything_about_game&#34;&gt;anything_about_game(夜莺人行自走库)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JasonXuDeveloper/JEngine&#34;&gt;JEngine是针对Unity开发者设计的开箱即用的框架，封装了强大的功能，小白也能快速上手，轻松制作可以热更新的游戏&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.jingfengji.tech/&#34;&gt;JingFengJi(静风霁的博客)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://networm.me/&#34;&gt;狂飙的博客&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.lfzxb.top/&#34;&gt;烟雨迷离半世殇&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xin-lover/&#34;&gt;北冥有鱼其名为鲲的博客&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://asuka4every.top/&#34;&gt;ZeaLotSean的博客&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>open-telemetry/opentelemetry-dotnet</title>
    <updated>2022-06-10T01:35:30Z</updated>
    <id>tag:github.com,2022-06-10:/open-telemetry/opentelemetry-dotnet</id>
    <link href="https://github.com/open-telemetry/opentelemetry-dotnet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The OpenTelemetry .NET Client&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OpenTelemetry .NET&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cloud-native.slack.com/archives/C01N3BC2W7Q&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/slack-@cncf/otel/dotnet-brightgreen.svg?logo=slack&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/open-telemetry/opentelemetry-dotnet/&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/open-telemetry/opentelemetry-dotnet/branch/main/graphs/badge.svg?&#34; alt=&#34;codecov.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/profiles/OpenTelemetry&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/OpenTelemetry.svg?sanitize=true&#34; alt=&#34;Nuget&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/profiles/OpenTelemetry&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/OpenTelemetry.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/actions/workflows/linux-ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/actions/workflows/linux-ci.yml/badge.svg?branch=main&#34; alt=&#34;Linux&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/actions/workflows/windows-ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/actions/workflows/windows-ci.yml/badge.svg?branch=main&#34; alt=&#34;Windows&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The .NET &lt;a href=&#34;https://opentelemetry.io/&#34;&gt;OpenTelemetry&lt;/a&gt; client.&lt;/p&gt; &#xA;&lt;h2&gt;Supported .NET Versions&lt;/h2&gt; &#xA;&lt;p&gt;Packages shipped from this repository generally support all the officially supported versions of &lt;a href=&#34;https://dotnet.microsoft.com/download/dotnet&#34;&gt;.NET&lt;/a&gt; and &lt;a href=&#34;https://dotnet.microsoft.com/download/dotnet-framework&#34;&gt;.NET Framework&lt;/a&gt; (an older Windows-based .NET implementation), except &lt;code&gt;.NET Framework 3.5&lt;/code&gt;. Any exceptions to this are noted in the individual &lt;code&gt;README.md&lt;/code&gt; files.&lt;/p&gt; &#xA;&lt;h2&gt;Project Status&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Signal&lt;/th&gt; &#xA;   &lt;th&gt;Status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Logs&lt;/td&gt; &#xA;   &lt;td&gt;Stable*&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Metrics&lt;/td&gt; &#xA;   &lt;td&gt;Stable&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Traces&lt;/td&gt; &#xA;   &lt;td&gt;Stable&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;*While the &lt;code&gt;OpenTelemetryLoggerProvider&lt;/code&gt; (i.e integration with &lt;code&gt;ILogger&lt;/code&gt;) is stable, the &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/tree/main/src/OpenTelemetry.Exporter.OpenTelemetryProtocol#otlp-logs&#34;&gt;OTLP Exporter for Logs&lt;/a&gt; is still non-stable.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;If you are new here, please read the getting started docs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/logs/getting-started/README.md&#34;&gt;logs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/metrics/getting-started/README.md&#34;&gt;metrics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/trace/getting-started/README.md&#34;&gt;traces&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repository includes multiple installable components, available on &lt;a href=&#34;https://www.nuget.org/profiles/OpenTelemetry&#34;&gt;NuGet&lt;/a&gt;. Each component has its individual &lt;code&gt;README.md&lt;/code&gt; file, which covers the instruction on how to install and how to get started. To find all the available components, please take a look at the &lt;code&gt;src&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;Here are the most commonly used components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Api/README.md&#34;&gt;OpenTelemetry .NET API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry/README.md&#34;&gt;OpenTelemetry .NET SDK&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here are the &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-specification/raw/main/specification/glossary.md#instrumentation-library&#34;&gt;instrumentation libraries&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Instrumentation.AspNet/README.md&#34;&gt;ASP.NET&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Instrumentation.AspNetCore/README.md&#34;&gt;ASP.NET Core&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Instrumentation.GrpcNetClient/README.md&#34;&gt;Grpc.Net.Client&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Instrumentation.Http/README.md&#34;&gt;HTTP clients&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Instrumentation.SqlClient/README.md&#34;&gt;SQL client&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here are the &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-specification/raw/main/specification/glossary.md#exporter-library&#34;&gt;exporter libraries&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Exporter.Console/README.md&#34;&gt;Console&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Exporter.InMemory/README.md&#34;&gt;In-memory&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Exporter.Jaeger/README.md&#34;&gt;Jaeger&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Exporter.OpenTelemetryProtocol/README.md&#34;&gt;OTLP&lt;/a&gt; (OpenTelemetry Protocol)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Exporter.Prometheus/README.md&#34;&gt;Prometheus&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/src/OpenTelemetry.Exporter.Zipkin/README.md&#34;&gt;Zipkin&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://opentelemetry.io/registry/?s=net&#34;&gt;OpenTelemetry registry&lt;/a&gt; for more exporters.&lt;/p&gt; &#xA;&lt;h2&gt;Extensibility&lt;/h2&gt; &#xA;&lt;p&gt;OpenTelemetry .NET is designed to be extensible. Here are the most common extension scenarios:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Building a custom &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/trace/extending-the-sdk/README.md#instrumentation-library&#34;&gt;instrumentation library&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Building a custom exporter for &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/logs/extending-the-sdk/README.md#exporter&#34;&gt;logs&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/metrics/extending-the-sdk/README.md#exporter&#34;&gt;metrics&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/trace/extending-the-sdk/README.md#exporter&#34;&gt;traces&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Building a custom processor for &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/logs/extending-the-sdk/README.md#processor&#34;&gt;logs&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/trace/extending-the-sdk/README.md#processor&#34;&gt;traces&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Building a custom sampler for &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/docs/trace/extending-the-sdk/README.md#sampler&#34;&gt;traces&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We meet weekly on Tuesdays, and the time of the meeting alternates between 11AM PT and 4PM PT. The meeting is subject to change depending on contributors&#39; availability. Check the &lt;a href=&#34;https://calendar.google.com/calendar/embed?src=google.com_b79e3e90j7bbsa2n2p5an5lf60%40group.calendar.google.com&#34;&gt;OpenTelemetry community calendar&lt;/a&gt; for specific dates and for Zoom meeting links.&lt;/p&gt; &#xA;&lt;p&gt;Meeting notes are available as a public &lt;a href=&#34;https://docs.google.com/document/d/1yjjD6aBcLxlRazYrawukDgrhZMObwHARJbB9glWdHj8/edit?usp=sharing&#34;&gt;Google doc&lt;/a&gt;. If you have trouble accessing the doc, please get in touch on &lt;a href=&#34;https://cloud-native.slack.com/archives/C01N3BC2W7Q&#34;&gt;Slack&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/community/raw/main/community-membership.md#maintainer&#34;&gt;Maintainers&lt;/a&gt; (&lt;a href=&#34;https://github.com/orgs/open-telemetry/teams/dotnet-maintainers&#34;&gt;@open-telemetry/dotnet-maintainers&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alanwest&#34;&gt;Alan West&lt;/a&gt;, New Relic&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cijothomas&#34;&gt;Cijo Thomas&lt;/a&gt;, Microsoft&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/CodeBlanch&#34;&gt;Mikel Blanchard&lt;/a&gt;, Microsoft&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/community/raw/main/community-membership.md#approver&#34;&gt;Approvers&lt;/a&gt; (&lt;a href=&#34;https://github.com/orgs/open-telemetry/teams/dotnet-approvers&#34;&gt;@open-telemetry/dotnet-approvers&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/reyang&#34;&gt;Reiley Yang&lt;/a&gt;, Microsoft&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pellared&#34;&gt;Robert Pająk&lt;/a&gt;, Splunk&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/utpilla&#34;&gt;Utkarsh Umesan Pillai&lt;/a&gt;, Microsoft&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/community/raw/main/community-membership.md#emeritus-maintainerapprovertriager&#34;&gt;Emeritus Maintainer/Approver/Triager&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bruno-garcia&#34;&gt;Bruno Garcia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eddynaka&#34;&gt;Eddy Nakamura&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lmolkova&#34;&gt;Liudmila Molkova&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MikeGoldsmith&#34;&gt;Mike Goldsmith&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pjanotti&#34;&gt;Paulo Janotti&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SergeyKanzhelev&#34;&gt;Sergey Kanzhelev&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/victlu&#34;&gt;Victor Lu&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Thanks to all the people who have contributed&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/graphs/contributors&#34;&gt;&lt;img src=&#34;https://contributors-img.web.app/image?repo=open-telemetry/opentelemetry-dotnet&#34; alt=&#34;contributors&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Release Schedule&lt;/h2&gt; &#xA;&lt;p&gt;Only the &lt;a href=&#34;https://raw.githubusercontent.com/open-telemetry/opentelemetry-dotnet/main/VERSIONING.md#core-components&#34;&gt;core components&lt;/a&gt; of the repo have released a stable version. Components which are marked &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/raw/main/VERSIONING.md#pre-releases&#34;&gt;pre-release&lt;/a&gt;, are still work in progress and can undergo many breaking changes before stable release.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/releases&#34;&gt;release notes&lt;/a&gt; for existing releases.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet/milestones&#34;&gt;project milestones&lt;/a&gt; for details on upcoming releases. The dates and features described in issues and milestones are estimates, and subject to change.&lt;/p&gt; &#xA;&lt;p&gt;Daily builds from this repo are published to MyGet, and can be installed from &lt;a href=&#34;https://www.myget.org/F/opentelemetry/api/v3/index.json&#34;&gt;this source&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Tyrrrz/CliWrap</title>
    <updated>2022-06-10T01:35:30Z</updated>
    <id>tag:github.com,2022-06-10:/Tyrrrz/CliWrap</id>
    <link href="https://github.com/Tyrrrz/CliWrap" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Library for running command line processes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CliWrap&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://vshymanskyy.github.io/StandWithUkraine&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/made_in-ukraine-ffd700.svg?labelColor=0057b7&#34; alt=&#34;Made in Ukraine&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Tyrrrz/CliWrap/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/Tyrrrz/CliWrap/CI/master&#34; alt=&#34;Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/Tyrrrz/CliWrap&#34;&gt;&lt;img src=&#34;https://img.shields.io/codecov/c/github/Tyrrrz/CliWrap/master&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://nuget.org/packages/CliWrap&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/CliWrap.svg?sanitize=true&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://nuget.org/packages/CliWrap&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/CliWrap.svg?sanitize=true&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/2SUWKFnHSm&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/869237470565392384?label=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://tyrrrz.me/donate&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/donate-$$$-8a2be2.svg?sanitize=true&#34; alt=&#34;Donate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/tyrrrz/status/1495972128977571848&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/fuck-russia-e4181c.svg?labelColor=000000&#34; alt=&#34;Fuck Russia&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;🟢 &lt;strong&gt;Project status&lt;/strong&gt;: active&lt;sup&gt;&lt;a href=&#34;https://github.com/Tyrrrz/.github/raw/master/docs/project-status.md&#34;&gt;[?]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;CliWrap&lt;/strong&gt; is a library for interacting with external command line interfaces. It provides a convenient model for launching processes, redirecting input and output streams, awaiting completion, handling cancellation, and more.&lt;/p&gt; &#xA;&lt;h2&gt;Terms of use&lt;sup&gt;&lt;a href=&#34;https://github.com/Tyrrrz/.github/raw/master/docs/why-so-political.md&#34;&gt;[?]&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt; &#xA;&lt;p&gt;By using this project or its source code, for any purpose and in any shape or form, you grant your &lt;strong&gt;implicit agreement&lt;/strong&gt; to all the following statements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You &lt;strong&gt;condemn Russia and its military aggression against Ukraine&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;You &lt;strong&gt;recognize that Russia is an occupant that unlawfully invaded a sovereign state&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;You &lt;strong&gt;support Ukraine&#39;s territorial integrity, including its claims over temporarily occupied territories of Crimea and Donbas&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;You &lt;strong&gt;reject false narratives perpetuated by Russian state propaganda&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To learn more about the war and how you can help, &lt;a href=&#34;https://tyrrrz.me&#34;&gt;click here&lt;/a&gt;. Glory to Ukraine! 🇺🇦&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;📦 &lt;a href=&#34;https://nuget.org/packages/CliWrap&#34;&gt;NuGet&lt;/a&gt;: &lt;code&gt;dotnet add package CliWrap&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Airtight abstraction over &lt;code&gt;System.Diagnostics.Process&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fluent configuration interface&lt;/li&gt; &#xA; &lt;li&gt;Flexible support for piping&lt;/li&gt; &#xA; &lt;li&gt;Fully asynchronous and cancellation-aware API&lt;/li&gt; &#xA; &lt;li&gt;Designed with strict immutability in mind&lt;/li&gt; &#xA; &lt;li&gt;Provides safety against typical deadlock scenarios&lt;/li&gt; &#xA; &lt;li&gt;Tested on Windows, Linux, and macOS&lt;/li&gt; &#xA; &lt;li&gt;Targets .NET Standard 2.0+, .NET Core 3.0+, .NET Framework 4.6.1+&lt;/li&gt; &#xA; &lt;li&gt;No external dependencies&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Video guide&lt;/h3&gt; &#xA;&lt;p&gt;📺 &lt;strong&gt;Watch &lt;a href=&#34;https://youtube.com/watch?v=3_Ucw3Fflmo&#34;&gt;Intro to CliWrap&lt;/a&gt; on YouTube for a deep look into the library and its features!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtube.com/watch?v=3_Ucw3Fflmo&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/.assets/webinar-yt-thumb.jpg&#34; alt=&#34;Intro to CliWrap&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Quick overview&lt;/h3&gt; &#xA;&lt;p&gt;Similarly to a shell, &lt;strong&gt;CliWrap&lt;/strong&gt;&#39;s base unit of work is a &lt;strong&gt;command&lt;/strong&gt; — an object that encodes instructions for running a process. To build a command, start by calling &lt;code&gt;Cli.Wrap(...)&lt;/code&gt; with the executable path, and then use the provided fluent interface to configure arguments, working directory, or other options. Once the command is configured, you can run it by calling &lt;code&gt;ExecuteAsync()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using CliWrap;&#xA;&#xA;var result = await Cli.Wrap(&#34;path/to/exe&#34;)&#xA;    .WithArguments(&#34;--foo bar&#34;)&#xA;    .WithWorkingDirectory(&#34;work/dir/path&#34;)&#xA;    .ExecuteAsync();&#xA;&#xA;// Result contains:&#xA;// -- result.ExitCode        (int)&#xA;// -- result.StartTime       (DateTimeOffset)&#xA;// -- result.ExitTime        (DateTimeOffset)&#xA;// -- result.RunTime         (TimeSpan)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code above spawns a child process with the configured command line arguments and working directory, and then asynchronously waits for it to exit. After the task has completed, it resolves to a &lt;code&gt;CommandResult&lt;/code&gt; object that contains the process exit code and other related information.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: &lt;strong&gt;CliWrap&lt;/strong&gt; will throw an exception if the underlying process returns a non-zero exit code, as it usually indicates an error. You can &lt;a href=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/#withvalidation&#34;&gt;override this behavior&lt;/a&gt; by disabling result validation using &lt;code&gt;WithValidation(CommandResultValidation.None)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;By default, the process&#39;s standard input, output and error streams are routed to &lt;strong&gt;CliWrap&lt;/strong&gt;&#39;s equivalent of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Null_device&#34;&gt;&lt;em&gt;null device&lt;/em&gt;&lt;/a&gt;, which represents an empty source and a target that discards all data. You can change this by calling &lt;code&gt;WithStandardInputPipe(...)&lt;/code&gt;, &lt;code&gt;WithStandardOutputPipe(...)&lt;/code&gt;, or &lt;code&gt;WithStandardErrorPipe(...)&lt;/code&gt; to configure pipes for the corresponding streams:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var stdOutBuffer = new StringBuilder();&#xA;var stdErrBuffer = new StringBuilder();&#xA;&#xA;// ⚠ This particular example can also be simplified with ExecuteBufferedAsync().&#xA;// Continue reading below!&#xA;var result = await Cli.Wrap(&#34;path/to/exe&#34;)&#xA;    .WithArguments(&#34;--foo bar&#34;)&#xA;    .WithWorkingDirectory(&#34;work/dir/path&#34;)&#xA;    .WithStandardOutputPipe(PipeTarget.ToStringBuilder(stdOutBuffer))&#xA;    .WithStandardErrorPipe(PipeTarget.ToStringBuilder(stdErrBuffer))&#xA;    .ExecuteAsync();&#xA;&#xA;// Contains stdOut/stdErr buffered in-memory as string&#xA;var stdOut = stdOutBuffer.ToString();&#xA;var stdErr = stdErrBuffer.ToString();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example command is configured to decode the data written to standard output and error streams as text, and append it to the corresponding &lt;code&gt;StringBuilder&lt;/code&gt; buffers. After the execution is complete, these buffers can be inspected to see what the process has printed to the console.&lt;/p&gt; &#xA;&lt;p&gt;Handling command output is a very common use case, so &lt;strong&gt;CliWrap&lt;/strong&gt; offers a few high-level &lt;a href=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/#execution-models&#34;&gt;execution models&lt;/a&gt; to make these scenarios simpler. In particular, the same thing shown above can also be achieved more succinctly with the &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt; extension method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using CliWrap;&#xA;using CliWrap.Buffered;&#xA;&#xA;// Calling `ExecuteBufferedAsync()` instead of `ExecuteAsync()`&#xA;// implicitly configures pipes that write to in-memory buffers.&#xA;var result = await Cli.Wrap(&#34;path/to/exe&#34;)&#xA;    .WithArguments(&#34;--foo bar&#34;)&#xA;    .WithWorkingDirectory(&#34;work/dir/path&#34;)&#xA;    .ExecuteBufferedAsync();&#xA;&#xA;// Result contains:&#xA;// -- result.StandardOutput  (string)&#xA;// -- result.StandardError   (string)&#xA;// -- result.ExitCode        (int)&#xA;// -- result.StartTime       (DateTimeOffset)&#xA;// -- result.ExitTime        (DateTimeOffset)&#xA;// -- result.RunTime         (TimeSpan)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Be mindful when using &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt;. Programs can write arbitrary data (including binary) to output and error streams, which may be impractical to buffer in-memory. For more advanced scenarios, &lt;strong&gt;CliWrap&lt;/strong&gt; also provides other piping options, which are covered in the &lt;a href=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/#piping&#34;&gt;piping section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Command configuration&lt;/h3&gt; &#xA;&lt;p&gt;The fluent interface provided by the command object allows you to configure various options related to its execution. Below list covers all available configuration methods and their usage.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;Command&lt;/code&gt; is an immutable object — all configuration methods listed here create a new instance instead of modifying the existing one.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithArguments(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets the command line arguments passed to the child process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: empty.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set arguments from a string:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithArguments(&#34;commit -m \&#34;my commit\&#34;&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set arguments from an array — each element is treated as a separate argument and spaces are escaped automatically:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithArguments(new[] {&#34;commit&#34;, &#34;-m&#34;, &#34;my commit&#34;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set arguments using a builder — same as above, but also works with non-string arguments and can be &lt;a href=&#34;https://twitter.com/Tyrrrz/status/1409104223753605121&#34;&gt;enhanced with your own extension methods&lt;/a&gt;:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithArguments(args =&amp;gt; args&#xA;        .Add(&#34;clone&#34;)&#xA;        .Add(&#34;https://github.com/Tyrrrz/CliWrap&#34;)&#xA;        .Add(&#34;--depth&#34;)&#xA;        .Add(20)&#xA;    );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: String overload of &lt;code&gt;WithArguments(...)&lt;/code&gt; only works well when the arguments are short, simple, and not expected to change. For all other scenarios, it&#39;s recommended to use the array or builder overload instead.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithWorkingDirectory(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets the working directory of the child process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: current working directory, i.e. &lt;code&gt;Directory.GetCurrentDirectory()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithWorkingDirectory(&#34;c:/projects/my project/&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithEnvironmentVariables(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets additional environment variables exposed to the child process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: empty.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set environment variables from a dictionary:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithEnvironmentVariables(new Dictionary&amp;lt;string, string?&amp;gt;&#xA;    {&#xA;        [&#34;GIT_AUTHOR_NAME&#34;] = &#34;John&#34;,&#xA;        [&#34;GIT_AUTHOR_EMAIL&#34;] = &#34;john@email.com&#34;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set environment variables using a builder:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithEnvironmentVariables(env =&amp;gt; env&#xA;        .Set(&#34;GIT_AUTHOR_NAME&#34;, &#34;John&#34;)&#xA;        .Set(&#34;GIT_AUTHOR_EMAIL&#34;, &#34;john@email.com&#34;)&#xA;    );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Environment variables configured using &lt;code&gt;WithEnvironmentVariables(...)&lt;/code&gt; are applied on top of those inherited from the parent process. If you need to remove an inherited variable, simply set its value to &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithCredentials(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets domain, name and password of the user, under whom the child process is started.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: no credentials.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set credentials directly:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithCredentials(new Credentials(&#xA;        &#34;some_workspace&#34;,&#xA;        &#34;johndoe&#34;,&#xA;        &#34;securepassword123&#34;&#xA;    ));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set credentials using a builder:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithCredentials(creds =&amp;gt; creds&#xA;       .SetDomain(&#34;some_workspace&#34;)&#xA;       .SetUserName(&#34;johndoe&#34;)&#xA;       .SetPassword(&#34;securepassword123&#34;)&#xA;    );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Running a process under a different username is supported across all platforms, but the domain and password options only work on Windows.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithValidation(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets the strategy for validating the result of an execution.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Accepted values&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CommandResultValidation.None&lt;/code&gt; — no validation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CommandResultValidation.ZeroExitCode&lt;/code&gt; — ensures zero exit code when the process exits&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: &lt;code&gt;CommandResultValidation.ZeroExitCode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enable validation — will throw an exception if the process exits with a non-zero exit code:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithValidation(CommandResultValidation.ZeroExitCode);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disable validation:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;git&#34;)&#xA;    .WithValidation(CommandResultValidation.None);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithStandardInputPipe(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets the pipe source that will be used for the standard &lt;em&gt;input&lt;/em&gt; stream of the process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: &lt;code&gt;PipeSource.Null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Read more about this method in the &lt;a href=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/#piping&#34;&gt;piping section&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithStandardOutputPipe(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets the pipe target that will be used for the standard &lt;em&gt;output&lt;/em&gt; stream of the process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: &lt;code&gt;PipeTarget.Null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Read more about this method in the &lt;a href=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/#piping&#34;&gt;piping section&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;WithStandardErrorPipe(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets the pipe target that will be used for the standard &lt;em&gt;error&lt;/em&gt; stream of the process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;: &lt;code&gt;PipeTarget.Null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Read more about this method in the &lt;a href=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/#piping&#34;&gt;piping section&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Piping&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;CliWrap&lt;/strong&gt; provides a very powerful and flexible piping model that allows you to redirect process&#39;s streams, transform input and output data, and even chain multiple commands together with minimal effort. At its core, it&#39;s based on two abstractions: &lt;code&gt;PipeSource&lt;/code&gt; which provides data for standard input stream, and &lt;code&gt;PipeTarget&lt;/code&gt; which reads data coming from standard output or standard error streams.&lt;/p&gt; &#xA;&lt;p&gt;By default, command&#39;s input pipe is set to &lt;code&gt;PipeSource.Null&lt;/code&gt; and the output and error pipes are set to &lt;code&gt;PipeTarget.Null&lt;/code&gt;. These objects effectively represent no-op stubs that provide empty input and discard all output respectively.&lt;/p&gt; &#xA;&lt;p&gt;You can specify your own &lt;code&gt;PipeSource&lt;/code&gt; and &lt;code&gt;PipeTarget&lt;/code&gt; instances by calling the corresponding configuration methods on the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await using var input = File.OpenRead(&#34;input.txt&#34;);&#xA;await using var output = File.Create(&#34;output.txt&#34;);&#xA;&#xA;await Cli.Wrap(&#34;foo&#34;)&#xA;    .WithStandardInputPipe(PipeSource.FromStream(input))&#xA;    .WithStandardOutputPipe(PipeTarget.ToStream(output))&#xA;    .ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, pipes can also be configured in a slightly terser way using pipe operators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await using var input = File.OpenRead(&#34;input.txt&#34;);&#xA;await using var output = File.Create(&#34;output.txt&#34;);&#xA;&#xA;await (input | Cli.Wrap(&#34;foo&#34;) | output).ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both &lt;code&gt;PipeSource&lt;/code&gt; and &lt;code&gt;PipeTarget&lt;/code&gt; have many factory methods that let you create pipe implementations for different scenarios:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;PipeSource&lt;/code&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeSource.Null&lt;/code&gt; — represents an empty pipe source&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeSource.FromStream(...)&lt;/code&gt; — pipes data from any readable stream&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeSource.FromFile(...)&lt;/code&gt; — pipes data from a file&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeSource.FromBytes(...)&lt;/code&gt; — pipes data from a byte array&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeSource.FromString(...)&lt;/code&gt; — pipes from a text string&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeSource.FromCommand(...)&lt;/code&gt; — pipes data from standard output of another command&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PipeTarget&lt;/code&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeTarget.Null&lt;/code&gt; — represents a pipe target that discards all data&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeTarget.ToStream(...)&lt;/code&gt; — pipes data into any writable stream&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeTarget.ToFile(...)&lt;/code&gt; — pipes data into a file&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeTarget.ToStringBuilder(...)&lt;/code&gt; — pipes data as text into &lt;code&gt;StringBuilder&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeTarget.ToDelegate(...)&lt;/code&gt; — pipes data as text, line-by-line, into &lt;code&gt;Action&amp;lt;string&amp;gt;&lt;/code&gt; or &lt;code&gt;Func&amp;lt;string, Task&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PipeTarget.Merge(...)&lt;/code&gt; — merges multiple outbound pipes by replicating the same data across all of them&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Using &lt;code&gt;PipeTarget.Null&lt;/code&gt; results in the corresponding stream (standard output or standard error) not being opened for the underlying process at all. In the vast majority of cases, this behavior should be functionally equivalent to piping to a null stream, but without the performance overhead of consuming and discarding unneeded data. This may be undesirable in &lt;a href=&#34;https://github.com/Tyrrrz/CliWrap/issues/145#issuecomment-1100680547&#34;&gt;certain situations&lt;/a&gt; — in which case it&#39;s recommended to pipe to a null stream explicitly using &lt;code&gt;PipeTarget.ToStream(Stream.Null)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Below you can see some examples of what you can achieve with the help of &lt;strong&gt;CliWrap&lt;/strong&gt;&#39;s piping feature:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe a string into stdin:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = &#34;Hello world&#34; | Cli.Wrap(&#34;foo&#34;);&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe stdout as text into a &lt;code&gt;StringBuilder&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var stdOutBuffer = new StringBuilder();&#xA;&#xA;var cmd = Cli.Wrap(&#34;foo&#34;) | stdOutBuffer;&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe a binary HTTP stream into stdin:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using var httpClient = new HttpClient();&#xA;await using var input = await httpClient.GetStreamAsync(&#34;https://example.com/image.png&#34;);&#xA;&#xA;var cmd = input | Cli.Wrap(&#34;foo&#34;);&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe stdout of one command into stdin of another:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;foo&#34;) | Cli.Wrap(&#34;bar&#34;) | Cli.Wrap(&#34;baz&#34;);&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe stdout and stderr into stdout and stderr of the parent process:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;await using var stdOut = Console.OpenStandardOutput();&#xA;await using var stdErr = Console.OpenStandardError();&#xA;&#xA;var cmd = Cli.Wrap(&#34;foo&#34;) | (stdOut, stdErr);&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe stdout into a delegate:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd = Cli.Wrap(&#34;foo&#34;) | Debug.WriteLine;&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe stdout into a file and stderr into a &lt;code&gt;StringBuilder&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var buffer = new StringBuilder();&#xA;&#xA;var cmd = Cli.Wrap(&#34;foo&#34;) |&#xA;    (PipeTarget.ToFile(&#34;output.txt&#34;), PipeTarget.ToStringBuilder(buffer));&#xA;&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe stdout into multiple files simultaneously:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var target = PipeTarget.Merge(&#xA;    PipeTarget.ToFile(&#34;file1.txt&#34;),&#xA;    PipeTarget.ToFile(&#34;file2.txt&#34;),&#xA;    PipeTarget.ToFile(&#34;file3.txt&#34;)&#xA;);&#xA;&#xA;var cmd = Cli.Wrap(&#34;foo&#34;) | target;&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe a string into stdin of one command, stdout of that command into stdin of another command, and then stdout and stderr of the last command into stdout and stderr of the parent process:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd =&#xA;    &#34;Hello world&#34; |&#xA;    Cli.Wrap(&#34;foo&#34;).WithArguments(&#34;aaa&#34;) |&#xA;    Cli.Wrap(&#34;bar&#34;).WithArguments(&#34;bbb&#34;) |&#xA;    (Console.WriteLine, Console.Error.WriteLine);&#xA;&#xA;await cmd.ExecuteAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Execution models&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;CliWrap&lt;/strong&gt; provides a few high-level execution models that offer alternative ways to reason about commands. These are essentially just extension methods that work by leveraging the &lt;a href=&#34;https://raw.githubusercontent.com/Tyrrrz/CliWrap/master/#piping&#34;&gt;piping feature&lt;/a&gt; shown earlier.&lt;/p&gt; &#xA;&lt;h4&gt;Buffered execution&lt;/h4&gt; &#xA;&lt;p&gt;This execution model lets you run a process while buffering its standard output and error streams in-memory. The buffered data can then be accessed after the command finishes executing.&lt;/p&gt; &#xA;&lt;p&gt;In order to execute a command with buffering, call the &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt; extension method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using CliWrap;&#xA;using CliWrap.Buffered;&#xA;&#xA;var result = await Cli.Wrap(&#34;path/to/exe&#34;)&#xA;    .WithArguments(&#34;--foo bar&#34;)&#xA;    .ExecuteBufferedAsync();&#xA;&#xA;var exitCode = result.ExitCode;&#xA;var stdOut = result.StandardOutput;&#xA;var stdErr = result.StandardError;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt; assumes that the underlying process uses the default encoding (&lt;code&gt;Console.OutputEncoding&lt;/code&gt;) for writing text to the console. To override this, specify the encoding explicitly by using one of the available overloads:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Treat both stdout and stderr as UTF8-encoded text streams&#xA;var result = await Cli.Wrap(&#34;path/to/exe&#34;)&#xA;    .WithArguments(&#34;--foo bar&#34;)&#xA;    .ExecuteBufferedAsync(Encoding.UTF8);&#xA;&#xA;// Treat stdout as ASCII-encoded and stderr as UTF8-encoded&#xA;var result = await Cli.Wrap(&#34;path/to/exe&#34;)&#xA;    .WithArguments(&#34;--foo bar&#34;)&#xA;    .ExecuteBufferedAsync(Encoding.ASCII, Encoding.UTF8);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Pull-based event stream&lt;/h4&gt; &#xA;&lt;p&gt;Besides executing a command as a task, &lt;strong&gt;CliWrap&lt;/strong&gt; also supports an alternative model, in which the execution is represented as an event stream. This lets you start a command and react to the events it produces in real-time.&lt;/p&gt; &#xA;&lt;p&gt;Those events are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;StartedCommandEvent&lt;/code&gt; — received just once, when the command starts executing (contains process ID)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;StandardOutputCommandEvent&lt;/code&gt; — received every time the underlying process writes a new line to the output stream (contains the text as string)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;StandardErrorCommandEvent&lt;/code&gt; — received every time the underlying process writes a new line to the error stream (contains the text as string)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ExitedCommandEvent&lt;/code&gt; — received just once, when the command finishes executing (contains exit code)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To execute a command as a &lt;em&gt;pull-based&lt;/em&gt; event stream, use the &lt;code&gt;ListenAsync()&lt;/code&gt; extension method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using CliWrap;&#xA;using CliWrap.EventStream;&#xA;&#xA;var cmd = Cli.Wrap(&#34;foo&#34;).WithArguments(&#34;bar&#34;);&#xA;&#xA;await foreach (var cmdEvent in cmd.ListenAsync())&#xA;{&#xA;    switch (cmdEvent)&#xA;    {&#xA;        case StartedCommandEvent started:&#xA;            _output.WriteLine($&#34;Process started; ID: {started.ProcessId}&#34;);&#xA;            break;&#xA;        case StandardOutputCommandEvent stdOut:&#xA;            _output.WriteLine($&#34;Out&amp;gt; {stdOut.Text}&#34;);&#xA;            break;&#xA;        case StandardErrorCommandEvent stdErr:&#xA;            _output.WriteLine($&#34;Err&amp;gt; {stdErr.Text}&#34;);&#xA;            break;&#xA;        case ExitedCommandEvent exited:&#xA;            _output.WriteLine($&#34;Process exited; Code: {exited.ExitCode}&#34;);&#xA;            break;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;ListenAsync()&lt;/code&gt; method starts the command and returns an object of type &lt;code&gt;IAsyncEnumerable&amp;lt;CommandEvent&amp;gt;&lt;/code&gt;, which you can iterate using the &lt;code&gt;await foreach&lt;/code&gt; construct introduced in C# 8. When using this execution model, back pressure is facilitated by locking the pipes between each iteration of the loop, preventing unnecessary buffering of data in-memory.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Just like with &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt;, you can specify custom encoding for &lt;code&gt;ListenAsync()&lt;/code&gt; using one of its overloads.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Push-based event stream&lt;/h4&gt; &#xA;&lt;p&gt;Similarly to the pull-based stream, you can also execute a command as a &lt;em&gt;push-based&lt;/em&gt; event stream instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using CliWrap;&#xA;using CliWrap.EventStream;&#xA;using System.Reactive;&#xA;&#xA;await cmd.Observe().ForEachAsync(cmdEvent =&amp;gt;&#xA;{&#xA;    switch (cmdEvent)&#xA;    {&#xA;        case StartedCommandEvent started:&#xA;            _output.WriteLine($&#34;Process started; ID: {started.ProcessId}&#34;);&#xA;            break;&#xA;        case StandardOutputCommandEvent stdOut:&#xA;            _output.WriteLine($&#34;Out&amp;gt; {stdOut.Text}&#34;);&#xA;            break;&#xA;        case StandardErrorCommandEvent stdErr:&#xA;            _output.WriteLine($&#34;Err&amp;gt; {stdErr.Text}&#34;);&#xA;            break;&#xA;        case ExitedCommandEvent exited:&#xA;            _output.WriteLine($&#34;Process exited; Code: {exited.ExitCode}&#34;);&#xA;            break;&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, &lt;code&gt;Observe()&lt;/code&gt; returns a cold &lt;code&gt;IObservable&amp;lt;CommandEvent&amp;gt;&lt;/code&gt; that represents an observable stream of command events. You can use the set of extensions provided by &lt;a href=&#34;https://github.com/dotnet/reactive&#34;&gt;Rx.NET&lt;/a&gt; to transform, filter, throttle, or otherwise manipulate this stream.&lt;/p&gt; &#xA;&lt;p&gt;Unlike the pull-based event stream, this execution model does not involve any back pressure, meaning that the data is pushed to the observer at the rate it becomes available.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Similarly to &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt;, you can specify custom encoding for &lt;code&gt;Observe()&lt;/code&gt; using one of its overloads.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Combining execution models with custom pipes&lt;/h4&gt; &#xA;&lt;p&gt;The different execution models shown above are based on the piping model, but those two concepts are not mutually exclusive. When running a command this way, existing pipe configurations are preserved and extended using &lt;code&gt;PipeTarget.Merge(...)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This means that you can, for example, pipe a command to a file and also execute it as an event stream without any issues:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cmd =&#xA;    PipeSource.FromFile(&#34;input.txt&#34;) |&#xA;    Cli.Wrap(&#34;foo&#34;) |&#xA;    PipeTarget.ToFile(&#34;output.txt&#34;);&#xA;&#xA;// Iterate as an event stream and pipe to a file at the same time&#xA;// (execution models preserve configured pipes)&#xA;await foreach (var cmdEvent in cmd.ListenAsync())&#xA;{&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timeout and cancellation&lt;/h3&gt; &#xA;&lt;p&gt;Command execution is asynchronous in nature as it involves a completely separate process. In many cases, it may be useful to implement an abortion mechanism to stop the execution before it finishes, either through a manual trigger or a timeout.&lt;/p&gt; &#xA;&lt;p&gt;To do that, just pass the corresponding &lt;code&gt;CancellationToken&lt;/code&gt; when calling &lt;code&gt;ExecuteAsync()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using var cts = new CancellationTokenSource();&#xA;&#xA;// Cancel automatically after a timeout of 10 seconds&#xA;cts.CancelAfter(TimeSpan.FromSeconds(10));&#xA;&#xA;var result = await Cli.Wrap(&#34;path/to/exe&#34;).ExecuteAsync(cts.Token);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the event of a cancellation request, the underlying process will be killed and &lt;code&gt;ExecuteAsync()&lt;/code&gt; will throw an exception of type &lt;code&gt;OperationCanceledException&lt;/code&gt; (or its derivative, &lt;code&gt;TaskCanceledException&lt;/code&gt;). You will need to catch this exception in your code to recover from cancellation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;try&#xA;{&#xA;    await Cli.Wrap(&#34;path/to/exe&#34;).ExecuteAsync(cts.Token);&#xA;}&#xA;catch (OperationCanceledException)&#xA;{&#xA;    // Command was cancelled&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Similarly to &lt;code&gt;ExecuteAsync()&lt;/code&gt;, cancellation is also supported by &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt;, &lt;code&gt;ListenAsync()&lt;/code&gt;, and &lt;code&gt;Observe()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: You can read more about &lt;code&gt;CancellationToken&lt;/code&gt; in .NET &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Retrieving process ID&lt;/h3&gt; &#xA;&lt;p&gt;The task returned by &lt;code&gt;ExecuteAsync()&lt;/code&gt; and &lt;code&gt;ExecuteBufferedAsync()&lt;/code&gt; is in fact not a regular &lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;, but an instance of &lt;code&gt;CommandTask&amp;lt;T&amp;gt;&lt;/code&gt;. This is a special awaitable object that contains additional information related to the currently executing command.&lt;/p&gt; &#xA;&lt;p&gt;You can inspect the task while it&#39;s running to get the ID of the process that was started by the associated command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var task = Cli.Wrap(&#34;path/to/exe&#34;)&#xA;    .WithArguments(&#34;--foo bar&#34;)&#xA;    .ExecuteAsync();&#xA;&#xA;// Get the process ID (for example, for logging purposes)&#xA;var processId = task.ProcessId;&#xA;&#xA;// Wait for the task to complete&#xA;await task;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>