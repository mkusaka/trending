<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-24T01:29:41Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dotnet/ClangSharp</title>
    <updated>2024-12-24T01:29:41Z</updated>
    <id>tag:github.com,2024-12-24:/dotnet/ClangSharp</id>
    <link href="https://github.com/dotnet/ClangSharp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clang bindings for .NET written in C#&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ClangSharp&lt;/h1&gt; &#xA;&lt;p&gt;ClangSharp provides Clang bindings written in C#. It is self-hosted and auto-generates itself by parsing the Clang C header files using ClangSharpPInvokeGenerator.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dotnet/ClangSharp/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/dotnet/ClangSharp/actions/workflows/ci.yml/badge.svg?branch=main&amp;amp;event=push&#34; alt=&#34;ci&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A nuget package for the project is provided here: &lt;a href=&#34;https://www.nuget.org/packages/clangsharp&#34;&gt;https://www.nuget.org/packages/clangsharp&lt;/a&gt;. A .NET tool for the P/Invoke generator project is provided here: &lt;a href=&#34;https://www.nuget.org/packages/ClangSharpPInvokeGenerator&#34;&gt;https://www.nuget.org/packages/ClangSharpPInvokeGenerator&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; If you are running as a dotnet tool, you may need to manually copy the appropriate DLLs from NuGet due to limitations in the dotnet tool support.&lt;/p&gt; &#xA;&lt;p&gt;A convenience package which provides the native libClang library for several platforms is provided here: &lt;a href=&#34;https://www.nuget.org/packages/libclang&#34;&gt;https://www.nuget.org/packages/libclang&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A helper package which exposes many Clang APIs missing from libClang is provided here: &lt;a href=&#34;https://www.nuget.org/packages/libClangSharp&#34;&gt;https://www.nuget.org/packages/libClangSharp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; libclang and libClangSharp are meta-packages which point to the platform-specific runtime packages (&lt;a href=&#34;https://www.nuget.org/packages/libClangSharp.runtime.win-x64/18.1.3&#34;&gt;e.g.&lt;/a&gt;; see others owned by &lt;a href=&#34;https://www.nuget.org/profiles/tannergooding&#34;&gt;tannergooding&lt;/a&gt;). Several manual steps may be required to use them, see discussion in &lt;a href=&#34;https://github.com/dotnet/ClangSharp/issues/46&#34;&gt;#46&lt;/a&gt; and &lt;a href=&#34;https://github.com/dotnet/ClangSharp/issues/118&#34;&gt;#118&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Nightly packages are available via the NuGet Feed URL: &lt;a href=&#34;https://pkgs.clangsharp.dev/index.json&#34;&gt;https://pkgs.clangsharp.dev/index.json&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Source browsing is available via: &lt;a href=&#34;https://source.clangsharp.dev/&#34;&gt;https://source.clangsharp.dev/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#code-of-conduct&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#building-managed&#34;&gt;Building Managed&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#building-native&#34;&gt;Building Native&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#generating-bindings&#34;&gt;Generating Bindings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#using-locally-built-versions&#34;&gt;Using locally built versions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/#spotlight&#34;&gt;Spotlight&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Code of Conduct&lt;/h3&gt; &#xA;&lt;p&gt;ClangSharp and everyone contributing (this includes issues, pull requests, the wiki, etc) must abide by the .NET Foundation Code of Conduct: &lt;a href=&#34;https://dotnetfoundation.org/about/code-of-conduct&#34;&gt;https://dotnetfoundation.org/about/code-of-conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at &lt;a href=&#34;mailto:conduct@dotnetfoundation.org&#34;&gt;conduct@dotnetfoundation.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;Copyright (c) .NET Foundation and Contributors. All Rights Reserved. Licensed under the MIT License (MIT). See &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/ClangSharp/main/LICENSE.md&#34;&gt;LICENSE.md&lt;/a&gt; in the repository root for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Auto-generated using Clang C headers files, and supports all functionality exposed by them ~ which means you can build tooling around C/C++&lt;/li&gt; &#xA; &lt;li&gt;Exposes the raw unsafe API for performance&lt;/li&gt; &#xA; &lt;li&gt;Exposes a slightly higher abstraction that is type safe (CXIndex and CXTranslationUnit are different types, despite being pointers internally)&lt;/li&gt; &#xA; &lt;li&gt;Exposes an again slightly higher abstraction that tries to mirror the Clang C++ Type Hierarchy where possible&lt;/li&gt; &#xA; &lt;li&gt;Nearly identical to the Clang C APIs, e.g. &lt;code&gt;clang_getDiagnosticSpelling&lt;/code&gt; in C, vs. &lt;code&gt;clang.getDiagnosticSpelling&lt;/code&gt; (notice the . in the C# API)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building Managed&lt;/h3&gt; &#xA;&lt;p&gt;ClangSharp requires the &lt;a href=&#34;https://dotnet.microsoft.com/download/dotnet/8.0&#34;&gt;.NET 8 SDK&lt;/a&gt; and can be built simply with &lt;code&gt;dotnet build -c Release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can reproduce what the CI environment does by running &lt;code&gt;./scripts/cibuild.cmd&lt;/code&gt; on Windows or &lt;code&gt;./scripts.cibuild.sh&lt;/code&gt; on Unix. This will download the required .NET SDK locally and use that to build the repo; it will also run through all available actions in the appropriate order.&lt;/p&gt; &#xA;&lt;p&gt;There are also several build scripts in the repository root. On Windows these scripts end with &lt;code&gt;.cmd&lt;/code&gt; and expect arguments with a &lt;code&gt;-&lt;/code&gt; prefix. On Unix these scripts end with &lt;code&gt;.sh&lt;/code&gt; and expect arguments with a &lt;code&gt;--&lt;/code&gt; prefix. By default, each script performs only the action specified in its name (i.e. &lt;code&gt;restore&lt;/code&gt; only restores, &lt;code&gt;build&lt;/code&gt; only builds, &lt;code&gt;test&lt;/code&gt; only tests, and &lt;code&gt;pack&lt;/code&gt; only packs). You can specify additional actions to be run by passing that name as an argument to the script (e.g. &lt;code&gt;build.cmd -restore&lt;/code&gt; will perform a package restore and build; &lt;code&gt;test.cmd -pack&lt;/code&gt; will run tests and package artifacts). Certain actions are dependent on a previous action having been run at least once. &lt;code&gt;build&lt;/code&gt; depends on &lt;code&gt;restore&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt; depends on &lt;code&gt;build&lt;/code&gt;, and &lt;code&gt;pack&lt;/code&gt; depends on &lt;code&gt;build&lt;/code&gt;. This means the recommended first time action is &lt;code&gt;build -restore&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can see any additional options that are available by passing &lt;code&gt;-help&lt;/code&gt; on Windows or &lt;code&gt;--help&lt;/code&gt; on Unix to the available build scripts.&lt;/p&gt; &#xA;&lt;h3&gt;Building Native&lt;/h3&gt; &#xA;&lt;p&gt;ClangSharp provides a helper library, &lt;code&gt;libClangSharp&lt;/code&gt;, that exposes additional functionality that is not available in &lt;code&gt;libClang&lt;/code&gt;. Building this requires &lt;a href=&#34;https://cmake.org/download/&#34;&gt;CMake 3.13 or later&lt;/a&gt; as well as a version of MSVC or Clang that supports C++ 17.&lt;/p&gt; &#xA;&lt;p&gt;To successfully build &lt;code&gt;libClangSharp&lt;/code&gt; you must first build Clang (&lt;a href=&#34;https://clang.llvm.org/get_started.html&#34;&gt;https://clang.llvm.org/get_started.html&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;The process done on Windows is roughly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;git clone --single-branch --branch llvmorg-18.1.3 https://github.com/llvm/llvm-project&#xA;cd llvm-project&#xA;mkdir artifacts/bin&#xA;cd artifacts/bin&#xA;cmake -DCMAKE_INSTALL_PREFIX=../install -DLLVM_ENABLE_PROJECTS=clang -G &#34;Visual Studio 17 2022&#34; -A x64 -Thost=x64 ../../llvm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then open &lt;code&gt;LLVM.sln&lt;/code&gt; in Visual Studio, change the configuration to &lt;code&gt;Release&lt;/code&gt; and build the &lt;code&gt;install&lt;/code&gt; project.&lt;/p&gt; &#xA;&lt;p&gt;Afterwards, you can then build &lt;code&gt;libClangSharp&lt;/code&gt; where the process followed is roughly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;git clone https://github.com/dotnet/clangsharp&#xA;cd clangsharp&#xA;mkdir artifacts/bin/native&#xA;cd artifacts/bin/native&#xA;cmake -DCMAKE_INSTALL_PREFIX=../install -DPATH_TO_LLVM=../../../../llvm-project/artifacts/install -G &#34;Visual Studio 17 2022&#34; -A x64 -Thost=x64 ../../..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then open &lt;code&gt;libClangSharp.sln&lt;/code&gt; in Visual Studio, change the configuration to &lt;code&gt;Release&lt;/code&gt; and build the &lt;code&gt;install&lt;/code&gt; project.&lt;/p&gt; &#xA;&lt;h4&gt;Linux&lt;/h4&gt; &#xA;&lt;p&gt;The process done on Linux is roughly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone --single-branch --branch llvmorg-18.1.3 https://github.com/llvm/llvm-project&#xA;cd llvm-project&#xA;mkdir -p artifacts/bin&#xA;cd artifacts/bin&#xA;cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../install -DLLVM_ENABLE_PROJECTS=clang ../../llvm&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want your Linux build to be portable, you may also consider specifying the following options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-DLLVM_ENABLE_TERMINFO=OFF&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-DLLVM_ENABLE_ZLIB=OFF&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-DLLVM_ENABLE_ZSTD=OFF&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-DLLVM_STATIC_LINK_CXX_STDLIB=ON&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you would prefer to use &lt;code&gt;Ninja&lt;/code&gt;, then make sure to pass in &lt;code&gt;-G Ninja&lt;/code&gt; and then invoke &lt;code&gt;ninja&lt;/code&gt; rather than &lt;code&gt;make install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Afterwards, you can then build &lt;code&gt;libClangSharp&lt;/code&gt; where the process followed is roughly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;git clone https://github.com/dotnet/clangsharp&#xA;cd clangsharp&#xA;mkdir -p artifacts/bin/native&#xA;cd artifacts/bin/native&#xA;cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../install -DPATH_TO_LLVM=../../../../llvm-project/artifacts/install ../../../&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generating Bindings&lt;/h3&gt; &#xA;&lt;p&gt;This program will take a given set of C or C++ header files and generate C# bindings from them. It is still a work-in-progress and not every declaration can have bindings generated today (contributions are welcome).&lt;/p&gt; &#xA;&lt;p&gt;The simplest and recommended setup is to install the generator as a .NET tool and then use response files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet tool install --global ClangSharpPInvokeGenerator --version 18.1.0&#xA;ClangSharpPInvokeGenerator @generate.rsp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A response file allows you to specify and checkin the command line arguments in a text file, with one argument per line. For example: &lt;a href=&#34;https://github.com/dotnet/ClangSharp/raw/main/sources/ClangSharpPInvokeGenerator/Properties/GenerateClang.rsp&#34;&gt;https://github.com/dotnet/ClangSharp/blob/main/sources/ClangSharpPInvokeGenerator/Properties/GenerateClang.rsp&lt;/a&gt; At a minimum, the command line expects one or more input files (&lt;code&gt;-f&lt;/code&gt;), an output namespace (&lt;code&gt;-n&lt;/code&gt;), and an output location (&lt;code&gt;-o&lt;/code&gt;). A typical response file may also specify explicit files to traverse, configuration options, name remappings, and other fixups.&lt;/p&gt; &#xA;&lt;p&gt;The full set of available switches:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ClangSharpPInvokeGenerator&#xA;  ClangSharp P/Invoke Binding Generator&#xA;&#xA;Usage:&#xA;  ClangSharpPInvokeGenerator [options]&#xA;&#xA;Options:&#xA;  -a, --additional &amp;lt;additional&amp;gt;                                    An argument to pass to Clang when parsing the input files. []&#xA;  -c, --config &amp;lt;config&amp;gt;                                            A configuration option that controls how the bindings are generated. Specify &#39;help&#39; to see the available options. []&#xA;  -D, --define-macro &amp;lt;define-macro&amp;gt;                                Define &amp;lt;macro&amp;gt; to &amp;lt;value&amp;gt; (or 1 if &amp;lt;value&amp;gt; omitted). []&#xA;  -e, --exclude &amp;lt;exclude&amp;gt;                                          A declaration name to exclude from binding generation. []&#xA;  -f, --file &amp;lt;file&amp;gt;                                                A file to parse and generate bindings for. []&#xA;  -F, --file-directory &amp;lt;file-directory&amp;gt;                            The base path for files to parse. []&#xA;  -hf, --headerFile &amp;lt;headerFile&amp;gt;                                   A file which contains the header to prefix every generated file with. []&#xA;  -i, --include &amp;lt;include&amp;gt;                                          A declaration name to include in binding generation. []&#xA;  -I, --include-directory &amp;lt;include-directory&amp;gt;                      Add directory to include search path. []&#xA;  -x, --language &amp;lt;c|c++&amp;gt;                                           Treat subsequent input files as having type &amp;lt;language&amp;gt;. [default: c++]&#xA;  -l, --libraryPath &amp;lt;libraryPath&amp;gt;                                  The string to use in the DllImport attribute used when generating bindings. []&#xA;  -m, --methodClassName &amp;lt;methodClassName&amp;gt;                          The name of the static class that will contain the generated method bindings. [default: Methods]&#xA;  -n, --namespace &amp;lt;namespace&amp;gt;                                      The namespace in which to place the generated bindings. []&#xA;  -om, --output-mode &amp;lt;CSharp|Xml&amp;gt;                                  The mode describing how the information collected from the headers are presented in the resultant bindings. [default: CSharp]&#xA;  -o, --output &amp;lt;output&amp;gt;                                            The output location to write the generated bindings to. []&#xA;  -p, --prefixStrip &amp;lt;prefixStrip&amp;gt;                                  The prefix to strip from the generated method bindings. []&#xA;  --nativeTypeNamesToStrip &amp;lt;nativeTypeNamesToStrip&amp;gt;                The contents to strip from the generated NativeTypeName attributes. []&#xA;  -r, --remap &amp;lt;remap&amp;gt;                                              A declaration name to be remapped to another name during binding generation. []&#xA;  -std &amp;lt;std&amp;gt;                                                       Language standard to compile for. []&#xA;  -to, --test-output &amp;lt;test-output&amp;gt;                                 The output location to write the generated tests to. []&#xA;  -t, --traverse &amp;lt;traverse&amp;gt;                                        A file name included either directly or indirectly by -f that should be traversed during binding generation. []&#xA;  -v, --version                                                    Prints the current version information for the tool and its native dependencies.&#xA;  -was, --with-access-specifier &amp;lt;with-access-specifier&amp;gt;            An access specifier to be used with the given qualified or remapped declaration name during binding generation. Supports wildcards. []&#xA;  -wa, --with-attribute &amp;lt;with-attribute&amp;gt;                           An attribute to be added to the given remapped declaration name during binding generation. Supports wildcards. []&#xA;  -wcc, --with-callconv &amp;lt;with-callconv&amp;gt;                            A calling convention to be used for the given declaration during binding generation. Supports wildcards. []&#xA;  -wc, --with-class &amp;lt;with-class&amp;gt;                                   A class to be used for the given remapped constant or function declaration name during binding generation. Supports wildcards. []&#xA;  -wg, --with-guid &amp;lt;with-guid&amp;gt;                                     A GUID to be used for the given declaration during binding generation. Supports wildcards. []&#xA;  -wl, --with-length &amp;lt;with-length&amp;gt;                                 A length to be used for the given declaration during binding generation. Supports wildcards. []&#xA;  -wlb, --with-librarypath &amp;lt;with-librarypath&amp;gt;                      A library path to be used for the given declaration during binding generation. Supports wildcards. []&#xA;  -wmi, --with-manual-import &amp;lt;with-manual-import&amp;gt;                  A remapped function name to be treated as a manual import during binding generation. Supports wildcards. []&#xA;  -wn, --with-namespace &amp;lt;with-namespace&amp;gt;                           A namespace to be used for the given remapped declaration name during binding generation. Supports wildcards. []&#xA;  -wp, --with-packing &amp;lt;with-packing&amp;gt;                               Overrides the StructLayoutAttribute.Pack property for the given type. Supports wildcards. []&#xA;  -wsle, --with-setlasterror &amp;lt;with-setlasterror&amp;gt;                   Add the SetLastError=true modifier or SetsSystemLastError attribute to a given DllImport or UnmanagedFunctionPointer. Supports wildcards. []&#xA;  -wsgct, --with-suppressgctransition &amp;lt;with-suppressgctransition&amp;gt;  Add the SuppressGCTransition calling convention to a given DllImport or UnmanagedFunctionPointer. Supports wildcards. []&#xA;  -wts, --with-transparent-struct &amp;lt;with-transparent-struct&amp;gt;        A remapped type name to be treated as a transparent wrapper during binding generation. Supports wildcards. []&#xA;  -wt, --with-type &amp;lt;with-type&amp;gt;                                     A type to be used for the given enum declaration during binding generation. Supports wildcards. []&#xA;  -wu, --with-using &amp;lt;with-using&amp;gt;                                   A using directive to be included for the given remapped declaration name during binding generation. Supports wildcards. []&#xA;  -?, -h, --help                                                   Show help and usage information&#xA;&#xA;Wildcards:&#xA;You can use * as catch-all rule for remapping procedures. For example if you want make all of your generated code internal you can use --with-access-specifier *=Internal.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The available configuration options (visible with &lt;code&gt;-c help&lt;/code&gt;) are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--config, -c    A configuration option that controls how the bindings are generated. Specify &#39;help&#39; to see the available options.&#xA;&#xA;Options:&#xA;  ?, h, help                             Show help and usage information for -c, --config&#xA;&#xA;  # Codegen Options&#xA;&#xA;  compatible-codegen                     Bindings should be generated with .NET Standard 2.0 compatibility. Setting this disables preview code generation.&#xA;  default-codegen                        Bindings should be generated for the previous LTS version of .NET/C#. This is currently .NET 6/C# 10.&#xA;  latest-codegen                         Bindings should be generated for the current LTS/STS version of .NET/C#. This is currently .NET 8/C# 12.&#xA;  preview-codegen                        Bindings should be generated for the preview version of .NET/C#. This is currently .NET 9/C# 13.&#xA;&#xA;  # File Options&#xA;&#xA;  single-file                            Bindings should be generated to a single output file. This is the default.&#xA;  multi-file                             Bindings should be generated so there is approximately one type per file.&#xA;&#xA;  # Type Options&#xA;&#xA;  unix-types                             Bindings should be generated assuming Unix defaults. This is the default on Unix platforms.&#xA;  windows-types                          Bindings should be generated assuming Windows defaults. This is the default on Windows platforms.&#xA;&#xA;  # Exclusion Options&#xA;&#xA;  exclude-anonymous-field-helpers        The helper ref properties generated for fields in nested anonymous structs and unions should not be generated.&#xA;  exclude-com-proxies                    Types recognized as COM proxies should not have bindings generated. These are currently function declarations ending with _UserFree, _UserMarshal, _UserSize, _UserUnmarshal, _Proxy, or _Stub.&#xA;  exclude-default-remappings             Default remappings for well known types should not be added. This currently includes intptr_t, ptrdiff_t, size_t, and uintptr_t&#xA;  exclude-empty-records                  Bindings for records that contain no members should not be generated. These are commonly encountered for opaque handle like types such as HWND.&#xA;  exclude-enum-operators                 Bindings for operators over enum types should not be generated. These are largely unnecessary in C# as the operators are available by default.&#xA;  exclude-fnptr-codegen                  Generated bindings for latest or preview codegen should not use function pointers.&#xA;  exclude-funcs-with-body                Bindings for functions with bodies should not be generated.&#xA;  exclude-using-statics-for-enums        Enum usages should be fully qualified and should not include a corresponding &#39;using static EnumName;&#39;&#xA;&#xA;  # Vtbl Options&#xA;&#xA;  explicit-vtbls                         VTBLs should have an explicit type generated with named fields per entry.&#xA;  implicit-vtbls                         VTBLs should be implicit to reduce metadata bloat. This is the current default&#xA;  trimmable-vtbls                        VTBLs should be defined but not used in helper methods to reduce metadata bloat when trimming.&#xA;&#xA;  # Test Options&#xA;&#xA;  generate-tests-nunit                   Basic tests validating size, blittability, and associated metadata should be generated for NUnit.&#xA;  generate-tests-xunit                   Basic tests validating size, blittability, and associated metadata should be generated for XUnit.&#xA;&#xA;  # Generation Options&#xA;&#xA;  generate-aggressive-inlining           [MethodImpl(MethodImplOptions.AggressiveInlining)] should be added to generated helper functions.&#xA;  generate-callconv-member-function      Instance function pointers should use [CallConvMemberFunction] where applicable.&#xA;  generate-cpp-attributes                [CppAttributeList(&#34;&#34;)] should be generated to document the encountered C++ attributes.&#xA;  generate-disable-runtime-marshalling   [assembly: DisableRuntimeMarshalling] should be generated.&#xA;  generate-doc-includes                  &amp;lt;include&amp;gt; xml documentation tags should be generated for declarations.&#xA;  generate-file-scoped-namespaces        Namespaces should be scoped to the file to reduce nesting.&#xA;  generate-guid-member                   Types with an associated GUID should have a corresponding member generated.&#xA;  generate-helper-types                  Code files should be generated for various helper attributes and declared transparent structs.&#xA;  generate-macro-bindings                Bindings for macro-definitions should be generated. This currently only works with value like macros and not function-like ones.&#xA;  generate-marker-interfaces             Bindings for marker interfaces representing native inheritance hierarchies should be generated.&#xA;  generate-native-bitfield-attribute     [NativeBitfield(&#34;&#34;, offset: #, length: #)] attribute should be generated to document the encountered bitfield layout.&#xA;  generate-native-inheritance-attribute  [NativeInheritance(&#34;&#34;)] attribute should be generated to document the encountered C++ base type.&#xA;  generate-generic-pointer-wrapper       Pointer&amp;lt;T&amp;gt; should be used for limited generic type support.&#xA;  generate-setslastsystemerror-attribute [SetsLastSystemError] attribute should be generated rather than using SetLastError = true.&#xA;  generate-template-bindings             Bindings for template-definitions should be generated. This is currently experimental.&#xA;  generate-unmanaged-constants           Unmanaged constants should be generated using static ref readonly properties. This is currently experimental.&#xA;  generate-vtbl-index-attribute          [VtblIndex(#)] attribute should be generated to document the underlying VTBL index for a helper method.&#xA;&#xA;  # Stripping Options&#xA;&#xA;  strip-enum-member-type-name            Strips the enum type name from the beginning of its member names.&#xA;&#xA;  # Logging Options&#xA;&#xA;  log-exclusions                         A list of excluded declaration types should be generated. This will also log if the exclusion was due to an exact or partial match.&#xA;  log-potential-typedef-remappings       A list of potential typedef remappings should be generated. This can help identify missing remappings.&#xA;  log-visited-files                      A list of the visited files should be generated. This can help identify traversal issues.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using locally built versions&lt;/h3&gt; &#xA;&lt;p&gt;After you build local version, you can use executable from build location.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;artifacts/bin/sources/ClangSharpPInvokeGenerator/Debug/net6.0/ClangSharpPInvokeGenerator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are on Linux&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;LD_LIBRARY_PATH=$(pwd)/artifacts/bin/native/lib/&#xA;artifacts/bin/sources/ClangSharpPInvokeGenerator/Debug/net6.0/ClangSharpPInvokeGenerator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Spotlight&lt;/h3&gt; &#xA;&lt;p&gt;The P/Invoke Generator is currently used by several projects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dotnet/clangsharp&#34;&gt;dotnet/clangsharp&lt;/a&gt; - ClangSharp is self-hosting&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dotnet/llvmsharp&#34;&gt;dotnet/llvmsharp&lt;/a&gt; - Bindings over libLLVM&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/win32metadata&#34;&gt;microsoft/win32metadata&lt;/a&gt; - Bindings over the Windows SDK meant for downstream use by projects such as CsWin32, RsWin32, etc&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/terrafx/terrafx.interop.windows&#34;&gt;terrafx/terrafx.interop.windows&lt;/a&gt; - Bindings for D3D10, D3D11, D3D12, D2D1, DWrite, WIC, User32, and more in a single NuGet&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/terrafx/terrafx.interop.vulkan&#34;&gt;terrafx/terrafx.interop.vulkan&lt;/a&gt; - Bindings for Vulkan&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/terrafx/terrafx.interop.xlib&#34;&gt;terrafx/terrafx.interop.xlib&lt;/a&gt; - Bindings for Xlib&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>