<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-11T01:25:13Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>blake502/balatro-apk-maker</title>
    <updated>2024-04-11T01:25:13Z</updated>
    <id>tag:github.com,2024-04-11:/blake502/balatro-apk-maker</id>
    <link href="https://github.com/blake502/balatro-apk-maker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Create a Balatro APK from your Steam version of Balatro&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Balatro APK Maker&lt;/h1&gt; &#xA;&lt;p&gt;This goal of this script is to allow &lt;em&gt;Balatro&lt;/em&gt; fans to play &lt;em&gt;Balatro&lt;/em&gt; on their mobile devices before the official release. This script provides a &lt;strong&gt;NON-PIRACY&lt;/strong&gt; avenue for players to do so, by converting their &lt;em&gt;Steam&lt;/em&gt; version of &lt;em&gt;Balatro&lt;/em&gt; to an APK format.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start Guide&lt;/h2&gt; &#xA;&lt;p&gt;Please review the &lt;strong&gt;Notes&lt;/strong&gt; section before you begin.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download or compile &lt;a href=&#34;https://github.com/blake502/balatro-apk-maker/releases&#34;&gt;&lt;strong&gt;balatro-apk-maker.exe&lt;/strong&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;strong&gt;balatro-apk-maker.exe&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Follow the prompts to apply optional patches. If you&#39;re unsure, always select &#34;Y&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Copy the resulting &lt;strong&gt;balatro.apk&lt;/strong&gt; to your Android device.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Optional Patches&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;FPS Cap&lt;/strong&gt; Caps FPS to a desired number (Or to the device&#39;s native refresh rate-- recommended for battery performance)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Landscape Orientation&lt;/strong&gt; Locks the game to landscape orientation (Recommended, since portrait orientation does not behave very well)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;CRT Shader Disable&lt;/strong&gt; Disables the CRT Shader (Recommended for Pixel and some other devices)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Accessible Saves&lt;/strong&gt; Changes the save path from &lt;code&gt;data/data/com.unofficial.balatro/files&lt;/code&gt; to &lt;code&gt;sdcard/Android/data/com.unofficial.balatro/files&lt;/code&gt;. Accessing this location with the lastest versions of Android is still tricky, but it should make it easier for root users. (Recommended for most cases)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This script assumes that &lt;strong&gt;Balatro.exe&lt;/strong&gt; is located in the default &lt;em&gt;Steam&lt;/em&gt; directory (&lt;code&gt;C:\Program Files (x86)\Steam\steamapps\common\Balatro\Balatro.exe&lt;/code&gt;). If it is not, simply copy your &lt;strong&gt;Balatro.exe&lt;/strong&gt; to the same folder as &lt;strong&gt;balatro-apk-maker.exe&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;This script can automatically download and install &lt;a href=&#34;https://www.java.com/en/download/&#34;&gt;Java&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;This script will automatically download &lt;a href=&#34;https://www.7-zip.org/&#34;&gt;7-Zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;This script will automatically download &lt;a href=&#34;https://apktool.org/&#34;&gt;APK Tool&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;This script will automatically download &lt;a href=&#34;https://github.com/patrickfav/uber-apk-signer/&#34;&gt;uber-apk-signer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;This script will automatically download &lt;a href=&#34;https://github.com/love2d/love-android/&#34;&gt;love-11.5-android-embed.apk&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;This script will automatically download &lt;a href=&#34;http://smudge.codes/files/Balatro-APK-Patch.zip&#34;&gt;Balatro-APK-Patch&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ip7z/7zip/raw/main/DOC/License.txt&#34;&gt;7-Zip&lt;/a&gt; is licensed under the GNU LGPL license.&lt;/p&gt; &#xA;&lt;p&gt;This project uses &lt;a href=&#34;https://github.com/iBotPeaches/Apktool/raw/master/LICENSE.md&#34;&gt;APKTool&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project uses &lt;a href=&#34;https://github.com/patrickfav/uber-apk-signer/raw/main/LICENSE&#34;&gt;uber-apk-signer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project uses &lt;a href=&#34;https://github.com/love2d/love/raw/main/license.txt&#34;&gt;LOVE&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>amantinband/error-or</title>
    <updated>2024-04-11T01:25:13Z</updated>
    <id>tag:github.com,2024-04-11:/amantinband/error-or</id>
    <link href="https://github.com/amantinband/error-or" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple, fluent discriminated union of an error or a result.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/assets/icon.png&#34; alt=&#34;drawing&#34; width=&#34;700px&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/erroror&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/erroror.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/amantinband/error-or/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/amantinband/error-or/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/amantinband/error-or/actions/workflows/publish.yml&#34;&gt;&lt;img src=&#34;https://github.com/amantinband/error-or/actions/workflows/publish.yml/badge.svg?sanitize=true&#34; alt=&#34;publish ErrorOr to nuget&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;h2&gt;&lt;a href=&#34;https://GitHub.com/amantinband/error-or/graphs/contributors/&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/contributors/amantinband/error-or&#34; alt=&#34;GitHub contributors&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/amantinband/error-or/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/amantinband/error-or.svg?sanitize=true&#34; alt=&#34;GitHub Stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/amantinband/error-or/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/amantinband/error-or&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/amantinband/error-or&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/amantinband/error-or/branch/main/graph/badge.svg?token=DR2EBIWK7B&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA; &lt;h3&gt;A simple, fluent discriminated union of an error or a result.&lt;/h3&gt; &#xA; &lt;p&gt;&lt;code&gt;dotnet add package ErrorOr&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#give-it-a-star-&#34;&gt;Give it a star ‚≠ê!&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#getting-started-&#34;&gt;Getting Started üèÉ&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#replace-throwing-exceptions-with-errorort&#34;&gt;Replace throwing exceptions with &lt;code&gt;ErrorOr&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#support-for-multiple-errors&#34;&gt;Support For Multiple Errors&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#various-functional-methods-and-extension-methods&#34;&gt;Various Functional Methods and Extension Methods&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#real-world-example&#34;&gt;Real world example&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#simple-example-with-intermediate-steps&#34;&gt;Simple Example with intermediate steps&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#no-failure&#34;&gt;No Failure&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#failure&#34;&gt;Failure&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#creating-an-erroror-instance&#34;&gt;Creating an &lt;code&gt;ErrorOr&lt;/code&gt; instance&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#using-implicit-conversion&#34;&gt;Using implicit conversion&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#using-the-errororfactory&#34;&gt;Using The &lt;code&gt;ErrorOrFactory&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#using-the-toerroror-extension-method&#34;&gt;Using The &lt;code&gt;ToErrorOr&lt;/code&gt; Extension Method&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#properties&#34;&gt;Properties&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#iserror&#34;&gt;&lt;code&gt;IsError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#value&#34;&gt;&lt;code&gt;Value&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#errors&#34;&gt;&lt;code&gt;Errors&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#firsterror&#34;&gt;&lt;code&gt;FirstError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#errorsoremptylist&#34;&gt;&lt;code&gt;ErrorsOrEmptyList&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#methods&#34;&gt;Methods&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#match&#34;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#match-1&#34;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#matchasync&#34;&gt;&lt;code&gt;MatchAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#matchfirst&#34;&gt;&lt;code&gt;MatchFirst&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#matchfirstasync&#34;&gt;&lt;code&gt;MatchFirstAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#switch&#34;&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#switch-1&#34;&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#switchasync&#34;&gt;&lt;code&gt;SwitchAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#switchfirst&#34;&gt;&lt;code&gt;SwitchFirst&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#switchfirstasync&#34;&gt;&lt;code&gt;SwitchFirstAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#then&#34;&gt;&lt;code&gt;Then&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#then-1&#34;&gt;&lt;code&gt;Then&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#thenasync&#34;&gt;&lt;code&gt;ThenAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#thendo-and-thendoasync&#34;&gt;&lt;code&gt;ThenDo&lt;/code&gt; and &lt;code&gt;ThenDoAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#mixing-then-thendo-thenasync-thendoasync&#34;&gt;Mixing &lt;code&gt;Then&lt;/code&gt;, &lt;code&gt;ThenDo&lt;/code&gt;, &lt;code&gt;ThenAsync&lt;/code&gt;, &lt;code&gt;ThenDoAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#failif&#34;&gt;&lt;code&gt;FailIf&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#else&#34;&gt;&lt;code&gt;Else&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#else-1&#34;&gt;&lt;code&gt;Else&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#elseasync&#34;&gt;&lt;code&gt;ElseAsync&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#mixing-features-then-failif-else-switch-match&#34;&gt;Mixing Features (&lt;code&gt;Then&lt;/code&gt;, &lt;code&gt;FailIf&lt;/code&gt;, &lt;code&gt;Else&lt;/code&gt;, &lt;code&gt;Switch&lt;/code&gt;, &lt;code&gt;Match&lt;/code&gt;)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#error-types&#34;&gt;Error Types&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#built-in-error-types&#34;&gt;Built in error types&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#custom-error-types&#34;&gt;Custom error types&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#built-in-result-types-resultsuccess-&#34;&gt;Built in result types (&lt;code&gt;Result.Success&lt;/code&gt;, ..)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#organizing-errors&#34;&gt;Organizing Errors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#mediator--fluentvalidation--erroror-&#34;&gt;Mediator + FluentValidation + &lt;code&gt;ErrorOr&lt;/code&gt; ü§ù&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#contribution-&#34;&gt;Contribution ü§≤&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#credits-&#34;&gt;Credits üôè&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#license-&#34;&gt;License ü™™&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Give it a star ‚≠ê!&lt;/h1&gt; &#xA;&lt;p&gt;Loving it? Show your support by giving this project a star!&lt;/p&gt; &#xA;&lt;h1&gt;Getting Started üèÉ&lt;/h1&gt; &#xA;&lt;h2&gt;Replace throwing exceptions with &lt;code&gt;ErrorOr&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public float Divide(int a, int b)&#xA;{&#xA;    if (b == 0)&#xA;    {&#xA;        throw new Exception(&#34;Cannot divide by zero&#34;);&#xA;    }&#xA;&#xA;    return a / b;&#xA;}&#xA;&#xA;try&#xA;{&#xA;    var result = Divide(4, 2);&#xA;    Console.WriteLine(result * 2); // 4&#xA;}&#xA;catch (Exception e)&#xA;{&#xA;    Console.WriteLine(e.Message);&#xA;    return;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Turns into this üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;float&amp;gt; Divide(int a, int b)&#xA;{&#xA;    if (b == 0)&#xA;    {&#xA;        return Error.Unexpected(description: &#34;Cannot divide by zero&#34;);&#xA;    }&#xA;&#xA;    return a / b;&#xA;}&#xA;&#xA;var result = Divide(4, 2);&#xA;&#xA;if (result.IsError)&#xA;{&#xA;    Console.WriteLine(result.FirstError.Description);&#xA;    return;&#xA;}&#xA;&#xA;Console.WriteLine(result.Value * 2); // 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, using &lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#then--thenasync&#34;&gt;Then&lt;/a&gt;/&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#else--elseasync&#34;&gt;Else&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#switch--switchasync&#34;&gt;Switch&lt;/a&gt;/&lt;a href=&#34;https://raw.githubusercontent.com/amantinband/error-or/main/#match--matchasync&#34;&gt;Match&lt;/a&gt;, you can do this üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;&#xA;Divide(4, 2)&#xA;    .Then(val =&amp;gt; val * 2)&#xA;    .SwitchFirst(&#xA;        onValue: Console.WriteLine, // 4&#xA;        onFirstError: error =&amp;gt; Console.WriteLine(error.Description));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support For Multiple Errors&lt;/h2&gt; &#xA;&lt;p&gt;Internally, the &lt;code&gt;ErrorOr&lt;/code&gt; object has a list of &lt;code&gt;Error&lt;/code&gt;s, so if you have multiple errors, you don&#39;t need to compromise and have only the first one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public class User(string _name)&#xA;{&#xA;    public static ErrorOr&amp;lt;User&amp;gt; Create(string name)&#xA;    {&#xA;        List&amp;lt;Error&amp;gt; errors = [];&#xA;&#xA;        if (name.Length &amp;lt; 2)&#xA;        {&#xA;            errors.Add(Error.Validation(description: &#34;Name is too short&#34;));&#xA;        }&#xA;&#xA;        if (name.Length &amp;gt; 100)&#xA;        {&#xA;            errors.Add(Error.Validation(description: &#34;Name is too long&#34;));&#xA;        }&#xA;&#xA;        if (string.IsNullOrWhiteSpace(name))&#xA;        {&#xA;            errors.Add(Error.Validation(description: &#34;Name cannot be empty or whitespace only&#34;));&#xA;        }&#xA;&#xA;        if (errors.Count &amp;gt; 0)&#xA;        {&#xA;            return errors;&#xA;        }&#xA;&#xA;        return new User(name);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Various Functional Methods and Extension Methods&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;ErrorOr&lt;/code&gt; object has a variety of methods that allow you to work with it in a functional way.&lt;/p&gt; &#xA;&lt;p&gt;This allows you to chain methods together, and handle the result in a clean and concise way.&lt;/p&gt; &#xA;&lt;h3&gt;Real world example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;return await _userRepository.GetByIdAsync(id)&#xA;    .Then(user =&amp;gt; user.IncrementAge()&#xA;        .Then(success =&amp;gt; user)&#xA;        .Else(errors =&amp;gt; Error.Unexpected(&#34;Not expected to fail&#34;)))&#xA;    .FailIf(user =&amp;gt; !user.IsOverAge(18), UserErrors.UnderAge)&#xA;    .ThenDo(user =&amp;gt; _logger.LogInformation($&#34;User {user.Id} incremented age to {user.Age}&#34;))&#xA;    .ThenAsync(user =&amp;gt; _userRepository.UpdateAsync(user))&#xA;    .Match(&#xA;        _ =&amp;gt; NoContent(),&#xA;        errors =&amp;gt; errors.ToActionResult());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Simple Example with intermediate steps&lt;/h3&gt; &#xA;&lt;h4&gt;No Failure&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await &#34;2&#34;.ToErrorOr()&#xA;    .Then(int.Parse) // 2&#xA;    .FailIf(val =&amp;gt; val &amp;gt; 2, Error.Validation(description: $&#34;{val} is too big&#34;) // 2&#xA;    .ThenDoAsync(Task.Delay) // Sleep for 2 milliseconds&#xA;    .ThenDo(val =&amp;gt; Console.WriteLine($&#34;Finished waiting {val} milliseconds.&#34;)) // Finished waiting 2 milliseconds.&#xA;    .ThenAsync(val =&amp;gt; Task.FromResult(val * 2)) // 4&#xA;    .Then(val =&amp;gt; $&#34;The result is {val}&#34;) // &#34;The result is 4&#34;&#xA;    .Else(errors =&amp;gt; Error.Unexpected(description: &#34;Yikes&#34;)) // &#34;The result is 4&#34;&#xA;    .MatchFirst(&#xA;        value =&amp;gt; value, // &#34;The result is 4&#34;&#xA;        firstError =&amp;gt; $&#34;An error occurred: {firstError.Description}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Failure&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await &#34;5&#34;.ToErrorOr()&#xA;    .Then(int.Parse) // 5&#xA;    .FailIf(val =&amp;gt; val &amp;gt; 2, Error.Validation(description: $&#34;{val} is too big&#34;) // Error.Validation()&#xA;    .ThenDoAsync(Task.Delay) // Error.Validation()&#xA;    .ThenDo(val =&amp;gt; Console.WriteLine($&#34;Finished waiting {val} milliseconds.&#34;)) // Error.Validation()&#xA;    .ThenAsync(val =&amp;gt; Task.FromResult(val * 2)) // Error.Validation()&#xA;    .Then(val =&amp;gt; $&#34;The result is {val}&#34;) // Error.Validation()&#xA;    .Else(errors =&amp;gt; Error.Unexpected(description: &#34;Yikes&#34;)) // Error.Unexpected()&#xA;    .MatchFirst(&#xA;        value =&amp;gt; value,&#xA;        firstError =&amp;gt; $&#34;An error occurred: {firstError.Description}&#34;); // An error occurred: Yikes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Creating an &lt;code&gt;ErrorOr&lt;/code&gt; instance&lt;/h1&gt; &#xA;&lt;h2&gt;Using implicit conversion&lt;/h2&gt; &#xA;&lt;p&gt;There are implicit converters from &lt;code&gt;TResult&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;List&amp;lt;Error&amp;gt;&lt;/code&gt; to &lt;code&gt;ErrorOr&amp;lt;TResult&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = 5;&#xA;ErrorOr&amp;lt;int&amp;gt; result = Error.Unexpected();&#xA;ErrorOr&amp;lt;int&amp;gt; result = [Error.Validation(), Error.Validation()];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;int&amp;gt; IntToErrorOr()&#xA;{&#xA;    return 5;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;int&amp;gt; SingleErrorToErrorOr()&#xA;{&#xA;    return Error.Unexpected();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;int&amp;gt; MultipleErrorsToErrorOr()&#xA;{&#xA;    return [&#xA;        Error.Validation(description: &#34;Invalid Name&#34;),&#xA;        Error.Validation(description: &#34;Invalid Last Name&#34;)&#xA;    ];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using The &lt;code&gt;ErrorOrFactory&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = ErrorOrFactory.From(5);&#xA;ErrorOr&amp;lt;int&amp;gt; result = ErrorOrFactory.From&amp;lt;int&amp;gt;(Error.Unexpected());&#xA;ErrorOr&amp;lt;int&amp;gt; result = ErrorOrFactory.From&amp;lt;int&amp;gt;([Error.Validation(), Error.Validation()]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;int&amp;gt; GetValue()&#xA;{&#xA;    return ErrorOrFactory.From(5);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;int&amp;gt; SingleErrorToErrorOr()&#xA;{&#xA;    return ErrorOrFactory.From&amp;lt;int&amp;gt;(Error.Unexpected());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;int&amp;gt; MultipleErrorsToErrorOr()&#xA;{&#xA;    return ErrorOrFactory.From([&#xA;        Error.Validation(description: &#34;Invalid Name&#34;),&#xA;        Error.Validation(description: &#34;Invalid Last Name&#34;)&#xA;    ]);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using The &lt;code&gt;ToErrorOr&lt;/code&gt; Extension Method&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = 5.ToErrorOr();&#xA;ErrorOr&amp;lt;int&amp;gt; result = Error.Unexpected().ToErrorOr&amp;lt;int&amp;gt;();&#xA;ErrorOr&amp;lt;int&amp;gt; result = new[] { Error.Validation(), Error.Validation() }.ToErrorOr&amp;lt;int&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Properties&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;code&gt;IsError&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = User.Create();&#xA;&#xA;if (result.IsError)&#xA;{&#xA;    // the result contains one or more errors&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;Value&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = User.Create();&#xA;&#xA;if (!result.IsError) // the result contains a value&#xA;{&#xA;    Console.WriteLine(result.Value);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;Errors&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = User.Create();&#xA;&#xA;if (result.IsError)&#xA;{&#xA;    result.Errors // contains the list of errors that occurred&#xA;        .ForEach(error =&amp;gt; Console.WriteLine(error.Description));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;FirstError&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = User.Create();&#xA;&#xA;if (result.IsError)&#xA;{&#xA;    var firstError = result.FirstError; // only the first error that occurred&#xA;    Console.WriteLine(firstError == result.Errors[0]); // true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;ErrorsOrEmptyList&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; result = User.Create();&#xA;&#xA;if (result.IsError)&#xA;{&#xA;    result.ErrorsOrEmptyList // List&amp;lt;Error&amp;gt; { /* one or more errors */  }&#xA;    return;&#xA;}&#xA;&#xA;result.ErrorsOrEmptyList // List&amp;lt;Error&amp;gt; { }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Methods&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Match&lt;/code&gt; method receives two functions, &lt;code&gt;onValue&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;, &lt;code&gt;onValue&lt;/code&gt; will be invoked if the result is success, and &lt;code&gt;onError&lt;/code&gt; is invoked if the result is an error.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;string foo = result.Match(&#xA;    value =&amp;gt; value,&#xA;    errors =&amp;gt; $&#34;{errors.Count} errors occurred.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;MatchAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;string foo = await result.MatchAsync(&#xA;    value =&amp;gt; Task.FromResult(value),&#xA;    errors =&amp;gt; Task.FromResult($&#34;{errors.Count} errors occurred.&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;MatchFirst&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;MatchFirst&lt;/code&gt; method receives two functions, &lt;code&gt;onValue&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;, &lt;code&gt;onValue&lt;/code&gt; will be invoked if the result is success, and &lt;code&gt;onError&lt;/code&gt; is invoked if the result is an error.&lt;/p&gt; &#xA;&lt;p&gt;Unlike &lt;code&gt;Match&lt;/code&gt;, if the state is error, &lt;code&gt;MatchFirst&lt;/code&gt;&#39;s &lt;code&gt;onError&lt;/code&gt; function receives only the first error that occurred, not the entire list of errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;string foo = result.MatchFirst(&#xA;    value =&amp;gt; value,&#xA;    firstError =&amp;gt; firstError.Description);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;MatchFirstAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;string foo = await result.MatchFirstAsync(&#xA;    value =&amp;gt; Task.FromResult(value),&#xA;    firstError =&amp;gt; Task.FromResult(firstError.Description));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Switch&lt;/code&gt; method receives two actions, &lt;code&gt;onValue&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;, &lt;code&gt;onValue&lt;/code&gt; will be invoked if the result is success, and &lt;code&gt;onError&lt;/code&gt; is invoked if the result is an error.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;result.Switch(&#xA;    value =&amp;gt; Console.WriteLine(value),&#xA;    errors =&amp;gt; Console.WriteLine($&#34;{errors.Count} errors occurred.&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;SwitchAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;await result.SwitchAsync(&#xA;    value =&amp;gt; { Console.WriteLine(value); return Task.CompletedTask; },&#xA;    errors =&amp;gt; { Console.WriteLine($&#34;{errors.Count} errors occurred.&#34;); return Task.CompletedTask; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;SwitchFirst&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;SwitchFirst&lt;/code&gt; method receives two actions, &lt;code&gt;onValue&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;, &lt;code&gt;onValue&lt;/code&gt; will be invoked if the result is success, and &lt;code&gt;onError&lt;/code&gt; is invoked if the result is an error.&lt;/p&gt; &#xA;&lt;p&gt;Unlike &lt;code&gt;Switch&lt;/code&gt;, if the state is error, &lt;code&gt;SwitchFirst&lt;/code&gt;&#39;s &lt;code&gt;onError&lt;/code&gt; function receives only the first error that occurred, not the entire list of errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;result.SwitchFirst(&#xA;    value =&amp;gt; Console.WriteLine(value),&#xA;    firstError =&amp;gt; Console.WriteLine(firstError.Description));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;SwitchFirstAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;await result.SwitchFirstAsync(&#xA;    value =&amp;gt; { Console.WriteLine(value); return Task.CompletedTask; },&#xA;    firstError =&amp;gt; { Console.WriteLine(firstError.Description); return Task.CompletedTask; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;Then&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;Then&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Then&lt;/code&gt; receives a function, and invokes it only if the result is not an error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; foo = result&#xA;    .Then(val =&amp;gt; val * 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multiple &lt;code&gt;Then&lt;/code&gt; methods can be chained together.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = result&#xA;    .Then(val =&amp;gt; val * 2)&#xA;    .Then(val =&amp;gt; $&#34;The result is {val}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If any of the methods return an error, the chain will break and the errors will be returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; Foo() =&amp;gt; Error.Unexpected();&#xA;&#xA;ErrorOr&amp;lt;string&amp;gt; foo = result&#xA;    .Then(val =&amp;gt; val * 2)&#xA;    .Then(_ =&amp;gt; GetAnError())&#xA;    .Then(val =&amp;gt; $&#34;The result is {val}&#34;) // this function will not be invoked&#xA;    .Then(val =&amp;gt; $&#34;The result is {val}&#34;); // this function will not be invoked&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;ThenAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ThenAsync&lt;/code&gt; receives an asynchronous function, and invokes it only if the result is not an error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await result&#xA;    .ThenAsync(val =&amp;gt; DoSomethingAsync(val))&#xA;    .ThenAsync(val =&amp;gt; DoSomethingElseAsync($&#34;The result is {val}&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;ThenDo&lt;/code&gt; and &lt;code&gt;ThenDoAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ThenDo&lt;/code&gt; and &lt;code&gt;ThenDoAsync&lt;/code&gt; are similar to &lt;code&gt;Then&lt;/code&gt; and &lt;code&gt;ThenAsync&lt;/code&gt;, but instead of invoking a function that returns a value, they invoke an action.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = result&#xA;    .ThenDo(val =&amp;gt; Console.WriteLine(val))&#xA;    .ThenDo(val =&amp;gt; Console.WriteLine($&#34;The result is {val}&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await result&#xA;    .ThenDoAsync(val =&amp;gt; Task.Delay(val))&#xA;    .ThenDo(val =&amp;gt; Console.WriteLine($&#34;Finsihed waiting {val} seconds.&#34;))&#xA;    .ThenDoAsync(val =&amp;gt; Task.FromResult(val * 2))&#xA;    .ThenDo(val =&amp;gt; $&#34;The result is {val}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mixing &lt;code&gt;Then&lt;/code&gt;, &lt;code&gt;ThenDo&lt;/code&gt;, &lt;code&gt;ThenAsync&lt;/code&gt;, &lt;code&gt;ThenDoAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can mix and match &lt;code&gt;Then&lt;/code&gt;, &lt;code&gt;ThenDo&lt;/code&gt;, &lt;code&gt;ThenAsync&lt;/code&gt;, &lt;code&gt;ThenDoAsync&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await result&#xA;    .ThenDoAsync(val =&amp;gt; Task.Delay(val))&#xA;    .Then(val =&amp;gt; val * 2)&#xA;    .ThenAsync(val =&amp;gt; DoSomethingAsync(val))&#xA;    .ThenDo(val =&amp;gt; Console.WriteLine($&#34;Finsihed waiting {val} seconds.&#34;))&#xA;    .ThenAsync(val =&amp;gt; Task.FromResult(val * 2))&#xA;    .Then(val =&amp;gt; $&#34;The result is {val}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;FailIf&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;FailIf&lt;/code&gt; receives a predicate and an error. If the predicate is true, &lt;code&gt;FailIf&lt;/code&gt; will return the error. Otherwise, it will return the value of the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;int&amp;gt; foo = result&#xA;    .FailIf(val =&amp;gt; val &amp;gt; 2, Error.Validation(description: $&#34;{val} is too big&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once an error is returned, the chain will break and the error will be returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var result = &#34;2&#34;.ToErrorOr()&#xA;    .Then(int.Parse) // 2&#xA;    .FailIf(val =&amp;gt; val &amp;gt; 1, Error.Validation(description: $&#34;{val} is too big&#34;) // validation error&#xA;    .Then(num =&amp;gt; num * 2) // this function will not be invoked&#xA;    .Then(num =&amp;gt; num * 2) // this function will not be invoked&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;Else&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Else&lt;/code&gt; receives a value or a function. If the result is an error, &lt;code&gt;Else&lt;/code&gt; will return the value or invoke the function. Otherwise, it will return the value of the result.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Else&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = result&#xA;    .Else(&#34;fallback value&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = result&#xA;    .Else(errors =&amp;gt; $&#34;{errors.Count} errors occurred.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;ElseAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await result&#xA;    .ElseAsync(Task.FromResult(&#34;fallback value&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await result&#xA;    .ElseAsync(errors =&amp;gt; Task.FromResult($&#34;{errors.Count} errors occurred.&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Mixing Features (&lt;code&gt;Then&lt;/code&gt;, &lt;code&gt;FailIf&lt;/code&gt;, &lt;code&gt;Else&lt;/code&gt;, &lt;code&gt;Switch&lt;/code&gt;, &lt;code&gt;Match&lt;/code&gt;)&lt;/h1&gt; &#xA;&lt;p&gt;You can mix &lt;code&gt;Then&lt;/code&gt;, &lt;code&gt;FailIf&lt;/code&gt;, &lt;code&gt;Else&lt;/code&gt;, &lt;code&gt;Switch&lt;/code&gt; and &lt;code&gt;Match&lt;/code&gt; methods together.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;string&amp;gt; foo = await result&#xA;    .ThenDoAsync(val =&amp;gt; Task.Delay(val))&#xA;    .FailIf(val =&amp;gt; val &amp;gt; 2, Error.Validation(description: $&#34;{val} is too big&#34;))&#xA;    .ThenDo(val =&amp;gt; Console.WriteLine($&#34;Finished waiting {val} seconds.&#34;))&#xA;    .ThenAsync(val =&amp;gt; Task.FromResult(val * 2))&#xA;    .Then(val =&amp;gt; $&#34;The result is {val}&#34;)&#xA;    .Else(errors =&amp;gt; Error.Unexpected())&#xA;    .MatchFirst(&#xA;        value =&amp;gt; value,&#xA;        firstError =&amp;gt; $&#34;An error occurred: {firstError.Description}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Error Types&lt;/h1&gt; &#xA;&lt;p&gt;Each &lt;code&gt;Error&lt;/code&gt; instance has a &lt;code&gt;Type&lt;/code&gt; property, which is an enum value that represents the type of the error.&lt;/p&gt; &#xA;&lt;h2&gt;Built in error types&lt;/h2&gt; &#xA;&lt;p&gt;The following error types are built in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public enum ErrorType&#xA;{&#xA;    Failure,&#xA;    Unexpected,&#xA;    Validation,&#xA;    Conflict,&#xA;    NotFound,&#xA;    Unauthorized,&#xA;    Forbidden,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each error type has a static method that creates an error of that type. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var error = Error.NotFound();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;optionally, you can pass a code, description and metadata to the error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var error = Error.Unexpected(&#xA;    code: &#34;User.ShouldNeverHappen&#34;,&#xA;    description: &#34;A user error that should never happen&#34;,&#xA;    metadata: new Dictionary&amp;lt;string, object&amp;gt;&#xA;    {&#xA;        { &#34;user&#34;, user },&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;ErrorType&lt;/code&gt; enum is a good way to categorize errors.&lt;/p&gt; &#xA;&lt;h2&gt;Custom error types&lt;/h2&gt; &#xA;&lt;p&gt;You can create your own error types if you would like to categorize your errors differently.&lt;/p&gt; &#xA;&lt;p&gt;A custom error type can be created with the &lt;code&gt;Custom&lt;/code&gt; static method&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public static class MyErrorTypes&#xA;{&#xA;    const int ShouldNeverHappen = 12;&#xA;}&#xA;&#xA;var error = Error.Custom(&#xA;    type: MyErrorTypes.ShouldNeverHappen,&#xA;    code: &#34;User.ShouldNeverHappen&#34;,&#xA;    description: &#34;A user error that should never happen&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;Error.NumericType&lt;/code&gt; method to retrieve the numeric type of the error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var errorMessage = Error.NumericType switch&#xA;{&#xA;    MyErrorType.ShouldNeverHappen =&amp;gt; &#34;Consider replacing dev team&#34;,&#xA;    _ =&amp;gt; &#34;An unknown error occurred.&#34;,&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Built in result types (&lt;code&gt;Result.Success&lt;/code&gt;, ..)&lt;/h1&gt; &#xA;&lt;p&gt;There are a few built in result types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;Success&amp;gt; result = Result.Success;&#xA;ErrorOr&amp;lt;Created&amp;gt; result = Result.Created;&#xA;ErrorOr&amp;lt;Updated&amp;gt; result = Result.Updated;&#xA;ErrorOr&amp;lt;Deleted&amp;gt; result = Result.Deleted;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which can be used as following&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ErrorOr&amp;lt;Deleted&amp;gt; DeleteUser(Guid id)&#xA;{&#xA;    var user = await _userRepository.GetByIdAsync(id);&#xA;    if (user is null)&#xA;    {&#xA;        return Error.NotFound(description: &#34;User not found.&#34;);&#xA;    }&#xA;&#xA;    await _userRepository.DeleteAsync(user);&#xA;    return Result.Deleted;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Organizing Errors&lt;/h1&gt; &#xA;&lt;p&gt;A nice approach, is creating a static class with the expected errors. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public static partial class DivisionErrors&#xA;{&#xA;    public static Error CannotDivideByZero = Error.Unexpected(&#xA;        code: &#34;Division.CannotDivideByZero&#34;,&#xA;        description: &#34;Cannot divide by zero.&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which can later be used as following üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public ErrorOr&amp;lt;float&amp;gt; Divide(int a, int b)&#xA;{&#xA;    if (b == 0)&#xA;    {&#xA;        return DivisionErrors.CannotDivideByZero;&#xA;    }&#xA;&#xA;    return a / b;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://github.com/jbogard/MediatR&#34;&gt;Mediator&lt;/a&gt; + &lt;a href=&#34;https://github.com/FluentValidation/FluentValidation&#34;&gt;FluentValidation&lt;/a&gt; + &lt;code&gt;ErrorOr&lt;/code&gt; ü§ù&lt;/h1&gt; &#xA;&lt;p&gt;A common approach when using &lt;code&gt;MediatR&lt;/code&gt; is to use &lt;code&gt;FluentValidation&lt;/code&gt; to validate the request before it reaches the handler.&lt;/p&gt; &#xA;&lt;p&gt;Usually, the validation is done using a &lt;code&gt;Behavior&lt;/code&gt; that throws an exception if the request is invalid.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;ErrorOr&lt;/code&gt;, we can create a &lt;code&gt;Behavior&lt;/code&gt; that returns an error instead of throwing an exception.&lt;/p&gt; &#xA;&lt;p&gt;This plays nicely when the project uses &lt;code&gt;ErrorOr&lt;/code&gt;, as the layer invoking the &lt;code&gt;Mediator&lt;/code&gt;, similar to other components in the project, simply receives an &lt;code&gt;ErrorOr&lt;/code&gt; and can handle it accordingly.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of a &lt;code&gt;Behavior&lt;/code&gt; that validates the request and returns an error if it&#39;s invalid üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public class ValidationBehavior&amp;lt;TRequest, TResponse&amp;gt;(IValidator&amp;lt;TRequest&amp;gt;? validator = null)&#xA;    : IPipelineBehavior&amp;lt;TRequest, TResponse&amp;gt;&#xA;        where TRequest : IRequest&amp;lt;TResponse&amp;gt;&#xA;        where TResponse : IErrorOr&#xA;{&#xA;    private readonly IValidator&amp;lt;TRequest&amp;gt;? _validator = validator;&#xA;&#xA;    public async Task&amp;lt;TResponse&amp;gt; Handle(&#xA;        TRequest request,&#xA;        RequestHandlerDelegate&amp;lt;TResponse&amp;gt; next,&#xA;        CancellationToken cancellationToken)&#xA;    {&#xA;        if (_validator is null)&#xA;        {&#xA;            return await next();&#xA;        }&#xA;&#xA;        var validationResult = await _validator.ValidateAsync(request, cancellationToken);&#xA;&#xA;        if (validationResult.IsValid)&#xA;        {&#xA;            return await next();&#xA;        }&#xA;&#xA;        var errors = validationResult.Errors&#xA;            .ConvertAll(error =&amp;gt; Error.Validation(&#xA;                code: error.PropertyName,&#xA;                description: error.ErrorMessage));&#xA;&#xA;        return (dynamic)errors;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Contribution ü§≤&lt;/h1&gt; &#xA;&lt;p&gt;If you have any questions, comments, or suggestions, please open an issue or create a pull request üôÇ&lt;/p&gt; &#xA;&lt;h1&gt;Credits üôè&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mcintyre321/OneOf/tree/master/OneOf&#34;&gt;OneOf&lt;/a&gt; - An awesome library which provides F# style discriminated unions behavior for C#&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License ü™™&lt;/h1&gt; &#xA;&lt;p&gt;This project is licensed under the terms of the &lt;a href=&#34;https://github.com/mantinband/error-or/raw/main/LICENSE&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;</summary>
  </entry>
</feed>