<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-23T01:30:32Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Humanizr/Humanizer</title>
    <updated>2022-12-23T01:30:32Z</updated>
    <id>tag:github.com,2022-12-23:/Humanizr/Humanizer</id>
    <link href="https://github.com/Humanizr/Humanizer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Humanizer meets all your .NET needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.github.com/Humanizr/Humanizer/master/logo.png&#34; alt=&#34;Logo&#34; style=&#34;max-width:100%;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dotnetfoundation.org/projects?type=project&amp;amp;q=humanizer&#34;&gt;&lt;img align=&#34;right&#34; width=&#34;100px&#34; src=&#34;https://dotnetfoundation.org/img/logo_big.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Humanizer meets all your .NET needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities. It is part of the &lt;a href=&#34;https://www.dotnetfoundation.org/&#34;&gt;.NET Foundation&lt;/a&gt;, and operates under their &lt;a href=&#34;https://www.dotnetfoundation.org/code-of-conduct&#34;&gt;code of conduct&lt;/a&gt;. It is licensed under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT&lt;/a&gt; (an OSI approved license).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/Humanizr/Humanizer&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/Humanizr/Humanizer&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Table of contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#install&#34;&gt;Install&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#specify-lang&#34;&gt;Specifying Languages (Optional)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#known-issues&#34;&gt;Known Installation Issues&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#aspnet4mvc&#34;&gt;Use in ASP.NET 4.x MVC Views&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#features&#34;&gt;Features&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanize-string&#34;&gt;Humanize String&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#dehumanize-string&#34;&gt;Dehumanize String&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#transform-string&#34;&gt;Transform String&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#truncate-string&#34;&gt;Truncate String&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#format-string&#34;&gt;Format String&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanize-enums&#34;&gt;Humanize Enums&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#dehumanize-enums&#34;&gt;Dehumanize Enums&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanize-datetime&#34;&gt;Humanize DateTime&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanize-timespan&#34;&gt;Humanize TimeSpan&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanize-collections&#34;&gt;Humanize Collections&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#inflector-methods&#34;&gt;Inflector methods&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#pluralize&#34;&gt;Pluralize&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#singularize&#34;&gt;Singularize&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#adding-words&#34;&gt;Adding Words&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#toquantity&#34;&gt;ToQuantity&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#ordinalize&#34;&gt;Ordinalize&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#titleize&#34;&gt;Titleize&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#pascalize&#34;&gt;Pascalize&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#camelize&#34;&gt;Camelize&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#underscore&#34;&gt;Underscore&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#dasherize--hyphenate&#34;&gt;Dasherize &amp;amp; Hyphenate&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#kebaberize&#34;&gt;Kebaberize&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#fluent-date&#34;&gt;Fluent date&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#number-to-numbers&#34;&gt;Number to Numbers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#number-to-words&#34;&gt;Number to words&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#number-to-ordinal-words&#34;&gt;Number to ordinal words&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#date-time-to-ordinal-words&#34;&gt;DateTime to ordinal words&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#time-only-to-clock-notation&#34;&gt;TimeOnly to Clock Notation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#roman-numerals&#34;&gt;Roman numerals&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#metric-numerals&#34;&gt;Metric numerals&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#bytesize&#34;&gt;ByteSize&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#heading-to-words&#34;&gt;Heading to words&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#tupleize&#34;&gt;Tupleize&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#timeunit-to-symbol&#34;&gt;Time unit to symbol&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#mix-this-into-your-framework-to-simplify-your-life&#34;&gt;Mix this into your framework to simplify your life&lt;/a&gt; -&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#how-to-contribute&#34;&gt;How to contribute?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#continuous-integration&#34;&gt;Continuous Integration from AppVeyor&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#related-projects&#34;&gt;Related Projects&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanizer-resharper-annotations&#34;&gt;Humanizer ReSharper Annotations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#powershell-humanizer&#34;&gt;PowerShell Humanizer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanizerjvm&#34;&gt;Humanizer JVM&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#humanizernode&#34;&gt;Humanizer.node&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#main-contributors&#34;&gt;Main contributors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Humanizr/Humanizer/main/#icon&#34;&gt;Icon&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;install&#34;&gt;Install&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You can install Humanizer as &lt;a href=&#34;https://nuget.org/packages/Humanizer&#34;&gt;a nuget package&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;English only&lt;/strong&gt;: &lt;code&gt;Humanizer.Core&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;All languages: &lt;code&gt;Humanizer&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Humanizer is a .NET Standard Class Library with support for .NET Standard 1.0+ (.Net 4.5+, UWP, Xamarin, and .NET Core).&lt;/p&gt; &#xA;&lt;p&gt;Also Humanizer symbols are source indexed with &lt;a href=&#34;https://github.com/dotnet/sourcelink&#34;&gt;SourceLink&lt;/a&gt; and are included in the package so you can step through Humanizer code while debugging your code.&lt;/p&gt; &#xA;&lt;p&gt;For pre-release builds, &lt;a href=&#34;https://dev.azure.com/dotnet/Humanizer/_packaging?_a=feed&amp;amp;feed=Humanizer&#34;&gt;Azure Artifacts feed&lt;/a&gt; is available where you can pull down CI packages from the latest codebase. The feed URL is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dev.azure.com/dotnet/Humanizer/_packaging?_a=package&amp;amp;feed=b39738c7-8e60-4bfb-825f-29c47261a5cc&amp;amp;package=db81f806-d0b5-43a3-99f4-3d27606376b8&amp;amp;preferRelease=true&#34;&gt;&lt;img src=&#34;https://feeds.dev.azure.com/dotnet/5829eea4-55e5-4a15-ba8d-1de5daaafcea/_apis/public/Packaging/Feeds/b39738c7-8e60-4bfb-825f-29c47261a5cc/Packages/db81f806-d0b5-43a3-99f4-3d27606376b8/Badge&#34; alt=&#34;Humanizer package in Humanizer feed in Azure Artifacts&#34;&gt;&lt;/a&gt; &lt;code&gt;https://pkgs.dev.azure.com/dotnet/Humanizer/_packaging/Humanizer/nuget/v3/index.json&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;specify-lang&#34;&gt;Specify Languages (Optional)&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;New in Humanizer 2.0 is the option to choose which localization packages you wish to use. You choose which packages based on what NuGet package(s) you install. By default, the main &lt;code&gt;Humanizer&lt;/code&gt; 2.0 package installs all supported languages exactly like it does in 1.x. If you&#39;re not sure, then just use the main &lt;code&gt;Humanizer&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;p&gt;Here are the options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;All languages&lt;/strong&gt;: use the main &lt;code&gt;Humanizer&lt;/code&gt; package. This pulls in &lt;code&gt;Humanizer.Core&lt;/code&gt; and all language packages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;English&lt;/strong&gt;: use the &lt;code&gt;Humanizer.Core&lt;/code&gt; package. Only the English language resources will be available&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Specific languages&lt;/strong&gt;: Use the language specific packages you&#39;d like. For example for French, use &lt;code&gt;Humanizer.Core.fr&lt;/code&gt;. You can include multiple languages by installing however many language packages you want.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The detailed explanation for how this works is in the comments &lt;a href=&#34;https://github.com/Humanizr/Humanizer/issues/59#issuecomment-152546079&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;features&#34;&gt;Features&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanize-string&#34;&gt;Humanize String&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Humanize&lt;/code&gt; string extensions allow you turn an otherwise computerized string into a more readable human-friendly one. The foundation of this was set in the &lt;a href=&#34;https://github.com/TestStack/TestStack.BDDfy&#34;&gt;BDDfy framework&lt;/a&gt; where class names, method names and properties are turned into human readable sentences.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;PascalCaseInputStringIsTurnedIntoSentence&#34;.Humanize() =&amp;gt; &#34;Pascal case input string is turned into sentence&#34;&#xA;&#xA;&#34;Underscored_input_string_is_turned_into_sentence&#34;.Humanize() =&amp;gt; &#34;Underscored input string is turned into sentence&#34;&#xA;&#xA;&#34;Underscored_input_String_is_turned_INTO_sentence&#34;.Humanize() =&amp;gt; &#34;Underscored input String is turned INTO sentence&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that a string that contains only upper case letters, and consists only of one word, is always treated as an acronym (regardless of its length). To guarantee that any arbitrary string will always be humanized you must use a transform (see &lt;code&gt;Transform&lt;/code&gt; method below):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// acronyms are left intact&#xA;&#34;HTML&#34;.Humanize() =&amp;gt; &#34;HTML&#34;&#xA;&#xA;// any unbroken upper case string is treated as an acronym&#xA;&#34;HUMANIZER&#34;.Humanize() =&amp;gt; &#34;HUMANIZER&#34;&#xA;&#34;HUMANIZER&#34;.Transform(To.LowerCase, To.TitleCase) =&amp;gt; &#34;Humanizer&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also specify the desired letter casing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;CanReturnTitleCase&#34;.Humanize(LetterCasing.Title) =&amp;gt; &#34;Can Return Title Case&#34;&#xA;&#xA;&#34;Can_return_title_Case&#34;.Humanize(LetterCasing.Title) =&amp;gt; &#34;Can Return Title Case&#34;&#xA;&#xA;&#34;CanReturnLowerCase&#34;.Humanize(LetterCasing.LowerCase) =&amp;gt; &#34;can return lower case&#34;&#xA;&#xA;&#34;CanHumanizeIntoUpperCase&#34;.Humanize(LetterCasing.AllCaps) =&amp;gt; &#34;CAN HUMANIZE INTO UPPER CASE&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;LetterCasing&lt;/code&gt; API and the methods accepting it are legacy from V0.2 era and will be deprecated in the future. Instead of that, you can use &lt;code&gt;Transform&lt;/code&gt; method explained below.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;dehumanize-string&#34;&gt;Dehumanize String&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Much like you can humanize a computer friendly into human friendly string you can dehumanize a human friendly string into a computer friendly one:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Pascal case input string is turned into sentence&#34;.Dehumanize() =&amp;gt; &#34;PascalCaseInputStringIsTurnedIntoSentence&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;transform-string&#34;&gt;Transform String&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;There is a &lt;code&gt;Transform&lt;/code&gt; method that supersedes &lt;code&gt;LetterCasing&lt;/code&gt;, &lt;code&gt;ApplyCase&lt;/code&gt; and &lt;code&gt;Humanize&lt;/code&gt; overloads that accept &lt;code&gt;LetterCasing&lt;/code&gt;. Transform method signature is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;string Transform(this string input, params IStringTransformer[] transformers)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And there are some out of the box implementations of &lt;code&gt;IStringTransformer&lt;/code&gt; for letter casing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Sentence casing&#34;.Transform(To.LowerCase) =&amp;gt; &#34;sentence casing&#34;&#xA;&#34;Sentence casing&#34;.Transform(To.SentenceCase) =&amp;gt; &#34;Sentence casing&#34;&#xA;&#34;Sentence casing&#34;.Transform(To.TitleCase) =&amp;gt; &#34;Sentence Casing&#34;&#xA;&#34;Sentence casing&#34;.Transform(To.UpperCase) =&amp;gt; &#34;SENTENCE CASING&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;LowerCase&lt;/code&gt; is a public static property on &lt;code&gt;To&lt;/code&gt; class that returns an instance of private &lt;code&gt;ToLowerCase&lt;/code&gt; class that implements &lt;code&gt;IStringTransformer&lt;/code&gt; and knows how to turn a string into lower case.&lt;/p&gt; &#xA;&lt;p&gt;The benefit of using &lt;code&gt;Transform&lt;/code&gt; and &lt;code&gt;IStringTransformer&lt;/code&gt; over &lt;code&gt;ApplyCase&lt;/code&gt; and &lt;code&gt;LetterCasing&lt;/code&gt; is that &lt;code&gt;LetterCasing&lt;/code&gt; is an enum and you&#39;re limited to use what&#39;s in the framework while &lt;code&gt;IStringTransformer&lt;/code&gt; is an interface you can implement in your codebase once and use it with &lt;code&gt;Transform&lt;/code&gt; method allowing for easy extension.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;truncate-string&#34;&gt;Truncate String&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can truncate a &lt;code&gt;string&lt;/code&gt; using the &lt;code&gt;Truncate&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#34;Long text to truncate&#34;.Truncate(10) =&amp;gt; &#34;Long text…&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default the &lt;code&gt;&#39;…&#39;&lt;/code&gt; character is used to truncate strings. The advantage of using the &lt;code&gt;&#39;…&#39;&lt;/code&gt; character instead of &lt;code&gt;&#34;...&#34;&lt;/code&gt; is that the former only takes a single character and thus allows more text to be shown before truncation. If you want, you can also provide your own truncation string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#34;Long text to truncate&#34;.Truncate(10, &#34;---&#34;) =&amp;gt; &#34;Long te---&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default truncation strategy, &lt;code&gt;Truncator.FixedLength&lt;/code&gt;, is to truncate the input string to a specific length, including the truncation string length. There are two more truncator strategies available: one for a fixed number of (alpha-numerical) characters and one for a fixed number of words. To use a specific truncator when truncating, the two &lt;code&gt;Truncate&lt;/code&gt; methods shown in the previous examples all have an overload that allow you to specify the &lt;code&gt;ITruncator&lt;/code&gt; instance to use for the truncation. Here are examples on how to use the three provided truncators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#34;Long text to truncate&#34;.Truncate(10, Truncator.FixedLength) =&amp;gt; &#34;Long text…&#34;&#xA;&#34;Long text to truncate&#34;.Truncate(10, &#34;---&#34;, Truncator.FixedLength) =&amp;gt; &#34;Long te---&#34;&#xA;&#xA;&#34;Long text to truncate&#34;.Truncate(6, Truncator.FixedNumberOfCharacters) =&amp;gt; &#34;Long t…&#34;&#xA;&#34;Long text to truncate&#34;.Truncate(6, &#34;---&#34;, Truncator.FixedNumberOfCharacters) =&amp;gt; &#34;Lon---&#34;&#xA;&#xA;&#34;Long text to truncate&#34;.Truncate(2, Truncator.FixedNumberOfWords) =&amp;gt; &#34;Long text…&#34;&#xA;&#34;Long text to truncate&#34;.Truncate(2, &#34;---&#34;, Truncator.FixedNumberOfWords) =&amp;gt; &#34;Long text---&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you can also use create your own truncator by implementing the &lt;code&gt;ITruncator&lt;/code&gt; interface.&lt;/p&gt; &#xA;&lt;p&gt;There is also an option to choose whether to truncate the string from the beginning (&lt;code&gt;TruncateFrom.Left&lt;/code&gt;) or the end (&lt;code&gt;TruncateFrom.Right&lt;/code&gt;). Default is the right as shown in the examples above. The examples below show how to truncate from the beginning of the string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#34;Long text to truncate&#34;.Truncate(10, Truncator.FixedLength, TruncateFrom.Left) =&amp;gt; &#34;… truncate&#34;&#xA;&#34;Long text to truncate&#34;.Truncate(10, &#34;---&#34;, Truncator.FixedLength, TruncateFrom.Left) =&amp;gt; &#34;---runcate&#34;&#xA;&#xA;&#34;Long text to truncate&#34;.Truncate(10, Truncator.FixedNumberOfCharacters, TruncateFrom.Left) =&amp;gt; &#34;…o truncate&#34;&#xA;&#34;Long text to truncate&#34;.Truncate(16, &#34;---&#34;, Truncator.FixedNumberOfCharacters, TruncateFrom.Left) =&amp;gt; &#34;---ext to truncate&#34;&#xA;&#xA;&#34;Long text to truncate&#34;.Truncate(2, Truncator.FixedNumberOfWords, TruncateFrom.Left) =&amp;gt; &#34;…to truncate&#34;&#xA;&#34;Long text to truncate&#34;.Truncate(2, &#34;---&#34;, Truncator.FixedNumberOfWords, TruncateFrom.Left) =&amp;gt; &#34;---to truncate&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;format-string&#34;&gt;Format String&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can format a &lt;code&gt;string&lt;/code&gt; using the &lt;code&gt;FormatWith()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#34;To be formatted -&amp;gt; {0}/{1}.&#34;.FormatWith(1, &#34;A&#34;) =&amp;gt; &#34;To be formatted -&amp;gt; 1/A.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an extension method based on &lt;code&gt;String.Format&lt;/code&gt;, so exact rules applies to it. If &lt;code&gt;format&lt;/code&gt; is null, it&#39;ll throw &lt;code&gt;ArgumentNullException&lt;/code&gt;. If passed a fewer number for arguments, it&#39;ll throw &lt;code&gt;String.FormatException&lt;/code&gt; exception.&lt;/p&gt; &#xA;&lt;p&gt;You also can specify the culture to use explicitly as the first parameter for the &lt;code&gt;FormatWith()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#34;{0:N2}&#34;.FormatWith(new CultureInfo(&#34;ru-RU&#34;), 6666.66) =&amp;gt; &#34;6 666,66&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If a culture is not specified, current thread&#39;s current culture is used.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanize-enums&#34;&gt;Humanize Enums&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;ToString&lt;/code&gt; directly on enum members usually results in less than ideal output for users. The solution to this is usually to use &lt;code&gt;DescriptionAttribute&lt;/code&gt; data annotation and then read that at runtime to get a more friendly output. That is a great solution; but more often than not we only need to put some space between words of an enum member - which is what &lt;code&gt;String.Humanize()&lt;/code&gt; does well. For an enum like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public enum EnumUnderTest&#xA;{&#xA;    [Description(&#34;Custom description&#34;)]&#xA;    MemberWithDescriptionAttribute,&#xA;    MemberWithoutDescriptionAttribute,&#xA;    ALLCAPITALS&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// DescriptionAttribute is honored&#xA;EnumUnderTest.MemberWithDescriptionAttribute.Humanize() =&amp;gt; &#34;Custom description&#34;&#xA;&#xA;// In the absence of Description attribute string.Humanizer kicks in&#xA;EnumUnderTest.MemberWithoutDescriptionAttribute.Humanize() =&amp;gt; &#34;Member without description attribute&#34;&#xA;&#xA;// Of course you can still apply letter casing&#xA;EnumUnderTest.MemberWithoutDescriptionAttribute.Humanize().Transform(To.TitleCase) =&amp;gt; &#34;Member Without Description Attribute&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You are not limited to &lt;code&gt;DescriptionAttribute&lt;/code&gt; for custom description. Any attribute applied on enum members with a &lt;code&gt;string Description&lt;/code&gt; property counts. This is to help with platforms with missing &lt;code&gt;DescriptionAttribute&lt;/code&gt; and also for allowing subclasses of the &lt;code&gt;DescriptionAttribute&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can even configure the name of the property of attibute to use as description.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Configurator.EnumDescriptionPropertyLocator = p =&amp;gt; p.Name == &#34;Info&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you need to provide localised descriptions you can use &lt;code&gt;DisplayAttribute&lt;/code&gt; data annotation instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public enum EnumUnderTest&#xA;{&#xA;    [Display(Description = &#34;EnumUnderTest_Member&#34;, ResourceType = typeof(Project.Resources))]&#xA;    Member&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;EnumUnderTest.Member.Humanize() =&amp;gt; &#34;content&#34; // from Project.Resources found under &#34;EnumUnderTest_Member&#34; resource key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hopefully this will help avoid littering enums with unnecessary attributes!&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;dehumanize-enums&#34;&gt;Dehumanize Enums&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Dehumanizes a string into the Enum it was originally Humanized from! The API looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public static TTargetEnum DehumanizeTo&amp;lt;TTargetEnum&amp;gt;(this string input)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the usage is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Member without description attribute&#34;.DehumanizeTo&amp;lt;EnumUnderTest&amp;gt;() =&amp;gt; EnumUnderTest.MemberWithoutDescriptionAttribute&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And just like the Humanize API it honors the &lt;code&gt;Description&lt;/code&gt; attribute. You don&#39;t have to provide the casing you provided during humanization: it figures it out.&lt;/p&gt; &#xA;&lt;p&gt;There is also a non-generic counterpart for when the original Enum is not known at compile time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public static Enum DehumanizeTo(this string input, Type targetEnum, NoMatch onNoMatch = NoMatch.ThrowsException)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which can be used like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Member without description attribute&#34;.DehumanizeTo(typeof(EnumUnderTest)) =&amp;gt; EnumUnderTest.MemberWithoutDescriptionAttribute&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default both methods throw a &lt;code&gt;NoMatchFoundException&lt;/code&gt; when they cannot match the provided input against the target enum. In the non-generic method you can also ask the method to return null by setting the second optional parameter to &lt;code&gt;NoMatch.ReturnsNull&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanize-datetime&#34;&gt;Humanize DateTime&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can &lt;code&gt;Humanize&lt;/code&gt; an instance of &lt;code&gt;DateTime&lt;/code&gt; or &lt;code&gt;DateTimeOffset&lt;/code&gt; and get back a string telling how far back or forward in time that is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;DateTime.UtcNow.AddHours(-30).Humanize() =&amp;gt; &#34;yesterday&#34;&#xA;DateTime.UtcNow.AddHours(-2).Humanize() =&amp;gt; &#34;2 hours ago&#34;&#xA;&#xA;DateTime.UtcNow.AddHours(30).Humanize() =&amp;gt; &#34;tomorrow&#34;&#xA;DateTime.UtcNow.AddHours(2).Humanize() =&amp;gt; &#34;2 hours from now&#34;&#xA;&#xA;DateTimeOffset.UtcNow.AddHours(1).Humanize() =&amp;gt; &#34;an hour from now&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Humanizer supports both local and UTC dates as well as dates with offset (&lt;code&gt;DateTimeOffset&lt;/code&gt;). You could also provide the date you want the input date to be compared against. If null, it will use the current date as comparison base. Also, culture to use can be specified explicitly. If it is not, current thread&#39;s current UI culture is used. Here is the API signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public static string Humanize(this DateTime input, bool utcDate = true, DateTime? dateToCompareAgainst = null, CultureInfo culture = null)&#xA;public static string Humanize(this DateTimeOffset input, DateTimeOffset? dateToCompareAgainst = null, CultureInfo culture = null)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Many localizations are available for this method. Here is a few examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// In ar culture&#xA;DateTime.UtcNow.AddDays(-1).Humanize() =&amp;gt; &#34;أمس&#34;&#xA;DateTime.UtcNow.AddDays(-2).Humanize() =&amp;gt; &#34;منذ يومين&#34;&#xA;DateTime.UtcNow.AddDays(-3).Humanize() =&amp;gt; &#34;منذ 3 أيام&#34;&#xA;DateTime.UtcNow.AddDays(-11).Humanize() =&amp;gt; &#34;منذ 11 يوم&#34;&#xA;&#xA;// In ru-RU culture&#xA;DateTime.UtcNow.AddMinutes(-1).Humanize() =&amp;gt; &#34;минуту назад&#34;&#xA;DateTime.UtcNow.AddMinutes(-2).Humanize() =&amp;gt; &#34;2 минуты назад&#34;&#xA;DateTime.UtcNow.AddMinutes(-10).Humanize() =&amp;gt; &#34;10 минут назад&#34;&#xA;DateTime.UtcNow.AddMinutes(-21).Humanize() =&amp;gt; &#34;21 минуту назад&#34;&#xA;DateTime.UtcNow.AddMinutes(-22).Humanize() =&amp;gt; &#34;22 минуты назад&#34;&#xA;DateTime.UtcNow.AddMinutes(-40).Humanize() =&amp;gt; &#34;40 минут назад&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are two strategies for &lt;code&gt;DateTime.Humanize&lt;/code&gt;: the default one as seen above and a precision based one. To use the precision based strategy you need to configure it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;Configurator.DateTimeHumanizeStrategy = new PrecisionDateTimeHumanizeStrategy(precision: .75);&#xA;Configurator.DateTimeOffsetHumanizeStrategy = new PrecisionDateTimeOffsetHumanizeStrategy(precision: .75); // configure when humanizing DateTimeOffset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default precision is set to .75 but you can pass your desired precision too. With precision set to 0.75:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;44 seconds =&amp;gt; 44 seconds ago/from now&#xA;45 seconds =&amp;gt; one minute ago/from now&#xA;104 seconds =&amp;gt; one minute ago/from now&#xA;105 seconds =&amp;gt; two minutes ago/from now&#xA;&#xA;25 days =&amp;gt; a month ago/from now&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;No dehumanization for dates as &lt;code&gt;Humanize&lt;/code&gt; is a lossy transformation and the human friendly date is not reversible&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanize-timespan&#34;&gt;Humanize TimeSpan&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can call &lt;code&gt;Humanize&lt;/code&gt; on a &lt;code&gt;TimeSpan&lt;/code&gt; to a get human friendly representation for it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromMilliseconds(1).Humanize() =&amp;gt; &#34;1 millisecond&#34;&#xA;TimeSpan.FromMilliseconds(2).Humanize() =&amp;gt; &#34;2 milliseconds&#34;&#xA;TimeSpan.FromDays(1).Humanize() =&amp;gt; &#34;1 day&#34;&#xA;TimeSpan.FromDays(16).Humanize() =&amp;gt; &#34;2 weeks&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is an optional &lt;code&gt;precision&lt;/code&gt; parameter for &lt;code&gt;TimeSpan.Humanize&lt;/code&gt; which allows you to specify the precision of the returned value. The default value of &lt;code&gt;precision&lt;/code&gt; is 1 which means only the largest time unit is returned like you saw in &lt;code&gt;TimeSpan.FromDays(16).Humanize()&lt;/code&gt;. Here is a few examples of specifying precision:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromDays(1).Humanize(precision:2) =&amp;gt; &#34;1 day&#34; // no difference when there is only one unit in the provided TimeSpan&#xA;TimeSpan.FromDays(16).Humanize(2) =&amp;gt; &#34;2 weeks, 2 days&#34;&#xA;&#xA;// the same TimeSpan value with different precision returns different results&#xA;TimeSpan.FromMilliseconds(1299630020).Humanize() =&amp;gt; &#34;2 weeks&#34;&#xA;TimeSpan.FromMilliseconds(1299630020).Humanize(3) =&amp;gt; &#34;2 weeks, 1 day, 1 hour&#34;&#xA;TimeSpan.FromMilliseconds(1299630020).Humanize(4) =&amp;gt; &#34;2 weeks, 1 day, 1 hour, 30 seconds&#34;&#xA;TimeSpan.FromMilliseconds(1299630020).Humanize(5) =&amp;gt; &#34;2 weeks, 1 day, 1 hour, 30 seconds, 20 milliseconds&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default when using &lt;code&gt;precision&lt;/code&gt; parameter empty time units are not counted towards the precision of the returned value. If this behavior isn&#39;t desired for you, you can use the overloaded &lt;code&gt;TimeSpan.Humanize&lt;/code&gt; method with &lt;code&gt;countEmptyUnits&lt;/code&gt; parameter. Leading empty time units never count. Here is an example showing the difference of counting empty units:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromMilliseconds(3603001).Humanize(3) =&amp;gt; &#34;1 hour, 3 seconds, 1 millisecond&#34;&#xA;TimeSpan.FromMilliseconds(3603001).Humanize(3, countEmptyUnits:true) =&amp;gt; &#34;1 hour, 3 seconds&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Many localizations are available for this method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// in de-DE culture&#xA;TimeSpan.FromDays(1).Humanize() =&amp;gt; &#34;Ein Tag&#34;&#xA;TimeSpan.FromDays(2).Humanize() =&amp;gt; &#34;2 Tage&#34;&#xA;&#xA;// in sk-SK culture&#xA;TimeSpan.FromMilliseconds(1).Humanize() =&amp;gt; &#34;1 milisekunda&#34;&#xA;TimeSpan.FromMilliseconds(2).Humanize() =&amp;gt; &#34;2 milisekundy&#34;&#xA;TimeSpan.FromMilliseconds(5).Humanize() =&amp;gt; &#34;5 milisekúnd&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Culture to use can be specified explicitly. If it is not, current thread&#39;s current UI culture is used. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromDays(1).Humanize(culture: &#34;ru-RU&#34;) =&amp;gt; &#34;один день&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, a minimum unit of time may be specified to avoid rolling down to a smaller unit. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromMilliseconds(122500).Humanize(minUnit: TimeUnit.Second) =&amp;gt; &#34;2 minutes, 2 seconds&#34;    // instead of 2 minutes, 2 seconds, 500 milliseconds&#xA;TimeSpan.FromHours(25).Humanize(minUnit: TimeUnit.Day) =&amp;gt; &#34;1 Day&#34;   //instead of 1 Day, 1 Hour&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, a maximum unit of time may be specified to avoid rolling up to the next largest unit. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromDays(7).Humanize(maxUnit: TimeUnit.Day) =&amp;gt; &#34;7 days&#34;    // instead of 1 week&#xA;TimeSpan.FromMilliseconds(2000).Humanize(maxUnit: TimeUnit.Millisecond) =&amp;gt; &#34;2000 milliseconds&#34;    // instead of 2 seconds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default maxUnit is &lt;code&gt;TimeUnit.Week&lt;/code&gt; because it gives exact results. You can increase this value to &lt;code&gt;TimeUnit.Month&lt;/code&gt; or &lt;code&gt;TimeUnit.Year&lt;/code&gt; which will give you an approximation based on 365.2425 days a year and 30.436875 days a month. Therefore the months are alternating between 30 and 31 days in length and every fourth year is 366 days long.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromDays(486).Humanize(maxUnit: TimeUnit.Year, precision: 7) =&amp;gt; &#34;1 year, 3 months, 29 days&#34; // One day further is 1 year, 4 month&#xA;TimeSpan.FromDays(517).Humanize(maxUnit: TimeUnit.Year, precision: 7) =&amp;gt; &#34;1 year, 4 months, 30 days&#34; // This month has 30 days and one day further is 1 year, 5 months&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When there are multiple time units, they are combined using the &lt;code&gt;&#34;, &#34;&lt;/code&gt; string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromMilliseconds(1299630020).Humanize(3) =&amp;gt; &#34;2 weeks, 1 day, 1 hour&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When &lt;code&gt;TimeSpan&lt;/code&gt; is zero, the default behavior will return &#34;0&#34; plus whatever the minimum time unit is. However, if you assign &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;toWords&lt;/code&gt; when calling &lt;code&gt;Humanize&lt;/code&gt;, then the method returns &#34;no time&#34;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.Zero.Humanize(1) =&amp;gt; &#34;0 milliseconds&#34;&#xA;TimeSpan.Zero.Humanize(1, toWords: true) =&amp;gt; &#34;no time&#34;&#xA;TimeSpan.Zero.Humanize(1, minUnit: Humanizer.Localisation.TimeUnit.Second) =&amp;gt; &#34;0 seconds&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;collectionSeparator&lt;/code&gt; parameter, you can specify your own separator string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromMilliseconds(1299630020).Humanize(3, collectionSeparator: &#34; - &#34;) =&amp;gt; &#34;2 weeks - 1 day - 1 hour&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to use the current culture&#39;s collection formatter to combine the time units. To do so, specify &lt;code&gt;null&lt;/code&gt; as the &lt;code&gt;collectionSeparator&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// in en-US culture&#xA;TimeSpan.FromMilliseconds(1299630020).Humanize(3, collectionSeparator: null) =&amp;gt; &#34;2 weeks, 1 day, and 1 hour&#34;&#xA;&#xA;// in de-DE culture&#xA;TimeSpan.FromMilliseconds(1299630020).Humanize(3, collectionSeparator: null) =&amp;gt; &#34;2 Wochen, Ein Tag und Eine Stunde&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If words are preferred to numbers, a &lt;code&gt;toWords: true&lt;/code&gt; parameter can be set to convert the numbers in a humanized TimeSpan to words:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeSpan.FromMilliseconds(1299630020).Humanize(3, toWords: true) =&amp;gt; &#34;two weeks, one day, one hour&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanize-collections&#34;&gt;Humanize Collections&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can call &lt;code&gt;Humanize&lt;/code&gt; on any &lt;code&gt;IEnumerable&lt;/code&gt; to get a nicely formatted string representing the objects in the collection. By default &lt;code&gt;ToString()&lt;/code&gt; will be called on each item to get its representation but a formatting function may be passed to &lt;code&gt;Humanize&lt;/code&gt; instead. Additionally, a default separator is provided (&#34;and&#34; in English), but a different separator may be passed into &lt;code&gt;Humanize&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;class SomeClass&#xA;{&#xA;    public string SomeString;&#xA;    public int SomeInt;&#xA;    public override string ToString()&#xA;    {&#xA;        return &#34;Specific String&#34;;&#xA;    }&#xA;}&#xA;&#xA;string FormatSomeClass(SomeClass sc)&#xA;{&#xA;    return string.Format(&#34;SomeObject #{0} - {1}&#34;, sc.SomeInt, sc.SomeString);&#xA;}&#xA;&#xA;var collection = new List&amp;lt;SomeClass&amp;gt;&#xA;{&#xA;    new SomeClass { SomeInt = 1, SomeString = &#34;One&#34; },&#xA;    new SomeClass { SomeInt = 2, SomeString = &#34;Two&#34; },&#xA;    new SomeClass { SomeInt = 3, SomeString = &#34;Three&#34; }&#xA;};&#xA;&#xA;collection.Humanize()                                    // &#34;Specific String, Specific String, and Specific String&#34;&#xA;collection.Humanize(&#34;or&#34;)                                // &#34;Specific String, Specific String, or Specific String&#34;&#xA;collection.Humanize(FormatSomeClass)                     // &#34;SomeObject #1 - One, SomeObject #2 - Two, and SomeObject #3 - Three&#34;&#xA;collection.Humanize(sc =&amp;gt; sc.SomeInt.Ordinalize(), &#34;or&#34;) // &#34;1st, 2nd, or 3rd&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Items are trimmed and blank (NullOrWhitespace) items are skipped. This results in clean comma punctuation. (If there is a custom formatter function, this applies only to the formatter&#39;s output.)&lt;/p&gt; &#xA;&lt;p&gt;You can provide your own collection formatter by implementing &lt;code&gt;ICollectionFormatter&lt;/code&gt; and registering it with &lt;code&gt;Configurator.CollectionFormatters&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;inflector-methods&#34;&gt;Inflector methods&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;There are also a few inflector methods:&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;pluralize&#34;&gt;Pluralize&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Pluralize&lt;/code&gt; pluralizes the provided input while taking irregular and uncountable words into consideration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Man&#34;.Pluralize() =&amp;gt; &#34;Men&#34;&#xA;&#34;string&#34;.Pluralize() =&amp;gt; &#34;strings&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Normally you would call &lt;code&gt;Pluralize&lt;/code&gt; on a singular word but if you&#39;re unsure about the singularity of the word you can call the method with the optional &lt;code&gt;inputIsKnownToBeSingular&lt;/code&gt; argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Men&#34;.Pluralize(inputIsKnownToBeSingular: false) =&amp;gt; &#34;Men&#34;&#xA;&#34;Man&#34;.Pluralize(inputIsKnownToBeSingular: false) =&amp;gt; &#34;Men&#34;&#xA;&#34;string&#34;.Pluralize(inputIsKnownToBeSingular: false) =&amp;gt; &#34;strings&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The overload of &lt;code&gt;Pluralize&lt;/code&gt; with &lt;code&gt;plurality&lt;/code&gt; argument is obsolete and was removed in version 2.0.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;singularize&#34;&gt;Singularize&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Singularize&lt;/code&gt; singularizes the provided input while taking irregular and uncountable words into consideration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Men&#34;.Singularize() =&amp;gt; &#34;Man&#34;&#xA;&#34;strings&#34;.Singularize() =&amp;gt; &#34;string&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Normally you would call &lt;code&gt;Singularize&lt;/code&gt; on a plural word but if you&#39;re unsure about the plurality of the word you can call the method with the optional &lt;code&gt;inputIsKnownToBePlural&lt;/code&gt; argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;Men&#34;.Singularize(inputIsKnownToBePlural: false) =&amp;gt; &#34;Man&#34;&#xA;&#34;Man&#34;.Singularize(inputIsKnownToBePlural: false) =&amp;gt; &#34;Man&#34;&#xA;&#34;strings&#34;.Singularize(inputIsKnownToBePlural: false) =&amp;gt; &#34;string&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The overload of &lt;code&gt;Singularize&lt;/code&gt; with &lt;code&gt;plurality&lt;/code&gt; argument is obsolete and was removed in version 2.0.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;adding-words&#34;&gt;Adding Words&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes, you may need to add a rule from the singularization/pluralization vocabulary (the examples below are already in the &lt;code&gt;DefaultVocabulary&lt;/code&gt; used by &lt;code&gt;Inflector&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// Adds a word to the vocabulary which cannot easily be pluralized/singularized by RegEx.&#xA;// Will match both &#34;salesperson&#34; and &#34;person&#34;.&#xA;Vocabularies.Default.AddIrregular(&#34;person&#34;, &#34;people&#34;);&#xA;&#xA;// To only match &#34;person&#34; and not &#34;salesperson&#34; you would pass false for the &#39;matchEnding&#39; parameter.&#xA;Vocabularies.Default.AddIrregular(&#34;person&#34;, &#34;people&#34;, matchEnding: false);&#xA;&#xA;// Adds an uncountable word to the vocabulary.  Will be ignored when plurality is changed:&#xA;Vocabularies.Default.AddUncountable(&#34;fish&#34;);&#xA;&#xA;// Adds a rule to the vocabulary that does not follow trivial rules for pluralization:&#xA;Vocabularies.Default.AddPlural(&#34;bus&#34;, &#34;buses&#34;);&#xA;&#xA;// Adds a rule to the vocabulary that does not follow trivial rules for singularization&#xA;// (will match both &#34;vertices&#34; -&amp;gt; &#34;vertex&#34; and &#34;indices&#34; -&amp;gt; &#34;index&#34;):&#xA;Vocabularies.Default.AddSingular(&#34;(vert|ind)ices$&#34;, &#34;$1ex&#34;);&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;toquantity&#34;&gt;ToQuantity&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Many times you want to call &lt;code&gt;Singularize&lt;/code&gt; and &lt;code&gt;Pluralize&lt;/code&gt; to prefix a word with a number; e.g. &#34;2 requests&#34;, &#34;3 men&#34;. &lt;code&gt;ToQuantity&lt;/code&gt; prefixes the provided word with the number and accordingly pluralizes or singularizes the word:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;case&#34;.ToQuantity(0) =&amp;gt; &#34;0 cases&#34;&#xA;&#34;case&#34;.ToQuantity(1) =&amp;gt; &#34;1 case&#34;&#xA;&#34;case&#34;.ToQuantity(5) =&amp;gt; &#34;5 cases&#34;&#xA;&#34;man&#34;.ToQuantity(0) =&amp;gt; &#34;0 men&#34;&#xA;&#34;man&#34;.ToQuantity(1) =&amp;gt; &#34;1 man&#34;&#xA;&#34;man&#34;.ToQuantity(2) =&amp;gt; &#34;2 men&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ToQuantity&lt;/code&gt; can figure out whether the input word is singular or plural and will singularize or pluralize as necessary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;men&#34;.ToQuantity(2) =&amp;gt; &#34;2 men&#34;&#xA;&#34;process&#34;.ToQuantity(2) =&amp;gt; &#34;2 processes&#34;&#xA;&#34;process&#34;.ToQuantity(1) =&amp;gt; &#34;1 process&#34;&#xA;&#34;processes&#34;.ToQuantity(2) =&amp;gt; &#34;2 processes&#34;&#xA;&#34;processes&#34;.ToQuantity(1) =&amp;gt; &#34;1 process&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass a second argument, &lt;code&gt;ShowQuantityAs&lt;/code&gt;, to &lt;code&gt;ToQuantity&lt;/code&gt; to specify how you want the provided quantity to be outputted. The default value is &lt;code&gt;ShowQuantityAs.Numeric&lt;/code&gt; which is what we saw above. The other two values are &lt;code&gt;ShowQuantityAs.Words&lt;/code&gt; and &lt;code&gt;ShowQuantityAs.None&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;case&#34;.ToQuantity(5, ShowQuantityAs.Words) =&amp;gt; &#34;five cases&#34;&#xA;&#34;case&#34;.ToQuantity(5, ShowQuantityAs.None) =&amp;gt; &#34;cases&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also an overload that allows you to format the number. You can pass in the format and the culture to be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;dollar&#34;.ToQuantity(2, &#34;C0&#34;, new CultureInfo(&#34;en-US&#34;)) =&amp;gt; &#34;$2 dollars&#34;&#xA;&#34;dollar&#34;.ToQuantity(2, &#34;C2&#34;, new CultureInfo(&#34;en-US&#34;)) =&amp;gt; &#34;$2.00 dollars&#34;&#xA;&#34;cases&#34;.ToQuantity(12000, &#34;N0&#34;) =&amp;gt; &#34;12,000 cases&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;ordinalize&#34;&gt;Ordinalize&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Ordinalize&lt;/code&gt; turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;1.Ordinalize() =&amp;gt; &#34;1st&#34;&#xA;5.Ordinalize() =&amp;gt; &#34;5th&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also call &lt;code&gt;Ordinalize&lt;/code&gt; on a numeric string and achieve the same result: &lt;code&gt;&#34;21&#34;.Ordinalize()&lt;/code&gt; =&amp;gt; &lt;code&gt;&#34;21st&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Ordinalize&lt;/code&gt; also supports grammatical gender for both forms. You can pass an argument to &lt;code&gt;Ordinalize&lt;/code&gt; to specify which gender the number should be outputted in. The possible values are &lt;code&gt;GrammaticalGender.Masculine&lt;/code&gt;, &lt;code&gt;GrammaticalGender.Feminine&lt;/code&gt; and &lt;code&gt;GrammaticalGender.Neuter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// for Brazilian Portuguese locale&#xA;1.Ordinalize(GrammaticalGender.Masculine) =&amp;gt; &#34;1º&#34;&#xA;1.Ordinalize(GrammaticalGender.Feminine) =&amp;gt; &#34;1ª&#34;&#xA;1.Ordinalize(GrammaticalGender.Neuter) =&amp;gt; &#34;1º&#34;&#xA;&#34;2&#34;.Ordinalize(GrammaticalGender.Masculine) =&amp;gt; &#34;2º&#34;&#xA;&#34;2&#34;.Ordinalize(GrammaticalGender.Feminine) =&amp;gt; &#34;2ª&#34;&#xA;&#34;2&#34;.Ordinalize(GrammaticalGender.Neuter) =&amp;gt; &#34;2º&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Obviously this only applies to some cultures. For others passing gender in or not passing at all doesn&#39;t make any difference in the result.&lt;/p&gt; &#xA;&lt;p&gt;In addition, &lt;code&gt;Ordinalize&lt;/code&gt; supports variations some cultures apply depending on the position of the ordinalized number in a sentence. Use the argument &lt;code&gt;wordForm&lt;/code&gt; to get one result or another. Possible values are &lt;code&gt;WordForm.Abbreviation&lt;/code&gt; and &lt;code&gt;WordForm.Normal&lt;/code&gt;. You can combine &lt;code&gt;wordForm&lt;/code&gt; argument with gender but passing this argument in when it is not applicable will not make any difference in the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// Spanish locale&#xA;1.Ordinalize(WordForm.Abbreviation) =&amp;gt; &#34;1.er&#34; // As in &#34;Vivo en el 1.er piso&#34;&#xA;1.Ordinalize(WordForm.Normal) =&amp;gt; &#34;1.º&#34; // As in &#34;He llegado el 1º&#34;&#xA;&#34;3&#34;.Ordinalize(GrammaticalGender.Feminine, WordForm.Abbreviation) =&amp;gt; &#34;3.ª&#34;&#xA;&#34;3&#34;.Ordinalize(GrammaticalGender.Feminine, WordForm.Normal) =&amp;gt; &#34;3.ª&#34;&#xA;&#34;3&#34;.Ordinalize(GrammaticalGender.Masculine, WordForm.Abbreviation) =&amp;gt; &#34;3.er&#34;&#xA;&#34;3&#34;.Ordinalize(GrammaticalGender.Masculine, WordForm.Normal) =&amp;gt; &#34;3.º&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;titleize&#34;&gt;Titleize&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Titleize&lt;/code&gt; converts the input words to Title casing; equivalent to &lt;code&gt;&#34;some title&#34;.Humanize(LetterCasing.Title)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;pascalize&#34;&gt;Pascalize&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Pascalize&lt;/code&gt; converts the input words to UpperCamelCase, also removing underscores and spaces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;some_title for something&#34;.Pascalize() =&amp;gt; &#34;SomeTitleForSomething&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;camelize&#34;&gt;Camelize&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Camelize&lt;/code&gt; behaves identically to &lt;code&gt;Pascalize&lt;/code&gt;, except that the first character is lower case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;some_title for something&#34;.Camelize() =&amp;gt; &#34;someTitleForSomething&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;underscore&#34;&gt;Underscore&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Underscore&lt;/code&gt; separates the input words with underscore:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;SomeTitle&#34;.Underscore() =&amp;gt; &#34;some_title&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;dasherize--hyphenate&#34;&gt;Dasherize &amp;amp; Hyphenate&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Dasherize&lt;/code&gt; and &lt;code&gt;Hyphenate&lt;/code&gt; replace underscores with dashes in the string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;some_title&#34;.Dasherize() =&amp;gt; &#34;some-title&#34;&#xA;&#34;some_title&#34;.Hyphenate() =&amp;gt; &#34;some-title&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;kebaberize&#34;&gt;Kebaberize&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Kebaberize&lt;/code&gt; separates the input words with hyphens and all words are converted to lowercase&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;SomeText&#34;.Kebaberize() =&amp;gt; &#34;some-text&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;fluent-date&#34;&gt;Fluent Date&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer provides a fluent API to deal with &lt;code&gt;DateTime&lt;/code&gt; and &lt;code&gt;TimeSpan&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;TimeSpan&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;2.Milliseconds() =&amp;gt; TimeSpan.FromMilliseconds(2)&#xA;2.Seconds() =&amp;gt; TimeSpan.FromSeconds(2)&#xA;2.Minutes() =&amp;gt; TimeSpan.FromMinutes(2)&#xA;2.Hours() =&amp;gt; TimeSpan.FromHours(2)&#xA;2.Days() =&amp;gt; TimeSpan.FromDays(2)&#xA;2.Weeks() =&amp;gt; TimeSpan.FromDays(14)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;small&gt;There are no fluent APIs for month or year as a month could have between 28 to 31 days and a year could be 365 or 366 days.&lt;/small&gt;&lt;/p&gt; &#xA;&lt;p&gt;You could use these methods to, for example, replace&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;DateTime.Now.AddDays(2).AddHours(3).AddMinutes(-5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;DateTime.Now + 2.Days() + 3.Hours() - 5.Minutes()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also three categories of fluent methods to deal with &lt;code&gt;DateTime&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;In.TheYear(2010) // Returns the first of January of 2010&#xA;In.January // Returns 1st of January of the current year&#xA;In.FebruaryOf(2009) // Returns 1st of February of 2009&#xA;&#xA;In.One.Second //  DateTime.UtcNow.AddSeconds(1);&#xA;In.Two.SecondsFrom(DateTime dateTime)&#xA;In.Three.Minutes // With corresponding From method&#xA;In.Three.Hours // With corresponding From method&#xA;In.Three.Days // With corresponding From method&#xA;In.Three.Weeks // With corresponding From method&#xA;In.Three.Months // With corresponding From method&#xA;In.Three.Years // With corresponding From method&#xA;&#xA;On.January.The4th // Returns 4th of January of the current year&#xA;On.February.The(12) // Returns 12th of Feb of the current year&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and some extension methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var someDateTime = new DateTime(2011, 2, 10, 5, 25, 45, 125);&#xA;&#xA;// Returns new DateTime(2008, 2, 10, 5, 25, 45, 125) changing the year to 2008&#xA;someDateTime.In(2008)&#xA;&#xA;// Returns new DateTime(2011, 2, 10, 2, 25, 45, 125) changing the hour to 2:25:45.125&#xA;someDateTime.At(2)&#xA;&#xA;// Returns new DateTime(2011, 2, 10, 2, 20, 15, 125) changing the time to 2:20:15.125&#xA;someDateTime.At(2, 20, 15)&#xA;&#xA;// Returns new DateTime(2011, 2, 10, 12, 0, 0) changing the time to 12:00:00.000&#xA;someDateTime.AtNoon()&#xA;&#xA;// Returns new DateTime(2011, 2, 10, 0, 0, 0) changing the time to 00:00:00.000&#xA;someDateTime.AtMidnight()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Obviously you could chain the methods too; e.g. &lt;code&gt;On.November.The13th.In(2010).AtNoon + 5.Minutes()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;number-to-numbers&#34;&gt;Number to numbers&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer provides a fluent API that produces (usually big) numbers in a clearer fashion:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;1.25.Billions() =&amp;gt; 1250000000&#xA;3.Hundreds().Thousands() =&amp;gt; 300000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;number-towords&#34;&gt;Number to words&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer can change numbers to words using the &lt;code&gt;ToWords&lt;/code&gt; extension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;1.ToWords() =&amp;gt; &#34;one&#34;&#xA;10.ToWords() =&amp;gt; &#34;ten&#34;&#xA;11.ToWords() =&amp;gt; &#34;eleven&#34;&#xA;122.ToWords() =&amp;gt; &#34;one hundred and twenty-two&#34;&#xA;3501.ToWords() =&amp;gt; &#34;three thousand five hundred and one&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass a second argument, &lt;code&gt;GrammaticalGender&lt;/code&gt;, to &lt;code&gt;ToWords&lt;/code&gt; to specify which gender the number should be outputted in. The possible values are &lt;code&gt;GrammaticalGender.Masculine&lt;/code&gt;, &lt;code&gt;GrammaticalGender.Feminine&lt;/code&gt; and &lt;code&gt;GrammaticalGender.Neuter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// for Russian locale&#xA;1.ToWords(GrammaticalGender.Masculine) =&amp;gt; &#34;один&#34;&#xA;1.ToWords(GrammaticalGender.Feminine) =&amp;gt; &#34;одна&#34;&#xA;1.ToWords(GrammaticalGender.Neuter) =&amp;gt; &#34;одно&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// for Arabic locale&#xA;1.ToWords(GrammaticalGender.Masculine) =&amp;gt; &#34;واحد&#34;&#xA;1.ToWords(GrammaticalGender.Feminine) =&amp;gt; &#34;واحدة&#34;&#xA;1.ToWords(GrammaticalGender.Neuter) =&amp;gt; &#34;واحد&#34;&#xA;(-1).ToWords() =&amp;gt; &#34;ناقص واحد&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Obviously this only applies to some cultures. For others passing gender in doesn&#39;t make any difference in the result.&lt;/p&gt; &#xA;&lt;p&gt;Also, culture to use can be specified explicitly. If it is not, current thread&#39;s current UI culture is used. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;11.ToWords(new CultureInfo(&#34;en&#34;)) =&amp;gt; &#34;eleven&#34;&#xA;1.ToWords(GrammaticalGender.Masculine, new CultureInfo(&#34;ru&#34;)) =&amp;gt; &#34;один&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another overload of the method allow you to pass a bool to remove the &#34;And&#34; that can be added before the last number:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;3501.ToWords(false) =&amp;gt; &#34;three thousand five hundred one&#34;&#xA;102.ToWords(false) =&amp;gt; &#34;one hundred two&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method can be useful for writing checks for example.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, &lt;code&gt;ToWords&lt;/code&gt; supports variations some cultures apply depending on the position of the number in a sentence. Use the argument &lt;code&gt;wordForm&lt;/code&gt; to get one result or another. Possible values are &lt;code&gt;WordForm.Abbreviation&lt;/code&gt; and &lt;code&gt;WordForm.Normal&lt;/code&gt;. This argument can be combined with the rest of the arguments presented above. Passing &lt;code&gt;wordForm&lt;/code&gt; argument in when it is not applicable will not make any difference in the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// Spanish locale&#xA;21501.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine) =&amp;gt; &#34;veintiún mil quinientos un&#34;&#xA;21501.ToWords(WordForm.Normal, GrammaticalGender.Masculine) =&amp;gt; &#34;veintiún mil quinientos uno&#34;&#xA;21501.ToWords(WordForm.Abbreviation, GrammaticalGender.Feminine) =&amp;gt; &#34;veintiuna mil quinientas una&#34;&#xA;// English US locale&#xA;21501.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine, new CultureInfo(&#34;en-US&#34;)) =&amp;gt; &#34;twenty-one thousand five hundred and one&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;number-toordinalwords&#34;&gt;Number to ordinal words&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This is kind of mixing &lt;code&gt;ToWords&lt;/code&gt; with &lt;code&gt;Ordinalize&lt;/code&gt;. You can call &lt;code&gt;ToOrdinalWords&lt;/code&gt; on a number to get an ordinal representation of the number in words! For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;0.ToOrdinalWords() =&amp;gt; &#34;zeroth&#34;&#xA;1.ToOrdinalWords() =&amp;gt; &#34;first&#34;&#xA;2.ToOrdinalWords() =&amp;gt; &#34;second&#34;&#xA;8.ToOrdinalWords() =&amp;gt; &#34;eighth&#34;&#xA;10.ToOrdinalWords() =&amp;gt; &#34;tenth&#34;&#xA;11.ToOrdinalWords() =&amp;gt; &#34;eleventh&#34;&#xA;12.ToOrdinalWords() =&amp;gt; &#34;twelfth&#34;&#xA;20.ToOrdinalWords() =&amp;gt; &#34;twentieth&#34;&#xA;21.ToOrdinalWords() =&amp;gt; &#34;twenty first&#34;&#xA;121.ToOrdinalWords() =&amp;gt; &#34;hundred and twenty first&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ToOrdinalWords&lt;/code&gt; also supports grammatical gender. You can pass a second argument to &lt;code&gt;ToOrdinalWords&lt;/code&gt; to specify the gender of the output. The possible values are &lt;code&gt;GrammaticalGender.Masculine&lt;/code&gt;, &lt;code&gt;GrammaticalGender.Feminine&lt;/code&gt; and &lt;code&gt;GrammaticalGender.Neuter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// for Brazilian Portuguese locale&#xA;1.ToOrdinalWords(GrammaticalGender.Masculine) =&amp;gt; &#34;primeiro&#34;&#xA;1.ToOrdinalWords(GrammaticalGender.Feminine) =&amp;gt; &#34;primeira&#34;&#xA;1.ToOrdinalWords(GrammaticalGender.Neuter) =&amp;gt; &#34;primeiro&#34;&#xA;2.ToOrdinalWords(GrammaticalGender.Masculine) =&amp;gt; &#34;segundo&#34;&#xA;2.ToOrdinalWords(GrammaticalGender.Feminine) =&amp;gt; &#34;segunda&#34;&#xA;2.ToOrdinalWords(GrammaticalGender.Neuter) =&amp;gt; &#34;segundo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// for Arabic locale&#xA;1.ToOrdinalWords(GrammaticalGender.Masculine) =&amp;gt; &#34;الأول&#34;&#xA;1.ToOrdinalWords(GrammaticalGender.Feminine) =&amp;gt; &#34;الأولى&#34;&#xA;1.ToOrdinalWords(GrammaticalGender.Neuter) =&amp;gt; &#34;الأول&#34;&#xA;2.ToOrdinalWords(GrammaticalGender.Masculine) =&amp;gt; &#34;الثاني&#34;&#xA;2.ToOrdinalWords(GrammaticalGender.Feminine) =&amp;gt; &#34;الثانية&#34;&#xA;2.ToOrdinalWords(GrammaticalGender.Neuter) =&amp;gt; &#34;الثاني&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Obviously this only applies to some cultures. For others passing gender in doesn&#39;t make any difference in the result.&lt;/p&gt; &#xA;&lt;p&gt;Also, culture to use can be specified explicitly. If it is not, current thread&#39;s current UI culture is used. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;10.ToOrdinalWords(new CultureInfo(&#34;en-US&#34;)) =&amp;gt; &#34;tenth&#34;&#xA;1.ToOrdinalWords(GrammaticalGender.Masculine, new CulureInfo(&#34;pt-BR&#34;)) =&amp;gt; &#34;primeiro&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ToOrdinalWords&lt;/code&gt; also supports variations some cultures apply depending on the position of the ordinalized number in a sentence. Use the argument &lt;code&gt;wordForm&lt;/code&gt; to get one result or another. Possible values are &lt;code&gt;WordForm.Abbreviation&lt;/code&gt; and &lt;code&gt;WordForm.Normal&lt;/code&gt;. Combine this argument with the rest of the arguments presented above. Passing &lt;code&gt;wordForm&lt;/code&gt; argument in when it is not applicable will not make any difference in the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// Spanish locale&#xA;43.ToOrdinalWords(WordForm.Normal, GrammaticalGender.Masculine) =&amp;gt; &#34;cuadragésimo tercero&#34;&#xA;43.ToOrdinalWords(WordForm.Abbreviation, GrammaticalGender.Masculine) =&amp;gt; &#34;cuadragésimo tercer&#34;&#xA;43.ToOrdinalWords(WordForm.Abbreviation, GrammaticalGender.Feminine) =&amp;gt; &#34;cuadragésima tercera&#34;&#xA;// English locale&#xA;43.ToOrdinalWords(GrammaticalGender.Masculine, WordForm.Abbreviation, new CultureInfo(&#34;en&#34;)) =&amp;gt; &#34;forty-third&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;date-time-to-ordinal-words&#34;&gt;DateTime to ordinal words&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This is kind of an extension of Ordinalize&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// for English UK locale&#xA;new DateTime(2015, 1, 1).ToOrdinalWords() =&amp;gt; &#34;1st January 2015&#34;&#xA;new DateTime(2015, 2, 12).ToOrdinalWords() =&amp;gt; &#34;12th February 2015&#34;&#xA;new DateTime(2015, 3, 22).ToOrdinalWords() =&amp;gt; &#34;22nd March 2015&#34;&#xA;// for English US locale&#xA;new DateTime(2015, 1, 1).ToOrdinalWords() =&amp;gt; &#34;January 1st, 2015&#34;&#xA;new DateTime(2015, 2, 12).ToOrdinalWords() =&amp;gt; &#34;February 12th, 2015&#34;&#xA;new DateTime(2015, 3, 22).ToOrdinalWords() =&amp;gt; &#34;March 22nd, 2015&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ToOrdinalWords&lt;/code&gt; also supports grammatical case. You can pass a second argument to &lt;code&gt;ToOrdinalWords&lt;/code&gt; to specify the case of the output. The possible values are &lt;code&gt;GrammaticalCase.Nominative&lt;/code&gt;, &lt;code&gt;GrammaticalCase.Genitive&lt;/code&gt;, &lt;code&gt;GrammaticalCase.Dative&lt;/code&gt;, &lt;code&gt;GrammaticalCase.Accusative&lt;/code&gt;, &lt;code&gt;GrammaticalCase.Instrumental&lt;/code&gt; and &lt;code&gt;GrammaticalGender.Prepositional&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Obviously this only applies to some cultures. For others passing case in doesn&#39;t make any difference in the result.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;time-only-to-clock-notation&#34;&gt;TimeOnly to Clock Notation&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Extends TimeOnly to allow humanizing it to a clock notation&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// for English US locale&#xA;new TimeOnly(3, 0).ToClockNotation() =&amp;gt; &#34;three o&#39;clock&#34;&#xA;new TimeOnly(12, 0).ToClockNotation() =&amp;gt; &#34;noon&#34;&#xA;new TimeOnly(14, 30).ToClockNotation() =&amp;gt; &#34;half past two&#34;&#xA;&#xA;// for Brazilian Portuguese locale&#xA;new TimeOnly(3, 0).ToClockNotation() =&amp;gt; &#34;três em ponto&#34;&#xA;new TimeOnly(12, 0).ToClockNotation() =&amp;gt; &#34;meio-dia&#34;&#xA;new TimeOnly(14, 30).ToClockNotation() =&amp;gt; &#34;duas e meia&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;roman-numerals&#34;&gt;Roman numerals&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer can change numbers to Roman numerals using the &lt;code&gt;ToRoman&lt;/code&gt; extension. The numbers 1 to 10 can be expressed in Roman numerals as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;1.ToRoman() =&amp;gt; &#34;I&#34;&#xA;2.ToRoman() =&amp;gt; &#34;II&#34;&#xA;3.ToRoman() =&amp;gt; &#34;III&#34;&#xA;4.ToRoman() =&amp;gt; &#34;IV&#34;&#xA;5.ToRoman() =&amp;gt; &#34;V&#34;&#xA;6.ToRoman() =&amp;gt; &#34;VI&#34;&#xA;7.ToRoman() =&amp;gt; &#34;VII&#34;&#xA;8.ToRoman() =&amp;gt; &#34;VIII&#34;&#xA;9.ToRoman() =&amp;gt; &#34;IX&#34;&#xA;10.ToRoman() =&amp;gt; &#34;X&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also the reverse operation using the &lt;code&gt;FromRoman&lt;/code&gt; extension.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;I&#34;.FromRoman() =&amp;gt; 1&#xA;&#34;II&#34;.FromRoman() =&amp;gt; 2&#xA;&#34;III&#34;.FromRoman() =&amp;gt; 3&#xA;&#34;IV&#34;.FromRoman() =&amp;gt; 4&#xA;&#34;V&#34;.FromRoman() =&amp;gt; 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that only integers smaller than 4000 can be converted to Roman numerals.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;metric-numerals&#34;&gt;Metric numerals&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer can change numbers to Metric numerals using the &lt;code&gt;ToMetric&lt;/code&gt; extension. The numbers 1, 1230 and 0.1 can be expressed in Metric numerals as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;1d.ToMetric() =&amp;gt; &#34;1&#34;&#xA;1230d.ToMetric() =&amp;gt; &#34;1.23k&#34;&#xA;0.1d.ToMetric() =&amp;gt; &#34;100m&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also the reverse operation using the &lt;code&gt;FromMetric&lt;/code&gt; extension.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;1&#34;.FromMetric() =&amp;gt; 1&#xA;&#34;1.23k&#34;.FromMetric() =&amp;gt; 1230&#xA;&#34;100m&#34;.FromMetric() =&amp;gt; 0.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;bytesize&#34;&gt;ByteSize&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer includes a port of the brilliant &lt;a href=&#34;https://github.com/omar/ByteSize&#34;&gt;ByteSize&lt;/a&gt; library. Quite a few changes and additions are made on &lt;code&gt;ByteSize&lt;/code&gt; to make the interaction with &lt;code&gt;ByteSize&lt;/code&gt; easier and more consistent with the Humanizer API. Here is a few examples of how you can convert from numbers to byte sizes and between size magnitudes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var fileSize = (10).Kilobytes();&#xA;&#xA;fileSize.Bits      =&amp;gt; 81920&#xA;fileSize.Bytes     =&amp;gt; 10240&#xA;fileSize.Kilobytes =&amp;gt; 10&#xA;fileSize.Megabytes =&amp;gt; 0.009765625&#xA;fileSize.Gigabytes =&amp;gt; 9.53674316e-6&#xA;fileSize.Terabytes =&amp;gt; 9.31322575e-9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a few extension methods that allow you to turn a number into a ByteSize instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;3.Bits();&#xA;5.Bytes();&#xA;(10.5).Kilobytes();&#xA;(2.5).Megabytes();&#xA;(10.2).Gigabytes();&#xA;(4.7).Terabytes();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also add/subtract the values using +/- operators and Add/Subtract methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var total = (10).Gigabytes() + (512).Megabytes() - (2.5).Gigabytes();&#xA;total.Subtract((2500).Kilobytes()).Add((25).Megabytes());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;ByteSize&lt;/code&gt; object contains two properties that represent the largest metric prefix symbol and value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var maxFileSize = (10).Kilobytes();&#xA;&#xA;maxFileSize.LargestWholeNumberSymbol;  // &#34;KB&#34;&#xA;maxFileSize.LargestWholeNumberValue;   // 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want a string representation you can call &lt;code&gt;ToString&lt;/code&gt; or &lt;code&gt;Humanize&lt;/code&gt; interchangeably on the &lt;code&gt;ByteSize&lt;/code&gt; instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;7.Bits().ToString();           // 7 b&#xA;8.Bits().ToString();           // 1 B&#xA;(.5).Kilobytes().Humanize();   // 512 B&#xA;(1000).Kilobytes().ToString(); // 1000 KB&#xA;(1024).Kilobytes().Humanize(); // 1 MB&#xA;(.5).Gigabytes().Humanize();   // 512 MB&#xA;(1024).Gigabytes().ToString(); // 1 TB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also optionally provide a format for the expected string representation. The formatter can contain the symbol of the value to display: &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;KB&lt;/code&gt;, &lt;code&gt;MB&lt;/code&gt;, &lt;code&gt;GB&lt;/code&gt;, &lt;code&gt;TB&lt;/code&gt;. The formatter uses the built in &lt;a href=&#34;https://docs.microsoft.com/dotnet/api/system.double.tostring&#34;&gt;&lt;code&gt;double.ToString&lt;/code&gt; method&lt;/a&gt; with &lt;code&gt;#.##&lt;/code&gt; as the default format which rounds the number to two decimal places:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var b = (10.505).Kilobytes();&#xA;&#xA;// Default number format is #.##&#xA;b.ToString(&#34;KB&#34;);         // 10.52 KB&#xA;b.Humanize(&#34;MB&#34;);         // .01 MB&#xA;b.Humanize(&#34;b&#34;);          // 86057 b&#xA;&#xA;// Default symbol is the largest metric prefix value &amp;gt;= 1&#xA;b.ToString(&#34;#.#&#34;);        // 10.5 KB&#xA;&#xA;// All valid values of double.ToString(string format) are acceptable&#xA;b.ToString(&#34;0.0000&#34;);     // 10.5050 KB&#xA;b.Humanize(&#34;000.00&#34;);     // 010.51 KB&#xA;&#xA;// You can include number format and symbols&#xA;b.ToString(&#34;#.#### MB&#34;);  // .0103 MB&#xA;b.Humanize(&#34;0.00 GB&#34;);    // 0 GB&#xA;b.Humanize(&#34;#.## B&#34;);     // 10757.12 B&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want a string representation with full words you can call &lt;code&gt;ToFullWords&lt;/code&gt; on the &lt;code&gt;ByteSize&lt;/code&gt; instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;7.Bits().ToFullWords();           // 7 bits&#xA;8.Bits().ToFullWords();           // 1 byte&#xA;(.5).Kilobytes().ToFullWords();   // 512 bytes&#xA;(1000).Kilobytes().ToFullWords(); // 1000 kilobytes&#xA;(1024).Kilobytes().ToFullWords(); // 1 megabyte&#xA;(.5).Gigabytes().ToFullWords();   // 512 megabytes&#xA;(1024).Gigabytes().ToFullWords(); // 1 terabyte&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There isn&#39;t a &lt;code&gt;Dehumanize&lt;/code&gt; method to turn a string representation back into a &lt;code&gt;ByteSize&lt;/code&gt; instance; but you can use &lt;code&gt;Parse&lt;/code&gt; and &lt;code&gt;TryParse&lt;/code&gt; on &lt;code&gt;ByteSize&lt;/code&gt; to do that. Like other &lt;code&gt;TryParse&lt;/code&gt; methods, &lt;code&gt;ByteSize.TryParse&lt;/code&gt; returns &lt;code&gt;boolean&lt;/code&gt; value indicating whether or not the parsing was successful. If the value is parsed it is output to the &lt;code&gt;out&lt;/code&gt; parameter supplied:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;ByteSize output;&#xA;ByteSize.TryParse(&#34;1.5mb&#34;, out output);&#xA;&#xA;// Invalid&#xA;ByteSize.Parse(&#34;1.5 b&#34;);   // Can&#39;t have partial bits&#xA;&#xA;// Valid&#xA;ByteSize.Parse(&#34;5b&#34;);&#xA;ByteSize.Parse(&#34;1.55B&#34;);&#xA;ByteSize.Parse(&#34;1.55KB&#34;);&#xA;ByteSize.Parse(&#34;1.55 kB &#34;); // Spaces are trimmed&#xA;ByteSize.Parse(&#34;1.55 kb&#34;);&#xA;ByteSize.Parse(&#34;1.55 MB&#34;);&#xA;ByteSize.Parse(&#34;1.55 mB&#34;);&#xA;ByteSize.Parse(&#34;1.55 mb&#34;);&#xA;ByteSize.Parse(&#34;1.55 GB&#34;);&#xA;ByteSize.Parse(&#34;1.55 gB&#34;);&#xA;ByteSize.Parse(&#34;1.55 gb&#34;);&#xA;ByteSize.Parse(&#34;1.55 TB&#34;);&#xA;ByteSize.Parse(&#34;1.55 tB&#34;);&#xA;ByteSize.Parse(&#34;1.55 tb&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, if you need to calculate the rate at which a quantity of bytes has been transferred, you can use the &lt;code&gt;Per&lt;/code&gt; method of &lt;code&gt;ByteSize&lt;/code&gt;. The &lt;code&gt;Per&lt;/code&gt; method accepts one argument - the measurement interval for the bytes; this is the amount of time it took to transfer the bytes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Per&lt;/code&gt; method returns a &lt;code&gt;ByteRate&lt;/code&gt; class which has a &lt;code&gt;Humanize&lt;/code&gt; method. By default, rates are given in seconds (eg, MB/s). However, if desired, a TimeUnit may be passed to &lt;code&gt;Humanize&lt;/code&gt; for an alternate interval. Valid intervals are &lt;code&gt;TimeUnit.Second&lt;/code&gt;, &lt;code&gt;TimeUnit.Minute&lt;/code&gt;, and &lt;code&gt;TimeUnit.Hour&lt;/code&gt;. Examples of each interval and example byte rate usage is below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var size = ByteSize.FromMegabytes(10);&#xA;var measurementInterval = TimeSpan.FromSeconds(1);&#xA;&#xA;var text = size.Per(measurementInterval).Humanize();&#xA;// 10 MB/s&#xA;&#xA;text = size.Per(measurementInterval).Humanize(TimeUnit.Minute);&#xA;// 600 MB/min&#xA;&#xA;text = size.Per(measurementInterval).Humanize(TimeUnit.Hour);&#xA;// 35.15625 GB/hour&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify a format for the bytes part of the humanized output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;19854651984.Bytes().Per(1.Seconds()).Humanize(&#34;#.##&#34;);&#xA;// 18.49 GB/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;heading-to-words&#34;&gt;Heading to words&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer includes methods to change a numeric heading to words. The heading can be a &lt;code&gt;double&lt;/code&gt; whereas the result will be a string. You can choose whether to return a full representation of the heading (e.g. north, east, south or west), a short representation (e.g. N, E, S, W) or a unicode arrow character (e.g. ↑, →, ↓, ←).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;360.ToHeading();&#xA;// north&#xA;720.ToHeading();&#xA;// north&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to retrieve a short version of the heading you can use the following call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;180.ToHeading(true);&#xA;// S&#xA;360.ToHeading(true);&#xA;// N&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that a textual representation has a maximum deviation of 11.25°.&lt;/p&gt; &#xA;&lt;p&gt;The methods above all have an overload with which you can provide a &lt;code&gt;CultureInfo&lt;/code&gt; object in order to determine the localized result to return.&lt;/p&gt; &#xA;&lt;p&gt;To retrieve an arrow representing the heading use the following method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;90.ToHeadingArrow();&#xA;// →&#xA;225.ToHeadingArrow();&#xA;// ↙&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arrow representation of the heading has a maximum deviation of 22.5°.&lt;/p&gt; &#xA;&lt;p&gt;In order to retrieve a heading based on the short text representation (e.g. N, E, S, W), the following method can be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#34;S&#34;.FromShortHeading();&#xA;// 180&#xA;&#34;SW&#34;.FromShortHeading();&#xA;// 225&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;tupleize&#34;&gt;Tupleize&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer can change whole numbers into their &#39;tuple&#39; using &lt;code&gt;Tupleize&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;1.Tupleize();&#xA;// single&#xA;3.Tupleize();&#xA;// triple&#xA;100.Tupleize();&#xA;// centuple&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The numbers 1-10, 100 and 1000 will be converted into a &#39;named&#39; tuple (i.e. &#34;single&#34;, &#34;double&#34; etc.). Any other number &#34;n&#34; will be converted to &#34;n-tuple&#34;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;timeunit-to-symbol&#34;&gt;Time unit to symbol&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Humanizer can translate time units to their symbols:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;TimeUnit.Day.ToSymbol();&#xA;// d&#xA;TimeUnit.Week.ToSymbol();&#xA;// week&#xA;TimeUnit.Year.ToSymbol();&#xA;// y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;mix-this-into-your-framework-to-simplify-your-life&#34;&gt;Mix this into your framework to simplify your life&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This is just a baseline and you can use this to simplify your day to day job. For example, in Asp.Net MVC we keep chucking &lt;code&gt;Display&lt;/code&gt; attribute on ViewModel properties so &lt;code&gt;HtmlHelper&lt;/code&gt; can generate correct labels for us; but, just like enums, in vast majority of cases we just need a space between the words in property name - so why not use &lt;code&gt;&#34;string&#34;.Humanize&lt;/code&gt; for that?!&lt;/p&gt; &#xA;&lt;p&gt;You may find an Asp.Net MVC sample &lt;a href=&#34;https://github.com/Humanizr/Humanizer/tree/master/src/Humanizer.MvcSample&#34;&gt;in the code&lt;/a&gt; that does that (although the project is excluded from the solution file to make the nuget package available for .Net 3.5 too).&lt;/p&gt; &#xA;&lt;p&gt;This is achieved using a custom &lt;code&gt;DataAnnotationsModelMetadataProvider&lt;/code&gt; I called &lt;a href=&#34;https://github.com/Humanizr/Humanizer/raw/master/src/Humanizer.MvcSample/HumanizerMetadataProvider.cs&#34;&gt;HumanizerMetadataProvider&lt;/a&gt;. It is small enough to repeat here; so here we go:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;using System;&#xA;using System.Collections.Generic;&#xA;using System.ComponentModel;&#xA;using System.ComponentModel.DataAnnotations;&#xA;using System.Linq;&#xA;using System.Web.Mvc;&#xA;using Humanizer;&#xA;&#xA;namespace YourApp&#xA;{&#xA;    public class HumanizerMetadataProvider : DataAnnotationsModelMetadataProvider&#xA;    {&#xA;        protected override ModelMetadata CreateMetadata(&#xA;            IEnumerable&amp;lt;Attribute&amp;gt; attributes,&#xA;            Type containerType,&#xA;            Func&amp;lt;object&amp;gt; modelAccessor,&#xA;            Type modelType,&#xA;            string propertyName)&#xA;        {&#xA;            var propertyAttributes = attributes.ToList();&#xA;            var modelMetadata = base.CreateMetadata(propertyAttributes, containerType, modelAccessor, modelType, propertyName);&#xA;&#xA;            if (IsTransformRequired(modelMetadata, propertyAttributes))&#xA;                modelMetadata.DisplayName = modelMetadata.PropertyName.Humanize();&#xA;&#xA;            return modelMetadata;&#xA;        }&#xA;&#xA;        private static bool IsTransformRequired(ModelMetadata modelMetadata, IList&amp;lt;Attribute&amp;gt; propertyAttributes)&#xA;        {&#xA;            if (string.IsNullOrEmpty(modelMetadata.PropertyName))&#xA;                return false;&#xA;&#xA;            if (propertyAttributes.OfType&amp;lt;DisplayNameAttribute&amp;gt;().Any())&#xA;                return false;&#xA;&#xA;            if (propertyAttributes.OfType&amp;lt;DisplayAttribute&amp;gt;().Any())&#xA;                return false;&#xA;&#xA;            return true;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This class calls the base class to extract the metadata and then, if required, humanizes the property name. It is checking if the property already has a &lt;code&gt;DisplayName&lt;/code&gt; or &lt;code&gt;Display&lt;/code&gt; attribute on it in which case the metadata provider will just honor the attribute and leave the property alone. For other properties it will Humanize the property name. That is all.&lt;/p&gt; &#xA;&lt;p&gt;Now you need to register this metadata provider with Asp.Net MVC. Make sure you use &lt;code&gt;System.Web.Mvc.ModelMetadataProviders&lt;/code&gt;, and not &lt;code&gt;System.Web.ModelBinding.ModelMetadataProviders&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;ModelMetadataProviders.Current = new HumanizerMetadataProvider();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... and now you can replace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public class RegisterModel&#xA;{&#xA;    [Display(Name = &#34;User name&#34;)]&#xA;    public string UserName { get; set; }&#xA;&#xA;    [Display(Name = &#34;Email address&#34;)]&#xA;    public string EmailAddress { get; set; }&#xA;&#xA;    [Display(Name = &#34;Confirm password&#34;)]&#xA;    public string ConfirmPassword { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;public class RegisterModel&#xA;{&#xA;    public string UserName { get; set; }&#xA;    public string EmailAddress { get; set; }&#xA;    public string ConfirmPassword { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... and the &#34;metadata humanizer&#34; will take care of the rest.&lt;/p&gt; &#xA;&lt;p&gt;No need to mention that if you want title casing for your labels you can chain the method with &lt;code&gt;Transform&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;modelMetadata.DisplayName = modelMetadata.PropertyName.Humanize().Transform(To.TitleCase);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;known-issues&#34;&gt;Known installation issues and workarounds&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Due to a &lt;a href=&#34;https://github.com/dotnet/cli/issues/3396&#34;&gt;bug&lt;/a&gt; in the CLI tools, the main &lt;code&gt;Humanizer&lt;/code&gt; package and it&#39;s language packages will fail to install. As temporary workaround, until that bug is fixed, use &lt;code&gt;Humanizer.xproj&lt;/code&gt; instead. It contains all of the languages.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;aspnet4mvc&#34;&gt;Use in ASP.NET 4.x MVC Views&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Humanizer is a Portable Class Library. There is currently &lt;a href=&#34;https://stackoverflow.com/questions/16675171/what-does-the-web-config-compilation-assemblies-element-do&#34;&gt;an issue&lt;/a&gt; if you try to use PCL&#39;s in an MVC view since the MVC views do not share the same build system as the regular project. You must specify all references in the &lt;code&gt;web.config&lt;/code&gt; file, including ones the project system normally automatically adds.&lt;/p&gt; &#xA;&lt;p&gt;If you encounter errors saying that you must add a reference to either &lt;code&gt;System.Runtime&lt;/code&gt; or &lt;code&gt;System.Globalization&lt;/code&gt;, this applies to you. The solution is to add the contract references to your &lt;code&gt;web.config&lt;/code&gt; as listed &lt;a href=&#34;https://stackoverflow.com/a/19942274/738188&#34;&gt;here&lt;/a&gt;. Note that this applies to any PCL you use in an MVC view, not just Humanizer.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;how-to-contribute&#34;&gt;How to contribute?&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/Humanizr/Humanizer/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;continuous-integration&#34;&gt;Continuous Integration from Azure DevOps&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Humanizer project is built &amp;amp; tested continuously by Azure DevOps (more details &lt;a href=&#34;https://dev.azure.com/dotnet/Humanizer/_build?definitionId=14&#34;&gt;here&lt;/a&gt;). That applies to pull requests too. Shortly after you submit a PR you can check the build and test status notification on your PR. Feel free to jump in and &lt;a href=&#34;https://github.com/Humanizr/Humanizer/raw/master/CONTRIBUTING.md&#34;&gt;contribute&lt;/a&gt; some green PRs!&lt;/p&gt; &#xA;&lt;p&gt;The current build status on the CI server is &lt;a href=&#34;https://dev.azure.com/dotnet/Humanizer/_build?definitionId=14&#34;&gt;&lt;img src=&#34;https://dev.azure.com/dotnet/Humanizer/_apis/build/status/Humanizer-CI?branchName=master&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;related-projects&#34;&gt;Related projects&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Below is a list of related open source projects:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanizer-resharper-annotations&#34;&gt;Humanizer ReSharper Annotations&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;If you use ReSharper, annotations for Humanizer are available in the &lt;a href=&#34;https://resharper-plugins.jetbrains.com/packages/Humanizer.Annotations/&#34;&gt;Humanizer.Annotations package&lt;/a&gt;, which you can obtain via the ReSharper Extension Manager. These annotations do not yet cover the entire library, but &lt;a href=&#34;https://github.com/enduracode/humanizer-annotations&#34;&gt;pull requests are always welcome!&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;powershell-humanizer&#34;&gt;PowerShell Humanizer&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dfinke/PowerShellHumanizer&#34;&gt;PowerShell Humanizer&lt;/a&gt; is a PowerShell module that wraps Humanizer.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanizerjvm&#34;&gt;Humanizer JVM&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/MehdiK/Humanizer.jvm&#34;&gt;Humanizer.jvm&lt;/a&gt; is an adaptation of the Humanizer framework for .Net which is made for the jvm and is written in Kotlin. Humanizer.jvm meets all your jvm needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;humanizernode&#34;&gt;Humanizer.node&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fakoua/humanizer.node&#34;&gt;Humanizer.node&lt;/a&gt; is a TypeScript port of the Humanizer framework.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;main-contributors&#34;&gt;Main contributors&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mehdi Khalili (&lt;a href=&#34;https://twitter.com/MehdiKhalili&#34;&gt;@MehdiKhalili&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Claire Novotny (&lt;a href=&#34;https://twitter.com/clairernovotny&#34;&gt;@clairernovotny&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Alexander I. Zaytsev (&lt;a href=&#34;https://github.com/hazzik&#34;&gt;@hazzik&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Max Malook (&lt;a href=&#34;https://github.com/mexx&#34;&gt;@mexx&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;license&#34;&gt;License&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Humanizer is released under the MIT License. See the &lt;a href=&#34;https://github.com/Humanizr/Humanizer/raw/master/LICENSE&#34;&gt;bundled LICENSE&lt;/a&gt; file for details.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;icon&#34;&gt;Icon&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Icon created by &lt;a href=&#34;https://twitter.com/Inkventive&#34;&gt;Tyrone Rieschiek&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>betalgo/openai</title>
    <updated>2022-12-23T01:30:32Z</updated>
    <id>tag:github.com,2022-12-23:/betalgo/openai</id>
    <link href="https://github.com/betalgo/openai" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open AI GPT-3 and DALL-E dotnet SDK&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Dotnet SDK for OpenAI GTP-3 and DALL·E&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/Betalgo.OpenAI.GPT3/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Betalgo.OpenAI.GPT3?style=for-the-badge&#34; alt=&#34;Betalgo.OpenAI.GPT3&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Install-Package Betalgo.OpenAI.GPT3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Dotnet SDK for OpenAI GTP-3 and DALL·E&lt;br&gt; &lt;em&gt;Unofficial&lt;/em&gt;.&lt;br&gt; &lt;em&gt;GPT-3 doesn&#39;t have any official .Net SDK.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Image (DALL·E)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Models&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Completions&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Edit&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Mars&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Embeddings&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Files&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Fine-tunes&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Moderation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For changelogs please go to end of the document.&lt;/p&gt; &#xA;&lt;p&gt;Visit &lt;a href=&#34;https://openai.com/&#34;&gt;https://openai.com/&lt;/a&gt; to get your API key. Also documentation with more detail is avaliable there.&lt;/p&gt; &#xA;&lt;h2&gt;Sample Usages&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;em&gt;&lt;strong&gt;!! I would strongly suggest to use different account than your main account while you use playground. Test methods could add or delete your files and models !!&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The repository includes one sample project already &lt;strong&gt;&#34;OpenAI.Playground&#34;&lt;/strong&gt; You can check playground project to see how I was testing it while I was developing the library. Be carefull while playing with it. Some test methods will delete your files or fine tunings.&lt;/p&gt; &#xA;&lt;h3&gt;Without using dependcy injection:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var openAiService = new OpenAIService(new OpenAiOptions()&#xA;{&#xA;    ApiKey =  Environment.GetEnvironmentVariable(&#34;MY_OPEN_AI_API_KEY&#34;)&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using dependcy injection:&lt;/h3&gt; &#xA;&lt;h4&gt;secrets.json:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt; &#34;OpenAIServiceOptions&#34;: {&#xA;    //&#34;ApiKey&#34;:&#34;Your api key goes here&#34;&#xA;    //,&#34;Organization&#34;: &#34;Your Organization Id goes here (optional)&#34;&#xA;  },&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;(How to use &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&amp;amp;tabs=windows&#34;&gt;user secret&lt;/a&gt; ?&lt;br&gt; Right click your project name in &#34;solution explorer&#34; then click &#34;Manage User Secret&#34;, it is a good way to keep your api keys)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Program.cs&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;serviceCollection.AddOpenAIService();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;br&gt; Use it like below but do NOT put your API key directly to your source code.&lt;/p&gt; &#xA;&lt;h4&gt;Program.cs&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;serviceCollection.AddOpenAIService(settings =&amp;gt; { settings.ApiKey = Environment.GetEnvironmentVariable(&#34;MY_OPEN_AI_API_KEY&#34;); });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After injecting your service you will be able to get it from service provider&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var openAiService = serviceProvider.GetRequiredService&amp;lt;IOpenAIService&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can set default engine(optional):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;openAiService.SetDefaultEngineId(Engines.Davinci);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Completions Sample&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var completionResult = await openAiService.Completions.CreateCompletion(new CompletionCreateRequest()&#xA;{&#xA;    Prompt = &#34;Once upon a time&#34;,&#xA;    MaxTokens = 5&#xA;}, Models.Davinci);&#xA;&#xA;if (completionResult.Successful)&#xA;{&#xA;    Console.WriteLine(completionResult.Choices.FirstOrDefault());&#xA;}&#xA;else&#xA;{&#xA;    if (completionResult.Error == null)&#xA;    {&#xA;        throw new Exception(&#34;Unknown Error&#34;);&#xA;    }&#xA;    Console.WriteLine($&#34;{completionResult.Error.Code}: {completionResult.Error.Message}&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes:&lt;/h2&gt; &#xA;&lt;p&gt;I couldn&#39;t find enough time to test all the methods or improve the documentation. My main target was to make fine-tuning available. If you hit any issue please report it or pull request always appreciated.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;I was building an SDK for myself then I decide to share it, I hope it will be useful for you. I haven&#39;t maintained any open source projects before. Any help would be much appreciated. I am open to suggestions If you would like to contribute somehow.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;I will be using the latest libraries all the time. Also, next releasing will include breaking changes frequently &lt;em&gt;(as I mentioned before I was building the SDK for myself. Unfortunately I do not have time to plan these changes and support lower version apps)&lt;/em&gt;. So please be aware of that before starting to use the library.&lt;/p&gt; &#xA;&lt;p&gt;As you can guess I do not accept any damage caused by use of the library. You are always free to use other libraries or OpenAI Web-API.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;h3&gt;6.6.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added support for new models (davinciv3 &amp;amp; edit models)&lt;/li&gt; &#xA; &lt;li&gt;Added support for Edit endpoint.&lt;/li&gt; &#xA; &lt;li&gt;(&lt;em&gt;Warning&lt;/em&gt;: edit endpoint works with only some of the models, I couldn&#39;t find documentation about it, please follow the thread for more information: &lt;a href=&#34;https://community.openai.com/t/is-edit-endpoint-documentation-incorrect/23361&#34;&gt;https://community.openai.com/t/is-edit-endpoint-documentation-incorrect/23361&lt;/a&gt; )&lt;/li&gt; &#xA; &lt;li&gt;Some objects were created as class instead of record at last version. I change them to record. This will be breaking changes for some of you.&lt;/li&gt; &#xA; &lt;li&gt;With this version I think we cover all of openai APIs&lt;/li&gt; &#xA; &lt;li&gt;In next version I will be focusing on code cleanup and refactoring.&lt;/li&gt; &#xA; &lt;li&gt;If I don&#39;t need to relase bug-fix for this version also I will be updating library with dotnet 7 in next version as I promised.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;6.5.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OpenAI made a surprise release yesterday and they have announced DALL·E API. I needed to do other things but I couldn&#39;t resist. Because I was rushing, some methods and class names may will change in the next release. Until that day, enjoy your creative AI.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;This library now fully support all DALL·E features&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;I tried to complete Edit API too bu unfortunately something was wrong with the documentation, I need to ask some questions in the community forum.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;6.4.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bug-fixes &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;FineTuneCreateRequest suffix json property name changed &#34;Suffix&#34; to &#34;suffix&#34;&lt;/li&gt; &#xA;   &lt;li&gt;CompletionCreateRequest user json property name changed &#34;User&#34; to &#34;user&#34; (Thanks to @shaneqld), also now it is a nullable string&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;6.4.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;I have good news and bad news&lt;/li&gt; &#xA; &lt;li&gt;Moderation feature implementation is done. Now we support Moderation.&lt;/li&gt; &#xA; &lt;li&gt;Updated some request and response models to catch up with changes in OpenAI API&lt;/li&gt; &#xA; &lt;li&gt;New version has some breaking changes. Because we are in the fall season I needed to do some cleanup. Sorry for breaking changes but most of them are just renaming. I believe they can be solved before your coffee finish.&lt;/li&gt; &#xA; &lt;li&gt;I am hoping to support Edit Feature in the next version.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;6.3.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thanks to @c-d and @sarilouis for their contributions to this version.&lt;/li&gt; &#xA; &lt;li&gt;Now we support Embedding endpoint. Thanks to @sarilouis&lt;/li&gt; &#xA; &lt;li&gt;Bug fixes and updates for Models&lt;/li&gt; &#xA; &lt;li&gt;Code clean-up&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;6.2.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Removed deprecated Answers, Classifications, and Search endpoints &lt;a href=&#34;https://community.openai.com/t/answers-classification-search-endpoint-deprecation/18532&#34;&gt;https://community.openai.com/t/answers-classification-search-endpoint-deprecation/18532&lt;/a&gt;. They will be still available until December at web-API. If you still need them please do not update to this version.&lt;/li&gt; &#xA; &lt;li&gt;Code clean-up&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;6.1.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Organization id is not a required value anymore, Thanks to @samuelnygaard&lt;/li&gt; &#xA; &lt;li&gt;Removed deprecated Engine Endpoint and replaced it with Models Endpoint. Now Model response has more fields.&lt;/li&gt; &#xA; &lt;li&gt;Regarding OpenAI Engine naming, I had to rename Engine Enum and static fields. They are quite similar but you have to replace them with new ones. Please use Models class instead of Engine class.&lt;/li&gt; &#xA; &lt;li&gt;To support fast engine name changing I have created a new Method, &lt;code&gt;Models.ModelNameBuilder()&lt;/code&gt; you may consider using it.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>