<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-23T01:32:08Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>MicrosoftLearning/AI-102-AIEngineer</title>
    <updated>2023-06-23T01:32:08Z</updated>
    <id>tag:github.com,2023-06-23:/MicrosoftLearning/AI-102-AIEngineer</id>
    <link href="https://github.com/MicrosoftLearning/AI-102-AIEngineer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lab files for AI-102 - AI Engineer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AI-102: AI Engineer&lt;/h1&gt; &#xA;&lt;p&gt;This repo contains the lab instructions and files used in Microsoft Official Curriculum course AI-102.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Are you a MCT?&lt;/strong&gt; - Have a look at our &lt;a href=&#34;https://microsoftlearning.github.io/MCT-User-Guide/&#34;&gt;GitHub User Guide for MCTs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Need to manually build the lab instructions?&lt;/strong&gt; - Instructions are available in the &lt;a href=&#34;https://github.com/MicrosoftLearning/Docker-Build&#34;&gt;MicrosoftLearning/Docker-Build&lt;/a&gt; repository&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What are we doing?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;To support this course, we will need to make frequent updates to the course content to keep it current with the Azure services used in the course. We are publishing the lab instructions and lab files on GitHub to allow for open contributions between the course authors and MCTs to keep the content current with changes in the Azure platform.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;We hope that this brings a sense of collaboration to the labs like we&#39;ve never had before - when Azure changes and you find it first during a live delivery, go ahead and make an enhancement right in the lab source. Help your fellow MCTs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How should I use these files relative to the released MOC files?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The instructor materials are still going to be your primary source for teaching the course content.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;These files on GitHub are designed to be used in the course labs, using the hosted lab environment.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;We recommend that for every delivery, trainers check GitHub for any changes that may have been made to support the latest Azure services, and get the latest files for their delivery.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What about changes to the student handbook?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We will review the student handbook on a quarterly basis and update through the normal MOC release channels as needed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How do I contribute?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Any MCT can submit a pull request to the code or content in the GitHub repo, Microsoft and the course author will triage and include content and lab code changes as needed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can submit bugs, changes, improvement and ideas. Find a new Azure feature before we have? Submit a new demo!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>puff/EazyDevirt</title>
    <updated>2023-06-23T01:32:08Z</updated>
    <id>tag:github.com,2023-06-23:/puff/EazyDevirt</id>
    <link href="https://github.com/puff/EazyDevirt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tool that automatically restores the original IL code from an assembly virtualized with Eazfuscator.NET&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/puff/EazyDevirt/main/assets/Logo.png&#34;&gt; &#xA; &lt;h1&gt;EazyDevirt&lt;/h1&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/puff/EazyDevirt&#34;&gt;EazyDevirt&lt;/a&gt; is an open-source tool that automatically restores the original IL code from an assembly virtualized with &lt;a href=&#34;https://www.gapotchenko.com/eazfuscator.net&#34;&gt;Eazfuscator.NET&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/puff/EazyDevirt/main/#installation&#34;&gt;Installation&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/puff/EazyDevirt/main/#usage&#34;&gt;Usage&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/puff/EazyDevirt/main/#features&#34;&gt;Features&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/puff/EazyDevirt/main/#roadmap&#34;&gt;Roadmap&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/puff/EazyDevirt/main/#support&#34;&gt;Support&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://forthebadge.com&#34;&gt;&lt;img src=&#34;https://forthebadge.com/images/badges/powered-by-black-magic.svg?sanitize=true&#34; alt=&#34;forthebadge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-GPL%20v3-orangered.svg?sanitize=true&#34; alt=&#34;GPLv3 License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ EazyDevirt &amp;lt;assembly&amp;gt; [&amp;lt;output&amp;gt;] [options]&#xA;Arguments:&#xA;  &amp;lt;assembly&amp;gt;  Path to target assembly&#xA;  &amp;lt;output&amp;gt;    Path to output directory [default: ./eazydevirt-output]&#xA;&#xA;Options:&#xA;  -v, --verbose &amp;lt;verbosity&amp;gt;  Level of verbosity [1: Verbose, 2: Very Verbose, 3: Very Very Verbose] [default: 0]&#xA;  --preserve-all             Preserves all metadata tokens [default: False]&#xA;  --no-verify                Don&#39;t verify labels or compute max stack for devirtualized methods [default: False]&#xA;  -kt, --keep-types          Keeps obfuscator types [default: False]&#xA;  --save-anyway              Saves output of devirtualizer even if it fails [default: False]&#xA;  --only-save-devirted       Only saves successfully devirtualized methods (This option only matters if you use the&#xA;                             save anyway option) [default: False]&#xA;  --version                  Show version information&#xA;  -?, -h, --help             Show help and usage information&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Example:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ EazyDevirt.exe test.exe -v 3 --preserve-all --save-anyway true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Notes&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.gapotchenko.com/eazfuscator.net&#34;&gt;Eazfuscator.NET&lt;/a&gt; resolves members using names rather than tokens. This means renaming any member may break the application.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/puff/EazyDevirt&#34;&gt;EazyDevirt&lt;/a&gt; requires control flow and other protections (such as string encryption or delegate proxies) to be removed first. To remove string encryption, you can use &lt;a href=&#34;https://github.com/holly-hacker/EazFixer&#34;&gt;EazFixer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For control flow obfuscation, you can try using de4dot:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ de4dot &amp;lt;assembly&amp;gt; --only-cflow-deob&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To clone the project use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git clone --recurse-submodules https://github.com/puff/EazyDevirt.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can use your favourite IDE or build from the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ dotnet restore&#xA;$ dotnet build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatically identify and map virtual opcodes to their CIL counterparts&lt;/li&gt; &#xA; &lt;li&gt;Automatically identify devirtualize methods virtualized with &lt;a href=&#34;https://www.gapotchenko.com/eazfuscator.net&#34;&gt;Eazfuscator.NET&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Emulated binary reader using &lt;a href=&#34;https://github.com/Washi1337/Echo&#34;&gt;Echo&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/puff/EazyDevirt/issues&#34;&gt;open issues&lt;/a&gt; for a list of proposed features (and known issues).&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/puff/EazyDevirt&#34;&gt;EazyDevirt&lt;/a&gt; is targeted at version 2022.2 of &lt;a href=&#34;https://www.gapotchenko.com/eazfuscator.net&#34;&gt;Eazfuscator.NET&lt;/a&gt;. If the version you&#39;re trying this tool on is not supported, you will need to add support for it yourself. You can take a look at the differences between the branches to see what you need to change. &lt;br&gt; The &lt;a href=&#34;https://github.com/puff/EazyDevirt/tree/old-2022.2&#34;&gt;old-2022&lt;/a&gt; branch supports a different version of 2022.2 than the &lt;a href=&#34;https://github.com/puff/EazyDevirt/tree/main&#34;&gt;main&lt;/a&gt; branch. The &lt;a href=&#34;https://github.com/puff/EazyDevirt/tree/old-2021&#34;&gt;old-2021&lt;/a&gt; branch supports an unknown version from 2021.&lt;/p&gt; &#xA;&lt;p&gt;I won&#39;t help you update this program for another version. But, if you find a bug, feel free to submit an issue.&lt;/p&gt; &#xA;&lt;h3&gt;Credits&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/void-stack&#34;&gt;void-stack&lt;/a&gt; for the many contributions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/saneki&#34;&gt;saneki&lt;/a&gt; for the &lt;a href=&#34;https://github.com/saneki/eazdevirt&#34;&gt;eazdevirt&lt;/a&gt; project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TobitoFatitoRE&#34;&gt;TobitoFatitoRE&lt;/a&gt; for the &lt;a href=&#34;https://github.com/TobitoFatitoRE/HexDevirt&#34;&gt;HexDevirt&lt;/a&gt; project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Washi1337&#34;&gt;Washi1337&lt;/a&gt; for the &lt;a href=&#34;https://github.com/Washi1337/AsmResolver&#34;&gt;AsmResolver&lt;/a&gt; and &lt;a href=&#34;https://github.com/Washi1337/Echo&#34;&gt;Echo&lt;/a&gt; libraries.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And a thank you, to &lt;a href=&#34;https://github.com/puff/EazyDevirt/graphs/contributors&#34;&gt;all other contributors&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tmoonlight/NSmartProxy</title>
    <updated>2023-06-23T01:32:08Z</updated>
    <id>tag:github.com,2023-06-23:/tmoonlight/NSmartProxy</id>
    <link href="https://github.com/tmoonlight/NSmartProxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NSmartProxy是一款开源的内网穿透工具。采用.NET CORE的全异步模式打造。(NSmartProxy is an open source reverse proxy tool that creates a secure tunnel from a public endpoint to a locally service.)&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;http://2017studio.oss-accelerate.aliyuncs.com/NSmartProxyNew.png&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tmoonlight/NSmartProxy/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/tmoonlight/NSmartProxy.svg?logoColor=%21%5BGitHub%20release%5D%28https%3A%2F%2Fimg.shields.io%2Fgithub%2Frelease%2Ftmoonlight%2FNSmartProxy.svg%29&#34; alt=&#34;GitHub release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/tmoonlight/NSmartProxy/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/tmoonlight/NSmartProxy.svg?sanitize=true&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dev.azure.com/tmoonlight/NSmartProxy/_build/latest?definitionId=1&amp;amp;branchName=master&#34;&gt;&lt;img src=&#34;https://dev.azure.com/tmoonlight/NSmartProxy/_apis/build/status/tmoonlight.NSmartProxy?branchName=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;img src=&#34;https://img.shields.io/docker/pulls/tmoonlight/nspclient?label=nspclient%20docker%20pulls&#34; alt=&#34;Docker Pulls&#34;&gt; &lt;img src=&#34;https://img.shields.io/docker/pulls/tmoonlight/nspserver?label=nspserver%20docker%20pulls&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;br&gt; 中文版 | &lt;a href=&#34;https://github.com/tmoonlight/NSmartProxy/raw/master/README_EN.md&#34;&gt;English&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;NSmartProxy&lt;/h1&gt; &#xA;&lt;h4&gt;什么是NSmartProxy？&lt;br&gt;&lt;/h4&gt; &#xA;&lt;p&gt;NSmartProxy是一款免费的内网穿透工具。&lt;br&gt; 使用中如果有任何问题和建议，可以&lt;a href=&#34;https://gitter.im/tmoonlight/NSmartProxy&#34;&gt;点击这里加入Gitter群组&lt;/a&gt;或者&lt;a href=&#34;https://raw.githubusercontent.com/shang.qq.com/wpa/qunwpa?idkey=139dc3d01be5cc7ac3226c022d832b8ddcc4ec4b64d8755cd4f5c669994970c7&#34;&gt;点击这里加入QQ群 （群号：813170640）&lt;/a&gt;我们一起讨论。&lt;/p&gt; &#xA;&lt;h2&gt;目录&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E7%89%B9%E7%82%B9&#34;&gt;特点&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86&#34;&gt;运行原理&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85&#34;&gt;客户端安装&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E5%90%AF%E5%8A%A8%E5%87%86%E5%A4%87&#34;&gt;启动准备&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95&#34;&gt;使用方法&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85&#34;&gt;服务端安装&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E5%90%AF%E5%8A%A8%E5%87%86%E5%A4%87-1&#34;&gt;启动准备&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1&#34;&gt;使用方法&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tmoonlight/NSmartProxy/master/#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B&#34;&gt;使用案例&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;特点&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;跨平台，客户端和服务端均可运行在MacOS，Linux，Windows系统上；&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;使用方便，配置简单；&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;多端映射，只需安装一个NSmartProxy客户端可映射整个局域网内的多种服务；&lt;/li&gt; &#xA; &lt;li&gt;支持TCP协议栈下的所有协议（已经经过测试的有FTP、Telnet、SMTP、HTTP/HTTPS、POP3、SMB、VNC、RDP。），以及相当一部分基于UDP的协议（已经经过测试的有DNS查询、mosh服务）。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;运行原理&lt;/h2&gt; &#xA;&lt;p&gt;NSmartProxy包含两个服务程序：&lt;br&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;服务端（NSmartProxy.ServerHost）：部署在外网，用来接收来自最终使用者和客户端的反向连接，并将它们进行相互转发。&lt;/li&gt; &#xA; &lt;li&gt;客户端（NSmartProxyClient）：部署在内网，用来转发访问内网各种服务的请求以及响应。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img src=&#34;http://2017studio.oss-accelerate.aliyuncs.com/theo.png&#34;&gt; &#xA;&lt;h2&gt;客户端安装&lt;/h2&gt; &#xA;&lt;p&gt;NSmartProxy支持各种基于TCP和UDP服务的端口映射，下面以mstsc,iis,ftp以及mosh服务为例：&lt;br&gt;&lt;/p&gt; &#xA;&lt;h3&gt;启动准备&lt;/h3&gt; &#xA;&lt;p&gt;NSmartProxy的客户端被打包成三种发布方式：第一种是跨平台包，需要预先安装&lt;a href=&#34;https://dotnet.microsoft.com/download&#34;&gt;.NET Core环境&lt;/a&gt;。 第二种是SCD包（包名带&#34;scd&#34;），无需安装.net环境，用户需要根据自己的平台和架构选择相应的压缩包。第三种是Windows窗体版本（包名带&#34;winform&#34;）：&lt;/p&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;确保客户端的环境在.NET Framework 4.6.1 以上。&lt;/li&gt; &#xA; &lt;li&gt;下载最新的窗体版本&lt;a href=&#34;https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspclient_winform_v1.2_final4.zip&#34;&gt;https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspclient_winform_v1.2_final4.zip&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Linux&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;下载最新版本的NSmartProxyClient，以SCD发布下的linux x64系统为例：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspserver_scd_linux_v1.2_final4.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;MacOS&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;下载最新版本的NSmartProxyClient：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspclient_scd_osx_v1.2_final4.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Docker&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;如果当前机器上已经有了docker运行环境，则无需安装运行时，直接拉取镜像即可运行，如下脚本在Docker CE 17.09下测试通过：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo docker pull tmoonlight/nspclient&#xA;sudo docker run --name mynspclient -dit tmoonlight/nspclient&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;使用方法&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;打开安装目录下的appsettings.json文件，配置服务地址，映射地址和端口（winform版本也兼容这种配置方式，也可直接进入界面配置）：&lt;br&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;  &#34;ProviderWebPort&#34;: 12309,         //服务器端口&#xA;  &#34;ProviderAddress&#34;: &#34;2017studio.imwork.net&#34;,   //服务器地址&#xA;&#xA;  //反向代理客户端列表&#xA;  &#34;Clients&#34;: [&#xA;    {//mstsc远程控制服务&#xA;      &#34;IP&#34;: &#34;127.0.0.1&#34;,           //反向代理机器的ip&#xA;      &#34;TargetServicePort&#34;: &#34;3389&#34;  //反向代理服务的端口&#xA;      &#34;ConsumerPort&#34;:&#34;3389&#34;          //外网访问端口，如被占用，则会从20000开始按顺序分配端口&#xA;    },&#xA;    {//网站服务&#xA;      &#34;IP&#34;: &#34;127.0.0.1&#34;,&#xA;      &#34;TargetServicePort&#34;: &#34;80&#34;&#xA;    },&#xA;    {//ftp服务&#xA;      &#34;IP&#34;: &#34;127.0.0.1&#34;,&#xA;      &#34;TargetServicePort&#34;: &#34;21&#34;,&#xA;      &#34;IsCompress&#34; : true,      //表示启动传输压缩&#xA;      &#34;Description&#34;: &#34;这是一个ftp协议。&#34; //描述字段，方便用户在服务端界面识别&#xA;    },&#xA;    {//mosh服务 &#xA;      &#34;IP&#34;: &#34;192.168.0.168&#34;,    //安装mosh服务的受控端地址&#xA;      &#34;TargetServicePort&#34;: &#34;60002&#34;,&#xA;      &#34;ConsumerPort&#34;: &#34;30002&#34;,  &#xA;      &#34;Protocol&#34;: &#34;UDP&#34;     //表示是一个UDP协议，如果不加以配置，则以TCP协议来转发&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;br&gt; 2. 运行NSmartProxy客户端 &lt;br&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;    sudo unzip nspclient_scd_linux_v1.2.zip&#xA;    cd nspclient_scd_linux_v1.2&#xA;    chmod +x ./NSmartProxyClient&#xA;    ./NSmartProxyClient&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MacOS：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;    sudo unzip nspclient_osx_linux_v1.2.zip&#xA;    cd nspclient_scd_osx_v1.2&#xA;    chmod +x ./NSmartProxyClient&#xA;    ./NSmartProxyClient&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Windows： 解压后运行NSmartProxyWinform.exe即可:&lt;/p&gt; &lt;img src=&#34;http://2017studio.oss-accelerate.aliyuncs.com/5.nspclientwinformrunning.gif&#34;&gt; &lt;br&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;后台运行：&lt;br&gt; 您还可以将NSmartProxy客户端注册为一个后台服务，方法如下：&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows：&lt;br&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;方法一&lt;br&gt; &lt;img src=&#34;https://github.com/tmoonlight/NSmartProxy/raw/master/imgs/servicecn.png&#34;&gt;&lt;br&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;方法二&lt;br&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    rem 注册客户端windows服务&#xA;    .\NSmartProxyClient action:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;    rem 卸载客户端windows服务&#xA;    .\NSmartProxyClient action:uninstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MacOS/Linux 暂略&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;客户端登陆&lt;/h4&gt; &#xA;&lt;p&gt;默认情况下，客户端以&lt;b&gt;匿名登陆&lt;/b&gt;，这种方式会在NSmartProxyServer端创建一个随机匿名用户（前提是服务端配置了允许&lt;b&gt;匿名登陆&lt;/b&gt;），如果想显式使用特定用户登陆，需要在第一次运行时增加-u 用户名 -p 密码参数，程序会在当前目录生成一份凭据（.usercache）方便下次自动登陆。 例如输入以下指令来生成一个用户名admin，密码admin123的凭据：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./NSmartProxyClient -u admin -p admin123&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;下次仅需使用：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./NSmartProxyClient&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;自动采用上次的admin用户登陆，如需恢复匿名登陆，则需要删除当前目录下的.usercache文件。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;P.S： 以上是客户端的配置方法，一般情况下，只要用我的免费服务（2017studio.imwork.net）即可进行内网映射了，如果你还想自己搭建服务端，请接着往下看。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;服务端安装&lt;/h2&gt; &#xA;&lt;p&gt;这里介绍NSmartProxy服务端的安装方法（linux,windows,MacOS均适用）&lt;br&gt;&lt;/p&gt; &#xA;&lt;h3&gt;启动准备&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;首先你需要一台具备独立IP的服务器，以下安装过程均在此机器上执行：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Linux/Windows/MacOS&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;NSmartProxy的服务端程序被打包成两种发布方式。第一种是跨平台包，需要预先安装&lt;a href=&#34;https://dotnet.microsoft.com/download&#34;&gt;.NET Core环境&lt;/a&gt;。 第二种是SCD包（包名带&#34;scd&#34;），无需安装.net环境，用户需要根据自己的平台和架构选择相应的压缩包。&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;下载最新版的NSmartProxy服务端：&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspserver_scd_linux_v1.2_final4.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Windows：&lt;br&gt; 下载&lt;a href=&#34;https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspserver_scd_win_v1.2_final4.zip&#34;&gt;https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspserver_scd_win_v1.2_final4.zip&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MacOS：&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://github.com/tmoonlight/NSmartProxy/releases/download/v1.2_final4/nspserver_scd_osx_v1.2_final4.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Docker&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;无需安装运行时，直接拉取镜像即可运行，运行镜像时需要4组端口：配置端口，反向连接端口，API服务端口，以及使用端口，如下脚本在Docker CE 17.09下测试通过：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo docker pull tmoonlight/nspserver&#xA;sudo docker run --name mynspserver -dit -p 7842:7842 -p 7841:7841 -p 12309:12309 -p 20000-20050 tmoonlight/nspserver&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;使用方法&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;解压缩NSmartProxy服务端的压缩包，以下以SCD发布下的linux系统为例&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;unzip nspserver_scd_linux_v1.2_final4.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;打开安装目录下的appsettings.json文件，设置反向连接端口和配置服务端口，如果没有特殊需求，默认就好：&lt;br&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;  &#34;ReversePort&#34;: 7842, //反向连接端口&#xA;  &#34;ConfigPort&#34;: 7841, //配置服务端口&#xA;  &#34;WebAPIPort&#34;: 12309         //API服务端口&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;运行NSmartProxy &lt;br&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;第一步 cd到安装目录 &lt;br&gt; 第二步 执行以下命令&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux/MacOS：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;chmod +x ./NSmartProxy.ServerHost&#xA;./NSmartProxy.ServerHost&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows： 点击 Win+R 打开运行窗口. 输入 &#34;cmd&#34; 按下Ctrl+Shift+Enter打开管理员身份运行的命令行窗口。cd到安装目录，运行如下指令：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;NSmartProxy.ServerHost&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;第三步 登陆&lt;a href=&#34;http://ip:12309&#34;&gt;http://ip:12309&lt;/a&gt; 进入web端，出厂用户密码为admin/admin&lt;/p&gt; &#xA;&lt;img src=&#34;http://2017studio.oss-accelerate.aliyuncs.com/6.nspserverrunnning_1.gif&#34;&gt; &#xA;&lt;p&gt;第四步 进入服务端对用户进行各种管理操作&lt;/p&gt; &#xA;&lt;img src=&#34;http://2017studio.oss-accelerate.aliyuncs.com/6.nspserverrunnning_2.gif&#34;&gt; &#xA;&lt;h4&gt;注册为后台服务&lt;br&gt;&lt;/h4&gt; &#xA;&lt;p&gt;NSmartProxy客户端和服务端均可以注册为一个后台服务，方法如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows 以管理员身份打开命令行后，cd到程序运行目录，运行以下指令进行服务的注册和卸载：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;rem 注册服务端windows服务&#xA;.\NSmartProxy.ServerHost action:install&#xA;&#xA;rem 卸载服务端windows服务&#xA;.\NSmartProxy.ServerHost action:uninstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MacOS/Linux &lt;br&gt; 可参考wiki: &lt;a href=&#34;https://github.com/tmoonlight/NSmartProxy/wiki/How-To:-30%E7%A7%92%E4%BD%BF%E7%94%A8Linux%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF&#34;&gt;How To: 30秒使用Linux搭建一个内网穿透服务端&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;使用案例&lt;/h2&gt; &#xA;&lt;p&gt;以上已经讲述了将内网的服务映射到外网的方法，还有更多有趣的用法等着你发掘：&lt;br&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;远程开机&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tmoonlight/NSmartProxy/wiki/How-To:-%E4%BD%BF%E7%94%A8NSmartProxy%E5%AE%9E%E7%8E%B0windows%E4%B8%8A%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC&#34;&gt;使用windows远程控制操作办公室电脑&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;告别昂贵的vps，以极低的成本制作一个更强大的服务集群&lt;br&gt;&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>