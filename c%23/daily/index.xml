<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-29T01:32:22Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dotnet/roslyn-sdk</title>
    <updated>2023-06-29T01:32:22Z</updated>
    <id>tag:github.com,2023-06-29:/dotnet/roslyn-sdk</id>
    <link href="https://github.com/dotnet/roslyn-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Roslyn-SDK templates and Syntax Visualizer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Roslyn SDK&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Branch&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;dev16.0.x&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://dnceng.visualstudio.com/public/_build/latest?definitionId=137&amp;amp;branchName=dev16.0.x&#34;&gt;&lt;img src=&#34;https://dnceng.visualstudio.com/public/_apis/build/status/dotnet/roslyn-sdk/public-CI?branchName=dev16.0.x&amp;amp;label=build&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;main&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://dnceng.visualstudio.com/public/_build/latest?definitionId=137&amp;amp;branchName=main&#34;&gt;&lt;img src=&#34;https://dnceng.visualstudio.com/public/_apis/build/status/dotnet/roslyn-sdk/public-CI?branchName=main&amp;amp;label=build&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;What is the Roslyn-SDK?&lt;/h1&gt; &#xA;&lt;p&gt;Roslyn is the compiler platform for .NET. It consists of the compiler itself and a powerful set of APIs to interact with the compiler. The Roslyn platform is hosted at &lt;a href=&#34;https://github.com/dotnet/roslyn&#34;&gt;github.com/dotnet/roslyn&lt;/a&gt;. The compiler is part of every .NET installation. The APIs to interact with the compiler are available via NuGet (see the &lt;a href=&#34;https://github.com/dotnet/roslyn&#34;&gt;Roslyn repository&lt;/a&gt; for details). The Roslyn SDK includes additional components to get you started with advanced topics such as distributing a Roslyn analyzer as Visual Studio extension or to inspect code with the Syntax Visualizer. The documentation for the Roslyn platform can be found at &lt;a href=&#34;https://docs.microsoft.com/dotnet/csharp/roslyn-sdk&#34;&gt;docs.microsoft.com/dotnet/csharp/roslyn-sdk&lt;/a&gt;. This repository contains code for both the Roslyn-SDK templates and Syntax Visualizer.&lt;/p&gt; &#xA;&lt;h1&gt;Installation instructions&lt;/h1&gt; &#xA;&lt;h2&gt;Visual Studio 2017 (Version 15.5 and above)&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;strong&gt;Visual Studio Installer&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Hit &lt;strong&gt;Modify&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Select the &lt;strong&gt;Individual components&lt;/strong&gt; tab&lt;/li&gt; &#xA; &lt;li&gt;Check the box for &lt;strong&gt;.NET Compiler Platform SDK&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Visual Studio 2015&lt;/h2&gt; &#xA;&lt;p&gt;For older versions of Visual Studio the &lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/2ddb7240-5249-4c8c-969e-5d05823bcb89&#34;&gt;.NET Compiler Platform SDK&lt;/a&gt; is available as an extension in the Visual Studio gallery.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>nozzlegear/ShopifySharp</title>
    <updated>2023-06-29T01:32:22Z</updated>
    <id>tag:github.com,2023-06-29:/nozzlegear/ShopifySharp</id>
    <link href="https://github.com/nozzlegear/ShopifySharp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ShopifySharp is a .NET library that helps developers easily authenticate with and manage Shopify stores.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ShopifySharp: A .NET library for Shopify.&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/ShopifySharp/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/ShopifySharp.svg?maxAge=3600&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/actions/workflows/build-and-test.yml&#34;&gt;&lt;img src=&#34;https://github.com/nozzlegear/ShopifySharp/actions/workflows/build-and-test.yml/badge.svg?branch=master&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/nozzlegear/shopifysharp/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/nozzlegear/shopifysharp.svg?maxAge=3600&#34; alt=&#34;license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ShopifySharp is a .NET library that enables you to authenticate and make API calls to Shopify. It&#39;s great for building custom Shopify Apps using C# and .NET. You can quickly and easily get up and running with Shopify using this library.&lt;/p&gt; &#xA;&lt;h1&gt;The Shopify Development Handbook&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nozzlegear.com/shopify-development-handbook?ref=ShopifySharp&#34;&gt;&lt;img src=&#34;https://i.imgur.com/9GgDjK0.png&#34; alt=&#34;Learn how to build rock-solid Shopify apps with C# and ASP.NET&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Building an app or integration for the Shopify store is hard work. There are a ton of things you need to keep in mind when stitching together all of the API calls, redirect URLs and app settings that you&#39;ll need to use.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;re going to be asking yourself all of these questions when you try to build an app for the Shopify store:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How can I charge my users when they use my app?&lt;/li&gt; &#xA; &lt;li&gt;What in the world is an embedded app?&lt;/li&gt; &#xA; &lt;li&gt;How should I be using Shopify&#39;s redirect URLs?&lt;/li&gt; &#xA; &lt;li&gt;When should I be using a proxy page?&lt;/li&gt; &#xA; &lt;li&gt;Am I dealing with webhooks the right way?&lt;/li&gt; &#xA; &lt;li&gt;How can I let my user&#39;s actual customers interact with the app?&lt;/li&gt; &#xA; &lt;li&gt;Can I add custom scripts to their website, and what can those scripts even do?&lt;/li&gt; &#xA; &lt;li&gt;How the heck do I go about testing my app?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It&#39;s difficult to find blog posts or tutorials about building Shopify apps, and downright impossible if you&#39;re trying to build them with C# and ASP.NET. Shopify&#39;s own partner blog puts a huge focus on designing themes over building real, functional apps, and their API docs only go so far if you don&#39;t know what you&#39;re looking for.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nozzlegear.com/shopify-development-handbook?ref=ShopifySharp&#34;&gt;The Shopify Development Handbook&lt;/a&gt; is a premium educational course that distills the experience of building Shopify applications and integrations into one concise and comprehensive course.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nozzlegear.com/shopify-development-handbook?ref=ShopifySharp&#34;&gt;Click here to learn more about The Shopify Development Handbook, &lt;strong&gt;and get a FREE sample chapter&lt;/strong&gt; on integrating a merchant&#39;s Shopify store with your app.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;ShopifySharp is &lt;a href=&#34;https://www.nuget.org/packages/ShopifySharp/&#34;&gt;available on NuGet&lt;/a&gt;. Use the package manager console in Visual Studio to install it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;Install-Package ShopifySharp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using .NET Core, you can use the &lt;code&gt;dotnet&lt;/code&gt; command from your favorite shell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;dotnet add package shopifysharp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;API support&lt;/h1&gt; &#xA;&lt;p&gt;Shopify has begun versioning their API, meaning new features are locked behind newer versions of the API, and older versions of the API lose support and are eventually shut off. Due to the differences in ShopifySharp&#39;s SemVer versioning, and Shopify&#39;s date-based versioning, the following table should be consulted to determine which version of ShopifySharp supports which version of Shopify&#39;s API:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ShopifySharp version&lt;/th&gt; &#xA;   &lt;th&gt;Shopify API version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4.x and below&lt;/td&gt; &#xA;   &lt;td&gt;None, unsupported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.0.0 - 5.5.0&lt;/td&gt; &#xA;   &lt;td&gt;2019-10&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.6.0 - 5.7.0&lt;/td&gt; &#xA;   &lt;td&gt;2020-07&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.8.0 - 5.10.0&lt;/td&gt; &#xA;   &lt;td&gt;2020-10&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.11.0 - 5.13.1&lt;/td&gt; &#xA;   &lt;td&gt;2021-07&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.14.0 - 5.15.0&lt;/td&gt; &#xA;   &lt;td&gt;2021-10&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.16.0 - 5.18.11&lt;/td&gt; &#xA;   &lt;td&gt;2022-04&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.19.0 - 5.19.1&lt;/td&gt; &#xA;   &lt;td&gt;2022-07&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6.0.1 and above&lt;/td&gt; &#xA;   &lt;td&gt;2023-01&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; ShopifySharp dropped support for .NET Framework 4.5 in version 5.14.0. &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/438&#34;&gt;More details in #438.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;A migration guide for migrating from ShopifySharp 5.x to ShopifySharp 6.0+ is coming soon.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Frequently Asked Questions&lt;/h1&gt; &#xA;&lt;h3&gt;Question: How do I contribute to ShopifySharp?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/raw/master/docs/contribution-guide.md&#34;&gt;Check out our contribution guide!&lt;/a&gt; Is the guide missing anything? Please let me know by opening an issue!&lt;/p&gt; &#xA;&lt;h3&gt;Question: How do I look up a Shopify order by its name?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nozzlegear.com/shopify/looking-up-a-shopify-order-by-its-name&#34;&gt;See this article to learn how to look up a Shopify order by its name property.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Question: How do I use ShopifySharp with a private app?&lt;/h3&gt; &#xA;&lt;p&gt;ShopifySharp works with any private Shopify app, no extra configuration needed. All you need to do is pass in your private app&#39;s password wherever ShopifySharp asks for an access token. For example: &lt;code&gt;var service = new ShopifySharp.OrderService(&#34;mydomain.myshopify.com&#34;, &#34;PRIVATE APP PASSWORD HERE&#34;)&lt;/code&gt;. This package&#39;s test suite uses a private app for testing API calls, so this method is confirmed working.&lt;/p&gt; &#xA;&lt;h3&gt;Question: X method or Y endpoint randomly 404s/throws exceptions for some shops.&lt;/h3&gt; &#xA;&lt;p&gt;Make sure that you&#39;re always using a *.myshopify.com domain! While a &#34;real&#34; domain like &#34;example.com&#34; will often work with the API, there are some API endpoints that will randomly return redirects or 404s if you aren&#39;t using the *.myshopify.com domain. &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/286#issuecomment-1248952763&#34;&gt;See this post by @dnatabar&lt;/a&gt; and &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/723#issuecomment-1074623062&#34;&gt;this post by @flgatormike&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Question: Updating a product (or other object) unpublishes it?&lt;/h3&gt; &#xA;&lt;p&gt;This is an issue related to the serialization of default property values in dotnet. As developers, we often want to update only a small subset of properties on an object. However, any property that is not explicitly given a value in dotnet will instead be initialized and serialized with its default value.&lt;/p&gt; &#xA;&lt;p&gt;For the &lt;code&gt;Product.PublishedAt&lt;/code&gt; property, this default value is &lt;code&gt;null&lt;/code&gt;. Setting &lt;code&gt;PublishedAt&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; will &lt;strong&gt;unpublish&lt;/strong&gt; the product, removing it from the storefront and making it unavailable for puchase. The fix is to first pull in the product with the API and then update its properties.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var product = await productService.GetAsync(productId);&#xA;product.SomeProperty = newValue;&#xA;product = await productService.UpdateAsync(productId, product);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;re looking for feedback on methods to improve object updating and property serialization in ShopifySharp. &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/388&#34;&gt;You can offer feedback here&lt;/a&gt;, and check out these issues (&lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/284&#34;&gt;#284&lt;/a&gt;, &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/367&#34;&gt;#367&lt;/a&gt;, &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/373&#34;&gt;#373&lt;/a&gt;, &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/379&#34;&gt;#379&lt;/a&gt;, &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/642&#34;&gt;#642&lt;/a&gt;) for further history on the problem.&lt;/p&gt; &#xA;&lt;h1&gt;A work-in-progress&lt;/h1&gt; &#xA;&lt;p&gt;I first started working on ShopifySharp because .NET developers need a fully-featured library for interacting with Shopify and building Shopify apps, which didn&#39;t exist several years ago. My goal is to eventually reach 100% compatibility with the Shopify REST API, but, with that said, Shopify is constantly adding new APIs and altering old ones. I try my best to keep up with them, but I tend to prioritize the support of new APIs by how much I need them in my own Shopify apps.&lt;/p&gt; &#xA;&lt;p&gt;ShopifySharp currently supports the following Shopify APIs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Access &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#authorization-and-authentication&#34;&gt;OAuth authentication&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#access-scopes&#34;&gt;Access Scopes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#storefrontaccesstokens&#34;&gt;StorefrontAccessTokens&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Analytics &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Report (not implimented yet)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Billing &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#one-time-application-charges&#34;&gt;Application charges (in-app purchases)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#application-credits&#34;&gt;Application Credits&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#recurring-application-charges-charge-shop-owners-to-use-your-app&#34;&gt;Recurring application charges (subscriptions)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#usage-charges&#34;&gt;Usage charges&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Customers &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#customers&#34;&gt;Customers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Customer Address (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;Customer Saved Search (docs not yet written)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Discounts &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#discounts&#34;&gt;Discounts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#price-rules&#34;&gt;Price Rules&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Events &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#events&#34;&gt;Events&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#webhooks&#34;&gt;Webhooks&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Inventory &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Inventory Item (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;Inventory Level (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#locations&#34;&gt;Locations&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Marketing Event (not implimented yet)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#metafields&#34;&gt;Metafields&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Online Store &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#articles&#34;&gt;Articles&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#assets&#34;&gt;Assets&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#blogs&#34;&gt;Blogs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Comment (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#pages&#34;&gt;Pages&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#redirects&#34;&gt;Redirects&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#script-tags&#34;&gt;Script Tags&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#themes&#34;&gt;Themes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Orders &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#abandoned-checkouts&#34;&gt;Abandoned Checkouts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#draft-orders&#34;&gt;Draft Orders&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#orders&#34;&gt;Orders&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#order-risks&#34;&gt;Order Risks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Refund (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#transactions&#34;&gt;Transactions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Plus &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#gift-cards&#34;&gt;GiftCards&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#users&#34;&gt;User&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Products &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#collects&#34;&gt;Collects&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#collections&#34;&gt;Collections&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#custom-collections&#34;&gt;Custom Collections&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#products&#34;&gt;Products&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#product-images&#34;&gt;Product Images&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#product-variants&#34;&gt;Product Variants&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#smart-collections&#34;&gt;Smart Collections&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Sales Channels &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#checkouts&#34;&gt;Checkouts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Collection Listing (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;Mobile Platform Application (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;Payment (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;Product Resource Feedback (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;Product Listing (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;Resource Feedback (not implimented yet)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Shipping and Fulfillment &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#assigned-fulfillment-orders&#34;&gt;Assigned Fulfillment Orders&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#cancellation-requests&#34;&gt;Cancellation Requests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Carrier Service (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#fulfillments&#34;&gt;Fulfillments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#fulfillment-events&#34;&gt;Fulfillment Events&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#fulfillment-orders&#34;&gt;Fulfillment Orders&lt;/a&gt; (List/Get/Close only. Scheduling not implemented yet)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#fulfillment-requests&#34;&gt;Fulfillment Requests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#fulfillment-services&#34;&gt;Fulfillment Services&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Locations For Move (not implimented yet)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Shopify Payments &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Balance (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;Dispute (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;Payouts (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;Transactions (docs not yet written)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Store Properties &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Country (docs not yet written)&lt;/li&gt; &#xA;   &lt;li&gt;Currency (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#policies&#34;&gt;Policies&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Province (not implimented yet)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#shipping-zones&#34;&gt;Shipping Zones&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#shops&#34;&gt;Shops&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#tender-transactions&#34;&gt;Tender Transactions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#multipass&#34;&gt;Multipass (Shopify Plus)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More functionality will be added each week until it reaches full parity with Shopify&#39;s REST API.&lt;/p&gt; &#xA;&lt;h3&gt;Contributors&lt;/h3&gt; &#xA;&lt;p&gt;These generous people have contributed their own hard work and time to improving ShopifySharp:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yitzchok&#34;&gt;Yitzchok&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/squallop&#34;&gt;Shannan Finley&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/stepankobzey&#34;&gt;stepankobzey&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Panksy&#34;&gt;Cathy Pank&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mooglegiant&#34;&gt;mooglegiant&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ishahrier&#34;&gt;ishahrier&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/darkstar74&#34;&gt;darkstar74&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/damazoarriaga&#34;&gt;Angel Arriaga&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shajumohamed&#34;&gt;Shaju Mohammed&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mrjono1&#34;&gt;Jono&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/thj-dk&#34;&gt;Tommy Holm Jakobsen&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ernestogutierrez&#34;&gt;Ernesto Gutiérrez&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/clement911&#34;&gt;clement911&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mchandschuh&#34;&gt;mchandschuh&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mobbsie&#34;&gt;Andrew Mobbs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/martinzezulkacz&#34;&gt;Martin Zezulka&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bartcoppens&#34;&gt;Bart Coppens&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/thj-dk&#34;&gt;Tommy Holm Jakobsen&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/foxandrewj&#34;&gt;Andrew Fox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vleontyev&#34;&gt;Victor&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lasamuadib&#34;&gt;lasamuadib&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jsimmonsdavidccook&#34;&gt;Jeremy Simmons&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/BrianBarnard&#34;&gt;BrianBarnard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/datvm&#34;&gt;Luke Vo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pianomanjh&#34;&gt;Josh&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yuvalsade&#34;&gt;yuvalsade&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thank you!&lt;/p&gt; &#xA;&lt;p&gt;(If I missed you, just shoot me an email at &lt;a href=&#34;mailto:joshua@nozzlegear.com&#34;&gt;joshua@nozzlegear.com&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h1&gt;Using ShopifySharp with a public Shopify app&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: All instances of &lt;code&gt;shopAccessToken&lt;/code&gt; in the examples below &lt;strong&gt;do not refer to your Shopify API key&lt;/strong&gt;. An access token is the token returned after authenticating and authorizing a Shopify app installation with a real Shopify store.&lt;/p&gt; &#xA;&lt;p&gt;All instances of &lt;code&gt;myShopifyUrl&lt;/code&gt; refer to your users&#39; &lt;code&gt;*.myshopify.com&lt;/code&gt; URL (although their custom domain should work too).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Using ShopifySharp with a private Shopify app&lt;/h1&gt; &#xA;&lt;p&gt;ShopifySharp should work out of the box with your private Shopify application, all you need to do is replace the &lt;code&gt;shopAccessToken&lt;/code&gt; with your private app&#39;s password when initializing a ShopifyService:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductService(myShopifyUrl, privateAppPassword)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you just need an access token for a private Shopify app, or for running the tests in this library, refer to the &lt;strong&gt;Tests&lt;/strong&gt; section below.&lt;/p&gt; &#xA;&lt;h2&gt;Authorization and authentication&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTICE&lt;/strong&gt;: If you&#39;re using ASP.NET MVC5 (or any version that isn&#39;t AspNet Core) you&#39;ll have compilation errors when trying to pass &lt;code&gt;Request.QueryString&lt;/code&gt; or &lt;code&gt;Request.Headers&lt;/code&gt; to the authorization methods described below. &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/164&#34;&gt;See this issue for a workaround&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Ensure a given URL is a valid *myshopify.com URL&lt;/h3&gt; &#xA;&lt;p&gt;This is a convenience method that validates whether a given URL is a valid Shopify API domain (the Shopify API is hosted on each individual shop rather than at once central URL). It&#39;s great for ensuring you don&#39;t redirect a user to an incorrect URL when you need them to authorize your app installation, and is ideally used in conjunction with &lt;code&gt;AuthorizationService.BuildAuthorizationUrl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;ShopifySharp will call the given URL and check for an &lt;code&gt;X-ShopId&lt;/code&gt; header in the response. That header is present on all Shopify shops and it&#39;s existence signals that the URL is indeed a Shopify URL.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;, however, that this feature is undocumented by Shopify and may break at any time. Use at your own discretion. In addition, it&#39;s possible for a malicious site to fake the &lt;code&gt;X-ShopId&lt;/code&gt; header which would make this method return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;string urlFromUser = &#34;https://example.myshopify.com&#34;;&#xA;bool isValidDomain = await AuthorizationService.IsValidShopDomainAsync(urlFromUser).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build an authorization URL&lt;/h3&gt; &#xA;&lt;p&gt;Redirect your users to this authorization URL, where they&#39;ll be prompted to install your app to their Shopify store.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;//This is the user&#39;s store URL.&#xA;string usersMyShopifyUrl = &#34;https://example.myshopify.com&#34;;&#xA;&#xA;// A URL to redirect the user to after they&#39;ve confirmed app installation.&#xA;// This URL is required, and must be listed in your app&#39;s settings in your Shopify app dashboard.&#xA;// It&#39;s case-sensitive too!&#xA;string redirectUrl = &#34;https://example.com/my/redirect/url&#34;;&#xA;&#xA;//An array of the Shopify access scopes your application needs to run.&#xA;var scopes = new List&amp;lt;AuthorizationScope&amp;gt;()&#xA;{&#xA;    AuthorizationScope.ReadCustomers,&#xA;    AuthorizationScope.WriteCustomers&#xA;};&#xA;&#xA;//Or, use an array of string permissions&#xA;var scopes = new List&amp;lt;string&amp;gt;()&#xA;{&#xA;    &#34;read_customers&#34;,&#xA;    &#34;write_customers&#34;&#xA;}&#xA;&#xA;//You can find your API key over at https://shopify.dev/tutorials/authenticate-a-private-app-with-shopify-admin&#xA;string shopifyApiKey = &#34;&#34;;&#xA;&#xA;//All AuthorizationService methods are static.&#xA;Uri authUrl = AuthorizationService.BuildAuthorizationUrl(scopes, usersMyShopifyUrl, shopifyApiKey, redirectUrl);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorize an installation and generate an access token&lt;/h3&gt; &#xA;&lt;p&gt;Once you&#39;ve sent a user to the authorization URL and they&#39;ve confirmed your app installation, they&#39;ll be redirected back to your application at either the default app URL, or the redirect URL you passed in when building the authorization URL.&lt;/p&gt; &#xA;&lt;p&gt;The access token you receive after authorizing should be stored in your database. You&#39;ll need it to access the shop&#39;s resources (e.g. orders, customers, fulfillments, etc.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;//The querystring will have several parameters you need for authorization.&#xA;string code = Request.QueryString[&#34;code&#34;];&#xA;string myShopifyUrl = Request.QueryString[&#34;shop&#34;];&#xA;&#xA;string accessToken = await AuthorizationService.Authorize(code, myShopifyUrl, shopifyApiKey, shopifySecretKey);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Determine if a request is authentic&lt;/h3&gt; &#xA;&lt;p&gt;Any (non-webhook, non-proxy-page) request coming from Shopify will have a querystring parameter called &#39;hmac&#39; that you can use to verify that the request is authentic. This signature is a hash of all querystring parameters and your app&#39;s secret key.&lt;/p&gt; &#xA;&lt;p&gt;Pass the entire querystring to &lt;code&gt;AuthorizationService&lt;/code&gt; to verify the request.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var qs = Request.QueryString;&#xA;&#xA;if(AuthorizationService.IsAuthenticRequest(qs, shopifySecretKey))&#xA;{&#xA;    //Request is authentic.&#xA;}&#xA;else&#xA;{&#xA;    //Request is not authentic and should not be acted on.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Determine if a proxy page request is authentic&lt;/h3&gt; &#xA;&lt;p&gt;Nearly identical to authenticating normal requests, a proxy page request only differs in the way the HMAC is generated. All proxy page requests coming from Shopify will have a querystring parameter named &lt;code&gt;hmac&lt;/code&gt; that you can use to verify the request. This signature is a hash of all querystring parameters and your app&#39;s secret key.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var qs = Request.QueryString;&#xA;&#xA;if(AuthorizationService.IsAuthenticProxyRequest(qs, shopifySecretKey))&#xA;{&#xA;    //Request is authentic.&#xA;}&#xA;else&#xA;{&#xA;    //Request is not authentic and should not be acted on.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Determine if a webhook request is authentic&lt;/h3&gt; &#xA;&lt;p&gt;Any webhook request coming from Shopify will have a header called &lt;code&gt;X-Shopify-Hmac-SHA256&lt;/code&gt; that you can use to verify that the webhook is authentic. The header is a hash of the entire request body and your app&#39;s secret key.&lt;/p&gt; &#xA;&lt;p&gt;Pass the entire header collection and the request&#39;s input stream to &lt;code&gt;AuthorizationService&lt;/code&gt; to verify the request.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;NameValueCollection requestHeaders = Request.Headers;&#xA;Stream inputStream = Request.InputStream;&#xA;&#xA;if(AuthorizationService.IsAuthenticWebhook(requestHeaders, inputStream, shopifySecretKey))&#xA;{&#xA;    //Webhook is authentic.&#xA;}&#xA;else&#xA;{&#xA;    //Webhook is not authentic and should not be acted on.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass in the request body as a string, rather than using the input stream. However, the request body string &lt;strong&gt;needs to be identical to the way it was sent from Shopify&lt;/strong&gt;. If it has been modified the verification will fail -- even if just one space is in the wrong place.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;NameValueCollection requestHeaders = Request.Headers;&#xA;string requestBody = null;&#xA;&#xA;//Reset the input stream. MVC controllers often read the stream to determine which parameters to pass to an action.&#xA;Request.InputStream.Position = 0;&#xA;&#xA;//Read the stream into a string&#xA;using(StreamReader reader = new StreamReader(Request.InputStream))&#xA;{&#xA;    requestBody = await reader.ReadToEndAsync();&#xA;}&#xA;&#xA;if(AuthorizationService.IsAuthenticWebhook(requestHeaders, requestBody, shopifySecretKey))&#xA;{&#xA;    //Webhook is authentic.&#xA;}&#xA;else&#xA;{&#xA;    //Webhook is not authentic and should not be acted on.&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Recurring Application Charges (charge shop owners to use your app)&lt;/h2&gt; &#xA;&lt;p&gt;The Shopify billing API lets you create a recurring charge on a shop owner&#39;s account, letting them pay you for using your application. There are pros and cons to using the Shopify billing API versus a service like Stripe, BrainTree or PayPal.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve put together a small guide called &lt;strong&gt;&lt;em&gt;Shopify Billing 101: A Developer&#39;s Guide To Getting Paid For Your Apps&lt;/em&gt;&lt;/strong&gt;, and you can get for &lt;strong&gt;free&lt;/strong&gt; by joining the mailing list for &lt;strong&gt;&lt;em&gt;Mastering Shopify Development&lt;/em&gt;&lt;/strong&gt; (a training course for building Shopify apps with C# and ASP.NET).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nozzlegear.com/landing/shopify-billing-101?ref=ShopifySharp&#34;&gt;Just head over here to get your free guide to the Shopify billing API.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that recurring charges are activated immediately after a user accepts them. At one time it was necessary to activate the charge after it was accepted, but Shopify has changed this behavior and it&#39;s no longer required or possible.&lt;/p&gt; &#xA;&lt;h3&gt;Create a recurring charge&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RecurringChargeService(myShopifyUrl, shopAccessToken);&#xA;var charge = new RecurringCharge()&#xA;{&#xA;    Name = &#34;Lorem Ipsum Plan&#34;,&#xA;    Price = 12.34,&#xA;    Test = true, //Marks this charge as a test, meaning it won&#39;t charge the shop owner.&#xA;    TrialDays = 21&#xA;}&#xA;&#xA;charge = await service.CreateAsync(charge);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieve a recurring charge&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RecurringChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;var charge = await service.GetAsync(chargeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing recurring charges&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RecurringChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;IEnumerable&amp;lt;RecurringCharge&amp;gt; charges = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a charge&lt;/h3&gt; &#xA;&lt;p&gt;Charges cannot be deleted unless they&#39;ve been activated. Shopify automatically deletes pending charges after 48 hours pass without activation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RecurringChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(chargeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;One-time application charges&lt;/h2&gt; &#xA;&lt;p&gt;Just like with the above recurring charges, the Shopify billing API lets you create a one-time application charge on the shop owner&#39;s account. One-time charges cannot be deleted.&lt;/p&gt; &#xA;&lt;h3&gt;Create a one-time charge&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ChargeService(myShopifyUrl, shopAccessToken);&#xA;var charge = new Charge()&#xA;{&#xA;    Name = &#34;Lorem Ipsum Charge&#34;,&#xA;    Price = 12.34,&#xA;    Test = true, //Marks this charge as a test, meaning it won&#39;t charge the shop owner.&#xA;}&#xA;&#xA;charge = await service.CreateAsync(charge);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieve a one-time charge&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;var charge = await service.GetAsync(chargeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing one-time charges&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;IEnumerable&amp;lt;Charge&amp;gt; charges = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Activating a charge&lt;/h3&gt; &#xA;&lt;p&gt;Just like recurring charges, creating a one-time charge does not actually charge the shop owner. You need to send them to the charge&#39;s &lt;code&gt;ConfirmationUrl&lt;/code&gt;, have them accept the charge, then activate it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.ActivateAsync(chargeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage charges&lt;/h2&gt; &#xA;&lt;p&gt;Shopify&#39;s Usage Charges let you set a capped amount on a recurring application charge, and only charge for usage. For example, you can create a charge that&#39;s capped at $100.00 per month, and then charge e.g. $1.00 for every 1000 emails your user sends using your app.&lt;/p&gt; &#xA;&lt;p&gt;To create a UsageCharge, you first need to create a RecurringCharge with a &lt;code&gt;CappedAmount&lt;/code&gt; value and a &lt;code&gt;Terms&lt;/code&gt; string. Your customers will see the terms when activating the recurring charge, so set it to something they can read like &#34;$1.00 per 1000 emails&#34;.&lt;/p&gt; &#xA;&lt;h3&gt;Create a usage charge&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new UsageChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;string description = &#34;Used 1000 emails&#34;;&#xA;double price = 1.00;&#xA;&#xA;var usageCharge = await service.CreateAsync(recurringChargeId, description, price);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get a usage charge&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new UsageChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;var usageCharge = await service.GetAsync(recurringChargeId, usageChargeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List usage charges&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new UsageChargeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;var usageCharges = await service.ListAsync(recurringChargeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Shops&lt;/h2&gt; &#xA;&lt;h3&gt;Retrieving shop information&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ShopService(myShopifyUrl, shopAccessToken);&#xA;&#xA;var shop = await service.GetAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Uninstalling your app&lt;/h3&gt; &#xA;&lt;p&gt;In cases where user intervention is not required, you can send a request to a Shopify shop to force it to uninstall your application. After sending this request, your shop access token will be immediately revoked and invalidated.&lt;/p&gt; &#xA;&lt;p&gt;Uninstalling an application is an irreversible operation. Be entirely sure that you no longer need to make API calls for the shop in which the application has been installed.&lt;/p&gt; &#xA;&lt;p&gt;Uninstalling an application also performs various cleanup tasks within Shopify. Registered Webhooks, ScriptTags and App Links will be destroyed as part of this operation. Also if an application is uninstalled during key rotation, both the old and new Access Tokens will be rendered useless.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ShopService(myShopifyUrl, shopAccessToken);&#xA;&#xA;var shop = await service.UninstallAppAsync()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customers&lt;/h2&gt; &#xA;&lt;h3&gt;Creating a customer&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;var customer = new Customer()&#xA;{&#xA;    FirstName = &#34;John&#34;,&#xA;    LastName = &#34;Doe&#34;,&#xA;    Email = &#34;john.doe@example.com&#34;,&#xA;    Addresses = new List&amp;lt;Address&amp;gt;()&#xA;    {&#xA;        new Address()&#xA;        {&#xA;            Address1 = &#34;123 4th Street&#34;,&#xA;            City = &#34;Minneapolis&#34;,&#xA;            Province = &#34;Minnesota&#34;,&#xA;            ProvinceCode = &#34;MN&#34;,&#xA;            Zip = &#34;55401&#34;,&#xA;            Phone = &#34;555-555-5555&#34;,&#xA;            FirstName = &#34;John&#34;,&#xA;            LastName = &#34;Doe&#34;,&#xA;            Company = &#34;Tomorrow Corporation&#34;,&#xA;            Country = &#34;United States&#34;,&#xA;            CountryCode = &#34;US&#34;,&#xA;            Default = true,&#xA;        }&#xA;    },&#xA;    VerifiedEmail = true,&#xA;    Note = &#34;Test note about the customer.&#34;,&#xA;    State = &#34;enabled&#34;&#xA;};&#xA;&#xA;customer = await service.CreateAsync(customer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a customer&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;var customer = await service.GetAsync(customerId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a customer with certain fields&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;var customer = await service.GetAsync(customerId, &#34;first_name,last_name,email&#34;);&#xA;&#xA;//Returns a customer with only FirstName, LastName and Email fields. All other fields are null.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a customer&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;var customer = await service.UpdateAsync(customerId, new Customer()&#xA;{&#xA;    Email = &#34;test-update@example.com&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a customer&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(customerId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting customers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;int customerCount = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing customers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;Customer&amp;gt; customers = await Service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing orders for a customer&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new CustomerService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;Order&amp;gt; orders = await service.ListOrdersForCustomerAsync(customerId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Searching customers&lt;/h3&gt; &#xA;&lt;p&gt;Use a &lt;code&gt;CustomerSearchListFilter&lt;/code&gt; to perform searches for customers. There is a noticeable 3-30 second delay between creating a new customer and Shopify indexing it for a search.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CustomerService(myShopifyUrl, shopAccessToken); &#xA;var filter = new CustomerSearchListFilter&#xA;{&#xA;  //Searches for a customer from the United States with a name like &#39;Jane&#39;.&#xA;  Query = &#34;Jane country:United States&#34;&#xA;};&#xA;IEnumerable&amp;lt;Customer&amp;gt; customers = await Service.SearchAsync(filter);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Orders&lt;/h2&gt; &#xA;&lt;h3&gt;Creating an order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;var order = new Order()&#xA;{&#xA;    CreatedAt = DateTime.UtcNow,&#xA;    BillingAddress = new Address()&#xA;    {&#xA;        Address1 = &#34;123 4th Street&#34;,&#xA;        City = &#34;Minneapolis&#34;,&#xA;        Province = &#34;Minnesota&#34;,&#xA;        ProvinceCode = &#34;MN&#34;,&#xA;        Zip = &#34;55401&#34;,&#xA;        Phone = &#34;555-555-5555&#34;,&#xA;        FirstName = &#34;John&#34;,&#xA;        LastName = &#34;Doe&#34;,&#xA;        Company = &#34;Tomorrow Corporation&#34;,&#xA;        Country = &#34;United States&#34;,&#xA;        CountryCode = &#34;US&#34;,&#xA;        Default = true,&#xA;    },&#xA;    LineItems = new List&amp;lt;LineItem&amp;gt;()&#xA;    {&#xA;        new LineItem()&#xA;        {&#xA;            Name = &#34;Test Line Item&#34;,&#xA;            Title = &#34;Test Line Item Title&#34;&#xA;        }&#xA;    },&#xA;    FinancialStatus = &#34;paid&#34;,&#xA;    TotalPrice = 5.00,&#xA;    Email = Guid.NewGuid().ToString() + &#34;@example.com&#34;,&#xA;    Note = &#34;Test note about the customer.&#34;,&#xA;};&#xA;&#xA;order = await service.CreateAsync(order);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving an order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;var order = await service.GetAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating an order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;var order = await service.UpdateAsync(orderId, new Order()&#xA;{&#xA;    Notes = &#34;test notes.&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting an order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting orders&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;int orderCount = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing orders&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;Order&amp;gt; orders = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Close an order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.CloseAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reopen a closed order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.OpenAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cancel an order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new OrderService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.CancelAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Products&lt;/h2&gt; &#xA;&lt;h3&gt;Creating a product&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;var product = new Product()&#xA;{&#xA;    Title = &#34;Burton Custom Freestlye 151&#34;,&#xA;    Vendor = &#34;Burton&#34;,&#xA;    BodyHtml = &#34;&amp;lt;strong&amp;gt;Good snowboard!&amp;lt;/strong&amp;gt;&#34;,&#xA;    ProductType = &#34;Snowboard&#34;,&#xA;    Images = new List&amp;lt;ProductImage&amp;gt;&#xA;    {&#xA;        new ProductImage&#xA;        {&#xA;            Attachment = &#34;R0lGODlhAQABAIAAAAAAAAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==&#34;&#xA;        }&#xA;    },&#xA;};&#xA;&#xA;product = await service.CreateAsync(product);&#xA;&#xA;//By default, creating a product will publish it. To create an unpublished product&lt;span&gt;👍&lt;/span&gt;&#xA;product = await service.CreateAsync(product, new ProductCreateOptions() { Published = false });&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a product&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;var product = await service.GetAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a product&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;var product = await service.UpdateAsync(productId, new Product()&#xA;{&#xA;    Title = &#34;New product title&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a product&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting products&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;int productCount = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing products&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;Product&amp;gt; products = await service.ListAsync();&#xA;&#xA;//Optionally filter the results&#xA;var filter = new ProductFilterOptions()&#xA;{&#xA;    Ids = new[]&#xA;    {&#xA;        productId1,&#xA;        productId2,&#xA;        productId3&#xA;    }&#xA;};&#xA;products = await service.ListAsync(filter);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Publishing a product&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;var product = await service.PublishAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unpublishing a product&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductService(myShopifyUrl, shopAccessToken);&#xA;var product = await service.UnpublishAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Webhooks&lt;/h2&gt; &#xA;&lt;h3&gt;Creating a webhook&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new WebhookService(myShopifyUrl, shopAccessToken);&#xA;Webhook hook = new Webhook()&#xA;{&#xA;    Address = &#34;https://my.webhook.url.com/path&#34;,&#xA;    CreatedAt = DateTime.Now,&#xA;    Fields = new List&amp;lt;string&amp;gt;() { &#34;field1&#34;, &#34;field2&#34; },&#xA;    Format = &#34;json&#34;,&#xA;    MetafieldNamespaces = new List&amp;lt;string&amp;gt;() { &#34;metafield1&#34;, &#34;metafield2&#34; },&#xA;    Topic = &#34;app/uninstalled&#34;,&#xA;};&#xA;&#xA;hook = await service.CreateAsync(hook);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a webhook&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new WebhookService(myShopifyUrl, shopAccessToken);&#xA;var webhook = await service.GetAsync(webhookId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a webhook&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new WebhookService(myShopifyUrl, shopAccessToken);&#xA;var webhook = await service.UpdateAsync(webhookId, new Webhook()&#xA;{&#xA;    Address = &#34;https://my.webhook.url.com/new/path&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a webhook&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new WebhookService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(webhookId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting webhooks&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new WebhookService(myShopifyUrl, shopAccessToken);&#xA;int webhookCount = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing webhooks&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new WebhookService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;Webhook&amp;gt; webhooks = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Script Tags&lt;/h2&gt; &#xA;&lt;p&gt;Script tags let you add remote javascript tags that are loaded into the pages of a shop&#39;s storefront, letting you dynamically change the functionality of their shop without manually editing their store&#39;s template.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a script tag&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ScriptTagService(myShopifyUrl, shopAccessToken);&#xA;var tag = new ScriptTag()&#xA;{&#xA;    Event = &#34;onload&#34;,&#xA;    Src  = &#34;https://example.com/my-javascript-file.js&#34;,&#xA;    DisplayScope = &#39;all&#39;&#xA;}&#xA;&#xA;tag = await service.CreateAsync(tag);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a script tag&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ScriptTagService(myShopifyUrl, shopAccessToken);&#xA;var tag = await service.GetAsync(tagId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a script tag&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ScriptTagService(myShopifyUrl, shopAccessToken);&#xA;var tag = await service.UpdateAsync(tagId, new ScriptTag()&#xA;{&#xA;    Src = &#34;https://example.com/my-new-javascript-file.js&#34;;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a script tag&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ScriptTagService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(tagId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting script tags&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ScriptTagService(myShopifyUrl, shopAccessToken);&#xA;int tagCount = await service.CountAsync();&#xA;&#xA;//Optionally filter the count to only those tags with a specific Src&#xA;int filteredTagCount = await service.CountAsync(&#34;https://example.com/my-filtered-url.js&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing script tags&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ScriptTagService(myShopifyUrl, shopAccessToken);&#xA;var tags = await service.ListAsync();&#xA;&#xA;//Optionally filter the list to only those tags with a specific Src&#xA;var filteredTags = await service.ListAsync(new ScriptTagListOptions() {&#xA;    Src = FilteredSrc&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Assets&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;AssetService&lt;/code&gt; lets you create, update and delete a store theme&#39;s asset files. Unlike other API services in ShopifySharp, the &lt;code&gt;AssetService&lt;/code&gt; has a single &lt;code&gt;.CreateOrUpdateAsync&lt;/code&gt; method due to the way Shopify&#39;s API handles assets. If an asset has a unique &lt;code&gt;Key&lt;/code&gt; value, it will be created. If not, it will be updated. You can copy an asset by setting the new asset&#39;s &lt;code&gt;SourceKey&lt;/code&gt; to the target&#39;s &lt;code&gt;Key&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;p&gt;Shopify asset&#39;s do not have an id, but rather a key string; they&#39;re also organized into type &#39;buckets&#39;. For a liquid template, it&#39;s full key would be &lt;code&gt;templates/liquid.index&lt;/code&gt;; for an image, its key would be &lt;code&gt;assets/my-image.png&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Finally, all assets are tied to a specific theme, and you need that theme&#39;s id to interact with assets. You can use the &lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#themes&#34;&gt;&lt;code&gt;ThemeService&lt;/code&gt;&lt;/a&gt; to get a list of the shop&#39;s themes, or the &lt;code&gt;ShopService&lt;/code&gt; to get the currently active theme&#39;s id.&lt;/p&gt; &#xA;&lt;h3&gt;Creating an asset&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new AssetService(myShopifyUrl, shopAccessToken);&#xA;var asset = new Asset()&#xA;{&#xA;    ContentType = &#34;text/x-liquid&#34;,&#xA;    Key = &#34;templates/test.liquid&#34;,&#xA;    Value  = &#34;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&#34;&#xA;}&#xA;&#xA;//Note: Creating an asset does not return it&#39;s &#39;Value&#39; property.&#xA;//You must specifically refresh it with service.GetAsync&#xA;asset = await service.CreateAsync(themeId, asset);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving an asset&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new AssetService(myShopifyUrl, shopAccessToken);&#xA;var key = &#34;templates/index.liquid&#34;;&#xA;&#xA;var asset = await service.GetAsync(themeId, key);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing assets&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new AssetService(myShopifyUrl, shopAccessToken);&#xA;&#xA;var assets = await service.ListAsync(themeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating assets&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new AssetService(myShopifyUrl, shopAccessToken);&#xA;&#xA;//Note: Updating an asset does not return it&#39;s &#39;Value&#39; property.&#xA;//You must specifically refresh it with service.GetAsync&#xA;var asset = await service.UpdateAsync(themeId, assetId, new Asset()&#xA;{&#xA;    Value = &#34;&amp;lt;h1&amp;gt;Hello, world! I&#39;ve been updated.&amp;lt;/h1&amp;gt;&#34;;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Copying an asset&lt;/h3&gt; &#xA;&lt;p&gt;You can create a new asset by copying an already existing one. Just set the new asset&#39;s &lt;code&gt;SourceKey&lt;/code&gt; property to match the target&#39;s &lt;code&gt;Key&lt;/code&gt; property.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new AssetService(myShopifyUrl, shopAccessToken);&#xA;var asset = new Asset()&#xA;{&#xA;    Key = &#34;templates/test.liquid&#34;,&#xA;    SourceKey = originalAsset.Key&#xA;};&#xA;&#xA;//Note: Creating an asset does not return it&#39;s &#39;Value&#39; property.&#xA;//You must specifically refresh it with service.GetAsync&#xA;asset = await service.UpdateAsync(themeId, assetId, asset);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Themes&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;ThemeService&lt;/code&gt; lets you create, update, list, get and delete a store&#39;s themes.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a theme&lt;/h3&gt; &#xA;&lt;p&gt;When you create a theme, you can optionally pass in a URL that points to a .zip file containing all of the new theme&#39;s files. Shopify will then copy those files into the theme. Be aware that copying files is not instant, and the theme&#39;s &lt;code&gt;Processing&lt;/code&gt; flag will be set to &lt;code&gt;true&lt;/code&gt; until it&#39;s done.&lt;/p&gt; &#xA;&lt;p&gt;You cannot update or delete a theme that is still processing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ThemeService(myShopifyUrl, shopAccessToken);&#xA;var theme = new Theme()&#xA;{&#xA;    Name = &#34;My new theme.&#34;,&#xA;    Role = &#34;unpublished&#34;&#xA;}&#xA;&#xA;theme = await service.CreateAsync(theme);&#xA;&#xA;//Or, create a theme and copy its files from a .zip file URL&#xA;theme = await service.CreateAsync(theme, &#39;https://my-domain.com/my-theme-files.zip&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a theme&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ThemeService(myShopifyUrl, shopAccessToken);&#xA;var theme = await service.GetAsync(themeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a theme&lt;/h3&gt; &#xA;&lt;p&gt;Remember, you can&#39;t update a theme if its &lt;code&gt;Processing&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt;. Shopify will automatically set it to &lt;code&gt;false&lt;/code&gt; once it&#39;s done processing. Additionally, you cannot set a theme&#39;s role from &lt;code&gt;&#34;main&#34;&lt;/code&gt; to &lt;code&gt;&#34;unpublished&#34;&lt;/code&gt;. Instead, you need to set a different theme&#39;s role to &lt;code&gt;&#34;main&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ThemeService(myShopifyUrl, shopAccessToken);&#xA;var theme = await service.UpdateAsync(themeId, new Theme()&#xA;{&#xA;    Role = ThemeRole.Main,&#xA;    Name = &#34;My updated theme.&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a theme&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ThemeService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(themeId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing themes&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new ThemeService(myShopifyUrl, shopAccessToken);&#xA;var themes = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Redirects&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;Redirect&lt;/code&gt; lets you create URL redirects on a Shopify store. When a store visitor navigates to a redirect&#39;s &lt;code&gt;Path&lt;/code&gt;, they&#39;ll be redirected to the redirect&#39;s &lt;code&gt;Target&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a redirect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RedirectService(myShopifyUrl, shopAccessToken);&#xA;var redirect = new Redirect()&#xA;{&#xA;    Path = &#34;/ipod&#34;,&#xA;    Target  = &#34;https://apple.com/ipod&#34;&#xA;}&#xA;&#xA;redirect = await service.CreateAsync(redirect);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a redirect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RedirectService(myShopifyUrl, shopAccessToken);&#xA;var redirect = await service.GetAsync(redirectId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a redirect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RedirectService(myShopifyUrl, shopAccessToken);&#xA;var redirect = await service.UpdateAsync(redirectId, new Redirect()&#xA;{&#xA;    Target = &#34;https://apple.com/ipad&#34;,&#xA;    Path = &#34;/ipad&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a redirect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RedirectService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(redirectId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting redirects&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RedirectService(myShopifyUrl, shopAccessToken);&#xA;int redirectCount = await service.CountAsync();&#xA;&#xA;//Optionally filter the count to only those redirects with a specific path or target&#xA;int filteredRedirectCount = await service.CountAsync(path: &#34;/ipod&#34;, target: &#34;https://apple.com/ipod/&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing redirects&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new RedirectService(myShopifyUrl, shopAccessToken);&#xA;var redirects = await service.ListAsync();&#xA;&#xA;//Optionally filter the list to only those redirects with a specific path or target&#xA;var filteredRedirects = await service.ListAsync(new RedirectListOptions() {&#xA;    Path = &#34;/ipod&#34;,&#xA;    Target = &#34;https://apple.com/ipod&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Collects&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;Collect&lt;/code&gt; is an object that connects a product to a custom collection.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a collect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CollectService(myShopifyUrl, shopAccessToken);&#xA;var collect = new Collect()&#xA;{&#xA;    CollectionId = collectionId,&#xA;    ProductId = productId&#xA;}&#xA;&#xA;collect = await service.CreateAsync(collect);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a collect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CollectService(myShopifyUrl, shopAccessToken);&#xA;var collect = await service.GetAsync(collectId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a collect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CollectService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(collectId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting collects&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CollectService(myShopifyUrl, shopAccessToken);&#xA;int collectCount = await service.CountAsync();&#xA;&#xA;//Optionally filter the count to only those collects for a certain product or collection&#xA;int filteredCollectCount = await service.CountAsync(new CollectFilterOptions()&#xA;{&#xA;    ProductId = productId,&#xA;    CollectionId = collectionId&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing collects&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CollectService(myShopifyUrl, shopAccessToken);&#xA;var collects = await service.ListAsync();&#xA;&#xA;//Optionally filter the list to only those collects for a certain product or collection&#xA;var filteredCollects = await service.CountAsync(new CollectFilterOptions()&#xA;{&#xA;    ProductId = productId,&#xA;    CollectionId = collectionId&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Fulfillments&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Shopify has changed how fulfillments are done in API version &lt;strong&gt;2022-07 and above&lt;/strong&gt;. This takes affect in &lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#API-support&#34;&gt;ShopifySharp versions &lt;strong&gt;5.19.0 and above&lt;/strong&gt;&lt;/a&gt;. If you&#39;re using these versions of ShopifySharp, you should use fulfillment orders to create fulfillments, rather than the &lt;code&gt;FulfillmentService&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/828&#34;&gt;Follow the example code in this issue&lt;/a&gt; until our fulfillment documentation is updated.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;A fulfillment represents a shipment of one or more items in an order. All fulfillments are tied to a single order.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a fulfillment for all fulfillment orders in Order&lt;/h3&gt; &#xA;&lt;p&gt;This will completely fulfill all of the fulfillment orders in the order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentShipping = new FulfillmentShipping()&#xA;{&#xA;    Message = &#34;Items will be shipped now.&#34;,&#xA;    NotifyCustomer = true,&#xA;    TrackingInfo = new TrackingInfo()&#xA;    {&#xA;        Number = &#34;123456789&#34;,&#xA;        Url = &#34;https://example.com/123456789&#34;,&#xA;        Company = &#34;Jack Black&#39;s Pack, Stack and Track&#34;&#xA;    },&#xA;    FulfillmentRequestOrderLineItems = []&#xA;};&#xA;&#xA;fulfillment = await service.CreateAsync(fulfillmentShipping);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a fulfillment for single fulfillment order in order&lt;/h3&gt; &#xA;&lt;p&gt;This will fulfill all line items of the specified fulfillment orders.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new FulfillmentService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentShipping = new FulfillmentShipping()&#xA;{&#xA;    Message = &#34;Items will be shipped now.&#34;,&#xA;    NotifyCustomer = true,&#xA;    TrackingInfo = new TrackingInfo()&#xA;    {&#xA;        Number = &#34;123456789&#34;,&#xA;        Url = &#34;https://example.com/123456789&#34;,&#xA;        Company = &#34;Jack Black&#39;s Pack, Stack and Track&#34;&#xA;    },&#xA;    FulfillmentRequestOrderLineItems = new List&amp;lt;LineItemsByFulfillmentOrder&amp;gt;()&#xA;    {&#xA;        new LineItemsByFulfillmentOrder() &#xA;        {&#xA;            FulfillmentOrderId = 1,&#xA;            FulfillmentRequestOrderLineItems = []&#xA;        }&#xA;    }&#xA;};&#xA;&#xA;fulfillment = await service.CreateAsync(fulfillmentShipping);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a fulfillment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentService(myShopifyUrl, shopAccessToken);&#xA;var fulfillment = await service.GetAsync(orderId, fulfillmentId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a fulfillment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new FulfillmentService(myShopifyUrl, shopAccessToken);&#xA;var fulfillment = await service.UpdateAsync(orderId, fulfillmentId, new Fulfillment()&#xA;{&#xA;    TrackingCompany = &#34;John Doe&#39;s Tracking Company&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting fulfillments&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentService(myShopifyUrl, shopAccessToken);&#xA;int fulfillmentCount = await service.CountAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing fulfillments&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentService(myShopifyUrl, shopAccessToken);&#xA;var fulfillments = await service.ListAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cancelling a fulfillment&lt;/h3&gt; &#xA;&lt;p&gt;Fulfillments can only be cancelled if their &lt;code&gt;Status&lt;/code&gt; is &lt;code&gt;pending&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new FulfillmentService(myShopifyUrl, shopAccessToken);&#xA;await service.CancelAsync(orderId, fulfillmentId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Assigned Fulfillment Orders&lt;/h2&gt; &#xA;&lt;p&gt;The AssignedFulfillmentOrder resource allows you to retrieve all the fulfillment orders that are assigned to an app at the shop level.&lt;/p&gt; &#xA;&lt;h3&gt;Listing assigned fulfillment orders&lt;/h3&gt; &#xA;&lt;p&gt;Retrieves a list of fulfillment orders on a shop for a specific app.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new AssignedFulfillmentOrderService(myShopifyUrl, shopAccessToken);&#xA;&#xA;//Optionally filter the list to only those assigned fulfillments with a specific status&#xA;var filterStatus = new AssignedFulfillmentOrderFilter()&#xA;{&#xA;    AssignmentStatus = &#34;fulfillment_requested&#34;&#xA;});&#xA;&#xA;var assignedFulfillments = await service.ListAsync(filterStatus);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Cancellation Requests&lt;/h2&gt; &#xA;&lt;p&gt;The CancellationRequest resource represents a cancellation request made by the merchant or an order management app to a fulfillment service for a fulfillment order.&lt;/p&gt; &#xA;&lt;h3&gt;Create A Cancellation Request&lt;/h3&gt; &#xA;&lt;p&gt;Send a cancellation request to the fulfillment service of a fulfillment order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CancellationRequestService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentOrder = await service.CreateAsync(fulfillmentOrderId, &#34;The customer changed his mind.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Accept A Cancellation Request&lt;/h3&gt; &#xA;&lt;p&gt;Accept a cancellation request sent to a fulfillment service for a fulfillment order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CancellationRequestService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentOrder = await service.AcceptAsync(fulfillmentOrderId, &#34;We had not started any processing yet.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reject A Cancellation Request&lt;/h3&gt; &#xA;&lt;p&gt;Reject a cancellation request sent to a fulfillment service for a fulfillment order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new CancellationRequestService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentOrder = await service.AcceptAsync(fulfillmentOrderId, &#34;We have already sent the shipment out.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Fulfillment Events&lt;/h2&gt; &#xA;&lt;p&gt;The FulfillmentEvent resource represents tracking events that belong to a fulfillment of one or more items in an order.&lt;/p&gt; &#xA;&lt;h3&gt;Creates a fulfillment event&lt;/h3&gt; &#xA;&lt;p&gt;Creates a new FulfillmentEvent on the fulfillment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentEventService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentEvent = new FulfillmentEvent()&#xA;{&#xA;    OrderId = 1234532,&#xA;    FulfillmentId = 156185165,&#xA;    Status = &#34;confirmed&#34;&#xA;};&#xA;&#xA;fulfillmentEvent = await service.CreateAsync(orderId, fulfillmentId, fulfillmentEvent);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List fulfillment events&lt;/h3&gt; &#xA;&lt;p&gt;Retrieves a list of fulfillment events for a specific fulfillment&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentEventService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentEvents = await service.ListAsync(orderId, fulfillmentId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get a Fulfillment Event&lt;/h3&gt; &#xA;&lt;p&gt;Retrieves a specific fulfillment event&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentEventService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentEvent = await service.GetAsync(orderId, fulfillmentId, fulfillmentEventId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delete A Fulfillment Event&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new FulfillmentEventService(myShopifyUrl, shopAccessToken);&#xA;await service.DeleteAsync(orderId, fulfillmentId, fulfillmentEventId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;--&lt;/p&gt; &#xA;&lt;h2&gt;Fulfillment Orders&lt;/h2&gt; &#xA;&lt;p&gt;The FulfillmentOrder resource represents either an item or a group of items in an order that are to be fulfilled from the same location. There can be more than one fulfillment order for an order at a given location.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;TODO&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;[X] Cancel a fulfillment order&lt;/li&gt; &#xA;  &lt;li&gt;[X] Mark a fulfillment order as incomplete&lt;/li&gt; &#xA;  &lt;li&gt;[ ] Move a fulfillment order to a new location&lt;/li&gt; &#xA;  &lt;li&gt;[ ] Mark the fulfillment order as open&lt;/li&gt; &#xA;  &lt;li&gt;[ ] Reschedule the fulfill_at time of a scheduled fulfillment order&lt;/li&gt; &#xA;  &lt;li&gt;[X] Retrieve a specific fulfillment order&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;List Fulfillment Orders&lt;/h3&gt; &#xA;&lt;p&gt;Retrieves a list of fulfillment orders for a specific order&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentOrderService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentOrders = await service.ListAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Fulfillment Requests&lt;/h2&gt; &#xA;&lt;p&gt;The FulfillmentRequest resource represents a fulfillment request made by the merchant to a fulfillment service for a fulfillment order.&lt;/p&gt; &#xA;&lt;h3&gt;Create A Fulfillment Request&lt;/h3&gt; &#xA;&lt;p&gt;Sends a fulfillment request to the fulfillment service of a fulfillment order&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentRequestService(myShopifyUrl, shopAccessToken);&#xA;&#xA;// Optionally, you can request only specific item to fulfilled.&#xA;var fulfillmentRequest = new FulfillmentRequest()&#xA;{&#xA;    FulfillmentRequestOrderLineItems = new List&amp;lt;FulfillmentRequestOrderLineItems&amp;gt;(){}&#xA;};&#xA;var fulfillmentOrder = await service.CreateAsync(fulfillmentOrderId, fulfillmentRequest);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Accept A Fulfillment Request&lt;/h3&gt; &#xA;&lt;p&gt;Accepts a fulfillment request sent to a fulfillment service for a fulfillment order&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentRequestService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentOrder = await service.AcceptAsync(fulfillmentOrderId, &#34;Your order will be filled shortly.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reject A Fulfillment Request&lt;/h3&gt; &#xA;&lt;p&gt;Reject a fulfillment request sent to a fulfillment service for a fulfillment order&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentRequestService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentOrder = await service.AcceptAsync(fulfillmentOrderId, &#34;Fulfillment services have been suspended for this store.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Fulfillment Services&lt;/h2&gt; &#xA;&lt;p&gt;A Fulfillment Service is a third party warehouse that prepares and ships orders on behalf of the store owner. Fulfillment services charge a fee to package and ship items and update product inventory levels. Some well known fulfillment services with Shopify integrations include: Amazon, Shipwire, and Rakuten. When an app registers a new FulfillmentService on a store, Shopify automatically creates a Location that&#39;s associated to that fulfillment service.&lt;/p&gt; &#xA;&lt;h3&gt;Create a Fulfillment Service&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentServiceService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentService = await service.CreateAsync(new FulfillmentServiceEntity()&#xA;{&#xA;    Name = &#34;Your Company Name&#34;, &#xA;    CallbackUrl = &#34;http://yourcompany.com&#34;, &#xA;    InventoryManagement = true,&#xA;    TrackingSupport = true,&#xA;    FulfillmentOrdersOptIn = true,&#xA;    RequiresShippingMethod = true, &#xA;    Format = &#34;json&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List Fulfillment Services&lt;/h3&gt; &#xA;&lt;p&gt;Retrieves a list of fulfillment orders for a specific order&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentServiceService(myShopifyUrl, shopAccessToken);&#xA;// Optional Filter&#xA;var filter = new FulfillmentServiceListFilter(){ Scope = &#34;all&#34;};&#xA;var fulfillmentServices = await service.ListAsync(filter);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get a Fulfillment Service&lt;/h3&gt; &#xA;&lt;p&gt;Retrieves a single Fulfillment Service&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentServiceService(myShopifyUrl, shopAccessToken);&#xA;// Optional Filter&#xA;var fields = &#34;id,name,email&#34;;&#xA;var fulfillmentService = await service.GetAsync(fulfillmentServiceId, fields);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Modify a Fulfillment Service&lt;/h3&gt; &#xA;&lt;p&gt;Update a Fulfillment Service. Not all fields are updatable&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentServiceService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentService = await service.UpdateAsync(fulfillmentServiceId, fulfillmentServiceEntity);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delete a Fulfillment Service&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new FulfillmentServiceService(myShopifyUrl, shopAccessToken);&#xA;var fulfillmentService = await service.DeleteAsync(fulfillmentServiceId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Transactions&lt;/h2&gt; &#xA;&lt;p&gt;Transactions are created for every order that results in an exchange of money. All transactions are tied to a single order.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a full capture transaction&lt;/h3&gt; &#xA;&lt;p&gt;By omitting an &lt;code&gt;Amount&lt;/code&gt; value, this transaction will capture the full amount.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: to create a &lt;code&gt;Capture&lt;/code&gt; transaction, the order must have an &lt;code&gt;Authorization&lt;/code&gt; transaction on it. However, an &lt;code&gt;Authorization&lt;/code&gt; transaction can only be created at the time the order was created.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TransactionService(myShopifyUrl, shopAccessToken);&#xA;var transaction = new Transaction()&#xA;{&#xA;    Kind = &#34;capture&#34;&#xA;};&#xA;&#xA;await service.CreateAsync(orderId, transaction);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a partial capture transaction&lt;/h3&gt; &#xA;&lt;p&gt;This method will capture a specified amount on a previously authorized order.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: to create a &lt;code&gt;Capture&lt;/code&gt; transaction, the order must have an &lt;code&gt;Authorization&lt;/code&gt; transaction on it. However, an &lt;code&gt;Authorization&lt;/code&gt; transaction can only be created at the time the order was created.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TransactionService(myShopifyUrl, shopAccessToken);&#xA;var transaction = new Transaction()&#xA;{&#xA;    Kind = &#34;capture&#34;,&#xA;    Amount = 5.00&#xA;};&#xA;&#xA;await service.CreateAsync(orderId, transaction);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a refund transaction&lt;/h3&gt; &#xA;&lt;p&gt;This method will create a refund on a previously authorized order. Like the last two examples, you can either refund a partial amount by setting the &lt;code&gt;Amount&lt;/code&gt; value, or refund the full amount by omitting that value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: to create a &lt;code&gt;Refund&lt;/code&gt; transaction, the order must have an &lt;code&gt;Authorization&lt;/code&gt; transaction on it. However, an &lt;code&gt;Authorization&lt;/code&gt; transaction can only be created at the time the order was created.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Additionally&lt;/strong&gt;, it seems you can&#39;t create a &lt;code&gt;Refund&lt;/code&gt; transaction for any order that was created via the API. (I can&#39;t find any documentation about this behavior. Let me know if this is wrong.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TransactionService(myShopifyUrl, shopAccessToken);&#xA;var transaction = new Transaction()&#xA;{&#xA;    Kind = &#34;refund&#34;,&#xA;    Amount = 5.00&#xA;};&#xA;&#xA;await service.CreateAsync(orderId, transaction);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a cancel transaction&lt;/h3&gt; &#xA;&lt;p&gt;This method is supposed to cancel a previously authorized order&#39;s payment. &lt;strong&gt;However&lt;/strong&gt;, the Shopify API will throw an error whenever you try to do this. It may be that, like the refund transaction, you can&#39;t cancel an order that was created via the API. Again, there&#39;s no documentation for this behavior, let me know if you have any information.&lt;/p&gt; &#xA;&lt;p&gt;That in mind, I&#39;m including this example for posterity.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TransactionService(myShopifyUrl, shopAccessToken);&#xA;var transaction = new Transaction()&#xA;{&#xA;    Kind = &#34;void&#34;&#xA;};&#xA;&#xA;//Throws an error.&#xA;await service.CreateAsync(orderId, transaction);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a transaction&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TransactionService(myShopifyUrl, shopAccessToken);&#xA;var transaction = await service.GetAsync(orderId, transactionId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting transactions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TransactionService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing transactions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TransactionService(myShopifyUrl, shopAccessToken);&#xA;var transactions = await service.ListAsync(orderId);&#xA;&#xA;//Optionally filter the list to those after the given id&#xA;var transactions = await service.ListAsync(orderId, sinceId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tender Transactions&lt;/h2&gt; &#xA;&lt;p&gt;Each tender transaction represents money passing between the merchant and a customer. A tender transaction with a positive amount represents a transaction where the customer paid money to the merchant. A negative amount represents a transaction where the merchant refunded money back to the customer. Tender transactions represent transactions that modify the shop&#39;s balance.&lt;/p&gt; &#xA;&lt;h3&gt;Listing tender transactions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new TenderTransactionService(myShopifyUrl, shopAccessToken);&#xA;var tenderTransactions = await service.ListAsync();&#xA;&#xA;//Optionally filter the list to transactions processed after the specified date/time&#xA;var transactions = await service.ListAsync(new TenderTransactionListFilter&#xA;{&#xA;    ProcessedAtMin = DateTimeOffset.Now.AddHours(-1)&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Pages&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;Page&lt;/code&gt; represents a web page on the merchant&#39;s Shopify storefront.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a page&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PageService(myShopifyUrl, shopAccessToken);&#xA;var page = new Page()&#xA;{&#xA;    CreatedAt = DateTime.UtcNow,&#xA;    Title = &#34;Burton Custom Freestlye 151&#34;,&#xA;    BodyHtml = &#34;&amp;lt;strong&amp;gt;Good snowboard!&amp;lt;/strong&amp;gt;&#34;,&#xA;};&#xA;&#xA;page = await service.CreateAsync(page);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting a page&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PageService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing pages&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PageService(myShopifyUrl, shopAccessToken);&#xA;var pages = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving a page&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PageService(myShopifyUrl, shopAccessToken);&#xA;var page = await service.GetAsync(pageId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a page&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PageService(myShopifyUrl, shopAccessToken);&#xA;var page = await service.UpdateAsync(pageId, new Page()&#xA;{&#xA;    Title = &#34;My new page title&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a page&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service = new PageService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(pageId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Metafields&lt;/h2&gt; &#xA;&lt;h3&gt;Creating a metafield&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new MetaFieldService(myShopifyUrl, shopAccessToken);&#xA;var metafield = new MetaField()&#xA;{&#xA;    Namespace = &#34;myNamespace&#34;,&#xA;    Key = &#34;myKey&#34;,&#xA;    Value = &#34;5&#34;,&#xA;    ValueType = &#34;integer&#34;,&#xA;    Description = &#34;This is a test meta field. It is an integer value.&#34;&#xA;};&#xA;&#xA;//Create a new metafield on a product&#xA;metafield = await service.CreateAsync(metafield, productId, &#34;products&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting metafields&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new MetaFieldService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync(productId, &#34;products&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing metafields&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new MetaFieldService(myShopifyUrl, shopAccessToken);&#xA;var metafields = await service.ListAsync(productId, &#34;products&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a metafield&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new MetaFieldService(myShopifyUrl, shopAccessToken);&#xA;var metafield = await service.GetAsync(metafieldId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a metafield&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new MetaFieldService(myShopifyUrl, shopAccessToken);&#xA;var metafield = await service.UpdateAsync(metafieldId, new MetaField()&#xA;{&#xA;    Value = &#34;45&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a metafield&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new MetaFieldService(myShopifyUrl, shopAccessToken);&#xA;await service.DeleteAsync(metafieldId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Collections&lt;/h2&gt; &#xA;&lt;p&gt;A custom collection is a grouping of products that a shop owner can create to make their shops easier to browse. A shop owner creates a custom collection and then selects the products that will go into it.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a custom collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CustomCollectionService(myShopifyUrl, shopAccessToken);&#xA;var collection = await service.CreateAsync(new CustomCollection()&#xA;{&#xA;    Title = &#34;My Custom Collection&#34;,&#xA;    Published = true,&#xA;    PublishedAt = DateTime.UtcNow,&#xA;    Image = new CustomCollectionImage()&#xA;    {&#xA;        Src = &#34;https://placekitten.com/250/250&#34;&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a custom collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CustomCollectionService(myShopifyUrl, shopAccessToken);&#xA;var collection = await service.GetAsync(collectionId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting custom collections&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CustomCollectionService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing custom collections&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CustomCollectionService(myShopifyUrl, shopAccessToken);&#xA;var collections = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a custom collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CustomCollectionService(myShopifyUrl, shopAccessToken);&#xA;var collection = await service.UpdateAsync(collectionId, new Collection()&#xA;{&#xA;    Title = &#34;My new collection title&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a custom collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CustomCollectionService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(collectionId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Product Images&lt;/h2&gt; &#xA;&lt;p&gt;Product Images represent the various different images for a product. All product images are tied to an owner product, and therefore you&#39;ll need to pass that product&#39;s id to each product image method.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a product image&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductImageService(myShopifyUrl, shopAccessToken);&#xA;var image = await service.CreateAsync(productId, new ProductImage()&#xA;{&#xA;    Metafields = new List&amp;lt;MetaField&amp;gt;()&#xA;    {&#xA;        new MetaField()&#xA;        {&#xA;            Key = &#34;alt&#34;,&#xA;            Value = &#34;new alt tag content&#34;,&#xA;            ValueType = &#34;string&#34;,&#xA;            Namespace = &#34;tags&#34;&#xA;        }&#xA;    },&#xA;    Src = &#34;https://placekitten.com/200/300&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a product image&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductImageService(myShopifyUrl, shopAccessToken);&#xA;var image = await service.GetAsync(productId, imageId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting product images&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductImageService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing product images&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductImageService(myShopifyUrl, shopAccessToken);&#xA;var images = await service.ListAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a product image&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductImageService(myShopifyUrl, shopAccessToken);&#xA;var image = await service.UpdateAsync(productId, imageId, new Image()&#xA;{&#xA;    Position = 2&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a product image&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductImageService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(productId, imageId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Locations&lt;/h2&gt; &#xA;&lt;p&gt;A Location represents a geographical location where your stores, headquarters, and/or pop-up shops exist. These locations can be used to track sales and to help Shopify configure the tax rates to charge when selling products.&lt;/p&gt; &#xA;&lt;h3&gt;Listing locations&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new LocationService(myShopifyUrl, shopAccessToken);&#xA;var locations = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a location&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new LocationService(myShopifyUrl, shopAccessToken);&#xA;var location = await service.GetAsync(locationId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Events&lt;/h2&gt; &#xA;&lt;p&gt;Events are generated by specific Shopify resources when specific things happen, such as the creation of an article, the placement or fulfillment of an order, the addition or deletion of a product, and so on. By requesting events, your app can get a &#34;log&#34; of important occurrences in the operation of a shop.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Caution:&lt;/strong&gt; the events returned by the Events API should not be considered to be realtime. Events might not appear in the list returned by the API until a few seconds after they&#39;ve occurred. In rare cases (&amp;lt;1% of the time) it can take up to a few minutes for some events to appear.&lt;/p&gt; &#xA;&lt;h3&gt;Counting events&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new EventService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting an event&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new EventService(myShopifyUrl, shopAccessToken);&#xA;var event = await service.GetAsync(eventId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing events&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new EventService(myShopifyUrl, shopAccessToken);&#xA;var events = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing events for a specific subject (e.g. Order or Product)&lt;/h3&gt; &#xA;&lt;p&gt;You can filter your event list result to only the events created by a specific &#34;subject&#34;; i.e. you can list all events for one specific Order, Product, Article, etc. When filtering events in this way, you must supply both the &#34;subject&#34; type &lt;em&gt;and&lt;/em&gt; its id.&lt;/p&gt; &#xA;&lt;p&gt;Known subject types are &#39;Articles&#39;, &#39;Blogs&#39;, &#39;Custom_Collections&#39;, &#39;Comments&#39;, &#39;Orders&#39;, &#39;Pages&#39;, &#39;Products&#39; and &#39;Smart_Collections&#39;. A current list of subject types can be found at &lt;a href=&#34;https://help.shopify.com/api/reference/event&#34;&gt;https://help.shopify.com/api/reference/event&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new EventService(myShopifyUrl, shopAccessToken);&#xA;var subjectType = &#34;Order&#34;;&#xA;var orderEvents = await service.ListAsync(orderId, subjectType);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Order Risks&lt;/h2&gt; &#xA;&lt;p&gt;The Order risk assessment is used to indicate to a merchant the fraud checks that have been done on an order.&lt;/p&gt; &#xA;&lt;h3&gt;Create an Order Risk&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new OrderRiskService(myShopifyUrl, shopAccessToken);&#xA;var risk = await service.CreateAsync(orderId, new OrderRisk()&#xA;{&#xA;    Message = &#34;This looks risk!&#34;,&#xA;    Score = (decimal)0.85,&#xA;    Recommendation = &#34;cancel&#34;,&#xA;    Source = &#34;External&#34;,&#xA;    CauseCancel = false,&#xA;    Display = true,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get an Order Risk&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new OrderRiskService(myShopifyUrl, shopAccessToken);&#xA;var risk = await service.GetAsync(orderId, riskId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Update an Order Risk&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new OrderRiskService(myShopifyUrl, shopAccessToken);&#xA;var risk = await service.UpdateAsync(orderId, riskId, new Risk()&#xA;{&#xA;    Message = &#34;An updated risk message&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List Order Risks&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new OrderRiskService(myShopifyUrl, shopAccessToken);&#xA;var risks = await service.ListAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delete an Order Risk&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new OrderRiskService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(orderId, riskId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Smart Collections&lt;/h2&gt; &#xA;&lt;p&gt;A smart collection is a grouping of products defined by simple rules set by shop owners. A shop owner creates a smart collection and then sets the rules that determine which products go in them. Shopify automatically changes the contents of smart collections based on their rules.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Smart Collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new SmartCollectionService(myShopifyUrl, shopAccessToken);&#xA;var smartCollection = await service.CreateAsync(new SmartCollection()&#xA;{&#xA;   Title = &#34;My Smart Collection&#34;,&#xA;   Handle = &#34;my-url-slug&#34;,&#xA;   BodyHtml = &#34;\&amp;lt;h1\&amp;gt;Hello world!\&amp;lt;/h1\&amp;gt;&#34;,&#xA;   Image = new SmartCollectionImage()&#xA;   {&#xA;       // Base-64 image attachment&#xA;       Attachment = &#34;R0lGODlhAQABAIAAAAAAAAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\n&#34;&#xA;   }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a Smart Collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new SmartCollectionService(myShopifyUrl, shopAccessToken);&#xA;var smartCollection = await service.UpdateAsync(smartCollectionId, new SmartCollection()&#xA;{&#xA;    Title = &#34;My updated title&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Smart Collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new SmartCollectionService(myShopifyUrl, shopAccessToken);&#xA;var smartCollection = await service.GetAsync(smartCollectionId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting Smart Collections&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new SmartCollectionService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Smart Collections&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new SmartCollectionService(myShopifyUrl, shopAccessToken);&#xA;var smartCollections = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a Smart Collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new SmartCollectionService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(smartCollectionId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Product Variants&lt;/h2&gt; &#xA;&lt;p&gt;A product variant is a different version of a product, such as differing sizes or differing colors. Without product variants, you would have to treat the small, medium and large versions of a t-shirt as three separate products; product variants let you treat the small, medium and large versions of a t-shirt as variations of the same product.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Product with a variant in one go&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt; var product = new Product()&#xA; {&#xA;     Title = &#34;Test Product Walter&#34;,&#xA;     Vendor = &#34;Burton&#34;,&#xA;     BodyHtml = &#34;&amp;lt;strong&amp;gt;Good snowboard!&amp;lt;/strong&amp;gt;&#34;,&#xA;     ProductType = &#34;Snowboard&#34;,&#xA;     Images = images,&#xA;     //Make sure to give your product the correct variant option&#xA;     Options = new List&amp;lt;ProductOption&amp;gt;&#xA;     {&#xA;         new ProductOption&#xA;         {&#xA;             Name = &#34;Color&#34;&#xA;         }&#xA;     },&#xA;     //And then create a collection of variants or assign the &#34;Variants&#34; property&#xA;     //to an already defined collection.&#xA;     Variants = new List&amp;lt;ProductVariant&amp;gt;&#xA;     {&#xA;         new ProductVariant&#xA;         {&#xA;             Option1 = &#34;Black&#34;,&#xA;         },&#xA;         new ProductVariant&#xA;         {&#xA;             Option1 = &#34;Green&#34;,&#xA;         },&#xA;     }&#xA; };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a Product Variant&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductVariantService(myShopifyUrl, shopAccessToken);&#xA;var variant = await service.CreateAsync(productId, new ProductVariant()&#xA;{&#xA;    Option1 = &#34;blue&#34;,&#xA;    Price = 123.45,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Product Variant&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductVariantService(myShopifyUrl, shopAccessToken);&#xA;var variant = await service.GetAsync(variantId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a Product Variant&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductVariantService(myShopifyUrl, shopAccessToken);&#xA;var variant = await service.UpdateAsync(variantId, new Variant()&#xA;{&#xA;    Price = 543.21&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Product Variants&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductVariantService(myShopifyUrl, shopAccessToken);&#xA;var variants = await service.ListAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting Product Variants&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductVariantService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync(productId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a Product Variant&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductVariantService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(productId, variantId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Blogs&lt;/h2&gt; &#xA;&lt;p&gt;In addition to an online storefront, Shopify shops come with a built-in blogging engine, allowing a shop to have one or more blogs. &lt;strong&gt;This service is for interacting with blogs themselves, not &lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#articles&#34;&gt;blog posts&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Blogs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new BlogService(myShopifyUrl, shopAccessToken);&#xA;var blog = await service.CreateAsync(new Blog()&#xA;{&#xA;    Title = &#34;My new blog&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Blog&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new BlogService(myShopifyUrl, shopAccessToken);&#xA;var blog = await service.GetAsync(blogId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a Blog&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new BlogService(myShopifyUrl, shopAccessToken);&#xA;var blog = await service.UpdateAsync(blogId, new Blog()&#xA;{&#xA;    Comments = &#34;moderate&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Blogs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new BlogService(myShopifyUrl, shopAccessToken);&#xA;var blogs = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting Blogs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new BlogService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a Blog&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new BlogService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(blogId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Articles&lt;/h2&gt; &#xA;&lt;p&gt;Articles are objects representing a blog post. Each article belongs to a &lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#blogs&#34;&gt;Blog&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Creating an Article&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;var article = await service.CreateAsync(blogId, new Article()&#xA;{&#xA;    Title = &#34;My new Article title&#34;,&#xA;    Author = &#34;John Smith&#34;,&#xA;    Tags = &#34;This Post, Has Been Tagged&#34;,&#xA;    BodyHtml = &#34;&amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;&#34;,&#xA;    Image = new ArticleImage()&#xA;    {&#xA;        Attachment = &#34;R0lGODlhAQABAIAAAAAAAAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\n&#34;&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting an Article&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;var article = await service.GetAsync(blogId, articleId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating an Article&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;var article = await service.UpdateAsync(blogId, articleId, new Article()&#xA;{&#xA;    Title = &#34;My new title&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Articles&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;var articles = await service.ListAsync(blogId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting Articles&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync(blogId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting an Article&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(blogId, articleId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing all Article authors&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;string&amp;gt; authors = await service.ListAuthorsAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing all Article tags&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;string&amp;gt; tags = await service.ListTagsAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing all Article tags for a single Blog&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ArticleService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;string&amp;gt; tags = await service.ListTagsForBlogAsync(blogId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Application Credits&lt;/h2&gt; &#xA;&lt;p&gt;Shopify&#39;s Application Credit API lets you offer credits for payments your app customers have made via the Application Charge, Recurring Application Charge, and Usage Charge APIs.&lt;/p&gt; &#xA;&lt;p&gt;The total amount of all Application Credits created by an application must not exceed:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Total amount paid to the application by the shop owner in the last 30 days.&lt;/li&gt; &#xA; &lt;li&gt;Total amount of pending receivables in the partner account associated with the application.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additionally, Application Credits cannot be used by private applications.&lt;/p&gt; &#xA;&lt;h3&gt;Creating an Application Credit&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ApplicationCreditService(myShopifyUrl, shopAccessToken);&#xA;var credit = await service.CreateAsync(new ApplicationCredit()&#xA;{&#xA;    Description = &#34;Refund for Foo&#34;,&#xA;    Amount = 10.00m&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting an Application Credit&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ApplicationCreditService(myShopifyUrl, shopAccessToken);&#xA;var charge = await service.GetAsync(creditId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Application Credits&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ApplicationCreditService(myShopifyUrl, shopAccessToken);&#xA;var charges = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Discounts&lt;/h2&gt; &#xA;&lt;p&gt;Developers can create a discount code with the &lt;code&gt;DiscountService&lt;/code&gt;. A merchant&#39;s customers can enter the discount code during the checkout process to redeem percentage-based, fixed amount, or free shipping discounts on a specific product, collection or order.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Discounts require a Shopify Plus subscription.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Discount&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DiscountService(myShopifyUrl, shopAccessToken);&#xA;var discount = await service.CreateAsync(new Discount()&#xA;{&#xA;    DiscountType = &#34;fixed_amount&#34;,&#xA;    Value = &#34;10.00&#34;,&#xA;    DiscountCode = &#34;AuntieDot&#34;,&#xA;    MinimumOrderAmount = &#34;40.00&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Discount&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DiscountService(myShopifyUrl, shopAccessToken);&#xA;var discount = await service.GetAsync(discountId):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Discounts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DiscountService(myShopifyUrl, shopAccessToken);&#xA;var discounts = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a Discount&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DiscountService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(discountId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Disabling a Discount&lt;/h3&gt; &#xA;&lt;p&gt;Discount codes can be disabled via that API, which makes them inactive and unusable until reenabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DiscountService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DisableAsync(discountId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enabling a Discount&lt;/h3&gt; &#xA;&lt;p&gt;Once disabled, a discount cannot be used by any customer until it&#39;s enabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DiscountService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.EnableAsync(discountId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Policies&lt;/h2&gt; &#xA;&lt;p&gt;Developers can get the list of policies that a merchant has configured for their store, such as their refund or privacy policies.&lt;/p&gt; &#xA;&lt;h3&gt;Listing Policies&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PolicyService(myShopifyUrl, shopAccessToken);&#xA;var policies = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Shipping Zones&lt;/h2&gt; &#xA;&lt;p&gt;Developers can get the list of shipping zones, their countries, provinces, and shipping rates.&lt;/p&gt; &#xA;&lt;h3&gt;Listing Shipping Zones&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ShippingZoneService(myShopifyUrl, shopAccessToken);&#xA;var shippingZones = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Gift Cards&lt;/h2&gt; &#xA;&lt;p&gt;Developers can create a gift card with the &lt;code&gt;GiftCardService&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Gift Cards require a Shopify Plus subscription.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Listing Gift Cards&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new GiftCardService(myShopifyUrl, shopAccessToken);&#xA;var giftCards = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a Gift Card&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new GiftCardService(myShopifyUrl, shopAccessToken);&#xA;var giftCard = await service.CreateAsync(new GiftCard()&#xA;{&#xA;    InitialValue = 100,&#xA;    Code = &#34;abc-bcd-efg&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Gift Card&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new GiftCardService(myShopifyUrl, shopAccessToken);&#xA;var giftCard = await service.GetAsync(giftCardId):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Disabling a Gift Card&lt;/h3&gt; &#xA;&lt;p&gt;Gift Cards can be disabled via that API, which makes them inactive and unusable until reenabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new GiftCardService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DisableAsync(discountId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting a Gift Cards&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new GiftCardService(myShopifyUrl, shopAccessToken);&#xA;int giftCardCount = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Searching a Gift Cards&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var service =  new GiftCardService(myShopifyUrl, shopAccessToken);&#xA;IEnumerable&amp;lt;GiftCard&amp;gt; giftCards = await Service.SearchAsync(&#34;code: abc-bcd-efg&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Gift Card Adjustments&lt;/h2&gt; &#xA;&lt;p&gt;Developers can create adjustments on existing gift cards with the &lt;code&gt;GiftCardAdjustmentService&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Gift Cards require a Shopify Plus subscription and also the Gift Card Adjustment endpoint needs to be enabled on your store, contact Shopify plus support for more info.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Listing Gift Card Adjustments&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new GiftCardAdjustmentService(myShopifyUrl, shopAccessToken);&#xA;var giftCardAdjustments = await service.ListAsync(giftCardId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a Gift Card Adjustment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new GiftCardAdjustmentService(myShopifyUrl, shopAccessToken);&#xA;var giftCard = await service.CreateAsync(giftCardId, new GiftCardAdjustment()&#xA;{&#xA;    Amount = -1.00,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Gift Card Adjustment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new GiftCardAdjustmentService(myShopifyUrl, shopAccessToken);&#xA;var giftCardAdjustment = await service.GetAsync(giftCardId, adjustmentId):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Price Rules&lt;/h2&gt; &#xA;&lt;p&gt;The Price Rules API allows you to dynamically create discounts with multiple conditions that can be applied at checkout to cart items or shipping lines via a discount code. Price rules can be created for a fixed value discount, a percentage discount, or a shipping line discount. You can also specify the dates for which the price rule is valid, the number of times the price rule can be applied, and to which products, collections, variants, customer groups and even shipping countries the price rule can be applied.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Price Rule&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PriceRuleService(myShopifyUrl, shopAccessToken);&#xA;var priceRule = await service.CreateAsync(new PriceRule()&#xA;{&#xA;    Title = &#34;My price rule&#34;,&#xA;    ValueType = &#34;percentage&#34;,&#xA;    TargetType = &#34;line_item&#34;,&#xA;    TargetSelection = &#34;all&#34;,&#xA;    AllocationMethod = &#34;across&#34;,&#xA;    Value = -10.0m,&#xA;    CustomerSelection = &#34;all&#34;,&#xA;    OncePerCustomer = false,&#xA;    PrerequisiteSubtotalRange = new PrerequisiteValueRange()&#xA;    {&#xA;        GreaterThanOrEqualTo = 40m&#xA;    },&#xA;    StartsAt = new DateTimeOffset(DateTime.Now)&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating a Price Rule&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PriceRuleService(myShopifyUrl, shopAccessToken);&#xA;var updatedRule = await service.UpdateAsync(ruleId, new PriceRule()&#xA;{&#xA;    Value = -15.0m&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Price Rule&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PriceRuleService(myShopifyUrl, shopAccessToken);&#xA;var priceRule = await service.GetAsync(ruleId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Price Rules&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PriceRuleService(myShopifyUrl, shopAccessToken);&#xA;var priceRules = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a Price Rule&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new PriceRuleService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(ruleId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Users&lt;/h2&gt; &#xA;&lt;p&gt;Developers can retrieve users with the &lt;code&gt;UserService&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;The Users API requires a Shopify Plus subscription.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Listing Users&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new UserService(myShopifyUrl, shopAccessToken);&#xA;var users = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a User&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new UserService(myShopifyUrl, shopAccessToken);&#xA;var user = await service.GetAsync(userId):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Abandoned Checkouts&lt;/h2&gt; &#xA;&lt;p&gt;This is used to return abandoned checkouts. A checkout is considered abandoned when a customer has entered their billing &amp;amp; shipping info, but has yet to complete the purchase.&lt;/p&gt; &#xA;&lt;h3&gt;Listing Abandoned Checkouts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CheckoutService(myShopifyUrl, shopAccessToken);&#xA;var checkouts = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Count Abandoned Checkouts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CheckoutService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Draft Orders&lt;/h2&gt; &#xA;&lt;p&gt;You can use the DraftOrder resource to allow merchants to create orders on behalf of customers. This is useful for Shopify merchants who receive orders through outside channels and enables a wide range of use cases including the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create new orders for sales made by phone, in person, via chat, or by other means. Credit card payments for these orders can subsequently be entered in the Shopify admin.&lt;/li&gt; &#xA; &lt;li&gt;Send invoices to customers to pay with a secure checkout link.&lt;/li&gt; &#xA; &lt;li&gt;Use custom items to represent additional costs or products that aren&#39;t displayed in a shop&#39;s inventory.&lt;/li&gt; &#xA; &lt;li&gt;Re-create mistaken orders.&lt;/li&gt; &#xA; &lt;li&gt;Sell products at discount or wholesale rates.&lt;/li&gt; &#xA; &lt;li&gt;Take pre-orders.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Listing Draft Orders&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;var draftOrders = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting Draft orders&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;var count = await service.CountAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting a Draft Order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;var draftOrder = await service.GetAsync(draftOrderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Create a Draft Order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;var draftOrder = await Service.CreateAsync(new DraftOrder()&#xA;{&#xA;    LineItems = new List&amp;lt;DraftLineItem&amp;gt;()&#xA;    {&#xA;        new DraftLineItem()&#xA;        {&#xA;            Title = &#34;My custom line item&#34;,&#xA;            Price = 15.00m,&#xA;            Quantity = 1,&#xA;        }&#xA;    },&#xA;    Note = &#34;Hello world!&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Update a Draft Order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;var original = await Service.GetAsync(originalOrderId);&#xA;original.Note = &#34;My new note&#34;;&#xA;&#xA;var updated = await Service.UpdateAsync(originalOrderId, original);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delete a Draft Order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(orderId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send a Draft Order invoice&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;var invoice = await service.SendInvoiceAsync(new DraftOrderInvoice()&#xA;{&#xA;    To = &#34;customer@example.com&#34;,&#xA;    Subject = &#34;Your order is ready to pay&#34;,&#xA;    CustomMessage = &#34;Please pay!&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Complete a Draft Order&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new DraftOrderService(myShopifyUrl, shopAccessToken);&#xA;bool paymentPending = false;&#xA;var draftOrder = await service.CompleteAsync(orderId, paymentPending);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Access Scopes&lt;/h2&gt; &#xA;&lt;p&gt;The Access Scope API allows you to retrieve the permissions that a merchant has granted to an app, such as &lt;code&gt;read_orders&lt;/code&gt; and &lt;code&gt;write_products&lt;/code&gt;. The list of access scopes is retrieved based on the access token used for the request, and only returns those scopes associated with the token.&lt;/p&gt; &#xA;&lt;h3&gt;List Access Scopes&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new AccessScopeService(myShopifyUrl, shopAccessToken);&#xA;var scopes = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Checkouts&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re building an app with the Sales Channel SDK, then you can use the Checkout API to let customers purchase products from Shopify stores that have installed your sales channel.&lt;/p&gt; &#xA;&lt;p&gt;Shopify uses the Checkout resource to manage a user&#39;s cart as it transitions to a paid order. This process includes specifying which line items are included in the checkout, attaching a customer&#39;s shipping and payment details, and calculating tax and shipping rates. Credit card payments can be attached to a Checkout using the Payment resource.&lt;/p&gt; &#xA;&lt;h3&gt;Create Checkouts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CheckoutService(myShopifyUrl, shopAccessToken);&#xA;var checkout = await service.CreateAsync(new Checkout&#xA;{&#xA;    Email = &#34;joshua@nozzlegear.com&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Complete Checkouts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CheckoutService(myShopifyUrl, shopAccessToken);&#xA;var checkoutToken = &#34;token&#34;;&#xA;var checkout = await service.CompleteAsync(checkoutToken);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get Checkouts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CheckoutService(myShopifyUrl, shopAccessToken);&#xA;var checkoutToken = &#34;token&#34;;&#xA;var checkout = await service.GetAsync(checkoutToken);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updates Checkouts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CheckoutService(myShopifyUrl, shopAccessToken);&#xA;var checkoutToken = &#34;token&#34;;&#xA;var checkout = await service.UpdateAsync(checkoutToken, new Checkout&#xA;{&#xA;    Email = &#34;updated-email@nozzlegear.com&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List Shipping Rates for Checkout&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CheckoutService(myShopifyUrl, shopAccessToken);&#xA;var checkoutToken = &#34;token&#34;;&#xA;var shippingRates = await service.ListShippingRatesAsync(checkoutToken);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Collections&lt;/h2&gt; &#xA;&lt;p&gt;API version 2020-01 introduces the new &#34;Collections&#34; endpoint, which can be used to get the base details and list of products associated with either a &lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#custom-collections&#34;&gt;Custom Collection&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/nozzlegear/ShopifySharp/master/#smart-collections&#34;&gt;Smart Collection&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This endpoint &lt;strong&gt;cannot&lt;/strong&gt; be used to manipulate the products, collects, custom collections or smart collections. You must use the entity&#39;s respective ShopifySharp service to do that (i.e. &lt;code&gt;CollectService&lt;/code&gt;, &lt;code&gt;ProductService&lt;/code&gt;, &lt;code&gt;CustomCollectionService&lt;/code&gt; and &lt;code&gt;SmartCollectionService&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Getting a Collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CollectionService(myShopifyUrl, shopAccessToken);&#xA;var collection = await service.GetAsync(collectionId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing products belonging to a Collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new CollectionService(myShopifyUrl, shopAccessToken);&#xA;var products = await service.ListAsync(collectionId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;StorefrontAccessTokens&lt;/h2&gt; &#xA;&lt;p&gt;You can use the StorefrontAccessToken resource to generate storefront access tokens. Storefront access tokens are used to delegate unauthenticated access scopes to clients that need to access the unautheticated Storefront API. A sales channel can generate a storefront access token and then pass it to a consuming client, such as JavaScript or a mobile application.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;There is a hard limit of 100 tokens per Shopify store.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Creating a StorefrontAccessToken&lt;/h3&gt; &#xA;&lt;p&gt;To create a StorefrontAccessToken, you must pass in a title for the token. There are no constraints on the uniqueness of the title.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new StorefrontAccessTokenService(myShopifyUrl, shopAccessToken);&#xA;var token = await service.CreateAsync(&#34;My storefront access token&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleting a StorefrontAccessToken&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new StorefrontAccessTokenService(myShopifyUrl, shopAccessToken);&#xA;&#xA;await service.DeleteAsync(storefrontAccessTokenId);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing StorefrontAccessTokens&lt;/h3&gt; &#xA;&lt;p&gt;This endpoint is not paginated, because there is a limit of only 100 storefront access tokens per shop.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new StorefrontAccessTokenService(myShopifyUrl, shopAccessToken);&#xA;var list = await service.ListAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Multipass&lt;/h2&gt; &#xA;&lt;p&gt;Multipass login is for store owners who have a separate website and a Shopify store. It redirects users from the website to the Shopify store and seamlessly logs them in with the same email address they used to sign up for the original website. If no account with that email address exists yet, one is created. There is no need to synchronize any customer databases.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Multipass redirect url&lt;/h3&gt; &#xA;&lt;p&gt;To create a multipass redirect url&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;string url = MultipassService.GetMultipassUrl(&#xA;&#x9;new Customer() {&#xA;&#x9;&#x9;Email = &#34;test@example.com&#34;,&#xA;&#x9;&#x9;MultipassIdentifier = Guid.Tostring(),&#xA;&#x9;&#x9;CreatedAt = DateTimeOffset.Now&#xA;&#x9;&#x9;....&#xA;&#x9;},&#xA;&#x9;Utils.MyShopifyUrl,&#xA;&#x9;Utils.AccessToken&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Handling Shopify&#39;s API rate limit&lt;/h1&gt; &#xA;&lt;p&gt;The Shopify API allows for an average of 2 API calls per second, with a burst limit of up to 40 API calls. Once you hit that 40 burst limit, Shopify will return a 429 Too Many Requests result. The limit is there to prevent you and thousands of other developers from overloading Shopify&#39;s servers by going hard in the paint with hundreds of requests every second. Unfortunately, it&#39;s pretty easy to write a &lt;code&gt;for&lt;/code&gt; loop while trying to close a list of orders, and then start getting exceptions after closing the first 40.&lt;/p&gt; &#xA;&lt;p&gt;By default, ShopifySharp will &lt;strong&gt;not&lt;/strong&gt; retry requests that get throttled by the rate limit, and instead this package will throw a &lt;code&gt;ShopifyRateLimitException&lt;/code&gt; that you can catch and decide to retry:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;foreach (var order in listOfOrders)&#xA;{&#xA;&#x9;try&#xA;&#x9;{&#xA;&#x9;&#x9;await orderService.CloseAsync(order.Id.Value);&#xA;&#x9;}&#xA;&#x9;catch (ShopifyRateLimitException e)&#xA;&#x9;{&#xA;&#x9;&#x9;//Wait for 10 seconds before trying again.&#xA;&#x9;&#x9;await Task.Delay(10000);&#xA;&#xA;&#x9;&#x9;//If this throws an exception again, loop will break and the exception will be thrown.&#xA;&#x9;&#x9;await orderService.CloseAsync(order.Id.Value);&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, ShopifySharp also has request execution policies that you can use to implement a retry strategy. Currently there are three execution policies bundled with the library:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;DefaultRequestExecutionPolicy&lt;/code&gt;: This is the default policy, which will throw a &lt;code&gt;ShopifyRateLimitException&lt;/code&gt; when the API rate limit has been reached.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RetryExecutionPolicy&lt;/code&gt;: If a request throws a &lt;code&gt;ShopifyRateLimitException&lt;/code&gt;, this policy will keep retrying it until it is successful.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SmartRetryExecutionPolicy&lt;/code&gt;: This policy attempts to use a leaky bucket strategy by proactively limiting the number of requests that will result in a &lt;code&gt;ShopifyRateLimitException&lt;/code&gt;. For example: if 100 requests are created in parallel, only 40 should be sent immediately, and the remaining 60 requests should be throttled at 1 per 500ms.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You have two different ways to set an execution policy. You can set a policy on a per-instance basis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var service = new ProductService(myShoipfyUrl, accessToken);&#xA;&#xA;service.SetExecutionPolicy(new RetryExecutionPolicy());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can set a &lt;strong&gt;global&lt;/strong&gt; execution policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ShopifyService.SetGlobalExecutionPolicy(new RetryExecutionPolicy());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;strong&gt;instance-specific policies will always be used over global execution policies&lt;/strong&gt;. In addition, if you clear the instance-specific policy by passing &lt;code&gt;null&lt;/code&gt;, &lt;strong&gt;the instance will then switch over to the global execution policy&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind that the &lt;code&gt;RetryExecutionPolicy&lt;/code&gt; and the &lt;code&gt;SmartRetryExecutionPolicy&lt;/code&gt; will keep retrying your requests – potentially until the end of time – until they are successful. It&#39;s up to you to ensure that such a strategy won&#39;t impact the performance of your applications.&lt;/p&gt; &#xA;&lt;p&gt;If you need a custom policy to do something more complicated or to e.g. implement request logging, you can create your own request policy that extends the &lt;code&gt;ShopifySharp.IRequestExecutionPolicy&lt;/code&gt; interface. &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/raw/master/ShopifySharp/Infrastructure/Policies/RetryExecutionPolicy.cs&#34;&gt;Check here&lt;/a&gt; for an example.&lt;/p&gt; &#xA;&lt;h1&gt;Custom Filters&lt;/h1&gt; &#xA;&lt;p&gt;Occasionally we get requests to add certain properties to one of the List or Count filters that isn&#39;t documented anywhere by Shopify. For example, at one point it was possible to add a &lt;code&gt;name&lt;/code&gt; prop to the &lt;code&gt;OrderFilter&lt;/code&gt; that would make it possible to search for an &lt;code&gt;Order&lt;/code&gt; by its name. Unfortunately this &lt;code&gt;name&lt;/code&gt; filter was never documented and Shopify eventually removed that functionality, but it&#39;s a perfect example of wanting to use custom properties on the filters.&lt;/p&gt; &#xA;&lt;p&gt;Officially, my stance is that I tend to favor not adding undocumented things to this package on the fear that it will someday break and I&#39;ll have a big headache fielding questions and issues here on GitHub when it does. However, in the case of Filters it&#39;s possible for you to implement your own custom filter without it being officially supported!&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s as easy as creating your own class that extends whichever filter your method accepts. For example, let&#39;s pretend that &lt;code&gt;name&lt;/code&gt; search still works when listing Shopify orders, but this package doesn&#39;t support it. The &lt;code&gt;OrderService.ListAsync&lt;/code&gt; method accepts an &lt;code&gt;OrderFilter&lt;/code&gt; argument, so to get the &lt;code&gt;name&lt;/code&gt; property sent along with the API call, all you need to do is create your own custom filter that extends &lt;code&gt;OrderFilter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public class MyCustomOrderFilter : OrderFilter&#xA;{&#xA;    [JsonProperty(&#34;name&#34;)] // This will serialize the value as `name` when sent to the API endpoint.&#xA;    public string Name { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Your custom order filter still has all of the original properties of the base &lt;code&gt;OrderFilter&lt;/code&gt; class, &lt;em&gt;plus&lt;/em&gt; it has your new &lt;code&gt;Name&lt;/code&gt; property. Since your custom filter extends the class that &lt;code&gt;OrderService.ListAsync&lt;/code&gt; was looking for, you can now pass it as an argument to that method without any problems:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var list = await orderService.ListAsync(new MyCustomOrderFilter()&#xA;{&#xA;    Name = &#34;1001&#34;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need even more fine-grained control over what gets sent through your custom filter, you can also override the &lt;code&gt;ToParameters&lt;/code&gt; or &lt;code&gt;ToSingleParameter&lt;/code&gt; methods of the filter. Those methods are called by the service when it&#39;s serializing the filter to a querystring.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/raw/85a0eed28937eee2870e9104a55796e1a1039cfb/ShopifySharp/Infrastructure/Parameterizable.cs#L18&#34;&gt;You can take a look at the &lt;code&gt;Parameterizable&lt;/code&gt; class (which is used by all filters) for a look at the current implementation&lt;/a&gt; and what you can do in those methods.&lt;/p&gt; &#xA;&lt;h1&gt;&#34;Why don&#39;t you use enums?&#34;&lt;/h1&gt; &#xA;&lt;p&gt;I&#39;m a big fan of using enums to make things easier for C# devs, because it removes a lot of the headache that comes with trying to remember all the valid string options for certain properties. With enums, we get those options hardcoded by default. We can easily scroll up and down the list of known values and select the one we need, without having to worry about typos.&lt;/p&gt; &#xA;&lt;p&gt;Many Shopify objects have string properties that only accept a predetermined list of values, and these properties are perfect for matching to C# enums. Unfortunately, Shopify has a habit of only documenting the most used values and leaving the developer to guess the rest. On top of that, they sometimes change those enums completely, &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/issues/64&#34;&gt;such as this case where they changed the enums used for filtering orders without announcing it&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s a problem when it comes to strongly-typed languages like C#. If you receive an enum property that doesn&#39;t have a value matching the enum, you&#39;re going to get a big fat exception thrown in your face. This is especially problematic when these undocumented enum values are sent to you automatically in webhooks.&lt;/p&gt; &#xA;&lt;p&gt;On top of that, if there&#39;s an enum value that you need to send but isn&#39;t in ShopifySharp, you&#39;ll need to wait until a new version of the lib is released before you can use it.&lt;/p&gt; &#xA;&lt;p&gt;Enums would be much better suited to ShopifySharp if Shopify themselves used API versioning, but sadly that isn&#39;t the case. After struggling with undocumented values and unannounced changes that break apps through two major releases of ShopifySharp, I&#39;ve made the decision to pull the plug on almost all enums in the lib.&lt;/p&gt; &#xA;&lt;p&gt;What were previously enums in ShopifySharp 1.x and 2.x are now string properties. This change will prevent breaking your app when an enum value changes, and will allow you to quickly update your app when a new enum value is released without waiting on an update to ShopifySharp first.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing to ShopifySharp&lt;/h1&gt; &#xA;&lt;p&gt;Check out our &lt;a href=&#34;https://github.com/nozzlegear/ShopifySharp/raw/master/docs/contribution-guide.md&#34;&gt;contribution guide&lt;/a&gt; for guidance on contributing new features, services, classes and bugfixes to ShopifySharp! The guide also contains details on how to set up and run ShopifySharp&#39;s test suite.&lt;/p&gt;</summary>
  </entry>
</feed>