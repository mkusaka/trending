<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-26T01:32:19Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>JasperFx/wolverine</title>
    <updated>2023-06-26T01:32:19Z</updated>
    <id>tag:github.com,2023-06-26:/JasperFx/wolverine</id>
    <link href="https://github.com/JasperFx/wolverine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Next Generation .NET Command and Message Bus&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Wolverine&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/WMxrvegf8H&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1074998995086225460?color=blue&amp;amp;label=Chat%20on%20Discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Wolverine is a &lt;em&gt;Next Generation .NET Mediator and Message Bus&lt;/em&gt;. Check out the &lt;a href=&#34;https://wolverine.netlify.app&#34;&gt;documentation website at https://wolverine.netlify.app&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Help us keep working on this project 💚&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sponsors/JasperFX&#34;&gt;Become a Sponsor on GitHub&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Working with the Code&lt;/h2&gt; &#xA;&lt;p&gt;To work with the code, just open the &lt;code&gt;wolverine.sln&lt;/code&gt; file in the root of the repository and go. If you want to run integration tests though, you&#39;ll want Docker installed locally and to start the matching testing services with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s a separate README in the Azure Service Bus tests as those require an actual cloud set up (sorry, but blame Microsoft for not having a local Docker based emulator ala Localstack).&lt;/p&gt; &#xA;&lt;h2&gt;Contributor&#39;s Guide&lt;/h2&gt; &#xA;&lt;p&gt;For contributors, there&#39;s a light naming style Jeremy refuses to let go of that he&#39;s used for &lt;em&gt;gulp&lt;/em&gt; 20+ years:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;All public or internal members should be Pascal cased&lt;/li&gt; &#xA; &lt;li&gt;All private or protected members should be Camel cased&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;_&lt;/code&gt; as a prefix for private fields&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The build is scripted out with &lt;a href=&#34;https://github.com/adamralph/bullseye&#34;&gt;Bullseye&lt;/a&gt; in the &lt;code&gt;/build&lt;/code&gt; folder. To run the build file locally, use &lt;code&gt;build&lt;/code&gt; with Windows or &lt;code&gt;./build.sh&lt;/code&gt; on OSX or Linux.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;All the documentation content is in the &lt;code&gt;/docs&lt;/code&gt; folder. The documentation is built and published with &lt;a href=&#34;https://vitepress.vuejs.org/&#34;&gt;Vitepress&lt;/a&gt; and uses &lt;a href=&#34;https://github.com/SimonCropp/MarkdownSnippets&#34;&gt;Markdown Snippets&lt;/a&gt; for code samples. To run the documentation locally, you&#39;ll need a recent version of Node.js installed. To start the documentation website, first run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then start the actual website with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run docs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To update the code sample snippets, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run mdsnippets&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;This is a little sad, but Wolverine started as a project named &#34;&lt;a href=&#34;https://github.com/jasperfx/jasper&#34;&gt;Jasper&lt;/a&gt;&#34; way, way back in 2015 as an intended reboot of an even older project named &lt;a href=&#34;https://fubumvc.github.io&#34;&gt;FubuMVC / FubuTransportation&lt;/a&gt; that was a combination web api framework and asynchronous message bus. What is now Wolverine was meant to build upon what we thought was the positive aspects of fubu&#39;s programming model but do so with a much more efficient runtime. Wolverine was largely rebooted, revamped, and renamed in 2022 with the intention of being combined with &lt;a href=&#34;https://martendb.io&#34;&gt;Marten&lt;/a&gt; into the &#34;critter stack&#34; for highly productive and highly performant server side development in .NET.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SnaffCon/Snaffler</title>
    <updated>2023-06-26T01:32:19Z</updated>
    <id>tag:github.com,2023-06-26:/SnaffCon/Snaffler</id>
    <link href="https://github.com/SnaffCon/Snaffler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;a tool for pentesters to help find delicious candy, by @l0ss and @Sh3r4 ( Twitter: @/mikeloss and @/sh3r4_hax )&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Snaffler&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ko-fi.com/T6T31VEVJ&#34;&gt;&lt;img src=&#34;https://www.ko-fi.com/img/githubbutton_sm.svg?sanitize=true&#34; alt=&#34;ko-fi&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SnaffCon/Snaffler/master/snaffler.png&#34; alt=&#34;A dictionary definition of &amp;quot;snaffle&amp;quot;.&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is it for?&lt;/h2&gt; &#xA;&lt;p&gt;Snaffler is a tool for &lt;strong&gt;pentesters&lt;/strong&gt; and &lt;strong&gt;red teamers&lt;/strong&gt; to help find delicious candy needles (creds mostly, but it&#39;s flexible) in a bunch of horrible boring haystacks (a massive Windows/AD environment).&lt;/p&gt; &#xA;&lt;p&gt;It might also be useful for other people doing other stuff, but it is explicitly NOT meant to be an &#34;audit&#34; tool.&lt;/p&gt; &#xA;&lt;h2&gt;I don&#39;t want to read all this!!!&lt;/h2&gt; &#xA;&lt;p&gt;Ugh, fine. But we aren&#39;t responsible for the results. We wrote all this other stuff for you, but that&#39;s okay. We&#39;re not mad, just disappointed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;snaffler.exe -s -o snaffler.log&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What does it do?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Broadly speaking&lt;/em&gt; - it gets a list of Windows computers from Active Directory, then spreads out its snaffly appendages to them all to figure out which ones have file shares, and whether you can read them.&lt;/p&gt; &#xA;&lt;p&gt;Then YET MORE snaffly appendages enumerate all the files in those shares and use &lt;strong&gt;L&lt;/strong&gt;EARNED &lt;strong&gt;A&lt;/strong&gt;RTIFACTUAL &lt;strong&gt;I&lt;/strong&gt;NTELLIGENCE for &lt;strong&gt;M&lt;/strong&gt;ACHINES to figure out which ones a grubby little hacker like you might want.&lt;/p&gt; &#xA;&lt;p&gt;Actually it doesn&#39;t do any ML stuff, because doing that right would require training data, and that would require an enormous amount of time that we don&#39;t have. Instead, like all good &#34;ML&#34; projects, it just uses a shitload of &lt;code&gt;if&lt;/code&gt; statements and regexen.&lt;/p&gt; &#xA;&lt;h2&gt;What does it look like?&lt;/h2&gt; &#xA;&lt;p&gt;Like this!&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SnaffCon/Snaffler/master/snaffler_screenshot.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;How do I use it?&lt;/h2&gt; &#xA;&lt;p&gt;If you &#34;literally just run the EXE on a domain joined machine in the context of a domain user&#34; (as people were instructed to do with Grouper2, immediately before they ran it with all the verbose/debug switches on so it screamed several hundred megabytes of stack traces at them) it will basically do nothing. This is our idea of a prank&lt;sup&gt;TM&lt;/sup&gt; on people who don&#39;t read README files, because we&#39;re monsters.&lt;/p&gt; &#xA;&lt;p&gt;HOWEVER... if you add the correct incantations, it will enable the aforementioned L.A.I.M. and the file paths where candy may be found will fall out.&lt;/p&gt; &#xA;&lt;p&gt;The key incantations are:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-o&lt;/code&gt; Enables outputting results to a file. You probably want this if you&#39;re not using &lt;code&gt;-s&lt;/code&gt;. e.g. &lt;code&gt;-o C:\users\thing\snaffler.log&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-s&lt;/code&gt; Enables outputting results to stdout as soon as they&#39;re found. You probably want this if you&#39;re not using &lt;code&gt;-o&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; Controls verbosity level, options are Trace (most verbose), Degub (less verbose, less gubs), Info (less verbose still, default), and Data (results only). e.g &lt;code&gt;-v debug&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; Enables and assigns an output dir for snaffler to automatically take a copy of (or Snaffle... if you will) any found files that it likes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-l&lt;/code&gt; Maximum size of files (in bytes) to Snaffle. Defaults to 10000000, which is &lt;em&gt;about&lt;/em&gt; 10MB.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-i&lt;/code&gt; Disables computer and share discovery, requires a path to a directory in which to perform file discovery.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; Disables computer discovery, takes a comma-separated list of hosts to do share and file discovery on.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-y&lt;/code&gt; TSV-formats the output.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-b&lt;/code&gt; Skips the LAIM rules that will find less-interesting stuff, tune it with a number between 0 and 3.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; Limits Snaffler to finding file shares via DFS (Distributed File System) - this should be quite a bit sneakier than the default while still covering the biggest file shares in a lot of orgs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; Skips file enumeration, just gives you a list of listable shares on the target hosts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-u&lt;/code&gt; Makes Snaffler pull a list of account names from AD, choose the ones that look most-interesting, and then use them in a search rule.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; Domain to search for computers to search for shares on to search for files in. Easy.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-c&lt;/code&gt; Domain controller to query for the list of domain computers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; The maximum size file (in bytes) to search inside for interesting strings. Defaults to 500k.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-j&lt;/code&gt; How many bytes of context either side of found strings in files to show, e.g. &lt;code&gt;-j 200&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-z&lt;/code&gt; Path to a config file that defines all of the above, and much much more! See below for more details. Give it &lt;code&gt;-z generate&lt;/code&gt; to generate a sample config file called &lt;code&gt;.\default.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; Type of log you would like to output. Currently supported options are plain and JSON. Defaults to plain.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-x&lt;/code&gt; Max number of threads to use. Don&#39;t set it below 4 or shit will break.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; Path to a directory full of .toml formatted rules. Snaffler will load all of these in place of the default ruleset.&lt;/p&gt; &#xA;&lt;h2&gt;What does any of this log output mean?&lt;/h2&gt; &#xA;&lt;p&gt;Hopefully this annotated example will help:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SnaffCon/Snaffler/master/log_key.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;This log entry should be read roughly from left to right as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;at 7:37ish&lt;/li&gt; &#xA; &lt;li&gt;Snaffler found a file it thinks is worth your attention&lt;/li&gt; &#xA; &lt;li&gt;it&#39;s rated it &#34;Red&#34;, the second most-interesting level&lt;/li&gt; &#xA; &lt;li&gt;it matched a rule named &#34;KeepConfigRegexRed&#34;&lt;/li&gt; &#xA; &lt;li&gt;you can read it, but not modify it&lt;/li&gt; &#xA; &lt;li&gt;the exact regex that was matched is that stuff in the red box&lt;/li&gt; &#xA; &lt;li&gt;it&#39;s 208kB&lt;/li&gt; &#xA; &lt;li&gt;it was last modified on January 10th 2020 at quarter-to-four in the afternoon.&lt;/li&gt; &#xA; &lt;li&gt;the file may be found at the path in purple&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;... and the rest of the line (in grey) is a little snippet of context from the file where the match was.&lt;/p&gt; &#xA;&lt;p&gt;In this case we&#39;ve found ASP.NET validationKey and decryptionKey values, which might let us RCE the web app via some deserialisation hackery. Hooray!&lt;/p&gt; &#xA;&lt;p&gt;Note: after this screenshot was made, Sh3r4 added a thing to prepend the current user and hostname to each line. I don&#39;t wanna redo the screenshot tho.&lt;/p&gt; &#xA;&lt;h2&gt;How does it decide which files are good and which files are boring?&lt;/h2&gt; &#xA;&lt;h3&gt;The &#34;so simple it&#39;s almost a lie&#34; answer:&lt;/h3&gt; &#xA;&lt;p&gt;Each L.A.I.M. magic file finding method does stuff like:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Searching by exact file extension match, meaning that any file with an extension that matches the relevant wordlist will be returned. This is meant for &lt;strong&gt;file extensions&lt;/strong&gt; that are almost always going to contain candy, e.g. &lt;code&gt;.kdbx&lt;/code&gt;, &lt;code&gt;.vmdk&lt;/code&gt;, &lt;code&gt;.ppk&lt;/code&gt;, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Searching by (case insensitive) exact filename match. This is meant for &lt;strong&gt;file names&lt;/strong&gt; that are almost always going to contain candy, e.g. &lt;code&gt;id_rsa&lt;/code&gt;, &lt;code&gt;shadow&lt;/code&gt;, &lt;code&gt;NTDS.DIT&lt;/code&gt;, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Searching by exact file extension match (yet another wordlist) FOLLOWED BY &#39;grepping&#39; the contents of any matching files for certain key words (yet yet another another wordlist). This is meant for file extensions that &lt;strong&gt;sometimes&lt;/strong&gt; contain candy but where you know there&#39;s likely to be a bunch of chaff to sift through. For example, &lt;code&gt;web.config&lt;/code&gt; will sometimes contain database credentials, but will also often contain boring IIS config nonsense and no passwords. This will (for example) find anything ending in &lt;code&gt;.config&lt;/code&gt;, then will grep through it for strings including but not limited to: &lt;code&gt;connectionString&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt;, &lt;code&gt;PRIVATE KEY&lt;/code&gt;, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Searching by partial filename match (oh god more wordlists). This is mostly meant to find &lt;code&gt;Jeff&#39;s Password File 2019 (Copy).docx&lt;/code&gt; or &lt;code&gt;Privileged Access Management System Design - As-Built.docx&lt;/code&gt; or whatever, by matching any file where the name contains the substrings &lt;code&gt;passw&lt;/code&gt;, &lt;code&gt;handover&lt;/code&gt;, &lt;code&gt;secret&lt;/code&gt;, &lt;code&gt;secure&lt;/code&gt;, &lt;code&gt;as-built&lt;/code&gt;, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There&#39;s also skip-lists to skip all files with certain extensions, or any file with a path containing a given string.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The real answer:&lt;/h3&gt; &#xA;&lt;p&gt;Snaffler uses a system of &#34;classifiers&#34;, each of which examine shares or folders or files or file contents, passing some items downstream to the next classifier, and discarding others. Each classifier uses a set of rules to decide what to do with the items it classifies.&lt;/p&gt; &#xA;&lt;p&gt;These rules can be very simple, e.g. &#34;if a file&#39;s extension is &lt;code&gt;.kdbx&lt;/code&gt;, tell me about it&#34;, or &#34;if a path contains &lt;code&gt;windows\sxs&lt;/code&gt; then stop looking at subdirectories and files within that path&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Rules can also use regular expressions, which allow for relatively sophisticated pattern-matching. This is particularly useful when examining file contents, although care should be taken to avoid regexen with a significant performance hit. In large environments these rules may be checked literally millions of times, so minor performance issues can be amplified significantly.&lt;/p&gt; &#xA;&lt;p&gt;The real power is in Snaffler&#39;s ability to chain multiple rules together, and even create branching chains. This allows us to use &#34;cheap&#34; rules like checking file names and extensions to decide when to use &#34;expensive&#34; rules like running regexen across the contents of files, parsing certs to see whether they contain private keys, etc. This is what allows Snaffler to achieve quite deep inspection of files where needed, while also being surprisingly fast for a tool written in a higher-level language like C#.&lt;/p&gt; &#xA;&lt;p&gt;For example, a very simple ruleset might contain:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a rule to discard all files with extensions associated with image files&lt;/li&gt; &#xA; &lt;li&gt;a rule to find all files with the &lt;code&gt;.dmp&lt;/code&gt; file extension and snaffle them&lt;/li&gt; &#xA; &lt;li&gt;a rule chain where: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the first rule looks for files with the &lt;code&gt;.ps1&lt;/code&gt; file extension, and sends all matching files to both the second and third rules.&lt;/li&gt; &#xA;   &lt;li&gt;the second rule looks inside files using regexen designed to find hard-coded credentials in PowerShell code.&lt;/li&gt; &#xA;   &lt;li&gt;the third rule looks inside files using regexen designed to find hard-coded credentials in &lt;code&gt;cmd.exe&lt;/code&gt; commands, as might be found in &lt;code&gt;.bat&lt;/code&gt; or &lt;code&gt;.cmd&lt;/code&gt; files, as these are also commonly used within PowerShell scripts.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This approach also lets us maintain a relatively manageable and legible ruleset, and also makes it much easier for the end-user (you) to customise the defaults or develop your own rulesets.&lt;/p&gt; &#xA;&lt;h3&gt;I don&#39;t want to write rules, that sounds hard and boring.&lt;/h3&gt; &#xA;&lt;p&gt;You&#39;re right, it was.&lt;/p&gt; &#xA;&lt;p&gt;Snaffler comes with a set of default rules baked into the &lt;code&gt;.exe&lt;/code&gt;. You can see them in &lt;code&gt;./Snaffler/SnaffRules/DefaultRules&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;I am a mighty titan of tedium, a master of the mundane, I wish to write my own ruleset.&lt;/h3&gt; &#xA;&lt;p&gt;No problem, you enormous weirdo. You have 2 options.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Edit or replace the rules in the &lt;code&gt;DefaultRules&lt;/code&gt; directory, then build a fresh Snaffler. The &lt;code&gt;.toml&lt;/code&gt; files in that dir will get baked into the &lt;code&gt;.exe&lt;/code&gt; as resources, and loaded up at runtime whenever you don&#39;t specify any other rules to use.&lt;/li&gt; &#xA; &lt;li&gt;Make a directory and stick a bunch of your own rule files in there, then run Snaffler with &lt;code&gt;-p .\path\to\rules&lt;/code&gt;. Snaffler will parse all the &lt;code&gt;.toml&lt;/code&gt; files in that directory and use the resulting ruleset. This will also work if you just have them all in one big &lt;code&gt;.toml&lt;/code&gt; file.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Here&#39;s some annotated examples that will hopefully help to explain things better. If this seems very hard, you can just use our rules and they&#39;ll probably find you some good stuff.&lt;/p&gt; &#xA;&lt;p&gt;This is an example of a rule that will make Snaffler ignore all files and subdirectories below a dir with a certain name.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[ClassifierRules]]&#xA;EnumerationScope = &#34;DirectoryEnumeration&#34; # This defines which phase of the discovery process we&#39;re going to apply the rule. &#xA;                                          # In this case, we&#39;re looking at directories. &#xA;                                          # Valid values include ShareEnumeration, DirectoryEnumeration, FileEnumeration, ContentsEnumeration&#xA;RuleName = &#34;DiscardLargeFalsePosDirs&#34; # This can be whatever you want. We&#39;ve been following a rough naming scheme, but you can call it &#34;Stinky&#34; if you want. ¯\_(ツ)_/¯&#xA;MatchAction = &#34;Discard&#34;# What to do with things that match the rule. In this case, we want to discard anything that matches this rule.&#xA;                        # Valid options include: Snaffle (keep), Discard, Relay (example of this below), and CheckForKeys (example below)&#xA;Description = &#34;File paths that will be skipped entirely.&#34; # Not used in the code, just a place for notes really.&#xA;MatchLocation = &#34;FilePath&#34; # What part of the file/dir/share to look at to check for a match. In this case we&#39;re looking at the whole path.&#xA;                           # Valid options include: ShareName, FilePath, FileName, FileExtension, FileContentAsString, FileContentAsBytes,&#xA;                           # although obviously not all of these will apply in all EnumerationScopes.&#xA;WordListType = &#34;Contains&#34; # What matching logic to apply, valid options are: Exact, Contains, EndsWith, StartsWith, or Regex.&#xA;                          # Under the hood these all get turned into regexen one way or another.&#xA;MatchLength = 0&#xA;WordList = [ &#xA;  # A list of strings or regex patterns to use to match. If using regex patterns, WordListType must be Regex.&#xA;&#x9;&#34;\\\\puppet\\\\share\\\\doc&#34;,&#xA;&#x9;&#34;\\\\lib\\\\ruby&#34;,&#xA;&#x9;&#34;\\\\lib\\\\site-packages&#34;,&#xA;&#x9;&#34;\\\\usr\\\\share\\\\doc&#34;,&#xA;&#x9;&#34;node_modules&#34;,&#xA;&#x9;&#34;vendor\\\\bundle&#34;,&#xA;&#x9;&#34;vendor\\\\cache&#34;,&#xA;&#x9;&#34;\\\\doc\\\\openssl&#34;,&#xA;&#x9;&#34;Anaconda3\\\\Lib\\\\test&#34;,&#xA;&#x9;&#34;WindowsPowerShell\\\\Modules&#34;,&#xA;&#x9;&#34;Python27\\\\Lib&#34;&#xA;]&#xA;Triage = &#34;Green&#34; # If we find a match, what severity rating should we give it. Valid values are Black, Red, Yellow, Green. This value is ignored for Discard MatchActions.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This rule on the other hand will look at file extensions, and immediately discard any we don&#39;t like.&lt;/p&gt; &#xA;&lt;p&gt;In this case I&#39;m mostly throwing away fonts, images, CSS, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[ClassifierRules]]&#xA;EnumerationScope = &#34;FileEnumeration&#34; # We&#39;re looking at the actual files, not the shares or dirs or whatever.&#xA;RuleName = &#34;DiscardExtExact&#34; # just a name&#xA;MatchAction = &#34;Discard&#34; # We&#39;re discarding these&#xA;MatchLocation = &#34;FileExtension&#34; # This time we&#39;re only looking at the file extension part of the file&#39;s name.&#xA;WordListType = &#34;Exact&#34; # and we only want exact matches. &#xA;WordList = [&#34;.bmp&#34;, &#34;.eps&#34;, &#34;.gif&#34;, &#34;.ico&#34;, &#34;.jfi&#34;, &#34;.jfif&#34;, &#34;.jif&#34;, &#34;.jpe&#34;, &#34;.jpeg&#34;, &#34;.jpg&#34;, &#34;.png&#34;, &#34;.psd&#34;, &#34;.svg&#34;, &#34;.tif&#34;, &#34;.tiff&#34;, &#34;.webp&#34;, &#34;.xcf&#34;, &#34;.ttf&#34;, &#34;.otf&#34;, &#34;.lock&#34;, &#34;.css&#34;, &#34;.less&#34;] # list of file extensions.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example of a really simple rule for stuff we like and want to keep.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[ClassifierRules]]&#xA;EnumerationScope = &#34;FileEnumeration&#34; # Still looking at files&#xA;RuleName = &#34;KeepExtExactBlack&#34; # Just a name&#xA;MatchAction = &#34;Snaffle&#34; # This time we are &#39;snaffling&#39; these. This usually just means send it to the output, &#xA;                       # but if you turn on the appropriate option it will also grab a copy.&#xA;MatchLocation = &#34;FileExtension&#34; # We&#39;re looking at file extensions again&#xA;WordListType = &#34;Exact&#34; # With Exact Matches&#xA;WordList = [&#34;.kdbx&#34;, &#34;.kdb&#34;, &#34;.ppk&#34;, &#34;.vmdk&#34;, &#34;.vhdx&#34;, &#34;.ova&#34;, &#34;.ovf&#34;, &#34;.psafe3&#34;, &#34;.cscfg&#34;, &#34;.kwallet&#34;, &#34;.tblk&#34;, &#34;.ovpn&#34;, &#34;.mdf&#34;, &#34;.sdf&#34;, &#34;.sqldump&#34;] # and a bunch of fun file extensions.&#xA;Triage = &#34;Black&#34; # these are all big wins if we find them, so we&#39;re giving them the most severe rating.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This one is basically the same, but we&#39;re looking at the whole file name. Simple!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[ClassifierRules]]&#xA;EnumerationScope = &#34;FileEnumeration&#34;&#xA;RuleName = &#34;KeepFilenameExactBlack&#34;&#xA;MatchAction = &#34;Snaffle&#34;&#xA;MatchLocation = &#34;FileName&#34;&#xA;WordListType = &#34;Exact&#34;&#xA;WordList = [&#34;id_rsa&#34;, &#34;id_dsa&#34;, &#34;NTDS.DIT&#34;, &#34;shadow&#34;, &#34;pwd.db&#34;, &#34;passwd&#34;]&#xA;Triage = &#34;Black&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This one is a bit nifty, check this out...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[ClassifierRules]]&#xA;EnumerationScope = &#34;FileEnumeration&#34; # we&#39;re looking for files...&#xA;RuleName = &#34;KeepCertContainsPrivKeyRed&#34; &#xA;MatchLocation = &#34;FileExtension&#34; # specifically, ones with certain file extensions...&#xA;WordListType = &#34;Exact&#34;&#xA;WordList = [&#34;.der&#34;, &#34;.pfx&#34;] # specifically these ones...&#xA;MatchAction = &#34;CheckForKeys&#34; # and any that we find, we&#39;re going to parse them as x509 certs, and see if the file includes a private key!&#xA;Triage = &#34;Red&#34; # cert files aren&#39;t very sexy, and you&#39;ll get huge numbers of them in most wintel environments, but this check gives us a way better SNR!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;OK, here&#39;s where the powerful stuff comes in. We got a pair of rules in a chain here.&lt;/p&gt; &#xA;&lt;p&gt;Files with extensions that match the first rule will be sent to second rule, which will &#34;grep&#34; (i.e. String.Contains()) them for stuff in a specific wordlist.&lt;/p&gt; &#xA;&lt;p&gt;You can chain these together as much as you like, although I imagine you&#39;ll start to see some performance problems if you get too inception-y with it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[ClassifierRules]]&#xA;EnumerationScope = &#34;FileEnumeration&#34; # this one looks at files...&#xA;RuleName = &#34;ConfigGrepExtExact&#34;&#xA;MatchLocation = &#34;FileExtension&#34; # specifically the extensions...&#xA;WordListType = &#34;Exact&#34;&#xA;WordList = [&#34;.yaml&#34;, &#34;.xml&#34;, &#34;.json&#34;, &#34;.config&#34;, &#34;.ini&#34;, &#34;.inf&#34;, &#34;.cnf&#34;, &#34;.conf&#34;] # these ones.&#xA;MatchAction = &#34;Relay&#34; # Then any files that match are handed downstream...&#xA;RelayTargets = [&#34;KeepConfigGrepContainsRed&#34;] # To the rule with this RuleName! This can also be an array of RuleNames if you want to get real wild and start writing branching rulesets.&#xA;&#xA;[[ClassifierRules]]&#xA;RuleName = &#34;KeepConfigGrepContainsRed&#34; # Anyway, this is the target rule. Following a naming convention really helps to make sure you&#39;re using the right targets.&#xA;EnumerationScope = &#34;ContentsEnumeration&#34; # this one looks at file content!&#xA;MatchAction = &#34;Snaffle&#34; # it keeps files that match&#xA;MatchLocation = &#34;FileContentAsString&#34; # it&#39;s looking at the contents as a string (rather than a byte array)&#xA;WordListType = &#34;Contains&#34; # it&#39;s using simple matching&#xA;WordList = [&#34;password=&#34;, &#34; connectionString=\&#34;&#34;, &#34;sqlConnectionString=\&#34;&#34;, &#34;validationKey=&#34;, &#34;decryptionKey=&#34;, &#34;NVRAM config last updated&#34;]&#xA;Triage = &#34;Red&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hopefully this convey the idea. I&#39;d recommend taking some of the default rules and tinkering with them until you feel like you&#39;ve got a good handle on it.&lt;/p&gt; &#xA;&lt;h2&gt;WTF is an &#34;UltraSnaffler&#34;???&lt;/h2&gt; &#xA;&lt;p&gt;A lot of people wanted the ability to look inside file formats that weren&#39;t just flat text, like Word documents, PDFs, &lt;code&gt;.eml&lt;/code&gt;, etc. Unfortunately, the easiest library for implementing that functionality blew out the final file size on &lt;code&gt;Snaffler.exe&lt;/code&gt; by about 1200%, which sucked for a bunch of the popular in-memory execution techniques that had upper limits on how big a file they could be used with.&lt;/p&gt; &#xA;&lt;p&gt;The solution was UltraSnaffler, which is just a second &lt;code&gt;.sln&lt;/code&gt; file that enables the required lib and the relevant code. Build &lt;code&gt;UltraSnaffler.sln&lt;/code&gt;, get UltraSnaffler.&lt;/p&gt; &#xA;&lt;p&gt;WARNING: Snaffler&#39;s default rules don&#39;t include any that will look inside Office docs or PDFs, because we found it really difficult to write any that weren&#39;t going to just take &lt;em&gt;years&lt;/em&gt; to finish a run in a typical corporate environment. &lt;em&gt;Be warned, looking inside these docs is a lot slower than looking inside good old fashioned text files, and a typical environment will have an absolute mountain of low-value Office docs and PDFs.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How does the config file thing work?&lt;/h2&gt; &#xA;&lt;p&gt;This is actually really neat IMO.&lt;/p&gt; &#xA;&lt;p&gt;If you add &lt;code&gt;-z generate&lt;/code&gt; onto the end of a Snaffler command line, Snaffler will serialise the configuration object (including whatever aspects of the configuration were set by your args) into a &lt;code&gt;.toml&lt;/code&gt; config file, which you can then hand-edit pretty easily (or not) and then re-use at your leisure&lt;/p&gt; &#xA;&lt;p&gt;For example, if you do:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Snaffler.exe -s -o C:\mydir\snaffler.log -v trace -i \\host.lol.domain\share -p C:\users\someguy\myrules -z generate&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Snaffler will parse all your many, many arguments, turn them into a config object, serialise that config object into the following &lt;code&gt;.toml&lt;/code&gt; config file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;PathTargets = [&#34;\\\\host.lol.domain\\share&#34;]&#xA;ComputerTargetsLdapFilter = &#34;(objectClass=computer)&#34;&#xA;ScanSysvol = true&#xA;ScanNetlogon = true&#xA;ScanFoundShares = true&#xA;InterestLevel = 0&#xA;DfsOnly = false&#xA;DfsShareDiscovery = false&#xA;DfsNamespacePaths = []&#xA;CurrentUser = &#34;l0sslab\\l0ss&#34;&#xA;RuleDir = &#34;C:\\users\\someguy\\myrules&#34;&#xA;MaxThreads = 60&#xA;ShareThreads = 20&#xA;TreeThreads = 20&#xA;FileThreads = 20&#xA;MaxFileQueue = 200000&#xA;MaxTreeQueue = 0&#xA;MaxShareQueue = 0&#xA;LogToFile = true&#xA;LogFilePath = &#34;C:\\mydir\\snaffler.log&#34;&#xA;LogType = &#34;Plain&#34;&#xA;LogTSV = false&#xA;Separator = 32&#xA;LogToConsole = true&#xA;LogLevelString = &#34;trace&#34;&#xA;ShareFinderEnabled = false&#xA;LogDeniedShares = false&#xA;DomainUserRules = false&#xA;DomainUserMinLen = 6&#xA;DomainUserNameFormats = [&#34;sAMAccountName&#34;]&#xA;DomainUserMatchStrings = [&#34;sql&#34;, &#34;svc&#34;, &#34;service&#34;, &#34;backup&#34;, &#34;ccm&#34;, &#34;scom&#34;, &#34;opsmgr&#34;, &#34;adm&#34;, &#34;adcs&#34;, &#34;MSOL&#34;, &#34;adsync&#34;, &#34;thycotic&#34;, &#34;secretserver&#34;, &#34;cyberark&#34;, &#34;configmgr&#34;]&#xA;DomainUsersWordlistRules = [&#34;KeepConfigRegexRed&#34;]&#xA;MaxSizeToGrep = 1000000&#xA;Snaffle = false&#xA;MaxSizeToSnaffle = 10000000&#xA;MatchContextBytes = 200&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may notice that there are many items in here that you didn&#39;t pass arguments for. Those values are the default config items, some of which can only be edited easily in the source or via a config file, usually because it didn&#39;t seem worth it to add an argument for them.&lt;/p&gt; &#xA;&lt;h2&gt;This sucks, do you have plans to make it suck less?&lt;/h2&gt; &#xA;&lt;p&gt;No it doesn&#39;t, you suck.&lt;/p&gt; &#xA;&lt;p&gt;Also, yes we do.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re also going to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add parsing of archive files, ideally treating them as just another dir to walk through looking for goodies.&lt;/li&gt; &#xA; &lt;li&gt;Keep refining the rules and regexen. &lt;strong&gt;More words for the wordlists! &lt;code&gt;string[]&lt;/code&gt;s for the &lt;code&gt;string&lt;/code&gt; throne!&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SnaffCon/Snaffler/master/WORDLISTS.png&#34; alt=&#34;A dumb joke about wordlists.&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Who did you steal code from?&lt;/h2&gt; &#xA;&lt;p&gt;The share enumeration bits were snaffled (see what I did there?) from SharpShares, which was written by the exceedingly useful Dwight Hohnstein. (&lt;a href=&#34;https://github.com/djhohnstein/SharpShares/&#34;&gt;https://github.com/djhohnstein/SharpShares/&lt;/a&gt;) Dwight&#39;s GitHub profile is like that amazing back aisle at a hardware store that has a whole bunch of tools that make you go &#34;oh man I can&#39;t wait til I have an excuse to try this one for realsies...&#34; and you should definitely check it out.&lt;/p&gt; &#xA;&lt;p&gt;While no code was taken (mainly cos it&#39;s Ruby lol) we did steal a bunch of nifty ideas from &lt;code&gt;plunder2&lt;/code&gt; (&lt;a href=&#34;http://joshstone.us/plunder2/&#34;&gt;http://joshstone.us/plunder2/&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Wordlists were also curated from those found in some other similar-ish tools like trufflehog, shhgit, gitrobber, and graudit.&lt;/p&gt; &#xA;&lt;h2&gt;Is it OPSEC safe? (Whatever the hell that means)&lt;/h2&gt; &#xA;&lt;p&gt;Pffft, no. It&#39;s noisy as fuck.&lt;/p&gt; &#xA;&lt;p&gt;Look let&#39;s put it this way... If it&#39;s the kind of environment where you&#39;d feel confident running BloodHound in its default mode, then uhhh, yeah man... It&#39;s real stealthy.&lt;/p&gt; &#xA;&lt;h2&gt;I thought you used this thing on red team gigs?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;sigh&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;OK, I&#39;ll give you the real answer.&lt;/p&gt; &#xA;&lt;p&gt;In default mode, Snaffler looks an awful lot like SharpHound, in a lot of ways. It talks a bunch of LDAP to AD, then it goes out and tries to talk SMB to every Windows machine in the domain. This kind of behaviour is pretty much guaranteed to get you busted in an org that has their shit even slightly together.&lt;/p&gt; &#xA;&lt;p&gt;HOWEVER...&lt;/p&gt; &#xA;&lt;p&gt;Snaffler&#39;s more-targeted options (especially &lt;code&gt;-i&lt;/code&gt;) are a &lt;em&gt;lot&lt;/em&gt; less likely to trigger detections.&lt;/p&gt; &#xA;&lt;p&gt;I am particularly fond of running &lt;code&gt;Snaffler.exe -s -i C:\&lt;/code&gt; on a freshly compromised server or workstation, and I&#39;ve not seen this behaviour get detected.&lt;/p&gt; &#xA;&lt;p&gt;Yet.&lt;/p&gt; &#xA;&lt;h2&gt;How can I help or get help?&lt;/h2&gt; &#xA;&lt;p&gt;If you want to discuss via Slack you can ping us (@l0ss or @Sh3r4) on the BloodHound Slack, joinable at &lt;a href=&#34;https://bloodhoundgang.herokuapp.com/&#34;&gt;https://bloodhoundgang.herokuapp.com/&lt;/a&gt;, or chat with a group of contributors in the #snaffler channel.&lt;/p&gt; &#xA;&lt;p&gt;You can also ping us on Twitter - @mikeloss and @sh3r4_hax&lt;/p&gt; &#xA;&lt;p&gt;Otherwise file an issue; we&#39;ll try.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>microsoft/fluentui-blazor</title>
    <updated>2023-06-26T01:32:19Z</updated>
    <id>tag:github.com,2023-06-26:/microsoft/fluentui-blazor</id>
    <link href="https://github.com/microsoft/fluentui-blazor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Microsoft Fluent UI Blazor components library. For use with .NET 6.0 or higher Blazor applications&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Microsoft Fluent UI Blazor components&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/csharp/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/.NET-C%23-blue&#34; alt=&#34;.NET C#&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Fast.Components.FluentUI?label=NuGet%20Component%20Library&#34; alt=&#34;Nuget&#34;&gt; &lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Fast.Templates.FluentUI?label=NuGet%20Templates&#34; alt=&#34;Nuget&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/microsoft/fluentui-blazor/actions/workflows/codeql-analysis.yml&#34;&gt;&lt;img src=&#34;https://github.com/microsoft/fluentui-blazor/actions/workflows/codeql-analysis.yml/badge.svg?sanitize=true&#34; alt=&#34;Validate Security&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.gitter.im/#/room/#fluentui-blazor:gitter.im&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat%20on-gitter-7289da.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/FcSNfg4&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat%20on-discord-7289da.svg?sanitize=true&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;⭐&lt;/span&gt; We appreciate your star, it helps!&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Microsoft.Fast.Components.FluentUI&lt;/code&gt; package provides a set of &lt;a href=&#34;https://blazor.net&#34;&gt;Blazor&lt;/a&gt; components which you can use to build applications that have the look and feel or modern Microsoft applications. Some of the componets are wrappers around Microsoft&#39;s official FluentUI Web Components. Others are components that leverage the Fluent UI design system or make it easier to work with Fluent UI. To get up and running with the library, see the &#39;Getting Started&#39; section below.&lt;/p&gt; &#xA;&lt;p&gt;The source for the library is hosted in the &lt;a href=&#34;https://github.com/microsoft/fluentui-blazor&#34;&gt;fluentui-blazor&lt;/a&gt; repository at GitHub. Documentation on the components is available at the &lt;a href=&#34;https://www.fluentui-blazor.net&#34;&gt;demo site&lt;/a&gt; and at &lt;a href=&#34;https://docs.microsoft.com/en-us/fluent-ui/web-components/&#34;&gt;docs.microsoft.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The source for &lt;code&gt;@fluentui/web-components&lt;/code&gt; is hosted in the &lt;a href=&#34;https://github.com/microsoft/fluentui/tree/master/packages/web-components&#34;&gt;fluentui&lt;/a&gt; mono-repository. Documentation for those components is available on &lt;a href=&#34;https://docs.microsoft.com/en-us/fluent-ui/web-components/&#34;&gt;docs.microsoft.com&lt;/a&gt;. The FluentUI Web Components are built on &lt;a href=&#34;https://www.fast.design/&#34;&gt;FAST&lt;/a&gt; and work in every major browser.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrading from an earlier version&lt;/h2&gt; &#xA;&lt;p&gt;If you are upgrading from an earlier version of the library, please see the &lt;a href=&#34;https://www.fluentui-blazor.net/whatsnew&#34;&gt;what&#39;s new&lt;/a&gt; for information on (breaking) changes.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;To get started using the Fluent UI Blazor components for Blazor, you will first need to install the official &lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Fast.Components.FluentUI/&#34;&gt;Nuget package for Fluent UI Blazor&lt;/a&gt; in the project you would like to use the library and components. You can use the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dotnet add package Microsoft.Fast.Components.FluentUI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Script&lt;/h3&gt; &#xA;&lt;p&gt;As of version 2.3 it is no longer needed to include the &lt;code&gt;web-components&lt;/code&gt; script in your &lt;code&gt;index.html&lt;/code&gt; or &lt;code&gt;_Layout.cshtml&lt;/code&gt; file. The script is now included in the library. This way we can safeguard that the you are always getting the version of the script that best matches the Blazor components.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;If you are upgrading from an earlier version please remove the script from your &lt;code&gt;index.html&lt;/code&gt; or &lt;code&gt;_Layout.cshtml&lt;/code&gt; file.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Styles&lt;/h3&gt; &#xA;&lt;p&gt;In order for this library to work as expected, you will need to add the composed scoped CSS file for the components. This can be done by adding the following line to the  section of your &lt;code&gt;index.html&lt;/code&gt; or &lt;code&gt;_Layout.cshtml&lt;/code&gt; file in the project you installed the package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#34;{PROJECT_NAME}.styles.css&#34; rel=&#34;stylesheet&#34; /&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible that the line is already in place (but commented out).&lt;/p&gt; &#xA;&lt;h4&gt;Reboot&lt;/h4&gt; &#xA;&lt;p&gt;Reboot is a collection of element-specific CSS changes in a single file to help kick-start building a site with the Fluent UI Blazor components for Blazor. It provides an elegant, consistent, and simple baseline to build upon.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use Reboot, you&#39;ll need to add to your &lt;code&gt;index.html&lt;/code&gt; or &lt;code&gt;_Layout.cshtml&lt;/code&gt; file a line that includes the stylesheet (&lt;code&gt;.css&lt;/code&gt; file). This can be done by adding the following line to the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#34;_content/Microsoft.Fast.Components.FluentUI/css/reboot.css&#34; rel=&#34;stylesheet&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is entirely possible to build a site without using Reboot. If you choose not to use it, please do add the &lt;code&gt;variables.css&lt;/code&gt; file (which is otherwise imported through the &lt;code&gt;reboot.css&lt;/code&gt; file) to your &lt;code&gt;index.html&lt;/code&gt; or &lt;code&gt;_Layout.cshtml&lt;/code&gt; file in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; section like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#34;_content/Microsoft.Fast.Components.FluentUI/css/variables.css&#34; rel=&#34;stylesheet&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The file contains a number of CSS variables that are required to be defined for the components to work correctly.&lt;/p&gt; &#xA;&lt;h3&gt;Project file&lt;/h3&gt; &#xA;&lt;p&gt;if you want to use icons and/or emoji, starting with version 2.1 you need add a &lt;code&gt;&amp;lt;PropertyGroup&amp;gt;&lt;/code&gt; to your project file. Within this group you can specify which icons and emoji are made available for usage and publication. Please refer to the &lt;a href=&#34;https://www.fluentui-blazor.net/ProjectSetup&#34;&gt;project setup&lt;/a&gt; document for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Code&lt;/h3&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://www.fluentui-blazor.net/CodeSetup&#34;&gt;code setup&lt;/a&gt; document to learn what needs to be included in your &lt;code&gt;Program.cs&lt;/code&gt; file so that all necessary services are available and setup in the correct way.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started by using project templates&lt;/h2&gt; &#xA;&lt;p&gt;To make it easier to start a project that uses the Fluent UI Blazor components out of the box, we have created the &lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Fast.Templates.FluentUI/&#34;&gt;Microsoft.Fast.Templates.FluentUI&lt;/a&gt; template package.&lt;/p&gt; &#xA;&lt;p&gt;The package contains templates for creating Blazor Server and/or Blazor WebAssembly apps that mimic the regular Blazor templates. The library is already set up (and all the Bootstrap styling removed). All components fromthe regular template have been replaced with Fluent UI Blazor counterparts (and a few extra have been added). Please see the &lt;a href=&#34;https://www.fluentui-blazor.net/Templates&#34;&gt;documentation page&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use icons and/or emoji with applications based on the templates, you still need to make the changes to the project file and &lt;code&gt;Program.cs&lt;/code&gt; as described in the previous sections.&lt;/p&gt; &#xA;&lt;h2&gt;Using the FluentUI Web Components&lt;/h2&gt; &#xA;&lt;p&gt;With the package installed and the script configured, you can begin using the Fluent UI Blazor components in the same way as any other Blazor component. Just be sure to add the following using statement to your views:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-razor&#34;&gt;@using Microsoft.Fast.Components.FluentUI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s a small example of a &lt;code&gt;FluentCard&lt;/code&gt; with a &lt;code&gt;FluentButton&lt;/code&gt; that uses the Fluent &#34;Accent&#34; appearance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-razor&#34;&gt;@using Microsoft.Fast.Components.FluentUI&#xA;&#xA;&amp;lt;FluentCard&amp;gt;&#xA;  &amp;lt;h2&amp;gt;Hello World!&amp;lt;/h2&amp;gt;&#xA;  &amp;lt;FluentButton Appearance=&#34;@Appearance.Accent&#34;&amp;gt;Click Me&amp;lt;/FluentButton&amp;gt;&#xA;&amp;lt;/FluentCard&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;💡&lt;/span&gt; &lt;strong&gt;Tip&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;You can add &lt;code&gt;@using Microsoft.Fast.Components.FluentUI&lt;/code&gt; to the namespace collection in &lt;code&gt;_Imports.razor&lt;/code&gt;, so you don&#39;t have to add it to every razor page that uses one of the components.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Configuring the Design System&lt;/h2&gt; &#xA;&lt;p&gt;The Fluent UI Blazor components are built on FAST&#39;s (Adaptive UI) technology, which enables design customization and personalization, while automatically maintaining accessibility. This is accomplished through setting various &#34;design tokens&#34;. The library exposes all design tokens, which you can use both from code as in a declarative way in your &lt;code&gt;.razor&lt;/code&gt; pages. The three different ways of working with design tokens are described in the &lt;a href=&#34;https://www.fluentui-blazor.net/DesignTokens&#34;&gt;design tokens&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;Blazor Hybrid&lt;/h2&gt; &#xA;&lt;p&gt;Starting with the 2.0 release, you can also use this library in your Blazor Hybrid projects. Setup is almost the same as described in the &#34;Getting started&#34; section above, but to get everything to work you&#39;ll need to take two extra steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;You need to add a MAUI specific IStaticAssetService implementation.&lt;br&gt; Due to some issues, this file can&#39;t be part of the library (yet) so this needs to be added manually to your MAUI Blazor project.&lt;br&gt; Create a new class in you project called &lt;code&gt;FileBasedStaticAssetService.cs&lt;/code&gt; Replace it&#39;s contents with the following:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System.Net;&#xA;using Microsoft.Fast.Components.FluentUI.Infrastructure;&#xA;&#xA;namespace Microsoft.Fast.Components.FluentUI;&#xA;&#xA;public class FileBasedStaticAssetService : IStaticAssetService&#xA;{&#xA;&#x9;public async Task&amp;lt;string&amp;gt; GetAsync(string assetUrl, bool useCache = false)&#xA;&#x9;{&#xA;&#x9;&#x9;string result = null;&#xA;&#x9;&#x9;HttpRequestMessage message = CreateMessage(assetUrl);&#xA;&#x9;&#x9;if (string.IsNullOrEmpty(result))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;result = await ReadData(assetUrl);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return result;&#xA;&#x9;}&#xA;&#x9;private static HttpRequestMessage CreateMessage(string url) =&amp;gt; new(HttpMethod.Get, url);&#xA; &#xA;&#x9;private static async Task&amp;lt;string&amp;gt; ReadData(string file)&#xA;&#x9;{&#xA;&#x9;&#x9;using var stream = await FileSystem.OpenAppPackageFileAsync($&#34;wwwroot/{file}&#34;);&#xA;&#x9;&#x9;using var reader = new StreamReader(stream);&#xA;&#x9;&#x9;return await reader.ReadToEndAsync();&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;You need to make some changes in your &lt;code&gt;MauiProgram.cs&lt;/code&gt; file&lt;br&gt; Make sure the following is added before the &lt;code&gt;return builder.Build()&lt;/code&gt; line:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;builder.Services.AddFluentUIComponents(options =&amp;gt;&#xA;{&#xA;&#x9;&#x9;options.HostingModel = BlazorHostingModel.Hybrid;&#xA;});&#xA;builder.Services.AddScoped&amp;lt;IStaticAssetService, FileBasedStaticAssetService&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tempory workaround for MAUI issues&lt;/h3&gt; &#xA;&lt;p&gt;Currently in MAUI the web-components script is not imported automatically (see &lt;a href=&#34;https://github.com/microsoft/fluentui-blazor/issues/404&#34;&gt;#404&lt;/a&gt;. There is also an isue with loading the custom event handelers that are being raised by the web-components script. Until these are fixed on the MAUI side, there is a workaround available, namely to intercept &#39;_framework/blazor.modules.json&#39; and provide proper JS initializers file (created by build). You can drop this &lt;a href=&#34;https://github.com/andreisaperski/fluentui-blazor/raw/hybrid-examples/examples/FluentUI.Demo.Hybrid.Shared/wwwroot/js/initializersLoader.windows.js&#34;&gt;initializersLoader.windows.js&lt;/a&gt; into wwwroot folder of your app and add a script tag for it to your &lt;code&gt;index.html&lt;/code&gt; right before the &lt;code&gt;_framework/blazor.webview.js&lt;/code&gt; tag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;script app-name=&#34;FluentUI.Demo.Hybrid.MAUI&#34; src=&#34;./_content/FluentUI.Demo.Hybrid.Shared/js/initializersLoader.windows.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&#34;_framework/blazor.webview.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;app-name&lt;/code&gt; attribute needs to match your app&#39;s assembly name - initializersLoader uses &#39;app-name&#39; to resolve name of the file with initializers. initializersLoader replaces standard &lt;code&gt;fetch&lt;/code&gt; function with one which provides the correct file in place of the empty &lt;code&gt;blazor.modules.json&lt;/code&gt;. &lt;code&gt;fetch&lt;/code&gt; is restored to its original state once &lt;code&gt;_framework/blazor.modules.json&lt;/code&gt; request is intercepted.&lt;/p&gt; &#xA;&lt;p&gt;For more information regarding the MAUI bug see issues &lt;a href=&#34;https://github.com/dotnet/maui/issues/15234&#34;&gt;15234&lt;/a&gt; there.&lt;/p&gt; &#xA;&lt;h2&gt;Use the DataGrid component with EF Core&lt;/h2&gt; &#xA;&lt;p&gt;If you want to use the &lt;code&gt;&amp;lt;FluentDataGrid&amp;gt;&lt;/code&gt; with data provided through EF Core, you need to install an additional package so the grid knows how to resolve queries asynchronously for efficiency. .&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Install the package by running the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet add package Microsoft.Fast.Components.FluentUI.DataGrid.EntityFrameworkAdapter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;In your Program.cs file you need to add the following after the &lt;code&gt;builder.Services.AddFluentUIComponents(...);&lt;/code&gt; lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;builder.Services.AddDataGridEntityFrameworkAdapter();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Additional resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Microsoft Fluent UI Blazor components &lt;a href=&#34;https://www.fluentui-blazor.net&#34;&gt;documentation and demo site&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Joining the Community&lt;/h3&gt; &#xA;&lt;p&gt;Looking to get answers to questions or engage with us in real-time? Our community is active on &lt;a href=&#34;https://app.gitter.im/#/room/#fluentui-blazor:gitter.im&#34;&gt;Gitter&lt;/a&gt; and &lt;a href=&#34;https://discord.gg/FcSNfg4&#34;&gt;Discord&lt;/a&gt;. Submit requests and issues on &lt;a href=&#34;https://github.com/microsoft/blazor-fluentui/issues/new/choose&#34;&gt;GitHub&lt;/a&gt;, or join us by contributing on &lt;a href=&#34;https://github.com/microsoft/fluentui-blazor/labels/community:good-first-issue&#34;&gt;some good first issues via GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We look forward to building an amazing open source community with you!&lt;/p&gt; &#xA;&lt;h3&gt;Contact&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Join the community and chat with us in real-time on &lt;a href=&#34;https://app.gitter.im/#/room/#fluentui-blazor:gitter.im&#34;&gt;Gitter&lt;/a&gt; or &lt;a href=&#34;https://discord.gg/FcSNfg4&#34;&gt;Discord&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Submit requests and issues on &lt;a href=&#34;https://github.com/microsoft/fluentui-blazor/issues/new/choose&#34;&gt;GitHub&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Contribute by helping out on some of our recommended first issues on &lt;a href=&#34;https://github.com/microsoft/fluentui-blazor/labels/community:good-first-issue&#34;&gt;GitHub&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>