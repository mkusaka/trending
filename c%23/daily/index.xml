<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-06T01:39:41Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>keijiro/BibcamVfx</title>
    <updated>2022-06-06T01:39:41Z</updated>
    <id>tag:github.com,2022-06-06:/keijiro/BibcamVfx</id>
    <link href="https://github.com/keijiro/BibcamVfx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AR VFX samples with Bibcam (burnt-in barcode metadata camera)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BibcamVfx&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/343936/143174726-3a01fd3d-eb9b-414b-8da0-b13ba147e3be.gif&#34; alt=&#34;gif&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/343936/143174736-3d68c401-3361-4ccb-9dc9-4a22420ef95a.gif&#34; alt=&#34;gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;BibcamVfx&lt;/strong&gt; is a sample project where I tried using &lt;a href=&#34;https://github.com/keijiro/Bibcam&#34;&gt;Bibcam&lt;/a&gt; to create AR visual effects.&lt;/p&gt; &#xA;&lt;p&gt;For the details of Bibcam, please check the &lt;a href=&#34;https://github.com/keijiro/Bibcam&#34;&gt;Bibcam&lt;/a&gt; repository.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>louthy/language-ext</title>
    <updated>2022-06-06T01:39:41Z</updated>
    <id>tag:github.com,2022-06-06:/louthy/language-ext</id>
    <link href="https://github.com/louthy/language-ext" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C# functional language extensions - a base class library for functional programming&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/Images/banner.png&#34; alt=&#34;lang-ext&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;C# Functional Programming Language Extensions&lt;/h1&gt; &#xA;&lt;p&gt;This library uses and abuses the features of C# to provide a functional-programming &#39;base class library&#39; that, if you squint, can look like extensions to the language itself. The desire here is to make programming in C# much more reliable and to make the engineer&#39;s inertia flow in the direction of declarative and functional code rather than imperative.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/discussions&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/Images/discussions.svg?sanitize=true&#34; alt=&#34;GitHub Discussions&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Author on twitter:&lt;/strong&gt; &lt;a href=&#34;https://twitter.com/paullouth&#34;&gt;https://twitter.com/paullouth&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#reference&#34;&gt;Reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#nu-get&#34;&gt;Nu-get package&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#code-gen-setup&#34;&gt;Code-gen setup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#unity&#34;&gt;Unity&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#getting-started&#34;&gt;Getting started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#prologue&#34;&gt;Prologue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#features&#34;&gt;&lt;strong&gt;Features&lt;/strong&gt;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#functional-effects-and-io&#34;&gt;Functional effects and IO&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#atomic-concurrency-and-collections&#34;&gt;Atomic concurrency, shared state, and collections&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#immutable-collections&#34;&gt;Immutable collections&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#optional-and-alternative-value-monads&#34;&gt;Optional and Alternative value monads&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#state-managing-monads&#34;&gt;State managing monads&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#parser-combinators&#34;&gt;Parser combinators&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#new-types---type-aliasing&#34;&gt;Type aliasing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#code-generation&#34;&gt;Records, Unions, Free Monads, Lenses - Code Generation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#pretty&#34;&gt;Pretty: Produce nicely formatted text with smart layouts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#make-c-better&#34;&gt;Make C# better: memoisation, currying, partial application, &lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Task&lt;/code&gt;, and &lt;code&gt;IQueryable&lt;/code&gt; extensions&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#poor-tuple-support&#34;&gt;Poor tuple support&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#null-reference-problem&#34;&gt;Null reference problem&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#option&#34;&gt;Option&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#lack-of-lambda-and-expression-inference&#34;&gt;Lack of lambda and expression inference&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#void-isnt-a-real-type&#34;&gt;Void isn&#39;t a real type&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#mutable-lists-and-dictionaries&#34;&gt;Mutable lists and dictionaries&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#lists&#34;&gt;Lists&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#list-pattern-matching&#34;&gt;List pattern matching&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#maps&#34;&gt;Maps&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#difficulty-in-creating-immutable-record-types&#34;&gt;Difficulty in creating immutable record types&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#transformation-of-immutable-types&#34;&gt;Transformation of immutable types&lt;/a&gt; &#xA;        &lt;ul&gt; &#xA;         &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#with&#34;&gt;&lt;code&gt;[With]&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;        &lt;/ul&gt; &lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#transformation-of-nested-immutable-types-with-lenses&#34;&gt;Transformation of nested immutable types with Lenses&lt;/a&gt; &#xA;        &lt;ul&gt; &#xA;         &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#withlens&#34;&gt;&lt;code&gt;[WithLens]&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;        &lt;/ul&gt; &lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#the-awful-out-parameter&#34;&gt;The awful &#39;out&#39; parameter&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#ad-hoc-polymorphism&#34;&gt;The lack of ad-hoc polymorphism&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#num%3CA%3E&#34;&gt;&lt;code&gt;Num&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#eq%3CA%3E&#34;&gt;&lt;code&gt;Eq&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#ord%3CA%3E&#34;&gt;&lt;code&gt;Ord&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#semigroup%3CA%3E&#34;&gt;&lt;code&gt;Semigroup&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#monoid%3CA%3E&#34;&gt;&lt;code&gt;Monoid&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#monad&#34;&gt;&lt;code&gt;Monad&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#transformer-types&#34;&gt;Transformer types&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#contributing--code-of-conduct&#34;&gt;Contributing &amp;amp; Code of Conduct&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/&#34;&gt;API Reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/issues?utf8=%E2%9C%93&amp;amp;q=is%3Aissue%20label%3A%22examples%20%2F%20documentation%22%20&#34;&gt;Issues that contain documentation and examples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Nu-get&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Nu-get package&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.Core&#34;&gt;LanguageExt.Core&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;All of the core types and functional &#39;prelude&#39;. &lt;strong&gt;This is all that&#39;s needed to get started&lt;/strong&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.Transformers&#34;&gt;LanguageExt.Transformers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;For every combination of monadic type &lt;code&gt;M&amp;lt;N&amp;lt;A&amp;gt;&amp;gt;&lt;/code&gt; (i.e. &lt;code&gt;Seq&amp;lt;Option&amp;lt;A&amp;gt;&amp;gt;&lt;/code&gt;), this package provides the following extension methods: &lt;code&gt;ApplyT&lt;/code&gt;, &lt;code&gt;AppendT&lt;/code&gt;, &lt;code&gt;BindT&lt;/code&gt;, &lt;code&gt;CompareT&lt;/code&gt;, &lt;code&gt;CountT&lt;/code&gt;, &lt;code&gt;EqualsT&lt;/code&gt;, &lt;code&gt;ExistsT&lt;/code&gt;, &lt;code&gt;ForAllT&lt;/code&gt;, &lt;code&gt;FoldT&lt;/code&gt;, &lt;code&gt;FoldBackT&lt;/code&gt;, &lt;code&gt;FilterT&lt;/code&gt;, &lt;code&gt;IterT&lt;/code&gt;, &lt;code&gt;MapT&lt;/code&gt;, &lt;code&gt;PlusT&lt;/code&gt;, &lt;code&gt;ProductT&lt;/code&gt;, &lt;code&gt;SubtractT&lt;/code&gt;, &lt;code&gt;DivideT&lt;/code&gt;, and &lt;code&gt;SumT&lt;/code&gt;. Which makes it much easier to work with those nested types (no need to manually unpack the bound values)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.FSharp&#34;&gt;LanguageExt.FSharp&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;F# to C# interop package. Provides interop between the LanguageExt.Core types (like &lt;code&gt;Option&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt;) to the F# equivalents, as well as interop between core BCL types and F#&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.Parsec&#34;&gt;LanguageExt.Parsec&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Port of the &lt;a href=&#34;https://hackage.haskell.org/package/parsec&#34;&gt;Haskell parsec library&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.Rx&#34;&gt;LanguageExt.Rx&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Reactive Extensions support for various types within the Core&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.Sys&#34;&gt;LanguageExt.Sys&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Provides an &lt;a href=&#34;https://github.com/louthy/language-ext/wiki/How-to-deal-with-side-effects&#34;&gt;&lt;code&gt;Aff&lt;/code&gt; and &lt;code&gt;Eff&lt;/code&gt;&lt;/a&gt; wrapper around the .NET System namespace making common IO operations pure and unit-testable&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.SysX&#34;&gt;LanguageExt.SysX&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;As above, but provides .NET5+ specific features&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.CodeGen&#34;&gt;LanguageExt.CodeGen&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Used to generate records, unions, lenses, and &lt;code&gt;With&lt;/code&gt; functions automagically&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Code-gen setup&lt;/h2&gt; &#xA;&lt;p&gt;To use the code-generation features of &lt;code&gt;language-ext&lt;/code&gt; (which are totally optional by the way), then you must include the &lt;a href=&#34;https://www.nuget.org/packages/LanguageExt.CodeGen&#34;&gt;LanguageExt.CodeGen&lt;/a&gt; package into your project.&lt;/p&gt; &#xA;&lt;p&gt;To make the reference &lt;strong&gt;build and design time only&lt;/strong&gt; (i.e. your project doesn&#39;t gain an additional dependencies because of the code-generator), open up your &lt;code&gt;csproj&lt;/code&gt; and set the &lt;code&gt;PrivateAssets&lt;/code&gt; attribute to &lt;code&gt;all&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;ItemGroup&amp;gt;&#xA;    &amp;lt;PackageReference Include=&#34;LanguageExt.Core&#34; Version=&#34;3.4.10&#34; /&amp;gt;&#xA;&#xA;    &amp;lt;PackageReference Include=&#34;LanguageExt.CodeGen&#34; Version=&#34;3.4.10&#34;&#xA;                      PrivateAssets=&#34;all&#34; /&amp;gt;&#xA;&#xA;    &amp;lt;PackageReference Include=&#34;CodeGeneration.Roslyn.BuildTime&#34;&#xA;                      Version=&#34;0.6.1&#34;&#xA;                      PrivateAssets=&#34;all&#34; /&amp;gt;&#xA;&#xA;    &amp;lt;DotNetCliToolReference Include=&#34;dotnet-codegen&#34; Version=&#34;0.6.1&#34; /&amp;gt;&#xA;&amp;lt;/ItemGroup&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Obviously, update the &lt;code&gt;Version&lt;/code&gt; attributes to the appropriate values. Also note that you will probably need the latest VS2019+ for this to work. Even early versions of VS2019 seem to have problems.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There&#39;s more information on the code-gen features on &lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;the wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Unity&lt;/h2&gt; &#xA;&lt;p&gt;This library seems compatible on the latest (at the time of writing) Unity 2018.2 with &lt;strong&gt;incremental compiler&lt;/strong&gt; (which enables C# 7), so it should work well once Unity has official support for C# 7 on upcoming 2018.3. In the meanwhile, you can install incremental compiler instead. If you are concerned about writing functionally and the possible performance overheads then please take a look at &lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Performance&#34;&gt;this wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;To use this library, simply include &lt;code&gt;LanguageExt.Core.dll&lt;/code&gt; in your project or grab it from NuGet, and add this to the top of each &lt;code&gt;.cs&lt;/code&gt; file that needs it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;using LanguageExt;&#xA;using static LanguageExt.Prelude;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The namespace &lt;code&gt;LanguageExt&lt;/code&gt; contains the core types, and &lt;code&gt;LanguageExt.Prelude&lt;/code&gt; contains the functions that you bring into scope &lt;code&gt;using static LanguageExt.Prelude&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Prologue&lt;/h2&gt; &#xA;&lt;p&gt;One of the great features of C#6+ is that it allows us to treat static classes like namespaces. This means that we can use static methods without qualifying them first. That instantly gives us access to single term method names that look exactly like functions in functional languages. i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    using static System.Console;&#xA;    &#xA;    WriteLine(&#34;Hello, World&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This library tries to bring some of the functional world into C#. It won&#39;t always sit well with the seasoned C# OO programmer, especially the choice of camelCase names for a lot of functions and the seeming &#39;globalness&#39; of a lot of the library.&lt;/p&gt; &#xA;&lt;p&gt;I can understand that much of this library is non-idiomatic, but when you think of the journey C# has been on, is &#34;idiomatic&#34; necessarily right? A lot of C#&#39;s idioms are inherited from Java and C# 1.0. Since then we&#39;ve had generics, closures, Func, LINQ, async... C# as a language is becoming more and more like a functional language on every release. In fact, the bulk of the new features are either inspired by or directly taken from features in functional languages. So perhaps it&#39;s time to move the C# idioms closer to the functional world&#39;s idioms?&lt;/p&gt; &#xA;&lt;h3&gt;A note about naming&lt;/h3&gt; &#xA;&lt;p&gt;One of the areas that&#39;s likely to get seasoned C# heads worked up is my choice of naming style. The intent is to try and make something that &lt;em&gt;feels&lt;/em&gt; like a functional language rather than following rules of naming conventions (mostly set out by the BCL).&lt;/p&gt; &#xA;&lt;p&gt;There is, however, a naming guide that will keep you in good stead while reading through this documentation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Type names are &lt;code&gt;PascalCase&lt;/code&gt; in the normal way&lt;/li&gt; &#xA; &lt;li&gt;The types all have constructor functions rather than public constructors that you instantiate with &lt;code&gt;new&lt;/code&gt;. They will always be &lt;code&gt;PascalCase&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    Option&amp;lt;int&amp;gt; x = Some(123);&#xA;    Option&amp;lt;int&amp;gt; y = None;&#xA;    Seq&amp;lt;int&amp;gt; items = Seq(1,2,3,4,5);&#xA;    List&amp;lt;int&amp;gt; items = List(1,2,3,4,5);&#xA;    HashMap&amp;lt;int, string&amp;gt; dict = HashMap((1, &#34;Hello&#34;), (2, &#34;World&#34;));&#xA;    Map&amp;lt;int, string&amp;gt; dict = Map((1, &#34;Hello&#34;), (2, &#34;World&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Any (non-type constructor) static function that can be used on its own by &lt;code&gt;using static LanguageExt.Prelude&lt;/code&gt; are &lt;code&gt;camelCase&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var x = map(opt, v =&amp;gt; v * 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Any extension methods, or anything &#34;fluent&#34; are &lt;code&gt;PascalCase&lt;/code&gt; in the normal way&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var x = opt.Map(v =&amp;gt; v * 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even if you disagree with this non-idiomatic approach, all of the &lt;code&gt;camelCase&lt;/code&gt; static functions have fluent variants, so you never actually have to see the non-standard stuff.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;If you&#39;re not using C# 6 yet, then you can still use this library. Anywhere in the docs below where you see a camelCase function it can be accessed by prefixing with &lt;code&gt;Prelude.&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h3&gt;Functional effects and IO&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Aff&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/How-to-deal-with-side-effects&#34;&gt;An asynchronous effect: an IO monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Eff&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/How-to-deal-with-side-effects&#34;&gt;A synchronous effect: an IO monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Aff&amp;lt;RT, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/How-to-deal-with-side-effects&#34;&gt;An asynchronous effect with injectable runtime: a unit testable IO monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Eff&amp;lt;RT, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/How-to-deal-with-side-effects&#34;&gt;A synchronous effect with injectable runtime: a unit testable IO monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Pipes&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/How-to-deal-with-side-effects&#34;&gt;A clean and powerful stream processing system that lets you build and connect reusable streaming components&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Atomic concurrency and collections&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Atom&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/Atom&#34;&gt;A lock-free atomically mutable reference for working with shared state&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ref&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/STM&#34;&gt;An atomic reference to be used in the transactional memory system&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;AtomHashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/AtomHashMap&#34;&gt;An immutable &lt;code&gt;HashMap&lt;/code&gt; with a lock-free atomically mutable reference&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;AtomSeq&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/AtomSeq&#34;&gt;An immutable &lt;code&gt;Seq&lt;/code&gt; with a lock-free atomically mutable reference&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;VectorClock&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/VectorClock&#34;&gt;Understand distributed causality&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;VersionVector&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/VersionVector&#34;&gt;A vector clock with some versioned data&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;VersionHashMap &amp;lt;ConflictV, K, V&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/VersionHashMap&#34;&gt;Distrubuted atomic versioning of keys in a hash-map&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Immutable collections&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Arr&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Arr/index.html&#34;&gt;Immutable array&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Seq&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Seq/index.html&#34;&gt;Immutable list with lazy behavior - a better &lt;code&gt;IEnumerable&lt;/code&gt;. Very, very fast!&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Lst&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/List/index.html&#34;&gt;Immutable list - use &lt;code&gt;Seq&lt;/code&gt; over &lt;code&gt;Lst&lt;/code&gt; unless you need &lt;code&gt;InsertAt&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Map&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Map/index.html&#34;&gt;Immutable map&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Map&amp;lt;OrdK, K, V&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Map/index.html&#34;&gt;Immutable map with Ord constraint on &lt;code&gt;K&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/HashMap/index.html&#34;&gt;Immutable hash-map&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;HashMap&amp;lt;EqK, K, V&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/HashMap/index.html&#34;&gt;Immutable hash-map with Eq constraint on &lt;code&gt;K&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Set&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Set/index.html&#34;&gt;Immutable set&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Set&amp;lt;OrdA, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Set/index.html&#34;&gt;Immutable set with Ord constraint on &lt;code&gt;A&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;HashSet&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/HashSet/index.html&#34;&gt;Immutable hash-set&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;HashSet&amp;lt;EqA, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/HashSet/index.html&#34;&gt;Immutable hash-set with Eq constraint on &lt;code&gt;A&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Que&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Queue/index.html&#34;&gt;Immutable queue&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Stck&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Immutable%20Collections/Stack/index.html&#34;&gt;Immutable stack&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Optional and alternative value monads&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Option&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Option/Option/index.html&#34;&gt;Option monad&lt;/a&gt; that can&#39;t be used with &lt;code&gt;null&lt;/code&gt; values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;OptionAsync&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Option/OptionAsync/index.html&#34;&gt;OptionAsync monad&lt;/a&gt; that can&#39;t be used with &lt;code&gt;null&lt;/code&gt; values with all value realisation does asynchronously&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;OptionUnsafe&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Option/OptionUnsafe/index.html&#34;&gt;Option monad&lt;/a&gt; that can be used with &lt;code&gt;null&lt;/code&gt; values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Either&amp;lt;L,R&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Either/Either/index.html&#34;&gt;Right/Left choice monad&lt;/a&gt; that won&#39;t accept &lt;code&gt;null&lt;/code&gt; values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;EitherUnsafe&amp;lt;L, R&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Either/EitherUnsafe/index.html&#34;&gt;Right/Left choice monad&lt;/a&gt; that can be used with &lt;code&gt;null&lt;/code&gt; values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;EitherAsync&amp;lt;L, R&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Either/EitherAsync/index.html&#34;&gt;EitherAsync monad&lt;/a&gt; that can&#39;t be used with &lt;code&gt;null&lt;/code&gt; values with all value realisation done asynchronously&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Try&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Try/Try/index.html&#34;&gt;Exception handling lazy monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;TryAsync&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Try/TryAsync/index.html&#34;&gt;Asynchronous exception handling lazy monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;TryOption&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Try/TryOption/index.html&#34;&gt;Option monad with third state&lt;/a&gt; &#39;Fail&#39; that catches exceptions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;TryOptionAsync&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Try/TryOptionAsync/index.html&#34;&gt;Asynchronous Option monad with third state&lt;/a&gt; &#39;Fail&#39; that catches exceptions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Validation&amp;lt;FAIL,SUCCESS&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Validation/index.html&#34;&gt;Validation applicative and monad&lt;/a&gt; for collecting multiple errors before aborting an operation&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Validation&amp;lt;MonoidFail, FAIL, SUCCESS&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Validation/index.html&#34;&gt;Validation applicative and monad&lt;/a&gt; for collecting multiple errors before aborting an operation, uses the supplied monoid in the first generic argument to collect the failure values.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;State managing monads&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Reader&amp;lt;E, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/State%20and%20Environment%20Monads/Reader/index.html&#34;&gt;Reader monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Writer&amp;lt;MonoidW, W, T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/State%20and%20Environment%20Monads/Writer/index.html&#34;&gt;Writer monad that logs to a &lt;code&gt;W&lt;/code&gt; constrained to be a Monoid&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;State&amp;lt;S, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/State%20and%20Environment%20Monads/State/index.html&#34;&gt;State monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;RWS&amp;lt;R, W, S, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/State%20and%20Environment%20Monads/RWS/index.html&#34;&gt;Reader Writer State monad&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Parser combinators&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Parsec&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Parser&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Parsec/index.html&#34;&gt;String parser monad and full parser combinators library&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Parsec&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Parser&amp;lt;I, O&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Parsec/index.html&#34;&gt;Parser monad that can work with any input stream type&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;New types - Type aliasing&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;NewType&amp;lt;SELF, A, PRED&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/New%20Types/NewType/index.html&#34;&gt;Haskell &lt;code&gt;newtype&lt;/code&gt; equivalent&lt;/a&gt; i.e: &lt;code&gt;class Hours : NewType&amp;lt;Hours, double&amp;gt; { public Hours(double value) : base(value) { } }&lt;/code&gt;. The resulting type is: equatable, comparable, foldable, a functor, monadic, and iterable&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;NumType&amp;lt;SELF, NUM, A, PRED&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/New%20Types/NumType/index.html&#34;&gt;Haskell &lt;code&gt;newtype&lt;/code&gt; equivalent but for numeric types&lt;/a&gt; i.e: &lt;code&gt;class Hours : NumType&amp;lt;Hours, TDouble, double&amp;gt; { public Hours(double value) : base(value) { } }&lt;/code&gt;. The resulting type is: equatable, comparable, foldable, a functor, a monoid, a semigroup, monadic, iterable, and can have basic artithmetic operations performed upon it.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;FloatType&amp;lt;SELF, FLOATING, A, PRED&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/New%20Types/FloatType/index.html&#34;&gt;Haskell &lt;code&gt;newtype&lt;/code&gt; equivalent but for real numeric types&lt;/a&gt; i.e: &lt;code&gt;class Hours : FloatType&amp;lt;Hours, TDouble, double&amp;gt; { public Hours(double value) : base(value) { } }&lt;/code&gt;. The resulting type is: equatable, comparable, foldable, a functor, a monoid, a semigroup, monadic, iterable, and can have complex artithmetic operations performed upon it.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Code generation&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CodeGen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Records&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Generate record types automatically&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CodeGen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Unions&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Generate discriminated unions automatically&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CodeGen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Free monads&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Generate discriminated free-monads&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CodeGen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Reader&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Generate reader-monads&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CodeGen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RWS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Generate RWS-monads&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CodeGen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;With&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Add a tranformational &lt;code&gt;With&lt;/code&gt; method to your records&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CodeGen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WithLens&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/louthy/language-ext/wiki/Code-generation&#34;&gt;Add a tranformational &lt;code&gt;With&lt;/code&gt; and generated Lenses method to your data types&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Lens&amp;lt;A, B&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/louthy/language-ext/main/#transformation-of-nested-immutable-types-with-lenses&#34;&gt;Well behaved bidirectional transformations&lt;/a&gt; - i.e. the ability to easily generate new immutable values from existing ones, even when heavily nested.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Record&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/Record/index.html&#34;&gt;Base type for creating record types&lt;/a&gt; with automatic structural equality, ordering, and hash code calculation.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Pretty&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Doc&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Produce nicely formatted text with smart layouts&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Differencing&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Patch&amp;lt;EqA, A&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Uses patch-theory to efficiently calculate the difference (&lt;code&gt;Patch.diff(list1, list2)&lt;/code&gt;) between two collections of &lt;code&gt;A&lt;/code&gt; and build a patch which can be applied (&lt;code&gt;Patch.apply(patch, list)&lt;/code&gt;) to one to make the other (think git diff).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Make C# better&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Location&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; extensions&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/Nullable/index.html&#34;&gt;Extension methods for &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; that make it into a functor, applicative, foldable, iterable and a monad&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt; extensions&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Concurrency/Task/index.html&#34;&gt;Extension methods for &lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; that make it into a functor, applicative, foldable, iterable and a monad&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Prelude/Lambda%20function%20inference/index.html&#34;&gt;Improved lambda type inference&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;var add = fun( (int x, int y) =&amp;gt; x + y)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Currying&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Prelude/Currying%20and%20Partial%20Application/index.html&#34;&gt;Translate the evaluation of a function that takes multiple arguments into a sequence of functions, each with a single argument&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Partial application&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Prelude/Currying%20and%20Partial%20Application/index.html&#34;&gt;the process of fixing a number of arguments to a function, producing another function of smaller arity&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Extensions/index.html&#34;&gt;&lt;code&gt;IQueryable&amp;lt;T&amp;gt;&lt;/code&gt; extensions&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Extensions/index.html&#34;&gt;&lt;code&gt;IObservable&amp;lt;T&amp;gt;&lt;/code&gt; extensions&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Memoization&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Prelude/Memoizing/index.html&#34;&gt;An optimization technique used primarily to speed up programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;This library started out trying to deal with issues in C#, that after using Haskell and F# started to frustrate me:&lt;/p&gt; &#xA;&lt;h2&gt;Poor tuple support&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: Since writing this, the csharplang team have improved tuple support in C#&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;I&#39;ve been crying out for proper tuple support for ages. When this library was created we were no closer (C# 6). The standard way of creating them is ugly &lt;code&gt;Tuple.Create(foo,bar)&lt;/code&gt; compared to functional languages where the syntax is often &lt;code&gt;(foo,bar)&lt;/code&gt; and to consume them you must work with the standard properties of &lt;code&gt;Item1&lt;/code&gt;...&lt;code&gt;ItemN&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var ab = Tuple(&#34;a&#34;,&#34;b&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now isn&#39;t that nice?&lt;/p&gt; &#xA;&lt;p&gt;Consuming the tuple is now handled using &lt;code&gt;Map&lt;/code&gt;, which projects the &lt;code&gt;Item1&lt;/code&gt;...&lt;code&gt;ItemN&lt;/code&gt; onto a lambda function (or action):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var name = Tuple(&#34;Paul&#34;,&#34;Louth&#34;);&#xA;    var res = name.Map( (first, last) =&amp;gt; $&#34;{first} {last}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, you can use a more functional approach:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var name = Tuple(&#34;Paul&#34;,&#34;Louth&#34;);&#xA;    var res = map( name, (first, last) =&amp;gt; $&#34;{first} {last}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows the tuple properties to have names, and it also allows for fluent handling of functions that return tuples.&lt;/p&gt; &#xA;&lt;p&gt;If you are using C#7+ then you&#39;ll know that the new &lt;code&gt;Tuple&lt;/code&gt; type is &lt;code&gt;ValueTuple&lt;/code&gt;. Just like with &lt;code&gt;Tuple&lt;/code&gt;, language-ext adds many extensions to the standard BCL &lt;code&gt;ValueTuple&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var abc = (&#39;a&#39;, &#39;b&#39;).Add(&#39;c&#39;);                                           // (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)&#xA;    var abcd = (&#39;a&#39;, &#39;b&#39;).Add(&#39;c&#39;).Add(&#39;d&#39;);                                 // (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)&#xA;    var abcd5 = (&#39;a&#39;, &#39;b&#39;).Add(&#39;c&#39;).Add(&#39;d&#39;).Add(5);                         // (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, 5)&#xA;&#xA;    var sum = (1, 2, 3).Sum&amp;lt;TInt, int&amp;gt;();                                    // 6&#xA;    var product = (2, 4, 8).Product&amp;lt;TInt, int&amp;gt;();                            // 64&#xA;    var flag = (&#34;one&#34;, &#34;two&#34;, &#34;three&#34;).Contains&amp;lt;TString, string&amp;gt;(&#34;one&#34;);     // true&#xA;    var str = (&#34;Hello&#34;, &#34; &#34;, &#34;World&#34;).Concat&amp;lt;TString, string&amp;gt;();             // &#34;Hello World&#34;&#xA;    var list = (List(1, 2, 3), List(4, 5, 6)).Concat&amp;lt;TLst&amp;lt;int&amp;gt;, Lst&amp;lt;int&amp;gt;&amp;gt;(); // [1,2,3,4,5,6]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Null reference problem&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: Since writing this, the csharplang team have improved null support in C#&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;null&lt;/code&gt; must be &lt;a href=&#34;https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/&#34;&gt;the biggest mistake&lt;/a&gt; in the whole of computer language history. I realise the original designers of C# had to make pragmatic decisions, it&#39;s a shame this one slipped through though. So, what to do about the &#34;null problem&#34;?&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;null&lt;/code&gt; is often used to indicate &lt;em&gt;no value&lt;/em&gt;; the method called can&#39;t produce a value of the type it said it was going to produce, and therefore it gives you &#34;nothing&#34;. The thing is that when &lt;em&gt;no value&lt;/em&gt; is passed to the consuming code, it gets assigned to a variable of type T, the same type that the function said it was going to return, except this variable now has a timebomb in it. You must continually check if the value is &lt;code&gt;null&lt;/code&gt;, if it&#39;s passed around it must be checked too.&lt;/p&gt; &#xA;&lt;p&gt;As we all know it&#39;s only a matter of time before a null reference bug crops up because the variable wasn&#39;t checked. It puts C# in the realm of the dynamic languages, where you can&#39;t trust the value you&#39;re being given.&lt;/p&gt; &#xA;&lt;p&gt;Functional languages use what&#39;s known as an &lt;em&gt;option type&lt;/em&gt;. In F# it&#39;s called &lt;code&gt;Option&lt;/code&gt;, in Haskell it&#39;s called &lt;code&gt;Maybe&lt;/code&gt;. In the next section we&#39;ll see how it&#39;s used.&lt;/p&gt; &#xA;&lt;h2&gt;Option&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; works in a very similar way to &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, except it works with all types rather than just value types. It&#39;s a &lt;code&gt;struct&lt;/code&gt; and therefore can&#39;t be &lt;code&gt;null&lt;/code&gt;. An instance can be created by either calling &lt;code&gt;Some(value)&lt;/code&gt;, which represents a positive &#34;I have a value&#34; response, or &lt;code&gt;None&lt;/code&gt;, which is the equivalent of returning &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;So why is it any better than returning &lt;code&gt;T&lt;/code&gt; and using &lt;code&gt;null&lt;/code&gt;? It seems we can have a non-value response again right? Yes, that&#39;s true, however you&#39;re forced to acknowledge that fact and to write code to handle both possible outcomes because you can&#39;t get to the underlying value without acknowledging the possibility of the two states that the value could be in. This bulletproofs your code. You&#39;re also explicitly telling any other programmers that &#34;this method might not return a value, so make sure you deal with that&#34;. This explicit declaration is very powerful.&lt;/p&gt; &#xA;&lt;p&gt;This is how you create an &lt;code&gt;Option&amp;lt;int&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var optional = Some(123);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To access the value you must check that it&#39;s valid first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    int x = optional.Match( &#xA;                Some: v  =&amp;gt; v * 2,&#xA;                None: () =&amp;gt; 0 &#xA;                );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An alternative (functional) way of matching is this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    int x = match( optional, &#xA;                   Some: v  =&amp;gt; v * 2,&#xA;                   None: () =&amp;gt; 0 );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Yet another alternative (&#34;fluent&#34;) matching method is this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    int x = optional&#xA;               .Some( v  =&amp;gt; v * 2 )&#xA;               .None( () =&amp;gt; 0 );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So choose your preferred method and stick with it. It&#39;s probably best not to mix styles.&lt;/p&gt; &#xA;&lt;p&gt;There are also some helper functions to work with default &lt;code&gt;None&lt;/code&gt; values; you won&#39;t see a &lt;code&gt;.Value&lt;/code&gt; or a &lt;code&gt;GetValueOrDefault()&lt;/code&gt; anywhere in this library. This is because &lt;code&gt;.Value&lt;/code&gt; puts us right back to where we started, and you may as well not use &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; in that case. &lt;code&gt;GetValueOrDefault()&lt;/code&gt; is also just as bad because it can return &lt;code&gt;null&lt;/code&gt; for reference types, and depends on how well defined the &lt;code&gt;struct&lt;/code&gt; type is you&#39;re working with.&lt;/p&gt; &#xA;&lt;p&gt;However, clearly there will be times when you don&#39;t need to do anything with the &lt;code&gt;Some&lt;/code&gt; case. Also, sometimes you just want some code to execute in the &lt;code&gt;Some&lt;/code&gt; case and not the &lt;code&gt;None&lt;/code&gt; case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Returns the Some case &#39;as is&#39; and 10 in the None case&#xA;    int x = optional.IfNone(10);        &#xA;&#xA;    // As above, but invokes a Func&amp;lt;T&amp;gt; to return a valid value for x&#xA;    int x = optional.IfNone(() =&amp;gt; GetAlternative());        &#xA;    &#xA;    // Invokes an Action&amp;lt;T&amp;gt; if in the Some state.&#xA;    optional.IfSome(x =&amp;gt; Console.WriteLine(x));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course there are functional versions of the fluent version above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    int x = ifNone(optional, 10);&#xA;    int x = ifNone(optional, () =&amp;gt; GetAlternative());&#xA;    ifSome(optional, x =&amp;gt; Console.WriteLine(x));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To smooth out the process of returning &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; types from methods there are some implicit conversion operators and constructors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Implicitly converts the integer to a Some of int&#xA;    Option&amp;lt;int&amp;gt; GetValue()&#xA;    {&#xA;        return 1000;&#xA;    }&#xA;&#xA;    // Implicitly converts to a None of int&#xA;    Option&amp;lt;int&amp;gt; GetValue()&#xA;    {&#xA;        return None;&#xA;    }&#xA;    &#xA;    // Will handle either a None or a Some returned&#xA;    Option&amp;lt;int&amp;gt; GetValue(bool select) =&amp;gt;&#xA;        select&#xA;            ? Some(1000)&#xA;            : None;&#xA;            &#xA;    // Explicitly converts a null value to None and a non-null value to Some(value)&#xA;    Option&amp;lt;string&amp;gt; GetValue()&#xA;    {&#xA;        string value = GetValueFromNonTrustedApi();&#xA;        return Optional(value);&#xA;    }&#xA;            &#xA;    // Implicitly converts a null value to None and a non-null value to Some(value)&#xA;    Option&amp;lt;string&amp;gt; GetValue()&#xA;    {&#xA;        string value = GetValueFromNonTrustedApi();&#xA;        return value;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s actually nearly impossible to get a &lt;code&gt;null&lt;/code&gt; out of a function, even if the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is a reference type and you write &lt;code&gt;Some(null)&lt;/code&gt;. Firstly, it won&#39;t compile, but you might think you can do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    private Option&amp;lt;string&amp;gt; GetStringNone()&#xA;    {&#xA;        string nullStr = null;&#xA;        return Some(nullStr);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That will compile, but at runtime will throw a &lt;code&gt;ValueIsNullException&lt;/code&gt;. If you do either of these (below) you&#39;ll get a &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    private Option&amp;lt;string&amp;gt; GetStringNone()&#xA;    {&#xA;        string nullStr = null;&#xA;        return nullStr;&#xA;    }&#xA;&#xA;    private Option&amp;lt;string&amp;gt; GetStringNone()&#xA;    {&#xA;        string nullStr = null;&#xA;        return Optional(nullStr);&#xA;    }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These are the coercion rules:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Converts from&lt;/th&gt; &#xA;   &lt;th&gt;Converts to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(x)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;None&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;None&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;None&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(x)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(x)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(null)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ValueIsNullException&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(None)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(None)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(Some(x))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(Some(x))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(Nullable null)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ValueIsNullException&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(Nullable x)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(x)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Optional(x)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(x)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Optional(null)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;None&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Optional(Nullable null)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;None&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Optional(Nullable x)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(x)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;As well as the protection of the internal value of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, there&#39;s protection for the return value of the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; handler functions. You can&#39;t return &lt;code&gt;null&lt;/code&gt; from those either; an exception will be thrown.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // This will throw a ResultIsNullException exception&#xA;    string res = GetValue(true)&#xA;                     .Some(x =&amp;gt; (string)null)&#xA;                     .None((string)null);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;null&lt;/code&gt; goes away if you use &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, there are times when you may want your &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; handlers to return &lt;code&gt;null&lt;/code&gt;. This is mostly when you need to use something in the BCL or from a third-party library, so momentarily you need to step out of your warm and cosy protected optional bubble, but you&#39;ve got an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; that will throw an exception if you try.&lt;/p&gt; &#xA;&lt;p&gt;So you can use &lt;code&gt;matchUnsafe&lt;/code&gt; and &lt;code&gt;ifNoneUnsafe&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    string x = matchUnsafe( optional,&#xA;                            Some: v =&amp;gt; v,&#xA;                            None: () =&amp;gt; null );&#xA;&#xA;    string x = ifNoneUnsafe( optional, (string)null );&#xA;    string x = ifNoneUnsafe( optional, () =&amp;gt; GetNull() );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And fluent versions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    string x = optional.MatchUnsafe(&#xA;                   Some: v =&amp;gt; v,&#xA;                   None: () =&amp;gt; null &#xA;                   );&#xA;    string x = optional.IfNoneUnsafe((string)null);&#xA;    string x = optional.IfNoneUnsafe(() =&amp;gt; GetNull());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is consistent throughout the library. Anything that could return &lt;code&gt;null&lt;/code&gt; has the &lt;code&gt;Unsafe&lt;/code&gt; suffix. That means that in those unavoidable circumstances where you need a &lt;code&gt;null&lt;/code&gt;, it gives you and any other programmers working with your code the clearest possible sign that they should treat the result with care.&lt;/p&gt; &#xA;&lt;h3&gt;Option monad - gasp! Not the M word!&lt;/h3&gt; &#xA;&lt;p&gt;I know, it&#39;s that damn monad word again. They&#39;re actually not scary at all, and damn useful. But if you couldn&#39;t care less (or &lt;em&gt;could&lt;/em&gt; care less, for my American friends), it won&#39;t stop you taking advantage of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type. However, &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type also implements &lt;code&gt;Select&lt;/code&gt; and &lt;code&gt;SelectMany&lt;/code&gt; and is therefore monadic, which also means it can be used in LINQ expressions and much more!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    Option&amp;lt;int&amp;gt; two = Some(2);&#xA;    Option&amp;lt;int&amp;gt; four = Some(4);&#xA;    Option&amp;lt;int&amp;gt; six = Some(6);&#xA;    Option&amp;lt;int&amp;gt; none = None;&#xA;&#xA;    // This expression succeeds because all items to the right of &#39;in&#39; are Some of int&#xA;    // and therefore it lands in the Some lambda.&#xA;    int r = match( from x in two&#xA;                   from y in four&#xA;                   from z in six&#xA;                   select x + y + z,&#xA;                   Some: v =&amp;gt; v * 2,&#xA;                   None: () =&amp;gt; 0 );     // r == 24&#xA;&#xA;    // This expression bails out once it gets to the None, and therefore doesn&#39;t calculate x+y+z&#xA;    // and lands in the None lambda&#xA;    int r = match( from x in two&#xA;                   from y in four&#xA;                   from _ in none&#xA;                   from z in six&#xA;                   select x + y + z,&#xA;                   Some: v =&amp;gt; v * 2,&#xA;                   None: () =&amp;gt; 0 );     // r == 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can be great for avoiding the use of &lt;code&gt;if then else&lt;/code&gt;, because the computation continues as long as the result is &lt;code&gt;Some&lt;/code&gt; and bails otherwise. It is also great for building blocks of computation that you can compose and reuse. Yes, actually compose and reuse, not like OOP where the promise of composability and modularity are essentially lies.&lt;/p&gt; &#xA;&lt;p&gt;To take this much further, all of the monads in this library implement a standard &#34;functional set&#34; of functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    Sum                 // For Option&amp;lt;int&amp;gt; it&#39;s the wrapped value.&#xA;    Count               // For Option&amp;lt;T&amp;gt; is always 1 for Some and 0 for None. &#xA;    Bind                // Part of the definition of anything monadic - SelectMany in LINQ&#xA;    Exists              // Any in LINQ - true if any element fits a predicate&#xA;    Filter              // Where in LINQ&#xA;    Fold                // Aggregate in LINQ&#xA;    ForAll              // All in LINQ - true if all element(s) fits a predicate&#xA;    Iter                // Passes the wrapped value(s) to an Action delegate&#xA;    Map                 // Part of the definition of any &#39;functor&#39;. Select in LINQ&#xA;    Lift / LiftUnsafe   // Different meaning to Haskell, this returns the wrapped value. Dangerous, should be used sparingly.&#xA;    Select&#xA;    SelectMany&#xA;    Where&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This makes them into what would be known in Haskell as a Type Class (although more of a catch-all type-class than a set of well-defined type-classes).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Monads/Alternative%20Value%20Monads/index.html&#34;&gt;Option and alternative-value-monads reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Monad transformer extensions&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For this section you will need the &lt;code&gt;LanguageExt.Transformers&lt;/code&gt; nu-get package&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Monad transformers extensions allow for behaviours that work with nested monadic types. Imagine functionality for working with &lt;code&gt;Seq&amp;lt;Option&amp;lt;A&amp;gt;&amp;gt;&lt;/code&gt; or a &lt;code&gt;Option&amp;lt;Task&amp;lt;A&amp;gt;&amp;gt;&lt;/code&gt;, etc. without having to unpack the values bound within.&lt;/p&gt; &#xA;&lt;p&gt;One problem with C# is it can&#39;t do higher order polymorphism (imagine saying &lt;code&gt;M&amp;lt;T&amp;gt; where M : Monad&lt;/code&gt; where the &lt;code&gt;M&lt;/code&gt; is polymorphic like the &lt;code&gt;T&lt;/code&gt;, and can be constrianed). There is a kind of cheat way to do it in C# through extension methods, but it still doesn&#39;t get you something that fits the pattern &lt;code&gt;M&amp;lt;T&amp;gt; where M : Monad&lt;/code&gt;. So there are limitations in that you can&#39;t write generic functions over higher-kinds, but with a bit of cunning we can generate code to deal with every pairing of monadic types.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;There&#39;s discussion later in the section on Ad-hoc Polymorphism of a more general approach, but it&#39;s a little too complicated use&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;As an example, below is a list of optional integers: &lt;code&gt;Lst&amp;lt;Option&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; (see lists later). We want to double all of the &lt;code&gt;Some&lt;/code&gt; values, leave the &lt;code&gt;None&lt;/code&gt; alone and keep everything in the list:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    using LanguageExt;&#xA;    using static LanguageExt.Prelude;&#xA;&#xA;    var list = List(Some(1), None, Some(2), None, Some(3));&#xA;&#xA;    list = list.MapT(x =&amp;gt; x * 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice the use of &lt;code&gt;MapT&lt;/code&gt; instead of &lt;code&gt;Map&lt;/code&gt;. If we used &lt;code&gt;Map&lt;/code&gt; (equivalent to &lt;code&gt;Select&lt;/code&gt; in &lt;code&gt;LINQ&lt;/code&gt;), it would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var list  = List(Some(1), None, Some(2), None, Some(3));&#xA;    &#xA;    list = list.Map(x =&amp;gt; x.Map( v =&amp;gt; v * 2));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the intention is much clearer in the first example, which is the point of functional programming most of the time. It&#39;s about declaring intent rather than the mechanics of delivery.&lt;/p&gt; &#xA;&lt;p&gt;To make this work we need extension methods for &lt;code&gt;List&amp;lt;Option&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that define &lt;code&gt;MapT&lt;/code&gt; and &lt;code&gt;SumT&lt;/code&gt; [for the one example above]. We also need one for every pair of monads in this library (for one level of nesting &lt;code&gt;A&amp;lt;B&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;), and for every function from the &#34;standard functional set&#34; listed above. That&#39;s 32 monads * 32 monads * 20 functions. That&#39;s a lot of extension methods (20,480!). Because of this, there&#39;s T4 template that generates &#39;monad transformers&#39; that allows for nested monads.&lt;/p&gt; &#xA;&lt;p&gt;This is super powerful, and means that most of the time you can leave your &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; or any of the monads in this library wrapped and rarely need to extract the value. You usually only need to extract the value to pass to the BCL or third-party libraries. Even then you could keep them wrapped and use &lt;code&gt;Iter&lt;/code&gt; or &lt;code&gt;IterT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;if( arg == null ) throw new ArgumentNullException(&#34;arg&#34;)&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: Since writing this, the csharplang team have improved required arguments in C#&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Another horrible side-effect of &lt;code&gt;null&lt;/code&gt; is having to bullet-proof every function that takes reference arguments. This is truly tedious. Instead use this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    public void Foo( Some&amp;lt;string&amp;gt; arg )&#xA;    {&#xA;        string value = arg;&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By wrapping &lt;code&gt;string&lt;/code&gt; as &lt;code&gt;Some&amp;lt;string&amp;gt;&lt;/code&gt; we get free runtime &lt;code&gt;null&lt;/code&gt; checking. Essentially it&#39;s impossible (well, almost) for &lt;code&gt;null&lt;/code&gt; to propagate through. As you can see above, the &lt;code&gt;arg&lt;/code&gt; variable casts automatically to &lt;code&gt;string value&lt;/code&gt;. It&#39;s also possible to get at the inner-value like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    public void Foo( Some&amp;lt;string&amp;gt; arg )&#xA;    {&#xA;        string value = arg.Value;&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; is a &lt;code&gt;struct&lt;/code&gt; and has implicit conversion operators that convert a type of &lt;code&gt;T&lt;/code&gt; to a type of &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt;. The constructor of &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; ensures that the value of &lt;code&gt;T&lt;/code&gt; has a non-null value.&lt;/p&gt; &#xA;&lt;p&gt;There is also an implicit cast operator from &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; will automatically put the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Some&lt;/code&gt; state. It&#39;s not possible to go the other way and cast from &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt;, because the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; could be in a &lt;code&gt;None&lt;/code&gt; state which would cause the &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; to throw &lt;code&gt;ValueIsNullException&lt;/code&gt;. We want to avoid exceptions being thrown, so you must explicitly &lt;code&gt;match&lt;/code&gt; to extract the &lt;code&gt;Some&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;p&gt;There is one weakness to this approach: if you add a member property or field to a class which is a &lt;code&gt;struct&lt;/code&gt;, and if you don&#39;t initialise it, then C# is happy to go along with that. This is the reason why you shouldn&#39;t normally include reference members inside structs (or if you do, have a strategy for dealing with it).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; unfortunately falls victim to this; it wraps a reference of type T. Therefore it can&#39;t realistically create a useful default. C# also doesn&#39;t call the default constructor for a &lt;code&gt;struct&lt;/code&gt; in these circumstances, so there&#39;s no way to catch the problem early. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    class SomeClass&#xA;    {&#xA;        public Some&amp;lt;string&amp;gt; SomeValue = &#34;Hello&#34;;&#xA;        public Some&amp;lt;string&amp;gt; SomeOtherValue;&#xA;    }&#xA;    &#xA;    ...&#xA;    &#xA;    public void Greet(Some&amp;lt;string&amp;gt; arg)&#xA;    {&#xA;        Console.WriteLine(arg);&#xA;    }&#xA;    &#xA;    ...&#xA;    &#xA;    public void App()&#xA;    {&#xA;        var obj = new SomeClass();&#xA;        Greet(obj.SomeValue);&#xA;        Greet(obj.SomeOtherValue);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;Greet(obj.SomeOtherValue);&lt;/code&gt; will work until &lt;code&gt;arg&lt;/code&gt; is used inside of the &lt;code&gt;Greet&lt;/code&gt; function, which puts us back into the &lt;code&gt;null&lt;/code&gt; realm. There&#39;s nothing (that I&#39;m aware of) that can be done about this. &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; will throw a useful &lt;code&gt;SomeNotInitialisedException&lt;/code&gt;, which should make life a little easier.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    &#34;Unitialised Some&amp;lt;...&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So what&#39;s the best plan of attack to mitigate this?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Don&#39;t use &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; for class members. That means the class logic might have to deal with &lt;code&gt;null&lt;/code&gt; however.&lt;/li&gt; &#xA; &lt;li&gt;Or, always initialise &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; class members. Mistakes do happen though.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There&#39;s no silver bullet here unfortunately.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: Since writing this library I have come to the opinion that &lt;code&gt;Some&amp;lt;T&amp;gt;&lt;/code&gt; isn&#39;t that useful. It&#39;s much better to protect everything else using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and immutable data structures. It doesn&#39;t fix the argument null checks unfortunately. Perhaps using a contracts library would be better.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/Alternative%20Value%20Monads/index.html&#34;&gt;Some and alternative-value monads reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Lack of lambda and expression inference&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: Since writing this, the csharplang team have improved lamdba inference in C#&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;One really annoying thing about the &lt;code&gt;var&lt;/code&gt; type inference in C# is that it can&#39;t handle inline lambdas. For example this won&#39;t compile, even though it&#39;s obvious it&#39;s a &lt;code&gt;Func&amp;lt;int,int,int&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var add = (int x, int y) =&amp;gt; x + y;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are some good reasons for this, so best not to bitch too much. Instead use the &lt;code&gt;fun&lt;/code&gt; function from this library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var add = fun( (int x, int y) =&amp;gt; x + y );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will work for &lt;code&gt;Func&amp;lt;..&amp;gt;&lt;/code&gt; and &lt;code&gt;Action&amp;lt;..&amp;gt;&lt;/code&gt; types of up to seven generic arguments. &lt;code&gt;Action&amp;lt;..&amp;gt;&lt;/code&gt; will be converted to &lt;code&gt;Func&amp;lt;..,Unit&amp;gt;&lt;/code&gt;. To maintain an &lt;code&gt;Action&lt;/code&gt; use the &lt;code&gt;act&lt;/code&gt; function instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var log = act( (int x) =&amp;gt; Console.WriteLine(x) );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you pass a &lt;code&gt;Func&amp;lt;..&amp;gt;&lt;/code&gt; to &lt;code&gt;act&lt;/code&gt; then its return value will be dropped, so &lt;code&gt;Func&amp;lt;R&amp;gt;&lt;/code&gt; becomes &lt;code&gt;Action&lt;/code&gt;, and &lt;code&gt;Func&amp;lt;T,R&amp;gt;&lt;/code&gt; will become &lt;code&gt;Action&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To do the same for &lt;code&gt;Expression&amp;lt;..&amp;gt;&lt;/code&gt;, use the &lt;code&gt;expr&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var add = expr( (int x, int y) =&amp;gt; x + y );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, if you&#39;re creating a &lt;code&gt;Func&lt;/code&gt; or &lt;code&gt;Action&lt;/code&gt; that take parameters, you must provide the type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Won&#39;t compile&#xA;    var add = fun( (x, y) =&amp;gt; x + y );&#xA;&#xA;    // Will compile&#xA;    var add = fun( (int x, int y) =&amp;gt; x + y );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/Prelude/Lambda%20function%20inference/index.html&#34;&gt;&lt;code&gt;fun&lt;/code&gt;, &lt;code&gt;act&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; and prelude reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Void isn&#39;t a real type&lt;/h2&gt; &#xA;&lt;p&gt;Functional languages have a concept of a type that has one possible value (itself) called &lt;code&gt;Unit&lt;/code&gt;. As an example, &lt;code&gt;bool&lt;/code&gt; has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;Unit&lt;/code&gt; has one possible value, usually represented in functional languages as &lt;code&gt;()&lt;/code&gt;. You can imagine that methods that take no arguments do in fact take one argument of &lt;code&gt;()&lt;/code&gt;. Anyway, we can&#39;t use the &lt;code&gt;()&lt;/code&gt; representation in C#, so &lt;code&gt;LanguageExt&lt;/code&gt; now provides &lt;code&gt;unit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    public Unit Empty()&#xA;    {&#xA;        return unit;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Unit&lt;/code&gt; is the type and &lt;code&gt;unit&lt;/code&gt; is the value. It is used throughout the &lt;code&gt;LanguageExt&lt;/code&gt; library instead of &lt;code&gt;void&lt;/code&gt;. The primary reason is that if you want to program functionally then all functions should return a value and &lt;code&gt;void&lt;/code&gt; is a type with zero possible values - and that&#39;s the type-theory reason why &lt;code&gt;void&lt;/code&gt; is a pain in the arse in C#. This can help a lot with LINQ expressions.&lt;/p&gt; &#xA;&lt;p&gt;Any &lt;code&gt;void&lt;/code&gt; function or its asynchronous equivalent &lt;code&gt;Task&lt;/code&gt; can be converted using &lt;code&gt;fun&lt;/code&gt; and &lt;code&gt;ToUnit&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    public static Func&amp;lt;string, Unit&amp;gt; GetConsoleWrite() =&amp;gt; fun&amp;lt;string&amp;gt;(Console.Write);&#xA;    public static Func&amp;lt;string, Task&amp;lt;Unit&amp;gt;&amp;gt; GetConsoleWriteAsync() =&amp;gt; (string v) =&amp;gt; Console.Out.WriteAsync(v).ToUnit();&#xA;&#xA;    public static Unit WriteToConsole(string v) =&amp;gt; fun(() =&amp;gt; Console.Write(v))();&#xA;    public static Task&amp;lt;Unit&amp;gt; WriteToConsoleAsync(string v) =&amp;gt; Console.Out.WriteAsync(v).ToUnit(); &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/Unit/index.html&#34;&gt;Unit reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Mutable lists and dictionaries&lt;/h2&gt; &#xA;&lt;p&gt;With the new &#34;get only&#34; property syntax with C# 6 it&#39;s now much easier to create immutable types (which everyone should do). However, there&#39;s still going to be a bias towards mutable collections. There&#39;s a great library on NuGet called &#34;Immutable Collections&#34; which sits in the &lt;code&gt;System.Collections.Immutable&lt;/code&gt; namespace. It brings performant immutable lists, dictionaries, etc. to C#. However, this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var list = ImmutableList.Create&amp;lt;string&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;compared to this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var list = new List&amp;lt;string&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is annoying. There&#39;s clearly going to be a bias toward the shorter, easier to type, better known method of creating lists. In functional languages collections are often baked in (because they&#39;re so fundamental), with lightweight and simple syntax for generating and modifying them. So let&#39;s have some of that...&lt;/p&gt; &#xA;&lt;h3&gt;Lists&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;s support for &lt;code&gt;Cons&lt;/code&gt;, which is the functional way of constructing lists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var test = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, empty&amp;lt;int&amp;gt;())))));&#xA;&#xA;    var array = test.ToArray();&#xA;&#xA;    Assert.IsTrue(array[0] == 1);&#xA;    Assert.IsTrue(array[1] == 2);&#xA;    Assert.IsTrue(array[2] == 3);&#xA;    Assert.IsTrue(array[3] == 4);&#xA;    Assert.IsTrue(array[4] == 5);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note, this isn&#39;t the strict definition of &lt;code&gt;Cons&lt;/code&gt;, but it&#39;s a pragmatic implementation that returns an &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, is lazy, and behaves the same. Functional purists, please don&#39;t get too worked up! I have yet to think of a way of implementing a proper type-safe &lt;code&gt;cons&lt;/code&gt; (that can also represent trees, etc.) in C#.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Functional languages usually have a shortcut list constructor syntax that makes the &lt;code&gt;Cons&lt;/code&gt; approach easier. It usually looks something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-F#&#34;&gt;    let list = [1;2;3;4;5]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In C# it looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var array = new int[] { 1, 2, 3, 4, 5 };&#xA;    var list = new List&amp;lt;int&amp;gt; { 1, 2, 3, 4, 5 };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or worse:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var list = new List&amp;lt;int&amp;gt;();&#xA;    list.Add(1);&#xA;    list.Add(2);&#xA;    list.Add(3);&#xA;    list.Add(4);&#xA;    list.Add(5);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So we provide the &lt;code&gt;List&lt;/code&gt; function that takes any number of parameters and turns them into a list:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Creates a list of five items&#xA;     var test = List(1, 2, 3, 4, 5);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is much closer to the &#34;functional way&#34;. It also returns a &lt;code&gt;Lst&amp;lt;T&amp;gt;&lt;/code&gt; which is an immutable list implementation, making it easier to use immutable-lists than mutable ones, and requires significantly less typing.&lt;/p&gt; &#xA;&lt;p&gt;Also &lt;code&gt;Range&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Creates a sequence of 1000 integers lazily (starting at 500).&#xA;    var list = Range(500,1000);&#xA;    &#xA;    // Produces: [0, 10, 20, 30, 40]&#xA;    var list = Range(0,50,10);&#xA;    &#xA;    // Produces: [&#39;a,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]&#xA;    var chars = Range(&#39;a&#39;,&#39;e&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some of the standard set of list functions are available (in &lt;code&gt;LanguageExt.List&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    using static LanguageExt.List;&#xA;    ...&#xA;&#xA;    // Generates 10,20,30,40,50&#xA;    var input = List(1, 2, 3, 4, 5);&#xA;    var output1 = map(input, x =&amp;gt; x * 10);&#xA;&#xA;    // Generates 30,40,50&#xA;    var output2 = filter(output1, x =&amp;gt; x &amp;gt; 20);&#xA;&#xA;    // Generates 120&#xA;    var output3 = fold(output2, 0, (x, s) =&amp;gt; s + x);&#xA;&#xA;    Assert.IsTrue(output3 == 120);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above can be written in a &#34;fluent&#34; style as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var res = List(1, 2, 3, 4, 5)&#xA;                .Map(x =&amp;gt; x * 10)&#xA;                .Filter(x =&amp;gt; x &amp;gt; 20)&#xA;                .Fold(0, (x, s) =&amp;gt; s + x);&#xA;&#xA;    Assert.IsTrue(res == 120);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List pattern matching&lt;/h3&gt; &#xA;&lt;p&gt;Here we implement the standard functional pattern for matching on list elements. In our version you must provide at least 2 handlers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;One for an empty list&lt;/li&gt; &#xA; &lt;li&gt;One for a non-empty list&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However, you can provide up to seven handlers, one for an empty list and six for deconstructing the first six items at the head of the list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    public int Sum(IEnumerable&amp;lt;int&amp;gt; list) =&amp;gt;&#xA;        match( list,&#xA;               ()      =&amp;gt; 0,&#xA;               (x, xs) =&amp;gt; x + Sum(xs) );&#xA;&#xA;    public int Product(IEnumerable&amp;lt;int&amp;gt; list) =&amp;gt;&#xA;        match( list,&#xA;               ()      =&amp;gt; 0,&#xA;               x       =&amp;gt; x,&#xA;               (x, xs) =&amp;gt; x * Product(xs) );&#xA;&#xA;    public void RecursiveMatchSumTest()&#xA;    {&#xA;        var list0 = List&amp;lt;int&amp;gt;();&#xA;        var list1 = List(10);&#xA;        var list5 = List(10,20,30,40,50);&#xA;        &#xA;        Assert.IsTrue(Sum(list0) == 0);&#xA;        Assert.IsTrue(Sum(list1) == 10);&#xA;        Assert.IsTrue(Sum(list5) == 150);&#xA;    }&#xA;&#xA;    public void RecursiveMatchProductTest()&#xA;    {&#xA;        var list0 = List&amp;lt;int&amp;gt;();&#xA;        var list1 = List(10);&#xA;        var list5 = List(10, 20, 30, 40, 50);&#xA;&#xA;        Assert.IsTrue(Product(list0) == 0);&#xA;        Assert.IsTrue(Product(list1) == 10);&#xA;        Assert.IsTrue(Product(list5) == 12000000);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Those patterns should be very familiar to anyone who&#39;s ventured into the functional world. For those that haven&#39;t, the &lt;code&gt;(x,xs)&lt;/code&gt; convention might seem odd. &lt;code&gt;x&lt;/code&gt; is the item at the head of the list - &lt;code&gt;list.First()&lt;/code&gt; in LINQ world. &lt;code&gt;xs&lt;/code&gt; (many X-es) is the tail of the list - &lt;code&gt;list.Skip(1)&lt;/code&gt; in LINQ. This recursive pattern of working on the head of the list until the list runs out is pretty much how loops are done in the functional world.&lt;/p&gt; &#xA;&lt;p&gt;Be wary of recursive processing; C# will happily blow up the stack after a few thousand iterations.&lt;/p&gt; &#xA;&lt;p&gt;Functional programming doesn&#39;t really &lt;em&gt;do&lt;/em&gt; design patterns, but if anything is a design pattern it&#39;s the use of &lt;code&gt;fold&lt;/code&gt;. If you put a bit of thought into it, you will realise that recursive processes all tend to follow a very similar pattern.&lt;/p&gt; &#xA;&lt;p&gt;The two recursive examples above for calculating the sum and product of a sequence of numbers can be written as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Sum&#xA;    var total = fold(list, 0, (s,x) =&amp;gt; s + x);&#xA;    &#xA;    // Product&#xA;    var total = reduce(list, (s,x) =&amp;gt; s * x);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; is &lt;code&gt;fold&lt;/code&gt; but instead of providing an initial state value, it uses the first item in the sequence. Therefore you don&#39;t get an initial multiply by zero (unless the first item is zero!). Internally &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;foldBack&lt;/code&gt;, and &lt;code&gt;reduce&lt;/code&gt; use an iterative loop rather than a recursive one, so no stack blowing problems!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/Immutable%20Collections/index.html&#34;&gt;Immutable collections reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Maps&lt;/h3&gt; &#xA;&lt;p&gt;We also support dictionaries. Again the word &lt;code&gt;Dictionary&lt;/code&gt; is such a pain to type, especially when there&#39;s a perfectly valid alternative used in the functional world: &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To create an immutable map, you no longer have to type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var dict = ImmutableDictionary.Create&amp;lt;string,int&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var dict = Map&amp;lt;string,int&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;code&gt;Map&amp;lt;K,V&amp;gt;&lt;/code&gt; is an implementation of an AVL Tree (self balancing binary tree). This allows us to extend the standard &lt;code&gt;IDictionary&lt;/code&gt; set of functions to include things like &lt;code&gt;findRange&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Also you can pass in a list of tuples or key-value pairs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var people = Map((1, &#34;Rod&#34;),&#xA;                     (2, &#34;Jane&#34;),&#xA;                     (3, &#34;Freddy&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To read an item call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    Option&amp;lt;string&amp;gt; result = find(people, 1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows for branching based on whether the item is in the map or not:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Find the item, do some processing on it and return.&#xA;    var res = match( find(people, 100),&#xA;                     Some: v  =&amp;gt; &#34;Hello &#34; + v,&#xA;                     None: () =&amp;gt; &#34;failed&#34; );&#xA;                   &#xA;    // Find the item and return it. If it&#39;s not there, return &#34;failed&#34;&#xA;    var res = find(people, 100).IfNone(&#34;failed&#34;);                   &#xA;    &#xA;    // Find the item and return it. If it&#39;s not there, return &#34;failed&#34;&#xA;    var res = ifNone( find(people, 100), &#34;failed&#34; );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because checking for the existence of something in a dictionary (&lt;code&gt;find&lt;/code&gt;), and then matching on its result is very common, there is a more convenient &lt;code&gt;match&lt;/code&gt; override:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    // Find the item, do some processing on it and return.&#xA;    var res = match( people, 1,&#xA;                     Some: v  =&amp;gt; &#34;Hello &#34; + v,&#xA;                     None: () =&amp;gt; &#34;failed&#34; );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To set an item call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    var newThings = setItem(people, 1, &#34;Zippy&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Obviously because it&#39;s an immutable structure, calling &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;tryAdd&lt;/code&gt;, &lt;code&gt;addOrUpdate&lt;/code&gt;, &lt;code&gt;addRange&lt;/code&gt;, &lt;code&gt;tryAddRange&lt;/code&gt;, &lt;code&gt;addOrUpdateRange&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;setItem&lt;/code&gt;, &lt;code&gt;trySetItem&lt;/code&gt;, &lt;code&gt;setItems&lt;/code&gt; or &lt;code&gt;trySetItems&lt;/code&gt;... will generate a new &lt;code&gt;Map&amp;lt;K,V&amp;gt;&lt;/code&gt;. It&#39;s quite cunning though, and it only replaces the items that need to be replaced and returns a new map with the new items and shared old items. This massively reduces the memory allocation burden&lt;/p&gt; &#xA;&lt;p&gt;By holding onto a reference to the &lt;code&gt;Map&lt;/code&gt; before and after calling &lt;code&gt;add&lt;/code&gt; you essentially have a perfect timeline history of the changes. Be wary that if what you&#39;re holding in the &lt;code&gt;Map&lt;/code&gt; is &lt;em&gt;mutable&lt;/em&gt; and you change your mutable items, then the old &lt;code&gt;Map&lt;/code&gt; and the new &lt;code&gt;Map&lt;/code&gt; will change, so only store immutable items in a &lt;code&gt;Map&lt;/code&gt; or leave them alone if they&#39;re mutable.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/DataTypes/Immutable%20Collections/index.html&#34;&gt;Immutable collections reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Map transformers&lt;/h3&gt; &#xA;&lt;p&gt;There are additional transformer functions for dealing with &#34;wrapped&#34; maps (i.e. &lt;code&gt;Map&amp;lt;int, Map&amp;lt;int, string&amp;gt;&amp;gt;&lt;/code&gt;). We only cover a limited set of the full set of &lt;code&gt;Map&lt;/code&gt; functions at the moment. You can wrap &lt;code&gt;Map&lt;/code&gt; up to 4 levels deep and still call things like &lt;code&gt;Fold&lt;/code&gt; and &lt;code&gt;Filter&lt;/code&gt;. There&#39;s interesting variants of &lt;code&gt;Filter&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt; called &lt;code&gt;FilterRemoveT&lt;/code&gt; and &lt;code&gt;MapRemoveT&lt;/code&gt;, where if a filter or map operation leaves any keys at any level with an empty &lt;code&gt;Map&lt;/code&gt; then it will auto-remove them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    Map&amp;lt;int,Map&amp;lt;int,Map&amp;lt;int, Map&amp;lt;int, string&amp;gt;&amp;gt;&amp;gt;&amp;gt; wrapped = Map.create&amp;lt;int,Map&amp;lt;int,Map&amp;lt;int,Map&amp;lt;int,string&amp;gt;&amp;gt;();&#xA;    &#xA;    wrapped = wrapped.AddOrUpdate(1,2,3,4,&#34;Paul&#34;);&#xA;    wrapped = wrapped.SetItemT(1,2,3,4,&#34;Louth&#34;);&#xA;    var name = wrapped.Find(1,2,3,4);               // &#34;Louth&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Map&lt;/code&gt; transformer functions:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note, there are only fluent versions of the transformer functions.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Find&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AddOrUpdate&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Remove&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MapRemoveT&lt;/code&gt; - maps each level, checks if the map is empty, in which case it removes it&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MapT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FilterT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;`FilterRemoveT`` - filters each level, checks if the map is empty, in which case it removes it&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Exists&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ForAll&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SetItemT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TrySetItemT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FoldT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;more coming...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Difficulty in creating immutable record types&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s no secret that implementing immutable record types with structural equality, structural ordering, and efficient hashing solutions is a real manual head-ache of implementing &lt;code&gt;Equals&lt;/code&gt;, &lt;code&gt;GetHashCode&lt;/code&gt;, deriving from &lt;code&gt;IEquatable&amp;lt;A&amp;gt;&lt;/code&gt;, &lt;code&gt;IComparer&amp;lt;A&amp;gt;&lt;/code&gt;, and implementing the operators: &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;. It is a constant maintenance headache of making sure they&#39;re kept up to date when new fields are added to the type, with no compilation errors if you forget to do it.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;Record&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This can now be achieved simply by deriving your type from &lt;code&gt;Record&amp;lt;A&amp;gt;&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is the type you want to have structural equality and ordering:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public class TestClass : Record&amp;lt;TestClass&amp;gt;&#xA;    {&#xA;        public readonly int X;&#xA;        public readonly string Y;&#xA;        public readonly Guid Z;&#xA;&#xA;        public TestClass(int x, string y, Guid z)&#xA;        {&#xA;            X = x;&#xA;            Y = y;&#xA;            Z = z;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This gives you &lt;code&gt;Equals&lt;/code&gt;, &lt;code&gt;IEquatable.Equals&lt;/code&gt;, &lt;code&gt;IComparer.CompareTo&lt;/code&gt;, &lt;code&gt;GetHashCode&lt;/code&gt;, &lt;code&gt;operator==&lt;/code&gt;, &lt;code&gt;operator!=&lt;/code&gt;, &lt;code&gt;operator &amp;gt;&lt;/code&gt;, &lt;code&gt;operator &amp;gt;=&lt;/code&gt;, &lt;code&gt;operator &amp;lt;&lt;/code&gt;, and &lt;code&gt;operator &amp;lt;=&lt;/code&gt; implemented by default. It also gives you a default &lt;code&gt;ToString()&lt;/code&gt; implementation and &lt;code&gt;ISerializable.GetObjectData()&lt;/code&gt; with a deserialisation constructor.&lt;/p&gt; &#xA;&lt;p&gt;Note that only &lt;em&gt;fields&lt;/em&gt; or &lt;em&gt;field backed properties&lt;/em&gt; (including auto-properties) are used in the structural comparisons and hash-code building. There are also &lt;code&gt;Attribute&lt;/code&gt;s for opting fields out of the equality testing, ordering comparisons, hash-code generation, stringification (&lt;code&gt;ToString&lt;/code&gt;), and serialisation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Equals()&lt;/code&gt; - &lt;code&gt;NonEq&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CompareTo()&lt;/code&gt; - &lt;code&gt;NonOrd&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GetHashCode()&lt;/code&gt; - &lt;code&gt;NonHash&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ToString()&lt;/code&gt; - &lt;code&gt;NonShow&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Serialization - &lt;code&gt;NonSerializable&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, here&#39;s a record type that opts out of various default behaviours:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public class TestClass2 : Record&amp;lt;TestClass2&amp;gt;&#xA;    {&#xA;        [NonEq]&#xA;        public readonly int X;&#xA;&#xA;        [NonHash]&#xA;        public readonly string Y;&#xA;&#xA;        [NonShow]&#xA;        public readonly Guid Z;&#xA;&#xA;        public TestClass2(int x, string y, Guid z)&#xA;        {&#xA;            X = x;&#xA;            Y = y;&#xA;            Z = z;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want your type to serialise with Json.NET or other serialisers, then you will need to add an extra serialisation constructor that calls the default base implementation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public class TestClass : Record&amp;lt;TestClass&amp;gt;&#xA;    {&#xA;        public readonly int X;&#xA;        public readonly string Y;&#xA;        public readonly Guid Z;&#xA;&#xA;        public TestClass(int x, string y, Guid z)&#xA;        {&#xA;            X = x;&#xA;            Y = y;&#xA;            Z = z;&#xA;        }&#xA;        &#xA;        TestClass(SerializationInfo info, StreamingContext context) &#xA;            : base(info, context) { }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will do full structural equality as the following examples demonstrate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;public class Cons&amp;lt;A&amp;gt; : Record&amp;lt;Cons&amp;lt;A&amp;gt;&amp;gt;&#xA;{&#xA;    public readonly A Head;&#xA;    public readonly Cons&amp;lt;A&amp;gt; Tail;&#xA;&#xA;    public Cons(A head, Cons&amp;lt;A&amp;gt; tail)&#xA;    {&#xA;        Head = head;&#xA;        Tail = tail;&#xA;    }&#xA;}&#xA;&#xA;public void ConsTests()&#xA;{&#xA;    var listA = new Cons&amp;lt;int&amp;gt;(1, new Cons&amp;lt;int&amp;gt;(2, new Cons&amp;lt;int&amp;gt;(3, new Cons&amp;lt;int&amp;gt;(4, null))));&#xA;    var listB = new Cons&amp;lt;int&amp;gt;(1, new Cons&amp;lt;int&amp;gt;(2, new Cons&amp;lt;int&amp;gt;(3, new Cons&amp;lt;int&amp;gt;(4, null))));&#xA;    var listC = new Cons&amp;lt;int&amp;gt;(1, new Cons&amp;lt;int&amp;gt;(2, new Cons&amp;lt;int&amp;gt;(3, null)));&#xA;&#xA;    Assert.True(listA == listB);&#xA;    Assert.True(listB != listC);&#xA;    Assert.True(listA != listC);&#xA;}&#xA;&#xA;public class Tree&amp;lt;A&amp;gt; : Record&amp;lt;Tree&amp;lt;A&amp;gt;&amp;gt;&#xA;{&#xA;    public readonly A Value;&#xA;    public readonly Tree&amp;lt;A&amp;gt; Left;&#xA;    public readonly Tree&amp;lt;A&amp;gt; Right;&#xA;&#xA;    public Tree(A value, Tree&amp;lt;A&amp;gt; left, Tree&amp;lt;A&amp;gt; right)&#xA;    {&#xA;        Value = value;&#xA;        Left = left;&#xA;        Right = right;&#xA;    }&#xA;}&#xA;&#xA;public void TreeTests()&#xA;{&#xA;    var treeA = new Tree&amp;lt;int&amp;gt;(5, new Tree&amp;lt;int&amp;gt;(3, null, null), new Tree&amp;lt;int&amp;gt;(7, null, new Tree&amp;lt;int&amp;gt;(9, null, null)));&#xA;    var treeB = new Tree&amp;lt;int&amp;gt;(5, new Tree&amp;lt;int&amp;gt;(3, null, null), new Tree&amp;lt;int&amp;gt;(7, null, new Tree&amp;lt;int&amp;gt;(9, null, null)));&#xA;    var treeC = new Tree&amp;lt;int&amp;gt;(5, new Tree&amp;lt;int&amp;gt;(3, null, null), new Tree&amp;lt;int&amp;gt;(7, null, null));&#xA;&#xA;    Assert.True(treeA == treeB);&#xA;    Assert.True(treeB != treeC);&#xA;    Assert.True(treeA != treeC);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are some &lt;a href=&#34;https://github.com/louthy/language-ext/raw/master/LanguageExt.Tests/RecordTypesTest.cs&#34;&gt;unit tests&lt;/a&gt; to see this in action.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Inheritance is not supported in &lt;code&gt;Record&lt;/code&gt; derived types, so if you derive a type from a type that derives from &lt;code&gt;Record&lt;/code&gt; then you won&#39;t magically inherit any equality, ordering, hash-code, etc. behaviours. This feature is explicitly here to implement record-like functionality, which do not support inheritance in other functional languages. Equality of origin is explicitly checked for.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;&lt;code&gt;RecordType&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You can also use the &#34;toolkit&#34; that &lt;code&gt;Record&amp;lt;A&amp;gt;&lt;/code&gt; uses to build this functionality in your own bespoke types (perhaps if you want to use this for &lt;code&gt;struct&lt;/code&gt; comparisons or if you can&#39;t derive directly from &lt;code&gt;Record&amp;lt;A&amp;gt;&lt;/code&gt;, or maybe you just want some of the functionality for ad-hoc behaviour):&lt;/p&gt; &#xA;&lt;p&gt;The toolkit is composed of four functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    RecordType&amp;lt;A&amp;gt;.Hash(record);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will provide the hash-code for the record of type &lt;code&gt;A&lt;/code&gt; provided. It can be used for your default &lt;code&gt;GetHashCode()&lt;/code&gt; implementation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    RecordType&amp;lt;A&amp;gt;.Equality(record, obj);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This provides structural equality with the record of type &lt;code&gt;A&lt;/code&gt; and the record of type &lt;code&gt;object&lt;/code&gt;. The types must match for the equality to pass. It can be used for your default &lt;code&gt;Equals(object)&lt;/code&gt; implementation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    RecordType&amp;lt;A&amp;gt;.EqualityTyped(record1, record2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This provides structural equality with the record of type &lt;code&gt;A&lt;/code&gt; and another record of type &lt;code&gt;A&lt;/code&gt;. It can be used for your default &lt;code&gt;Equals(a, b)&lt;/code&gt; method for the &lt;code&gt;IEquatable&amp;lt;A&amp;gt;&lt;/code&gt; implementation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    RecordType&amp;lt;A&amp;gt;.Compare(this, other);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This provides a structural ordering comparison with the record of type &lt;code&gt;A&lt;/code&gt; and another record the record of type &lt;code&gt;A&lt;/code&gt;. It can be used for your default &lt;code&gt;CompareTo(a, b)&lt;/code&gt; method for the &lt;code&gt;IComparable&amp;lt;A&amp;gt;&lt;/code&gt; implementation.&lt;/p&gt; &#xA;&lt;p&gt;Below is the toolkit in use, it&#39;s used to build a &lt;code&gt;struct&lt;/code&gt; type that has structural equality, ordering, and hash-code implementation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public class TestStruct : IEquatable&amp;lt;TestStruct&amp;gt;, IComparable&amp;lt;TestStruct&amp;gt;&#xA;    {&#xA;        public readonly int X;&#xA;        public readonly string Y;&#xA;        public readonly Guid Z;&#xA;&#xA;        public TestStruct(int x, string y, Guid z)&#xA;        {&#xA;            X = x;&#xA;            Y = y;&#xA;            Z = z;&#xA;        }&#xA;&#xA;        public override int GetHashCode() =&amp;gt;&#xA;            RecordType&amp;lt;TestStruct&amp;gt;.Hash(this);&#xA;&#xA;        public override bool Equals(object obj) =&amp;gt;&#xA;            RecordType&amp;lt;TestStruct&amp;gt;.Equality(this, obj);&#xA;&#xA;        public int CompareTo(TestStruct other) =&amp;gt;&#xA;            RecordType&amp;lt;TestStruct&amp;gt;.Compare(this, other);&#xA;&#xA;        public bool Equals(TestStruct other) =&amp;gt;&#xA;            RecordType&amp;lt;TestStruct&amp;gt;.EqualityTyped(this, other);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transformation of immutable types&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re writing functional code you should treat your types as values. Which means they should be immutable. One common way to do this is to use &lt;code&gt;readonly&lt;/code&gt; fields and provide a &lt;code&gt;With&lt;/code&gt; function for mutation. i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;public class A&#xA;{&#xA;    public readonly X X;&#xA;    public readonly Y Y;&#xA;&#xA;    public A(X x, Y y)&#xA;    {&#xA;        X = x;&#xA;        Y = y;&#xA;    }&#xA;&#xA;    public A With(X X = null, Y Y = null) =&amp;gt;&#xA;        new A(&#xA;            X ?? this.X,&#xA;            Y ?? this.Y&#xA;        );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then transformation can be achieved by using the named arguments feature of C# thus:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;val = val.With(X: x);&#xA;&#xA;val = val.With(Y: y);&#xA;&#xA;val = val.With(X: x, Y: y);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;[With]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;It can be quite tedious to write the &lt;code&gt;With&lt;/code&gt; function however. And so, if you include the &lt;code&gt;LanguageExt.CodeGen&lt;/code&gt; nu-get package in your solution you gain the ability to use the &lt;code&gt;[With]&lt;/code&gt; attribtue on a type. This will build the &lt;code&gt;With&lt;/code&gt; method for you.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: The &lt;code&gt;LanguageExt.CodeGen&lt;/code&gt; package and its dependencies will not be included in your final build - it is purely there to generate the code.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You must however:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Make the &lt;code&gt;class&lt;/code&gt; &lt;code&gt;partial&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Have a constructor that takes the fields in the order they are in the type&lt;/li&gt; &#xA; &lt;li&gt;The names of the arguments should be the same as the field, but with the first character lower-case&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;[With]&#xA;public partial class A&#xA;{&#xA;    public readonly X X;&#xA;    public readonly Y Y;&#xA;&#xA;    public A(X x, Y y)&#xA;    {&#xA;        X = x;&#xA;        Y = y;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transformation of nested immutable types with Lenses&lt;/h2&gt; &#xA;&lt;p&gt;One of the problems with immutable types is trying to transform something nested deep in several data structures. This often requires a lot of nested &lt;code&gt;With&lt;/code&gt; methods, which are not very pretty or easy to use.&lt;/p&gt; &#xA;&lt;p&gt;Enter the &lt;code&gt;Lens&amp;lt;A, B&amp;gt;&lt;/code&gt; type.&lt;/p&gt; &#xA;&lt;p&gt;Lenses encapsulate the getter and setter of a field in an immutable data structure and are composable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;[With]&#xA;public partial class Person&#xA;{&#xA;    public readonly string Name;&#xA;    public readonly string Surname;&#xA;&#xA;    public Person(string name, string surname)&#xA;    {&#xA;        Name = name;&#xA;        Surname = surname;&#xA;    }&#xA;&#xA;    public static Lens&amp;lt;Person, string&amp;gt; name =&amp;gt;&#xA;        Lens&amp;lt;Person, string&amp;gt;.New(&#xA;            Get: p =&amp;gt; p.Name,&#xA;            Set: x =&amp;gt; p =&amp;gt; p.With(Name: x));&#xA;&#xA;    public static Lens&amp;lt;Person, string&amp;gt; surname =&amp;gt;&#xA;        Lens&amp;lt;Person, string&amp;gt;.New(&#xA;            Get: p =&amp;gt; p.Surname,&#xA;            Set: x =&amp;gt; p =&amp;gt; p.With(Surname: x));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows direct transformation of the value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var person = new Person(&#34;Joe&#34;, &#34;Bloggs&#34;);&#xA;&#xA;var name = Person.name.Get(person);&#xA;var person2 = Person.name.Set(name + &#34;l&#34;, person);  // Joel Bloggs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be achieved using the &lt;code&gt;Update&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var person = new Person(&#34;Joe&#34;, &#34;Bloggs&#34;);&#xA;&#xA;var person2 = Person.name.Update(name =&amp;gt; name + &#34;l&#34;, person);  // Joel Bloggs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The power of lenses really becomes apparent when using nested immutable types, because lenses can be composed. So, let&#39;s first create a &lt;code&gt;Role&lt;/code&gt; type which will be used with the &lt;code&gt;Person&lt;/code&gt; type to represent an employee&#39;s job title and salary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;[With]&#xA;public partial class Role&#xA;{&#xA;    public readonly string Title;&#xA;    public readonly int Salary;&#xA;&#xA;    public Role(string title, int salary)&#xA;    {&#xA;        Title = title;&#xA;        Salary = salary;&#xA;    }&#xA;&#xA;    public static Lens&amp;lt;Role, string&amp;gt; title =&amp;gt;&#xA;        Lens&amp;lt;Role, string&amp;gt;.New(&#xA;            Get: p =&amp;gt; p.Title,&#xA;            Set: x =&amp;gt; p =&amp;gt; p.With(Title: x));&#xA;&#xA;    public static Lens&amp;lt;Role, int&amp;gt; salary =&amp;gt;&#xA;        Lens&amp;lt;Role, int&amp;gt;.New(&#xA;            Get: p =&amp;gt; p.Salary,&#xA;            Set: x =&amp;gt; p =&amp;gt; p.With(Salary: x));&#xA;}&#xA;&#xA;[With]&#xA;public partial class Person&#xA;{&#xA;    public readonly string Name;&#xA;    public readonly string Surname;&#xA;    public readonly Role Role;&#xA;&#xA;    public Person(string name, string surname, Role role)&#xA;    {&#xA;        Name = name;&#xA;        Surname = surname;&#xA;        Role = role;&#xA;    }&#xA;&#xA;    public static Lens&amp;lt;Person, string&amp;gt; name =&amp;gt;&#xA;        Lens&amp;lt;Person, string&amp;gt;.New(&#xA;            Get: p =&amp;gt; p.Name,&#xA;            Set: x =&amp;gt; p =&amp;gt; p.With(Name: x));&#xA;&#xA;    public static Lens&amp;lt;Person, string&amp;gt; surname =&amp;gt;&#xA;        Lens&amp;lt;Person, string&amp;gt;.New(&#xA;            Get: p =&amp;gt; p.Surname,&#xA;            Set: x =&amp;gt; p =&amp;gt; p.With(Surname: x));&#xA;&#xA;    public static Lens&amp;lt;Person, Role&amp;gt; role =&amp;gt;&#xA;        Lens&amp;lt;Person, Role&amp;gt;.New(&#xA;            Get: p =&amp;gt; p.Role,&#xA;            Set: x =&amp;gt; p =&amp;gt; p.With(Role: x));&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can now compose the lenses within the types to access the nested fields:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var cto = new Person(&#34;Joe&#34;, &#34;Bloggs&#34;, new Role(&#34;CTO&#34;, 150000));&#xA;&#xA;var personSalary = lens(Person.role, Role.salary);&#xA;&#xA;var cto2 = personSalary.Set(170000, cto);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;[WithLens]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Typing the lens fields out every time is even more tedious than writing the &lt;code&gt;With&lt;/code&gt; function, and so there is code generation for that too: using the &lt;code&gt;[WithLens]&lt;/code&gt; attribute. Next, we&#39;ll use some of the built-in lenses in the &lt;code&gt;Map&lt;/code&gt; type to access and mutate a &lt;code&gt;Appt&lt;/code&gt; type within a map:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;[WithLens]&#xA;public partial class Person : Record&amp;lt;Person&amp;gt;&#xA;{&#xA;    public readonly string Name;&#xA;    public readonly string Surname;&#xA;    public readonly Map&amp;lt;int, Appt&amp;gt; Appts;&#xA;&#xA;    public Person(string name, string surname, Map&amp;lt;int, Appt&amp;gt; appts)&#xA;    {&#xA;        Name = name;&#xA;        Surname = surname;&#xA;        Appts = appts;&#xA;    }&#xA;}&#xA;&#xA;[WithLens]&#xA;public partial class Appt : Record&amp;lt;Appt&amp;gt;&#xA;{&#xA;    public readonly int Id;&#xA;    public readonly DateTime StartDate;&#xA;    public readonly ApptState State;&#xA;&#xA;    public Appt(int id, DateTime startDate, ApptState state)&#xA;    {&#xA;        Id = id;&#xA;        StartDate = startDate;&#xA;        State = state;&#xA;    }&#xA;}&#xA;&#xA;public enum ApptState&#xA;{&#xA;    NotArrived,&#xA;    Arrived,&#xA;    DNA,&#xA;    Cancelled&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, here we have a &lt;code&gt;Person&lt;/code&gt; with a map of &lt;code&gt;Appt&lt;/code&gt; types. And we want to update an appointment state to be &lt;code&gt;Arrived&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;// Generate a Person with three Appts in a Map&#xA;var person = new Person(&#34;Paul&#34;, &#34;Louth&#34;, Map(&#xA;    (1, new Appt(1, DateTime.Parse(&#34;1/1/2010&#34;), ApptState.NotArrived)),&#xA;    (2, new Appt(2, DateTime.Parse(&#34;2/1/2010&#34;), ApptState.NotArrived)),&#xA;    (3, new Appt(3, DateTime.Parse(&#34;3/1/2010&#34;), ApptState.NotArrived))));&#xA;&#xA;// Local function for composing a new lens from 3 other lenses&#xA;Lens&amp;lt;Person, ApptState&amp;gt; setState(int id) =&amp;gt; &#xA;    lens(Person.appts, Map&amp;lt;int, Appt&amp;gt;.item(id), Appt.state);&#xA;&#xA;// Transform&#xA;var person2 = setState(2).Set(ApptState.Arrived, person);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice the local-function which takes an ID and uses that with the &lt;code&gt;item&lt;/code&gt; lens in the &lt;code&gt;Map&lt;/code&gt; type to mutate an &lt;code&gt;Appt&lt;/code&gt;. Very powerful stuff.&lt;/p&gt; &#xA;&lt;p&gt;There are a number of useful lenses in the collection types that can do common things like mutate by index, head, tail, last, etc.&lt;/p&gt; &#xA;&lt;h2&gt;The awful &lt;code&gt;out&lt;/code&gt; parameter&lt;/h2&gt; &#xA;&lt;p&gt;This has to be one of the most awful patterns in C#:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    int result;&#xA;    if( Int32.TryParse(value, out result) )&#xA;    {&#xA;        ...&#xA;    }&#xA;    else&#xA;    {&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s all kinds of wrong there. Essentially the function needs to return two pieces of information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Whether the parse was a success or not&lt;/li&gt; &#xA; &lt;li&gt;The successfully parsed value&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a common theme throughout the .NET framework. For example on &lt;code&gt;IDictionary.TryGetValue&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    int value;&#xA;    if( dict.TryGetValue(&#34;thing&#34;, out value) )&#xA;    {&#xA;       ...&#xA;    }&#xA;    else&#xA;    {&#xA;       ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So to solve it we now have methods that instead of returning &lt;code&gt;bool&lt;/code&gt;, return &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. If the operation fails it returns &lt;code&gt;None&lt;/code&gt;. If it succeeds it returns &lt;code&gt;Some(the value)&lt;/code&gt; which can then be matched. Here&#39;s some usage examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;    &#xA;    // Attempts to parse the value, uses 0 if it can&#39;t&#xA;    int res = parseInt(&#34;123&#34;).IfNone(0);&#xA;&#xA;    // Attempts to parse the value, uses 0 if it can&#39;t&#xA;    int res = ifNone(parseInt(&#34;123&#34;), 0);&#xA;&#xA;    // Attempts to parse the value, doubles it if can, returns 0 otherwise&#xA;    int res = parseInt(&#34;123&#34;).Match(&#xA;                  Some: x =&amp;gt; x * 2,&#xA;                 None: () =&amp;gt; 0&#xA;              );&#xA;&#xA;    // Attempts to parse the value, doubles it if can, returns 0 otherwise&#xA;    int res = match( parseInt(&#34;123&#34;),&#xA;                     Some: x =&amp;gt; x * 2,&#xA;                     None: () =&amp;gt; 0 );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;out&lt;/code&gt; method variants&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IDictionary&amp;lt;K, V&amp;gt;.TryGetValue&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IReadOnlyDictionary&amp;lt;K, V&amp;gt;.TryGetValue&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;int.TryParse&lt;/code&gt; becomes &lt;code&gt;parseInt&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;long.TryParse&lt;/code&gt; becomes &lt;code&gt;parseLong&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;short.TryParse&lt;/code&gt; becomes &lt;code&gt;parseShort&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;char.TryParse&lt;/code&gt; becomes &lt;code&gt;parseChar&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbyte.TryParse&lt;/code&gt; becomes &lt;code&gt;parseSByte&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;byte.TryParse&lt;/code&gt; becomes &lt;code&gt;parseByte&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ulong.TryParse&lt;/code&gt; becomes &lt;code&gt;parseULong&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uint.TryParse&lt;/code&gt; becomes &lt;code&gt;parseUInt&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ushort.TryParse&lt;/code&gt; becomes &lt;code&gt;parseUShort&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;float.TryParse&lt;/code&gt; becomes &lt;code&gt;parseFloat&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;double.TryParse&lt;/code&gt; becomes &lt;code&gt;parseDouble&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;decimal.TryParse&lt;/code&gt; becomes &lt;code&gt;parseDecimal&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bool.TryParse&lt;/code&gt; becomes &lt;code&gt;parseBool&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Guid.TryParse&lt;/code&gt; becomes &lt;code&gt;parseGuid&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DateTime.TryParse&lt;/code&gt; becomes &lt;code&gt;parseDateTime&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DateTimeOffset.TryParse&lt;/code&gt; becomes &lt;code&gt;parseDateTimeOffset&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TimeSpan.TryParse&lt;/code&gt; becomes &lt;code&gt;parseTimeSpan&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Enum.TryParse&lt;/code&gt; becomes &lt;code&gt;parseEnum&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;any others you think should be included, please get in touch&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Ad-hoc polymorphism&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;This is where things get a little crazy! This section is taking what&#39;s possible with C# to its limits. None of what follows is essential for 99% of the use cases for this library. However, the seasoned C# programmer will recognise some of the issues raised (like no common numeric base-type); and experienced functional programmers will recognise the category theory creeping in... Just remember, this is all optional, but also pretty powerful if you want to go for it&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Ad-hoc polymorphism has long been believed to not be possible in C#. However with some cunning it is. Ad-hoc polymorphism allows programmers to add traits to a type later. For example in C# it would be amazing if we had an interface called &lt;code&gt;INumeric&lt;/code&gt; for numeric types like &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, etc. The reason this doesn&#39;t exist is if you write a function like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    INumeric Add(INumeric x, INumeric y) =&amp;gt; x + y;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then it would cause boxing. Which is slow (well, slower). I can only assume that&#39;s why it wasn&#39;t added by the BCL team. Anyway, it&#39;s possible to create a numeric type, very much like a type-class in Haskell, and ad-hoc &lt;em&gt;instances&lt;/em&gt; of the numeric &lt;em&gt;type-class&lt;/em&gt; that allow for generic numeric operations without boxing.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;From now on I will call them type-classes and class-instances, or just instances. This is not exactly the same as Haskell&#39;s type-classes. If anything it&#39;s closer to Scala&#39;s implicits. However to make it easier to discuss them I will steal from Haskell&#39;s lexicon.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;Num&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;So for example, this is how to create a number type-class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Num&amp;lt;A&amp;gt;&#xA;    {&#xA;        A Add(A x, A y);&#xA;        A Subtract(A x, A y);&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice how there are two arguments to &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Subtract&lt;/code&gt;. Normally if I was going to implement this &lt;code&gt;interface&lt;/code&gt; the left-hand-side of the &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Subtract&lt;/code&gt; would be &lt;code&gt;this&lt;/code&gt;. I will implement the &lt;em&gt;ad-hoc&lt;/em&gt; class-instance to demonstrate why that is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public struct TInt : Num&amp;lt;int&amp;gt;&#xA;    {&#xA;        public int Add(int x, int y) =&amp;gt; x + y;&#xA;        public int Subtract(int x, int y) =&amp;gt; x - y;&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See how &lt;code&gt;TInt&lt;/code&gt; is a &lt;code&gt;struct&lt;/code&gt;? Structs have a useful property in C# in that they can&#39;t be &lt;code&gt;null&lt;/code&gt;. So we can invoke the operations like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    int r = default(TInt).Add(10, 20);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The important thing to note is that &lt;code&gt;default(TInt)&lt;/code&gt; gets optimisied out in a release build, so there&#39;s no cost to the invocation of &lt;code&gt;Add&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Subtract&lt;/code&gt; methods both take &lt;code&gt;int&lt;/code&gt; and return &lt;code&gt;int&lt;/code&gt;. So therefore there&#39;s no boxing at all.&lt;/p&gt; &#xA;&lt;p&gt;If we now implement &lt;code&gt;TFloat&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public struct TFloat : Num&amp;lt;float&amp;gt;&#xA;    {&#xA;        public float Add(float x, float y) =&amp;gt; x + y;&#xA;        public float Subtract(float x, float y) =&amp;gt; x - y;&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then we can see how a general function could be written to take any numeric type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public A DoubleIt&amp;lt;NumA, A&amp;gt;(A x) where NumA : struct, Num&amp;lt;A&amp;gt; =&amp;gt;&#xA;        default(NumA).Add(x, x);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The important bit is the &lt;code&gt;NumA&lt;/code&gt; generic argument, and the constraint of &lt;code&gt;struct, Num&amp;lt;A&amp;gt;&lt;/code&gt;. That allows us to call &lt;code&gt;default(NumA)&lt;/code&gt; to get the type-class instance and invoke &lt;code&gt;Add&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And so this can now be called by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    int a   = DoubleIt&amp;lt;TInt, int&amp;gt;(5);        // 10&#xA;    float b = DoubleIt&amp;lt;TFloat, float&amp;gt;(5.25); // 10.5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By expanding the amount of operations that the &lt;code&gt;Num&amp;lt;A&amp;gt;&lt;/code&gt; type-class can do, you can perform any numeric operation you like. If you like you can add new numeric types (say for complex numbers, or whatever), where the rules of the type are kept in the &lt;em&gt;ad-hoc&lt;/em&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;Luckily you don&#39;t need to do that, because I have created the &lt;code&gt;Num&amp;lt;A&amp;gt;&lt;/code&gt; type (in the &lt;code&gt;LanguageExt.TypeClasses&lt;/code&gt; namespace), as well as &lt;code&gt;Floating&amp;lt;A&amp;gt;&lt;/code&gt; (with all of the operations from &lt;code&gt;Math&lt;/code&gt;; like &lt;code&gt;Sin&lt;/code&gt;, &lt;code&gt;Cos&lt;/code&gt;, &lt;code&gt;Exp&lt;/code&gt;, etc.). &lt;code&gt;Num&amp;lt;A&amp;gt;&lt;/code&gt; also has a base-type of &lt;code&gt;Arithmetic&amp;lt;A&amp;gt;&lt;/code&gt; which supports &lt;code&gt;Plus&lt;/code&gt;, &lt;code&gt;Subtract&lt;/code&gt;, &lt;code&gt;Product&lt;/code&gt;, &lt;code&gt;Negate&lt;/code&gt;. This is for types which don&#39;t need the full spec of the &lt;code&gt;Num&amp;lt;A&amp;gt;&lt;/code&gt; type. I have also mapped all of the core numeric types to instances: &lt;code&gt;TInt&lt;/code&gt;, &lt;code&gt;TShort&lt;/code&gt;, &lt;code&gt;TLong&lt;/code&gt;, &lt;code&gt;TFloat&lt;/code&gt;, &lt;code&gt;TDouble&lt;/code&gt;, &lt;code&gt;TDecimal&lt;/code&gt;, &lt;code&gt;TBigInt&lt;/code&gt;, etc. So it&#39;s possible to write truly generic numeric code once.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;There&#39;s no getting around the fact that providing the class-instance in the generic arguments list is annoying (and later you&#39;ll see how annoying). The Roslyn team are looking into a type-classes like feature for a future version of C# (variously named: &#39;Concepts&#39; or &#39;Shapes&#39;). So this will I&#39;m sure be rectified, and when it is, it will be implemented exactly as I am using them here.&lt;/p&gt; &#xA; &lt;p&gt;Until then the pain of providing the generic arguments must continue. You do however get a &lt;em&gt;super-powered C#&lt;/em&gt; in the mean-time.&lt;/p&gt; &#xA; &lt;p&gt;The need to write this kind of super-generic code is rare; but when you need it, &lt;em&gt;you need it&lt;/em&gt; - and right now this is simply the most powerful way.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;Eq&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Next up is &lt;code&gt;Eq&amp;lt;A&amp;gt;&lt;/code&gt;. Equality testing in C# is an absolute nightmare. From the different semantics of &lt;code&gt;Equals&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;, to &lt;code&gt;IEqualityComparer&lt;/code&gt;, and the enormous hack which is &lt;code&gt;EqualityComparer.Default&lt;/code&gt; (which doesn&#39;t blow up at compile-time if your code is wrong).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Eq&amp;lt;A&amp;gt;&lt;/code&gt; type-class looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Eq&amp;lt;A&amp;gt;&#xA;    {&#xA;        bool Equals(A x, A y);&#xA;        int GetHashCode(A x);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are &lt;code&gt;Eq&lt;/code&gt; prefixed instances for all common types (&lt;code&gt;EqInt&lt;/code&gt;, &lt;code&gt;EqString&lt;/code&gt;, &lt;code&gt;EqGuid&lt;/code&gt; etc.), as well as for all of the types in this library (&lt;code&gt;EqLst&lt;/code&gt;, &lt;code&gt;EqSet&lt;/code&gt;, &lt;code&gt;EqTry&lt;/code&gt;, etc). All of the numeric types (&lt;code&gt;TInt&lt;/code&gt;, &lt;code&gt;TDouble&lt;/code&gt;, etc.) also implement &lt;code&gt;Eq&amp;lt;A&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To make it slightly prettier to use in code, you can use the &lt;code&gt;Prelude&lt;/code&gt; &lt;code&gt;equals&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    bool x = equals&amp;lt;EqInt&amp;gt;(1, 1); // True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or use &lt;code&gt;default&lt;/code&gt; as shown before:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    bool x = default(EqInt).Equals(1, 1); // True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One final way is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    bool x = EqInt.Inst.Equals(1, 1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Inst&lt;/code&gt; is defined on all of the instances in lang-ext, but it&#39;s not an &#39;official feature&#39;. Anybody could implement an ad-hoc implementation of &lt;code&gt;Eq&amp;lt;A&amp;gt;&lt;/code&gt; and not provide an &lt;code&gt;Inst&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example you may call this directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    bool x = EqLst.Inst.Equals(List(1,2,3), List(1,2,3)); // true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because you may be concerned about calling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    bool x = List(1,2,3) == List(1,2,3); // ?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... as all C# programmers are at some point, because we have no idea most of the time whether &lt;code&gt;==&lt;/code&gt; does what we think it should.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Just FYI &lt;code&gt;List(1,2,3) == List(1,2,3)&lt;/code&gt; does work properly! As do all types in language-ext.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There are two variants of the immutable &lt;code&gt;HashSet&lt;/code&gt; in language-ext:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    HashSet&amp;lt;A&amp;gt;&#xA;    HashSet&amp;lt;EqA, A&amp;gt; where EqA : struct, Eq&amp;lt;A&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What&#39;s interesting about the second one is that the equality &lt;em&gt;definition&lt;/em&gt; is baked into the type. So this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    HashSet&amp;lt;EqString, string&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Is not compatible with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    HashSet&amp;lt;EqStringOrdinalIgnoreCase, string&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And if you think about that, it&#39;s right. The strings that are used as keys in the &lt;code&gt;HashSet&amp;lt;EqString, string&amp;gt;&lt;/code&gt; do not have the same properties as the strings in &lt;code&gt;HashSet&amp;lt;EqStringOrdinalIgnoreCase, string&amp;gt;&lt;/code&gt;. So even though they&#39;re both strings, they have different semantics (which cause wildly different behaviour for things like set intersection, unions, etc.)&lt;/p&gt; &#xA;&lt;p&gt;Now compare that to &lt;code&gt;HashSet&amp;lt;T&amp;gt;&lt;/code&gt; in the BCL, or &lt;code&gt;ImmutableHashSet&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;System.Collections.Immutable&lt;/code&gt;, where two different sets with different &lt;code&gt;IEqualityComparer&lt;/code&gt; types injected will cause undefined results when used together.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;That&#39;s hopefully a small glimpse into the potential for improving type-safeness in C#.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;Ord&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Ord&lt;/code&gt; is for ordering. i.e. a &lt;code&gt;IComparable&lt;/code&gt; replacement. By the way, these names &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Num&lt;/code&gt;, are all lifted from Haskell. I much prefer the short concise names that still convey meaning than the bulky and often clumsy names of the BCL.&lt;/p&gt; &#xA;&lt;p&gt;This is &lt;code&gt;Ord&amp;lt;A&amp;gt;&lt;/code&gt;, it derives from &lt;code&gt;Eq&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Ord&amp;lt;A&amp;gt; : Eq&amp;lt;A&amp;gt;&#xA;    {&#xA;        int Compare(A x, A y);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Usage should be self-explanatory now, but the important thing to note here is that because &#39;type classes&#39; are just interfaces, they can also have an inheritance hierarchy.&lt;/p&gt; &#xA;&lt;p&gt;This is a slightly more complex example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public struct OrdArray&amp;lt;ORD, A&amp;gt; : Ord&amp;lt;A[]&amp;gt;&#xA;        where ORD : struct, Ord&amp;lt;A&amp;gt;&#xA;    {&#xA;        public int Compare(A[] mx, A[] my)&#xA;        {&#xA;            if (ReferenceEquals(mx, my)) return 0;&#xA;            if (ReferenceEquals(mx, null)) return -1;&#xA;            if (ReferenceEquals(my, null)) return 1;&#xA;&#xA;            var cmp = mx.Length.CompareTo(my.Length);&#xA;            if (cmp == 0)&#xA;            {&#xA;                for(var i = 0; i &amp;lt; mx.Length; i++)&#xA;                {&#xA;                    cmp = default(ORD).Compare(mx[i], my[i]);&#xA;                    if (cmp != 0) return cmp;&#xA;                }&#xA;                return 0;&#xA;            }&#xA;            else&#xA;            {&#xA;                return cmp;&#xA;            }&#xA;        }&#xA;&#xA;        public bool Equals(A[] x, A[] y) =&amp;gt;&#xA;            default(EqArray&amp;lt;ORD, A&amp;gt;).Equals(x, y);&#xA;&#xA;        public int GetHashCode(A[] x) =&amp;gt;&#xA;            hash(x);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;OrdArray&lt;/code&gt; which is an &lt;code&gt;Ord&amp;lt;A[]&amp;gt;&lt;/code&gt;, does itself also take an &lt;code&gt;ORD&lt;/code&gt; generic argument, which allows the contents of the array to be compared:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    int x = OrdArray&amp;lt;TInt, int&amp;gt;.Inst.Compare(new [] {1,2}, new [] {1,2}); // 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Semigroup&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;This is where we start going a little more abstract. Semigroups are a feature of category theory, which is soooo not important for this discussion. They represent an associative binary operation, which can be invoked by calling &lt;code&gt;Append&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Semigroup&amp;lt;A&amp;gt;&#xA;    {&#xA;        A Append(A x, A y);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Positive numbers (for example) form a semigroup. I won&#39;t dwell on it too long, because although the &lt;code&gt;Append&lt;/code&gt; function is super-useful, nearly everything that falls into the &lt;code&gt;Semigroup&lt;/code&gt; category is also a &lt;code&gt;Monoid&lt;/code&gt;...&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Monoid&amp;lt;A&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;A monoid has something that a semigroup doesn&#39;t, and that&#39;s the concept of identity (often meaning &#39;empty&#39; or &#39;zero&#39;). It looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Monoid&amp;lt;A&amp;gt; : Semigroup&amp;lt;A&amp;gt;&#xA;    {&#xA;        A Empty();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This comes with some helper functions in &lt;code&gt;LanguageExt.TypeClass&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public static partial class TypeClass&#xA;    {&#xA;        public static A mempty&amp;lt;MONOID, A&amp;gt;() where MONOID : struct, Monoid&amp;lt;A&amp;gt; =&amp;gt;&#xA;            default(MONOID).Empty();&#xA;&#xA;        public static A mconcat&amp;lt;MONOID, A&amp;gt;(IEnumerable&amp;lt;A&amp;gt; xs) where MONOID : struct, Monoid&amp;lt;A&amp;gt; =&amp;gt;&#xA;            xs.Fold(mempty&amp;lt;MONOID, A&amp;gt;(), (s, x) =&amp;gt; append&amp;lt;MONOID, A&amp;gt;(s, x));&#xA;&#xA;        public static A mconcat&amp;lt;MONOID, A&amp;gt;(params A[] xs) where MONOID : struct, Monoid&amp;lt;A&amp;gt; =&amp;gt;&#xA;            xs.Fold(mempty&amp;lt;MONOID, A&amp;gt;(), (s, x) =&amp;gt; append&amp;lt;MONOID, A&amp;gt;(s, x));&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the semigroup &lt;code&gt;Append&lt;/code&gt; comes to life. Examples of monoids are: &lt;code&gt;TInt&lt;/code&gt;, &lt;code&gt;MLst&lt;/code&gt;, &lt;code&gt;TString&lt;/code&gt;, etc. i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    var x = mconcat&amp;lt;TString, string&amp;gt;(&#34;Hello&#34;, &#34; &#34;, &#34;World&#34;);   // &#34;Hello World&#34;&#xA;    var y = mconcat&amp;lt;TLst&amp;lt;int&amp;gt;, Lst&amp;lt;int&amp;gt;&amp;gt;(List(1), List(2, 3)); // [1,2,3]&#xA;    var z = mconcat&amp;lt;TInt, int&amp;gt;(1, 2, 3, 4, 5);                 // 15&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Empty()&lt;/code&gt; function is what provides the &lt;em&gt;identity value&lt;/em&gt; for the concat operations. So for &lt;code&gt;string&lt;/code&gt; it&#39;s &lt;code&gt;&#34;&#34;&lt;/code&gt;, for &lt;code&gt;Lst&amp;lt;T&amp;gt;&lt;/code&gt; it&#39;s &lt;code&gt;[]&lt;/code&gt; and for &lt;code&gt;int&lt;/code&gt; it&#39;s &lt;code&gt;0&lt;/code&gt;. So a monoid is a semigroup with a &lt;em&gt;zero&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s surprising how much &lt;em&gt;stuff&lt;/em&gt; just starts working when you know your type is a monoid. For example in language-ext version 1 there is a monadic type called &lt;code&gt;Writer&amp;lt;W, T&amp;gt;&lt;/code&gt;. The writer monad collects a &lt;em&gt;log&lt;/em&gt; as well as returning the bound value. In version 1 the log had to be an &lt;code&gt;IEnumerable&amp;lt;W&amp;gt;&lt;/code&gt;, which isn&#39;t super flexible. In language-ext version 2 the type looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public class Writer&amp;lt;MonoidW, W, A&amp;gt; where MonoidW : struct, Monoid&amp;lt;W&amp;gt;&#xA;    {&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So now it can be a running numeric total, or a &lt;code&gt;Lst&amp;lt;W&amp;gt;&lt;/code&gt;, or a &lt;code&gt;Set&amp;lt;W&amp;gt;&lt;/code&gt;, or whatever monoid &lt;em&gt;you&lt;/em&gt; dream up.&lt;/p&gt; &#xA;&lt;h3&gt;Higher-kinds&lt;/h3&gt; &#xA;&lt;p&gt;Higher-order polymorphism would allow us to define a type like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface MyType&amp;lt;M&amp;lt;A&amp;gt;&amp;gt;&#xA;    {&#xA;        M&amp;lt;B&amp;gt; Foo&amp;lt;B&amp;gt;(M&amp;lt;A&amp;gt; ma);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where not only is the &lt;code&gt;A&lt;/code&gt; parametric, but so it &lt;code&gt;M&lt;/code&gt;. So for example if I wanted to implement &lt;code&gt;MyType&lt;/code&gt; for &lt;code&gt;Option&amp;lt;A&amp;gt;&lt;/code&gt; I could do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public class MyOptionType&amp;lt;A&amp;gt; : MyType&amp;lt;Option&amp;lt;A&amp;gt;&amp;gt;&#xA;    {&#xA;        public Option&amp;lt;B&amp;gt; Foo&amp;lt;B&amp;gt;(Option&amp;lt;A&amp;gt; ma) =&amp;gt; ...;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It would be soooo nice if C# (well, the &lt;em&gt;immutable&lt;/em&gt; CLR) would support this. But it doesn&#39;t. So we need to find ways around it. The way I am using for language-ext is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface MyType&amp;lt;MA, A&amp;gt;&#xA;    {&#xA;        MB Foo&amp;lt;MB, B&amp;gt;(MA ma);&#xA;    }&#xA;&#xA;    public class MyOptionType&amp;lt;A&amp;gt; : MyType&amp;lt;Option&amp;lt;A&amp;gt;, A&amp;gt;&#xA;    {&#xA;        public MB Foo&amp;lt;MB, B&amp;gt;(Option&amp;lt;A&amp;gt; ma) =&amp;gt; ...;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Monad&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;This is where some of the difficulties come in. How do we return an &lt;code&gt;MB&lt;/code&gt; if we don&#39;t know what it is? This is a problem for the &lt;code&gt;Monad&lt;/code&gt; type. This is a simplified version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Monad&amp;lt;MA, A&amp;gt;&#xA;    {&#xA;        MB Bind&amp;lt;MB, B&amp;gt;(MA ma, Func&amp;lt;A, MB&amp;gt; bind);&#xA;        MA Return(A a);&#xA;        MA Fail(Exception e = null);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Looking at the prototype for &lt;code&gt;Bind&lt;/code&gt; it seems at first glance that the &lt;code&gt;bind&lt;/code&gt; argument will give us the &lt;code&gt;MB&lt;/code&gt; value we want. But an &lt;code&gt;Option&lt;/code&gt; might be in a &lt;code&gt;None&lt;/code&gt; state, in which case it shouldn&#39;t run &lt;code&gt;bind&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public MB Bind&amp;lt;MB, B&amp;gt;(Option&amp;lt;A&amp;gt; ma, Func&amp;lt;A, MB&amp;gt; bind) =&amp;gt;&#xA;        ma.IsSome&#xA;            ? bind(ma.Value)&#xA;            : ??? ; // What do we return here?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The key is to use constraints. But it also requires an extra generic parameter for &lt;code&gt;Bind&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Monad&amp;lt;MA, A&amp;gt;&#xA;    {&#xA;        MB Bind&amp;lt;MonadB, MB, B&amp;gt;(MA ma, Func&amp;lt;A, MB&amp;gt; bind) &#xA;            where MonadB : struct, Monad&amp;lt;MB, B&amp;gt;;&#xA;&#xA;        MA Return(A a);&#xA;        MA Fail(Exception e = null);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So we now know that &lt;code&gt;MonadB&lt;/code&gt; is a class-instance of the &lt;code&gt;Monad&amp;lt;MB, B&amp;gt;&lt;/code&gt; type-class. So we can now do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public MB Bind&amp;lt;MonadB, MB, B&amp;gt;(Option&amp;lt;A&amp;gt; ma, Func&amp;lt;A, MB&amp;gt; f) &#xA;        where MonadB : struct, Monad&amp;lt;MB, B&amp;gt; =&amp;gt;&#xA;            ma.IsSome&#xA;                ? f(ma.Value)&#xA;                : default(MonadB).Fail();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The eagle eyed reader will notice that this actually allows binding to any resulting monad (not just &lt;code&gt;Option&amp;lt;B&amp;gt;&lt;/code&gt;). I&#39;m sure some may consider labelling this a monad as incorrect, but it works, it&#39;s type-safe, it&#39;s efficient, and performs the exact same function and so I am happy to use the term.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/TypeClasses/Monad/index.html&#34;&gt;The actual definition of &lt;code&gt;Monad&lt;/code&gt;&lt;/a&gt; is more complex than this, in order to unify monadic types that take arguments (&lt;code&gt;Reader&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;) and monads that carry internal state (&lt;code&gt;Writer&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;), as well as to support asynchronous monads (&lt;code&gt;TryAsync&lt;/code&gt; and &lt;code&gt;TryOption&lt;/code&gt;). I won&#39;t muddy the waters too much right now, but unified and type-safe they are. There are no hacks.&lt;/p&gt; &#xA;&lt;p&gt;You should see that the &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Fail&lt;/code&gt; functions are trivial to implement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public Option&amp;lt;A&amp;gt; Return(A a) =&amp;gt;&#xA;        Optional(a);&#xA;&#xA;    public Option&amp;lt;A&amp;gt; Fail(Exception e = null) =&amp;gt;&#xA;        None;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What that means is that any function that has been constrained by a monad instance can create new instances of them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public M CreateNewIntegerMonad&amp;lt;MonadInt, M, int&amp;gt;(int x) &#xA;        where MonadInt : struct, Monad&amp;lt;M, int&amp;gt; =&amp;gt;&#xA;            default(MonadInt).Return(x);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is one of the key breakthroughs. Imagine trying to create a &lt;code&gt;Monad&lt;/code&gt; type the &lt;em&gt;old way&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public interface Monad&amp;lt;A&amp;gt;&#xA;    {&#xA;        Monad&amp;lt;B&amp;gt; Bind&amp;lt;B&amp;gt;(Func&amp;lt;A, Monad&amp;lt;B&amp;gt;&amp;gt; bind);&#xA;    }&#xA;&#xA;    public class Option&amp;lt;A&amp;gt; : Monad&amp;lt;A&amp;gt;&#xA;    {&#xA;        public Monad&amp;lt;B&amp;gt; Bind&amp;lt;B&amp;gt;(Monad&amp;lt;A&amp;gt; ma, Func&amp;lt;A, Monad&amp;lt;B&amp;gt;&amp;gt; bind) =&amp;gt;&#xA;            IsSome&#xA;                ? bind(Value)&#xA;                : None;&#xA;    }&#xA;&#xA;    public Monad&amp;lt;int&amp;gt; CreateNewIntegerMonad(int x) =&amp;gt;&#xA;        ????; // How?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Maybe we could parameterise it?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public Monad&amp;lt;int&amp;gt; CreateNewIntegerMonad&amp;lt;M&amp;gt;(int x) where M : Monad&amp;lt;int&amp;gt; =&amp;gt;&#xA;        ????; // We still can&#39;t call new M(x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But that doesn&#39;t work either because we still can&#39;t call &lt;code&gt;new M(x)&lt;/code&gt;. Being able to paramterise generic functions at the point where you know the concrete types (and therefore know the concrete class-instance) means that the generic functions can invoke the instance functions to create the concrete types.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a super generic example of a function that takes two monad arguments, they&#39;re both of the same type, and their bound values are &lt;code&gt;Num&amp;lt;A&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    public static MA Add&amp;lt;MonadA, MA, NumA, A&amp;gt;(MA ma, MA mb)&#xA;        where MonadA  : struct, Monad&amp;lt;MA, A&amp;gt;&#xA;        where NumA    : struct, Num&amp;lt;A&amp;gt; =&amp;gt;&#xA;            default(MonadA).Bind&amp;lt;MonadA, MA, A&amp;gt;(ma, a =&amp;gt;&#xA;            default(MonadA).Bind&amp;lt;MonadA, MA, A&amp;gt;(mb, b =&amp;gt;&#xA;            default(MonadA).Return(default(NumA).Plus(a, b))));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may notice that the two &lt;code&gt;Bind&lt;/code&gt; calls followed by the &lt;code&gt;Return&lt;/code&gt; are basically a much less attractive version of this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;        from a in ma&#xA;        from b in mb&#xA;        select default(NumA).Plus(a, b);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And so I can now add two options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    var x = Some(10);&#xA;    var y = Some(20);&#xA;    var z = Option&amp;lt;int&amp;gt;.None;&#xA;&#xA;    var r1 = Add&amp;lt;MOption&amp;lt;int&amp;gt;, Option&amp;lt;int&amp;gt;, TInt, int&amp;gt;(x, y); // Some(30)&#xA;    var r2 = Add&amp;lt;MOption&amp;lt;int&amp;gt;, Option&amp;lt;int&amp;gt;, TInt, int&amp;gt;(x, z); // None&#xA;&#xA;    Assert.True(r1 == Some(30));&#xA;    Assert.True(r2 == None);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or two lists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    var x = List(1, 2, 3);&#xA;    var y = List(4, 5, 6);&#xA;    var z = List&amp;lt;int&amp;gt;();&#xA;&#xA;    var r1 = Add&amp;lt;MLst&amp;lt;int&amp;gt;, Lst&amp;lt;int&amp;gt;, TInt, int&amp;gt;(x, y);&#xA;    var r2 = Add&amp;lt;MLst&amp;lt;int&amp;gt;, Lst&amp;lt;int&amp;gt;, TInt, int&amp;gt;(x, z);&#xA;&#xA;    Assert.True(r1 == List(5, 6, 7,  6, 7, 8,  7, 8, 9));&#xA;    Assert.True(r2 == z);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or any two monads. They will follow the built in rules for the type, and produce concrete values efficiently and without any boxing or dynamic casting.&lt;/p&gt; &#xA;&lt;h3&gt;Transformer types&lt;/h3&gt; &#xA;&lt;p&gt;Often you&#39;ll find yourself with nested monadic types &lt;code&gt;Option&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Seq&amp;lt;Either&amp;lt;L, R&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Try&amp;lt;Validation&amp;lt;Fail, Success&amp;gt;&amp;gt;&lt;/code&gt;, ..., and you want to work with the bound value(s) of &lt;code&gt;A&lt;/code&gt; without having to unwrap/match the values away. And so there are around 100,000 lines of generated code for working with &#39;transformer types&#39;.&lt;/p&gt; &#xA;&lt;p&gt;There is a new &lt;a href=&#34;https://louthy.github.io/language-ext/LanguageExt.Core/TypeClasses/MonadTrans/index.html&#34;&gt;&lt;code&gt;MonadTrans&lt;/code&gt;&lt;/a&gt;. It does all the heavy lifting, and it is what the generated code uses (it&#39;s also what you&#39;d need to use if you create your own monadic types and you want to build transformers for the various pairs of monadic types).&lt;/p&gt; &#xA;&lt;p&gt;For every pair of nested monads: &lt;code&gt;Lst&amp;lt;Option&amp;lt;A&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Try&amp;lt;Either&amp;lt;L, A&amp;gt;&amp;gt;&lt;/code&gt;, etc. there are the following extension methods (this is for &lt;code&gt;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt;&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#xA;// Sums all the bound value(s)&#xA;A SumT&amp;lt;NumA, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma);&#xA;&#xA;// Counts all the bound value(s)&#xA;int CountT&amp;lt;A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma);&#xA;&#xA;// Monadic bind on the inner monad&#xA;Arr&amp;lt;Lst&amp;lt;B&amp;gt;&amp;gt; BindT&amp;lt;A, B&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, Lst&amp;lt;B&amp;gt;&amp;gt; f);&#xA;&#xA;// Flips the inner and outer monads (using the rules of the inner and outer &#xA;// monads to compose the result) and performs a map operation on the bound values&#xA;Lst&amp;lt;Arr&amp;lt;B&amp;gt;&amp;gt; Traverse&amp;lt;A, B&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, B&amp;gt; f);&#xA;&#xA;// Flips the inner and outer monads (using the rules of the inner and outer &#xA;// monads to compose the result) &#xA;Lst&amp;lt;Arr&amp;lt;A&amp;gt;&amp;gt; Sequence&amp;lt;A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma);&#xA;&#xA;// Maps the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;B&amp;gt;&amp;gt; MapT&amp;lt;A, B&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, B&amp;gt; f);&#xA;&#xA;// Folds the bound value(s)&#xA;S FoldT&amp;lt;S, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, S state, Func&amp;lt;S, A, S&amp;gt; f);&#xA;&#xA;// Reverse folds the bound value(s)&#xA;S FoldBackT&amp;lt;S, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, S state, Func&amp;lt;S, A, S&amp;gt; f);&#xA;&#xA;// Returns true if f(x) returns true for any of the bound value(s)&#xA;bool ExistsT&amp;lt;A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, bool&amp;gt; f);&#xA;&#xA;// Returns true if f(x) returns true for all of the bound value(s)&#xA;bool ForAllT&amp;lt;A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, bool&amp;gt; f);&#xA;&#xA;// Iterates all of the bound values&#xA;Unit IterT&amp;lt;A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Action&amp;lt;A&amp;gt; f);&#xA;&#xA;// Filters the bound value(s) with the predicate&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; FilterT&amp;lt; A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, bool&amp;gt; pred);&#xA;&#xA;// Filters the bound value(s) with the predicate&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; Where&amp;lt;A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, bool&amp;gt; pred);&#xA;&#xA;// Maps the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; Select&amp;lt;A, B&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma, Func&amp;lt;A, B&amp;gt; f);&#xA;&#xA;// LINQ monadic bind and project on the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;C&amp;gt;&amp;gt; SelectMany&amp;lt;A, B, C&amp;gt;(&#xA;        this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ma,&#xA;        Func&amp;lt;A, Lst&amp;lt;B&amp;gt;&amp;gt; bind,&#xA;        Func&amp;lt;A, B, C&amp;gt; project);&#xA;&#xA;// Plus operation on the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; PlusT&amp;lt;NUM, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; x, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; y) where NUM : struct, Num&amp;lt;A&amp;gt;;&#xA;&#xA;// Subtraction operation on the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; SubtractT&amp;lt;NUM, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; x, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; y) where NUM : struct, Num&amp;lt;A&amp;gt;;&#xA;&#xA;// Product operation on the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ProductT&amp;lt;NUM, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; x, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; y) where NUM : struct, Num&amp;lt;A&amp;gt; =&amp;gt;&#xA;        ApplyT(default(NUM).Product, x, y);&#xA;&#xA;// Divide operation on the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; DivideT&amp;lt;NUM, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; x, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; y) where NUM : struct, Num&amp;lt;A&amp;gt;;&#xA;&#xA;// Semigroup append operation on the bound value(s)&#xA;AppendT&amp;lt;SEMI, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; x, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; y) where SEMI : struct, Semigroup&amp;lt;A&amp;gt;;&#xA;&#xA;// Comparison operation on the bound value(s)&#xA;int CompareT&amp;lt;ORD, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; x, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; y) where ORD : struct, Ord&amp;lt;A&amp;gt;;&#xA;&#xA;// Equality operation on the bound value(s)&#xA;bool EqualsT&amp;lt;EQ, A&amp;gt;(this Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; x, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; y) where EQ : struct, Eq&amp;lt;A&amp;gt;;&#xA;&#xA;// Applicative apply operation on the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; ApplyT&amp;lt;A, B&amp;gt;(this Func&amp;lt;A, B&amp;gt; fab, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; fa);&#xA;&#xA;// Application apply operation on the bound value(s)&#xA;Arr&amp;lt;Lst&amp;lt;C&amp;gt;&amp;gt; ApplyT&amp;lt;A, B, C&amp;gt;(this Func&amp;lt;A, B, C&amp;gt; fabc, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; fa, Arr&amp;lt;Lst&amp;lt;A&amp;gt;&amp;gt; fb);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The number of functions has increased dramatically. Some of the special ones are &lt;code&gt;Traverse&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; which flips the inner and outer types. So for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Lst&amp;lt;Option&amp;lt;int&amp;gt;&amp;gt; x = List(Some(1), Some(2), Some(3), Some(4), Some(5));&#xA;    Option&amp;lt;Lst&amp;lt;int&amp;gt;&amp;gt; y = x.Sequence();&#xA;&#xA;    Assert.True(y == Some(List(1, 2, 3, 4, 5)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the list is now inside the option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Lst&amp;lt;Option&amp;lt;int&amp;gt;&amp;gt; x = List(Some(1), Some(2), Some(3), None, Some(5));&#xA;    Option&amp;lt;Lst&amp;lt;int&amp;gt;&amp;gt; y = x.Sequence();&#xA;&#xA;    Assert.True(y == None);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case there is a &lt;code&gt;None&lt;/code&gt; in the &lt;code&gt;Lst&lt;/code&gt; so when the &lt;code&gt;Lst&amp;lt;Option&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; becomes a &lt;code&gt;Option&amp;lt;Lst&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; the rules of the &lt;code&gt;Option&lt;/code&gt; take over, and one &lt;code&gt;None&lt;/code&gt; means all &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This can be quite useful for &lt;code&gt;Either&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    var x = List&amp;lt;Either&amp;lt;string, int&amp;gt;&amp;gt;(1, 2, 3, 4, &#34;error&#34;);&#xA;&#xA;    var y = x.Sequence();&#xA;&#xA;    Assert.True(y.IsLeft &amp;amp;&amp;amp; y == &#34;error&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This collects the first error it finds, or returns &lt;code&gt;Right&lt;/code&gt; if there is no error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Traverse&lt;/code&gt; is the same as &lt;code&gt;Sequence&lt;/code&gt; except it applies a mapping function to each bound value as it&#39;s transforming the types. Here&#39;s an example that runs 6 tasks in parallel, and collects their results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    var start = DateTime.UtcNow;&#xA;&#xA;    var f1 = Task.Run(() =&amp;gt; { Thread.Sleep(3000); return 1; });&#xA;    var f2 = Task.Run(() =&amp;gt; { Thread.Sleep(3000); return 2; });&#xA;    var f3 = Task.Run(() =&amp;gt; { Thread.Sleep(3000); return 3; });&#xA;    var f4 = Task.Run(() =&amp;gt; { Thread.Sleep(3000); return 4; });&#xA;    var f5 = Task.Run(() =&amp;gt; { Thread.Sleep(3000); return 5; });&#xA;    var f6 = Task.Run(() =&amp;gt; { Thread.Sleep(3000); return 6; });&#xA;&#xA;    var res = await List(f1, f2, f3, f4, f5, f6).Traverse(x =&amp;gt; x * 2);&#xA;&#xA;    Assert.True(toSet(res) == Set(2, 4, 6, 8, 10, 12));&#xA;&#xA;    var ms = (int)(DateTime.UtcNow - start).TotalMilliseconds;&#xA;    Assert.True(ms &amp;lt; 3500, $&#34;Took {ms} ticks&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So there is a List of Tasks that becomes a single awaitable Task of List.&lt;/p&gt; &#xA;&lt;p&gt;As well as the extensions, there are also static classes for the transformer types. There is one for each type of monad. So for example, &lt;code&gt;Option&lt;/code&gt; has a &lt;code&gt;LanguageExt.OptionT&lt;/code&gt; type. Whenever you have a pair of nested monads, and &lt;code&gt;Option&lt;/code&gt; is the inner monad, then you would use &lt;code&gt;OptionT&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    var ma = List(Some(1),Some(2),Some(3),Some(4),Some(5));&#xA;&#xA;    var total = OptionT.foldT(ma, 0, (s, x) =&amp;gt; s + x); // 15&#xA;    var total = OptionT.sumT&amp;lt;TInt, int&amp;gt;(ma); // 15&#xA;    var mb    = OptionT.filterT(ma, x &amp;gt; 3); // List(Some(3), Some(4))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing &amp;amp; Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;If you would like to get involved with this project, please first read the &lt;a href=&#34;https://github.com/louthy/language-ext/raw/master/CONTRIBUTING.md&#34;&gt;Contribution Guidelines&lt;/a&gt; and the &lt;a href=&#34;https://github.com/louthy/language-ext/raw/master/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>keijiro/Bibcam</title>
    <updated>2022-06-06T01:39:41Z</updated>
    <id>tag:github.com,2022-06-06:/keijiro/Bibcam</id>
    <link href="https://github.com/keijiro/Bibcam" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Burnt-in barcode metadata camera&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Bibcam - Burnt-in barcode metadata camera&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/343936/142789278-4ede7318-e789-4d32-ad99-06ff90e91b20.gif&#34; alt=&#34;gif&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/343936/142789286-f7ba3b96-c176-4687-aa58-170f2e166855.gif&#34; alt=&#34;gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bibcam&lt;/strong&gt; is a proof-of-concept project where I tried the idea of &#34;burnt-in barcode metadata&#34; carrying camera tracking data within a single video stream.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/343936/142789292-9bba9330-0fa0-49f8-b270-9bcefe326278.png&#34; alt=&#34;Planes&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;By using this format, you can record/edit/playback AR-ready video clips without worrying about desynchronization with external tracking data.&lt;/p&gt; &#xA;&lt;h2&gt;System Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unity 2021 LTS&lt;/li&gt; &#xA; &lt;li&gt;LiDAR-enabled iOS device for recording&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to Try&lt;/h2&gt; &#xA;&lt;p&gt;Build and play the &lt;code&gt;Encoder&lt;/code&gt; scene on a LiDAR-enabled iOS device. You can record Bibcam video clips by pressing the &#34;Record&#34; button. It saves recorded clips into the camera roll.&lt;/p&gt; &#xA;&lt;p&gt;To try playback with the recorded clips, copy them into the project directory (the directory that contains &lt;code&gt;Assets&lt;/code&gt;, &lt;code&gt;Packages&lt;/code&gt;, etc.) and rename it to &lt;code&gt;Test.mp4&lt;/code&gt;. Then you can play it back with the &lt;code&gt;Decoder&lt;/code&gt; scene.&lt;/p&gt; &#xA;&lt;h2&gt;Tips&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The encoder application caps the frame rate at 30fps to reduce excessive energy consumption and thermal throttling. You can switch this behavior in the application settings (Settings -&amp;gt; Bibcam -&amp;gt; &#34;Cap Frame Rate&#34;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related Repositories&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/keijiro/BibcamVfx&#34;&gt;BibcamVfx&lt;/a&gt; -- Advanced Bibcam VFX with HDRP&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/keijiro/BibcamUrp&#34;&gt;BibcamUrp&lt;/a&gt; -- Bibcam renderer on URP&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/keijiro/BibcamTimeline&#34;&gt;BibcamTimeline&lt;/a&gt; -- Bibcam frame-accurate playback with Timeline&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>