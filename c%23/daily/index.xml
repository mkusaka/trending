<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-14T01:35:35Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>richardszalay/mockhttp</title>
    <updated>2022-07-14T01:35:35Z</updated>
    <id>tag:github.com,2022-07-14:/richardszalay/mockhttp</id>
    <link href="https://github.com/richardszalay/mockhttp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Testing layer for Microsoft&#39;s HttpClient library. Create canned responses using a fluent API.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/RichardSzalay.MockHttp/&#34;&gt;&lt;img src=&#34;http://img.shields.io/nuget/v/RichardSzalay.MockHttp.svg?style=flat-square&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.nuget.org/packages/RichardSzalay.MockHttp/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/RichardSzalay.MockHttp.svg?style=flat-square&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ci.appveyor.com/project/richardszalay/mockhttp&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/3in8hmcyg11wpcjw/branch/master?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;MockHttp for HttpClient&lt;/h1&gt; &#xA;&lt;p&gt;MockHttp is a testing layer for Microsoft&#39;s HttpClient library. It allows stubbed responses to be configured for matched HTTP requests and can be used to test your application&#39;s service layer.&lt;/p&gt; &#xA;&lt;h2&gt;NuGet&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package RichardSzalay.MockHttp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How?&lt;/h2&gt; &#xA;&lt;p&gt;MockHttp defines a replacement &lt;code&gt;HttpMessageHandler&lt;/code&gt;, the engine that drives HttpClient, that provides a fluent configuration API and provides a canned response. The caller (eg. your application&#39;s service layer) remains unaware of its presence.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var mockHttp = new MockHttpMessageHandler();&#xA;&#xA;// Setup a respond for the user api (including a wildcard in the URL)&#xA;mockHttp.When(&#34;http://localhost/api/user/*&#34;)&#xA;        .Respond(&#34;application/json&#34;, &#34;{&#39;name&#39; : &#39;Test McGee&#39;}&#34;); // Respond with JSON&#xA;&#xA;// Inject the handler or client into your application code&#xA;var client = mockHttp.ToHttpClient();&#xA;&#xA;var response = await client.GetAsync(&#34;http://localhost/api/user/1234&#34;);&#xA;// or without async: var response = client.GetAsync(&#34;http://localhost/api/user/1234&#34;).Result;&#xA;&#xA;var json = await response.Content.ReadAsStringAsync();&#xA;&#xA;// No network connection required&#xA;Console.Write(json); // {&#39;name&#39; : &#39;Test McGee&#39;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;When (Backend Definitions) vs Expect (Request Expectations)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;MockHttpMessageHandler&lt;/code&gt; defines both &lt;code&gt;When&lt;/code&gt; and &lt;code&gt;Expect&lt;/code&gt;, which can be used to define responses. They both expose the same fluent API, but each works in a slightly different way.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;When&lt;/code&gt; specifies a &#34;Backend Definition&#34;. Backend Definitions can be matched against multiple times and in any order, but they won&#39;t match if there are any outstanding Request Expectations present (unless &lt;code&gt;BackendDefinitionBehavior.Always&lt;/code&gt; is specified). If no Request Expectations match, &lt;code&gt;Fallback&lt;/code&gt; will be used.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;Expect&lt;/code&gt; specifies a &#34;Request Expectation&#34;. Request Expectations match only once and in the order they were added in. Only once all expectations have been satisfied will Backend Definitions be evaluated. Calling &lt;code&gt;mockHttp.VerifyNoOutstandingExpectation()&lt;/code&gt; will assert that there are no expectations that have yet to be called. Calling &lt;code&gt;ResetExpectations&lt;/code&gt; clears the the queue of expectations.&lt;/p&gt; &#xA;&lt;p&gt;This pattern is heavily inspired by &lt;a href=&#34;https://docs.angularjs.org/api/ngMock/service/$httpBackend&#34;&gt;AngularJS&#39;s $httpBackend&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Matchers (With*)&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;With&lt;/code&gt; and &lt;code&gt;Expect&lt;/code&gt; methods return a &lt;code&gt;MockedRequest&lt;/code&gt;, which can have additional constraints (called matchers) placed on them before specifying a response with &lt;code&gt;Respond&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Passing an HTTP method and URL to &lt;code&gt;When&lt;/code&gt; or &lt;code&gt;Expect&lt;/code&gt; is equivalent to applying a Method and Url matcher respectively. The following chart breaks down additional built in matchers and their usage:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;WithQueryString(&#34;key&#34;, &#34;value&#34;)&lt;br&gt;&lt;br&gt;WithQueryString(&#34;key=value&amp;amp;other=value&#34;)&lt;br&gt;&lt;br&gt;WithQueryString(new Dictionary&amp;lt;string,string&amp;gt;&lt;br&gt;{&lt;br&gt;  { &#34;key&#34;, &#34;value&#34; },&lt;br&gt;  { &#34;other&#34;, &#34;value&#34; }&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Matches on one or more querystring values, ignoring additional values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;WithExactQueryString(&#34;key=value&amp;amp;other=value&#34;)&lt;br&gt;&lt;br&gt;WithExactQueryString(new Dictionary&amp;lt;string,string&amp;gt;&lt;br&gt;{&lt;br&gt;  { &#34;key&#34;, &#34;value&#34; },&lt;br&gt;  { &#34;other&#34;, &#34;value&#34; }&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Matches on one or more querystring values, rejecting additional values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;WithFormData(&#34;key&#34;, &#34;value&#34;)&lt;br&gt;&lt;br&gt;WithFormData(&#34;key=value&amp;amp;other=value&#34;)&lt;br&gt;&lt;br&gt;WithFormData(new Dictionary&amp;lt;string,string&amp;gt;&lt;br&gt;{&lt;br&gt;  { &#34;key&#34;, &#34;value&#34; },&lt;br&gt;  { &#34;other&#34;, &#34;value&#34; }&lt;br&gt;})&lt;br&gt;&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Matches on one or more form data values, ignoring additional values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;WithExactFormData(&#34;key=value&amp;amp;other=value&#34;)&lt;br&gt;&lt;br&gt;WithExactFormData(new Dictionary&amp;lt;string,string&amp;gt;&lt;br&gt;{&lt;br&gt;  { &#34;key&#34;, &#34;value&#34; },&lt;br&gt;  { &#34;other&#34;, &#34;value&#34; }&lt;br&gt;})&lt;br&gt;&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Matches on one or more form data values, rejecting additional values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;WithContent(&#34;{&#39;name&#39;:&#39;McGee&#39;}&#34;)&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Matches on the (post) content of the request&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;WithPartialContent(&#34;McGee&#34;)&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Matches on the partial (post) content of the request&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;WithHeaders(&#34;Authorization&#34;, &#34;Basic abcdef&#34;)&lt;br&gt;&lt;br&gt;WithHeaders(@&#34;Authorization: Basic abcdef&lt;br&gt;Accept: application/json&#34;)&lt;br&gt;&lt;br&gt;WithHeaders(new Dictionary&amp;lt;string,string&amp;gt;&lt;br&gt;{&lt;br&gt;  { &#34;Authorization&#34;, &#34;Basic abcdef&#34; },&lt;br&gt;  { &#34;Accept&#34;, &#34;application/json&#34; }&lt;br&gt;})&lt;br&gt;&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Matches on one or more HTTP header values&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;pre&gt;With(request =&amp;gt; request.Content.Length &amp;gt; 50)&lt;/pre&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Applies custom matcher logic against an HttpRequestMessage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;These methods are chainable, making complex requirements easy to descirbe.&lt;/p&gt; &#xA;&lt;h3&gt;Verifying Matches&lt;/h3&gt; &#xA;&lt;p&gt;When using Request Expectations via &lt;code&gt;Expect&lt;/code&gt;, &lt;code&gt;MockHttpMessageHandler.VerifyNoOutstandingExpectation()&lt;/code&gt; can be used to assert that there are no unmatched requests.&lt;/p&gt; &#xA;&lt;p&gt;For other use cases, &lt;code&gt;GetMatchCount&lt;/code&gt; will return the number of times a mocked request (returned by When / Expect) was called. This even works with &lt;code&gt;Fallback&lt;/code&gt;, so you can check how many unmatched requests there were.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var mockHttp = new MockHttpMessageHandler();&#xA;&#xA;var request = mockHttp.When(&#34;http://localhost/api/user/*&#34;)&#xA;        .Respond(&#34;application/json&#34;, &#34;{&#39;name&#39; : &#39;Test McGee&#39;}&#34;);&#xA;&#xA;var client = mockHttp.ToHttpClient();&#xA;&#xA;await client.GetAsync(&#34;http://localhost/api/user/1234&#34;);&#xA;await client.GetAsync(&#34;http://localhost/api/user/2345&#34;);&#xA;await client.GetAsync(&#34;http://localhost/api/user/3456&#34;);&#xA;&#xA;Console.Write(mockHttp.GetMatchCount(request)); // 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Match Behavior&lt;/h3&gt; &#xA;&lt;p&gt;Each request is evaluated using the following process:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If Request Expectations exist and the request matches the next expectation in the queue, the expectation is used to process the response and is then removed from the queue&lt;/li&gt; &#xA; &lt;li&gt;If no Request Expectations exist, or the handler was constructed with &lt;code&gt;BackendDefinitionBehavior.Always&lt;/code&gt;, the first matching Backend Definition processes the response&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MockHttpMessageHandler.Fallback&lt;/code&gt; handles the request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Fallback&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Fallback&lt;/code&gt; property handles all requests that weren&#39;t handled by the match behavior. Since it is also a mocked request, any of the &lt;code&gt;Respond&lt;/code&gt; overloads can be applied.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Unhandled requests should throw an exception&#xA;mockHttp.Fallback.Throw(new InvalidOperationException(&#34;No matching mock handler&#34;));&#xA;&#xA;// Unhandled requests should be executed against the network&#xA;mockHttp.Fallback.Respond(new HttpClient());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default fallback behavior is to return an empty response the status &lt;code&gt;404 No matching mock handler for &#34;GET http://host/url&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;This example uses Expect to test an OAuth ticket recycle process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Simulate an expired token&#xA;mockHttp.Expect(&#34;/users/me&#34;)&#xA;        .WithQueryString(&#34;access_token&#34;, &#34;old_token&#34;)&#xA;        .Respond(HttpStatusCode.Unauthorized);&#xA;    &#xA;// Expect the request to refresh the token and supply a new one&#xA;mockHttp.Expect(&#34;/tokens/refresh&#34;)&#xA;        .WithFormData(&#34;refresh_token&#34;, &#34;refresh_token&#34;)&#xA;        .Respond(&#34;application/json&#34;, &#34;{&#39;access_token&#39; : &#39;new_token&#39;, &#39;refresh_token&#39; : &#39;new_refresh&#39;}&#34;);&#xA;    &#xA;// Expect the original call to be retried with the new token&#xA;mockHttp.Expect(&#34;/users/me&#34;)&#xA;        .WithQueryString(&#34;access_token&#34;, &#34;new_token&#34;)&#xA;        .Respond(&#34;application/json&#34;, &#34;{&#39;name&#39; : &#39;Test McGee&#39;}&#34;);&#xA;    &#xA;var httpClient = mockHttp.ToHttpClient();&#xA;&#xA;var userService = new UserService(httpClient);&#xA;&#xA;var user = await userService.GetUserDetails();&#xA;&#xA;Assert.Equals(&#34;Test McGee&#34;, user.Name);&#xA;mockHttp.VerifyNoOutstandingExpectation();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Platform Support&lt;/h2&gt; &#xA;&lt;p&gt;MockHttp is compiled for .NET Standard 2.0, .NET Standard 1.1, .NET 4, and .NET 4.5, as well a Portable Class Library (Profile 328) supporting:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.NET 4&lt;/li&gt; &#xA; &lt;li&gt;Silverlight 5&lt;/li&gt; &#xA; &lt;li&gt;Winodws 8&lt;/li&gt; &#xA; &lt;li&gt;Windows Phone Silverlight 8&lt;/li&gt; &#xA; &lt;li&gt;Windows Phone 8.1&lt;/li&gt; &#xA; &lt;li&gt;Xamarin iOS&lt;/li&gt; &#xA; &lt;li&gt;Xamarin Android&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build / Release&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository and build &lt;code&gt;RichardSzalay.MockHttp.sln&lt;/code&gt; using MSBuild. NuGet package restore must be enabled.&lt;/p&gt; &#xA;&lt;p&gt;To release, build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;msbuild Release.proj /p:PackageVersion=1.2.3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you fork the project, simply rename the &lt;code&gt;nuspec&lt;/code&gt; file accordingly and it will be picked up by the release script.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Many thanks to all the members of the community that have contributed PRs to this project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jozefizso&#34;&gt;jozefizso&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/camiller2&#34;&gt;camiller2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wislon&#34;&gt;wislon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/coryflucas&#34;&gt;coryflucas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/esskar&#34;&gt;esskar&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jericho&#34;&gt;jericho&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2018 Richard Szalay&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>m3rcer/Chisel-Strike</title>
    <updated>2022-07-14T01:35:35Z</updated>
    <id>tag:github.com,2022-07-14:/m3rcer/Chisel-Strike</id>
    <link href="https://github.com/m3rcer/Chisel-Strike" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A .NET XOR encrypted cobalt strike aggressor implementation for chisel to utilize faster proxy and advanced socks5 capabilities.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Chisel-Strike&lt;/h1&gt; &#xA;&lt;p&gt;A .NET XOR encrypted cobalt strike aggressor implementation for chisel to utilize faster proxy and advanced socks5 capabilities.&lt;/p&gt; &#xA;&lt;h2&gt;Why write this?&lt;/h2&gt; &#xA;&lt;p&gt;In my experience I found socks4/socks4a proxies quite slow in comparison to its socks5 counterparts and a lack of implementation of socks5 in most C2 frameworks. There is a C# wrapper around the go version of &lt;a href=&#34;https://github.com/jpillora/chisel&#34;&gt;chisel&lt;/a&gt; called &lt;a href=&#34;https://github.com/shantanu561993/SharpChisel&#34;&gt;SharpChisel&lt;/a&gt;. This wrapper has a few &lt;a href=&#34;https://github.com/shantanu561993/SharpChisel/issues/1&#34;&gt;issues&lt;/a&gt; and isn&#39;t maintained to the latest version of &lt;a href=&#34;https://github.com/jpillora/chisel&#34;&gt;chisel&lt;/a&gt;. It didn’t allow using shellcode with &lt;a href=&#34;https://github.com/TheWover/donut&#34;&gt;donut&lt;/a&gt;, reflection methods or &lt;code&gt;execute-assembly&lt;/code&gt;. I found a fix for this using the &lt;a href=&#34;https://github.com/latortuga71/SharpChisel-NG&#34;&gt;SharpChisel-NG&lt;/a&gt; project.&lt;/p&gt; &#xA;&lt;p&gt;Since the &lt;a href=&#34;https://github.com/shantanu561993/SharpChisel&#34;&gt;SharpChisel&lt;/a&gt; assembly is around &lt;code&gt;16.7 MB&lt;/code&gt;, &lt;code&gt;execute-assembly&lt;/code&gt;(has a hidden size limitation of &lt;code&gt;1 MB&lt;/code&gt;) and similar in memory methods wouldn’t work. To maintain most of the execution in memory I incorporated the &lt;a href=&#34;https://gist.github.com/Arno0x/2b223114a726be3c5e7a9cacd25053a2&#34;&gt;NetLoader&lt;/a&gt; project by &lt;a href=&#34;https://github.com/Flangvik&#34;&gt;Flangvik&lt;/a&gt; which is executed via &lt;code&gt;execute-assembly&lt;/code&gt; to reflectively host and load a XOR encrypted version of &lt;code&gt;SharpChisel&lt;/code&gt; with base64 arguments in memory.&lt;/p&gt; &#xA;&lt;p&gt;As an alternative, it is also possible to implement similar C# proxies like &lt;a href=&#34;https://github.com/nettitude/SharpSocks&#34;&gt;SharpSocks&lt;/a&gt; by replacing the appropriate &lt;a href=&#34;https://github.com/jpillora/chisel&#34;&gt;chisel&lt;/a&gt; binaries in the project.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: If using a Windows teamserver skip steps 2 and 3.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone/download the repository: &lt;code&gt;git clone https://github.com/m3rcer/Chisel-Strike.git&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make all binaries executable:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cd Chisel-Strike&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chmod +x -R chisel-modules&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chmod +x -R tools&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Install &lt;code&gt;Mingw-w64&lt;/code&gt; and &lt;code&gt;mono&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;sudo apt-get install mingw-w64&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;sudo apt install mono-complete&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Import &lt;code&gt;ChiselStrike.cna&lt;/code&gt; in cobalt strike using the &lt;code&gt;Script Manager&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Recompile binaries from the &lt;code&gt;src&lt;/code&gt; folder if needed.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jpillora/chisel&#34;&gt;chisel&lt;/a&gt; can be executed on both the teamserver (windows/linux) and the beacon. With either acting as the server/client. A normal execution flow would be to setup a &lt;a href=&#34;https://github.com/jpillora/chisel&#34;&gt;chisel&lt;/a&gt; server on the teamserver and create a client on the beacon connecting back to the teamserver.&lt;/p&gt; &#xA;&lt;h3&gt;Commands&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chisel &amp;lt;client/server&amp;gt; &amp;lt;command&amp;gt;&lt;/code&gt;: Run Chisel on a beacon&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chisel-tms &amp;lt;client/server&amp;gt; &amp;lt;command&amp;gt;&lt;/code&gt;: Run Chisel on your teamserver&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chisel-enc&lt;/code&gt;: XOR Encrypt &lt;code&gt;SharpChisel.exe&lt;/code&gt; with a password of choice&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chisel-jobs&lt;/code&gt;: List active chisel jobs on the teamserver and beacon&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chisel-kill&lt;/code&gt;: Kill active chisel jobs on a beacon&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chisel-tms-kill&lt;/code&gt;: Kill active chisel jobs on teamserver&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/m3rcer/Chisel-Strike/main/chiselstrike.gif&#34; alt=&#34;Alt Text&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;OPSEC&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gist.github.com/Arno0x/2b223114a726be3c5e7a9cacd25053a2&#34;&gt;NetLoader&lt;/a&gt; can easily be obfuscated and used to bypass defender using projects like &lt;a href=&#34;https://github.com/icyguider/Nimcrypt2&#34;&gt;NimCrypt2&lt;/a&gt; and the like.&lt;/p&gt; &#xA;&lt;p&gt;Yet &lt;code&gt;SharpChisel.exe&lt;/code&gt; drops a &lt;code&gt;dll&lt;/code&gt; on disk due to the use of &lt;code&gt;Costura/Fody&lt;/code&gt; packages at a location similar to: &lt;code&gt;C:\Users\m3rcer\AppData\Local\Temp\Costura\CB9433C24E75EC539BF34CD1AA12B236\64\main.dll&lt;/code&gt; which is detected by defender. It is advised to obfuscate &lt;a href=&#34;https://github.com/jpillora/chisel&#34;&gt;chisel&lt;/a&gt; dll&#39;s using projects like &lt;a href=&#34;https://github.com/unixpickle/gobfuscate&#34;&gt;gobfuscate&lt;/a&gt; in the &lt;a href=&#34;https://github.com/latortuga71/SharpChisel-NG&#34;&gt;SharpChisel-NG&lt;/a&gt; project and re-build new &lt;a href=&#34;https://github.com/latortuga71/SharpChisel-NG&#34;&gt;SharpChisel-NG&lt;/a&gt; binaries as shown &lt;a href=&#34;https://medium.com/@shantanukhande/red-team-how-to-embed-golang-tools-in-c-e269bf33876a#:~:text=Step%202%3A%20Make%20a%20C%23,rename%20the%20XML%20to%20FodyWeavers.&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Figure a way to avoid &lt;code&gt;SharpChisel&lt;/code&gt; dropping &lt;code&gt;main.dll&lt;/code&gt; on disk / Create a new C# wrapper for &lt;a href=&#34;https://github.com/jpillora/chisel&#34;&gt;chisel&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a method to parse command output for the &lt;code&gt;chisel-tms&lt;/code&gt; command.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/Flangvik&#34;&gt;Flangvik&lt;/a&gt; and &lt;a href=&#34;https://gist.github.com/Arno0x&#34;&gt;Arno0x&lt;/a&gt; for the &lt;a href=&#34;https://gist.github.com/Arno0x/2b223114a726be3c5e7a9cacd25053a2&#34;&gt;NetLoader&lt;/a&gt; project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/shantanu561993&#34;&gt;shantanu561993&lt;/a&gt; for the C# wrapper implementation of chisel: &lt;a href=&#34;https://github.com/shantanu561993/SharpChisel&#34;&gt;SharpChisel&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/latortuga71&#34;&gt;latortuga71&lt;/a&gt; for the &lt;code&gt;load-assembly&lt;/code&gt; fix: &lt;a href=&#34;https://github.com/latortuga71/SharpChisel-NG&#34;&gt;SharpChisel-NG&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>de4dot/de4dot</title>
    <updated>2022-07-14T01:35:35Z</updated>
    <id>tag:github.com,2022-07-14:/de4dot/de4dot</id>
    <link href="https://github.com/de4dot/de4dot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;.NET deobfuscator and unpacker.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;de4dot is an open source (GPLv3) .NET deobfuscator and unpacker written in C#. It will try its best to restore a packed and obfuscated assembly to almost the original assembly. Most of the obfuscation can be completely restored (eg. string encryption), but symbol renaming is impossible to restore since the original names aren&#39;t (usually) part of the obfuscated assembly.&lt;/p&gt; &#xA;&lt;p&gt;It uses &lt;a href=&#34;https://github.com/0xd4d/dnlib/&#34;&gt;dnlib&lt;/a&gt; to read and write assemblies so make sure you get it or it won&#39;t compile.&lt;/p&gt; &#xA;&lt;h1&gt;Binaries&lt;/h1&gt; &#xA;&lt;p&gt;Get binaries from the build server &lt;a href=&#34;https://github.com/0xd4d/de4dot/actions&#34;&gt;&lt;img src=&#34;https://github.com/0xd4d/de4dot/workflows/GitHub%20CI/badge.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;It&#39;s FREE but there&#39;s NO SUPPORT&lt;/h1&gt; &#xA;&lt;p&gt;There&#39;s no support. Don&#39;t email me if you can&#39;t use it or if it fails to deobfuscate a file obfuscated with an updated obfuscator.&lt;/p&gt; &#xA;&lt;p&gt;Instead, try to update de4dot yourself. It&#39;s a lot easier than you think. If you can&#39;t, search the Internet and you should find a couple of forums where you can ask your question.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;p&gt;Here&#39;s a pseudo random list of the things it will do depending on what obfuscator was used to obfuscate an assembly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Inline methods. Some obfuscators move small parts of a method to another static method and calls it.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt strings statically or dynamically&lt;/li&gt; &#xA; &lt;li&gt;Decrypt other constants. Some obfuscators can also encrypt other constants, such as all integers, all doubles, etc.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt methods statically or dynamically&lt;/li&gt; &#xA; &lt;li&gt;Remove proxy methods. Many obfuscators replace most/all call instructions with a call to a delegate. This delegate in turn calls the real method.&lt;/li&gt; &#xA; &lt;li&gt;Rename symbols. Even though most symbols can&#39;t be restored, it will rename them to human readable strings. Sometimes, some of the original names can be restored, though.&lt;/li&gt; &#xA; &lt;li&gt;Devirtualize virtualized code&lt;/li&gt; &#xA; &lt;li&gt;Decrypt resources. Many obfuscators have an option to encrypt .NET resources.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt embedded files. Many obfuscators have an option to embed and possibly encrypt/compress other assemblies.&lt;/li&gt; &#xA; &lt;li&gt;Remove tamper detection code&lt;/li&gt; &#xA; &lt;li&gt;Remove anti-debug code&lt;/li&gt; &#xA; &lt;li&gt;Control flow deobfuscation. Many obfuscators modify the IL code so it looks like spaghetti code making it very difficult to understand the code.&lt;/li&gt; &#xA; &lt;li&gt;Restore class fields. Some obfuscators can move fields from one class to some other obfuscator created class.&lt;/li&gt; &#xA; &lt;li&gt;Convert a PE exe to a .NET exe. Some obfuscators wrap a .NET assembly inside a Win32 PE so a .NET decompiler can&#39;t read the file.&lt;/li&gt; &#xA; &lt;li&gt;Removes most/all junk classes added by the obfuscator.&lt;/li&gt; &#xA; &lt;li&gt;Fixes some peverify errors. Many of the obfuscators are buggy and create unverifiable code by mistake.&lt;/li&gt; &#xA; &lt;li&gt;Restore the types of method parameters and fields&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Supported obfuscators/packers&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Agile.NET (aka CliSecure)&lt;/li&gt; &#xA; &lt;li&gt;Babel.NET&lt;/li&gt; &#xA; &lt;li&gt;CodeFort&lt;/li&gt; &#xA; &lt;li&gt;CodeVeil&lt;/li&gt; &#xA; &lt;li&gt;CodeWall&lt;/li&gt; &#xA; &lt;li&gt;CryptoObfuscator&lt;/li&gt; &#xA; &lt;li&gt;DeepSea Obfuscator&lt;/li&gt; &#xA; &lt;li&gt;Dotfuscator&lt;/li&gt; &#xA; &lt;li&gt;.NET Reactor&lt;/li&gt; &#xA; &lt;li&gt;Eazfuscator.NET&lt;/li&gt; &#xA; &lt;li&gt;Goliath.NET&lt;/li&gt; &#xA; &lt;li&gt;ILProtector&lt;/li&gt; &#xA; &lt;li&gt;MaxtoCode&lt;/li&gt; &#xA; &lt;li&gt;MPRESS&lt;/li&gt; &#xA; &lt;li&gt;Rummage&lt;/li&gt; &#xA; &lt;li&gt;Skater.NET&lt;/li&gt; &#xA; &lt;li&gt;SmartAssembly&lt;/li&gt; &#xA; &lt;li&gt;Spices.Net&lt;/li&gt; &#xA; &lt;li&gt;Xenocode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some of the above obfuscators are rarely used (eg. Goliath.NET), so they have had much less testing. Help me out by reporting bugs or problems you find.&lt;/p&gt; &#xA;&lt;h1&gt;Warning&lt;/h1&gt; &#xA;&lt;p&gt;Sometimes the obfuscated assembly and all its dependencies are loaded into memory for execution. Use a safe sandbox environment if you suspect the assembly or assemblies to be malware.&lt;/p&gt; &#xA;&lt;p&gt;Even if the current version of de4dot doesn&#39;t load a certain assembly into memory for execution, a future version might.&lt;/p&gt; &#xA;&lt;h1&gt;How to use de4dot&lt;/h1&gt; &#xA;&lt;h2&gt;N00b users&lt;/h2&gt; &#xA;&lt;p&gt;Drag and drop the file(s) onto de4dot.exe and wait a few seconds.&lt;/p&gt; &#xA;&lt;h2&gt;Deobfuscate more than one file at a time&lt;/h2&gt; &#xA;&lt;p&gt;When more than one assembly has been obfuscated, it&#39;s very likely that you must deobfuscate them all at the same time unless you disable symbol renaming. The reason is that if assembly A has a reference to class C in assembly B, and you rename symbols only in assembly B, then class C could be renamed to eg. Class0 but the reference in assembly A still references a class called C in assembly B. If you deobfuscate both assemblies at the same time, all references will also be updated.&lt;/p&gt; &#xA;&lt;h2&gt;Find all obfuscated files and deobfuscate them&lt;/h2&gt; &#xA;&lt;p&gt;The following command line will deobfuscate all assemblies that have been obfuscated by a supported obfuscator and save the assemblies to &lt;code&gt;c:\output&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot -r c:\input -ru -ro c:\output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; means recursive search. &lt;code&gt;-ru&lt;/code&gt; means it should ignore unknown files. &lt;code&gt;-ro&lt;/code&gt; means it should place the output files in the following directory. Typically, you&#39;d first copy &lt;code&gt;c:\input&lt;/code&gt; to &lt;code&gt;c:\output&lt;/code&gt;, and then run the command. That way all the files will be in &lt;code&gt;c:\output&lt;/code&gt;, even non-assemblies and non-processed assemblies. When de4dot is finished, you&#39;d just double click the main assembly in &lt;code&gt;c:\output&lt;/code&gt; and it should hopefully start.&lt;/p&gt; &#xA;&lt;h2&gt;Detect obfuscator&lt;/h2&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;-d&lt;/code&gt; option to detect the obfuscator without deobfuscating any assembly.&lt;/p&gt; &#xA;&lt;p&gt;Find all .NET assemblies and detect obfuscator. If it&#39;s an unsupported obfuscator or if it&#39;s not obfuscated, it will print &#34;Unknown obfuscator&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot -d -r c:\input&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Same as above except that it will only show which files have been obfuscated by a supported obfuscator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot -d -r c:\input -ru&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Detect obfuscator&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot -d file1.dll file2.dll file3.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Preserving metadata tokens&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes in rare cases, you&#39;d want to preserve the metadata tokens. Use &lt;code&gt;--preserve-tokens&lt;/code&gt; or &lt;code&gt;--preserve-table&lt;/code&gt;. Also consider using &lt;code&gt;--keep-types&lt;/code&gt; since it won&#39;t remove any types and methods added by the obfuscator. Another useful option is &lt;code&gt;--dont-create-params&lt;/code&gt;. If used, the renamer won&#39;t create Param rows for method parameters that don&#39;t have a Param row. That way the ParamPtr table won&#39;t be added to your assemblies. Peverify has a bug and doesn&#39;t support it (you&#39;ll see lots of &#34;errors&#34;).&lt;/p&gt; &#xA;&lt;p&gt;The #Strings, #US and #Blob heaps can also be preserved by using &lt;code&gt;--preserve-strings&lt;/code&gt;, &lt;code&gt;--preserve-us&lt;/code&gt;, and &lt;code&gt;--preserve-blob&lt;/code&gt; respectively. Of these three, &lt;code&gt;--preserve-us&lt;/code&gt; is the most useful one since &lt;code&gt;ldstr&lt;/code&gt; instruction and &lt;code&gt;module.ResolveString()&lt;/code&gt; directly reference the #US heap.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--preserve-sig-data&lt;/code&gt; should be used if the obfuscator adds extra data at the end of signatures that it uses for its own purpose, eg. as decryption keys. Confuser is one obfuscator that does this.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--preserve-tokens&lt;/code&gt; preserves all important tokens but will also enable &lt;code&gt;--preserve-us&lt;/code&gt;, &lt;code&gt;--preserve-blob&lt;/code&gt; and &lt;code&gt;--preserve-sig-data&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If it&#39;s detected as an unknown (unsupported) obfuscator (or if you force it with &lt;code&gt;-p un&lt;/code&gt;), all tokens are preserved, including the #US heap and any extra data at the end of signatures. Also, no obfuscator types, fields or methods are removed.&lt;/p&gt; &#xA;&lt;p&gt;Preserve all important tokens, #US, #Blob, extra sig data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot --preserve-tokens file1.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Preserve all important tokens, #US, #Blob, extra sig data and don&#39;t remove types/fields added by the obfuscator&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot --keep-types --preserve-tokens file1.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Preserve all important tokens, #US, #Blob, extra sig data and don&#39;t create extra Param rows to prevent the ParamPtr table from being created.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot --dont-create-params --preserve-tokens file1.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Preserve all important tokens except the Param tokens.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot --preserve-table all,-pd file1.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dynamically decrypting strings&lt;/h2&gt; &#xA;&lt;p&gt;Although &lt;code&gt;de4dot&lt;/code&gt; supports a lot of obfuscators, there&#39;s still some it doesn&#39;t support. To decrypt strings, you&#39;ll first need to figure out which method or methods decrypt strings. To get the method token of these string decrypters, you can use ILDASM with the &#39;show metadata tokens&#39; option enabled. A method token is a 32-bit number and begins with 06, eg. 06012345.&lt;/p&gt; &#xA;&lt;p&gt;This command will load assembly file1.dll into memory by calling &lt;code&gt;Assembly.Load()&lt;/code&gt;. When it detects calls to the two string decrypters (06012345 and 060ABCDE), it will call them by creating a dynamic method, and save the result (the decrypted string). The call to the string decrypter will be removed and the decrypted string will be in its place.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot file1.dll --strtyp delegate --strtok 06012345 --strtok 060ABCDE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since the assembly is loaded and executed, make sure you run this in a sandbox if you suspect the file to be malware.&lt;/p&gt; &#xA;&lt;h2&gt;Forcing detection of a certain obfuscator&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;de4dot&lt;/code&gt; isn&#39;t perfect. If it fails to detect an obfuscator, you can use the &lt;code&gt;-p&lt;/code&gt; option to force it to assume it&#39;s been obfuscated by it.&lt;/p&gt; &#xA;&lt;p&gt;Force SmartAssembly&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot file1.dll -p sa&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Force unsupported obfuscator&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot file1.dll -p un&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For other obfuscator types, see the help screen.&lt;/p&gt; &#xA;&lt;h2&gt;Disabling symbol renaming&lt;/h2&gt; &#xA;&lt;p&gt;Renaming symbols isn&#39;t as easy as renaming A to B when reflection is involved. &lt;code&gt;de4dot&lt;/code&gt; currently doesn&#39;t support renaming XAML so if you suspect that it uses WPF (or if it&#39;s a Silverlight app) you should disable renaming if the assembly fails to run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot --dont-rename file1.dll file2.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;--keep-names&lt;/code&gt; can also be used to tell &lt;code&gt;de4dot&lt;/code&gt; not to rename certain symbols, eg. &#34;don&#39;t rename fields&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Rename everything that should be renamed except properties, events and methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot --keep-names pem file1.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using a different rename regex&lt;/h2&gt; &#xA;&lt;p&gt;The default regexes should be enough, except possibly the one that is used when an unsupported obfuscator is detected. To see all default regexes, start &lt;code&gt;de4dot&lt;/code&gt; without any arguments and it will list all options and all default values.&lt;/p&gt; &#xA;&lt;p&gt;Eg., currently the following is the default regex used when Dotfuscator is detected&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;!^[a-z][a-z0-9]{0,2}$&amp;amp;!^A_[0-9]+$&amp;amp;^[\u2E80-\u9FFFa-zA-Z_&amp;lt;{$][\u2E80-\u9FFFa-zA-Z_0-9&amp;lt;&amp;gt;{}$.`-]*$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, it&#39;s not just one regex, it&#39;s more than one. Each one is separated by &lt;code&gt;&amp;amp;&lt;/code&gt; and each regex can be negated by using &lt;code&gt;!&lt;/code&gt; in front of it. To show it more clearly, these regexes are used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(negated) ^[a-z][a-z0-9]{0,2}$&#xA;(negated) ^A_[0-9]+$&#xA;^[\u2E80-\u9FFFa-zA-Z_&amp;lt;{$][\u2E80-\u9FFFa-zA-Z_0-9&amp;lt;&amp;gt;{}$.`-]*$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To change the regex(es), you must know the short type name of the obfuscator (see help screen). Eg. it&#39;s &lt;code&gt;sa&lt;/code&gt; if it&#39;s SmartAssembly, and &lt;code&gt;un&lt;/code&gt; if it&#39;s an unsupported/unknown obfuscator. The option to use is &lt;code&gt;--TYPE-name&lt;/code&gt; (eg. &lt;code&gt;--sa-name&lt;/code&gt; for SmartAssembly and &lt;code&gt;--un-name&lt;/code&gt; for unknown/unsupported obfuscators):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;de4dot --un-name &#34;^[a-zA-Z]\w*$&#34; file1.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Other options&lt;/h2&gt; &#xA;&lt;p&gt;Start &lt;code&gt;de4dot&lt;/code&gt; without any arguments and it will show all options.&lt;/p&gt;</summary>
  </entry>
</feed>