<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-07T01:32:28Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>StefanTheCode/OptimizeMePlease</title>
    <updated>2022-10-07T01:32:28Z</updated>
    <id>tag:github.com,2022-10-07:/StefanTheCode/OptimizeMePlease</id>
    <link href="https://github.com/StefanTheCode/OptimizeMePlease" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OptimizeMePlease&lt;/h1&gt; &#xA;&lt;h2&gt;You are probably here because you saw my post on Linkedin.&lt;/h2&gt; &#xA;&lt;h2&gt;Welcome!&lt;/h2&gt; &#xA;&lt;h1&gt;Steps&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Before you run an application, you will need to create a database (I&#39;m using MSSQL) named &#34;OptimizeMePlease&#34;&lt;/li&gt; &#xA; &lt;li&gt;Go to Program.cs class&lt;/li&gt; &#xA; &lt;li&gt;&#34;IWillPopulateDate()&#34; is a method which will get a script from the project directory and run in on created DB&lt;/li&gt; &#xA; &lt;li&gt;Run application in Debug/Release mode&lt;/li&gt; &#xA; &lt;li&gt;Comment or delete IWillPopulateData() call from Main method&lt;/li&gt; &#xA; &lt;li&gt;Go to BenchmarkService.cs class&lt;/li&gt; &#xA; &lt;li&gt;Start coding within GetAuthors_Optimized method&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How do I submit my solution?&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone the project, create a branch and work on that branch.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;OR&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you don&#39;t want to bother with github, after you&#39;re done with the changes, send me the results on Linkedin.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Rules&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Only Entity Framework (Core) is allowed for using&lt;/li&gt; &#xA; &lt;li&gt;The data obtained in the non-optimized version of the code must also be obtained in the optimized version&lt;/li&gt; &#xA; &lt;li&gt;If you see potential optimization of something else, you can do it&lt;/li&gt; &#xA; &lt;li&gt;Entities and DbContext cannot be changed (you got legacy code no matter what it might be bad :) )&lt;/li&gt; &#xA; &lt;li&gt;The models returned from the method can be changed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;What should the method return?&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Given that there is a predefined database of data, the method should in any case return the list of data currently returned by the non-optimized method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How will performance success be measured?&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Given that each of us works on a computer with different performance and power, the execution time quotient of the non-optimized and optimized method will be checked for each separately.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;Non-optimized method Execution time: 1.1s = 1100ms Optimized method Execution time: 200ms&lt;/p&gt; &#xA;&lt;h3&gt;Result: 1100ms/200ms = 5.5x faster.&lt;/h3&gt; &#xA;&lt;p&gt;In addition, I will check the performance on my computer for individual results.&lt;/p&gt; &#xA;&lt;h1&gt;GOOD LUCK!&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>jadepeng/XMusicDownloader</title>
    <updated>2022-10-07T01:32:28Z</updated>
    <id>tag:github.com,2022-10-07:/jadepeng/XMusicDownloader</id>
    <link href="https://github.com/jadepeng/XMusicDownloader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;一款 支持从百度、网易、qq、酷狗、咪咕等音乐网站搜索并下载歌曲的程序，支持下载无损音乐&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;XMusicDownloader&lt;/h1&gt; &#xA;&lt;p&gt;XMusicDownloader，一款 支持从百度、网易、qq和酷狗、咪咕音乐等音乐网站搜索并下载歌曲的程序。&lt;/p&gt; &#xA;&lt;p&gt;开源音乐下载神器XMusicDownloader更新啦，新增网易、腾讯音乐歌单歌曲、歌手歌曲、专辑歌曲一键下载，同时支持下载flac无损音乐。&lt;/p&gt; &#xA;&lt;h2&gt;功能&lt;/h2&gt; &#xA;&lt;p&gt;V1.0 功能&lt;a href=&#34;https://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html&#34;&gt;开源工具软件XMusicDownloader——音乐下载神器&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;聚合搜索多家音乐网站&lt;/li&gt; &#xA; &lt;li&gt;支持音乐批量下载&lt;/li&gt; &#xA; &lt;li&gt;搜索结果综合排序&lt;/li&gt; &#xA; &lt;li&gt;可以编写Provider程序，支持其他音乐网站&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;V1.1 新增功能支持歌单、专辑、歌手歌曲下载，支持无损下载&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;支持歌单、专辑、歌手歌曲下载（腾讯、网易）&lt;/li&gt; &#xA; &lt;li&gt;支持flac无损、320,128 码率下载&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/jadepeng/XMusicDownloader/raw/master/v1.1.png&#34; alt=&#34;V1.1截图&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;关联软件&lt;/h2&gt; &#xA;&lt;h3&gt;网易云音乐歌单收费歌曲补全工具&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/25/1598352954630.png&#34; alt=&#34;界面&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;原理以及使用方法见： &lt;a href=&#34;https://www.cnblogs.com/xiaoqi/p/music163tool.html&#34;&gt;https://www.cnblogs.com/xiaoqi/p/music163tool.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;扩展功能说明&lt;/h2&gt; &#xA;&lt;p&gt;主要是调用了一个&lt;a href=&#34;https://www.bzqll.com/2019/04/318.html&#34;&gt;第三方接口&lt;/a&gt;实现歌单、歌手和专辑歌曲读取，以及获取真实下载地址。&lt;/p&gt; &#xA;&lt;h3&gt;扩展provider接口，增加获取歌曲列表接口&lt;/h3&gt; &#xA;&lt;p&gt;增加Support接口判断url地址是否是歌单地址，增加GetSongList用于获取歌单的歌曲列表，增加getDownloadUrl(string id, string rate)获取歌曲下载地址。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;public interface IMusicProvider&#xA;    {&#xA;        string Name { get; }&#xA;&#xA;        string getDownloadUrl(Song song);&#xA;        List&amp;lt;Song&amp;gt; SearchSongs(string keyword, int page, int pageSize);&#xA;&#xA;        // 歌单&#xA;        bool Support(string url);&#xA;        List&amp;lt;Song&amp;gt; GetSongList(string url);&#xA;        /// &amp;lt;summary&amp;gt;&#xA;        /// 获取下载地址&#xA;        /// &amp;lt;/summary&amp;gt;&#xA;        /// &amp;lt;param name=&#34;id&#34;&amp;gt;歌曲id&amp;lt;/param&amp;gt;&#xA;        /// &amp;lt;param name=&#34;rate&#34;&amp;gt;码率，音质 如果最大音质获取出错则自动转其他音质&#x9;&amp;lt;/param&amp;gt;&#xA;        /// &amp;lt;returns&amp;gt;歌曲下载地址&amp;lt;/returns&amp;gt;&#xA;        string getDownloadUrl(string id, string rate);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;实现provider&lt;/h3&gt; &#xA;&lt;p&gt;以QQ为例：&lt;/p&gt; &#xA;&lt;p&gt;先判断是否是支持的url，主要是判断是否符合歌单、专辑、歌手的url格式。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;        // 歌单： https://y.qq.com/n/yqq/playsquare/6924336223.html#stat=y_new.playlist.dissname&#xA;        // 专辑 https://y.qq.com/n/yqq/album/00153q8l2vldMz.html&#xA;        // 歌手 https://y.qq.com/n/yqq/singer/000CK5xN3yZDJt.html&#xA;&#xA;        Regex regex = new Regex(&#34;\\/(\\w+).html&#34;);&#xA;        public bool Support(string url)&#xA;        {&#xA;            if (url == null)&#xA;            {&#xA;                return false;&#xA;            }&#xA;&#xA;            if (!regex.IsMatch(url))&#xA;            {&#xA;                return false;&#xA;            }&#xA;&#xA;            return url.StartsWith(&#34;https://y.qq.com/n/yqq/playsquare&#34;) || url.StartsWith(&#34;https://y.qq.com/n/yqq/album&#34;) || url.StartsWith(&#34;https://y.qq.com/n/yqq/singer&#34;);&#xA;        } &#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;然后调用itooi.cn的api获取歌曲&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;歌单接口 &lt;code&gt;https://v1.itooi.cn/tencent/songList?id=&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;歌手歌曲接口 &lt;code&gt;https://v1.itooi.cn/tencent/song/artist?id=&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;专辑歌曲接口 &lt;code&gt;https://v1.itooi.cn/tencent/album?id=&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt; public List&amp;lt;Song&amp;gt; GetSongList(string url)&#xA;        {&#xA;            var isSongList = url.StartsWith(&#34;https://y.qq.com/n/yqq/playsquare&#34;);&#xA;&#xA;            var id = regex.Match(url).Groups[1].Value;&#xA;&#xA;            var result = new List&amp;lt;Song&amp;gt;();&#xA;&#xA;            if (isSongList)&#xA;            {&#xA;                GetSongListDetail(id, result);&#xA;            }&#xA;            else if (url.StartsWith(&#34;https://y.qq.com/n/yqq/albu&#34;))&#xA;            {&#xA;                GetAlbum(id, result);&#xA;            }&#xA;            else&#xA;            {&#xA;                GetSingerSong(id, result);&#xA;            }&#xA;&#xA;&#xA;            return result;&#xA;&#xA;        }&#xA;&#xA;        private void GetSongListDetail(string id, List&amp;lt;Song&amp;gt; result)&#xA;        {&#xA;            var requestUrl = &#34;https://v1.itooi.cn/tencent/songList?id=&#34; + id;&#xA;            var searchResult = HttpHelper.GET(requestUrl, DEFAULT_CONFIG);&#xA;&#xA;            var songList = JObject.Parse(searchResult)[&#34;data&#34;][0][&#34;songlist&#34;];&#xA;            var index = 1;&#xA;&#xA;            foreach (var songItem in songList)&#xA;            {&#xA;                var song = new Song&#xA;                {&#xA;                    id = (string)songItem[&#34;songmid&#34;],&#xA;                    name = (string)songItem[&#34;title&#34;],&#xA;                    album = (string)songItem[&#34;album&#34;][&#34;name&#34;],&#xA;                    rate = 320,&#xA;                    index = index++,&#xA;                    size = (double)songItem[&#34;file&#34;][&#34;size_320mp3&#34;],&#xA;                    source = Name,&#xA;                    //singer = (string)songItem[&#34;author&#34;],&#xA;                    duration = (double)songItem[&#34;interval&#34;]&#xA;                };&#xA;                if (song.size == 0d)&#xA;                {&#xA;                    song.size = (double)songItem[&#34;file&#34;][&#34;size_128mp3&#34;];&#xA;                    song.rate = 128;&#xA;                }&#xA;                song.singer = &#34;&#34;;&#xA;                foreach (var ar in songItem[&#34;singer&#34;])&#xA;                {&#xA;                    song.singer += ar[&#34;name&#34;] + &#34; &#34;;&#xA;                }&#xA;                result.Add(song);&#xA;&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;最后获取下载地址，接口地址是&lt;code&gt;https://v1.itooi.cn/tencent/url?id=${id}&amp;amp;quality=[128,320,flac]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; public string getDownloadUrl(string id, string rate)&#xA;        {&#xA;            return HttpHelper.DetectLocationUrl(&#34;https://v1.itooi.cn/tencent/url?id=&#34; + id + &#34;&amp;amp;quality=&#34; + rate, DEFAULT_CONFIG);&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;这里要检测下真实url，递归检测302跳转：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; public static string DetectLocationUrl(string url, HttpConfig config)&#xA;        {&#xA;            if (config == null) config = new HttpConfig();&#xA;            using (HttpWebResponse response = GetResponse(url, &#34;GET&#34;, null, config))&#xA;            {&#xA;                string detectUrl =  response.GetResponseHeader(&#34;Location&#34;);&#xA;                if(detectUrl.Length == 0)&#xA;                {&#xA;                    return url;&#xA;                }&#xA;                // 递归获取&#xA;                return DetectLocationUrl(detectUrl, config);&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;缘起：&lt;/p&gt; &#xA;&lt;p&gt;一直用网易音乐听歌，但是诸如李健、周杰伦的不少歌曲，网易都没有版权，要从QQ等音乐去下载，因此一直想写一个小程序，可以从其他音乐网站下载相关歌曲，趁放假，花了几小时做了这样一个程序。&lt;/p&gt; &#xA;&lt;p&gt;BTW: 之前写过一个&lt;a href=&#34;https://github.com/jadepeng/musicDecryptor&#34;&gt;从酷狗和网易音乐提取缓存文件的程序&lt;/a&gt;，感兴趣的可以查看。&lt;/p&gt; &#xA;&lt;h2&gt;功能&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;聚合搜索多家音乐网站&lt;/li&gt; &#xA; &lt;li&gt;支持音乐批量下载&lt;/li&gt; &#xA; &lt;li&gt;搜索结果综合排序&lt;/li&gt; &#xA; &lt;li&gt;可以编写Provider程序，支持其他音乐网站&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;实现IMusicProvider即可，主要是搜索和获取下载链接的方法。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp?linenums&#34;&gt;    public interface IMusicProvider&#xA;    {&#xA;        string Name { get; }&#xA;&#xA;        string getDownloadUrl(Song song);&#xA;        List&amp;lt;Song&amp;gt; SearchSongs(string keyword, int page, int pageSize);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;界面截图&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://www.github.com/jadepeng/blogpic/raw/master/images/2019/1-25/1548431781568.png&#34; alt=&#34;预览&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;下载程序&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jadepeng/XMusicDownloader/releases&#34;&gt;https://github.com/jadepeng/XMusicDownloader/releases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;实现方案介绍&lt;/h2&gt; &#xA;&lt;h3&gt;定义song实体&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;public class Song&#xA;    {&#xA;        public string id { get; set; }&#xA;        public string name { get; set; }&#xA;        public string singer { get; set; }&#xA;        public string album { get; set; }&#xA;        public string source { get; set; }&#xA;        public double duration { get; set; }&#xA;        public double size { get; set; }&#xA;        public string url { get; set; }&#xA;        public int rate { get; set; }&#xA;        public int index { get; set; }&#xA;&#xA;        public string getFileName()&#xA;        {&#xA;            return singer + &#34;-&#34; + name + &#34;.mp3&#34;;&#xA;        }&#xA;&#xA;        public string getMergedKey()&#xA;        {&#xA;            return singer.Replace(&#34; &#34;, &#34;&#34;) + name.Replace(&#34; &#34;, &#34;&#34;);&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;封装各个音乐网站&lt;/h3&gt; &#xA;&lt;p&gt;抽象为MusicProvider，音乐提供方:)，定义Name为名称，SearchSongs搜索歌曲，getDownloadUrl获取音乐下载地址。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#xA;    public interface IMusicProvider&#xA;    {&#xA;        string Name { get; }&#xA;&#xA;        string getDownloadUrl(Song song);&#xA;        List&amp;lt;Song&amp;gt; SearchSongs(string keyword, int page, int pageSize);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;然后就是依次实现百度、网易等音乐网站，以QQ为例。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt; public class QQProvider : IMusicProvider&#xA;    {&#xA;        static HttpConfig DEFAULT_CONFIG = new HttpConfig&#xA;        {&#xA;            Referer = &#34;http://m.y.qq.com&#34;,&#xA;&#xA;        };&#xA;&#xA;        public string Name { get; } = &#34;QQ&#34;;&#xA;&#xA;        static string[] prefixes = new string[] { &#34;M800&#34;, &#34;M500&#34;, &#34;C400&#34; };&#xA;&#xA;        public List&amp;lt;Song&amp;gt; SearchSongs(string keyword,int page,int pageSize)&#xA;        {&#xA;            var searchResult = HttpHelper.GET(string.Format(&#34;http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&amp;amp;format=json&amp;amp;p={1}&amp;amp;n={2}&#34;, keyword, page,pageSize), DEFAULT_CONFIG);&#xA;            var searchResultJson = JsonParser.Deserialize(searchResult).data.song;&#xA;            var result = new List&amp;lt;Song&amp;gt;();&#xA;&#xA;            var index = 1;&#xA;            foreach(var songItem in searchResultJson.list)&#xA;            {&#xA;                var song = new Song&#xA;                {&#xA;                    id = songItem[&#34;songmid&#34;],&#xA;                    name = songItem[&#34;songname&#34;],&#xA;                    album = songItem[&#34;albumname&#34;],&#xA;                    rate = 128,&#xA;                    size = songItem[&#34;size128&#34;],&#xA;                    source = Name,&#xA;                    index = index++,&#xA;                    duration = songItem[&#34;interval&#34;]&#xA;                };&#xA;                song.singer = &#34;&#34;;&#xA;                foreach (var ar in songItem[&#34;singer&#34;])&#xA;                {&#xA;                    song.singer += ar[&#34;name&#34;] + &#34; &#34;;&#xA;                }&#xA;                result.Add(song);&#xA;            }&#xA;&#xA;            return result;&#xA;&#xA;        }&#xA;&#xA;        public string getDownloadUrl(Song song)&#xA;        {&#xA;            var guid = new Random().Next(1000000000, 2000000000);&#xA;&#xA;            var key = JsonParser.Deserialize(HttpHelper.GET(string.Format(&#34;http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&amp;amp;format=json&amp;amp;json=3&#34;,guid), DEFAULT_CONFIG)).key;&#xA;            foreach(var prefix in prefixes)&#xA;            {&#xA;               &#xA;                var musicUrl = string.Format(&#34;http://dl.stream.qqmusic.qq.com/{0}{1}.mp3?vkey={2}&amp;amp;guid={3}&amp;amp;fromtag=1&#34;, prefix, song.id, key, guid);&#xA;                if (HttpHelper.GetUrlContentLength(musicUrl) &amp;gt; 0)&#xA;                {&#xA;                    return musicUrl;&#xA;                }&#xA;            }&#xA;&#xA;            return null;&#xA;&#xA;        }&#xA;    &#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;搜索调用&lt;code&gt;http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&amp;amp;format=json&amp;amp;p={1}&amp;amp;n={2}&lt;/code&gt;接口，获取下载地址调用&lt;code&gt;http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&amp;amp;format=json&amp;amp;json=3&lt;/code&gt;,然后再组合。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;聚合搜索&lt;/h3&gt; &#xA;&lt;p&gt;设计一个MusicProviders，加载所有的IMusicProvider，提供一个SearchSongs方法，并发调用各个网站的搜索，然后merge到一起。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;&#xA;  public List&amp;lt;MergedSong&amp;gt; SearchSongs(string keyword, int page, int pageSize)&#xA;        {&#xA;            var songs = new List&amp;lt;Song&amp;gt;();&#xA;            Providers.AsParallel().ForAll(provider =&amp;gt;&#xA;            {&#xA;                var currentSongs = provider.SearchSongs(keyword, page, pageSize);&#xA;                songs.AddRange(currentSongs);&#xA;            });&#xA;&#xA;            // merge&#xA;&#xA;            return songs.GroupBy(s =&amp;gt; s.getMergedKey()).Select(g =&amp;gt; new MergedSong(g.ToList())).OrderByDescending(s =&amp;gt; s.score).ToList();&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;关于merge，核心就是将相同的歌曲合并到一起，我们暂且认为歌手+歌曲名相同的为同一首歌曲：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp?linenums&#34;&gt;   public string getMergedKey()&#xA;        {&#xA;            return singer.Replace(&#34; &#34;, &#34;&#34;) + name.Replace(&#34; &#34;, &#34;&#34;);&#xA;        }&#xA;&#x9;&#x9;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;因此按megekey分组，就能实现聚合。我们设计一个&lt;code&gt;MergedSong&lt;/code&gt;来包裹。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MergedSong&#xA;    {&#xA;        public List&amp;lt;Song&amp;gt; items&#xA;        {&#xA;            get; set;&#xA;        }&#xA;&#xA;        public MergedSong(List&amp;lt;Song&amp;gt; items)&#xA;        {&#xA;            this.items = items;&#xA;        }&#xA;&#xA;        public string name&#xA;        {&#xA;            get&#xA;            {&#xA;                return this.items[0].name;&#xA;            }&#xA;        }&#xA;        public string singer&#xA;        {&#xA;            get&#xA;            {&#xA;                return this.items[0].singer;&#xA;            }&#xA;        }&#xA;        public string album&#xA;        {&#xA;            get&#xA;            {&#xA;                return this.items[0].album;&#xA;            }&#xA;        }&#xA;&#xA;        public string source&#xA;        {&#xA;            get&#xA;            {&#xA;                return string.Join(&#34;,&#34;, this.items.Select(i =&amp;gt; i.source).ToArray());&#xA;            }&#xA;        }&#xA;&#xA;&#xA;        public double duration&#xA;        {&#xA;            get&#xA;            {&#xA;                return this.items[0].duration;&#xA;            }&#xA;        }&#xA;&#xA;        public double size&#xA;        {&#xA;            get&#xA;            {&#xA;                return this.items[0].size;&#xA;            }&#xA;        }&#xA;&#xA;        public double rate&#xA;        {&#xA;            get&#xA;            {&#xA;                return this.items[0].rate;&#xA;            }&#xA;        }&#xA;&#xA;&#xA;        public double score&#xA;        {&#xA;            get&#xA;            {&#xA;                // 投票+排序加权  (各50%）&#xA;                return this.items.Count / (MusicProviders.Instance.Providers.Count - 1) + (20 - this.items.Average(i =&amp;gt; i.index)) / 20;&#xA;            }&#xA;        }&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MergedSong的核心是定义了一个score，我们通过投票+搜索结果排序，用来决定合并结果的排序。&lt;/p&gt; &#xA;&lt;h3&gt;下载&lt;/h3&gt; &#xA;&lt;p&gt;下载主要是通过provider获取真实url，然后下载即可。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp?linenums&#34;&gt;public class SongItemDownloader&#xA;    {&#xA;        MusicProviders musicProviders;&#xA;        string target;&#xA;        MergedSong song;&#xA;&#xA;        public event DownloadFinishEvent DownloadFinish;&#xA;&#xA;        public SongItemDownloader(MusicProviders musicProviders, string target, MergedSong song)&#xA;        {&#xA;            this.musicProviders = musicProviders;&#xA;            this.target = target;&#xA;            this.song = song;&#xA;        }&#xA;&#xA;        public long totalBytes;&#xA;&#xA;        public long bytesReceived;&#xA;&#xA;        public double ReceiveProgress;&#xA;&#xA;&#xA;        public double receiveSpeed;&#xA;&#xA;        DateTime lastTime = DateTime.Now;&#xA;&#xA;        public void Download()&#xA;        {&#xA;            WebClient client = new WebClient();&#xA;            client.DownloadProgressChanged += Client_DownloadProgressChanged;&#xA;            new Thread(() =&amp;gt;&#xA;            {&#xA;                // 多来源，防止单个来源出错&#xA;                foreach (var item in song.items)&#xA;                {&#xA;                    try&#xA;                    {&#xA;                        client.DownloadFile(musicProviders.getDownloadUrl(item), target + &#34;\\&#34; + item.getFileName());&#xA;                        DownloadFinish?.Invoke(this, this);&#xA;                        break;&#xA;&#xA;                    }&#xA;                    catch&#xA;                    {&#xA;                    }&#xA;                }&#xA;&#xA;            }).Start();&#xA;        }&#xA;&#xA;        private void Client_DownloadProgressChanged(object sender, DownloadEventArgs e)&#xA;        {&#xA;            this.bytesReceived = e.bytesReceived;&#xA;            this.totalBytes = e.totalBytes;&#xA;            this.receiveSpeed = e.receiveSpeed;&#xA;            this.ReceiveProgress = e.ReceiveProgress;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;参考&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;程序界面，使用了 &lt;a href=&#34;https://github.com/Gsangu/KugouDownloader&#34;&gt;https://github.com/Gsangu/KugouDownloader&lt;/a&gt; 代码&lt;/li&gt; &#xA; &lt;li&gt;搜索和下载方案参考 &lt;a href=&#34;https://github.com/0xHJK/music-dl&#34;&gt;https://github.com/0xHJK/music-dl&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>microsoft/scalar</title>
    <updated>2022-10-07T01:32:28Z</updated>
    <id>tag:github.com,2022-10-07:/microsoft/scalar</id>
    <link href="https://github.com/microsoft/scalar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scalar: A set of tools and extensions for Git to allow very large monorepos to run on Git without a virtualization layer&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/microsoft/scalar/main/Images/scalar-card.png&#34; alt=&#34;Scalar&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is Scalar?&lt;/h2&gt; &#xA;&lt;p&gt;Scalar is a tool that helps Git scale to some of the largest Git repositories. It achieves this by enabling some advanced Git features, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Partial clone:&lt;/em&gt; reduces time to get a working repository by not downloading all Git objects right away.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Background prefetch:&lt;/em&gt; downloads Git object data from all remotes every hour, reducing the amount of time for foreground &lt;code&gt;git fetch&lt;/code&gt; calls.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Sparse-checkout:&lt;/em&gt; limits the size of your working directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;File system monitor:&lt;/em&gt; tracks the recently modified files and eliminates the need for Git to scan the entire worktree.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Commit-graph:&lt;/em&gt; accelerates commit walks and reachability calculations, speeding up commands like &lt;code&gt;git log&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Multi-pack-index:&lt;/em&gt; enables fast object lookups across many pack-files.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Incremental repack:&lt;/em&gt; Repacks the packed Git data into fewer pack-file without disrupting concurrent commands by using the multi-pack-index.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As new versions of Git are released, we update the list of features that Scalar automatically configures. This reduces your effort to keep your repositories as efficient as possible.&lt;/p&gt; &#xA;&lt;h2&gt;Scalar has moved!&lt;/h2&gt; &#xA;&lt;p&gt;Through significant effort from our team, we have successfully transitioned Scalar from a modified version of &lt;a href=&#34;https://github.com/microsoft/vfsforgit&#34;&gt;VFS for Git&lt;/a&gt; into a thin shell around core Git features. The Scalar executable has now been ported to be included &lt;a href=&#34;https://github.com/microsoft/git&#34;&gt;in the &lt;code&gt;microsoft/git&lt;/code&gt; fork&lt;/a&gt;. Please visit that fork for all of your Scalar needs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download &lt;a href=&#34;https://github.com/microsoft/git/releases&#34;&gt;the latest &lt;code&gt;microsoft/git&lt;/code&gt; release&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Read &lt;a href=&#34;https://github.com/microsoft/git/raw/HEAD/contrib/scalar/docs/index.md&#34;&gt;the Scalar documentation&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Contribute changes &lt;a href=&#34;https://github.com/microsoft/git/raw/HEAD/contrib/scalar/scalar.c&#34;&gt;to the &lt;code&gt;scalar&lt;/code&gt; CLI&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Why did Scalar move?&lt;/h3&gt; &#xA;&lt;p&gt;Scalar started as a modification of &lt;a href=&#34;https://github.com/microsoft/vfsforgit&#34;&gt;VFS for Git&lt;/a&gt; to create a working solution with a robust test suite in a short amount of time. The goal was to depend more on features that exist within Git itself instead of creating new functionality within this project. Since the start, we have focused on this goal with efforts such as &lt;a href=&#34;https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/&#34;&gt;improving sparse-checkout performance in Git&lt;/a&gt;, &lt;a href=&#34;https://github.blog/2021-03-15-highlights-from-git-2-31/#introducing-git-maintenance&#34;&gt;implementing background maintenance in Git&lt;/a&gt;, and &lt;a href=&#34;https://github.com/microsoft/scalar/pull/122&#34;&gt;integrating the GVFS protocol into &lt;code&gt;microsoft/git&lt;/code&gt;&lt;/a&gt; which allowed us to &lt;a href=&#34;https://github.com/microsoft/scalar/pull/222&#34;&gt;drop the &lt;code&gt;Scalar.Mount&lt;/code&gt; process&lt;/a&gt;. All of these changes reduced the size of the code in Scalar itself until it could be replaced &lt;a href=&#34;https://github.com/microsoft/git/raw/HEAD/contrib/scalar/scalar.c&#34;&gt;with a small command-line interface&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additional benefits to this change include making our release and installation mechanism much simpler. Users now only need to install one tool, not multiple, to take advantage of all of the benefits.&lt;/p&gt; &#xA;&lt;h3&gt;What remains in this repository?&lt;/h3&gt; &#xA;&lt;p&gt;We are keeping the &lt;code&gt;microsoft/scalar&lt;/code&gt; repository available since we have linked to it and want to make sure those links continue to work. We added pointers in several places to navigate readers to the &lt;code&gt;microsoft/git&lt;/code&gt; repository for the latest versions.&lt;/p&gt; &#xA;&lt;p&gt;We also have a large set of functional tests that verify that Scalar enlistments continue to work in a variety of advanced Git scenarios. These tests are incredibly helpful as we advance features in &lt;code&gt;microsoft/git&lt;/code&gt;, so those tests remain in this repository. We run them as part of pull request validation in &lt;code&gt;microsoft/git&lt;/code&gt;, so no changes are made there without passing this suite of tests.&lt;/p&gt; &#xA;&lt;h3&gt;What if I already installed Scalar and want the new version?&lt;/h3&gt; &#xA;&lt;p&gt;We are working to ensure that users on the .NET version of Scalar have a painless experience while changing to the new version.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;On Windows, users can &lt;a href=&#34;https://github.com/microsoft/git#windows&#34;&gt;install &lt;code&gt;microsoft/git&lt;/code&gt;&lt;/a&gt; and the installer will remove the .NET version and update any registered enlistments to work with the new version.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;On macOS, users should run &lt;code&gt;brew uninstall --cask scalar&lt;/code&gt; or &lt;code&gt;brew uninstall --cask scalar-azrepos&lt;/code&gt; depending on their version and then run &lt;code&gt;brew install --cask microsoft-git&lt;/code&gt; to get the new version. At the moment, users on macOS will need to re-run &lt;code&gt;scalar register&lt;/code&gt; on their enlistments to ensure they are registered for future upgrades.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;On Linux, there is no established uninstall mechanism, but the .NET version can be removed via &lt;code&gt;sudo rm -rf /usr/local/lib/scalar/&lt;/code&gt;. Installing the new version will overwrite the &lt;code&gt;scalar&lt;/code&gt; binary in &lt;code&gt;/usr/local/bin&lt;/code&gt;. At the moment, users on Linux will need to re-run &lt;code&gt;scalar register&lt;/code&gt; on their enlistments to ensure they are registered for future upgrades.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can check if the new Scalar version is installed correctly by running &lt;code&gt;scalar version&lt;/code&gt; which should have the same output as &lt;code&gt;git version&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The Scalar source code in this repo is available under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/scalar/main/License.md&#34;&gt;License.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;. For more information see the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/faq/&#34;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:opencode@microsoft.com&#34;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt;</summary>
  </entry>
</feed>