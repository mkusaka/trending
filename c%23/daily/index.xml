<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-15T01:31:22Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>vullabs/Crassus</title>
    <updated>2023-01-15T01:31:22Z</updated>
    <id>tag:github.com,2023-01-15:/vullabs/Crassus</id>
    <link href="https://github.com/vullabs/Crassus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Crassus Windows privilege escalation discovery tool&lt;/h1&gt; &#xA;&lt;h1&gt;Quick start&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;Process Monitor&lt;/a&gt;, select the &lt;code&gt;Enable Boot Logging&lt;/code&gt; option. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/procmon_boot_log.png&#34; alt=&#34;&amp;quot;Process Monitor Boot Logging option&amp;quot;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Reboot.&lt;/li&gt; &#xA; &lt;li&gt;Once you have logged in and Windows has settled, run Process Monitor once again.&lt;/li&gt; &#xA; &lt;li&gt;When prompted, save the boot log, e.g., to &lt;code&gt;raw.PML&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Reset the default Process Monitor filter using &lt;code&gt;Ctrl-R&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Save this log file, e.g., to &lt;code&gt;boot.PML&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;Crassus.exe boot.PML&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Investigate any green colored results and the corresponding entries in &lt;code&gt;results.csv&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#why-crassus&#34;&gt;Why &#34;Crassus&#34;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#did-you-really-make-yet-another-privilege-escalation-discovery-tool&#34;&gt;Did you really make yet another privilege escalation discovery tool?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#screenshots&#34;&gt;Screenshots&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#Crassus-execution&#34;&gt;Crassus Execution&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#csv-output&#34;&gt;CSV Output&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#output-exports&#34;&gt;Exports&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#export-dll-functions&#34;&gt;Export DLL Functions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#export-dll-ordinals&#34;&gt;Export DLL Ordinals&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#getting-crassusexe&#34;&gt;Getting Crassus.exe&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#building-with-visual-studio&#34;&gt;Building with Visual studio&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#using-precompiled-crassusexe&#34;&gt;Using precompiled Crassus.exe&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#execution-flow&#34;&gt;Execution Flow&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#command-line-arguments&#34;&gt;Command Line Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#proxy-dll-template&#34;&gt;Proxy DLL Template&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#openssl-template&#34;&gt;openssl.cnf Template&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#compiling-proxy-dlls&#34;&gt;Compiling Proxy DLLs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#visual-studio&#34;&gt;Visual Studio&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#mingw&#34;&gt;MinGW&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#real-world-examples&#34;&gt;Real World Examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#acronis-true-image&#34;&gt;Acronis True Image&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#atlassian-bitbucket&#34;&gt;Atlassian Bitbucket&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#mcafee&#34;&gt;McAfee&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#microsoft-sql-server-2022&#34;&gt;Microsoft SQL Server 2022&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#missing-file-not-executed&#34;&gt;Missing files not loaded&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#code-executed-with-unexpected-privileges&#34;&gt;Code executed with unexpected privileges&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#findings-disappear-on-reboot&#34;&gt;Findings disappear on reboot&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#contributions&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Why &#34;Crassus&#34;?&lt;/h1&gt; &#xA;&lt;p&gt;Accenture made a tool called &lt;a href=&#34;https://github.com/Accenture/Spartacus&#34;&gt;Spartacus&lt;/a&gt;, which finds DLL hijacking opportunities on Windows. Using Spartacus as a starting point, we created Crassus to extend Windows privilege escalation finding capabilities beyond simply looking for missing files. The ACLs used by files and directories of privileged processes can find more than just &lt;a href=&#34;https://vuls.cert.org/confluence/display/Wiki/2021/06/21/Finding+Privilege+Escalation+Vulnerabilities+in+Windows+using+Process+Monitor&#34;&gt;looking for missing files&lt;/a&gt; to achieve the goal.&lt;/p&gt; &#xA;&lt;h2&gt;Did you really make yet another privilege escalation discovery tool?&lt;/h2&gt; &#xA;&lt;p&gt;...but with a twist as Crassus is utilizing the &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;SysInternals Process Monitor&lt;/a&gt; and is parsing raw PML log files. Typical usage is to generate a boot log using Process Monitor and then parse it with Crassus. It will also automatically generate source code for proxy DLLs with all relevant exports for vulnerable DLLs.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Parsing ProcMon PML files natively. The log (PML) parser has been implemented by porting partial functionality to C# from &lt;a href=&#34;https://github.com/eronnen/procmon-parser/&#34;&gt;https://github.com/eronnen/procmon-parser/&lt;/a&gt;. You can find the format specification &lt;a href=&#34;https://github.com/eronnen/procmon-parser/tree/master/docs&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Crassus will create source code for proxy DLLs for all missing DLLs that were identified. For instance, if an application is vulnerable to DLL Hijacking via &lt;code&gt;version.dll&lt;/code&gt;, Crassus will create &lt;code&gt;version.cpp&lt;/code&gt; and &lt;code&gt;version.def&lt;/code&gt; files for you with all the exports included in it. By default the proxy DLLs will launch &lt;code&gt;calc.exe&lt;/code&gt;. Build scripts are included to build the DLLs on Visual Studio or MinGW.&lt;/li&gt; &#xA; &lt;li&gt;For other events of interest, such as creating a process or loading a library, the ability for unprivileged users to modify the file or any parts of the path to the file is investigated.&lt;/li&gt; &#xA; &lt;li&gt;Able to process large PML files and store all events of interest in an output CSV file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Screenshots&lt;/h1&gt; &#xA;&lt;h2&gt;Crassus Execution&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/runtime.png&#34; alt=&#34;Running Crassus&#34; title=&#34;Running Crassus&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CSV Output&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/output.png&#34; alt=&#34;CSV Output&#34; title=&#34;CSV Output&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Output Exports&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/exports.png&#34; alt=&#34;Exports&#34; title=&#34;Exports&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Export DLL Functions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/exports-version.png&#34; alt=&#34;DLL Functions&#34; title=&#34;DLL Functions&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Export DLL Ordinals&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/exports-def.png&#34; alt=&#34;DLL Ordinals&#34; title=&#34;DLL Ordinals&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Getting Crassus.exe&lt;/h1&gt; &#xA;&lt;h2&gt;Building with Visual Studio&lt;/h2&gt; &#xA;&lt;p&gt;Crassus was developed as a Visual Studio 2019 project. To build &lt;code&gt;Crassus.exe&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open &lt;code&gt;Crassus.sln&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Press &lt;code&gt;Ctrl+Shift+B&lt;/code&gt; on your keyboard&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Using precompiled Crassus.exe&lt;/h2&gt; &#xA;&lt;p&gt;If you trust running other people&#39;s code without knowing what it does, &lt;code&gt;Crassus.exe&lt;/code&gt; is &lt;a href=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/binaries/Crassus.exe&#34;&gt;provided in this repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;Execution Flow&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;Process Monitor&lt;/a&gt;, select the &lt;code&gt;Enable Boot Logging&lt;/code&gt; option. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/procmon_boot_log.png&#34; alt=&#34;&amp;quot;Process Monitor Boot Logging option&amp;quot;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Reboot.&lt;/li&gt; &#xA; &lt;li&gt;Once you have logged in and Windows has settled, optionally also run &lt;a href=&#34;https://gist.github.com/wdormann/8afe4edf605627ee4f203861b6cc3a1c&#34;&gt;scheduled tasks that may be configured to run with privileges&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run Process Monitor once again.&lt;/li&gt; &#xA; &lt;li&gt;When prompted, save the boot log.&lt;/li&gt; &#xA; &lt;li&gt;Reset the default Process Monitor filter using &lt;code&gt;Ctrl-R&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Save this log file, e.g., to &lt;code&gt;boot.PML&lt;/code&gt;. The reason for re-saving the log file is twofold: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Older versions of Process Monitor do not save boot logs as a single file.&lt;/li&gt; &#xA;   &lt;li&gt;Boot logs by default will be unfiltered, which may contain extra noise, such as a local-user DLL hijacking in the launching of of Process Monitor itself.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Command Line Arguments&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Argument&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&amp;lt;PMLFILE&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Location (file) of the existing ProcMon event log file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--verbose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable verbose output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--debug&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable debug output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Parse the Process Monitor boot log saved in &lt;code&gt;boot.PML&lt;/code&gt;. All vulnerable paths will be saved as &lt;code&gt;results.csv&lt;/code&gt; and all proxy DLL source files in the &lt;code&gt;stubs&lt;/code&gt; subdirectory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\tmp&amp;gt; Crassus.exe boot.PML&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Proxy DLL Template&lt;/h2&gt; &#xA;&lt;p&gt;Below is the template that is used when generating proxy DLLs., For DLLs that are found by Crassus, the proxy DLL will contain the same export names as specified in &lt;code&gt;%_EXPORTS_%&lt;/code&gt;, as well as the same ordinals as specified in the &lt;code&gt;.def&lt;/code&gt; file. Crassus will detect whether the DLL needs to be built as a 32-bit library or a 64-bit library by looking at the architecture of the parent process, and tagging the source code in the &lt;code&gt;%_BUILD_AS_%&lt;/code&gt; field accordingly.&lt;/p&gt; &#xA;&lt;p&gt;If the real DLL cannot be found using the Process Monitor log, or if the export name is problematic, the build scripts will fall back to creating a DLL without specified exports.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once&#xA;    &#xA;//%_BUILD_AS%&#xA;&#xA;#include &amp;lt;windows.h&amp;gt;;&#xA;&#xA;extern &#34;C&#34; {&#xA;&#xA;  VOID Payload() {&#xA;      // Run your payload here.&#xA;      WinExec(&#34;calc.exe&#34;, 1);&#xA;  }&#xA;&#xA;  BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)&#xA;  {&#xA;      switch (fdwReason)&#xA;      {&#xA;      case DLL_PROCESS_ATTACH:&#xA;          Payload();&#xA;          break;&#xA;      case DLL_THREAD_ATTACH:&#xA;          break;&#xA;      case DLL_THREAD_DETACH:&#xA;          break;&#xA;      case DLL_PROCESS_DETACH:&#xA;          break;&#xA;      }&#xA;      return TRUE;&#xA;  }&#xA;&#xA;&#xA;  #ifdef ADD_EXPORTS&#xA;  %_EXPORTS_%&#xA;  #endif&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;openssl.cnf Template&lt;/h2&gt; &#xA;&lt;p&gt;For applications that unsafely use the &lt;code&gt;OPENSSLDIR&lt;/code&gt; variable value, a crafted &lt;code&gt;openssl.cnf&lt;/code&gt; file can be placed in the noted location. For this example, the software will load &lt;code&gt;C:\tmp\calc.dll&lt;/code&gt;. Be sure to use a 32-bit library to target 32-bit processes, and a 64-bit library to target 64-bit processes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-openssl_conf&#34;&gt;[openssl_init]&#xA;# This will attempt to load the file c:\tmp\calc.dll as part of OpenSSL initialization&#xA;# Build scripts should detect whether the calc.dll library needs to be built as 32-bit or 64-bit&#xA;/tmp/calc = asdf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Compiling Proxy DLLs&lt;/h1&gt; &#xA;&lt;h2&gt;Visual Studio&lt;/h2&gt; &#xA;&lt;p&gt;Compilation is possible using the &lt;code&gt;cl.exe&lt;/code&gt; binary included with Visual Studio. Specifically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cl.exe /DADD_EXPORTS /D_USRDLL /D_WINDLL &amp;lt;target&amp;gt;.cpp /LD /Fe&amp;lt;target&amp;gt;.dll /link /DEF:&amp;lt;target&amp;gt;.def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To automate the build process, including specifying whether the library should be 64-bit or 32-bit:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open the Visual Studio Developer Command Prompt.&lt;/li&gt; &#xA; &lt;li&gt;Build the DLLs with the &lt;code&gt;build.bat&lt;/code&gt; script.&lt;/li&gt; &#xA; &lt;li&gt;Rename the compiled file as necessary if the vulnerable file name ends with something other than &lt;code&gt;.dll&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Due to an unfortunate behavior with &lt;code&gt;vcvarsall.bat&lt;/code&gt;, which is &lt;a href=&#34;https://developercommunity.visualstudio.com/t/vcvarsallbat-reports-the-input-line-is-too-long-if/257260#T-N258712&#34;&gt;definitely not a bug&lt;/a&gt;, you may encounter trouble attempting to run &lt;code&gt;build.bat&lt;/code&gt; more than once in the same Visual Studio Developer Command Prompt session. If you encounter an error, simply close the window and launch it again.&lt;/p&gt; &#xA;&lt;h2&gt;MinGW&lt;/h2&gt; &#xA;&lt;p&gt;If Visual Studio isn&#39;t readily available, proxy DLLs can be compiled with &lt;a href=&#34;https://www.mingw-w64.org/&#34;&gt;MinGW-w64&lt;/a&gt; instead. On an Ubuntu platform for example, MinGW can be installed via the following: &lt;code&gt;sudo apt install g++-mingw-w64-x86-64-win32 g++-mingw-w64-i686-win32&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Create a 32-bit DLL&#xA;i686-w64-mingw32-g++ -c -o &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.cpp -D ADD_EXPORTS&#xA;i686-w64-mingw32-g++ -o &amp;lt;target&amp;gt;.dll &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.def -s -shared -Wl,--subsystem,windows&#xA;&#xA;# Create a 64-bit DLL&#xA;x86_64-w64-mingw32-g++ -c -o &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.cpp -D ADD_EXPORTS&#xA;x86_64-w64-mingw32-g++ -o &amp;lt;target&amp;gt;.dll &amp;lt;target&amp;gt;.o &amp;lt;target&amp;gt;.def -s -shared -Wl,--subsystem,windows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To automate the build process, including specifying whether the library should be 64-bit or 32-bit:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open a terminal.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;bash ./build.sh&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Rename the compiled file as necessary if the vulnerable file name ends with something other than &lt;code&gt;.dll&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Real World Examples&lt;/h1&gt; &#xA;&lt;h2&gt;Acronis True Image&lt;/h2&gt; &#xA;&lt;h3&gt;Crassus Analysis&lt;/h3&gt; &#xA;&lt;p&gt;As outlined in &lt;a href=&#34;https://kb.cert.org/vuls/id/114757&#34;&gt;VU#114757&lt;/a&gt;, older Acronis software contains multiple privilege escalation vulnerabilities.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Placement of &lt;code&gt;openssl.cnf&lt;/code&gt; in a unprivileged-user-creatable location.&lt;/li&gt; &#xA; &lt;li&gt;Inappropriate ACLs in the &lt;code&gt;C:\ProgramData\Acronis&lt;/code&gt; directory.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Crassus finds both of these issues automatically. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/acronis.png&#34; alt=&#34;Crassus output for Acronis&#34; title=&#34;Crassus output for Acronis&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;DLL Hijacking&lt;/h3&gt; &#xA;&lt;p&gt;By planting our compiled &lt;code&gt;curl.dll&lt;/code&gt; file in the &lt;code&gt;C:\ProgramData\Acronis\Agent\var\atp-downloader\&lt;/code&gt; directory and rebooting with a new Process Monitor boot log we can see that our payload that runs calc.exe runs, with SYSTEM privileges. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/acronis_planted.png&#34; alt=&#34;&amp;quot;Process Monitor log of planted curl.dll&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;openssl.cnf Placement&lt;/h3&gt; &#xA;&lt;p&gt;The vulnerable Acronis software attempts to load &lt;code&gt;openssl.cnf&lt;/code&gt; from two different locations. We&#39;ll place our template &lt;code&gt;openssl.cnf&lt;/code&gt; file in &lt;code&gt;c:\jenkins_agent\workspace\tp-openssl-win-vs2013\17\product\out\standard\vs_2013_release\openssl\ssl&lt;/code&gt;, and a 32-bit &lt;code&gt;calc.dll&lt;/code&gt; payload in &lt;code&gt;c:\tmp&lt;/code&gt;. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/acronis_openssl.png&#34; alt=&#34;&amp;quot;Process Monitor log of planted openssl.cnf&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Atlassian Bitbucket&lt;/h2&gt; &#xA;&lt;h3&gt;Crassus Analysis&lt;/h3&gt; &#xA;&lt;p&gt;As outlined in &lt;a href=&#34;https://kb.cert.org/vuls/id/240785&#34;&gt;VU#240785&lt;/a&gt;, older Atlassian Bitbucket software is vulnerable to privilege escalation due to weak ACLs of the installation directory. As with any Windows software that installs to a location outside of &lt;code&gt;C:\Program Files\&lt;/code&gt; or other ACL-restricted locations, it is up to the software installer to explicitly set ACLs on the target directory.&lt;/p&gt; &#xA;&lt;p&gt;Crassus finds many ways to achieve privilege escalation with this software, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Placement of missing DLLs in user-writable locations.&lt;/li&gt; &#xA; &lt;li&gt;Placement of missing EXEs in user-writable locations.&lt;/li&gt; &#xA; &lt;li&gt;Renaming the directory of a privileged EXE to allow user placement of an EXE of the same name.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/bitbucket.png&#34; alt=&#34;Crassus output for Atlassian Bitbucket&#34; title=&#34;Crassus output for Atlassian Bitbucket&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;EXE Hijacking&lt;/h3&gt; &#xA;&lt;p&gt;In the Crassus output, we can see that &lt;code&gt;c:\atlassian\bitbucket\7.9.1\elasticsearch\bin\elasticsearch-service-x64.exe&lt;/code&gt; is privileged, but since it&#39;s running we cannot simply replace it. However, we can use another trick to hijack it. We may be able to simply rename the directory that it lives in, create a new directory of the same name, and plant our payload there as the same name. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/bitbucket_rename_dir.png&#34; alt=&#34;&amp;quot;Rename the directory that a privileged process is running from&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once we reboot with a Process monitor boot log, we can see that our planted &lt;code&gt;elasticsearch-service-x64.exe&lt;/code&gt; file is running instead of the real one, based on the Windows Calculator icon. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/elasticsearch_planted.png&#34; alt=&#34;&amp;quot;Planted calc.exe as elasticsearch-service-x64.exe&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;McAfee&lt;/h2&gt; &#xA;&lt;p&gt;As outlined in &lt;a href=&#34;https://kb.cert.org/vuls/id/287178&#34;&gt;VU#287178&lt;/a&gt;, older versions of McAfee software are vulnerable to privilege escalation via &lt;code&gt;openssl.cnf&lt;/code&gt;. Let&#39;s have a look: &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/mcafee.png&#34; alt=&#34;Crassus output for Mcafee&#34; title=&#34;Crassus output for McAfee&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To see why there are two different references to &lt;code&gt;openssl.cnf&lt;/code&gt; in this boot log, we can refer to the &lt;code&gt;results.csv&lt;/code&gt; file: &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/mcafee_results.png&#34; alt=&#34;results.csv for Mcafee&#34; title=&#34;results.csv for McAfee&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that the loading of the &lt;code&gt;openssl.cnf&lt;/code&gt; file from the &lt;code&gt;D:\&lt;/code&gt; path will require further manual investigation, as the feasibility of loading such a path depends on the platform in question, and what access to the system is available. It may be possible to create an optical disk that provides an &lt;code&gt;openssl.cnf&lt;/code&gt; file that also refers to a path that resolves to the optical drive as well.&lt;/p&gt; &#xA;&lt;h2&gt;Microsoft SQL Server 2022&lt;/h2&gt; &#xA;&lt;p&gt;SQL Server 2022 isn&#39;t obviously vulnerable to privilege escalation due to weak ACLs &lt;strong&gt;unless&lt;/strong&gt; it is installed to a non-standard location. If it is installed to a location outside of &lt;code&gt;C:\Program Files&lt;/code&gt;, Crassus will uncover several possibilities for privilege escalation. Most Windows applications that include a privileged component appear to be exploitable in this manner if they are installed to a directory that doesn&#39;t already have inherently secure ACLs. &lt;img src=&#34;https://raw.githubusercontent.com/vullabs/Crassus/main/screenshots/sqlserver2022.png&#34; alt=&#34;&amp;quot;Microsoft SQL Server 2022 installed to an insecure directory&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Troubleshooting&lt;/h1&gt; &#xA;&lt;h2&gt;Missing file not executed&lt;/h2&gt; &#xA;&lt;p&gt;If Crassus reports the privileged loading of a file that a user can plant or modify, this doesn&#39;t necessarily mean that it&#39;s an exploitable scenario. While Crassus looks for &lt;strong&gt;potentially&lt;/strong&gt; interesting file types, a Process Monitor log file will not directly indicate what the associated process &lt;strong&gt;would have&lt;/strong&gt; done with the file with it if it were there. It could be as simple as extracting a program icon. Investigating the call stack of the file operation in Process Monitor may give a hint as to what would have been done. Or simply place the file and investigate the behavior with a new Process Monitor boot log, if you prefer the easier brute force path.&lt;/p&gt; &#xA;&lt;h2&gt;Code executed with unexpected privileges&lt;/h2&gt; &#xA;&lt;p&gt;Crassus will look for privileged file operations to discover paths of interest. You may encounter a scenario where both a privileged and an unprivileged process access a path, but only the non-privileged process is the one that does the execution of what may be present.&lt;/p&gt; &#xA;&lt;h2&gt;Findings disappear on reboot&lt;/h2&gt; &#xA;&lt;p&gt;Especially when installing software for the first time, or when installing updates, Process Monitor may log a file operation that looks to be exploitable but does not occur every time that the system boots. Exploiting these operations may be possible on the first reboot after such an event happens. To avoid such edge cases, confirm that subsequent boot logs contain the same reported file operations on subsequent reboots.&lt;/p&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;Whether it&#39;s a typo, a bug, or a new feature, Crassus is very open to contributions as long as we agree on the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You are OK with the MIT license of this project.&lt;/li&gt; &#xA; &lt;li&gt;Before creating a pull request, create an issue so it could be discussed before doing any work as internal development is not tracked via the public GitHub repository. Otherwise, you risk having a pull request rejected if for example we are already working on the same/similar feature, or for any other reason.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eronnen/procmon-parser/&#34;&gt;https://github.com/eronnen/procmon-parser/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>riok/mapperly</title>
    <updated>2023-01-15T01:31:22Z</updated>
    <id>tag:github.com,2023-01-15:/riok/mapperly</id>
    <link href="https://github.com/riok/mapperly" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A .NET source generator for generating object mappings. No runtime reflection. Inspired by MapStruct.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mapperly&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/Riok.Mapperly/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Riok.Mapperly?style=flat-square&#34; alt=&#34;Nuget&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Riok.Mapperly/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/Riok.Mapperly?style=flat-square&amp;amp;label=nuget%20preview&#34; alt=&#34;Nuget Preview&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/riok/mapperly/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/riok/mapperly?style=flat-square&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Riok.Mapperly/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/riok.mapperly?style=flat-square&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/riok/mapperly&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/-source-181717.svg?logo=GitHub&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Mapperly is a .NET source generator for generating object mappings. Inspired by MapStruct.&lt;/p&gt; &#xA;&lt;p&gt;Because Mapperly creates the mapping code at build time, there is minimal overhead at runtime. Even better, the generated code is perfectly readable, allowing you to verify the generated mapping code easily.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The documentation is available &lt;a href=&#34;https://mapperly.riok.app/docs/getting-started/installation&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Add the NuGet Package to your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package Riok.Mapperly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Create your first mapper&lt;/h3&gt; &#xA;&lt;p&gt;Create a mapper declaration as a partial class and apply the &lt;code&gt;Riok.Mapperly.Abstractions.MapperAttribute&lt;/code&gt; attribute. Mapperly generates mapping method implementations for the defined mapping methods in the mapper.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;// Mapper declaration&#xA;[Mapper]&#xA;public partial class CarMapper&#xA;{&#xA;    public partial CarDto CarToCarDto(Car car);&#xA;}&#xA;&#xA;// Mapper usage&#xA;var mapper = new CarMapper();&#xA;var car = new Car { NumberOfSeats = 10, ... };&#xA;var dto = mapper.CarToCarDto(car);&#xA;dto.NumberOfSeats.Should().Be(10);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mapperly.riok.app/docs/getting-started/installation&#34;&gt;Read the docs&lt;/a&gt; for any further information.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Mapperly is &lt;a href=&#34;https://github.com/riok/mapperly/raw/main/LICENSE&#34;&gt;Apache 2.0&lt;/a&gt; licensed.&lt;/p&gt;</summary>
  </entry>
</feed>