<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-03T01:34:12Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Redth/ZXing.Net.Maui</title>
    <updated>2022-09-03T01:34:12Z</updated>
    <id>tag:github.com,2022-09-03:/Redth/ZXing.Net.Maui</id>
    <link href="https://github.com/Redth/ZXing.Net.Maui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Barcode Scanning for MAUI?&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZXing.Net.MAUI&lt;/h1&gt; &#xA;&lt;p&gt;The successor to ZXing.Net.Mobile: barcode scanning and generation for .NET MAUI applications&lt;/p&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/271950/129272315-b3f5a468-c585-49f2-bbab-68a884618b94.png&#34; width=&#34;300&#34;&gt; &#xA;&lt;h2&gt;Barcode Scanning&lt;/h2&gt; &#xA;&lt;h3&gt;Install ZXing.Net.MAUI&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;a href=&#34;https://www.nuget.org/packages/ZXing.Net.Maui&#34;&gt;ZXing.Net.MAUI&lt;/a&gt; NuGet package on your .NET MAUI application&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure to initialize the plugin first in your &lt;code&gt;MauiProgram.cs&lt;/code&gt;, see below&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Add the using to the top&#xA;using ZXing.Net.Maui;&#xA;&#xA;// ... other code &#xA;&#xA;public static MauiApp Create()&#xA;{&#xA;&#x9;var builder = MauiApp.CreateBuilder();&#xA;&#xA;&#x9;builder&#xA;&#x9;&#x9;.UseMauiApp&amp;lt;App&amp;gt;()&#xA;&#x9;&#x9;.UseBarcodeReader(); // Make sure to add this line&#xA;&#xA;&#x9;return builder.Build();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Now we just need to add the right permissions to our app metadata. Find below how to do that for each platform.&lt;/p&gt; &#xA;&lt;h4&gt;Android&lt;/h4&gt; &#xA;&lt;p&gt;For Android go to your &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file (under the Platforms\Android folder) and add the following permissions inside of the &lt;code&gt;manifest&lt;/code&gt; node:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-permission android:name=&#34;android.permission.CAMERA&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;iOS&lt;/h4&gt; &#xA;&lt;p&gt;For iOS go to your &lt;code&gt;info.plist&lt;/code&gt; file (under the Platforms\iOS folder) and add the following permissions inside of the &lt;code&gt;dict&lt;/code&gt; node:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;&#xA;&amp;lt;string&amp;gt;This app uses barcode scanning to...&amp;lt;/string&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure that you enter a clear and valid reason for your app to access the camera. This description will be shown to the user.&lt;/p&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;Windows is not supported at this time for barcode scanning. You can however use the barcode generation. No extra permissions are required for that.&lt;/p&gt; &#xA;&lt;p&gt;For more information on permissions, see the &lt;a href=&#34;https://docs.microsoft.com/dotnet/maui/platform-integration/appmodel/permissions&#34;&gt;Microsoft Docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using ZXing.Net.Maui&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using the controls from XAML, make sure to add the right XML namespace in the root of your file, e.g: &lt;code&gt;xmlns:zxing=&#34;clr-namespace:ZXing.Net.Maui.Controls;assembly=ZXing.Net.MAUI&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xaml&#34;&gt;&amp;lt;zxing:CameraBarcodeReaderView&#xA;  x:Name=&#34;cameraBarcodeReaderView&#34;&#xA;  BarcodesDetected=&#34;BarcodesDetected&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configure Reader options&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;cameraBarcodeReaderView.Options = new BarcodeReaderOptions&#xA;{&#xA;  Formats = BarcodeFormats.OneDimensional,&#xA;  AutoRotate = true,&#xA;  Multiple = true&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Toggle Torch&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;cameraBarcodeReaderView.IsTorchOn = !cameraBarcodeReaderView.IsTorchOn;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Flip between Rear/Front cameras&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;cameraBarcodeReaderView.CameraLocation&#xA;  = cameraBarcodeReaderView.CameraLocation == CameraLocation.Rear ? CameraLocation.Front : CameraLocation.Rear;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Handle detected barcode(s)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;protected void BarcodesDetected(object sender, BarcodeDetectionEventArgs e)&#xA;{&#xA;  foreach (var barcode in e.Results)&#xA;    Console.WriteLine($&#34;Barcodes: {barcode.Format} -&amp;gt; {barcode.Value}&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Barcode Generator View&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xaml&#34;&gt;&amp;lt;zxing:BarcodeGeneratorView&#xA;  HeightRequest=&#34;100&#34;&#xA;  WidthRequest=&#34;100&#34;&#xA;  ForegroundColor=&#34;DarkBlue&#34;&#xA;  Value=&#34;https://dotnet.microsoft.com&#34;&#xA;  Format=&#34;QrCode&#34;&#xA;  Margin=&#34;3&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>EllanJiang/GameFramework</title>
    <updated>2022-09-03T01:34:12Z</updated>
    <id>tag:github.com,2022-09-03:/EllanJiang/GameFramework</id>
    <link href="https://github.com/EllanJiang/GameFramework" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is literally a game framework, based on Unity game engine. It encapsulates commonly used game modules during development, and, to a large degree, standardises the process, enhances the development speed and ensures the product quality.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;HOMEPAGE&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;English&lt;/strong&gt; - Coming soon.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;简体中文&lt;/strong&gt; - &lt;a href=&#34;https://gameframework.cn/&#34;&gt;https://gameframework.cn/&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;QQ 讨论群&lt;/strong&gt; 216332935&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://gameframework.cn/image/gameframework.png&#34; alt=&#34;Game Framework&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Game Framework 简介&lt;/h2&gt; &#xA;&lt;p&gt;Game Framework 是一个基于 Unity 引擎的游戏框架，主要对游戏开发过程中常用模块进行了封装，很大程度地规范开发过程、加快开发速度并保证产品质量。&lt;/p&gt; &#xA;&lt;p&gt;在最新的 Game Framework 版本中，包含以下 19 个内置模块，后续我们还将开发更多的扩展模块供开发者使用。&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;全局配置 (Config)&lt;/strong&gt; - 存储一些全局的只读的游戏配置，如玩家初始速度、游戏初始音量等。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;数据结点 (Data Node)&lt;/strong&gt; - 将任意类型的数据以树状结构的形式进行保存，用于管理游戏运行时的各种数据。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;数据表 (Data Table)&lt;/strong&gt; - 可以将游戏数据以表格（如 Microsoft Excel）的形式进行配置后，使用此模块使用这些数据表。数据表的格式是可以自定义的。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;调试器 (Debugger)&lt;/strong&gt; - 当游戏在 Unity 编辑器中运行或者以 Development 方式发布运行时，将出现调试器窗口，便于查看运行时日志、调试信息等。用户还可以方便地将自己的功能注册到调试器窗口上并使用。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;下载 (Download)&lt;/strong&gt; - 提供下载文件的功能，支持断点续传，并可指定允许几个下载器进行同时下载。更新资源时会主动调用此模块。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;实体 (Entity)&lt;/strong&gt; - 我们将游戏场景中，动态创建的一切物体定义为实体。此模块提供管理实体和实体组的功能，如显示隐藏实体、挂接实体（如挂接武器、坐骑，或者抓起另一个实体）等。实体使用结束后可以不立刻销毁，从而等待下一次重新使用。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;事件 (Event)&lt;/strong&gt; - 游戏逻辑监听、抛出事件的机制。Game Framework 中的很多模块在完成操作后都会抛出内置事件，监听这些事件将大大解除游戏逻辑之间的耦合。用户也可以定义自己的游戏逻辑事件。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;文件系统 (File System)&lt;/strong&gt; - 虚拟文件系统使用类似磁盘的概念对零散文件进行集中管理，优化资源加载时产生的内存分配，甚至可以对资源进行局部片段加载，这些都将极大提升资源加载时的性能。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;有限状态机 (FSM)&lt;/strong&gt; - 提供创建、使用和销毁有限状态机的功能，一些适用于有限状态机机制的游戏逻辑，使用此模块将是一个不错的选择。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;本地化 (Localization)&lt;/strong&gt; - 提供本地化功能，也就是我们平时所说的多语言。Game Framework 在本地化方面，不但支持文本的本地化，还支持任意资源的本地化，比如游戏中释放烟花特效也可以做出几个多国语言的版本，使得中文版里是“新年好”字样的特效，而英文版里是“Happy New Year”字样的特效。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;网络 (Network)&lt;/strong&gt; - 提供使用 Socket 长连接的功能，当前我们支持 TCP 协议，同时兼容 IPv4 和 IPv6 两个版本。用户可以同时建立多个连接与多个服务器同时进行通信，比如除了连接常规的游戏服务器，还可以连接语音聊天服务器。如果想接入 ProtoBuf 之类的协议库，只要派生自 Packet 类并实现自己的消息包类即可使用。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;对象池 (Object Pool)&lt;/strong&gt; - 提供对象缓存池的功能，避免频繁地创建和销毁各种游戏对象，提高游戏性能。除了 Game Framework 自身使用了对象池，用户还可以很方便地创建和管理自己的对象池。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;流程 (Procedure)&lt;/strong&gt; - 是贯穿游戏运行时整个生命周期的有限状态机。通过流程，将不同的游戏状态进行解耦将是一个非常好的习惯。对于网络游戏，你可能需要如检查资源流程、更新资源流程、检查服务器列表流程、选择服务器流程、登录服务器流程、创建角色流程等流程，而对于单机游戏，你可能需要在游戏选择菜单流程和游戏实际玩法流程之间做切换。如果想增加流程，只要派生自 ProcedureBase 类并实现自己的流程类即可使用。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;资源 (Resource)&lt;/strong&gt; - 为了保证玩家的体验，我们不推荐再使用同步的方式加载资源，由于 Game Framework 自身使用了一套完整的异步加载资源体系，因此只提供了异步加载资源的接口。不论简单的数据表、本地化字典，还是复杂的实体、场景、界面，我们都将使用异步加载。同时，Game Framework 提供了默认的内存管理策略（当然，你也可以定义自己的内存管理策略）。多数情况下，在使用 GameObject 的过程中，你甚至可以不需要自行进行 Instantiate 或者是 Destroy 操作。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;场景 (Scene)&lt;/strong&gt; - 提供场景管理的功能，可以同时加载多个场景，也可以随时卸载任何一个场景，从而很容易地实现场景的分部加载。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;配置 (Setting)&lt;/strong&gt; - 以键值对的形式存储玩家数据，对 UnityEngine.PlayerPrefs 进行封装，也可以将这些数据直接存储在磁盘上。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;声音 (Sound)&lt;/strong&gt; - 提供管理声音和声音组的功能，用户可以自定义一个声音的音量、是 2D 声音还是 3D 声音，甚至是直接绑定到某个实体上跟随实体移动。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;界面 (UI)&lt;/strong&gt; - 提供管理界面和界面组的功能，如显示隐藏界面、激活界面、改变界面层级等。不论是 Unity 内置的 uGUI 还是其它类型的 UI 插件（如 NGUI），只要派生自 UIFormLogic 类并实现自己的界面类即可使用。界面使用结束后可以不立刻销毁，从而等待下一次重新使用。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Web 请求 (Web Request)&lt;/strong&gt; - 提供使用短连接的功能，可以用 Get 或者 Post 方法向服务器发送请求并获取响应数据，可指定允许几个 Web 请求器进行同时请求。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;INTRODUCTION&lt;/h2&gt; &#xA;&lt;p&gt;Game Framework is literally a game framework, based on Unity game engine. It encapsulates commonly used game modules during development, and, to a large degree, standardises the process, enhances the development speed and ensures the product quality.&lt;/p&gt; &#xA;&lt;p&gt;Game Framework provides the following 19 builtin modules, and more will be developed later for game developers to use.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Config&lt;/strong&gt; - saves some global read-only game configurations, such as the player&#39;s initial speed, the initial volume of the game, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Data Node&lt;/strong&gt; - saves arbitrary types of data within tree structures in order to manage various data during game runtime.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Data Table&lt;/strong&gt; - is intended to invoke game data in the form of pre-configured tables (such as Microsoft Excel sheets). The format of the tables can be customised.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Debugger&lt;/strong&gt; - displays a debugger window when the game runs in the Unity Editor or in a development build, to facilitate the viewing of runtime logs and debug messages. The user can register their own features to the debugger windows and use them conveniently.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Download&lt;/strong&gt; - provides the ability to download files. The user is free to set how many downloaders could be used simultaneously.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Entity&lt;/strong&gt; - provides the ability to manage entities and groups of entities, where an entity is defined as any dynamically created objects in the game scene. It shows or hides entities, attach one entity to another (such as weapons, horses or snatching up another entity). Entities could avoid being destroyed instantly after use, and hence be recycled for reuse.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Event&lt;/strong&gt; - gives the mechanism for the game logic to fire or observe events. Many modules in the Game Framework fires events after operations, and observing these events will largely decouple game logic modules. The user can define his own game logic events, too.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;File System&lt;/strong&gt; - the virtual file system, based on the concept of disks, manages scattered files in a centralized way, optimizes memory allocation when resources are loaded, and can even load segments of resources. These will drastically enhance the performance of resource loading.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;FSM&lt;/strong&gt; - provides the ability to create, use and destroy finite state machines. It’d be a good choice to use this module for some state-machine-like game logic.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Localization&lt;/strong&gt; - provides the ability to localise the game. Game Framework not only supports the localisation of texts, but also assets of all kinds. For example, a firework effect in the game can be localised as various versions, so that the player will see a &#34;新年好&#34; - like effect in the Chinese version, while &#34;Happy New Year&#34; - like in the English version.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Network&lt;/strong&gt; - provides socket connections where TCP is currently supported and both IPv4 and IPv6 are valid. The user can establish several connections to different servers at the same time. For example, the user can connect to a normal game server, and another server for voice chat. The &#39;Packet&#39; class is ready for inheritance and implemented if the user wants to take use of protocol libraries such as ProtoBuf.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Object Pool&lt;/strong&gt; - provides the ability to cache objects in pools. It avoids frequent creation and destruction operations of game objects, and hence improves the game performance. Game Framework itself uses object pools, and the user could conveniently create and manage his own pools.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Procedure&lt;/strong&gt; - is in fact an FSM of the whole lifecycle of the game. It’d be a very good habit to decouple different game states via procedures. For a network game, you probably need procedures of checking resources, updating resources, checking the server list, selecting a server, logging in a server and creating avatars. For a standalone game, you perhaps need to switch between procedures of the menu and the real gameplay. The user could add procedures by simply subclassing and implementing the &#39;ProcedureBase&#39; class.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Resource&lt;/strong&gt; - provides only asynchronous interfaces to load resources. We don’t recommend synchronous approaches for better play experience, and Game Framework itself uses a complete system of asynchronous resource loading. We load everything asynchronously, including simple things like data tables and localisation texts, and complex things like entities, scenes and UIs. Meanwhile, Game Framework provides default strategies of memory management (and of course, you could define your own strategies). In most cases, you don&#39;t even need to call &#39;Instantiate&#39; or &#39;Destroy&#39; when using &#39;GameObject&#39; instances.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Scene&lt;/strong&gt; - provides features to manage scenes. It supports simultaneous loading of multiple scenes, and the user is allowed to unload a scene at any time. Therefore partial loading/unloading of scenes could be easily implemented.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Setting&lt;/strong&gt; - stores player data in key-value pairs by either encapsulating UnityEngine.PlayerPrefs or by saving the data directly to the disk.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Sound&lt;/strong&gt; - provides features to manage sounds and groups of sounds. The user could set the properties of an audio clip, such as the volume, whether the clip is 2D or 3D, and could even bind the clip to some entity to follow its position.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;UI&lt;/strong&gt; - provides features to manage user interfaces and groups of UIs, such as showing or hiding, activating or deactivating, and depth changing. No matter the user uses the builtin uGUI in Unity or other UI plugins (NGUI, for example), he only needs to subclass &#39;UIFormLogic&#39; and implement his own UI logic. The UIs could avoid being destroyed instantly after use, and hence be recycled for reuse.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Web Request&lt;/strong&gt; - provides features of short connections, supports GET and POST methods to send requests to the server and acquire the response data, and allows the user to send simultaneous requests to different servers.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>dotnet/BenchmarkDotNet</title>
    <updated>2022-09-03T01:34:12Z</updated>
    <id>tag:github.com,2022-09-03:/dotnet/BenchmarkDotNet</id>
    <link href="https://github.com/dotnet/BenchmarkDotNet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Powerful .NET library for benchmarking&lt;/p&gt;&lt;hr&gt;&lt;h3 align=&#34;center&#34;&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/docs/logo/logo-wide.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/h3&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt; &lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/BenchmarkDotNet/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/BenchmarkDotNet.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/BenchmarkDotNet/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/benchmarkdotnet.svg?sanitize=true&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/dotnet/BenchmarkDotNet?color=brightgreen&#34; alt=&#34;Stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/dotnet/BenchmarkDotNet&#34;&gt;&lt;img src=&#34;https://img.shields.io/gitter/room/dotnet/BenchmarkDotNet?color=yellow&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/LICENSE.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/h3&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#Features&#34;&gt;Features&lt;/a&gt; &lt;span&gt; · &lt;/span&gt; &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/getting-started.html&#34;&gt;Getting started&lt;/a&gt; &lt;span&gt; · &lt;/span&gt; &lt;a href=&#34;https://benchmarkdotnet.org/articles/overview.html&#34;&gt;Documentation&lt;/a&gt; &lt;span&gt; · &lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#learn-more-about-benchmarking&#34;&gt;Learn more about benchmarking&lt;/a&gt; &lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;BenchmarkDotNet&lt;/strong&gt; helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments. It&#39;s no harder than writing unit tests! Under the hood, it performs a lot of &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#Automation&#34;&gt;magic&lt;/a&gt; that guarantees &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#Reliability&#34;&gt;reliable and precise&lt;/a&gt; results thanks to the &lt;a href=&#34;https://github.com/AndreyAkinshin/perfolizer&#34;&gt;perfolizer&lt;/a&gt; statistical engine. BenchmarkDotNet protects you from popular benchmarking mistakes and warns you if something is wrong with your benchmark design or obtained measurements. The results are presented in a &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#Friendliness&#34;&gt;user-friendly&lt;/a&gt; form that highlights all the important facts about your experiment. The library is adopted by &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#who-uses-benchmarkdotnet&#34;&gt;11700+ projects&lt;/a&gt; including .NET Runtime and supported by the &lt;a href=&#34;https://dotnetfoundation.org&#34;&gt;.NET Foundation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#Simplicity&#34;&gt;easy&lt;/a&gt; to start writing benchmarks, check out an example (copy-pastable version is &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/getting-started.html&#34;&gt;here&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;[SimpleJob(RuntimeMoniker.Net472, baseline: true)]&#xA;[SimpleJob(RuntimeMoniker.NetCoreApp30)]&#xA;[SimpleJob(RuntimeMoniker.NativeAot70)]&#xA;[SimpleJob(RuntimeMoniker.Mono)]&#xA;[RPlotExporter]&#xA;public class Md5VsSha256&#xA;{&#xA;    private SHA256 sha256 = SHA256.Create();&#xA;    private MD5 md5 = MD5.Create();&#xA;    private byte[] data;&#xA;&#xA;    [Params(1000, 10000)]&#xA;    public int N;&#xA;&#xA;    [GlobalSetup]&#xA;    public void Setup()&#xA;    {&#xA;        data = new byte[N];&#xA;        new Random(42).NextBytes(data);&#xA;    }&#xA;&#xA;    [Benchmark]&#xA;    public byte[] Sha256() =&amp;gt; sha256.ComputeHash(data);&#xA;&#xA;    [Benchmark]&#xA;    public byte[] Md5() =&amp;gt; md5.ComputeHash(data);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;BenchmarkDotNet automatically runs the benchmarks on all the runtimes, aggregates the measurements, and prints a summary table with the most important information:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;BenchmarkDotNet=v0.12.0, OS=Windows 10.0.17763.805 (1809/October2018Update/Redstone5)&#xA;Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores&#xA;  [Host]       : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT&#xA;  Net472       : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT&#xA;  NetCoreApp30 : .NET Core 3.0.0 (CoreCLR 4.700.19.46205, CoreFX 4.700.19.46214), X64 RyuJIT&#xA;  NativeAot70  : .NET 7.0.0-preview.4.22172.7, X64 NativeAOT&#xA;  Mono         : Mono 6.4.0 (Visual Studio), X64&#xA;&#xA;&#xA;| Method |       Runtime |     N |       Mean |     Error |    StdDev | Ratio |&#xA;|------- |-------------- |------ |-----------:|----------:|----------:|------:|&#xA;| Sha256 |    .NET 4.7.2 |  1000 |   7.735 us | 0.1913 us | 0.4034 us |  1.00 |&#xA;| Sha256 | .NET Core 3.0 |  1000 |   3.989 us | 0.0796 us | 0.0745 us |  0.50 |&#xA;| Sha256 | NativeAOT 7.0 |  1000 |   4.091 us | 0.0811 us | 0.1562 us |  0.53 |&#xA;| Sha256 |          Mono |  1000 |  13.117 us | 0.2485 us | 0.5019 us |  1.70 |&#xA;|        |               |       |            |           |           |       |&#xA;|    Md5 |    .NET 4.7.2 |  1000 |   2.872 us | 0.0552 us | 0.0737 us |  1.00 |&#xA;|    Md5 | .NET Core 3.0 |  1000 |   1.848 us | 0.0348 us | 0.0326 us |  0.64 |&#xA;|    Md5 | NativeAOT 7.0 |  1000 |   1.817 us | 0.0359 us | 0.0427 us |  0.63 |&#xA;|    Md5 |          Mono |  1000 |   3.574 us | 0.0678 us | 0.0753 us |  1.24 |&#xA;|        |               |       |            |           |           |       |&#xA;| Sha256 |    .NET 4.7.2 | 10000 |  74.509 us | 1.5787 us | 4.6052 us |  1.00 |&#xA;| Sha256 | .NET Core 3.0 | 10000 |  36.049 us | 0.7151 us | 1.0025 us |  0.49 |&#xA;| Sha256 | NativeAOT 7.0 | 10000 |  36.253 us | 0.7076 us | 0.7571 us |  0.49 |&#xA;| Sha256 |          Mono | 10000 | 116.350 us | 2.2555 us | 3.0110 us |  1.58 |&#xA;|        |               |       |            |           |           |       |&#xA;|    Md5 |    .NET 4.7.2 | 10000 |  17.308 us | 0.3361 us | 0.4250 us |  1.00 |&#xA;|    Md5 | .NET Core 3.0 | 10000 |  15.726 us | 0.2064 us | 0.1930 us |  0.90 |&#xA;|    Md5 | NativeAOT 7.0 | 10000 |  15.627 us | 0.2631 us | 0.2461 us |  0.89 |&#xA;|    Md5 |          Mono | 10000 |  30.205 us | 0.5868 us | 0.6522 us |  1.74 |&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The measured data can be exported to different formats (md, html, csv, xml, json, etc.) including plots:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/docs/images/v0.12.0/rplot.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Supported runtimes:&lt;/em&gt; .NET 5+, .NET Framework 4.6.1+, .NET Core 2.0+, Mono, NativeAOT&lt;br&gt; &lt;em&gt;Supported languages:&lt;/em&gt; C#, F#, Visual Basic&lt;br&gt; &lt;em&gt;Supported OS:&lt;/em&gt; Windows, Linux, macOS&lt;br&gt; &lt;em&gt;Supported architectures:&lt;/em&gt; x86, x64, ARM, ARM64, Wasm and LoongArch64&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;BenchmarkDotNet has tons of features that are essential in comprehensive performance investigations. Four aspects define the design of these features: &lt;em&gt;simplicity&lt;/em&gt;, &lt;em&gt;automation&lt;/em&gt;, &lt;em&gt;reliability&lt;/em&gt;, and &lt;em&gt;friendliness&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Simplicity&lt;/h3&gt; &#xA;&lt;p&gt;You shouldn&#39;t be an experienced performance engineer if you want to write benchmarks. You can design very complicated performance experiments in the declarative style using simple APIs.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you want to &lt;a href=&#34;https://benchmarkdotnet.org/articles/features/parameterization.html&#34;&gt;parameterize&lt;/a&gt; your benchmark, mark a field or a property with &lt;code&gt;[Params(1, 2, 3)]&lt;/code&gt;: BenchmarkDotNet will enumerate all of the specified values and run benchmarks for each case. If you want to compare benchmarks with each other, mark one of the benchmark as the &lt;a href=&#34;https://benchmarkdotnet.org/articles/features/baselines.html&#34;&gt;baseline&lt;/a&gt; via &lt;code&gt;[Benchmark(Baseline = true)]&lt;/code&gt;: BenchmarkDotNet will compare it with all of the other benchmarks. If you want to compare performance in different environments, use &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/jobs.html&#34;&gt;jobs&lt;/a&gt;. For example, you can run all the benchmarks on .NET Core 3.0 and Mono via &lt;code&gt;[SimpleJob(RuntimeMoniker.NetCoreApp30)]&lt;/code&gt; and &lt;code&gt;[SimpleJob(RuntimeMoniker.Mono)]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t like attributes, you can call most of the APIs via the fluent style and write code like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ManualConfig.CreateEmpty() // A configuration for our benchmarks&#xA;    .AddJob(Job.Default // Adding first job&#xA;        .WithRuntime(ClrRuntime.Net472) // .NET Framework 4.7.2&#xA;        .WithPlatform(Platform.X64) // Run as x64 application&#xA;        .WithJit(Jit.LegacyJit) // Use LegacyJIT instead of the default RyuJIT&#xA;        .WithGcServer(true) // Use Server GC&#xA;    ).AddJob(Job.Default // Adding second job&#xA;        .AsBaseline() // It will be marked as baseline&#xA;        .WithEnvironmentVariable(&#34;Key&#34;, &#34;Value&#34;) // Setting an environment variable&#xA;        .WithWarmupCount(0) // Disable warm-up stage&#xA;    );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you prefer command-line experience, you can configure your benchmarks via the &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/console-args.html&#34;&gt;console arguments&lt;/a&gt; in any console application (other types of applications are not supported).&lt;/p&gt; &#xA;&lt;h3&gt;Automation&lt;/h3&gt; &#xA;&lt;p&gt;Reliable benchmarks always include a lot of boilerplate code.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s think about what should you do in a typical case. First, you should perform a pilot experiment and determine the best number of method invocations. Next, you should execute several warm-up iterations and ensure that your benchmark achieved a steady state. After that, you should execute the main iterations and calculate some basic statistics. If you calculate some values in your benchmark, you should use it somehow to prevent the dead code elimination. If you use loops, you should care about an effect of the loop unrolling on your results (which may depend on the processor architecture). Once you get results, you should check for some special properties of the obtained performance distribution like multimodality or extremely high outliers. You should also evaluate the overhead of your infrastructure and deduct it from your results. If you want to test several environments, you should perform the measurements in each of them and manually aggregate the results.&lt;/p&gt; &#xA;&lt;p&gt;If you write this code from scratch, it&#39;s easy to make a mistake and spoil your measurements. Note that it&#39;s a shortened version of the full checklist that you should follow during benchmarking: there are a lot of additional hidden pitfalls that should be handled appropriately. Fortunately, you shouldn&#39;t worry about it because BenchmarkDotNet &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/how-it-works.html&#34;&gt;will do&lt;/a&gt; this boring and time-consuming stuff for you.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, the library can help you with some advanced tasks that you may want to perform during the investigation. For example, BenchmarkDotNet can measure the &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/diagnosers.html#usage&#34;&gt;managed&lt;/a&gt; and &lt;a href=&#34;https://benchmarkdotnet.org/articles/samples/IntroNativeMemory.html&#34;&gt;native&lt;/a&gt; memory traffic and print &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/diagnosers.html#sample-introdisassembly&#34;&gt;disassembly listings&lt;/a&gt; for your benchmarks.&lt;/p&gt; &#xA;&lt;h3&gt;Reliability&lt;/h3&gt; &#xA;&lt;p&gt;A lot of hand-written benchmarks produce wrong numbers that lead to incorrect business decisions. BenchmarkDotNet protects you from most of the benchmarking pitfalls and allows achieving high measurement precision.&lt;/p&gt; &#xA;&lt;p&gt;You shouldn&#39;t worry about the perfect number of method invocation, the number of warm-up and actual iterations: BenchmarkDotNet tries to choose the best benchmarking parameters and achieve a good trade-off between the measurement prevision and the total duration of all benchmark runs. So, you shouldn&#39;t use any magic numbers (like &#34;We should perform 100 iterations here&#34;), the library will do it for you based on the values of statistical metrics.&lt;/p&gt; &#xA;&lt;p&gt;BenchmarkDotNet also prevents benchmarking of non-optimized assemblies that was built using DEBUG mode because the corresponding results will be unreliable. It will print a warning you if you have an attached debugger, if you use hypervisor (HyperV, VMware, VirtualBox), or if you have any other problems with the current environment.&lt;/p&gt; &#xA;&lt;p&gt;During 6+ years of development, we faced dozens of different problems that may spoil your measurements. Inside BenchmarkDotNet, there are a lot of heuristics, checks, hacks, and tricks that help you to increase the reliability of the results.&lt;/p&gt; &#xA;&lt;h3&gt;Friendliness&lt;/h3&gt; &#xA;&lt;p&gt;Analysis of performance data is a time-consuming activity that requires attentiveness, knowledge, and experience. BenchmarkDotNet performs the main part of this analysis for you and presents results in a user-friendly form.&lt;/p&gt; &#xA;&lt;p&gt;After the experiments, you get a summary table that contains a lot of useful data about the executed benchmarks. By default, it includes only the most important columns, but they can be &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/columns.html&#34;&gt;easily customized&lt;/a&gt;. The column set is adaptive and depends on the benchmark definition and measured values. For example, if you mark one of the benchmarks as a &lt;a href=&#34;https://benchmarkdotnet.org/articles/features/baselines.html&#34;&gt;baseline&lt;/a&gt;, you will get additional columns that will help you to compare all the benchmarks with the baseline. By default, it always shows the Mean column, but if we detected a vast difference between the Mean and the Median values, both columns will be presented.&lt;/p&gt; &#xA;&lt;p&gt;BenchmarkDotNet tries to find some unusual properties of your performance distributions and prints nice messages about it. For example, it will warn you in case of multimodal distribution or high outliers. In this case, you can scroll the results up and check out ASCII-style histograms for each distribution or generate beautiful png plots using &lt;code&gt;[RPlotExporter]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;BenchmarkDotNet doesn&#39;t overload you with data; it shows only the essential information depending on your results: it allows you to keep summary small for primitive cases and extend it only for the complicated cases. Of course, you can request any additional statistics and visualizations manually. If you don&#39;t customize the summary view, the default presentation will be as much user-friendly as possible. :)&lt;/p&gt; &#xA;&lt;h2&gt;Who uses BenchmarkDotNet?&lt;/h2&gt; &#xA;&lt;p&gt;Everyone! BenchmarkDotNet is already adopted by more than &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/network/dependents?package_id=UGFja2FnZS0xNTY3MzExMzE%3D&#34;&gt;11700+&lt;/a&gt; projects including &lt;a href=&#34;https://github.com/dotnet/performance&#34;&gt;dotnet/performance&lt;/a&gt; (reference benchmarks for all .NET Runtimes), &lt;a href=&#34;https://github.com/dotnet/runtime/issues?utf8=%E2%9C%93&amp;amp;q=BenchmarkDotNet&#34;&gt;dotnet/runtime&lt;/a&gt; (.NET runtime and libraries), &lt;a href=&#34;https://github.com/dotnet/roslyn/search?q=BenchmarkDotNet&amp;amp;type=Issues&amp;amp;utf8=%E2%9C%93&#34;&gt;Roslyn&lt;/a&gt; (C# and Visual Basic compiler), &lt;a href=&#34;https://github.com/mono/mono/tree/master/sdks/wasm/bench-runner&#34;&gt;Mono&lt;/a&gt;, &lt;a href=&#34;https://github.com/aspnet/AspNetCore/tree/master/src/Servers/IIS/IIS/benchmarks&#34;&gt;ASP.NET Core&lt;/a&gt;, &lt;a href=&#34;https://github.com/dotnet/machinelearning/tree/main/test/Microsoft.ML.PerformanceTests&#34;&gt;ML.NET&lt;/a&gt;, &lt;a href=&#34;https://github.com/dotnet/efcore/tree/master/benchmark&#34;&gt;Entity Framework Core&lt;/a&gt;, &lt;a href=&#34;https://github.com/PowerShell/PowerShell/tree/master/test/perf/benchmarks&#34;&gt;PowerShell&lt;/a&gt; &lt;a href=&#34;https://github.com/aspnet/SignalR/tree/master/benchmarks/Microsoft.AspNetCore.SignalR.Microbenchmarks&#34;&gt;SignalR&lt;/a&gt;, &lt;a href=&#34;https://github.com/fsharp/fsharp/raw/master/tests/scripts/array-perf/array-perf.fs&#34;&gt;F#&lt;/a&gt;, &lt;a href=&#34;https://github.com/dotnet/orleans/tree/master/test/Benchmarks&#34;&gt;Orleans&lt;/a&gt;, &lt;a href=&#34;https://github.com/JamesNK/Newtonsoft.Json/tree/master/Src/Newtonsoft.Json.Tests/Benchmarks&#34;&gt;Newtonsoft.Json&lt;/a&gt;, &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/net-api/current/bool-queries.html#_perfomance_considerations&#34;&gt;Elasticsearch.Net&lt;/a&gt;, &lt;a href=&#34;https://github.com/DapperLib/Dapper/tree/main/benchmarks/Dapper.Tests.Performance&#34;&gt;Dapper&lt;/a&gt;, &lt;a href=&#34;https://github.com/haf/expecto/tree/master/Expecto.BenchmarkDotNet&#34;&gt;Expecto&lt;/a&gt;, &lt;a href=&#34;https://github.com/SixLabors/ImageSharp/tree/master/tests/ImageSharp.Benchmarks&#34;&gt;ImageSharp&lt;/a&gt;, &lt;a href=&#34;https://github.com/ravendb/ravendb/tree/v4.0/bench&#34;&gt;RavenDB&lt;/a&gt;, &lt;a href=&#34;https://github.com/nodatime/nodatime/tree/master/src/NodaTime.Benchmarks&#34;&gt;NodaTime&lt;/a&gt;, &lt;a href=&#34;https://github.com/sebastienros/jint/tree/dev/Jint.Benchmark&#34;&gt;Jint&lt;/a&gt;, &lt;a href=&#34;https://github.com/Particular/NServiceBus/issues?utf8=%E2%9C%93&amp;amp;q=+BenchmarkDotNet+&#34;&gt;NServiceBus&lt;/a&gt;, &lt;a href=&#34;https://github.com/serilog/serilog/tree/dev/test/Serilog.PerformanceTests&#34;&gt;Serilog&lt;/a&gt;, &lt;a href=&#34;https://github.com/autofac/Autofac/tree/develop/bench/Autofac.Benchmarks&#34;&gt;Autofac&lt;/a&gt;, &lt;a href=&#34;https://github.com/npgsql/npgsql/tree/main/test/Npgsql.Benchmarks&#34;&gt;Npgsql&lt;/a&gt;, &lt;a href=&#34;https://github.com/AvaloniaUI/Avalonia/tree/master/tests/Avalonia.Benchmarks&#34;&gt;Avalonia&lt;/a&gt;, &lt;a href=&#34;https://github.com/reactiveui/ReactiveUI/tree/master/src/Benchmarks&#34;&gt;ReactiveUI&lt;/a&gt;, &lt;a href=&#34;https://github.com/icsharpcode/SharpZipLib/tree/master/benchmark/ICSharpCode.SharpZipLib.Benchmark&#34;&gt;SharpZipLib&lt;/a&gt;, &lt;a href=&#34;https://github.com/mbdavid/LiteDB/tree/master/LiteDB.Benchmarks&#34;&gt;LiteDB&lt;/a&gt;, &lt;a href=&#34;https://github.com/graphql-dotnet/graphql-dotnet/tree/master/src/GraphQL.Benchmarks&#34;&gt;GraphQL for .NET&lt;/a&gt;, &lt;a href=&#34;https://github.com/dotnet/docs/tree/master/samples/snippets/csharp/safe-efficient-code/benchmark&#34;&gt;.NET Docs&lt;/a&gt;, &lt;a href=&#34;https://github.com/restsharp/RestSharp/tree/dev/benchmarks/RestSharp.Benchmarks&#34;&gt;RestSharp&lt;/a&gt;, &lt;a href=&#34;https://github.com/jbogard/MediatR/tree/master/test/MediatR.Benchmarks&#34;&gt;MediatR&lt;/a&gt;, &lt;a href=&#34;https://github.com/SciSharp/TensorFlow.NET/tree/master/src/TensorFlowNet.Benchmarks&#34;&gt;TensorFlow.NET&lt;/a&gt;, &lt;a href=&#34;https://github.com/apache/thrift/tree/master/lib/netstd/Benchmarks/Thrift.Benchmarks&#34;&gt;Apache Thrift&lt;/a&gt;.&lt;br&gt; On GitHub, you can find 8400+ &lt;a href=&#34;https://github.com/search?o=desc&amp;amp;q=BenchmarkDotNet+-repo:dotnet%2FBenchmarkDotNet&amp;amp;s=created&amp;amp;type=Issues&amp;amp;utf8=%E2%9C%93&#34;&gt;issues&lt;/a&gt;, 3700+ &lt;a href=&#34;https://github.com/search?o=desc&amp;amp;q=BenchmarkDotNet+-repo:dotnet%2FBenchmarkDotNet&amp;amp;s=committer-date&amp;amp;type=Commits&amp;amp;utf8=%E2%9C%93&#34;&gt;commits&lt;/a&gt;, and 1,200,000+ &lt;a href=&#34;https://github.com/search?o=desc&amp;amp;q=BenchmarkDotNet+-repo:dotnet%2FBenchmarkDotNet&amp;amp;s=indexed&amp;amp;type=Code&amp;amp;utf8=%E2%9C%93&#34;&gt;files&lt;/a&gt; that involve BenchmarkDotNet.&lt;/p&gt; &#xA;&lt;h2&gt;Learn more about benchmarking&lt;/h2&gt; &#xA;&lt;p&gt;BenchmarkDotNet is not a silver bullet that magically makes all of your benchmarks correct and analyzes the measurements for you. Even if you use this library, you still should know how to design the benchmark experiments and how to make correct conclusions based on the raw data. If you want to know more about benchmarking methodology and good practices, it&#39;s recommended to read a book by Andrey Akinshin (the BenchmarkDotNet project lead): &lt;a href=&#34;https://aakinshin.net/prodotnetbenchmarking/&#34;&gt;&#34;Pro .NET Benchmarking&#34;&lt;/a&gt;. Use this in-depth guide to correctly design benchmarks, measure key performance metrics of .NET applications, and analyze results. This book presents dozens of case studies to help you understand complicated benchmarking topics. You will avoid common pitfalls, control the accuracy of your measurements, and improve the performance of your software.&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://aakinshin.net/prodotnetbenchmarking/&#34;&gt; &lt;img src=&#34;https://aakinshin.net/img/misc/prodotnetbenchmarking-cover.png&#34; width=&#34;400&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Build status&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Build server&lt;/th&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Build status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure Pipelines&lt;/td&gt; &#xA;   &lt;td&gt;Windows&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://dev.azure.com/dotnet/BenchmarkDotNet/_build/latest?definitionId=55&#34;&gt;&lt;img src=&#34;https://dev.azure.com/dotnet/BenchmarkDotNet/_apis/build/status/BenchmarkDotNet%20-%20Windows&#34; alt=&#34;Azure Pipelines Windows&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure Pipelines&lt;/td&gt; &#xA;   &lt;td&gt;Ubuntu&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://dev.azure.com/dotnet/BenchmarkDotNet/_build/latest?definitionId=56&#34;&gt;&lt;img src=&#34;https://dev.azure.com/dotnet/BenchmarkDotNet/_apis/build/status/BenchmarkDotNet%20-%20Ubuntu&#34; alt=&#34;Azure Pipelines Ubuntu&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure Pipelines&lt;/td&gt; &#xA;   &lt;td&gt;macOS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://dev.azure.com/dotnet/BenchmarkDotNet/_build/latest?definitionId=57&#34;&gt;&lt;img src=&#34;https://dev.azure.com/dotnet/BenchmarkDotNet/_apis/build/status/BenchmarkDotNet%20-%20macOS&#34; alt=&#34;Azure Pipelines macOS&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;AppVeyor&lt;/td&gt; &#xA;   &lt;td&gt;Windows&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://ci.appveyor.com/project/dotnetfoundation/benchmarkdotnet/branch/master&#34;&gt;&lt;img src=&#34;https://img.shields.io/appveyor/ci/dotnetfoundation/benchmarkdotnet/master.svg?sanitize=true&#34; alt=&#34;AppVeyor/Windows&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GitHub Actions&lt;/td&gt; &#xA;   &lt;td&gt;*&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/actions/workflows/build.yaml&#34;&gt;&lt;img src=&#34;https://github.com/dotnet/BenchmarkDotNet/actions/workflows/build.yaml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Contributions are welcome!&lt;/h2&gt; &#xA;&lt;p&gt;BenchmarkDotNet is already a stable full-featured library that allows performing performance investigation on a professional level. And it continues to evolve! We add new features all the time, but we have too many new cool ideas. Any help will be appreciated. You can develop new features, fix bugs, improve the documentation, or do some other cool stuff.&lt;/p&gt; &#xA;&lt;p&gt;If you want to contribute, check out the &lt;a href=&#34;https://benchmarkdotnet.org/articles/contributing/building.html&#34;&gt;Contributing guide&lt;/a&gt; and &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/issues?q=is:open+is:issue+label:up-for-grabs&#34;&gt;up-for-grabs&lt;/a&gt; issues. If you have new ideas or want to complain about bugs, feel free to &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/issues/new&#34;&gt;create a new issue&lt;/a&gt;. Let&#39;s build the best tool for benchmarking together!&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;This project has adopted the code of conduct defined by the &lt;a href=&#34;http://contributor-covenant.org/&#34;&gt;Contributor Covenant&lt;/a&gt; to clarify expected behavior in our community. For more information, see the &lt;a href=&#34;https://dotnetfoundation.org/code-of-conduct&#34;&gt;.NET Foundation Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>