<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-24T01:26:59Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>LykosAI/StabilityMatrix</title>
    <updated>2023-08-24T01:26:59Z</updated>
    <id>tag:github.com,2023-08-24:/LykosAI/StabilityMatrix</id>
    <link href="https://github.com/LykosAI/StabilityMatrix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Multi-Platform Package Manager for Stable Diffusion&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Stability Matrix&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/LykosAI/StabilityMatrix/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/LykosAI/StabilityMatrix/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.com/invite/TUrgfECxHz&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1115555685476868168?logo=discord&amp;amp;logoColor=white&amp;amp;label=Discord%20Server&#34; alt=&#34;Discord Server&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Multi-Platform Package Manager for Stable Diffusion&lt;/p&gt; &#xA;&lt;h3&gt;üñ±Ô∏è One click install and update for Stable Diffusion Web UI Packages&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports &lt;a href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;&gt;Automatic 1111&lt;/a&gt;, &lt;a href=&#34;https://github.com/comfyanonymous/ComfyUI&#34;&gt;Comfy UI&lt;/a&gt;, &lt;a href=&#34;https://github.com/vladmandic/automatic&#34;&gt;SD.Next (Vladmandic)&lt;/a&gt;, &lt;a href=&#34;https://github.com/VoltaML/voltaML-fast-stable-diffusion&#34;&gt;VoltaML&lt;/a&gt;, &lt;a href=&#34;https://github.com/invoke-ai/InvokeAI&#34;&gt;InvokeAI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Embedded Git and Python dependencies, with no need for either to be globally installed&lt;/li&gt; &#xA; &lt;li&gt;Fully Portable, move Stability Matrix&#39;s Data Directory to a new drive or computer at any time&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;üöÄ Launcher with syntax highlighted terminal emulator, routed GUI input prompts&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Launch arguments editor with predefined or custom options for each Package install&lt;/li&gt; &#xA; &lt;li&gt;Package environment variables&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;üóÉÔ∏è Checkpoint Manager, configured to be shared by all Package installs&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Option to find CivitAI metadata and preview thumbnails for new local imports&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;‚òÅÔ∏è Model Browser to import from &lt;a href=&#34;https://civitai.com/&#34;&gt;CivitAI&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatically imports to the associated model folder depending on the model type&lt;/li&gt; &#xA; &lt;li&gt;Also downloads relavent metadata files and preview image&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/LykosAI/StabilityMatrix/assets/13956642/a9c5f925-8561-49ba-855b-1b7bf57d7c0d&#34; alt=&#34;header&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/LykosAI/StabilityMatrix/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/LykosAI/StabilityMatrix?label=Latest%20Release&amp;amp;link=https%3A%2F%2Fgithub.com%2FLykosAI%2FStabilityMatrix%2Freleases%2Flatest&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/LykosAI/StabilityMatrix/releases/latest/download/StabilityMatrix-win-x64.zip&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Windows-%230079d5.svg?style=for-the-badge&amp;amp;logo=Windows%2011&amp;amp;logoColor=white&#34; alt=&#34;Windows&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/LykosAI/StabilityMatrix/releases/latest/download/StabilityMatrix-linux-x64.zip&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Linux-FCC624?style=for-the-badge&amp;amp;logo=linux&amp;amp;logoColor=black&#34; alt=&#34;Linux&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/LykosAI/StabilityMatrix/issues/45&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/mac%20os%20%28apple%20silicon%29-000000?style=for-the-badge&amp;amp;logo=macos&amp;amp;logoColor=F0F0F0&#34; alt=&#34;macOS&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;macOS builds are currently pending: &lt;a href=&#34;https://github.com/LykosAI/StabilityMatrix/issues/45&#34;&gt;#45&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Searchable launch options&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img style=&#34;width: 80%; height: 80%&#34; src=&#34;https://github.com/LykosAI/StabilityMatrix/assets/13956642/75456866-9d95-47c6-8c0a-fdc19443ee02&#34; alt=&#34;&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Model browser powered by &lt;a href=&#34;https://civitai.com/&#34;&gt;Civit AI&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Downloads new models, automatically uses the appropriate shared model directory&lt;/li&gt; &#xA; &lt;li&gt;Available immediately to all installed packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img style=&#34;width: 80%; height: 80%&#34; src=&#34;https://github.com/LykosAI/StabilityMatrix/assets/13956642/30b9f610-6033-4307-8d92-7d72b93cd73e&#34; alt=&#34;&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Shared model directory for all your packages&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Import local models by simple drag and drop&lt;/li&gt; &#xA; &lt;li&gt;Toggle visibility of categories like LoRA, VAE, CLIP, etc.&lt;/li&gt; &#xA; &lt;li&gt;For models imported from Civit AI, shows additional information like version, fp precision, and preview thumbnail on hover&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img style=&#34;width: 80%; height: 80%&#34; src=&#34;https://github.com/LykosAI/StabilityMatrix/assets/13956642/d42d1c53-67a4-45a0-b009-21400d44e17e&#34; alt=&#34;&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This repository maintains the latest source code release for Stability Matrix, and is licensed under the &lt;a href=&#34;https://www.gnu.org/licenses/agpl-3.0.en.html&#34;&gt;GNU Affero General Public License&lt;/a&gt;. Binaries and executable releases are licensed under the &lt;a href=&#34;https://lykos.ai/license&#34;&gt;End User License Agreement&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Giannoudis/TimePeriodLibrary</title>
    <updated>2023-08-24T01:26:59Z</updated>
    <id>tag:github.com,2023-08-24:/Giannoudis/TimePeriodLibrary</id>
    <link href="https://github.com/Giannoudis/TimePeriodLibrary" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extensive time period calculations and individual calendar periods.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;When implementing some software for another project, I came across several requirements involving calculations with time periods. These calculations were an important part of the solution and had high demands in respect to the correctness and accuracy of the results.&lt;/p&gt; &#xA;&lt;p&gt;The required functionality covered the following areas:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for individual time periods&lt;/li&gt; &#xA; &lt;li&gt;Working with calendar periods within calendar years&lt;/li&gt; &#xA; &lt;li&gt;Working with calendar periods deviating from the calendar year (fiscal or school periods)&lt;/li&gt; &#xA; &lt;li&gt;Working with the accounting and broadcast calendar&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The time calculations should be made available to both server components (Web Services and tasks) as well as for a rich client (WPF and Silverlight) and mobile devices.&lt;/p&gt; &#xA;&lt;p&gt;Analyzing the situation brought me to the conclusion that neither the components of the .NET Framework (which I didn&#39;t expect) nor any other available tools would cover all the requirements. Because I already encountered similar needs in earlier projects, I decided to develop a generic library for this purpose.&lt;/p&gt; &#xA;&lt;p&gt;From several development cycles resulted the following library &lt;strong&gt;Time Period&lt;/strong&gt;, which is now available for the following .NET runtime environments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.NET Framework from Version 3.5 or newer&lt;/li&gt; &#xA; &lt;li&gt;.NET Core Framework&lt;/li&gt; &#xA; &lt;li&gt;.NET Mono Framework&lt;/li&gt; &#xA; &lt;li&gt;Xamarin&lt;/li&gt; &#xA; &lt;li&gt;Universal Windows Platform - UWP&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Time Periods&lt;/h2&gt; &#xA;&lt;p&gt;The .NET Framework already offers the extensive base classes &lt;code&gt;DateTime&lt;/code&gt; and &lt;code&gt;TimeSpan&lt;/code&gt; for basic time related calculations. The library &lt;strong&gt;Time Period&lt;/strong&gt; extends the .NET Framework by several classes for handling periods of time. Such periods are basically characterized by a start, a duration, and an end:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriod.png&#34; alt=&#34;Time Period&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Per definition, the start always occurs before the end. The start is considered undefined if it holds the minimal possible value (&lt;code&gt;DateTime.MinValue&lt;/code&gt;). Likewise, the end is undefined if it holds the maximal possible value (&lt;code&gt;DateTime.MaxValue&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The implementation of these time periods is based on the interface &lt;code&gt;ITimePeriod&lt;/code&gt; and extended by the specializations &lt;code&gt;ITimeRange&lt;/code&gt;, &lt;code&gt;ITimeBlock&lt;/code&gt; and and &lt;code&gt;ITimeInterval&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodInterfaces_small.png&#34; alt=&#34;Time Period Interfaces&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The interface &lt;code&gt;ITimePeriod&lt;/code&gt; offers information and operations for time periods without defining the ways in which the crucial properties are being calculated:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Start&lt;/code&gt;, &lt;code&gt;End&lt;/code&gt;, and &lt;code&gt;Duration&lt;/code&gt; of the time period&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HasStart&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Start&lt;/code&gt; time is defined&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HasEnd&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;End&lt;/code&gt; time is defined&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IsAnytime&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if neither the &lt;code&gt;Start&lt;/code&gt; nor the &lt;code&gt;End&lt;/code&gt; times are defined&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IsMoment&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;End&lt;/code&gt; hold identical values&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IsReadOnly&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for immutable time periods (for its usage, see below)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The relation of two time periods is described by the enumeration &lt;code&gt;PeriodRelation&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/PeriodRelations_small.png&#34; alt=&#34;Time Period Relations&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Methods like &lt;code&gt;IsSamePeriod&lt;/code&gt;, &lt;code&gt;HasInside&lt;/code&gt;, &lt;code&gt;OverlapsWith&lt;/code&gt;, or &lt;code&gt;IntersectsWith&lt;/code&gt; are available for convenience to query for special, often used variants of such period relations.&lt;/p&gt; &#xA;&lt;h3&gt;Time Range&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;TimeRange&lt;/code&gt; as an implementation of &lt;code&gt;ITimeRange&lt;/code&gt; defines the time period by its &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;End&lt;/code&gt;; the duration is calculated from these:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeRange.png&#34; alt=&#34;Time Range&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;TimeRange&lt;/code&gt; can be created by specifying its &lt;code&gt;Start&lt;/code&gt;/&lt;code&gt;End&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt;/&lt;code&gt;Duration&lt;/code&gt;, or &lt;code&gt;Duration&lt;/code&gt;/&lt;code&gt;End&lt;/code&gt;. If required, the given &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;End&lt;/code&gt; will be sorted chronologically.&lt;/p&gt; &#xA;&lt;p&gt;For the modification of such a time period, various operations are available (Orange = new instance):&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeRangeOperations.png&#34; alt=&#34;Time Range Operations&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The following example shows the usage of &lt;code&gt;TimeRange&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimeRangeSample()&#xA;{&#xA;  // --- time range 1 ---&#xA;  TimeRange timeRange1 = new TimeRange(&#xA;    new DateTime( 2011, 2, 22, 14, 0, 0 ),&#xA;    new DateTime( 2011, 2, 22, 18, 0, 0 ) );&#xA;  Console.WriteLine( &#34;TimeRange1: &#34; + timeRange1 );&#xA;  // &amp;gt; TimeRange1: 22.02.2011 14:00:00 - 18:00:00 | 04:00:00&#xA;&#xA;  // --- time range 2 ---&#xA;  TimeRange timeRange2 = new TimeRange(&#xA;    new DateTime( 2011, 2, 22, 15, 0, 0 ),&#xA;    new TimeSpan( 2, 0, 0 ) );&#xA;  Console.WriteLine( &#34;TimeRange2: &#34; + timeRange2 );&#xA;  // &amp;gt; TimeRange2: 22.02.2011 15:00:00 - 17:00:00 | 02:00:00&#xA;&#xA;  // --- time range 3 ---&#xA;  TimeRange timeRange3 = new TimeRange(&#xA;    new DateTime( 2011, 2, 22, 16, 0, 0 ),&#xA;    new DateTime( 2011, 2, 22, 21, 0, 0 ) );&#xA;  Console.WriteLine( &#34;TimeRange3: &#34; + timeRange3 );&#xA;  // &amp;gt; TimeRange3: 22.02.2011 16:00:00 - 21:00:00 | 05:00:00&#xA;&#xA;  // --- relation ---&#xA;  Console.WriteLine( &#34;TimeRange1.GetRelation( TimeRange2 ): &#34; +&#xA;                     timeRange1.GetRelation( timeRange2 ) );&#xA;  // &amp;gt; TimeRange1.GetRelation( TimeRange2 ): Enclosing&#xA;  Console.WriteLine( &#34;TimeRange1.GetRelation( TimeRange3 ): &#34; +&#xA;                     timeRange1.GetRelation( timeRange3 ) );&#xA;  // &amp;gt; TimeRange1.GetRelation( TimeRange3 ): EndInside&#xA;  Console.WriteLine( &#34;TimeRange3.GetRelation( TimeRange2 ): &#34; +&#xA;                     timeRange3.GetRelation( timeRange2 ) );&#xA;  // &amp;gt; TimeRange3.GetRelation( TimeRange2 ): StartInside&#xA;&#xA;  // --- intersection ---&#xA;  Console.WriteLine( &#34;TimeRange1.GetIntersection( TimeRange2 ): &#34; +&#xA;                     timeRange1.GetIntersection( timeRange2 ) );&#xA;  // &amp;gt; TimeRange1.GetIntersection( TimeRange2 ):&#xA;  //             22.02.2011 15:00:00 - 17:00:00 | 02:00:00&#xA;  Console.WriteLine( &#34;TimeRange1.GetIntersection( TimeRange3 ): &#34; +&#xA;                     timeRange1.GetIntersection( timeRange3 ) );&#xA;  // &amp;gt; TimeRange1.GetIntersection( TimeRange3 ):&#xA;  //             22.02.2011 16:00:00 - 18:00:00 | 02:00:00&#xA;  Console.WriteLine( &#34;TimeRange3.GetIntersection( TimeRange2 ): &#34; +&#xA;                     timeRange3.GetIntersection( timeRange2 ) );&#xA;  // &amp;gt; TimeRange3.GetIntersection( TimeRange2 ):&#xA;  //             22.02.2011 16:00:00 - 17:00:00 | 01:00:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following example tests whether a reservation is within the working hours of a day:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public bool IsValidReservation( DateTime start, DateTime end )&#xA;{&#xA;  if ( !TimeCompare.IsSameDay( start, end ) )&#xA;  {&#xA;    return false;  // multiple day reservation&#xA;  }&#xA;&#xA;  TimeRange workingHours =&#xA;    new TimeRange( TimeTrim.Hour( start, 8 ), TimeTrim.Hour( start, 18 ) );&#xA;  return workingHours.HasInside( new TimeRange( start, end ) );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Time Block&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;TimeBlock&lt;/code&gt; implements the interface &lt;code&gt;ITimeBlock&lt;/code&gt; and defines the time period by &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;Duration&lt;/code&gt;; the &lt;code&gt;End&lt;/code&gt; is being calculated:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeBlock.png&#34; alt=&#34;Time Block&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;As with &lt;code&gt;TimeRange&lt;/code&gt;, a &lt;code&gt;TimeBlock&lt;/code&gt; can be created with &lt;code&gt;Start&lt;/code&gt;/&lt;code&gt;End&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt;/&lt;code&gt;Duration&lt;/code&gt;, or &lt;code&gt;Duration&lt;/code&gt;/&lt;code&gt;End&lt;/code&gt;. As above, &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;End&lt;/code&gt; will be automatically sorted if necessary.&lt;/p&gt; &#xA;&lt;p&gt;For the modification of a time block, these operations are available (Orange = new instance):&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeBlockOperations.png&#34; alt=&#34;Time Block Operations&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The following example shows the usage of &lt;code&gt;TimeBlock&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimeBlockSample()&#xA;{&#xA;  // --- time block ---&#xA;  TimeBlock timeBlock = new TimeBlock(&#xA;    new DateTime( 2011, 2, 22, 11, 0, 0 ),&#xA;    new TimeSpan( 2, 0, 0 ) );&#xA;  Console.WriteLine( &#34;TimeBlock: &#34; + timeBlock );&#xA;  // &amp;gt; TimeBlock: 22.02.2011 11:00:00 - 13:00:00 | 02:00:00&#xA;&#xA;  // --- modification ---&#xA;  timeBlock.Start = new DateTime( 2011, 2, 22, 15, 0, 0 );&#xA;  Console.WriteLine( &#34;TimeBlock.Start: &#34; + timeBlock );&#xA;  // &amp;gt; TimeBlock.Start: 22.02.2011 15:00:00 - 17:00:00 | 02:00:00&#xA;  timeBlock.Move( new TimeSpan( 1, 0, 0 ) );&#xA;  Console.WriteLine( &#34;TimeBlock.Move(1 hour): &#34; + timeBlock );&#xA;  // &amp;gt; TimeBlock.Move(1 hour): 22.02.2011 16:00:00 - 18:00:00 | 02:00:00&#xA;&#xA;  // --- previous/next ---&#xA;  Console.WriteLine( &#34;TimeBlock.GetPreviousPeriod(): &#34; +&#xA;                     timeBlock.GetPreviousPeriod() );&#xA;  // &amp;gt; TimeBlock.GetPreviousPeriod(): 22.02.2011 14:00:00 - 16:00:00 | 02:00:00&#xA;  Console.WriteLine( &#34;TimeBlock.GetNextPeriod(): &#34; + timeBlock.GetNextPeriod() );&#xA;  // &amp;gt; TimeBlock.GetNextPeriod(): 22.02.2011 18:00:00 - 20:00:00 | 02:00:00&#xA;  Console.WriteLine( &#34;TimeBlock.GetNextPeriod(+1 hour): &#34; +&#xA;                     timeBlock.GetNextPeriod( new TimeSpan( 1, 0, 0 ) ) );&#xA;  // &amp;gt; TimeBlock.GetNextPeriod(+1 hour): 22.02.2011 19:00:00 - 21:00:00 | 02:00:00&#xA;  Console.WriteLine( &#34;TimeBlock.GetNextPeriod(-1 hour): &#34; +&#xA;                     timeBlock.GetNextPeriod( new TimeSpan( -1, 0, 0 ) ) );&#xA;  // &amp;gt; TimeBlock.GetNextPeriod(-1 hour): 22.02.2011 17:00:00 - 19:00:00 | 02:00:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Time Interval&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ITimeInterval&lt;/code&gt; determines its period of time like &lt;code&gt;ITimeRange&lt;/code&gt; with a &lt;code&gt;Start&lt;/code&gt; and an &lt;code&gt;End&lt;/code&gt;. In addition, it is possible to control the interpretation of its &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;End&lt;/code&gt; by the enumeration &lt;code&gt;IntervalEdge&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Closed&lt;/code&gt;: The boundary moment of time is included in calculations. This corresponds to the behavior of &lt;code&gt;ITimeRange&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Open&lt;/code&gt;: The boundary moment of time represents a boundary value which is excluded in regard to calculations.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The possible interval variants look as follows:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeInterval_small.png&#34; alt=&#34;Time Interval&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Normally, edges in interval periods have the value &lt;code&gt;IntervalEdge.Closed&lt;/code&gt;, which leads to an intersection point with adjacent time periods. As soon as one of the adjacent points has its value set to &lt;code&gt;IntervalEdge.Open&lt;/code&gt;, no intersection point exists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimeIntervalSample()&#xA;{&#xA;  // --- time interval 1 ---&#xA;  TimeInterval timeInterval1 = new TimeInterval(&#xA;    new DateTime( 2011, 5, 8 ),&#xA;    new DateTime( 2011, 5, 9 ) );&#xA;  Console.WriteLine( &#34;TimeInterval1: &#34; + timeInterval1 );&#xA;  // &amp;gt; TimeInterval1: \[08.05.2011 - 09.05.2011\] | 1.00:00&#xA;&#xA;  // --- time interval 2 ---&#xA;  TimeInterval timeInterval2 = new TimeInterval(&#xA;    timeInterval1.End,&#xA;    timeInterval1.End.AddDays( 1 ) );&#xA;  Console.WriteLine( &#34;TimeInterval2: &#34; + timeInterval2 );&#xA;  // &amp;gt; TimeInterval2: \[09.05.2011 - 10.05.2011\] | 1.00:00&#xA;&#xA;  // --- relation ---&#xA;  Console.WriteLine( &#34;Relation: &#34; + timeInterval1.GetRelation( timeInterval2 ) );&#xA;  // &amp;gt; Relation: EndTouching&#xA;  Console.WriteLine( &#34;Intersection: &#34; +&#xA;                     timeInterval1.GetIntersection( timeInterval2 ) );&#xA;  // &amp;gt; Intersection: \[09.05.2011\]&#xA;&#xA;  timeInterval1.EndEdge = IntervalEdge.Open;&#xA;  Console.WriteLine( &#34;TimeInterval1: &#34; + timeInterval1 );&#xA;  // &amp;gt; TimeInterval1: \[08.05.2011 - 09.05.2011) | 1.00:00&#xA;&#xA;  timeInterval2.StartEdge = IntervalEdge.Open;&#xA;  Console.WriteLine( &#34;TimeInterval2: &#34; + timeInterval2 );&#xA;  // &amp;gt; TimeInterval2: (09.05.2011 - 10.05.2011\] | 1.00:00&#xA;&#xA;  // --- relation ---&#xA;  Console.WriteLine( &#34;Relation: &#34; + timeInterval1.GetRelation( timeInterval2 ) );&#xA;  // &amp;gt; Relation: Before&#xA;  Console.WriteLine( &#34;Intersection: &#34; +&#xA;                     timeInterval1.GetIntersection( timeInterval2 ) );&#xA;  // &amp;gt; Intersection:&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For certain scenarios, as for example the search for gaps in time periods, the exclusion of period edges can lead to undesired results. In such situations, it is possible to turn off this exclusion by setting the property &lt;code&gt;IsIntervalEnabled&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Time intervals without boundaries can be created using the value &lt;code&gt;TimeSpec.MinPeriodDate&lt;/code&gt; for &lt;code&gt;Start&lt;/code&gt;, and &lt;code&gt;TimeSpec.MaxPeriodDate&lt;/code&gt; for &lt;code&gt;End&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Time Period Container&lt;/h2&gt; &#xA;&lt;p&gt;In everyday usage, time calculations often involve several periods which can be collected in a container and operated upon as a whole. The &lt;strong&gt;Time Period&lt;/strong&gt; library offers the following containers for time periods:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodContainerInterfaces.png&#34; alt=&#34;Time Period Container Interfaces&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;All containers are based on the interface &lt;code&gt;ITimePeriod&lt;/code&gt;, so containers themselves represent a time period. Like this, they can be used in calculations like other periods, for example, &lt;code&gt;ITimeRange&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The interface &lt;code&gt;ITimePeriodContainer&lt;/code&gt; serves as the base for all containers, and offers list functionality by deriving from &lt;code&gt;IList&amp;lt;ITimePeriod&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Time Period Collection&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;ITimePeriodCollection&lt;/code&gt; can hold arbitrary elements of type &lt;code&gt;ITimePeriod&lt;/code&gt; and interprets the earliest start of all its elements as the start of the collection time period. Correspondingly, the latest end of all its elements serves as the end of the collection period:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodCollection.png&#34; alt=&#34;Time Period Collection&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The time period collection offers the following operations:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodCollectionOperations.png&#34; alt=&#34;Time Period Collection Operations&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The following example shows the usage of the class &lt;code&gt;TimePeriodCollection&lt;/code&gt;, which implements the interface &lt;code&gt;ITimePeriodCollection&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimePeriodCollectionSample()&#xA;{&#xA;  TimePeriodCollection timePeriods = new TimePeriodCollection();&#xA;&#xA;  DateTime testDay = new DateTime( 2010, 7, 23 );&#xA;&#xA;  // --- items ---&#xA;  timePeriods.Add( new TimeRange( TimeTrim.Hour( testDay, 8 ),&#xA;                   TimeTrim.Hour( testDay, 11 ) ) );&#xA;  timePeriods.Add( new TimeBlock( TimeTrim.Hour( testDay, 10 ), Duration.Hours( 3 ) ) );&#xA;  timePeriods.Add( new TimeRange( TimeTrim.Hour( testDay, 16, 15 ),&#xA;                   TimeTrim.Hour( testDay, 18, 45 ) ) );&#xA;  timePeriods.Add( new TimeRange( TimeTrim.Hour( testDay, 14 ),&#xA;                   TimeTrim.Hour( testDay, 15, 30 ) ) );&#xA;  Console.WriteLine( &#34;TimePeriodCollection: &#34; + timePeriods );&#xA;  // &amp;gt; TimePeriodCollection: Count = 4; 23.07.2010 08:00:00 - 18:45:00 | 0.10:45&#xA;  Console.WriteLine( &#34;TimePeriodCollection.Items&#34; );&#xA;  foreach ( ITimePeriod timePeriod in timePeriods )&#xA;  {&#xA;    Console.WriteLine( &#34;Item: &#34; + timePeriod );&#xA;  }&#xA;  // &amp;gt; Item: 23.07.2010 08:00:00 - 11:00:00 | 03:00:00&#xA;  // &amp;gt; Item: 23.07.2010 10:00:00 - 13:00:00 | 03:00:00&#xA;  // &amp;gt; Item: 23.07.2010 16:15:00 - 18:45:00 | 02:30:00&#xA;  // &amp;gt; Item: 23.07.2010 14:00:00 - 15:30:00 | 01:30:00&#xA;&#xA;  // --- intersection by moment ---&#xA;  DateTime intersectionMoment = new DateTime( 2010, 7, 23, 10, 30, 0 );&#xA;  ITimePeriodCollection momentIntersections =&#xA;     timePeriods.IntersectionPeriods( intersectionMoment );&#xA;  Console.WriteLine( &#34;TimePeriodCollection.IntesectionPeriods of &#34; +&#xA;                     intersectionMoment );&#xA;  // &amp;gt; TimePeriodCollection.IntesectionPeriods of 23.07.2010 10:30:00&#xA;  foreach ( ITimePeriod momentIntersection in momentIntersections )&#xA;  {&#xA;    Console.WriteLine( &#34;Intersection: &#34; + momentIntersection );&#xA;  }&#xA;  // &amp;gt; Intersection: 23.07.2010 08:00:00 - 11:00:00 | 03:00:00&#xA;  // &amp;gt; Intersection: 23.07.2010 10:00:00 - 13:00:00 | 03:00:00&#xA;&#xA;  // --- intersection by period ---&#xA;  TimeRange intersectionPeriod =&#xA;    new TimeRange( TimeTrim.Hour( testDay, 9 ),&#xA;                   TimeTrim.Hour( testDay, 14, 30 ) );&#xA;  ITimePeriodCollection periodIntersections =&#xA;    timePeriods.IntersectionPeriods( intersectionPeriod );&#xA;  Console.WriteLine( &#34;TimePeriodCollection.IntesectionPeriods of &#34; +&#xA;                     intersectionPeriod );&#xA;  // &amp;gt; TimePeriodCollection.IntesectionPeriods&#xA;  //      of 23.07.2010 09:00:00 - 14:30:00 | 0.05:30&#xA;  foreach ( ITimePeriod periodIntersection in periodIntersections )&#xA;  {&#xA;    Console.WriteLine( &#34;Intersection: &#34; + periodIntersection );&#xA;  }&#xA;  // &amp;gt; Intersection: 23.07.2010 08:00:00 - 11:00:00 | 03:00:00&#xA;  // &amp;gt; Intersection: 23.07.2010 10:00:00 - 13:00:00 | 03:00:00&#xA;  // &amp;gt; Intersection: 23.07.2010 14:00:00 - 15:30:00 | 01:30:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Time Period Chain&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ITimePeriodChain&lt;/code&gt; connects several time periods of type &lt;code&gt;ITimePeriod&lt;/code&gt; in a chain and ensures that no gaps exist between successive periods:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodChain.png&#34; alt=&#34;Time Period Chain&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Because &lt;code&gt;ITimePeriodChain&lt;/code&gt; might change the position of elements, no read-only time periods can be added. Attempting this leads to a &lt;code&gt;NotSupportedException&lt;/code&gt;. &lt;code&gt;ITimePeriodChain&lt;/code&gt; offers the following functionality:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodChainOperations.png&#34; alt=&#34;Time Period Chain Operations&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The following example shows the usage of class &lt;code&gt;TimePeriodChain&lt;/code&gt;, which implements the interface &lt;code&gt;ITimePeriodChain&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimePeriodChainSample()&#xA;{&#xA;  TimePeriodChain timePeriods = new TimePeriodChain();&#xA;&#xA;  DateTime now = ClockProxy.Clock.Now;&#xA;  DateTime testDay = new DateTime( 2010, 7, 23 );&#xA;&#xA;  // --- add ---&#xA;  timePeriods.Add( new TimeBlock(&#xA;                   TimeTrim.Hour( testDay, 8 ), Duration.Hours( 2 ) ) );&#xA;  timePeriods.Add( new TimeBlock( now, Duration.Hours( 1, 30 ) ) );&#xA;  timePeriods.Add( new TimeBlock( now, Duration.Hour ) );&#xA;  Console.WriteLine( &#34;TimePeriodChain.Add(): &#34; + timePeriods );&#xA;  // &amp;gt; TimePeriodChain.Add(): Count = 3; 23.07.2010 08:00:00 - 12:30:00 | 0.04:30&#xA;  foreach ( ITimePeriod timePeriod in timePeriods )&#xA;  {&#xA;    Console.WriteLine( &#34;Item: &#34; + timePeriod );&#xA;  }&#xA;  // &amp;gt; Item: 23.07.2010 08:00:00 - 10:00:00 | 02:00:00&#xA;  // &amp;gt; Item: 23.07.2010 10:00:00 - 11:30:00 | 01:30:00&#xA;  // &amp;gt; Item: 23.07.2010 11:30:00 - 12:30:00 | 01:00:00&#xA;&#xA;  // --- insert ---&#xA;  timePeriods.Insert( 2, new TimeBlock( now, Duration.Minutes( 45 ) ) );&#xA;  Console.WriteLine( &#34;TimePeriodChain.Insert(): &#34; + timePeriods );&#xA;  // &amp;gt; TimePeriodChain.Insert(): Count = 4; 23.07.2010 08:00:00 - 13:15:00 | 0.05:15&#xA;  foreach ( ITimePeriod timePeriod in timePeriods )&#xA;  {&#xA;    Console.WriteLine( &#34;Item: &#34; + timePeriod );&#xA;  }&#xA;  // &amp;gt; Item: 23.07.2010 08:00:00 - 10:00:00 | 02:00:00&#xA;  // &amp;gt; Item: 23.07.2010 10:00:00 - 11:30:00 | 01:30:00&#xA;  // &amp;gt; Item: 23.07.2010 11:30:00 - 12:15:00 | 00:45:00&#xA;  // &amp;gt; Item: 23.07.2010 12:15:00 - 13:15:00 | 01:00:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Calendar Time Periods&lt;/h2&gt; &#xA;&lt;p&gt;Calculations with calendar periods must consider the peculiarity that the end of a time period doesn&#39;t equal the start of the following period. The following example shows the corresponding values for the hours of day between 13h and 15h:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;13:00:00.0000000&lt;/code&gt; - &lt;code&gt;13:59:59.9999999&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;14:00:00.0000000&lt;/code&gt; - &lt;code&gt;14:59:59.9999999&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The end lies a moment before the next start, the difference between the two is at least 1 Tick = 100 nanoseconds. This is an important aspect and may not be neglected in calculations involving time periods.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;Time Period&lt;/strong&gt; library offers the interface &lt;code&gt;ITimePeriodMapper&lt;/code&gt;, which can convert moments of a time period in both directions. Applied to the scenario above, this would be handled as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimePeriodMapperSample()&#xA;{&#xA;  TimeCalendar timeCalendar = new TimeCalendar();&#xA;  CultureInfo ci = CultureInfo.InvariantCulture;&#xA;&#xA;  DateTime start = new DateTime( 2011, 3, 1, 13, 0, 0 );&#xA;  DateTime end = new DateTime( 2011, 3, 1, 14, 0, 0 );&#xA;&#xA;  Console.WriteLine( &#34;Original start: {0}&#34;,&#xA;                     start.ToString( &#34;HH:mm:ss.fffffff&#34;, ci ) );&#xA;  // &amp;gt; Original start: 13:00:00.0000000&#xA;  Console.WriteLine( &#34;Original end: {0}&#34;,&#xA;                     end.ToString( &#34;HH:mm:ss.fffffff&#34;, ci ) );&#xA;  // &amp;gt; Original end: 14:00:00.0000000&#xA;&#xA;  Console.WriteLine( &#34;Mapping offset start: {0}&#34;, timeCalendar.StartOffset );&#xA;  // &amp;gt; Mapping offset start: 00:00:00&#xA;  Console.WriteLine( &#34;Mapping offset end: {0}&#34;, timeCalendar.EndOffset );&#xA;  // &amp;gt; Mapping offset end: -00:00:00.0000001&#xA;&#xA;  Console.WriteLine( &#34;Mapped start: {0}&#34;,&#xA;    timeCalendar.MapStart( start ).ToString( &#34;HH:mm:ss.fffffff&#34;, ci ) );&#xA;  // &amp;gt; Mapped start: 13:00:00.0000000&#xA;  Console.WriteLine( &#34;Mapped end: {0}&#34;,&#xA;    timeCalendar.MapEnd( end ).ToString( &#34;HH:mm:ss.fffffff&#34;, ci ) );&#xA;  // &amp;gt; Mapped end: 13:59:59.9999999&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Time Calendar&lt;/h3&gt; &#xA;&lt;p&gt;The task of interpretation of time periods of calendar elements is combined in the interface &lt;code&gt;ITimeCalendar&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeCalendarInterfaces.png&#34; alt=&#34;Time Calendar Interfaces&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ITimeCalendar&lt;/code&gt; covers the following areas:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Assignment to a &lt;code&gt;CultureInfo&lt;/code&gt; (default = &lt;code&gt;CultureInfo&lt;/code&gt; of the current thread)&lt;/li&gt; &#xA; &lt;li&gt;Mapping of period boundaries (&lt;code&gt;ITimePeriodMapper&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Base month of the year (default = January)&lt;/li&gt; &#xA; &lt;li&gt;Definition of how to interpret calendar weeks&lt;/li&gt; &#xA; &lt;li&gt;Definition for accounting calendar&lt;/li&gt; &#xA; &lt;li&gt;Naming of periods like, for example, the name of the year (fiscal year, school year, ...)&lt;/li&gt; &#xA; &lt;li&gt;Various calendar related calculations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Deriving from &lt;code&gt;ITimePeriodMapper&lt;/code&gt;, the mapping of time period boundaries happens with the properties &lt;code&gt;StartOffset&lt;/code&gt; (default = 0) and &lt;code&gt;EndOffset&lt;/code&gt; (default = -1 Tick).&lt;/p&gt; &#xA;&lt;p&gt;The following example shows a specialization of a time calendar for a fiscal year:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class FiscalTimeCalendar : TimeCalendar&#xA;{&#xA;  public FiscalTimeCalendar(): &#xA;  base(&#xA;      new TimeCalendarConfig&#xA;      {&#xA;        YearBaseMonth = YearMonth.October,  //  October year base month&#xA;        YearWeekType = YearWeekType.Iso8601, // ISO 8601 week numbering&#xA;        YearType = YearType.FiscalYear // treat years as fiscal years&#xA;      } )&#xA;  {&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This time calendar can now be used as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void FiscalYearSample()&#xA;{&#xA;  FiscalTimeCalendar calendar = new FiscalTimeCalendar(); // use fiscal periods&#xA;&#xA;  DateTime moment1 = new DateTime( 2006, 9, 30 );&#xA;  Console.WriteLine( &#34;Fiscal Year of {0}: {1}&#34;, moment1.ToShortDateString(),&#xA;                     new Year( moment1, calendar ).YearName );&#xA;  // &amp;gt; Fiscal Year of 30.09.2006: FY2005&#xA;  Console.WriteLine( &#34;Fiscal Quarter of {0}: {1}&#34;, moment1.ToShortDateString(),&#xA;                     new Quarter( moment1, calendar ).QuarterOfYearName );&#xA;  // &amp;gt; Fiscal Quarter of 30.09.2006: FQ4 2005&#xA;&#xA;  DateTime moment2 = new DateTime( 2006, 10, 1 );&#xA;  Console.WriteLine( &#34;Fiscal Year of {0}: {1}&#34;, moment2.ToShortDateString(),&#xA;                     new Year( moment2, calendar ).YearName );&#xA;  // &amp;gt; Fiscal Year of 01.10.2006: FY2006&#xA;  Console.WriteLine( &#34;Fiscal Quarter of {0}: {1}&#34;, moment1.ToShortDateString(),&#xA;                     new Quarter( moment2, calendar ).QuarterOfYearName );&#xA;  // &amp;gt; Fiscal Quarter of 30.09.2006: FQ1 2006&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A more thorough description of the classes &lt;code&gt;Year&lt;/code&gt; and &lt;code&gt;Quarter&lt;/code&gt; follows below.&lt;/p&gt; &#xA;&lt;h3&gt;Calendar Elements&lt;/h3&gt; &#xA;&lt;p&gt;For the most commonly used calendar elements, specialized classes are available:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Time period&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Single period&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Multiple periods&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Refers to year&#39;s base month&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Year&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Year&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Years&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Yes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Broadcast year&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;BroadcastYear&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Half year&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Halfyear&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Halfyears&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Yes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Quarter&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Quarter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Quarters&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Yes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Month&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Month&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Months&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Broadcast month&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;BroadcastMonth&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Week&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Week&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Weeks&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Broadcast week&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;BroadcastWeek&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Day&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Day&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Days&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Hour&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Hour&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Hours&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Minute&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Minute&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Minutes&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Instantiating elements with multiple periods can happen with a specified number of periods.&lt;/p&gt; &#xA;&lt;p&gt;The following diagram shows the calendar elements for quarters and months, other elements are analogous:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodCalendarClasses.png&#34; alt=&#34;Time Period Calendar Classes&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;All calendar elements derive from the base class &lt;code&gt;CalendarTimeRange&lt;/code&gt; which itself derives from &lt;code&gt;TimeRange&lt;/code&gt;. &lt;code&gt;CalendarTimeRange&lt;/code&gt; contains the time calendar &lt;code&gt;ITimeCalendar&lt;/code&gt; and thus ensures that the values of the time period cannot be changed after creation (&lt;code&gt;IsReadOnly=true&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Because by inheritance through the base class &lt;code&gt;TimePeriod&lt;/code&gt;, the calendar elements implement the interface &lt;code&gt;ITimePeriod&lt;/code&gt;, they can all be used for calculations with other time periods.&lt;/p&gt; &#xA;&lt;p&gt;The following example shows various calendar elements:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void CalendarYearTimePeriodsSample()&#xA;{&#xA;  DateTime moment = new DateTime( 2011, 8, 15 );&#xA;  Console.WriteLine( &#34;Calendar Periods of {0}:&#34;, moment.ToShortDateString() );&#xA;  // &amp;gt; Calendar Periods of 15.08.2011:&#xA;  Console.WriteLine( &#34;Year     : {0}&#34;, new Year( moment ) );&#xA;  Console.WriteLine( &#34;Halfyear : {0}&#34;, new Halfyear( moment ) );&#xA;  Console.WriteLine( &#34;Quarter  : {0}&#34;, new Quarter( moment ) );&#xA;  Console.WriteLine( &#34;Month    : {0}&#34;, new Month( moment ) );&#xA;  Console.WriteLine( &#34;Week     : {0}&#34;, new Week( moment ) );&#xA;  Console.WriteLine( &#34;Day      : {0}&#34;, new Day( moment ) );&#xA;  Console.WriteLine( &#34;Hour     : {0}&#34;, new Hour( moment ) );&#xA;  // &amp;gt; Year     : 2011; 01.01.2011 - 31.12.2011 | 364.23:59&#xA;  // &amp;gt; Halfyear : HY2 2011; 01.07.2011 - 31.12.2011 | 183.23:59&#xA;  // &amp;gt; Quarter  : Q3 2011; 01.07.2011 - 30.09.2011 | 91.23:59&#xA;  // &amp;gt; Month    : August 2011; 01.08.2011 - 31.08.2011 | 30.23:59&#xA;  // &amp;gt; Week     : w/c 33 2011; 15.08.2011 - 21.08.2011 | 6.23:59&#xA;  // &amp;gt; Day      : Montag; 15.08.2011 - 15.08.2011 | 0.23:59&#xA;  // &amp;gt; Hour     : 15.08.2011; 00:00 - 00:59 | 0.00:59&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some specific calendar elements offer methods to access the time periods of their sub-elements. The following example shows the quarters of a calendar year:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void YearQuartersSample()&#xA;{&#xA;  Year year = new Year( 2012 );&#xA;  ITimePeriodCollection quarters = year.GetQuarters();&#xA;  Console.WriteLine( &#34;Quarters of Year: {0}&#34;, year );&#xA;  // &amp;gt; Quarters of Year: 2012; 01.01.2012 - 31.12.2012 | 365.23:59&#xA;  foreach ( Quarter quarter in quarters )&#xA;  {&#xA;    Console.WriteLine( &#34;Quarter: {0}&#34;, quarter );&#xA;  }&#xA;  // &amp;gt; Quarter: Q1 2012; 01.01.2012 - 31.03.2012 | 90.23:59&#xA;  // &amp;gt; Quarter: Q2 2012; 01.04.2012 - 30.06.2012 | 90.23:59&#xA;  // &amp;gt; Quarter: Q3 2012; 01.07.2012 - 30.09.2012 | 91.23:59&#xA;  // &amp;gt; Quarter: Q4 2012; 01.10.2012 - 31.12.2012 | 91.23:59&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Year and Year Periods&lt;/h3&gt; &#xA;&lt;p&gt;A peculiarity of the calendar elements is their support for calendar periods which deviate from (normal) calendar years:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/Year_small.png&#34; alt=&#34;Year&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The beginning of the year can be set through the property &lt;code&gt;ITimeCalendar.YearBaseMonth&lt;/code&gt; and will be considered by the calendar elements Year, Half Year, and Quarter. Valid values for the start of a year can be an arbitrary month. The calendar year thus simply represents the special case where &lt;code&gt;YearBaseMonth = YearMonth.January&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following properties govern the interpretation of the boundaries between years:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;MultipleCalendarYears&lt;/code&gt; holds &lt;code&gt;true&lt;/code&gt; if a period spans over multiple calendar years&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IsCalendarYear&lt;/code&gt;/&lt;code&gt;Halfyear&lt;/code&gt;/&lt;code&gt;Quarter&lt;/code&gt; holds &lt;code&gt;true&lt;/code&gt; if a period corresponds the one of the calendar year&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Fiscal years which start in July or later conventionally use the year number of the following calendar year. The calendar property &lt;code&gt;FiscalYearBaseMonth&lt;/code&gt; offers the possibility to define the month, after which the fiscal year will be assigned the following calendar year.&lt;/p&gt; &#xA;&lt;p&gt;The following example shows the calendar elements of a fiscal year:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void FiscalYearTimePeriodsSample()&#xA;{&#xA;  DateTime moment = new DateTime( 2011, 8, 15 );&#xA;  FiscalTimeCalendar fiscalCalendar = new FiscalTimeCalendar();&#xA;  Console.WriteLine( &#34;Fiscal Year Periods of {0}:&#34;, moment.ToShortDateString() );&#xA;  // &amp;gt; Fiscal Year Periods of 15.08.2011:&#xA;  Console.WriteLine( &#34;Year     : {0}&#34;, new Year( moment, fiscalCalendar ) );&#xA;  Console.WriteLine( &#34;Halfyear : {0}&#34;, new Halfyear( moment, fiscalCalendar ) );&#xA;  Console.WriteLine( &#34;Quarter  : {0}&#34;, new Quarter( moment, fiscalCalendar ) );&#xA;  // &amp;gt; Year     : FY2010; 01.10.2010 - 30.09.2011 | 364.23:59&#xA;  // &amp;gt; Halfyear : FHY2 2010; 01.04.2011 - 30.09.2011 | 182.23:59&#xA;  // &amp;gt; Quarter  : FQ4 2010; 01.07.2011 - 30.09.2011 | 91.23:59&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Moving the beginning of the year influences the outcome of all contained elements and their operations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void YearStartSample()&#xA;{&#xA;  TimeCalendar calendar = new TimeCalendar(&#xA;    new TimeCalendarConfig { YearBaseMonth = YearMonth.February } );&#xA;&#xA;  Years years = new Years( 2012, 2, calendar ); // 2012-2013&#xA;  Console.WriteLine( &#34;Quarters of Years (February): {0}&#34;, years );&#xA;  // &amp;gt; Quarters of Years (February): 2012 - 2014; 01.02.2012 - 31.01.2014 | 730.23:59&#xA;&#xA;  foreach ( Year year in years.GetYears() )&#xA;  {&#xA;    foreach ( Quarter quarter in year.GetQuarters() )&#xA;    {&#xA;      Console.WriteLine( &#34;Quarter: {0}&#34;, quarter );&#xA;    }&#xA;  }&#xA;  // &amp;gt; Quarter: Q1 2012; 01.02.2012 - 30.04.2012 | 89.23:59&#xA;  // &amp;gt; Quarter: Q2 2012; 01.05.2012 - 31.07.2012 | 91.23:59&#xA;  // &amp;gt; Quarter: Q3 2012; 01.08.2012 - 31.10.2012 | 91.23:59&#xA;  // &amp;gt; Quarter: Q4 2012; 01.11.2012 - 31.01.2013 | 91.23:59&#xA;  // &amp;gt; Quarter: Q1 2013; 01.02.2013 - 30.04.2013 | 88.23:59&#xA;  // &amp;gt; Quarter: Q2 2013; 01.05.2013 - 31.07.2013 | 91.23:59&#xA;  // &amp;gt; Quarter: Q3 2013; 01.08.2013 - 31.10.2013 | 91.23:59&#xA;  // &amp;gt; Quarter: Q4 2013; 01.11.2013 - 31.01.2014 | 91.23:59&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Following are some illustrative usages of often useful utility functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public bool IntersectsYear( DateTime start, DateTime end, int year )&#xA;{&#xA;  return new Year( year ).IntersectsWith( new TimeRange( start, end ) );&#xA;}&#xA;&#xA;public void GetDaysOfPastQuarter( DateTime moment,&#xA;       out DateTime firstDay, out DateTime lastDay )&#xA;{&#xA;  TimeCalendar calendar = new TimeCalendar(&#xA;    new TimeCalendarConfig { YearBaseMonth = YearMonth.October } );&#xA;  Quarter quarter = new Quarter( moment, calendar );&#xA;  Quarter pastQuarter = quarter.GetPreviousQuarter();&#xA;&#xA;  firstDay = pastQuarter.FirstDayStart;&#xA;  lastDay = pastQuarter.LastDayStart;&#xA;}&#xA;&#xA;public DateTime GetFirstDayOfWeek( DateTime moment )&#xA;{&#xA;  return new Week( moment ).FirstDayStart;&#xA;}&#xA;&#xA;public bool IsInCurrentWeek( DateTime test )&#xA;{&#xA;  return new Week().HasInside( test );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Weeks&lt;/h3&gt; &#xA;&lt;p&gt;Common practice numbers the weeks of a year from 1 to 52/53. The .NET Framework offers in &lt;code&gt;Calendar.GetWeekOfYear&lt;/code&gt; a method to get at this number of the week for a given moment in time. Unfortunately, this deviates from the definition given in &lt;a href=&#34;http://www.iso.org/iso/support/faqs/faqs_widely_used_standards/widely_used_standards_other/date_and_time_format.htm&#34;&gt;ISO 8601&lt;/a&gt;, which can lead to wrong interpretations and other misbehavior.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;Time Period&lt;/strong&gt; library contains the enumeration &lt;code&gt;YearWeekType&lt;/code&gt;, which controls the calculation of calendar week numbers according to ISO 8601. &lt;code&gt;YearWeekType&lt;/code&gt; is supported by &lt;code&gt;ITimeCalendar&lt;/code&gt; and thus defines the different ways of calculation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// see also http://blogs.msdn.com/b/shawnste/archive/2006/01/24/517178.aspx&#xA;public void CalendarWeekSample()&#xA;{&#xA;  DateTime testDate = new DateTime( 2007, 12, 31 );&#xA;&#xA;  // .NET calendar week&#xA;  TimeCalendar calendar = new TimeCalendar();&#xA;  Console.WriteLine( &#34;Calendar Week of {0}: {1}&#34;, testDate.ToShortDateString(),&#xA;                     new Week( testDate, calendar ).WeekOfYear );&#xA;  // &amp;gt; Calendar Week of 31.12.2007: 53&#xA;&#xA;  // ISO 8601 calendar week&#xA;  TimeCalendar calendarIso8601 = new TimeCalendar(&#xA;    new TimeCalendarConfig { YearWeekType = YearWeekType.Iso8601 } );&#xA;  Console.WriteLine( &#34;ISO 8601 Week of {0}: {1}&#34;, testDate.ToShortDateString(),&#xA;                     new Week( testDate, calendarIso8601 ).WeekOfYear );&#xA;  // &amp;gt; ISO 8601 Week of 31.12.2007: 1&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Accounting Calendar&lt;/h3&gt; &#xA;&lt;p&gt;To simplify planning, accounting related industries often structure years into quarters which are composed of months with either four or five weeks (&lt;a href=&#34;http://en.wikipedia.org/wiki/4-4-5_Calendar&#34;&gt;4-4-5 calendar&lt;/a&gt;). Such a year is usually aligned to&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the last week day of a month (&lt;code&gt;FiscalYearAlignment.LastDay&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;a week day close to the end of the month (&lt;code&gt;FiscalYearAlignment.NearestDay&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Arrangement of the weeks occurs according to the following grouping criteria:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;4-4-5 weeks (&lt;code&gt;FiscalQuarterGrouping.FourFourFiveWeeks&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;4-5-4 weeks (&lt;code&gt;FiscalQuarterGrouping.FourFiveFourWeeks&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;5-4-4 weeks (&lt;code&gt;FiscalQuarterGrouping.FiveFourFourWeeks&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Control of this behavior is located in &lt;code&gt;ITimeCalendar&lt;/code&gt; and only applies to fiscal years (&lt;code&gt;YearType.FiscalYear&lt;/code&gt;). The calendar property &lt;code&gt;FiscalFirstDayOfYear&lt;/code&gt; determines the week day on which a year begins.&lt;/p&gt; &#xA;&lt;p&gt;The following example shows a fiscal year which ends on the last Saturday of August:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void FiscalYearLastDay()&#xA;{&#xA;  ITimeCalendar calendar = new TimeCalendar( new TimeCalendarConfig&#xA;  {&#xA;    YearType = YearType.FiscalYear,&#xA;    YearBaseMonth = YearMonth.September,&#xA;    FiscalFirstDayOfYear = DayOfWeek.Sunday,&#xA;    FiscalYearAlignment = FiscalYearAlignment.LastDay,&#xA;    FiscalQuarterGrouping = FiscalQuarterGrouping.FourFourFiveWeeks&#xA;  } );&#xA;&#xA;  Years years = new Years( 2005, 14, calendar );&#xA;  foreach ( Year year in years.GetYears() )&#xA;  {&#xA;    Console.WriteLine( &#34;Fiscal year {0}: {1} - {2}&#34;, year.YearValue,&#xA;      year.Start.ToString( &#34;yyyy-MM-dd&#34; ), year.End.ToString( &#34;yyyy-MM-dd&#34; ) );&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following fiscal year ends on that Saturday which is closer to the end of August:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void FiscalYearNearestDay()&#xA;{&#xA;  ITimeCalendar calendar = new TimeCalendar( new TimeCalendarConfig&#xA;  {&#xA;    YearType = YearType.FiscalYear,&#xA;    YearBaseMonth = YearMonth.September,&#xA;    FiscalFirstDayOfYear = DayOfWeek.Sunday,&#xA;    FiscalYearAlignment = FiscalYearAlignment.NearestDay,&#xA;    FiscalQuarterGrouping = FiscalQuarterGrouping.FourFourFiveWeeks&#xA;  } );&#xA;&#xA;  Years years = new Years( 2005, 14, calendar );&#xA;  foreach ( Year year in years.GetYears() )&#xA;  {&#xA;    Console.WriteLine( &#34;Fiscal year {0}: {1} - {2}&#34;, year.YearValue,&#xA;      year.Start.ToString( &#34;yyyy-MM-dd&#34; ), year.End.ToString( &#34;yyyy-MM-dd&#34; ) );&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Broadcast Calendar&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Broadcast_calendar&#34;&gt;Broadcast Calendar&lt;/a&gt; is supported by the classes &lt;code&gt;BroadcastYear&lt;/code&gt;, &lt;code&gt;BroadcastMonth&lt;/code&gt; and &lt;code&gt;BroadcastWeek&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void BroadcastCalendar()&#xA;{&#xA;  BroadcastYear year = new BroadcastYear( 2013 );&#xA;  Console.WriteLine( &#34;Broadcast year: &#34; + year );&#xA;  // &amp;gt; Broadcast year: 2013; 31.12.2012 - 29.12.2013 | 363.23:59&#xA;  foreach ( BroadcastMonth month in year.GetMonths() )&#xA;  {&#xA;    Console.WriteLine( &#34; Broadcast month: &#34; + month );&#xA;    foreach ( BroadcastWeek week in month.GetWeeks() )&#xA;    {&#xA;      Console.WriteLine( &#34; Broadcast week: &#34; + week );&#xA;    }&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Time Period Calculation Tools&lt;/h2&gt; &#xA;&lt;h3&gt;Time Line&lt;/h3&gt; &#xA;&lt;p&gt;The class &lt;code&gt;TimeLine&lt;/code&gt; is at the heart of calculations regarding time gaps and overlaps. It analyzes the time periods of a Collection by ordering them according to occurrence of the respective moments in time. Each moment on the time line is represented as an &lt;code&gt;ITimeLineMoment&lt;/code&gt; and contains the information about which time periods start and end at a specific moment. This representation allows for keeping track of a running balance by addition and subtraction while processing a time line.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeLine.png&#34; alt=&#34;Time Line&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The moments of the time axis are stored in the &lt;code&gt;ITimeLineMomentCollection&lt;/code&gt; which allows efficient access for iteration and by index based on moments of time.&lt;/p&gt; &#xA;&lt;h3&gt;Difference between Two Points of Time&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;TimeSpan&lt;/code&gt; structure of the .NET Framework just offers the time range values for days, hours, minutes, seconds and milliseconds. From a user perspective, it is often desirable to also represent the months and years of a time range:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Last visit 1 year, 4 months and 12 days ago&lt;/li&gt; &#xA; &lt;li&gt;Current age: 28 years&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;strong&gt;Time Period&lt;/strong&gt; library includes the class &lt;code&gt;DateDiff&lt;/code&gt;, which calculates the difference in time between two date values and also offers access to the elapsed time range. This properly considers calendar periods to account for varying month durations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void DateDiffSample()&#xA;{&#xA;  DateTime date1 = new DateTime( 2009, 11, 8, 7, 13, 59 );&#xA;  Console.WriteLine( &#34;Date1: {0}&#34;, date1 );&#xA;  // &amp;gt; Date1: 08.11.2009 07:13:59&#xA;  DateTime date2 = new DateTime( 2011, 3, 20, 19, 55, 28 );&#xA;  Console.WriteLine( &#34;Date2: {0}&#34;, date2 );&#xA;  // &amp;gt; Date2: 20.03.2011 19:55:28&#xA;&#xA;  DateDiff dateDiff = new DateDiff( date1, date2 );&#xA;&#xA;  // differences&#xA;  Console.WriteLine( &#34;DateDiff.Years: {0}&#34;, dateDiff.Years );&#xA;  // &amp;gt; DateDiff.Years: 1&#xA;  Console.WriteLine( &#34;DateDiff.Quarters: {0}&#34;, dateDiff.Quarters );&#xA;  // &amp;gt; DateDiff.Quarters: 5&#xA;  Console.WriteLine( &#34;DateDiff.Months: {0}&#34;, dateDiff.Months );&#xA;  // &amp;gt; DateDiff.Months: 16&#xA;  Console.WriteLine( &#34;DateDiff.Weeks: {0}&#34;, dateDiff.Weeks );&#xA;  // &amp;gt; DateDiff.Weeks: 70&#xA;  Console.WriteLine( &#34;DateDiff.Days: {0}&#34;, dateDiff.Days );&#xA;  // &amp;gt; DateDiff.Days: 497&#xA;  Console.WriteLine( &#34;DateDiff.Weekdays: {0}&#34;, dateDiff.Weekdays );&#xA;  // &amp;gt; DateDiff.Weekdays: 71&#xA;  Console.WriteLine( &#34;DateDiff.Hours: {0}&#34;, dateDiff.Hours );&#xA;  // &amp;gt; DateDiff.Hours: 11940&#xA;  Console.WriteLine( &#34;DateDiff.Minutes: {0}&#34;, dateDiff.Minutes );&#xA;  // &amp;gt; DateDiff.Minutes: 716441&#xA;  Console.WriteLine( &#34;DateDiff.Seconds: {0}&#34;, dateDiff.Seconds );&#xA;  // &amp;gt; DateDiff.Seconds: 42986489&#xA;&#xA;  // elapsed&#xA;  Console.WriteLine( &#34;DateDiff.ElapsedYears: {0}&#34;, dateDiff.ElapsedYears );&#xA;  // &amp;gt; DateDiff.ElapsedYears: 1&#xA;  Console.WriteLine( &#34;DateDiff.ElapsedMonths: {0}&#34;, dateDiff.ElapsedMonths );&#xA;  // &amp;gt; DateDiff.ElapsedMonths: 4&#xA;  Console.WriteLine( &#34;DateDiff.ElapsedDays: {0}&#34;, dateDiff.ElapsedDays );&#xA;  // &amp;gt; DateDiff.ElapsedDays: 12&#xA;  Console.WriteLine( &#34;DateDiff.ElapsedHours: {0}&#34;, dateDiff.ElapsedHours );&#xA;  // &amp;gt; DateDiff.ElapsedHours: 12&#xA;  Console.WriteLine( &#34;DateDiff.ElapsedMinutes: {0}&#34;, dateDiff.ElapsedMinutes );&#xA;  // &amp;gt; DateDiff.ElapsedMinutes: 41&#xA;  Console.WriteLine( &#34;DateDiff.ElapsedSeconds: {0}&#34;, dateDiff.ElapsedSeconds );&#xA;  // &amp;gt; DateDiff.ElapsedSeconds: 29&#xA;&#xA;  // description&#xA;  Console.WriteLine( &#34;DateDiff.GetDescription(1): {0}&#34;, dateDiff.GetDescription( 1 ) );&#xA;  // &amp;gt; DateDiff.GetDescription(1): 1 Year&#xA;  Console.WriteLine( &#34;DateDiff.GetDescription(2): {0}&#34;, dateDiff.GetDescription( 2 ) );&#xA;  // &amp;gt; DateDiff.GetDescription(2): 1 Year 4 Months&#xA;  Console.WriteLine( &#34;DateDiff.GetDescription(3): {0}&#34;, dateDiff.GetDescription( 3 ) );&#xA;  // &amp;gt; DateDiff.GetDescription(3): 1 Year 4 Months 12 Days&#xA;  Console.WriteLine( &#34;DateDiff.GetDescription(4): {0}&#34;, dateDiff.GetDescription( 4 ) );&#xA;  // &amp;gt; DateDiff.GetDescription(4): 1 Year 4 Months 12 Days 12 Hours&#xA;  Console.WriteLine( &#34;DateDiff.GetDescription(5): {0}&#34;, dateDiff.GetDescription( 5 ) );&#xA;  // &amp;gt; DateDiff.GetDescription(5): 1 Year 4 Months 12 Days 12 Hours 41 Mins&#xA;  Console.WriteLine( &#34;DateDiff.GetDescription(6): {0}&#34;, dateDiff.GetDescription( 6 ) );&#xA;  // &amp;gt; DateDiff.GetDescription(6): 1 Year 4 Months 12 Days 12 Hours 41 Mins 29 Secs&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The method &lt;code&gt;DateDiff.GetDescription&lt;/code&gt; can format the time duration with variable level of detail.&lt;/p&gt; &#xA;&lt;h3&gt;Time Gap Calculation&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;TimeGapCalculator&lt;/code&gt; calculates the gaps between time periods in a collection:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimeGapCalculator.png&#34; alt=&#34;Time Gap Calculator&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Interpretation of the moments of time can be subject to the application of a &lt;code&gt;ITimePeriodMapper&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following example shows how to find the largest possible gap between existing bookings while considering weekends as unavailable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimeGapCalculatorSample()&#xA;{&#xA;  // simulation of some reservations&#xA;  TimePeriodCollection reservations = new TimePeriodCollection();&#xA;  reservations.Add( new Days( 2011, 3, 7, 2 ) );&#xA;  reservations.Add( new Days( 2011, 3, 16, 2 ) );&#xA;&#xA;  // the overall search range&#xA;  CalendarTimeRange searchLimits = new CalendarTimeRange(&#xA;      new DateTime( 2011, 3, 4 ), new DateTime( 2011, 3, 21 ) );&#xA;&#xA;  // search the largest free time block&#xA;  ICalendarTimeRange largestFreeTimeBlock =&#xA;      FindLargestFreeTimeBlock( reservations, searchLimits );&#xA;  Console.WriteLine( &#34;Largest free time: &#34; + largestFreeTimeBlock );&#xA;  // &amp;gt; Largest free time: 09.03.2011 00:00:00 - 11.03.2011 23:59:59 | 2.23:59&#xA;}&#xA;&#xA;public ICalendarTimeRange FindLargestFreeTimeBlock(&#xA;       IEnumerable&amp;lt;ITimePeriod&amp;gt; reservations,&#xA;       ITimePeriod searchLimits = null, bool excludeWeekends = true )&#xA;{&#xA;  TimePeriodCollection bookedPeriods = new TimePeriodCollection( reservations );&#xA;&#xA;  if ( searchLimits == null )&#xA;  {&#xA;    searchLimits = bookedPeriods; // use boundary of reservations&#xA;  }&#xA;&#xA;  if ( excludeWeekends )&#xA;  {&#xA;    Week currentWeek = new Week( searchLimits.Start );&#xA;    Week lastWeek = new Week( searchLimits.End );&#xA;    do&#xA;    {&#xA;      ITimePeriodCollection days = currentWeek.GetDays();&#xA;      foreach ( Day day in days )&#xA;      {&#xA;        if ( !searchLimits.HasInside( day ) )&#xA;        {&#xA;          continue; // outside of the search scope&#xA;        }&#xA;        if ( day.DayOfWeek == DayOfWeek.Saturday ||&#xA;             day.DayOfWeek == DayOfWeek.Sunday )&#xA;        {&#xA;          bookedPeriods.Add( day ); // // exclude weekend day&#xA;        }&#xA;      }&#xA;      currentWeek = currentWeek.GetNextWeek();&#xA;    } while ( currentWeek.Start &amp;lt; lastWeek.Start );&#xA;  }&#xA;&#xA;  // calculate the gaps using the time calendar as period mapper&#xA;  TimeGapCalculator&amp;lt;TimeRange&amp;gt; gapCalculator =&#xA;    new TimeGapCalculator&amp;lt;TimeRange&amp;gt;( new TimeCalendar() );&#xA;  ITimePeriodCollection freeTimes =&#xA;    gapCalculator.GetGaps( bookedPeriods, searchLimits );&#xA;  if ( freeTimes.Count == 0 )&#xA;  {&#xA;    return null;&#xA;  }&#xA;&#xA;  freeTimes.SortByDuration(); // move the largest gap to the start&#xA;  return new CalendarTimeRange( freeTimes\[ 0 \] );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Consolidation of Time Periods&lt;/h3&gt; &#xA;&lt;p&gt;In some situations, it is reasonable to have a consolidated view on overlapping or adjacent time periods - e.g., the contrary of finding gaps. The class &lt;code&gt;TimePeriodCombiner&lt;/code&gt; offers this possibility to consolidate such time periods:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodCombiner.png&#34; alt=&#34;Time Period Combiner&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The following example shows the combination of time periods according to the illustration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimePeriodCombinerSample()&#xA;{&#xA;  TimePeriodCollection periods = new TimePeriodCollection();&#xA;&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 01 ), new DateTime( 2011, 3, 10 ) ) );&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 04 ), new DateTime( 2011, 3, 08 ) ) );&#xA;&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 15 ), new DateTime( 2011, 3, 18 ) ) );&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 18 ), new DateTime( 2011, 3, 22 ) ) );&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 20 ), new DateTime( 2011, 3, 24 ) ) );&#xA;&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 26 ), new DateTime( 2011, 3, 30 ) ) );&#xA;&#xA;  TimePeriodCombiner&amp;lt;TimeRange&amp;gt; periodCombiner = new TimePeriodCombiner&amp;lt;TimeRange&amp;gt;();&#xA;  ITimePeriodCollection combinedPeriods = periodCombiner.CombinePeriods( periods );&#xA;&#xA;  foreach ( ITimePeriod combinedPeriod in combinedPeriods )&#xA;  {&#xA;    Console.WriteLine( &#34;Combined Period: &#34; + combinedPeriod );&#xA;  }&#xA;  // &amp;gt; Combined Period: 01.03.2011 - 10.03.2011 | 9.00:00&#xA;  // &amp;gt; Combined Period: 15.03.2011 - 24.03.2011 | 9.00:00&#xA;  // &amp;gt; Combined Period: 26.03.2011 - 30.03.2011 | 4.00:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Intersections of Time Periods&lt;/h3&gt; &#xA;&lt;p&gt;If time periods should be checked for intersections (e.g., duplicate bookings), the class &lt;code&gt;TimePeriodIntersector&lt;/code&gt; comes to the rescue:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodIntersector.png&#34; alt=&#34;Time Periods Intersector&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;By default, the intersection periods are combined into one. To maintain all intersection periods, the parameter &lt;code&gt;combinePeriods&lt;/code&gt; of the method &lt;code&gt;IntersectPeriods&lt;/code&gt; can be set to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following example shows the usage of &lt;code&gt;TimePeriodIntersector&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// ----------------------------------------------------------------------&#xA;public void TimePeriodIntersectorSample()&#xA;{&#xA;  TimePeriodCollection periods = new TimePeriodCollection();&#xA;&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 01 ), new DateTime( 2011, 3, 10 ) ) );&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 05 ), new DateTime( 2011, 3, 15 ) ) );&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 12 ), new DateTime( 2011, 3, 18 ) ) );&#xA;&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 20 ), new DateTime( 2011, 3, 24 ) ) );&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 22 ), new DateTime( 2011, 3, 28 ) ) );&#xA;  periods.Add( new TimeRange( new DateTime( 2011, 3, 24 ), new DateTime( 2011, 3, 26 ) ) );&#xA;&#xA;  TimePeriodIntersector&amp;lt;TimeRange&amp;gt; periodIntersector =&#xA;                    new TimePeriodIntersector&amp;lt;TimeRange&amp;gt;();&#xA;  ITimePeriodCollection intersectedPeriods = periodIntersector.IntersectPeriods( periods );&#xA;&#xA;  foreach ( ITimePeriod intersectedPeriod in intersectedPeriods )&#xA;  {&#xA;    Console.WriteLine( &#34;Intersected Period: &#34; + intersectedPeriod );&#xA;  }&#xA;  // &amp;gt; Intersected Period: 05.03.2011 - 10.03.2011 | 5.00:00&#xA;  // &amp;gt; Intersected Period: 12.03.2011 - 15.03.2011 | 3.00:00&#xA;  // &amp;gt; Intersected Period: 22.03.2011 - 26.03.2011 | 4.00:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Subtraction of Time Periods&lt;/h3&gt; &#xA;&lt;p&gt;Using the class &lt;code&gt;TimePeriodSubtractor&lt;/code&gt; you can subtract time periods (subtrahend) from other time periods (minuend):&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriodSubtractor.png&#34; alt=&#34;Time Periods Subtractor&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The result contains the differences between the two time period collections:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void TimePeriodSubtractorSample()&#xA;{&#xA;  DateTime moment = new DateTime( 2012, 1, 29 );&#xA;  TimePeriodCollection sourcePeriods = new TimePeriodCollection&#xA;    {&#xA;        new TimeRange( moment.AddHours( 2 ), moment.AddDays( 1 ) )&#xA;    };&#xA;&#xA;  TimePeriodCollection subtractingPeriods = new TimePeriodCollection&#xA;    {&#xA;        new TimeRange( moment.AddHours( 6 ), moment.AddHours( 10 ) ),&#xA;        new TimeRange( moment.AddHours( 12 ), moment.AddHours( 16 ) )&#xA;    };&#xA;&#xA;  TimePeriodSubtractor&amp;lt;timerange&amp;gt; subtractor = new TimePeriodSubtractor&amp;lt;timerange&amp;gt;();&#xA;  ITimePeriodCollection subtractedPeriods =&#xA;    subtractor.SubtractPeriods( sourcePeriods, subtractingPeriods );&#xA;  foreach ( TimeRange subtractedPeriod in subtractedPeriods )&#xA;  {&#xA;    Console.WriteLine( &#34;Subtracted Period: {0}&#34;, subtractedPeriod );&#xA;  }&#xA;  // &amp;gt; Subtracted Period : 29.01.2012 02:00:00 - 06:00:00 | 0.04:00&#xA;  // &amp;gt; Subtracted Period : 29.01.2012 10:00:00 - 12:00:00 | 0.02:00&#xA;  // &amp;gt; Subtracted Period : 29.01.2012 16:00:00 - 30.01.2012 00:00:00 | 0.08:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Addition and Subtraction of Dates&lt;/h3&gt; &#xA;&lt;p&gt;Often, the problem arises to add a certain time period to a given date and from that derive the target point of time. What at first sounds easy is often complicated by several factors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;only business hours should be considered&lt;/li&gt; &#xA; &lt;li&gt;weekends, holidays, service and maintenance periods should be excluded&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As soon as there exist such requirements, common date arithmetic will invariably fail. In such cases, the class &lt;code&gt;DateAdd&lt;/code&gt; might come to the rescue:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/DateAdd.png&#34; alt=&#34;Date Addition and Subtraction&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Although the name of the class might suggest otherwise, it is possible to do addition as well as subtraction. A peculiarity of &lt;code&gt;DateAdd&lt;/code&gt; is its capability of specifying periods to include with &lt;code&gt;DateAdd.IncludePeriods&lt;/code&gt; as well as exclude certain periods with &lt;code&gt;DateAdd.ExcludePeriods&lt;/code&gt;. It is also possible to specify just one of the two. If both are undefined, the tool behaves equivalent to &lt;code&gt;DateTime.Add&lt;/code&gt; and &lt;code&gt;DateTime.Subtract&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following example shows the usage of &lt;code&gt;DateAdd&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void DateAddSample()&#xA;{&#xA;  DateAdd dateAdd = new DateAdd();&#xA;&#xA;  dateAdd.IncludePeriods.Add( new TimeRange( new DateTime( 2011, 3, 17 ),&#xA;                              new DateTime( 2011, 4, 20 ) ) );&#xA;&#xA;  // setup some periods to exclude&#xA;  dateAdd.ExcludePeriods.Add( new TimeRange(&#xA;    new DateTime( 2011, 3, 22 ), new DateTime( 2011, 3, 25 ) ) );&#xA;  dateAdd.ExcludePeriods.Add( new TimeRange(&#xA;    new DateTime( 2011, 4, 1 ), new DateTime( 2011, 4, 7 ) ) );&#xA;  dateAdd.ExcludePeriods.Add( new TimeRange(&#xA;    new DateTime( 2011, 4, 15 ), new DateTime( 2011, 4, 16 ) ) );&#xA;&#xA;  // positive&#xA;  DateTime dateDiffPositive = new DateTime( 2011, 3, 19 );&#xA;  DateTime? positive1 = dateAdd.Add( dateDiffPositive, Duration.Hours( 1 ) );&#xA;  Console.WriteLine( &#34;DateAdd Positive1: {0}&#34;, positive1 );&#xA;  // &amp;gt; DateAdd Positive1: 19.03.2011 01:00:00&#xA;  DateTime? positive2 = dateAdd.Add( dateDiffPositive, Duration.Days( 4 ) );&#xA;  Console.WriteLine( &#34;DateAdd Positive2: {0}&#34;, positive2 );&#xA;  // &amp;gt; DateAdd Positive2: 26.03.2011 00:00:00&#xA;  DateTime? positive3 = dateAdd.Add( dateDiffPositive, Duration.Days( 17 ) );&#xA;  Console.WriteLine( &#34;DateAdd Positive3: {0}&#34;, positive3 );&#xA;  // &amp;gt; DateAdd Positive3: 14.04.2011 00:00:00&#xA;  DateTime? positive4 = dateAdd.Add( dateDiffPositive, Duration.Days( 20 ) );&#xA;  Console.WriteLine( &#34;DateAdd Positive4: {0}&#34;, positive4 );&#xA;  // &amp;gt; DateAdd Positive4: 18.04.2011 00:00:00&#xA;&#xA;  // negative&#xA;  DateTime dateDiffNegative = new DateTime( 2011, 4, 18 );&#xA;  DateTime? negative1 = dateAdd.Add( dateDiffNegative, Duration.Hours( -1 ) );&#xA;  Console.WriteLine( &#34;DateAdd Negative1: {0}&#34;, negative1 );&#xA;  // &amp;gt; DateAdd Negative1: 17.04.2011 23:00:00&#xA;  DateTime? negative2 = dateAdd.Add( dateDiffNegative, Duration.Days( -4 ) );&#xA;  Console.WriteLine( &#34;DateAdd Negative2: {0}&#34;, negative2 );&#xA;  // &amp;gt; DateAdd Negative2: 13.04.2011 00:00:00&#xA;  DateTime? negative3 = dateAdd.Add( dateDiffNegative, Duration.Days( -17 ) );&#xA;  Console.WriteLine( &#34;DateAdd Negative3: {0}&#34;, negative3 );&#xA;  // &amp;gt; DateAdd Negative3: 22.03.2011 00:00:00&#xA;  DateTime? negative4 = dateAdd.Add( dateDiffNegative, Duration.Days( -20 ) );&#xA;  Console.WriteLine( &#34;DateAdd Negative4: {0}&#34;, negative4 );&#xA;  // &amp;gt; DateAdd Negative4: 19.03.2011 00:00:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The specialization &lt;code&gt;CalendarDateAdd&lt;/code&gt; allows specifying the weekdays and working hours used by the addition or subtraction:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void CalendarDateAddSample()&#xA;{&#xA;  CalendarDateAdd calendarDateAdd = new CalendarDateAdd();&#xA;  // weekdays&#xA;  calendarDateAdd.AddWorkingWeekDays();&#xA;  // holidays&#xA;  calendarDateAdd.ExcludePeriods.Add( new Day( 2011, 4, 5, calendarDateAdd.Calendar ) );&#xA;  // working hours&#xA;  calendarDateAdd.WorkingHours.Add( new HourRange( new Time( 08, 30 ), new Time( 12 ) ) );&#xA;  calendarDateAdd.WorkingHours.Add( new HourRange( new Time( 13, 30 ), new Time( 18 ) ) );&#xA;&#xA;  DateTime start = new DateTime( 2011, 4, 1, 9, 0, 0 );&#xA;  TimeSpan offset = new TimeSpan( 22, 0, 0 ); // 22 hours&#xA;&#xA;  DateTime? end = calendarDateAdd.Add( start, offset );&#xA;&#xA;  Console.WriteLine( &#34;start: {0}&#34;, start );&#xA;  // &amp;gt; start: 01.04.2011 09:00:00&#xA;  Console.WriteLine( &#34;offset: {0}&#34;, offset );&#xA;  // &amp;gt; offset: 22:00:00&#xA;  Console.WriteLine( &#34;end: {0}&#34;, end );&#xA;  // &amp;gt; end: 06.04.2011 16:30:00&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Search for Calendar Periods&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;CalendarPeriodCollector&lt;/code&gt; offers the possibility to search for certain calendar periods within given time limits. By using a &lt;code&gt;ICalendarPeriodCollectorFilter&lt;/code&gt;, such a search can be restricted by the following criteria:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Search by years&lt;/li&gt; &#xA; &lt;li&gt;Search by months&lt;/li&gt; &#xA; &lt;li&gt;Search by days of months&lt;/li&gt; &#xA; &lt;li&gt;Search by weekdays&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Without a filter set, all time ranges of a period will be considered matching. Combining can be done by the following target scopes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Years: &lt;code&gt;CalendarPeriodCollector.CollectYears&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Months: &lt;code&gt;CalendarPeriodCollector.CollectMonths&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Days: &lt;code&gt;CalendarPeriodCollector.CollectDays&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Hours: &lt;code&gt;CalendarPeriodCollector.CollectHours&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In normal mode, all time ranges of the found ranges will be combined. For example, this allows to find all hours of a day by using &lt;code&gt;CalendarPeriodCollector.CollectHours&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To further constrain the result, time ranges can be defined as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Which months of a year: &lt;code&gt;ICalendarPeriodCollectorFilter.AddCollectingMonths&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Which days of a month: &lt;code&gt;ICalendarPeriodCollectorFilter.AddCollectingDays&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Which hours of a day: &lt;code&gt;ICalendarPeriodCollectorFilter.AddCollectingHours&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By defining a time range for the hours from 08:00 to 10:00 for example, the result will only contain one single time period covering both hours (as opposed to having a time period for each hour). This proves to be a valuable (if not necessary) optimization when combining large time ranges.&lt;/p&gt; &#xA;&lt;p&gt;The following example collects all working hours of Fridays in the month of January of several years:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void CalendarPeriodCollectorSample()&#xA;{&#xA;  CalendarPeriodCollectorFilter filter = new CalendarPeriodCollectorFilter();&#xA;  filter.Months.Add( YearMonth.January ); // only Januaries&#xA;  filter.WeekDays.Add( DayOfWeek.Friday ); // only Fridays&#xA;  filter.CollectingHours.Add( new HourRange( 8, 18 ) ); // working hours&#xA;&#xA;  CalendarTimeRange testPeriod =&#xA;    new CalendarTimeRange( new DateTime( 2010, 1, 1 ), new DateTime( 2011, 12, 31 ) );&#xA;  Console.WriteLine( &#34;Calendar period collector of period: &#34; + testPeriod );&#xA;  // &amp;gt; Calendar period collector of period:&#xA;  //            01.01.2010 00:00:00 - 30.12.2011 23:59:59 | 728.23:59&#xA;&#xA;  CalendarPeriodCollector collector =&#xA;          new CalendarPeriodCollector( filter, testPeriod );&#xA;  collector.CollectHours();&#xA;  foreach ( ITimePeriod period in collector.Periods )&#xA;  {&#xA;    Console.WriteLine( &#34;Period: &#34; + period );&#xA;  }&#xA;  // &amp;gt; Period: 01.01.2010; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 08.01.2010; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 15.01.2010; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 22.01.2010; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 29.01.2010; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 07.01.2011; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 14.01.2011; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 21.01.2011; 08:00 - 17:59 | 0.09:59&#xA;  // &amp;gt; Period: 28.01.2011; 08:00 - 17:59 | 0.09:59&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Search for Days&lt;/h3&gt; &#xA;&lt;p&gt;In many situations, it is required to determine the next available day of work, given a number of working days. When counting through the days from a given moment in time, weekends, holidays, service and maintenance periods should be excluded.&lt;/p&gt; &#xA;&lt;p&gt;To help with this task, the class &lt;code&gt;DaySeeker&lt;/code&gt; is available. Analogous to the &lt;code&gt;CalendarPeriodCollector&lt;/code&gt;, this class can be controlled with predefined filters. The following example shows the search for working days while skipping over all weekends and holidays:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/DaySeeker.png&#34; alt=&#34;Day Seeker&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;The implementation of this example looks as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void DaySeekerSample()&#xA;{&#xA;  Day start = new Day( new DateTime( 2011, 2, 15 ) );&#xA;  Console.WriteLine( &#34;DaySeeker Start: &#34; + start );&#xA;  // &amp;gt; DaySeeker Start: Dienstag; 15.02.2011 | 0.23:59&#xA;&#xA;  CalendarVisitorFilter filter = new CalendarVisitorFilter();&#xA;  filter.AddWorkingWeekDays(); // only working days&#xA;  filter.ExcludePeriods.Add( new Week( 2011, 9 ) );  // week #9&#xA;  Console.WriteLine( &#34;DaySeeker Holidays: &#34; + filter.ExcludePeriods\[ 0 \] );&#xA;  // &amp;gt; DaySeeker Holidays: w/c 9 2011; 28.02.2011 - 06.03.2011 | 6.23:59&#xA;&#xA;  DaySeeker daySeeker = new DaySeeker( filter );&#xA;  Day day1 = daySeeker.FindDay( start, 3 ); // same working week&#xA;  Console.WriteLine( &#34;DaySeeker(3): &#34; + day1 );&#xA;  // &amp;gt; DaySeeker(3): Freitag; 18.02.2011 | 0.23:59&#xA;&#xA;  Day day2 = daySeeker.FindDay( start, 4 ); // Saturday -&amp;gt; next Monday&#xA;  Console.WriteLine( &#34;DaySeeker(4): &#34; + day2 );&#xA;  // &amp;gt; DaySeeker(4): Montag; 21.02.2011 | 0.23:59&#xA;&#xA;  Day day3 = daySeeker.FindDay( start, 9 ); // holidays -&amp;gt; next Monday&#xA;  Console.WriteLine( &#34;DaySeeker(9): &#34; + day3 );&#xA;  // &amp;gt; DaySeeker(9): Montag; 07.03.2011 | 0.23:59&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Environmental Elements&lt;/h2&gt; &#xA;&lt;p&gt;Time related definitions and basic calculations are located in various utility classes:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Element&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TimeSpec&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Constants for times and periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;YearHalfyear&lt;/code&gt;&lt;br&gt;&lt;code&gt;YearQuarter&lt;/code&gt;&lt;br&gt;&lt;code&gt;YearMonth&lt;/code&gt;&lt;br&gt;&lt;code&gt;YearWeekType&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enumerations for half years, quarters, months, and week types&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TimeTool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Operations for modifications of date and time values as well as for specific time periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TimeCompare&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Functions for comparison of time periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TimeFormatter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Formatting of time periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;TimeTrim&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Functions to trim time periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Now&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Calculation of the current moment of time for the various time periods; e.g., the start time of the current calendar quarter&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Calculation for specific time periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The date part of a &lt;code&gt;DateTime&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The time part of a &lt;code&gt;DateTime&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CalendarVisitor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Abstract base class for iterating over calendar periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DateTimeSet&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sorted list of unique moments in time&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CalendarVisitor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Abstract base class for iterating over calendar periods&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;BroadcastCalendarTool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Calculation Tools for the broadcast calendar&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FiscalCalendarTool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Calculation Tools for the fiscal calendar&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Library and Unit Tests&lt;/h2&gt; &#xA;&lt;p&gt;The library Time Period is available in four versions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Library for .NET 2.0 including Unit Tests&lt;/li&gt; &#xA; &lt;li&gt;Library for .NET for Silverlight 4&lt;/li&gt; &#xA; &lt;li&gt;Library for .NET for Windows Phone 7&lt;/li&gt; &#xA; &lt;li&gt;o Portable Class Library for Windows Store, .NET 4, Silverlight 4, Windows Phone 7&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most of the classes are covered by NUnit tests. The source code is the same for all three variants (see below: Composite Library Development), but the Unit Tests are only available with the Portable Class Library and for the complete .NET Framework.&lt;/p&gt; &#xA;&lt;p&gt;Creating stable working tests for time based functionality is not an easy task, because various factors influence the state of the test objects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Differing Cultures make use of different calendars&lt;/li&gt; &#xA; &lt;li&gt;Functionality which is based on &lt;code&gt;DateTime.Now&lt;/code&gt; can (and most often will) result in differing behavior and test results when executed at different times&lt;/li&gt; &#xA; &lt;li&gt;Time calculations - especially involving time periods - lead to a multitude of special cases&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Considering this, it is of little surprise to find almost three times as much code in the Unit Tests as in the actual library implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Applications&lt;/h2&gt; &#xA;&lt;p&gt;To visualize the calendar objects, the library contains the application &lt;strong&gt;Time Period Demo&lt;/strong&gt; for the command line console, for Silverlight, and Windows Phone.&lt;/p&gt; &#xA;&lt;p&gt;For calculating calendar periods, the Silverlight application &lt;strong&gt;Calendar Period Collector&lt;/strong&gt; has been made available. The tool is basically a configuration frontend for the most important parameters of the class &lt;code&gt;CalendarPeriodCollectorFilter&lt;/code&gt;, and can calculate the time periods with the &lt;code&gt;CalendarPeriodCollector&lt;/code&gt;. The results can be copied to the Clipboard and pasted into Microsoft Excel:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/CalendarPeriodCollector_small.png&#34; alt=&#34;Calendar Period Collector&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Composite Library Development&lt;/h2&gt; &#xA;&lt;p&gt;The following naming conventions are being used in the Time Period library to separate files for the different target platforms where necessary:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;FileName&amp;gt;.Desktop&amp;lt;Extension&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;FileName&amp;gt;.Silverlight&amp;lt;Extension&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;FileName&amp;gt;.WindowsPhone&amp;lt;Extension&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;FileName&amp;gt;.Pcl&amp;lt;Extension&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The name of the DLL as well as the namespace is identical for all target platforms. These project settings can be changed under &lt;code&gt;Properties&lt;/code&gt; &amp;gt; &lt;code&gt;Application&lt;/code&gt; &amp;gt; &lt;code&gt;Assembly Name&lt;/code&gt; and &lt;code&gt;Default namespace&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The output for the Debug und Release targets will be placed in different directories for each target platform (&lt;code&gt;Properties&lt;/code&gt; &amp;gt; &lt;code&gt;Build&lt;/code&gt; &amp;gt; &lt;code&gt;Output Path&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;..\\Pub\\Desktop.&amp;lt;Debug|Release&amp;gt;\\&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;..\\Pub\\Silverlight.&amp;lt;Debug|Release&amp;gt;\\&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;..\\Pub\\WindowsPhone&amp;lt;Debug|Release&amp;gt;\\&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;..\\Pub\\Pcl&amp;lt;Debug|Release&amp;gt;\\&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To prevent problems with Visual Studio and some of its extension tools, it is necessary (!) to place the temporary compiler output in separate directories per target platform. To do this, it is necessary to &lt;code&gt;Unload Project&lt;/code&gt; and insert the following configuration elements into each target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&amp;gt;&#xA;&amp;lt;Project ToolsVersion=&#34;4.0&#34; DefaultTargets=&#34;Build&#34;&#xA;       xmlns=&#34;http://schemas.microsoft.com/developer/msbuild/2003&#34;&amp;gt;&#xA;  ...&#xA;  &amp;lt;PropertyGroup Condition=&#34; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &#34;&amp;gt;&#xA;    ...&#xA;    &amp;lt;BaseIntermediateOutputPath&amp;gt;obj\\Desktop.Debug\\&amp;lt;/BaseIntermediateOutputPath&amp;gt;&#xA;    &amp;lt;UseHostCompilerIfAvailable&amp;gt;false&amp;lt;/UseHostCompilerIfAvailable&amp;gt;&#xA;    ...&#xA;  &amp;lt;/PropertyGroup&amp;gt;&#xA;  &amp;lt;PropertyGroup Condition=&#34; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &#34;&amp;gt;&#xA;    ...&#xA;    &amp;lt;BaseIntermediateOutputPath&amp;gt;obj\\Desktop.Release\\&amp;lt;/BaseIntermediateOutputPath&amp;gt;&#xA;    &amp;lt;UseHostCompilerIfAvailable&amp;gt;false&amp;lt;/UseHostCompilerIfAvailable&amp;gt;&#xA;    ...&#xA;  &amp;lt;/PropertyGroup&amp;gt;&#xA;  ...&#xA;&amp;lt;/Project&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;p&gt;üëâ English Manual &lt;a href=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriod_en.pdf&#34;&gt;Pdf&lt;/a&gt;&lt;br&gt; üëâ German Manual &lt;a href=&#34;https://raw.githubusercontent.com/Giannoudis/TimePeriodLibrary/master/docs/TimePeriod_de.pdf&#34;&gt;Pdf&lt;/a&gt;&lt;br&gt; üëâ &lt;a href=&#34;https://www.nuget.org/packages/TimePeriodLibrary.NET/&#34;&gt;NuGet Package&lt;/a&gt;&lt;br&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Azure/azure-functions-openapi-extension</title>
    <updated>2023-08-24T01:26:59Z</updated>
    <id>tag:github.com,2023-08-24:/Azure/azure-functions-openapi-extension</id>
    <link href="https://github.com/Azure/azure-functions-openapi-extension" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This extension provides an Azure Functions app with Open API capability for better discoverability to consuming parties&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Azure Functions OpenAPI Extension&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Out-of-Proc Worker&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;In-Proc Worker&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.Functions.Worker.Extensions.OpenApi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/Microsoft.Azure.Functions.Worker.Extensions.OpenApi.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.Functions.Worker.Extensions.OpenApi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Azure.Functions.Worker.Extensions.OpenApi.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.WebJobs.Extensions.OpenApi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/Microsoft.Azure.WebJobs.Extensions.OpenApi.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.WebJobs.Extensions.OpenApi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Azure.WebJobs.Extensions.OpenApi.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;Swagger UI&lt;/a&gt; version used for this library is &lt;a href=&#34;https://github.com/swagger-api/swagger-ui/releases/tag/v3.44.0&#34;&gt;v3.44.0&lt;/a&gt; under the &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;Apache 2.0 license&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;This extension supports the OpenAPI spec version of &lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification/raw/main/versions/2.0.md&#34;&gt;v2.0&lt;/a&gt; and &lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification/raw/main/versions/3.0.1.md&#34;&gt;v3.0.1&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/enable-open-api-endpoints.md&#34;&gt;&lt;strong&gt;Enable OpenAPI documents to your Azure Functions HTTP Trigger&lt;/strong&gt;&lt;/a&gt;: This document shows how to enable OpenAPI extension on your Azure Functions applications and render Swagger UI, and OpenAPI v2 and v3 documents on-the-fly. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/openapi-out-of-proc.md&#34;&gt;&lt;strong&gt;Microsoft.Azure.Functions.Worker.Extensions.OpenApi&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/openapi-in-proc.md&#34;&gt;&lt;strong&gt;Microsoft.Azure.WebJobs.Extensions.OpenApi&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/openapi-core.md&#34;&gt;&lt;strong&gt;Microsoft.Azure.WebJobs.Extensions.OpenApi.Core&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/openapi-auth.md&#34;&gt;&lt;strong&gt;Securing Azure Functions Endpoints through OpenAPI Auth&lt;/strong&gt;&lt;/a&gt;: This document shows many various scenarios to add authN features including the built-in features and OAuth2 auth flows.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/azure-functions-v1-support.md&#34;&gt;&lt;strong&gt;Azure Functions v1 Support&lt;/strong&gt;&lt;/a&gt;: This document shows how to support Azure Functions v1 runtime with this OpenAPI extension.&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/integrate-with-apim.md&#34;&gt;&lt;strong&gt;Integrating OpenAPI-enabled Azure Functions to Azure API Management&lt;/strong&gt;&lt;/a&gt;: This document shows how to integrate the Azure Functions application with &lt;a href=&#34;https://docs.microsoft.com/azure/api-management/api-management-key-concepts?WT.mc_id=dotnet_0000_juyoo&#34;&gt;Azure API Management&lt;/a&gt;, via this OpenAPI extension.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- * [**Integrating OpenAPI-enabled Azure Functions to Power Platform**](docs/integrate-with-powerplatform.md): This document shows how to integrate the Azure Functions application with [Power Platform](https://powerplatform.microsoft.com/?WT.mc_id=dotnet_0000_juyoo), via this OpenAPI extension. --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/generic-cicd-pipeline-support.md&#34;&gt;**Generic CI/CD Pipeline Support&lt;/a&gt;: This document shows how to generate the OpenAPI document within a CI/CD pipeline, using either PowerShell or bash shell script.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;GitHub Actions Support&lt;/h2&gt; &#xA;&lt;p&gt;If you are using GitHub Actions as your preferred CI/CD pipeline, you can run the GitHub Action into your workflow to automatically generate the OpenAPI document. Find more details at the &lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/actions/build-openapi/&#34;&gt;Build OpenAPI&lt;/a&gt; action page.&lt;/p&gt; &#xA;&lt;h2&gt;GitHub Codespaces Support&lt;/h2&gt; &#xA;&lt;p&gt;If you want to run your Azure Functions app on GitHub Codespaces, you might want to accommodate &lt;code&gt;local.settings.json&lt;/code&gt;. The following PowerShell script may help you for the accommodation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Update local.settings.json&#xA;pwsh -c &#34;Invoke-RestMethod https://aka.ms/azfunc-openapi/add-codespaces.ps1 | Invoke-Expression&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sample Azure Function Apps with OpenAPI Document Enabled&lt;/h2&gt; &#xA;&lt;p&gt;Here are sample apps using the project references:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/samples/Microsoft.Azure.Functions.Worker.Extensions.OpenApi.FunctionApp.OutOfProc&#34;&gt;Function App out-of-proc worker&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/samples/Microsoft.Azure.WebJobs.Extensions.OpenApi.FunctionApp.InProc&#34;&gt;Function App in-proc worker&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;del&gt;## Azure Functions V1 Support ##&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;This library supports Azure Functions V3 and onwards. If you still want to get your v1 and v2 runtime app supported, find the &lt;a href=&#34;https://github.com/aliencube/AzureFunctions.Extensions&#34;&gt;community contribution&lt;/a&gt; or the &lt;a href=&#34;https://raw.githubusercontent.com/Azure/azure-functions-openapi-extension/main/docs/azure-functions-v1-support.md&#34;&gt;proxy feature&lt;/a&gt;.&lt;/del&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Known Issues&lt;/h2&gt; &#xA;&lt;h3&gt;Missing .dll Files&lt;/h3&gt; &#xA;&lt;p&gt;Due to the Azure Functions Runtime limitation, sometimes some of .dll files are removed while publishing the function app. In this case, try the following workaround with your function app &lt;code&gt;.csproj&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;Project Sdk=&#34;Microsoft.NET.Sdk&#34;&amp;gt;&#xA;  ...&#xA;  &amp;lt;PropertyGroup&amp;gt;&#xA;    ...&#xA;    &amp;lt;_FunctionsSkipCleanOutput&amp;gt;true&amp;lt;/_FunctionsSkipCleanOutput&amp;gt;&#xA;  &amp;lt;/PropertyGroup&amp;gt;&#xA;  ...&#xA;&amp;lt;/Project&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Empty Swagger UI When Deployed through Azure Pipelines&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Workaround: &lt;a href=&#34;https://github.com/Azure/azure-functions-openapi-extension/issues/306&#34;&gt;#306&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Swagger UI Error When Empty Project Referenced&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Workaround: &lt;a href=&#34;https://github.com/Azure/azure-functions-openapi-extension/issues/302#issuecomment-961791941&#34;&gt;#302&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Issues?&lt;/h2&gt; &#xA;&lt;p&gt;While using this library, if you find any issue, please raise an issue on the &lt;a href=&#34;https://github.com/Azure/azure-functions-openapi-extension/issues&#34;&gt;Issue&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit &lt;a href=&#34;https://cla.opensource.microsoft.com&#34;&gt;https://cla.opensource.microsoft.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.&lt;/p&gt; &#xA;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;. For more information see the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/faq/&#34;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:opencode@microsoft.com&#34;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt;</summary>
  </entry>
</feed>