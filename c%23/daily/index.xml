<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-10T01:31:38Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>martinothamar/Mediator</title>
    <updated>2022-11-10T01:31:38Z</updated>
    <id>tag:github.com,2022-11-10:/martinothamar/Mediator</id>
    <link href="https://github.com/martinothamar/Mediator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A high performance implementation of Mediator pattern in .NET using source generators.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/martinothamar/Mediator/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/martinothamar/Mediator/Build&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://www.nuget.org/packages/Mediator.Abstractions&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Mediator.Abstractions?label=Mediator.Abstractions&#34; alt=&#34;Abstractions NuGet current&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Mediator.SourceGenerator&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Mediator.SourceGenerator?label=Mediator.SourceGenerator&#34; alt=&#34;SourceGenerator NuGet current&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://www.nuget.org/packages/Mediator.Abstractions&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/Mediator.Abstractions?label=Mediator.Abstractions&#34; alt=&#34;Abstractions NuGet prerelease&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Mediator.SourceGenerator&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/Mediator.SourceGenerator?label=Mediator.SourceGenerator&#34; alt=&#34;SourceGenerator NuGet prerelease&#34;&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Mediator&lt;/h1&gt; &#xA;&lt;p&gt;This is a high performance .NET implementation of the Mediator pattern using the &lt;a href=&#34;https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/&#34;&gt;source generators&lt;/a&gt; feature introduced in .NET 5. The API and usage is mostly based on the great &lt;a href=&#34;https://github.com/jbogard/MediatR&#34;&gt;MediatR&lt;/a&gt; library, with some deviations to allow for better performance. Packages are .NET Standard 2.1 compatible.&lt;/p&gt; &#xA;&lt;p&gt;The mediator pattern is great for implementing cross cutting concern (logging, metrics, etc) and avoiding &#34;fat&#34; constructors due to lots of injected services.&lt;/p&gt; &#xA;&lt;p&gt;Goals for this library&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;High performance &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Runtime performance can be the same for both runtime reflection and source generator based approaches, but it&#39;s easier to optimize in the latter case&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;AOT friendly &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;MS are investing time in various AOT scenarios, and for example iOS requirees AOT compilation&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Build time errors instead of runtime errors &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The generator includes diagnostics, i.e. if a handler is not defined for a request, a warning is emitted&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In particular, source generators in this library is used to&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generate code for DI registration&lt;/li&gt; &#xA; &lt;li&gt;Generate code for &lt;code&gt;IMediator&lt;/code&gt; implementation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Request/Command/Query &lt;code&gt;Send&lt;/code&gt; methods are monomorphized (1 method per T), the generic &lt;code&gt;ISender.Send&lt;/code&gt; methods rely on these&lt;/li&gt; &#xA;   &lt;li&gt;You can use both &lt;code&gt;IMediator&lt;/code&gt; and &lt;code&gt;Mediator&lt;/code&gt;, the latter allows for better performance&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Generate diagnostics related messages and message handlers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;I am currently working on 2.0 version of Mediator, I recommend using the preview releases at this point. This version is currently in preview and includes a lot of improvements:&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Configure Mediator through &lt;code&gt;AddMediator&lt;/code&gt; call (assembly attribute still works) (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/21&#34;&gt;https://github.com/martinothamar/Mediator/pull/21&lt;/a&gt;, &lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/24&#34;&gt;https://github.com/martinothamar/Mediator/pull/24&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Throw &lt;code&gt;ArgumentNullException&lt;/code&gt; for null messages (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/22&#34;&gt;https://github.com/martinothamar/Mediator/pull/22&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Pass &lt;code&gt;Publish&amp;lt;INotification&amp;gt;&lt;/code&gt; calls to &lt;code&gt;Publish(object)&lt;/code&gt; (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/22&#34;&gt;https://github.com/martinothamar/Mediator/pull/22&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Optimize notifications (52ns -&amp;gt; 11ns for the most common case) (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/23&#34;&gt;https://github.com/martinothamar/Mediator/pull/23&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Cleanup and optimization in source generator (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/25&#34;&gt;https://github.com/martinothamar/Mediator/pull/25&lt;/a&gt;, thanks &lt;a href=&#34;https://github.com/Timmoth&#34;&gt;@Timmoth&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Modernize source generator to support both 3.8 and 4.0 Roslyn versions (also prepare for incremental codegen) (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/26&#34;&gt;https://github.com/martinothamar/Mediator/pull/26&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Updated benchmarks to account for changes (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/27&#34;&gt;https://github.com/martinothamar/Mediator/pull/27&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Smoketests, unittests, memory allocation tests (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/28&#34;&gt;https://github.com/martinothamar/Mediator/pull/28&lt;/a&gt;, &lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/29&#34;&gt;https://github.com/martinothamar/Mediator/pull/29&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Cleanup analysis-part of source generator, use 6.0.0 of .NET references (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/30&#34;&gt;https://github.com/martinothamar/Mediator/pull/30&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Use &lt;a href=&#34;https://github.com/belav/csharpier&#34;&gt;csharpier&lt;/a&gt; for consistent formatting (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/31&#34;&gt;https://github.com/martinothamar/Mediator/pull/31&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Benchmark for source generation process (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/32&#34;&gt;https://github.com/martinothamar/Mediator/pull/32&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Bugfix for using arrays as response types (&lt;a href=&#34;https://github.com/martinothamar/Mediator/issues/33&#34;&gt;https://github.com/martinothamar/Mediator/issues/33&lt;/a&gt;, &lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/34&#34;&gt;https://github.com/martinothamar/Mediator/pull/34&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Multiple bugfixes for stream requests and structs (see linked PRs &lt;a href=&#34;https://github.com/martinothamar/Mediator/issues/36&#34;&gt;https://github.com/martinothamar/Mediator/issues/36&lt;/a&gt;, thanks &lt;a href=&#34;https://github.com/Tornhoof&#34;&gt;@Tornhoof&lt;/a&gt;!)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Improve error handling in source generation process (&lt;a href=&#34;https://github.com/martinothamar/Mediator/issues/33#issuecomment-1146689609&#34;&gt;https://github.com/martinothamar/Mediator/issues/33#issuecomment-1146689609&lt;/a&gt;, &lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/40&#34;&gt;https://github.com/martinothamar/Mediator/pull/40&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support Notification Handler Identification via Reflection (&lt;a href=&#34;https://github.com/martinothamar/Mediator/issues/39&#34;&gt;https://github.com/martinothamar/Mediator/issues/39&lt;/a&gt;, &lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/42&#34;&gt;https://github.com/martinothamar/Mediator/pull/42&lt;/a&gt;, thanks &lt;a href=&#34;https://github.com/Tornhoof&#34;&gt;@Tornhoof&lt;/a&gt;!)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Fix defensive copy for non-readonly structs (&lt;a href=&#34;https://github.com/martinothamar/Mediator/issues/43&#34;&gt;https://github.com/martinothamar/Mediator/issues/43&lt;/a&gt;, &lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/44&#34;&gt;https://github.com/martinothamar/Mediator/pull/44&lt;/a&gt;, thanks &lt;a href=&#34;https://github.com/Tornhoof&#34;&gt;@Tornhoof&lt;/a&gt;!)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add missing debugger attributes (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/46&#34;&gt;https://github.com/martinothamar/Mediator/pull/46&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Bugfixes and benchmark for larger projects (&lt;a href=&#34;https://github.com/martinothamar/Mediator/pull/41&#34;&gt;https://github.com/martinothamar/Mediator/pull/41&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#mediator&#34;&gt;Mediator&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#2-benchmarks&#34;&gt;2. Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#3-usage-and-abstractions&#34;&gt;3. Usage and abstractions&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#31-message-types&#34;&gt;3.1. Message types&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#32-handler-types&#34;&gt;3.2. Handler types&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#33-pipeline-types&#34;&gt;3.3. Pipeline types&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#34-configuration&#34;&gt;3.4. Configuration&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#4-getting-started&#34;&gt;4. Getting started&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#41-add-package&#34;&gt;4.1. Add package&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#42-add-mediator-to-di-container&#34;&gt;4.2. Add Mediator to DI container&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#43-create-irequest-type&#34;&gt;4.3. Create &lt;code&gt;IRequest&amp;lt;&amp;gt;&lt;/code&gt; type&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#44-use-pipeline-behaviors&#34;&gt;4.4. Use pipeline behaviors&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#45-constrain-ipipelinebehavior-message-with-open-generics&#34;&gt;4.5. Constrain &lt;code&gt;IPipelineBehavior&amp;lt;,&amp;gt;&lt;/code&gt; message with open generics&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#46-use-notifications&#34;&gt;4.6. Use notifications&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#47-polymorphic-dispatch-with-notification-handlers&#34;&gt;4.7. Polymorphic dispatch with notification handlers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#48-notification-handlers-also-support-open-generics&#34;&gt;4.8. Notification handlers also support open generics&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#49-use-streaming-messages&#34;&gt;4.9. Use streaming messages&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#5-diagnostics&#34;&gt;5. Diagnostics&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/#6-differences-from-mediatr&#34;&gt;6. Differences from MediatR&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;2. Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;This benchmark exposes the perf overhead of the libraries. Mediator (this library) and MediatR methods show the overhead of the respective mediator implementations. I&#39;ve also included the &lt;a href=&#34;https://github.com/Cysharp/MessagePipe&#34;&gt;MessagePipe&lt;/a&gt; library as it also has great performance.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;SendRequest | Stream&amp;gt;_Baseline&lt;/code&gt;: simple method call into the handler class&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;SendRequest | Stream&amp;gt;_Mediator&lt;/code&gt;: the concrete &lt;code&gt;Mediator&lt;/code&gt; class generated by this library&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;SendRequest | Stream&amp;gt;_MessagePipe&lt;/code&gt;: the &lt;a href=&#34;https://github.com/Cysharp/MessagePipe&#34;&gt;MessagePipe&lt;/a&gt; library&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;SendRequest | Stream&amp;gt;_IMediator&lt;/code&gt;: call through the &lt;code&gt;IMediator&lt;/code&gt; interface in this library&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;SendRequest | Stream&amp;gt;_MediatR&lt;/code&gt;: the &lt;a href=&#34;https://github.com/jbogard/MediatR&#34;&gt;MediatR&lt;/a&gt; library&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/benchmarks/Mediator.Benchmarks/Request&#34;&gt;benchmarks code&lt;/a&gt; for more details on the measurement.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/img/request_benchmark.png&#34; alt=&#34;Requests benchmark&#34; title=&#34;Requests benchmark&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/img/stream_benchmark.png&#34; alt=&#34;Stream benchmark&#34; title=&#34;Stream benchmark&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;3. Usage and abstractions&lt;/h2&gt; &#xA;&lt;p&gt;There are two NuGet packages needed to use this library&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mediator.SourceGenerator &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;To generate the &lt;code&gt;IMediator&lt;/code&gt; implementation and dependency injection setup.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Mediator &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Message types (&lt;code&gt;IRequest&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;INotification&lt;/code&gt;), handler types (&lt;code&gt;IRequestHandler&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;INotificationHandler&amp;lt;&amp;gt;&lt;/code&gt;), pipeline types (&lt;code&gt;IPipelineBehavior&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You install the source generator package into your edge/outermost project (i.e. ASP.NET Core application, Background worker project), and then use the &lt;code&gt;Mediator&lt;/code&gt; package wherever you define message types and handlers. Standard message handlers are automatically picked up and added to the DI container in the generated &lt;code&gt;AddMediator&lt;/code&gt; method. &lt;em&gt;Pipeline behaviors need to be added manually.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;For example implementations, see the &lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/samples&#34;&gt;/samples&lt;/a&gt; folder. See the &lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/samples/ASPNET_CleanArchitecture&#34;&gt;ASP.NET sample&lt;/a&gt; for a more real world setup.&lt;/p&gt; &#xA;&lt;h3&gt;3.1. Message types&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IMessage&lt;/code&gt; - marker interface&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamMessage&lt;/code&gt; - marker interface&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IBaseRequest&lt;/code&gt; - market interface for requests&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IRequest&lt;/code&gt; - a request message, no return value (&lt;code&gt;ValueTask&amp;lt;Unit&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IRequest&amp;lt;out TResponse&amp;gt;&lt;/code&gt; - a request message with a response (&lt;code&gt;ValueTask&amp;lt;TResponse&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamRequest&amp;lt;out TResponse&amp;gt;&lt;/code&gt; - a request message with a streaming response (&lt;code&gt;IAsyncEnumerable&amp;lt;TResponse&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IBaseCommand&lt;/code&gt; - marker interface for commands&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ICommand&lt;/code&gt; - a command message, no return value (&lt;code&gt;ValueTask&amp;lt;Unit&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ICommand&amp;lt;out TResponse&amp;gt;&lt;/code&gt; - a command message with a response (&lt;code&gt;ValueTask&amp;lt;TResponse&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamCommand&amp;lt;out TResponse&amp;gt;&lt;/code&gt; - a command message with a streaming response (&lt;code&gt;IAsyncEnumerable&amp;lt;TResponse&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IBaseQuery&lt;/code&gt; - marker interface for queries&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IQuery&amp;lt;out TResponse&amp;gt;&lt;/code&gt; - a query message with a response (&lt;code&gt;ValueTask&amp;lt;TResponse&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamQuery&amp;lt;out TResponse&amp;gt;&lt;/code&gt; - a query message with a streaming response (&lt;code&gt;IAsyncEnumerable&amp;lt;TResponse&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;INotification&lt;/code&gt; - a notification message, no return value (&lt;code&gt;ValueTask&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As you can see, you can achieve the exact same thing with requests, commands and queries. But I find the distinction in naming useful if you for example use the CQRS pattern or for some reason have a preference on naming in your application.&lt;/p&gt; &#xA;&lt;h3&gt;3.2. Handler types&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IRequestHandler&amp;lt;in TRequest&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IRequestHandler&amp;lt;in TRequest, TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamRequestHandler&amp;lt;in TRequest, out TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ICommandHandler&amp;lt;in TCommand&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ICommandHandler&amp;lt;in TCommand, TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamCommandHandler&amp;lt;in TCommand, out TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IQueryHandler&amp;lt;in TQuery, TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamQueryHandler&amp;lt;in TQuery, out TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;INotificationHandler&amp;lt;in TNotification&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These types are used in correlation with the message types above.&lt;/p&gt; &#xA;&lt;h3&gt;3.3. Pipeline types&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IPipelineBehavior&amp;lt;TMessage, TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamPipelineBehavior&amp;lt;TMessage, TResponse&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public sealed class GenericHandler&amp;lt;TMessage, TResponse&amp;gt; : IPipelineBehavior&amp;lt;TMessage, TResponse&amp;gt;&#xA;    where TMessage : IMessage&#xA;{&#xA;    public ValueTask&amp;lt;TResponse&amp;gt; Handle(TMessage message, CancellationToken cancellationToken, MessageHandlerDelegate&amp;lt;TMessage, TResponse&amp;gt; next)&#xA;    {&#xA;        // ...&#xA;        return next(message, cancellationToken);&#xA;    }&#xA;}&#xA;&#xA;public sealed class GenericStreamHandler&amp;lt;TMessage, TResponse&amp;gt; : IStreamPipelineBehavior&amp;lt;TMessage, TResponse&amp;gt;&#xA;    where TMessage : IStreamMessage&#xA;{&#xA;    public IAsyncEnumerable&amp;lt;TResponse&amp;gt; Handle(TMessage message, CancellationToken cancellationToken, StreamHandlerDelegate&amp;lt;TMessage, TResponse&amp;gt; next)&#xA;    {&#xA;        // ...&#xA;        return next(message, cancellationToken);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3.4. Configuration&lt;/h3&gt; &#xA;&lt;p&gt;There are two ways to configure Mediator. Configuration values are needed during compile-time since this is a source generator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Assembly level attribute for configuration: &lt;code&gt;MediatorOptionsAttribute&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Options configuration delegate in &lt;code&gt;AddMediator&lt;/code&gt; function.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;services.AddMediator(options =&amp;gt;&#xA;{&#xA;    options.Namespace = &#34;SimpleConsole.Mediator&#34;;&#xA;    options.DefaultServiceLifetime = ServiceLifetime.Transient;&#xA;});&#xA;&#xA;// or&#xA;&#xA;[assembly: MediatorOptions(Namespace = &#34;SimpleConsole.Mediator&#34;, DefaultServiceLifetime = ServiceLifetime.Transient)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Namespace&lt;/code&gt; - where the &lt;code&gt;IMediator&lt;/code&gt; implementation is generated&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DefaultServiceLifetime&lt;/code&gt; - the DI service lifetime &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Singleton&lt;/code&gt; - (default value) everything registered as singletons, minimal allocations&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Transient&lt;/code&gt; - handlers registered as transient, &lt;code&gt;IMediator&lt;/code&gt;/&lt;code&gt;Mediator&lt;/code&gt;/&lt;code&gt;ISender&lt;/code&gt;/&lt;code&gt;IPublisher&lt;/code&gt; still singleton&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Scoped&lt;/code&gt; - mediator and handlers registered as scoped&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;4. Getting started&lt;/h2&gt; &#xA;&lt;p&gt;In this section we will get started with Mediator and go through a sample illustrating the various ways the Mediator pattern can be used in an application.&lt;/p&gt; &#xA;&lt;p&gt;See the full runnable sample code in the &lt;a href=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/samples/SimpleEndToEnd/&#34;&gt;SimpleEndToEnd sample&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;4.1. Add package&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;dotnet add package Mediator.SourceGenerator --version 1.0.*&#xA;dotnet add package Mediator.Abstractions --version 1.0.*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;PackageReference Include=&#34;Mediator.SourceGenerator&#34; Version=&#34;1.0.*&#34;&amp;gt;&#xA;  &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;&#xA;  &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers&amp;lt;/IncludeAssets&amp;gt;&#xA;&amp;lt;/PackageReference&amp;gt;&#xA;&amp;lt;PackageReference Include=&#34;Mediator.Abstractions&#34; Version=&#34;1.0.*&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.2. Add Mediator to DI container&lt;/h3&gt; &#xA;&lt;p&gt;In &lt;code&gt;ConfigureServices&lt;/code&gt; or equivalent, call &lt;code&gt;AddMediator&lt;/code&gt; (unless &lt;code&gt;MediatorOptions&lt;/code&gt; is configured, default namespace is &lt;code&gt;Mediator&lt;/code&gt;). This registers your handler below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Mediator;&#xA;using Microsoft.Extensions.DependencyInjection;&#xA;using System;&#xA;&#xA;var services = new ServiceCollection(); // Most likely IServiceCollection comes from IHostBuilder/Generic host abstraction in Microsoft.Extensions.Hosting&#xA;&#xA;services.AddMediator();&#xA;var serviceProvider = services.BuildServiceProvider();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.3. Create &lt;code&gt;IRequest&amp;lt;&amp;gt;&lt;/code&gt; type&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var mediator = serviceProvider.GetRequiredService&amp;lt;IMediator&amp;gt;();&#xA;var ping = new Ping(Guid.NewGuid());&#xA;var pong = await mediator.Send(ping);&#xA;Debug.Assert(ping.Id == pong.Id);&#xA;&#xA;// ...&#xA;&#xA;public sealed record Ping(Guid Id) : IRequest&amp;lt;Pong&amp;gt;;&#xA;&#xA;public sealed record Pong(Guid Id);&#xA;&#xA;public sealed class PingHandler : IRequestHandler&amp;lt;Ping, Pong&amp;gt;&#xA;{&#xA;    public ValueTask&amp;lt;Pong&amp;gt; Handle(Ping request, CancellationToken cancellationToken)&#xA;    {&#xA;        return new ValueTask&amp;lt;Pong&amp;gt;(new Pong(request.Id));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As soon as you code up message types, the source generator will add DI registrations automatically (inside &lt;code&gt;AddMediator&lt;/code&gt;). P.S - You can inspect the code yourself - open &lt;code&gt;Mediator.g.cs&lt;/code&gt; in VS from Project -&amp;gt; Dependencies -&amp;gt; Analyzers -&amp;gt; Mediator.SourceGenerator -&amp;gt; Mediator.SourceGenerator.MediatorGenerator, or just F12 through the code.&lt;/p&gt; &#xA;&lt;h3&gt;4.4. Use pipeline behaviors&lt;/h3&gt; &#xA;&lt;p&gt;The pipeline behavior below validates all incoming &lt;code&gt;Ping&lt;/code&gt; messages. Pipeline behaviors currently must be added manually.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;services.AddMediator();&#xA;services.AddSingleton&amp;lt;IPipelineBehavior&amp;lt;Ping, Pong&amp;gt;, PingValidator&amp;gt;();&#xA;&#xA;public sealed class PingValidator : IPipelineBehavior&amp;lt;Ping, Pong&amp;gt;&#xA;{&#xA;    public ValueTask&amp;lt;Pong&amp;gt; Handle(Ping request, CancellationToken cancellationToken, MessageHandlerDelegate&amp;lt;Ping, Pong&amp;gt; next)&#xA;    {&#xA;        if (request is null || request.Id == default)&#xA;            throw new ArgumentException(&#34;Invalid input&#34;);&#xA;&#xA;        return next(request, cancellationToken);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.5. Constrain &lt;code&gt;IPipelineBehavior&amp;lt;,&amp;gt;&lt;/code&gt; message with open generics&lt;/h3&gt; &#xA;&lt;p&gt;Add open generic handler to process all or a subset of messages passing through Mediator. This handler will log any error that is thrown from message handlers (&lt;code&gt;IRequest&lt;/code&gt;, &lt;code&gt;ICommand&lt;/code&gt;, &lt;code&gt;IQuery&lt;/code&gt;). It also publishes a notification allowing notification handlers to react to errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;services.AddMediator();&#xA;services.AddSingleton(typeof(IPipelineBehavior&amp;lt;,&amp;gt;), typeof(ErrorLoggerHandler&amp;lt;,&amp;gt;));&#xA;&#xA;public sealed record ErrorMessage(Exception Exception) : INotification;&#xA;public sealed record SuccessfulMessage() : INotification;&#xA;&#xA;public sealed class ErrorLoggerHandler&amp;lt;TMessage, TResponse&amp;gt; : IPipelineBehavior&amp;lt;TMessage, TResponse&amp;gt;&#xA;    where TMessage : IMessage // Constrained to IMessage, or constrain to IBaseCommand or any custom interface you&#39;ve implemented&#xA;{&#xA;    private readonly ILogger&amp;lt;ErrorLoggerHandler&amp;lt;TMessage, TResponse&amp;gt;&amp;gt; _logger;&#xA;    private readonly IMediator _mediator;&#xA;&#xA;    public ErrorLoggerHandler(ILogger&amp;lt;ErrorLoggerHandler&amp;lt;TMessage, TResponse&amp;gt;&amp;gt; logger, IMediator mediator)&#xA;    {&#xA;        _logger = logger;&#xA;        _mediator = mediator;&#xA;    }&#xA;&#xA;    public async ValueTask&amp;lt;TResponse&amp;gt; Handle(TMessage message, CancellationToken cancellationToken, MessageHandlerDelegate&amp;lt;TMessage, TResponse&amp;gt; next)&#xA;    {&#xA;        try&#xA;        {&#xA;            var response = await next(message, cancellationToken);&#xA;            return response;&#xA;        }&#xA;        catch (Exception ex)&#xA;        {&#xA;            _logger.LogError(ex, &#34;Error handling message&#34;);&#xA;            await _mediator.Publish(new ErrorMessage(ex));&#xA;            throw;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.6. Use notifications&lt;/h3&gt; &#xA;&lt;p&gt;We can define a notification handler to catch errors from the above pipeline behavior.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Notification handlers are automatically added to DI container&#xA;&#xA;public sealed class ErrorNotificationHandler : INotificationHandler&amp;lt;ErrorMessage&amp;gt;&#xA;{&#xA;    public ValueTask Handle(ErrorMessage error, CancellationToken cancellationToken)&#xA;    {&#xA;        // Could log to application insights or something...&#xA;        return default;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.7. Polymorphic dispatch with notification handlers&lt;/h3&gt; &#xA;&lt;p&gt;We can also define a notification handler that receives all notifications.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;&#xA;public sealed class StatsNotificationHandler : INotificationHandler&amp;lt;INotification&amp;gt; // or any other interface deriving from INotification&#xA;{&#xA;    private long _messageCount;&#xA;    private long _messageErrorCount;&#xA;&#xA;    public (long MessageCount, long MessageErrorCount) Stats =&amp;gt; (_messageCount, _messageErrorCount);&#xA;&#xA;    public ValueTask Handle(INotification notification, CancellationToken cancellationToken)&#xA;    {&#xA;        Interlocked.Increment(ref _messageCount);&#xA;        if (notification is ErrorMessage)&#xA;            Interlocked.Increment(ref _messageErrorCount);&#xA;        return default;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.8. Notification handlers also support open generics&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public sealed class GenericNotificationHandler&amp;lt;TNotification&amp;gt; : INotificationHandler&amp;lt;TNotification&amp;gt;&#xA;    where TNotification : INotification // Generic notification handlers will be registered as open constrained types automatically&#xA;{&#xA;    public ValueTask Handle(TNotification notification, CancellationToken cancellationToken)&#xA;    {&#xA;        return default;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4.9. Use streaming messages&lt;/h3&gt; &#xA;&lt;p&gt;Since version 1.* of this library there is support for streaming using &lt;code&gt;IAsyncEnumerable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var mediator = serviceProvider.GetRequiredService&amp;lt;IMediator&amp;gt;();&#xA;&#xA;var ping = new StreamPing(Guid.NewGuid());&#xA;&#xA;await foreach (var pong in mediator.CreateStream(ping))&#xA;{&#xA;    Debug.Assert(ping.Id == pong.Id);&#xA;    Console.WriteLine(&#34;Received pong!&#34;); // Should log 5 times&#xA;}&#xA;&#xA;// ...&#xA;&#xA;public sealed record StreamPing(Guid Id) : IStreamRequest&amp;lt;Pong&amp;gt;;&#xA;&#xA;public sealed record Pong(Guid Id);&#xA;&#xA;public sealed class PingHandler : IStreamRequestHandler&amp;lt;StreamPing, Pong&amp;gt;&#xA;{&#xA;    public async IAsyncEnumerable&amp;lt;Pong&amp;gt; Handle(StreamPing request, [EnumeratorCancellation] CancellationToken cancellationToken)&#xA;    {&#xA;        for (int i = 0; i &amp;lt; 5; i++)&#xA;        {&#xA;            await Task.Delay(1000, cancellationToken);&#xA;            yield return new Pong(request.Id);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;5. Diagnostics&lt;/h2&gt; &#xA;&lt;p&gt;Since this is a source generator, diagnostics are also included. Examples below&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Missing request handler&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/img/missing_request_handler.png&#34; alt=&#34;Missing request handler&#34; title=&#34;Missing request handler&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Multiple request handlers found&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/martinothamar/Mediator/main/img/multiple_request_handlers.png&#34; alt=&#34;Multiple request handlers found&#34; title=&#34;Multiple request handlers found&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;6. Differences from &lt;a href=&#34;https://github.com/jbogard/MediatR&#34;&gt;MediatR&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This is a work in progress list on the differences between this library and MediatR.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;RequestHandlerDelegate&amp;lt;TResponse&amp;gt;()&lt;/code&gt; -&amp;gt; &lt;code&gt;MessageHandlerDelegate&amp;lt;TMessage, TResponse&amp;gt;(TMessage message, CancellationToken cancellationToken)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This is to avoid excessive closure allocations. I thin it&#39;s worthwhile when the cost is simply passing along the message and the cancellationtoken.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;No &lt;code&gt;ServiceFactory&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This library relies on the &lt;code&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;, so it only works with DI containers that integrate with those abstractions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Singleton service lifetime by default &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;MediatR in combination with &lt;code&gt;MediatR.Extensions.Microsoft.DependencyInjection&lt;/code&gt; does transient service registration by default, which leads to a lot of allocations. Even if it is configured for singleton lifetime, &lt;code&gt;IMediator&lt;/code&gt; and &lt;code&gt;ServiceFactory&lt;/code&gt; services are registered as transient (not configurable).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>OdysseusYuan/LKY_OfficeTools</title>
    <updated>2022-11-10T01:31:38Z</updated>
    <id>tag:github.com,2022-11-10:/OdysseusYuan/LKY_OfficeTools</id>
    <link href="https://github.com/OdysseusYuan/LKY_OfficeTools" rel="alternate"></link>
    <summary type="html">&lt;p&gt;一键自动化 下载、安装、激活 Office 的利器。&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;LKY Office Tools&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;一键自动化 下载、安装、激活 Office 的利器。绿色、开源、安全、无毒。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;目前包含的功能：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;一键快速下载、安装、激活最新版 Microsoft Office 全套流程。&lt;/li&gt; &#xA; &lt;li&gt;程序默认安装 Word、PPT、Excel 三件套。&lt;/li&gt; &#xA; &lt;li&gt;工具可自动识别不同的操作系统架构，自动下载适配版本的 Office。&lt;/li&gt; &#xA; &lt;li&gt;本工具激活 Office 的方式为正版激活模式，不会篡改任何系统文件。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;使用方法&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;解压形如：LKY_OfficeTools_v*.zip 的文件，运行解压后目录下的 LKY_OfficeTools.exe 文件即可完成部署。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;测试环境&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;目前已经在 Windows 10(1703) 及以上版本进行了测试，均可在其 x86、x64 完美安装正版 Office 并激活。&lt;/li&gt; &#xA; &lt;li&gt;应 Office 官方要求，系统中只能部署唯一架构类型，故本工具部署时，会征求用户同意，由其自行决定是否卸载其它架构。&lt;/li&gt; &#xA; &lt;li&gt;2016年7月及其之前发布的 Windows 系统，因其架构过于陈旧，其已经不再支持安装最新的正版 Office。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;开源说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;欢迎广大开发者、爱好者们 Fork、PR 本仓库。参考、引用、转发、二次开发本开源库时，请注明来源。&lt;/li&gt; &#xA; &lt;li&gt;本工具自动激活功能，仅用于给大家无偿的学习编程开发能力之用，如需商业办公使用，请从微软官网购买商业许可。&lt;/li&gt; &#xA; &lt;li&gt;该软件任何人、企业、机构等，不得使用任何直接或间接的方式将其商业化，否则本仓库及其所属人将不承担任何后果。&lt;/li&gt; &#xA; &lt;li&gt;当前工具将持续进行迭代更新和维护，迭代过程中不排除在各种因素综合下，可能产生计算机运行的各种情况。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;关于&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;如有建议、疑惑等，大家可以发邮件至 &lt;a href=&#34;mailto:liukaiyuan@sjtu.edu.cn&#34;&gt;liukaiyuan@sjtu.edu.cn&lt;/a&gt; 交流探讨。&lt;/li&gt; &#xA; &lt;li&gt;© 2022 LiuKaiyuan (Odysseus.Yuan). All Rights Reserved.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>