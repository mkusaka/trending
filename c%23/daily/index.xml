<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-26T01:25:28Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jonowilliams26/StructuredMinimalApi</title>
    <updated>2024-04-26T01:25:28Z</updated>
    <id>tag:github.com,2024-04-26:/jonowilliams26/StructuredMinimalApi</id>
    <link href="https://github.com/jonowilliams26/StructuredMinimalApi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An example of a structured minimal api project&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Structured Minimal API&lt;/h1&gt; &#xA;&lt;p&gt;An example on how to structure a minmal API using &lt;a href=&#34;https://www.jimmybogard.com/vertical-slice-architecture/&#34;&gt;Vertical Slice Architecture&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is Vertical Slice Architecture?&lt;/h2&gt; &#xA;&lt;p&gt;Vertical slice architecture is an approach for organising your code into features/vertical slices rather than organising by technical conerns (e.g. Controllers, Models, Services etc). Each slice will contain all the code which fullfills a feature or use case inside the application. One of the main benefits of VSA is the ability to structure each feature/slice independently, so each feature/slice can be as simple or complicated as it needs to be.&lt;/p&gt; &#xA;&lt;h2&gt;What does this API do?&lt;/h2&gt; &#xA;&lt;p&gt;This is an API for Twitter/X like social media, where users can make text posts, like and comment on posts and follow other users.&lt;/p&gt; &#xA;&lt;h2&gt;Some Important Design Decisions In This Project&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Each &lt;code&gt;endpoint&lt;/code&gt; will define their own &lt;code&gt;request&lt;/code&gt;/&lt;code&gt;response&lt;/code&gt; contract &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;I have found trying to resuse DTOs can be a pain as soon as an edge case requires the DTO to diverge from the common structure. Rather than dealing with that pain later, bite the bullet now and create a seperate &lt;code&gt;request&lt;/code&gt;/&lt;code&gt;response&lt;/code&gt; DTO.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Let &lt;strong&gt;DATA BE DATA&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;I&#39;m not using &lt;a href=&#34;https://martinfowler.com/bliki/DomainDrivenDesign.html&#34;&gt;Domain Driven Design&lt;/a&gt;, after using DDD on real world projects, I personally, don&#39;t like the approach (if it works for you, keep doing it, don&#39;t let me change that), I found I was always trying to search for the code that was actually doing the thing, or trying to figure out which &lt;em&gt;Domain object&lt;/em&gt; the code belongs too rather than writing the code.&lt;/li&gt; &#xA;   &lt;li&gt;After experimenting with &lt;a href=&#34;https://go.dev/&#34;&gt;Golang&lt;/a&gt; I really like the approach of letting data just be simple &lt;code&gt;structs&lt;/code&gt; and using methods/functions to operate over them.&lt;/li&gt; &#xA;   &lt;li&gt;So, in this project our &lt;code&gt;Data Types&lt;/code&gt; will just be simple data buckets, no logic inside them, they are just there to represent our data. Some people call this an &lt;a href=&#34;https://martinfowler.com/bliki/AnemicDomainModel.html&#34;&gt;Anemic Domain Model&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;No &lt;code&gt;IRepository&lt;/code&gt; abstraction over &lt;a href=&#34;https://learn.microsoft.com/en-us/ef/core/&#34;&gt;EF Core&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Controversial, I know. My take is EF Core is already a pretty solid abstraction over a database and covers 99.9% of use cases. Some people say &#34;What about unit testing?&#34;, I think you shouldn&#39;t be mocking &lt;strong&gt;YOUR OWN&lt;/strong&gt; database, if you need to test something which is reading/writing to your database, you should be writing an &lt;a href=&#34;https://en.wikipedia.org/wiki/Integration_testing&#34;&gt;integration test&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;If EF Core isn&#39;t suitable for a specific feature/slice, we can use anything we want (e.g. &lt;a href=&#34;https://github.com/DapperLib/Dapper&#34;&gt;Dapper&lt;/a&gt;) as each feature/slice is independent.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>SergeyTeplyakov/ErrorProne.NET</title>
    <updated>2024-04-26T01:25:28Z</updated>
    <id>tag:github.com,2024-04-26:/SergeyTeplyakov/ErrorProne.NET</id>
    <link href="https://github.com/SergeyTeplyakov/ErrorProne.NET" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Set of roslyn-based analyzers for catching common C# errors (inspired by Google&#39;s error-prone)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Error Prone .NET&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://seteplia.visualstudio.com/ErrorProne.NET/_build/latest?definitionId=1&#34;&gt;&lt;img src=&#34;https://seteplia.visualstudio.com/ErrorProne.NET/_apis/build/status/SergeyTeplyakov.ErrorProne.NET?label=build&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ErrorProne.NET is a set of Roslyn-based analyzers that will help you to write correct code. The idea is similar to Google&#39;s &lt;a href=&#34;https://github.com/google/error-prone&#34;&gt;error-prone&lt;/a&gt; but instead of Java, the analyzers are focusing on correctness (and, maybe, performance) of C# programs.&lt;/p&gt; &#xA;&lt;p&gt;Currently, there are two types of analyzers that split into two projects that ended up in two separate nuget packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ErrorProne.CoreAnalyzers - the analyzers covering the most common cases that may occur in almost any project, like error handling or correctness of some widely used API.&lt;/li&gt; &#xA; &lt;li&gt;ErrorProne.StructAnalyzers - the analyzers focusing on potential performance problem when dealing with structs in C#.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ErrorProne.CoreAnalyzers&lt;/h2&gt; &#xA;&lt;p&gt;The &#34;core&#34; analyzers are the analyzers that will be useful in almost any .NET project by focusing on the correctness aspects and not on performance or low memory footprint.&lt;/p&gt; &#xA;&lt;h3&gt;Core Analyzers&lt;/h3&gt; &#xA;&lt;h4&gt;Unobserved Result Analysis&lt;/h4&gt; &#xA;&lt;p&gt;Some projects are heavily rely on a set of special result type and instead of exception handling patterns are using &lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Possible&amp;lt;T&amp;gt;&lt;/code&gt; families of types. In this case, it is very important for the callers of operations that return a result to observe it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Result&#xA;{&#xA;    public bool Success = false;&#xA;}&#xA;&#xA;public static Result ProcessRequest() =&amp;gt; null;&#xA;&#xA;// Result of type &#39;Result&#39; should be observed&#xA;ProcessRequest();&#xA;//~~~~~~~~~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The analyzers emit a diagnostic for every method that return a type with &lt;code&gt;Result&lt;/code&gt; in its name as well as for some other well-known types that should be observed in vast majority of cases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Stream s = null;&#xA;// The result of type &#39;Task&#39; should be observed&#xA;s.FlushAsync();&#xA;//~~~~~~~~~~&#xA;&#xA;// The result of type &#39;Exception&#39; should be observed&#xA;getException();&#xA;//~~~~~~~~~~&#xA;Exception getException() =&amp;gt; null;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Suspicious equality implementation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class FooBar : IEquatable&amp;lt;FooBar&amp;gt;&#xA;{&#xA;    private string _s;&#xA;&#xA;    // Suspicious equality implementation: parameter &#39;other&#39; is never used&#xA;    public bool Equals(FooBar other)&#xA;    //                        ~~~~~&#xA;    {&#xA;        return _s == &#34;42&#34;;&#xA;    }&#xA;}&#xA;&#xA;public class Baz : IEquatable&amp;lt;Baz&amp;gt;&#xA;{&#xA;    private string _s;&#xA;&#xA;    // Suspicious equality implementation: no instance members are used&#xA;    public bool Equals(Baz other)&#xA;    //          ~~~~~~&#xA;    {&#xA;        return other != null;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exception handling analyzers&lt;/h3&gt; &#xA;&lt;p&gt;Correct exception handling is a very complex topic, but one case that is very common requires special attention. A generic handler that handles &lt;code&gt;System.Exception&lt;/code&gt; or &lt;code&gt;System.AggregateException&lt;/code&gt; should &#34;observe&#34; the whole exception instance and not only the &lt;code&gt;Message&lt;/code&gt; property. The &lt;code&gt;Message&lt;/code&gt; property is quite important, but in some cases it can be quite meaningless. For instance, the &lt;code&gt;Message&lt;/code&gt; property for &lt;code&gt;TargetInvocationException&lt;/code&gt;, &lt;code&gt;AggregateException&lt;/code&gt;, &lt;code&gt;TypeLoadExcpetion&lt;/code&gt; and some others doesn&#39;t provide anything useful in it&#39;s message and the most useful information is stored in &lt;code&gt;InnerException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To avoid this anti-pattern, the analyzer will warn you if the code only traces the &lt;code&gt;Exception&lt;/code&gt; property without &#34;looking inside&#34;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;EPC12 - Suspicious exception handling: only &#39;&#39; is observed in the catch block.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;try&#xA;{&#xA;    Console.WriteLine();&#xA;}&#xA;catch (Exception e)&#xA;{&#xA;    // Suspicious exception handling: only e.Message is observed in exception block&#xA;    Console.WriteLine(e.Message);&#xA;    //                  ~~~~~~~&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;ERP022 - swallows an unobserved exception.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;try&#xA;{&#xA;    Console.WriteLine();&#xA;}&#xA;catch (Exception e)&#xA;{&#xA;    // Exit point &#39;return&#39; swallows an unobserved exception&#xA;    return;&#xA;//  ~~~~~~&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;ERP021 - incorrect exception propagation. Use &#39;throw;&#39; instead&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;try&#xA;{&#xA;    Console.WriteLine();&#xA;}&#xA;catch (Exception e)&#xA;{&#xA;    // Incorrect exception propagation: use &#39;throw&#39; instead&#xA;    throw e;&#xA;    //    ~&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Async Analyzers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Stream sample = null;&#xA;// Awaiting the result of a null-conditional expression may cause NullReferenceException.&#xA;await sample?.FlushAsync();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Configuring &lt;code&gt;ConfigureAwait&lt;/code&gt; behavior&lt;/h4&gt; &#xA;&lt;p&gt;The strictness of whether to use &lt;code&gt;ConfigureAwait&lt;/code&gt; everywhere is very much depends on the project and the layer of the project. It is very important for all the library code to always use &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; to avoid potential issues like deadlocks. On the other hand, some other parts of the system maybe used only in service layer and the team may decide not to litter the code with redudnat &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; calls. But regardless of what a team decides to do - whether to call &lt;code&gt;ConfigureAwait&lt;/code&gt; or not, its very important to enforce (if possible) the consistency of the code.&lt;/p&gt; &#xA;&lt;p&gt;ErrorProne.NET allows a developer to &#34;annotate&#34; the assembly with an attribute and the anlyzers will enforce the desired behavior:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: UseConfigureAwaitFalse()]&#xA;public class UseConfigureAwaitFalseAttribute : System.Attribute { }&#xA;&#xA;public static async Task CopyTo(Stream source, Stream destination)&#xA;{&#xA;    // ConfigureAwait(false) must be used&#xA;    await source.CopyToAsync(destination);&#xA;    //    ~~~~~~~~~~~~~~~~~~&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: DoNotUseConfigureAwaitFalse()]&#xA;public class UseConfigureAwaitFalseAttribute : System.Attribute { }&#xA;// ConfigureAwait(false) call is redundant&#xA;await source.CopyToAsync(destination).ConfigureAwait(false);&#xA;//                                    ~~~~~~~~~~~~~~~~~~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In both cases, the analyzers will look for a special attribute used for a given assembly and will emit diagnostics based on the required usage of &lt;code&gt;ConfigureAwait&lt;/code&gt;. In the second case, the &lt;code&gt;ConfigureAwait(false)&lt;/code&gt; will be grayed-out in the IDE and the IDE will suggest a fixer to remove the redundant call.&lt;/p&gt; &#xA;&lt;p&gt;Please note, that you don&#39;t have to reference any ErrorProne.NET assembly in order to use this feature. You can just declare the two attributes by yourself and the analyzer will use duck-typing approach to detect that the right attributes were used.&lt;/p&gt; &#xA;&lt;h2&gt;Struct Analyzers&lt;/h2&gt; &#xA;&lt;p&gt;Value types are very important in high performance scenarios, but they have its own limitations and hidden aspects that can cause incorrect behavior or performance degradations.&lt;/p&gt; &#xA;&lt;h3&gt;Do not use default contructors for structs&lt;/h3&gt; &#xA;&lt;p&gt;In high-performant code it is quite common to use structs as an optimization tool. And in some cases, the default constructor for structs can not establish the invariants required for the correct behavior. Such structs can be marked with a special attribute (&lt;code&gt;DoNotUseDefaultConstruction&lt;/code&gt;) and any attempt to create the struct marked with this attribute using &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; will trigger a diagnostic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[System.AttributeUsage(System.AttributeTargets.Struct)]&#xA;public class DoNotUseDefaultConstructionAttribute : System.Attribute { }&#xA;&#xA;[DoNotUseDefaultConstruction]&#xA;public readonly struct TaskSourceSlim&amp;lt;T&amp;gt;&#xA;{&#xA;    private readonly TaskCompletionSource&amp;lt;T&amp;gt; _tcs;&#xA;    public TaskSourceSlim(TaskCompletionSource&amp;lt;T&amp;gt; tcs) =&amp;gt; _tcs = tcs;&#xA;    // Other members&#xA;}&#xA;&#xA;// Do not use default construction for struct &#39;TaskSourceSlim&#39; marked with &#39;DoNotUseDefaultConstruction&#39; attribute&#xA;var tss = new TaskSourceSlim&amp;lt;object&amp;gt;();&#xA;//        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xA;&#xA;// The same warning.&#xA;TaskSourceSlim&amp;lt;object&amp;gt; tss2 = default;&#xA;//                            ~~~~~~~&#xA;&#xA;// The same warning.&#xA;var tss3 = Create&amp;lt;TaskSourceSlim&amp;lt;object&amp;gt;&amp;gt;();&#xA;//         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xA;&#xA;var a = new TaskSourceSlim&amp;lt;object&amp;gt;[5]; // OK&#xA;&#xA;// The same warning! ImmutableArray will throw NRE&#xA;var ia = new ImmutableArray&amp;lt;int&amp;gt;();&#xA;//           ~~~~~~~~~~~~~~~~~~~~~&#xA;&#xA;public static T Create&amp;lt;T&amp;gt;() where T : new() =&amp;gt; default;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you can&#39;t embed a struct marked with this attribute into another struct, unless the other struct is marked with &lt;code&gt;DoNotUseDefaultConstruction&lt;/code&gt; attribute as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public readonly struct S2&#xA;{&#xA;    // Do not embed struct &#39;TaskSourceSlim&#39; marked with &#39;DoNotUseDefaultConstruction&#39; attribute into another struct&#xA;    private readonly TaskSourceSlim&amp;lt;object&amp;gt; _tss;&#xA;    //               ~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;A hashtable unfriendly type is used as a key in a dictionary&lt;/h3&gt; &#xA;&lt;p&gt;Every type that is used as the key in a dictionary must implement &lt;code&gt;Equals&lt;/code&gt; and &lt;code&gt;GetHashCode&lt;/code&gt;. By default the CLR provides the default implementations for &lt;code&gt;Equals&lt;/code&gt; and &lt;code&gt;GetHashCode&lt;/code&gt; that follows &#34;value semantics&#34;, i.e. the two instances of a struct are equals when all the fields are equals. But unfortunately, the calling a default &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;GetHashCode&lt;/code&gt; methods causes boxing allocation and may be implemented using reflection, that can be extremely slow.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public struct MyStruct&#xA;{&#xA;    private readonly long _x;&#xA;    private readonly long _y;&#xA;    public void FooBar() { }&#xA;    // Struct &#39;MyStruct&#39; with the default Equals and HashCode implementation&#xA;    // is used as a key in a hash table.&#xA;    private static Dictionary&amp;lt;MyStruct, string&amp;gt; Table;&#xA;    //             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same issue may occur when &lt;code&gt;MyStruct&lt;/code&gt; instance is embedded into another struct that provide custom implementations for &lt;code&gt;Equals&lt;/code&gt; and &lt;code&gt;GetHashCode&lt;/code&gt;. And there is an analyzer that warns in this case as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;A struct can be made readonly&lt;/h3&gt; &#xA;&lt;p&gt;Marking a struct readonly can be beneficial in terms of design, because it allows conveying the intent more clearly, and also readonly structs can be more performant by avoiding defensive copies in readonly contexts (like when passed by &lt;code&gt;in&lt;/code&gt;, when stored in readonly field, &lt;code&gt;ref readonly&lt;/code&gt; variables etc):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Struct &#39;MyStruct&#39; can be made readonly&#xA;public struct MyStruct&#xA;//            ~~~~~~~~&#xA;{&#xA;    private readonly long _x;&#xA;    private readonly long _y;&#xA;    public void FooBar() { }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the analyzers below will trigger a diagnostics only for &#34;large&#34; structs, i.e. with the structs larger than 16 bytes. This is done to avoid too many warnings when there is potential performance issues because the copy of a small struct will be very much negligible.&lt;/p&gt; &#xA;&lt;h3&gt;Non-readonly struct is passed as in-parameter&lt;/h3&gt; &#xA;&lt;p&gt;It doesn&#39;t make sense to pass non-readonly and non-poco structs as &lt;code&gt;in&lt;/code&gt; parameter, because almost every access to the argument will cause a defensive copy that will eliminate all the benefits of &#34;passing by reference&#34;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Non-readonly struct &#39;MyStruct&#39; is passed as in-parameter &#39;ms&#39;&#xA;public static void InParameter(in MyStruct ms)&#xA;//                             ~~~~~~~~~~~~~~&#xA;{&#xA;}&#xA;&#xA;// Non-readonly struct &#39;MyStruct&#39; returned by readonly reference&#xA;public static ref readonly MyStruct Return() =&amp;gt; throw null;&#xA;//            ~~~~~~~~~~~~~~~~~~~~~&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Defensive copy analyzers&lt;/h3&gt; &#xA;&lt;p&gt;C# 7.3 introduced features that help passing or returning struct by &#34;readonly&#34; reference. The features are very helpful for readonly structs, but for non-readonly members of non-readonly structs that can decrease performance by causing a lots of redundant copies.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static void HiddenCopy(in MyStruct ms)&#xA;{&#xA;    // Some analyzers are triggered only for &#34;large&#34; structs to avoid extra noise&#xA;    // Hidden copy copy&#xA;    &#xA;    // Expression &#39;FooBar&#39; causes a hidden copy of a non-readonly struct &#39;MyStruct&#39;&#xA;    ms.FooBar();&#xA;    // ~~~~~~&#xA;&#xA;    ref readonly MyStruct local = ref ms;&#xA;&#xA;    // Hidden copy as well&#xA;    local.FooBar();&#xA;    //    ~~~~~~&#xA;&#xA;    // Hidden copy as well&#xA;    _staticStruct.FooBar();&#xA;    //            ~~~~~~&#xA;}&#xA;&#xA;private static readonly MyStruct _staticStruct;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;Are highly appreciated. You may send a pull request with various fixes or you can suggest some interesting rule that can prevent from some nasty bugs in your app!&lt;/p&gt; &#xA;&lt;h1&gt;HowTos&lt;/h1&gt; &#xA;&lt;p&gt;Q: How to generate stable nuget packages that can be added to a local nuget feed? A: msbuild /p:PublicRelease=true&lt;/p&gt; &#xA;&lt;p&gt;Q: How to add a newly generate nuget package into a local nuget feed? A: nuget add $package -source c:\localPackages&lt;/p&gt; &#xA;&lt;h1&gt;Roadmap&lt;/h1&gt; &#xA;&lt;p&gt;TBD&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>DomainDrivers/dd-csharp</title>
    <updated>2024-04-26T01:25:28Z</updated>
    <id>tag:github.com,2024-04-26:/DomainDrivers/dd-csharp</id>
    <link href="https://github.com/DomainDrivers/dd-csharp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>