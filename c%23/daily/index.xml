<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-07T01:35:46Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ScottPlot/ScottPlot</title>
    <updated>2022-07-07T01:35:46Z</updated>
    <id>tag:github.com,2022-07-07:/ScottPlot/ScottPlot</id>
    <link href="https://github.com/ScottPlot/ScottPlot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Interactive Plotting Library for .NET&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ScottPlot&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ScottPlot/ScottPlot/actions/workflows/ci-ScottPlot-v4.yaml&#34;&gt;&lt;img src=&#34;https://github.com/ScottPlot/ScottPlot/actions/workflows/ci-ScottPlot-v4.yaml/badge.svg?sanitize=true&#34; alt=&#34;Test ScottPlot v4&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/ScottPlot/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/scottplot?color=004880&amp;amp;label=downloads&amp;amp;logo=NuGet&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/ScottPlot/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/scottplot?color=%23004880&amp;amp;label=NuGet&amp;amp;logo=nuget&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/ScottPlot/ScottPlot/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/scottplot/scottplot?color=%231281c0&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ScottPlot is a free and open-source plotting library for .NET&lt;/strong&gt; that makes it easy to interactively display large datasets. The &lt;a href=&#34;https://scottplot.net/cookbook&#34;&gt;&lt;strong&gt;ScottPlot Cookbook&lt;/strong&gt;&lt;/a&gt; demonstrates how to create line plots, bar charts, pie graphs, scatter plots, and more with just a few lines of code.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://scottplot.net/cookbook&#34;&gt;ScottPlot Cookbook&lt;/a&gt;&lt;/strong&gt; üëà &lt;em&gt;Learn how to use ScottPlot&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://scottplot.net/demo/&#34;&gt;ScottPlot Demo&lt;/a&gt;&lt;/strong&gt; üëà &lt;em&gt;See what ScottPlot can do&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Quickstart:&lt;/strong&gt; &lt;a href=&#34;https://scottplot.net/quickstart/winforms/&#34;&gt;&lt;strong&gt;WinForms&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://scottplot.net/quickstart/wpf/&#34;&gt;&lt;strong&gt;WPF&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://scottplot.net/quickstart/console/&#34;&gt;&lt;strong&gt;Console&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://scottplot.net/quickstart/avalonia/&#34;&gt;&lt;strong&gt;Avalonia&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://scottplot.net/quickstart/eto/&#34;&gt;&lt;strong&gt;Eto&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://scottplot.net/quickstart/powershell/&#34;&gt;&lt;strong&gt;PowerShell&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://scottplot.net/quickstart/notebook/&#34;&gt;&lt;strong&gt;Notebook&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://scottplot.net&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ScottPlot/ScottPlot/main/dev/graphics/ScottPlot.gif&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://scottplot.net/cookbook&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ScottPlot/ScottPlot/main/dev/graphics/cookbook.jpg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Windows Forms Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Windows Forms:&lt;/strong&gt; Use NuGet to install &lt;a href=&#34;https://www.nuget.org/packages/ScottPlot.WinForms&#34;&gt;&lt;code&gt;ScottPlot.WinForms&lt;/code&gt;&lt;/a&gt;, drag/drop a &lt;code&gt;FormsPlot&lt;/code&gt; onto your form, then add the following to your start-up sequence:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;double[] xs = new double[] {1, 2, 3, 4, 5};&#xA;double[] ys = new double[] {1, 4, 9, 16, 25};&#xA;formsPlot1.Plot.AddScatter(xs, ys);&#xA;formsPlot1.Refresh();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ScottPlot/ScottPlot/main/dev/graphics/winforms-quickstart.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;More Quickstart Guides&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scottplot.net/quickstart/console/&#34;&gt;&lt;strong&gt;Console Application&lt;/strong&gt; Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scottplot.net/quickstart/winforms/&#34;&gt;&lt;strong&gt;Windows Forms&lt;/strong&gt; Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scottplot.net/quickstart/wpf/&#34;&gt;&lt;strong&gt;WPF&lt;/strong&gt; Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scottplot.net/quickstart/avalonia/&#34;&gt;&lt;strong&gt;Avalonia&lt;/strong&gt; Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scottplot.net/quickstart/eto/&#34;&gt;&lt;strong&gt;Eto Forms&lt;/strong&gt; Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scottplot.net/quickstart/powershell/&#34;&gt;&lt;strong&gt;PowerShell&lt;/strong&gt; Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scottplot.net/quickstart/notebook/&#34;&gt;&lt;strong&gt;.NET Interactive Notebook&lt;/strong&gt; Quickstart&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Plot in the Cloud with ScottPlot&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;These images are generated by ScottPlot in the cloud.&lt;/strong&gt; Every hour an &lt;a href=&#34;https://azure.microsoft.com/en-us/services/functions/&#34;&gt;Azure Function&lt;/a&gt; hits the &lt;a href=&#34;https://docs.github.com/en/rest&#34;&gt;GitHub API&lt;/a&gt; to get an updated list of stargazers, then uses ScottPlot to create a figure from this data and saves it to web-accessible blob storage. Since this automatically-generated plot is just a static image accessible by a URL, it can be displayed in places where JavaScript is not permitted (like in this readme file) to display dynamic data.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://stargraph.z20.web.core.windows.net/scottplot-stars.png?&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://stargraph.z20.web.core.windows.net/scottplot-stars.png?&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://nugetppt.z20.web.core.windows.net/plots/scottplot.png?&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://nugetppt.z20.web.core.windows.net/plots/scottplot.png?&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Try it out!&lt;/strong&gt; Give us a star and come back in an hour and your name will appear &lt;a href=&#34;https://stargraph.z20.web.core.windows.net/scottplot-stars.png&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About ScottPlot&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://scottplot.net/changelog/&#34;&gt;ScottPlot Changelog&lt;/a&gt; details the most recent features and bug fixes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ScottPlot was created by &lt;a href=&#34;https://swharden.com/about/&#34;&gt;Scott W Harden&lt;/a&gt; and enhanced by &lt;a href=&#34;https://scottplot.net/contributors/&#34;&gt;many contributions&lt;/a&gt; from the open-source community.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ScottPlot is provided under the the permissive &lt;a href=&#34;https://raw.githubusercontent.com/ScottPlot/ScottPlot/main/LICENSE&#34;&gt;MIT license&lt;/a&gt; and is free to modify and use for any purpose.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you enjoy ScottPlot &lt;strong&gt;give it a star!&lt;/strong&gt; ‚≠ê&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>neuecc/UniRx</title>
    <updated>2022-07-07T01:35:46Z</updated>
    <id>tag:github.com,2022-07-07:/neuecc/UniRx</id>
    <link href="https://github.com/neuecc/UniRx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Reactive Extensions for Unity&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;UniRx - Reactive Extensions for Unity&lt;/h1&gt; &#xA;&lt;p&gt;Created by Yoshifumi Kawai(neuecc)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/neuecc/UniRx&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/neuecc/UniRx.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://opencollective.com/unirx&#34;&gt;&lt;img src=&#34;https://opencollective.com/unirx/tiers/backer.svg?avatarHeight=50&#34; alt=&#34;Become as Backer&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/unirx&#34;&gt;&lt;img src=&#34;https://opencollective.com/unirx/tiers/sponsor.svg?avatarHeight=50&#34; alt=&#34;Become as Sponsor&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is UniRx?&lt;/h2&gt; &#xA;&lt;p&gt;UniRx (Reactive Extensions for Unity) is a reimplementation of the .NET Reactive Extensions. The Official Rx implementation is great but doesn&#39;t work on Unity and has issues with iOS IL2CPP compatibility. This library fixes those issues and adds some specific utilities for Unity. Supported platforms are PC/Mac/Android/iOS/WebGL/WindowsStore/etc and the library.&lt;/p&gt; &#xA;&lt;p&gt;UniRx is available on the Unity Asset Store (FREE) - &lt;a href=&#34;http://u3d.as/content/neuecc/uni-rx-reactive-extensions-for-unity/7tT&#34;&gt;http://u3d.as/content/neuecc/uni-rx-reactive-extensions-for-unity/7tT&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Blog for update info - &lt;a href=&#34;https://medium.com/@neuecc&#34;&gt;https://medium.com/@neuecc&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Support thread on the Unity Forums: Ask me any question - &lt;a href=&#34;http://forum.unity3d.com/threads/248535-UniRx-Reactive-Extensions-for-Unity&#34;&gt;http://forum.unity3d.com/threads/248535-UniRx-Reactive-Extensions-for-Unity&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Release Notes, see &lt;a href=&#34;https://github.com/neuecc/UniRx/releases&#34;&gt;UniRx/releases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;UniRx is Core Library (Port of Rx) + Platform Adaptor (MainThreadScheduler/FromCoroutine/etc) + Framework (ObservableTriggers/ReactiveProeperty/etc).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: async/await integration(UniRx.Async) is separated to &lt;a href=&#34;https://github.com/Cysharp/UniTask&#34;&gt;Cysharp/UniTask&lt;/a&gt; after ver. 7.0.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Why Rx?&lt;/h2&gt; &#xA;&lt;p&gt;Ordinarily, Network operations in Unity require the use of &lt;code&gt;WWW&lt;/code&gt; and &lt;code&gt;Coroutine&lt;/code&gt;. That said, using &lt;code&gt;Coroutine&lt;/code&gt; is not good practice for asynchronous operations for the following (and other) reasons:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Coroutines can&#39;t return any values, since its return type must be IEnumerator.&lt;/li&gt; &#xA; &lt;li&gt;Coroutines can&#39;t handle exceptions, because yield return statements cannot be surrounded with a try-catch construction.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This kind of lack of composability causes operations to be close-coupled, which often results in huge monolithic IEnumerators.&lt;/p&gt; &#xA;&lt;p&gt;Rx cures that kind of &#34;asynchronous blues&#34;. Rx is a library for composing asynchronous and event-based programs using observable collections and LINQ-style query operators.&lt;/p&gt; &#xA;&lt;p&gt;The game loop (every Update, OnCollisionEnter, etc), sensor data (Kinect, Leap Motion, VR Input, etc.) are all types of events. Rx represents events as reactive sequences which are both easily composable and support time-based operations by using LINQ query operators.&lt;/p&gt; &#xA;&lt;p&gt;Unity is generally single threaded but UniRx facilitates multithreading for joins, cancels, accessing GameObjects, etc.&lt;/p&gt; &#xA;&lt;p&gt;UniRx helps UI programming with uGUI. All UI events (clicked, valuechanged, etc) can be converted to UniRx event streams.&lt;/p&gt; &#xA;&lt;p&gt;Unity supports async/await from 2017 with C# upgrades, UniRx family prjects provides more lightweight, more powerful async/await integration with Unity. Please see &lt;a href=&#34;https://github.com/Cysharp/UniTask&#34;&gt;Cysharp/UniTask&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Great introduction to Rx article: &lt;a href=&#34;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&#34;&gt;The introduction to Reactive Programming you&#39;ve been missing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following code implements the double click detection example from the article in UniRx:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var clickStream = Observable.EveryUpdate()&#xA;    .Where(_ =&amp;gt; Input.GetMouseButtonDown(0));&#xA;&#xA;clickStream.Buffer(clickStream.Throttle(TimeSpan.FromMilliseconds(250)))&#xA;    .Where(xs =&amp;gt; xs.Count &amp;gt;= 2)&#xA;    .Subscribe(xs =&amp;gt; Debug.Log(&#34;DoubleClick Detected! Count:&#34; + xs.Count));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example demonstrates the following features (in only five lines!):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The game loop (Update) as an event stream&lt;/li&gt; &#xA; &lt;li&gt;Composable event streams&lt;/li&gt; &#xA; &lt;li&gt;Merging self stream&lt;/li&gt; &#xA; &lt;li&gt;Easy handling of time based operations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Network operations&lt;/h2&gt; &#xA;&lt;p&gt;Use ObservableWWW for asynchronous network operations. Its Get/Post functions return subscribable IObservables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;ObservableWWW.Get(&#34;http://google.co.jp/&#34;)&#xA;    .Subscribe(&#xA;        x =&amp;gt; Debug.Log(x.Substring(0, 100)), // onSuccess&#xA;        ex =&amp;gt; Debug.LogException(ex)); // onError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rx is composable and cancelable. You can also query with LINQ expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// composing asynchronous sequence with LINQ query expressions&#xA;var query = from google in ObservableWWW.Get(&#34;http://google.com/&#34;)&#xA;            from bing in ObservableWWW.Get(&#34;http://bing.com/&#34;)&#xA;            from unknown in ObservableWWW.Get(google + bing)&#xA;            select new { google, bing, unknown };&#xA;&#xA;var cancel = query.Subscribe(x =&amp;gt; Debug.Log(x));&#xA;&#xA;// Call Dispose is cancel.&#xA;cancel.Dispose();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use Observable.WhenAll for parallel requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Observable.WhenAll is for parallel asynchronous operation&#xA;// (It&#39;s like Observable.Zip but specialized for single async operations like Task.WhenAll)&#xA;var parallel = Observable.WhenAll(&#xA;    ObservableWWW.Get(&#34;http://google.com/&#34;),&#xA;    ObservableWWW.Get(&#34;http://bing.com/&#34;),&#xA;    ObservableWWW.Get(&#34;http://unity3d.com/&#34;));&#xA;&#xA;parallel.Subscribe(xs =&amp;gt;&#xA;{&#xA;    Debug.Log(xs[0].Substring(0, 100)); // google&#xA;    Debug.Log(xs[1].Substring(0, 100)); // bing&#xA;    Debug.Log(xs[2].Substring(0, 100)); // unity&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Progress information is available:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// notifier for progress use ScheduledNotifier or new Progress&amp;lt;float&amp;gt;(/* action */)&#xA;var progressNotifier = new ScheduledNotifier&amp;lt;float&amp;gt;();&#xA;progressNotifier.Subscribe(x =&amp;gt; Debug.Log(x)); // write www.progress&#xA;&#xA;// pass notifier to WWW.Get/Post&#xA;ObservableWWW.Get(&#34;http://google.com/&#34;, progress: progressNotifier).Subscribe();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Error handling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// If WWW has .error, ObservableWWW throws WWWErrorException to onError pipeline.&#xA;// WWWErrorException has RawErrorMessage, HasResponse, StatusCode, ResponseHeaders&#xA;ObservableWWW.Get(&#34;http://www.google.com/404&#34;)&#xA;    .CatchIgnore((WWWErrorException ex) =&amp;gt;&#xA;    {&#xA;        Debug.Log(ex.RawErrorMessage);&#xA;        if (ex.HasResponse)&#xA;        {&#xA;            Debug.Log(ex.StatusCode);&#xA;        }&#xA;        foreach (var item in ex.ResponseHeaders)&#xA;        {&#xA;            Debug.Log(item.Key + &#34;:&#34; + item.Value);&#xA;        }&#xA;    })&#xA;    .Subscribe();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using with IEnumerators (Coroutines)&lt;/h2&gt; &#xA;&lt;p&gt;IEnumerator (Coroutine) is Unity&#39;s primitive asynchronous tool. UniRx integrates coroutines and IObservables. You can write asynchronious code in coroutines, and orchestrate them using UniRx. This is best way to control asynchronous flow.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// two coroutines&#xA;&#xA;IEnumerator AsyncA()&#xA;{&#xA;    Debug.Log(&#34;a start&#34;);&#xA;    yield return new WaitForSeconds(1);&#xA;    Debug.Log(&#34;a end&#34;);&#xA;}&#xA;&#xA;IEnumerator AsyncB()&#xA;{&#xA;    Debug.Log(&#34;b start&#34;);&#xA;    yield return new WaitForEndOfFrame();&#xA;    Debug.Log(&#34;b end&#34;);&#xA;}&#xA;&#xA;// main code&#xA;// Observable.FromCoroutine converts IEnumerator to Observable&amp;lt;Unit&amp;gt;.&#xA;// You can also use the shorthand, AsyncA().ToObservable()&#xA;        &#xA;// after AsyncA completes, run AsyncB as a continuous routine.&#xA;// UniRx expands SelectMany(IEnumerator) as SelectMany(IEnumerator.ToObservable())&#xA;var cancel = Observable.FromCoroutine(AsyncA)&#xA;    .SelectMany(AsyncB)&#xA;    .Subscribe();&#xA;&#xA;// you can stop a coroutine by calling your subscription&#39;s Dispose.&#xA;cancel.Dispose();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If in Unity 5.3, you can use ToYieldInstruction for Observable to Coroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;IEnumerator TestNewCustomYieldInstruction()&#xA;{&#xA;    // wait Rx Observable.&#xA;    yield return Observable.Timer(TimeSpan.FromSeconds(1)).ToYieldInstruction();&#xA;&#xA;    // you can change the scheduler(this is ignore Time.scale)&#xA;    yield return Observable.Timer(TimeSpan.FromSeconds(1), Scheduler.MainThreadIgnoreTimeScale).ToYieldInstruction();&#xA;&#xA;    // get return value from ObservableYieldInstruction&#xA;    var o = ObservableWWW.Get(&#34;http://unity3d.com/&#34;).ToYieldInstruction(throwOnError: false);&#xA;    yield return o;&#xA;&#xA;    if (o.HasError) { Debug.Log(o.Error.ToString()); }&#xA;    if (o.HasResult) { Debug.Log(o.Result); }&#xA;&#xA;    // other sample(wait until transform.position.y &amp;gt;= 100) &#xA;    yield return this.transform.ObserveEveryValueChanged(x =&amp;gt; x.position).FirstOrDefault(p =&amp;gt; p.y &amp;gt;= 100).ToYieldInstruction();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Normally, we have to use callbacks when we require a coroutine to return a value. Observable.FromCoroutine can convert coroutines to cancellable IObservable[T] instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// public method&#xA;public static IObservable&amp;lt;string&amp;gt; GetWWW(string url)&#xA;{&#xA;    // convert coroutine to IObservable&#xA;    return Observable.FromCoroutine&amp;lt;string&amp;gt;((observer, cancellationToken) =&amp;gt; GetWWWCore(url, observer, cancellationToken));&#xA;}&#xA;&#xA;// IObserver is a callback publisher&#xA;// Note: IObserver&#39;s basic scheme is &#34;OnNext* (OnError | Oncompleted)?&#34; &#xA;static IEnumerator GetWWWCore(string url, IObserver&amp;lt;string&amp;gt; observer, CancellationToken cancellationToken)&#xA;{&#xA;    var www = new UnityEngine.WWW(url);&#xA;    while (!www.isDone &amp;amp;&amp;amp; !cancellationToken.IsCancellationRequested)&#xA;    {&#xA;        yield return null;&#xA;    }&#xA;&#xA;    if (cancellationToken.IsCancellationRequested) yield break;&#xA;&#xA;    if (www.error != null)&#xA;    {&#xA;        observer.OnError(new Exception(www.error));&#xA;    }&#xA;    else&#xA;    {&#xA;        observer.OnNext(www.text);&#xA;        observer.OnCompleted(); // IObserver needs OnCompleted after OnNext!&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here are some more examples. Next is a multiple OnNext pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static IObservable&amp;lt;float&amp;gt; ToObservable(this UnityEngine.AsyncOperation asyncOperation)&#xA;{&#xA;    if (asyncOperation == null) throw new ArgumentNullException(&#34;asyncOperation&#34;);&#xA;&#xA;    return Observable.FromCoroutine&amp;lt;float&amp;gt;((observer, cancellationToken) =&amp;gt; RunAsyncOperation(asyncOperation, observer, cancellationToken));&#xA;}&#xA;&#xA;static IEnumerator RunAsyncOperation(UnityEngine.AsyncOperation asyncOperation, IObserver&amp;lt;float&amp;gt; observer, CancellationToken cancellationToken)&#xA;{&#xA;    while (!asyncOperation.isDone &amp;amp;&amp;amp; !cancellationToken.IsCancellationRequested)&#xA;    {&#xA;        observer.OnNext(asyncOperation.progress);&#xA;        yield return null;&#xA;    }&#xA;    if (!cancellationToken.IsCancellationRequested)&#xA;    {&#xA;        observer.OnNext(asyncOperation.progress); // push 100%&#xA;        observer.OnCompleted();&#xA;    }&#xA;}&#xA;&#xA;// usecase&#xA;Application.LoadLevelAsync(&#34;testscene&#34;)&#xA;    .ToObservable()&#xA;    .Do(x =&amp;gt; Debug.Log(x)) // output progress&#xA;    .Last() // last sequence is load completed&#xA;    .Subscribe();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using for MultiThreading&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Observable.Start is start factory methods on specified scheduler&#xA;// default is on ThreadPool&#xA;var heavyMethod = Observable.Start(() =&amp;gt;&#xA;{&#xA;    // heavy method...&#xA;    System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1));&#xA;    return 10;&#xA;});&#xA;&#xA;var heavyMethod2 = Observable.Start(() =&amp;gt;&#xA;{&#xA;    // heavy method...&#xA;    System.Threading.Thread.Sleep(TimeSpan.FromSeconds(3));&#xA;    return 10;&#xA;});&#xA;&#xA;// Join and await two other thread values&#xA;Observable.WhenAll(heavyMethod, heavyMethod2)&#xA;    .ObserveOnMainThread() // return to main thread&#xA;    .Subscribe(xs =&amp;gt;&#xA;    {&#xA;        // Unity can&#39;t touch GameObject from other thread&#xA;        // but use ObserveOnMainThread, you can touch GameObject naturally.&#xA;        (GameObject.Find(&#34;myGuiText&#34;)).guiText.text = xs[0] + &#34;:&#34; + xs[1];&#xA;    }); &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;DefaultScheduler&lt;/h2&gt; &#xA;&lt;p&gt;UniRx&#39;s default time based operations (Interval, Timer, Buffer(timeSpan), etc) use &lt;code&gt;Scheduler.MainThread&lt;/code&gt; as their scheduler. That means most operators (except for &lt;code&gt;Observable.Start&lt;/code&gt;) work on a single thread, so ObserverOn isn&#39;t needed and thread safety measures can be ignored. This is differet from the standard RxNet implementation but better suited to the Unity environment.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Scheduler.MainThread&lt;/code&gt; runs under Time.timeScale&#39;s influence. If you want to ignore the time scale, use &lt;code&gt; Scheduler.MainThreadIgnoreTimeScale&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;h2&gt;MonoBehaviour triggers&lt;/h2&gt; &#xA;&lt;p&gt;UniRx can handle MonoBehaviour events with &lt;code&gt;UniRx.Triggers&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using UniRx;&#xA;using UniRx.Triggers; // need UniRx.Triggers namespace&#xA;&#xA;public class MyComponent : MonoBehaviour&#xA;{&#xA;    void Start()&#xA;    {&#xA;        // Get the plain object&#xA;        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);&#xA;&#xA;        // Add ObservableXxxTrigger for handle MonoBehaviour&#39;s event as Observable&#xA;        cube.AddComponent&amp;lt;ObservableUpdateTrigger&amp;gt;()&#xA;            .UpdateAsObservable()&#xA;            .SampleFrame(30)&#xA;            .Subscribe(x =&amp;gt; Debug.Log(&#34;cube&#34;), () =&amp;gt; Debug.Log(&#34;destroy&#34;));&#xA;&#xA;        // destroy after 3 second:)&#xA;        GameObject.Destroy(cube, 3f);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported triggers are listed in &lt;a href=&#34;https://github.com/neuecc/UniRx/wiki#unirxtriggers&#34;&gt;UniRx.wiki#UniRx.Triggers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;These can also be handled more easily by directly subscribing to observables returned by extension methods on Component/GameObject. These methods inject ObservableTrigger automaticaly (except for &lt;code&gt;ObservableEventTrigger&lt;/code&gt; and &lt;code&gt;ObservableStateMachineTrigger&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using UniRx;&#xA;using UniRx.Triggers; // need UniRx.Triggers namespace for extend gameObejct&#xA;&#xA;public class DragAndDropOnce : MonoBehaviour&#xA;{&#xA;    void Start()&#xA;    {&#xA;        // All events can subscribe by ***AsObservable&#xA;        this.OnMouseDownAsObservable()&#xA;            .SelectMany(_ =&amp;gt; this.UpdateAsObservable())&#xA;            .TakeUntil(this.OnMouseUpAsObservable())&#xA;            .Select(_ =&amp;gt; Input.mousePosition)&#xA;            .Subscribe(x =&amp;gt; Debug.Log(x));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Previous versions of UniRx provided &lt;code&gt;ObservableMonoBehaviour&lt;/code&gt;. This is a legacy interface that is no longer supported. Please use UniRx.Triggers instead.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Creating custom triggers&lt;/h2&gt; &#xA;&lt;p&gt;Converting to Observable is the best way to handle Unity events. If the standard triggers supplied by UniRx are not enough, you can create custom triggers. To demonstrate, here&#39;s a LongTap trigger for uGUI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class ObservableLongPointerDownTrigger : ObservableTriggerBase, IPointerDownHandler, IPointerUpHandler&#xA;{&#xA;    public float IntervalSecond = 1f;&#xA;&#xA;    Subject&amp;lt;Unit&amp;gt; onLongPointerDown;&#xA;&#xA;    float? raiseTime;&#xA;&#xA;    void Update()&#xA;    {&#xA;        if (raiseTime != null &amp;amp;&amp;amp; raiseTime &amp;lt;= Time.realtimeSinceStartup)&#xA;        {&#xA;            if (onLongPointerDown != null) onLongPointerDown.OnNext(Unit.Default);&#xA;            raiseTime = null;&#xA;        }&#xA;    }&#xA;&#xA;    void IPointerDownHandler.OnPointerDown(PointerEventData eventData)&#xA;    {&#xA;        raiseTime = Time.realtimeSinceStartup + IntervalSecond;&#xA;    }&#xA;&#xA;    void IPointerUpHandler.OnPointerUp(PointerEventData eventData)&#xA;    {&#xA;        raiseTime = null;&#xA;    }&#xA;&#xA;    public IObservable&amp;lt;Unit&amp;gt; OnLongPointerDownAsObservable()&#xA;    {&#xA;        return onLongPointerDown ?? (onLongPointerDown = new Subject&amp;lt;Unit&amp;gt;());&#xA;    }&#xA;&#xA;    protected override void RaiseOnCompletedOnDestroy()&#xA;    {&#xA;        if (onLongPointerDown != null)&#xA;        {&#xA;            onLongPointerDown.OnCompleted();&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can be used as easily as the standard triggers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var trigger = button.AddComponent&amp;lt;ObservableLongPointerDownTrigger&amp;gt;();&#xA;&#xA;trigger.OnLongPointerDownAsObservable().Subscribe();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Observable Lifecycle Management&lt;/h2&gt; &#xA;&lt;p&gt;When is OnCompleted called? Subscription lifecycle management is very important to consider when using UniRx. &lt;code&gt;ObservableTriggers&lt;/code&gt; call OnCompleted when the GameObject they are attached to is destroyed. Other static generator methods (&lt;code&gt;Observable.Timer&lt;/code&gt;, &lt;code&gt;Observable.EveryUpdate&lt;/code&gt;, etc...) do not stop automatically, and their subscriptions should be managed manually.&lt;/p&gt; &#xA;&lt;p&gt;Rx provides some helper methods, such as &lt;code&gt;IDisposable.AddTo&lt;/code&gt; which allows you to dispose of several subscriptions at once:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// CompositeDisposable is similar with List&amp;lt;IDisposable&amp;gt;, manage multiple IDisposable&#xA;CompositeDisposable disposables = new CompositeDisposable(); // field&#xA;&#xA;void Start()&#xA;{&#xA;    Observable.EveryUpdate().Subscribe(x =&amp;gt; Debug.Log(x)).AddTo(disposables);&#xA;}&#xA;&#xA;void OnTriggerEnter(Collider other)&#xA;{&#xA;    // .Clear() =&amp;gt; Dispose is called for all inner disposables, and the list is cleared.&#xA;    // .Dispose() =&amp;gt; Dispose is called for all inner disposables, and Dispose is called immediately after additional Adds.&#xA;    disposables.Clear();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to automatically Dispose when a GameObjects is destroyed, use AddTo(GameObject/Component):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void Start()&#xA;{&#xA;    Observable.IntervalFrame(30).Subscribe(x =&amp;gt; Debug.Log(x)).AddTo(this);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;AddTo calls facilitate automatic Dispose. If you needs special OnCompleted handling in the pipeline, however, use &lt;code&gt;TakeWhile&lt;/code&gt;, &lt;code&gt;TakeUntil&lt;/code&gt;, &lt;code&gt;TakeUntilDestroy&lt;/code&gt; and &lt;code&gt;TakeUntilDisable&lt;/code&gt; instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Observable.IntervalFrame(30).TakeUntilDisable(this)&#xA;    .Subscribe(x =&amp;gt; Debug.Log(x), () =&amp;gt; Debug.Log(&#34;completed!&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you handle events, &lt;code&gt;Repeat&lt;/code&gt; is an important but dangerous method. It may cause an infinite loop, so handle with care:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using UniRx;&#xA;using UniRx.Triggers;&#xA;&#xA;public class DangerousDragAndDrop : MonoBehaviour&#xA;{&#xA;    void Start()&#xA;    {&#xA;        this.gameObject.OnMouseDownAsObservable()&#xA;            .SelectMany(_ =&amp;gt; this.gameObject.UpdateAsObservable())&#xA;            .TakeUntil(this.gameObject.OnMouseUpAsObservable())&#xA;            .Select(_ =&amp;gt; Input.mousePosition)&#xA;            .Repeat() // dangerous!!! Repeat cause infinite repeat subscribe at GameObject was destroyed.(If in UnityEditor, Editor is freezed)&#xA;            .Subscribe(x =&amp;gt; Debug.Log(x));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;UniRx provides an additional safe Repeat method. &lt;code&gt;RepeatSafe&lt;/code&gt;: if contiguous &#34;OnComplete&#34; are called repeat stops. &lt;code&gt;RepeatUntilDestroy(gameObject/component)&lt;/code&gt;, &lt;code&gt;RepeatUntilDisable(gameObject/component)&lt;/code&gt; allows to stop when a target GameObject has been destroyed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;this.gameObject.OnMouseDownAsObservable()&#xA;    .SelectMany(_ =&amp;gt; this.gameObject.UpdateAsObservable())&#xA;    .TakeUntil(this.gameObject.OnMouseUpAsObservable())&#xA;    .Select(_ =&amp;gt; Input.mousePosition)&#xA;    .RepeatUntilDestroy(this) // safety way&#xA;    .Subscribe(x =&amp;gt; Debug.Log(x));            &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;UniRx gurantees hot observable(FromEvent/Subject/ReactiveProperty/UnityUI.AsObservable..., there are like event) have unhandled exception durability. What is it? If subscribe in subcribe, does not detach event.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;button.OnClickAsObservable().Subscribe(_ =&amp;gt;&#xA;{&#xA;    // If throws error in inner subscribe, but doesn&#39;t detached OnClick event.&#xA;    ObservableWWW.Get(&#34;htttp://error/&#34;).Subscribe(x =&amp;gt;&#xA;    {&#xA;        Debug.Log(x);&#xA;    });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This behaviour is sometimes useful such as user event handling.&lt;/p&gt; &#xA;&lt;p&gt;All class instances provide an &lt;code&gt;ObserveEveryValueChanged&lt;/code&gt; method, which watches for changing values every frame:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// watch position change&#xA;this.transform.ObserveEveryValueChanged(x =&amp;gt; x.position).Subscribe(x =&amp;gt; Debug.Log(x));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s very useful. If the watch target is a GameObject, it will stop observing when the target is destroyed, and call OnCompleted. If the watch target is a plain C# Object, OnCompleted will be called on GC.&lt;/p&gt; &#xA;&lt;h2&gt;Converting Unity callbacks to IObservables&lt;/h2&gt; &#xA;&lt;p&gt;Use Subject (or AsyncSubject for asynchronious operations):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class LogCallback&#xA;{&#xA;    public string Condition;&#xA;    public string StackTrace;&#xA;    public UnityEngine.LogType LogType;&#xA;}&#xA;&#xA;public static class LogHelper&#xA;{&#xA;    static Subject&amp;lt;LogCallback&amp;gt; subject;&#xA;&#xA;    public static IObservable&amp;lt;LogCallback&amp;gt; LogCallbackAsObservable()&#xA;    {&#xA;        if (subject == null)&#xA;        {&#xA;            subject = new Subject&amp;lt;LogCallback&amp;gt;();&#xA;&#xA;            // Publish to Subject in callback&#xA;            UnityEngine.Application.RegisterLogCallback((condition, stackTrace, type) =&amp;gt;&#xA;            {&#xA;                subject.OnNext(new LogCallback { Condition = condition, StackTrace = stackTrace, LogType = type });&#xA;            });&#xA;        }&#xA;&#xA;        return subject.AsObservable();&#xA;    }&#xA;}&#xA;&#xA;// method is separatable and composable&#xA;LogHelper.LogCallbackAsObservable()&#xA;    .Where(x =&amp;gt; x.LogType == LogType.Warning)&#xA;    .Subscribe();&#xA;&#xA;LogHelper.LogCallbackAsObservable()&#xA;    .Where(x =&amp;gt; x.LogType == LogType.Error)&#xA;    .Subscribe();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Unity5, &lt;code&gt;Application.RegisterLogCallback&lt;/code&gt; was removed in favor of &lt;code&gt;Application.logMessageReceived&lt;/code&gt;, so we can now simply use &lt;code&gt;Observable.FromEvent&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static IObservable&amp;lt;LogCallback&amp;gt; LogCallbackAsObservable()&#xA;{&#xA;    return Observable.FromEvent&amp;lt;Application.LogCallback, LogCallback&amp;gt;(&#xA;        h =&amp;gt; (condition, stackTrace, type) =&amp;gt; h(new LogCallback { Condition = condition, StackTrace = stackTrace, LogType = type }),&#xA;        h =&amp;gt; Application.logMessageReceived += h, h =&amp;gt; Application.logMessageReceived -= h);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Stream Logger&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// using UniRx.Diagnostics;&#xA;&#xA;// logger is threadsafe, define per class with name.&#xA;static readonly Logger logger = new Logger(&#34;Sample11&#34;);&#xA;&#xA;// call once at applicationinit&#xA;public static void ApplicationInitialize()&#xA;{&#xA;    // Log as Stream, UniRx.Diagnostics.ObservableLogger.Listener is IObservable&amp;lt;LogEntry&amp;gt;&#xA;    // You can subscribe and output to any place.&#xA;    ObservableLogger.Listener.LogToUnityDebug();&#xA;&#xA;    // for example, filter only Exception and upload to web.&#xA;    // (make custom sink(IObserver&amp;lt;EventEntry&amp;gt;) is better to use)&#xA;    ObservableLogger.Listener&#xA;        .Where(x =&amp;gt; x.LogType == LogType.Exception)&#xA;        .Subscribe(x =&amp;gt;&#xA;        {&#xA;            // ObservableWWW.Post(&#34;&#34;, null).Subscribe();&#xA;        });&#xA;}&#xA;&#xA;// Debug is write only DebugBuild.&#xA;logger.Debug(&#34;Debug Message&#34;);&#xA;&#xA;// or other logging methods&#xA;logger.Log(&#34;Message&#34;);&#xA;logger.Exception(new Exception(&#34;test exception&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Debug&lt;/code&gt; operator in &lt;code&gt;UniRx.Diagnostics&lt;/code&gt; namespace helps debugging.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// needs Diagnostics using&#xA;using UniRx.Diagnostics;&#xA;&#xA;---&#xA;&#xA;// [DebugDump, Normal]OnSubscribe&#xA;// [DebugDump, Normal]OnNext(1)&#xA;// [DebugDump, Normal]OnNext(10)&#xA;// [DebugDump, Normal]OnCompleted()&#xA;{&#xA;    var subject = new Subject&amp;lt;int&amp;gt;();&#xA;&#xA;    subject.Debug(&#34;DebugDump, Normal&#34;).Subscribe();&#xA;&#xA;    subject.OnNext(1);&#xA;    subject.OnNext(10);&#xA;    subject.OnCompleted();&#xA;}&#xA;&#xA;// [DebugDump, Cancel]OnSubscribe&#xA;// [DebugDump, Cancel]OnNext(1)&#xA;// [DebugDump, Cancel]OnCancel&#xA;{&#xA;    var subject = new Subject&amp;lt;int&amp;gt;();&#xA;&#xA;    var d = subject.Debug(&#34;DebugDump, Cancel&#34;).Subscribe();&#xA;&#xA;    subject.OnNext(1);&#xA;    d.Dispose();&#xA;}&#xA;&#xA;// [DebugDump, Error]OnSubscribe&#xA;// [DebugDump, Error]OnNext(1)&#xA;// [DebugDump, Error]OnError(System.Exception)&#xA;{&#xA;    var subject = new Subject&amp;lt;int&amp;gt;();&#xA;&#xA;    subject.Debug(&#34;DebugDump, Error&#34;).Subscribe();&#xA;&#xA;    subject.OnNext(1);&#xA;    subject.OnError(new Exception());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;shows sequence element on &lt;code&gt;OnNext&lt;/code&gt;, &lt;code&gt;OnError&lt;/code&gt;, &lt;code&gt;OnCompleted&lt;/code&gt;, &lt;code&gt;OnCancel&lt;/code&gt;, &lt;code&gt;OnSubscribe&lt;/code&gt; timing to Debug.Log. It enables only &lt;code&gt;#if DEBUG&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Unity-specific Extra Gems&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Unity&#39;s singleton UiThread Queue Scheduler&#xA;Scheduler.MainThreadScheduler &#xA;ObserveOnMainThread()/SubscribeOnMainThread()&#xA;&#xA;// Global StartCoroutine runner&#xA;MainThreadDispatcher.StartCoroutine(enumerator)&#xA;&#xA;// convert Coroutine to IObservable&#xA;Observable.FromCoroutine((observer, token) =&amp;gt; enumerator(observer, token)); &#xA;&#xA;// convert IObservable to Coroutine&#xA;yield return Observable.Range(1, 10).ToYieldInstruction(); // after Unity 5.3, before can use StartAsCoroutine()&#xA;&#xA;// Lifetime hooks&#xA;Observable.EveryApplicationPause();&#xA;Observable.EveryApplicationFocus();&#xA;Observable.OnceApplicationQuit();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Framecount-based time operators&lt;/h2&gt; &#xA;&lt;p&gt;UniRx provides a few framecount-based time operators:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;EveryUpdate&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;EveryFixedUpdate&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;EveryEndOfFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;EveryGameObjectUpdate&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;EveryLateUpdate&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ObserveOnMainThread&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NextFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;IntervalFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TimerFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DelayFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SampleFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ThrottleFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ThrottleFirstFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TimeoutFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DelayFrameSubscription&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FrameInterval&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FrameTimeInterval&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BatchFrame&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For example, delayed invoke once:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Observable.TimerFrame(100).Subscribe(_ =&amp;gt; Debug.Log(&#34;after 100 frame&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every* Method&#39;s execution order is&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;EveryGameObjectUpdate(in MainThreadDispatcher&#39;s Execution Order) -&amp;gt;&#xA;EveryUpdate -&amp;gt; &#xA;EveryLateUpdate -&amp;gt; &#xA;EveryEndOfFrame&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;EveryGameObjectUpdate invoke from same frame if caller is called before MainThreadDispatcher.Update(I recommend MainThreadDispatcher called first than others(ScriptExecutionOrder makes -32000)&lt;br&gt; EveryLateUpdate, EveryEndOfFrame invoke from same frame.&lt;br&gt; EveryUpdate, invoke from next frame.&lt;/p&gt; &#xA;&lt;h2&gt;MicroCoroutine&lt;/h2&gt; &#xA;&lt;p&gt;MicroCoroutine is memory efficient and fast coroutine worker. This implemantation is based on &lt;a href=&#34;http://blogs.unity3d.com/2015/12/23/1k-update-calls/&#34;&gt;Unity blog&#39;s 10000 UPDATE() CALLS&lt;/a&gt;, avoid managed-unmanaged overhead so gets 10x faster iteration. MicroCoroutine is automaticaly used on Framecount-based time operators and ObserveEveryValueChanged.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use MicroCoroutine instead of standard unity coroutine, use &lt;code&gt;MainThreadDispatcher.StartUpdateMicroCoroutine&lt;/code&gt; or &lt;code&gt;Observable.FromMicroCoroutine&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int counter;&#xA;&#xA;IEnumerator Worker()&#xA;{&#xA;    while(true)&#xA;    {&#xA;        counter++;&#xA;        yield return null;&#xA;    }&#xA;}&#xA;&#xA;void Start()&#xA;{&#xA;    for(var i = 0; i &amp;lt; 10000; i++)&#xA;    {&#xA;        // fast, memory efficient&#xA;        MainThreadDispatcher.StartUpdateMicroCoroutine(Worker());&#xA;&#xA;        // slow...&#xA;        // StartCoroutine(Worker());&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/46207/15267997/86e9ed5c-1a0c-11e6-8371-14b61a09c72c.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;MicroCoroutine&#39;s limitation, only supports &lt;code&gt;yield return null&lt;/code&gt; and update timing is determined start method(&lt;code&gt;StartUpdateMicroCoroutine&lt;/code&gt;, &lt;code&gt;StartFixedUpdateMicroCoroutine&lt;/code&gt;, &lt;code&gt;StartEndOfFrameMicroCoroutine&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If you combine with other IObservable, you can check completed property like isDone.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;IEnumerator MicroCoroutineWithToYieldInstruction()&#xA;{&#xA;    var www = ObservableWWW.Get(&#34;http://aaa&#34;).ToYieldInstruction();&#xA;    while (!www.IsDone)&#xA;    {&#xA;        yield return null;&#xA;    }&#xA;&#xA;    if (www.HasResult)&#xA;    {&#xA;        UnityEngine.Debug.Log(www.Result);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;uGUI Integration&lt;/h2&gt; &#xA;&lt;p&gt;UniRx can handle &lt;code&gt;UnityEvent&lt;/code&gt;s easily. Use &lt;code&gt;UnityEvent.AsObservable&lt;/code&gt; to subscribe to events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public Button MyButton;&#xA;// ---&#xA;MyButton.onClick.AsObservable().Subscribe(_ =&amp;gt; Debug.Log(&#34;clicked&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Treating Events as Observables enables declarative UI programming.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public Toggle MyToggle;&#xA;public InputField MyInput;&#xA;public Text MyText;&#xA;public Slider MySlider;&#xA;&#xA;// On Start, you can write reactive rules for declaretive/reactive ui programming&#xA;void Start()&#xA;{&#xA;    // Toggle, Input etc as Observable (OnValueChangedAsObservable is a helper providing isOn value on subscribe)&#xA;    // SubscribeToInteractable is an Extension Method, same as .interactable = x)&#xA;    MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);&#xA;    &#xA;    // Input is displayed after a 1 second delay&#xA;    MyInput.OnValueChangedAsObservable()&#xA;        .Where(x =&amp;gt; x != null)&#xA;        .Delay(TimeSpan.FromSeconds(1))&#xA;        .SubscribeToText(MyText); // SubscribeToText is helper for subscribe to text&#xA;    &#xA;    // Converting for human readability&#xA;    MySlider.OnValueChangedAsObservable()&#xA;        .SubscribeToText(MyText, x =&amp;gt; Math.Round(x, 2).ToString());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more on reactive UI programming please consult Sample12, Sample13 and the ReactiveProperty section below.&lt;/p&gt; &#xA;&lt;h2&gt;ReactiveProperty, ReactiveCollection&lt;/h2&gt; &#xA;&lt;p&gt;Game data often requires notification. Should we use properties and events (callbacks)? That&#39;s often too complex. UniRx provides ReactiveProperty, a lightweight property broker.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Reactive Notification Model&#xA;public class Enemy&#xA;{&#xA;    public ReactiveProperty&amp;lt;long&amp;gt; CurrentHp { get; private set; }&#xA;&#xA;    public ReactiveProperty&amp;lt;bool&amp;gt; IsDead { get; private set; }&#xA;&#xA;    public Enemy(int initialHp)&#xA;    {&#xA;        // Declarative Property&#xA;        CurrentHp = new ReactiveProperty&amp;lt;long&amp;gt;(initialHp);&#xA;        IsDead = CurrentHp.Select(x =&amp;gt; x &amp;lt;= 0).ToReactiveProperty();&#xA;    }&#xA;}&#xA;&#xA;// ---&#xA;// onclick, HP decrement&#xA;MyButton.OnClickAsObservable().Subscribe(_ =&amp;gt; enemy.CurrentHp.Value -= 99);&#xA;// subscribe from notification model.&#xA;enemy.CurrentHp.SubscribeToText(MyText);&#xA;enemy.IsDead.Where(isDead =&amp;gt; isDead == true)&#xA;    .Subscribe(_ =&amp;gt;&#xA;    {&#xA;        MyButton.interactable = false;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can combine ReactiveProperties, ReactiveCollections and observables returned by UnityEvent.AsObservable. All UI elements are observable.&lt;/p&gt; &#xA;&lt;p&gt;Generic ReactiveProperties are not serializable or inspecatble in the Unity editor, but UniRx provides specialized subclasses of ReactiveProperty that are. These include classes such as Int/LongReactiveProperty, Float/DoubleReactiveProperty, StringReactiveProperty, BoolReactiveProperty and more (Browse them here: &lt;a href=&#34;https://github.com/neuecc/UniRx/raw/master/Assets/Plugins/UniRx/Scripts/UnityEngineBridge/InspectableReactiveProperty.cs&#34;&gt;InspectableReactiveProperty.cs&lt;/a&gt;). All are fully editable in the inspector. For custom Enum ReactiveProperty, it&#39;s easy to write a custom inspectable ReactiveProperty[T].&lt;/p&gt; &#xA;&lt;p&gt;If you needs &lt;code&gt;[Multiline]&lt;/code&gt; or &lt;code&gt;[Range]&lt;/code&gt; attach to ReactiveProperty, you can use &lt;code&gt;MultilineReactivePropertyAttribute&lt;/code&gt; and &lt;code&gt;RangeReactivePropertyAttribute&lt;/code&gt; instead of &lt;code&gt;Multiline&lt;/code&gt; and &lt;code&gt;Range&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The provided derived InpsectableReactiveProperties are displayed in the inspector naturally and notify when their value is changed even when it is changed in the inspector.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/RxPropInspector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This functionality is provided by &lt;a href=&#34;https://github.com/neuecc/UniRx/raw/master/Assets/Plugins/UniRx/Scripts/UnityEngineBridge/InspectorDisplayDrawer.cs&#34;&gt;InspectorDisplayDrawer&lt;/a&gt;. You can supply your own custom specialized ReactiveProperties by inheriting from it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public enum Fruit&#xA;{&#xA;    Apple, Grape&#xA;}&#xA;&#xA;[Serializable]&#xA;public class FruitReactiveProperty : ReactiveProperty&amp;lt;Fruit&amp;gt;&#xA;{&#xA;    public FruitReactiveProperty()&#xA;    {&#xA;    }&#xA;&#xA;    public FruitReactiveProperty(Fruit initialValue)&#xA;        :base(initialValue)&#xA;    {&#xA;    }&#xA;}&#xA;&#xA;[UnityEditor.CustomPropertyDrawer(typeof(FruitReactiveProperty))]&#xA;[UnityEditor.CustomPropertyDrawer(typeof(YourSpecializedReactiveProperty2))] // and others...&#xA;public class ExtendInspectorDisplayDrawer : InspectorDisplayDrawer&#xA;{&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If a ReactiveProperty value is only updated within a stream, you can make it read only by using from &lt;code&gt;ReadOnlyReactiveProperty&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Person&#xA;{&#xA;    public ReactiveProperty&amp;lt;string&amp;gt; GivenName { get; private set; }&#xA;    public ReactiveProperty&amp;lt;string&amp;gt; FamilyName { get; private set; }&#xA;    public ReadOnlyReactiveProperty&amp;lt;string&amp;gt; FullName { get; private set; }&#xA;&#xA;    public Person(string givenName, string familyName)&#xA;    {&#xA;        GivenName = new ReactiveProperty&amp;lt;string&amp;gt;(givenName);&#xA;        FamilyName = new ReactiveProperty&amp;lt;string&amp;gt;(familyName);&#xA;        // If change the givenName or familyName, notify with fullName!&#xA;        FullName = GivenName.CombineLatest(FamilyName, (x, y) =&amp;gt; x + &#34; &#34; + y).ToReadOnlyReactiveProperty();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Model-View-(Reactive)Presenter Pattern&lt;/h2&gt; &#xA;&lt;p&gt;UniRx makes it possible to implement the MVP(MVRP) Pattern.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/MVP_Pattern.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Why should we use MVP instead of MVVM? Unity doesn&#39;t provide a UI binding mechanism and creating a binding layer is too complex and loss and affects performance. Still, Views need updating. Presenters are aware of their view&#39;s components and can update them. Although there is no real binding, Observables enables subscription to notification, which can act much like the real thing. This pattern is called a Reactive Presenter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Presenter for scene(canvas) root.&#xA;public class ReactivePresenter : MonoBehaviour&#xA;{&#xA;    // Presenter is aware of its View (binded in the inspector)&#xA;    public Button MyButton;&#xA;    public Toggle MyToggle;&#xA;    &#xA;    // State-Change-Events from Model by ReactiveProperty&#xA;    Enemy enemy = new Enemy(1000);&#xA;&#xA;    void Start()&#xA;    {&#xA;        // Rx supplies user events from Views and Models in a reactive manner &#xA;        MyButton.OnClickAsObservable().Subscribe(_ =&amp;gt; enemy.CurrentHp.Value -= 99);&#xA;        MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);&#xA;&#xA;        // Models notify Presenters via Rx, and Presenters update their views&#xA;        enemy.CurrentHp.SubscribeToText(MyText);&#xA;        enemy.IsDead.Where(isDead =&amp;gt; isDead == true)&#xA;            .Subscribe(_ =&amp;gt;&#xA;            {&#xA;                MyToggle.interactable = MyButton.interactable = false;&#xA;            });&#xA;    }&#xA;}&#xA;&#xA;// The Model. All property notify when their values change&#xA;public class Enemy&#xA;{&#xA;    public ReactiveProperty&amp;lt;long&amp;gt; CurrentHp { get; private set; }&#xA;&#xA;    public ReactiveProperty&amp;lt;bool&amp;gt; IsDead { get; private set; }&#xA;&#xA;    public Enemy(int initialHp)&#xA;    {&#xA;        // Declarative Property&#xA;        CurrentHp = new ReactiveProperty&amp;lt;long&amp;gt;(initialHp);&#xA;        IsDead = CurrentHp.Select(x =&amp;gt; x &amp;lt;= 0).ToReactiveProperty();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A View is a scene, that is a Unity hierarchy. Views are associated with Presenters by the Unity Engine on initialize. The XxxAsObservable methods make creating event signals simple, without any overhead. SubscribeToText and SubscribeToInteractable are simple binding-like helpers. These may be simple tools, but they are very powerful. They feel natural in the Unity environment and provide high performance and a clean architecture.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/MVRP_Loop.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;V -&amp;gt; RP -&amp;gt; M -&amp;gt; RP -&amp;gt; V completely connected in a reactive way. UniRx provides all of the adaptor methods and classes, but other MVVM(or MV*) frameworks can be used instead. UniRx/ReactiveProperty is only simple toolkit.&lt;/p&gt; &#xA;&lt;p&gt;GUI programming also benefits from ObservableTriggers. ObservableTriggers convert Unity events to Observables, so the MV(R)P pattern can be composed using them. For example, &lt;code&gt;ObservableEventTrigger&lt;/code&gt; converts uGUI events to Observable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var eventTrigger = this.gameObject.AddComponent&amp;lt;ObservableEventTrigger&amp;gt;();&#xA;eventTrigger.OnBeginDragAsObservable()&#xA;    .SelectMany(_ =&amp;gt; eventTrigger.OnDragAsObservable(), (start, current) =&amp;gt; UniRx.Tuple.Create(start, current))&#xA;    .TakeUntil(eventTrigger.OnEndDragAsObservable())&#xA;    .RepeatUntilDestroy(this)&#xA;    .Subscribe(x =&amp;gt; Debug.Log(x));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;(Obsolete)PresenterBase&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: PresenterBase works enough, but too complex.&lt;br&gt; You can use simple &lt;code&gt;Initialize&lt;/code&gt; method and call parent to child, it works for most scenario.&lt;br&gt; So I don&#39;t recommend using &lt;code&gt;PresenterBase&lt;/code&gt;, sorry.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;ReactiveCommand, AsyncReactiveCommand&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveCommand abstraction of button command with boolean interactable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Player&#xA;{&#x9;&#x9;&#xA;   public ReactiveProperty&amp;lt;int&amp;gt; Hp;&#x9;&#x9;&#xA;   public ReactiveCommand Resurrect;&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;   public Player()&#xA;   {&#x9;&#x9;&#xA;        Hp = new ReactiveProperty&amp;lt;int&amp;gt;(1000);&#x9;&#x9;&#xA;        &#x9;&#x9;&#xA;        // If dead, can not execute.&#x9;&#x9;&#xA;        Resurrect = Hp.Select(x =&amp;gt; x &amp;lt;= 0).ToReactiveCommand();&#x9;&#x9;&#xA;        // Execute when clicked&#x9;&#x9;&#xA;        Resurrect.Subscribe(_ =&amp;gt;&#x9;&#x9;&#xA;        {&#x9;&#x9;&#xA;             Hp.Value = 1000;&#x9;&#x9;&#xA;        }); &#x9;&#x9;&#xA;    }&#x9;&#x9;&#xA;}&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;public class Presenter : MonoBehaviour&#x9;&#x9;&#xA;{&#x9;&#x9;&#xA;    public Button resurrectButton;&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;    Player player;&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;    void Start()&#xA;    {&#x9;&#x9;&#xA;      player = new Player();&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;      // If Hp &amp;lt;= 0, can&#39;t press button.&#x9;&#x9;&#xA;      player.Resurrect.BindTo(resurrectButton);&#x9;&#x9;&#xA;    }&#x9;&#x9;&#xA;}&#x9;&#x9;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;AsyncReactiveCommand is a variation of ReactiveCommand that &lt;code&gt;CanExecute&lt;/code&gt;(in many cases bind to button&#39;s interactable) is changed to false until asynchronous execution was finished.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Presenter : MonoBehaviour&#x9;&#x9;&#xA;{&#x9;&#x9;&#xA;    public UnityEngine.UI.Button button;&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;    void Start()&#xA;    {&#x9;&#x9;&#xA;        var command = new AsyncReactiveCommand();&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;        command.Subscribe(_ =&amp;gt;&#x9;&#x9;&#xA;        {&#x9;&#x9;&#xA;            // heavy, heavy, heavy method....&#x9;&#x9;&#xA;            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();&#x9;&#x9;&#xA;        });&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;        // after clicked, button shows disable for 3 seconds&#x9;&#x9;&#xA;        command.BindTo(button);&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;        // Note:shortcut extension, bind aync onclick directly&#x9;&#x9;&#xA;        button.BindToOnClick(_ =&amp;gt;&#x9;&#x9;&#xA;        {&#x9;&#x9;&#xA;            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();&#x9;&#x9;&#xA;        });&#x9;&#x9;&#xA;    }&#x9;&#x9;&#xA;}&#x9;&#x9;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;AsyncReactiveCommand&lt;/code&gt; has three constructor.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;()&lt;/code&gt; - CanExecute is changed to false until async execution finished&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(IObservable&amp;lt;bool&amp;gt; canExecuteSource)&lt;/code&gt; - Mixed with empty, CanExecute becomes true when canExecuteSource send to true and does not executing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(IReactiveProperty&amp;lt;bool&amp;gt; sharedCanExecute)&lt;/code&gt; - share execution status between multiple AsyncReactiveCommands, if one AsyncReactiveCommand is executing, other AsyncReactiveCommands(with same sharedCanExecute property) becomes CanExecute false until async execution finished&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Presenter : MonoBehaviour&#xA;{&#xA;    public UnityEngine.UI.Button button1;&#xA;    public UnityEngine.UI.Button button2;&#xA;&#xA;    void Start()&#xA;    {&#xA;        // share canExecute status.&#xA;        // when clicked button1, button1 and button2 was disabled for 3 seconds.&#xA;&#xA;        var sharedCanExecute = new ReactiveProperty&amp;lt;bool&amp;gt;();&#xA;&#xA;        button1.BindToOnClick(sharedCanExecute, _ =&amp;gt;&#xA;        {&#xA;            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();&#xA;        });&#xA;&#xA;        button2.BindToOnClick(sharedCanExecute, _ =&amp;gt;&#xA;        {&#xA;            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();&#xA;        });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;MessageBroker, AsyncMessageBroker&lt;/h2&gt; &#xA;&lt;p&gt;MessageBroker is Rx based in-memory pubsub system filtered by type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class TestArgs&#xA;{&#xA;    public int Value { get; set; }&#xA;}&#xA;&#xA;---&#xA;&#xA;// Subscribe message on global-scope.&#xA;MessageBroker.Default.Receive&amp;lt;TestArgs&amp;gt;().Subscribe(x =&amp;gt; UnityEngine.Debug.Log(x));&#xA;&#xA;// Publish message&#xA;MessageBroker.Default.Publish(new TestArgs { Value = 1000 });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;AsyncMessageBroker is variation of MessageBroker, can await Publish call.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;AsyncMessageBroker.Default.Subscribe&amp;lt;TestArgs&amp;gt;(x =&amp;gt;&#xA;{&#xA;    // show after 3 seconds.&#xA;    return Observable.Timer(TimeSpan.FromSeconds(3))&#xA;        .ForEachAsync(_ =&amp;gt;&#xA;        {&#xA;            UnityEngine.Debug.Log(x);&#xA;        });&#xA;});&#xA;&#xA;AsyncMessageBroker.Default.PublishAsync(new TestArgs { Value = 3000 })&#xA;    .Subscribe(_ =&amp;gt;&#xA;    {&#xA;        UnityEngine.Debug.Log(&#34;called all subscriber completed&#34;);&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;UniRx.Toolkit&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;UniRx.Toolkit&lt;/code&gt; includes serveral Rx-ish tools. Currently includes &lt;code&gt;ObjectPool&lt;/code&gt; and &lt;code&gt;AsyncObjectPool&lt;/code&gt;. It can &lt;code&gt;Rent&lt;/code&gt;, &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;PreloadAsync&lt;/code&gt; for fill pool before rent operation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// sample class&#xA;public class Foobar : MonoBehaviour&#xA;{&#xA;    public IObservable&amp;lt;Unit&amp;gt; ActionAsync()&#xA;    {&#xA;        // heavy, heavy, action...&#xA;        return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();&#xA;    }&#xA;}&#xA;&#xA;public class FoobarPool : ObjectPool&amp;lt;Foobar&amp;gt;&#xA;{&#xA;    readonly Foobar prefab;&#xA;    readonly Transform hierarchyParent;&#xA;&#xA;    public FoobarPool(Foobar prefab, Transform hierarchyParent)&#xA;    {&#xA;        this.prefab = prefab;&#xA;        this.hierarchyParent = hierarchyParent;&#xA;    }&#xA;&#xA;    protected override Foobar CreateInstance()&#xA;    {&#xA;        var foobar = GameObject.Instantiate&amp;lt;Foobar&amp;gt;(prefab);&#xA;        foobar.transform.SetParent(hierarchyParent);&#xA;&#xA;        return foobar;&#xA;    }&#xA;&#xA;    // You can overload OnBeforeRent, OnBeforeReturn, OnClear for customize action.&#xA;    // In default, OnBeforeRent = SetActive(true), OnBeforeReturn = SetActive(false)&#xA;&#xA;    // protected override void OnBeforeRent(Foobar instance)&#xA;    // protected override void OnBeforeReturn(Foobar instance)&#xA;    // protected override void OnClear(Foobar instance)&#xA;}&#xA;&#xA;public class Presenter : MonoBehaviour&#xA;{&#xA;    FoobarPool pool = null;&#xA;&#xA;    public Foobar prefab;&#xA;    public Button rentButton;&#xA;&#xA;    void Start()&#xA;    {&#xA;        pool = new FoobarPool(prefab, this.transform);&#xA;&#xA;        rentButton.OnClickAsObservable().Subscribe(_ =&amp;gt;&#xA;        {&#xA;            var foobar = pool.Rent();&#xA;            foobar.ActionAsync().Subscribe(__ =&amp;gt;&#xA;            {&#xA;                // if action completed, return to pool&#xA;                pool.Return(foobar);&#xA;            });&#xA;        });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Visual Studio Analyzer&lt;/h2&gt; &#xA;&lt;p&gt;For Visual Studio 2015 users, a custom analyzer, UniRxAnalyzer, is provided. It can, for example, detect when streams aren&#39;t subscribed to.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/AnalyzerReference.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/VSAnalyzer.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ObservableWWW&lt;/code&gt; doesn&#39;t fire until it&#39;s subscribed to, so the analyzer warns about incorrect usage. It can be downloaded from NuGet.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install-Package &lt;a href=&#34;http://www.nuget.org/packages/UniRxAnalyzer&#34;&gt;UniRxAnalyzer&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please submit new analyzer ideas on GitHub Issues!&lt;/p&gt; &#xA;&lt;h2&gt;Samples&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/neuecc/UniRx/tree/master/Assets/Plugins/UniRx/Examples&#34;&gt;UniRx/Examples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The samples demonstrate how to do resource management (Sample09_EventHandling), what is the MainThreadDispatcher, among other things.&lt;/p&gt; &#xA;&lt;h2&gt;Windows Store/Phone App (NETFX_CORE)&lt;/h2&gt; &#xA;&lt;p&gt;Some interfaces, such as &lt;code&gt;UniRx.IObservable&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;System.IObservable&amp;lt;T&amp;gt;&lt;/code&gt;, cause conflicts when submitting to the Windows Store App. Therefore, when using NETFX_CORE, please refrain from using such constructs as &lt;code&gt;UniRx.IObservable&amp;lt;T&amp;gt;&lt;/code&gt; and refer to the UniRx components by their short name, without adding the namespace. This solves the conflicts.&lt;/p&gt; &#xA;&lt;h2&gt;DLL Separation&lt;/h2&gt; &#xA;&lt;p&gt;If you want to pre-build UniRx, you can build own dll. clone project and open &lt;code&gt;UniRx.sln&lt;/code&gt;, you can see &lt;code&gt;UniRx&lt;/code&gt;, it is fullset separated project of UniRx. You should define compile symbol like &lt;code&gt;UNITY;UNITY_5_4_OR_NEWER;UNITY_5_4_0;UNITY_5_4;UNITY_5;&lt;/code&gt; + &lt;code&gt;UNITY_EDITOR&lt;/code&gt;, &lt;code&gt;UNITY_IPHONE&lt;/code&gt; or other platform symbol. We can not provides pre-build binary to release page, asset store because compile symbol is different each other.&lt;/p&gt; &#xA;&lt;h2&gt;UPM Package&lt;/h2&gt; &#xA;&lt;p&gt;After Unity 2019.3.4f1, Unity 2020.1a21, that support path query parameter of git package. You can add &lt;code&gt;https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts&lt;/code&gt; to Package Manager&lt;/p&gt; &#xA;&lt;p&gt;or add &lt;code&gt;&#34;com.neuecc.unirx&#34;: &#34;https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts&#34;&lt;/code&gt; to &lt;code&gt;Packages/manifest.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/neuecc/UniRx/wiki&#34;&gt;UniRx/wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;UniRx API documents.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/&#34;&gt;ReactiveX&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The home of ReactiveX. &lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;Introduction&lt;/a&gt;, &lt;a href=&#34;http://reactivex.io/documentation/operators.html&#34;&gt;All operators&lt;/a&gt; are illustrated with graphical marble diagrams, there makes easy to understand. And UniRx is official &lt;a href=&#34;http://reactivex.io/languages.html&#34;&gt;ReactiveX Languages&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://introtorx.com/&#34;&gt;Introduction to Rx&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A great online tutorial and eBook.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/data/gg577611&#34;&gt;Beginner&#39;s Guide to the Reactive Extensions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Many videos, slides and documents for Rx.NET.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/torisoup/unity-unirx&#34;&gt;The future of programming technology in Unity - UniRx -(JPN)&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/agebreak/160402-unirx&#34;&gt;Korean translation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Intro slide by &lt;a href=&#34;https://github.com/torisoup&#34;&gt;@torisoup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://slides.com/sammegidov/unirx#/&#34;&gt;Reactive Programming, ‚ÄãUnity 3D and you&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Xerios/UniRxSimpleGame&#34;&gt;Repository of UniRxSimpleGame&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Intro slide and sample game by &lt;a href=&#34;https://github.com/Xerios&#34;&gt;@Xerios&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=j3YhG91mPsU&amp;amp;feature=youtu.be&amp;amp;t=9m12s&#34;&gt;GDC 2016 Sessions of Adventure Capialist&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;How to integrate with PlayFab API&lt;/p&gt; &#xA;&lt;h2&gt;Help &amp;amp; Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Support thread on the Unity forum. Ask me any question - &lt;a href=&#34;http://forum.unity3d.com/threads/248535-UniRx-Reactive-Extensions-for-Unity&#34;&gt;http://forum.unity3d.com/threads/248535-UniRx-Reactive-Extensions-for-Unity&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Become a backer, Sponsored, one time donation are welcome, we&#39;re using &lt;a href=&#34;https://opencollective.com/unirx/#&#34;&gt;Open Collective - UniRx&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We welcome any contributions, be they bug reports, requests or pull request.&lt;br&gt; Please consult and submit your reports or requests on GitHub issues.&lt;br&gt; Source code is available in &lt;code&gt;Assets/Plugins/UniRx/Scripts&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Author&#39;s other Unity + LINQ Assets&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/neuecc/LINQ-to-GameObject-for-Unity/&#34;&gt;LINQ to GameObject&lt;/a&gt; is a group of GameObject extensions for Unity that allows traversing the hierarchy and appending GameObject to it like LINQ to XML. It&#39;s free and opensource on GitHub.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neuecc/LINQ-to-GameObject-for-Unity/master/Images/axis.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Author Info&lt;/h2&gt; &#xA;&lt;p&gt;Yoshifumi Kawai(a.k.a. neuecc) is a software developer in Japan.&lt;br&gt; Currently founded consulting company &lt;a href=&#34;http://new-world.co/&#34;&gt;New World, Inc.&lt;/a&gt;&lt;br&gt; He is awarding Microsoft MVP for Visual C# since 2011.&lt;/p&gt; &#xA;&lt;p&gt;Blog: &lt;a href=&#34;https://medium.com/@neuecc&#34;&gt;https://medium.com/@neuecc&lt;/a&gt; (English)&lt;br&gt; Blog: &lt;a href=&#34;http://neue.cc/&#34;&gt;http://neue.cc/&lt;/a&gt; (Japanese)&lt;br&gt; Twitter: &lt;a href=&#34;https://twitter.com/neuecc&#34;&gt;https://twitter.com/neuecc&lt;/a&gt; (Japanese)&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is under the MIT License.&lt;/p&gt; &#xA;&lt;p&gt;Some code is borrowed from &lt;a href=&#34;https://github.com/dotnet/reactive/&#34;&gt;Rx.NET&lt;/a&gt; and &lt;a href=&#34;https://github.com/mono/mono&#34;&gt;mono/mcs&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>MassTransit/MassTransit</title>
    <updated>2022-07-07T01:35:46Z</updated>
    <id>tag:github.com,2022-07-07:/MassTransit/MassTransit</id>
    <link href="https://github.com/MassTransit/MassTransit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Distributed Application Framework for .NET&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MassTransit&lt;/h1&gt; &#xA;&lt;p&gt;MassTransit is a &lt;em&gt;free, open-source&lt;/em&gt; distributed application framework for .NET. MassTransit makes it easy to create applications and services that leverage message-based, loosely-coupled asynchronous communication for higher availability, reliability, and scalability.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/317796?s=200&amp;amp;v=4&#34; alt=&#34;Mass Transit&#34; title=&#34;Mass Transit&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;MassTransit is Apache 2.0 licensed.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Get started by &lt;a href=&#34;https://masstransit-project.com/&#34;&gt;reading through the documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Build Status&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Branch&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;master&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/MassTransit/MassTransit/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/MassTransit/MassTransit/actions/workflows/build.yml/badge.svg?branch=master&amp;amp;event=push&#34; alt=&#34;master&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;develop&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/MassTransit/MassTransit/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/MassTransit/MassTransit/actions/workflows/build.yml/badge.svg?branch=develop&amp;amp;event=push&#34; alt=&#34;develop&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;documentation&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/MassTransit/MassTransit/actions/workflows/docs.yml&#34;&gt;&lt;img src=&#34;https://github.com/MassTransit/MassTransit/actions/workflows/docs.yml/badge.svg?branch=develop&amp;amp;event=push&#34; alt=&#34;documentation&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;MassTransit NuGet Packages&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Package Name&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;.NET Standard&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;.NET Core App&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Main&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit&#34;&gt;MassTransit&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Abstractions&#34;&gt;MassTransit.Abstractions&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Other&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Analyzers&#34;&gt;MassTransit.Analyzers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Templates&#34;&gt;MassTransit.Templates&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;5.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.SignalR&#34;&gt;MassTransit.SignalR&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.TestFramework&#34;&gt;MassTransit.TestFramework&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Monitoring&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Prometheus&#34;&gt;MassTransit.Prometheus&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Persistence&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Azure.Cosmos&#34;&gt;MassTransit.Azure.Cosmos&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Azure.Storage&#34;&gt;MassTransit.Azure.Storage&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.DapperIntegration&#34;&gt;MassTransit.Dapper&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.EntityFrameworkCore&#34;&gt;MassTransit.EntityFrameworkCore&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0 or 6.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.EntityFramework&#34;&gt;MassTransit.EntityFramework&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Marten&#34;&gt;MassTransit.Marten&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.MongoDb&#34;&gt;MassTransit.MongoDb&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.NHibernate&#34;&gt;MassTransit.NHibernate&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Redis&#34;&gt;MassTransit.Redis&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Scheduling&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Hangfire&#34;&gt;MassTransit.Hangfire&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Quartz&#34;&gt;MassTransit.Quartz&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Transports&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.ActiveMQ&#34;&gt;MassTransit.ActiveMQ&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.AmazonSQS&#34;&gt;MassTransit.AmazonSQS&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Azure.ServiceBus.Core&#34;&gt;MassTransit.Azure.ServiceBus.Core&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Grpc&#34;&gt;MassTransit.Grpc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.RabbitMQ&#34;&gt;MassTransit.RabbitMQ&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.WebJobs.EventHubs&#34;&gt;MassTransit.WebJobs.EventHubs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.WebJobs.ServiceBus&#34;&gt;MassTransit.WebJobs.ServiceBus&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Riders&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.Kafka&#34;&gt;MassTransit.Kafka&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/MassTransit.EventHub&#34;&gt;MassTransit.EventHub&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Discord&lt;/h2&gt; &#xA;&lt;p&gt;Get help live at the MassTransit Discord server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/rNpQgYn&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/682238261753675864.svg?sanitize=true&#34; alt=&#34;alt Join the conversation&#34; title=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;GitHub Issues&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pay attention&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please do not open an issue on GitHub, unless you have spotted an actual bug in MassTransit.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://github.com/MassTransit/MassTransit/discussions&#34;&gt;GitHub Discussions&lt;/a&gt; to ask questions, bring up ideas, or other general items. Issues are not the place for questions, and will either be converted to a discussion or closed.&lt;/p&gt; &#xA;&lt;p&gt;This policy is in place to avoid bugs being drowned out in a pile of sensible suggestions for future enhancements and calls for help from people who forget to check back if they get it and so on.&lt;/p&gt; &#xA;&lt;h2&gt;Building from Source&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install the latest &lt;a href=&#34;https://dotnet.microsoft.com/en-us/download/dotnet/6.0&#34;&gt;.NET 6 SDK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Clone the source down to your machine&lt;br&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://github.com/MassTransit/MassTransit.git&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;dotnet build&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Turn off &lt;code&gt;autocrlf&lt;/code&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config core.autocrlf false&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Hack!&lt;/li&gt; &#xA; &lt;li&gt;Make a pull request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;REQUIREMENTS&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.NET 6 SDK&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;CREDITS&lt;/h1&gt; &#xA;&lt;p&gt;Logo Design by &lt;em&gt;The Agile Badger&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
</feed>