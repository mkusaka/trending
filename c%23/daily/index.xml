<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-17T01:32:04Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Accenture/Codecepticon</title>
    <updated>2022-09-17T01:32:04Z</updated>
    <id>tag:github.com,2022-09-17:/Accenture/Codecepticon</id>
    <link href="https://github.com/Accenture/Codecepticon" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Codecepticon&lt;/h1&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#read-this-first&#34;&gt;Read This First&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#prerequisites&#34;&gt;Prerequisites&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#visual-studio-procommunity-2022&#34;&gt;Visual Studio&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#roslyn-compiler&#34;&gt;Roslyn Compiler&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#open-and-compile&#34;&gt;Check to see if it works&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#using-codecepticon&#34;&gt;Using Codecepticon&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#c&#34;&gt;C#&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#vbavb6&#34;&gt;VBA/VB6&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#powershell&#34;&gt;PowerShell&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#obfuscating-command-line-arguments&#34;&gt;Obfuscating Command Line Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/Functionality.md&#34;&gt;Functionality Deep Dive&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/Tips.md&#34;&gt;Tips&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/KnownIssues.md&#34;&gt;Known Issues&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#contributions&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#references--credits&#34;&gt;References / Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Codecepticon is a .NET application that allows you to obfuscate C#, VBA/VB6 (macros), and PowerShell source code, and is developed for offensive security engagements such as Red/Purple Teams. What separates Codecepticon from other obfuscators is that it targets the source code rather than the compiled executables, and was developed specifically for AV/EDR evasion.&lt;/p&gt; &#xA;&lt;p&gt;Codecepticon allows you to obfuscate and rewrite code, but also provides features such as rewriting the command line as well.&lt;/p&gt; &#xA;&lt;h2&gt;Read This First&lt;/h2&gt; &#xA;&lt;p&gt;&lt;span style=&#34;color: red&#34;&gt;!&lt;/span&gt; Before we begin &lt;span style=&#34;color: red&#34;&gt;!&lt;/span&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;This documentation is on how to install and use Codecepticon only. Compilation, usage, and support for tools like Rubeus and SharpHound will not be provided. Refer to each project&#39;s repo separately for more information.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Codecepticon is actively developed/tested in VS2022, but it &lt;em&gt;should&lt;/em&gt; work in VS2019 as well. Any tickets/issues created for VS2019 and below, will not be investigated unless the issue is reproducible in VS2022. So please use the latest and greatest VS2022.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The following packages &lt;strong&gt;MUST be v3.9.0&lt;/strong&gt;, as newer versions have the following issue which is still open: &lt;a href=&#34;https://github.com/dotnet/roslyn/issues/58463&#34;&gt;https://github.com/dotnet/roslyn/issues/58463&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Microsoft.CodeAnalysis.CSharp.Workspaces&lt;/li&gt; &#xA;   &lt;li&gt;Microsoft.CodeAnalysis.Workspaces.MSBuild&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Codecepticon checks the version of these packages on runtime and will inform you if the version is different to v3.9.0.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It cannot be stressed this enough: &lt;strong&gt;always test your obfuscated code locally first&lt;/strong&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;h3&gt;Visual Studio Pro/Community 2022&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/VS2022-NET.png&#34; alt=&#34;VS2022 .NET&#34; title=&#34;Install .NET desktop development&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Roslyn Compiler&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/VS2022-NET-Roslyn.png&#34; alt=&#34;VS2022 Roslyn&#34; title=&#34;Install .NET Compiler Platform SDK&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Open and Compile&lt;/h3&gt; &#xA;&lt;p&gt;Open Codecepticon, wait until all NuGet packages are downloaded and then build the solution.&lt;/p&gt; &#xA;&lt;h2&gt;Using Codecepticon&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways to use Codecepticon, either by putting all arguments in the command line or by passing a single XML configuration file. Due to the high level of supported customisations, It&#39;s not recommended manually going through &lt;code&gt;--help&lt;/code&gt; output to try and figure out which parameters to use and how. Use &lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/CommandLineGenerator.html&#34;&gt;CommandLineGenerator.html&lt;/a&gt; and generate your command quickly:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/CmdGenerator.png&#34; alt=&#34;Command Line Generator&#34; title=&#34;Command Line Generator&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The command generator&#39;s output format can be either &lt;code&gt;Console&lt;/code&gt; or &lt;code&gt;XML&lt;/code&gt;, depending what you prefer. Console commands can be executed as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Codecepticon.exe --action obfuscate --module csharp --verbose ...etc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While when using an XML config file, as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Codecepticon.exe --config C:\Your\Path\To\The\File.xml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to deep dive into Codecepticon&#39;s functionality, &lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/Functionality.md&#34;&gt;check out this document&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For tips you can use, &lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/Tips.md&#34;&gt;check out this document&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;C#&lt;/h3&gt; &#xA;&lt;p&gt;Obfuscating a C# project is simple, simply select the solution you wish to target. Note that a backup of the solution itself will not be taken, and the current one will be the one that will be obfuscated. Make sure that you can independently compile the target project before trying to run Codecepticon against it.&lt;/p&gt; &#xA;&lt;h3&gt;VBA/VB6&lt;/h3&gt; &#xA;&lt;p&gt;The VBA obfuscation works against source code itself rather than a Microsoft Office document. This means that you cannot pass a &lt;code&gt;doc(x)&lt;/code&gt; or &lt;code&gt;xls(x)&lt;/code&gt; file to Codecepticon. It will have to be the source code of the module itself (press Alt-F11 and copy the code from there).&lt;/p&gt; &#xA;&lt;h3&gt;PowerShell&lt;/h3&gt; &#xA;&lt;p&gt;Due to the complexity of PowerShell scripts, along with the freedom it provides in how to write scripts it is challenging to cover all edge cases and ensure that the obfuscated result will be fully functional. Although it&#39;s expected for Codecepticon to work fine against simple scripts/functionality, running it against complex ones such as PowerView will not work - this is a work in progress.&lt;/p&gt; &#xA;&lt;h3&gt;Obfuscating Command Line Arguments&lt;/h3&gt; &#xA;&lt;p&gt;After obfuscating an application or a script, it is very likely that the command line arguments have also been renamed. The solution to this is to use the HTML mapping file to find what the new names are. For example, let&#39;s convert the following command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SharpHound.exe --CollectionMethods DCOnly --OutputDirectory C:\temp\&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By searching through the HTML mapping file for each argument, we get:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/Mapping-File-1.png&#34; alt=&#34;Mapping One&#34; title=&#34;Mapping One&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/Mapping-File-2.png&#34; alt=&#34;Mapping Two&#34; title=&#34;Mapping Two&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/Mapping-File-3.png&#34; alt=&#34;Mapping Three&#34; title=&#34;Mapping Three&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;And by replacing all strings the result is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ObfuscatedSharpHound.exe --AphylesPiansAsp TurthsTance --AnineWondon C:\temp\&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, some values may exist in more than one category:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/Mapping-File-4.png&#34; alt=&#34;Mapping Four&#34; title=&#34;Mapping Four&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Therefore it is &lt;strong&gt;critical&lt;/strong&gt; to always test your result in a local environment first.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Why isn&#39;t there a compiled version under Releases that I can download?&lt;/h3&gt; &#xA;&lt;p&gt;The compiled output includes a lot of dependency DLLs, which due to licensing requirements we can&#39;t re-distribute without written consent.&lt;/p&gt; &#xA;&lt;h3&gt;Does Codecepticon only work for C# projects that already have a supported profile?&lt;/h3&gt; &#xA;&lt;p&gt;No, Codecepticon should work with everything. The profiles are just a bit of extra tweaks that are done to the target project in order to make it more reliable and easier to work with.&lt;/p&gt; &#xA;&lt;p&gt;But as all code is unique, there will be instances where obfuscating a project will end up with an error or two that won&#39;t allow it to be compiled or executed. In this case a new profile may be in order - please raise a new issue if this is the case.&lt;/p&gt; &#xA;&lt;p&gt;Same principle applies to PowerShell/VBA code - although those currently have no profiles that come with Codecepticon, it&#39;s an easy task to add if some are needed.&lt;/p&gt; &#xA;&lt;h3&gt;Can I contribute?&lt;/h3&gt; &#xA;&lt;p&gt;For reporting bugs and suggesting new features, please create an issue.&lt;/p&gt; &#xA;&lt;p&gt;For submitting pull requests, please see the &lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/#contributions&#34;&gt;Contributions&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;h3&gt;I&#39;m using Codecepticon against a C# project, it runs, but afterwards I can&#39;t compile the target project.&lt;/h3&gt; &#xA;&lt;p&gt;Before running Codecepticon make sure you can compile a &lt;strong&gt;clean&lt;/strong&gt; version of the target project. Very often when this issue appears, it&#39;s due to missing dependencies for the target solution rather than Codecepticon. But if it still doesn&#39;t compile:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Is it a public project? Create an issue and paste the link with as much detail as possible. If the tool is part of SharpCollection, even better.&lt;/li&gt; &#xA; &lt;li&gt;Is it a private project? In the spirit of improving Codecepticon we&#39;ll try to provide as much support as possible via screenshots and error/debug messages. But we will not be accessing/running any clean/obfuscated code via private repos etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Same as above, but it&#39;s a PowerShell/VBA script - can you help?&lt;/h3&gt; &#xA;&lt;p&gt;I will do my best, but as PowerShell scripts can be VERY complex and the PSParser isn&#39;t as advanced as Roslyn for C#, no promises can be made. Same applies for VBA/VB6.&lt;/p&gt; &#xA;&lt;h3&gt;I keep getting: &#34;Method not found: &#39;System.Collections.Immutable.ImmutableArray&#34;&lt;/h3&gt; &#xA;&lt;p&gt;You may at some point encounter the following error:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Codecepticon/main/docs/images/MissingMethodException.png&#34; alt=&#34;Method not found&#34; title=&#34;System.Collections.Immutable.ImmutableArray&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Still trying to get to the bottom of this one, a quick fix is to uninstall and reinstall the &lt;code&gt;System.Collections.Immutable&lt;/code&gt; package, from the NuGet Package Manager.&lt;/p&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Whether it&#39;s a typo, a bug, or a new feature, Codecepticon is very open to contributions as long as we agree on the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You are OK with the MIT license of this project.&lt;/li&gt; &#xA; &lt;li&gt;Before creating a pull request, create an issue so it could be discussed before doing any work as internal development is not tracked via the public GitHub repository. Otherwise you risk having a pull request rejected if for example we are already working on the same/similar feature, or for any other reason.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;References / Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.xpnsec.com/building-modifying-packing-devops/&#34;&gt;https://blog.xpnsec.com/building-modifying-packing-devops/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/EmericNasi/status/1460640760928296966&#34;&gt;https://twitter.com/EmericNasi/status/1460640760928296966&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MagicMau/ProceduralNameGenerator&#34;&gt;https://github.com/MagicMau/ProceduralNameGenerator&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/uwol/proleap-vb6-parser&#34;&gt;https://github.com/uwol/proleap-vb6-parser&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dwyl/english-words&#34;&gt;https://github.com/dwyl/english-words&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Cysharp/MagicOnion</title>
    <updated>2022-09-17T01:32:04Z</updated>
    <id>tag:github.com,2022-09-17:/Cysharp/MagicOnion</id>
    <link href="https://github.com/Cysharp/MagicOnion" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unified Realtime/API framework for .NET platform and Unity.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MagicOnion&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Cysharp/MagicOnion/workflows/build-debug/badge.svg?sanitize=true&#34; alt=&#34;build-debug&#34;&gt; &lt;img src=&#34;https://github.com/Cysharp/MagicOnion/workflows/build-canary/badge.svg?sanitize=true&#34; alt=&#34;build-canary&#34;&gt; &lt;img src=&#34;https://github.com/Cysharp/MagicOnion/workflows/build-release/badge.svg?sanitize=true&#34; alt=&#34;build-release&#34;&gt; &lt;a href=&#34;https://github.com/Cysharp/MagicOnion/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/Cysharp/MagicOnion.svg?sanitize=true&#34; alt=&#34;Releases&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unified Realtime/API framework for .NET platform and Unity.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#-table-of-contents&#34;&gt;ðŸ“– Table of contents&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About MagicOnion&lt;/h2&gt; &#xA;&lt;p&gt;MagicOnion is a modern RPC framework for .NET platform that provides bi-directional real-time communications such as &lt;a href=&#34;https://github.com/aspnet/AspNetCore/tree/master/src/SignalR&#34;&gt;SignalR&lt;/a&gt; and &lt;a href=&#34;https://socket.io/&#34;&gt;Socket.io&lt;/a&gt; and RPC mechanisms such as WCF and web-based APIs.&lt;/p&gt; &#xA;&lt;p&gt;This framework is based on &lt;a href=&#34;https://grpc.io/&#34;&gt;gRPC&lt;/a&gt;, which is a fast and compact binary network transport for HTTP/2. However, unlike plain gRPC, it treats C# interfaces as a protocol schema, enabling seamless code sharing between C# projects without &lt;code&gt;.proto&lt;/code&gt; (Protocol Buffers IDL).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/50965239-c4fdb000-1514-11e9-8365-304c776ffd77.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Interfaces are schemas and provide API services, just like the plain C# code&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/50965825-7bae6000-1516-11e9-9501-dc91582f4d1b.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Using the StreamingHub real-time communication service, the server can broadcast data to multiple clients&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;MagicOnion can be adopted or replaced in the following use cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RPC services such as gRPC, used by Microservices, and WCF, commonly used by WinForms/WPF&lt;/li&gt; &#xA; &lt;li&gt;API services such as ASP.NET Core MVC targeting Unity, Xamarin, and Windows clients&lt;/li&gt; &#xA; &lt;li&gt;Bi-directional real-time communication such as Socket.io, SignalR, Photon and UNet&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;MagicOnion uses &lt;a href=&#34;https://github.com/neuecc/MessagePack-CSharp&#34;&gt;MessagePack for C#&lt;/a&gt; to serialize call arguments and return values. NET primitives and other complex types that can be serialized into MessagePack objects. See MessagePack for C# for details about serialization.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;MagicOnion server requires NET Core 3.1 or .NET 5.0+.&lt;/p&gt; &#xA;&lt;p&gt;MagicOnion client supports a wide range of platforms, including .NET Framework 4.6.1 to .NET 5.0 as well as Unity.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Server-side (MagicOnion.Server) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;.NET 5.0+&lt;/li&gt; &#xA;   &lt;li&gt;.NET Core 3.1&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Client-side (MagicOnion.Client) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;.NET Standard 2.1 (.NET Core 3.x+, .NET 5.0+, Xamarin)&lt;/li&gt; &#xA;   &lt;li&gt;.NET Standard 2.0 (.NET Framework 4.6.1+, Universal Windows Platform, .NET Core 2.x)&lt;/li&gt; &#xA;   &lt;li&gt;Unity 2018.4.13f1+&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;h3&gt;Server-side project&lt;/h3&gt; &#xA;&lt;h4&gt;Setup a project for MagicOnion&lt;/h4&gt; &#xA;&lt;p&gt;First, you need to create a &lt;strong&gt;gRPC Service&lt;/strong&gt; project from within Visual Studio or the .NET CLI tools. MagicOnion Server is built on top of ASP.NET Core and gRPC, so the server project must be an ASP.NET Core project.&lt;/p&gt; &#xA;&lt;p&gt;When you create a project, it contains &lt;code&gt;Protos&lt;/code&gt; and &lt;code&gt;Services&lt;/code&gt; folders, which are not needed in MagicOnion projects and should be removed.&lt;/p&gt; &#xA;&lt;p&gt;Add NuGet package &lt;code&gt;MagicOnion.Server&lt;/code&gt; to your project. If you are using the .NET CLI tools to add it, you can run the following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package MagicOnion.Server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Open Startup.cs and add the following line to &lt;code&gt;ConfigureServices&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;services.AddMagicOnion();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;app.UseEndpoints&lt;/code&gt; call in &lt;code&gt;Configure&lt;/code&gt; method is rewritten as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;app.UseEndpoints(endpoints =&amp;gt;&#xA;{&#xA;    endpoints.MapMagicOnionService();&#xA;&#xA;    endpoints.MapGet(&#34;/&#34;, async context =&amp;gt;&#xA;    {&#xA;        await context.Response.WriteAsync(&#34;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909&#34;);&#xA;    });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The complete Startup.cs will look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Microsoft.AspNetCore.Builder;&#xA;using Microsoft.AspNetCore.Hosting;&#xA;using Microsoft.AspNetCore.Http;&#xA;using Microsoft.Extensions.DependencyInjection;&#xA;namespace MyApp&#xA;{&#xA;    public class Startup&#xA;    {&#xA;        public void ConfigureServices(IServiceCollection services)&#xA;        {&#xA;            services.AddGrpc();&#xA;            services.AddMagicOnion(); // Add this line&#xA;        }&#xA;        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#xA;        {&#xA;            app.UseRouting();&#xA;            app.UseEndpoints(endpoints =&amp;gt;&#xA;            {&#xA;                // Replace to this line instead of MapGrpcService&amp;lt;GreeterService&amp;gt;()&#xA;                endpoints.MapMagicOnionService();&#xA;                endpoints.MapGet(&#34;/&#34;, async context =&amp;gt;&#xA;                {&#xA;                    await context.Response.WriteAsync(&#34;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909&#34;);&#xA;                });&#xA;            });&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you are ready to use MagicOnion on your server project.&lt;/p&gt; &#xA;&lt;h4&gt;Implements a service on MagicOnion&lt;/h4&gt; &#xA;&lt;p&gt;MagicOnion provides a Web API-like RPC service and a StreamingHub for real-time communication. This section implements a Web API-like RPC service.&lt;/p&gt; &#xA;&lt;p&gt;Add an &lt;code&gt;IMyFirstService&lt;/code&gt; interface to be shared between the server and the client (namespace should match the project).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System;&#xA;using MagicOnion;&#xA;&#xA;namespace MyApp.Shared&#xA;{&#xA;    // Defines .NET interface as a Server/Client IDL.&#xA;    // The interface is shared between server and client.&#xA;    public interface IMyFirstService : IService&amp;lt;IMyFirstService&amp;gt;&#xA;    {&#xA;        // The return type must be `UnaryResult&amp;lt;T&amp;gt;`.&#xA;        UnaryResult&amp;lt;int&amp;gt; SumAsync(int x, int y);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add a class that implements the interface &lt;code&gt;IMyFirstService&lt;/code&gt;. The client calls this class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System;&#xA;using MagicOnion;&#xA;using MagicOnion.Server;&#xA;using MyApp.Shared;&#xA;&#xA;namespace MyApp.Services&#xA;{&#xA;    // Implements RPC service in the server project.&#xA;    // The implementation class must inherit `ServiceBase&amp;lt;IMyFirstService&amp;gt;` and `IMyFirstService`&#xA;    public class MyFirstService : ServiceBase&amp;lt;IMyFirstService&amp;gt;, IMyFirstService&#xA;    {&#xA;        // `UnaryResult&amp;lt;T&amp;gt;` allows the method to be treated as `async` method.&#xA;        public async UnaryResult&amp;lt;int&amp;gt; SumAsync(int x, int y)&#xA;        {&#xA;            Console.WriteLine($&#34;Received:{x}, {y}&#34;);&#xA;            return x + y;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The service is now defined and implemented. That&#39;s it.&lt;/p&gt; &#xA;&lt;p&gt;Now you can start MagicOnion server as you would a ASP.NET Core project using the F5 key or the &lt;code&gt;dotnet run&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;h3&gt;Client-side: Call the service on MagicOnion&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; If you want to use MagicOnion client with Unity clients, see also &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#support-for-unity-client&#34;&gt;Support for Unity client&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Create a &lt;strong&gt;Console application&lt;/strong&gt; project and add NuGet package &lt;code&gt;MagicOnion.Client&lt;/code&gt; to the project.&lt;/p&gt; &#xA;&lt;p&gt;Share &lt;code&gt;IMyFirstService&lt;/code&gt; interface with the client. Share the interface definition in some way, such as file links, shared libraries, or copy and paste.&lt;/p&gt; &#xA;&lt;p&gt;In the client code, Create &lt;code&gt;MagicOnionClient&lt;/code&gt; client proxy on the shared interface and calls the service transparently.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Grpc.Net.Client;&#xA;using MagicOnion.Client;&#xA;using MyApp.Shared;&#xA;&#xA;// Connect to the server using gRPC channel.&#xA;var channel = GrpcChannel.ForAddress(&#34;https://localhost:5001&#34;);&#xA;&#xA;// NOTE: If your project targets non-.NET Standard 2.1, use `Grpc.Core.Channel` class instead.&#xA;// var channel = new Channel(&#34;localhost&#34;, 5001, new SslCredentials());&#xA;&#xA;// Create a proxy to call the server transparently.&#xA;var client = MagicOnionClient.Create&amp;lt;IMyFirstService&amp;gt;(channel);&#xA;&#xA;// Call the server-side method using the proxy.&#xA;var result = await client.SumAsync(123, 456);&#xA;Console.WriteLine($&#34;Result: {result}&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;MagicOnion is available in four NuGet packages. Please install any of the packages as needed.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; If you want to use MagicOnion client with Unity clients, see also &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#support-for-unity-client&#34;&gt;Support for Unity client&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The package &lt;code&gt;MagicOnion.Server&lt;/code&gt; to implement the server. You need to install this package to implement services on your server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package MagicOnion.Server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The package &lt;code&gt;MagicOnion.Client&lt;/code&gt; to implement the client. To implement the client such as as WPF and Xamarin, you need to install this package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package MagicOnion.Client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The package &lt;code&gt;MagicOnion.Abstractions&lt;/code&gt; provides interfaces and attributes commonly used by servers and clients. To create a class library project which is shared between the servers and the clients, you need to install this package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package MagicOnion.Abstractions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The package &lt;code&gt;MagicOnion&lt;/code&gt; is meta package to implements the role of both server and client. To implement server-to-server communication such as Microservices, that can be both a server and a client, we recommend to install this package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package MagicOnion&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ðŸ“– Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#about-magiconion&#34;&gt;About MagicOnion&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#quick-start&#34;&gt;Quick Start&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fundamentals &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#service&#34;&gt;Service&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#streaminghub&#34;&gt;StreamingHub&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#filter&#34;&gt;Filter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#clientfilter&#34;&gt;ClientFilter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#servicecontext-and-lifecycle&#34;&gt;ServiceContext and Lifecycle&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#exceptionhandling-and-statuscode&#34;&gt;ExceptionHandling and StatusCode&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#group-and-groupconfiguration&#34;&gt;Group and GroupConfiguration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#project-structure&#34;&gt;Project Structure&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#dependency-injection&#34;&gt;Dependency Injection&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Client &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#support-for-unity-client&#34;&gt;Support for Unity client&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#ios-build-with-grpc&#34;&gt;iOS build with gRPC&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#stripping-debug-symbols-from-ioslibgrpca&#34;&gt;Stripping debug symbols from ios/libgrpc.a&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#stripping-debug-symbols-from-libgrpccsharpextso&#34;&gt;Stripping debug symbols from libgrpc_csharp_ext.so&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#workaround-for-il2cpp--windows-build-failure&#34;&gt;Workaround for il2cpp + Windows Build failure&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#grpc-keepalive&#34;&gt;gRPC Keepalive&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#https-tls&#34;&gt;HTTPS (TLS)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#deployment&#34;&gt;Deployment&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Integrations &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#swagger&#34;&gt;Swagger&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Advanced &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#magiconionoptionlogging&#34;&gt;MagicOnionOption/Logging&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#raw-grpc-apis&#34;&gt;Raw gRPC APIs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#zero-deserialization-mapping&#34;&gt;Zero deserialization mapping&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Experimentals &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#opentelemetry&#34;&gt;OpenTelemetry&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Fundamentals&lt;/h2&gt; &#xA;&lt;h3&gt;Service&lt;/h3&gt; &#xA;&lt;p&gt;A service is a mechanism that provides a request/response API in the style of RPC or Web-API, and is implemented as a Unary call to gRPC. A service can be defined as a C# interface to benefit from the type. This means that it can be observed as a request over HTTP/2.&lt;/p&gt; &#xA;&lt;h4&gt;Service definition (Shared library)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System;&#xA;using MagicOnion;&#xA;&#xA;namespace MyApp.Shared&#xA;{&#xA;    // Defines .NET interface as a Server/Client IDL.&#xA;    // The interface is shared between server and client.&#xA;    public interface IMyFirstService : IService&amp;lt;IMyFirstService&amp;gt;&#xA;    {&#xA;        // The return type must be `UnaryResult&amp;lt;T&amp;gt;`.&#xA;        UnaryResult&amp;lt;int&amp;gt; SumAsync(int x, int y);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Service implementation (Server-side)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System;&#xA;using MagicOnion;&#xA;using MagicOnion.Server;&#xA;using MyApp.Shared;&#xA;&#xA;namespace MyApp.Services&#xA;{&#xA;    // Implements RPC service in the server project.&#xA;    // The implementation class must inherit `ServiceBase&amp;lt;IMyFirstService&amp;gt;` and `IMyFirstService`&#xA;    public class MyFirstService : ServiceBase&amp;lt;IMyFirstService&amp;gt;, IMyFirstService&#xA;    {&#xA;        // `UnaryResult&amp;lt;T&amp;gt;` allows the method to be treated as `async` method.&#xA;        public async UnaryResult&amp;lt;int&amp;gt; SumAsync(int x, int y)&#xA;        {&#xA;            Console.WriteLine($&#34;Received:{x}, {y}&#34;);&#xA;            return x + y;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In MagicOnion, unlike gRPC in general, the body of the request is serialized by MessagePack for sending and receiving.&lt;/p&gt; &#xA;&lt;h3&gt;StreamingHub&lt;/h3&gt; &#xA;&lt;p&gt;StreamingHub is a fully-typed realtime server &amp;lt;--&amp;gt; client communication framework.&lt;/p&gt; &#xA;&lt;p&gt;This sample is for Unity(use Vector3, GameObject, etc) but StreamingHub supports .NET Core, too.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Server -&amp;gt; Client definition&#xA;public interface IGamingHubReceiver&#xA;{&#xA;    // The method must have a return type of `void` and can have up to 15 parameters of any type.&#xA;    void OnJoin(Player player);&#xA;    void OnLeave(Player player);&#xA;    void OnMove(Player player);&#xA;}&#xA; &#xA;// Client -&amp;gt; Server definition&#xA;// implements `IStreamingHub&amp;lt;TSelf, TReceiver&amp;gt;`  and share this type between server and client.&#xA;public interface IGamingHub : IStreamingHub&amp;lt;IGamingHub, IGamingHubReceiver&amp;gt;&#xA;{&#xA;    // The method must return `Task` or `Task&amp;lt;T&amp;gt;` and can have up to 15 parameters of any type.&#xA;    Task&amp;lt;Player[]&amp;gt; JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation);&#xA;    Task LeaveAsync();&#xA;    Task MoveAsync(Vector3 position, Quaternion rotation);&#xA;}&#xA; &#xA;// for example, request object by MessagePack.&#xA;[MessagePackObject]&#xA;public class Player&#xA;{&#xA;    [Key(0)]&#xA;    public string Name { get; set; }&#xA;    [Key(1)]&#xA;    public Vector3 Position { get; set; }&#xA;    [Key(2)]&#xA;    public Quaternion Rotation { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Server implementation&#xA;// implements : StreamingHubBase&amp;lt;THub, TReceiver&amp;gt;, THub&#xA;public class GamingHub : StreamingHubBase&amp;lt;IGamingHub, IGamingHubReceiver&amp;gt;, IGamingHub&#xA;{&#xA;    // this class is instantiated per connected so fields are cache area of connection.&#xA;    IGroup room;&#xA;    Player self;&#xA;    IInMemoryStorage&amp;lt;Player&amp;gt; storage;&#xA;&#xA;    public async Task&amp;lt;Player[]&amp;gt; JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation)&#xA;    {&#xA;        self = new Player() { Name = userName, Position = position, Rotation = rotation };&#xA;&#xA;        // Group can bundle many connections and it has inmemory-storage so add any type per group. &#xA;        (room, storage) = await Group.AddAsync(roomName, self);&#xA;&#xA;        // Typed Server-&amp;gt;Client broadcast.&#xA;        Broadcast(room).OnJoin(self);&#xA;&#xA;        return storage.AllValues.ToArray();&#xA;    }&#xA;&#xA;    public async Task LeaveAsync()&#xA;    {&#xA;        await room.RemoveAsync(this.Context);&#xA;        Broadcast(room).OnLeave(self);&#xA;    }&#xA;&#xA;    public async Task MoveAsync(Vector3 position, Quaternion rotation)&#xA;    {&#xA;        self.Position = position;&#xA;        self.Rotation = rotation;&#xA;        Broadcast(room).OnMove(self);&#xA;    }&#xA;&#xA;    // You can hook OnConnecting/OnDisconnected by override.&#xA;    protected override async ValueTask OnDisconnected()&#xA;    {&#xA;        // on disconnecting, if automatically removed this connection from group.&#xA;        return CompletedTask;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can write client like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class GamingHubClient : IGamingHubReceiver&#xA;{&#xA;    Dictionary&amp;lt;string, GameObject&amp;gt; players = new Dictionary&amp;lt;string, GameObject&amp;gt;();&#xA; &#xA;    IGamingHub client;&#xA; &#xA;    public async Task&amp;lt;GameObject&amp;gt; ConnectAsync(ChannelBase grpcChannel, string roomName, string playerName)&#xA;    {&#xA;        this.client = await StreamingHubClient.ConnectAsync&amp;lt;IGamingHub, IGamingHubReceiver&amp;gt;(grpcChannel, this);&#xA; &#xA;        var roomPlayers = await client.JoinAsync(roomName, playerName, Vector3.zero, Quaternion.identity);&#xA;        foreach (var player in roomPlayers)&#xA;        {&#xA;            (this as IGamingHubReceiver).OnJoin(player);&#xA;        }&#xA; &#xA;        return players[playerName];&#xA;    }&#xA; &#xA;    // methods send to server.&#xA; &#xA;    public Task LeaveAsync()&#xA;    {&#xA;        return client.LeaveAsync();&#xA;    }&#xA; &#xA;    public Task MoveAsync(Vector3 position, Quaternion rotation)&#xA;    {&#xA;        return client.MoveAsync(position, rotation);&#xA;    }&#xA; &#xA;    // dispose client-connection before channel.ShutDownAsync is important!&#xA;    public Task DisposeAsync()&#xA;    {&#xA;        return client.DisposeAsync();&#xA;    }&#xA; &#xA;    // You can watch connection state, use this for retry etc.&#xA;    public Task WaitForDisconnect()&#xA;    {&#xA;        return client.WaitForDisconnect();&#xA;    }&#xA; &#xA;    // Receivers of message from server.&#xA; &#xA;    void IGamingHubReceiver.OnJoin(Player player)&#xA;    {&#xA;        Debug.Log(&#34;Join Player:&#34; + player.Name);&#xA; &#xA;        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);&#xA;        cube.name = player.Name;&#xA;        cube.transform.SetPositionAndRotation(player.Position, player.Rotation);&#xA;        players[player.Name] = cube;&#xA;    }&#xA; &#xA;    void IGamingHubReceiver.OnLeave(Player player)&#xA;    {&#xA;        Debug.Log(&#34;Leave Player:&#34; + player.Name);&#xA; &#xA;        if (players.TryGetValue(player.Name, out var cube))&#xA;        {&#xA;            GameObject.Destroy(cube);&#xA;        }&#xA;    }&#xA; &#xA;    void IGamingHubReceiver.OnMove(Player player)&#xA;    {&#xA;        Debug.Log(&#34;Move Player:&#34; + player.Name);&#xA; &#xA;        if (players.TryGetValue(player.Name, out var cube))&#xA;        {&#xA;            cube.transform.SetPositionAndRotation(player.Position, player.Rotation);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Filter&lt;/h3&gt; &#xA;&lt;p&gt;MagicOnion filter is powerful feature to hook before-after invoke. It is useful than gRPC server interceptor.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/50969421-cb465900-1521-11e9-8824-8a34cc52bbe4.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// You can attach per class/method like [SampleFilter]&#xA;// for StreamingHub methods, implement StreamingHubFilterAttribute instead.&#xA;public class SampleFilterAttribute : MagicOnionFilterAttribute&#xA;{&#xA;    public override async ValueTask Invoke(ServiceContext context, Func&amp;lt;ServiceContext, ValueTask&amp;gt; next)&#xA;    {&#xA;        try&#xA;        {&#xA;            /* on before */&#xA;            await next(context); // next&#xA;            /* on after */&#xA;        }&#xA;        catch&#xA;        {&#xA;            /* on exception */&#xA;            throw;&#xA;        }&#xA;        finally&#xA;        {&#xA;            /* on finally */&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is example of what kind of filter can be stacked.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/50969539-2bd59600-1522-11e9-84ab-15dd85e3dcac.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;GlobalFilter can attach to MagicOnionOptions.&lt;/p&gt; &#xA;&lt;p&gt;MagicOnion filters supports &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#dependency-injection&#34;&gt;DI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyStreamingHubFilterAttribute : StreamingHubFilterAttribute&#xA;{&#xA;    private readonly ILogger _logger;&#xA;&#xA;    // the `logger` parameter will be injected at instantiating.&#xA;    public MyStreamingHubFilterAttribute(ILogger&amp;lt;MyStreamingHubFilterAttribute&amp;gt; logger)&#xA;    {&#xA;        _logger = logger;&#xA;    }&#xA;&#xA;    public override async ValueTask Invoke(StreamingHubContext context, Func&amp;lt;StreamingHubContext, ValueTask&amp;gt; next)&#xA;    {&#xA;        _logger.LogInformation($&#34;MyStreamingHubFilter Begin: {context.Path}&#34;);&#xA;        await next(context);&#xA;        _logger.LogInformation($&#34;MyStreamingHubFilter End: {context.Path}&#34;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Register filters using attributes with constructor injection(you can use &lt;code&gt;[FromTypeFilter]&lt;/code&gt; and &lt;code&gt;[FromServiceFilter]&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[FromTypeFilter(typeof(MyFilterAttribute))]&#xA;public class MyService : ServiceBase&amp;lt;IMyService&amp;gt;, IMyService&#xA;{&#xA;    // The filter will instantiate from type.&#xA;    [FromTypeFilter(typeof(MySecondFilterAttribute))]&#xA;    public UnaryResult&amp;lt;int&amp;gt; Foo()&#xA;    {&#xA;        return UnaryResult(0);&#xA;    }&#xA;&#xA;    // The filter will instantiate from type with some arguments. if the arguments are missing, it will be obtained from `IServiceLocator` &#xA;    [FromTypeFilter(typeof(MyThirdFilterAttribute), Arguments = new object[] { &#34;foo&#34;, 987654 })]&#xA;    public UnaryResult&amp;lt;int&amp;gt; Bar()&#xA;    {&#xA;        return UnaryResult(0);&#xA;    }&#xA;&#xA;    // The filter instance will be provided via `IServiceLocator`.&#xA;    [FromServiceFilter(typeof(MyFourthFilterAttribute))]&#xA;    public UnaryResult&amp;lt;int&amp;gt; Baz()&#xA;    {&#xA;        return UnaryResult(0);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ClientFilter&lt;/h3&gt; &#xA;&lt;p&gt;MagicOnion client-filter is a powerful feature to hook before-after invoke. It is useful than gRPC client interceptor.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Currently only supports on Unary.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// you can attach in MagicOnionClient.Create.&#xA;var client = MagicOnionClient.Create&amp;lt;ICalcService&amp;gt;(channel, new IClientFilter[]&#xA;{&#xA;    new LoggingFilter(),&#xA;    new AppendHeaderFilter(),&#xA;    new RetryFilter()&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can create custom client-filter by implements &lt;code&gt;IClientFilter.SendAsync&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class IDemoFilter : IClientFilter&#xA;{&#xA;    public async ValueTask&amp;lt;ResponseContext&amp;gt; SendAsync(RequestContext context, Func&amp;lt;RequestContext, ValueTask&amp;lt;ResponseContext&amp;gt;&amp;gt; next)&#xA;    {&#xA;        try&#xA;        {&#xA;            /* Before Request, context.MethodPath/CallOptions/Items, etc */&#xA;&#xA;            var response = await next(context); /* Call next filter or method body */&#xA;&#xA;            /* After Request, response.GetStatus/GetTrailers/GetResponseAs&amp;lt;T&amp;gt;, etc */&#xA;&#xA;            return response;&#xA;        }&#xA;        catch (RpcException ex)&#xA;        {&#xA;            /* Get gRPC Error Response */&#xA;            throw;&#xA;        }&#xA;        catch (OperationCanceledException ex)&#xA;        {&#xA;            /* If canceled */&#xA;            throw;&#xA;        }&#xA;        catch (Exception ex)&#xA;        {&#xA;            /* Other Exception */&#xA;            throw;&#xA;        }&#xA;        finally&#xA;        {&#xA;            /* Common Finalize */&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is the sample filters, you can imagine what you can do.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class AppendHeaderFilter : IClientFilter&#xA;{&#xA;    public async ValueTask&amp;lt;ResponseContext&amp;gt; SendAsync(RequestContext context, Func&amp;lt;RequestContext, ValueTask&amp;lt;ResponseContext&amp;gt;&amp;gt; next)&#xA;    {&#xA;        // add the common header(like authentication).&#xA;        var header = context.CallOptions.Headers;&#xA;        if (!header.Any(x =&amp;gt; x.Key == &#34;x-foo&#34;))&#xA;        {&#xA;            header.Add(&#34;x-foo&#34;, &#34;abcdefg&#34;);&#xA;            header.Add(&#34;x-bar&#34;, &#34;hijklmn&#34;);&#xA;        }&#xA;&#xA;        return await next(context);&#xA;    }&#xA;}&#xA;&#xA;public class LoggingFilter : IClientFilter&#xA;{&#xA;    public async ValueTask&amp;lt;ResponseContext&amp;gt; SendAsync(RequestContext context, Func&amp;lt;RequestContext, ValueTask&amp;lt;ResponseContext&amp;gt;&amp;gt; next)&#xA;    {&#xA;        Console.WriteLine(&#34;Request Begin:&#34; + context.MethodPath); // Debug.Log in Unity.&#xA;&#xA;        var sw = Stopwatch.StartNew();&#xA;        var response = await next(context);&#xA;        sw.Stop();&#xA;&#xA;        Console.WriteLine(&#34;Request Completed:&#34; + context.MethodPath + &#34;, Elapsed:&#34; + sw.Elapsed.TotalMilliseconds + &#34;ms&#34;);&#xA;&#xA;        return response;&#xA;    }&#xA;}&#xA;&#xA;public class ResponseHandlingFilter : IClientFilter&#xA;{&#xA;    public async ValueTask&amp;lt;ResponseContext&amp;gt; SendAsync(RequestContext context, Func&amp;lt;RequestContext, ValueTask&amp;lt;ResponseContext&amp;gt;&amp;gt; next)&#xA;    {&#xA;        var response = await next(context);&#xA;&#xA;        if (context.MethodPath == &#34;ICalc/Sum&#34;)&#xA;        {&#xA;            // You can cast response type.&#xA;            var sumResult = await response.GetResponseAs&amp;lt;int&amp;gt;();&#xA;            Console.WriteLine(&#34;Called Sum, Result:&#34; + sumResult);&#xA;        }&#xA;&#xA;        return response;&#xA;    }&#xA;}&#xA;&#xA;public class MockRequestFilter : IClientFilter&#xA;{&#xA;    public async ValueTask&amp;lt;ResponseContext&amp;gt; SendAsync(RequestContext context, Func&amp;lt;RequestContext, ValueTask&amp;lt;ResponseContext&amp;gt;&amp;gt; next)&#xA;    {&#xA;        if (context.MethodPath == &#34;ICalc/Sum&#34;)&#xA;        {&#xA;            // don&#39;t call next, return mock result.&#xA;            return new ResponseContext&amp;lt;int&amp;gt;(9999);&#xA;        }&#xA;&#xA;        return await next(context);&#xA;    }&#xA;}&#xA;&#xA;public class RetryFilter : IClientFilter&#xA;{&#xA;    public async ValueTask&amp;lt;ResponseContext&amp;gt; SendAsync(RequestContext context, Func&amp;lt;RequestContext, ValueTask&amp;lt;ResponseContext&amp;gt;&amp;gt; next)&#xA;    {&#xA;        Exception lastException = null;&#xA;        var retryCount = 0;&#xA;        while (retryCount != 3)&#xA;        {&#xA;            try&#xA;            {&#xA;                // using same CallOptions so be careful to add duplicate headers or etc.&#xA;                return await next(context);&#xA;            }&#xA;            catch (Exception ex)&#xA;            {&#xA;                lastException = ex;&#xA;            }&#xA;            retryCount++;&#xA;        }&#xA;&#xA;        throw new Exception(&#34;Retry failed&#34;, lastException);&#xA;    }&#xA;}&#xA;&#xA;public class EncryptFilter : IClientFilter&#xA;{&#xA;    public async ValueTask&amp;lt;ResponseContext&amp;gt; SendAsync(RequestContext context, Func&amp;lt;RequestContext, ValueTask&amp;lt;ResponseContext&amp;gt;&amp;gt; next)&#xA;    {&#xA;        context.SetRequestMutator(bytes =&amp;gt; Encrypt(bytes));&#xA;        context.SetResponseMutator(bytes =&amp;gt; Decrypt(bytes));&#xA;        &#xA;        return await next(context);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ServiceContext and Lifecycle&lt;/h3&gt; &#xA;&lt;p&gt;Service/StreamingHub&#39;s method or &lt;code&gt;MagicOnionFilter&lt;/code&gt; can access &lt;code&gt;this.Context&lt;/code&gt; it is&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ConcurrentDictionary&amp;lt;string, object&amp;gt;&lt;/code&gt; Items&lt;/td&gt; &#xA;   &lt;td&gt;Object storage per request/connection.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Guid&lt;/code&gt; ContextId&lt;/td&gt; &#xA;   &lt;td&gt;Unique ID per request(Service)/connection(StreamingHub).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DateTime&lt;/code&gt; Timestamp&lt;/td&gt; &#xA;   &lt;td&gt;Timestamp that request/connection is started time.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Type&lt;/code&gt; ServiceType&lt;/td&gt; &#xA;   &lt;td&gt;Invoked Class.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MethodInfo&lt;/code&gt; MethodInfo&lt;/td&gt; &#xA;   &lt;td&gt;Invoked Method.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;`ILookup&amp;lt;Type, Attribute&amp;gt; AttributeLookup&lt;/td&gt; &#xA;   &lt;td&gt;Cached Attributes that merged both service and method.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ServerCallContext&lt;/code&gt; CallContext&lt;/td&gt; &#xA;   &lt;td&gt;Raw gRPC Context.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MessagePackSerializerOptions&lt;/code&gt; SerializerOptions&lt;/td&gt; &#xA;   &lt;td&gt;Using MessagePack serializer options.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IServiceProvider&lt;/code&gt; ServiceProvider&lt;/td&gt; &#xA;   &lt;td&gt;Get the service provider.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;code&gt;Items&lt;/code&gt; is useful, for example authentication filter add UserId to Items and take out from service method.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If using StreamingHub, ServiceContext means per connected context so &lt;code&gt;Items&lt;/code&gt; is not per method invoke. &lt;code&gt;StreamingHubContext.Items&lt;/code&gt; supports per streaming hub method request but currently can not take from streaming hub method(only use in StreamingHubFilter). &lt;a href=&#34;https://github.com/Cysharp/MagicOnion/issues/67&#34;&gt;Issue:#67&lt;/a&gt;, it will fix.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;MagicOnion supports get current context globally like HttpContext.Current. &lt;code&gt;ServiceContext.Current&lt;/code&gt; can get it but it requires &lt;code&gt;MagicOnionOptions.EnableCurrentContext = true&lt;/code&gt;, default is false.&lt;/p&gt; &#xA;&lt;p&gt;Lifecycle image of ServiceBase&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gRPC In(&#xA;    var context = new ServiceContext();&#xA;    Filter.Invoke(context, &#xA;        var service = new ServiceImpl();&#xA;        service.ServiceContext = context;&#xA;        service.MethodInvoke(&#xA;            /* method impl */&#xA;        )&#xA;    )&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lifecycle image of StreamingHub(StreamingHub is inherited from ServiceBase)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gRPC In(&#xA;    var context = new ServiceContext();&#xA;    Filter.Invoke(context, &#xA;        var hub = new StreamingHubImpl();&#xA;        hub.ServiceContext = context;&#xA;        hub.Connect(&#xA;            while (connecting) {&#xA;                Streaming In(&#xA;                    var streamingHubContext = new StreamingHubContext(context);&#xA;                    StreamingHubFilter.Invoke(streamingHubContext,&#xA;                        hub.MethodInvoke(&#xA;                            /* method impl */&#xA;                        )&#xA;                    )&#xA;                )&#xA;            }&#xA;        )&#xA;    )&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;StreamingHub instance is shared while connecting so StreamingHub&#39;s field can use cache area of connection.&lt;/p&gt; &#xA;&lt;h3&gt;ExceptionHandling and StatusCode&lt;/h3&gt; &#xA;&lt;p&gt;If you are return custom status code from server to client, you can use &lt;code&gt;throw new ReturnStatusException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public Task SendMessageAsync(string message)&#xA;{&#xA;    if (message.Contains(&#34;foo&#34;))&#xA;    {&#xA;        //&#xA;        throw new ReturnStatusException((Grpc.Core.StatusCode)99, &#34;invalid&#34;);&#xA;    }&#xA;&#xA;    // ....&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Client can receive exception as gRPC&#39;s &lt;code&gt;RpcException&lt;/code&gt;. If performance centric to avoid exception throw, you can use raw gRPC CallContext.Status(&lt;code&gt;ServiceContext.CallContext.Status&lt;/code&gt;) and set status directly.&lt;/p&gt; &#xA;&lt;p&gt;MagicOnion&#39;s engine catched exception(except ReturnStatusException), set &lt;code&gt;StatusCode.Unknown&lt;/code&gt; and client received gRPC&#39;s &lt;code&gt;RpcException&lt;/code&gt;. If &lt;code&gt;MagicOnionOption.IsReturnExceptionStackTraceInErrorDetail&lt;/code&gt; is true, client can receive StackTrace of server exception, it is very useful for debugging but has critical issue about security so should only to enable debug build.&lt;/p&gt; &#xA;&lt;h3&gt;Group and GroupConfiguration&lt;/h3&gt; &#xA;&lt;p&gt;StreamingHub&#39;s broadcast system is called Group. It can get from StreamingHub impl method, &lt;code&gt;this.Group&lt;/code&gt;(this.Group type is &lt;code&gt;HubGroupRepository&lt;/code&gt;, not &lt;code&gt;IGroup&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Current connection can add to group by &lt;code&gt;this.Group.AddAsync(string groupName)&lt;/code&gt;, return value(&lt;code&gt;IGroup&lt;/code&gt;) is joined group broadcaster so cache to field. It is enable per connection(if disconnected, automatically leaved from group). If you want to use some restriction, you can use &lt;code&gt;TryAddAsync(string groupName, int incluciveLimitCount, bool createIfEmpty)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IGroup&lt;/code&gt; can pass to StreamingHub.&lt;code&gt;Broadcast&lt;/code&gt;, &lt;code&gt;BroadcastExceptSelf&lt;/code&gt;, &lt;code&gt;BroadcastExcept&lt;/code&gt; and calls client proxy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class ChatHub : StreamingHubBase&amp;lt;IChatHub, IMessageReceiver&amp;gt;, IChatHub&#xA;{&#xA;    string userName;&#xA;    IGroup room;&#xA;&#xA;    public async Task JoinAsync(string userName, string roomName)&#xA;    {&#xA;        this.userName = userName;&#xA;        this.room = await Group.AddAsync(roomName);&#xA;    }&#xA;&#xA;    public async Task SendMessageAsync(string message)&#xA;    {&#xA;        Broadcast(room).OnReceiveMessage(userName, message);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;GroupRepository is created per StreamingHub type&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you want to create ServerSide loop and broadcast out of StreamingHub, you can pass Broadcast(room) result but it is unnatural, I&#39;ll add support kit of create server-side loop&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Group has in-memory storage, it can store extra data to group member. It can set &lt;code&gt;Group.AddAsync(string groupName, TStorage data)&lt;/code&gt; instead of standard AddAsync.&lt;/p&gt; &#xA;&lt;p&gt;Data is can get from &lt;code&gt;group.GetInMemoryStorage&amp;lt;T&amp;gt;&lt;/code&gt; and can invoke &lt;code&gt;AllValues&lt;/code&gt;, &lt;code&gt;Set(Guid connectionId, T Value)&lt;/code&gt;, &lt;code&gt;Get(Guid connectionId)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;StreamingHub&#39;s ConnectionId is ServiceContext.ContextId&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Default MagicOnion&#39;s group is inmemory and using &lt;code&gt;ImmutableArrayGroup&lt;/code&gt;. This group implementation is tuned for small room, not enter/leave frequently. If large room and enter/leave frequently design, you can use &lt;code&gt;ConcurrentDictionaryGroup&lt;/code&gt;. It can configure by &lt;code&gt;GroupConfigurationAttribute&lt;/code&gt; or &lt;code&gt;MagicOnionOptions.DefaultGroupRepositoryFactory&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// use ***GroupRepositoryFactory type.&#xA;[GroupConfiguration(typeof(ConcurrentDictionaryGroupRepositoryFactory))]&#xA;public class ChatHub : StreamingHubBase&amp;lt;IChatHub, IMessageReceiver&amp;gt;, IChatHub&#xA;{&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MagicOnion has distribute system called redis-backplane for group broadcast.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/50974777-5f6aed00-152f-11e9-97f3-ba2a0c97f0eb.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package MagicOnion.Server.Redis&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;services.AddMagicOnion()&#xA;    .UseRedisGroupRepository(options =&amp;gt;&#xA;    {&#xA;        options.ConnectionMultiplexer = ConnectionMultiplexer.Connect(&#34;localhost:6379&#34;);&#xA;    });&#xA;    // If you want to use Redis backplane by default, you can specify `registerAsDefault: true`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Use Redis as backplane&#xA;[GroupConfiguration(typeof(RedisGroupRepositoryFactory))]&#xA;public class ...&#xA;{&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Project Structure&lt;/h3&gt; &#xA;&lt;p&gt;If creates Server-Client project, I recommend make three projects. &lt;code&gt;Server&lt;/code&gt;, &lt;code&gt;ServerDefinition&lt;/code&gt;, &lt;code&gt;Client&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/46207/21081857/e0f6dfce-c012-11e6-850d-358c5b928a82.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;ServerDefinition is only defined interface(&lt;code&gt;IService&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;IStreamingHub&amp;lt;,&amp;gt;&lt;/code&gt;)(and some share request/response types).&lt;/p&gt; &#xA;&lt;p&gt;If debugging, I recommend use &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=vs-publisher-141975.SwitchStartupProjectforVS2017&#34;&gt;SwitchStartupProject&lt;/a&gt; extension of VisualStudio and launch both Server and Client.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&#34;MultiProjectConfigurations&#34;: {&#xA;    &#34;Server + Client&#34;: {&#xA;        &#34;Projects&#34;: {&#xA;            &#34;FooService&#34;: {},&#xA;            &#34;FooClient&#34;: {}&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can step-in/out seamlessly in server and client.&lt;/p&gt; &#xA;&lt;p&gt;for Unity, you can&#39;t share by DLL(because can&#39;t share &lt;code&gt;IServer&amp;lt;&amp;gt;&lt;/code&gt; because it is different reference both Unity and Server). It is slightly complex so we provides sample project and explanation.&lt;/p&gt; &#xA;&lt;p&gt;see: &lt;a href=&#34;https://github.com/Cysharp/MagicOnion/tree/master/samples&#34;&gt;samples&lt;/a&gt; page and ReadMe.&lt;/p&gt; &#xA;&lt;h3&gt;Dependency Injection&lt;/h3&gt; &#xA;&lt;p&gt;You can use DI(constructor injection) on the server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyFirstService : ServiceBase&amp;lt;IMyFirstService&amp;gt;, IMyFirstService&#xA;{&#xA;    IOptions&amp;lt;MyConfig&amp;gt; config;&#xA;    ILogger&amp;lt;MyFirstService&amp;gt; logger;&#xA;&#xA;    public MyFirstService(IOptions&amp;lt;MyConfig&amp;gt; config, ILogger&amp;lt;MyFirstService&amp;gt; logger)&#xA;    {&#xA;        this.config = config;&#xA;        this.logger = logger;&#xA;    }&#xA;&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Clients&lt;/h1&gt; &#xA;&lt;h2&gt;Support for Unity client&lt;/h2&gt; &#xA;&lt;p&gt;MagicOnion supports from Unity version 2018.4.13f1 and above, which is available for &lt;code&gt;.NET 4.x&lt;/code&gt; runtime and C# 7.3 or latest.&lt;/p&gt; &#xA;&lt;p&gt;Using MagicOnion with Unity client requires the following four things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MagicOnion.Client.Unity.package (Unity asset package for MagicOnion library)&lt;/li&gt; &#xA; &lt;li&gt;gRPC library for Unity client (gRPC official)&lt;/li&gt; &#xA; &lt;li&gt;MessagePack for C#&lt;/li&gt; &#xA; &lt;li&gt;MagicOnion code generator (for IL2CPP)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;MagicOnion.Client.Unity.package (Unity asset package for MagicOnion library)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;MagicOnion.Client.Unity.package&lt;/code&gt; is available for download from &lt;a href=&#34;https://github.com/cysharp/MagicOnion/releases&#34;&gt;Releases&lt;/a&gt; page of this repository.&lt;/p&gt; &#xA;&lt;p&gt;The package contains the code to use MagicOnion with Unity. It consists of several extensions for Unity in addition to MagicOnion.Client NuGet package.&lt;/p&gt; &#xA;&lt;h3&gt;gRPC library for Unity client (gRPC official)&lt;/h3&gt; &#xA;&lt;p&gt;gRPC library is not included in MagicOnion package. You need to download and install separately.&lt;/p&gt; &#xA;&lt;p&gt;gRPC library can be found at &lt;a href=&#34;https://packages.grpc.io/&#34;&gt;gRPC daily builds&lt;/a&gt;, click &lt;code&gt;Build ID&lt;/code&gt;, then click &lt;code&gt;grpc_unity_package.*.*.*-dev.zip&lt;/code&gt; to download the library. See &lt;a href=&#34;https://github.com/grpc/grpc/tree/master/src/csharp/experimental#unity&#34;&gt;gRPC C# - experimental support for Unity&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: If you encounter error about &lt;code&gt;Google.Protobuf.dll&lt;/code&gt;, you can remove the library. MagicOnion does not depend &lt;code&gt;Google.Protobuf.dll&lt;/code&gt;. (&lt;a href=&#34;https://github.com/Cysharp/MagicOnion/issues/296&#34;&gt;Issue#296&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: gRPC native library for iOS has a file size of over 100MB, which may cause problems when pushing to GitHub or others. For more information on solutions, see &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/#stripping-debug-symbols-from-ioslibgrpca&#34;&gt;Stripping debug symbols from ios/libgrpc.a&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;MessagePack for C#&lt;/h3&gt; &#xA;&lt;p&gt;MessagePack for C# is not included in MagicOnion package. You need to download and install separately.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/neuecc/MessagePack-CSharp#unity&#34;&gt;MessagePack for C# installation for Unity&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h3&gt;MagicOnion code generator (for IL2CPP)&lt;/h3&gt; &#xA;&lt;p&gt;MagicOnion&#39;s default client only supports Unity Editor or non-IL2CPP environments (e.g. Windows/macOS/Linux Standalone). If you want to use MagicOnion on IL2CPP environments, you need to generate a client and register it in your Unity project.&lt;/p&gt; &#xA;&lt;p&gt;There are two ways to generate code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using &lt;code&gt;mpc&lt;/code&gt; (MagicOnion Codegen) command line tool&lt;/li&gt; &#xA; &lt;li&gt;Using &lt;code&gt;MagicOnion.MSBuild.Task&lt;/code&gt; (MSBuild Integration)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;MessagePack for C#&lt;/h4&gt; &#xA;&lt;p&gt;For the same reason, MessagePack for C# code generation is also required.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/neuecc/MessagePack-CSharp#aot-code-generation-to-support-unityxamarin&#34;&gt;MessagePack-CSharp AOT Code Generation (to support Unity/Xamarin) &lt;/a&gt; section for more details about MessagePack code generation.&lt;/p&gt; &#xA;&lt;p&gt;MagicOnion code generator also generates code for MessagePack and requires Resolver registration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]&#xA;static void RegisterResolvers()&#xA;{&#xA;    // NOTE: Currently, CompositeResolver doesn&#39;t work on Unity IL2CPP build. Use StaticCompositeResolver instead of it.&#xA;    StaticCompositeResolver.Instance.Register(&#xA;        // This resolver is generated by MagicOnion&#39;s code generator.&#xA;        MagicOnion.Resolvers.MagicOnionResolver.Instance,&#xA;        // This resolver is generated by MessagePack&#39;s code generator.&#xA;        MessagePack.Resolvers.GeneratedResolver.Instance,&#xA;        StandardResolver.Instance&#xA;    );&#xA;&#xA;    MessagePackSerializer.DefaultOptions = MessagePackSerializer.DefaultOptions&#xA;        .WithResolver(StaticCompositeResolver.Instance);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;moc&lt;/code&gt; (MagicOnion Codegen) command line tool&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;moc&lt;/code&gt; is a cross-platform application. It requires &lt;a href=&#34;https://dotnet.microsoft.com/download&#34;&gt;.NET Core 3.1 SDK&lt;/a&gt; to run it.&lt;/p&gt; &#xA;&lt;p&gt;You can download a binary from &lt;a href=&#34;https://github.com/cysharp/MagicOnion/releases&#34;&gt;Releases&lt;/a&gt; page in this repository or install the tool as .NET Core tools. We recommend installing it as a local tool for .NET Core tools because of its advantages, such as fixing version per project.&lt;/p&gt; &#xA;&lt;p&gt;To install as a &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools#install-a-local-tool&#34;&gt;.NET Core tools (local tool)&lt;/a&gt;, you can run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet new tool-manifest&#xA;dotnet tool install MagicOnion.Generator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;moc&lt;/code&gt; is installed as a local tool, you can run it with &lt;code&gt;dotnet moc&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet moc -h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;argument list:&#xA;-i, -input: Input path of analyze csproj or directory.&#xA;-o, -output: Output path(file) or directory base(in separated mode).&#xA;-u, -unuseUnityAttr: [default=False]Unuse UnityEngine&#39;s RuntimeInitializeOnLoadMethodAttribute on MagicOnionInitializer.&#xA;-n, -namespace: [default=MagicOnion]Set namespace root name.&#xA;-c, -conditionalSymbol: [default=null]Conditional compiler symbols, split with &#39;,&#39;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet moc -i ./Assembly-CSharp.csproj -o Assets/Scripts/MagicOnion.Generated.cs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;MagicOnion.MSBuild.Tasks (MSBuild Integration)&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MagicOnion.MSBuild.Tasks&lt;/code&gt; is easy way of generate code that target to shared project. We&#39;re mostly recommended to use this way. For example, PostCompile sample.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;&amp;lt;!-- in Shared.csproj --&amp;gt;&#xA;&#xA;&amp;lt;ItemGroup&amp;gt;&#xA;    &amp;lt;!-- Install MSBuild Task(with PrivateAssets=&#34;All&#34;, it means to use dependency only in build time). --&amp;gt;&#xA;    &amp;lt;PackageReference Include=&#34;MessagePack.MSBuild.Tasks&#34; Version=&#34;*&#34; PrivateAssets=&#34;All&#34; /&amp;gt;&#xA;    &amp;lt;PackageReference Include=&#34;MagicOnion.MSBuild.Tasks&#34; Version=&#34;*&#34; PrivateAssets=&#34;All&#34; /&amp;gt;&#xA;&amp;lt;/ItemGroup&amp;gt;&#xA;&#xA;&amp;lt;!-- Call code generator after compile successfully. --&amp;gt;&#xA;&amp;lt;Target Name=&#34;GenerateMessagePack&#34; AfterTargets=&#34;Compile&#34;&amp;gt;&#xA;    &amp;lt;MessagePackGenerator Input=&#34;$(ProjectPath)&#34; Output=&#34;..\UnityClient\Assets\Scripts\Generated\MessagePack.Generated.cs&#34; /&amp;gt;&#xA;&amp;lt;/Target&amp;gt;&#xA;&amp;lt;Target Name=&#34;GenerateMagicOnion&#34; AfterTargets=&#34;Compile&#34;&amp;gt;&#xA;    &amp;lt;MagicOnionGenerator Input=&#34;$(ProjectPath)&#34; Output=&#34;..\UnityClient\Assets\Scripts\Generated\MagicOnion.Generated.cs&#34; /&amp;gt;&#xA;&amp;lt;/Target&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Full options are below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;MagicOnionGenerator&#xA;    Input=&#34;string:required&#34;&#xA;    Output=&#34;string:required&#34;&#xA;    ConditionalSymbol=&#34;string:optional&#34;&#xA;    ResolverName=&#34;string:optional&#34;&#xA;    Namespace=&#34;string:optional&#34;&#xA;    UnuseUnityAttr=&#34;bool:optional&#34;&#xA;/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Project structure and code generation samples are found in &lt;a href=&#34;https://github.com/Cysharp/MagicOnion/tree/master/samples&#34;&gt;samples&lt;/a&gt; directory and README.&lt;/p&gt; &#xA;&lt;h3&gt;gRPC channel management integration for Unity&lt;/h3&gt; &#xA;&lt;p&gt;Wraps gRPC channels and provides a mechanism to manage them with Unity&#39;s lifecycle. This prevents your application and the Unity Editor from freezing by releasing channels and StreamingHub in one place.&lt;/p&gt; &#xA;&lt;p&gt;The editor extension also provides the ability to display the communication status of channels.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9012/111609638-da21a800-881d-11eb-81b2-33abe80ea497.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The data rate is calculated only for the message body of methods, and does not include Headers, Trailers, or Keep-alive pings.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;New APIs&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;MagicOnion.GrpcChannelx&lt;/code&gt; class &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;GrpcChannelx.ForTarget(GrpcChannelTarget)&lt;/code&gt; method&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;GrpcChannelx.ForAddress(Uri)&lt;/code&gt; method&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;GrpcChannelx.ForAddress(string)&lt;/code&gt; method&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MagicOnion.Unity.GrpcChannelProviderHost&lt;/code&gt; class &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;GrpcChannelProviderHost.Initialize(IGrpcChannelProvider)&lt;/code&gt; method&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MagicOnion.Unity.IGrpcChannelProvider&lt;/code&gt; interface &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;DefaultGrpcChannelProvider&lt;/code&gt; class&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;LoggingGrpcChannelProvider&lt;/code&gt; class&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Usages&lt;/h4&gt; &#xA;&lt;h5&gt;1. Prepare to use &lt;code&gt;GrpcChannelx&lt;/code&gt; in your Unity project.&lt;/h5&gt; &#xA;&lt;p&gt;Before creating a channel in your application, you need to initialize the provider host to be managed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]&#xA;public static void OnRuntimeInitialize()&#xA;{&#xA;    // Initialize gRPC channel provider when the application is loaded.&#xA;    GrpcChannelProviderHost.Initialize(new DefaultGrpcChannelProvider(new []&#xA;    {&#xA;        // send keepalive ping every 5 second, default is 2 hours&#xA;        new ChannelOption(&#34;grpc.keepalive_time_ms&#34;, 5000),&#xA;        // keepalive ping time out after 5 seconds, default is 20 seconds&#xA;        new ChannelOption(&#34;grpc.keepalive_timeout_ms&#34;, 5 * 1000),&#xA;    }));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GrpcChannelProviderHost will be created as DontDestroyOnLoad and keeps existing while the application is running. DO NOT destory it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9012/111586444-2eb82980-8804-11eb-8a4f-a898c86e5a60.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;2. Use &lt;code&gt;GrpcChannelx.ForTarget&lt;/code&gt; or &lt;code&gt;GrpcChannelx.ForAddress&lt;/code&gt; to create a channel.&lt;/h5&gt; &#xA;&lt;p&gt;Use &lt;code&gt;GrpcChannelx.ForTarget&lt;/code&gt; or &lt;code&gt;GrpcChannelx.ForAddress&lt;/code&gt; to create a channel instead of &lt;code&gt;new Channel(...)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var channel = GrpcChannelx.ForTarget(new GrpcChannelTarget(&#34;localhost&#34;, 12345, ChannelCredentials.Insecure));&#xA;// or&#xA;var channel = GrpcChannelx.ForAddress(&#34;http://localhost:12345&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;3. Use the channel instead of &lt;code&gt;Grpc.Core.Channel&lt;/code&gt;.&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var channel = GrpcChannelx.ForAddress(&#34;http://localhost:12345&#34;);&#xA;&#xA;var serviceClient = MagicOnionClient.Create&amp;lt;IGreeterService&amp;gt;(channel);&#xA;var hubClient = StreamingHubClient.ConnectAsync&amp;lt;IGreeterHub, IGreeterHubReceiver&amp;gt;(channel, this);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Extensions for Unity Editor (Editor Window &amp;amp; Inspector)&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9012/111585700-0d0a7280-8803-11eb-8ce3-3b8f9d968c13.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;iOS build with gRPC&lt;/h2&gt; &#xA;&lt;p&gt;gRPC iOS build require two additional operation on build.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Disable Bitcode&lt;/li&gt; &#xA; &lt;li&gt;Add libz.tbd&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We introduce OnPostProcessingBuild sample &lt;a href=&#34;https://github.com/Cysharp/MagicOnion/raw/master/samples/ChatApp/ChatApp.Unity/Assets/Editor/BuildeIos.cs&#34;&gt;BuildIos.cs&lt;/a&gt; for ChatApp.Unity to automate these steps.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;#if UNITY_IPHONE&#xA;using System.IO;&#xA;using UnityEngine;&#xA;using UnityEditor;&#xA;using UnityEditor.Callbacks;&#xA;using UnityEditor.iOS.Xcode;&#xA;&#xA;public class BuildIos&#xA;{&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Handle libgrpc project settings.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;param name=&#34;target&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;    /// &amp;lt;param name=&#34;path&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;    [PostProcessBuild(1)]&#xA;    public static void OnPostProcessBuild(BuildTarget target, string path)&#xA;    {&#xA;        var projectPath = PBXProject.GetPBXProjectPath(path);&#xA;        var project = new PBXProject();&#xA;        project.ReadFromString(File.ReadAllText(projectPath));&#xA;        var targetGuid = project.TargetGuidByName(PBXProject.GetUnityTargetName());&#xA;&#xA;        // libz.tbd for grpc ios build&#xA;        project.AddFrameworkToProject(targetGuid, &#34;libz.tbd&#34;, false);&#xA;&#xA;        // libgrpc_csharp_ext missing bitcode. as BITCODE exand binary size to 250MB.&#xA;        project.SetBuildProperty(targetGuid, &#34;ENABLE_BITCODE&#34;, &#34;NO&#34;);&#xA;        &#xA;        File.WriteAllText(projectPath, project.WriteToString());&#xA;    }&#xA;}&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Stripping debug symbols from ios/libgrpc.a&lt;/h2&gt; &#xA;&lt;p&gt;When you download gRPC daily build and extract Native Libraries for Unity, you will find file size of Plugins/Grpc.Core/runtime/ios/libgrpc.a beyonds 100MB. GitHub will reject commit when file size is over 100MB, therefore libgrpc.a often become unwelcome for gif-low. The reason of libgrpc.a file size is because it includes debug symbols for 3 architectures, arm64, armv7 and x86_64.&lt;/p&gt; &#xA;&lt;p&gt;We introduce strip debug symbols and generate reduced size &lt;code&gt;libgrpc_stripped.a&lt;/code&gt;, it&#39;s about 17MB. This may useful for whom want commit &lt;code&gt;libgrpc.a&lt;/code&gt; to GitHub, and understanding stripped library missing debug symbols.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;How to strip&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Download gRPC lib &lt;code&gt;grpc_unity_package.*.*.*-dev.zip&lt;/code&gt; from &lt;a href=&#34;https://packages.grpc.io/&#34;&gt;gRPC daily builds&lt;/a&gt; and extract it, copy Plugins folder to Unity&#39;s Assets path.&lt;/p&gt; &#xA;&lt;p&gt;Open terminal on &lt;code&gt;Plugins/Grpc.Core/runtimes/ios/&lt;/code&gt; and execute following will generate &lt;code&gt;libgrpc_stripped.a&lt;/code&gt; and replace original libgrpc.a with stripped version.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd ${UNITY_PATH}/Plugins/Grpc.Core/runtimes/ios&#xA;$ strip -S -x libgrpc.a -o libgrpc_stripped.a&#xA;$ rm libgrpc.a &amp;amp;&amp;amp; mv libgrpc_stripped.a libgrpc.a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure you can build app with iOS and works fine.&lt;/p&gt; &#xA;&lt;h2&gt;Stripping debug symbols from libgrpc_csharp_ext.so&lt;/h2&gt; &#xA;&lt;p&gt;Plugins/Grpc.Core/runtime/android/[arch]/libgrpc_csharp_ext.so file size is big because its includes debug symbols.&lt;/p&gt; &#xA;&lt;p&gt;You can reduce its size using strip (this command is includes in the NDK).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd ${UNITY_PATH}/Plugins/Grpc.Core/runtime/android/${TARGET_ARCH}&#xA;$ strip.exe libgrpc_csharp_ext.so&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Workaround for il2cpp + Windows Build failure&lt;/h2&gt; &#xA;&lt;p&gt;If you do a Windows il2cpp build with the gRPC daily build, the build may fail with following error messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;20AAB1A42EE7F9CA535031CD347327DE.obj : error LNK2019: unresolved external symbol dlopen referenced in function Mono_dlopen_m7F2DE2CD0870AB15EEA4E0A0BA6C47044E74BB67&#xA;20AAB1A42EE7F9CA535031CD347327DE.obj : error LNK2019: unresolved external symbol dlerror referenced in function Mono_dlerror_m359ABCFD23D0EB5314DE2DFF8AB58CFE949BBABD&#xA;20AAB1A42EE7F9CA535031CD347327DE.obj : error LNK2019: unresolved external symbol dlsym referenced in function Mono_dlsym_m31A00C09F598C9D552A94628C2C28B3C7B04C2DD&#xA;C:\Path\To\MyProject\Library\il2cpp_cache\linkresult_C1E926E002526A4D380E4B12B6BD0522\GameAssembly.dll : fatal error LNK1120: 3 unresolved externals&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason is because some native function (but not nessessary at the runtime) not found on Windows il2cpp build. You can avoid this problem by adding the following code to &lt;code&gt;grpc_csharp_ext_dummy_stubs.c&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void* dlopen(const char* filename, int flags) {&#xA;  fprintf(stderr, &#34;Should never reach here&#34;);&#xA;  abort();&#xA;}&#xA;char* dlerror(void) {&#xA;  fprintf(stderr, &#34;Should never reach here&#34;);&#xA;  abort();&#xA;}&#xA;void* dlsym(void* handle, const char* symbol) {&#xA;  fprintf(stderr, &#34;Should never reach here&#34;);&#xA;  abort();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;gRPC Keepalive&lt;/h2&gt; &#xA;&lt;p&gt;When you want detect network termination on Client or vice-versa, you can configure gRPC Keepalive.&lt;/p&gt; &#xA;&lt;h3&gt;Applied to .NET Standard 2.1 platforms (Grpc.Net.Client)&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/grpc/performance?view=aspnetcore-5.0#keep-alive-pings&#34;&gt;keep alive pings | Performance best practices with gRPC | Microsoft Docs&lt;/a&gt; for information on setting up keepalive for Grpc.Net.Client.&lt;/p&gt; &#xA;&lt;h3&gt;Applied to .NET Standard 2.0 or Unity platforms (Grpc.Core)&lt;/h3&gt; &#xA;&lt;p&gt;Follow to the &lt;a href=&#34;https://github.com/grpc/grpc/raw/master/doc/keepalive.md&#34;&gt;Keepalive UserGuide for gRPC Core&lt;/a&gt; but let&#39;s see how in actual.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ChannelOption&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;ChannelOptions is primitive way to configure options. Below uses &lt;code&gt;ChannelOption&lt;/code&gt; and offer keepalive for every 10 second even RPC is not called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// If you want configure KEEP_ALIVE interval, then....&#xA;// * set same value for `grpc.keepalive_time_ms` and `grpc.http2.min_time_between_pings_ms`&#xA;// * keep `grpc.http2.min_ping_interval_without_data_ms &amp;lt; grpc.http2.min_time_between_pings_ms`&#xA;var options = new[]&#xA;{&#xA;    // send keepalive ping every 10 second, default is 2 hours&#xA;    new ChannelOption(&#34;grpc.keepalive_time_ms&#34;, 10000),&#xA;    // keepalive ping time out after 5 seconds, default is 20 seconds&#xA;    new ChannelOption(&#34;grpc.keepalive_timeout_ms&#34;, 5000),&#xA;    // allow grpc pings from client every 10 seconds&#xA;    new ChannelOption(&#34;grpc.http2.min_time_between_pings_ms&#34;, 10000),&#xA;    // allow unlimited amount of keepalive pings without data&#xA;    new ChannelOption(&#34;grpc.http2.max_pings_without_data&#34;, 0),&#xA;    // allow keepalive pings when there&#39;s no gRPC calls&#xA;    new ChannelOption(&#34;grpc.keepalive_permit_without_calls&#34;, 1),&#xA;    // allow grpc pings from client without data every 5 seconds&#xA;    new ChannelOption(&#34;grpc.http2.min_ping_interval_without_data_ms&#34;, 5000),&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pass this options to Channel on Client will configure Keepalive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Client&#xA;this.channel = new Channel(&#34;localhost&#34;, 12345, ChannelCredentials.Insecure, options);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can detect client network disconnection on serverside, let&#39;s override &lt;code&gt;OnDisconnected&lt;/code&gt; and set debugger, disconnect Client network and wait for interval sec!&lt;/p&gt; &#xA;&lt;h2&gt;HTTPS (TLS)&lt;/h2&gt; &#xA;&lt;p&gt;MagicOnion supports TLS encrypted connection.&lt;/p&gt; &#xA;&lt;h3&gt;Server-side&lt;/h3&gt; &#xA;&lt;p&gt;In general, HTTPS encryption settings on the server follow ASP.NET Core. For more information, see &lt;a href=&#34;https://docs.microsoft.com/ja-jp/aspnet/core/security/enforcing-ssl&#34;&gt;Enforce HTTPS in ASP.NET Core | Microsoft Docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The limitations on macOS environment and when running on Docker are also described in ASP.NET Core documentation.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Client-side&lt;/h3&gt; &#xA;&lt;p&gt;Depending on whether the client supports .NET Standard 2.1 or .NET Standard 2.1 (including Unity), the configuration is different.&lt;/p&gt; &#xA;&lt;h4&gt;.NET Standard 2.1 (.NET Core 3.x, .NET 5, Xamarin)&lt;/h4&gt; &#xA;&lt;p&gt;If the client supports .NET Standard 2.1 or newer, MagicOnion uses &lt;code&gt;Grpc.Net.Client&lt;/code&gt; (a pure C# implementation) for gRPC connection.&lt;/p&gt; &#xA;&lt;p&gt;Grpc.Net.Client uses &lt;code&gt;HttpClient&lt;/code&gt; internally, so it handles certificates the same way as &lt;code&gt;HttpClient&lt;/code&gt;. For example, on Windows, it uses Windows&#39;s certificate store to validate certificates.&lt;/p&gt; &#xA;&lt;h4&gt;.NET Standard 2.0 (.NET Core 2.x, .NET Framework 4.6.1+) / Unity&lt;/h4&gt; &#xA;&lt;p&gt;If the client supports .NET Standard 2.0, MagicOnion uses &lt;code&gt;Grpc.Core&lt;/code&gt; (C-library binding) for gRPC connection.&lt;/p&gt; &#xA;&lt;p&gt;Grpc.Core has its &lt;a href=&#34;https://github.com/grpc/grpc/raw/master/etc/roots.pem&#34;&gt;own certificate store built into the library&lt;/a&gt; and uses it unless you specify a certificate. This certificate store contains common CAs and is rarely a problem in production environment.&lt;/p&gt; &#xA;&lt;p&gt;However, there is a problem when connecting with a server using &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0&amp;amp;tabs=visual-studio#trust-the-aspnet-core-https-development-certificate-on-windows-and-macos&#34;&gt;ASP.NET Core development certificate&lt;/a&gt;. For example, if you see the following exceptions when you try to connect, the server certificate validation may have failed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Grpc.Core.RpcException: &#39;Status(StatusCode=&#34;Unavailable&#34;, Detail=&#34;failed to connect to all addresses&#34;, ...&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following workarounds are suggested for such cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Issue and configure a trusted certificate to the server&lt;/li&gt; &#xA; &lt;li&gt;Use OpenSSL commands to issue and configure self-signed certificates to servers and clients&lt;/li&gt; &#xA; &lt;li&gt;Unencrypted connection without TLS&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Use HTTP unencrypted connection without TLS&lt;/h3&gt; &#xA;&lt;p&gt;It is recommended to use HTTPS for server-client connection, but in some cases during development you may want to configure unencrypted connection. Also, you need to configure unencrypted connection in macOS because ALPN over TLS is not supported.&lt;/p&gt; &#xA;&lt;h4&gt;Server-side&lt;/h4&gt; &#xA;&lt;p&gt;To allow your server to accept unencrypted HTTP/2, you must configure an endpoint to listen to Kestrel. Endpoints can be configured either by using &lt;code&gt;appsettings.json&lt;/code&gt; or directly in the source code.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot#unable-to-start-aspnet-core-grpc-app-on-macos&#34;&gt;Unable to start ASP.NET Core gRPC app on macOS | Troubleshoot gRPC on .NET Core&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    ...&#xA;    &#34;Kestrel&#34;: {&#xA;        &#34;Endpoints&#34;: {&#xA;            &#34;Grpc&#34;: {&#xA;                &#34;Url&#34;: &#34;http://localhost:5000&#34;,&#xA;                &#34;Protocols&#34;: &#34;Http2&#34;&#xA;            },&#xA;            &#34;Https&#34;: {&#xA;                &#34;Url&#34;: &#34;https://localhost:5001&#34;,&#xA;                &#34;Protocols&#34;: &#34;Http1AndHttp2&#34;&#xA;            },&#xA;            &#34;Http&#34;: {&#xA;                &#34;Url&#34;: &#34;http://localhost:5002&#34;,&#xA;                &#34;Protocols&#34;: &#34;Http1&#34;&#xA;            }&#xA;        }&#xA;    },&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;webBuilder&#xA;    .UseKestrel(options =&amp;gt;&#xA;    {&#xA;        // WORKAROUND: Accept HTTP/2 only to allow insecure HTTP/2 connections during development.&#xA;        options.ConfigureEndpointDefaults(endpointOptions =&amp;gt;&#xA;        {&#xA;            endpointOptions.Protocols = HttpProtocols.Http2;&#xA;        });&#xA;    })&#xA;    .UseStartup&amp;lt;Startup&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Client-side (.NET Standard 2.1; Grpc.Net.Client)&lt;/h4&gt; &#xA;&lt;p&gt;When calling &lt;code&gt;GrpcChannel.ForAddress&lt;/code&gt;, change the URL scheme to HTTP and the port to an unencrypted port.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var channel = GrpcChannel.ForAddress(&#34;http://localhost:5000&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable AppSwitch to allow HTTP/2 without encryption.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// WORKAROUND: Use insecure HTTP/2 connections during development.&#xA;AppContext.SetSwitch(&#34;System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport&#34;, true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot#call-insecure-grpc-services-with-net-core-client&#34;&gt;Call insecure gRPC services with .NET Core client | Troubleshoot gRPC on .NET Core | Microsoft Docs&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h4&gt;Client-side (.NET Standard 2.0/Unity; Grpc.Core)&lt;/h4&gt; &#xA;&lt;p&gt;When creating &lt;code&gt;Channel&lt;/code&gt;, specify the unencrypted port and pass &lt;code&gt;ChannelCredentials.Insecure&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var channel = new Channel(&#34;localhost&#34;, 5000, ChannelCredentials.Insecure);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Limitations&lt;/h4&gt; &#xA;&lt;p&gt;If unencrypted HTTP/2 connection is accepted, HTTP/1 and HTTP/2 cannot be served on the same port. When TLS is enabled, ALPN is used for HTTP/2 negotiation, but with non-TLS, this is not possible.&lt;/p&gt; &#xA;&lt;p&gt;If you want HTTP/1 and HTTP/2 to work together for the convenience of hosting a web site or API, you can listen on multiple ports by configuring Kestrel.&lt;/p&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;p&gt;MagicOnion is also supported in Docker containers and running on Kubernetes.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/docs/articles/deployment/&#34;&gt;docs/articles/deployment/&lt;/a&gt; for information on deploying to Amazon Web Service and other cloud services.&lt;/p&gt; &#xA;&lt;h2&gt;Integrations&lt;/h2&gt; &#xA;&lt;h3&gt;Swagger&lt;/h3&gt; &#xA;&lt;p&gt;MagicOnion has built-in HTTP/1.1 JSON Gateway and &lt;a href=&#34;http://swagger.io/&#34;&gt;Swagger&lt;/a&gt; integration for Unary operation. It can execute and debug RPC-API easily.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package MagicOnion.Server.HttpGateway&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Startup&#xA;{&#xA;    public Startup(IConfiguration configuration)&#xA;    {&#xA;        Configuration = configuration;&#xA;    }&#xA;&#xA;    public IConfiguration Configuration { get; }&#xA;&#xA;    // This method gets called by the runtime. Use this method to add services to the container.&#xA;    public void ConfigureServices(IServiceCollection services)&#xA;    {&#xA;        services.AddControllersWithViews();&#xA;&#xA;        services.AddGrpc(); // MagicOnion depends on ASP.NET Core gRPC service.&#xA;        services.AddMagicOnion();&#xA;    }&#xA;&#xA;    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&#xA;    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#xA;    {&#xA;        if (env.IsDevelopment())&#xA;        {&#xA;            app.UseDeveloperExceptionPage();&#xA;        }&#xA;&#xA;        app.UseRouting();&#xA;&#xA;        app.UseEndpoints(endpoints =&amp;gt;&#xA;        {&#xA;            endpoints.MapMagicOnionHttpGateway(&#34;_&#34;, app.ApplicationServices.GetService&amp;lt;MagicOnion.Server.MagicOnionServiceDefinition&amp;gt;().MethodHandlers, GrpcChannel.ForAddress(&#34;https://localhost:5001&#34;));&#xA;            endpoints.MapMagicOnionSwagger(&#34;swagger&#34;, app.ApplicationServices.GetService&amp;lt;MagicOnion.Server.MagicOnionServiceDefinition&amp;gt;().MethodHandlers, &#34;/_/&#34;);&#xA;&#xA;            endpoints.MapMagicOnionService();&#xA;        });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Open &lt;code&gt;http://localhost:5000&lt;/code&gt;, you can see swagger view.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/46207/21295663/6a9d3e28-c59d-11e6-8081-18d14e359567.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Advanced&lt;/h2&gt; &#xA;&lt;h3&gt;MagicOnionOption&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;MagicOnionOption&lt;/code&gt; can pass to &lt;code&gt;MagicOnionEngine.BuildServerServiceDefinition(MagicOnionOptions option)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IList&amp;lt;MagicOnionFilterDescriptor&amp;gt;&lt;/code&gt; GlobalFilters&lt;/td&gt; &#xA;   &lt;td&gt;Global MagicOnion filters.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt; EnableCurrentContext&lt;/td&gt; &#xA;   &lt;td&gt;Enable ServiceContext.Current option by AsyncLocal, default is false.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IList&amp;lt;StreamingHubFilterDescriptor&amp;gt;&lt;/code&gt; Global StreamingHub filters.&lt;/td&gt; &#xA;   &lt;td&gt;GlobalStreamingHubFilters&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IGroupRepositoryFactory&lt;/code&gt; DefaultGroupRepositoryFactory&lt;/td&gt; &#xA;   &lt;td&gt;Default GroupRepository factory for StreamingHub, default is ``.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt; IsReturnExceptionStackTraceInErrorDetail&lt;/td&gt; &#xA;   &lt;td&gt;If true, MagicOnion handles exception ownself and send to message. If false, propagate to gRPC engine. Default is false.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MessagePackSerializerOptions&lt;/code&gt; SerializerOptions&lt;/td&gt; &#xA;   &lt;td&gt;MessagePack serialization resolver. Default is used ambient default(MessagePackSerializer.DefaultOptions).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Internal Logging&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;IMagicOnionLogger&lt;/code&gt; is structured logger of MagicOnion internal information.&lt;/p&gt; &#xA;&lt;p&gt;Implements your custom logging code and append it, default is &lt;code&gt;NullMagicOnionLogger&lt;/code&gt;(do nothing). MagicOnion has some built in logger, &lt;code&gt;MagicOnionLogToLogger&lt;/code&gt; that structured log to string log and send to &lt;code&gt;Microsoft.Extensions.Logging.ILogger&lt;/code&gt;. &lt;code&gt;MagicOnionLogToLoggerWithDataDump&lt;/code&gt; is includes data dump it is useful for debugging(but slightly heavy, recommended to only use debugging). &lt;code&gt;MagicOnionLogToLoggerWithNamedDataDump&lt;/code&gt; is more readable than simple WithDataDump logger.&lt;/p&gt; &#xA;&lt;h3&gt;Raw gRPC APIs&lt;/h3&gt; &#xA;&lt;p&gt;MagicOnion can define and use primitive gRPC APIs(ClientStreaming, ServerStreaming, DuplexStreaming). Especially DuplexStreaming is used underlying StreamingHub. If there is no reason, we recommend using StreamingHub.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Definitions&#xA;public interface IMyFirstService : IService&amp;lt;IMyFirstService&amp;gt;&#xA;{&#xA;    UnaryResult&amp;lt;string&amp;gt; SumAsync(int x, int y);&#xA;    Task&amp;lt;UnaryResult&amp;lt;string&amp;gt;&amp;gt; SumLegacyTaskAsync(int x, int y);&#xA;    Task&amp;lt;ClientStreamingResult&amp;lt;int, string&amp;gt;&amp;gt; ClientStreamingSampleAsync();&#xA;    Task&amp;lt;ServerStreamingResult&amp;lt;string&amp;gt;&amp;gt; ServerStreamingSampleAsync(int x, int y, int z);&#xA;    Task&amp;lt;DuplexStreamingResult&amp;lt;int, string&amp;gt;&amp;gt; DuplexStreamingSampleAsync();&#xA;}&#xA;&#xA;// Server&#xA;public class MyFirstService : ServiceBase&amp;lt;IMyFirstService&amp;gt;, IMyFirstService&#xA;{&#xA;    // VisualStudio 2017(C# 7.0), Unity 2018.3+ supports return `async UnaryResult` directly&#xA;    // I recommend disable async-warning on project level. &amp;lt;NoWarn&amp;gt;1998&amp;lt;/NoWarn&amp;gt;&#xA;    public async UnaryResult&amp;lt;string&amp;gt; SumAsync(int x, int y)&#xA;    {&#xA;        Logger.Debug($&#34;Called SumAsync - x:{x} y:{y}&#34;);&#xA;&#xA;        return (x + y).ToString();&#xA;    }&#xA;&#xA;    // VS2015(C# 6.0), Unity 2018.2 use Task&#xA;    public async Task&amp;lt;UnaryResult&amp;lt;string&amp;gt;&amp;gt; SumLegacyTaskAsync(int x, int y)&#xA;    {&#xA;        Logger.Debug($&#34;Called SumAsync - x:{x} y:{y}&#34;);&#xA;&#xA;        // use UnaryResult method.&#xA;        return UnaryResult((x + y).ToString());&#xA;    }&#xA;&#xA;    public async Task&amp;lt;ClientStreamingResult&amp;lt;int, string&amp;gt;&amp;gt; ClientStreamingSampleAsync()&#xA;    {&#xA;        Logger.Debug($&#34;Called ClientStreamingSampleAsync&#34;);&#xA;&#xA;        // If ClientStreaming, use GetClientStreamingContext.&#xA;        var stream = GetClientStreamingContext&amp;lt;int, string&amp;gt;();&#xA;&#xA;        // receive from client asynchronously&#xA;        await foreach (var x in stream.ReadAllAsync())&#xA;        {&#xA;            Logger.Debug(&#34;Client Stream Received:&#34; + x);&#xA;        }&#xA;&#xA;        // StreamingContext.Result() for result value.&#xA;        return stream.Result(&#34;finished&#34;);&#xA;    }&#xA;&#xA;    public async Task&amp;lt;ServerStreamingResult&amp;lt;string&amp;gt;&amp;gt; ServerStreamingSampleAsync(int x, int y, int z)&#xA;    {&#xA;        Logger.Debug($&#34;Called ServerStreamingSampleAsync - x:{x} y:{y} z:{z}&#34;);&#xA;&#xA;        var stream = GetServerStreamingContext&amp;lt;string&amp;gt;();&#xA;&#xA;        var acc = 0;&#xA;        for (int i = 0; i &amp;lt; z; i++)&#xA;        {&#xA;            acc = acc + x + y;&#xA;            await stream.WriteAsync(acc.ToString());&#xA;        }&#xA;&#xA;        return stream.Result();&#xA;    }&#xA;&#xA;    public async Task&amp;lt;DuplexStreamingResult&amp;lt;int, string&amp;gt;&amp;gt; DuplexStreamingSampleAsync()&#xA;    {&#xA;        Logger.Debug($&#34;Called DuplexStreamingSampleAsync&#34;);&#xA;&#xA;        // DuplexStreamingContext represents both server and client streaming.&#xA;        var stream = GetDuplexStreamingContext&amp;lt;int, string&amp;gt;();&#xA;&#xA;        var waitTask = Task.Run(async () =&amp;gt;&#xA;        {&#xA;            // ForEachAsync(MoveNext, Current) can receive client streaming.&#xA;            await foreach (var x in stream.ReadAllAsync())&#xA;            {&#xA;                Logger.Debug($&#34;Duplex Streaming Received:&#34; + x);&#xA;            }&#xA;        });&#xA;&#xA;        // WriteAsync is ServerStreaming.&#xA;        await stream.WriteAsync(&#34;test1&#34;);&#xA;        await stream.WriteAsync(&#34;test2&#34;);&#xA;        await stream.WriteAsync(&#34;finish&#34;);&#xA;&#xA;        await waitTask;&#xA;&#xA;        return stream.Result();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Client sample.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;static async Task UnaryRun(IMyFirstService client)&#xA;{&#xA;    // await(C# 7.0, Unity 2018.3+)&#xA;    var vvvvv = await client.SumAsync(10, 20);&#xA;    Console.WriteLine(&#34;SumAsync:&#34; + vvvvv);&#xA;    &#xA;    // if use Task&amp;lt;UnaryResult&amp;gt;(Unity 2018.2), use await await&#xA;    var vvvv2 = await await client.SumLegacyTaskAsync(10, 20);&#xA;}&#xA;&#xA;static async Task ClientStreamRun(IMyFirstService client)&#xA;{&#xA;    var stream = await client.ClientStreamingSampleAsync();&#xA;&#xA;    for (int i = 0; i &amp;lt; 3; i++)&#xA;    {&#xA;        await stream.RequestStream.WriteAsync(i);&#xA;    }&#xA;    await stream.RequestStream.CompleteAsync();&#xA;&#xA;    var response = await stream.ResponseAsync;&#xA;&#xA;    Console.WriteLine(&#34;Response:&#34; + response);&#xA;}&#xA;&#xA;static async Task ServerStreamRun(IMyFirstService client)&#xA;{&#xA;    var stream = await client.ServerStreamingSampleAsync(10, 20, 3);&#xA;&#xA;    await foreach (var x in stream.ResponseStream.ReadAllAsync())&#xA;    {&#xA;        Console.WriteLine(&#34;ServerStream Response:&#34; + x);&#xA;    }&#xA;}&#xA;&#xA;static async Task DuplexStreamRun(IMyFirstService client)&#xA;{&#xA;    var stream = await client.DuplexStreamingSampleAsync();&#xA;&#xA;    var count = 0;&#xA;    await foreach (var x in stream.ResponseStream.ReadAllAsync())&#xA;    {&#xA;        Console.WriteLine(&#34;DuplexStream Response:&#34; + x);&#xA;&#xA;        await stream.RequestStream.WriteAsync(count++);&#xA;        if (x == &#34;finish&#34;)&#xA;        {&#xA;            await stream.RequestStream.CompleteAsync();&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Zero deserialization mapping&lt;/h3&gt; &#xA;&lt;p&gt;In RPC, especially in real-time communication involving frequent transmission of data, it is often the serialization process where data is converted before being sent that limits the performance. In MagicOnion, serialization is done by my MessagePack for C#, which is the fastest binary serializer for C#, so it cannot be a limiting factor. Also, in addition to performance, it also provides flexibility regarding data in that variables of any type can be sent as long as they can be serialized by MessagePack for C#.&lt;/p&gt; &#xA;&lt;p&gt;Also, taking advantage of the fact that both the client and the server run on C# and data stored on internal memory are expected to share the same layout, I added an option to do mapping through memory copy without serialization/deserialization in case of a value-type variable.&lt;/p&gt; &#xA;&lt;p&gt;Especially in Unity, this is can combinate with &lt;code&gt;MessagePack.UnityShims&lt;/code&gt; package of NuGet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// It supports standard struct-type variables that are provided by Unity, such as Vector3, and arrays containing them, as well as custom struct-type variables and their arrays.&#xA;// I recommend doing this explicitly using [StructLayout(LayoutKind.Explicit)] to accurately match the size.&#xA;public struct CustomStruct&#xA;{&#xA;    public long Id;&#xA;    public int Hp;&#xA;    public int Mp;&#xA;    public byte Status;&#xA;}&#xA; &#xA;// ---- Register the following code when initializing.&#xA; &#xA;// By registering it, T and T[] can be handled using zero deserialization mapping.&#xA;UnsafeDirectBlitResolver.Register&amp;lt;CustomStruct&amp;gt;();&#xA; &#xA;// The struct-type above as well as Unity-provided struct-types (Vector2, Rect, etc.), and their arrays are registered as standards.&#xA;CompositeResolver.RegisterAndSetAsDefault(&#xA;    UnsafeDirectBlitResolver.Instance,&#xA;    MessagePack.Unity.Extension.UnityBlitResolver.Instance&#xA;    );&#xA; &#xA;// --- Now the communication will be in the format above when they are used for transmission.&#xA;await client.SendAsync(new CustomStruct { Hp = 99 });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nothing needs to be processed here, so it promises the best performance theoretically possible in terms of transmission speed. However, since these struct-type variables need to be copied, I recommend handling everything as ref as a rule when you need to define a large struct-type, or it might slow down the process.&lt;/p&gt; &#xA;&lt;p&gt;I believe that this can be easily and effectively applied to sending a large number of Transforms, such as an array of Vector3 variables.&lt;/p&gt; &#xA;&lt;h2&gt;Experimentals&lt;/h2&gt; &#xA;&lt;h3&gt;OpenTelemetry&lt;/h3&gt; &#xA;&lt;p&gt;MagicOnion.OpenTelemetry is implementation of &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-dotnet&#34;&gt;open-telemetry/opentelemetry-dotnet: OpenTelemetry .NET SDK&lt;/a&gt;, so you can use any OpenTelemetry exporter, like &lt;a href=&#34;https://www.jaegertracing.io/&#34;&gt;Jaeger&lt;/a&gt;, &lt;a href=&#34;https://zipkin.io/&#34;&gt;Zipkin&lt;/a&gt;, &lt;a href=&#34;https://cloud.google.com/stackdriver&#34;&gt;StackDriver&lt;/a&gt; and others.&lt;/p&gt; &#xA;&lt;p&gt;See details at &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MagicOnion/master/src/MagicOnion.Server.OpenTelemetry&#34;&gt;MagicOnion.Server.OpenTelemetry&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is under the MIT License.&lt;/p&gt;</summary>
  </entry>
</feed>