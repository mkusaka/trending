<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-15T01:31:18Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mgth/LittleBigMouse</title>
    <updated>2022-11-15T01:31:18Z</updated>
    <id>tag:github.com,2022-11-15:/mgth/LittleBigMouse</id>
    <link href="https://github.com/mgth/LittleBigMouse" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DPI Aware mouse move across screens&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LittleBigMouse&lt;/h1&gt; &#xA;&lt;p&gt;DPI Aware mouse move across screens for Windows 10&lt;/p&gt; &#xA;&lt;p&gt;Allows accurate mouse screen crossover location within multi dpi monitors environment. It is typically useful when using a 4k monitor and a full HD side by side.&lt;/p&gt; &#xA;&lt;p&gt;Downloadable compiled version : &lt;a href=&#34;https://github.com/mgth/LittleBigMouse/releases&#34;&gt;https://github.com/mgth/LittleBigMouse/releases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please find a very small doc in the Wiki : &lt;a href=&#34;https://github.com/mgth/LittleBigMouse/wiki&#34;&gt;https://github.com/mgth/LittleBigMouse/wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If people wants to participate with feedback or new ideas you&#39;re welcome. I really need beta testers now to provide a stable tool.&lt;/p&gt; &#xA;&lt;p&gt;contens code from :&lt;/p&gt; &#xA;&lt;p&gt;MouseKeyboardActivityMonitor &lt;a href=&#34;https://globalmousekeyhook.codeplex.com/documentation&#34;&gt;https://globalmousekeyhook.codeplex.com/documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;and&lt;/p&gt; &#xA;&lt;p&gt;Task Scheduler Managed Wrapper &lt;a href=&#34;https://taskscheduler.codeplex.com/&#34;&gt;https://taskscheduler.codeplex.com/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Donation&lt;/h2&gt; &#xA;&lt;p&gt;If this project help you, you can give me a cup of coffee :) &lt;a href=&#34;https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;amp;business=YLGYPSHWTQ5UW&amp;amp;lc=FR&amp;amp;item_name=Mgth&amp;amp;currency_code=EUR&amp;amp;bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Donate-PayPal-green.svg?sanitize=true&#34; alt=&#34;Donate&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>davidfowl/TodoApi</title>
    <updated>2022-11-15T01:31:18Z</updated>
    <id>tag:github.com,2022-11-15:/davidfowl/TodoApi</id>
    <link href="https://github.com/davidfowl/TodoApi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ASP.NET Core API with JWT authentication and authorization&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Todo REST API with ASP.NET Core&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/davidfowl/TodoApi/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://github.com/davidfowl/TodoApi/actions/workflows/ci.yaml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Todo REST API samples using ASP.NET Core minimal APIs. It showcases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using EntityFramework and SQLite for data access&lt;/li&gt; &#xA; &lt;li&gt;JWT authentication&lt;/li&gt; &#xA; &lt;li&gt;OpenAPI support&lt;/li&gt; &#xA; &lt;li&gt;Rate Limiting&lt;/li&gt; &#xA; &lt;li&gt;Writing tests for your REST API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;h3&gt;.NET&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dotnet.microsoft.com/en-us/download&#34;&gt;Install .NET 7&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Database&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install the &lt;strong&gt;dotnet-ef&lt;/strong&gt; tool: &lt;code&gt;dotnet tool install dotnet-ef -g&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Navigate to the TodoApi folder and run &lt;code&gt;dotnet ef database update&lt;/code&gt; to create the database.&lt;/li&gt; &#xA; &lt;li&gt;Learn more about &lt;a href=&#34;https://learn.microsoft.com/en-us/ef/core/cli/dotnet&#34;&gt;dotnet-ef&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;dotnet user-jwts create --claim id=myid&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;You should be able to use this JWT token to make requests to the endpoint&lt;/li&gt; &#xA; &lt;li&gt;Learn more about &lt;a href=&#34;https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/security?view=aspnetcore-7.0#using-dotnet-user-jwts-to-improve-development-time-testing&#34;&gt;user-jwts&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>brminnick/AsyncAwaitBestPractices</title>
    <updated>2022-11-15T01:31:18Z</updated>
    <id>tag:github.com,2022-11-15:/brminnick/AsyncAwaitBestPractices</id>
    <link href="https://github.com/brminnick/AsyncAwaitBestPractices" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extensions for System.Threading.Tasks.Task and System.Threading.Tasks.ValueTask&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AsyncAwaitBestPractices&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://brminnick.visualstudio.com/AsyncAwaitBestPractices/_build/latest?definitionId=8&amp;amp;branchName=main&#34;&gt;&lt;img src=&#34;https://brminnick.visualstudio.com/AsyncAwaitBestPractices/_apis/build/status/brminnick.AsyncAwaitBestPractices?branchName=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Extensions for &lt;code&gt;System.Threading.Tasks.Task&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Inspired by &lt;a href=&#34;https://github.com/johnthiriet&#34;&gt;John Thiriet&lt;/a&gt;&#39;s blog posts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://johnthiriet.com/removing-async-void/&#34;&gt;Removing Async Void&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://johnthiriet.com/mvvm-going-async-with-async-command/&#34;&gt;MVVM - Going Async With AsyncCommand&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;AsyncAwaitBestPractices&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/AsyncAwaitBestPractices/&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/AsyncAwaitBestPractices?includePreReleases=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Available on NuGet: &lt;a href=&#34;https://www.nuget.org/packages/AsyncAwaitBestPractices/&#34;&gt;https://www.nuget.org/packages/AsyncAwaitBestPractices/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SafeFireAndForget&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;An extension method to safely fire-and-forget a &lt;code&gt;Task&lt;/code&gt; or a &lt;code&gt;ValueTask&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Ensures the &lt;code&gt;Task&lt;/code&gt; will rethrow an &lt;code&gt;Exception&lt;/code&gt; if an &lt;code&gt;Exception&lt;/code&gt; is caught in &lt;code&gt;IAsyncStateMachine.MoveNext()&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;WeakEventManager&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Avoids memory leaks when events are not unsubscribed&lt;/li&gt; &#xA;   &lt;li&gt;Used by &lt;code&gt;AsyncCommand&lt;/code&gt;, &lt;code&gt;AsyncCommand&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;AsyncValueCommand&lt;/code&gt;, &lt;code&gt;AsyncValueCommand&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/brminnick/AsyncAwaitBestPractices/main/#asyncawaitbestpractices-3&#34;&gt;Usage instructions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;AsyncAwaitBestPractices.MVVM&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/AsyncAwaitBestPractices.MVVM/&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/AsyncAwaitBestPractices.MVVM?includePreReleases=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Available on NuGet: &lt;a href=&#34;https://www.nuget.org/packages/AsyncAwaitBestPractices.MVVM/&#34;&gt;https://www.nuget.org/packages/AsyncAwaitBestPractices.MVVM/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Allows for &lt;code&gt;Task&lt;/code&gt; to safely be used asynchronously with &lt;code&gt;ICommand&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;IAsyncCommand : ICommand&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AsyncCommand : IAsyncCommand&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;IAsyncCommand&amp;lt;T&amp;gt; : ICommand&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AsyncCommand&amp;lt;T&amp;gt; : IAsyncCommand&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;IAsyncCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncCommand&amp;lt;TExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AsyncCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncCommand&amp;lt;TExecute, TCanExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Allows for &lt;code&gt;ValueTask&lt;/code&gt; to safely be used asynchronously with &lt;code&gt;ICommand&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;IAsyncValueCommand : ICommand&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AsyncValueCommand : IAsyncValueCommand&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;IAsyncValueCommand&amp;lt;T&amp;gt; : ICommand&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AsyncValueCommand&amp;lt;T&amp;gt; : IAsyncValueCommand&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;IAsyncValueCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncValueCommand&amp;lt;TExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AsyncValueCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncValueCommand&amp;lt;TExecute, TCanExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/brminnick/AsyncAwaitBestPractices/main/#asyncawaitbestpracticesmvvm-2&#34;&gt;Usage instructions&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;h3&gt;AsyncAwaitBestPractices&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Available on NuGet: &lt;a href=&#34;https://www.nuget.org/packages/AsyncAwaitBestPractices/&#34;&gt;https://www.nuget.org/packages/AsyncAwaitBestPractices/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add to any project supporting .NET Standard 1.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;AsyncAwaitBestPractices.MVVM&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Available on NuGet: &lt;a href=&#34;https://www.nuget.org/packages/AsyncAwaitBestPractices.MVVM/&#34;&gt;https://www.nuget.org/packages/AsyncAwaitBestPractices.MVVM/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add to any project supporting .NET Standard 1.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why Do I Need This?&lt;/h2&gt; &#xA;&lt;h3&gt;Podcasts&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nodogmapodcast.bryanhogan.net&#34;&gt;No Dogma Podcast&lt;/a&gt;, Hosted by &lt;a href=&#34;https://twitter.com/bryanjhogan&#34;&gt;Bryan Hogan&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nodogmapodcast.bryanhogan.net/133-brandon-minnick-async-await-common-mistakes-part-1/&#34;&gt;Episode #133 Brandon Minnick, Async Await – Common Mistakes, Part 1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nodogmapodcast.bryanhogan.net/134-brandon-minnick-async-await-common-mistakes-part-2/&#34;&gt;Episode #134 Brandon Minnick, Async Await – Common Mistakes, Part 2&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Video&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;NDC Oslo 2019&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=J0mcYVxJEl0&#34;&gt;Correcting Common Async Await Mistakes in .NET&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=J0mcYVxJEl0&#34; title=&#34;Correcting Common Async Await Mistakes in .NET&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/13558917/62509892-a32a8a00-b7d2-11e9-9460-267220838b76.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Explaination&lt;/h3&gt; &#xA;&lt;p&gt;Async/await is great &lt;em&gt;but&lt;/em&gt; there are two subtle problems that can easily creep into code:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Creating race conditions/concurrent execution (where you code things in the right order but the code executes in a different order than you expect)&lt;/li&gt; &#xA; &lt;li&gt;Creating methods where the compiler recognizes exceptions but you the coder never see them (making it head-scratchingly annoying to debug &lt;em&gt;especially&lt;/em&gt; if you accidentally introduced a race condition that you can’t see).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This library solves both of these problems.&lt;/p&gt; &#xA;&lt;p&gt;To better understand why this library was created and the problem it solves, it’s important to first understand how the compiler generates code for an async method.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt; A non-awaited &lt;code&gt;Task&lt;/code&gt; doesn&#39;t rethrow exceptions and &lt;code&gt;AsyncAwaitBestPractices.SafeFireAndForget&lt;/code&gt; ensures it will&lt;/p&gt; &#xA;&lt;h2&gt;Compiler-Generated Code for Async Method&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.stack.imgur.com/c9im1.png&#34; alt=&#34;Compiler-Generated Code for Async Method&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;(Source: &lt;a href=&#34;https://github.com/XamarinUniversity/CSC350&#34;&gt;Xamarin University: &lt;em&gt;Using Async and Await&lt;/em&gt;&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;The compiler transforms an &lt;code&gt;async&lt;/code&gt; method into an &lt;code&gt;IAsyncStateMachine&lt;/code&gt; class which allows the .NET Runtime to &#34;remember&#34; what the method has accomplished.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.stack.imgur.com/JsmG1.png&#34; alt=&#34;Move Next&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;(Source: &lt;a href=&#34;https://github.com/XamarinUniversity/CSC350&#34;&gt;Xamarin University: &lt;em&gt;Using Async and Await&lt;/em&gt;&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;IAsyncStateMachine&lt;/code&gt; interface implements &lt;code&gt;MoveNext()&lt;/code&gt;, a method the executes every time the &lt;code&gt;await&lt;/code&gt; operator is used inside of the &lt;code&gt;async&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MoveNext()&lt;/code&gt; essentially runs your code until it reaches an &lt;code&gt;await&lt;/code&gt; statement, then it &lt;code&gt;return&lt;/code&gt;s while the &lt;code&gt;await&lt;/code&gt;&#39;d method executes. This is the mechanism that allows the current method to &#34;pause&#34;, yielding its thread execution to another thread/Task.&lt;/p&gt; &#xA;&lt;h3&gt;Try/Catch in &lt;code&gt;MoveNext()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Look closely at &lt;code&gt;MoveNext()&lt;/code&gt;; notice that it is wrapped in a &lt;code&gt;try/catch&lt;/code&gt; block.&lt;/p&gt; &#xA;&lt;p&gt;Because the compiler creates &lt;code&gt;IAsyncStateMachine&lt;/code&gt; for every &lt;code&gt;async&lt;/code&gt; method and &lt;code&gt;MoveNext()&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; wrapped in a &lt;code&gt;try/catch&lt;/code&gt;, every exception thrown inside of an &lt;code&gt;async&lt;/code&gt; method is caught!&lt;/p&gt; &#xA;&lt;h2&gt;How to Rethrow an Exception Caught By &lt;code&gt;MoveNext&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Now we see that the &lt;code&gt;async&lt;/code&gt; method catches every exception thrown - that is to say, the exception is caught internally by the state machine, &lt;em&gt;but&lt;/em&gt; you the coder will not see it. In order for you to see it, you&#39;ll need to rethrow the exception to surface it in your debugging. So the questions is - how do I rethrow the exception?&lt;/p&gt; &#xA;&lt;p&gt;There are a few ways to rethrow exceptions that are thrown in an &lt;code&gt;async&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;await&lt;/code&gt; keyword &lt;em&gt;(Prefered)&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;e.g. &lt;code&gt;await DoSomethingAsync()&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;.GetAwaiter().GetResult()&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;e.g. &lt;code&gt;DoSomethingAsync().GetAwaiter().GetResult()&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The &lt;code&gt;await&lt;/code&gt; keyword is preferred because &lt;code&gt;await&lt;/code&gt; allows the &lt;code&gt;Task&lt;/code&gt; to run asynchronously on a different thread, and it will not lock-up the current thread.&lt;/p&gt; &#xA;&lt;h3&gt;What About &lt;code&gt;.Result&lt;/code&gt; or &lt;code&gt;.Wait()&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;Never, never, never, never, never use &lt;code&gt;.Result&lt;/code&gt; or &lt;code&gt;.Wait()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Both &lt;code&gt;.Result&lt;/code&gt; and &lt;code&gt;.Wait()&lt;/code&gt; will lock-up the current thread. If the current thread is the Main Thread (also known as the UI Thread), your UI will freeze until the &lt;code&gt;Task&lt;/code&gt; has completed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.Result&lt;/code&gt; or &lt;code&gt;.Wait()&lt;/code&gt; rethrow your exception as a &lt;code&gt;System.AggregateException&lt;/code&gt;, which makes it difficult to find the actual exception.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;AsyncAwaitBestPractices&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;SafeFireAndForget&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;An extension method to safely fire-and-forget a &lt;code&gt;Task&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;SafeFireAndForget&lt;/code&gt; allows a Task to safely run on a different thread while the calling thread does not wait for its completion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static async void SafeFireAndForget(this System.Threading.Tasks.Task task, System.Action&amp;lt;System.Exception&amp;gt;? onException = null, bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static async void SafeFireAndForget(this System.Threading.Tasks.ValueTask task, System.Action&amp;lt;System.Exception&amp;gt;? onException = null, bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Basic Usage - Task&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void HandleButtonTapped(object sender, EventArgs e)&#xA;{&#xA;    // Allows the async Task method to safely run on a different thread while the calling thread continues, not awaiting its completion&#xA;    // onException: If an Exception is thrown, print it to the Console&#xA;    ExampleAsyncMethod().SafeFireAndForget(onException: ex =&amp;gt; Console.WriteLine(ex));&#xA;&#xA;    // HandleButtonTapped continues execution here while `ExampleAsyncMethod()` is running on a different thread&#xA;    // ...&#xA;}&#xA;&#xA;async Task ExampleAsyncMethod()&#xA;{&#xA;    await Task.Delay(1000);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Basic Usage - ValueTask&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re new to ValueTask, check out this great write-up, &lt;a href=&#34;https://blogs.msdn.microsoft.com/dotnet/2018/11/07/understanding-the-whys-whats-and-whens-of-valuetask?WT.mc_id=mobile-0000-bramin&#34;&gt;Understanding the Whys, Whats, and Whens of ValueTask &lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void HandleButtonTapped(object sender, EventArgs e)&#xA;{&#xA;    // Allows the async ValueTask method to safely run on a different thread while the calling thread continues, not awaiting its completion&#xA;    // onException: If an Exception is thrown, print it to the Console&#xA;    ExampleValueTaskMethod().SafeFireAndForget(onException: ex =&amp;gt; Console.WriteLine(ex));&#xA;&#xA;    // HandleButtonTapped continues execution here while `ExampleAsyncMethod()` is running on a different thread&#xA;    // ...&#xA;}&#xA;&#xA;async ValueTask ExampleValueTaskMethod()&#xA;{&#xA;    var random = new Random();&#xA;    if (random.Next(10) &amp;gt; 9)&#xA;        await Task.Delay(1000);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Advanced Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void InitializeSafeFireAndForget()&#xA;{&#xA;    // Initialize SafeFireAndForget&#xA;    // Only use `shouldAlwaysRethrowException: true` when you want `.SafeFireAndForget()` to always rethrow every exception. This is not recommended, because there is no way to catch an Exception rethrown by `SafeFireAndForget()`; `shouldAlwaysRethrowException: true` should **not** be used in Production/Release builds.&#xA;    SafeFireAndForgetExtensions.Initialize(shouldAlwaysRethrowException: false);&#xA;&#xA;    // SafeFireAndForget will print every exception to the Console&#xA;    SafeFireAndForgetExtensions.SetDefaultExceptionHandling(ex =&amp;gt; Console.WriteLine(ex));&#xA;}&#xA;&#xA;void UninitializeSafeFireAndForget()&#xA;{&#xA;    // Remove default exception handling&#xA;    SafeFireAndForgetExtensions.RemoveDefaultExceptionHandling();&#xA;}&#xA;&#xA;void HandleButtonTapped(object sender, EventArgs e)&#xA;{&#xA;    // Allows the async Task method to safely run on a different thread while not awaiting its completion&#xA;    // onException: If a WebException is thrown, print its StatusCode to the Console. **Note**: If a non-WebException is thrown, it will not be handled by `onException`&#xA;    // Because we set `SetDefaultExceptionHandling` in `void InitializeSafeFireAndForget()`, the entire exception will also be printed to the Console&#xA;    ExampleAsyncMethod().SafeFireAndForget&amp;lt;WebException&amp;gt;(onException: ex =&amp;gt;&#xA;    {&#xA;        if(ex.Response is HttpWebResponse webResponse)&#xA;            Console.WriteLine($&#34;Task Exception\n Status Code: {webResponse.StatusCode}&#34;);&#xA;    });&#xA;    &#xA;    ExampleValueTaskMethod().SafeFireAndForget&amp;lt;WebException&amp;gt;(onException: ex =&amp;gt;&#xA;    {&#xA;        if(ex.Response is HttpWebResponse webResponse)&#xA;            Console.WriteLine($&#34;ValueTask Error\n Status Code: {webResponse.StatusCode}&#34;);&#xA;    });&#xA;&#xA;    // HandleButtonTapped continues execution here while `ExampleAsyncMethod()` and `ExampleValueTaskMethod()` run in the background&#xA;}&#xA;&#xA;async Task ExampleAsyncMethod()&#xA;{&#xA;    await Task.Delay(1000);&#xA;    throw new WebException();&#xA;}&#xA;&#xA;async ValueTask ExampleValueTaskMethod()&#xA;{&#xA;    var random = new Random();&#xA;    if (random.Next(10) &amp;gt; 9)&#xA;        await Task.Delay(1000);&#xA;        &#xA;    throw new WebException();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;WeakEventManager&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;An event implementation that enables the &lt;a href=&#34;http://paulstovell.com/blog/weakevents&#34;&gt;garbage collector to collect an object without needing to unsubscribe event handlers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Inspired by &lt;a href=&#34;https://github.com/xamarin/Xamarin.Forms/raw/master/Xamarin.Forms.Core/WeakEventManager.cs&#34;&gt;Xamarin.Forms.WeakEventManager&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Using &lt;code&gt;EventHandler&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;readonly WeakEventManager _canExecuteChangedEventManager = new WeakEventManager();&#xA;&#xA;public event EventHandler CanExecuteChanged&#xA;{&#xA;    add =&amp;gt; _canExecuteChangedEventManager.AddEventHandler(value);&#xA;    remove =&amp;gt; _canExecuteChangedEventManager.RemoveEventHandler(value);&#xA;}&#xA;&#xA;void OnCanExecuteChanged() =&amp;gt; _canExecuteChangedEventManager.RaiseEvent(this, EventArgs.Empty, nameof(CanExecuteChanged));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using &lt;code&gt;Delegate&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;readonly WeakEventManager _propertyChangedEventManager = new WeakEventManager();&#xA;&#xA;public event PropertyChangedEventHandler PropertyChanged&#xA;{&#xA;    add =&amp;gt; _propertyChangedEventManager.AddEventHandler(value);&#xA;    remove =&amp;gt; _propertyChangedEventManager.RemoveEventHandler(value);&#xA;}&#xA;&#xA;void OnPropertyChanged([CallerMemberName]string propertyName = &#34;&#34;) =&amp;gt; _propertyChangedEventManager.RaiseEvent(this, new PropertyChangedEventArgs(propertyName), nameof(PropertyChanged));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using &lt;code&gt;Action&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;readonly WeakEventManager _weakActionEventManager = new WeakEventManager();&#xA;&#xA;public event Action ActionEvent&#xA;{&#xA;    add =&amp;gt; _weakActionEventManager.AddEventHandler(value);&#xA;    remove =&amp;gt; _weakActionEventManager.RemoveEventHandler(value);&#xA;}&#xA;&#xA;void OnActionEvent(string message) =&amp;gt; _weakActionEventManager.RaiseEvent(message, nameof(ActionEvent));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;WeakEventManager&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;An event implementation that enables the &lt;a href=&#34;http://paulstovell.com/blog/weakevents&#34;&gt;garbage collector to collect an object without needing to unsubscribe event handlers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Inspired by &lt;a href=&#34;https://github.com/xamarin/Xamarin.Forms/raw/master/Xamarin.Forms.Core/WeakEventManager.cs&#34;&gt;Xamarin.Forms.WeakEventManager&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Using &lt;code&gt;EventHandler&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;readonly WeakEventManager&amp;lt;string&amp;gt; _errorOcurredEventManager = new WeakEventManager&amp;lt;string&amp;gt;();&#xA;&#xA;public event EventHandler&amp;lt;string&amp;gt; ErrorOcurred&#xA;{&#xA;    add =&amp;gt; _errorOcurredEventManager.AddEventHandler(value);&#xA;    remove =&amp;gt; _errorOcurredEventManager.RemoveEventHandler(value);&#xA;}&#xA;&#xA;void OnErrorOcurred(string message) =&amp;gt; _errorOcurredEventManager.RaiseEvent(this, message, nameof(ErrorOcurred));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using &lt;code&gt;Action&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;readonly WeakEventManager&amp;lt;string&amp;gt; _weakActionEventManager = new WeakEventManager&amp;lt;string&amp;gt;();&#xA;&#xA;public event Action&amp;lt;string&amp;gt; ActionEvent&#xA;{&#xA;    add =&amp;gt; _weakActionEventManager.AddEventHandler(value);&#xA;    remove =&amp;gt; _weakActionEventManager.RemoveEventHandler(value);&#xA;}&#xA;&#xA;void OnActionEvent(string message) =&amp;gt; _weakActionEventManager.RaiseEvent(message, nameof(ActionEvent));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;AsyncAwaitBestPractices.MVVM&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;AsyncCommand&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Allows for &lt;code&gt;Task&lt;/code&gt; to safely be used asynchronously with &lt;code&gt;ICommand&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncCommand&amp;lt;TExecute, TCanExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IAsyncCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncCommand&amp;lt;TExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncCommand&amp;lt;T&amp;gt; : IAsyncCommand&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IAsyncCommand&amp;lt;T&amp;gt; : ICommand&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncCommand : IAsyncCommand&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IAsyncCommand : ICommand&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public AsyncCommand(Func&amp;lt;TExecute, Task&amp;gt; execute,&#xA;                     Func&amp;lt;TCanExecute, bool&amp;gt;? canExecute = null,&#xA;                     Action&amp;lt;Exception&amp;gt;? onException = null,&#xA;                     bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public AsyncCommand(Func&amp;lt;T, Task&amp;gt; execute,&#xA;                     Func&amp;lt;object?, bool&amp;gt;? canExecute = null,&#xA;                     Action&amp;lt;Exception&amp;gt;? onException = null,&#xA;                     bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public AsyncCommand(Func&amp;lt;Task&amp;gt; execute,&#xA;                     Func&amp;lt;object?, bool&amp;gt;? canExecute = null,&#xA;                     Action&amp;lt;Exception&amp;gt;? onException = null,&#xA;                     bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class ExampleClass&#xA;{&#xA;    bool _isBusy;&#xA;&#xA;    public ExampleClass()&#xA;    {&#xA;        ExampleAsyncCommand = new AsyncCommand(ExampleAsyncMethod);&#xA;        ExampleAsyncIntCommand = new AsyncCommand&amp;lt;int&amp;gt;(ExampleAsyncMethodWithIntParameter);&#xA;        ExampleAsyncIntCommandWithCanExecute = new AsyncCommand&amp;lt;int, int&amp;gt;(ExampleAsyncMethodWithIntParameter, CanExecuteInt);&#xA;        ExampleAsyncExceptionCommand = new AsyncCommand(ExampleAsyncMethodWithException, onException: ex =&amp;gt; Console.WriteLine(ex.ToString()));&#xA;        ExampleAsyncCommandWithCanExecuteChanged = new AsyncCommand(ExampleAsyncMethod, _ =&amp;gt; !IsBusy);&#xA;        ExampleAsyncCommandReturningToTheCallingThread = new AsyncCommand(ExampleAsyncMethod, continueOnCapturedContext: true);&#xA;    }&#xA;&#xA;    public IAsyncCommand ExampleAsyncCommand { get; }&#xA;    public IAsyncCommand&amp;lt;int&amp;gt; ExampleAsyncIntCommand { get; }&#xA;    public IAsyncCommand&amp;lt;int, int&amp;gt; ExampleAsyncIntCommandWithCanExecute { get; }&#xA;    public IAsyncCommand ExampleAsyncExceptionCommand { get; }&#xA;    public IAsyncCommand ExampleAsyncCommandWithCanExecuteChanged { get; }&#xA;    public IAsyncCommand ExampleAsyncCommandReturningToTheCallingThread { get; }&#xA;    &#xA;    public bool IsBusy&#xA;    {&#xA;        get =&amp;gt; _isBusy;&#xA;        set&#xA;        {&#xA;            if (_isBusy != value)&#xA;            {&#xA;                _isBusy = value;&#xA;                ExampleAsyncCommandWithCanExecuteChanged.RaiseCanExecuteChanged();&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    async Task ExampleAsyncMethod()&#xA;    {&#xA;        await Task.Delay(1000);&#xA;    }&#xA;  &#xA;    async Task ExampleAsyncMethodWithIntParameter(int parameter)&#xA;    {&#xA;        await Task.Delay(parameter);&#xA;    }&#xA;&#xA;    async Task ExampleAsyncMethodWithException()&#xA;    {&#xA;        await Task.Delay(1000);&#xA;        throw new Exception();&#xA;    }&#xA;&#xA;    bool CanExecuteInt(int count)&#xA;    {&#xA;        if(count &amp;gt; 2)&#xA;            return true;&#xA;        &#xA;        return false;&#xA;    }&#xA;&#xA;    void ExecuteCommands()&#xA;    {&#xA;        _isBusy = true;&#xA;    &#xA;        try&#xA;        {&#xA;            ExampleAsyncCommand.Execute(null);&#xA;            ExampleAsyncIntCommand.Execute(1000);&#xA;            ExampleAsyncExceptionCommand.Execute(null);&#xA;            ExampleAsyncCommandReturningToTheCallingThread.Execute(null);&#xA;            &#xA;            if(ExampleAsyncCommandWithCanExecuteChanged.CanExecute(null))&#xA;                ExampleAsyncCommandWithCanExecuteChanged.Execute(null);&#xA;            &#xA;            if(ExampleAsyncIntCommandWithCanExecute.CanExecute(1))&#xA;                ExampleAsyncIntCommandWithCanExecute.Execute(1);&#xA;        }&#xA;        finally&#xA;        {&#xA;            _isBusy = false;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;AsyncValueCommand&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Allows for &lt;code&gt;ValueTask&lt;/code&gt; to safely be used asynchronously with &lt;code&gt;ICommand&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re new to ValueTask, check out this great write-up, &lt;a href=&#34;https://blogs.msdn.microsoft.com/dotnet/2018/11/07/understanding-the-whys-whats-and-whens-of-valuetask?WT.mc_id=mobile-0000-bramin&#34;&gt;Understanding the Whys, Whats, and Whens of ValueTask &lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncValueCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncValueCommand&amp;lt;TExecute, TCanExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IAsyncValueCommand&amp;lt;TExecute, TCanExecute&amp;gt; : IAsyncValueCommand&amp;lt;TExecute&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncValueCommand&amp;lt;T&amp;gt; : IAsyncValueCommand&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IAsyncValueCommand&amp;lt;T&amp;gt; : ICommand&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncValueCommand : IAsyncValueCommand&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IAsyncValueCommand : ICommand&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public AsyncValueCommand(Func&amp;lt;TExecute, ValueTask&amp;gt; execute,&#xA;                            Func&amp;lt;TCanExecute, bool&amp;gt;? canExecute = null,&#xA;                            Action&amp;lt;Exception&amp;gt;? onException = null,&#xA;                            bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public AsyncValueCommand(Func&amp;lt;T, ValueTask&amp;gt; execute,&#xA;                            Func&amp;lt;object?, bool&amp;gt;? canExecute = null,&#xA;                            Action&amp;lt;Exception&amp;gt;? onException = null,&#xA;                            bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public AsyncValueCommand(Func&amp;lt;ValueTask&amp;gt; execute,&#xA;                            Func&amp;lt;object?, bool&amp;gt;? canExecute = null,&#xA;                            Action&amp;lt;Exception&amp;gt;? onException = null,&#xA;                            bool continueOnCapturedContext = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class ExampleClass&#xA;{&#xA;    bool _isBusy;&#xA;&#xA;    public ExampleClass()&#xA;    {&#xA;        ExampleValueTaskCommand = new AsyncValueCommand(ExampleValueTaskMethod);&#xA;        ExampleValueTaskIntCommand = new AsyncValueCommand&amp;lt;int&amp;gt;(ExampleValueTaskMethodWithIntParameter);&#xA;        ExampleValueTaskIntCommandWithCanExecute = new AsyncValueCommand&amp;lt;int, int&amp;gt;(ExampleValueTaskMethodWithIntParameter, CanExecuteInt);&#xA;        ExampleValueTaskExceptionCommand = new AsyncValueCommand(ExampleValueTaskMethodWithException, onException: ex =&amp;gt; Debug.WriteLine(ex.ToString()));&#xA;        ExampleValueTaskCommandWithCanExecuteChanged = new AsyncValueCommand(ExampleValueTaskMethod, _ =&amp;gt; !IsBusy);&#xA;        ExampleValueTaskCommandReturningToTheCallingThread = new AsyncValueCommand(ExampleValueTaskMethod, continueOnCapturedContext: true);&#xA;    }&#xA;&#xA;    public IAsyncValueCommand ExampleValueTaskCommand { get; }&#xA;    public IAsyncValueCommand&amp;lt;int&amp;gt; ExampleValueTaskIntCommand { get; }&#xA;    public IAsyncCommand&amp;lt;int, int&amp;gt; ExampleValueTaskIntCommandWithCanExecute { get; }&#xA;    public IAsyncValueCommand ExampleValueTaskExceptionCommand { get; }&#xA;    public IAsyncValueCommand ExampleValueTaskCommandWithCanExecuteChanged { get; }&#xA;    public IAsyncValueCommand ExampleValueTaskCommandReturningToTheCallingThread { get; }&#xA;&#xA;    public bool IsBusy&#xA;    {&#xA;        get =&amp;gt; _isBusy;&#xA;        set&#xA;        {&#xA;            if (_isBusy != value)&#xA;            {&#xA;                _isBusy = value;&#xA;                ExampleValueTaskCommandWithCanExecuteChanged.RaiseCanExecuteChanged();&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    async ValueTask ExampleValueTaskMethod()&#xA;    {&#xA;        var random = new Random();&#xA;        if (random.Next(10) &amp;gt; 9)&#xA;            await Task.Delay(1000);&#xA;    }&#xA;&#xA;    async ValueTask ExampleValueTaskMethodWithIntParameter(int parameter)&#xA;    {&#xA;        var random = new Random();&#xA;        if (random.Next(10) &amp;gt; 9)&#xA;            await Task.Delay(parameter);&#xA;    }&#xA;&#xA;    async ValueTask ExampleValueTaskMethodWithException()&#xA;    {&#xA;        var random = new Random();&#xA;        if (random.Next(10) &amp;gt; 9)&#xA;            await Task.Delay(1000);&#xA;&#xA;        throw new Exception();&#xA;    }&#xA;&#xA;    bool CanExecuteInt(int count)&#xA;    {&#xA;        if(count &amp;gt; 2)&#xA;            return true;&#xA;        &#xA;        return false;&#xA;    }&#xA;&#xA;    void ExecuteCommands()&#xA;    {&#xA;        _isBusy = true;&#xA;&#xA;        try&#xA;        {&#xA;            ExampleValueTaskCommand.Execute(null);&#xA;            ExampleValueTaskIntCommand.Execute(1000);&#xA;            ExampleValueTaskExceptionCommand.Execute(null);&#xA;            ExampleValueTaskCommandReturningToTheCallingThread.Execute(null);&#xA;&#xA;            if (ExampleValueTaskCommandWithCanExecuteChanged.CanExecute(null))&#xA;                ExampleValueTaskCommandWithCanExecuteChanged.Execute(null);&#xA;&#xA;            if(ExampleValueTaskIntCommandWithCanExecute.CanExecute(2))&#xA;                ExampleValueTaskIntCommandWithCanExecute.Execute(2);&#xA;        }&#xA;        finally&#xA;        {&#xA;            _isBusy = false;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Learn More&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://johnthiriet.com/removing-async-void/&#34;&gt;Removing Async Void&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://johnthiriet.com/mvvm-going-async-with-async-command/&#34;&gt;MVVM Going Async with Async Command&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/dotnet/csharp/async?WT.mc_id=mobile-0000-bramin&#34;&gt;Asynchronous Programming in .NET&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/dotnet/standard/threading/the-managed-thread-pool?WT.mc_id=mobile-0000-bramin&#34;&gt;The Managed Thread Pool&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/?WT.mc_id=mobile-0000-bramin&#34;&gt;Understanding the Whys, Whats, and Whens of ValueTask&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=yyT6dSjq-nE&amp;amp;feature=youtu.be&#34;&gt;Async/Await Best Practices Video&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/&#34;&gt;What is Synchronization Context?&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>