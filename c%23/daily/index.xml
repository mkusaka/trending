<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-01T01:35:55Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>RonSijm/ButtFish</title>
    <updated>2022-10-01T01:35:55Z</updated>
    <id>tag:github.com,2022-10-01:/RonSijm/ButtFish</id>
    <link href="https://github.com/RonSijm/ButtFish" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Effortlessly transmitting Morse Code of chess moves to your butthole üíù&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ButtFish üçëüêü&lt;/h1&gt; &#xA;&lt;h3&gt;Effortlessly transmitting Morse Code of chess moves to your butthole üíù&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Wait what now?&lt;/h2&gt; &#xA;&lt;p&gt;If you haven&#39;t been following the chess news - (because why would you) - As of the last couple of weeks - (Monday September 5, 2022) there&#39;s been drama going on in the chess world.&lt;/p&gt; &#xA;&lt;p&gt;During the Sinquefield Cup there was a chess match between 5-time world chess champion Magnus Carlsen - (basically the final boss of chess) - and another lower level chess player. No one expected Magnus to lose, but he did. After losing the chess match Magnus Carlsen withdrew from the tournament and posted a tweet saying &#34;I&#39;ve withdrawn from the tournament&#34; and attached a meme video of Jose Mourinho saying &lt;a href=&#34;https://www.youtube.com/watch?v=yogfwJXVBDg&#34;&gt;&#34;I prefer not to speak. If I speak I am in big trouble ‚Ä¶ and I don&#39;t want to be in big trouble.&#34;&lt;/a&gt; - Classic üëå.&lt;/p&gt; &#xA;&lt;p&gt;The tweet was interpreted by the chess community as an accusation of cheating.&lt;/p&gt; &#xA;&lt;p&gt;This chess drama has been ongoing for the last couple weeks with everyone making wild guesses on how the alleged cheating could have been done.&lt;/p&gt; &#xA;&lt;p&gt;The wildest accusation is that the cheating player might have been using a Buttplug - sending him information about the best moves though his butthole&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m not going to name the other player, google it I suppose. So far it hasn&#39;t been proven that he actually cheated, though he has received a lot of backlash already - so I assume this whole drama has been a huge pain in the butt for him already anyways. ü•Å&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;This project is mostly a meme.&lt;/p&gt; &#xA;&lt;p&gt;Firstly I didn&#39;t have much else to do this weekend, so it seemed like a fun thing to implement. I could not find any project making this kind of cheat possible. The closest mention I could find is &lt;a href=&#34;https://incoherency.co.uk/blog/stories/sockfish.html&#34;&gt;Sockfish&lt;/a&gt; - A project by James Stanley where he implemented Stockfish in his shoes (or sock). I&#39;m not entirely sure how he implemented it, or whether his implementation is open sourced.&lt;/p&gt; &#xA;&lt;p&gt;So I started looking into the possibilities and I found the project &lt;a href=&#34;https://buttplug.io/&#34;&gt;Buttplug.io&lt;/a&gt; - the name of this project is not super inclusive of what it actually does - actually it connects to a huge amount of sex toys. &lt;a href=&#34;https://iostindex.com/?filter0Availability=Available,DIY&amp;amp;filter1Connection=Digital&#34;&gt;See a full list here [nswf]&lt;/a&gt;. Other devices include Cockthings, so if you&#39;re not comfortable with putting Stockfish in your butthole, there&#39;s also the possibility of trying this with a Cockthing, and practically you&#39;ll be running &lt;em&gt;CockFish&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Secondly, who else would possibly build this? I&#39;ve created a Venn diagram to illustrate how rare the chances are someone would develop this.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/337928/192335511-f8a3d559-ad29-443b-ab3f-c45125b1e100.png&#34; alt=&#34;venndiagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;As you can see by the diagram, if we&#39;d have to wait for &#34;the chosen one&#34; with interests in all three fields, this project would never exist. So I decided that it should exist, so I made it.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h4&gt;Connectivity&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Discover Yeelight devices on your network&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Manually connect with Yeelight devices on your network though IP or hostname&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Discover Buttplug.io Capable devices on your network&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Manually connect with Buttplug.io Capable devices though remote discover host address&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Main&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Read a Chess FEN string and determine the next best move&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Encode the next best move into Morse Code&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Send the encoded Morse Code to the connected device&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Encoders&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; (default) &lt;a href=&#34;https://github.com/RonSijm/ButtFish/raw/main/RonSijm.ButtFish/Encoders/MorseEncoder.cs&#34;&gt;A text to Morse Encoder&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://github.com/RonSijm/ButtFish/raw/main/RonSijm.ButtFish/Encoders/SimplifiedPulseEncoder.cs&#34;&gt;A simplified Pulse Encoder&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;appsettings.json&lt;/code&gt; -&amp;gt; Encoder -&amp;gt; &#34;SimplifiedPulse&#34;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Config&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; End Position Only [Expert] By just knowing the end position, a serious chess player would know intuitively which piece belongs there. ~ &lt;a href=&#34;https://youtu.be/ifJnWVSoyAY?t=431&#34;&gt;Hikaru&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;appsettings.json&lt;/code&gt; -&amp;gt; EndPositionOnly -&amp;gt; true&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Demo&lt;/h3&gt; &#xA;&lt;h4&gt;Discovery&lt;/h4&gt; &#xA;&lt;p&gt;A demo of discovering devices on the network &lt;img src=&#34;https://user-images.githubusercontent.com/337928/192335028-c3ffd6b0-3b96-49c1-be87-f95cd91a8ede.gif&#34; alt=&#34;discovery&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Manual&lt;/h4&gt; &#xA;&lt;p&gt;A demo of manually entering a Yeelight address &lt;img src=&#34;https://user-images.githubusercontent.com/337928/192335161-9cd095a1-133b-4b0a-930b-e5174c1aa7b5.gif&#34; alt=&#34;manual&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Side by side&lt;/h4&gt; &#xA;&lt;p&gt;A demo of a Yeelight connector running side by side with the application&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/337928/192337315-964201e4-0a23-49bc-8889-a079357967c3.webm&#34;&gt;sidebyside-yeelight.webm&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Setup / Yeelight&lt;/h3&gt; &#xA;&lt;p&gt;To use a Yeelight, you must enable developer mode for your Yeelight. To do so, do the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open Yeelight APP and go to ‚ÄúDevice‚Äù.&lt;/li&gt; &#xA; &lt;li&gt;Select the device you want to use.&lt;/li&gt; &#xA; &lt;li&gt;Enable LAN Control&lt;/li&gt; &#xA; &lt;li&gt;(optional), if network discovery of the Yeelight does not seem to work:)&lt;/li&gt; &#xA; &lt;li&gt;Go to your Yeelight settings in the upper right corner&lt;/li&gt; &#xA; &lt;li&gt;Click Device Info&lt;/li&gt; &#xA; &lt;li&gt;You should now see a field &#34;IP address&#34;. Use the value for manual mode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Data&lt;/h3&gt; &#xA;&lt;p&gt;Example FEN code that I used: &lt;em&gt;&#34;rnb1kbnr/pppp1ppp/8/4p1q1/5P2/4PQ2/PPPP2PP/RNB1KBNR b KQkq - 2 3&#34;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you want to generate a FEN code on chess.com, you can go to a match, click on&amp;nbsp;analysis - which will redirect you to &lt;a href=&#34;https://www.chess.com/analysis&#34;&gt;https://www.chess.com/analysis&lt;/a&gt; with the selected match, and then if you press the share button you will see a FEN code. There might be an easier way to do this, but I don&#39;t know&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;TODO&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;buttplug.io verification&lt;/strong&gt; - Due to not having any buttplugs myself, or other devices compatible with Buttplug.io, I&#39;ve only built this project based on the documentation and samples provided by Buttplug.io. I&#39;m looking to contact some of their people on discord to see if anyone has a device that should work with this project, and verify that it actually works&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;Real world chess match testing&lt;/strong&gt; - The chess world seems to assume that it&#39;s possible to accurately receive chess moves through your butthole, and use this to your advantage and even beat the final chess boss Magnus Carlsen with this. Since this has been a working theory, so far I haven&#39;t seen any attempts to replicate this. Hopefully this project with aid in this endeavor. Unfortunately I can barely play chess, nor understand Morse Code, so hopefully we&#39;ll be able to find some brave chessmaster grandmaster that&#39;s willing to &#39;take one for the team&#39; (in the butt)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;Post vid&lt;/strong&gt; In the spirit of &lt;a href=&#34;https://www.reddit.com/r/WatchPeopleCode/&#34;&gt;WatchPeopleCode&lt;/a&gt; I recorded my development process. I haven&#39;t had time to edit it down and post it. Might if someone is actually interested (probably not)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Testing (buttplug.io verification)&lt;/h3&gt; &#xA;&lt;p&gt;The internet pointed out that I hadn&#39;t actually tested it out with a vibrating device. Also there&#39;s a theory in computer science that &lt;a href=&#34;https://rubberduckdebugging.com/&#34;&gt;every programmer needs a rubby ducky&lt;/a&gt; - &lt;a href=&#34;https://en.wikipedia.org/wiki/Rubber_duck_debugging&#34;&gt;for debugging purposes.&lt;/a&gt;. What I found is close enough&lt;/p&gt; &#xA;&lt;p&gt;After scrolling through the list of compatible Buttplug.io devices, I came across this &lt;a href=&#34;https://www.libotoy.co.uk/designer-toys/carlos-app-remote-control-stimulator&#34;&gt;nonsensical device&lt;/a&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/337928/192588741-dc7f6268-c87f-4890-a335-976910adda0e.png&#34; alt=&#34;ducky&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It reminds me of a real-life representation of the famous internet meme dickbutt.&lt;/p&gt; &#xA;&lt;p&gt;I also don&#39;t have a rubber duck for debugging purposes yet, so I count this as a win-win-win. I ordered this thing, it might take a couple of days to ship.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;re lucky that I&#39;m this dedicated to stupid memes. I&#39;ll let you know how it goes once it arrives&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Donate&lt;/h2&gt; &#xA;&lt;p&gt;I don&#39;t really need your money, but if you feel like donating anything:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Eth: 0xEc4AB6855b2A58F27448c9Bb40E778e4D238FEe2&lt;/li&gt; &#xA; &lt;li&gt;Paypal: &lt;a href=&#34;https://paypal.me/ronsijm&#34;&gt;paypal.me/ronsijm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;I signed up for the github sponsor program, that&#39;s still pending though&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Code of Conduct and Ethics&lt;/h2&gt; &#xA;&lt;p&gt;As mentioned before - this project is a meme. I do not endorse or encourage chess cheating in any way possible. Would you decide to try out this project yourself, you must notify your chess partner in advance that you&#39;re using chess augmentations though vibrations in your butthole.&lt;/p&gt; &#xA;&lt;p&gt;Would you decide not to disclose this in (official) matches, then I&#39;m in no way responsible for the consequences of either you getting banned from chess.com, or pissing off Magnus Carlsen and having him forfeit your matches after a couple of moves&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Coverage and Mentions (incoming)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.vice.com/en/article/5d3w9z/did-hans-neimann-cheat-at-chess-with-a-sex-toy-this-coder-is-attempting-to-find-out&#34;&gt;This project was covered by&lt;/a&gt; &lt;a href=&#34;https://www.vice.com/en/contributor/matthew-gault&#34;&gt;Matthew Gault&lt;/a&gt; a Staff Writer at Motherboard/VICE Media. Initially it was on the front-page of Motherboard, on their front-page together with a live feed of NASA&#39;s DART mission - humanity&#39;s first strike against potential total annihilation by an asteroid in the future.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/337928/192803688-06c840bd-352a-4e12-8c6f-49f187dd21b8.png&#34; alt=&#34;vice-front-page&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Someone is solving possibly the biggest crisis in human history, while the other is just smashing spacecrafts into a space rocks&lt;/p&gt; &#xA;&lt;p&gt;NASA and I have different priorities I suppose...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/337928/192804145-49200e59-77b0-4d8d-b5f0-a9ca11fdfe20.png&#34;&gt;It was also shown on the VICE front-page of World News...&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ifJnWVSoyAY&#34;&gt;Hikaru Nakamura&lt;/a&gt; Five-time U.S. Chess Champion and Chess Meme King himself read the vice article on youtube&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gigazine.net/news/20220929-buttfish/&#34;&gt;Gigazine.net&lt;/a&gt; covered it in Japanese [&lt;a href=&#34;https://gigazine-net.translate.goog/news/20220929-buttfish/?_x_tr_sl=ja&amp;amp;_x_tr_tl=en&#34;&gt;Google translate English&lt;/a&gt;]&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.sohu.com/a/588661192_610300&#34;&gt;Sohu.com&lt;/a&gt; covered it in Chinese [&lt;a href=&#34;https://www-sohu-com.translate.goog/a/588661192_610300?_x_tr_sl=zh-CN&amp;amp;_x_tr_tl=en&amp;amp;_x_tr_hl=en&#34;&gt;Google translate English&lt;/a&gt;] &lt;img src=&#34;https://user-images.githubusercontent.com/337928/193144038-f80dddbb-afd9-40ab-86db-7bff14a20494.png&#34; alt=&#34;Sohucom2&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Library and Mentions (outgoing)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Buttplug.io main website: &lt;a href=&#34;https://buttplug.io&#34;&gt;https://buttplug.io&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Buttplug.io C# library: &lt;a href=&#34;https://github.com/buttplugio/buttplug-rs-ffi/tree/master/csharp&#34;&gt;https://github.com/buttplugio/buttplug-rs-ffi/tree/master/csharp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stockfish main website: &lt;a href=&#34;https://stockfishchess.org&#34;&gt;https://stockfishchess.org&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stockfish C# library: &lt;a href=&#34;https://github.com/Oremiro/Stockfish.NET&#34;&gt;https://github.com/Oremiro/Stockfish.NET&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Yeelight C# library: &lt;a href=&#34;https://github.com/roddone/YeelightAPI&#34;&gt;https://github.com/roddone/YeelightAPI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;ColorfulConsole C# library: &lt;a href=&#34;https://github.com/tomakita/Colorful.Console&#34;&gt;https://github.com/tomakita/Colorful.Console&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Cysharp/MemoryPack</title>
    <updated>2022-10-01T01:35:55Z</updated>
    <id>tag:github.com,2022-10-01:/Cysharp/MemoryPack</id>
    <link href="https://github.com/Cysharp/MemoryPack" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Zero encoding extreme performance binary serializer for C#.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MemoryPack&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Cysharp/MemoryPack/actions&#34;&gt;&lt;img src=&#34;https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg?sanitize=true&#34; alt=&#34;GitHub Actions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Cysharp/MemoryPack/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/Cysharp/MemoryPack.svg?sanitize=true&#34; alt=&#34;Releases&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Zero encoding extreme performance binary serializer for C#.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/192748136-262ac2e7-4646-46e1-afb8-528a51a4a987.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For standard object, MemoryPack is x3 faster than MessagePack for C#. For struct array, MemoryPack gots boosted power, x50~100 faster than other serializers.&lt;/p&gt; &#xA;&lt;p&gt;MemoryPack is my 4th serializer, previously I&#39;ve created well known serializers, &lt;del&gt;&lt;a href=&#34;https://github.com/neuecc/ZeroFormatter&#34;&gt;ZeroFormatter&lt;/a&gt;&lt;/del&gt;, &lt;del&gt;&lt;a href=&#34;https://github.com/neuecc/Utf8Json&#34;&gt;Utf8Json&lt;/a&gt;&lt;/del&gt;, &lt;a href=&#34;https://github.com/neuecc/MessagePack-CSharp&#34;&gt;MessagePack for C#&lt;/a&gt;. The reason for MemoryPack&#39;s speed is due to its C#-specific, C#-optimized binary format and a well tuned implementation based on my past experience. It is also a completely new design utilizing .NET 7 and C# 11 and the Incremental Source Generator.&lt;/p&gt; &#xA;&lt;p&gt;Other serializers performs many encoding operations such as VarInt encoding, tag, UTF8 Encoding, etc. MemoryPack format uses a zero-encoding design that copies as much of the C# memory as possible. zero-encoding is similar as FlatBuffers but don&#39;t need special type, MemoryPack&#39;s serialize target is POCO.&lt;/p&gt; &#xA;&lt;p&gt;Other than performance, MemoryPack has these features.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support modern I/O APIs(&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Native AOT friendly Source Generator based code generation, no Dynamic CodeGen(IL.Emit)&lt;/li&gt; &#xA; &lt;li&gt;Reflectionless non-generics APIs&lt;/li&gt; &#xA; &lt;li&gt;Deserialize into existing instance&lt;/li&gt; &#xA; &lt;li&gt;Polymorphism(Union) serialization&lt;/li&gt; &#xA; &lt;li&gt;PipeWriter/Reader based streaming serialization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;This library is distributed via NuGet. Minimum requirement is &lt;code&gt;.NET 7 RC1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;PM&amp;gt; Install-Package &lt;a href=&#34;https://www.nuget.org/packages/MemoryPack&#34;&gt;MemoryPack&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;And you need to enable preview features to &lt;code&gt;.csproj&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;PropertyGroup&amp;gt;&#xA;    &amp;lt;EnablePreviewFeatures&amp;gt;True&amp;lt;/EnablePreviewFeatures&amp;gt;&#xA;&amp;lt;/PropertyGroup&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;Define the struct or class to be serialized and annotate it with a &lt;code&gt;[MemoryPackable]&lt;/code&gt; attribute and &lt;code&gt;partial&lt;/code&gt; keyword.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using MemoryPack;&#xA;&#xA;[MemoryPackable]&#xA;public partial class Person&#xA;{&#xA;    public int Age { get; set; }&#xA;    public string Name { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Serialization code is generated via C# source generator feature, that implements &lt;code&gt;IMemoryPackable&amp;lt;T&amp;gt;&lt;/code&gt; interface. In Visual Studio, you can check generated code via &lt;code&gt;Ctrl+K, R&lt;/code&gt; on class name and select &lt;code&gt;*.MemoryPackFormatter.g.cs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Call &lt;code&gt;MemoryPackSerializer.Serialize&amp;lt;T&amp;gt;/Deserialize&amp;lt;T&amp;gt;&lt;/code&gt; to serialize/deserialize your object instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var v = new Person { Age = 40, Name = &#34;John&#34; };&#xA;&#xA;var bin = MemoryPackSerializer.Serialize(v);&#xA;var val = MemoryPackSerializer.Deserialize&amp;lt;Person&amp;gt;(bin);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Serialize method supports return &lt;code&gt;byte[]&lt;/code&gt; and serialize to &lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt; or &lt;code&gt;Stream&lt;/code&gt;. Deserialize method supports &lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySeqeunce&amp;lt;byte&amp;gt;&lt;/code&gt; and &lt;code&gt;Stream&lt;/code&gt;. Andalso there have non-generics version.&lt;/p&gt; &#xA;&lt;h2&gt;Built-in supported types&lt;/h2&gt; &#xA;&lt;p&gt;These types can serialize by default:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.NET primitives (&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, etc...)&lt;/li&gt; &#xA; &lt;li&gt;Unmanaged types(Any &lt;code&gt;enum&lt;/code&gt;, Any user-defined &lt;code&gt;strcut&lt;/code&gt; that no contains reference type)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, &lt;code&gt;Half&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;, &lt;code&gt;Guid&lt;/code&gt;, &lt;code&gt;Rune&lt;/code&gt;, &lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TimeSpan&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt;, &lt;code&gt;DateTimeOffset&lt;/code&gt;, &lt;code&gt;TimeOnly&lt;/code&gt;, &lt;code&gt;DateOnly&lt;/code&gt;, &lt;code&gt;TimeZoneInfo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Complex&lt;/code&gt;, &lt;code&gt;Plane&lt;/code&gt;, &lt;code&gt;Quaternion&lt;/code&gt; &lt;code&gt;Matrix3x2&lt;/code&gt;, &lt;code&gt;Matrix4x4&lt;/code&gt;, &lt;code&gt;Vector2&lt;/code&gt;, &lt;code&gt;Vector3&lt;/code&gt;, &lt;code&gt;Vector4&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Uri&lt;/code&gt;, &lt;code&gt;Version&lt;/code&gt;, &lt;code&gt;StringBuilder&lt;/code&gt;, &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;BitArray&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;T[]&lt;/code&gt;, &lt;code&gt;T[,]&lt;/code&gt;, &lt;code&gt;T[,,]&lt;/code&gt;, &lt;code&gt;T[,,,]&lt;/code&gt;, &lt;code&gt;Memory&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlyMemory&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ArraySegment&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySequence&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Nullable&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Lazy&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;KeyValuePair&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;Tuple&amp;lt;,...&amp;gt;&lt;/code&gt;, &lt;code&gt;ValueTuple&amp;lt;,...&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;LinkedList&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Queue&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Stack&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;HashSet&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;PriorityQueue&amp;lt;,&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Dictionary&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;SortedList&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;SortedDictionary&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlyDictionary&amp;lt;,&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Collection&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlyCollection&amp;lt;&amp;gt;&lt;/code&gt;,&lt;code&gt;ObservableCollection&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlyObservableCollection&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IEnumerable&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ICollection&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;IList&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyCollection&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyList&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ISet&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IDictionary&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyDictionary&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;ILookup&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;IGrouping&amp;lt;,&amp;gt;&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ConcurrentBag&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ConcurrentQueue&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ConcurrentStack&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ConcurrentDictionary&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;BlockingCollection&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Immutable collections (&lt;code&gt;ImmutableList&amp;lt;&amp;gt;&lt;/code&gt;, etc) and interfaces (&lt;code&gt;IImmutableList&amp;lt;&amp;gt;&lt;/code&gt;, etc)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Define &lt;code&gt;[MemoryPackable]&lt;/code&gt; &lt;code&gt;class&lt;/code&gt; / &lt;code&gt;struct&lt;/code&gt; / &lt;code&gt;record&lt;/code&gt; / &lt;code&gt;record struct&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;[MemoryPackable]&lt;/code&gt; can annotate to any &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;record&lt;/code&gt;, &lt;code&gt;record struct&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt;. If type is &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;record struct&lt;/code&gt; and that contains no reference type(&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types&#34;&gt;C# Unmanaged types&lt;/a&gt;), any additional annotation(ignore, include, constructor, callbacks) is not used, that serialize/deserialize directly from the memory.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, in the default, &lt;code&gt;[MemoryPackable]&lt;/code&gt; serializes public instance property or field. You can use &lt;code&gt;[MemoryPackIgnore]&lt;/code&gt; to remove serialization target, &lt;code&gt;[MemoryPackInclude]&lt;/code&gt; promotes a private member to serialization target.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[MemoryPackable]&#xA;public partial class Sample&#xA;{&#xA;    // these types are serialized by default&#xA;    public int PublicField;&#xA;    public readonly int PublicReadOnlyField;&#xA;    public int PublicProperty { get; set; }&#xA;    public int PrivateSetPublicProperty { get; private set; }&#xA;    public int ReadOnlyPublicProperty { get; }&#xA;    public int InitProperty { get; init; }&#xA;    public required int RequiredInitProperty { get; init; }&#xA;&#xA;    // these types are not serialized by default&#xA;    int privateProperty { get; set; }&#xA;    int privateField;&#xA;    readonly int privateReadOnlyField;&#xA;&#xA;    // use [MemoryPackIgnore] to remove target of public member&#xA;    [MemoryPackIgnore]&#xA;    public int PublicProperty2 =&amp;gt; PublicProperty + PublicField;&#xA;&#xA;    // use [MemoryPackInclude] to promote private member to serialization target&#xA;    [MemoryPackInclude]&#xA;    int privateField2;&#xA;    [MemoryPackInclude]&#xA;    int privateProperty2 { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which members are serialized, you can check IntelliSense in type(code genreator makes serialization info to &lt;code&gt;&amp;lt;remarks /&amp;gt;&lt;/code&gt; comment).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;All members must be memorypack-serializable, if not, code generator reports error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;MemoryPack has 24 diagnostics rules(&lt;code&gt;MEMPACK001&lt;/code&gt; to &lt;code&gt;MEMPACK024&lt;/code&gt;) to be define comfortably.&lt;/p&gt; &#xA;&lt;p&gt;If target type is defined MemoryPack serialization externally and registered, use &lt;code&gt;[MemoryPackAllowSerialize]&lt;/code&gt; to silent diagnostics.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[MemoryPackable]&#xA;public partial class Sample2&#xA;{&#xA;    [MemoryPackAllowSerialize]&#xA;    public NotSerializableType? NotSerializableProperty { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Member order is &lt;strong&gt;important&lt;/strong&gt;, MemoryPack does not serialize any member-name and other tags, serialize in the declared order. If the type is inherited, serialize in the order of parent ‚Üí child. Member orders can not change for the deserialization. For the schema evolution, see &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#version-tolerant&#34;&gt;Version tolerant&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h3&gt;Constructor selection&lt;/h3&gt; &#xA;&lt;p&gt;MemoryPack supports parameterized constructor not only parameterless constructor. The selection of the constructor follows these rules. Both class and struct follows same.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If has &lt;code&gt;[MemoryPackConstructor]&lt;/code&gt;, use it&lt;/li&gt; &#xA; &lt;li&gt;If has no explicit constructor(includes private), use parameterless one&lt;/li&gt; &#xA; &lt;li&gt;If has a one parameterless/parameterized constructor(includes private), use it&lt;/li&gt; &#xA; &lt;li&gt;If has multiple constructors, must apply &lt;code&gt;[MemoryPackConstructor]&lt;/code&gt; attribute(no automatically choose one), otherwise generator error it.&lt;/li&gt; &#xA; &lt;li&gt;If choosed parameterized constructor, all parameter name must match with member name(case-insensitive)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[MemoryPackable]&#xA;public partial class Person&#xA;{&#xA;    public readonly int Age;&#xA;    public readonly string Name;&#xA;&#xA;    // You can use parametarized constructor(paramter name must match with member names)&#xA;    public Person(int age, string name)&#xA;    {&#xA;        this.Age = age;&#xA;        this.Name = name;&#xA;    }&#xA;}&#xA;&#xA;// also supports record primary constructor&#xA;[MemoryPackable]&#xA;public partial record Person2(int Age, string Name);&#xA;&#xA;public partial class Person3&#xA;{&#xA;    public int Age { get; set; }&#xA;    public string Name { get; set; }&#xA;&#xA;    public Person3()&#xA;    {&#xA;    }&#xA;&#xA;    // If exists multiple constructors, must use [MemoryPackConstructor]&#xA;    [MemoryPackConstructor]&#xA;    public Person3(int age, string name)&#xA;    {&#xA;        this.Age = age;&#xA;        this.Name = name;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serialization callbacks&lt;/h3&gt; &#xA;&lt;p&gt;When serialize, deserialize, MemoryPack can hook before/after event with &lt;code&gt;[MemoryPackOnSerializing]&lt;/code&gt;, &lt;code&gt;[MemoryPackOnSerialized]&lt;/code&gt;, &lt;code&gt;[MemoryPackOnDeserializing]&lt;/code&gt;, &lt;code&gt;[MemoryPackOnDeserialized]&lt;/code&gt; attributes. It can annotate both static and instance, public and private method but must be paramterless method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[MemoryPackable]&#xA;public partial class MethodCallSample&#xA;{&#xA;    // method call order is static -&amp;gt; instance&#xA;    [MemoryPackOnSerializing]&#xA;    public static void OnSerializing1()&#xA;    {&#xA;        Console.WriteLine(nameof(OnSerializing1));&#xA;    }&#xA;&#xA;    // also allows private method&#xA;    [MemoryPackOnSerializing]&#xA;    void OnSerializing2()&#xA;    {&#xA;        Console.WriteLine(nameof(OnSerializing2));&#xA;    }&#xA;&#xA;    // serializing -&amp;gt; /* serialize */ -&amp;gt; serialized&#xA;    [MemoryPackOnSerialized]&#xA;    static void OnSerialized1()&#xA;    {&#xA;        Console.WriteLine(nameof(OnSerialized1));&#xA;    }&#xA;&#xA;    [MemoryPackOnSerialized]&#xA;    public void OnSerialized2()&#xA;    {&#xA;        Console.WriteLine(nameof(OnSerialized2));&#xA;    }&#xA;&#xA;    [MemoryPackOnDeserializing]&#xA;    public static void OnDeserializing1()&#xA;    {&#xA;        Console.WriteLine(nameof(OnDeserializing1));&#xA;    }&#xA;&#xA;    // Note: instance method with MemoryPackOnDeserializing, that not called if instance is not passed by `ref`&#xA;    [MemoryPackOnDeserializing]&#xA;    public void OnDeserializing2()&#xA;    {&#xA;        Console.WriteLine(nameof(OnDeserializing2));&#xA;    }&#xA;&#xA;    [MemoryPackOnDeserialized]&#xA;    public static void OnDeserialized1()&#xA;    {&#xA;        Console.WriteLine(nameof(OnDeserialized1));&#xA;    }&#xA;&#xA;    [MemoryPackOnDeserialized]&#xA;    public void OnDeserialized2()&#xA;    {&#xA;        Console.WriteLine(nameof(OnDeserialized2));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Define custom collection&lt;/h2&gt; &#xA;&lt;p&gt;In default, annotated &lt;code&gt;[MemoryPackObject]&lt;/code&gt; type try to search members. However if type is collection(&lt;code&gt;ICollection&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ISet&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;IDictionary&amp;lt;,&amp;gt;&lt;/code&gt;), you can change &lt;code&gt;GenreateType.Collection&lt;/code&gt; to serialize correctly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[MemoryPackable(GenerateType.Collection)]&#xA;public partial class MyList&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;&#xA;{&#xA;}&#xA;&#xA;[MemoryPackable(GenerateType.Collection)]&#xA;public partial class MyStringDictionary&amp;lt;TValue&amp;gt; : Dictionary&amp;lt;string, TValue&amp;gt;&#xA;{&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Polymorphism(Union)&lt;/h2&gt; &#xA;&lt;p&gt;MemoryPack supports serializing interface and abstract class objects for polymorphism serialization. In MemoryPack these are called Union. Only interfaces and abstracts classes are allowed to be annotated with &lt;code&gt;[MemoryPackUnion]&lt;/code&gt; attributes. Unique union tags are required.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Annotate [MemoryPackable] and inheritance types by [MemoryPackUnion]&#xA;// Union also supports abstract class&#xA;[MemoryPackable]&#xA;[MemoryPackUnion(0, typeof(FooClass))]&#xA;[MemoryPackUnion(1, typeof(BarClass))]&#xA;public partial interface IUnionSample&#xA;{&#xA;}&#xA;&#xA;[MemoryPackable]&#xA;public partial class FooClass : IUnionSample&#xA;{&#xA;    public int XYZ { get; set; }&#xA;}&#xA;&#xA;[MemoryPackable]&#xA;public partial class BarClass : IUnionSample&#xA;{&#xA;    public string? OPQ { get; set; }&#xA;}&#xA;// ---&#xA;&#xA;IUnionSample data = new FooClass() { XYZ = 999 };&#xA;&#xA;// Serialize as interface type.&#xA;var bin = MemoryPackSerializer.Serialize(data);&#xA;&#xA;// Deserialize as interface type.&#xA;var reData = MemoryPackSerializer.Deserialize&amp;lt;IUnionSample&amp;gt;(bin);&#xA;&#xA;switch (reData)&#xA;{&#xA;    case FooClass x:&#xA;        Console.WriteLine(x.XYZ);&#xA;        break;&#xA;    case BarClass x:&#xA;        Console.WriteLine(x.OPQ);&#xA;        break;&#xA;    default:&#xA;        break;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Serialize API&lt;/h2&gt; &#xA;&lt;p&gt;Serialize has three overloads.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Non generic API also available, these version is first argument is Type and value is object?&#xA;byte[] Serialize&amp;lt;T&amp;gt;(in T? value)&#xA;void Serialize&amp;lt;T, TBufferWriter&amp;gt;(in TBufferWriter bufferWriter, in T? value)&#xA;async ValueTask SerializeAsync&amp;lt;T&amp;gt;(Stream stream, T? value, CancellationToken cancellationToken = default)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The recommended way to do this in Performance is to use &lt;code&gt;BufferWriter&lt;/code&gt;. This serializes directly into the buffer. It can be applied to &lt;code&gt;PipeWriter&lt;/code&gt; in &lt;code&gt;System.IO.Pipelines&lt;/code&gt;, &lt;code&gt;BodyWriter&lt;/code&gt; in ASP .NET Core, etc.&lt;/p&gt; &#xA;&lt;p&gt;If a &lt;code&gt;byte[]&lt;/code&gt; is required (e.g. &lt;code&gt;RedisValue&lt;/code&gt; in &lt;a href=&#34;https://github.com/StackExchange/StackExchange.Redis&#34;&gt;StackExchange.Redis&lt;/a&gt;), return &lt;code&gt;byte[]&lt;/code&gt; API is simple and almostly fast.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;SerializeAsync&lt;/code&gt; for &lt;code&gt;Stream&lt;/code&gt; is asynchronous only for Flush; it serializes everything once into MemoryPack&#39;s internal pool buffer and then writes it out with WriteAsync. Therefore, BufferWriter overloading, which separates and controls buffer and flush, is better.&lt;/p&gt; &#xA;&lt;p&gt;If you want to do complete streaming write, see &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#streaming-serialization&#34;&gt;Streaming Serialization&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Deserialize API&lt;/h2&gt; &#xA;&lt;p&gt;Deserialize has &lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt; and &lt;code&gt;ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code&gt;, &lt;code&gt;Stream&lt;/code&gt; overload and &lt;code&gt;ref&lt;/code&gt; support.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;T? Deserialize&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;byte&amp;gt; buffer)&#xA;void Deserialize&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;byte&amp;gt; buffer, ref T? value)&#xA;T? Deserialize&amp;lt;T&amp;gt;(in ReadOnlySequence&amp;lt;byte&amp;gt; buffer)&#xA;void Deserialize&amp;lt;T&amp;gt;(in ReadOnlySequence&amp;lt;byte&amp;gt; buffer, ref T? value)&#xA;async ValueTask&amp;lt;T?&amp;gt; DeserializeAsync&amp;lt;T&amp;gt;(Stream stream)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ref&lt;/code&gt; overload overwrite existing instance, for details see &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#overwrite&#34;&gt;Overwrite&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;DeserializeAsync(Stream)&lt;/code&gt; is not completely streaming read, first read into MemoryPack&#39;s internal pool up to the end-of-stream, then deserialize.&lt;/p&gt; &#xA;&lt;p&gt;If you want to do complete streaming read, see &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#streaming-serialization&#34;&gt;Streaming Serialization&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Overwrite&lt;/h2&gt; &#xA;&lt;p&gt;MemoryPack supports deserialize to existing instance, that reduce new instance allocation. It can use by &lt;code&gt;Deserialize(ref T? value)&lt;/code&gt; overload.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var person = new Person();&#xA;var bin = MemoryPackSerializer.Serialize(person);&#xA;&#xA;// overwrite data to existing instance.&#xA;MemoryPackSerializer.Deserialize(bin, ref person);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MemoryPack will attempt to overwrite as much as possible, but if the conditions do not match, it will create a new instance (as in normal deserialization).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ref value(includes members in object graph) is null, set new instance&lt;/li&gt; &#xA; &lt;li&gt;only allows parameterless constructor, if parametarized constructor is used, create new instance&lt;/li&gt; &#xA; &lt;li&gt;if value is &lt;code&gt;T[]&lt;/code&gt;, reuse only if the length is the same, otherwise create new instance&lt;/li&gt; &#xA; &lt;li&gt;if value is collection that has &lt;code&gt;.Clear()&lt;/code&gt; method(&lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Stack&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Queue&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;LinkedList&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;HashSet&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;PriorityQueue&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;ObservableCollection&lt;/code&gt;, &lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;ConcurrentQueue&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ConcurrentStack&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;ConcurrentBag&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Dictionary&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;SoretedDictionary&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;SortedList&amp;lt;,&amp;gt;&lt;/code&gt;, &lt;code&gt;ConcurrentDictionary&amp;lt;,&amp;gt;&lt;/code&gt;) call Clear() and reuse it, otherwise create new instance&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Version tolerant&lt;/h2&gt; &#xA;&lt;p&gt;MemoryPack supports schema evolution limitedly.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;unmanaged struct can&#39;t change any more&lt;/li&gt; &#xA; &lt;li&gt;MemoryPackable objects, members can be added, but not deleted&lt;/li&gt; &#xA; &lt;li&gt;MemoryPackable objects, can&#39;t change member order&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[MemoryPackable]&#xA;public partial class VersionCheck&#xA;{&#xA;    public int Prop1 { get; set; }&#xA;    public long Prop2 { get; set; }&#xA;}&#xA;&#xA;// Add is OK.&#xA;[MemoryPackable]&#xA;public partial class VersionCheck&#xA;{&#xA;    public int Prop1 { get; set; }&#xA;    public long Prop2 { get; set; }&#xA;    public int? AddedProp { get; set; }&#xA;}&#xA;&#xA;// Remove is NG.&#xA;[MemoryPackable]&#xA;public partial class VersionCheck&#xA;{&#xA;    // public int Prop1 { get; set; }&#xA;    public long Prop2 { get; set; }&#xA;}&#xA;&#xA;// Change order is NG.&#xA;[MemoryPackable]&#xA;public partial class VersionCheck&#xA;{&#xA;    public long Prop2 { get; set; }&#xA;    public int Prop1 { get; set; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#serialization-info&#34;&gt;Serialization info&lt;/a&gt; section shows how to check for schema changes, e.g., by CI, to prevent accidents.&lt;/p&gt; &#xA;&lt;h2&gt;Serialization info&lt;/h2&gt; &#xA;&lt;p&gt;Which members are serialized, you can check IntelliSense in type. There is an option to write that information to a file at compile time. Set &lt;code&gt;MemoryPackGenerator_SerializationInfoOutputDirectory&lt;/code&gt; as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- output memoerypack serialization info to directory --&amp;gt;&#xA;&amp;lt;ItemGroup&amp;gt;&#xA;    &amp;lt;CompilerVisibleProperty Include=&#34;MemoryPackGenerator_SerializationInfoOutputDirectory&#34; /&amp;gt;&#xA;&amp;lt;/ItemGroup&amp;gt;&#xA;&amp;lt;PropertyGroup&amp;gt;&#xA;    &amp;lt;MemoryPackGenerator_SerializationInfoOutputDirectory&amp;gt;$(MSBuildProjectDirectory)\MemoryPackLogs&amp;lt;/MemoryPackGenerator_SerializationInfoOutputDirectory&amp;gt;&#xA;&amp;lt;/PropertyGroup&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following info is written to the file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;If the type is unmanaged, showed &lt;code&gt;unmanaged&lt;/code&gt; before type name.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;unmanaged FooStruct&#xA;---&#xA;int x&#xA;int y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By checking the differences in this file, dangerous schema changes can be prevented. For example, you may want to use CI to detect the following rules&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;modify unmanaged type&lt;/li&gt; &#xA; &lt;li&gt;member order change&lt;/li&gt; &#xA; &lt;li&gt;member deletion&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;TODO for describe details, stay tuned.&lt;/p&gt; &#xA;&lt;h2&gt;Payload size and compression&lt;/h2&gt; &#xA;&lt;p&gt;Payload size depends on the target value; unlike JSON, there are no keys and it is a binary format, so the payload size is likely to be smaller than JSON.&lt;/p&gt; &#xA;&lt;p&gt;For those with varint encoding, such as MessagePack and Protobuf, MemoryPack tends to be larger if ints are used a lot (in MemoryPack, ints are always 4 bytes due to fixed size encoding, while MsgPack is 1~5 bytes).&lt;/p&gt; &#xA;&lt;p&gt;Also, strings are usually UTF8 for other formats, but MemoryPack is UTF16 fixed length (2 bytes), so MemoryPack is larger if the string occupies ASCII. Conversely, MemoryPack may be smaller if the string contains many UTF8 characters of 3 bytes or more, such as Japanese.&lt;/p&gt; &#xA;&lt;p&gt;float and double are 4 bytes and 8 bytes in MemoryPack, but 5 bytes and 9 bytes in MsgPack. So MemoryPack is smaller, for example, for Vector3 (float, float, float) arrays.&lt;/p&gt; &#xA;&lt;p&gt;In any case, if the payload size is large, compression should be considered. LZ4, ZStandard and Brotli are recommended. An efficient way to combine compression and serialization will be presented at a later date.&lt;/p&gt; &#xA;&lt;h2&gt;Packages&lt;/h2&gt; &#xA;&lt;p&gt;MemoryPack has four packages.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MemoryPack&lt;/li&gt; &#xA; &lt;li&gt;MemoryPack.Core&lt;/li&gt; &#xA; &lt;li&gt;MemoryPack.Generator&lt;/li&gt; &#xA; &lt;li&gt;MemoryPack.Streaming&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Mainly you only reference &lt;code&gt;MemoryPack&lt;/code&gt;, this both &lt;code&gt;MemoryPack.Core&lt;/code&gt; and &lt;code&gt;MemoryPack.Generator&lt;/code&gt;. If you want to use &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#streaming-serialization&#34;&gt;Streaming Serialization&lt;/a&gt;, additionaly use &lt;code&gt;MemoryPack.Streaming&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Streaming Serialization&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;MemoryPack.Streaming&lt;/code&gt; provides additional &lt;code&gt;MemoryPackStreamingSerializer&lt;/code&gt;, it serialize/deserialize collection data streamingly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class MemoryPackStreamingSerializer&#xA;{&#xA;    public static async ValueTask SerializeAsync&amp;lt;T&amp;gt;(PipeWriter pipeWriter, int count, IEnumerable&amp;lt;T&amp;gt; source, int flushRate = 4096, CancellationToken cancellationToken = default)&#xA;    public static async ValueTask SerializeAsync&amp;lt;T&amp;gt;(Stream stream, int count, IEnumerable&amp;lt;T&amp;gt; source, int flushRate = 4096, CancellationToken cancellationToken = default)&#xA;    public static async IAsyncEnumerable&amp;lt;T?&amp;gt; DeserializeAsync&amp;lt;T&amp;gt;(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)&#xA;    public static IAsyncEnumerable&amp;lt;T?&amp;gt; DeserializeAsync&amp;lt;T&amp;gt;(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Formatter/Provider API&lt;/h2&gt; &#xA;&lt;p&gt;If you want to implement formatter manually, inherit &lt;code&gt;MemoryPackFormatter&amp;lt;T&amp;gt;&lt;/code&gt; to recommended.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class SkeltonFormatter : MemoryPackFormatter&amp;lt;Skelton&amp;gt;&#xA;{&#xA;    public override void Serialize&amp;lt;TBufferWriter&amp;gt;(ref MemoryPackWriter&amp;lt;TBufferWriter&amp;gt; writer, scoped ref Skelton? value)&#xA;    {&#xA;        if (value == null)&#xA;        {&#xA;            writer.WriteNullObjectHeader();&#xA;            return;&#xA;        }&#xA;&#xA;        // use writer method.&#xA;    }&#xA;&#xA;    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)&#xA;    {&#xA;        if (!reader.TryReadObjectHeader(out var count))&#xA;        {&#xA;            value = null;&#xA;            return;&#xA;        }&#xA;&#xA;        // use reader method.&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The created formatter is registered with &lt;code&gt;MemoryPackFormatterProvider&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;MemoryPackFormatterProvider.Register(new SkeltonFormatter());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Unity support&lt;/h2&gt; &#xA;&lt;p&gt;Currently MemoryPack dependents .NET 7 runtime, incremental generator and C# 11. Therefore it will not work in Unity. .NET 7 support is planned for Unity 2025.&lt;/p&gt; &#xA;&lt;p&gt;If you request it, there is a possibility to make a detuned Unity version. Please send your request to Issues with the case you wish to use.&lt;/p&gt; &#xA;&lt;h2&gt;Binary wire format specification&lt;/h2&gt; &#xA;&lt;p&gt;The type of &lt;code&gt;T&lt;/code&gt; defined in &lt;code&gt;Serialize&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Deserialize&amp;lt;T&amp;gt;&lt;/code&gt; is called C# schema. MemoryPack format is not self described format. Deserialize requires the corresponding C# schema. Four types exist as internal representations of binaries, but types cannot be determined without a C# schema.&lt;/p&gt; &#xA;&lt;p&gt;There are no endian specifications. It is not possible to convert on machines with different endianness. However modern computers are usually little-endian.&lt;/p&gt; &#xA;&lt;p&gt;There are four value types of format.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unmanaged struct&lt;/li&gt; &#xA; &lt;li&gt;Object&lt;/li&gt; &#xA; &lt;li&gt;Collection&lt;/li&gt; &#xA; &lt;li&gt;Union&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Unmanaged struct&lt;/h3&gt; &#xA;&lt;p&gt;Unmanaged struct is C# struct that no contains referene type, similar constraint of &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types&#34;&gt;C# Unmanaged types&lt;/a&gt;. Serializing struct layout as is, includes padding.&lt;/p&gt; &#xA;&lt;h3&gt;Object&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;{byte memberCount, values...}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Object has 1byte unsigned byte as member count in header. Member count allows &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;249&lt;/code&gt;, &lt;code&gt;255&lt;/code&gt; represents object is &lt;code&gt;null&lt;/code&gt;. Values store memorypack value for the number of member count.&lt;/p&gt; &#xA;&lt;h3&gt;Collection&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;[int length, values...]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Collection has 4byte signed interger as data count in header, &lt;code&gt;-1&lt;/code&gt; represents &lt;code&gt;null&lt;/code&gt;. Values store memorypack value for the number of length. String is collection(serialize as &lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;, in other words, UTF16).&lt;/p&gt; &#xA;&lt;h3&gt;Union&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;((byte)254, byte tag, value)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Union has 2 byte unsgined byte in header, First byte &lt;code&gt;254&lt;/code&gt; is marker as Union, next unsgined byte is tag that for discriminated value type.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is licensed under the MIT License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Collective-Software/ClickPaste</title>
    <updated>2022-10-01T01:35:55Z</updated>
    <id>tag:github.com,2022-10-01:/Collective-Software/ClickPaste</id>
    <link href="https://github.com/Collective-Software/ClickPaste" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Windows 10 notification area app in C# that can paste clipboard contents as keystrokes to whatever location you click.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ClickPaste&lt;/h1&gt; &#xA;&lt;p&gt;Windows 10 notification area app in C# that can paste clipboard contents as keystrokes to whatever location you click.&lt;/p&gt; &#xA;&lt;h2&gt;Starting&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Launch ClickPaste.exe, or put it in your Startup folder.&lt;/li&gt; &#xA; &lt;li&gt;If you intend to paste onto windows of UAC-elevated processes, you need ClickPaste.exe to be running UAC-elevated as well. You can do this by making a shortcut and setting its properties to &#34;Run as Administrator&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Collective-Software/ClickPaste/master/doc/RunAsAdmin.png&#34; alt=&#34;How to run as administrator&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;First of course, you need to have some text in your clipboard. Then:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Click the target notification icon to begin:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Collective-Software/ClickPaste/master/doc/ClickToTarget.png&#34; alt=&#34;Click to choose a target&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Click to choose a location you want to paste the text:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Collective-Software/ClickPaste/master/doc/ClickToPaste.png&#34; alt=&#34;Click to choose a location to paste&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Your clipboard contents should be typed as keystrokes onto the window you selected:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Collective-Software/ClickPaste/master/doc/Pasted.png&#34; alt=&#34;Your clipboard is typed as keystrokes onto the window you selected&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Stopping&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Right-click the notification icon and select Exit.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Collective-Software/ClickPaste/master/doc/RightClickToExit.png&#34; alt=&#34;How to exit&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Collective-Software/releases/latest&#34;&gt;Go to Releases page&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>