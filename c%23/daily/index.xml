<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-16T01:31:31Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>TNG/ArchUnitNET</title>
    <updated>2023-02-16T01:31:31Z</updated>
    <id>tag:github.com,2023-02-16:/TNG/ArchUnitNET</id>
    <link href="https://github.com/TNG/ArchUnitNET" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A C# architecture test library to specify and assert architecture rules in C# for automated testing.&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/TNG/ArchUnitNET/main/Logo/ArchUnitNET-Logo.png&#34; height=&#34;64&#34; alt=&#34;ArchUnit&#34;&gt; &#xA;&lt;h1&gt;ArchUnitNET &lt;a href=&#34;https://travis-ci.com/TNG/ArchUnitNET&#34;&gt;&lt;img src=&#34;https://travis-ci.com/TNG/ArchUnitNET.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/TNG/ArchUnitNET/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/TngTech.ArchUnitNET/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/TngTech.ArchUnitNET&#34; alt=&#34;Nuget&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Visit our documentation at &lt;a href=&#34;https://archunitnet.readthedocs.io/en/latest/&#34;&gt;https://archunitnet.readthedocs.io/en/latest/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;ArchUnitNET is a free, simple library for checking the architecture of C# code. It is the C# fork of &lt;a href=&#34;https://www.archunit.org/&#34;&gt;https://www.archunit.org/&lt;/a&gt; for Java. ArchUnitNET can check dependencies between classes, members, interfaces, and more. This is done by analyzing C# bytecode and importing all classes into our C# code structure. The main focus of ArchUnitNET is to automatically test architecture and coding rules.&lt;/p&gt; &#xA;&lt;h2&gt;An Example&lt;/h2&gt; &#xA;&lt;p&gt;To use ArchUnitNET, install the ArchUnitNET package from NuGet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS&amp;gt; Install-Package ArchUnitNET&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use xUnit, NUnit or MSTestV2 for your unit tests, you should instead install the corresponding ArchUnit extension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS&amp;gt; Install-Package ArchUnitNET.xUnit&#xA;PS&amp;gt; Install-Package ArchUnitNET.NUnit&#xA;PS&amp;gt; Install-Package ArchUnitNET.MSTestV2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Create a Test&lt;/h4&gt; &#xA;&lt;p&gt;Then you will want to create a class to start testing. We used xUnit with the ArchUnit extension here, but it works similarly with NUnit or other Unit Test Frameworks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;&#xA;using ArchUnitNET.Domain;&#xA;using ArchUnitNET.Loader;&#xA;using ArchUnitNET.Fluent;&#xA;using Xunit;&#xA;&#xA;//add a using directive to ArchUnitNET.Fluent.ArchRuleDefinition to easily define ArchRules&#xA;using static ArchUnitNET.Fluent.ArchRuleDefinition;&#xA;&#xA;&#xA;namespace ExampleTest&#xA;{&#xA;    public class ExampleArchUnitTest&#xA;    {&#xA;        // TIP: load your architecture once at the start to maximize performance of your tests&#xA;        private static readonly Architecture Architecture = new ArchLoader().LoadAssemblies(&#xA;                System.Reflection.Assembly.Load(&#34;ExampleClassAssemblyName&#34;),&#xA;                System.Reflection.Assembly.Load(&#34;ForbiddenClassAssemblyName&#34;)&#xA;            .Build();&#xA;        // replace &amp;lt;ExampleClass&amp;gt; and &amp;lt;ForbiddenClass&amp;gt; with classes from the assemblies you want to test&#xA;&#xA;        //declare variables you&#39;ll use throughout your tests up here&#xA;        //use As() to give them a custom description&#xA;        private readonly IObjectProvider&amp;lt;IType&amp;gt; ExampleLayer =&#xA;            Types().That().ResideInAssembly(&#34;ExampleAssembly&#34;).As(&#34;Example Layer&#34;);&#xA;&#xA;        private readonly IObjectProvider&amp;lt;Class&amp;gt; ExampleClasses =&#xA;            Classes().That().ImplementInterface(&#34;IExampleInterface&#34;).As(&#34;Example Classes&#34;);&#xA;&#xA;        private readonly IObjectProvider&amp;lt;IType&amp;gt; ForbiddenLayer =&#xA;            Types().That().ResideInNamespace(&#34;ForbiddenNamespace&#34;).As(&#34;Forbidden Layer&#34;);&#xA;&#xA;        private readonly IObjectProvider&amp;lt;Interface&amp;gt; ForbiddenInterfaces =&#xA;            Interfaces().That().HaveFullNameContaining(&#34;forbidden&#34;).As(&#34;Forbidden Interfaces&#34;);&#xA;&#xA;&#xA;        //write some tests&#xA;        [Fact]&#xA;        public void TypesShouldBeInCorrectLayer()&#xA;        {&#xA;            //you can use the fluent API to write your own rules&#xA;            IArchRule exampleClassesShouldBeInExampleLayer =&#xA;                Classes().That().Are(ExampleClasses).Should().Be(ExampleLayer);&#xA;            IArchRule forbiddenInterfacesShouldBeInForbiddenLayer =&#xA;                Interfaces().That().Are(ForbiddenInterfaces).Should().Be(ForbiddenLayer);&#xA;&#xA;            //check if your architecture fulfils your rules&#xA;            exampleClassesShouldBeInExampleLayer.Check(Architecture);&#xA;            forbiddenInterfacesShouldBeInForbiddenLayer.Check(Architecture);&#xA;&#xA;            //you can also combine your rules&#xA;            IArchRule combinedArchRule =&#xA;                exampleClassesShouldBeInExampleLayer.And(forbiddenInterfacesShouldBeInForbiddenLayer);&#xA;            combinedArchRule.Check(Architecture);&#xA;        }&#xA;&#xA;        [Fact]&#xA;        public void ExampleLayerShouldNotAccessForbiddenLayer()&#xA;        {&#xA;            //you can give your rules a custom reason, which is displayed when it fails&#xA;            //(together with the types that failed the rule)&#xA;            IArchRule exampleLayerShouldNotAccessForbiddenLayer = Types().That().Are(ExampleLayer).Should()&#xA;                .NotDependOnAny(ForbiddenLayer).Because(&#34;it&#39;s forbidden&#34;);&#xA;            exampleLayerShouldNotAccessForbiddenLayer.Check(Architecture);&#xA;        }&#xA;&#xA;        [Fact]&#xA;        public void ForbiddenClassesShouldHaveCorrectName()&#xA;        {&#xA;            Classes().That().AreAssignableTo(ForbiddenInterfaces).Should().HaveNameContaining(&#34;forbidden&#34;)&#xA;                .Check(Architecture);&#xA;        }&#xA;&#xA;        [Fact]&#xA;        public void ExampleClassesShouldNotCallForbiddenMethods()&#xA;        {&#xA;            Classes().That().Are(ExampleClasses).Should().NotCallAny(&#xA;                    MethodMembers().That().AreDeclaredIn(ForbiddenLayer).Or().HaveNameContaining(&#34;forbidden&#34;))&#xA;                .Check(Architecture);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Further Info and Help&lt;/h4&gt; &#xA;&lt;p&gt;Check out test examples for the current release at &lt;a href=&#34;https://github.com/TNG/ArchUnitNET/tree/master/ExampleTest&#34; title=&#34;ExampleTests&#34;&gt;ArchUnitNET Examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;ArchUnitNET is published under the Apache License 2.0. For more information concerning the license, see &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache License 2.0&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>