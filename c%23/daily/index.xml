<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-20T01:30:40Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jstedfast/MimeKit</title>
    <updated>2023-04-20T01:30:40Z</updated>
    <id>tag:github.com,2023-04-20:/jstedfast/MimeKit</id>
    <link href="https://github.com/jstedfast/MimeKit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A .NET MIME creation and parser library with support for S/MIME, PGP, DKIM, TNEF and Unix mbox spools.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MimeKit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/jstedfast/MimeKit?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/jstedfast/MimeKit&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Package&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Latest Release&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Latest Build&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;MimeKit&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.nuget.org/packages/MimeKit&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/MimeKit&#34; alt=&#34;NuGet Badge MimeKit&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.myget.org/feed/mimekit/package/nuget/MimeKit&#34;&gt;&lt;img src=&#34;https://buildstats.info/myget/mimekit/MimeKit&#34; alt=&#34;MyGet Badge MimeKit&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;MimeKitLite&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.nuget.org/packages/MimeKitLite&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/MimeKitLite&#34; alt=&#34;NuGet Badge MimeKitLite&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Platform&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Build Status&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Code Coverage&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Static Analysis&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Linux/Mac&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/jstedfast/MimeKit/actions/workflows/main.yml&#34;&gt;&lt;img src=&#34;https://github.com/jstedfast/MimeKit/actions/workflows/main.yml/badge.svg?event=push&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://coveralls.io/r/jstedfast/MimeKit?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/jstedfast/MimeKit/badge.svg?branch=master&#34; alt=&#34;Code Coverage&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://scan.coverity.com/projects/3201&#34;&gt;&lt;img src=&#34;https://scan.coverity.com/projects/3201/badge.svg?sanitize=true&#34; alt=&#34;Static Analysis&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/jstedfast/MimeKit/actions/workflows/main.yml&#34;&gt;&lt;img src=&#34;https://github.com/jstedfast/MimeKit/actions/workflows/main.yml/badge.svg?event=push&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://coveralls.io/r/jstedfast/MimeKit?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/jstedfast/MimeKit/badge.svg?branch=master&#34; alt=&#34;Code Coverage&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://scan.coverity.com/projects/3201&#34;&gt;&lt;img src=&#34;https://scan.coverity.com/projects/3201/badge.svg?sanitize=true&#34; alt=&#34;Static Analysis&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;What is MimeKit?&lt;/h2&gt; &#xA;&lt;p&gt;MimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose Internet Mail Extension (MIME), as defined by &lt;a href=&#34;https://github.com/jstedfast/MimeKit/raw/master/RFCs.md&#34;&gt;numerous IETF specifications&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Donate&lt;/h2&gt; &#xA;&lt;p&gt;MimeKit is a personal open source project that I have put thousands of hours into perfecting with the goal of making it the very best MIME parser framework for .NET. I need your help to achieve this.&lt;/p&gt; &#xA;&lt;p&gt;Donating helps pay for things such as web hosting, domain registration and licenses for developer tools such as a performance profiler, memory profiler, a static code analysis tool, and more. It also helps motivate me to continue working on the project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sponsors/jstedfast&#34; _target=&#34;blank&#34;&gt;&lt;img alt=&#34;Click here to lend your support to MimeKit by making a donation!&#34; src=&#34;https://www.paypal.com/en_US/i/btn/x-click-but21.gif&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;As a developer and user of email clients, I had come to realize that the vast majority of email client (and server) software had less-than-satisfactory MIME implementations. More often than not these email clients created broken MIME messages and/or would incorrectly try to parse a MIME message thus subtracting from the full benefits that MIME was meant to provide. MimeKit is meant to address this issue by following the MIME specification as closely as possible while also providing programmers with an extremely easy to use high-level API.&lt;/p&gt; &#xA;&lt;p&gt;This led me, at first, to implement another MIME parser library called &lt;a href=&#34;https://github.com/jstedfast/gmime&#34;&gt;GMime&lt;/a&gt; which is implemented in C and later added a C# binding called GMime-Sharp.&lt;/p&gt; &#xA;&lt;p&gt;Now that I typically find myself working in C# rather than lower level languages like C, I decided to begin writing a new parser in C# which would not depend on GMime. This would also allow me to have more flexibility in that I&#39;d be able to use Generics and create a more .NET-compliant API.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;While mainstream beliefs may suggest that C# can never be as fast as C, it turns out that with a bit of creative parser design and a few clever optimizations &lt;sup&gt;[&lt;a href=&#34;http://jeffreystedfast.blogspot.com/2013/09/optimization-tips-tricks-used-by.html&#34;&gt;1&lt;/a&gt;] [&lt;a href=&#34;http://jeffreystedfast.blogspot.com/2013/10/optimization-tips-tricks-used-by.html&#34;&gt;2&lt;/a&gt;]&lt;/sup&gt;, MimeKit&#39;s performance is actually &lt;a href=&#34;http://jeffreystedfast.blogspot.com/2014/03/gmime-gets-speed-boost.html&#34;&gt;on par with GMime&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Since GMime is pretty well-known as a high-performance native MIME parser and MimeKit more-or-less matches GMime&#39;s performance, it stands to reason that MimeKit is likely unsurpassed in performance in the .NET MIME parser space.&lt;/p&gt; &#xA;&lt;p&gt;For a comparison, as I &lt;a href=&#34;http://jeffreystedfast.blogspot.com/2013/10/optimization-tips-tricks-used-by.html&#34;&gt;blogged here&lt;/a&gt; (I have since optimized MimeKit by at least another 30%), MimeKit is more than 25x faster than OpenPOP.NET, 75x faster than SharpMimeTools, and 65x faster than regex-based parsers. Even the commercial MIME parser offerings such as LimiLabs&#39; Mail.dll and NewtonIdeas&#39; Mime4Net cannot even come close to matching MimeKit&#39;s performance (they are both orders of magnitude slower than MimeKit).&lt;/p&gt; &#xA;&lt;p&gt;For comparison purposes, I&#39;ve published a &lt;a href=&#34;https://github.com/jstedfast/MimeParserBenchmark&#34;&gt;MIME parser benchmark&lt;/a&gt; to make it easier for anyone else to compare the performance of MimeKit to their favourite MIME parser.&lt;/p&gt; &#xA;&lt;p&gt;Here are the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Parsing startrek.msg (1000 iterations):&#xA;MimeKit:        0.6989221 seconds&#xA;OpenPop:        25.3056064 seconds&#xA;AE.Net.Mail:    17.5971438 seconds&#xA;MailSystem.NET: 26.3891218 seconds&#xA;MIMER:          76.4538978 seconds&#xA;&#xA;Parsing xamarin3.msg (1000 iterations):&#xA;MimeKit:        3.4215505 seconds&#xA;OpenPop:        159.3308053 seconds&#xA;AE.Net.Mail:    132.3044291 seconds&#xA;MailSystem.NET: 133.5832078 seconds&#xA;MIMER:          784.433441 seconds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How does your MIME parser compare?&lt;/p&gt; &#xA;&lt;h2&gt;License Information&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;MIT License&#xA;&#xA;Copyright (C) 2012-2022 .NET Foundation and Contributors&#xA;&#xA;Permission is hereby granted, free of charge, to any person obtaining a copy&#xA;of this software and associated documentation files (the &#34;Software&#34;), to deal&#xA;in the Software without restriction, including without limitation the rights&#xA;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#xA;copies of the Software, and to permit persons to whom the Software is&#xA;furnished to do so, subject to the following conditions:&#xA;&#xA;The above copyright notice and this permission notice shall be included in&#xA;all copies or substantial portions of the Software.&#xA;&#xA;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xA;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xA;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xA;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xA;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xA;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#xA;THE SOFTWARE.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing via NuGet&lt;/h2&gt; &#xA;&lt;p&gt;The easiest way to install MimeKit is via &lt;a href=&#34;https://www.nuget.org/packages/MimeKit/&#34;&gt;NuGet&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In Visual Studio&#39;s &lt;a href=&#34;http://docs.nuget.org/docs/start-here/using-the-package-manager-console&#34;&gt;Package Manager Console&lt;/a&gt;, enter the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Install-Package MimeKit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting the Source Code&lt;/h2&gt; &#xA;&lt;p&gt;First, you&#39;ll need to clone MimeKit from my GitHub repository. To do this using the command-line version of Git, you&#39;ll need to issue the following command in your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --recursive https://github.com/jstedfast/MimeKit.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using &lt;a href=&#34;https://tortoisegit.org&#34;&gt;TortoiseGit&lt;/a&gt; on Windows, you&#39;ll need to right-click in the directory where you&#39;d like to clone MimeKit and select &lt;strong&gt;Git Clone...&lt;/strong&gt; in the menu. Once you do that, you&#39;ll get the following dialog:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/jstedfast/MimeKit/raw/master/Documentation/media/clone.png&#34; alt=&#34;Download the source code using TortoiseGit&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Fill in the areas outlined in red and then click &lt;strong&gt;OK&lt;/strong&gt;. This will recursively clone MimeKit onto your local machine.&lt;/p&gt; &#xA;&lt;h2&gt;Updating the Source Code&lt;/h2&gt; &#xA;&lt;p&gt;Occasionally you might want to update your local copy of the source code if I have made changes to MimeKit since you downloaded the source code in the step above. To do this using the command-line version fo Git, you&#39;ll need to issue the following commands in your terminal within the MimeKit directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git pull&#xA;git submodule update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using &lt;a href=&#34;https://tortoisegit.org&#34;&gt;TortoiseGit&lt;/a&gt; on Windows, you&#39;ll need to right-click on the MimeKit directory and select &lt;strong&gt;Git Sync...&lt;/strong&gt; in the menu. Once you do that, you&#39;ll need to click the &lt;strong&gt;Pull&lt;/strong&gt; and &lt;strong&gt;Submodule Update&lt;/strong&gt; buttons in the following dialog:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/jstedfast/MimeKit/raw/master/Documentation/media/update.png&#34; alt=&#34;Update the source code using TortoiseGit&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;In the top-level MimeKit directory, there are a number of solution files; they are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;MimeKit.sln&lt;/strong&gt; - includes projects for .NET 4.6.2/4.7/4.8, .NETStandard 2.0/2.1, .NET Core 6.0 as well as the unit tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;MimeKitLite.sln&lt;/strong&gt; - includes projects for the stripped-down versions of MimeKit that drop support for crypto.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once you&#39;ve opened the appropriate MimeKit solution file in &lt;a href=&#34;https://www.visualstudio.com/downloads/&#34;&gt;Visual Studio&lt;/a&gt;, you can choose the &lt;strong&gt;Debug&lt;/strong&gt; or &lt;strong&gt;Release&lt;/strong&gt; build configuration and then build.&lt;/p&gt; &#xA;&lt;p&gt;Both Visual Studio 2022 and Visual Studio 2019 should be able to build MimeKit without any issues, but older versions such as Visual Studio 2015 and 2017 will require modifications to the projects in order to build correctly. It has been reported that adding NuGet package references to &lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Net.Compilers/&#34;&gt;Microsoft.Net.Compilers&lt;/a&gt; &amp;gt;= 3.6.0 and &lt;a href=&#34;https://www.nuget.org/packages/System.ValueTuple/&#34;&gt;System.ValueTuple&lt;/a&gt; &amp;gt;= 4.5.0 will allow MimeKit to build successfully.&lt;/p&gt; &#xA;&lt;p&gt;Note: The &lt;strong&gt;Release&lt;/strong&gt; build will generate the xml API documentation, but the &lt;strong&gt;Debug&lt;/strong&gt; build will not.&lt;/p&gt; &#xA;&lt;h2&gt;Using MimeKit&lt;/h2&gt; &#xA;&lt;h3&gt;Parsing Messages&lt;/h3&gt; &#xA;&lt;p&gt;One of the more common operations that MimeKit is meant for is parsing email messages from arbitrary streams. There are two ways of accomplishing this task.&lt;/p&gt; &#xA;&lt;p&gt;The first way is to use one of the &lt;a href=&#34;http://www.mimekit.net/docs/html/Overload_MimeKit_MimeMessage_Load.htm&#34;&gt;Load&lt;/a&gt; methods on &lt;code&gt;MimeMessage&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Load a MimeMessage from a stream&#xA;var message = MimeMessage.Load (stream);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can load a message from a file path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Load a MimeMessage from a file path&#xA;var message = MimeMessage.Load (&#34;message.eml&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second way is to use the &lt;a href=&#34;http://www.mimekit.net/docs/html/T_MimeKit_MimeParser.htm&#34;&gt;MimeParser&lt;/a&gt; class. For the most part, using the &lt;code&gt;MimeParser&lt;/code&gt; directly is not necessary unless you wish to parse a Unix mbox file stream. However, this is how you would do it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Load a MimeMessage from a stream&#xA;var parser = new MimeParser (stream, MimeFormat.Entity);&#xA;var message = parser.ParseMessage ();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Unix mbox file streams, you would use the parser like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Load every message from a Unix mbox&#xA;var parser = new MimeParser (stream, MimeFormat.Mbox);&#xA;while (!parser.IsEndOfStream) {&#xA;    var message = parser.ParseMessage ();&#xA;&#xA;    // do something with the message&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting the Body of a Message&lt;/h3&gt; &#xA;&lt;p&gt;A common misunderstanding about email is that there is a well-defined message body and then a list of attachments. This is not really the case. The reality is that MIME is a tree structure of content, much like a file system.&lt;/p&gt; &#xA;&lt;p&gt;Luckily, MIME does define a set of general rules for how mail clients should interpret this tree structure of MIME parts. The &lt;code&gt;Content-Disposition&lt;/code&gt; header is meant to provide hints to the receiving client as to which parts are meant to be displayed as part of the message body and which are meant to be interpreted as attachments.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Content-Disposition&lt;/code&gt; header will generally have one of two values: &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;attachment&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The meaning of these values should be fairly obvious. If the value is &lt;code&gt;attachment&lt;/code&gt;, then the content of said MIME part is meant to be presented as a file attachment separate from the core message. However, if the value is &lt;code&gt;inline&lt;/code&gt;, then the content of that MIME part is meant to be displayed inline within the mail client&#39;s rendering of the core message body. If the &lt;code&gt;Content-Disposition&lt;/code&gt; header does not exist, then it should be treated as if the value were &lt;code&gt;inline&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Technically, every part that lacks a &lt;code&gt;Content-Disposition&lt;/code&gt; header or that is marked as &lt;code&gt;inline&lt;/code&gt;, then, is part of the core message body.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s a bit more to it than that, though.&lt;/p&gt; &#xA;&lt;p&gt;Modern MIME messages will often contain a &lt;code&gt;multipart/alternative&lt;/code&gt; MIME container which will generally contain a &lt;code&gt;text/plain&lt;/code&gt; and &lt;code&gt;text/html&lt;/code&gt; version of the text that the sender wrote. The &lt;code&gt;text/html&lt;/code&gt; version is typically formatted much closer to what the sender saw in his or her WYSIWYG editor than the &lt;code&gt;text/plain&lt;/code&gt; version.&lt;/p&gt; &#xA;&lt;p&gt;The reason for sending the message text in both formats is that not all mail clients are capable of displaying HTML.&lt;/p&gt; &#xA;&lt;p&gt;The receiving client should only display one of the alternative views contained within the &lt;code&gt;multipart/alternative&lt;/code&gt; container. Since alternative views are listed in order of least faithful to most faithful with what the sender saw in his or her WYSIWYG editor, the receiving client &lt;em&gt;should&lt;/em&gt; walk over the list of alternative views starting at the end and working backwards until it finds a part that it is capable of displaying.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;multipart/alternative&#xA;  text/plain&#xA;  text/html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As seen in the example above, the &lt;code&gt;text/html&lt;/code&gt; part is listed last because it is the most faithful to what the sender saw in his or her WYSIWYG editor when writing the message.&lt;/p&gt; &#xA;&lt;p&gt;To make matters even more complicated, sometimes modern mail clients will use a &lt;code&gt;multipart/related&lt;/code&gt; MIME container instead of a simple &lt;code&gt;text/html&lt;/code&gt; part in order to embed images and other content within the HTML.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;multipart/alternative&#xA;  text/plain&#xA;  multipart/related&#xA;    text/html&#xA;    image/jpeg&#xA;    video/mp4&#xA;    image/png&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, one of the alternative views is a &lt;code&gt;multipart/related&lt;/code&gt; container which contains an HTML version of the message body that references the sibling video and images.&lt;/p&gt; &#xA;&lt;p&gt;Now that you have a rough idea of how a message is structured and how to interpret various MIME entities, the next step is learning how to traverse the MIME tree using MimeKit.&lt;/p&gt; &#xA;&lt;p&gt;Note: For your convenience, MimeKit&#39;s &lt;code&gt;MimeMessage&lt;/code&gt; class has two properties that can help you get the &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;text/html&lt;/code&gt; version of the message body. These are &lt;code&gt;TextBody&lt;/code&gt; and &lt;code&gt;HtmlBody&lt;/code&gt;, respectively.&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind, however, that at least with the &lt;code&gt;HtmlBody&lt;/code&gt; property, it may be that the HTML part is a child of a &lt;code&gt;multipart/related&lt;/code&gt;, allowing it to refer to images and other types of media that are also contained within that &lt;code&gt;multipart/related&lt;/code&gt; entity. This property is really only a convenience property and is not a really good substitute for traversing the MIME structure yourself so that you may properly interpret related content.&lt;/p&gt; &#xA;&lt;h3&gt;Traversing a MimeMessage&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;MimeMessage.Body&lt;/code&gt; is the top-level MIME entity of the message. Generally, it will either be a &lt;code&gt;TextPart&lt;/code&gt; or a &lt;code&gt;Multipart&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As an example, if you wanted to rip out all of the attachments of a message, your code might look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var attachments = new List&amp;lt;MimePart&amp;gt; ();&#xA;var multiparts = new List&amp;lt;Multipart&amp;gt; ();&#xA;var iter = new MimeIterator (message);&#xA;&#xA;// collect our list of attachments and their parent multiparts&#xA;while (iter.MoveNext ()) {&#xA;    var multipart = iter.Parent as Multipart;&#xA;    var part = iter.Current as MimePart;&#xA;&#xA;    if (multipart != null &amp;amp;&amp;amp; part != null &amp;amp;&amp;amp; part.IsAttachment) {&#xA;        // keep track of each attachment&#39;s parent multipart&#xA;        multiparts.Add (multipart);&#xA;        attachments.Add (part);&#xA;    }&#xA;}&#xA;&#xA;// now remove each attachment from its parent multipart...&#xA;for (int i = 0; i &amp;lt; attachments.Count; i++)&#xA;    multiparts[i].Remove (attachments[i]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Quick and Dirty Enumeration of Message Body Parts&lt;/h3&gt; &#xA;&lt;p&gt;If you would rather skip the proper way of traversing a MIME tree, another option that MimeKit provides is a simple enumerator over the message&#39;s body parts in a flat (depth-first) list.&lt;/p&gt; &#xA;&lt;p&gt;You can access this flat list via the &lt;code&gt;BodyParts&lt;/code&gt; property, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;foreach (var part in message.BodyParts) {&#xA;   // do something&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another helper property on the MimeMessage class is the &lt;code&gt;Attachments&lt;/code&gt; property which works much the same way as the &lt;code&gt;BodyParts&lt;/code&gt; property except that it will only contain MIME parts which have a &lt;code&gt;Content-Disposition&lt;/code&gt; header value that is set to &lt;code&gt;attachment&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Getting the Decoded Content of a MIME Part&lt;/h3&gt; &#xA;&lt;p&gt;At some point, you&#39;re going to want to extract the decoded content of a &lt;code&gt;MimePart&lt;/code&gt; (such as an image) and save it to disk or feed it to a UI control to display it.&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve found the &lt;code&gt;MimePart&lt;/code&gt; object that you&#39;d like to extract the content of, here&#39;s how you can save the decoded content to a file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// This will get the name of the file as specified by the sending mail client.&#xA;// Note: this value *may* be null, so you&#39;ll want to handle that case in your code.&#xA;var fileName = part.FileName;&#xA;&#xA;using (var stream = File.Create (fileName)) {&#xA;    part.Content.DecodeTo (stream);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also get access to the original raw content by &#34;opening&#34; the &lt;code&gt;Content&lt;/code&gt;. This might be useful if you want to pass the content off to a UI control that can do its own loading from a stream.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using (var stream = part.Content.Open ()) {&#xA;    // At this point, you can now read from the stream as if it were the original,&#xA;    // raw content. Assuming you have an image UI control that could load from a&#xA;    // stream, you could do something like this:&#xA;    imageControl.Load (stream);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a number of useful filters that can be applied to a &lt;code&gt;FilteredStream&lt;/code&gt;, so if you find this type of interface appealing, I suggest taking a look at the available filters in the &lt;code&gt;MimeKit.IO.Filters&lt;/code&gt; namespace or even write your own! The possibilities are limited only by your imagination.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Simple Message&lt;/h3&gt; &#xA;&lt;p&gt;Creating MIME messages using MimeKit is really trivial.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var message = new MimeMessage ();&#xA;message.From.Add (new MailboxAddress (&#34;Joey&#34;, &#34;joey@friends.com&#34;));&#xA;message.To.Add (new MailboxAddress (&#34;Alice&#34;, &#34;alice@wonderland.com&#34;));&#xA;message.Subject = &#34;How you doin?&#34;;&#xA;&#xA;message.Body = new TextPart (&#34;plain&#34;) {&#xA;    Text = @&#34;Hey Alice,&#xA;&#xA;What are you up to this weekend? Monica is throwing one of her parties on&#xA;Saturday and I was hoping you could make it.&#xA;&#xA;Will you be my +1?&#xA;&#xA;-- Joey&#xA;&#34;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;TextPart&lt;/code&gt; is a leaf-node MIME part with a text media-type. The first argument to the &lt;code&gt;TextPart&lt;/code&gt; constructor specifies the media-subtype, in this case, &#34;plain&#34;. Another media subtype you are probably familiar with is the &#34;html&#34; subtype. Some other examples include &#34;enriched&#34;, &#34;rtf&#34;, and &#34;csv&#34;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Text&lt;/code&gt; property is the easiest way to both get and set the string content of the MIME part.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Message with Attachments&lt;/h3&gt; &#xA;&lt;p&gt;Attachments are just like any other &lt;code&gt;MimePart&lt;/code&gt;, the only difference is that they typically have a &lt;code&gt;Content-Disposition&lt;/code&gt; header with a value of &#34;attachment&#34; instead of &#34;inline&#34; or no &lt;code&gt;Content-Disposition&lt;/code&gt; header at all.&lt;/p&gt; &#xA;&lt;p&gt;Typically, when a mail client adds attachments to a message, it will create a &lt;code&gt;multipart/mixed&lt;/code&gt; part and add the text body part and all of the file attachments to the &lt;code&gt;multipart/mixed.&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how you can do that with MimeKit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var message = new MimeMessage ();&#xA;message.From.Add (new MailboxAddress (&#34;Joey&#34;, &#34;joey@friends.com&#34;));&#xA;message.To.Add (new MailboxAddress (&#34;Alice&#34;, &#34;alice@wonderland.com&#34;));&#xA;message.Subject = &#34;How you doin?&#34;;&#xA;&#xA;// create our message text, just like before (except don&#39;t set it as the message.Body)&#xA;var body = new TextPart (&#34;plain&#34;) {&#xA;    Text = @&#34;Hey Alice,&#xA;&#xA;What are you up to this weekend? Monica is throwing one of her parties on&#xA;Saturday and I was hoping you could make it.&#xA;&#xA;Will you be my +1?&#xA;&#xA;-- Joey&#xA;&#34;&#xA;};&#xA;&#xA;// create an image attachment for the file located at path&#xA;var attachment = new MimePart (&#34;image&#34;, &#34;gif&#34;) {&#xA;    Content = new MimeContent (File.OpenRead (path), ContentEncoding.Default),&#xA;    ContentDisposition = new ContentDisposition (ContentDisposition.Attachment),&#xA;    ContentTransferEncoding = ContentEncoding.Base64,&#xA;    FileName = Path.GetFileName (path)&#xA;};&#xA;&#xA;// now create the multipart/mixed container to hold the message text and the&#xA;// image attachment&#xA;var multipart = new Multipart (&#34;mixed&#34;);&#xA;multipart.Add (body);&#xA;multipart.Add (attachment);&#xA;&#xA;// now set the multipart/mixed as the message body&#xA;message.Body = multipart;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, that is just a simple example. A lot of modern mail clients such as Outlook or Thunderbird will send out both a &lt;code&gt;text/html&lt;/code&gt; and a &lt;code&gt;text/plain&lt;/code&gt; version of the message text. To do this, you&#39;d create a &lt;code&gt;TextPart&lt;/code&gt; for the &lt;code&gt;text/plain&lt;/code&gt; part and another &lt;code&gt;TextPart&lt;/code&gt; for the &lt;code&gt;text/html&lt;/code&gt; part and then add them to a &lt;code&gt;multipart/alternative&lt;/code&gt; like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var attachment = CreateAttachment ();&#xA;var plain = CreateTextPlainPart ();&#xA;var html = CreateTextHtmlPart ();&#xA;&#xA;// Note: it is important that the text/html part is added second, because it is the&#xA;// most expressive version and (probably) the most faithful to the sender&#39;s WYSIWYG &#xA;// editor.&#xA;var alternative = new Multipart (&#34;alternative&#34;);&#xA;alternative.Add (plain);&#xA;alternative.Add (html);&#xA;&#xA;// now create the multipart/mixed container to hold the multipart/alternative&#xA;// and the image attachment&#xA;var multipart = new Multipart (&#34;mixed&#34;);&#xA;multipart.Add (alternative);&#xA;multipart.Add (attachment);&#xA;&#xA;// now set the multipart/mixed as the message body&#xA;message.Body = multipart;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a Message Using a BodyBuilder (not Arnold Schwarzenegger)&lt;/h3&gt; &#xA;&lt;p&gt;If you are used to System.Net.Mail&#39;s API for creating messages, you will probably find using a &lt;code&gt;BodyBuilder&lt;/code&gt; much more friendly than manually creating the tree of MIME parts. Here&#39;s how you could create a message body using a &lt;code&gt;BodyBuilder&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var message = new MimeMessage ();&#xA;message.From.Add (new MailboxAddress (&#34;Joey&#34;, &#34;joey@friends.com&#34;));&#xA;message.To.Add (new MailboxAddress (&#34;Alice&#34;, &#34;alice@wonderland.com&#34;));&#xA;message.Subject = &#34;How you doin?&#34;;&#xA;&#xA;var builder = new BodyBuilder ();&#xA;&#xA;// Set the plain-text version of the message text&#xA;builder.TextBody = @&#34;Hey Alice,&#xA;&#xA;What are you up to this weekend? Monica is throwing one of her parties on&#xA;Saturday and I was hoping you could make it.&#xA;&#xA;Will you be my +1?&#xA;&#xA;-- Joey&#xA;&#34;;&#xA;&#xA;// generate a Content-Id for the image we&#39;ll be referencing&#xA;var contentId = MimeUtils.GenerateMessageId ();&#xA;&#xA;// Set the html version of the message text&#xA;builder.HtmlBody = string.Format (@&#34;&amp;lt;p&amp;gt;Hey Alice,&amp;lt;br&amp;gt;&#xA;&amp;lt;p&amp;gt;What are you up to this weekend? Monica is throwing one of her parties on&#xA;Saturday and I was hoping you could make it.&amp;lt;br&amp;gt;&#xA;&amp;lt;p&amp;gt;Will you be my +1?&amp;lt;br&amp;gt;&#xA;&amp;lt;p&amp;gt;-- Joey&amp;lt;br&amp;gt;&#xA;&amp;lt;center&amp;gt;&amp;lt;img src=&#34;&#34;cid:{0}&#34;&#34; alt=&#34;&#34;selfie.jpg&#34;&#34;&amp;gt;&amp;lt;/center&amp;gt;&#34;, contentId);&#xA;&#xA;// Since selfie.jpg is referenced from the html text, we&#39;ll need to add it&#xA;// to builder.LinkedResources and then set the Content-Id header value&#xA;builder.LinkedResources.Add (@&#34;C:\Users\Joey\Documents\Selfies\selfie.jpg&#34;);&#xA;builder.LinkedResources[0].ContentId = contentId;&#xA;&#xA;// We may also want to attach a calendar event for Monica&#39;s party...&#xA;builder.Attachments.Add (@&#34;C:\Users\Joey\Documents\party.ics&#34;);&#xA;&#xA;// Now we just need to set the message body and we&#39;re done&#xA;message.Body = builder.ToMessageBody ();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Preparing to use MimeKit&#39;s S/MIME support&lt;/h3&gt; &#xA;&lt;p&gt;Before you can begin using MimeKit&#39;s S/MIME support, you will need to decide which database to use for certificate storage.&lt;/p&gt; &#xA;&lt;p&gt;If you are targetting any of the Xamarin platforms (or Linux), you won&#39;t need to do anything (although you certainly can if you want to) because, by default, I&#39;ve configured MimeKit to use the Mono.Data.Sqlite binding to SQLite.&lt;/p&gt; &#xA;&lt;p&gt;If you are on any of the Windows platforms, however, you&#39;ll need to decide on whether to use one of the conveniently available backends such as the &lt;code&gt;WindowsSecureMimeContext&lt;/code&gt; backend or the &lt;code&gt;TemporarySecureMimeContext&lt;/code&gt; backend or else you&#39;ll need to pick a System.Data provider such as &lt;a href=&#34;https://www.nuget.org/packages/System.Data.SQLite&#34;&gt;System.Data.SQLite&lt;/a&gt; to use with the &lt;code&gt;DefaultSecureMimeContext&lt;/code&gt; base class.&lt;/p&gt; &#xA;&lt;p&gt;If you opt for using the &lt;code&gt;DefaultSecureMimeContext&lt;/code&gt; backend, you&#39;ll need to implement your own &lt;code&gt;DefaultSecureMimeContext&lt;/code&gt; subclass. Luckily, it&#39;s very simple to do. Assuming you&#39;ve chosen System.Data.SQLite, here&#39;s how you&#39;d implement your own &lt;code&gt;DefaultSecureMimeContext&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System.Data.SQLite;&#xA;using MimeKit.Cryptography;&#xA;&#xA;using MyAppNamespace {&#xA;    class MySecureMimeContext : DefaultSecureMimeContext&#xA;    {&#xA;        public MySecureMimeContext () : base (OpenDatabase (&#34;C:\\wherever\\certdb.sqlite&#34;))&#xA;        {&#xA;        }&#xA;&#xA;        static IX509CertificateDatabase OpenDatabase (string fileName)&#xA;        {&#xA;            var builder = new SQLiteConnectionStringBuilder ();&#xA;            builder.DateTimeFormat = SQLiteDateFormats.Ticks;&#xA;            builder.DataSource = fileName;&#xA;&#xA;            if (!File.Exists (fileName))&#xA;                SQLiteConnection.CreateFile (fileName);&#xA;&#xA;            var sqlite = new SQLiteConnection (builder.ConnectionString);&#xA;            sqlite.Open ();&#xA;&#xA;            return new SqliteCertificateDatabase (sqlite, &#34;password&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that you&#39;ve implemented your own &lt;code&gt;SecureMimeContext&lt;/code&gt;, you&#39;ll want to register it with MimeKit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;CryptographyContext.Register (typeof (MySecureMimeContext));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you are ready to encrypt, decrypt, sign and verify S/MIME messages!&lt;/p&gt; &#xA;&lt;p&gt;Note: If you choose to use the &lt;code&gt;WindowsSecureMimeContext&lt;/code&gt; or &lt;code&gt;TemporarySecureMimeContext&lt;/code&gt; backend, you should register that class instead.&lt;/p&gt; &#xA;&lt;h3&gt;Preparing to use MimeKit&#39;s PGP/MIME support&lt;/h3&gt; &#xA;&lt;p&gt;Like with S/MIME support, you also need to register your own &lt;code&gt;OpenPgpContext&lt;/code&gt;. Unlike S/MIME, however, you don&#39;t need to choose a database if you subclass &lt;code&gt;GnuPGContext&lt;/code&gt; because it uses GnuPG&#39;s PGP keyrings to load and store public and private keys. If you choose to subclass &lt;code&gt;GnuPGContext&lt;/code&gt;, the only thing you you need to do is implement a password callback method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using MimeKit.Cryptography;&#xA;&#xA;namespace MyAppNamespace {&#xA;    class MyGnuPGContext : GnuPGContext&#xA;    {&#xA;        public MyGnuPgContext () : base ()&#xA;        {&#xA;        }&#xA;&#xA;        protected override string GetPasswordForKey (PgpSecretKey key)&#xA;        {&#xA;            // prompt the user (or a secure password cache) for the password for the specified secret key.&#xA;            return &#34;password&#34;;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once again, to register your &lt;code&gt;OpenPgpContext&lt;/code&gt;, you can use the following code snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;CryptographyContext.Register (typeof (MyGnuPGContext));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you are ready to encrypt, decrypt, sign and verify PGP/MIME messages!&lt;/p&gt; &#xA;&lt;h3&gt;Encrypting Messages with S/MIME&lt;/h3&gt; &#xA;&lt;p&gt;S/MIME uses an &lt;code&gt;application/pkcs7-mime&lt;/code&gt; MIME part to encapsulate encrypted content (as well as other things).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var joey = new MailboxAddress (&#34;Joey&#34;, &#34;joey@friends.com&#34;);&#xA;var alice = new MailboxAddress (&#34;Alice&#34;, &#34;alice@wonderland.com&#34;);&#xA;&#xA;var message = new MimeMessage ();&#xA;message.From.Add (joey);&#xA;message.To.Add (alice);&#xA;message.Subject = &#34;How you doin?&#34;;&#xA;&#xA;// create our message body (perhaps a multipart/mixed with the message text and some&#xA;// image attachments, for example)&#xA;var body = CreateMessageBody ();&#xA;&#xA;// now to encrypt our message body using our custom S/MIME cryptography context&#xA;using (var ctx = new MySecureMimeContext ()) {&#xA;    // Note: this assumes that &#34;Alice&#34; has an S/MIME certificate with an X.509&#xA;    // Subject Email identifier that matches her email address. If she doesn&#39;t,&#xA;    // try using a SecureMailboxAddress which allows you to specify the&#xA;    // fingerprint of her certificate to use for lookups.&#xA;    message.Body = ApplicationPkcs7Mime.Encrypt (ctx, message.To.Mailboxes, body);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Decrypting S/MIME Messages&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned earlier, S/MIME uses an &lt;code&gt;application/pkcs7-mime&lt;/code&gt; part with an &#34;smime-type&#34; parameter with a value of &#34;enveloped-data&#34; to encapsulate the encrypted content.&lt;/p&gt; &#xA;&lt;p&gt;The first thing you must do is find the &lt;code&gt;ApplicationPkcs7Mime&lt;/code&gt; part (see the section on traversing MIME parts).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;if (entity is ApplicationPkcs7Mime) {&#xA;    var pkcs7 = (ApplicationPkcs7Mime) entity;&#xA;&#xA;    if (pkcs7.SecureMimeType == SecureMimeType.EnvelopedData)&#xA;        return pkcs7.Decrypt ();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encrypting Messages with PGP/MIME&lt;/h3&gt; &#xA;&lt;p&gt;Unlike S/MIME, PGP/MIME uses &lt;code&gt;multipart/encrypted&lt;/code&gt; to encapsulate its encrypted data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var joey = new MailboxAddress (&#34;Joey&#34;, &#34;joey@friends.com&#34;);&#xA;var alice = new MailboxAddress (&#34;Alice&#34;, &#34;alice@wonderland.com&#34;);&#xA;&#xA;var message = new MimeMessage ();&#xA;message.From.Add (joey);&#xA;message.To.Add (alice);&#xA;message.Subject = &#34;How you doin?&#34;;&#xA;&#xA;// create our message body (perhaps a multipart/mixed with the message text and some&#xA;// image attachments, for example)&#xA;var body = CreateMessageBody ();&#xA;&#xA;// now to encrypt our message body using our custom PGP/MIME cryptography context&#xA;using (var ctx = new MyGnuPGContext ()) {&#xA;    // Note: this assumes that &#34;Alice&#34; has a public PGP key that matches her email&#xA;    // address. If she doesn&#39;t, try using a SecureMailboxAddress which allows you&#xA;    // to specify the fingerprint of her public PGP key to use for lookups.&#xA;    message.Body = MultipartEncrypted.Encrypt (ctx, message.To.Mailboxes, body);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Decrypting PGP/MIME Messages&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned earlier, PGP/MIME uses a &lt;code&gt;multipart/encrypted&lt;/code&gt; part to encapsulate the encrypted content.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;multipart/encrypted&lt;/code&gt; contains exactly 2 parts: the first &lt;code&gt;MimeEntity&lt;/code&gt; is the version information while the second &lt;code&gt;MimeEntity&lt;/code&gt; is the actual encrypted content and will typically be an &lt;code&gt;application/octet-stream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The first thing you must do is find the &lt;code&gt;MultipartEncrypted&lt;/code&gt; part (see the section on traversing MIME parts).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;if (entity is MultipartEncrypted) {&#xA;    var encrypted = (MultipartEncrypted) entity;&#xA;&#xA;    return encrypted.Decrypt ();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Digitally Signing Messages with S/MIME or PGP/MIME&lt;/h3&gt; &#xA;&lt;p&gt;Both S/MIME and PGP/MIME use a &lt;code&gt;multipart/signed&lt;/code&gt; to contain the signed content and the detached signature data.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how you might digitally sign a message using S/MIME:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var joey = new MailboxAddress (&#34;Joey&#34;, &#34;joey@friends.com&#34;);&#xA;var alice = new MailboxAddress (&#34;Alice&#34;, &#34;alice@wonderland.com&#34;);&#xA;&#xA;var message = new MimeMessage ();&#xA;message.From.Add (joey);&#xA;message.To.Add (alice);&#xA;message.Subject = &#34;How you doin?&#34;;&#xA;&#xA;// create our message body (perhaps a multipart/mixed with the message text and some&#xA;// image attachments, for example)&#xA;var body = CreateMessageBody ();&#xA;&#xA;// now to digitally sign our message body using our custom S/MIME cryptography context&#xA;using (var ctx = new MySecureMimeContext ()) {&#xA;    // Note: this assumes that &#34;Joey&#34; has an S/MIME signing certificate and private key&#xA;    // with an X.509 Subject Email identifier that matches Joey&#39;s email address.&#xA;    message.Body = MultipartSigned.Create (ctx, joey, DigestAlgorithm.Sha1, body);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For S/MIME, if you have a way for the user to configure which S/MIME certificate to use as their signing certificate, you could also do something more like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// now to digitally sign our message body using our custom S/MIME cryptography context&#xA;using (var ctx = new MySecureMimeContext ()) {&#xA;    var certificate = GetJoeysX509Certificate ();&#xA;    var signer = new CmsSigner (certificate);&#xA;    signer.DigestAlgorithm = DigestAlgorithm.Sha1;&#xA;&#xA;    message.Body = MultipartSigned.Create (ctx, signer, body);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;d prefer to use PGP instead of S/MIME, things work almost exactly the same except that you would use an OpenPGP cryptography context. For example, you might use a subclass of the &lt;code&gt;GnuPGContext&lt;/code&gt; that comes with MimeKit if you want to re-use the user&#39;s GnuPG keyrings (you can&#39;t use &lt;code&gt;GnuPGContext&lt;/code&gt; directly because it has no way of prompting the user for their passphrase).&lt;/p&gt; &#xA;&lt;p&gt;For the sake of this example, let&#39;s pretend that you&#39;ve written a minimal subclass of &lt;code&gt;MimeKit.Cryptography.GnuPGContext&lt;/code&gt; that only overrides the &lt;code&gt;GetPassword()&lt;/code&gt; method and that this subclass is called &lt;code&gt;MyGnuPGContext&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// now to digitally sign our message body using our custom OpenPGP cryptography context&#xA;using (var ctx = new MyGnuPGContext ()) {&#xA;    // Note: this assumes that &#34;Joey&#34; has a PGP key that matches his email address.&#xA;    message.Body = MultipartSigned.Create (ctx, joey, DigestAlgorithm.Sha1, body);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like S/MIME, however, you can also do your own PGP key lookups instead of relying on email addresses to match up with the user&#39;s private key.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// now to digitally sign our message body using our custom OpenPGP cryptography context&#xA;using (var ctx = new MyGnuPGContext ()) {&#xA;    var key = GetJoeysPrivatePgpKey ();&#xA;    message.Body = MultipartSigned.Create (ctx, key, DigestAlgorithm.Sha1, body);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Verifying S/MIME and PGP/MIME Digital Signatures&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned earlier, both S/MIME and PGP/MIME typically use a &lt;code&gt;multipart/signed&lt;/code&gt; part to contain the signed content and the detached signature data.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;multipart/signed&lt;/code&gt; contains exactly 2 parts: the first &lt;code&gt;MimeEntity&lt;/code&gt; is the signed content while the second &lt;code&gt;MimeEntity&lt;/code&gt; is the detached signature and, by default, will either be an &lt;code&gt;ApplicationPgpSignature&lt;/code&gt; part or an &lt;code&gt;ApplicationPkcs7Signature&lt;/code&gt; part (depending on whether the sending client signed using OpenPGP or S/MIME).&lt;/p&gt; &#xA;&lt;p&gt;Because the &lt;code&gt;multipart/signed&lt;/code&gt; part may have been signed by multiple signers, it is important to verify each of the digital signatures (one for each signer) that are returned by the &lt;code&gt;MultipartSigned.Verify()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;if (entity is MultipartSigned) {&#xA;    var signed = (MultipartSigned) entity;&#xA;&#xA;    foreach (var signature in signed.Verify ()) {&#xA;        try {&#xA;            bool valid = signature.Verify ();&#xA;&#xA;            // If valid is true, then it signifies that the signed content has not been&#xA;            // modified since this particular signer signed the content.&#xA;            //&#xA;            // However, if it is false, then it indicates that the signed content has&#xA;            // been modified.&#xA;        } catch (DigitalSignatureVerifyException) {&#xA;            // There was an error verifying the signature.&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It should be noted, however, that while most S/MIME clients will use the preferred &lt;code&gt;multipart/signed&lt;/code&gt; approach, it is possible that you may encounter an &lt;code&gt;application/pkcs7-mime&lt;/code&gt; part with an &#34;smime-type&#34; parameter set to &#34;signed-data&#34;. Luckily, MimeKit can handle this format as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;if (entity is ApplicationPkcs7Mime) {&#xA;    var pkcs7 = (ApplicationPkcs7Mime) entity;&#xA;&#xA;    if (pkcs7.SecureMimeType == SecureMimeType.SignedData) {&#xA;        // extract the original content and get a list of signatures&#xA;        MimeEntity extracted;&#xA;&#xA;        // Note: if you are rendering the message, you&#39;ll want to render the&#xA;        // extracted mime part rather than the application/pkcs7-mime part.&#xA;        foreach (var signature in pkcs7.Verify (out extracted)) {&#xA;            try {&#xA;                bool valid = signature.Verify ();&#xA;&#xA;                // If valid is true, then it signifies that the signed content has not&#xA;                // been modified since this particular signer signed the content.&#xA;                //&#xA;                // However, if it is false, then it indicates that the signed content&#xA;                // has been modified.&#xA;            } catch (DigitalSignatureVerifyException) {&#xA;                // There was an error verifying the signature.&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Signing Messages with DKIM&lt;/h3&gt; &#xA;&lt;p&gt;In addition to OpenPGP and S/MIME, MimeKit also supports DKIM signatures. To sign a message using DKIM, you&#39;ll first need a private key. In the following example, assume that the private key is saved in a file called &lt;strong&gt;privatekey.pem&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var headers = new HeaderId[] { HeaderId.From, HeaderId.Subject, HeaderId.Date };&#xA;var signer = new DkimSigner (&#34;privatekey.pem&#34;, &#34;example.com&#34;, &#34;brisbane&#34;, DkimSignatureAlgorithm.RsaSha256) {&#xA;&#x9;HeaderCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Simple,&#xA;&#x9;BodyCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Simple,&#xA;&#x9;AgentOrUserIdentifier = &#34;@eng.example.com&#34;,&#xA;&#x9;QueryMethod = &#34;dns/txt&#34;,&#xA;};&#xA;&#xA;// Prepare the message body to be sent over a 7bit transport (such as older versions of SMTP).&#xA;// Note: If the SMTP server you will be sending the message over supports the 8BITMIME extension,&#xA;// then you can use `EncodingConstraint.EightBit` instead.&#xA;message.Prepare (EncodingConstraint.SevenBit);&#xA;&#xA;signer.Sign (message, headers);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, it&#39;s fairly straight forward.&lt;/p&gt; &#xA;&lt;h3&gt;Verifying DKIM Signatures&lt;/h3&gt; &#xA;&lt;p&gt;Verifying DKIM signatures is slightly more involved than creating them because you&#39;ll need to write a custom implementation of the &lt;code&gt;IDkimPublicKeyLocator&lt;/code&gt; interface. Typically, this custom class will need to download the DKIM public keys via your chosen DNS library as they are requested by MimeKit during verification of DKIM signature headers.&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve implemented a custom &lt;code&gt;IDkimPublicKeyLocator&lt;/code&gt;, verifying signatures is fairly trivial. Most of the work needed will be in the &lt;code&gt;IDkimPublicKeyLocator&lt;/code&gt; implementation. As an example of how to implement this interface, here is one possible implementation using the &lt;a href=&#34;http://www.nuget.org/packages/Heijden.Dns/&#34;&gt;Heijden.DNS&lt;/a&gt; library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System;&#xA;using System.IO;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;using System.Collections.Generic;&#xA;&#xA;using Heijden.DNS;&#xA;&#xA;using Org.BouncyCastle.Crypto;&#xA;&#xA;using MimeKit;&#xA;using MimeKit.Cryptography;&#xA;&#xA;namespace DkimVerifierExample&#xA;{&#xA;&#x9;// Note: By using the DkimPublicKeyLocatorBase, we avoid having to parse the DNS TXT records&#xA;&#x9;// in order to get the public key ourselves.&#xA;&#x9;class DkimPublicKeyLocator : DkimPublicKeyLocatorBase&#xA;&#x9;{&#xA;&#x9;&#x9;readonly Dictionary&amp;lt;string, AsymmetricKeyParameter&amp;gt; cache;&#xA;&#x9;&#x9;readonly Resolver resolver;&#xA;&#xA;&#x9;&#x9;public DkimPublicKeyLocator ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cache = new Dictionary&amp;lt;string, AsymmetricKeyParameter&amp;gt; ();&#xA;&#xA;&#x9;&#x9;&#x9;resolver = new Resolver (&#34;8.8.8.8&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;TransportType = TransportType.Udp,&#xA;&#x9;&#x9;&#x9;&#x9;UseCache = true,&#xA;&#x9;&#x9;&#x9;&#x9;Retries = 3&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;AsymmetricKeyParameter DnsLookup (string domain, string selector, CancellationToken cancellationToken)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var query = selector + &#34;._domainkey.&#34; + domain;&#xA;&#x9;&#x9;&#x9;AsymmetricKeyParameter pubkey;&#xA;&#xA;&#x9;&#x9;&#x9;// checked if we&#39;ve already fetched this key&#xA;&#x9;&#x9;&#x9;if (cache.TryGetValue (query, out pubkey))&#xA;&#x9;&#x9;&#x9;&#x9;return pubkey;&#xA;&#xA;&#x9;&#x9;&#x9;// make a DNS query&#xA;&#x9;&#x9;&#x9;var response = resolver.Query (query, QType.TXT);&#xA;&#x9;&#x9;&#x9;var builder = new StringBuilder ();&#xA;&#xA;&#x9;&#x9;&#x9;// combine the TXT records into 1 string buffer&#xA;&#x9;&#x9;&#x9;foreach (var record in response.RecordsTXT) {&#xA;&#x9;&#x9;&#x9;&#x9;foreach (var text in record.TXT)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;builder.Append (text);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;var txt = builder.ToString ();&#xA;&#xA;                        // DkimPublicKeyLocatorBase provides us with this helpful method.&#xA;                        pubkey = GetPublicKey (txt);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;cache.Add (query, pubkey);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;return pubkey;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public AsymmetricKeyParameter LocatePublicKey (string methods, string domain, string selector, CancellationToken cancellationToken = default (CancellationToken))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var methodList = methods.Split (new char[] { &#39;:&#39; }, StringSplitOptions.RemoveEmptyEntries);&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &amp;lt; methodList.Length; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;if (methodList[i] == &#34;dns/txt&#34;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return DnsLookup (domain, selector, cancellationToken);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;throw new NotSupportedException (string.Format (&#34;{0} does not include any suported lookup methods.&#34;, methods));&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public Task&amp;lt;AsymmetricKeyParameter&amp;gt; LocatePublicKeyAsync (string methods, string domain, string selector, CancellationToken cancellationToken = default (CancellationToken))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return Task.Run (() =&amp;gt; {&#xA;&#x9;&#x9;&#x9;&#x9;return LocatePublicKey (methods, domain, selector, cancellationToken);&#xA;&#x9;&#x9;&#x9;}, cancellationToken);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;class Program&#xA;&#x9;{&#xA;&#x9;&#x9;public static void Main (string[] args)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (args.Length == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;Help ();&#xA;&#x9;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &amp;lt; args.Length; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;if (args[i] == &#34;--help&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Help ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;var locator = new DkimPublicKeyLocator ();&#xA;&#x9;&#x9;&#x9;var verifier = new DkimVerifier (locator);&#xA;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &amp;lt; args.Length; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;if (!File.Exists (args[i])) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.Error.WriteLine (&#34;{0}: No such file.&#34;, args[i]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Console.Write (&#34;{0} -&amp;gt; &#34;, args[i]);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var message = MimeMessage.Load (args[i]);&#xA;&#x9;&#x9;&#x9;&#x9;var index = message.Headers.IndexOf (HeaderId.DkimSignature);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (index == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&#34;NO SIGNATURE&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var dkim = message.Headers[index];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (verifier.Verify (message, dkim)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// the DKIM-Signature header is valid!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.ForegroundColor = ConsoleColor.Green;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&#34;VALID&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.ResetColor ();&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// the DKIM-Signature is invalid!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.ForegroundColor = ConsoleColor.Red;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&#34;INVALID&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.ResetColor ();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;static void Help ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Console.WriteLine (&#34;Usage is: DkimVerifier [options] [messages]&#34;);&#xA;&#x9;&#x9;&#x9;Console.WriteLine ();&#xA;&#x9;&#x9;&#x9;Console.WriteLine (&#34;Options:&#34;);&#xA;&#x9;&#x9;&#x9;Console.WriteLine (&#34;  --help               This help menu.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Signing Messages with ARC&lt;/h3&gt; &#xA;&lt;p&gt;Signing with ARC is similar to DKIM but quite a bit more involved. In order to sign with ARC, you must first validate that the existing message is authentictic and produce an ARC-Authentication-Results header containing the methods that you used to authenticate the message as well as their results.&lt;/p&gt; &#xA;&lt;p&gt;The abstract &lt;a href=&#34;http://www.mimekit.net/docs/html/T_MimeKit_Cryptography_ArcSigner.htm&#34;&gt;ArcSigner&lt;/a&gt; class provided by MimeKit will need to be subclassed before it can be used. An example subclass that provides 2 different implementations for generating the ARC-Authentication-Results header can be seen below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System;&#xA;using System.Linq;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;using System.Collections.Generic;&#xA;&#xA;using MimeKit;&#xA;using MimeKit.Cryptography;&#xA;&#xA;namespace ArcSignerExample&#xA;{&#xA;&#x9;class MyArcSigner : ArcSigner&#xA;&#x9;{&#xA;&#x9;&#x9;public MyArcSigner (string fileName, string domain, string selector, DkimSigningAlgorithm algorithm = DkimSignatureAlgorithm.RsaSha256)&#xA;&#x9;&#x9;       : base (fileName, domain, selector, algorithm)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &amp;lt;summary&amp;gt;&#xA;&#x9;&#x9;/// Generate the ARC-Authentication-Results header.&#xA;&#x9;&#x9;/// &amp;lt;/summary&amp;gt;&#xA;&#x9;&#x9;/// &amp;lt;remarks&amp;gt;&#xA;&#x9;&#x9;/// The ARC-Authentication-Results header contains information detailing the results of&#xA;&#x9;&#x9;/// authenticating/verifying the message via ARC, DKIM, SPF, etc.&#xA;&#x9;&#x9;///&#xA;&#x9;&#x9;/// In the following implementation, we assume that all of these authentication results&#xA;&#x9;&#x9;/// have already been determined by other mail software that has added some Authentication-Results&#xA;&#x9;&#x9;/// headers containing this information.&#xA;&#x9;&#x9;///&#xA;&#x9;&#x9;/// Note: This method is used when ArcSigner.Sign() is called instead of ArcSigner.SignAsync().&#xA;&#x9;&#x9;/// &amp;lt;/remarks&amp;gt;&#xA;&#x9;&#x9;protected override AuthenticationResults GenerateArcAuthenticationResults (FormatOptions options, MimeMessage message, CancellationToken cancellationToken)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;const string AuthenticationServiceIdentifier = &#34;lists.example.com&#34;;&#xA;&#xA;&#x9;&#x9;&#x9;var results = new AuthenticationResults (AuthenticationServiceIdentifier);&#xA;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &amp;lt; message.Headers.Count; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;var header = message.Headers[i];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (header.Id != HeaderId.AuthenticationResults)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (!AuthenticationResults.TryParse (header.RawValue, out AuthenticationResults authres))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (authres.AuthenticationServiceIdentifier != AuthenticationServiceIdentifier)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Merge any authentication results that aren&#39;t already known.&#xA;&#x9;&#x9;&#x9;&#x9;foreach (var result in authres.Results) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!results.Results.Any (r =&amp;gt; r.Method == result.Method))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;results.Results.Add (result);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return results;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &amp;lt;summary&amp;gt;&#xA;&#x9;&#x9;/// Generate the ARC-Authentication-Results asynchronously.&#xA;&#x9;&#x9;/// &amp;lt;/summary&amp;gt;&#xA;&#x9;&#x9;/// &amp;lt;remarks&amp;gt;&#xA;&#x9;&#x9;/// The ARC-Authentication-Results header contains information detailing the results of&#xA;&#x9;&#x9;/// authenticating/verifying the message via ARC, DKIM, SPF, etc.&#xA;&#x9;&#x9;///&#xA;&#x9;&#x9;/// In the following implementation, we assume that we have to verify all of the various&#xA;&#x9;&#x9;/// authentication methods ourselves.&#xA;&#x9;&#x9;///&#xA;&#x9;&#x9;/// Note: This method is used when ArcSigner.SignAsync() is called instead of ArcSigner.Sign().&#xA;&#x9;&#x9;/// &amp;lt;/remarks&amp;gt;&#xA;&#x9;&#x9;protected override async Task&amp;lt;AuthenticationResults&amp;gt; GenerateArcAuthenticationResultsAsync (FormatOptions options, MimeMessage message, CancellationToken cancellationToken)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;const string AuthenticationServiceIdentifier = &#34;lists.example.com&#34;;&#xA;&#xA;&#x9;&#x9;&#x9;var results = new AuthenticationResults (AuthenticationServiceIdentifier);&#xA;&#x9;&#x9;&#x9;var locator = new DkimPublicKeyLocator (); // from the DKIM example above&#xA;&#x9;&#x9;&#x9;var dkimVerifier = new DkimVerifier (locator);&#xA;&#x9;&#x9;&#x9;var arcVerifier = new ArcVerifier (locator);&#xA;&#x9;&#x9;&#x9;AuthenticationMethodResult method;&#xA;&#xA;&#x9;&#x9;&#x9;// Add the ARC authentication results&#xA;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;var arc = await arcVerifier.VerifyAsync (message, cancellationToken);&#xA;&#x9;&#x9;&#x9;&#x9;var result = arc.Chain.ToString ().ToLowerInvariant ();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;method = new AuthenticationMethodResult (&#34;arc&#34;, result);&#xA;&#x9;&#x9;&#x9;&#x9;results.Results.Add (method);&#xA;&#x9;&#x9;&#x9;} catch {&#xA;&#x9;&#x9;&#x9;&#x9;// Likely a DNS error&#xA;&#x9;&#x9;&#x9;&#x9;method = new AuthenticationMethodResult (&#34;arc&#34;, &#34;fail&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;method.Reason = &#34;DNS error&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;results.Results.Add (method);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// Add authentication results for each DKIM signature&#xA;&#x9;&#x9;&#x9;foreach (var dkimHeader in message.Headers.Where (h =&amp;gt; h.Id == HeaderId.DkimSignature)) {&#xA;&#x9;&#x9;&#x9;&#x9;string result;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (await dkimVerifier.VerifyAsync (message, cancellationToken)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result = &#34;pass&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result = &#34;fail&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} catch {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result = &#34;fail&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;method = new AuthenticationMethodResult (&#34;dkim&#34;, result);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Parse the DKIM-Signature header so that we can add some&#xA;&#x9;&#x9;&#x9;&#x9;// properties to our method result.&#xA;&#x9;&#x9;&#x9;&#x9;var params = dkimHeader.Value.Replace (&#34; &#34;, &#34;&#34;).Split (new char[] { &#39;;&#39; });&#xA;&#x9;&#x9;&#x9;&#x9;var i = params.FirstOrDefault (p =&amp;gt; p.StartsWith (&#34;i=&#34;, StringComparison.Ordinal));&#xA;&#x9;&#x9;&#x9;&#x9;var b = params.FirstOrDefault (p =&amp;gt; p.StartsWith (&#34;b=&#34;, StringComparison.Ordinal));&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (i != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;method.Parameters.Add (&#34;header.i&#34;, i.Substring (2));&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (b != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;method.Parameters.Add (&#34;header.b&#34;, b.Substring (2, 8));&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;results.Results.Add (method);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return results;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you have a custom &lt;code&gt;ArcSigner&lt;/code&gt; class, the actual logic for signing is almost identical to DKIM.&lt;/p&gt; &#xA;&lt;p&gt;Note: As with the DKIM signing example above, assume that the private key is saved in a file called &lt;strong&gt;privatekey.pem&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var headers = new HeaderId[] { HeaderId.From, HeaderId.Subject, HeaderId.Date };&#xA;var signer = new MyArcSigner (&#34;privatekey.pem&#34;, &#34;example.com&#34;, &#34;brisbane&#34;, DkimSignatureAlgorithm.RsaSha256) {&#xA;&#x9;HeaderCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Relaxed,&#xA;&#x9;BodyCanonicalizationAlgorithm = DkimCanonicalizationAlgorithm.Relaxed,&#xA;&#x9;AgentOrUserIdentifier = &#34;@eng.example.com&#34;&#xA;};&#xA;&#xA;// Prepare the message body to be sent over a 7bit transport (such as older versions of SMTP).&#xA;// Note: If the SMTP server you will be sending the message over supports the 8BITMIME extension,&#xA;// then you can use `EncodingConstraint.EightBit` instead.&#xA;message.Prepare (EncodingConstraint.SevenBit);&#xA;&#xA;signer.Sign (message, headers); // or SignAsync&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Verifying ARC Signatures&lt;/h3&gt; &#xA;&lt;p&gt;Just like with verifying DKIM signatures, you will need to implement the &lt;code&gt;IDkimPublicKeyLocator&lt;/code&gt; interface. To see an example of how to implement this interface, see the DKIM signature verification example above.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ArcVerifier&lt;/code&gt; works exactly the same as the &lt;code&gt;DkimVerifier&lt;/code&gt; except that it is not necessary to provide a &lt;code&gt;Header&lt;/code&gt; argument to the &lt;code&gt;Verify&lt;/code&gt; or &lt;code&gt;VerifyAsync&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var verifier = new ArcVerifier (new DkimPublicKeyLocator ());&#xA;var results = await verifier.VerifyAsync (message);&#xA;&#xA;// The Chain results are the only real important results.&#xA;Console.WriteLine (&#34;ARC results: {0}&#34;, results.Chain);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;The first thing you&#39;ll need to do is fork MimeKit to your own GitHub repository. For instructions on how to do that, see the section titled &lt;strong&gt;Getting the Source Code&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://visualstudio.microsoft.com/vs/mac/&#34;&gt;Visual Studio for Mac&lt;/a&gt; or &lt;a href=&#34;http://monodevelop.com&#34;&gt;MonoDevelop&lt;/a&gt;, all of the solution files are configured with the coding style used by MimeKit. If you use Visual Studio on Windows or some other editor, please try to maintain the existing coding style as best as you can.&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve got some changes that you&#39;d like to submit upstream to the official MimeKit repository, send me a &lt;strong&gt;Pull Request&lt;/strong&gt; and I will try to review your changes in a timely manner.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to contribute but don&#39;t have any particular features in mind to work on, check out the issue tracker and look for something that might pique your interest!&lt;/p&gt; &#xA;&lt;h2&gt;Reporting Bugs&lt;/h2&gt; &#xA;&lt;p&gt;Have a bug or a feature request? Please open a new &lt;a href=&#34;https://github.com/jstedfast/MimeKit/issues/new?template=bug_report.md&#34;&gt;bug report&lt;/a&gt; or &lt;a href=&#34;https://github.com/jstedfast/MimeKit/issues/new?template=feature_request.md&#34;&gt;feature request&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before opening a new issue, please search through any &lt;a href=&#34;https://github.com/jstedfast/MimeKit/issues&#34;&gt;existing issues&lt;/a&gt; to avoid submitting duplicates. It may also be worth checking the &lt;a href=&#34;https://github.com/jstedfast/MimeKit/raw/master/FAQ.md&#34;&gt;FAQ&lt;/a&gt; for common questions that other developers have had.&lt;/p&gt; &#xA;&lt;p&gt;If you are getting an exception from somewhere within MimeKit, don&#39;t just provide the &lt;code&gt;Exception.Message&lt;/code&gt; string. Please include the &lt;code&gt;Exception.StackTrace&lt;/code&gt; as well. The &lt;code&gt;Message&lt;/code&gt;, by itself, is often useless.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;API documentation can be found at &lt;a href=&#34;http://www.mimekit.net/docs&#34;&gt;http://www.mimekit.net/docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A copy of the XML-formatted API reference documentation is also included in the NuGet package.&lt;/p&gt; &#xA;&lt;h2&gt;.NET Foundation&lt;/h2&gt; &#xA;&lt;p&gt;MimeKit is a &lt;a href=&#34;https://www.dotnetfoundation.org/projects&#34;&gt;.NET Foundation&lt;/a&gt; project.&lt;/p&gt; &#xA;&lt;p&gt;This project has adopted the code of conduct defined by the &lt;a href=&#34;http://contributor-covenant.org/&#34;&gt;Contributor Covenant&lt;/a&gt; to clarify expected behavior in our community. For more information, see the &lt;a href=&#34;http://www.dotnetfoundation.org/code-of-conduct&#34;&gt;.NET Foundation Code of Conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;General .NET OSS discussions: &lt;a href=&#34;https://forums.dotnetfoundation.org&#34;&gt;.NET Foundation forums&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>