<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-28T01:27:38Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>runevision/LayerProcGen</title>
    <updated>2024-05-28T01:27:38Z</updated>
    <id>tag:github.com,2024-05-28:/runevision/LayerProcGen</id>
    <link href="https://github.com/runevision/LayerProcGen" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Layer-based infinite procedural generation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LayerProcGen&lt;/h1&gt; &#xA;&lt;p&gt;LayerProcGen is a framework that can be used to implement layer-based procedural generation that&#39;s &lt;strong&gt;infinite&lt;/strong&gt;, &lt;strong&gt;deterministic&lt;/strong&gt; and &lt;strong&gt;contextual&lt;/strong&gt;. It works out of the box in Unity but can be used in any C#-compatible engine.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://runevision.github.io/LayerProcGen/&#34;&gt;Documentation&lt;/a&gt; - &lt;a href=&#34;https://github.com/runevision/LayerProcGen&#34;&gt;GitHub&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/runevision/LayerProcGen/main/Documentation/ContextualTransition.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The framework does not itself include any procedural generation algorithms. At its core, it&#39;s a way to keep track of dependencies between generation processes in a powerful spatial way.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Generating infinite worlds in chunks is a well-known concept since Minecraft.&lt;/em&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;em&gt;However, there is a widespread misconception that the chunk-based approach canâ€™t be used deterministically with algorithms where the surroundings of a chunk would need to affect the chunk itself.&lt;/em&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;em&gt;LayerProcGen is designed to help with just that.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Contextual &amp;amp; deterministic&lt;/strong&gt;&lt;br&gt; A central purpose of the framework is to support contextual generation while staying deterministic. Procedural operations can be performed across chunk boundaries, producing seamless results for context-based operations such as blurring, point relaxation, or path-finding. This is possible by dividing the generation into multiple layers and keeping a strict separation between the input and output of each layer.&lt;br&gt; &lt;a href=&#34;https://runevision.github.io/LayerProcGen/md_ContextualGeneration.html&#34;&gt;Contextual Generation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Plan at scale with intent&lt;/strong&gt;&lt;br&gt; Chunks in one layer can be orders of magnitude larger than chunks in another layer, and you can design them to operate at different levels of abstraction. You can use top-down planning to e.g. have road signs point to distant locations, unlock entire regions based on player progress, or have NPCs talk about things at the other side of the continent.&lt;br&gt; &lt;a href=&#34;https://runevision.github.io/LayerProcGen/md_PlanningAtScale.html&#34;&gt;Planning at Scale&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bring your own algorithms&lt;/strong&gt;&lt;br&gt; You implement data layers by creating pairs of layer and chunk classes, and you can use whichever generation techniques you want there, as long as they are suitable for generation in chunks on the fly.&lt;br&gt; &lt;a href=&#34;https://runevision.github.io/LayerProcGen/md_LayersAndChunks.html&#34;&gt;Layers and Chunks&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Handles dependencies&lt;/strong&gt;&lt;br&gt; The framework makes it possible to build many different chunk-based procedural data layers with dependencies between each other. It automatically generates depended on chunks when they are needed by chunks in other layers, or by top level requirements.&lt;br&gt; &lt;a href=&#34;https://runevision.github.io/LayerProcGen/md_LayerDependencies.html&#34;&gt;Layer Dependencies&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Two-dimensional infinity&lt;/strong&gt;&lt;br&gt; The framework arranges chunks in either a horizontal or vertical plane. It can be used for 2D or 3D worlds, but 3D worlds can only extend infinitely in two dimensions, similar to Minecraft. The infinity is pseudo-infinite, as it is limited by the range of 32-bit integer numbers and the specifics of which calculations you use in your procedural processes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Multi-threaded&lt;/strong&gt;&lt;br&gt; The framework is multi-threaded based on Parallel.ForEach functionality in .Net. The degree of parallelism automatically scales to the number of available cores. When needed, actions can be enqueued to be performed on the main thread.&lt;/p&gt; &#xA;&lt;h2&gt;Installation in Unity&lt;/h2&gt; &#xA;&lt;p&gt;LayerProcGen requires Unity 2019.4 or later.&lt;/p&gt; &#xA;&lt;p&gt;Install LayerProcGen as a Unity Package Manager package from this Git URL:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;https://github.com/runevision/LayerProcGen.git#upm&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://docs.unity3d.com/Manual/upm-ui-giturl.html&#34;&gt;Unity&#39;s instructions here&lt;/a&gt;. If you already have Git installed, it&#39;s simply these steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open the Package Manager window via &lt;code&gt;Window &amp;gt; Package Manager&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click the &lt;code&gt;+&lt;/code&gt; button and choose &lt;code&gt;Add package from git URL...&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Paste the URL: &lt;code&gt;https://github.com/runevision/LayerProcGen.git#upm&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click &lt;code&gt;Add&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Samples&lt;/h3&gt; &#xA;&lt;p&gt;You can also import samples for how to use the framework on the &lt;code&gt;Samples&lt;/code&gt; tab of the package.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;Simple Samples&lt;/em&gt; have no special requirements.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;Terrain Sample&lt;/em&gt; requires:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Burst package&lt;/li&gt; &#xA; &lt;li&gt;Input System package&lt;/li&gt; &#xA; &lt;li&gt;Player Settings: Enabling &lt;code&gt;Allow unsafe code&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Player Settings: Setting &lt;code&gt;Active Input Handling&lt;/code&gt; to &lt;code&gt;Both&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Only tested with Builtin Render Pipeline&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Platform support&lt;/h2&gt; &#xA;&lt;p&gt;The functionality should in general work on all platforms.&lt;/p&gt; &#xA;&lt;p&gt;The save-state functionality depends on the open-source FBPP (File Based Player Prefs) solution, which has been tested on Windows, MacOS, Linux, iOS and Android. Extending it to work on other platforms will likely be straightforward for someone porting a game for those platforms.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;LayerProcGen is licensed under the &lt;a href=&#34;https://mozilla.org/MPL/2.0/&#34;&gt;Mozilla Public License, v. 2.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can read a summary &lt;a href=&#34;https://choosealicense.com/licenses/mpl-2.0/&#34;&gt;here&lt;/a&gt;. In short: If you make changes/improvements to LayerProcGen, you must share those for free with the community. But the rest of the source code for your game or application is not subject to this license, so there&#39;s nothing preventing you from creating proprietary and commercial games that use LayerProcGen.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jonathanpeppers/dotnes</title>
    <updated>2024-05-28T01:27:38Z</updated>
    <id>tag:github.com,2024-05-28:/jonathanpeppers/dotnes</id>
    <link href="https://github.com/jonathanpeppers/dotnes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;.NET for the NES game console&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;.NES (&#34;dot&#34; NES)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jonathanpeppers/dotnes/main/assets/logo.png&#34; alt=&#34;dot NES logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;.NET for the NES game console!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jonathanpeppers/dotnes/main/assets/vscode.gif&#34; alt=&#34;Gif of NES Emulator launching from VS Code&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Simply install the template:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;dotnet new install dotnes.templates&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;dotnet new nes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or use the project template in Visual Studio:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jonathanpeppers/dotnes/main/assets/vs-template.png&#34; alt=&#34;Screenshot of the NES project template in Visual Studio&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Build and run it as you would a console app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;dotnet run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, you can also just open the project in Visual Studio and hit F5.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that Ctrl+F5 currently works better in C# Dev Kit in VS Code.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Check out the video for a full demo:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/m4TU5PJ8WtY&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/m4TU5PJ8WtY/maxresdefault.jpg&#34; alt=&#34;Check out the video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Anatomy of an NES application&lt;/h2&gt; &#xA;&lt;p&gt;&#34;Hello World&#34; looks something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// set palette colors&#xA;pal_col(0, 0x02);   // set screen to dark blue&#xA;pal_col(1, 0x14);   // fuchsia&#xA;pal_col(2, 0x20);   // grey&#xA;pal_col(3, 0x30);   // white&#xA;&#xA;// write text to name table&#xA;vram_adr(NTADR_A(2, 2));            // set address&#xA;vram_write(&#34;Hello, world!&#34;);         // write bytes to video RAM&#xA;&#xA;// enable PPU rendering (turn on screen)&#xA;ppu_on_all();&#xA;&#xA;// infinite loop&#xA;while (true) ;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This looks very much like &lt;a href=&#34;https://8bitworkshop.com/v3.10.0/?platform=nes&amp;amp;file=hello.c&#34;&gt;&#34;Hello World&#34; in C&lt;/a&gt;, taking advantage of the latest C# features in 2023.&lt;/p&gt; &#xA;&lt;p&gt;By default the APIs like &lt;code&gt;pal_col&lt;/code&gt;, etc. are provided by an implicit &lt;code&gt;global using static NESLib;&lt;/code&gt; and all code is written within a single &lt;code&gt;Program.cs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, a &lt;code&gt;chr_generic.s&lt;/code&gt; file is included as your game&#39;s &#34;artwork&#34; (lol?):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.segment &#34;CHARS&#34;&#xA;.byte $00,$00,$00,$00,$00,$00,$00,$00&#xA;...&#xA;.byte $B4,$8C,$FC,$3C,$98,$C0,$00,$00&#xA;;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This table of data is used to render sprites, text, etc.&lt;/p&gt; &#xA;&lt;h2&gt;Scope&lt;/h2&gt; &#xA;&lt;p&gt;The types of things I wanted to get working initially:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An object model for writing NES binaries&lt;/li&gt; &#xA; &lt;li&gt;Building a project should produce a &lt;code&gt;*.nes&lt;/code&gt; binary, that is byte-for-byte identical to a program written in C.&lt;/li&gt; &#xA; &lt;li&gt;&#34;Hello World&#34; runs&lt;/li&gt; &#xA; &lt;li&gt;Byte arrays, and a more advanced sample like &lt;code&gt;attributetable&lt;/code&gt; run&lt;/li&gt; &#xA; &lt;li&gt;Local variables work in some form&lt;/li&gt; &#xA; &lt;li&gt;Project template, MSBuild support, IDE support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Down the road, I might think about support for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Methods&lt;/li&gt; &#xA; &lt;li&gt;Structs&lt;/li&gt; &#xA; &lt;li&gt;Multiple files&lt;/li&gt; &#xA; &lt;li&gt;Some subset of useful BCL methods&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;For lack of a better word, .NES is a &#34;transpiler&#34; that takes &lt;a href=&#34;https://en.wikipedia.org/wiki/MSIL&#34;&gt;MSIL&lt;/a&gt; and transforms it directly into a working &lt;a href=&#34;http://www.6502.org/&#34;&gt;6502 microprocessor&lt;/a&gt; binary that can run in your favorite NES emulator. If you think about .NET&#39;s Just-In-Time (JIT) compiler or the various an Ahead-Of-Time (AOT) compilers, .NES is doing something similiar: taking MSIL and turning it into runnable machine code.&lt;/p&gt; &#xA;&lt;p&gt;To understand further, let&#39;s look at the MSIL of a &lt;code&gt;pal_col&lt;/code&gt; method call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-msil&#34;&gt;// pal_col((byte)0, (byte)2);&#xA;IL_0000: ldc.i4.0&#xA;IL_0001: ldc.i4.2&#xA;IL_0002: call void [neslib]NES.NESLib::pal_col(uint8, uint8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In 6502 assembly, this would look something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;A900          LDA #$00&#xA;20A285        JSR pusha&#xA;A902          LDA #$02&#xA;203E82        JSR _pal_col&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can see how one might envision using &lt;a href=&#34;https://learn.microsoft.com/dotnet/api/system.reflection.metadata&#34;&gt;System.Reflection.Metadata&lt;/a&gt; to iterate over the contents of a .NET assembly and generate &lt;a href=&#34;https://www.masswerk.at/6502/6502_instruction_set.html&#34;&gt;6502 instructions&lt;/a&gt; -- that&#39;s how this whole idea was born!&lt;/p&gt; &#xA;&lt;p&gt;Note that the method &lt;code&gt;NESLib.pal_col()&lt;/code&gt; has no actual C# implementation. In fact! there is &lt;em&gt;only&lt;/em&gt; a reference assembly even shipped in .NES:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;&amp;gt; 7z l dotnes.0.1.1-alpha.nupkg&#xA;   Date      Time    Attr         Size   Compressed  Name&#xA;------------------- ----- ------------ ------------  ------------------------&#xA;2023-09-14 14:37:38 .....         8192         3169  ref\net8.0\neslib.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you decompile &lt;code&gt;neslib.dll&lt;/code&gt;, no code is inside:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Warning! This assembly is marked as a &#39;reference assembly&#39;, which means that it only contains metadata and no executable code.&#xA;// neslib, Version=0.1.0.0, Culture=neutral, PublicKeyToken=null&#xA;// NES.NESLib&#xA;public static void pal_col(byte index, byte color) =&amp;gt; throw null;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When generating &lt;code&gt;*.nes&lt;/code&gt; binaries, .NES simply does a lookup for &lt;code&gt;pal_col&lt;/code&gt; to &#34;jump&#34; to the appropriate subroutine to call it.&lt;/p&gt; &#xA;&lt;p&gt;.NES also emits the assembly instructions for the actual &lt;code&gt;pal_col&lt;/code&gt; subroutine, a code snippet of the implementation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;/*&#xA;* 823E&#x9;8517          &#x9;STA TEMP                      ; _pal_col&#xA;* 8240&#x9;209285        &#x9;JSR popa                      &#xA;* 8243&#x9;291F          &#x9;AND #$1F                      &#xA;* 8245&#x9;AA            &#x9;TAX                           &#xA;* 8246&#x9;A517          &#x9;LDA TEMP                      &#xA;* 8248&#x9;9DC001        &#x9;STA $01C0,x                   &#xA;* 824B&#x9;E607          &#x9;INC PAL_UPDATE                &#xA;* 824D&#x9;60            &#x9;RTS&#xA;*/&#xA;Write(NESInstruction.STA_zpg, TEMP);&#xA;Write(NESInstruction.JSR, popa.GetAddressAfterMain(sizeOfMain));&#xA;Write(NESInstruction.AND, 0x1F);&#xA;Write(NESInstruction.TAX_impl);&#xA;Write(NESInstruction.LDA_zpg, TEMP);&#xA;Write(NESInstruction.STA_abs_X, PAL_BUF);&#xA;Write(NESInstruction.INC_zpg, PAL_UPDATE);&#xA;Write(NESInstruction.RTS_impl);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;This is a hobby project, so only around 5 C# programs are known to work. But to get an idea of what is not available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No runtime&lt;/li&gt; &#xA; &lt;li&gt;No BCL&lt;/li&gt; &#xA; &lt;li&gt;No objects or GC&lt;/li&gt; &#xA; &lt;li&gt;No debugger&lt;/li&gt; &#xA; &lt;li&gt;Strings are ASCII&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What we &lt;em&gt;do&lt;/em&gt; have is a way to express an NES program in a single &lt;code&gt;Program.cs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;p&gt;To learn more about NES development, I found the following useful:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://8bitworkshop.com&#34;&gt;8bitworkshop&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.vbforums.com/showthread.php?858389-NES-6502-Programming-Tutorial-Part-1-Getting-Started&#34;&gt;NES 6502 Programming Tutorial&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wiki.nesdev.org/w/index.php/INES&#34;&gt;INES File Format&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.masswerk.at/6502/6502_instruction_set.html&#34;&gt;6502 Instruction Set&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mh-nexus.de/en/hxd/&#34;&gt;HxD Hex Editor&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ANESE License&lt;/h2&gt; &#xA;&lt;p&gt;I needed a simple, small NES emulator to redistribute with .NES that runs on Mac and Windows. Special thanks to &lt;a href=&#34;https://github.com/daniel5151/ANESE&#34;&gt;@daniel5151 and ANESE&lt;/a&gt;. This is the default NES emulator used in the &lt;code&gt;dotnet.anese&lt;/code&gt; package, &lt;a href=&#34;https://github.com/daniel5151/ANESE/raw/8ae814d615479b1496c98033a1f5bc4da5921c6f/LICENSE&#34;&gt;license here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>