<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-31T01:32:22Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SitronX/UnityTimeRewinder</title>
    <updated>2022-10-31T01:32:22Z</updated>
    <id>tag:github.com,2022-10-31:/SitronX/UnityTimeRewinder</id>
    <link href="https://github.com/SitronX/UnityTimeRewinder" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unity time rewind solution, that is easily customizable for any project.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/68167377/196243323-3509d486-b9dd-4575-9753-134ab1b39de2.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;Time Rewinder for Unity&lt;/h1&gt; &#xA;&lt;p&gt;Rewind time in Unity with ease! While there are certain frameworks that let you rewind time in Unity, they are usually quite restrictive and hard to modify. I faced these problems myself when i needed to add time rewind mechanics in my game and none of the solutions that i have found were good enough. That is why i decided to start this open source project that i hope you find usefull. Time Rewinder uses highly efficient circular buffer implementation to store and retrieve the rewinded values.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Customizability is one of the main points of this project, so it can be used in any of your custom Unity projects and you can track and rewind anything you want!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Straight from the box you can start rewinding &lt;strong&gt;positions, rotations, velocities, animators (also all animator layers), audios and particle systems&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to install&lt;/h2&gt; &#xA;&lt;p&gt;You have two options how to install it into your project.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First option is to download prepared Unity package in Github release section. After download, open your Unity project and simply open the downloaded package, import dialogue window should appear (Unity should automatically associate the package with itself). If it didnt work out for you, you can also import it thru Unity package manager.&lt;/li&gt; &#xA; &lt;li&gt;Second option is to download this sample project from Github and start using it, or just import the TimeRewinder folder under Assets/TimeRewinder into your project&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;TimeRewinder supports two types of rewinds.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Instant rewinds where you rewind time by specified amount of seconds&lt;/li&gt; &#xA; &lt;li&gt;Rewinds with previews&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The latter of the two is definitely more interesting option, cause you can freely choose which snapshot you can return to after you spectate these previews for yourself. This is especially helpfull if you want to give more control to player with rewinding time. As shown in demo-scene examples, player can choose on the time axis the exact moment he wants to return to, while the time is stopped (technically time is not stopped, but for the objects that are rewinded, it appears like it). The showcase of this mechanic is shown right below. I think, this is also unique feature of this project, because i havent found a similar functionality in other Time Rewind frameworks.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/68167377/196203578-a476d5b1-5314-49bd-933d-904eba1dd51a.gif&#34; alt=&#34;ezgif com-gif-maker (9)&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The classic functionality to rewind time by holding button, which you probably already know from other solutions is also here. These two types of rewinds inputs are prepared straight from the box, but it would be very easy to design completely new rewind input system. You would only have to call corresponding methods, that are all prepared and documented for you.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/68167377/196241351-b1c05483-79e1-4554-8fc2-d4f6efc69b14.gif&#34; alt=&#34;ezgif com-gif-maker (10)&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;p&gt;Detailed steps how to use TimeRewinder are described in &lt;a href=&#34;https://github.com/SitronX/UnityTimeRewinder/raw/main/Assets/TimeRewinder/Documentation/Unity%20Time%20Rewinder.pdf&#34;&gt;documentation&lt;/a&gt; and all important parts of code are also documented.&lt;/p&gt; &#xA;&lt;p&gt;If you still face any problem, dont hesitate to contact me, I will gladly help you out.&lt;/p&gt; &#xA;&lt;h2&gt;Showcase of rewinding&lt;/h2&gt; &#xA;&lt;p&gt;In demo-scenes there are few examples of time rewinding, as well as two examples of tracking and rewinding custom variables. I recommend you look into it , so you get the idea how everything is connected. Here comes few other videos showcasing rewinding time from demo scenes&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/68167377/196215651-c3002e8b-a722-4bb6-b655-81946cfeff18.mp4&#34;&gt;https://user-images.githubusercontent.com/68167377/196215651-c3002e8b-a722-4bb6-b655-81946cfeff18.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/68167377/196215735-e3e612a4-aa69-40e2-8e4f-3fd68669b667.mp4&#34;&gt;https://user-images.githubusercontent.com/68167377/196215735-e3e612a4-aa69-40e2-8e4f-3fd68669b667.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/68167377/196240813-ba4c6b79-ebec-461e-9bbe-335cc75a7af7.mp4&#34;&gt;https://user-images.githubusercontent.com/68167377/196240813-ba4c6b79-ebec-461e-9bbe-335cc75a7af7.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;And here is example and maybe motivation how it could look in actual game (mobile game), where you customize it for your needs :)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/68167377/196215814-45e4667b-748a-4eff-a2ce-8c62b9d90f29.mp4&#34;&gt;https://user-images.githubusercontent.com/68167377/196215814-45e4667b-748a-4eff-a2ce-8c62b9d90f29.mp4&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Accenture/Spartacus</title>
    <updated>2022-10-31T01:32:22Z</updated>
    <id>tag:github.com,2022-10-31:/Accenture/Spartacus</id>
    <link href="https://github.com/Accenture/Spartacus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Spartacus DLL Hijacking Discovery Tool&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Spartacus DLL Hijacking&lt;/h1&gt; &#xA;&lt;h2&gt;Why &#34;Spartacus&#34;?&lt;/h2&gt; &#xA;&lt;p&gt;If you have seen the film Spartacus from 1960, you will remember the scene where the Romans are asking for Spartacus to give himself up. The moment the real Spartacus stood up, a lot of others stood up as well and claimed to be him using the &#34;I AM SPARTACUS&#34; phrase.&lt;/p&gt; &#xA;&lt;p&gt;When a process that is vulnerable to DLL Hijacking is asking for a DLL to be loaded, it&#39;s kind of asking &#34;WHO IS VERSION.DLL?&#34; and random directories start claiming &#34;I AM VERSION.DLL&#34; and &#34;NO, I AM VERSION.DLL&#34;. And thus, Spartacus.&lt;/p&gt; &#xA;&lt;h2&gt;Did you really make yet another DLL Hijacking discovery tool?&lt;/h2&gt; &#xA;&lt;p&gt;...but with a twist as Spartacus is utilising the &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/procmon&#34;&gt;SysInternals Process Monitor&lt;/a&gt; and is parsing raw PML log files. You can leave ProcMon running for hours and discover 2nd and 3rd level (ie an app that loads another DLL that loads yet another DLL when you use a specific feature of the parent app) DLL Hijacking vulnerabilities. It will also automatically generate proxy DLLs with all relevant exports for vulnerable DLLs.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Parsing ProcMon PML files natively. The config (PMC) and log (PML) parsers have been implemented by porting partial functionality to C# from &lt;a href=&#34;https://github.com/eronnen/procmon-parser/&#34;&gt;https://github.com/eronnen/procmon-parser/&lt;/a&gt;. You can find the format specification &lt;a href=&#34;https://github.com/eronnen/procmon-parser/tree/master/docs&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Spartacus will create proxy DLLs for all missing DLLs that were identified. For instance, if an application is vulnerable to DLL Hijacking via &lt;code&gt;version.dll&lt;/code&gt;, Spartacus will create a &lt;code&gt;version.dll.cpp&lt;/code&gt; file for you with all the exports included in it. Then you can insert your payload/execution technique and compile.&lt;/li&gt; &#xA; &lt;li&gt;Able to process large PML files and store all DLLs of interest in an output CSV file. Local benchmark processed a 3GB file with 8 million events in 45 seconds.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[Defence]&lt;/code&gt; Monitoring mode trying to identify running applications proxying calls, as in &#34;DLL Hijacking in progress&#34;. This is just to get any low hanging fruit and should not be relied upon.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#screenshots&#34;&gt;Screenshots&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#spartacus-execution&#34;&gt;Spartacus Execution&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#csv-output&#34;&gt;CSV Output&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#output-exports&#34;&gt;Exports&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#export-dll-functions&#34;&gt;Export DLL Functions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#execution-flow&#34;&gt;Execution Flow&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#command-line-arguments&#34;&gt;Command Line Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#proxy-dll-template&#34;&gt;Proxy DLL Template&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#contributions&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Screenshots&lt;/h1&gt; &#xA;&lt;h2&gt;Spartacus Execution&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/screenshots/runtime.png&#34; alt=&#34;Running Spartacus&#34; title=&#34;Running Spartacus&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CSV Output&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/screenshots/output.png&#34; alt=&#34;CSV Output&#34; title=&#34;CSV Output&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Output Exports&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/screenshots/exports.png&#34; alt=&#34;Exports&#34; title=&#34;Exports&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Export DLL Functions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Accenture/Spartacus/main/screenshots/exports-version.png&#34; alt=&#34;DLL Functions&#34; title=&#34;DLL Functions&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;Execution Flow&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Generate a ProcMon (PMC) config file on the fly, based on the arguments passed. The filters that will be set are: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Operation is &lt;code&gt;CreateFile&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Path ends with &lt;code&gt;.dll&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Process name is not &lt;code&gt;procmon.exe&lt;/code&gt; or &lt;code&gt;procmon64.exe&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Enable &lt;code&gt;Drop Filtered Events&lt;/code&gt; to ensure minimum PML output size.&lt;/li&gt; &#xA;   &lt;li&gt;Disable &lt;code&gt;Auto Scroll&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Execute Process Monitor.&lt;/li&gt; &#xA; &lt;li&gt;Halt its execution until the user presses &lt;code&gt;ENTER&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Terminates Process Monitor.&lt;/li&gt; &#xA; &lt;li&gt;Parses the output Event Log (PML) file. &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Creates a CSV file with all the NAME_NOT_FOUND and PATH_NOT_FOUND DLLs.&lt;/li&gt; &#xA;   &lt;li&gt;Compares the DLLs from above and tries to identify the DLLs that were actually loaded.&lt;/li&gt; &#xA;   &lt;li&gt;For every &#34;found&#34; DLL it generates a proxy DLL with all its export functions.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Command Line Arguments&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Argument&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--pml&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Location (file) to store the ProcMon event log file. If the file exists, it will be overwritten. When used with &lt;code&gt;--existing-log&lt;/code&gt; it will indicate the event log file to read from and will not be overwritten.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--pmc&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Define a custom ProcMon (PMC) file to use. This file will not be modified and will be used as is.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--csv&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Location (file) to store the CSV output of the execution. This file will include only the DLLs that were marked as NAME_NOT_FOUND, PATH_NOT_FOUND, and were in user-writable locations (it excludes anything in the &lt;code&gt;Windows&lt;/code&gt; and &lt;code&gt;Program Files&lt;/code&gt; directories)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--exe&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Define process names (comma separated) that you want to track, helpful when you are interested only in a specific process.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--exports&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Location (folder) in which all the proxy DLL files will be saved. Proxy DLL files will only be generated if this argument is used.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--procmon&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Location (file) of the SysInternals Process Monitor &lt;code&gt;procmon.exe&lt;/code&gt; or &lt;code&gt;procmon64.exe&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--proxy-dll-template&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Define a DLL template to use for generating the proxy DLL files. Only relevant when &lt;code&gt;--exports&lt;/code&gt; is used. All &lt;code&gt;#pragma&lt;/code&gt; exports are inserted by replacing the &lt;code&gt;%_PRAGMA_COMMENTS_%&lt;/code&gt; string, so make sure your template includes that string in the relevant location.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--existing-log&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Switch to indicate that Spartacus should process an existing ProcMon event log file (PML). To indicate the event log file use &lt;code&gt;--pml&lt;/code&gt;, useful when you have been running ProcMon for hours or used it in Boot Logging.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--all&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;By default any DLLs in the Windows or Program Files directories will be skipped. Use this to include those directories in the output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--detect&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Try to identify DLLs that are proxying calls (like &#39;DLL Hijacking in progress&#39;). This isn&#39;t a feature to be relied upon, it&#39;s there to get the low hanging fruit.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--verbose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable verbose output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--debug&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable debug output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Collect all events and save them into &lt;code&gt;C:\Data\logs.pml&lt;/code&gt;. All vulnerable DLLs will be saved as &lt;code&gt;C:\Data\VulnerableDLLFiles.csv&lt;/code&gt; and all proxy DLLs in &lt;code&gt;C:\Data\DLLExports&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--procmon C:\SysInternals\Procmon.exe --pml C:\Data\logs.pml --csv C:\Data\VulnerableDLLFiles.csv --exports C:\Data\DLLExports --verbose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Collect events only for &lt;code&gt;Teams.exe&lt;/code&gt; and &lt;code&gt;OneDrive.exe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--procmon C:\SysInternals\Procmon.exe --pml C:\Data\logs.pml --csv C:\Data\VulnerableDLLFiles.csv --exports C:\Data\DLLExports --verbose --exe &#34;Teams.exe,OneDrive.exe&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Collect events only for &lt;code&gt;Teams.exe&lt;/code&gt; and &lt;code&gt;OneDrive.exe&lt;/code&gt;, and use a custom proxy DLL template at &lt;code&gt;C:\Data\myProxySkeleton.cpp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--procmon C:\SysInternals\Procmon.exe --pml C:\Data\logs.pml --csv C:\Data\VulnerableDLLFiles.csv --exports C:\Data\DLLExports --verbose --exe &#34;Teams.exe,OneDrive.exe&#34; --proxy-dll-template C:\Data\myProxySkeleton.cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Collect events only for &lt;code&gt;Teams.exe&lt;/code&gt; and &lt;code&gt;OneDrive.exe&lt;/code&gt;, but don&#39;t generate proxy DLLs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--procmon C:\SysInternals\Procmon.exe --pml C:\Data\logs.pml --csv C:\Data\VulnerableDLLFiles.csv --verbose --exe &#34;Teams.exe,OneDrive.exe&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parse an existing PML event log output, save output to CSV, and generate proxy DLLs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--existing-log --pml C:\MyData\SomeBackup.pml --csv C:\Data\VulnerableDLLFiles.csv --exports C:\Data\DLLExports&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run in monitoring mode and try to detect any applications that is proxying DLL calls.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--detect&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Proxy DLL Template&lt;/h2&gt; &#xA;&lt;p&gt;Below is the template that is used when generating proxy DLLs, the generated &lt;code&gt;#pragma&lt;/code&gt; statements are inserted by replacing the &lt;code&gt;%_PRAGMA_COMMENTS_%&lt;/code&gt; string.&lt;/p&gt; &#xA;&lt;p&gt;The only thing to be aware of is that the &lt;code&gt;pragma&lt;/code&gt; DLL will be using a hardcoded path of its location rather than trying to load it dynamically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once&#xA;&#xA;%_PRAGMA_COMMENTS_%&#xA;&#xA;#include &amp;lt;windows.h&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;atlstr.h&amp;gt;  &#xA;&#xA;VOID Payload() {&#xA;    // Run your payload here.&#xA;}&#xA;&#xA;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)&#xA;{&#xA;    switch (fdwReason)&#xA;    {&#xA;    case DLL_PROCESS_ATTACH:&#xA;        Payload();&#xA;        break;&#xA;    case DLL_THREAD_ATTACH:&#xA;        break;&#xA;    case DLL_THREAD_DETACH:&#xA;        break;&#xA;    case DLL_PROCESS_DETACH:&#xA;        break;&#xA;    }&#xA;    return TRUE;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you wish to use your own template, just make sure the &lt;code&gt;%_PRAGMA_COMMENTS_%&lt;/code&gt; is in the right place.&lt;/p&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;Whether it&#39;s a typo, a bug, or a new feature, Spartacus is very open to contributions as long as we agree on the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You are OK with the MIT license of this project.&lt;/li&gt; &#xA; &lt;li&gt;Before creating a pull request, create an issue so it could be discussed before doing any work as internal development is not tracked via the public GitHub repository. Otherwise you risk having a pull request rejected if for example we are already working on the same/similar feature, or for any other reason.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eronnen/procmon-parser/&#34;&gt;https://github.com/eronnen/procmon-parser/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>redteamsocietegenerale/DLLirant</title>
    <updated>2022-10-31T01:32:22Z</updated>
    <id>tag:github.com,2022-10-31:/redteamsocietegenerale/DLLirant</id>
    <link href="https://github.com/redteamsocietegenerale/DLLirant" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DLLirant is a tool to automatize the DLL Hijacking researches on a specified binary.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DLLirant&lt;/h1&gt; &#xA;&lt;p&gt;DLLirant is a tool to automatize the DLL Hijacking and DLL Proxying researches on a specified binary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot.png&#34; alt=&#34;alt text&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot2.png&#34; alt=&#34;alt text&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot3.png&#34; alt=&#34;alt text&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot4.png&#34; alt=&#34;alt text&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot5.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Final PoC output when a DLL Hijacking is found:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot6.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Old Live Demo (similar to the new version)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/live.gif&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to install&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install LLVM for Windows x64 (LLVM-version-win64.exe): &lt;a href=&#34;https://github.com/llvm/llvm-project/releases&#34;&gt;https://github.com/llvm/llvm-project/releases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Do not forget to check the &#34;Add LLVM to the system PATH for current user&#34; during the installation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;p&gt;Select the desired PE file, if it is an .exe, the application will currently search for DLL Search Order Hijacking, if you select a DLL, the application will offer you to proxy it.&lt;/p&gt; &#xA;&lt;p&gt;Regarding the second option, you must specify a path for the proxy DLL, this path can be specified in two ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;With a name, this will generate the proxy DLL and rename it with the name of the selected DLL, and the application will copy the selected (original) DLL and rename it with the name you selected.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;With a path, this option will generate a single file, the proxy DLL that will call the functions exported from the DLL specified in the text box.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also create an &lt;code&gt;import&lt;/code&gt; directory and place the missing DLL files that your application need if necessary (the DLL files will be copied automatically in the &lt;code&gt;output&lt;/code&gt; directory with the targeted binary).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Concerning the error messages of your targeted application, I tried to avoid the error messages, but you can&#39;t really because the messagebox is generated by the System via csrss.exe, not via the targeted application, so you can try to kill the threads, the child windows, use SetErrorMode etc... it will not work.&lt;/p&gt; &#xA;&lt;h2&gt;Python version&lt;/h2&gt; &#xA;&lt;p&gt;This version is deprecated but if you want to use it, you must install &lt;code&gt;pefile&lt;/code&gt; with pip and:&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;cd&lt;/code&gt; command to your DLLirant directory and to test a binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 DLLirant.py -f &#34;C:\THEFULLPATH\YourBinary.exe&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to create a proxy dll, you can use the -p option on the original vulnerable dll (read &lt;a href=&#34;https://itm4n.github.io/dll-proxying/&#34;&gt;https://itm4n.github.io/dll-proxying/&lt;/a&gt; for more informations):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 DLLirant.py -p &#34;C:\THEFULLPATH\VulnerableDLL.dll&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;The script will create an output directory in the same directory of DLLirant, copy the targeted binary to the output directory.&lt;/p&gt; &#xA;&lt;p&gt;Via the PeNet library, the script will extract the dll names required by the binary, and test each imports functions available one by one by compilate a custom DLL with the required exported functions.&lt;/p&gt; &#xA;&lt;p&gt;If a function required by the binary is executed, the custom DLL will create a &lt;code&gt;C:\DLLirant\output.txt&lt;/code&gt; to be sure that a DLL Hijacking is possible.&lt;/p&gt; &#xA;&lt;p&gt;The PoCs of the DLL Hijackings will be also created in the DLLirant/dll-hijacks directory.&lt;/p&gt; &#xA;&lt;h2&gt;Technical posts (in French)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://sh0ckfr.com/pages/martine-a-la-recherche-de-la-dll-hijacking-perdue/&#34;&gt;https://sh0ckfr.com/pages/martine-a-la-recherche-de-la-dll-hijacking-perdue/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://sh0ckfr.com/pages/martin-et-le-dll-proxying-de-cristal/&#34;&gt;https://sh0ckfr.com/pages/martin-et-le-dll-proxying-de-cristal/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>