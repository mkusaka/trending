<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-30T01:36:11Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zeroruka/GI_Assets</title>
    <updated>2022-06-30T01:36:11Z</updated>
    <id>tag:github.com,2022-06-30:/zeroruka/GI_Assets</id>
    <link href="https://github.com/zeroruka/GI_Assets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Character textures, models and mods for a certain anime game.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GI Assets&lt;/h1&gt; &#xA;&lt;p&gt;A collection of Anime Game Character Model &amp;amp; Texture files for modding.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;DISCLAIMER: Using mods in this repo on official Genshin servers is very likely to get you banned. I do not recommend or condone the use of these scripts and programs on official servers, and if you do use it on official servers I take no responsibility for any consequences as a result.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;免责声明：在官方服务器上使用本库中的MOD，很可能会被封号。我不推荐或纵容在官方服务器上使用这些脚本和程序，如果你依然要在官服上使用，我对由此产生的任何后果不承担责任。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;All guides are in the &lt;a href=&#34;https://github.com/zeroruka/GI_Assets/wiki&#34;&gt;wiki&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;中文教程请看 &lt;a href=&#34;https://github.com/zeroruka/GI-Assets-wiki/wiki&#34;&gt;wiki&lt;/a&gt;&lt;/h2&gt;</summary>
  </entry>
  <entry>
    <title>commandlineparser/commandline</title>
    <updated>2022-06-30T01:36:11Z</updated>
    <id>tag:github.com,2022-06-30:/commandlineparser/commandline</id>
    <link href="https://github.com/commandlineparser/commandline" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The best C# command line parser that brings standardized *nix getopt style, for .NET. Includes F# support&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://ci.appveyor.com/project/commandlineparser/commandline/branch/master&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/p61dj8udxs2aocmo/branch/master?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://nuget.org/packages/commandlineparser&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/commandlineparser.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/CommandLineParser/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/commandlineparser.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/CommandLineParser/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/commandlineparser.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/gsscoder/commandline?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/gsscoder/commandline.svg?sanitize=true&#34; alt=&#34;Join the Gitter chat!&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Command Line Parser Library for CLR and NetStandard&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the API surface has changed since v1.9.x and earlier. If you are looking for documentation on v1.9.x, please see &lt;a href=&#34;https://github.com/gsscoder/commandline/tree/stable-1.9.71.2&#34;&gt;stable-1.9.71.2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Command Line Parser Library offers CLR applications a clean and concise API for manipulating command line arguments and related tasks, such as defining switches, options and verb commands. It allows you to display a help screen with a high degree of customization and a simple way to report syntax errors to the end user.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\Project&amp;gt; NuGet Install CommandLineParser&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Nightly Build&lt;/h1&gt; &#xA;&lt;p&gt;Nightly version of the CommandLineParser can be downloaded from github &lt;a href=&#34;https://github.com/commandlineparser/commandline/releases&#34;&gt;Releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The Last new features and fixes, read &lt;a href=&#34;https://github.com/commandlineparser/commandline/raw/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: Mentioned F# Support is provided via &lt;code&gt;CommandLineParser.FSharp&lt;/code&gt; package with FSharp dependencies.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;This library provides &lt;em&gt;hassle free&lt;/em&gt; command line parsing with a constantly updated API since 2005.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;At a glance:&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compatible with &lt;strong&gt;.NET Framework 4.0+&lt;/strong&gt;, &lt;strong&gt;Mono 2.1+ Profile&lt;/strong&gt;, &lt;strong&gt;.NET Standard&lt;/strong&gt; and &lt;strong&gt;.NET Core&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Doesn&#39;t depend on other packages (No dependencies beyond standard base libraries)&lt;/li&gt; &#xA; &lt;li&gt;One line parsing using default singleton: &lt;code&gt;CommandLine.Parser.Default.ParseArguments(...)&lt;/code&gt; and three overload methods.&lt;/li&gt; &#xA; &lt;li&gt;Automatic or one line help screen generator: &lt;code&gt;HelpText.AutoBuild(...)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;code&gt;--help&lt;/code&gt;, &lt;code&gt;--version&lt;/code&gt;, &lt;code&gt;version&lt;/code&gt; and &lt;code&gt;help [verb]&lt;/code&gt; by default with customization.&lt;/li&gt; &#xA; &lt;li&gt;Map to sequences (via &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; and similar) and scalar types, including Enums and &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;You can also map to every type with a constructor that accepts a string (like &lt;code&gt;System.Uri&lt;/code&gt;) for reference and value types.&lt;/li&gt; &#xA; &lt;li&gt;Verbs can be array of types collected from Plugins or IoC container.&lt;/li&gt; &#xA; &lt;li&gt;Define &lt;a href=&#34;https://github.com/commandlineparser/commandline/wiki/Verbs&#34;&gt;verb commands&lt;/a&gt; similar to &lt;code&gt;git commit -a&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Support default verb.&lt;/li&gt; &#xA; &lt;li&gt;Support Mutable and Immutable types.&lt;/li&gt; &#xA; &lt;li&gt;Support HelpText localization.&lt;/li&gt; &#xA; &lt;li&gt;Support ordering of options in HelpText.&lt;/li&gt; &#xA; &lt;li&gt;Support &lt;a href=&#34;https://github.com/commandlineparser/commandline/wiki/Mutually-Exclusive-Options&#34;&gt;Mutually Exclusive Options&lt;/a&gt; and &lt;a href=&#34;https://github.com/commandlineparser/commandline/wiki/Option-Groups&#34;&gt;Option groups&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Support named and value options.&lt;/li&gt; &#xA; &lt;li&gt;Support Asynchronous programming with async and await.&lt;/li&gt; &#xA; &lt;li&gt;Unparsing support: &lt;code&gt;CommandLine.Parser.Default.FormatCommandLine&amp;lt;T&amp;gt;(T options)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;CommandLineParser.FSharp package is F#-friendly with support for &lt;code&gt;option&amp;lt;&#39;a&amp;gt;&lt;/code&gt;, see &lt;a href=&#34;https://github.com/commandlineparser/commandline/raw/master/demo/fsharp-demo.fsx&#34;&gt;demo&lt;/a&gt;. &lt;em&gt;NOTE: This is a separate NuGet package.&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Include wiki documentation with lot of examples ready to run online.&lt;/li&gt; &#xA; &lt;li&gt;Support Source Link and symbolic nuget package snupkg.&lt;/li&gt; &#xA; &lt;li&gt;Tested in Windows, Linux Ubuntu 18.04 and Mac OS.&lt;/li&gt; &#xA; &lt;li&gt;Most of features applies with a &lt;a href=&#34;http://en.wikipedia.org/wiki/Convention_over_configuration&#34;&gt;CoC&lt;/a&gt; philosophy.&lt;/li&gt; &#xA; &lt;li&gt;C# demo: source &lt;a href=&#34;https://github.com/commandlineparser/commandline/tree/master/demo/ReadText.Demo&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Getting Started with the Command Line Parser Library&lt;/h1&gt; &#xA;&lt;p&gt;You can utilize the parser library in several ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install via NuGet/Paket: &lt;a href=&#34;https://www.nuget.org/packages/CommandLineParser/&#34;&gt;https://www.nuget.org/packages/CommandLineParser/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Integrate directly into your project by copying the .cs files into your project.&lt;/li&gt; &#xA; &lt;li&gt;ILMerge during your build process.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start Examples&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a class to define valid options, and to receive the parsed options.&lt;/li&gt; &#xA; &lt;li&gt;Call ParseArguments with the args string array.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;C# Quick Start:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;using System;&#xA;using CommandLine;&#xA;&#xA;namespace QuickStart&#xA;{&#xA;    class Program&#xA;    {&#xA;        public class Options&#xA;        {&#xA;            [Option(&#39;v&#39;, &#34;verbose&#34;, Required = false, HelpText = &#34;Set output to verbose messages.&#34;)]&#xA;            public bool Verbose { get; set; }&#xA;        }&#xA;&#xA;        static void Main(string[] args)&#xA;        {&#xA;            Parser.Default.ParseArguments&amp;lt;Options&amp;gt;(args)&#xA;                   .WithParsed&amp;lt;Options&amp;gt;(o =&amp;gt;&#xA;                   {&#xA;                       if (o.Verbose)&#xA;                       {&#xA;                           Console.WriteLine($&#34;Verbose output enabled. Current Arguments: -v {o.Verbose}&#34;);&#xA;                           Console.WriteLine(&#34;Quick Start Example! App is in Verbose mode!&#34;);&#xA;                       }&#xA;                       else&#xA;                       {&#xA;                           Console.WriteLine($&#34;Current Arguments: -v {o.Verbose}&#34;);&#xA;                           Console.WriteLine(&#34;Quick Start Example!&#34;);&#xA;                       }&#xA;                   });&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C# Examples:&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand!&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;&#xA;class Options&#xA;{&#xA;  [Option(&#39;r&#39;, &#34;read&#34;, Required = true, HelpText = &#34;Input files to be processed.&#34;)]&#xA;  public IEnumerable&amp;lt;string&amp;gt; InputFiles { get; set; }&#xA;&#xA;  // Omitting long name, defaults to name of property, ie &#34;--verbose&#34;&#xA;  [Option(&#xA;&#x9;Default = false,&#xA;&#x9;HelpText = &#34;Prints all messages to standard output.&#34;)]&#xA;  public bool Verbose { get; set; }&#xA;  &#xA;  [Option(&#34;stdin&#34;,&#xA;&#x9;Default = false,&#xA;&#x9;HelpText = &#34;Read from stdin&#34;)]&#xA;  public bool stdin { get; set; }&#xA;&#xA;  [Value(0, MetaName = &#34;offset&#34;, HelpText = &#34;File offset.&#34;)]&#xA;  public long? Offset { get; set; }&#xA;}&#xA;&#xA;static void Main(string[] args)&#xA;{&#xA;  CommandLine.Parser.Default.ParseArguments&amp;lt;Options&amp;gt;(args)&#xA;    .WithParsed(RunOptions)&#xA;    .WithNotParsed(HandleParseError);&#xA;}&#xA;static void RunOptions(Options opts)&#xA;{&#xA;  //handle options&#xA;}&#xA;static void HandleParseError(IEnumerable&amp;lt;Error&amp;gt; errs)&#xA;{&#xA;  //handle errors&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Demo to show IEnumerable options and other usage: &lt;a href=&#34;https://dotnetfiddle.net/wrcAxr&#34;&gt;Online Demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;F# Examples:&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand!&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#xA;type options = {&#xA;  [&amp;lt;Option(&#39;r&#39;, &#34;read&#34;, Required = true, HelpText = &#34;Input files.&#34;)&amp;gt;] files : seq&amp;lt;string&amp;gt;;&#xA;  [&amp;lt;Option(HelpText = &#34;Prints all messages to standard output.&#34;)&amp;gt;] verbose : bool;&#xA;  [&amp;lt;Option(Default = &#34;русский&#34;, HelpText = &#34;Content language.&#34;)&amp;gt;] language : string;&#xA;  [&amp;lt;Value(0, MetaName=&#34;offset&#34;, HelpText = &#34;File offset.&#34;)&amp;gt;] offset : int64 option;&#xA;}&#xA;&#xA;let main argv =&#xA;  let result = CommandLine.Parser.Default.ParseArguments&amp;lt;options&amp;gt;(argv)&#xA;  match result with&#xA;  | :? Parsed&amp;lt;options&amp;gt; as parsed -&amp;gt; run parsed.Value&#xA;  | :? NotParsed&amp;lt;options&amp;gt; as notParsed -&amp;gt; fail notParsed.Errors&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;VB.NET Example:&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand!&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-vb&#34;&gt;&#xA;Class Options&#xA;&#x9;&amp;lt;CommandLine.Option(&#39;r&#39;, &#34;read&#34;, Required := true,&#xA;&#x9;HelpText:=&#34;Input files to be processed.&#34;)&amp;gt;&#xA;&#x9;Public Property InputFiles As IEnumerable(Of String)&#xA;&#xA;&#x9;&#39; Omitting long name, defaults to name of property, ie &#34;--verbose&#34;&#xA;&#x9;&amp;lt;CommandLine.Option(&#xA;&#x9;HelpText:=&#34;Prints all messages to standard output.&#34;)&amp;gt;&#xA;&#x9;Public Property Verbose As Boolean&#xA;&#xA;&#x9;&amp;lt;CommandLine.Option(Default:=&#34;中文&#34;,&#xA;&#x9;HelpText:=&#34;Content language.&#34;)&amp;gt;&#xA;&#x9;Public Property Language As String&#xA;&#xA;&#x9;&amp;lt;CommandLine.Value(0, MetaName:=&#34;offset&#34;,&#xA;&#x9;HelpText:=&#34;File offset.&#34;)&amp;gt;&#xA;&#x9;Public Property Offset As Long?&#xA;End Class&#xA;&#xA;Sub Main(ByVal args As String())&#xA;    CommandLine.Parser.Default.ParseArguments(Of Options)(args) _&#xA;        .WithParsed(Function(opts As Options) RunOptionsAndReturnExitCode(opts)) _&#xA;        .WithNotParsed(Function(errs As IEnumerable(Of [Error])) 1)&#xA;End Sub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;For verbs:&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create separate option classes for each verb. An options base class is supported.&lt;/li&gt; &#xA; &lt;li&gt;Call ParseArguments with all the verb attribute decorated options classes.&lt;/li&gt; &#xA; &lt;li&gt;Use MapResult to direct program flow to the verb that was parsed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;C# example:&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand!&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[Verb(&#34;add&#34;, HelpText = &#34;Add file contents to the index.&#34;)]&#xA;class AddOptions {&#xA;  //normal options here&#xA;}&#xA;[Verb(&#34;commit&#34;, HelpText = &#34;Record changes to the repository.&#34;)]&#xA;class CommitOptions {&#xA;  //commit options here&#xA;}&#xA;[Verb(&#34;clone&#34;, HelpText = &#34;Clone a repository into a new directory.&#34;)]&#xA;class CloneOptions {&#xA;  //clone options here&#xA;}&#xA;&#xA;int Main(string[] args) {&#xA;  return CommandLine.Parser.Default.ParseArguments&amp;lt;AddOptions, CommitOptions, CloneOptions&amp;gt;(args)&#xA;&#x9;.MapResult(&#xA;&#x9;  (AddOptions opts) =&amp;gt; RunAddAndReturnExitCode(opts),&#xA;&#x9;  (CommitOptions opts) =&amp;gt; RunCommitAndReturnExitCode(opts),&#xA;&#x9;  (CloneOptions opts) =&amp;gt; RunCloneAndReturnExitCode(opts),&#xA;&#x9;  errs =&amp;gt; 1);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;VB.NET example:&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand!&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-vb&#34;&gt;&amp;lt;CommandLine.Verb(&#34;add&#34;, HelpText:=&#34;Add file contents to the index.&#34;)&amp;gt;&#xA;Public Class AddOptions&#xA;    &#39;Normal options here&#xA;End Class&#xA;&amp;lt;CommandLine.Verb(&#34;commit&#34;, HelpText:=&#34;Record changes to the repository.&#34;)&amp;gt;&#xA;Public Class CommitOptions&#xA;    &#39;Normal options here&#xA;End Class&#xA;&amp;lt;CommandLine.Verb(&#34;clone&#34;, HelpText:=&#34;Clone a repository into a new directory.&#34;)&amp;gt;&#xA;Public Class CloneOptions&#xA;    &#39;Normal options here&#xA;End Class&#xA;&#xA;Function Main(ByVal args As String()) As Integer&#xA;    Return CommandLine.Parser.Default.ParseArguments(Of AddOptions, CommitOptions, CloneOptions)(args) _&#xA;          .MapResult(&#xA;              (Function(opts As AddOptions) RunAddAndReturnExitCode(opts)),&#xA;              (Function(opts As CommitOptions) RunCommitAndReturnExitCode(opts)),&#xA;              (Function(opts As CloneOptions) RunCloneAndReturnExitCode(opts)),&#xA;              (Function(errs As IEnumerable(Of [Error])) 1)&#xA;          )&#xA;End Function&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;F# Example:&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand!&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;open CommandLine&#xA;&#xA;[&amp;lt;Verb(&#34;add&#34;, HelpText = &#34;Add file contents to the index.&#34;)&amp;gt;]&#xA;type AddOptions = {&#xA;  // normal options here&#xA;}&#xA;[&amp;lt;Verb(&#34;commit&#34;, HelpText = &#34;Record changes to the repository.&#34;)&amp;gt;]&#xA;type CommitOptions = {&#xA;  // normal options here&#xA;}&#xA;[&amp;lt;Verb(&#34;clone&#34;, HelpText = &#34;Clone a repository into a new directory.&#34;)&amp;gt;]&#xA;type CloneOptions = {&#xA;  // normal options here&#xA;}&#xA;&#xA;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main args =&#xA;  let result = Parser.Default.ParseArguments&amp;lt;AddOptions, CommitOptions, CloneOptions&amp;gt; args&#xA;  match result with&#xA;  | :? CommandLine.Parsed&amp;lt;obj&amp;gt; as command -&amp;gt;&#xA;&#x9;match command.Value with&#xA;&#x9;| :? AddOptions as opts -&amp;gt; RunAddAndReturnExitCode opts&#xA;&#x9;| :? CommitOptions as opts -&amp;gt; RunCommitAndReturnExitCode opts&#xA;&#x9;| :? CloneOptions as opts -&amp;gt; RunCloneAndReturnExitCode opts&#xA;  | :? CommandLine.NotParsed&amp;lt;obj&amp;gt; -&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Release History&lt;/h1&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/commandlineparser/commandline/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;First off, &lt;em&gt;Thank you!&lt;/em&gt; All contributions are welcome.&lt;/p&gt; &#xA;&lt;p&gt;Please consider sticking with the GNU getopt standard for command line parsing.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, for easiest diff compares, please follow the project&#39;s tabs settings. Utilizing the EditorConfig extension for Visual Studio/your favorite IDE is recommended.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;And most importantly, please target the &lt;code&gt;develop&lt;/code&gt; branch in your pull requests!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Main Contributors (alphabetical order):&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alexander Fast (@mizipzor)&lt;/li&gt; &#xA; &lt;li&gt;Dan Nemec (@nemec)&lt;/li&gt; &#xA; &lt;li&gt;Eric Newton (@ericnewton76)&lt;/li&gt; &#xA; &lt;li&gt;Kevin Moore (@gimmemoore)&lt;/li&gt; &#xA; &lt;li&gt;Moh-Hassan (@moh-hassan)&lt;/li&gt; &#xA; &lt;li&gt;Steven Evans&lt;/li&gt; &#xA; &lt;li&gt;Thomas Démoulins (@Thilas)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Resources for newcomers:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/commandlineparser/commandline/wiki&#34;&gt;Wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.gnu.org/software/libc/manual/html_node/Getopt.html&#34;&gt;GNU getopt&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contacts:&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Giacomo Stelluti Scala &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;gsscoder AT gmail DOT com (&lt;em&gt;use this for everything that is not available via GitHub features&lt;/em&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;GitHub: &lt;a href=&#34;https://github.com/gsscoder&#34;&gt;gsscoder&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://gsscoder.blogspot.it&#34;&gt;Blog&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://twitter.com/gsscoder&#34;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Dan Nemec&lt;/li&gt; &#xA; &lt;li&gt;Eric Newton &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;ericnewton76+commandlineparser AT gmail DOT com&lt;/li&gt; &#xA;   &lt;li&gt;GitHub: &lt;a href=&#34;https://github.com/ericnewton76&#34;&gt;ericnewton76&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Blog:&lt;/li&gt; &#xA;   &lt;li&gt;Twitter: &lt;a href=&#34;http://twitter.com/enorl76&#34;&gt;enorl76&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Moh-Hassan&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>tmenier/Flurl</title>
    <updated>2022-06-30T01:36:11Z</updated>
    <id>tag:github.com,2022-06-30:/tmenier/Flurl</id>
    <link href="https://github.com/tmenier/Flurl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fluent URL builder and testable HTTP client for .NET&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Flurl&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ci.appveyor.com/project/kroniak/flurl/branch/master&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/hec8ioqg0j07ttg5/branch/master?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Flurl/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Flurl.svg?maxAge=3600&amp;amp;label=Flurl%20nuget&#34; alt=&#34;Flurl-stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Flurl.Http/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Flurl.Http.svg?maxAge=3600&amp;amp;label=Flurl.Http%20nuget&#34; alt=&#34;Flurl.Http-stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Flurl/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/Flurl.svg?maxAge=3600&amp;amp;label=Flurl%20Pre-Release%20nuget&#34; alt=&#34;Flurl-pre-release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Flurl.Http/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/Flurl.Http.svg?maxAge=3600&amp;amp;label=Flurl.Http%20Pre-Release%20nuget&#34; alt=&#34;Flurl.Http-pre-release&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Flurl is a modern, fluent, asynchronous, testable, portable, buzzword-laden URL builder and HTTP client library.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;var result = await &#34;https://api.mysite.com&#34;&#xA;    .AppendPathSegment(&#34;person&#34;)&#xA;    .SetQueryParams(new { api_key = &#34;xyz&#34; })&#xA;    .WithOAuthBearerToken(&#34;my_oauth_token&#34;)&#xA;    .PostJsonAsync(new { first_name = firstName, last_name = lastName })&#xA;    .ReceiveJson&amp;lt;T&amp;gt;();&#xA;&#xA;[Test]&#xA;public void Can_Create_Person() {&#xA;    // fake &amp;amp; record all http calls in the test subject&#xA;    using (var httpTest = new HttpTest()) {&#xA;        // arrange&#xA;        httpTest.RespondWith(&#34;OK&#34;, 200);&#xA;&#xA;        // act&#xA;        await sut.CreatePersonAsync(&#34;Claire&#34;, &#34;Underwood&#34;);&#xA;        &#xA;        // assert&#xA;        httpTest.ShouldHaveCalled(&#34;http://api.mysite.com/*&#34;)&#xA;            .WithVerb(HttpMethod.Post)&#xA;            .WithContentType(&#34;application/json&#34;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get it on NuGet:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PM&amp;gt; Install-Package Flurl.Http&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Or get just the stand-alone URL builder without the HTTP features:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PM&amp;gt; Install-Package Flurl&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For updates and announcements, &lt;a href=&#34;https://twitter.com/intent/user?screen_name=FlurlHttp&#34;&gt;follow @FlurlHttp on Twitter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For detailed documentation, please visit the &lt;a href=&#34;https://flurl.dev&#34;&gt;main site&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>