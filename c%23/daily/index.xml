<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-30T01:31:32Z</updated>
  <subtitle>Daily Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Azure/durabletask</title>
    <updated>2022-11-30T01:31:32Z</updated>
    <id>tag:github.com,2022-11-30:/Azure/durabletask</id>
    <link href="https://github.com/Azure/durabletask" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Durable Task Framework allows users to write long running persistent workflows in C# using the async/await capabilities.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Durable Task Framework&lt;/h1&gt; &#xA;&lt;p&gt;The Durable Task Framework (DTFx) is a library that allows users to write long running persistent workflows (referred to as &lt;em&gt;orchestrations&lt;/em&gt;) in C# using simple async/await coding constructs. It is used heavily within various teams at Microsoft to reliably orchestrate long running provisioning, monitoring, and management operations. The orchestrations scale out linearly by simply adding more worker machines. This framework is also used to power the serverless &lt;a href=&#34;https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview&#34;&gt;Durable Functions&lt;/a&gt; extension of &lt;a href=&#34;https://azure.microsoft.com/services/functions/&#34;&gt;Azure Functions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By open sourcing this project we hope to give the community a very cost-effective alternative to heavy duty workflow systems. We also hope to build an ecosystem of providers and activities around this simple yet incredibly powerful framework.&lt;/p&gt; &#xA;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For more information see the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/faq/&#34;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:opencode@microsoft.com&#34;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt; &#xA;&lt;h2&gt;Supported persistance stores&lt;/h2&gt; &#xA;&lt;p&gt;Starting in v2.x, the Durable Task Framework supports an extensible set of backend persistence stores. Each store can be enabled using a different NuGet package. The latest version of all packages are signed and available for download at nuget.org.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Package&lt;/th&gt; &#xA;   &lt;th&gt;Latest Version&lt;/th&gt; &#xA;   &lt;th&gt;Details&lt;/th&gt; &#xA;   &lt;th&gt;Development Status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DurableTask.ServiceBus&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.DurableTask.ServiceBus/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Azure.DurableTask.ServiceBus.svg?style=flat&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Orchestration message and runtime state is stored in Service Bus queues while tracking state is stored in Azure Storage. The strength of this provider is its maturity and transactional consistency. However, it is no longer in active development at Microsoft.&lt;/td&gt; &#xA;   &lt;td&gt;Production ready but not actively maintained&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DurableTask.AzureStorage&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.DurableTask.AzureStorage/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Azure.DurableTask.AzureStorage.svg?style=flat&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;All orchestration state is stored in Azure Storage queues, tables, and blobs. The strength of this provider is the minimal service dependencies, high efficiency, and rich feature-set. This is the only backend available for &lt;a href=&#34;https://docs.microsoft.com/azure/azure-functions/durable/&#34;&gt;Durable Functions&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;Production ready and actively maintained&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DurableTask.AzureServiceFabric&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.DurableTask.AzureServiceFabric/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Azure.DurableTask.AzureServiceFabric.svg?style=flat&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;All orchestration state is stored in &lt;a href=&#34;https://docs.microsoft.com/azure/service-fabric/service-fabric-reliable-services-reliable-collections&#34;&gt;Azure Service Fabric Reliable Collections&lt;/a&gt;. This is an ideal choice if you are hosting your application in &lt;a href=&#34;https://azure.microsoft.com/services/service-fabric/&#34;&gt;Azure Service Fabric&lt;/a&gt; and don&#39;t want to take on external dependencies for storing state.&lt;/td&gt; &#xA;   &lt;td&gt;Production ready and actively maintained&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DurableTask.Netherite&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Netherite/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Azure.DurableTask.Netherite.svg?style=flat&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An ultra-high performance backend developed by Microsoft Research where state is stored in &lt;a href=&#34;https://azure.microsoft.com/en-us/services/event-hubs/&#34;&gt;Azure Event Hubs&lt;/a&gt; and Azure Page Blobs using &lt;a href=&#34;https://www.microsoft.com/research/project/faster/&#34;&gt;FASTER&lt;/a&gt; database technology from Microsoft Research. &lt;a href=&#34;https://github.com/microsoft/durabletask-netherite&#34;&gt;ðŸ‘‰ GitHub Repo&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Production ready and actively maintained&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DurableTask.SqlServer&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.DurableTask.SqlServer/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.DurableTask.SqlServer.svg?style=flat&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;All orchestration state is stored in a &lt;a href=&#34;https://www.microsoft.com/sql-server/sql-server-2019&#34;&gt;Microsoft SQL Server&lt;/a&gt; or &lt;a href=&#34;https://azure.microsoft.com/products/azure-sql/database/&#34;&gt;Azure SQL&lt;/a&gt; database with indexed tables and stored procedures for direct interaction. &lt;a href=&#34;https://github.com/microsoft/durabletask-mssql&#34;&gt;ðŸ‘‰ GitHub Repo&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Production ready and actively maintained&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DurableTask.Emulator&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Emulator/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Azure.DurableTask.Emulator.svg?style=flat&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;This is an in-memory store intended for testing purposes only. It is not designed or recommended for any production workloads.&lt;/td&gt; &#xA;   &lt;td&gt;Not actively maintained&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The core programming model for the Durable Task Framework is contained in the &lt;a href=&#34;https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Core/&#34;&gt;DurableTask.Core&lt;/a&gt; package, which is also under active development.&lt;/p&gt; &#xA;&lt;h2&gt;Learning more&lt;/h2&gt; &#xA;&lt;p&gt;The associated wiki contains more details about the framework and how it can be used: &lt;a href=&#34;https://github.com/Azure/durabletask/wiki&#34;&gt;https://github.com/Azure/durabletask/wiki&lt;/a&gt;. You can also find great information in &lt;a href=&#34;https://abhikmitra.github.io/blog/durable-task/&#34;&gt;this blog series&lt;/a&gt;. In some cases, the &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-functions/durable/&#34;&gt;Durable Functions documentation&lt;/a&gt; can actually be useful in learning things about the underlying framework, although not everything will apply. Lastly, you can watch a video with some of the original maintainers in &lt;a href=&#34;https://channel9.msdn.com/Shows/On-NET/Building-workflows-with-the-Durable-Task-Framework&#34;&gt;this Channel 9 video&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development Notes&lt;/h2&gt; &#xA;&lt;p&gt;To run unit tests, you must specify your Service Bus connection string for the tests to use. You can do this via the &lt;strong&gt;ServiceBusConnectionString&lt;/strong&gt; app.config value in the test project, or by defining a &lt;strong&gt;DurableTaskTestServiceBusConnectionString&lt;/strong&gt; environment variable. The benefit of the environment variable is that no temporary source changes are required.&lt;/p&gt; &#xA;&lt;p&gt;Unit tests also require &lt;a href=&#34;https://docs.microsoft.com/azure/storage/common/storage-use-emulator&#34;&gt;Azure Storage Emulator&lt;/a&gt;, so make sure it&#39;s installed and running.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: While it&#39;s possible to use in tests a real Azure Storage account it is not recommended to do so because many tests will fail with a 409 Conflict error. This is because tests delete and quickly recreate the same storage tables, and Azure Storage doesn&#39;t do well in these conditions. If you really want to change Azure Storage connection string you can do so via the &lt;strong&gt;StorageConnectionString&lt;/strong&gt; app.config value in the test project, or by defining a &lt;strong&gt;DurableTaskTestStorageConnectionString&lt;/strong&gt; environment variable.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There is a gitter for this repo, but it&#39;s not currently being monitored. We&#39;re leaving the link for it up for now and will update this message if anything changes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/azure/durabletask?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/azure/durabletask&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ironmansoftware/psmsi</title>
    <updated>2022-11-30T01:31:32Z</updated>
    <id>tag:github.com,2022-11-30:/ironmansoftware/psmsi</id>
    <link href="https://github.com/ironmansoftware/psmsi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Create MSIs using PowerShell.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Installers&lt;/h1&gt; &#xA;&lt;p&gt;PSMSI includes cmdlets for creating MSI packages that can contain any file and directory structure you wish. It also includes functionality to customize the installer interface by including custom EULAs and images.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;To get started creating installers with PSMSI, you will need to download the latest version of the PSMSI module. This can be installed with &lt;code&gt;Install-Module&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Install-Module PSMSI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;WiX Toolset&lt;/h2&gt; &#xA;&lt;p&gt;This module is based on v3 of the &lt;a href=&#34;https://wixtoolset.org/docs/v3/&#34;&gt;Wix Toolset&lt;/a&gt;. There is so much more we could accomplish with this module. It mainly creates WiX XML and runs the WiX tools to generate MSIs. We&#39;re very open to PRs and issues. Feel free to check out the WiX documentation for features that could be added.&lt;/p&gt; &#xA;&lt;h2&gt;Creating your first installer&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;New-Installer&lt;/code&gt; cmdlet is used to generate an installer. It can contain directories and files for installation. The first step is to define the basic parameters of your installer.&lt;/p&gt; &#xA;&lt;p&gt;The Product and UpgradeCode parameters are required. The UpgradeCode is a GUID that needs to remain the same for each version of your product and should be unique from other products.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-Installer -ProductName &#34;My First Product&#34; -UpgradeCode &#39;1a73a1be-50e6-4e92-af03-586f4a9d9e82&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Within the Content parameter of the New-Installer cmdlet, you need to include a root directory for installation on the end user&#39;s machine. The root directory needs to be a predefined directory. One of the parameter sets on New-InstallerDirectory defines a PredefinedDirectory parameter that you can use to select the target root directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerDirectory -PredefinedDirectory &#34;LocalAppDataFolder&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now optionally specify a nested directory within your root directory. This will be created if it does not exist and removed on uninstall.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerDirectory -DirectoryName &#34;My First Product&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, you can include files within your directory. The New-InstallerFile cmdlet accepts a Source parameter with the path to the file you would like to install.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerFile -Source .\MyTextFile.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The full script for this installer looks like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-Installer -ProductName &#34;My First Product&#34; -UpgradeCode &#39;1a73a1be-50e6-4e92-af03-586f4a9d9e82&#39; -Content {&#xA;    New-InstallerDirectory -PredefinedDirectory &#34;LocalAppDataFolder&#34;  -Content {&#xA;       New-InstallerDirectory -DirectoryName &#34;My First Product&#34; -Content {&#xA;          New-InstallerFile -Source .\license.txt&#xA;       }&#xA;    }&#xA; } -OutputDirectory (Join-Path $PSScriptRoot &#34;output&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running the above script will produce a WXS, WXSOBJ and MSI file in the output directory. The MSI is the only file that you need to provide to your end users. The WXS and WXSOBJ files are artifacts of the Windows Installer XML Toolkit used to generate these installers.&lt;/p&gt; &#xA;&lt;h2&gt;Installers&lt;/h2&gt; &#xA;&lt;h3&gt;All Users Installation&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;-RequriesElevation&lt;/code&gt; parameter of &lt;code&gt;New-Installer&lt;/code&gt; to change from the default &lt;code&gt;PerUser&lt;/code&gt; installation to a &lt;code&gt;PerMachine&lt;/code&gt; installation.&lt;/p&gt; &#xA;&lt;p&gt;The following creates an installer that will install to the program files folder. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-Installer -ProductName &#34;My First Product&#34; -UpgradeCode &#39;1a73a1be-50e6-4e92-af03-586f4a9d9e82&#39; -Content {&#xA;    New-InstallerDirectory -PredefinedDirectory &#34;ProgramFilesFolder&#34;  -Content {&#xA;       New-InstallerDirectory -DirectoryName &#34;My First Product&#34; -Content {&#xA;          New-InstallerFile -Source .\license.txt&#xA;       }&#xA;    }&#xA; } -OutputDirectory (Join-Path $PSScriptRoot &#34;output&#34;) -RequiresElevation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Add\Remove Programs Icon&lt;/h3&gt; &#xA;&lt;p&gt;The Application Icon that will be displayed within Add\Remove Programs can be defined using the &lt;code&gt;AddRemoveProgramsIcon&lt;/code&gt; of &lt;code&gt;New-Installer&lt;/code&gt;. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-Installer -Product &#34;My First Product&#34; -UpgradeCode &#39;1a73a1be-50e6-4e92-af03-586f4a9d9e82&#39; -Content {&#xA;    New-InstallerDirectory -PredefinedDirectory &#34;ProgramFilesFolder&#34;  -Content {&#xA;       New-InstallerDirectory -DirectoryName &#34;My First Product&#34; -Content {&#xA;          New-InstallerFile -Source .\license.txt&#xA;       }&#xA;    }&#xA; } -OutputDirectory (Join-Path $PSScriptRoot &#34;output&#34;) -AddRemoveProgramsIcon &#34;icon.ico&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Upgrade Code&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;UpgradeCode&lt;/code&gt; value should be static to ensure that upgrades work successfully. Define the upgrade code by on &lt;code&gt;New-Installer&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-Installer -ProductName &#34;My First Product&#34; -UpgradeCode &#39;1a73a1be-50e6-4e92-af03-586f4a9d9e82&#39; -Content {&#xA;    New-InstallerDirectory -PredefinedDirectory &#34;ProgramFilesFolder&#34;  -Content {&#xA;       New-InstallerDirectory -DirectoryName &#34;My First Product&#34; -Content {&#xA;          New-InstallerFile -Source .\license.txt&#xA;       }&#xA;    }&#xA; } -OutputDirectory (Join-Path $PSScriptRoot &#34;output&#34;) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Version&lt;/h3&gt; &#xA;&lt;p&gt;The installer version is set using the &lt;code&gt;Version&lt;/code&gt; parameter of &lt;code&gt;New-Installer&lt;/code&gt;. You can provide upgrades by increasing the version and keeping the Upgrade Code the same. &lt;/p&gt; &#xA;&lt;p&gt;The version defaults to 1.0. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-Installer -ProductName &#34;My First Product&#34; -UpgradeCode &#39;1a73a1be-50e6-4e92-af03-586f4a9d9e82&#39; -Content {&#xA;    New-InstallerDirectory -PredefinedDirectory &#34;ProgramFilesFolder&#34;  -Content {&#xA;       New-InstallerDirectory -DirectoryName &#34;My First Product&#34; -Content {&#xA;          New-InstallerFile -Source .\license.txt&#xA;       }&#xA;    }&#xA; } -OutputDirectory (Join-Path $PSScriptRoot &#34;output&#34;) -Version 2.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Actions&lt;/h2&gt; &#xA;&lt;p&gt;Custom actions allow you to run PowerShell scripts during install and uninstall. You will need to include the script as a file in your installer. Use the &lt;code&gt;FileId&lt;/code&gt; parameter of &lt;code&gt;New-InstallerCustomAction&lt;/code&gt; to reference the PS1 file you wish to execute. &lt;/p&gt; &#xA;&lt;p&gt;For example, you may have a script named &lt;code&gt;MyCustomAction.ps1&lt;/code&gt; with an ID of &lt;code&gt;CustomAction&lt;/code&gt;. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerFile -Source .\myCustomAction.ps1 -Id &#39;CustomAction&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then use that script as a custom action during an installation. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerCustomAction -FileId &#39;CustomAction&#39; -RunOnInstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Arguments&lt;/h3&gt; &#xA;&lt;p&gt;You can pass arguments to both PowerShell.exe and your script. The &lt;code&gt;Arguments&lt;/code&gt; parameter passes custom arguments to PowerShell.exe (like -NoProfile). The &lt;code&gt;ScriptArguments&lt;/code&gt; parameter defines arguments to pass to the script itself. &lt;/p&gt; &#xA;&lt;h3&gt;CheckReturnValue&lt;/h3&gt; &#xA;&lt;p&gt;This checks the exit code of PowerShell.exe. If the exit code is non-zero, then it will cause the install to fail. &lt;/p&gt; &#xA;&lt;h3&gt;RunOnInstall&lt;/h3&gt; &#xA;&lt;p&gt;Runs the custom action during install. &lt;/p&gt; &#xA;&lt;h3&gt;RunOnUninstall&lt;/h3&gt; &#xA;&lt;p&gt;Runs the custom action during uninstall.&lt;/p&gt; &#xA;&lt;h2&gt;Directories and Files&lt;/h2&gt; &#xA;&lt;p&gt;You can create directories and files using &lt;code&gt;New-InstallerDirectory&lt;/code&gt; and &lt;code&gt;New-InstallerFile&lt;/code&gt;. Directories should start with one of the pre-defined directories provided by MSI. &lt;/p&gt; &#xA;&lt;h3&gt;Pre-defined Directories&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;PredefinedDirectory&lt;/code&gt; parameter of &lt;code&gt;New-InstallerDirectory&lt;/code&gt; to define the root folder for the installation. You can use directories such as &lt;code&gt;Program Files&lt;/code&gt;, &lt;code&gt;AppData&lt;/code&gt; and &lt;code&gt;CommonAppData&lt;/code&gt;. &lt;/p&gt; &#xA;&lt;h3&gt;Custom Folders&lt;/h3&gt; &#xA;&lt;p&gt;Custom folders appear within pre-defined directories. You can nest folders to create a folder tree. Folders can then contain files. Use the &lt;code&gt;DirectoryName&lt;/code&gt; parameter of &lt;code&gt;New-InstallerDirectory&lt;/code&gt; to create a directory. Use &lt;code&gt;Content&lt;/code&gt; to specify either folders or files to include. &lt;/p&gt; &#xA;&lt;p&gt;Including the &lt;code&gt;Configurable&lt;/code&gt; property on &lt;code&gt;New-InstallerDirectory&lt;/code&gt; will allow the end user to select a directory during installation. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerDirectory -DirectoryName &#34;My First Product&#34; -Content {&#xA;    New-InstallerFile -Source .\license.txt&#xA;} -Configurable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Files&lt;/h3&gt; &#xA;&lt;p&gt;Files are defined by their current location and an ID. The &lt;code&gt;Source&lt;/code&gt; parameter should identify the file you wish to include. It&#39;s location in the &lt;code&gt;New-InstallerDirectory&lt;/code&gt; tree will define where it is installed on disk. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerDirectory -DirectoryName &#34;My First Product&#34; -Content {&#xA;    New-InstallerFile -Source .\license.txt&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Shortcuts&lt;/h2&gt; &#xA;&lt;p&gt;Shortcuts can be defined for installers using &lt;code&gt;New-InstallerShortcut&lt;/code&gt;. You will define where the shortcut is located using &lt;code&gt;New-InstallerDirectory&lt;/code&gt; and reference a file by Id. &lt;/p&gt; &#xA;&lt;p&gt;For example, to define a file by ID, you would include the &lt;code&gt;Id&lt;/code&gt; parameter of &lt;code&gt;New-InstallerFile&lt;/code&gt;. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerFile -Source .\MyTextFile.txt -Id &#34;myTestFile&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, you would define the shortcut in a directory and reference the file by ID.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-InstallerDirectory -PredefinedDirectory &#34;DesktopFolder&#34; -Content {&#xA;    New-InstallerShortcut -Name &#34;My Test File&#34; -FileId &#34;myTestFile&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Working Directory&lt;/h3&gt; &#xA;&lt;p&gt;You can set the working directory of a shortcut by specifying the ID of the folder. The below example sets the working directory to the installation directory&#39;s ID. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;New-Installer -ProductName &#34;MyImage&#34; -UpgradeCode (New-Guid) -Version 1.0.0 -Content {&#xA;    New-InstallerDirectory -PredefinedDirectoryName ProgramFilesFolder -Content {&#xA;        New-InstallerDirectory -DirectoryName &#39;MyDir&#39; -Id &#39;MyDir&#39; -Content {&#xA;            New-InstallerFile -Id &#39;Image&#39; -Source &#39;services.png&#39;&#xA;        }&#xA;    }&#xA;    New-InstallerDirectory -PredefinedDirectoryName DesktopFolder -Content {&#xA;        New-InstallerShortcut -Name &#39;Test&#39; -FileId &#39;Image&#39; -WorkingDirectoryId &#39;MyDir&#39;&#xA;    }    &#xA;} -OutputDirectory .\installer -RequiresElevation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;User Interfaces&lt;/h2&gt; &#xA;&lt;p&gt;You can customize the user interface of the installer by using the &lt;code&gt;UserInterface&lt;/code&gt; parameter of &lt;code&gt;New-Installer&lt;/code&gt; along with &lt;code&gt;New-InstallerUserInterface&lt;/code&gt;. &lt;/p&gt; &#xA;&lt;p&gt;User interfaces can include custom graphics and EULAs for your installer. &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt; $UserInterface = New-InstallerUserInterface -Eula (Join-Path $PSScriptRoot &#39;eula.rtf&#39;) -TopBanner (Join-Path $PSScriptRoot &#34;banner.png&#34;) -Welcome (Join-Path $PSScriptRoot &#34;welcome.png&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ironman Software Free Tools&lt;/h3&gt; &#xA;&lt;p&gt;For more free tools, visit the &lt;a href=&#34;https://ironmansoftware.com/free-powershell-tools&#34;&gt;Ironman Software free tools index&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pirate-kiiiing/PersonalFinanceApp.Api</title>
    <updated>2022-11-30T01:31:32Z</updated>
    <id>tag:github.com,2022-11-30:/pirate-kiiiing/PersonalFinanceApp.Api</id>
    <link href="https://github.com/pirate-kiiiing/PersonalFinanceApp.Api" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PIRATE KING&#39;s Personal Finance App&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PersonalFinanceApp - Backend&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Please, note that this repository is a replica of PK&#39;s private project in GitHub.&lt;/strong&gt;&lt;/em&gt; &lt;em&gt;&lt;strong&gt;The open-source version was modified slightly and, as a result, might not build.&lt;/strong&gt;&lt;/em&gt; &lt;em&gt;&lt;strong&gt;The app&#39;s no longer maintained is for reference only.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;PIRATE KING&#39;s personal finance app BACKEND&lt;/p&gt; &#xA;&lt;p&gt;Tech Stack:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C#&lt;/li&gt; &#xA; &lt;li&gt;.net Core&lt;/li&gt; &#xA; &lt;li&gt;Plaid API&lt;/li&gt; &#xA; &lt;li&gt;Azure Cosmos DB&lt;/li&gt; &#xA; &lt;li&gt;Azure Cloud Apps (Functions, KeyVault, AppService, etc.)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>