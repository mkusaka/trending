<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-02T01:52:08Z</updated>
  <subtitle>Weekly Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Jessecar96/SteamDesktopAuthenticator</title>
    <updated>2023-07-02T01:52:08Z</updated>
    <id>tag:github.com,2023-07-02:/Jessecar96/SteamDesktopAuthenticator</id>
    <link href="https://github.com/Jessecar96/SteamDesktopAuthenticator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Desktop implementation of Steam&#39;s mobile authenticator app&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Jessecar96/SteamDesktopAuthenticator/master/icon.png&#34; height=&#34;64&#34; width=&#34;64&#34;&gt; &lt;br&gt; Steam Desktop Authenticator &lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; A desktop implementation of Steam&#39;s mobile authenticator app.&lt;br&gt; &lt;sup&gt;&lt;b&gt;We are not affiliated with Steam or Scrap.TF in any way!&lt;/b&gt; This project is run by community volunteers. &lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt; &lt;b&gt;WARNING: Recently there have been fake versions of SDA floating around that will steal your Steam account. Never download SDA from any place other than this github repo!&lt;/b&gt; &lt;/h3&gt; &#xA;&lt;h3 align=&#34;center&#34; style=&#34;margin-bottom:0&#34;&gt; &lt;a href=&#34;https://github.com/Jessecar96/SteamDesktopAuthenticator/releases/latest&#34;&gt;Download here&lt;/a&gt; &lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Supports Windows 7 and up.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;Clicking &#34;Download ZIP&#34; will not work!&lt;/strong&gt; This project uses git submodules so you must use git to download it properly. Using &lt;a href=&#34;https://desktop.github.com/&#34;&gt;GitHub Desktop&lt;/a&gt; is an easy way to do that.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;DISCLAIMER: We provide no support for you when using Steam Desktop Authenticator! This project is run by community volunteers and is not affiliated with Steam or Scrap.TF. You use this program at your own risk, and accept the responsibility to make backups and prevent unauthorized access to your computer!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;REMEMBER: Always make backups of your &lt;code&gt;maFiles&lt;/code&gt; directory! If you lose your encryption key or delete &lt;code&gt;maFiles&lt;/code&gt; by accident AND you didn&#39;t save your revocation code, you are screwed.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;FINALLY: Using this application is a bad idea, because it COMPLETELY DEFEATS THE PURPOSE of two-factor authentication! If your desktop is infected with a virus, it will be able to hijack the authenticator app and completely subvert the protection. THIS APPLICATION DOES NOT PROTECT YOUR ACCOUNT; IT ONLY ALLOWS YOU TO USE STEAM FEATURES THAT REQUIRE THE AUTHENTICATOR WITHOUT HAVING A PHONE. If you have a phone that supports the Mobile Authenticator, you really shouldn&#39;t use this application!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;IF you lost your &lt;code&gt;maFiles&lt;/code&gt; OR lost your encryption key, go &lt;a href=&#34;https://store.steampowered.com/twofactor/manage&#34;&gt;here&lt;/a&gt; and click &#34;Remove Authenticator&#34; then enter your revocation code that you wrote down when you first added your account to SDA.&lt;/p&gt; &#xA;&lt;p&gt;If you did not follow the directions and did not write your revocation code down, you&#39;re well and truly screwed. The only option is beg to &lt;a href=&#34;https://support.steampowered.com/&#34;&gt;Steam Support&lt;/a&gt; and say you lost your mobile authenticator and the revocation code.&lt;/p&gt; &#xA;&lt;h2&gt;Detailed setup instructions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download &amp;amp; Install &lt;a href=&#34;https://www.microsoft.com/net/download/dotnet-framework-runtime/net472&#34;&gt;.NET Framework 4.7.2&lt;/a&gt; if you&#39;re using Windows 7. Windows 8 and above should do this automatically for you.&lt;/li&gt; &#xA; &lt;li&gt;Visit &lt;a href=&#34;https://github.com/Jessecar96/SteamDesktopAuthenticator/releases&#34;&gt;the releases page&lt;/a&gt; and download the latest .zip (not the source code one).&lt;/li&gt; &#xA; &lt;li&gt;Extract the files somewhere very safe on your computer. If you lose the files you can lose access to your Steam account.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;Steam Desktop Authenticator.exe&lt;/code&gt; and click the button to set up a new account.&lt;/li&gt; &#xA; &lt;li&gt;Login to Steam and follow the instructions to set it up. &lt;strong&gt;Note: you still need a mobile phone that can receive SMS.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;You may be asked to set up encryption, this is to make sure if someone gains access to your computer they can&#39;t steal your Steam account from this program. This is optional but highly recommended.&lt;/li&gt; &#xA; &lt;li&gt;Select your account from the list to view the current login code, and click &lt;code&gt;Trade Confirmations&lt;/code&gt; to see pending trade confirmations.&lt;/li&gt; &#xA; &lt;li&gt;For your safety, remember to get Steam Guard backup codes! Follow &lt;a href=&#34;https://store.steampowered.com/twofactor/manage&#34;&gt;this link&lt;/a&gt; and click &#34;Get Backup Codes,&#34; then print out that page and save it in a safe place. You can use these codes if you lose access to your authenticator.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Jessecar96/SteamDesktopAuthenticator/wiki/Updating&#34;&gt;How to update SDA.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Jessecar96/SteamDesktopAuthenticator/wiki/Using-SDA-on-multiple-computers&#34;&gt;How to use SDA on multiple computers.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Command line options&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;-k [encryption key]&#xA;  Set your encryption key when opened&#xA;-s&#xA;  Auto-minimize to tray when opened&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Trade confirmation list is just white or a blank screen&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;First open the &#34;Selected Account&#34; menu, then click &#34;Force session refresh&#34;. If it still doesn&#39;t work after that, open the &#34;Selected Account&#34; menu again, then click &#34;Login again&#34; and login to your Steam account.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If your problem doesn&#39;t appear on the list or none of the solutions worked, submit an issue on the issue tracker. When posting logs in an issue, please upload it to some site like &lt;a href=&#34;http://www.pastebin.com&#34;&gt;Pastebin&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building on linux&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First, you will need to install the &lt;code&gt;mono&lt;/code&gt; and &lt;code&gt;monodevelop&lt;/code&gt; packages, usually available from your standard package repository.&lt;/li&gt; &#xA; &lt;li&gt;Open monodevelop and select File -&amp;gt; Open. Navigate to the folder where you cloned this program to and open the file &#34;Steam Desktop Authenticator/Steam Desktop Authenticator.sln&#34;&lt;/li&gt; &#xA; &lt;li&gt;If you initialized submodules correctly, you should see two tree hirarchies on the left side of the screen, one labeled &lt;strong&gt;SteamDesktopAuthenticator&lt;/strong&gt; and the other &lt;strong&gt;SteamAuth&lt;/strong&gt;. (If you didn&#39;t, an error will be displayed; go update them!) For both of them, select &#34;Packages&#34;, right click on &#34;Newtonsoft.Json&#34;, and click update. Remember to do this for &lt;strong&gt;both SteamDesktopAuthenticator and SteamAuth&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Select Project-&amp;gt;Active Configuration-&amp;gt;Release (this will make this application run faster)&lt;/li&gt; &#xA; &lt;li&gt;Select Build-&amp;gt;Build All. The package should now build successfully.&lt;/li&gt; &#xA; &lt;li&gt;The resulting executable and files will be in &#34;Steam Desktop Authenticator/bin/Release&#34;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Danily07/Translumo</title>
    <updated>2023-07-02T01:52:08Z</updated>
    <id>tag:github.com,2023-07-02:/Danily07/Translumo</id>
    <link href="https://github.com/Danily07/Translumo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Advanced real-time screen translator for games, hardcoded subtitles in videos, static text and etc.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache_2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/Danily07/Translumo/total.svg?sanitize=true&#34; alt=&#34;Github All Releases&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://trello.com/b/MEHnLySw/translumo&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Trello-0052CC?style=for-the-badge&amp;amp;logo=trello&amp;amp;logoColor=white&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;670&#34; src=&#34;https://github.com/Danily07/Translumo/assets/29047281/8985049f-ea1c-428e-94be-042ece66cb54&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;b&gt;EN&lt;/b&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/Danily07/Translumo/master/docs/README-RU.md&#34;&gt;&lt;b&gt;RU&lt;/b&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Advanced screen translator. &lt;b&gt;Translumo&lt;/b&gt; is able to detect and translate appearing in the selected area text in real-time (e.g. subtitles).&lt;/p&gt; &#xA;&lt;h1&gt;Main features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;b&gt;High text recognition precision&lt;/b&gt;&lt;/li&gt; &#xA; &lt;p&gt;Translumo allows to combine the usage of several OCR engines simultaneously. It uses machine learning training model for scoring each recognized result by OCR and chooses the best one.&lt;/p&gt; &#xA; &lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;740&#34; src=&#34;https://github.com/Danily07/Translumo/assets/29047281/649e5fab-a5de-4c54-a3d8-f7ea95b8f218&#34;&gt; &lt;/p&gt; &#xA; &lt;li&gt;&lt;b&gt;Simple interface&lt;/b&gt;&lt;/li&gt; The main idea was to make tool, that does not require manual adjustments for each case and convenient for everyday use. &#xA; &lt;li&gt;&lt;b&gt;Low latency&lt;/b&gt;&lt;/li&gt; There are several implemented optimizations to reduce impact on system performance and minimize latency between the moment a text appears and actual translation. &#xA; &lt;li&gt;&lt;b&gt;Integrated modern OCR engines:&lt;/b&gt; Tesseract 5.2, WindowsOCR, EasyOCR&lt;/li&gt; &#xA; &lt;li&gt;&lt;b&gt;Available translators:&lt;/b&gt; Google Translate, Yandex translate, Naver Papago, DeepL&lt;/li&gt; &#xA; &lt;li&gt;&lt;b&gt;Available recognition languages:&lt;/b&gt; English, Russian, Japanese, Chinese (simplified), Korean&lt;/li&gt; &#xA; &lt;li&gt;&lt;b&gt;Available translation languages:&lt;/b&gt; English, Russian, Japanese, Chinese (simplified), Korean, French, Spanish, German, Portuguese, Italian&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;System requirements&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows 10 build 19041 (20H1) / Windows 11&lt;/li&gt; &#xA; &lt;li&gt;DirectX11&lt;/li&gt; &#xA; &lt;li&gt;8 GB RAM &lt;i&gt;(for mode with EasyOCR)&lt;/i&gt;&lt;/li&gt; &#xA; &lt;li&gt;5 GB free storage space &lt;i&gt;(for mode with EasyOCR)&lt;/i&gt;&lt;/li&gt; &#xA; &lt;li&gt;Nvidia GPU with CUDA SDK 11.8 support (GTX 7xx series or later) &lt;i&gt;(for mode with EasyOCR)&lt;/i&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to use&lt;/h1&gt; &#xA;&lt;img src=&#34;https://github.com/Danily07/Translumo/raw/7f4a73ffba0e5a0090ea0bfc3d72acb99832a0f4/docs/preview-EN.gif&#34;&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open the Settings&lt;/li&gt; &#xA; &lt;li&gt;Select Languages-&amp;gt;Source language and Languages-&amp;gt;Translation language&lt;/li&gt; &#xA; &lt;li&gt;Select Text recognition-&amp;gt;Engines (please check Usage tips for recommendation modes)&lt;/li&gt; &#xA; &lt;li&gt;Select capture area&lt;/li&gt; &#xA; &lt;li&gt;Run translation&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Usage tips&lt;/h1&gt; Generally, I recommend always keep Windows OCR turned on. This is the most effective OCR for the primary text detection with less impact on performance. &#xA;&lt;h3&gt;Recommended combinations of OCR engines&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;b&gt;Tesseract-Windows OCR-EasyOCR&lt;/b&gt; - advanced mode with the highest percision&lt;/li&gt; &#xA; &lt;li&gt;&lt;b&gt;Tesseract-Windows OCR&lt;/b&gt; - noticeably less impact on system performance. It will be enough for cases when text has simple solid background and font is quite common&lt;/li&gt; &#xA; &lt;li&gt;&lt;b&gt;Windows OCR-EasyOCR&lt;/b&gt; - for very specific complex cases it makes sense to disable Tesseract and avoid unnecessary text noises&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Select minimum capture area&lt;/h3&gt; &#xA;&lt;p&gt;It reduces chances of getting into the area random letters from background. Also the larger frame will take longer to process.&lt;/p&gt; &#xA;&lt;h3&gt;Use proxy list to avoid blocking by translation services&lt;/h3&gt; &#xA;&lt;p&gt;Some translators sometimes block client for a large number of requests. You can configure personal/shared IPv4 proxies (1-2 should be enough) on &lt;b&gt;Languages-&amp;gt;Proxy tab&lt;/b&gt;. The application will alternately use proxies for requests to reduce number from one IP address.&lt;/p&gt; &#xA;&lt;h3&gt;Use Borderless/Windowed modes in games (not Fullscreen)&lt;/h3&gt; &#xA;&lt;p&gt;It is necessary to display the translation window overlay correctly.&lt;/p&gt; &#xA;&lt;p&gt;If the game doesn&#39;t have such mode, you can use external tools to make it borderless (e.g. &lt;a href=&#34;https://github.com/Codeusa/Borderless-Gaming&#34;&gt;Borderless Gaming&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Install the application on SSD&lt;/h3&gt; &#xA;&lt;p&gt;To reduce cold launch time with enabled EasyOCR engine (loading large EasyOCR model into RAM).&lt;/p&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;h4&gt;I got error &#34;Failed to capture screen&#34; or nothing happens after translation starts&lt;/h4&gt; &#xA;&lt;p&gt;Make sure that target window with text is active. Also try to restart Translumo or reopen target window.&lt;/p&gt; &#xA;&lt;h4&gt;I got error &#34;Text translation is failed&#34; after successful using the translation&lt;/h4&gt; &#xA;&lt;p&gt;There is a high probability that translation service temporarily blocked requests from your IP. You can change translator or configure proxy list.&lt;/p&gt; &#xA;&lt;h4&gt;Can&#39;t enable Windows OCR&lt;/h4&gt; &#xA;&lt;p&gt;Make sure that the application is runned as an Administrator. Translumo each time tries check installed Windows language pack via PowerShell.&lt;/p&gt; &#xA;&lt;h4&gt;Package downloading for EasyOCR failed&lt;/h4&gt; &#xA;&lt;p&gt;Try to re-install it under VPN&lt;/p&gt; &#xA;&lt;h4&gt;Hotkeys don&#39;t work&lt;/h4&gt; &#xA;&lt;p&gt;Other applications may intercept specific hotkeys handling&lt;/p&gt; &#xA;&lt;h4&gt;I got error &#34;Text detection is failed (TesseractOCREngine)&#34;&lt;/h4&gt; &#xA;&lt;p&gt;Make sure that the application path contains only latin letters.&lt;/p&gt; &#xA;&lt;h1&gt;Build&lt;/h1&gt; &#xA;&lt;p&gt;&lt;i&gt;Visual Studio 2022 and .NET 7 SDK are required&lt;/i&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone repository (&lt;b&gt;master&lt;/b&gt; branch always equals last release version):&lt;/li&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Danily07/Translumo.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;li&gt;Restore packages and build a solution. &lt;b&gt;binaries_extract.bat&lt;/b&gt; will be executed during building, which will automatically download models and python binaries to target output directory.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit&#34;&gt;Material Design In XAML Toolkit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/charlesw/tesseract&#34;&gt;Tesseract .NET wrapper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shimat/opencvsharp&#34;&gt;Opencvsharp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pythonnet/pythonnet&#34;&gt;Python.NET&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JaidedAI/EasyOCR&#34;&gt;EasyOCR&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>dotnet/orleans</title>
    <updated>2023-07-02T01:52:08Z</updated>
    <id>tag:github.com,2023-07-02:/dotnet/orleans</id>
    <link href="https://github.com/dotnet/orleans" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cloud Native application framework for .NET&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/dotnet/orleans/gh-pages/assets/logo_full.png&#34; alt=&#34;Orleans logo&#34; width=&#34;600px&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.nuget.org/profiles/Orleans&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Microsoft.Orleans.Core.svg?style=flat&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=msftorleans&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/msftorleans.svg?style=social&amp;amp;logo=twitter&#34; alt=&#34;Follow on Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://aka.ms/orleans-discord&#34;&gt;&lt;img src=&#34;https://discordapp.com/api/guilds/333727978460676096/widget.png?style=banner2&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Orleans is a cross-platform framework for building robust, scalable distributed applications&lt;/h3&gt; &#xA;&lt;p&gt;Orleans builds on the developer productivity of .NET and brings it to the world of distributed applications, such as cloud services. Orleans scales from a single on-premises server to globally distributed, highly-available applications in the cloud.&lt;/p&gt; &#xA;&lt;p&gt;Orleans takes familiar concepts like objects, interfaces, async/await, and try/catch and extends them to multi-server environments. As such, it helps developers experienced with single-server applications transition to building resilient, scalable cloud services and other distributed applications. For this reason, Orleans has often been referred to as &#34;Distributed .NET&#34;.&lt;/p&gt; &#xA;&lt;p&gt;It was created by &lt;a href=&#34;http://research.microsoft.com/projects/orleans/&#34;&gt;Microsoft Research&lt;/a&gt; and introduced the &lt;a href=&#34;http://research.microsoft.com/apps/pubs/default.aspx?id=210931&#34;&gt;Virtual Actor Model&lt;/a&gt; as a novel approach to building a new generation of distributed systems for the Cloud era. The core contribution of Orleans is its programming model which tames the complexity inherent to highly-parallel distributed systems without restricting capabilities or imposing onerous constraints on the developer.&lt;/p&gt; &#xA;&lt;h2&gt;Grains&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dotnet/orleans/main/assets/grain_formulation.svg?sanitize=true&#34; alt=&#34;A grain is composed of a stable identity, behavior, and state&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The fundamental building block in any Orleans application is a &lt;em&gt;grain&lt;/em&gt;. Grains are entities comprising user-defined identity, behavior, and state. Grain identities are user-defined keys which make Grains always available for invocation. Grains can be invoked by other grains or by external clients such as Web frontends, via strongly-typed communication interfaces (contracts). Each grain is an instance of a class which implements one or more of these interfaces.&lt;/p&gt; &#xA;&lt;p&gt;Grains can have volatile and/or persistent state that can be stored in any storage system. As such, grains implicitly partition application state, enabling automatic scalability and simplifying recovery from failures. Grain state is kept in memory while the grain is active, leading to lower latency and less load on data stores.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/dotnet/orleans/main/assets/managed_lifecycle.svg?sanitize=true&#34; alt=&#34;A diagram showing the managed lifecycle of a grain&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Instantiation of grains is automatically performed on demand by the Orleans runtime. Grains which are not used for a while are automatically removed from memory to free up resources. This is possible because of their stable identity, which allows invoking grains whether they are already loaded into memory or not. This also allows for transparent recovery from failure because the caller does not need to know on which server a grain is instantiated on at any point in time. Grains have a managed lifecycle, with the Orleans runtime responsible for activating/deactivating, and placing/locating grains as needed. This allows the developer to write code as if all grains were always in-memory.&lt;/p&gt; &#xA;&lt;p&gt;Taken together, the stable identity, statefulness, and managed lifecycle of Grains are core factors that make systems built on Orleans scalable, performant, &amp;amp; reliable without forcing developers to write complex distributed systems code.&lt;/p&gt; &#xA;&lt;h3&gt;Example: IoT cloud backend&lt;/h3&gt; &#xA;&lt;p&gt;Consider a cloud backend for an &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_of_things&#34;&gt;Internet of Things&lt;/a&gt; system. This application needs to process incoming device data, filter, aggregate, and process this information, and enable sending commands to devices. In Orleans, it is natural to model each device with a grain which becomes a &lt;em&gt;digital twin&lt;/em&gt; of the physical device it corresponds to. These grains keep the latest device data in memory, so that they can be quickly queried and processed without the need to communicate with the physical device directly. By observing streams of time-series data from the device, the grain can detect changes in conditions, such as measurements exceeding a threshold, and trigger an action.&lt;/p&gt; &#xA;&lt;p&gt;A simple thermostat could be modeled as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface IThermostat : IGrainWithStringKey&#xA;{&#xA;    Task&amp;lt;List&amp;lt;Command&amp;gt;&amp;gt; OnUpdate(ThermostatStatus update);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Events arriving from the thermostat from a Web frontend can be sent to its grain by invoking the &lt;code&gt;OnUpdate&lt;/code&gt; method which optionally returns a command back to the device.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var thermostat = client.GetGrain&amp;lt;IThermostat&amp;gt;(id);&#xA;return await thermostat.OnUpdate(update);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same thermostat grain can implement a separate interface for control systems to interact with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface IThermostatControl : IGrainWithStringKey&#xA;{&#xA;    Task&amp;lt;ThermostatStatus&amp;gt; GetStatus();&#xA;&#xA;    Task UpdateConfiguration(ThermostatConfiguration config);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These two interfaces (&lt;code&gt;IThermostat&lt;/code&gt; and &lt;code&gt;IThermostatControl&lt;/code&gt;) are implemented by a single implementation class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class ThermostatGrain : Grain, IThermostat, IThermostatControl&#xA;{&#xA;    private ThermostatStatus _status;&#xA;    private List&amp;lt;Command&amp;gt; _commands;&#xA;&#xA;    public Task&amp;lt;List&amp;lt;Command&amp;gt;&amp;gt; OnUpdate(ThermostatStatus status)&#xA;    {&#xA;        _status = status;&#xA;        var result = _commands;&#xA;        _commands = new List&amp;lt;Command&amp;gt;();&#xA;        return Task.FromResult(result);&#xA;    }&#xA;    &#xA;    public Task&amp;lt;ThermostatStatus&amp;gt; GetStatus() =&amp;gt; Task.FromResult(_status);&#xA;    &#xA;    public Task UpdateConfiguration(ThermostatConfiguration config)&#xA;    {&#xA;        _commands.Add(new ConfigUpdateCommand(config));&#xA;        return Task.CompletedTask;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Grain&lt;/code&gt; class above does not persist its state. A more thorough example demonstrating state persistence is available in the docs, for more information see &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/grain-persistence&#34;&gt;Microsoft Orleans: Grain Persistence&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Orleans runtime&lt;/h2&gt; &#xA;&lt;p&gt;The Orleans runtime is what implements the programming model for applications. The main component of the runtime is the &lt;em&gt;silo&lt;/em&gt;, which is responsible for hosting grains. Typically, a group of silos run as a cluster for scalability and fault-tolerance. When run as a cluster, silos coordinate with each other to distribute work, detect and recover from failures. The runtime enables grains hosted in the cluster to communicate with each other as if they are within a single process.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the core programming model, the silo provides grains with a set of runtime services, such as timers, reminders (persistent timers), persistence, transactions, streams, and more. See the &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/orleans/main/#features&#34;&gt;features section&lt;/a&gt; below for more detail.&lt;/p&gt; &#xA;&lt;p&gt;Web frontends and other external clients call grains in the cluster using the client library which automatically manages network communication. Clients can also be co-hosted in the same process with silos for simplicity.&lt;/p&gt; &#xA;&lt;p&gt;Orleans is compatible with .NET Standard 2.0 and above, running on Windows, Linux, and macOS, in full .NET Framework or .NET Core.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Orleans is a feature-rich framework. It provides a set of services that enable the development of distributed systems. The following sections describe the features of Orleans.&lt;/p&gt; &#xA;&lt;h3&gt;Persistence&lt;/h3&gt; &#xA;&lt;p&gt;Orleans provides a simple persistence model which ensures that state is available to a grain before requests are processed and that consistency is maintained. Grains can have multiple named persistent data objects, for example, one called &#34;profile&#34; for a user&#39;s profile and one called &#34;inventory&#34; for their inventory. This state can be stored in any storage system. For example, profile data may be stored in one database and inventory in another. While a grain is running, this state is kept in memory so that read requests can be served without accessing storage. When the grain updates its state, a &lt;code&gt;state.WriteStateAsync()&lt;/code&gt; call ensures that the backing store is updated for durability and consistency. For more information see &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/grain-persistence&#34;&gt;Microsoft Orleans: Grain Persistence&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Distributed ACID transactions&lt;/h3&gt; &#xA;&lt;p&gt;In addition to the simple persistence model described above, grains can have &lt;em&gt;transactional state&lt;/em&gt;. Multiple grains can participate in &lt;a href=&#34;https://en.wikipedia.org/wiki/ACID&#34;&gt;ACID&lt;/a&gt; transactions together regardless of where their state is ultimately stored. Transactions in Orleans are distributed and decentralized (there is no central transaction manager or transaction coordinator) and have &lt;a href=&#34;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&#34;&gt;serializable isolation&lt;/a&gt;. For more information, see the &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/transactions&#34;&gt;Microsoft Orleans: Transactions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Streams&lt;/h3&gt; &#xA;&lt;p&gt;Streams help developers to process series of data items in near-real time. Streams in Orleans are &lt;em&gt;managed&lt;/em&gt;: streams do not need to be created or registered before a grain or client publishes to a stream or subscribes to a stream. This allows for greater decoupling of stream producers and consumers from each other and from the infrastructure. Stream processing is reliable: grains can store checkpoints (cursors) and reset to a stored checkpoint during activation or at any point afterwards.&lt;/p&gt; &#xA;&lt;p&gt;Streams supports batch delivery of messages to consumers to improve efficiency and recovery performance. Streams are backed by queueing services such as Azure Event Hubs, Amazon Kinesis, and others. An arbitrary number of streams can be multiplexed onto a smaller number of queues and the responsibility for processing these queues is balanced evenly across the cluster.&lt;/p&gt; &#xA;&lt;h3&gt;Timers &amp;amp; reminders&lt;/h3&gt; &#xA;&lt;p&gt;Reminders are a durable scheduling mechanism for grains. They can be used to ensure that some action is completed at a future point even if the grain is not currently activated at that time. Timers are the non-durable counterpart to reminders and can be used for high-frequency events which do not require reliability. For more information, see &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/timers-and-reminders&#34;&gt;Microsoft Orleans: Timers and reminders&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Flexible grain placement&lt;/h3&gt; &#xA;&lt;p&gt;When a grain is activated in Orleans, the runtime decides which server (silo) to activate that grain on. This is called grain placement. The placement process in Orleans is fully configurable: developers can choose from a set of out-of-the-box placement policies such as random, prefer-local, and load-based, or custom logic can be configured. This allows for full flexibility in deciding where grains are created. For example, grains can be placed on a server close to resources which they need to operate on or other grains which they communicate with.&lt;/p&gt; &#xA;&lt;h3&gt;Grain versioning &amp;amp; heterogeneous clusters&lt;/h3&gt; &#xA;&lt;p&gt;Application code evolves over time and upgrading live, production systems in a manner which safely accounts for these changes can be challenging, particularly in stateful systems. Grain interfaces in Orleans can be optionally versioned. The cluster maintains a mapping of which grain implementations are available on which silos in the cluster and the versions of those implementations. This version information is used by the runtime in conjunction with placement strategies to make placement decisions when routing calls to grains. In addition to safe update of versioned grains, this also enables heterogeneous clusters, where different silos have different sets of grain implementations available. For more information, see &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/grain-versioning/grain-versioning&#34;&gt;Microsoft Orleans: Grain interface versioning&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Elastic scalability &amp;amp; fault tolerance&lt;/h3&gt; &#xA;&lt;p&gt;Orleans is designed to scale elastically. When a silo joins a cluster it is able to accept new activations and when a silo leaves the cluster (either because of scale down or a machine failure) the grains which were activated on that silo will be re-activated on remaining silos as needed. An Orleans cluster can be scaled down to a single silo. The same properties which enable elastic scalability also enable fault tolerance: the cluster automatically detects and quickly recovers from failures.&lt;/p&gt; &#xA;&lt;h3&gt;Run anywhere&lt;/h3&gt; &#xA;&lt;p&gt;Orleans runs anywhere that .NET Core or .NET Framework are supported. This includes hosting on Linux, Windows, and macOS and deploying to Kubernetes, virtual or physical machines, on premises or in the cloud, and PaaS services such as Azure Cloud Services.&lt;/p&gt; &#xA;&lt;h3&gt;Stateless workers&lt;/h3&gt; &#xA;&lt;p&gt;Stateless workers are specially marked grains which do not have any associated state and can be activated on multiple silos simultaneously. This enables increased parallelism for stateless functions. For more information, see &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/stateless-worker-grains&#34;&gt;Microsoft Orleans: Stateless worker grains&lt;/a&gt; documentation.&lt;/p&gt; &#xA;&lt;h3&gt;Grain call filters&lt;/h3&gt; &#xA;&lt;p&gt;Logic which is common to many grains can be expressed as &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/interceptors&#34;&gt;an interceptor, or Grain call filter&lt;/a&gt;. Orleans supports filters for both incoming and outgoing calls. Some common use-cases of filters are: authorization, logging and telemetry, and error handling.&lt;/p&gt; &#xA;&lt;h3&gt;Request context&lt;/h3&gt; &#xA;&lt;p&gt;Metadata and other information can be passed along a series of requests using &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/grains/request-context&#34;&gt;request context&lt;/a&gt;. Request context can be used for holding distributed tracing information or any other user-defined values.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The official documentation for Microsoft Orleans is available at &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans&#34;&gt;https://docs.microsoft.com/dotnet/orleans&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/orleans/main/samples/#readme&#34;&gt;Samples&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;A variety of samples are available in the official &lt;a href=&#34;https://docs.microsoft.com/samples/browse/?terms=orleans&#34;&gt;.NET Samples Browser&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Get started&lt;/h2&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/tutorials-and-samples/tutorial-1&#34;&gt;getting started tutorial&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;On Windows, run the &lt;code&gt;build.cmd&lt;/code&gt; script to build the NuGet packages locally, then reference the required NuGet packages from &lt;code&gt;/Artifacts/Release/*&lt;/code&gt;. You can run &lt;code&gt;Test.cmd&lt;/code&gt; to run all BVT tests, and &lt;code&gt;TestAll.cmd&lt;/code&gt; to also run Functional tests.&lt;/p&gt; &#xA;&lt;p&gt;On Linux and macOS, run the &lt;code&gt;build.sh&lt;/code&gt; script or &lt;code&gt;dotnet build&lt;/code&gt; to build Orleans.&lt;/p&gt; &#xA;&lt;h2&gt;Official builds&lt;/h2&gt; &#xA;&lt;p&gt;The latest stable, production-quality release is located &lt;a href=&#34;https://github.com/dotnet/orleans/releases/latest&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Nightly builds are published to &lt;a href=&#34;https://orleans.pkgs.visualstudio.com/orleans-public/_packaging/orleans-builds/nuget/v3/index.json&#34;&gt;a NuGet feed&lt;/a&gt;. These builds pass all functional tests, but are not thoroughly tested as the stable builds or pre-release builds published to NuGet.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Using the nightly build packages in your project &lt;/summary&gt; &#xA; &lt;p&gt;To use nightly builds in your project, add the MyGet feed using either of the following methods:&lt;/p&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;Changing the .csproj file to include this section:&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;RestoreSources&amp;gt;&#xA;    $(RestoreSources);&#xA;    https://orleans.pkgs.visualstudio.com/orleans-public/_packaging/orleans-builds/nuget/v3/index.json;&#xA;  &amp;lt;/RestoreSources&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;or&lt;/p&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;Creating a &lt;code&gt;NuGet.config&lt;/code&gt; file in the solution directory with the following contents:&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&amp;gt;&#xA;&amp;lt;configuration&amp;gt;&#xA;  &amp;lt;packageSources&amp;gt;&#xA;    &amp;lt;clear /&amp;gt;&#xA;    &amp;lt;add key=&#34;orleans-builds&#34;&#xA;      value=&#34;https://orleans.pkgs.visualstudio.com/orleans-public/_packaging/orleans-builds/nuget/v3/index.json&#34; /&amp;gt;&#xA;  &amp;lt;add key=&#34;nuget&#34; value=&#34;https://api.nuget.org/v3/index.json&#34; /&amp;gt;&#xA;  &amp;lt;/packageSources&amp;gt;&#xA;&amp;lt;/configuration&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://aka.ms/orleans-discord&#34;&gt;&lt;img src=&#34;https://discordapp.com/api/guilds/333727978460676096/widget.png?style=banner4&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ask questions by &lt;a href=&#34;https://github.com/dotnet/orleans/issues&#34;&gt;opening an issue on GitHub&lt;/a&gt; or on &lt;a href=&#34;https://stackoverflow.com/questions/ask?tags=orleans&#34;&gt;Stack Overflow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aka.ms/orleans-discord&#34;&gt;Chat on Discord&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Follow the &lt;a href=&#34;https://twitter.com/msftorleans&#34;&gt;@msftorleans&lt;/a&gt; Twitter account for Orleans announcements.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/OrleansContrib/&#34;&gt;OrleansContrib - GitHub organization for community add-ons to Orleans&lt;/a&gt; Various community projects, including Monitoring, Design Patterns, Storage Providers, etc.&lt;/li&gt; &#xA; &lt;li&gt;Guidelines for developers wanting to &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/orleans/main/CONTRIBUTING.md&#34;&gt;contribute code changes to Orleans&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;You are also encouraged to report bugs or start a technical discussion by starting a new &lt;a href=&#34;https://github.com/dotnet/orleans/issues&#34;&gt;thread&lt;/a&gt; on GitHub.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/orleans/main/LICENSE&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quick links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://research.microsoft.com/projects/orleans/&#34;&gt;Microsoft Research project home&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Technical Report: &lt;a href=&#34;http://research.microsoft.com/apps/pubs/default.aspx?id=210931&#34;&gt;Distributed Virtual Actors for Programmability and Scalability&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/dotnet/orleans/&#34;&gt;Microsoft Orleans: Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/orleans/main/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>