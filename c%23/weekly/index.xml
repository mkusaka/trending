<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-08T01:40:38Z</updated>
  <subtitle>Weekly Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dotnet/BenchmarkDotNet</title>
    <updated>2025-06-08T01:40:38Z</updated>
    <id>tag:github.com,2025-06-08:/dotnet/BenchmarkDotNet</id>
    <link href="https://github.com/dotnet/BenchmarkDotNet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Powerful .NET library for benchmarking&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/ec962b0bd6854c991d7a3ebd77037579165acb36/docs/logo/logo-wide.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/BenchmarkDotNet/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/BenchmarkDotNet.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.myget.org/feed/benchmarkdotnet/package/nuget/BenchmarkDotNet&#34;&gt;&lt;img src=&#34;https://img.shields.io/myget/benchmarkdotnet/vpre/benchmarkdotnet?label=myget&#34; alt=&#34;MyGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/BenchmarkDotNet/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/benchmarkdotnet.svg?sanitize=true&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/dotnet/BenchmarkDotNet?color=brightgreen&#34; alt=&#34;Stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/raw/master/LICENSE.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/BenchmarkDotNet&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/BenchmarkDotNet?style=social&amp;amp;label=Twitter&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34; style=&#34;font-size: 130%; margin-bottom: 20px&#34;&gt; &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#features&#34;&gt;Features&lt;/a&gt; &#xA; &lt;span&gt; · &lt;/span&gt; &#xA; &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/getting-started.html&#34;&gt;Getting started&lt;/a&gt; &#xA; &lt;span&gt; · &lt;/span&gt; &#xA; &lt;a href=&#34;https://benchmarkdotnet.org/articles/overview.html&#34;&gt;Documentation&lt;/a&gt; &#xA; &lt;span&gt; · &lt;/span&gt; &#xA; &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#learn-more-about-benchmarking&#34;&gt;Learn more about benchmarking&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;strong&gt;BenchmarkDotNet&lt;/strong&gt; helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments. It&#39;s no harder than writing unit tests! Under the hood, it performs a lot of &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#automation&#34;&gt;magic&lt;/a&gt; that guarantees &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#reliability&#34;&gt;reliable and precise&lt;/a&gt; results thanks to the &lt;a href=&#34;https://github.com/AndreyAkinshin/perfolizer&#34;&gt;perfolizer&lt;/a&gt; statistical engine. BenchmarkDotNet protects you from popular benchmarking mistakes and warns you if something is wrong with your benchmark design or obtained measurements. The results are presented in a &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#friendliness&#34;&gt;user-friendly&lt;/a&gt; form that highlights all the important facts about your experiment. BenchmarkDotNet is already adopted by &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/network/dependents&#34;&gt;26000+ GitHub projects&lt;/a&gt; including &lt;a href=&#34;https://github.com/dotnet/runtime&#34;&gt;.NET Runtime&lt;/a&gt;, &lt;a href=&#34;https://github.com/dotnet/roslyn&#34;&gt;.NET Compiler&lt;/a&gt;, &lt;a href=&#34;https://github.com/dotnet/performance&#34;&gt;.NET Performance&lt;/a&gt;, and many others.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/master/#simplicity&#34;&gt;easy&lt;/a&gt; to start writing benchmarks, check out the following example (copy-pastable version is &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/getting-started.html&#34;&gt;here&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;[SimpleJob(RuntimeMoniker.Net472, baseline: true)]&#xA;[SimpleJob(RuntimeMoniker.NetCoreApp30)]&#xA;[SimpleJob(RuntimeMoniker.NativeAot70)]&#xA;[SimpleJob(RuntimeMoniker.Mono)]&#xA;[RPlotExporter]&#xA;public class Md5VsSha256&#xA;{&#xA;    private SHA256 sha256 = SHA256.Create();&#xA;    private MD5 md5 = MD5.Create();&#xA;    private byte[] data;&#xA;&#xA;    [Params(1000, 10000)]&#xA;    public int N;&#xA;&#xA;    [GlobalSetup]&#xA;    public void Setup()&#xA;    {&#xA;        data = new byte[N];&#xA;        new Random(42).NextBytes(data);&#xA;    }&#xA;&#xA;    [Benchmark]&#xA;    public byte[] Sha256() =&amp;gt; sha256.ComputeHash(data);&#xA;&#xA;    [Benchmark]&#xA;    public byte[] Md5() =&amp;gt; md5.ComputeHash(data);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;BenchmarkDotNet automatically runs the benchmarks on all the runtimes, aggregates the measurements, and prints a summary table with the most important information:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;BenchmarkDotNet=v0.12.0, OS=Windows 10.0.17763.805 (1809/October2018Update/Redstone5)&#xA;Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores&#xA;  [Host]       : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT&#xA;  Net472       : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT&#xA;  NetCoreApp30 : .NET Core 3.0.0 (CoreCLR 4.700.19.46205, CoreFX 4.700.19.46214), X64 RyuJIT&#xA;  NativeAot70  : .NET 7.0.0-preview.4.22172.7, X64 NativeAOT&#xA;  Mono         : Mono 6.4.0 (Visual Studio), X64&#xA;&#xA;&#xA;| Method |       Runtime |     N |       Mean |     Error |    StdDev | Ratio |&#xA;|------- |-------------- |------ |-----------:|----------:|----------:|------:|&#xA;| Sha256 |    .NET 4.7.2 |  1000 |   7.735 us | 0.1913 us | 0.4034 us |  1.00 |&#xA;| Sha256 | .NET Core 3.0 |  1000 |   3.989 us | 0.0796 us | 0.0745 us |  0.50 |&#xA;| Sha256 | NativeAOT 7.0 |  1000 |   4.091 us | 0.0811 us | 0.1562 us |  0.53 |&#xA;| Sha256 |          Mono |  1000 |  13.117 us | 0.2485 us | 0.5019 us |  1.70 |&#xA;|        |               |       |            |           |           |       |&#xA;|    Md5 |    .NET 4.7.2 |  1000 |   2.872 us | 0.0552 us | 0.0737 us |  1.00 |&#xA;|    Md5 | .NET Core 3.0 |  1000 |   1.848 us | 0.0348 us | 0.0326 us |  0.64 |&#xA;|    Md5 | NativeAOT 7.0 |  1000 |   1.817 us | 0.0359 us | 0.0427 us |  0.63 |&#xA;|    Md5 |          Mono |  1000 |   3.574 us | 0.0678 us | 0.0753 us |  1.24 |&#xA;|        |               |       |            |           |           |       |&#xA;| Sha256 |    .NET 4.7.2 | 10000 |  74.509 us | 1.5787 us | 4.6052 us |  1.00 |&#xA;| Sha256 | .NET Core 3.0 | 10000 |  36.049 us | 0.7151 us | 1.0025 us |  0.49 |&#xA;| Sha256 | NativeAOT 7.0 | 10000 |  36.253 us | 0.7076 us | 0.7571 us |  0.49 |&#xA;| Sha256 |          Mono | 10000 | 116.350 us | 2.2555 us | 3.0110 us |  1.58 |&#xA;|        |               |       |            |           |           |       |&#xA;|    Md5 |    .NET 4.7.2 | 10000 |  17.308 us | 0.3361 us | 0.4250 us |  1.00 |&#xA;|    Md5 | .NET Core 3.0 | 10000 |  15.726 us | 0.2064 us | 0.1930 us |  0.90 |&#xA;|    Md5 | NativeAOT 7.0 | 10000 |  15.627 us | 0.2631 us | 0.2461 us |  0.89 |&#xA;|    Md5 |          Mono | 10000 |  30.205 us | 0.5868 us | 0.6522 us |  1.74 |&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The measured data can be exported to different formats (md, html, csv, xml, json, etc.) including plots:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dotnet/BenchmarkDotNet/ec962b0bd6854c991d7a3ebd77037579165acb36/docs/images/v0.12.0/rplot.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Supported runtimes:&lt;/em&gt; .NET 5+, .NET Framework 4.6.1+, .NET Core 2.0+, Mono, NativeAOT&lt;br&gt; &lt;em&gt;Supported languages:&lt;/em&gt; C#, F#, Visual Basic&lt;br&gt; &lt;em&gt;Supported OS:&lt;/em&gt; Windows, Linux, macOS&lt;br&gt; &lt;em&gt;Supported architectures:&lt;/em&gt; x86, x64, ARM, ARM64, Wasm and LoongArch64&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;BenchmarkDotNet has tons of features that are essential in comprehensive performance investigations. Four aspects define the design of these features: &lt;em&gt;simplicity&lt;/em&gt;, &lt;em&gt;automation&lt;/em&gt;, &lt;em&gt;reliability&lt;/em&gt;, and &lt;em&gt;friendliness&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Simplicity&lt;/h3&gt; &#xA;&lt;p&gt;You shouldn&#39;t have to be an experienced performance engineer if you want to write benchmarks. You can design very complicated performance experiments in the declarative style using simple APIs.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you want to &lt;a href=&#34;https://benchmarkdotnet.org/articles/features/parameterization.html&#34;&gt;parameterize&lt;/a&gt; your benchmark, mark a field or a property with &lt;code&gt;[Params(1, 2, 3)]&lt;/code&gt;: BenchmarkDotNet will enumerate all of the specified values and run benchmarks for each case. If you want to compare benchmarks with each other, mark one of the benchmarks as the &lt;a href=&#34;https://benchmarkdotnet.org/articles/features/baselines.html&#34;&gt;baseline&lt;/a&gt; via &lt;code&gt;[Benchmark(Baseline = true)]&lt;/code&gt;: BenchmarkDotNet will compare it with all of the other benchmarks. If you want to compare performance in different environments, use &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/jobs.html&#34;&gt;jobs&lt;/a&gt;. For example, you can run all the benchmarks on .NET 8.0 and Mono via &lt;code&gt;[SimpleJob(RuntimeMoniker.Net80)]&lt;/code&gt; and &lt;code&gt;[SimpleJob(RuntimeMoniker.Mono)]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t like attributes, you can call most of the APIs via the fluent style and write code like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ManualConfig.CreateEmpty() // A configuration for our benchmarks&#xA;    .AddJob(Job.Default // Adding first job&#xA;        .WithRuntime(ClrRuntime.Net472) // .NET Framework 4.7.2&#xA;        .WithPlatform(Platform.X64) // Run as x64 application&#xA;        .WithJit(Jit.LegacyJit) // Use LegacyJIT instead of the default RyuJIT&#xA;        .WithGcServer(true) // Use Server GC&#xA;    ).AddJob(Job.Default // Adding second job&#xA;        .AsBaseline() // It will be marked as baseline&#xA;        .WithEnvironmentVariable(&#34;Key&#34;, &#34;Value&#34;) // Setting an environment variable&#xA;        .WithWarmupCount(0) // Disable warm-up stage&#xA;    );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you prefer command-line experience, you can configure your benchmarks via the &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/console-args.html&#34;&gt;console arguments&lt;/a&gt; in any console application (other types of applications are not supported).&lt;/p&gt; &#xA;&lt;h3&gt;Automation&lt;/h3&gt; &#xA;&lt;p&gt;Reliable benchmarks always include a lot of boilerplate code.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s think about what you should do in a typical case. First, you should perform a pilot experiment and determine the best number of method invocations. Next, you should execute several warm-up iterations and ensure that your benchmark achieved a steady state. After that, you should execute the main iterations and calculate some basic statistics. If you calculate some values in your benchmark, you should use it somehow to prevent dead code elimination. If you use loops, you should care about the effect of the loop unrolling on your results (which may depend on the processor architecture). Once you get results, you should check for some special properties of the obtained performance distribution like multimodality or extremely high outliers. You should also evaluate the overhead of your infrastructure and deduct it from your results. If you want to test several environments, you should perform the measurements in each of them and manually aggregate the results.&lt;/p&gt; &#xA;&lt;p&gt;If you write this code from scratch, it&#39;s easy to make a mistake and spoil your measurements. Note that it&#39;s a shortened version of the full checklist that you should follow during benchmarking: there are a lot of additional hidden pitfalls that should be handled appropriately. Fortunately, you shouldn&#39;t worry about it because BenchmarkDotNet &lt;a href=&#34;https://benchmarkdotnet.org/articles/guides/how-it-works.html&#34;&gt;will perform&lt;/a&gt; this boring and time-consuming stuff for you.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, the library can help you with some advanced tasks that you may want to perform during the investigation. For example, BenchmarkDotNet can measure the &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/diagnosers.html#usage&#34;&gt;managed&lt;/a&gt; and &lt;a href=&#34;https://benchmarkdotnet.org/articles/samples/IntroNativeMemory.html&#34;&gt;native&lt;/a&gt; memory traffic and print &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/diagnosers.html#sample-introdisassembly&#34;&gt;disassembly listings&lt;/a&gt; for your benchmarks.&lt;/p&gt; &#xA;&lt;h3&gt;Reliability&lt;/h3&gt; &#xA;&lt;p&gt;A lot of hand-written benchmarks produce wrong numbers that lead to incorrect business decisions. BenchmarkDotNet protects you from most of the benchmarking pitfalls and allows achieving high measurement precision.&lt;/p&gt; &#xA;&lt;p&gt;You shouldn&#39;t worry about the perfect number of method invocation, the number of warm-up and actual iterations: BenchmarkDotNet tries to choose the best benchmarking parameters and achieve a good trade-off between the measurement prevision and the total duration of all benchmark runs. So, you shouldn&#39;t use any magic numbers (like &#34;We should perform 100 iterations here&#34;), the library will do it for you based on the values of statistical metrics.&lt;/p&gt; &#xA;&lt;p&gt;BenchmarkDotNet also prevents benchmarking of non-optimized assemblies that were built using DEBUG mode because the corresponding results will be unreliable. The library will print a warning if you have an attached debugger, if you use a hypervisor (HyperV, VMware, VirtualBox), or if you have any other problems with the current environment.&lt;/p&gt; &#xA;&lt;p&gt;During 6+ years of development, we faced dozens of different problems that may spoil your measurements. Inside BenchmarkDotNet, there are a lot of heuristics, checks, hacks, and tricks that help you to increase the reliability of the results.&lt;/p&gt; &#xA;&lt;h3&gt;Friendliness&lt;/h3&gt; &#xA;&lt;p&gt;Analysis of performance data is a time-consuming activity that requires attentiveness, knowledge, and experience. BenchmarkDotNet performs the main part of this analysis for you and presents results in a user-friendly form.&lt;/p&gt; &#xA;&lt;p&gt;After the experiments, you get a summary table that contains a lot of useful data about the executed benchmarks. By default, it includes only the most important columns, but they can be &lt;a href=&#34;https://benchmarkdotnet.org/articles/configs/columns.html&#34;&gt;easily customized&lt;/a&gt;. The column set is adaptive and depends on the benchmark definition and measured values. For example, if you mark one of the benchmarks as a &lt;a href=&#34;https://benchmarkdotnet.org/articles/features/baselines.html&#34;&gt;baseline&lt;/a&gt;, you will get additional columns that will help you to compare all the benchmarks with the baseline. By default, it always shows the Mean column, but if we detected a vast difference between the Mean and the Median values, both columns will be presented.&lt;/p&gt; &#xA;&lt;p&gt;BenchmarkDotNet tries to find some unusual properties of your performance distributions and prints nice messages about it. For example, it will warn you in case of multimodal distribution or high outliers. In this case, you can scroll the results up and check out ASCII-style histograms for each distribution or generate beautiful png plots using &lt;code&gt;[RPlotExporter]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;BenchmarkDotNet doesn&#39;t overload you with data; it shows only the essential information depending on your results: it allows you to keep the summary small for primitive cases and extend it only for complicated cases. Of course, you can request any additional statistics and visualizations manually. If you don&#39;t customize the summary view, the default presentation will be as much user-friendly as possible. :)&lt;/p&gt; &#xA;&lt;h2&gt;Learn more about benchmarking&lt;/h2&gt; &#xA;&lt;p&gt;BenchmarkDotNet is not a silver bullet that magically makes all of your benchmarks correct and analyzes the measurements for you. Even if you use this library, you still should know how to design benchmark experiments and how to make correct conclusions based on the raw data. If you want to know more about benchmarking methodology and good practices, it&#39;s recommended to read a book by Andrey Akinshin (the BenchmarkDotNet project lead): &lt;a href=&#34;https://aakinshin.net/prodotnetbenchmarking/&#34;&gt;&#34;Pro .NET Benchmarking&#34;&lt;/a&gt;. Use this in-depth guide to correctly design benchmarks, measure key performance metrics of .NET applications, and analyze results. This book presents dozens of case studies to help you understand complicated benchmarking topics. You will avoid common pitfalls, control the accuracy of your measurements, and improve the performance of your software.&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://aakinshin.net/prodotnetbenchmarking/&#34;&gt; &lt;img src=&#34;https://aakinshin.net/img/misc/prodotnetbenchmarking-cover.png&#34; width=&#34;400&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Contributions are welcome!&lt;/h2&gt; &#xA;&lt;p&gt;BenchmarkDotNet is already a stable full-featured library that allows performing performance investigation on a professional level. And it continues to evolve! We add new features all the time, but we have too many new cool ideas. Any help will be appreciated. You can develop new features, fix bugs, improve the documentation, or do some other cool stuff.&lt;/p&gt; &#xA;&lt;p&gt;If you want to contribute, check out the &lt;a href=&#34;https://benchmarkdotnet.org/articles/contributing/building.html&#34;&gt;Contributing guide&lt;/a&gt; and &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/issues?q=is:open+is:issue+label:up-for-grabs&#34;&gt;up-for-grabs&lt;/a&gt; issues. If you have new ideas or want to complain about bugs, feel free to &lt;a href=&#34;https://github.com/dotnet/BenchmarkDotNet/issues/new&#34;&gt;create a new issue&lt;/a&gt;. Let&#39;s build the best tool for benchmarking together!&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;This project has adopted the code of conduct defined by the &lt;a href=&#34;https://www.contributor-covenant.org/&#34;&gt;Contributor Covenant&lt;/a&gt; to clarify expected behavior in our community. For more information, see the &lt;a href=&#34;https://dotnetfoundation.org/code-of-conduct&#34;&gt;.NET Foundation Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dotnet/msbuild</title>
    <updated>2025-06-08T01:40:38Z</updated>
    <id>tag:github.com,2025-06-08:/dotnet/msbuild</id>
    <link href="https://github.com/dotnet/msbuild" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Microsoft Build Engine (MSBuild) is the build platform for .NET and Visual Studio.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Microsoft.Build (MSBuild)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dev.azure.com/dnceng-public/public/_build?definitionId=75&#34;&gt;&lt;img src=&#34;https://dev.azure.com/dnceng-public/public/_apis/build/status/75?branchName=main&amp;amp;label=Public&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434&#34;&gt;&lt;img src=&#34;https://devdiv.visualstudio.com/DevDiv/_apis/build/status/9434?label=Internal&amp;amp;branchName=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Microsoft Build Engine is a platform for building applications. This engine, also known as MSBuild, provides an XML schema for a project file that controls how the build platform processes and builds software. Visual Studio uses MSBuild, but MSBuild can run without Visual Studio. By invoking msbuild.exe on your project or solution file, you can orchestrate and build products in environments where Visual Studio isn&#39;t installed.&lt;/p&gt; &#xA;&lt;p&gt;For more information on MSBuild, see the &lt;a href=&#34;https://learn.microsoft.com/visualstudio/msbuild/msbuild&#34;&gt;MSBuild documentation&lt;/a&gt; on learn.microsoft.com.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/Changelog.md&#34;&gt;changelog&lt;/a&gt; has detailed information about changes made in different releases.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;Building MSBuild with Visual Studio 2022 on Windows&lt;/h3&gt; &#xA;&lt;p&gt;For the full supported experience, you will need to have Visual Studio 2022 or higher.&lt;/p&gt; &#xA;&lt;p&gt;To get started on &lt;strong&gt;Visual Studio 2022&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.visualstudio.com/vs/&#34;&gt;Install Visual Studio 2022&lt;/a&gt;. Select the following Workloads: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;.NET desktop development&lt;/li&gt; &#xA;   &lt;li&gt;.NET Core cross-platform development&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Ensure &lt;a href=&#34;https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry#enable-long-paths-in-windows-10-version-1607-and-later&#34;&gt;long path support&lt;/a&gt; is enabled at the Windows level.&lt;/li&gt; &#xA; &lt;li&gt;Open a &lt;code&gt;Developer Command Prompt for VS 2022&lt;/code&gt; prompt.&lt;/li&gt; &#xA; &lt;li&gt;Clone the source code: &lt;code&gt;git clone https://github.com/dotnet/msbuild&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You may have to &lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;download Git&lt;/a&gt; first.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;.\build.cmd&lt;/code&gt; from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.&lt;/li&gt; &#xA; &lt;li&gt;Open &lt;code&gt;MSBuild.sln&lt;/code&gt; or &lt;code&gt;MSBuild.Dev.slnf&lt;/code&gt; in Visual Studio 2022.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This newly-built MSBuild will be located at &lt;code&gt;artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe&lt;/code&gt;. It may not work for all scenarios, including C++ builds.&lt;/p&gt; &#xA;&lt;h3&gt;Building MSBuild in Unix (Mac &amp;amp; Linux)&lt;/h3&gt; &#xA;&lt;p&gt;MSBuild can be run on Unix systems that support .NET Core. Set-up instructions can be viewed on the wiki: &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md&#34;&gt;Building Testing and Debugging on .Net Core MSBuild&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Localization&lt;/h2&gt; &#xA;&lt;p&gt;You can turn on localized builds via the &lt;code&gt;/p:LocalizedBuild=true&lt;/code&gt; command line argument. For more information on localized builds and how to make contributions to MSBuild&#39;s translations, see our &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/wiki/Localization.md&#34;&gt;localization documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Interested in contributing?&lt;/h3&gt; &#xA;&lt;p&gt;Before you contribute, please read through the contributing and developer guides to get an idea of what kinds of pull requests we accept.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/wiki/Contributing-Code.md&#34;&gt;Contributing Guide&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Developer Guide on:&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md&#34;&gt;.NET Core&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md&#34;&gt;Full Framework&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;See our &lt;a href=&#34;https://github.com/dotnet/msbuild/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22&#34;&gt;help wanted issues&lt;/a&gt; for a list of issues we think are great to onboard new developers.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Note:&lt;/strong&gt; Please leave a comment asking to be assigned the issue if you want to work on it.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;See our &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/wiki/Labels.md&#34;&gt;label documentation&lt;/a&gt; for descriptions of labels we use throughout the repo.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Other ways to contribute&lt;/h3&gt; &#xA;&lt;p&gt;We encourage any contributions you decide to make to the repo!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dotnet/msbuild/issues/new/choose&#34;&gt;File an issue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dotnet/msbuild/discussions&#34;&gt;Start a discussion&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;MSBuild Components&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;MSBuild&lt;/strong&gt;. &lt;a href=&#34;https://docs.microsoft.com/visualstudio/msbuild/msbuild&#34;&gt;Microsoft.Build.CommandLine&lt;/a&gt; is the entrypoint for the Microsoft Build Engine (MSBuild.exe).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Microsoft.Build&lt;/strong&gt;. The &lt;a href=&#34;https://docs.microsoft.com/dotnet/api/?term=Microsoft.Build&#34;&gt;Microsoft.Build&lt;/a&gt; namespaces contain types that provide programmatic access to, and control of, the MSBuild engine.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Microsoft.Build.Framework&lt;/strong&gt;. The &lt;a href=&#34;https://docs.microsoft.com/dotnet/api/microsoft.build.framework&#34;&gt;Microsoft.Build.Framework&lt;/a&gt; namespace contains the types that define how tasks and loggers interact with the MSBuild engine. For additional information on this component, see our &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/documentation/wiki/Microsoft.Build.Framework.md&#34;&gt;Microsoft.Build.Framework wiki page&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Microsoft.Build.Tasks&lt;/strong&gt;. The &lt;a href=&#34;https://docs.microsoft.com/dotnet/api/microsoft.build.tasks&#34;&gt;Microsoft.Build.Tasks&lt;/a&gt; namespace contains the implementation of all tasks shipping with MSBuild.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Microsoft.Build.Utilities&lt;/strong&gt;. The &lt;a href=&#34;https://docs.microsoft.com/dotnet/api/microsoft.build.utilities&#34;&gt;Microsoft.Build.Utilities&lt;/a&gt; namespace provides helper classes that you can use to create your own MSBuild loggers and tasks.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;MSBuild is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/dotnet/msbuild/main/LICENSE&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>