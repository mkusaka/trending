<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-10T01:50:44Z</updated>
  <subtitle>Weekly Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dotnetcore/CAP</title>
    <updated>2023-12-10T01:50:44Z</updated>
    <id>tag:github.com,2023-12-10:/dotnetcore/CAP</id>
    <link href="https://github.com/dotnetcore/CAP" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Distributed transaction solution in micro-service base on eventually consistency, also an eventbus with Outbox pattern&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img height=&#34;140&#34; src=&#34;https://raw.githubusercontent.com/dotnetcore/CAP/master/docs/content/img/logo.svg?sanitize=true&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;CAP 　　　　　　　　　　　　　　　　　　　　&lt;a href=&#34;https://github.com/dotnetcore/CAP/raw/master/README.zh-cn.md&#34;&gt;中文&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dotnetcore/CAP/actions/workflows/deploy-docs-and-dashboard.yml&#34;&gt;&lt;img src=&#34;https://github.com/dotnetcore/CAP/actions/workflows/deploy-docs-and-dashboard.yml/badge.svg?branch=master&#34; alt=&#34;Docs&amp;amp;Dashboard&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/yang-xiaodong/cap/branch/master&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/v8gfh6pe2u2laqoa/branch/master?svg=true&#34; alt=&#34;AppVeyor&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/DotNetCore.CAP/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/DotNetCore.CAP.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/DotNetCore.CAP/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/DotNetCore.CAP.svg?label=nuget-pre&#34; alt=&#34;NuGet Preview&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dotnetcore&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/member%20project%20of-NCC-9e20c9.svg?sanitize=true&#34; alt=&#34;Member project of .NET Core Community&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/dotnetcore/CAP/master/LICENSE.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;CAP is a library based on .Net standard, which is a solution to deal with distributed transactions, has the function of EventBus, it is lightweight, easy to use, and efficient.&lt;/p&gt; &#xA;&lt;p&gt;In the process of building an SOA or MicroService system, we usually need to use the event to integrate each service. In the process, simple use of message queue does not guarantee reliability. CAP adopts local message table program integrated with the current database to solve exceptions that may occur in the process of the distributed system calling each other. It can ensure that the event messages are not lost in any case.&lt;/p&gt; &#xA;&lt;p&gt;You can also use CAP as an EventBus. CAP provides a simpler way to implement event publishing and subscriptions. You do not need to inherit or implement any interface during subscription and sending process.&lt;/p&gt; &#xA;&lt;h2&gt;Architecture overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dotnetcore/CAP/master/docs/content/img/architecture-new.png&#34; alt=&#34;cap.png&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;CAP implements the Outbox Pattern described in the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/subscribe-events#designing-atomicity-and-resiliency-when-publishing-to-the-event-bus&#34;&gt;eShop ebook&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;NuGet&lt;/h3&gt; &#xA;&lt;p&gt;CAP can be installed in your project with the following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CAP supports most popular message queue as transport, following packages are available to install:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP.Kafka&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.RabbitMQ&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.AzureServiceBus&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.AmazonSQS&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.NATS&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.RedisStreams&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.Pulsar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CAP supports most popular database as event storage, following packages are available to install:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// select a database provider you are using, event log table will integrate into.&#xA;&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.SqlServer&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.MySql&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.PostgreSql&#xA;PM&amp;gt; Install-Package DotNetCore.CAP.MongoDB     //need MongoDB 4.0+ cluster&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;First, you need to configure CAP in your Startup.cs：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public void ConfigureServices(IServiceCollection services)&#xA;{&#xA;    //......&#xA;&#xA;    services.AddDbContext&amp;lt;AppDbContext&amp;gt;(); //Options, If you are using EF as the ORM&#xA;    services.AddSingleton&amp;lt;IMongoClient&amp;gt;(new MongoClient(&#34;&#34;)); //Options, If you are using MongoDB&#xA;&#xA;    services.AddCap(x =&amp;gt;&#xA;    {&#xA;        // If you are using EF, you need to add the configuration：&#xA;        x.UseEntityFramework&amp;lt;AppDbContext&amp;gt;(); //Options, Notice: You don&#39;t need to config x.UseSqlServer(&#34;&#34;&#34;) again! CAP can autodiscovery.&#xA;&#xA;        // If you are using ADO.NET, choose to add configuration you needed：&#xA;        x.UseSqlServer(&#34;Your ConnectionStrings&#34;);&#xA;        x.UseMySql(&#34;Your ConnectionStrings&#34;);&#xA;        x.UsePostgreSql(&#34;Your ConnectionStrings&#34;);&#xA;&#xA;        // If you are using MongoDB, you need to add the configuration：&#xA;        x.UseMongoDB(&#34;Your ConnectionStrings&#34;);  //MongoDB 4.0+ cluster&#xA;&#xA;        // CAP support RabbitMQ,Kafka,AzureService as the MQ, choose to add configuration you needed：&#xA;        x.UseRabbitMQ(&#34;HostName&#34;);&#xA;        x.UseKafka(&#34;ConnectionString&#34;);&#xA;        x.UseAzureServiceBus(&#34;ConnectionString&#34;);&#xA;        x.UseAmazonSQS();&#xA;    });&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Publish&lt;/h3&gt; &#xA;&lt;p&gt;Inject &lt;code&gt;ICapPublisher&lt;/code&gt; in your Controller, then use the &lt;code&gt;ICapPublisher&lt;/code&gt; to send messages.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The version 7.0+ supports publish delay messages.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;public class PublishController : Controller&#xA;{&#xA;    private readonly ICapPublisher _capBus;&#xA;&#xA;    public PublishController(ICapPublisher capPublisher)&#xA;    {&#xA;        _capBus = capPublisher;&#xA;    }&#xA;&#xA;    [Route(&#34;~/adonet/transaction&#34;)]&#xA;    public IActionResult AdonetWithTransaction()&#xA;    {&#xA;        using (var connection = new MySqlConnection(ConnectionString))&#xA;        {&#xA;            using (var transaction = connection.BeginTransaction(_capBus, autoCommit: true))&#xA;            {&#xA;                //your business logic code&#xA;&#xA;                _capBus.Publish(&#34;xxx.services.show.time&#34;, DateTime.Now);&#xA;&#xA;                // Publish delay message&#xA;                _capBus.PublishDelayAsync(TimeSpan.FromSeconds(delaySeconds), &#34;xxx.services.show.time&#34;, DateTime.Now);&#xA;            }&#xA;        }&#xA;&#xA;        return Ok();&#xA;    }&#xA;&#xA;    [Route(&#34;~/ef/transaction&#34;)]&#xA;    public IActionResult EntityFrameworkWithTransaction([FromServices]AppDbContext dbContext)&#xA;    {&#xA;        using (var trans = dbContext.Database.BeginTransaction(_capBus, autoCommit: true))&#xA;        {&#xA;            //your business logic code&#xA;&#xA;            _capBus.Publish(&#34;xxx.services.show.time&#34;, DateTime.Now);&#xA;        }&#xA;&#xA;        return Ok();&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Subscribe&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;In Controller Action&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add the Attribute &lt;code&gt;[CapSubscribe()]&lt;/code&gt; on Action to subscribe to messages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;public class PublishController : Controller&#xA;{&#xA;    [CapSubscribe(&#34;xxx.services.show.time&#34;)]&#xA;    public void CheckReceivedMessage(DateTime datetime)&#xA;    {&#xA;        Console.WriteLine(datetime);&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;In Business Logic Service&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If your subscription method is not in the Controller, then your subscribe class needs to implement &lt;code&gt;ICapSubscribe&lt;/code&gt; interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;&#xA;namespace BusinessCode.Service&#xA;{&#xA;    public interface ISubscriberService&#xA;    {&#xA;        void CheckReceivedMessage(DateTime datetime);&#xA;    }&#xA;&#xA;    public class SubscriberService: ISubscriberService, ICapSubscribe&#xA;    {&#xA;        [CapSubscribe(&#34;xxx.services.show.time&#34;)]&#xA;        public void CheckReceivedMessage(DateTime datetime)&#xA;        {&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then register your class that implements &lt;code&gt;ISubscriberService&lt;/code&gt; in Startup.cs&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;public void ConfigureServices(IServiceCollection services)&#xA;{&#xA;    services.AddTransient&amp;lt;ISubscriberService,SubscriberService&amp;gt;();&#xA;&#xA;    services.AddCap(x=&amp;gt;&#xA;    {&#xA;        //...&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Async subscription&lt;/h4&gt; &#xA;&lt;p&gt;You are able to implement async subscription. Subscription&#39;s method should return Task and receive CancellationToken as parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;public class AsyncSubscriber : ICapSubscribe&#xA;{&#xA;    [CapSubscribe(&#34;name&#34;)]&#xA;    public async Task ProcessAsync(Message message, CancellationToken cancellationToken)&#xA;    {&#xA;        await SomeOperationAsync(message, cancellationToken);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Use partials for topic subscriptions&lt;/h4&gt; &#xA;&lt;p&gt;To group topic subscriptions on class level you&#39;re able to define a subscription on a method as a partial. Subscriptions on the message queue will then be a combination of the topic defined on the class and the topic defined on the method. In the following example the &lt;code&gt;Create(..)&lt;/code&gt; function will be invoked when receiving a message on &lt;code&gt;customers.create&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;[CapSubscribe(&#34;customers&#34;)]&#xA;public class CustomersSubscriberService : ICapSubscribe&#xA;{&#xA;    [CapSubscribe(&#34;create&#34;, isPartial: true)]&#xA;    public void Create(Customer customer)&#xA;    {&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Subscribe Group&lt;/h4&gt; &#xA;&lt;p&gt;The concept of a subscription group is similar to that of a consumer group in Kafka. it is the same as the broadcast mode in the message queue, which is used to process the same message between multiple different microservice instances.&lt;/p&gt; &#xA;&lt;p&gt;When CAP startups, it will use the current assembly name as the default group name, if multiple same group subscribers subscribe to the same topic name, there is only one subscriber that can receive the message. Conversely, if subscribers are in different groups, they will all receive messages.&lt;/p&gt; &#xA;&lt;p&gt;In the same application, you can specify &lt;code&gt;Group&lt;/code&gt; property to keep subscriptions in different subscribe groups:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;&#xA;[CapSubscribe(&#34;xxx.services.show.time&#34;, Group = &#34;group1&#34; )]&#xA;public void ShowTime1(DateTime datetime)&#xA;{&#xA;}&#xA;&#xA;[CapSubscribe(&#34;xxx.services.show.time&#34;, Group = &#34;group2&#34;)]&#xA;public void ShowTime2(DateTime datetime)&#xA;{&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ShowTime1&lt;/code&gt; and &lt;code&gt;ShowTime2&lt;/code&gt; will be called one after another because all received messages are processed linear. You can change that behaviour to set &lt;code&gt;UseDispatchingPerGroup&lt;/code&gt; true.&lt;/p&gt; &#xA;&lt;p&gt;BTW, You can specify the default group name in the configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;services.AddCap(x =&amp;gt;&#xA;{&#xA;    x.DefaultGroup = &#34;default-group-name&#34;;  &#xA;});&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dashboard&lt;/h3&gt; &#xA;&lt;p&gt;CAP also provides dashboard pages, you can easily view messages that were sent and received. In addition, you can also view the message status in real time in the dashboard. Use the following command to install the Dashboard in your project.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP.Dashboard&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the distributed environment, the dashboard built-in integrates &lt;a href=&#34;http://consul.io&#34;&gt;Consul&lt;/a&gt; as a node discovery, while the realization of the gateway agent function, you can also easily view the node or other node data, It&#39;s like you are visiting local resources.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cap.dotnetcore.xyz/user-guide/en/monitoring/consul&#34;&gt;View Consul config docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If your service is deployed in Kubernetes, please use our Kubernetes discovery package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PM&amp;gt; Install-Package DotNetCore.CAP.Dashboard.K8s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cap.dotnetcore.xyz/user-guide/en/monitoring/kubernetes/&#34;&gt;View Kubernetes config docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The dashboard default address is: &lt;a href=&#34;http://localhost:xxx/cap&#34;&gt;http://localhost:xxx/cap&lt;/a&gt; , you can configure relative path &lt;code&gt;/cap&lt;/code&gt; with &lt;code&gt;x.UseDashboard(opt =&amp;gt;{ opt.MatchPath=&#34;/mycap&#34;; })&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;One of the easiest ways to contribute is to participate in discussions and discuss issues. You can also contribute by submitting pull requests with code changes.&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dotnetcore/CAP/raw/master/LICENSE.txt&#34;&gt;MIT&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NethermindEth/nethermind</title>
    <updated>2023-12-10T01:50:44Z</updated>
    <id>tag:github.com,2023-12-10:/NethermindEth/nethermind</id>
    <link href="https://github.com/NethermindEth/nethermind" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A robust execution client for Ethereum node operators.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://github.com/nethermindeth/nethermind/assets/337518/3e3b3c06-9cf3-4364-a774-158e649588cc&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://github.com/nethermindeth/nethermind/assets/337518/d1cc365c-6045-409f-a961-18d22ddb2535&#34;&gt; &#xA;  &lt;img alt=&#34;Nethermind&#34; src=&#34;https://github.com/nethermindeth/nethermind/assets/337518/d1cc365c-6045-409f-a961-18d22ddb2535&#34; height=&#34;64&#34;&gt; &#xA; &lt;/picture&gt; &lt;/p&gt; &#xA;&lt;h1&gt;Nethermind Ethereum client&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nethermindeth/nethermind/actions/workflows/nethermind-tests.yml&#34;&gt;&lt;img src=&#34;https://github.com/nethermindeth/nethermind/actions/workflows/nethermind-tests.yml/badge.svg?sanitize=true&#34; alt=&#34;Tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/GXJFaYk&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/629004402170134531?style=social&amp;amp;logo=discord&#34; alt=&#34;Chat on Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/nethermindeth&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/nethermindeth?style=social&amp;amp;label=Follow&#34; alt=&#34;Follow us on Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://community.nethermind.io/c/nethermind-client&#34;&gt;&lt;img src=&#34;https://img.shields.io/discourse/posts?style=social&amp;amp;label=Community&amp;amp;logo=discourse&amp;amp;server=https%3A%2F%2Fcommunity.nethermind.io&#34; alt=&#34;Ask on Discourse&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gitpoap.io/gh/NethermindEth/nethermind&#34;&gt;&lt;img src=&#34;https://public-api.gitpoap.io/v1/repo/NethermindEth/nethermind/badge&#34; alt=&#34;GitPOAPs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Nethermind is a high-performance, highly configurable Ethereum execution client built on .NET that runs on Linux, Windows, and macOS and supports Clique, Aura, and Ethash. With breakneck sync speeds and support for external plugins, it provides reliable access to rich on-chain data thanks to a high-performance JSON-RPC interface and node health monitoring with Grafana and Seq.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Nethermind documentation is available at &lt;a href=&#34;https://docs.nethermind.io&#34;&gt;docs.nethermind.io&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Supported networks&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Mainnet&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Goerli&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Sepolia&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Holesky&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Gnosis (xDai)&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Chiado&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Energy Web&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Volta&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Download and run&lt;/h2&gt; &#xA;&lt;p&gt;Release builds are available on the &lt;a href=&#34;https://github.com/nethermindeth/nethermind/releases&#34;&gt;Releases page&lt;/a&gt; and at &lt;a href=&#34;https://downloads.nethermind.io&#34;&gt;downloads.nethermind.io&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;On Linux&lt;/h3&gt; &#xA;&lt;h4&gt;Prerequisites&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h4&gt;Ubuntu / Debian&lt;/h4&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install libsnappy-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h4&gt;CentOS / Fedora&lt;/h4&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo dnf install -y snappy&#xA;sudo ln -s `find /usr/lib64/ -type f -name &#34;libbz2.so.1*&#34;` /usr/lib64/libbz2.so.1.0&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Install using PPA&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;sudo add-apt-repository ppa:nethermindeth/nethermind&lt;/code&gt; &lt;br&gt; If command not found: &lt;code&gt;sudo apt-get install software-properties-common&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sudo apt-get install nethermind&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nethermind -c mainnet&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;On Windows&lt;/h3&gt; &#xA;&lt;h4&gt;Prerequisites&lt;/h4&gt; &#xA;&lt;p&gt;In some cases, &lt;a href=&#34;https://aka.ms/vcredist&#34;&gt;Visual C++ Redistributable&lt;/a&gt; may need an update:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;winget install Microsoft.VCRedist.2015+.x64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install using Windows Package Manager&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;winget install nethermind&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nethermind -c mainnet&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;On macOS&lt;/h3&gt; &#xA;&lt;h4&gt;Install using Homebrew&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;brew tap nethermindeth/nethermind&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brew install nethermind&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nethermind -c mainnet&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Docker image&lt;/h2&gt; &#xA;&lt;p&gt;The official Docker images of Nethermind are available on &lt;a href=&#34;https://hub.docker.com/r/nethermind/nethermind&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Get the digest of the Docker image&lt;/h3&gt; &#xA;&lt;p&gt;In case of any Docker image need to be updated in the repository, you can update the digest of these images as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker inspect --format=&#39;{{index .RepoDigests 0}}&#39; &amp;lt;image_name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output should show the image digest, and then you can copy that to the &lt;code&gt;FROM&lt;/code&gt; tag in the Dockerfile.&lt;/p&gt; &#xA;&lt;h2&gt;Building from source&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://dotnet.microsoft.com/en-us/download&#34;&gt;.NET SDK&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Clone the repository&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone --recursive https://github.com/nethermindeth/nethermind.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build and run&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd nethermind/src/Nethermind/Nethermind.Runner&#xA;dotnet run -c release -- -c mainnet&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd nethermind/src/Nethermind&#xA;&#xA;# Run Nethermind tests:&#xA;dotnet test Nethermind.sln -c release&#xA;&#xA;# Run Ethereum Foundation tests:&#xA;dotnet test EthereumTests.sln -c release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;BEFORE you start work on a feature or fix, please read and follow our &lt;a href=&#34;https://github.com/nethermindeth/nethermind/raw/master/CONTRIBUTING.md&#34;&gt;contribution guide&lt;/a&gt; to help avoid any wasted or duplicate effort.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;If you believe you have found a security vulnerability in our code, please report it to us as described in our &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/nethermind/master/SECURITY.md&#34;&gt;security policy&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Nethermind is an open-source software licensed under the &lt;a href=&#34;https://github.com/nethermindeth/nethermind/raw/master/LICENSE-LGPL&#34;&gt;LGPL-3.0&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>builtbybel/Bloatynosy</title>
    <updated>2023-12-10T01:50:44Z</updated>
    <id>tag:github.com,2023-12-10:/builtbybel/Bloatynosy</id>
    <link href="https://github.com/builtbybel/Bloatynosy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The real Windows 11 Copilot&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Let&#39;s customize your Windows 11 experience with - Bloatynosy (Bloaty &amp;amp; nosy) -&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/builtbybel/Bloatynosy/raw/main/assets/bloatynosy.png?raw=true&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Universal Debloater and PC Manager for the most up-to-date version of the Redmond OS (Windows 11)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;h3&gt;GitHub (Recommended)&lt;/h3&gt; &#xA;&lt;p&gt;You can download Bloatynosy directly from the &lt;a href=&#34;https://github.com/builtbybel/Bloatynosy/releases&#34;&gt;GitHub releases page&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;The app is also distributed within &lt;a href=&#34;https://github.com/builtbybel/Bloatynosy/releases&#34;&gt;App Installer&lt;/a&gt; package.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Windows 11 has a gazillion toggles and settings options. And general users don’t know where to find most of these features, what to make of them, and which setting to enable or disable. &lt;strong&gt;Bloatynosy&lt;/strong&gt; streamlines and houses all the essential settings under one app and allows you to disable and remove unnecessary features with just a simple click.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Via the link in the lower right corner &lt;strong&gt;&#34;I want to set up Windows 11 for the first time&#34;&lt;/strong&gt;, you can call a &lt;strong&gt;Windows 11 Wizard&lt;/strong&gt; and customize your system step by step and debloat it.&lt;/li&gt; &#xA; &lt;li&gt;You can skip the assistant and let the app module on the main page handle the analysis entirely. It will check and fix a tons of unnecessary components and creating a debloated Windows 11.&lt;/li&gt; &#xA; &lt;li&gt;It features a &lt;strong&gt;Bloatpilot app&lt;/strong&gt;, which allows you to remove pre-installed apps automatically or the manual way.&lt;/li&gt; &#xA; &lt;li&gt;Next to this the app installer &lt;strong&gt;Packages&lt;/strong&gt; is integrated, which allows you to install some of the most important apps with a click and in bulk.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More infos here &lt;a href=&#34;https://www.builtbybel.com/apps/bloatynosy&#34;&gt;https://www.builtbybel.com/apps/bloatynosy&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Star History&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://star-history.com/#builtbybel/Bloatynosy&amp;amp;Timeline&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=builtbybel/Bloatynosy&amp;amp;type=Timeline&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>