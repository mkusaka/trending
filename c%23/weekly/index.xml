<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C# Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-06T01:39:21Z</updated>
  <subtitle>Weekly Trending of C# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Cysharp/ZLinq</title>
    <updated>2025-04-06T01:39:21Z</updated>
    <id>tag:github.com,2025-04-06:/Cysharp/ZLinq</id>
    <link href="https://github.com/Cysharp/ZLinq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Zero allocation LINQ with Span and LINQ to SIMD, LINQ to Tree (FileSystem, Json, GameObject, etc.) for all .NET platforms and Unity.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZLinq&lt;/h1&gt; &#xA;&lt;p&gt;Zero allocation LINQ with Span and LINQ to SIMD, LINQ to Tree (FileSystem, Json, GameObject, etc.) for all .NET platforms(netstandard2.0, 2.1, net8, net9) and Unity, Godot.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] This library is currently in preview. All methods have been implemented, but testing is not complete so operation is not guaranteed. The official release will be soon, but please wait until then for official use in production.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/Images/title_bench.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;var seq = source&#xA;    .AsValueEnumerable() // only add this line&#xA;    .Where(x =&amp;gt; x % 2 == 0)&#xA;    .Select(x =&amp;gt; x * 3);&#xA;&#xA;foreach (var item in seq) { }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;99% compatibility&lt;/strong&gt; with .NET 10&#39;s LINQ (including new &lt;code&gt;Shuffle&lt;/code&gt;, &lt;code&gt;RightJoin&lt;/code&gt;, &lt;code&gt;LeftJoin&lt;/code&gt; operators)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Zero allocation&lt;/strong&gt; for method chains through struct-based Enumerable via &lt;code&gt;ValueEnumerable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Full support for LINQ operations on &lt;strong&gt;Span&lt;/strong&gt; using .NET 9/C# 13&#39;s &lt;code&gt;allows ref struct&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;LINQ to Tree&lt;/strong&gt; to extend tree-structured objects (built-in support for FileSystem, JSON, GameObject)&lt;/li&gt; &#xA; &lt;li&gt;Automatic application of SIMD where possible and customizable &lt;strong&gt;LINQ to SIMD&lt;/strong&gt; for arbitrary operations&lt;/li&gt; &#xA; &lt;li&gt;Optional &lt;strong&gt;Drop-in replacement&lt;/strong&gt; Source Generator to automatically accelerate all LINQ methods&lt;/li&gt; &#xA; &lt;li&gt;Fusion of my past LINQ (&lt;a href=&#34;https://github.com/neuecc/linq.js/&#34;&gt;linq.js&lt;/a&gt;, &lt;a href=&#34;https://github.com/Cysharp/SimdLinq/&#34;&gt;SimdLinq&lt;/a&gt;, &lt;a href=&#34;https://github.com/neuecc/UniRx&#34;&gt;UniRx&lt;/a&gt;, &lt;a href=&#34;https://github.com/Cysharp/R3&#34;&gt;R3&lt;/a&gt;) and zero alloc (&lt;a href=&#34;https://github.com/Cysharp/ZString&#34;&gt;ZString&lt;/a&gt;, &lt;a href=&#34;https://github.com/Cysharp/ZLogger&#34;&gt;ZLogger&lt;/a&gt;) impls&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I aimed to create not just an experimental library but a practical one. It&#39;s also designed to handle high-load requirements, such as those found in games.&lt;/p&gt; &#xA;&lt;p&gt;You can install it from &lt;a href=&#34;https://www.nuget.org/packages/ZLinq&#34;&gt;NuGet/ZLinq&lt;/a&gt;. For Unity usage, refer to the &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#unity&#34;&gt;Unity section&lt;/a&gt;. For Godot usage, refer to the &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#godot&#34;&gt;Godot section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ZLinq chains internally use the following interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public readonly ref struct ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;(TEnumerator enumerator)&#xA;    where TEnumerator : struct, IValueEnumerator&amp;lt;T&amp;gt;, allows ref struct&#xA;{&#xA;    public readonly TEnumerator Enumerator = enumerator;&#xA;}&#xA;&#xA;public interface IValueEnumerator&amp;lt;T&amp;gt; : IDisposable&#xA;{&#xA;    bool TryGetNext(out T current); // as MoveNext + Current&#xA;&#xA;    // Optimization helper&#xA;    bool TryGetNonEnumeratedCount(out int count);&#xA;    bool TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span);&#xA;    bool TryCopyTo(Span&amp;lt;T&amp;gt; destination, Index offset);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Besides changing to a struct-based approach, we&#39;ve integrated MoveNext and Current to reduce the number of iterator calls. Also, since structs automatically copy internal state, we&#39;ve simplified the type complexity by unifying Enumerable and Enumerator(almost types only implements custom enumerator).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static ValueEnumerable&amp;lt;Where&amp;lt;TEnumerator, TSource&amp;gt;, TSource&amp;gt; Where&amp;lt;TEnumerator, TSource&amp;gt;(in this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Func&amp;lt;TSource, Boolean&amp;gt; predicate)&#xA;    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Operators have this method signature. C# cannot infer types from generic constraints(&lt;a href=&#34;https://github.com/dotnet/csharplang/discussions/6930&#34;&gt;dotnet/csharplang#6930&lt;/a&gt;). Therefore, the traditional Struct LINQ approach required implementing all operator combinations as instance methods, resulting in &lt;a href=&#34;https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/&#34;&gt;100,000+ methods and massive assembly sizes&lt;/a&gt;. However, in ZLinq, we&#39;ve successfully avoided all the boilerplate method implementations by devising an approach that properly conveys types to C# compiler.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, &lt;code&gt;TryGetNonEnumeratedCount(out int count)&lt;/code&gt;, &lt;code&gt;TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span)&lt;/code&gt;, and &lt;code&gt;TryCopyTo(Span&amp;lt;T&amp;gt; destination)&lt;/code&gt; defined in the interface itself enable flexible optimizations. For example, Take+Skip can be expressed entirely as Span slices, so if the original source can be converted to a Span, Span slices are passed through TryGetSpan chains. For ToArray, if the sequence length can be calculated, a fixed-length array is prepared in advance, and operators that can write directly to the final array via TryCopyTo will do so. Some methods automatically use SIMD-based optimization if a Span can be obtained.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;code&gt;using ZLinq;&lt;/code&gt; and call &lt;code&gt;AsValueEnumerable()&lt;/code&gt; on any iterable type to use ZLinq&#39;s zero-allocation LINQ. Also, &lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;Repeat&lt;/code&gt;, and &lt;code&gt;Empty&lt;/code&gt; are defined in &lt;code&gt;ValueEnumerable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;var source = new int[] { 1, 2, 3, 4, 5 };&#xA;&#xA;// Call AsValueEnumerable to apply ZLinq&#xA;var seq1 = source.AsValueEnumerable().Where(x =&amp;gt; x % 2 == 0);&#xA;&#xA;// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)&#xA;Span&amp;lt;int&amp;gt; span = stackalloc int[5] { 1, 2, 3, 4, 5 };&#xA;var seq2 = span.AsValueEnumerable().Select(x =&amp;gt; x * x);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Drop-in replacement&lt;/h2&gt; &#xA;&lt;p&gt;When introducing &lt;code&gt;ZLinq.DropInGenerator&lt;/code&gt;, you can automatically use ZLinq for all LINQ methods without calling &lt;code&gt;AsValueEnumerable()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.DropInGenerator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/Images/dropin.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It works by using a Source Generator to add extension methods for each type that take priority, making &lt;code&gt;ZLinq&lt;/code&gt; methods be selected instead of System.Linq when the same name and arguments are used. After installing the package, you need to configure it with an assembly attribute.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: ZLinq.ZLinqDropInAttribute(&#34;ZLinq.DropIn&#34;, ZLinq.DropInGenerateTypes.Array)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;generateNamespace&lt;/code&gt; is the namespace for the generated code, and &lt;code&gt;DropInGenerateTypes&lt;/code&gt; selects the target types. &lt;code&gt;DropInGenerateTypes&lt;/code&gt; allows you to choose from &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Span&lt;/code&gt; (Span/ReadOnlySpan), &lt;code&gt;Memory&lt;/code&gt; (Memory/ReadOnlyMemory), &lt;code&gt;List&lt;/code&gt;, and &lt;code&gt;Enumerable&lt;/code&gt; (IEnumerable). These are Flags, so you can combine them, such as &lt;code&gt;DropInGenerateTypes.Array | DropInGenerateTypes.Span&lt;/code&gt;. There are also predefined combinations: &lt;code&gt;Collection = Array | Span | Memory | List&lt;/code&gt; and &lt;code&gt;Everything = Array | Span | Memory | List | Enumerable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can enable it for all files by global using the generated namespace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;global using ZLinq.Dropin;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;DropInGenerateTypes.Enumerable&lt;/code&gt;, which generates extension methods for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, you need to make &lt;code&gt;generateNamespace&lt;/code&gt; global as a namespace priority. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: ZLinq.ZLinqDropInAttribute(&#34;&#34;, ZLinq.DropInGenerateTypes.Everything)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the most aggressive configuration, causing all LINQ methods to be processed by ZLinq, and making it impossible to use normal LINQ methods (if Enumerable is not included, you can call AsEnumerable() to execute with System.Linq).&lt;/p&gt; &#xA;&lt;p&gt;While ZLinq offers superior performance, there are some differences from System.Linq. For instance, be aware that you cannot store it in fields or pass it as method arguments. For example, you cannot pass LINQ operations to &lt;code&gt;string.Join&lt;/code&gt;. In such cases, you need to use &lt;code&gt;ToArray&lt;/code&gt; (if you want to minimize allocations, you can use &lt;code&gt;ToArrayPool&lt;/code&gt; and return it to the Pool after the Join operation). However case of &lt;code&gt;string.Join&lt;/code&gt;, ZLinq has &lt;code&gt;JoinToString&lt;/code&gt; operator so you can use it instead.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;I recommend considering &lt;code&gt;Everything&lt;/code&gt; to have too strong of side effects, so it would be better to try using namespaces and &lt;code&gt;DropInGenerateTypes.Collection&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Other options for &lt;code&gt;ZLinqDropInAttribute&lt;/code&gt; include &lt;code&gt;GenerateAsPublic&lt;/code&gt;, &lt;code&gt;ConditionalCompilationSymbols&lt;/code&gt;, and &lt;code&gt;DisableEmitSource&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;LINQ to Tree&lt;/h2&gt; &#xA;&lt;p&gt;LINQ to XML introduced the concept of querying around axes to C#. Even if you don&#39;t use XML, similar APIs are incorporated into Roslyn and effectively used for exploring SyntaxTrees. ZLinq extends this concept to make it applicable to anything that can be considered a Tree, allowing &lt;code&gt;Ancestors&lt;/code&gt;, &lt;code&gt;Children&lt;/code&gt;, &lt;code&gt;Descendants&lt;/code&gt;, &lt;code&gt;BeforeSelf&lt;/code&gt;, and &lt;code&gt;AfterSelf&lt;/code&gt; to be applied.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/Images/axis.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Specifically, by defining a struct that implements the following interface, it becomes iterable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface ITraverser&amp;lt;TTraverser, T&amp;gt; : IDisposable&#xA;    where TTraverser : struct, ITraverser&amp;lt;TTraverser, T&amp;gt; // self&#xA;{&#xA;    T Origin { get; }&#xA;    TTraverser ConvertToTraverser(T next); // for Descendants&#xA;    bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants&#xA;    bool TryGetChildCount(out int count);   // optional: optimize use for Children&#xA;    bool TryGetParent(out T parent); // for Ancestors&#xA;    bool TryGetNextChild(out T child); // for Children | Descendants&#xA;    bool TryGetNextSibling(out T next); // for AfterSelf&#xA;    bool TryGetPreviousSibling(out T previous); // BeforeSelf&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Standard packages are available for FileSystemInfo and JsonNode. For Unity, it&#39;s applicable to GameObject and Transform.&lt;/p&gt; &#xA;&lt;h3&gt;FileSystem&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.FileSystem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;var root = new DirectoryInfo(&#34;C:\\Program Files (x86)\\Steam&#34;);&#xA;&#xA;// FileSystemInfo(FileInfo/DirectoryInfo) can call `Ancestors`, `Children`, `Descendants`, `BeforeSelf`, `AfterSelf`&#xA;var allDlls = root&#xA;    .Descendants()&#xA;    .OfType&amp;lt;FileInfo&amp;gt;()&#xA;    .Where(x =&amp;gt; x.Extension == &#34;.dll&#34;);&#xA;&#xA;var grouped = allDlls&#xA;    .GroupBy(x =&amp;gt; x.Name)&#xA;    .Select(x =&amp;gt; new { FileName = x.Key, Count = x.Count() })&#xA;    .OrderByDescending(x =&amp;gt; x.Count);&#xA;&#xA;foreach (var item in grouped)&#xA;{&#xA;    Console.WriteLine(item);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JSON(System.Text.Json)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.Json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;// System.Text.Json&#39;s JsonNode is the target of LINQ to JSON(not JsonDocument/JsonElement).&#xA;var json = JsonNode.Parse(&#34;&#34;&#34;&#xA;{&#xA;    &#34;nesting&#34;: {&#xA;      &#34;level1&#34;: {&#xA;        &#34;description&#34;: &#34;First level of nesting&#34;,&#xA;        &#34;value&#34;: 100,&#xA;        &#34;level2&#34;: {&#xA;          &#34;description&#34;: &#34;Second level of nesting&#34;,&#xA;          &#34;flags&#34;: [true, false, true],&#xA;          &#34;level3&#34;: {&#xA;            &#34;description&#34;: &#34;Third level of nesting&#34;,&#xA;            &#34;coordinates&#34;: {&#xA;              &#34;x&#34;: 10.5,&#xA;              &#34;y&#34;: 20.75,&#xA;              &#34;z&#34;: -5.0&#xA;            },&#xA;            &#34;level4&#34;: {&#xA;              &#34;description&#34;: &#34;Fourth level of nesting&#34;,&#xA;              &#34;metadata&#34;: {&#xA;                &#34;created&#34;: &#34;2025-02-15T14:30:00Z&#34;,&#xA;                &#34;modified&#34;: null,&#xA;                &#34;version&#34;: 2.1&#xA;              },&#xA;              &#34;level5&#34;: {&#xA;                &#34;description&#34;: &#34;Fifth level of nesting&#34;,&#xA;                &#34;settings&#34;: {&#xA;                  &#34;enabled&#34;: true,&#xA;                  &#34;threshold&#34;: 0.85,&#xA;                  &#34;options&#34;: [&#34;fast&#34;, &#34;accurate&#34;, &#34;balanced&#34;],&#xA;                  &#34;config&#34;: {&#xA;                    &#34;timeout&#34;: 30000,&#xA;                    &#34;retries&#34;: 3,&#xA;                    &#34;deepSetting&#34;: {&#xA;                      &#34;algorithm&#34;: &#34;advanced&#34;,&#xA;                      &#34;parameters&#34;: [1, 1, 2, 3, 5, 8, 13]&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;}&#xA;&#34;&#34;&#34;);&#xA;&#xA;// JsonNode&#xA;var origin = json![&#34;nesting&#34;]![&#34;level1&#34;]![&#34;level2&#34;]!;&#xA;&#xA;// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self.&#xA;foreach (var item in origin.Descendants().Select(x =&amp;gt; x.Node).OfType&amp;lt;JsoArray&amp;gt;())&#xA;{&#xA;    // [true, false, true], [&#34;fast&#34;, &#34;accurate&#34;, &#34;balanced&#34;], [1, 1, 2, 3, 5, 8, 13]&#xA;    Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GameObject/Transform(Unity)&lt;/h3&gt; &#xA;&lt;p&gt;see: &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#unity&#34;&gt;unity&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;LINQ to SIMD&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;.AsVectorizable()&lt;/code&gt; from &lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Unity&lt;/h2&gt; &#xA;&lt;p&gt;The minimum supported Unity version will be &lt;code&gt;2022.3.12f1&lt;/code&gt;, as it is necessary to support C# Incremental Source Generator(Compiler Version, 4.3.0).&lt;/p&gt; &#xA;&lt;p&gt;There are two installation steps required to use it in Unity.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;code&gt;ZLinq&lt;/code&gt; from NuGet using &lt;a href=&#34;https://github.com/GlitchEnzo/NuGetForUnity&#34;&gt;NuGetForUnity&lt;/a&gt;&lt;br&gt; Open Window from NuGet -&amp;gt; Manage NuGet Packages, Search &#34;ZLinq&#34; and Press Install.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the &lt;code&gt;ZLinq.Unity&lt;/code&gt; package by referencing the git URL&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://github.com/Cysharp/ZLinq.git?path=src/ZLinq.Unity/Assets/ZLinq.Unity&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the help of the Unity package, in addition to the standard ZLinq, LINQ to GameObject functionality becomes available for exploring GameObject/Transform.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/Images/axis.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;public class SampleScript : MonoBehaviour&#xA;{&#xA;    public Transform Origin;&#xA;&#xA;    void Start()&#xA;    {&#xA;        Debug.Log(&#34;Ancestors--------------&#34;);  // Container, Root&#xA;        foreach (var item in Origin.Ancestors()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;Children--------------&#34;); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B&#xA;        foreach (var item in Origin.Children()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;Descendants--------------&#34;); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B&#xA;        foreach (var item in Origin.Descendants()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;BeforeSelf--------------&#34;); // C1, C2&#xA;        foreach (var item in Origin.BeforeSelf()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;AfterSelf--------------&#34;);  // C3, C4&#xA;        foreach (var item in Origin.AfterSelf()) Debug.Log(item.name);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can chain query(LINQ to Objects). Also, you can filter by component using the &lt;code&gt;OfComponent&amp;lt;T&amp;gt;&lt;/code&gt; helper.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// all filtered(tag == &#34;foobar&#34;) objects&#xA;var foobars = root.Descendants().Where(x =&amp;gt; x.tag == &#34;foobar&#34;);&#xA;&#xA;// get FooScript under self childer objects and self&#xA;var fooScripts = root.ChildrenAndSelf().OfComponent&amp;lt;FooScript&amp;gt;(); &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In .NET 9, &lt;code&gt;ValueEnumerable&lt;/code&gt; is a &lt;code&gt;ref struct&lt;/code&gt;, so it cannot be converted to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;. However, in Unity it&#39;s a regular &lt;code&gt;struct&lt;/code&gt;, making it possible to convert to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;. You can improve interoperability by preparing an extension method like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class ZLinqExtensions&#xA;{&#xA;    public static IEnumerable&amp;lt;T&amp;gt; AsEnumerable&amp;lt;TEnumerator, T&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, T&amp;gt; valueEnumerable)&#xA;        where TEnumerator : struct, IValueEnumerator&amp;lt;T&amp;gt;&#xA;    {&#xA;        using (var e = valueEnumerable.Enumerator)&#xA;        {&#xA;            while (e.TryGetNext(out var current))&#xA;            {&#xA;                yield return current;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Godot&lt;/h2&gt; &#xA;&lt;p&gt;The minimum supported Godot version will be &lt;code&gt;4.0.0&lt;/code&gt;. You can install ZLinq.Godot package via NuGet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.Godot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to the standard ZLinq, LINQ to Node functionality is available.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/Images/godot.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Godot;&#xA;using ZLinq;&#xA;&#xA;public partial class SampleScript : Node2D&#xA;{&#xA;    public override void _Ready()&#xA;    {&#xA;        var origin = GetNode&amp;lt;Node2D&amp;gt;(&#34;Container/Origin&#34;);&#xA;&#xA;        GD.Print(&#34;Ancestors--------------&#34;); // Container, Root, root (Root Window)&#xA;        foreach (var item in origin.Ancestors()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;Children--------------&#34;); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B&#xA;        foreach (var item in origin.Children()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;Descendants--------------&#34;); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B&#xA;        foreach (var item in origin.Descendants()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;BeforeSelf--------------&#34;); // C1, C2&#xA;        foreach (var item in origin.BeforeSelf()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;AfterSelf--------------&#34;); // C3, C4&#xA;        foreach (var item in origin.AfterSelf()) GD.Print(item.Name);&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can chain query(LINQ to Objects). Also, you can filter by node type using the &lt;code&gt;OfType()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// get ancestors under a Window&#xA;var ancestors = root.Ancestors().TakeWhile(x =&amp;gt; x is not Window);&#xA;// get FooScript under self childer objects and self&#xA;var fooScripts = root.ChildrenAndSelf().OfType(default(FooScript));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;p&gt;Since the preview version release, we have received multiple ideas for fundamental interface revisions leading to performance improvements from &lt;a href=&#34;https://github.com/Akeit0&#34;&gt;@Akeit0&lt;/a&gt;, and test and benchmark infrastructure from &lt;a href=&#34;https://github.com/filzrev&#34;&gt;@filzrev&lt;/a&gt;. We are grateful for their many contributions.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is under MIT License.&lt;/p&gt;</summary>
  </entry>
</feed>