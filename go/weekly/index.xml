<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-16T01:55:19Z</updated>
  <subtitle>Weekly Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>deweizhu/bookget</title>
    <updated>2023-07-16T01:55:19Z</updated>
    <id>tag:github.com,2023-07-16:/deweizhu/bookget</id>
    <link href="https://github.com/deweizhu/bookget" rel="alternate"></link>
    <summary type="html">&lt;p&gt;bookget 数字古籍图书下载工具&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bookget&lt;/h1&gt; &#xA;&lt;p&gt;bookget 数字图书馆下载工具，目前支持约50+个数字图书馆。&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;[必读]使用手册wiki &lt;a href=&#34;https://github.com/deweizhu/bookget/wiki&#34;&gt;https://github.com/deweizhu/bookget/wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;此项目代码仅供学习研究使用，欢迎有能力的朋友git clone 代码二次开发维护您自己的版本。&lt;/li&gt; &#xA; &lt;li&gt;请诸位养成保持下载最新代码的习惯，此项目随时可能中止并关闭。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;p&gt;特别推荐： &lt;a href=&#34;https://new.shuge.org/&#34;&gt;书格&lt;/a&gt; 有品格的数字古籍图书馆&lt;br&gt; &lt;img src=&#34;https://new.shuge.org/wp-content/themes/artview/images/layout/logo.png&#34; alt=&#34;书格&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>aws/karpenter</title>
    <updated>2023-07-16T01:55:19Z</updated>
    <id>tag:github.com,2023-07-16:/aws/karpenter</id>
    <link href="https://github.com/aws/karpenter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Karpenter is a Kubernetes Node Autoscaler built for flexibility, performance, and simplicity.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/aws/karpenter/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://github.com/aws/karpenter/actions/workflows/ci.yaml/badge.svg?branch=main&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/stars/aws/karpenter&#34; alt=&#34;GitHub stars&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/forks/aws/karpenter&#34; alt=&#34;GitHub forks&#34;&gt; &lt;a href=&#34;https://github.com/aws/karpenter/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-ff69b4.svg?sanitize=true&#34; alt=&#34;GitHub License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/aws/karpenter&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/aws/karpenter&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/aws/karpenter?branch=main&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/aws/karpenter/badge.svg?branch=main&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/aws/karpenter/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat&#34; alt=&#34;contributions welcome&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aws/karpenter/main/website/static/banner.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Karpenter is an open-source node provisioning project built for Kubernetes. Karpenter improves the efficiency and cost of running workloads on Kubernetes clusters by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Watching&lt;/strong&gt; for pods that the Kubernetes scheduler has marked as unschedulable&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Evaluating&lt;/strong&gt; scheduling constraints (resource requests, nodeselectors, affinities, tolerations, and topology spread constraints) requested by the pods&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Provisioning&lt;/strong&gt; nodes that meet the requirements of the pods&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Removing&lt;/strong&gt; the nodes when the nodes are no longer needed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Come discuss Karpenter in the &lt;a href=&#34;https://kubernetes.slack.com/archives/C02SFFZSA2K&#34;&gt;#karpenter&lt;/a&gt; channel in the &lt;a href=&#34;https://slack.k8s.io/&#34;&gt;Kubernetes slack&lt;/a&gt; or join the &lt;a href=&#34;https://karpenter.sh/docs/contributing/working-group/&#34;&gt;Karpenter working group&lt;/a&gt; bi-weekly calls.&lt;/p&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://karpenter.sh/&#34;&gt;Docs&lt;/a&gt; to learn more.&lt;/p&gt; &#xA;&lt;h2&gt;Talks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;09/08/2022 &lt;a href=&#34;https://youtu.be/BnksdJ3oOEs&#34;&gt;Workload Consolidation with Karpenter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;05/19/2022 &lt;a href=&#34;https://www.youtube.com/watch?v=UBb8wbfSc34&#34;&gt;Scaling K8s Nodes Without Breaking the Bank or Your Sanity&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;03/25/2022 &lt;a href=&#34;https://youtu.be/sxDtmzbNHwE?t=3931&#34;&gt;Karpenter @ AWS Community Day 2022&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;12/20/2021 &lt;a href=&#34;https://youtu.be/C-2v7HT-uSA&#34;&gt;How To Auto-Scale Kubernetes Clusters With Karpenter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;11/30/2021 &lt;a href=&#34;https://youtu.be/3QsVRHVdOnM&#34;&gt;Karpenter vs Kubernetes Cluster Autoscaler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;11/19/2021 &lt;a href=&#34;https://youtu.be/qxWJRUF6JJc&#34;&gt;Karpenter @ Container Day&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;05/14/2021 &lt;a href=&#34;https://www.youtube.com/watch?v=43g8uPohTgc&#34;&gt;Groupless Autoscaling with Karpenter @ Kubecon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;05/04/2021 &lt;a href=&#34;https://youtu.be/MZ-4HzOC_ac?t=7137&#34;&gt;Karpenter @ Container Day&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>hibiken/asynq</title>
    <updated>2023-07-16T01:55:19Z</updated>
    <id>tag:github.com,2023-07-16:/hibiken/asynq</id>
    <link href="https://github.com/hibiken/asynq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, reliable, and efficient distributed task queue in Go&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/11155743/114697792-ffbfa580-9d26-11eb-8e5b-33bef69476dc.png&#34; alt=&#34;Asynq logo&#34; width=&#34;360px&#34;&gt; &#xA;&lt;h1&gt;Simple, reliable &amp;amp; efficient distributed task queue in Go&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/hibiken/asynq&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/hibiken/asynq?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/hibiken/asynq&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/hibiken/asynq&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/hibiken/asynq/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-green.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/go-asynq/community&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/go-asynq/gitter.svg?sanitize=true&#34; alt=&#34;Gitter chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Asynq is a Go library for queueing tasks and processing them asynchronously with workers. It&#39;s backed by &lt;a href=&#34;https://redis.io/&#34;&gt;Redis&lt;/a&gt; and is designed to be scalable yet easy to get started.&lt;/p&gt; &#xA;&lt;p&gt;Highlevel overview of how Asynq works:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Client puts tasks on a queue&lt;/li&gt; &#xA; &lt;li&gt;Server pulls tasks off queues and starts a worker goroutine for each task&lt;/li&gt; &#xA; &lt;li&gt;Tasks are processed concurrently by multiple workers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Task queues are used as a mechanism to distribute work across multiple machines. A system can consist of multiple worker servers and brokers, giving way to high availability and horizontal scaling.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example use case&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/11155743/116358505-656f5f80-a806-11eb-9c16-94e49dab0f99.jpg&#34; alt=&#34;Task Queue Diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Guaranteed &lt;a href=&#34;https://www.cloudcomputingpatterns.org/at_least_once_delivery/&#34;&gt;at least one execution&lt;/a&gt; of a task&lt;/li&gt; &#xA; &lt;li&gt;Scheduling of tasks&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Task-Retry&#34;&gt;Retries&lt;/a&gt; of failed tasks&lt;/li&gt; &#xA; &lt;li&gt;Automatic recovery of tasks in the event of a worker crash&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Queue-Priority#weighted-priority&#34;&gt;Weighted priority queues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Queue-Priority#strict-priority&#34;&gt;Strict priority queues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Low latency to add a task since writes are fast in Redis&lt;/li&gt; &#xA; &lt;li&gt;De-duplication of tasks using &lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Unique-Tasks&#34;&gt;unique option&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Allow &lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Task-Timeout-and-Cancelation&#34;&gt;timeout and deadline per task&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Allow &lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Task-aggregation&#34;&gt;aggregating group of tasks&lt;/a&gt; to batch multiple successive operations&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Handler-Deep-Dive&#34;&gt;Flexible handler interface with support for middlewares&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hibiken/asynq/master/tools/asynq/README.md#pause&#34;&gt;Ability to pause queue&lt;/a&gt; to stop processing tasks from the queue&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Periodic-Tasks&#34;&gt;Periodic Tasks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Redis-Cluster&#34;&gt;Support Redis Cluster&lt;/a&gt; for automatic sharding and high availability&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Automatic-Failover&#34;&gt;Support Redis Sentinels&lt;/a&gt; for high availability&lt;/li&gt; &#xA; &lt;li&gt;Integration with &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt; to collect and visualize queue metrics&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hibiken/asynq/master/#web-ui&#34;&gt;Web UI&lt;/a&gt; to inspect and remote-control queues and tasks&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hibiken/asynq/master/#command-line-tool&#34;&gt;CLI&lt;/a&gt; to inspect and remote-control queues and tasks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Stability and Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Status&lt;/strong&gt;: The library is currently undergoing &lt;strong&gt;heavy development&lt;/strong&gt; with frequent, breaking API changes.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;☝️ &lt;strong&gt;Important Note&lt;/strong&gt;: Current major version is zero (&lt;code&gt;v0.x.x&lt;/code&gt;) to accommodate rapid development and fast iteration while getting early feedback from users (&lt;em&gt;feedback on APIs are appreciated!&lt;/em&gt;). The public API could change without a major version update before &lt;code&gt;v1.0.0&lt;/code&gt; release.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Sponsoring&lt;/h2&gt; &#xA;&lt;p&gt;If you are using this package in production, &lt;strong&gt;please consider sponsoring the project to show your support!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Make sure you have Go installed (&lt;a href=&#34;https://golang.org/dl/&#34;&gt;download&lt;/a&gt;). Version &lt;code&gt;1.14&lt;/code&gt; or higher is required.&lt;/p&gt; &#xA;&lt;p&gt;Initialize your project by creating a folder and then running &lt;code&gt;go mod init github.com/your/repo&lt;/code&gt; (&lt;a href=&#34;https://blog.golang.org/using-go-modules&#34;&gt;learn more&lt;/a&gt;) inside the folder. Then install Asynq library with the &lt;a href=&#34;https://golang.org/cmd/go/#hdr-Add_dependencies_to_current_module_and_install_them&#34;&gt;&lt;code&gt;go get&lt;/code&gt;&lt;/a&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get -u github.com/hibiken/asynq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure you&#39;re running a Redis server locally or from a &lt;a href=&#34;https://hub.docker.com/_/redis&#34;&gt;Docker&lt;/a&gt; container. Version &lt;code&gt;4.0&lt;/code&gt; or higher is required.&lt;/p&gt; &#xA;&lt;p&gt;Next, write a package that encapsulates task creation and task handling.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package tasks&#xA;&#xA;import (&#xA;    &#34;context&#34;&#xA;    &#34;encoding/json&#34;&#xA;    &#34;fmt&#34;&#xA;    &#34;log&#34;&#xA;    &#34;time&#34;&#xA;    &#34;github.com/hibiken/asynq&#34;&#xA;)&#xA;&#xA;// A list of task types.&#xA;const (&#xA;    TypeEmailDelivery   = &#34;email:deliver&#34;&#xA;    TypeImageResize     = &#34;image:resize&#34;&#xA;)&#xA;&#xA;type EmailDeliveryPayload struct {&#xA;    UserID     int&#xA;    TemplateID string&#xA;}&#xA;&#xA;type ImageResizePayload struct {&#xA;    SourceURL string&#xA;}&#xA;&#xA;//----------------------------------------------&#xA;// Write a function NewXXXTask to create a task.&#xA;// A task consists of a type and a payload.&#xA;//----------------------------------------------&#xA;&#xA;func NewEmailDeliveryTask(userID int, tmplID string) (*asynq.Task, error) {&#xA;    payload, err := json.Marshal(EmailDeliveryPayload{UserID: userID, TemplateID: tmplID})&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return asynq.NewTask(TypeEmailDelivery, payload), nil&#xA;}&#xA;&#xA;func NewImageResizeTask(src string) (*asynq.Task, error) {&#xA;    payload, err := json.Marshal(ImageResizePayload{SourceURL: src})&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    // task options can be passed to NewTask, which can be overridden at enqueue time.&#xA;    return asynq.NewTask(TypeImageResize, payload, asynq.MaxRetry(5), asynq.Timeout(20 * time.Minute)), nil&#xA;}&#xA;&#xA;//---------------------------------------------------------------&#xA;// Write a function HandleXXXTask to handle the input task.&#xA;// Note that it satisfies the asynq.HandlerFunc interface.&#xA;//&#xA;// Handler doesn&#39;t need to be a function. You can define a type&#xA;// that satisfies asynq.Handler interface. See examples below.&#xA;//---------------------------------------------------------------&#xA;&#xA;func HandleEmailDeliveryTask(ctx context.Context, t *asynq.Task) error {&#xA;    var p EmailDeliveryPayload&#xA;    if err := json.Unmarshal(t.Payload(), &amp;amp;p); err != nil {&#xA;        return fmt.Errorf(&#34;json.Unmarshal failed: %v: %w&#34;, err, asynq.SkipRetry)&#xA;    }&#xA;    log.Printf(&#34;Sending Email to User: user_id=%d, template_id=%s&#34;, p.UserID, p.TemplateID)&#xA;    // Email delivery code ...&#xA;    return nil&#xA;}&#xA;&#xA;// ImageProcessor implements asynq.Handler interface.&#xA;type ImageProcessor struct {&#xA;    // ... fields for struct&#xA;}&#xA;&#xA;func (processor *ImageProcessor) ProcessTask(ctx context.Context, t *asynq.Task) error {&#xA;    var p ImageResizePayload&#xA;    if err := json.Unmarshal(t.Payload(), &amp;amp;p); err != nil {&#xA;        return fmt.Errorf(&#34;json.Unmarshal failed: %v: %w&#34;, err, asynq.SkipRetry)&#xA;    }&#xA;    log.Printf(&#34;Resizing image: src=%s&#34;, p.SourceURL)&#xA;    // Image resizing code ...&#xA;    return nil&#xA;}&#xA;&#xA;func NewImageProcessor() *ImageProcessor {&#xA;&#x9;return &amp;amp;ImageProcessor{}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your application code, import the above package and use &lt;a href=&#34;https://pkg.go.dev/github.com/hibiken/asynq?tab=doc#Client&#34;&gt;&lt;code&gt;Client&lt;/code&gt;&lt;/a&gt; to put tasks on queues.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;    &#34;log&#34;&#xA;    &#34;time&#34;&#xA;&#xA;    &#34;github.com/hibiken/asynq&#34;&#xA;    &#34;your/app/package/tasks&#34;&#xA;)&#xA;&#xA;const redisAddr = &#34;127.0.0.1:6379&#34;&#xA;&#xA;func main() {&#xA;    client := asynq.NewClient(asynq.RedisClientOpt{Addr: redisAddr})&#xA;    defer client.Close()&#xA;&#xA;    // ------------------------------------------------------&#xA;    // Example 1: Enqueue task to be processed immediately.&#xA;    //            Use (*Client).Enqueue method.&#xA;    // ------------------------------------------------------&#xA;&#xA;    task, err := tasks.NewEmailDeliveryTask(42, &#34;some:template:id&#34;)&#xA;    if err != nil {&#xA;        log.Fatalf(&#34;could not create task: %v&#34;, err)&#xA;    }&#xA;    info, err := client.Enqueue(task)&#xA;    if err != nil {&#xA;        log.Fatalf(&#34;could not enqueue task: %v&#34;, err)&#xA;    }&#xA;    log.Printf(&#34;enqueued task: id=%s queue=%s&#34;, info.ID, info.Queue)&#xA;&#xA;&#xA;    // ------------------------------------------------------------&#xA;    // Example 2: Schedule task to be processed in the future.&#xA;    //            Use ProcessIn or ProcessAt option.&#xA;    // ------------------------------------------------------------&#xA;&#xA;    info, err = client.Enqueue(task, asynq.ProcessIn(24*time.Hour))&#xA;    if err != nil {&#xA;        log.Fatalf(&#34;could not schedule task: %v&#34;, err)&#xA;    }&#xA;    log.Printf(&#34;enqueued task: id=%s queue=%s&#34;, info.ID, info.Queue)&#xA;&#xA;&#xA;    // ----------------------------------------------------------------------------&#xA;    // Example 3: Set other options to tune task processing behavior.&#xA;    //            Options include MaxRetry, Queue, Timeout, Deadline, Unique etc.&#xA;    // ----------------------------------------------------------------------------&#xA;&#xA;    task, err = tasks.NewImageResizeTask(&#34;https://example.com/myassets/image.jpg&#34;)&#xA;    if err != nil {&#xA;        log.Fatalf(&#34;could not create task: %v&#34;, err)&#xA;    }&#xA;    info, err = client.Enqueue(task, asynq.MaxRetry(10), asynq.Timeout(3 * time.Minute))&#xA;    if err != nil {&#xA;        log.Fatalf(&#34;could not enqueue task: %v&#34;, err)&#xA;    }&#xA;    log.Printf(&#34;enqueued task: id=%s queue=%s&#34;, info.ID, info.Queue)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, start a worker server to process these tasks in the background. To start the background workers, use &lt;a href=&#34;https://pkg.go.dev/github.com/hibiken/asynq?tab=doc#Server&#34;&gt;&lt;code&gt;Server&lt;/code&gt;&lt;/a&gt; and provide your &lt;a href=&#34;https://pkg.go.dev/github.com/hibiken/asynq?tab=doc#Handler&#34;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt; to process the tasks.&lt;/p&gt; &#xA;&lt;p&gt;You can optionally use &lt;a href=&#34;https://pkg.go.dev/github.com/hibiken/asynq?tab=doc#ServeMux&#34;&gt;&lt;code&gt;ServeMux&lt;/code&gt;&lt;/a&gt; to create a handler, just as you would with &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; Handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;    &#34;log&#34;&#xA;&#xA;    &#34;github.com/hibiken/asynq&#34;&#xA;    &#34;your/app/package/tasks&#34;&#xA;)&#xA;&#xA;const redisAddr = &#34;127.0.0.1:6379&#34;&#xA;&#xA;func main() {&#xA;    srv := asynq.NewServer(&#xA;        asynq.RedisClientOpt{Addr: redisAddr},&#xA;        asynq.Config{&#xA;            // Specify how many concurrent workers to use&#xA;            Concurrency: 10,&#xA;            // Optionally specify multiple queues with different priority.&#xA;            Queues: map[string]int{&#xA;                &#34;critical&#34;: 6,&#xA;                &#34;default&#34;:  3,&#xA;                &#34;low&#34;:      1,&#xA;            },&#xA;            // See the godoc for other configuration options&#xA;        },&#xA;    )&#xA;&#xA;    // mux maps a type to a handler&#xA;    mux := asynq.NewServeMux()&#xA;    mux.HandleFunc(tasks.TypeEmailDelivery, tasks.HandleEmailDeliveryTask)&#xA;    mux.Handle(tasks.TypeImageResize, tasks.NewImageProcessor())&#xA;    // ...register other handlers...&#xA;&#xA;    if err := srv.Run(mux); err != nil {&#xA;        log.Fatalf(&#34;could not run server: %v&#34;, err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a more detailed walk-through of the library, see our &lt;a href=&#34;https://github.com/hibiken/asynq/wiki/Getting-Started&#34;&gt;Getting Started&lt;/a&gt; guide.&lt;/p&gt; &#xA;&lt;p&gt;To learn more about &lt;code&gt;asynq&lt;/code&gt; features and APIs, see the package &lt;a href=&#34;https://godoc.org/github.com/hibiken/asynq&#34;&gt;godoc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Web UI&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hibiken/asynqmon&#34;&gt;Asynqmon&lt;/a&gt; is a web based tool for monitoring and administrating Asynq queues and tasks.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a few screenshots of the Web UI:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Queues view&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/11155743/114697016-07327f00-9d26-11eb-808c-0ac841dc888e.png&#34; alt=&#34;Web UI Queues View&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tasks view&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/11155743/114697070-1f0a0300-9d26-11eb-855c-d3ec263865b7.png&#34; alt=&#34;Web UI TasksView&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Metrics view&lt;/strong&gt; &lt;img width=&#34;1532&#34; alt=&#34;Screen Shot 2021-12-19 at 4 37 19 PM&#34; src=&#34;https://user-images.githubusercontent.com/10953044/146777420-cae6c476-bac6-469c-acce-b2f6584e8707.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Settings and adaptive dark mode&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/11155743/114697149-3517c380-9d26-11eb-9f7a-ae2dd00aad5b.png&#34; alt=&#34;Web UI Settings and adaptive dark mode&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For details on how to use the tool, refer to the tool&#39;s &lt;a href=&#34;https://github.com/hibiken/asynqmon#readme&#34;&gt;README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Command Line Tool&lt;/h2&gt; &#xA;&lt;p&gt;Asynq ships with a command line tool to inspect the state of queues and tasks.&lt;/p&gt; &#xA;&lt;p&gt;To install the CLI tool, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go install github.com/hibiken/asynq/tools/asynq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example of running the &lt;code&gt;asynq dash&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hibiken/asynq/master/docs/assets/dash.gif&#34; alt=&#34;Gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For details on how to use the tool, refer to the tool&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/hibiken/asynq/master/tools/asynq/README.md&#34;&gt;README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We are open to, and grateful for, any contributions (GitHub issues/PRs, feedback on &lt;a href=&#34;https://gitter.im/go-asynq/community&#34;&gt;Gitter channel&lt;/a&gt;, etc) made by the community.&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://raw.githubusercontent.com/hibiken/asynq/master/CONTRIBUTING.md&#34;&gt;Contribution Guide&lt;/a&gt; before contributing.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2019-present &lt;a href=&#34;https://github.com/hibiken&#34;&gt;Ken Hibino&lt;/a&gt; and &lt;a href=&#34;https://github.com/hibiken/asynq/graphs/contributors&#34;&gt;Contributors&lt;/a&gt;. &lt;code&gt;Asynq&lt;/code&gt; is free and open-source software licensed under the &lt;a href=&#34;https://github.com/hibiken/asynq/raw/master/LICENSE&#34;&gt;MIT License&lt;/a&gt;. Official logo was created by &lt;a href=&#34;https://github.com/koddr&#34;&gt;Vic Shóstak&lt;/a&gt; and distributed under &lt;a href=&#34;https://creativecommons.org/publicdomain/zero/1.0/&#34;&gt;Creative Commons&lt;/a&gt; license (CC0 1.0 Universal).&lt;/p&gt;</summary>
  </entry>
</feed>