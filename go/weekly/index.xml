<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-12T02:08:48Z</updated>
  <subtitle>Weekly Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tulir/whatsmeow</title>
    <updated>2022-06-12T02:08:48Z</updated>
    <id>tag:github.com,2022-06-12:/tulir/whatsmeow</id>
    <link href="https://github.com/tulir/whatsmeow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Go library for the WhatsApp web multidevice API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;whatsmeow&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/go.mau.fi/whatsmeow&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/go.mau.fi/whatsmeow.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;whatsmeow is a Go library for the WhatsApp web multidevice API.&lt;/p&gt; &#xA;&lt;h2&gt;Discussion&lt;/h2&gt; &#xA;&lt;p&gt;Matrix room: &lt;a href=&#34;https://matrix.to/#/#whatsmeow:maunium.net&#34;&gt;#whatsmeow:maunium.net&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For questions about the WhatsApp protocol (like how to send a specific type of message), you can also use the &lt;a href=&#34;https://github.com/tulir/whatsmeow/discussions/categories/whatsapp-protocol-q-a&#34;&gt;WhatsApp protocol Q&amp;amp;A&lt;/a&gt; section on GitHub discussions.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://pkg.go.dev/go.mau.fi/whatsmeow&#34;&gt;godoc&lt;/a&gt; includes docs for all methods and event types. There&#39;s also a &lt;a href=&#34;https://godocs.io/go.mau.fi/whatsmeow#example-package&#34;&gt;simple example&lt;/a&gt; at the top.&lt;/p&gt; &#xA;&lt;p&gt;Also see &lt;a href=&#34;https://raw.githubusercontent.com/tulir/whatsmeow/main/mdtest&#34;&gt;mdtest&lt;/a&gt; for a CLI tool you can easily try out whatsmeow with.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Most core features are already present:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sending messages to private chats and groups (both text and media)&lt;/li&gt; &#xA; &lt;li&gt;Receiving all messages&lt;/li&gt; &#xA; &lt;li&gt;Managing groups and receiving group change events&lt;/li&gt; &#xA; &lt;li&gt;Joining via invite messages, using and creating invite links&lt;/li&gt; &#xA; &lt;li&gt;Sending and receiving typing notifications&lt;/li&gt; &#xA; &lt;li&gt;Sending and receiving delivery and read receipts&lt;/li&gt; &#xA; &lt;li&gt;Reading app state (contact list, chat pin/mute status, etc)&lt;/li&gt; &#xA; &lt;li&gt;Sending and handling retry receipts if message decryption fails&lt;/li&gt; &#xA; &lt;li&gt;Sending status messages (experimental, may not work for large contact lists)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Things that are not yet implemented:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Writing app state (contact list, chat pin/mute status, etc)&lt;/li&gt; &#xA; &lt;li&gt;Sending broadcast list messages (this is not supported on WhatsApp web either)&lt;/li&gt; &#xA; &lt;li&gt;Calls&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>tinygo-org/tinygo</title>
    <updated>2022-06-12T02:08:48Z</updated>
    <id>tag:github.com,2022-06-12:/tinygo-org/tinygo</id>
    <link href="https://github.com/tinygo-org/tinygo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Go compiler for small places. Microcontrollers, WebAssembly (WASM/WASI), and command-line tools. Based on LLVM.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TinyGo - Go compiler for small places&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/linux.yml&#34;&gt;&lt;img src=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/linux.yml/badge.svg?branch=dev&#34; alt=&#34;Linux&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/build-macos.yml&#34;&gt;&lt;img src=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/build-macos.yml/badge.svg?branch=dev&#34; alt=&#34;macOS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/windows.yml&#34;&gt;&lt;img src=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/windows.yml/badge.svg?branch=dev&#34; alt=&#34;Windows&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/docker.yml&#34;&gt;&lt;img src=&#34;https://github.com/tinygo-org/tinygo/actions/workflows/docker.yml/badge.svg?branch=dev&#34; alt=&#34;Docker&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/tinygo-org/tinygo/tree/dev&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/tinygo-org/tinygo/tree/dev.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;TinyGo is a Go compiler intended for use in small places such as microcontrollers, WebAssembly (Wasm), and command-line tools.&lt;/p&gt; &#xA;&lt;p&gt;It reuses libraries used by the &lt;a href=&#34;https://golang.org/pkg/go/&#34;&gt;Go language tools&lt;/a&gt; alongside &lt;a href=&#34;http://llvm.org&#34;&gt;LLVM&lt;/a&gt; to provide an alternative way to compile programs written in the Go programming language.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example program that blinks the built-in LED when run directly on any supported board with onboard LED:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;    &#34;machine&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    led := machine.LED&#xA;    led.Configure(machine.PinConfig{Mode: machine.PinOutput})&#xA;    for {&#xA;        led.Low()&#xA;        time.Sleep(time.Millisecond * 1000)&#xA;&#xA;        led.High()&#xA;        time.Sleep(time.Millisecond * 1000)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above program can be compiled and run without modification on an Arduino Uno, an Adafruit ItsyBitsy M0, or any of the supported boards that have a built-in LED, just by setting the correct TinyGo compiler target. For example, this compiles and flashes an Arduino Uno:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tinygo flash -target arduino examples/blinky1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://tinygo.org/getting-started/&#34;&gt;getting started instructions&lt;/a&gt; for information on how to install TinyGo, as well as how to run the TinyGo compiler using our Docker container.&lt;/p&gt; &#xA;&lt;h2&gt;Supported boards/targets&lt;/h2&gt; &#xA;&lt;p&gt;You can compile TinyGo programs for microcontrollers, WebAssembly and Linux.&lt;/p&gt; &#xA;&lt;p&gt;The following 85 microcontroller boards are currently supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4333&#34;&gt;Adafruit Circuit Playground Bluefruit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/3333&#34;&gt;Adafruit Circuit Playground Express&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4500&#34;&gt;Adafruit CLUE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/2772&#34;&gt;Adafruit Feather M0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/3857&#34;&gt;Adafruit Feather M4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4759&#34;&gt;Adafruit Feather M4 CAN&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4062&#34;&gt;Adafruit Feather nRF52840 Express&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4516&#34;&gt;Adafruit Feather nRF52840 Sense&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4884&#34;&gt;Adafruit Feather RP2040&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4382&#34;&gt;Adafruit Feather STM32F405 Express&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4064&#34;&gt;Adafruit Grand Central M4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/3727&#34;&gt;Adafruit ItsyBitsy M0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/3800&#34;&gt;Adafruit ItsyBitsy M4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4481&#34;&gt;Adafruit ItsyBitsy nRF52840&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/5100&#34;&gt;Adafruit MacroPad RP2040&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4745&#34;&gt;Adafruit Matrix Portal M4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4000&#34;&gt;Adafruit Metro M4 Express Airlift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4200&#34;&gt;Adafruit PyBadge&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4242&#34;&gt;Adafruit PyGamer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4116&#34;&gt;Adafruit PyPortal&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/4600&#34;&gt;Adafruit QT Py&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/3500&#34;&gt;Adafruit Trinket M0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.arduino.cc/en/Main/arduinoBoardMega/&#34;&gt;Arduino Mega 1280&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/arduino-mega-2560-rev3&#34;&gt;Arduino Mega 2560&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/arduino-mkr1000-wifi&#34;&gt;Arduino MKR1000&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/usa/mkr-wifi-1010&#34;&gt;Arduino MKR WiFi 1010&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/arduino-nano&#34;&gt;Arduino Nano&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/nano-33-ble&#34;&gt;Arduino Nano 33 BLE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/nano-33-ble-sense&#34;&gt;Arduino Nano 33 BLE Sense&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/nano-33-iot&#34;&gt;Arduino Nano 33 IoT&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/nano-rp2040-connect&#34;&gt;Arduino Nano RP2040 Connect&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/arduino-uno-rev3&#34;&gt;Arduino Uno&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.arduino.cc/usa/arduino-zero&#34;&gt;Arduino Zero&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://microbit.org/&#34;&gt;BBC micro:bit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://microbit.org/new-microbit/&#34;&gt;BBC micro:bit v2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blues.io/products/swan/&#34;&gt;blues wireless Swan&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://digistump.com/products/1&#34;&gt;Digispark&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.dragino.com/products/lora-lorawan-end-node/item/142-lgt-92.html&#34;&gt;Dragino LoRaWAN GPS Tracker LGT-92&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.espressif.com/en/products/socs/esp32&#34;&gt;ESP32 - Core board&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.espressif.com/en/products/socs/esp32&#34;&gt;ESP32 - mini32&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.espressif.com/en/products/socs/esp32-c3&#34;&gt;ESP32-C3-12f&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.espressif.com/en/products/socs/esp8266&#34;&gt;ESP8266 - d1mini&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.espressif.com/en/products/socs/esp8266&#34;&gt;ESP8266 - NodeMCU&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Game_Boy_Advance&#34;&gt;Game Boy Advance&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.m5stack.com/en/core/basic&#34;&gt;M5Stack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://shop.m5stack.com/products/m5stack-core2-esp32-iot-development-kit&#34;&gt;M5Stack Core2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.m5stack.com/en/core/stamp_c3&#34;&gt;M5Stamp C3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wiki.makerdiary.com/nrf52840-mdk/&#34;&gt;Makerdiary nRF52840-MDK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wiki.makerdiary.com/nrf52840-mdk-usb-dongle/&#34;&gt;Makerdiary nRF52840-MDK USB Dongle&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.microchip.com/developmenttools/productdetails/atsame54-xpro&#34;&gt;Microchip SAM E54 Xplained Pro&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.nicekeyboards.com/#/nice!nano/&#34;&gt;nice!nano&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nintendo.com/switch/&#34;&gt;Nintendo Switch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nordicsemi.com/eng/Products/nRF51-Dongle&#34;&gt;Nordic Semiconductor PCA10031&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF52-DK&#34;&gt;Nordic Semiconductor PCA10040&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nordicsemi.com/Software-and-Tools/Development-Kits/nRF52840-DK&#34;&gt;Nordic Semiconductor PCA10056&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nordicsemi.com/Software-and-tools/Development-Kits/nRF52840-Dongle&#34;&gt;Nordic Semiconductor pca10059&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.particle.io/datasheets/wi-fi/argon-datasheet/&#34;&gt;Particle Argon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.particle.io/datasheets/cellular/boron-datasheet/&#34;&gt;Particle Boron&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.particle.io/datasheets/discontinued/xenon-datasheet/&#34;&gt;Particle Xenon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.phytec.eu/product-eu/internet-of-things/reelboard/&#34;&gt;Phytec reel board&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pine64.org/pinetime/&#34;&gt;PineTime DevKit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pjrc.com/store/teensy36.html&#34;&gt;PJRC Teensy 3.6&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pjrc.com/store/teensy40.html&#34;&gt;PJRC Teensy 4.0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pjrc.com/store/teensy41.html&#34;&gt;PJRC Teensy 4.1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://facts-engineering.github.io/modules/P1AM-100/P1AM-100.html&#34;&gt;ProductivityOpen P1AM-100&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.raspberrypi.org/products/raspberry-pi-pico/&#34;&gt;Raspberry Pi Pico&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.adafruit.com/product/5199&#34;&gt;Raytac MDBT50Q-RX Dongle (with TinyUF2 bootloader)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.seeedstudio.com/Seeeduino-XIAO-Arduino-Microcontroller-SAMD21-Cortex-M0+-p-4426.html&#34;&gt;Seeed Seeeduino XIAO&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.seeedstudio.com/Seeed-XIAO-BLE-nRF52840-p-5201.html&#34;&gt;Seeed XIAO BLE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.seeedstudio.com/LoRa-E5-Dev-Kit-p-4868.html&#34;&gt;Seeed LoRa-E5 Development Kit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.seeedstudio.com/Sipeed-MAix-BiT-for-RISC-V-AI-IoT-p-2872.html&#34;&gt;Seeed Sipeed MAix BiT&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.seeedstudio.com/Wio-Terminal-p-4509.html&#34;&gt;Seeed Wio Terminal&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.sifive.com/boards/hifive1&#34;&gt;SiFIve HiFive1 Rev B&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.sparkfun.com/products/17745&#34;&gt;Sparkfun Thing Plus RP2040&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/en/evaluation-tools/nucleo-f103rb.html&#34;&gt;ST Micro &#34;Nucleo&#34; F103RB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/en/evaluation-tools/nucleo-f722ze.html&#34;&gt;ST Micro &#34;Nucleo&#34; F722ZE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/ja/evaluation-tools/nucleo-l031k6.html&#34;&gt;ST Micro &#34;Nucleo&#34; L031K6&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/ja/evaluation-tools/nucleo-l432kc.html&#34;&gt;ST Micro &#34;Nucleo&#34; L432KC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/en/evaluation-tools/nucleo-l552ze-q.html&#34;&gt;ST Micro &#34;Nucleo&#34; L552ZE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/en/evaluation-tools/nucleo-wl55jc.html&#34;&gt;ST Micro &#34;Nucleo&#34; WL55JC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stm32-base.org/boards/STM32F103C8T6-Blue-Pill&#34;&gt;ST Micro STM32F103XX &#34;Bluepill&#34;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/en/evaluation-tools/stm32f4discovery.html&#34;&gt;ST Micro STM32F407 &#34;Discovery&#34;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-mpu-eval-tools/stm32-mcu-mpu-eval-tools/stm32-discovery-kits/32f469idiscovery.html&#34;&gt;ST Micro STM32F469 &#34;Discovery&#34;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/curtpw/nRF5x-device-reverse-engineering/tree/master/X9-nrf52832-activity-tracker/&#34;&gt;X9 Pro smartwatch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.genericnode.com/docs/sensor-edition/&#34;&gt;The Things Industries Generic Node Sensor Edition&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more information, see &lt;a href=&#34;https://tinygo.org/microcontrollers/&#34;&gt;this list of boards&lt;/a&gt;. Pull requests for additional support are welcome!&lt;/p&gt; &#xA;&lt;h2&gt;Currently supported features:&lt;/h2&gt; &#xA;&lt;p&gt;For a description of currently supported Go language features, please see &lt;a href=&#34;https://tinygo.org/lang-support/&#34;&gt;https://tinygo.org/lang-support/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation is located on our web site at &lt;a href=&#34;https://tinygo.org/&#34;&gt;https://tinygo.org/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can find the web site code at &lt;a href=&#34;https://github.com/tinygo-org/tinygo-site&#34;&gt;https://github.com/tinygo-org/tinygo-site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting help&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re looking for a more interactive way to discuss TinyGo usage or development, we have a &lt;a href=&#34;https://gophers.slack.com/messages/CDJD3SUP6/&#34;&gt;#TinyGo channel&lt;/a&gt; on the &lt;a href=&#34;https://gophers.slack.com&#34;&gt;Gophers Slack&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you need an invitation for the Gophers Slack, you can generate one here which should arrive fairly quickly (under 1 min): &lt;a href=&#34;https://invite.slack.golangbridge.org&#34;&gt;https://invite.slack.golangbridge.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Your contributions are welcome!&lt;/p&gt; &#xA;&lt;p&gt;Please take a look at our &lt;a href=&#34;https://tinygo.org/docs/guides/contributing/&#34;&gt;Contributing&lt;/a&gt; page on our web site for details.&lt;/p&gt; &#xA;&lt;h2&gt;Project Scope&lt;/h2&gt; &#xA;&lt;p&gt;Goals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Have very small binary sizes. Don&#39;t pay for what you don&#39;t use.&lt;/li&gt; &#xA; &lt;li&gt;Support for most common microcontroller boards.&lt;/li&gt; &#xA; &lt;li&gt;Be usable on the web using WebAssembly.&lt;/li&gt; &#xA; &lt;li&gt;Good CGo support, with no more overhead than a regular function call.&lt;/li&gt; &#xA; &lt;li&gt;Support most standard library packages and compile most Go code without modification.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Non-goals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Be efficient while using zillions of goroutines. However, good goroutine support is certainly a goal.&lt;/li&gt; &#xA; &lt;li&gt;Be as fast as &lt;code&gt;gc&lt;/code&gt;. However, LLVM will probably be better at optimizing certain things so TinyGo might actually turn out to be faster for number crunching.&lt;/li&gt; &#xA; &lt;li&gt;Be able to compile every Go program out there.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why this project exists&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;We never expected Go to be an embedded language and so its got serious problems...&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;-- Rob Pike, &lt;a href=&#34;https://www.youtube.com/watch?v=VoS7DsT1rdM&amp;amp;feature=youtu.be&amp;amp;t=2799&#34;&gt;GopherCon 2014 Opening Keynote&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;TinyGo is a project to bring Go to microcontrollers and small systems with a single processor core. It is similar to &lt;a href=&#34;https://github.com/ziutek/emgo&#34;&gt;emgo&lt;/a&gt; but a major difference is that we want to keep the Go memory model (which implies garbage collection of some sort). Another difference is that TinyGo uses LLVM internally instead of emitting C, which hopefully leads to smaller and more efficient code and certainly leads to more flexibility.&lt;/p&gt; &#xA;&lt;p&gt;The original reasoning was: if &lt;a href=&#34;https://micropython.org/&#34;&gt;Python&lt;/a&gt; can run on microcontrollers, then certainly &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; should be able to run on even lower level micros.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the BSD 3-clause license, just like the &lt;a href=&#34;https://golang.org/LICENSE&#34;&gt;Go project&lt;/a&gt; itself.&lt;/p&gt; &#xA;&lt;p&gt;Some code has been copied from the LLVM project and is therefore licensed under &lt;a href=&#34;http://releases.llvm.org/11.0.0/LICENSE.TXT&#34;&gt;a variant of the Apache 2.0 license&lt;/a&gt;. This has been clearly indicated in the header of these files.&lt;/p&gt; &#xA;&lt;p&gt;Some code has been copied and/or ported from Paul Stoffregen&#39;s Teensy libraries and is therefore licensed under PJRC&#39;s license. This has been clearly indicated in the header of these files.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>samber/lo</title>
    <updated>2022-06-12T02:08:48Z</updated>
    <id>tag:github.com,2022-06-12:/samber/lo</id>
    <link href="https://github.com/samber/lo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;💥 A Lodash-style Go library based on Go 1.18+ Generics (map, filter, contains, find...)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lo&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/samber/lo/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/tag/samber/lo.svg?sanitize=true&#34; alt=&#34;tag&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/samber/lo&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/samber/lo?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/samber/lo/actions/workflows/go.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/samber/lo&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/samber/lo&#34; alt=&#34;Go report&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/samber/lo&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/samber/lo/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;✨ &lt;strong&gt;&lt;code&gt;samber/lo&lt;/code&gt; is a Lodash-style Go library based on Go 1.18+ Generics.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project started as an experiment with the new generics implementation. It may look like &lt;a href=&#34;https://github.com/lodash/lodash&#34;&gt;Lodash&lt;/a&gt; in some aspects. I used to code with the fantastic &lt;a href=&#34;https://github.com/thoas/go-funk&#34;&gt;&#34;go-funk&#34;&lt;/a&gt; package, but &#34;go-funk&#34; uses reflection and therefore is not typesafe.&lt;/p&gt; &#xA;&lt;p&gt;As expected, benchmarks demonstrate that generics will be much faster than implementations based on the &#34;reflect&#34; package. Benchmarks also show similar performance gains compared to pure &lt;code&gt;for&lt;/code&gt; loops. &lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#-benchmark&#34;&gt;See below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the future, 5 to 10 helpers will overlap with those coming into the Go standard library (under package names &lt;code&gt;slices&lt;/code&gt; and &lt;code&gt;maps&lt;/code&gt;). I feel this library is legitimate and offers many more valuable abstractions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;See also:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/samber/do&#34;&gt;samber/do&lt;/a&gt;: A dependency injection toolkit based on Go 1.18+ Generics&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/samber/mo&#34;&gt;samber/mo&lt;/a&gt;: Monads based on Go 1.18+ Generics (Option, Result, Either...)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why this name?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;I wanted a &lt;strong&gt;short name&lt;/strong&gt;, similar to &#34;Lodash&#34; and no Go package currently uses this name.&lt;/p&gt; &#xA;&lt;h2&gt;🚀 Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get github.com/samber/lo@v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This library is v1 and follows SemVer strictly.&lt;/p&gt; &#xA;&lt;p&gt;No breaking changes will be made to exported APIs before v2.0.0.&lt;/p&gt; &#xA;&lt;h2&gt;💡 Usage&lt;/h2&gt; &#xA;&lt;p&gt;You can import &lt;code&gt;lo&lt;/code&gt; using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    &#34;github.com/samber/lo&#34;&#xA;    lop &#34;github.com/samber/lo/parallel&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use one of the helpers below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;names := lo.Uniq[string]([]string{&#34;Samuel&#34;, &#34;Marc&#34;, &#34;Samuel&#34;})&#xA;// []string{&#34;Samuel&#34;, &#34;Marc&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most of the time, the compiler will be able to infer the type so that you can call: &lt;code&gt;lo.Uniq([]string{...})&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;🤠 Spec&lt;/h2&gt; &#xA;&lt;p&gt;GoDoc: &lt;a href=&#34;https://godoc.org/github.com/samber/lo&#34;&gt;https://godoc.org/github.com/samber/lo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Supported helpers for slices:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Filter&lt;/li&gt; &#xA; &lt;li&gt;Map&lt;/li&gt; &#xA; &lt;li&gt;FilterMap&lt;/li&gt; &#xA; &lt;li&gt;FlatMap&lt;/li&gt; &#xA; &lt;li&gt;Reduce&lt;/li&gt; &#xA; &lt;li&gt;ForEach&lt;/li&gt; &#xA; &lt;li&gt;Times&lt;/li&gt; &#xA; &lt;li&gt;Uniq&lt;/li&gt; &#xA; &lt;li&gt;UniqBy&lt;/li&gt; &#xA; &lt;li&gt;GroupBy&lt;/li&gt; &#xA; &lt;li&gt;Chunk&lt;/li&gt; &#xA; &lt;li&gt;PartitionBy&lt;/li&gt; &#xA; &lt;li&gt;Flatten&lt;/li&gt; &#xA; &lt;li&gt;Shuffle&lt;/li&gt; &#xA; &lt;li&gt;Reverse&lt;/li&gt; &#xA; &lt;li&gt;Fill&lt;/li&gt; &#xA; &lt;li&gt;Repeat&lt;/li&gt; &#xA; &lt;li&gt;KeyBy&lt;/li&gt; &#xA; &lt;li&gt;Drop&lt;/li&gt; &#xA; &lt;li&gt;DropRight&lt;/li&gt; &#xA; &lt;li&gt;DropWhile&lt;/li&gt; &#xA; &lt;li&gt;DropRightWhile&lt;/li&gt; &#xA; &lt;li&gt;Reject&lt;/li&gt; &#xA; &lt;li&gt;Count&lt;/li&gt; &#xA; &lt;li&gt;CountBy&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for maps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Keys&lt;/li&gt; &#xA; &lt;li&gt;Values&lt;/li&gt; &#xA; &lt;li&gt;PickBy&lt;/li&gt; &#xA; &lt;li&gt;PickByKeys&lt;/li&gt; &#xA; &lt;li&gt;PickByValues&lt;/li&gt; &#xA; &lt;li&gt;OmitBy&lt;/li&gt; &#xA; &lt;li&gt;OmitByKeys&lt;/li&gt; &#xA; &lt;li&gt;OmitByValues&lt;/li&gt; &#xA; &lt;li&gt;Entries&lt;/li&gt; &#xA; &lt;li&gt;FromEntries&lt;/li&gt; &#xA; &lt;li&gt;Invert&lt;/li&gt; &#xA; &lt;li&gt;Assign (merge of maps)&lt;/li&gt; &#xA; &lt;li&gt;MapKeys&lt;/li&gt; &#xA; &lt;li&gt;MapValues&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported math helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Range / RangeFrom / RangeWithSteps&lt;/li&gt; &#xA; &lt;li&gt;Clamp&lt;/li&gt; &#xA; &lt;li&gt;SumBy&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for strings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Substring&lt;/li&gt; &#xA; &lt;li&gt;RuneLength&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for tuples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;T2 -&amp;gt; T9&lt;/li&gt; &#xA; &lt;li&gt;Unpack2 -&amp;gt; Unpack9&lt;/li&gt; &#xA; &lt;li&gt;Zip2 -&amp;gt; Zip9&lt;/li&gt; &#xA; &lt;li&gt;Unzip2 -&amp;gt; Unzip9&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported intersection helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contains&lt;/li&gt; &#xA; &lt;li&gt;ContainsBy&lt;/li&gt; &#xA; &lt;li&gt;Every&lt;/li&gt; &#xA; &lt;li&gt;EveryBy&lt;/li&gt; &#xA; &lt;li&gt;Some&lt;/li&gt; &#xA; &lt;li&gt;SomeBy&lt;/li&gt; &#xA; &lt;li&gt;None&lt;/li&gt; &#xA; &lt;li&gt;NoneBy&lt;/li&gt; &#xA; &lt;li&gt;Intersect&lt;/li&gt; &#xA; &lt;li&gt;Difference&lt;/li&gt; &#xA; &lt;li&gt;Union&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported search helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;IndexOf&lt;/li&gt; &#xA; &lt;li&gt;LastIndexOf&lt;/li&gt; &#xA; &lt;li&gt;Find&lt;/li&gt; &#xA; &lt;li&gt;FindIndexOf&lt;/li&gt; &#xA; &lt;li&gt;FindLastIndexOf&lt;/li&gt; &#xA; &lt;li&gt;Min&lt;/li&gt; &#xA; &lt;li&gt;MinBy&lt;/li&gt; &#xA; &lt;li&gt;Max&lt;/li&gt; &#xA; &lt;li&gt;MaxBy&lt;/li&gt; &#xA; &lt;li&gt;Last&lt;/li&gt; &#xA; &lt;li&gt;Nth&lt;/li&gt; &#xA; &lt;li&gt;Sample&lt;/li&gt; &#xA; &lt;li&gt;Samples&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Conditional helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ternary (1 line if/else statement)&lt;/li&gt; &#xA; &lt;li&gt;If / ElseIf / Else&lt;/li&gt; &#xA; &lt;li&gt;Switch / Case / Default&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Type manipulation helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ToPtr&lt;/li&gt; &#xA; &lt;li&gt;ToSlicePtr&lt;/li&gt; &#xA; &lt;li&gt;ToAnySlice&lt;/li&gt; &#xA; &lt;li&gt;FromAnySlice&lt;/li&gt; &#xA; &lt;li&gt;Empty&lt;/li&gt; &#xA; &lt;li&gt;Coalesce&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Concurrency helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Attempt&lt;/li&gt; &#xA; &lt;li&gt;AttemptWithDelay&lt;/li&gt; &#xA; &lt;li&gt;Debounce&lt;/li&gt; &#xA; &lt;li&gt;Async&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Error handling:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Must&lt;/li&gt; &#xA; &lt;li&gt;Try&lt;/li&gt; &#xA; &lt;li&gt;TryCatch&lt;/li&gt; &#xA; &lt;li&gt;TryWithErrorValue&lt;/li&gt; &#xA; &lt;li&gt;TryCatchWithErrorValue&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Constraints:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clonable&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Map&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a slice of one type and transforms it into a slice of another type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &#34;github.com/samber/lo&#34;&#xA;&#xA;lo.Map[int64, string]([]int64{1, 2, 3, 4}, func(x int64, _ int) string {&#xA;    return strconv.FormatInt(x, 10)&#xA;})&#xA;// []string{&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.Map()&lt;/code&gt;, but the mapper function is called in a goroutine. Results are returned in the same order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.Map[int64, string]([]int64{1, 2, 3, 4}, func(x int64, _ int) string {&#xA;    return strconv.FormatInt(x, 10)&#xA;})&#xA;// []string{&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FlatMap&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a slice and transforms and flattens it to a slice of another type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.FlatMap[int, string]([]int{0, 1, 2}, func(x int, _ int) []string {&#xA;&#x9;return []string{&#xA;&#x9;&#x9;strconv.FormatInt(x, 10),&#xA;&#x9;&#x9;strconv.FormatInt(x, 10),&#xA;&#x9;}&#xA;})&#xA;// []string{&#34;0&#34;, &#34;0&#34;, &#34;1&#34;, &#34;1&#34;, &#34;2&#34;, &#34;2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FilterMap&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice which obtained after both filtering and mapping using the given callback function.&lt;/p&gt; &#xA;&lt;p&gt;The callback function should return two values: the result of the mapping operation and whether the result element should be included or not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;matching := lo.FilterMap[string, string]([]string{&#34;cpu&#34;, &#34;gpu&#34;, &#34;mouse&#34;, &#34;keyboard&#34;}, func(x string, _ int) (string, bool) {&#xA;    if strings.HasSuffix(x, &#34;pu&#34;) {&#xA;        return &#34;xpu&#34;, true&#xA;    }&#xA;    return &#34;&#34;, false&#xA;})&#xA;// []string{&#34;xpu&#34;, &#34;xpu&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Filter&lt;/h3&gt; &#xA;&lt;p&gt;Iterates over a collection and returns an array of all the elements the predicate function returns &lt;code&gt;true&lt;/code&gt; for.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;even := lo.Filter[int]([]int{1, 2, 3, 4}, func(x int, _ int) bool {&#xA;    return x%2 == 0&#xA;})&#xA;// []int{2, 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Contains&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if an element is present in a collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;present := lo.Contains[int]([]int{0, 1, 2, 3, 4, 5}, 5)&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ContainsBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate function returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;present := lo.ContainsBy[int]([]int{0, 1, 2, 3, 4, 5}, func(x int) bool {&#xA;    return x == 3&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reduce&lt;/h3&gt; &#xA;&lt;p&gt;Reduces a collection to a single value. The value is calculated by accumulating the result of running each element in the collection through an accumulator function. Each successive invocation is supplied with the return value returned by the previous call.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sum := lo.Reduce[int, int]([]int{1, 2, 3, 4}, func(agg int, item int, _ int) int {&#xA;    return agg + item&#xA;}, 0)&#xA;// 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ForEach&lt;/h3&gt; &#xA;&lt;p&gt;Iterates over elements of a collection and invokes the function over each element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &#34;github.com/samber/lo&#34;&#xA;&#xA;lo.ForEach[string]([]string{&#34;hello&#34;, &#34;world&#34;}, func(x string, _ int) {&#xA;    println(x)&#xA;})&#xA;// prints &#34;hello\nworld\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.ForEach()&lt;/code&gt;, but the callback is called as a goroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.ForEach[string]([]string{&#34;hello&#34;, &#34;world&#34;}, func(x string, _ int) {&#xA;    println(x)&#xA;})&#xA;// prints &#34;hello\nworld\n&#34; or &#34;world\nhello\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Times&lt;/h3&gt; &#xA;&lt;p&gt;Times invokes the iteratee n times, returning an array of the results of each invocation. The iteratee is invoked with index as argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &#34;github.com/samber/lo&#34;&#xA;&#xA;lo.Times[string](3, func(i int) string {&#xA;    return strconv.FormatInt(int64(i), 10)&#xA;})&#xA;// []string{&#34;0&#34;, &#34;1&#34;, &#34;2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.Times()&lt;/code&gt;, but callback is called in goroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.Times[string](3, func(i int) string {&#xA;    return strconv.FormatInt(int64(i), 10)&#xA;})&#xA;// []string{&#34;0&#34;, &#34;1&#34;, &#34;2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Uniq&lt;/h3&gt; &#xA;&lt;p&gt;Returns a duplicate-free version of an array, in which only the first occurrence of each element is kept. The order of result values is determined by the order they occur in the array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uniqValues := lo.Uniq[int]([]int{1, 2, 2, 1})&#xA;// []int{1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;UniqBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns a duplicate-free version of an array, in which only the first occurrence of each element is kept. The order of result values is determined by the order they occur in the array. It accepts &lt;code&gt;iteratee&lt;/code&gt; which is invoked for each element in array to generate the criterion by which uniqueness is computed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uniqValues := lo.UniqBy[int, int]([]int{0, 1, 2, 3, 4, 5}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// []int{0, 1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GroupBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns an object composed of keys generated from the results of running each element of collection through iteratee.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lo &#34;github.com/samber/lo&#34;&#xA;&#xA;groups := lo.GroupBy[int, int]([]int{0, 1, 2, 3, 4, 5}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// map[int][]int{0: []int{0, 3}, 1: []int{1, 4}, 2: []int{2, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.GroupBy()&lt;/code&gt;, but callback is called in goroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.GroupBy[int, int]([]int{0, 1, 2, 3, 4, 5}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// map[int][]int{0: []int{0, 3}, 1: []int{1, 4}, 2: []int{2, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chunk&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array of elements split into groups the length of size. If array can&#39;t be split evenly, the final chunk will be the remaining elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Chunk[int]([]int{0, 1, 2, 3, 4, 5}, 2)&#xA;// [][]int{{0, 1}, {2, 3}, {4, 5}}&#xA;&#xA;lo.Chunk[int]([]int{0, 1, 2, 3, 4, 5, 6}, 2)&#xA;// [][]int{{0, 1}, {2, 3}, {4, 5}, {6}}&#xA;&#xA;lo.Chunk[int]([]int{}, 2)&#xA;// [][]int{}&#xA;&#xA;lo.Chunk[int]([]int{0}, 2)&#xA;// [][]int{{0}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PartitionBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array of elements split into groups. The order of grouped values is determined by the order they occur in collection. The grouping is generated from the results of running each element of collection through iteratee.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lo &#34;github.com/samber/lo&#34;&#xA;&#xA;partitions := lo.PartitionBy[int, string]([]int{-2, -1, 0, 1, 2, 3, 4, 5}, func(x int) string {&#xA;    if x &amp;lt; 0 {&#xA;        return &#34;negative&#34;&#xA;    } else if x%2 == 0 {&#xA;        return &#34;even&#34;&#xA;    }&#xA;    return &#34;odd&#34;&#xA;})&#xA;// [][]int{{-2, -1}, {0, 2, 4}, {1, 3, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.PartitionBy()&lt;/code&gt;, but callback is called in goroutine. Results are returned in the same order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;partitions := lo.PartitionBy[int, string]([]int{-2, -1, 0, 1, 2, 3, 4, 5}, func(x int) string {&#xA;    if x &amp;lt; 0 {&#xA;        return &#34;negative&#34;&#xA;    } else if x%2 == 0 {&#xA;        return &#34;even&#34;&#xA;    }&#xA;    return &#34;odd&#34;&#xA;})&#xA;// [][]int{{-2, -1}, {0, 2, 4}, {1, 3, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Flatten&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array a single level deep.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;flat := lo.Flatten[int]([][]int{{0, 1}, {2, 3, 4, 5}})&#xA;// []int{0, 1, 2, 3, 4, 5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Shuffle&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;randomOrder := lo.Shuffle[int]([]int{0, 1, 2, 3, 4, 5})&#xA;// []int{0, 1, 2, 3, 4, 5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reverse&lt;/h3&gt; &#xA;&lt;p&gt;Reverses array so that the first element becomes the last, the second element becomes the second to last, and so on.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;reverseOder := lo.Reverse[int]([]int{0, 1, 2, 3, 4, 5})&#xA;// []int{5, 4, 3, 2, 1, 0}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fill&lt;/h3&gt; &#xA;&lt;p&gt;Fills elements of array with &lt;code&gt;initial&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct {&#xA;&#x9;bar string&#xA;}&#xA;&#xA;func (f foo) Clone() foo {&#xA;&#x9;return foo{f.bar}&#xA;}&#xA;&#xA;initializedSlice := lo.Fill[foo]([]foo{foo{&#34;a&#34;}, foo{&#34;a&#34;}}, foo{&#34;b&#34;})&#xA;// []foo{foo{&#34;b&#34;}, foo{&#34;b&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Repeat&lt;/h3&gt; &#xA;&lt;p&gt;Builds a slice with N copies of initial value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct {&#xA;&#x9;bar string&#xA;}&#xA;&#xA;func (f foo) Clone() foo {&#xA;&#x9;return foo{f.bar}&#xA;}&#xA;&#xA;slice := lo.Repeat[foo](2, foo{&#34;a&#34;})&#xA;// []foo{foo{&#34;a&#34;}, foo{&#34;a&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RepeatBy&lt;/h3&gt; &#xA;&lt;p&gt;Builds a slice with values returned by N calls of callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice := lo.RepeatBy[int](0, func (i int) int {&#xA;    return math.Pow(i, 2)&#xA;})&#xA;// []int{}&#xA;&#xA;slice := lo.RepeatBy[int](5, func (i int) int {&#xA;    return math.Pow(i, 2)&#xA;})&#xA;// []int{0, 1, 4, 9, 16}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;KeyBy&lt;/h3&gt; &#xA;&lt;p&gt;Transforms a slice or an array of structs to a map based on a pivot callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.KeyBy[int, string]([]string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;}, func(str string) int {&#xA;    return len(str)&#xA;})&#xA;// map[int]string{1: &#34;a&#34;, 2: &#34;aa&#34;, 3: &#34;aaa&#34;}&#xA;&#xA;type Character struct {&#xA;&#x9;dir  string&#xA;&#x9;code int&#xA;}&#xA;characters := []Character{&#xA;    {dir: &#34;left&#34;, code: 97},&#xA;    {dir: &#34;right&#34;, code: 100},&#xA;}&#xA;result := lo.KeyBy[string, Character](characters, func(char Character) string {&#xA;    return string(rune(char.code))&#xA;})&#xA;//map[a:{dir:left code:97} d:{dir:right code:100}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Drop&lt;/h3&gt; &#xA;&lt;p&gt;Drops n elements from the beginning of a slice or array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.Drop[int]([]int{0, 1, 2, 3, 4, 5}, 2)&#xA;// []int{2, 3, 4, 5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DropRight&lt;/h3&gt; &#xA;&lt;p&gt;Drops n elements from the end of a slice or array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.DropRight[int]([]int{0, 1, 2, 3, 4, 5}, 2)&#xA;// []int{0, 1, 2, 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DropWhile&lt;/h3&gt; &#xA;&lt;p&gt;Drop elements from the beginning of a slice or array while the predicate returns true.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.DropWhile[string]([]string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;, &#34;aa&#34;, &#34;aa&#34;}, func(val string) bool {&#xA;&#x9;return len(val) &amp;lt;= 2&#xA;})&#xA;// []string{&#34;aaa&#34;, &#34;aa&#34;, &#34;aa&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DropRightWhile&lt;/h3&gt; &#xA;&lt;p&gt;Drop elements from the end of a slice or array while the predicate returns true.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.DropRightWhile[string]([]string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;, &#34;aa&#34;, &#34;aa&#34;}, func(val string) bool {&#xA;&#x9;return len(val) &amp;lt;= 2&#xA;})&#xA;// []string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reject&lt;/h3&gt; &#xA;&lt;p&gt;The opposite of Filter, this method returns the elements of collection that predicate does not return truthy for.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;odd := lo.Reject[int]([]int{1, 2, 3, 4}, func(x int, _ int) bool {&#xA;    return x%2 == 0&#xA;})&#xA;// []int{1, 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Count&lt;/h3&gt; &#xA;&lt;p&gt;Counts the number of elements in the collection that compare equal to value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;count := lo.Count[int]([]int{1, 5, 1}, 1)&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CountBy&lt;/h3&gt; &#xA;&lt;p&gt;Counts the number of elements in the collection for which predicate is true.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;count := lo.CountBy[int]([]int{1, 5, 1}, func(i int) bool {&#xA;    return i &amp;lt; 4&#xA;})&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Subset&lt;/h3&gt; &#xA;&lt;p&gt;Return part of a slice.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []int{0, 1, 2, 3, 4}&#xA;&#xA;sub := lo.Subset(in, 2, 3)&#xA;// []int{2, 3, 4}&#xA;&#xA;sub := lo.Subset(in, -4, 3)&#xA;// []int{1, 2, 3}&#xA;&#xA;sub := lo.Subset(in, -2, math.MaxUint)&#xA;// []int{3, 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Replace&lt;/h3&gt; &#xA;&lt;p&gt;Returns a copy of the slice with the first n non-overlapping instances of old replaced by new.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []int{0, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, 0, 42, 1)&#xA;// []int{42, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, -1, 42, 1)&#xA;// []int{0, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, 0, 42, 2)&#xA;// []int{42, 1, 42, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, 0, 42, -1)&#xA;// []int{42, 1, 42, 1, 2, 3, 42}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ReplaceAll&lt;/h3&gt; &#xA;&lt;p&gt;Returns a copy of the slice with all non-overlapping instances of old replaced by new.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []int{0, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.ReplaceAll(in, 0, 42)&#xA;// []int{42, 1, 42, 1, 2, 3, 42}&#xA;&#xA;slice := lo.ReplaceAll(in, -1, 42)&#xA;// []int{0, 1, 0, 1, 2, 3, 0}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Keys&lt;/h3&gt; &#xA;&lt;p&gt;Creates an array of the map keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;keys := lo.Keys[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2})&#xA;// []string{&#34;bar&#34;, &#34;foo&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Values&lt;/h3&gt; &#xA;&lt;p&gt;Creates an array of the map values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;values := lo.Values[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2})&#xA;// []int{1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PickBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given predicate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.PickBy[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, func(key string, value int) bool {&#xA;    return value%2 == 1&#xA;})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;baz&#34;: 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PickByKeys&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.PickByKeys[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []string{&#34;foo&#34;, &#34;baz&#34;})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;baz&#34;: 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PickByValues&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.PickByValues[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []int{1, 3})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;baz&#34;: 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OmitBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given predicate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.OmitBy[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, func(key string, value int) bool {&#xA;    return value%2 == 1&#xA;})&#xA;// map[string]int{&#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OmitByKeys&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.OmitByKeys[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []string{&#34;foo&#34;, &#34;baz&#34;})&#xA;// map[string]int{&#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OmitByValues&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.OmitByValues[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []int{1, 3})&#xA;// map[string]int{&#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Entries&lt;/h3&gt; &#xA;&lt;p&gt;Transforms a map into array of key/value pairs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;entries := lo.Entries[string, int](map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2})&#xA;// []lo.Entry[string, int]{&#xA;//     {&#xA;//         Key: &#34;foo&#34;,&#xA;//         Value: 1,&#xA;//     },&#xA;//     {&#xA;//         Key: &#34;bar&#34;,&#xA;//         Value: 2,&#xA;//     },&#xA;// }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FromEntries&lt;/h3&gt; &#xA;&lt;p&gt;Transforms an array of key/value pairs into a map.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.FromEntries[string, int]([]lo.Entry[string, int]{&#xA;    {&#xA;        Key: &#34;foo&#34;,&#xA;        Value: 1,&#xA;    },&#xA;    {&#xA;        Key: &#34;bar&#34;,&#xA;        Value: 2,&#xA;    },&#xA;})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invert&lt;/h3&gt; &#xA;&lt;p&gt;Creates a map composed of the inverted keys and values. If map contains duplicate values, subsequent values overwrite property assignments of previous values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m1 := lo.Invert[string, int]([map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 2})&#xA;// map[int]string{1: &#34;a&#34;, 2: &#34;b&#34;}&#xA;&#xA;m2 := lo.Invert[string, int]([map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 1})&#xA;// map[int]string{1: &#34;c&#34;, 2: &#34;b&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Assign&lt;/h3&gt; &#xA;&lt;p&gt;Merges multiple maps from left to right.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;mergedMaps := lo.Assign[string, int](&#xA;    map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 2},&#xA;    map[string]int{&#34;b&#34;: 3, &#34;c&#34;: 4},&#xA;)&#xA;// map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 3, &#34;c&#34;: 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MapKeys&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a map keys and transforms it to a map of another type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m2 := lo.MapKeys[int, int, string](map[int]int{1: 1, 2: 2, 3: 3, 4: 4}, func(_ int, v int) string {&#xA;    return strconv.FormatInt(int64(v), 10)&#xA;})&#xA;// map[string]int{&#34;1&#34;: 1, &#34;2&#34;: 2, &#34;3&#34;: 3, &#34;4&#34;: 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MapValues&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a map values and transforms it to a map of another type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m1 := map[int]int64{1: 1, 2: 2, 3: 3}&#xA;&#xA;m2 := lo.MapValues[int, int64, string](m1, func(x int64, _ int) string {&#xA;&#x9;return strconv.FormatInt(x, 10)&#xA;})&#xA;// map[int]string{1: &#34;1&#34;, 2: &#34;2&#34;, 3: &#34;3&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Range / RangeFrom / RangeWithSteps&lt;/h3&gt; &#xA;&lt;p&gt;Creates an array of numbers (positive and/or negative) progressing from start up to, but not including end.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := Range(4)&#xA;// [0, 1, 2, 3]&#xA;&#xA;result := Range(-4);&#xA;// [0, -1, -2, -3]&#xA;&#xA;result := RangeFrom(1, 5);&#xA;// [1, 2, 3, 4]&#xA;&#xA;result := RangeFrom[float64](1.0, 5);&#xA;// [1.0, 2.0, 3.0, 4.0]&#xA;&#xA;result := RangeWithSteps(0, 20, 5);&#xA;// [0, 5, 10, 15]&#xA;&#xA;result := RangeWithSteps[float32](-1.0, -4.0, -1.0);&#xA;// [-1.0, -2.0, -3.0]&#xA;&#xA;result := RangeWithSteps(1, 4, -1);&#xA;// []&#xA;&#xA;result := Range(0);&#xA;// []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Clamp&lt;/h3&gt; &#xA;&lt;p&gt;Clamps number within the inclusive lower and upper bounds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r1 := lo.Clamp(0, -10, 10)&#xA;// 0&#xA;&#xA;r2 := lo.Clamp(-42, -10, 10)&#xA;// -10&#xA;&#xA;r3 := lo.Clamp(42, -10, 10)&#xA;// 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SumBy&lt;/h3&gt; &#xA;&lt;p&gt;Summarizes the values in a collection using the given return value from the iteration function. If collection is empty 0 is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;strings := []string{&#34;foo&#34;, &#34;bar&#34;}&#xA;sum := lo.SumBy(strings, func(item string) int {&#xA;    return len(item)&#xA;})&#xA;// 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Substring&lt;/h3&gt; &#xA;&lt;p&gt;Return part of a string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sub := lo.Substring(&#34;hello&#34;, 2, 3)&#xA;// &#34;llo&#34;&#xA;&#xA;sub := lo.Substring(&#34;hello&#34;, -4, 3)&#xA;// &#34;ell&#34;&#xA;&#xA;sub := lo.Substring(&#34;hello&#34;, -2, math.MaxUint)&#xA;// &#34;lo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RuneLength&lt;/h3&gt; &#xA;&lt;p&gt;An alias to utf8.RuneCountInString which returns the number of runes in string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sub := lo.RuneLength(&#34;hellô&#34;)&#xA;// 5&#xA;&#xA;sub := len(&#34;hellô&#34;)&#xA;// 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;T2 -&amp;gt; T9&lt;/h3&gt; &#xA;&lt;p&gt;Creates a tuple from a list of values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tuple1 := lo.T2[string, int](&#34;x&#34;, 1)&#xA;// Tuple2[string, int]{A: &#34;x&#34;, B: 1}&#xA;&#xA;func example() (string, int) { return &#34;y&#34;, 2 }&#xA;tuple2 := lo.T2[string, int](example())&#xA;// Tuple2[string, int]{A: &#34;y&#34;, B: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unpack2 -&amp;gt; Unpack9&lt;/h3&gt; &#xA;&lt;p&gt;Returns values contained in tuple.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r1, r2 := lo.Unpack2[string, int](lo.Tuple2[string, int]{&#34;a&#34;, 1})&#xA;// &#34;a&#34;, 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Zip2 -&amp;gt; Zip9&lt;/h3&gt; &#xA;&lt;p&gt;Zip creates a slice of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on.&lt;/p&gt; &#xA;&lt;p&gt;When collections have different size, the Tuple attributes are filled with zero value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tuples := lo.Zip2[string, int]([]string{&#34;a&#34;, &#34;b&#34;}, []int{1, 2})&#xA;// []Tuple2[string, int]{{A: &#34;a&#34;, B: 1}, {A: &#34;b&#34;, B: 2}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unzip2 -&amp;gt; Unzip9&lt;/h3&gt; &#xA;&lt;p&gt;Unzip accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a, b := lo.Unzip2[string, int]([]Tuple2[string, int]{{A: &#34;a&#34;, B: 1}, {A: &#34;b&#34;, B: 2}})&#xA;// []string{&#34;a&#34;, &#34;b&#34;}&#xA;// []int{1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Every&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if all elements of a subset are contained into a collection or if the subset is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Every[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// true&#xA;&#xA;ok := lo.Every[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;EveryBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate returns true for all of the elements in the collection or if the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := EveryBy[int]([]int{1, 2, 3, 4}, func(x int) bool {&#xA;    return x &amp;lt; 5&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Some&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if at least 1 element of a subset is contained into a collection. If the subset is empty Some returns false.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Some[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// true&#xA;&#xA;ok := lo.Some[int]([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SomeBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate returns true for any of the elements in the collection. If the collection is empty SomeBy returns false.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := SomeBy[int]([]int{1, 2, 3, 4}, func(x int) bool {&#xA;    return x &amp;lt; 3&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;None&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if no element of a subset are contained into a collection or if the subset is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := None[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// false&#xA;b := None[int]([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NoneBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate returns true for none of the elements in the collection or if the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := NoneBy[int]([]int{1, 2, 3, 4}, func(x int) bool {&#xA;    return x &amp;lt; 0&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Intersect&lt;/h3&gt; &#xA;&lt;p&gt;Returns the intersection between two collections.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result1 := lo.Intersect[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// []int{0, 2}&#xA;&#xA;result2 := lo.Intersect[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 6}&#xA;// []int{0}&#xA;&#xA;result3 := lo.Intersect[int]([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})&#xA;// []int{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Difference&lt;/h3&gt; &#xA;&lt;p&gt;Returns the difference between two collections.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first value is the collection of element absent of list2.&lt;/li&gt; &#xA; &lt;li&gt;The second value is the collection of element absent of list1.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;left, right := lo.Difference[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 2, 6})&#xA;// []int{1, 3, 4, 5}, []int{6}&#xA;&#xA;left, right := lo.Difference[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 1, 2, 3, 4, 5})&#xA;// []int{}, []int{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Union&lt;/h3&gt; &#xA;&lt;p&gt;Returns all distinct elements from both collections. Result will not change the order of elements relatively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;union := lo.Union[int]([]int{0, 1, 2, 3, 4, 5}, []int{0, 2, 10})&#xA;// []int{0, 1, 2, 3, 4, 5, 10}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;IndexOf&lt;/h3&gt; &#xA;&lt;p&gt;Returns the index at which the first occurrence of a value is found in an array or return -1 if the value cannot be found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;found := lo.IndexOf[int]([]int{0, 1, 2, 1, 2, 3}, 2)&#xA;// 2&#xA;&#xA;notFound := lo.IndexOf[int]([]int{0, 1, 2, 1, 2, 3}, 6)&#xA;// -1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LastIndex&lt;/h3&gt; &#xA;&lt;p&gt;Returns the index at which the last occurrence of a value is found in an array or return -1 if the value cannot be found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;found := lo.LastIndexOf[int]([]int{0, 1, 2, 1, 2, 3}, 2)&#xA;// 4&#xA;&#xA;notFound := lo.LastIndexOf[int]([]int{0, 1, 2, 1, 2, 3}, 6)&#xA;// -1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Find&lt;/h3&gt; &#xA;&lt;p&gt;Search an element in a slice based on a predicate. It returns element and true if element was found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, ok := lo.Find[string]([]string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;b&#34;, true&#xA;&#xA;str, ok := lo.Find[string]([]string{&#34;foobar&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;&#34;, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindIndexOf&lt;/h3&gt; &#xA;&lt;p&gt;FindIndexOf searches an element in a slice based on a predicate and returns the index and true. It returns -1 and false if the element is not found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, index, ok := lo.FindIndexOf[string]([]string{&#34;a&#34;, &#34;b&#34;, &#34;a&#34;, &#34;b&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;b&#34;, 1, true&#xA;&#xA;str, index, ok := lo.FindIndexOf[string]([]string{&#34;foobar&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;&#34;, -1, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindLastIndexOf&lt;/h3&gt; &#xA;&lt;p&gt;FindLastIndexOf searches an element in a slice based on a predicate and returns the index and true. It returns -1 and false if the element is not found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, index, ok := lo.FindLastIndexOf[string]([]string{&#34;a&#34;, &#34;b&#34;, &#34;a&#34;, &#34;b&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;b&#34;, 4, true&#xA;&#xA;str, index, ok := lo.FindLastIndexOf[string]([]string{&#34;foobar&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;&#34;, -1, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Min&lt;/h3&gt; &#xA;&lt;p&gt;Search the minimum value of a collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;min := lo.Min[int]([]int{1, 2, 3})&#xA;// 1&#xA;&#xA;min := lo.Min[int]([]int{})&#xA;// 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MinBy&lt;/h3&gt; &#xA;&lt;p&gt;Search the minimum value of a collection using the given comparison function. If several values of the collection are equal to the smallest value, returns the first such value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;min := lo.MinBy[string]([]string{&#34;s1&#34;, &#34;string2&#34;, &#34;s3&#34;}, func(item string, min string) bool {&#xA;    return len(item) &amp;lt; len(min)&#xA;})&#xA;// &#34;s1&#34;&#xA;&#xA;min := lo.MinBy[string]([]string{}, func(item string, min string) bool {&#xA;    return len(item) &amp;lt; len(min)&#xA;})&#xA;// &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Max&lt;/h3&gt; &#xA;&lt;p&gt;Search the maximum value of a collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;max := lo.Max[int]([]int{1, 2, 3})&#xA;// 3&#xA;&#xA;max := lo.Max[int]([]int{})&#xA;// 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MaxBy&lt;/h3&gt; &#xA;&lt;p&gt;Search the maximum value of a collection using the given comparison function. If several values of the collection are equal to the greatest value, returns the first such value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;max := lo.MaxBy[string]([]string{&#34;string1&#34;, &#34;s2&#34;, &#34;string3&#34;}, func(item string, max string) bool {&#xA;    return len(item) &amp;gt; len(max)&#xA;})&#xA;// &#34;string1&#34;&#xA;&#xA;max := lo.MaxBy[string]([]string{}, func(item string, max string) bool {&#xA;    return len(item) &amp;gt; len(max)&#xA;})&#xA;// &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Last&lt;/h3&gt; &#xA;&lt;p&gt;Returns the last element of a collection or error if empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;last, err := lo.Last[int]([]int{1, 2, 3})&#xA;// 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nth&lt;/h3&gt; &#xA;&lt;p&gt;Returns the element at index &lt;code&gt;nth&lt;/code&gt; of collection. If &lt;code&gt;nth&lt;/code&gt; is negative, the nth element from the end is returned. An error is returned when nth is out of slice bounds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;nth, err := lo.Nth[int]([]int{0, 1, 2, 3}, 2)&#xA;// 2&#xA;&#xA;nth, err := lo.Nth[int]([]int{0, 1, 2, 3}, -2)&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sample&lt;/h3&gt; &#xA;&lt;p&gt;Returns a random item from collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Sample[string]([]string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;})&#xA;// a random string from []string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;}&#xA;&#xA;lo.Sample[string]([]string{})&#xA;// &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Samples&lt;/h3&gt; &#xA;&lt;p&gt;Returns N random unique items from collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Samples[string]([]string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;}, 3)&#xA;// []string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;} in random order&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ternary&lt;/h3&gt; &#xA;&lt;p&gt;A 1 line if/else statement.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Ternary[string](true, &#34;a&#34;, &#34;b&#34;)&#xA;// &#34;a&#34;&#xA;&#xA;result := lo.Ternary[string](false, &#34;a&#34;, &#34;b&#34;)&#xA;// &#34;b&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;If / ElseIf / Else&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.If[int](true, 1).&#xA;    ElseIf(false, 2).&#xA;    Else(3)&#xA;// 1&#xA;&#xA;result := lo.If[int](false, 1).&#xA;    ElseIf(true, 2).&#xA;    Else(3)&#xA;// 2&#xA;&#xA;result := lo.If[int](false, 1).&#xA;    ElseIf(false, 2).&#xA;    Else(3)&#xA;// 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using callbacks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.IfF[int](true, func () int {&#xA;        return 1&#xA;    }).&#xA;    ElseIfF(false, func () int {&#xA;        return 2&#xA;    }).&#xA;    ElseF(func () int {&#xA;        return 3&#xA;    })&#xA;// 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mixed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.IfF[int](true, func () int {&#xA;        return 1&#xA;    }).&#xA;    Else(42)&#xA;// 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Switch / Case / Default&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Switch[int, string](1).&#xA;    Case(1, &#34;1&#34;).&#xA;    Case(2, &#34;2&#34;).&#xA;    Default(&#34;3&#34;)&#xA;// &#34;1&#34;&#xA;&#xA;result := lo.Switch[int, string](2).&#xA;    Case(1, &#34;1&#34;).&#xA;    Case(2, &#34;2&#34;).&#xA;    Default(&#34;3&#34;)&#xA;// &#34;2&#34;&#xA;&#xA;result := lo.Switch[int, string](42).&#xA;    Case(1, &#34;1&#34;).&#xA;    Case(2, &#34;2&#34;).&#xA;    Default(&#34;3&#34;)&#xA;// &#34;3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using callbacks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Switch[int, string](1).&#xA;    CaseF(1, func() string {&#xA;        return &#34;1&#34;&#xA;    }).&#xA;    CaseF(2, func() string {&#xA;        return &#34;2&#34;&#xA;    }).&#xA;    DefaultF(func() string {&#xA;        return &#34;3&#34;&#xA;    })&#xA;// &#34;1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mixed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Switch[int, string](1).&#xA;    CaseF(1, func() string {&#xA;        return &#34;1&#34;&#xA;    }).&#xA;    Default(&#34;42&#34;)&#xA;// &#34;1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ToPtr&lt;/h3&gt; &#xA;&lt;p&gt;Returns a pointer copy of value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ptr := lo.ToPtr[string](&#34;hello world&#34;)&#xA;// *string{&#34;hello world&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ToSlicePtr&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice of pointer copy of value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ptr := lo.ToSlicePtr[string]([]string{&#34;hello&#34;, &#34;world&#34;})&#xA;// []*string{&#34;hello&#34;, &#34;world&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ToAnySlice&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice with all elements mapped to &lt;code&gt;any&lt;/code&gt; type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;elements := lo.ToAnySlice[int]([]int{1, 5, 1})&#xA;// []any{1, 5, 1}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FromAnySlice&lt;/h3&gt; &#xA;&lt;p&gt;Returns an &lt;code&gt;any&lt;/code&gt; slice with all elements mapped to a type. Returns false in case of type conversion failure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;elements, ok := lo.FromAnySlice[string]([]any{&#34;foobar&#34;, 42})&#xA;// []string{}, false&#xA;&#xA;elements, ok := lo.FromAnySlice[string]([]any{&#34;foobar&#34;, &#34;42&#34;})&#xA;// []string{&#34;foobar&#34;, &#34;42&#34;}, true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Empty&lt;/h3&gt; &#xA;&lt;p&gt;Returns an empty value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Empty[int]()&#xA;// 0&#xA;lo.Empty[string]()&#xA;// &#34;&#34;&#xA;lo.Empty[bool]()&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Coalesce&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first non-empty arguments. Arguments must be comparable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result, ok := lo.Coalesce(0, 1, 2, 3)&#xA;// 1 true&#xA;&#xA;result, ok := lo.Coalesce(&#34;&#34;)&#xA;// &#34;&#34; false&#xA;&#xA;var nilStr *string&#xA;str := &#34;foobar&#34;&#xA;result, ok := lo.Coalesce[*string](nil, nilStr, &amp;amp;str)&#xA;// &amp;amp;&#34;foobar&#34; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Attempt&lt;/h3&gt; &#xA;&lt;p&gt;Invokes a function N times until it returns valid output. Returning either the caught error or nil. When first argument is less than &lt;code&gt;1&lt;/code&gt;, the function runs until a sucessfull response is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;iter, err := lo.Attempt(42, func(i int) error {&#xA;    if i == 5 {&#xA;        return nil&#xA;    }&#xA;&#xA;    return fmt.Errorf(&#34;failed&#34;)&#xA;})&#xA;// 6&#xA;// nil&#xA;&#xA;iter, err := lo.Attempt(2, func(i int) error {&#xA;    if i == 5 {&#xA;        return nil&#xA;    }&#xA;&#xA;    return fmt.Errorf(&#34;failed&#34;)&#xA;})&#xA;// 2&#xA;// error &#34;failed&#34;&#xA;&#xA;iter, err := lo.Attempt(0, func(i int) error {&#xA;    if i &amp;lt; 42 {&#xA;        return fmt.Errorf(&#34;failed&#34;)&#xA;    }&#xA;&#xA;    return nil&#xA;})&#xA;// 43&#xA;// nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced retry strategies (delay, exponential backoff...), please take a look on &lt;a href=&#34;https://github.com/cenkalti/backoff&#34;&gt;cenkalti/backoff&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;AttemptWithDelay&lt;/h3&gt; &#xA;&lt;p&gt;Invokes a function N times until it returns valid output, with a pause betwwen each call. Returning either the caught error or nil.&lt;/p&gt; &#xA;&lt;p&gt;When first argument is less than &lt;code&gt;1&lt;/code&gt;, the function runs until a sucessfull response is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;iter, duration, err := lo.AttemptWithDelay(5, 2*time.Second, func(i int, duration time.Duration) error {&#xA;    if i == 2 {&#xA;        return nil&#xA;    }&#xA;&#xA;    return fmt.Errorf(&#34;failed&#34;)&#xA;})&#xA;// 3&#xA;// ~ 4 seconds&#xA;// nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced retry strategies (delay, exponential backoff...), please take a look on &lt;a href=&#34;https://github.com/cenkalti/backoff&#34;&gt;cenkalti/backoff&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Debounce&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;NewDebounce&lt;/code&gt; creates a debounced instance that delays invoking functions given until after wait milliseconds have elapsed, until &lt;code&gt;cancel&lt;/code&gt; is called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f := func() {&#xA;    println(&#34;Called once after 100ms when debounce stopped invoking!&#34;)&#xA;}&#xA;&#xA;debounce, cancel := lo.NewDebounce(100 * time.Millisecond, f)&#xA;for j := 0; j &amp;lt; 10; j++ {&#xA;    debounce()&#xA;}&#xA;&#xA;time.Sleep(1 * time.Second)&#xA;cancel()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Synchronize&lt;/h3&gt; &#xA;&lt;p&gt;Wraps the underlying callback in a mutex. It receives an optional mutex.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := lo.Synchronize()&#xA;&#xA;for i := 0; i &amp;lt; 10; i++ {&#xA;    go s.Do(func () {&#xA;        println(&#34;will be called sequentially&#34;)&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is equivalent to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;mu := sync.Mutex{}&#xA;&#xA;func foobar() {&#xA;    mu.Lock()&#xA;    defer mu.Unlock()&#xA;&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Async&lt;/h3&gt; &#xA;&lt;p&gt;Executes a function in a goroutine and returns the result in a channel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := lo.Async(func() error { time.Sleep(10 * time.Second); return nil })&#xA;// chan error (nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Async{0-&amp;gt;6}&lt;/h3&gt; &#xA;&lt;p&gt;Executes a function in a goroutine and returns the result in a channel. For function with multiple return values, the results will be returned as a tuple inside the channel. For function without return, struct{} will be returned in the channel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := lo.Async0(func() { time.Sleep(10 * time.Second) })&#xA;// chan struct{}&#xA;&#xA;ch := lo.Async1(func() int {&#xA;  time.Sleep(10 * time.Second);&#xA;  return 42&#xA;})&#xA;// chan int (42)&#xA;&#xA;ch := lo.Async2(func() (int, string) {&#xA;  time.Sleep(10 * time.Second);&#xA;  return 42, &#34;Hello&#34;&#xA;})&#xA;// chan lo.Tuple2[int, string] ({42, &#34;Hello&#34;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Must&lt;/h3&gt; &#xA;&lt;p&gt;Wraps a function call to panics if second argument is &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, returns the value otherwise.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;val := lo.Must(time.Parse(&#34;2006-01-02&#34;, &#34;2022-01-15&#34;))&#xA;// 2022-01-15&#xA;&#xA;val := lo.Must(time.Parse(&#34;2006-01-02&#34;, &#34;bad-value&#34;))&#xA;// panics&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Must{0-&amp;gt;6}&lt;/h3&gt; &#xA;&lt;p&gt;Must* has the same behavior than Must, but returns multiple values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func example0() (error)&#xA;func example1() (int, error)&#xA;func example2() (int, string, error)&#xA;func example3() (int, string, time.Date, error)&#xA;func example4() (int, string, time.Date, bool, error)&#xA;func example5() (int, string, time.Date, bool, float64, error)&#xA;func example6() (int, string, time.Date, bool, float64, byte, error)&#xA;&#xA;lo.Must0(example0())&#xA;val1 := lo.Must1(example1())    // alias to Must&#xA;val1, val2 := lo.Must2(example2())&#xA;val1, val2, val3 := lo.Must3(example3())&#xA;val1, val2, val3, val4 := lo.Must4(example4())&#xA;val1, val2, val3, val4, val5 := lo.Must5(example5())&#xA;val1, val2, val3, val4, val5, val6 := lo.Must6(example6())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can wrap functions like &lt;code&gt;func (...) (..., ok bool)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// math.Signbit(float64) bool&#xA;lo.Must0(math.Signbit(v))&#xA;&#xA;// bytes.Cut([]byte,[]byte) ([]byte, []byte, bool)&#xA;before, after := lo.Must2(bytes.Cut(s, sep))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Try&lt;/h2&gt; &#xA;&lt;p&gt;Calls the function and return false in case of error and on panic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Try(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;})&#xA;// false&#xA;&#xA;ok := lo.Try(func() error {&#xA;    return nil&#xA;})&#xA;// true&#xA;&#xA;ok := lo.Try(func() error {&#xA;    return fmt.Errorf(&#34;error&#34;)&#xA;})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Try{0-&amp;gt;6}&lt;/h2&gt; &#xA;&lt;p&gt;The same behavior than &lt;code&gt;Try&lt;/code&gt;, but callback returns 2 variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Try2(func() (string, error) {&#xA;    panic(&#34;error&#34;)&#xA;    return &#34;&#34;, nil&#xA;})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TryWithErrorValue&lt;/h2&gt; &#xA;&lt;p&gt;The same behavior than &lt;code&gt;Try&lt;/code&gt;, but also returns value passed to panic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err, ok := lo.TryWithErrorValue(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;})&#xA;// &#34;error&#34;, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TryCatch&lt;/h2&gt; &#xA;&lt;p&gt;The same behavior than &lt;code&gt;Try&lt;/code&gt;, but calls the catch function in case of error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;caught := false&#xA;&#xA;ok := lo.TryCatch(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;}, func() {&#xA;    caught = true&#xA;})&#xA;// false&#xA;// caught == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TryCatchWithErrorValue&lt;/h2&gt; &#xA;&lt;p&gt;The same behavior than &lt;code&gt;TryWithErrorValue&lt;/code&gt;, but calls the catch function in case of error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;caught := false&#xA;&#xA;ok := lo.TryCatchWithErrorValue(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;}, func(val any) {&#xA;    caught = val == &#34;error&#34;&#xA;})&#xA;// false&#xA;// caught == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🛩 Benchmark&lt;/h2&gt; &#xA;&lt;p&gt;We executed a simple benchmark with the a dead-simple &lt;code&gt;lo.Map&lt;/code&gt; loop:&lt;/p&gt; &#xA;&lt;p&gt;See the full implementation &lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/benchmark_test.go&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_ = lo.Map[int64](arr, func(x int64, i int) string {&#xA;    return strconv.FormatInt(x, 10)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here is a comparison between &lt;code&gt;lo.Map&lt;/code&gt;, &lt;code&gt;lop.Map&lt;/code&gt;, &lt;code&gt;go-funk&lt;/code&gt; library and a simple Go &lt;code&gt;for&lt;/code&gt; loop.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ go test -benchmem -bench ./...&#xA;goos: linux&#xA;goarch: amd64&#xA;pkg: github.com/samber/lo&#xA;cpu: Intel(R) Core(TM) i5-7267U CPU @ 3.10GHz&#xA;cpu: Intel(R) Core(TM) i7 CPU         920  @ 2.67GHz&#xA;BenchmarkMap/lo.Map-8         &#x9;       8&#x9; 132728237 ns/op&#x9;39998945 B/op&#x9; 1000002 allocs/op&#xA;BenchmarkMap/lop.Map-8        &#x9;       2&#x9; 503947830 ns/op&#x9;119999956 B/op&#x9; 3000007 allocs/op&#xA;BenchmarkMap/reflect-8        &#x9;       2&#x9; 826400560 ns/op&#x9;170326512 B/op&#x9; 4000042 allocs/op&#xA;BenchmarkMap/for-8            &#x9;       9&#x9; 126252954 ns/op&#x9;39998674 B/op&#x9; 1000001 allocs/op&#xA;PASS&#xA;ok  &#x9;github.com/samber/lo&#x9;6.657s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lo.Map&lt;/code&gt; is way faster (x7) than &lt;code&gt;go-funk&lt;/code&gt;, a relection-based Map implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lo.Map&lt;/code&gt; have the same allocation profile than &lt;code&gt;for&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lo.Map&lt;/code&gt; is 4% slower than &lt;code&gt;for&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lop.Map&lt;/code&gt; is slower than &lt;code&gt;lo.Map&lt;/code&gt; because it implies more memory allocation and locks. &lt;code&gt;lop.Map&lt;/code&gt; will be usefull for long-running callbacks, such as i/o bound processing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;for&lt;/code&gt; beats other implementations for memory and CPU.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;🤝 Contributing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ping me on twitter &lt;a href=&#34;https://twitter.com/samuelberthe&#34;&gt;@samuelberthe&lt;/a&gt; (DMs, mentions, whatever :))&lt;/li&gt; &#xA; &lt;li&gt;Fork the &lt;a href=&#34;https://github.com/samber/lo&#34;&gt;project&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fix &lt;a href=&#34;https://github.com/samber/lo/issues&#34;&gt;open issues&lt;/a&gt; or request new features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Don&#39;t hesitate ;)&lt;/p&gt; &#xA;&lt;h3&gt;Install go 1.18&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make go1.18beta1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your OS currently not default to Go 1.18, replace &lt;code&gt;BIN=go&lt;/code&gt; by &lt;code&gt;BIN=go1.18beta1&lt;/code&gt; in the Makefile.&lt;/p&gt; &#xA;&lt;h3&gt;With Docker&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose run --rm dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Without Docker&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install some dev dependencies&#xA;make tools&#xA;&#xA;# Run tests&#xA;make test&#xA;# or&#xA;make watch-test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;👤 Authors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Samuel Berthe&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;💫 Show your support&lt;/h2&gt; &#xA;&lt;p&gt;Give a ⭐️ if this project helped you!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.patreon.com/samber&#34;&gt;&lt;img src=&#34;https://c5.patreon.com/external/logo/become_a_patron_button.png&#34; alt=&#34;support us&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;📝 License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright © 2022 &lt;a href=&#34;https://github.com/samber&#34;&gt;Samuel Berthe&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This project is &lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/LICENSE&#34;&gt;MIT&lt;/a&gt; licensed.&lt;/p&gt;</summary>
  </entry>
</feed>