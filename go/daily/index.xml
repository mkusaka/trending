<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-29T01:24:02Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>anthdm/hollywood</title>
    <updated>2023-12-29T01:24:02Z</updated>
    <id>tag:github.com,2023-12-29:/anthdm/hollywood</id>
    <link href="https://github.com/anthdm/hollywood" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Blazingly fast and light-weight Actor engine written in Golang&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://goreportcard.com/report/github.com/anthdm/hollywood&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/anthdm/hollywood&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/anthdm/hollywood/actions/workflows/build.yml/badge.svg?branch=master&#34; alt=&#34;example workflow&#34;&gt; &lt;a href=&#34;https://discord.gg/gdwXmXYNTh&#34;&gt; &lt;img src=&#34;https://discordapp.com/api/guilds/1025692014903316490/widget.png?style=shield&#34; alt=&#34;Discord Shield&#34;&gt; &lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Blazingly fast, low latency actors for Golang&lt;/h1&gt; &#xA;&lt;p&gt;Hollywood is an ULTRA fast actor engine build for speed and low-latency applications. Think about game servers, advertising brokers, trading engines, etc... It can handle &lt;strong&gt;10 million messages in under 1 second&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What is the actor model?&lt;/h2&gt; &#xA;&lt;p&gt;The Actor Model is a computational model used to build highly concurrent and distributed systems. It was introduced by Carl Hewitt in 1973 as a way to handle complex systems in a more scalable and fault-tolerant manner.&lt;/p&gt; &#xA;&lt;p&gt;In the Actor Model, the basic building block is an actor, sometimes referred to as a receiver in Hollywood, which is an independent unit of computation that communicates with other actors by exchanging messages. Each actor has its own state and behavior, and can only communicate with other actors by sending messages. This message-passing paradigm allows for a highly decentralized and fault-tolerant system, as actors can continue to operate independently even if other actors fail or become unavailable.&lt;/p&gt; &#xA;&lt;p&gt;Actors can be organized into hierarchies, with higher-level actors supervising and coordinating lower-level actors. This allows for the creation of complex systems that can handle failures and errors in a graceful and predictable way.&lt;/p&gt; &#xA;&lt;p&gt;By using the Actor Model in your application, you can build highly scalable and fault-tolerant systems that can handle a large number of concurrent users and complex interactions.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;guaranteed message delivery on actor failure (buffer mechanism)&lt;/li&gt; &#xA; &lt;li&gt;fire &amp;amp; forget or request &amp;amp; response messaging, or both.&lt;/li&gt; &#xA; &lt;li&gt;High performance dRPC as the transport layer&lt;/li&gt; &#xA; &lt;li&gt;Optimized proto buffers without reflection&lt;/li&gt; &#xA; &lt;li&gt;lightweight and highly customizable&lt;/li&gt; &#xA; &lt;li&gt;cluster support [wip]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Benchmarks&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;make bench&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;spawned 10 engines&#xA;spawned 2000 actors per engine&#xA;Send storm starting, will send for 10s using 20 workers&#xA;Messages sent per second 3244217&#xA;..&#xA;Messages sent per second 3387478&#xA;Concurrent senders: 20 messages sent 35116641, messages received 35116641 - duration: 10s&#xA;messages per second: 3511664&#xA;deadletters: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get github.com/anthdm/hollywood/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Hollywood requires Golang version &lt;code&gt;1.21&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Quickstart&lt;/h1&gt; &#xA;&lt;p&gt;We recommend you start out by writing a few examples that run locally. Running locally is a bit simpler as the compiler is able to figure out the types used. When running remotely, you&#39;ll need to provide protobuffer definitions for the compiler.&lt;/p&gt; &#xA;&lt;h2&gt;Hello world.&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s go through a Hello world message. The complete example is available in the &lt;a href=&#34;https://raw.githubusercontent.com/anthdm/hollywood/master/examples/helloworld&#34;&gt;hello world&lt;/a&gt; folder. Let&#39;s start in main:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;engine, err := actor.NewEngine(nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates a new engine. The engine is the core of Hollywood. It&#39;s responsible for spawning actors, sending messages and handling the lifecycle of actors. If Hollywood fails to create the engine it&#39;ll return an error. For development you shouldn&#39;t use to pass any options to the engine so you can pass nil. We&#39;ll look at the options later.&lt;/p&gt; &#xA;&lt;p&gt;Next we&#39;ll need to create an actor. These are some times referred to as &lt;code&gt;Receivers&lt;/code&gt; after the interface they must implement. Let&#39;s create a new actor that will print a message when it receives a message.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;pid := engine.Spawn(newHelloer, &#34;hello&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will cause the engine to spawn an actor with the ID &#34;hello&#34;. The actor will be created by the provided function &lt;code&gt;newHelloer&lt;/code&gt;. Ids must be unique. It will return a pointer to a PID. A PID is a process identifier. It&#39;s a unique identifier for the actor. Most of the time you&#39;ll use the PID to send messages to the actor. Against remote systems you&#39;ll use the ID to send messages, but on local systems you&#39;ll mostly use the PID.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s look at the &lt;code&gt;newHelloer&lt;/code&gt; function and the actor it returns.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type helloer struct{}&#xA;&#xA;func newHelloer() actor.Receiver {&#xA;&#x9;return &amp;amp;helloer{}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Simple enough. The &lt;code&gt;newHelloer&lt;/code&gt; function returns a new actor. The actor is a struct that implements the actor.Receiver. Lets look at the &lt;code&gt;Receive&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type message struct {}&#xA;&#xA;func (h *helloer) Receive(ctx *actor.Context) {&#xA;&#x9;switch msg := ctx.Message().(type) {&#xA;&#x9;case actor.Initialized:&#xA;&#x9;&#x9;fmt.Println(&#34;helloer has initialized&#34;)&#xA;&#x9;case actor.Started:&#xA;&#x9;&#x9;fmt.Println(&#34;helloer has started&#34;)&#xA;&#x9;case actor.Stopped:&#xA;&#x9;&#x9;fmt.Println(&#34;helloer has stopped&#34;)&#xA;&#x9;case *message:&#xA;&#x9;&#x9;fmt.Println(&#34;hello world&#34;, msg.data)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can see we define a message struct. This is the message we&#39;ll send to the actor later. The Receive method also handles a few other messages. These lifecycle messages are sent by the engine to the actor, you&#39;ll use these to initialize your actor&lt;/p&gt; &#xA;&lt;p&gt;The engine passes an actor.Context to the &lt;code&gt;Receive&lt;/code&gt; method. This context contains the message, the PID of the sender and some other dependencies that you can use.&lt;/p&gt; &#xA;&lt;p&gt;Now, lets send a message to the actor. We&#39;ll send a &lt;code&gt;message&lt;/code&gt;, but you can send any type of message you want. The only requirement is that the actor must be able to handle the message. For messages to be able to cross the wire they must be serializable. For protobuf to be able to serialize the message it must be a pointer. Local messages can be of any type.&lt;/p&gt; &#xA;&lt;p&gt;Finally, lets send a message to the actor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;engine.Send(pid, &#34;hello world!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will send a message to the actor. Hollywood will route the message to the correct actor. The actor will then print a message to the console.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/anthdm/hollywood/master/examples/&#34;&gt;examples&lt;/a&gt;&lt;/strong&gt; folder is the best place to learn and explore Hollywood further.&lt;/p&gt; &#xA;&lt;h2&gt;Spawning actors&lt;/h2&gt; &#xA;&lt;p&gt;When you spawn an actor you&#39;ll need to provide a function that returns a new actor. As the actor is spawn there are a few tunable options you can provide.&lt;/p&gt; &#xA;&lt;h3&gt;With default configuration&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;e.Spawn(newFoo, &#34;myactorname&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Passing arguments to the constructor&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes you&#39;ll want to pass arguments to the actor constructor. This can be done by using a closure. There is an example of this in the &lt;a href=&#34;https://raw.githubusercontent.com/anthdm/hollywood/master/examples/request&#34;&gt;request example&lt;/a&gt;. Let&#39;s look at the code.&lt;/p&gt; &#xA;&lt;p&gt;The default constructor will look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func newNameResponder() actor.Receiver {&#xA;&#x9;return &amp;amp;nameResponder{name: &#34;noname&#34;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build a new actor with a name you can do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func newCustomNameResponder(name string) actor.Producer {&#xA;&#x9;return func() actor.Receiver {&#xA;&#x9;&#x9;return &amp;amp;nameResponder{name}&#xA;&#x9;}&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then spawn the actor with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;pid := engine.Spawn(newCustomNameResponder(&#34;anthony&#34;), &#34;name-responder&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;With custom configuration&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;e.Spawn(newFoo, &#34;myactorname&#34;,&#xA;&#x9;actor.WithMaxRestarts(4),&#xA;&#x9;&#x9;actor.WithInboxSize(1024 * 2),&#xA;&#x9;&#x9;actor.WithId(&#34;bar&#34;),&#xA;&#x9;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The options should be pretty self explanatory. You can set the maximum number of restarts, which tells the engine how many times the given actor should be restarted in case of panic, the size of the inbox, which sets a limit on how and unprocessed messages the inbox can hold before it will start to block.&lt;/p&gt; &#xA;&lt;h3&gt;As a stateless function&lt;/h3&gt; &#xA;&lt;p&gt;Actors without state can be spawned as a function, because its quick and simple.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;e.SpawnFunc(func(c *actor.Context) {&#xA;&#x9;switch msg := c.Message().(type) {&#xA;&#x9;case actor.Started:&#xA;&#x9;&#x9;fmt.Println(&#34;started&#34;)&#xA;&#x9;&#x9;_ = msg&#xA;&#x9;}&#xA;}, &#34;foo&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Remote actors&lt;/h2&gt; &#xA;&lt;p&gt;Actors can communicate with each other over the network with the Remote package. This works the same as local actors but &#34;over the wire&#34;. Hollywood supports serialization with protobuf.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;remote.New() takes a remote.Config struct. This struct contains the following fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ListenAddr string&lt;/li&gt; &#xA; &lt;li&gt;TlsConfig *tls.Config&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You&#39;ll instantiate a new remote with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var engine *actor.Engine&#xA;remote := remote.New(&#34;0.0.0.0:2222&#34;,&#xA;&#x9;&#x9;&amp;amp;remote.Config{TlsConfig: &amp;amp;tls.Config{&#xA;&#x9;&#x9;&#x9;Certificates: []tls.Certificate{cert},&#xA;&#x9;&#x9;},&#xA;&#x9;}&#x9;&#x9;&#xA;})&#xA;var err error&#xA;engine, err = actor.NewEngine(actor.EngineOptRemote(remote))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Look at the &lt;a href=&#34;https://raw.githubusercontent.com/anthdm/hollywood/master/examples/remote&#34;&gt;Remote actor examples&lt;/a&gt; and the &lt;a href=&#34;https://raw.githubusercontent.com/anthdm/hollywood/master/examples/chat&#34;&gt;Chat client &amp;amp; Server&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Eventstream&lt;/h2&gt; &#xA;&lt;p&gt;In a production system thing will eventually go wrong. Actors will crash, machines will fail, messages will end up in the deadletter queue. You can build software that can handle these events in a graceful and predictable way by using the event stream.&lt;/p&gt; &#xA;&lt;p&gt;The Eventstream is a powerful abstraction that allows you to build flexible and pluggable systems without dependencies.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Subscribe any actor to a various list of system events&lt;/li&gt; &#xA; &lt;li&gt;Broadcast your custom events to all subscribers&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note that events that are not handled by any actor will be dropped. You should have an actor subscribed to the event stream in order to receive events. As a bare minimum, you&#39;ll want to handle &lt;code&gt;DeadLetterEvent&lt;/code&gt;. If Hollywood fails to deliver a message to an actor it will send a &lt;code&gt;DeadLetterEvent&lt;/code&gt; to the event stream.&lt;/p&gt; &#xA;&lt;p&gt;Any event that fulfills the &lt;code&gt;actor.LogEvent&lt;/code&gt; interface will be logged to the default logger, with the severity level, message and the attributes of the event set by the &lt;code&gt;actor.LogEvent&lt;/code&gt; &lt;code&gt;log()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;h3&gt;List of internal system events&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;actor.ActorStartedEvent&lt;/code&gt;, an actor has started&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;actor.ActorStoppedEvent&lt;/code&gt;, an actor has stopped&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;actor.DeadLetterEvent&lt;/code&gt;, a message was not delivered to an actor&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;actor.ActorRestartedEvent&lt;/code&gt;, an actor has restarted after a crash/panic.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;actor.RemoteUnreachableEvent&lt;/code&gt;, sending a message over the wire to a remote that is not reachable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster.MemberJoinEvent&lt;/code&gt;, a new member joins the cluster&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster.MemberLeaveEvent&lt;/code&gt;, a new member left the cluster&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster.ActivationEvent&lt;/code&gt;, a new actor is activated on the cluster&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster.DeactivationEvent&lt;/code&gt;, an actor is deactivated on the cluster&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Eventstream example&lt;/h3&gt; &#xA;&lt;p&gt;There is a &lt;a href=&#34;https://raw.githubusercontent.com/anthdm/hollywood/master/examples/eventstream-monitor&#34;&gt;eventstream monitoring example&lt;/a&gt; which shows you how to use the event stream. It features two actors, one is unstable and will crash every second. The other actor is subscribed to the event stream and maintains a few counters for different events such as crashes, etc.&lt;/p&gt; &#xA;&lt;p&gt;The application will run for a few seconds and the poison the unstable actor. It&#39;ll then query the monitor with a request. As actors are floating around inside the engine, this is the way you interact with them. main will then print the result of the query and the application will exit.&lt;/p&gt; &#xA;&lt;h2&gt;Customizing the Engine&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re using the function option pattern. All function options are in the actor package and start their name with &#34;EngineOpt&#34;. Currently, the only option is to provide a remote. This is done by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := remote.New(remote.Config{ListenAddr: addr})&#xA;engine, err := actor.NewEngine(actor.EngineOptRemote(r))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;addr is a string with the format &#34;host:port&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Middleware&lt;/h2&gt; &#xA;&lt;p&gt;You can add custom middleware to your Receivers. This can be useful for storing metrics, saving and loading data for your Receivers on &lt;code&gt;actor.Started&lt;/code&gt; and &lt;code&gt;actor.Stopped&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For examples on how to implement custom middleware, check out the middleware folder in the &lt;em&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/anthdm/hollywood/master/examples/middleware&#34;&gt;examples&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Logging&lt;/h2&gt; &#xA;&lt;p&gt;Hollywood has some built in logging. It will use the default logger from the &lt;code&gt;log/slog&lt;/code&gt; package. You can configure the logger to your liking by setting the default logger using &lt;code&gt;slog.SetDefaultLogger()&lt;/code&gt;. This will allow you to customize the log level, format and output. Please see the &lt;code&gt;slog&lt;/code&gt; package for more information.&lt;/p&gt; &#xA;&lt;p&gt;Note that some events might be logged to the default logger, such as &lt;code&gt;DeadLetterEvent&lt;/code&gt; and &lt;code&gt;ActorStartedEvent&lt;/code&gt; as these events fulfill the &lt;code&gt;actor.LogEvent&lt;/code&gt; interface. See the Eventstream section above for more information.&lt;/p&gt; &#xA;&lt;h1&gt;Test&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Community and discussions&lt;/h1&gt; &#xA;&lt;p&gt;Join our Discord community with over 2000 members for questions and a nice chat. &lt;br&gt; &lt;a href=&#34;https://discord.gg/gdwXmXYNTh&#34;&gt; &lt;img src=&#34;https://discordapp.com/api/guilds/1025692014903316490/widget.png?style=banner2&#34; alt=&#34;Discord Banner&#34;&gt; &lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Used in Production By&lt;/h1&gt; &#xA;&lt;p&gt;This project is currently used in production by the following organizations/projects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://sensora.io&#34;&gt;Sensora IoT&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Hollywood is licensed under the MIT licence.&lt;/p&gt;</summary>
  </entry>
</feed>