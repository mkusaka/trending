<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-14T01:28:40Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>letsencrypt/boulder</title>
    <updated>2023-09-14T01:28:40Z</updated>
    <id>tag:github.com,2023-09-14:/letsencrypt/boulder</id>
    <link href="https://github.com/letsencrypt/boulder" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An ACME-based certificate authority, written in Go.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Boulder - An ACME CA&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/letsencrypt/boulder/actions/workflows/boulder-ci.yml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/letsencrypt/boulder/actions/workflows/boulder-ci.yml/badge.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is an implementation of an ACME-based CA. The &lt;a href=&#34;https://github.com/ietf-wg-acme/acme/&#34;&gt;ACME protocol&lt;/a&gt; allows the CA to automatically verify that an applicant for a certificate actually controls an identifier, and allows domain holders to issue and revoke certificates for their domains. Boulder is the software that runs &lt;a href=&#34;https://letsencrypt.org&#34;&gt;Let&#39;s Encrypt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#setting-up-boulder&#34;&gt;Setting up Boulder&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#development&#34;&gt;Development&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#working-with-certbot&#34;&gt;Working with Certbot&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#working-with-another-acme-client&#34;&gt;Working with another ACME Client&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#production&#34;&gt;Production&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/letsencrypt/boulder/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Boulder is divided into the following main components:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Web Front Ends (one per API version)&lt;/li&gt; &#xA; &lt;li&gt;Registration Authority&lt;/li&gt; &#xA; &lt;li&gt;Validation Authority&lt;/li&gt; &#xA; &lt;li&gt;Certificate Authority&lt;/li&gt; &#xA; &lt;li&gt;Storage Authority&lt;/li&gt; &#xA; &lt;li&gt;Publisher&lt;/li&gt; &#xA; &lt;li&gt;OCSP Responder&lt;/li&gt; &#xA; &lt;li&gt;CRL Updater&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This component model lets us separate the function of the CA by security context. The Web Front End, Validation Authority, OCSP Responder and Publisher need access to the Internet, which puts them at greater risk of compromise. The Registration Authority can live without Internet connectivity, but still needs to talk to the Web Front End and Validation Authority. The Certificate Authority need only receive instructions from the Registration Authority. All components talk to the SA for storage, so most lines indicating SA RPCs are not shown here.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;                            CA ---------&amp;gt; Publisher&#xA;                             ^&#xA;                             |&#xA;       Subscriber -&amp;gt; WFE --&amp;gt; RA --&amp;gt; SA --&amp;gt; MariaDB&#xA;                             |               ^&#xA;Subscriber server &amp;lt;- VA &amp;lt;----+               |&#xA;                                             |&#xA;          Browser -------------------&amp;gt; OCSP Responder&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Internally, the logic of the system is based around five types of objects: accounts, authorizations, challenges, orders and certificates, mapping directly to the resources of the same name in ACME. Requests from ACME clients result in new objects and changes to objects. The Storage Authority maintains persistent copies of the current set of objects.&lt;/p&gt; &#xA;&lt;p&gt;Boulder uses gRPC for inter-component communication. For components that you want to be remote, it is necessary to instantiate a &#34;client&#34; and &#34;server&#34; for that component. The client implements the component&#39;s Go interface, while the server has the actual logic for the component. A high level overview for this communication model can be found in the &lt;a href=&#34;https://www.grpc.io/docs/&#34;&gt;gRPC documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The full details of how the various ACME operations happen in Boulder are laid out in &lt;a href=&#34;https://github.com/letsencrypt/boulder/raw/main/docs/DESIGN.md&#34;&gt;DESIGN.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setting up Boulder&lt;/h2&gt; &#xA;&lt;h3&gt;Development&lt;/h3&gt; &#xA;&lt;p&gt;Boulder has a Dockerfile and uses Docker Compose to make it easy to install and set up all its dependencies. This is how the maintainers work on Boulder, and is our main recommended way to run it for development/experimentation. It is not suitable for use as a production environment.&lt;/p&gt; &#xA;&lt;p&gt;While we aim to make Boulder easy to setup ACME client developers may find &lt;a href=&#34;https://github.com/letsencrypt/pebble&#34;&gt;Pebble&lt;/a&gt;, a miniature version of Boulder, to be better suited for continuous integration and quick experimentation.&lt;/p&gt; &#xA;&lt;p&gt;We recommend setting git&#39;s &lt;a href=&#34;https://groups.google.com/forum/#!topic/binary-transparency/f-BI4o8HZW0/discussion&#34;&gt;fsckObjects setting&lt;/a&gt; before getting a copy of Boulder to have better integrity guarantees for updates.&lt;/p&gt; &#xA;&lt;p&gt;Clone the boulder repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/letsencrypt/boulder/&#xA;cd boulder&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, make sure you have Docker Engine 1.13.0+ and Docker Compose 1.10.0+ installed. If you do not, you can follow Docker&#39;s &lt;a href=&#34;https://docs.docker.com/compose/install/&#34;&gt;installation instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We recommend having &lt;strong&gt;at least 2GB of RAM&lt;/strong&gt; available on your Docker host. In practice using less RAM may result in the MariaDB container failing in non-obvious ways.&lt;/p&gt; &#xA;&lt;p&gt;To start Boulder in a Docker container, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose up&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run our standard battery of tests (lints, unit, integration):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder ./test.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run all unit tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder ./test.sh --unit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run specific unit tests (example is of the ./va directory):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder ./test.sh --unit --filter=./va&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run all integration tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder ./test.sh --integration&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run specific integration tests (example runs TestAkamaiPurgerDrainQueueFails and TestWFECORS):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder ./test.sh --filter TestAkamaiPurgerDrainQueueFails/TestWFECORS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get a list of available integration tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder ./test.sh --list-integration-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The configuration in docker-compose.yml mounts your boulder checkout at /boulder so you can edit code on your host and it will be immediately reflected inside the Docker containers run with &lt;code&gt;docker compose&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have problems with Docker, you may want to try &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-remove-docker-images-containers-and-volumes&#34;&gt;removing all containers and volumes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, Boulder uses a fake DNS resolver that resolves all hostnames to 127.0.0.1. This is suitable for running integration tests inside the Docker container. If you want Boulder to be able to communicate with a client running on your host instead, you should find your host&#39;s Docker IP with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ifconfig docker0 | grep &#34;inet addr:&#34; | cut -d: -f2 | awk &#39;{ print $1}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And edit docker-compose.yml to change the &lt;code&gt;FAKE_DNS&lt;/code&gt; environment variable to match. This will cause Boulder&#39;s stubbed-out DNS resolver (&lt;code&gt;sd-test-srv&lt;/code&gt;) to respond to all A queries with the address in &lt;code&gt;FAKE_DNS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you use a host-based firewall (e.g. &lt;code&gt;ufw&lt;/code&gt; or &lt;code&gt;iptables&lt;/code&gt;) make sure you allow connections from the Docker instance to your host on the required validation ports to your ACME client.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can override the docker-compose.yml default with an environmental variable using -e (replace 172.17.0.1 with the host IPv4 address found in the command above)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases -e FAKE_DNS=172.17.0.1 --service-ports boulder ./start.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running tests without the &lt;code&gt;./test.sh&lt;/code&gt; wrapper:&lt;/p&gt; &#xA;&lt;p&gt;Run all unit tests&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder go test -p 1 ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run unit tests for a specific directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder go test &amp;lt;DIRECTORY&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run integration tests (omit &lt;code&gt;--filter &amp;lt;REGEX&amp;gt;&lt;/code&gt; to run all):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose run --use-aliases boulder python3 test/integration-test.py --chisel --gotest --filter &amp;lt;REGEX&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Working with Certbot&lt;/h3&gt; &#xA;&lt;p&gt;Check out the Certbot client from &lt;a href=&#34;https://github.com/certbot/certbot&#34;&gt;https://github.com/certbot/certbot&lt;/a&gt; and follow their setup instructions. Once you&#39;ve got the client set up, you&#39;ll probably want to run it against your local Boulder. There are a number of command line flags that are necessary to run the client against a local Boulder, and without root access. The simplest way to run the client locally is to use a convenient alias for certbot (&lt;code&gt;certbot_test&lt;/code&gt;) with a custom &lt;code&gt;SERVER&lt;/code&gt; environment variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;SERVER=http://localhost:4001/directory certbot_test certonly --standalone -d test.example.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Your local Boulder instance uses a fake DNS resolver that returns 127.0.0.1 for any query, so you can use any value for the -d flag. To return an answer other than &lt;code&gt;127.0.0.1&lt;/code&gt; change the Boulder &lt;code&gt;FAKE_DNS&lt;/code&gt; environment variable to another IP address.&lt;/p&gt; &#xA;&lt;h3&gt;Working with another ACME Client&lt;/h3&gt; &#xA;&lt;p&gt;Once you have followed the Boulder development environment instructions and have started the containers you will find the ACME endpoints exposed to your host at the following URLs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ACME v2, HTTP: &lt;code&gt;http://localhost:4001/directory&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;ACME v2, HTTPS: &lt;code&gt;https://localhost:4431/directory&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To access the HTTPS versions of the endpoints you will need to configure your ACME client software to use a CA truststore that contains the &lt;code&gt;test/wfe-tls/minica.pem&lt;/code&gt; CA certificate. See &lt;a href=&#34;https://github.com/letsencrypt/boulder/raw/main/test/PKI.md&#34;&gt;&lt;code&gt;test/PKI.md&lt;/code&gt;&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;Your local Boulder instance uses a fake DNS resolver that returns 127.0.0.1 for any query, allowing you to issue certificates for any domain as if it resolved to your localhost. To return an answer other than &lt;code&gt;127.0.0.1&lt;/code&gt; change the Boulder &lt;code&gt;FAKE_DNS&lt;/code&gt; environment variable to another IP address.&lt;/p&gt; &#xA;&lt;p&gt;Most often you will want to configure &lt;code&gt;FAKE_DNS&lt;/code&gt; to point to your host machine where you run an ACME client.&lt;/p&gt; &#xA;&lt;h3&gt;Production&lt;/h3&gt; &#xA;&lt;p&gt;Boulder is custom built for Let&#39;s Encrypt and is intended only to support the Web PKI and the CA/Browser forum&#39;s baseline requirements. In our experience often Boulder is not the right fit for organizations that are evaluating it for production usage. In most cases a centrally managed PKI that doesn&#39;t require domain-authorization with ACME is a better choice. For this environment we recommend evaluating a project other than Boulder.&lt;/p&gt; &#xA;&lt;p&gt;We offer a brief &lt;a href=&#34;https://github.com/letsencrypt/boulder/wiki/Deployment-&amp;amp;-Implementation-Guide&#34;&gt;deployment and implementation guide&lt;/a&gt; that describes some of the required work and security considerations involved in using Boulder in a production environment. As-is the docker based Boulder development environment is &lt;strong&gt;not suitable for production usage&lt;/strong&gt;. It uses private key material that is publicly available, exposes debug ports and is brittle to component failure.&lt;/p&gt; &#xA;&lt;p&gt;While we are supportive of other organization&#39;s deploying Boulder in a production setting we prioritize support and development work that favors Let&#39;s Encrypt&#39;s mission. This means we may not be able to provide timely support or accept pull-requests that deviate significantly from our first line goals. If you&#39;ve thoroughly evaluated the alternatives and Boulder is definitely the best fit we&#39;re happy to answer questions to the best of our ability.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please take a look at &lt;a href=&#34;https://github.com/letsencrypt/boulder/raw/main/docs/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for our guidelines on submitting patches, code review process, code of conduct, and various other tips related to working on the codebase.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;The code of conduct for everyone participating in this community in any capacity is available for reference &lt;a href=&#34;https://community.letsencrypt.org/guidelines&#34;&gt;on the community forum&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the Mozilla Public License 2.0, the full text of which can be found in the &lt;a href=&#34;https://github.com/letsencrypt/boulder/raw/main/LICENSE.txt&#34;&gt;LICENSE.txt&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
</feed>