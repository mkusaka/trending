<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-19T01:36:00Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>darkr4y/geacon</title>
    <updated>2023-05-19T01:36:00Z</updated>
    <id>tag:github.com,2023-05-19:/darkr4y/geacon</id>
    <link href="https://github.com/darkr4y/geacon" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Practice Go programming and implement CobaltStrike&#39;s Beacon in Go&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Geacon&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using Go to implement CobaltStrike&#39;s Beacon&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;em&gt;This project is for learning protocol analysis and reverse engineering only, if someone&#39;s rights have been violated, please contact me to remove the project, and the last DO NOT USE IT ILLEGALLY&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to play&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Setup the teamserver and start a http lisenter, the teamserver will generate the file &lt;code&gt;.cobaltstrike.beacon_keys&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Compile the BeaconTool with Jetbrains Idea, use command &lt;code&gt;java -jar BeaconTool.jar &lt;/code&gt; to convert java keystore to PEM format.&lt;/li&gt; &#xA; &lt;li&gt;Replace the RSA key pair in the file &lt;code&gt;cmd/config/config.go&lt;/code&gt; (the RSA private key is not required, I wrote it in the code just for the record)&lt;/li&gt; &#xA; &lt;li&gt;Compile the geacon whatever platform you want to run: for example, use the command &lt;code&gt;export GOOS=&#34;darwin&#34; &amp;amp;&amp;amp; export GOARCH=&#34;amd64&#34; &amp;amp;&amp;amp; go build cmd/main.go&lt;/code&gt; to compile an executable binary running on MacOS.&lt;/li&gt; &#xA; &lt;li&gt;Having fun ! PR and issue is welcome ;)&lt;/li&gt; &#xA; &lt;li&gt;Geacon has just been tested on CobaltStrike 3.14 and only support default c2profile, so many hardcode in the project and I will not try to implement more C2profile support at this moment.&lt;/li&gt; &#xA; &lt;li&gt;Thanks for &lt;strong&gt;&lt;a href=&#34;https://github.com/xxxxxyyyy&#34;&gt;@xxxxxyyyy&lt;/a&gt;&lt;/strong&gt;&#39;s PR, And now Geacon supports &lt;strong&gt;CobaltStrike 4.0&lt;/strong&gt;, please checkout the branch &lt;code&gt;4.0&lt;/code&gt; to compile.&lt;/li&gt; &#xA; &lt;li&gt;Geacon&#39;s branch &lt;code&gt;master&lt;/code&gt; supports &lt;strong&gt;CobaltStrike 4.1&lt;/strong&gt;, currently available functions include: executing commands, uploading, downloading, file browser, switching the current working directory, and exiting the current process.&lt;/li&gt; &#xA; &lt;li&gt;Geacon only focuses on protocol analysis, but if you want to experience more features, you can use another project of our partners, check out &lt;strong&gt;&lt;a href=&#34;https://github.com/gloxec/CrossC2&#34;&gt;CrossC2&lt;/a&gt;&lt;/strong&gt; now!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;p&gt;Get the Geacon&#39;s command execution results on Linux. &lt;img src=&#34;https://github.com/darkr4y/geacon/raw/master/screenshots/sc.png&#34; alt=&#34;login&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Protocol analysis&lt;/h2&gt; &#xA;&lt;p&gt;To be continued, I will update as soon as I have time ...&lt;/p&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;Support CobaltStrike 4.x&lt;/del&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fix the OS icon issue in session table&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;String encoding issue&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;_DarkRay@RedCore&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>redis/rueidis</title>
    <updated>2023-05-19T01:36:00Z</updated>
    <id>tag:github.com,2023-05-19:/redis/rueidis</id>
    <link href="https://github.com/redis/rueidis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast Golang Redis client that supports Client Side Caching, Auto Pipelining, Generics OM, RedisJSON, RedisBloom, RediSearch, etc.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rueidis&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/redis/rueidis&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/redis/rueidis.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dl.circleci.com/status-badge/redirect/gh/redis/rueidis/tree/main&#34;&gt;&lt;img src=&#34;https://dl.circleci.com/status-badge/img/gh/redis/rueidis/tree/main.svg?style=shield&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/redis/rueidis&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/redis/rueidis&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/redis/rueidis&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/redis/rueidis/branch/master/graph/badge.svg?token=wGTB8GdY06&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A fast Golang Redis client that does auto pipelining and supports client side caching.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://redis.io/docs/manual/pipelining/&#34;&gt;Auto pipelining for non-blocking redis commands&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://redis.io/docs/manual/client-side-caching/&#34;&gt;Client side caching in RESP3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Pub/Sub, Sharded Pub/Sub, Streams&lt;/li&gt; &#xA; &lt;li&gt;Redis Cluster, Sentinel, RedisJSON, RedisBloom, RediSearch, RedisTimeseries, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/rueidis/main/om&#34;&gt;Generic Object Mapping with client side caching and optimistic locking&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/rueidis/main/rueidislock&#34;&gt;Distributed Locks with client side caching&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/rueidis/main/mock&#34;&gt;Helpers for writing tests with rueidis mock&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/rueidis/main/rueidisotel&#34;&gt;OpenTelemetry integration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/rueidis/main/rueidishook&#34;&gt;Hooks and other integrations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/rueidis/main/rueidiscompat&#34;&gt;Go-redis like API adapter&lt;/a&gt; by &lt;a href=&#34;https://github.com/418Coffee&#34;&gt;@418Coffee&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;context&#34;&#xA;&#x9;&#34;github.com/redis/rueidis&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;client, err := rueidis.NewClient(rueidis.ClientOption{InitAddress: []string{&#34;127.0.0.1:6379&#34;}})&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer client.Close()&#xA;&#xA;&#x9;ctx := context.Background()&#xA;&#x9;// SET key val NX&#xA;&#x9;err = client.Do(ctx, client.B().Set().Key(&#34;key&#34;).Value(&#34;val&#34;).Nx().Build()).Error()&#xA;&#x9;// HGETALL hm&#xA;&#x9;hm, err := client.Do(ctx, client.B().Hgetall().Key(&#34;hm&#34;).Build()).AsStrMap()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Checkout more examples: &lt;a href=&#34;https://github.com/redis/rueidis#command-response-cheatsheet&#34;&gt;Command Response Cheatsheet&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Developer friendly Command Builder&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;client.B()&lt;/code&gt; is the builder entrypoint to construct a redis command:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/2727535/209358313-39000aee-eaa4-42e1-9748-0d3836c1264f.gif&#34; alt=&#34;Developer friendly command builder&#34;&gt;&lt;br&gt; &lt;sub&gt;&lt;em&gt;Recorded by @FZambia &lt;a href=&#34;https://centrifugal.dev/blog/2022/12/20/improving-redis-engine-performance&#34;&gt;Improving Centrifugo Redis Engine throughput and allocation efficiency with Rueidis Go library &lt;/a&gt;&lt;/em&gt;&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once a command is built, use either &lt;code&gt;client.Do()&lt;/code&gt; or &lt;code&gt;client.DoMulti()&lt;/code&gt; to send it to redis.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Constructed commands will be recycled to underlying &lt;code&gt;sync.Pool&lt;/code&gt; by default and you ❗️SHOULD NOT❗️ reuse them across multiple &lt;code&gt;client.Do()&lt;/code&gt; or &lt;code&gt;client.DoMulti()&lt;/code&gt; calls.&lt;/strong&gt; To reuse a command, use &lt;code&gt;Pin()&lt;/code&gt; after &lt;code&gt;Build()&lt;/code&gt; and it will prevent the command being recycled.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://redis.io/docs/manual/pipelining/&#34;&gt;Auto Pipelining&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;All concurrent non-blocking redis commands (such as &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;) are automatically pipelined through connections, which reduces the overall round trips and system calls, and gets higher throughput. You can easily get the benefit of &lt;a href=&#34;https://redis.io/docs/manual/pipelining/&#34;&gt;pipelining technique&lt;/a&gt; by just calling &lt;code&gt;client.Do()&lt;/code&gt; from multiple goroutines. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkPipelining(b *testing.B, client rueidis.Client) {&#xA;&#x9;// the below client.Do() operations will be issued from&#xA;&#x9;// multiple goroutines and thus will be pipelined automatically.&#xA;&#x9;b.RunParallel(func(pb *testing.PB) {&#xA;&#x9;&#x9;for pb.Next() {&#xA;&#x9;&#x9;&#x9;client.Do(context.Background(), client.B().Get().Key(&#34;k&#34;).Build()).ToString()&#xA;&#x9;&#x9;}&#xA;&#x9;})&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Benchmark comparison with go-redis v9&lt;/h3&gt; &#xA;&lt;p&gt;Comparing to go-redis, Rueidis has higher throughput across 1, 8, and 64 parallelism settings.&lt;/p&gt; &#xA;&lt;p&gt;It is even able to achieve ~14x throughput over go-redis in a local benchmark of Macbook Pro 16&#34; M1 Pro 2021. (see &lt;code&gt;parallelism(64)-key(16)-value(64)-10&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/rueian/rueidis-benchmark/raw/master/client_test_set_10.png&#34; alt=&#34;client_test_set&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Benchmark source code: &lt;a href=&#34;https://github.com/rueian/rueidis-benchmark&#34;&gt;https://github.com/rueian/rueidis-benchmark&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A benchmark result performed on two GCP n2-highcpu-2 machines also shows that rueidis can achieve higher throughput with lower latencies: &lt;a href=&#34;https://github.com/redis/rueidis/pull/93&#34;&gt;https://github.com/redis/rueidis/pull/93&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Pipelining Bulk Operations Manually&lt;/h3&gt; &#xA;&lt;p&gt;Though all concurrent non-blocking commands are automatically pipelined, you can still pipeline commands manually with &lt;code&gt;DoMulti()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;cmds := make(rueidis.Commands, 0, 10)&#xA;for i := 0; i &amp;lt; 10; i++ {&#xA;    cmds = append(cmds, client.B().Set().Key(&#34;key&#34;).Value(&#34;value&#34;).Build())&#xA;}&#xA;for _, resp := range client.DoMulti(ctx, cmds...) {&#xA;    if err := resp.Error(); err != nil {&#xA;        panic(err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://redis.io/docs/manual/client-side-caching/&#34;&gt;Client Side Caching&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The opt-in mode of &lt;a href=&#34;https://redis.io/docs/manual/client-side-caching/&#34;&gt;server-assisted client side caching&lt;/a&gt; is enabled by default, and can be used by calling &lt;code&gt;DoCache()&lt;/code&gt; or &lt;code&gt;DoMultiCache()&lt;/code&gt; with pairs of a readonly command and a client side TTL.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client.DoCache(ctx, client.B().Hmget().Key(&#34;myhash&#34;).Field(&#34;1&#34;, &#34;2&#34;).Cache(), time.Minute).ToArray()&#xA;client.DoMultiCache(ctx,&#xA;    rueidis.CT(client.B().Get().Key(&#34;k1&#34;).Cache(), 1*time.Minute),&#xA;    rueidis.CT(client.B().Get().Key(&#34;k2&#34;).Cache(), 2*time.Minute))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Cached responses will be invalidated when being notified by redis or their client side ttl is reached.&lt;/p&gt; &#xA;&lt;h3&gt;Benchmark&lt;/h3&gt; &#xA;&lt;p&gt;Client Side Caching can boost read throughput just like &lt;strong&gt;having a redis replica right inside your application&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/rueian/rueidis-benchmark/raw/master/client_test_get_10.png&#34; alt=&#34;client_test_get&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Benchmark source code: &lt;a href=&#34;https://github.com/rueian/rueidis-benchmark&#34;&gt;https://github.com/rueian/rueidis-benchmark&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Client Side Caching Helpers&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;CacheTTL()&lt;/code&gt; to check the remaining client side TTL in seconds:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client.DoCache(ctx, client.B().Get().Key(&#34;k1&#34;).Cache(), time.Minute).CacheTTL() == 60&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;IsCacheHit()&lt;/code&gt; to verify that if the response came from the client side memory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client.DoCache(ctx, client.B().Get().Key(&#34;k1&#34;).Cache(), time.Minute).IsCacheHit() == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the OpenTelemetry is enabled by the &lt;code&gt;rueidisotel.WithClient(client)&lt;/code&gt;, then there are also two metrics instrumented:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;rueidis_do_cache_miss&lt;/li&gt; &#xA; &lt;li&gt;rueidis_do_cache_hits&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;MGET/JSON.MGET Client Side Caching Helpers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;rueidis.MGetCache&lt;/code&gt; and &lt;code&gt;rueidis.JsonMGetCache&lt;/code&gt; are handy helpers fetching multiple keys across different slots through the client side caching. They will first group keys by slot to build &lt;code&gt;MGET&lt;/code&gt; or &lt;code&gt;JSON.MGET&lt;/code&gt; commands respectively and then send requests with only cache missed keys to redis nodes.&lt;/p&gt; &#xA;&lt;h3&gt;Broadcast Mode Client Side Caching&lt;/h3&gt; &#xA;&lt;p&gt;Although the default is opt-in mode, you can use broadcast mode by specifying your prefixes in &lt;code&gt;ClientOption.ClientTrackingOptions&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client, err := rueidis.NewClient(rueidis.ClientOption{&#xA;&#x9;InitAddress:           []string{&#34;127.0.0.1:6379&#34;},&#xA;&#x9;ClientTrackingOptions: []string{&#34;PREFIX&#34;, &#34;prefix1:&#34;, &#34;PREFIX&#34;, &#34;prefix2:&#34;, &#34;BCAST&#34;},&#xA;})&#xA;if err != nil {&#xA;&#x9;panic(err)&#xA;}&#xA;client.DoCache(ctx, client.B().Get().Key(&#34;prefix1:1&#34;).Cache(), time.Minute).IsCacheHit() == false&#xA;client.DoCache(ctx, client.B().Get().Key(&#34;prefix1:1&#34;).Cache(), time.Minute).IsCacheHit() == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please make sure that commands passed to &lt;code&gt;DoCache()&lt;/code&gt; and &lt;code&gt;DoMultiCache()&lt;/code&gt; are covered by your prefixes. Otherwise, their client-side cache will not be invalidated by redis.&lt;/p&gt; &#xA;&lt;h3&gt;Disable Client Side Caching&lt;/h3&gt; &#xA;&lt;p&gt;Some Redis provider doesn&#39;t support client-side caching, ex. Google Cloud Memorystore. You can disable client-side caching by setting &lt;code&gt;ClientOption.DisableCache&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. This will also fall back &lt;code&gt;client.DoCache()&lt;/code&gt; and &lt;code&gt;client.DoMultiCache()&lt;/code&gt; to &lt;code&gt;client.Do()&lt;/code&gt; and &lt;code&gt;client.DoMulti()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Context Cancellation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;client.Do()&lt;/code&gt;, &lt;code&gt;client.DoMulti()&lt;/code&gt;, &lt;code&gt;client.DoCache()&lt;/code&gt; and &lt;code&gt;client.DoMultiCache()&lt;/code&gt; can return early if the context is canceled or the deadline is reached.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;ctx, cancel := context.WithTimeout(context.Background(), time.Second)&#xA;defer cancel()&#xA;client.Do(ctx, client.B().Set().Key(&#34;key&#34;).Value(&#34;val&#34;).Nx().Build()).Error() == context.DeadlineExceeded&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that though operations can return early, the command is likely sent already.&lt;/p&gt; &#xA;&lt;h2&gt;Pub/Sub&lt;/h2&gt; &#xA;&lt;p&gt;To receive messages from channels, &lt;code&gt;client.Receive()&lt;/code&gt; should be used. It supports &lt;code&gt;SUBSCRIBE&lt;/code&gt;, &lt;code&gt;PSUBSCRIBE&lt;/code&gt; and Redis 7.0&#39;s &lt;code&gt;SSUBSCRIBE&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;err = client.Receive(context.Background(), client.B().Subscribe().Channel(&#34;ch1&#34;, &#34;ch2&#34;).Build(), func(msg rueidis.PubSubMessage) {&#xA;    // handle the msg&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The provided handler will be called with received message.&lt;/p&gt; &#xA;&lt;p&gt;It is important to note that &lt;code&gt;client.Receive()&lt;/code&gt; will keep blocking and return only when the following cases:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;return &lt;code&gt;nil&lt;/code&gt; when received any unsubscribe/punsubscribe message related to the provided &lt;code&gt;subscribe&lt;/code&gt; command.&lt;/li&gt; &#xA; &lt;li&gt;return &lt;code&gt;rueidis.ErrClosing&lt;/code&gt; when the client is closed manually.&lt;/li&gt; &#xA; &lt;li&gt;return &lt;code&gt;ctx.Err()&lt;/code&gt; when the &lt;code&gt;ctx&lt;/code&gt; is done.&lt;/li&gt; &#xA; &lt;li&gt;return non-nil &lt;code&gt;err&lt;/code&gt; when the provided &lt;code&gt;subscribe&lt;/code&gt; command failed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;While the &lt;code&gt;client.Receive()&lt;/code&gt; call is blocking, the &lt;code&gt;Client&lt;/code&gt; is still able to accept other concurrent requests, and they are sharing the same tcp connection. If your message handler may take some time to complete, it is recommended to use the &lt;code&gt;client.Receive()&lt;/code&gt; inside a &lt;code&gt;client.Dedicated()&lt;/code&gt; for not blocking other concurrent requests.&lt;/p&gt; &#xA;&lt;h3&gt;Alternative PubSub Hooks&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;client.Receive()&lt;/code&gt; requires users to provide a subscription command in advance. There is an alternative &lt;code&gt;Dedicatedclient.SetPubSubHooks()&lt;/code&gt; allows users to subscribe/unsubscribe channels later.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;c, cancel := client.Dedicate()&#xA;defer cancel()&#xA;&#xA;wait := c.SetPubSubHooks(rueidis.PubSubHooks{&#xA;&#x9;OnMessage: func(m rueidis.PubSubMessage) {&#xA;&#x9;&#x9;// Handle message. This callback will be called sequentially, but in another goroutine.&#xA;&#x9;}&#xA;})&#xA;c.Do(ctx, c.B().Subscribe().Channel(&#34;ch&#34;).Build())&#xA;err := &amp;lt;-wait // disconnected with err&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the hooks are not nil, the above &lt;code&gt;wait&lt;/code&gt; channel is guaranteed to be close when the hooks will not be called anymore, and produce at most one error describing the reason. Users can use this channel to detect disconnection.&lt;/p&gt; &#xA;&lt;h2&gt;CAS Pattern&lt;/h2&gt; &#xA;&lt;p&gt;To do a CAS operation (&lt;code&gt;WATCH&lt;/code&gt; + &lt;code&gt;MULTI&lt;/code&gt; + &lt;code&gt;EXEC&lt;/code&gt;), a dedicated connection should be used, because there should be no unintentional write commands between &lt;code&gt;WATCH&lt;/code&gt; and &lt;code&gt;EXEC&lt;/code&gt;. Otherwise, the &lt;code&gt;EXEC&lt;/code&gt; may not fail as expected.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client.Dedicated(func(c rueidis.DedicatedClient) error {&#xA;    // watch keys first&#xA;    c.Do(ctx, c.B().Watch().Key(&#34;k1&#34;, &#34;k2&#34;).Build())&#xA;    // perform read here&#xA;    c.Do(ctx, c.B().Mget().Key(&#34;k1&#34;, &#34;k2&#34;).Build())&#xA;    // perform write with MULTI EXEC&#xA;    c.DoMulti(&#xA;        ctx,&#xA;        c.B().Multi().Build(),&#xA;        c.B().Set().Key(&#34;k1&#34;).Value(&#34;1&#34;).Build(),&#xA;        c.B().Set().Key(&#34;k2&#34;).Value(&#34;2&#34;).Build(),&#xA;        c.B().Exec().Build(),&#xA;    )&#xA;    return nil&#xA;})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or use &lt;code&gt;Dedicate()&lt;/code&gt; and invoke &lt;code&gt;cancel()&lt;/code&gt; when finished to put the connection back to the pool.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;c, cancel := client.Dedicate()&#xA;defer cancel()&#xA;&#xA;c.Do(ctx, c.B().Watch().Key(&#34;k1&#34;, &#34;k2&#34;).Build())&#xA;// do the rest CAS operations with the `client` who occupying a connection &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, occupying a connection is not good in terms of throughput. It is better to use Lua script to perform optimistic locking instead.&lt;/p&gt; &#xA;&lt;h2&gt;Memory Consumption Consideration&lt;/h2&gt; &#xA;&lt;p&gt;Each underlying connection in rueidis allocates a ring buffer for pipelining. Its size is controlled by the &lt;code&gt;ClientOption.RingScaleEachConn&lt;/code&gt; and the default value is 10 which results into each ring of size 2^10.&lt;/p&gt; &#xA;&lt;p&gt;If you have many rueidis connections, you may find that they occupy quite amount of memory. In that case, you may consider reducing &lt;code&gt;ClientOption.RingScaleEachConn&lt;/code&gt; to 8 or 9 at the cost of potential throughput degradation.&lt;/p&gt; &#xA;&lt;h2&gt;Lua Script&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;NewLuaScript&lt;/code&gt; or &lt;code&gt;NewLuaScriptReadOnly&lt;/code&gt; will create a script which is safe for concurrent usage.&lt;/p&gt; &#xA;&lt;p&gt;When calling the &lt;code&gt;script.Exec&lt;/code&gt;, it will try sending &lt;code&gt;EVALSHA&lt;/code&gt; first and fallback to &lt;code&gt;EVAL&lt;/code&gt; if the server returns &lt;code&gt;NOSCRIPT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;script := rueidis.NewLuaScript(&#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34;)&#xA;// the script.Exec is safe for concurrent call&#xA;list, err := script.Exec(ctx, client, []string{&#34;k1&#34;, &#34;k2&#34;}, []string{&#34;a1&#34;, &#34;a2&#34;}).ToArray()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Redis Cluster, Single Redis and Sentinel&lt;/h2&gt; &#xA;&lt;p&gt;To connect to a redis cluster, the &lt;code&gt;NewClient&lt;/code&gt; should be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client, err := rueidis.NewClient(rueidis.ClientOption{&#xA;    InitAddress: []string{&#34;127.0.0.1:7001&#34;, &#34;127.0.0.1:7002&#34;, &#34;127.0.0.1:7003&#34;},&#xA;    ShuffleInit: true,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To connect to a single redis node, still use the &lt;code&gt;NewClient&lt;/code&gt; with one InitAddress&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client, err := rueidis.NewClient(rueidis.ClientOption{&#xA;    InitAddress: []string{&#34;127.0.0.1:6379&#34;},&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To connect to sentinels, specify the required master set name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client, err := rueidis.NewClient(rueidis.ClientOption{&#xA;    InitAddress: []string{&#34;127.0.0.1:26379&#34;, &#34;127.0.0.1:26380&#34;, &#34;127.0.0.1:26381&#34;},&#xA;    Sentinel: rueidis.SentinelOption{&#xA;        MasterSet: &#34;my_master&#34;,&#xA;    },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Arbitrary Command&lt;/h2&gt; &#xA;&lt;p&gt;If you want to construct commands that are absent from the command builder, you can use &lt;code&gt;client.B().Arbitrary()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// This will result into [ANY CMD k1 k2 a1 a2]&#xA;client.B().Arbitrary(&#34;ANY&#34;, &#34;CMD&#34;).Keys(&#34;k1&#34;, &#34;k2&#34;).Args(&#34;a1&#34;, &#34;a2&#34;).Build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Working with JSON, Raw &lt;code&gt;[]byte&lt;/code&gt;, and Vector Similarity Search&lt;/h2&gt; &#xA;&lt;p&gt;The command builder treats all the parameters as Redis strings, which are binary safe. This means that users can store &lt;code&gt;[]byte&lt;/code&gt; directly into Redis without conversion. And the &lt;code&gt;rueidis.BinaryString&lt;/code&gt; helper can convert &lt;code&gt;[]byte&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; without copy. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client.B().Set().Key(&#34;b&#34;).Value(rueidis.BinaryString([]byte{...})).Build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Treating all the parameters as Redis strings also means that the command builder doesn&#39;t do any quoting, conversion automatically for users.&lt;/p&gt; &#xA;&lt;p&gt;When working with RedisJSON, users frequently need to prepare JSON string in Redis string. And &lt;code&gt;rueidis.JSON&lt;/code&gt; can help:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;client.B().JsonSet().Key(&#34;j&#34;).Path(&#34;$.myStrField&#34;).Value(rueidis.JSON(&#34;str&#34;)).Build()&#xA;// equivalent to&#xA;client.B().JsonSet().Key(&#34;j&#34;).Path(&#34;$.myStrField&#34;).Value(`&#34;str&#34;`).Build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When working with vector similarity search, users can use &lt;code&gt;rueidis.VectorString32&lt;/code&gt; and &lt;code&gt;rueidis.VectorString64&lt;/code&gt; to build queries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;cmd := client.B().FtSearch().Index(&#34;idx&#34;).Query(&#34;*=&amp;gt;[KNN 5 @vec $V]&#34;).&#xA;    Params().Nargs(2).NameValue().NameValue(&#34;V&#34;, rueidis.VectorString64([]float64{...})).&#xA;    Dialect(2).Build()&#xA;n, resp, err := client.Do(ctx, cmd).AsFtSearch()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Command Response Cheatsheet&lt;/h2&gt; &#xA;&lt;p&gt;It is hard to remember what message type is returned from redis and which parsing method should be used with. So, here is some common examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// GET&#xA;client.Do(ctx, client.B().Get().Key(&#34;k&#34;).Build()).ToString()&#xA;client.Do(ctx, client.B().Get().Key(&#34;k&#34;).Build()).AsInt64()&#xA;// MGET&#xA;client.Do(ctx, client.B().Mget().Key(&#34;k1&#34;, &#34;k2&#34;).Build()).ToArray()&#xA;// SET&#xA;client.Do(ctx, client.B().Set().Key(&#34;k&#34;).Value(&#34;v&#34;).Build()).Error()&#xA;// INCR&#xA;client.Do(ctx, client.B().Incr().Key(&#34;k&#34;).Build()).AsInt64()&#xA;// HGET&#xA;client.Do(ctx, client.B().Hget().Key(&#34;k&#34;).Field(&#34;f&#34;).Build()).ToString()&#xA;// HMGET&#xA;client.Do(ctx, client.B().Hmget().Key(&#34;h&#34;).Field(&#34;a&#34;, &#34;b&#34;).Build()).ToArray()&#xA;// HGETALL&#xA;client.Do(ctx, client.B().Hgetall().Key(&#34;h&#34;).Build()).AsStrMap()&#xA;// ZRANGE&#xA;client.Do(ctx, client.B().Zrange().Key(&#34;k&#34;).Min(&#34;1&#34;).Max(&#34;2&#34;).Build()).AsStrSlice()&#xA;// ZRANK&#xA;client.Do(ctx, client.B().Zrank().Key(&#34;k&#34;).Member(&#34;m&#34;).Build()).AsInt64()&#xA;// ZSCORE&#xA;client.Do(ctx, client.B().Zscore().Key(&#34;k&#34;).Member(&#34;m&#34;).Build()).AsFloat64()&#xA;// ZRANGE&#xA;client.Do(ctx, client.B().Zrange().Key(&#34;k&#34;).Min(&#34;0&#34;).Max(&#34;-1&#34;).Build()).AsStrSlice()&#xA;client.Do(ctx, client.B().Zrange().Key(&#34;k&#34;).Min(&#34;0&#34;).Max(&#34;-1&#34;).Withscores().Build()).AsZScores()&#xA;// ZPOPMIN&#xA;client.Do(ctx, client.B().Zpopmin().Key(&#34;k&#34;).Build()).AsZScore()&#xA;client.Do(ctx, client.B().Zpopmin().Key(&#34;myzset&#34;).Count(2).Build()).AsZScores()&#xA;// SCARD&#xA;client.Do(ctx, client.B().Scard().Key(&#34;k&#34;).Build()).AsInt64()&#xA;// SMEMBERS&#xA;client.Do(ctx, client.B().Smembers().Key(&#34;k&#34;).Build()).AsStrSlice()&#xA;// LINDEX&#xA;client.Do(ctx, client.B().Lindex().Key(&#34;k&#34;).Index(0).Build()).ToString()&#xA;// LPOP&#xA;client.Do(ctx, client.B().Lpop().Key(&#34;k&#34;).Build()).ToString()&#xA;client.Do(ctx, client.B().Lpop().Key(&#34;k&#34;).Count(2).Build()).AsStrSlice()&#xA;// FT.SEARCH&#xA;client.Do(ctx, client.B().FtSearch().Index(&#34;idx&#34;).Query(&#34;@f:v&#34;).Build()).AsFtSearch()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Supporting Go mod 1.18&lt;/h2&gt; &#xA;&lt;p&gt;To support the old Go 1.18 at least until Go 1.21 comes, there will be a special build tagged with &lt;code&gt;-go1.18&lt;/code&gt; for each release.&lt;/p&gt; &#xA;&lt;p&gt;Such releases remove &lt;code&gt;RedisResult.AsBytes()&lt;/code&gt; and other related functionalities provided by later go versions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# go.mod&#xA;module mymodule&#xA;&#xA;go 1.18&#xA;&#xA;require github.com/redis/rueidis v1.0.4-go1.18&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>bufbuild/buf</title>
    <updated>2023-05-19T01:36:00Z</updated>
    <id>tag:github.com,2023-05-19:/bufbuild/buf</id>
    <link href="https://github.com/bufbuild/buf" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A new way of working with Protocol Buffers.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bufbuild/buf/main/.github/buf-logo.svg?sanitize=true&#34; alt=&#34;The Buf logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Buf&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bufbuild/buf/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/bufbuild/buf?color=blue&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bufbuild/buf/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/bufbuild/buf?include_prereleases&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bufbuild/buf/actions?workflow=ci&#34;&gt;&lt;img src=&#34;https://github.com/bufbuild/buf/workflows/ci/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/bufbuild/buf&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/bufbuild/buf&#34; alt=&#34;Docker&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bufbuild/homebrew-buf&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/homebrew-v1.19.0-blue&#34; alt=&#34;Homebrew&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://aur.archlinux.org/packages/buf&#34;&gt;&lt;img src=&#34;https://img.shields.io/aur/version/buf&#34; alt=&#34;AUR&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://buf.build/links/slack&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/slack-buf-%23e01563&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://buf.build&#34;&gt;&lt;code&gt;buf&lt;/code&gt;&lt;/a&gt; CLI is a tool for working with &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34;&gt;Protocol Buffers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;features&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The ability to manage Protobuf assets on the &lt;a href=&#34;https://docs.buf.build/bsr&#34;&gt;Buf Schema Registry&lt;/a&gt; (BSR).&lt;/li&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://docs.buf.build/lint/usage&#34;&gt;linter&lt;/a&gt; that enforces good API design choices and structure.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://docs.buf.build/breaking/usage&#34;&gt;breaking change detector&lt;/a&gt; that enforces compatibility at the source code or wire level.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://docs.buf.build/generate/usage&#34;&gt;generator&lt;/a&gt; that invokes your plugins based on configurable &lt;a href=&#34;https://docs.buf.build/configuration/v1/buf-gen-yaml&#34;&gt;templates&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://docs.buf.build/format/usage&#34;&gt;formatter&lt;/a&gt; that formats your Protobuf files in accordance with industry standards.&lt;/li&gt; &#xA; &lt;li&gt;Integration with the &lt;a href=&#34;https://docs.buf.build/bsr&#34;&gt;Buf Schema Registry&lt;/a&gt;, including full dependency management.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Homebrew&lt;/h3&gt; &#xA;&lt;p&gt;You can install &lt;code&gt;buf&lt;/code&gt; using &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; (macOS or Linux):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install bufbuild/buf/buf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This installs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;buf&lt;/code&gt;, &lt;a href=&#34;https://docs.buf.build/breaking&#34;&gt;&lt;code&gt;protoc-gen-buf-breaking&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://docs.buf.build/lint&#34;&gt;&lt;code&gt;protoc-gen-buf-lint&lt;/code&gt;&lt;/a&gt; binaries&lt;/li&gt; &#xA; &lt;li&gt;Shell completion scripts for &lt;a href=&#34;https://www.gnu.org/software/bash&#34;&gt;Bash&lt;/a&gt;, &lt;a href=&#34;https://fishshell.com&#34;&gt;Fish&lt;/a&gt;, &lt;a href=&#34;https://docs.microsoft.com/en-us/powershell&#34;&gt;Powershell&lt;/a&gt;, and &lt;a href=&#34;https://zsh.org&#34;&gt;zsh&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Other methods&lt;/h3&gt; &#xA;&lt;p&gt;For other installation methods, see our &lt;a href=&#34;https://docs.buf.build/installation&#34;&gt;official documentation&lt;/a&gt;, which covers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installing &lt;code&gt;buf&lt;/code&gt; via &lt;a href=&#34;https://docs.buf.build/installation#npm&#34;&gt;npm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Installing &lt;code&gt;buf&lt;/code&gt; on &lt;a href=&#34;https://docs.buf.build/installation#windows-support&#34;&gt;Windows&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Using &lt;code&gt;buf&lt;/code&gt; as a &lt;a href=&#34;https://docs.buf.build/installation#use-the-docker-image&#34;&gt;Docker image&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Installing as a &lt;a href=&#34;https://docs.buf.build/installation#binary&#34;&gt;binary&lt;/a&gt;, from a &lt;a href=&#34;https://docs.buf.build/installation#tarball&#34;&gt;tarball&lt;/a&gt;, and from &lt;a href=&#34;https://docs.buf.build/installation#from-source&#34;&gt;source&lt;/a&gt; through &lt;a href=&#34;https://docs.buf.build/installation#github-releases&#34;&gt;GitHub Releases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.buf.build/installation#verifying-a-release&#34;&gt;Verifying&lt;/a&gt; releases using a &lt;a href=&#34;https://github.com/jedisct1/minisign&#34;&gt;minisign&lt;/a&gt; public key&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Buf&#39;s help interface provides summaries for commands and flags:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;buf --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more comprehensive usage information, consult Buf&#39;s &lt;a href=&#34;https://docs.buf.build&#34;&gt;documentation&lt;/a&gt;, especially these guides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.buf.build/breaking/usage&#34;&gt;&lt;code&gt;buf breaking&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.buf.build/build/usage&#34;&gt;&lt;code&gt;buf build&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.buf.build/generate/usage&#34;&gt;&lt;code&gt;buf generate&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.buf.build/lint/usage&#34;&gt;&lt;code&gt;buf lint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.buf.build/format/usage&#34;&gt;&lt;code&gt;buf format&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.buf.build/bsr/usage&#34;&gt;&lt;code&gt;buf registry&lt;/code&gt;&lt;/a&gt; (for using the &lt;a href=&#34;https://docs.buf.build/bsr&#34;&gt;BSR&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;CLI breaking change policy&lt;/h2&gt; &#xA;&lt;p&gt;We will never make breaking changes within a given major version of the CLI. Once &lt;code&gt;buf&lt;/code&gt; reaches v1.0, you can expect no breaking changes until v2.0. But as we have no plans to ever release a v2.0, we will likely never break the &lt;code&gt;buf&lt;/code&gt; CLI.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This breaking change policy does &lt;em&gt;not&lt;/em&gt; apply to commands behind the &lt;code&gt;buf beta&lt;/code&gt; gate, and you should expect breaking changes to commands like &lt;code&gt;buf beta registry&lt;/code&gt;. The policy does go into effect, however, when those commands or flags are elevated out of beta.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Our goals for Protobuf&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://buf.build&#34;&gt;Buf&lt;/a&gt;&#39;s goal is to replace the current paradigm of API development, centered around REST/JSON, with a &lt;strong&gt;schema-driven&lt;/strong&gt; paradigm. Defining APIs using an &lt;a href=&#34;https://en.wikipedia.org/wiki/Interface_description_language&#34;&gt;IDL&lt;/a&gt; provides numerous benefits over REST/JSON, and &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34;&gt;Protobuf&lt;/a&gt; is by far the most stable and widely adopted IDL in the industry. We&#39;ve chosen to build on this widely trusted foundation rather than creating a new IDL from scratch.&lt;/p&gt; &#xA;&lt;p&gt;But despite its technical merits, actually &lt;em&gt;using&lt;/em&gt; Protobuf has long been more challenging than it needs to be. The Buf CLI and the &lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/buf/main/#the-buf-schema-registry&#34;&gt;BSR&lt;/a&gt; are the cornerstones of our effort to change that for good and to make Protobuf reliable and easy to use for service owners and clients alike—in other words, to create a &lt;strong&gt;modern Protobuf ecosystem&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;While we intend to incrementally improve on the &lt;code&gt;buf&lt;/code&gt; CLI and the &lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/buf/main/#the-buf-schema-registry&#34;&gt;BSR&lt;/a&gt;, we&#39;re confident that the basic groundwork for such an ecosystem is &lt;em&gt;already&lt;/em&gt; in place.&lt;/p&gt; &#xA;&lt;h2&gt;The Buf Schema Registry&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://docs.buf.build/bsr&#34;&gt;Buf Schema Registry&lt;/a&gt; (BSR) is a SaaS platform for managing your Protobuf APIs. It provides a centralized registry and a single source of truth for all of your Protobuf assets, including not just your &lt;code&gt;.proto&lt;/code&gt; files but also &lt;a href=&#34;https://buf.build/plugins&#34;&gt;remote plugins&lt;/a&gt;. Although the BSR provides an intuitive browser UI, &lt;code&gt;buf&lt;/code&gt; enables you to perform most BSR-related tasks from the command line, such as &lt;a href=&#34;https://docs.buf.build/bsr/usage#push-a-module&#34;&gt;pushing&lt;/a&gt; Protobuf sources to the registry and managing &lt;a href=&#34;https://docs.buf.build/bsr/user-management#organization-roles&#34;&gt;users&lt;/a&gt; and &lt;a href=&#34;https://docs.buf.build/bsr/overview#module&#34;&gt;repositories&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The BSR is not required to use &lt;code&gt;buf&lt;/code&gt;. We&#39;ve made the core &lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/buf/main/#features&#34;&gt;features&lt;/a&gt; of the &lt;code&gt;buf&lt;/code&gt; CLI available to &lt;em&gt;all&lt;/em&gt; Protobuf users.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;More advanced CLI features&lt;/h2&gt; &#xA;&lt;p&gt;While &lt;code&gt;buf&lt;/code&gt;&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/buf/main/#features&#34;&gt;core features&lt;/a&gt; should cover most use cases, we&#39;ve included some more advanced features to cover edge cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Automatic file discovery&lt;/strong&gt;. Buf walks your file tree and builds your &lt;code&gt;.proto&lt;/code&gt; files in accordance with your supplied &lt;a href=&#34;https://docs.buf.build/build/usage/#configuration&#34;&gt;build configuration&lt;/a&gt;, which means that you no longer need to manually specify &lt;code&gt;--proto_paths&lt;/code&gt;. You can still, however, specify &lt;code&gt;.proto&lt;/code&gt; files manually through CLI flags in cases where file discovery needs to be disabled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fine-grained rule configuration&lt;/strong&gt; for &lt;a href=&#34;https://docs.buf.build/lint/rules&#34;&gt;linting&lt;/a&gt; and &lt;a href=&#34;https://docs.buf.build/breaking/rules&#34;&gt;breaking changes&lt;/a&gt;. While we do have recommended defaults, you can always select the exact set of rules that your use case requires, with &lt;a href=&#34;https://docs.buf.build/lint/rules&#34;&gt;40 lint rules&lt;/a&gt; and &lt;a href=&#34;https://docs.buf.build/breaking/rules&#34;&gt;53 breaking change rules&lt;/a&gt; available.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Configurable error formats&lt;/strong&gt; for CLI output. &lt;code&gt;buf&lt;/code&gt; outputs information in &lt;code&gt;file:line:column:message&lt;/code&gt; form by default for each lint error and breaking change it encounters, but you can also select JSON and, in the near future, JUnit output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Editor integration&lt;/strong&gt; driven by &lt;code&gt;buf&lt;/code&gt;&#39;s granular error output. We currently provide linting integrations for both &lt;a href=&#34;https://docs.buf.build/editor-integration&#34;&gt;Vim and Visual Studio Code&lt;/a&gt; but we plan to support other editors, such as Emacs and &lt;a href=&#34;https://docs.buf.build/editor-integration#jetbrains-ides&#34;&gt;JetBrains IDEs&lt;/a&gt; like IntelliJ and GoLand, in the future.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Universal Input targeting&lt;/strong&gt;. Buf enables you to perform actions like linting and breaking change detection not just against local &lt;code&gt;.proto&lt;/code&gt; files but also against a broad range of other &lt;a href=&#34;https://docs.buf.build/reference/inputs&#34;&gt;Inputs&lt;/a&gt;, such as tarballs and ZIP files, remote Git repositories, and pre-built &lt;a href=&#34;https://docs.buf.build/reference/images&#34;&gt;image&lt;/a&gt; files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Speed&lt;/strong&gt;. Buf&#39;s internal Protobuf compiler compiles your Protobuf sources using all available cores without compromising deterministic output, which is considerably faster than &lt;code&gt;protoc&lt;/code&gt;. This allows for near-instantaneous feedback, which is of special importance for features like &lt;a href=&#34;https://docs.buf.build/editor-integration&#34;&gt;editor integration&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Next steps&lt;/h2&gt; &#xA;&lt;p&gt;Once you&#39;ve installed &lt;code&gt;buf&lt;/code&gt;, we recommend completing the &lt;a href=&#34;https://docs.buf.build/tour/introduction&#34;&gt;Tour of Buf&lt;/a&gt;, which provides a broad but hands-on overview of the core functionality of both the CLI and the &lt;a href=&#34;https://docs.buf.build/bsr&#34;&gt;BSR&lt;/a&gt;. The tour takes about 10 minutes to complete.&lt;/p&gt; &#xA;&lt;p&gt;After completing the tour, check out the remainder of the &lt;a href=&#34;https://docs.buf.build&#34;&gt;docs&lt;/a&gt; for your specific areas of interest.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;For help and discussion around Protobuf, best practices, and more, join us on &lt;a href=&#34;https://buf.build/links/slack&#34;&gt;Slack&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For updates on the Buf CLI, &lt;a href=&#34;https://github.com/bufbuild/buf/&#34;&gt;follow this repo on GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For feature requests, bugs, or technical questions, email us at &lt;a href=&#34;mailto:dev@buf.build&#34;&gt;dev@buf.build&lt;/a&gt;. For general inquiries or inclusion in our upcoming feature betas, email us at &lt;a href=&#34;mailto:info@buf.build&#34;&gt;info@buf.build&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>