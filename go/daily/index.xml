<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-31T01:37:33Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ergo-services/ergo</title>
    <updated>2023-01-31T01:37:33Z</updated>
    <id>tag:github.com,2023-01-31:/ergo-services/ergo</id>
    <link href="https://github.com/ergo-services/ergo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;an actor based Framework for creating microservices using technologies and design patterns of Erlang/OTP in Golang&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://ergo.services&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/.github/images/logo.svg?sanitize=true&#34; alt=&#34;Ergo Framework&#34; width=&#34;159&#34; height=&#34;49&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;!--[![Gitbook Documentation](https://img.shields.io/badge/GitBook-Documentation-f37f40?style=plastic&amp;logo=gitbook&amp;logoColor=white&amp;style=flat)](https://docs.ergo.services) --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/ergo-services/ergo&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/ergo-services/ergo&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-brightgreen.svg?sanitize=true&#34; alt=&#34;MIT license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/ergo_services&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Telegram-Community-blue?style=flat&amp;amp;logo=telegram&#34; alt=&#34;Telegram Community&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/sdscxKGV62&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Discord-Community-5865F2?style=flat&amp;amp;logo=discord&amp;amp;logoColor=white&#34; alt=&#34;Discord Community&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/ergo_services&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Twitter-ergo__services-1DA1F2?style=flat&amp;amp;logo=twitter&amp;amp;logoColor=white&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Technologies and design patterns of Erlang/OTP have been proven over the years. Now in Golang. Up to x5 times faster than original Erlang/OTP in terms of network messaging. The easiest way to create an OTP-designed application in Golang.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ergo.services&#34;&gt;https://ergo.services&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Purpose&lt;/h3&gt; &#xA;&lt;p&gt;The goal of this project is to leverage Erlang/OTP experience with Golang performance. Ergo Framework implements &lt;a href=&#34;https://erlang.org/doc/apps/erts/erl_dist_protocol.html&#34;&gt;DIST protocol&lt;/a&gt;, &lt;a href=&#34;https://erlang.org/doc/apps/erts/erl_ext_dist.html&#34;&gt;ETF data format&lt;/a&gt; and &lt;a href=&#34;https://erlang.org/doc/design_principles/des_princ.html&#34;&gt;OTP design patterns&lt;/a&gt; &lt;code&gt;gen.Server&lt;/code&gt;, &lt;code&gt;gen.Supervisor&lt;/code&gt;, &lt;code&gt;gen.Application&lt;/code&gt; which makes you able to create distributed, high performance and reliable microservice solutions having native integration with Erlang infrastructure&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/118860/113710255-c57d5500-96e3-11eb-9970-20f49008a990.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support Erlang 24 (including &lt;a href=&#34;https://blog.erlang.org/My-OTP-24-Highlights/#eep-53-process-aliases&#34;&gt;Alias&lt;/a&gt; and &lt;a href=&#34;https://blog.erlang.org/OTP-23-Highlights/#distributed-spawn-and-the-new-erpc-module&#34;&gt;Remote Spawn&lt;/a&gt; features)&lt;/li&gt; &#xA; &lt;li&gt;Spawn Erlang-like processes&lt;/li&gt; &#xA; &lt;li&gt;Register/unregister processes with simple atom&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gen.Server&lt;/code&gt; behavior support (with atomic state)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gen.Supervisor&lt;/code&gt; behavior support with all known &lt;a href=&#34;https://erlang.org/doc/design_principles/sup_princ.html#restart-strategy&#34;&gt;restart strategies&lt;/a&gt; support &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;One For One&lt;/li&gt; &#xA;   &lt;li&gt;One For All&lt;/li&gt; &#xA;   &lt;li&gt;Rest For One&lt;/li&gt; &#xA;   &lt;li&gt;Simple One For One&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gen.Application&lt;/code&gt; behavior support with all known &lt;a href=&#34;https://erlang.org/doc/design_principles/applications.html#application-start-types&#34;&gt;starting types&lt;/a&gt; support &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Permanent&lt;/li&gt; &#xA;   &lt;li&gt;Temporary&lt;/li&gt; &#xA;   &lt;li&gt;Transient&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gen.Stage&lt;/code&gt; behavior support (originated from Elixir&#39;s &lt;a href=&#34;https://hexdocs.pm/gen_stage/GenStage.html&#34;&gt;GenStage&lt;/a&gt;). This is abstraction built on top of &lt;code&gt;gen.Server&lt;/code&gt; to provide a simple way to create a distributed Producer/Consumer architecture, while automatically managing the concept of backpressure. This implementation is fully compatible with Elixir&#39;s GenStage. Example is here &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genstage&#34;&gt;examples/genstage&lt;/a&gt; or just run &lt;code&gt;go run ./examples/genstage&lt;/code&gt; to see it in action&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gen.Saga&lt;/code&gt; behavior support. It implements Saga design pattern - a sequence of transactions that updates each service state and publishes the result (or cancels the transaction or triggers the next transaction step). &lt;code&gt;gen.Saga&lt;/code&gt; also provides a feature of interim results (can be used as transaction progress or as a part of pipeline processing), time deadline (to limit transaction lifespan), two-phase commit (to make distributed transaction atomic). Here is example &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/gensaga&#34;&gt;examples/gensaga&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gen.Raft&lt;/code&gt; behavior support. It&#39;s improved implementation of &lt;a href=&#34;https://raft.github.io&#34;&gt;Raft consensus algorithm&lt;/a&gt;. The key improvement is using quorum under the hood to manage the leader election process and make the Raft cluster more reliable. This implementation supports quorums of 3, 5, 7, 9, or 11 quorum members. Here is an example of this feature &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genraft&#34;&gt;examples/genraft&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Connect to (accept connection from) any Erlang/Elixir node within a cluster&lt;/li&gt; &#xA; &lt;li&gt;Making sync request &lt;code&gt;ServerProcess.Call&lt;/code&gt;, async - &lt;code&gt;ServerProcess.Cast&lt;/code&gt; or &lt;code&gt;Process.Send&lt;/code&gt; in fashion of &lt;code&gt;gen_server:call&lt;/code&gt;, &lt;code&gt;gen_server:cast&lt;/code&gt;, &lt;code&gt;erlang:send&lt;/code&gt; accordingly&lt;/li&gt; &#xA; &lt;li&gt;Monitor processes/nodes, local/remote&lt;/li&gt; &#xA; &lt;li&gt;Link processes local/remote&lt;/li&gt; &#xA; &lt;li&gt;RPC callbacks support&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/#epmd&#34;&gt;embedded EPMD&lt;/a&gt; (in order to get rid of erlang&#39; dependencies)&lt;/li&gt; &#xA; &lt;li&gt;Unmarshalling terms into the struct using &lt;code&gt;etf.TermIntoStruct&lt;/code&gt;, &lt;code&gt;etf.TermProplistIntoStruct&lt;/code&gt; or to the string using &lt;code&gt;etf.TermToString&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Custom marshaling/unmarshaling via &lt;code&gt;Marshal&lt;/code&gt; and &lt;code&gt;Unmarshal&lt;/code&gt; interfaces&lt;/li&gt; &#xA; &lt;li&gt;Encryption (TLS 1.3) support (including autogenerating self-signed certificates)&lt;/li&gt; &#xA; &lt;li&gt;Compression support (with customization of compression level and threshold). It can be configured for the node or a particular process.&lt;/li&gt; &#xA; &lt;li&gt;Proxy support with end-to-end encryption, includeing compression/fragmentation/linking/monitoring features.&lt;/li&gt; &#xA; &lt;li&gt;Tested and confirmed support Windows, Darwin (MacOS), Linux, FreeBSD.&lt;/li&gt; &#xA; &lt;li&gt;Zero dependencies. All features are implemented using the standard Golang library.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go 1.17.x and above&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Versioning&lt;/h3&gt; &#xA;&lt;p&gt;Golang introduced &lt;a href=&#34;https://go.dev/blog/v2-go-modules&#34;&gt;v2 rule&lt;/a&gt; a while ago to solve complicated dependency issues. We found this solution very controversial and there is still a lot of discussion around it. So, we decided to keep the old way for the versioning, but have to use the git tag with v1 as a major version (due to &#34;v2 rule&#34; restrictions). Since now we use git tag pattern 1.999.XYZ where X - major number, Y - minor, Z - patch version.&lt;/p&gt; &#xA;&lt;h3&gt;Changelog&lt;/h3&gt; &#xA;&lt;p&gt;Here are the changes of latest release. For more details see the &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/ChangeLog.md&#34;&gt;ChangeLog&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://github.com/ergo-services/ergo/releases/tag/v1.999.220&#34;&gt;v2.2.0&lt;/a&gt; 2022-10-18 [tag version v1.999.220]&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Introduced &lt;code&gt;gen.Web&lt;/code&gt; behavior. It implements &lt;strong&gt;Web API Gateway pattern&lt;/strong&gt; is also sometimes known as the &#34;Backend For Frontend&#34; (BFF). See example &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genweb&#34;&gt;examples/genweb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Introduced &lt;code&gt;gen.TCP&lt;/code&gt; behavior - &lt;strong&gt;socket acceptor pool for TCP protocols&lt;/strong&gt;. It provides everything you need to accept TCP connections and process packets with a small code base and low latency. Here is simple example &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/gentcp&#34;&gt;examples/gentcp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Introduced &lt;code&gt;gen.UDP&lt;/code&gt; - the same as &lt;code&gt;gen.TCP&lt;/code&gt;, but for UDP protocols. Example is here &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genudp&#34;&gt;examples/genudp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Introduced &lt;strong&gt;Events&lt;/strong&gt;. This is a simple pub/sub feature within a node - any &lt;code&gt;gen.Process&lt;/code&gt; can become a producer by registering a new event &lt;code&gt;gen.Event&lt;/code&gt; using method &lt;code&gt;gen.Process.RegisterEvent&lt;/code&gt;, while the others can subscribe to these events using &lt;code&gt;gen.Process.MonitorEvent&lt;/code&gt;. Subscriber process will also receive &lt;code&gt;gen.MessageEventDown&lt;/code&gt; if a producer process went down (terminated). This feature behaves in a monitor manner but only works within a node. You may also want to subscribe to a system event - &lt;code&gt;node.EventNetwork&lt;/code&gt; to receive event notification on connect/disconnect any peers. Here is simple example of this feature &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/events&#34;&gt;examples/events&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Introduced &lt;strong&gt;Cloud Client&lt;/strong&gt; - allows connecting to the cloud platform &lt;a href=&#34;https://ergo.services&#34;&gt;https://ergo.sevices&lt;/a&gt;. You may want to register your email there, and we will inform you about the platform launch day&lt;/li&gt; &#xA; &lt;li&gt;Introduced &lt;strong&gt;type registration&lt;/strong&gt; for the ETF encoding/decoding. This feature allows you to get rid of manually decoding with &lt;code&gt;etf.TermIntoStruct&lt;/code&gt; for the receiving messages. Register your type using &lt;code&gt;etf.RegisterType(...)&lt;/code&gt;, and you will be receiving messages in a native type&lt;/li&gt; &#xA; &lt;li&gt;Predefined set of errors has moved to the &lt;code&gt;lib&lt;/code&gt; package&lt;/li&gt; &#xA; &lt;li&gt;Updated &lt;code&gt;gen.ServerBehavior.HandleDirect&lt;/code&gt; method (got extra argument &lt;code&gt;etf.Ref&lt;/code&gt; to distinguish the requests). This change allows you to handle these requests asynchronously using method &lt;code&gt;gen.ServerProcess.Reply(...)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Updated &lt;code&gt;node.Options&lt;/code&gt;. Now it has field &lt;code&gt;Listeners&lt;/code&gt; (type &lt;code&gt;node.Listener&lt;/code&gt;). It allows you to start any number of listeners with custom options - &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;TLS&lt;/code&gt; settings, or custom &lt;code&gt;Handshake&lt;/code&gt;/&lt;code&gt;Proto&lt;/code&gt; interfaces&lt;/li&gt; &#xA; &lt;li&gt;Fixed build on 32-bit arch&lt;/li&gt; &#xA; &lt;li&gt;Fixed freezing on ARM arch #102&lt;/li&gt; &#xA; &lt;li&gt;Fixed problem with encoding negative int8&lt;/li&gt; &#xA; &lt;li&gt;Fixed #103 (there was an issue on interop with Elixir&#39;s GenStage)&lt;/li&gt; &#xA; &lt;li&gt;Fixed node stuck on start if it uses the name which is already taken in EPMD&lt;/li&gt; &#xA; &lt;li&gt;Fixed incorrect &lt;code&gt;gen.ProcessOptions.Context&lt;/code&gt; handling&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;Here is simple EndToEnd test demonstrates performance of messaging subsystem&lt;/p&gt; &#xA;&lt;p&gt;Hardware: workstation with AMD Ryzen Threadripper 3970X (64) @ 3.700GHz&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;❯❯❯❯ go test -bench=NodeParallel -run=XXX -benchtime=10s&#xA;goos: linux&#xA;goarch: amd64&#xA;pkg: github.com/ergo-services/ergo/tests&#xA;cpu: AMD Ryzen Threadripper 3970X 32-Core Processor&#xA;BenchmarkNodeParallel-64                 4738918              2532 ns/op&#xA;BenchmarkNodeParallelSingleNode-64      100000000              429.8 ns/op&#xA;&#xA;PASS&#xA;ok      github.com/ergo-services/ergo/tests  29.596s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;these numbers show almost &lt;strong&gt;500.000 sync requests per second&lt;/strong&gt; for the network messaging via localhost and &lt;strong&gt;10.000.000 sync requests per second&lt;/strong&gt; for the local messaging (within a node).&lt;/p&gt; &#xA;&lt;h4&gt;Compression&lt;/h4&gt; &#xA;&lt;p&gt;This benchmark shows the performance of compression for sending 1MB message between two nodes (via a network).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;❯❯❯❯ go test -bench=NodeCompression -run=XXX -benchtime=10s&#xA;goos: linux&#xA;goarch: amd64&#xA;pkg: github.com/ergo-services/ergo/tests&#xA;cpu: AMD Ryzen Threadripper 3970X 32-Core Processor&#xA;BenchmarkNodeCompressionDisabled1MBempty-64         2400           4957483 ns/op&#xA;BenchmarkNodeCompressionEnabled1MBempty-64          5769           2088051 ns/op&#xA;BenchmarkNodeCompressionEnabled1MBstring-64         5202           2077099 ns/op&#xA;PASS&#xA;ok      github.com/ergo-services/ergo/tests     56.708s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It demonstrates &lt;strong&gt;more than 2 times&lt;/strong&gt; improvement.&lt;/p&gt; &#xA;&lt;h4&gt;Proxy&lt;/h4&gt; &#xA;&lt;p&gt;This benchmark demonstrates how proxy feature and e2e encryption impact a messaging performance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;❯❯❯❯ go test -bench=NodeProxy -run=XXX -benchtime=10s&#xA;goos: linux&#xA;goarch: amd64&#xA;pkg: github.com/ergo-services/ergo/tests&#xA;cpu: AMD Ryzen Threadripper 3970X 32-Core Processor&#xA;BenchmarkNodeProxy_NodeA_to_NodeC_direct_Message_1KB-64                     1908477       6337 ns/op&#xA;BenchmarkNodeProxy_NodeA_to_NodeC_via_NodeB_Message_1KB-64                  1700984       7062 ns/op&#xA;BenchmarkNodeProxy_NodeA_to_NodeC_via_NodeB_Message_1KB_Encrypted-64        1271125       9410 ns/op&#xA;PASS&#xA;ok      github.com/ergo-services/ergo/tests     45.649s&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Ergo Framework vs original Erlang/OTP&lt;/h4&gt; &#xA;&lt;p&gt;Hardware: laptop with Intel(R) Core(TM) i5-8265U (4 cores. 8 with HT)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/halturin/ergobenchmarks/master/ergobenchmark.png&#34; alt=&#34;benchmarks&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;sources of these benchmarks are &lt;a href=&#34;https://github.com/halturin/ergobenchmarks&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;EPMD&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;Ergo Framework&lt;/em&gt; has embedded EPMD implementation in order to run your node without external epmd process needs. By default, it works as a client with erlang&#39; epmd daemon or others ergo&#39;s nodes either.&lt;/p&gt; &#xA;&lt;p&gt;The one thing that makes embedded EPMD different is the behavior of handling connection hangs - if ergo&#39; node is running as an EPMD client and lost connection, it tries either to run its own embedded EPMD service or to restore the lost connection.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;Code below is a simple implementation of gen.Server pattern &lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genserver&#34;&gt;examples/genserver&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;time&#34;&#xA;&#xA;&#x9;&#34;github.com/ergo-services/ergo/etf&#34;&#xA;&#x9;&#34;github.com/ergo-services/ergo/gen&#34;&#xA;)&#xA;&#xA;type simple struct {&#xA;&#x9;gen.Server&#xA;}&#xA;&#xA;func (s *simple) HandleInfo(process *gen.ServerProcess, message etf.Term) gen.ServerStatus {&#xA;&#x9;value := message.(int)&#xA;&#x9;fmt.Printf(&#34;HandleInfo: %#v \n&#34;, message)&#xA;&#x9;if value &amp;gt; 104 {&#xA;&#x9;&#x9;return gen.ServerStatusStop&#xA;&#x9;}&#xA;&#x9;// sending message with delay 1 second&#xA;&#x9;fmt.Println(&#34;increase this value by 1 and send it to itself again&#34;)&#xA;&#x9;process.SendAfter(process.Self(), value+1, time.Second)&#xA;&#x9;return gen.ServerStatusOK&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;here is output of this code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run ./examples/simple&#xA;HandleInfo: 100&#xA;HandleInfo: 101&#xA;HandleInfo: 102&#xA;HandleInfo: 103&#xA;HandleInfo: 104&#xA;HandleInfo: 105&#xA;exited&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;code&gt;examples/&lt;/code&gt; for more details&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/application&#34;&gt;gen.Application&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/supervisor&#34;&gt;gen.Supervisor&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genserver&#34;&gt;gen.Server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genstage&#34;&gt;gen.Stage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/gensaga&#34;&gt;gen.Saga&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genraft&#34;&gt;gen.Raft&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/gencustom&#34;&gt;gen.Custom&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genweb&#34;&gt;gen.Web&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/gentcp&#34;&gt;gen.TCP&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/genudp&#34;&gt;gen.UDP&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/events&#34;&gt;events&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/erlang&#34;&gt;erlang&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/examples/proxy&#34;&gt;proxy&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Elixir Phoenix Users&lt;/h3&gt; &#xA;&lt;p&gt;Users of the Elixir Phoenix framework might encounter timeouts when trying to connect a Phoenix node to an ergo node. The reason is that, in addition to global_name_server and net_kernel, Phoenix attempts to broadcast messages to the &lt;a href=&#34;https://hexdocs.pm/phoenix/1.1.0/Phoenix.PubSub.PG2.html&#34;&gt;pg2 PubSub handler&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To work with Phoenix nodes, you must create and register a dedicated pg2 GenServer, and spawn it inside your node. The spawning process must have &#34;pg2&#34; as a process name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Pg2GenServer struct {&#xA;    gen.Server&#xA;}&#xA;&#xA;func main() {&#xA;    // ...&#xA;    pg2 := &amp;amp;Pg2GenServer{}&#xA;    node1, _ := ergo.StartNode(&#34;node1@localhost&#34;, &#34;cookies&#34;, node.Options{})&#xA;    process, _ := node1.Spawn(&#34;pg2&#34;, gen.ProcessOptions{}, pg2, nil)&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Development and debugging&lt;/h3&gt; &#xA;&lt;p&gt;There are options already defined that you might want to use&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-ergo.trace&lt;/code&gt; - enable extended debug info&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-ergo.norecover&lt;/code&gt; - disable panic catching&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-ergo.warning&lt;/code&gt; - enable/disable warnings (default: enable)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To enable Golang profiler just add &lt;code&gt;--tags debug&lt;/code&gt; in your &lt;code&gt;go run&lt;/code&gt; or &lt;code&gt;go build&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go run --tags debug ./examples/genserver/demoGenServer.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now golang&#39; profiler is available at &lt;code&gt;http://localhost:9009/debug/pprof&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To check test coverage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go test -coverprofile=cover.out ./...&#xA;go tool cover -html=cover.out -o coverage.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run tests with cleaned test cache:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go vet&#xA;go clean -testcache&#xA;go test -v ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run benchmarks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go test -bench=Node -run=X -benchmem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Companies are using Ergo Framework&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://kaspersky.com&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/.github/images/kaspersky.png&#34; alt=&#34;Kaspersky&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.ringcentral.com&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/.github/images/ringcentral.png&#34; alt=&#34;RingCentral&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://lilithgames.com&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ergo-services/ergo/master/.github/images/lilithgames.png&#34; alt=&#34;LilithGames&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;is your company using Ergo? add your company logo/name here&lt;/p&gt; &#xA;&lt;h3&gt;Commercial support&lt;/h3&gt; &#xA;&lt;p&gt;please, visit &lt;a href=&#34;https://ergo.services&#34;&gt;https://ergo.services&lt;/a&gt; for more information&lt;/p&gt;</summary>
  </entry>
</feed>