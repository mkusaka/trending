<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-11T01:41:36Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>gorilla/mux</title>
    <updated>2022-08-11T01:41:36Z</updated>
    <id>tag:github.com,2022-08-11:/gorilla/mux</id>
    <link href="https://github.com/gorilla/mux" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A powerful HTTP router and URL matcher for building Go web servers with ü¶ç&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gorilla/mux&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/gorilla/mux&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/gorilla/mux?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/gorilla/mux&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/gorilla/mux.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sourcegraph.com/github.com/gorilla/mux?badge&#34;&gt;&lt;img src=&#34;https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg?sanitize=true&#34; alt=&#34;Sourcegraph&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud-cdn.questionable.services/gorilla-icon-64.png&#34; alt=&#34;Gorilla Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;‚ö†Ô∏è &lt;strong&gt;&lt;a href=&#34;https://github.com/gorilla/mux/issues/659&#34;&gt;The Gorilla Toolkit is looking for a new maintainer&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Package &lt;code&gt;gorilla/mux&lt;/code&gt; implements a request router and dispatcher for matching incoming requests to their respective handler.&lt;/p&gt; &#xA;&lt;p&gt;The name mux stands for &#34;HTTP request multiplexer&#34;. Like the standard &lt;code&gt;http.ServeMux&lt;/code&gt;, &lt;code&gt;mux.Router&lt;/code&gt; matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It implements the &lt;code&gt;http.Handler&lt;/code&gt; interface so it is compatible with the standard &lt;code&gt;http.ServeMux&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers.&lt;/li&gt; &#xA; &lt;li&gt;URL hosts, paths and query values can have variables with an optional regular expression.&lt;/li&gt; &#xA; &lt;li&gt;Registered URLs can be built, or &#34;reversed&#34;, which helps maintaining references to resources.&lt;/li&gt; &#xA; &lt;li&gt;Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#matching-routes&#34;&gt;Matching Routes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#static-files&#34;&gt;Static Files&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#serving-single-page-applications&#34;&gt;Serving Single Page Applications&lt;/a&gt; (e.g. React, Vue, Ember.js, etc.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#registered-urls&#34;&gt;Registered URLs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#walking-routes&#34;&gt;Walking Routes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#graceful-shutdown&#34;&gt;Graceful Shutdown&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#middleware&#34;&gt;Middleware&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#handling-cors-requests&#34;&gt;Handling CORS Requests&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#testing-handlers&#34;&gt;Testing Handlers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#full-example&#34;&gt;Full Example&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;With a &lt;a href=&#34;https://golang.org/doc/install#testing&#34;&gt;correctly configured&lt;/a&gt; Go toolchain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get -u github.com/gorilla/mux&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s start registering a couple of URL paths and handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    r := mux.NewRouter()&#xA;    r.HandleFunc(&#34;/&#34;, HomeHandler)&#xA;    r.HandleFunc(&#34;/products&#34;, ProductsHandler)&#xA;    r.HandleFunc(&#34;/articles&#34;, ArticlesHandler)&#xA;    http.Handle(&#34;/&#34;, r)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we register three routes mapping URL paths to handlers. This is equivalent to how &lt;code&gt;http.HandleFunc()&lt;/code&gt; works: if an incoming request URL matches one of the paths, the corresponding handler is called passing (&lt;code&gt;http.ResponseWriter&lt;/code&gt;, &lt;code&gt;*http.Request&lt;/code&gt;) as parameters.&lt;/p&gt; &#xA;&lt;p&gt;Paths can have variables. They are defined using the format &lt;code&gt;{name}&lt;/code&gt; or &lt;code&gt;{name:pattern}&lt;/code&gt;. If a regular expression pattern is not defined, the matched variable will be anything until the next slash. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;r.HandleFunc(&#34;/products/{key}&#34;, ProductHandler)&#xA;r.HandleFunc(&#34;/articles/{category}/&#34;, ArticlesCategoryHandler)&#xA;r.HandleFunc(&#34;/articles/{category}/{id:[0-9]+}&#34;, ArticleHandler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The names are used to create a map of route variables which can be retrieved calling &lt;code&gt;mux.Vars()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) {&#xA;    vars := mux.Vars(r)&#xA;    w.WriteHeader(http.StatusOK)&#xA;    fmt.Fprintf(w, &#34;Category: %v\n&#34;, vars[&#34;category&#34;])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And this is all you need to know about the basic usage. More advanced options are explained below.&lt;/p&gt; &#xA;&lt;h3&gt;Matching Routes&lt;/h3&gt; &#xA;&lt;p&gt;Routes can also be restricted to a domain or subdomain. Just define a host pattern to be matched. They can also have variables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;// Only matches if domain is &#34;www.example.com&#34;.&#xA;r.Host(&#34;www.example.com&#34;)&#xA;// Matches a dynamic subdomain.&#xA;r.Host(&#34;{subdomain:[a-z]+}.example.com&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are several other matchers that can be added. To match path prefixes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.PathPrefix(&#34;/products/&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...or HTTP methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.Methods(&#34;GET&#34;, &#34;POST&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...or URL schemes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.Schemes(&#34;https&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...or header values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.Headers(&#34;X-Requested-With&#34;, &#34;XMLHttpRequest&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...or query values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.Queries(&#34;key&#34;, &#34;value&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...or to use a custom matcher function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {&#xA;    return r.ProtoMajor == 0&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...and finally, it is possible to combine several matchers in a single route:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.HandleFunc(&#34;/products&#34;, ProductsHandler).&#xA;  Host(&#34;www.example.com&#34;).&#xA;  Methods(&#34;GET&#34;).&#xA;  Schemes(&#34;http&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Routes are tested in the order they were added to the router. If two routes match, the first one wins:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;r.HandleFunc(&#34;/specific&#34;, specificHandler)&#xA;r.PathPrefix(&#34;/&#34;).Handler(catchAllHandler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Setting the same matching conditions again and again can be boring, so we have a way to group several routes that share the same requirements. We call it &#34;subrouting&#34;.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s say we have several URLs that should only match when the host is &lt;code&gt;www.example.com&lt;/code&gt;. Create a route for that host and get a &#34;subrouter&#34; from it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;s := r.Host(&#34;www.example.com&#34;).Subrouter()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then register routes in the subrouter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s.HandleFunc(&#34;/products/&#34;, ProductsHandler)&#xA;s.HandleFunc(&#34;/products/{key}&#34;, ProductHandler)&#xA;s.HandleFunc(&#34;/articles/{category}/{id:[0-9]+}&#34;, ArticleHandler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The three URL paths we registered above will only be tested if the domain is &lt;code&gt;www.example.com&lt;/code&gt;, because the subrouter is tested first. This is not only convenient, but also optimizes request matching. You can create subrouters combining any attribute matchers accepted by a route.&lt;/p&gt; &#xA;&lt;p&gt;Subrouters can be used to create domain or path &#34;namespaces&#34;: you define subrouters in a central place and then parts of the app can register its paths relatively to a given subrouter.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s one more thing about subroutes. When a subrouter has a path prefix, the inner routes use it as base for their paths:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;s := r.PathPrefix(&#34;/products&#34;).Subrouter()&#xA;// &#34;/products/&#34;&#xA;s.HandleFunc(&#34;/&#34;, ProductsHandler)&#xA;// &#34;/products/{key}/&#34;&#xA;s.HandleFunc(&#34;/{key}/&#34;, ProductHandler)&#xA;// &#34;/products/{key}/details&#34;&#xA;s.HandleFunc(&#34;/{key}/details&#34;, ProductDetailsHandler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Static Files&lt;/h3&gt; &#xA;&lt;p&gt;Note that the path provided to &lt;code&gt;PathPrefix()&lt;/code&gt; represents a &#34;wildcard&#34;: calling &lt;code&gt;PathPrefix(&#34;/static/&#34;).Handler(...)&lt;/code&gt; means that the handler will be passed any request that matches &#34;/static/*&#34;. This makes it easy to serve static files with mux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    var dir string&#xA;&#xA;    flag.StringVar(&amp;amp;dir, &#34;dir&#34;, &#34;.&#34;, &#34;the directory to serve files from. Defaults to the current dir&#34;)&#xA;    flag.Parse()&#xA;    r := mux.NewRouter()&#xA;&#xA;    // This will serve files under http://localhost:8000/static/&amp;lt;filename&amp;gt;&#xA;    r.PathPrefix(&#34;/static/&#34;).Handler(http.StripPrefix(&#34;/static/&#34;, http.FileServer(http.Dir(dir))))&#xA;&#xA;    srv := &amp;amp;http.Server{&#xA;        Handler:      r,&#xA;        Addr:         &#34;127.0.0.1:8000&#34;,&#xA;        // Good practice: enforce timeouts for servers you create!&#xA;        WriteTimeout: 15 * time.Second,&#xA;        ReadTimeout:  15 * time.Second,&#xA;    }&#xA;&#xA;    log.Fatal(srv.ListenAndServe())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serving Single Page Applications&lt;/h3&gt; &#xA;&lt;p&gt;Most of the time it makes sense to serve your SPA on a separate web server from your API, but sometimes it&#39;s desirable to serve them both from one place. It&#39;s possible to write a simple handler for serving your SPA (for use with React Router&#39;s &lt;a href=&#34;https://reacttraining.com/react-router/web/api/BrowserRouter&#34;&gt;BrowserRouter&lt;/a&gt; for example), and leverage mux&#39;s powerful routing for your API endpoints.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;path/filepath&#34;&#xA;&#x9;&#34;time&#34;&#xA;&#xA;&#x9;&#34;github.com/gorilla/mux&#34;&#xA;)&#xA;&#xA;// spaHandler implements the http.Handler interface, so we can use it&#xA;// to respond to HTTP requests. The path to the static directory and&#xA;// path to the index file within that static directory are used to&#xA;// serve the SPA in the given static directory.&#xA;type spaHandler struct {&#xA;&#x9;staticPath string&#xA;&#x9;indexPath  string&#xA;}&#xA;&#xA;// ServeHTTP inspects the URL path to locate a file within the static dir&#xA;// on the SPA handler. If a file is found, it will be served. If not, the&#xA;// file located at the index path on the SPA handler will be served. This&#xA;// is suitable behavior for serving an SPA (single page application).&#xA;func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    // get the absolute path to prevent directory traversal&#xA;&#x9;path, err := filepath.Abs(r.URL.Path)&#xA;&#x9;if err != nil {&#xA;        // if we failed to get the absolute path respond with a 400 bad request&#xA;        // and stop&#xA;&#x9;&#x9;http.Error(w, err.Error(), http.StatusBadRequest)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;    // prepend the path with the path to the static directory&#xA;&#x9;path = filepath.Join(h.staticPath, path)&#xA;&#xA;    // check whether a file exists at the given path&#xA;&#x9;_, err = os.Stat(path)&#xA;&#x9;if os.IsNotExist(err) {&#xA;&#x9;&#x9;// file does not exist, serve index.html&#xA;&#x9;&#x9;http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))&#xA;&#x9;&#x9;return&#xA;&#x9;} else if err != nil {&#xA;        // if we got an error (that wasn&#39;t that the file doesn&#39;t exist) stating the&#xA;        // file, return a 500 internal server error and stop&#xA;&#x9;&#x9;http.Error(w, err.Error(), http.StatusInternalServerError)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;    // otherwise, use http.FileServer to serve the static dir&#xA;&#x9;http.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;router := mux.NewRouter()&#xA;&#xA;&#x9;router.HandleFunc(&#34;/api/health&#34;, func(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;&#x9;// an example API handler&#xA;&#x9;&#x9;json.NewEncoder(w).Encode(map[string]bool{&#34;ok&#34;: true})&#xA;&#x9;})&#xA;&#xA;&#x9;spa := spaHandler{staticPath: &#34;build&#34;, indexPath: &#34;index.html&#34;}&#xA;&#x9;router.PathPrefix(&#34;/&#34;).Handler(spa)&#xA;&#xA;&#x9;srv := &amp;amp;http.Server{&#xA;&#x9;&#x9;Handler: router,&#xA;&#x9;&#x9;Addr:    &#34;127.0.0.1:8000&#34;,&#xA;&#x9;&#x9;// Good practice: enforce timeouts for servers you create!&#xA;&#x9;&#x9;WriteTimeout: 15 * time.Second,&#xA;&#x9;&#x9;ReadTimeout:  15 * time.Second,&#xA;&#x9;}&#xA;&#xA;&#x9;log.Fatal(srv.ListenAndServe())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Registered URLs&lt;/h3&gt; &#xA;&lt;p&gt;Now let&#39;s see how to build registered URLs.&lt;/p&gt; &#xA;&lt;p&gt;Routes can be named. All routes that define a name can have their URLs built, or &#34;reversed&#34;. We define a name calling &lt;code&gt;Name()&lt;/code&gt; on a route. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;r.HandleFunc(&#34;/articles/{category}/{id:[0-9]+}&#34;, ArticleHandler).&#xA;  Name(&#34;article&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build a URL, get the route and call the &lt;code&gt;URL()&lt;/code&gt; method, passing a sequence of key/value pairs for the route variables. For the previous route, we would do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;url, err := r.Get(&#34;article&#34;).URL(&#34;category&#34;, &#34;technology&#34;, &#34;id&#34;, &#34;42&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...and the result will be a &lt;code&gt;url.URL&lt;/code&gt; with the following path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;/articles/technology/42&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This also works for host and query value variables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;r.Host(&#34;{subdomain}.example.com&#34;).&#xA;  Path(&#34;/articles/{category}/{id:[0-9]+}&#34;).&#xA;  Queries(&#34;filter&#34;, &#34;{filter}&#34;).&#xA;  HandlerFunc(ArticleHandler).&#xA;  Name(&#34;article&#34;)&#xA;&#xA;// url.String() will be &#34;http://news.example.com/articles/technology/42?filter=gorilla&#34;&#xA;url, err := r.Get(&#34;article&#34;).URL(&#34;subdomain&#34;, &#34;news&#34;,&#xA;                                 &#34;category&#34;, &#34;technology&#34;,&#xA;                                 &#34;id&#34;, &#34;42&#34;,&#xA;                                 &#34;filter&#34;, &#34;gorilla&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All variables defined in the route are required, and their values must conform to the corresponding patterns. These requirements guarantee that a generated URL will always match a registered route -- the only exception is for explicitly defined &#34;build-only&#34; routes which never match.&lt;/p&gt; &#xA;&lt;p&gt;Regex support also exists for matching Headers within a route. For example, we could do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.HeadersRegexp(&#34;Content-Type&#34;, &#34;application/(text|json)&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...and the route will match both requests with a Content-Type of &lt;code&gt;application/json&lt;/code&gt; as well as &lt;code&gt;application/text&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s also a way to build only the URL host or path for a route: use the methods &lt;code&gt;URLHost()&lt;/code&gt; or &lt;code&gt;URLPath()&lt;/code&gt; instead. For the previous route, we would do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// &#34;http://news.example.com/&#34;&#xA;host, err := r.Get(&#34;article&#34;).URLHost(&#34;subdomain&#34;, &#34;news&#34;)&#xA;&#xA;// &#34;/articles/technology/42&#34;&#xA;path, err := r.Get(&#34;article&#34;).URLPath(&#34;category&#34;, &#34;technology&#34;, &#34;id&#34;, &#34;42&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And if you use subrouters, host and path defined separately can be built as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;s := r.Host(&#34;{subdomain}.example.com&#34;).Subrouter()&#xA;s.Path(&#34;/articles/{category}/{id:[0-9]+}&#34;).&#xA;  HandlerFunc(ArticleHandler).&#xA;  Name(&#34;article&#34;)&#xA;&#xA;// &#34;http://news.example.com/articles/technology/42&#34;&#xA;url, err := r.Get(&#34;article&#34;).URL(&#34;subdomain&#34;, &#34;news&#34;,&#xA;                                 &#34;category&#34;, &#34;technology&#34;,&#xA;                                 &#34;id&#34;, &#34;42&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Walking Routes&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Walk&lt;/code&gt; function on &lt;code&gt;mux.Router&lt;/code&gt; can be used to visit all of the routes that are registered on a router. For example, the following prints all of the registered routes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;strings&#34;&#xA;&#xA;&#x9;&#34;github.com/gorilla/mux&#34;&#xA;)&#xA;&#xA;func handler(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;r := mux.NewRouter()&#xA;&#x9;r.HandleFunc(&#34;/&#34;, handler)&#xA;&#x9;r.HandleFunc(&#34;/products&#34;, handler).Methods(&#34;POST&#34;)&#xA;&#x9;r.HandleFunc(&#34;/articles&#34;, handler).Methods(&#34;GET&#34;)&#xA;&#x9;r.HandleFunc(&#34;/articles/{id}&#34;, handler).Methods(&#34;GET&#34;, &#34;PUT&#34;)&#xA;&#x9;r.HandleFunc(&#34;/authors&#34;, handler).Queries(&#34;surname&#34;, &#34;{surname}&#34;)&#xA;&#x9;err := r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {&#xA;&#x9;&#x9;pathTemplate, err := route.GetPathTemplate()&#xA;&#x9;&#x9;if err == nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;ROUTE:&#34;, pathTemplate)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;pathRegexp, err := route.GetPathRegexp()&#xA;&#x9;&#x9;if err == nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;Path regexp:&#34;, pathRegexp)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;queriesTemplates, err := route.GetQueriesTemplates()&#xA;&#x9;&#x9;if err == nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;Queries templates:&#34;, strings.Join(queriesTemplates, &#34;,&#34;))&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;queriesRegexps, err := route.GetQueriesRegexp()&#xA;&#x9;&#x9;if err == nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;Queries regexps:&#34;, strings.Join(queriesRegexps, &#34;,&#34;))&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;methods, err := route.GetMethods()&#xA;&#x9;&#x9;if err == nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;Methods:&#34;, strings.Join(methods, &#34;,&#34;))&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Println()&#xA;&#x9;&#x9;return nil&#xA;&#x9;})&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;&#xA;&#x9;http.Handle(&#34;/&#34;, r)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Graceful Shutdown&lt;/h3&gt; &#xA;&lt;p&gt;Go 1.8 introduced the ability to &lt;a href=&#34;https://golang.org/doc/go1.8#http_shutdown&#34;&gt;gracefully shutdown&lt;/a&gt; a &lt;code&gt;*http.Server&lt;/code&gt;. Here&#39;s how to do that alongside &lt;code&gt;mux&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;    &#34;context&#34;&#xA;    &#34;flag&#34;&#xA;    &#34;log&#34;&#xA;    &#34;net/http&#34;&#xA;    &#34;os&#34;&#xA;    &#34;os/signal&#34;&#xA;    &#34;time&#34;&#xA;&#xA;    &#34;github.com/gorilla/mux&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    var wait time.Duration&#xA;    flag.DurationVar(&amp;amp;wait, &#34;graceful-timeout&#34;, time.Second * 15, &#34;the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m&#34;)&#xA;    flag.Parse()&#xA;&#xA;    r := mux.NewRouter()&#xA;    // Add your routes as needed&#xA;&#xA;    srv := &amp;amp;http.Server{&#xA;        Addr:         &#34;0.0.0.0:8080&#34;,&#xA;        // Good practice to set timeouts to avoid Slowloris attacks.&#xA;        WriteTimeout: time.Second * 15,&#xA;        ReadTimeout:  time.Second * 15,&#xA;        IdleTimeout:  time.Second * 60,&#xA;        Handler: r, // Pass our instance of gorilla/mux in.&#xA;    }&#xA;&#xA;    // Run our server in a goroutine so that it doesn&#39;t block.&#xA;    go func() {&#xA;        if err := srv.ListenAndServe(); err != nil {&#xA;            log.Println(err)&#xA;        }&#xA;    }()&#xA;&#xA;    c := make(chan os.Signal, 1)&#xA;    // We&#39;ll accept graceful shutdowns when quit via SIGINT (Ctrl+C)&#xA;    // SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.&#xA;    signal.Notify(c, os.Interrupt)&#xA;&#xA;    // Block until we receive our signal.&#xA;    &amp;lt;-c&#xA;&#xA;    // Create a deadline to wait for.&#xA;    ctx, cancel := context.WithTimeout(context.Background(), wait)&#xA;    defer cancel()&#xA;    // Doesn&#39;t block if no connections, but will otherwise wait&#xA;    // until the timeout deadline.&#xA;    srv.Shutdown(ctx)&#xA;    // Optionally, you could run srv.Shutdown in a goroutine and block on&#xA;    // &amp;lt;-ctx.Done() if your application should wait for other services&#xA;    // to finalize based on context cancellation.&#xA;    log.Println(&#34;shutting down&#34;)&#xA;    os.Exit(0)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Middleware&lt;/h3&gt; &#xA;&lt;p&gt;Mux supports the addition of middlewares to a &lt;a href=&#34;https://godoc.org/github.com/gorilla/mux#Router&#34;&gt;Router&lt;/a&gt;, which are executed in the order they are added if a match is found, including its subrouters. Middlewares are (typically) small pieces of code which take one request, do something with it, and pass it down to another middleware or the final handler. Some common use cases for middleware are request logging, header manipulation, or &lt;code&gt;ResponseWriter&lt;/code&gt; hijacking.&lt;/p&gt; &#xA;&lt;p&gt;Mux middlewares are defined using the de facto standard type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MiddlewareFunc func(http.Handler) http.Handler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed to it, and then calls the handler passed as parameter to the MiddlewareFunc. This takes advantage of closures being able access variables from the context where they are created, while retaining the signature enforced by the receivers.&lt;/p&gt; &#xA;&lt;p&gt;A very basic middleware which logs the URI of the request being handled could be written as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func loggingMiddleware(next http.Handler) http.Handler {&#xA;    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {&#xA;        // Do stuff here&#xA;        log.Println(r.RequestURI)&#xA;        // Call the next handler, which can be another middleware in the chain, or the final handler.&#xA;        next.ServeHTTP(w, r)&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Middlewares can be added to a router using &lt;code&gt;Router.Use()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;r.HandleFunc(&#34;/&#34;, handler)&#xA;r.Use(loggingMiddleware)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A more complex authentication middleware, which maps session token to users, could be written as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Define our struct&#xA;type authenticationMiddleware struct {&#xA;&#x9;tokenUsers map[string]string&#xA;}&#xA;&#xA;// Initialize it somewhere&#xA;func (amw *authenticationMiddleware) Populate() {&#xA;&#x9;amw.tokenUsers[&#34;00000000&#34;] = &#34;user0&#34;&#xA;&#x9;amw.tokenUsers[&#34;aaaaaaaa&#34;] = &#34;userA&#34;&#xA;&#x9;amw.tokenUsers[&#34;05f717e5&#34;] = &#34;randomUser&#34;&#xA;&#x9;amw.tokenUsers[&#34;deadbeef&#34;] = &#34;user0&#34;&#xA;}&#xA;&#xA;// Middleware function, which will be called for each request&#xA;func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {&#xA;    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {&#xA;        token := r.Header.Get(&#34;X-Session-Token&#34;)&#xA;&#xA;        if user, found := amw.tokenUsers[token]; found {&#xA;        &#x9;// We found the token in our map&#xA;        &#x9;log.Printf(&#34;Authenticated user %s\n&#34;, user)&#xA;        &#x9;// Pass down the request to the next middleware (or final handler)&#xA;        &#x9;next.ServeHTTP(w, r)&#xA;        } else {&#xA;        &#x9;// Write an error and stop the handler chain&#xA;        &#x9;http.Error(w, &#34;Forbidden&#34;, http.StatusForbidden)&#xA;        }&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := mux.NewRouter()&#xA;r.HandleFunc(&#34;/&#34;, handler)&#xA;&#xA;amw := authenticationMiddleware{}&#xA;amw.Populate()&#xA;&#xA;r.Use(amw.Middleware)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The handler chain will be stopped if your middleware doesn&#39;t call &lt;code&gt;next.ServeHTTP()&lt;/code&gt; with the corresponding parameters. This can be used to abort a request if the middleware writer wants to. Middlewares &lt;em&gt;should&lt;/em&gt; write to &lt;code&gt;ResponseWriter&lt;/code&gt; if they &lt;em&gt;are&lt;/em&gt; going to terminate the request, and they &lt;em&gt;should not&lt;/em&gt; write to &lt;code&gt;ResponseWriter&lt;/code&gt; if they &lt;em&gt;are not&lt;/em&gt; going to terminate it.&lt;/p&gt; &#xA;&lt;h3&gt;Handling CORS Requests&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/gorilla/mux#CORSMethodMiddleware&#34;&gt;CORSMethodMiddleware&lt;/a&gt; intends to make it easier to strictly set the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; response header.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You will still need to use your own CORS handler to set the other CORS headers such as &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The middleware will set the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header to all the method matchers (e.g. &lt;code&gt;r.Methods(http.MethodGet, http.MethodPut, http.MethodOptions)&lt;/code&gt; -&amp;gt; &lt;code&gt;Access-Control-Allow-Methods: GET,PUT,OPTIONS&lt;/code&gt;) on a route&lt;/li&gt; &#xA; &lt;li&gt;If you do not specify any methods, then:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Important&lt;/em&gt;: there must be an &lt;code&gt;OPTIONS&lt;/code&gt; method matcher for the middleware to set the headers.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Here is an example of using &lt;code&gt;CORSMethodMiddleware&lt;/code&gt; along with a custom &lt;code&gt;OPTIONS&lt;/code&gt; handler to set all the required CORS headers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;github.com/gorilla/mux&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    r := mux.NewRouter()&#xA;&#xA;    // IMPORTANT: you must specify an OPTIONS method matcher for the middleware to set CORS headers&#xA;    r.HandleFunc(&#34;/foo&#34;, fooHandler).Methods(http.MethodGet, http.MethodPut, http.MethodPatch, http.MethodOptions)&#xA;    r.Use(mux.CORSMethodMiddleware(r))&#xA;    &#xA;    http.ListenAndServe(&#34;:8080&#34;, r)&#xA;}&#xA;&#xA;func fooHandler(w http.ResponseWriter, r *http.Request) {&#xA;    w.Header().Set(&#34;Access-Control-Allow-Origin&#34;, &#34;*&#34;)&#xA;    if r.Method == http.MethodOptions {&#xA;        return&#xA;    }&#xA;&#xA;    w.Write([]byte(&#34;foo&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And an request to &lt;code&gt;/foo&lt;/code&gt; using something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl localhost:8080/foo -v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Would look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;*   Trying ::1...&#xA;* TCP_NODELAY set&#xA;* Connected to localhost (::1) port 8080 (#0)&#xA;&amp;gt; GET /foo HTTP/1.1&#xA;&amp;gt; Host: localhost:8080&#xA;&amp;gt; User-Agent: curl/7.59.0&#xA;&amp;gt; Accept: */*&#xA;&amp;gt; &#xA;&amp;lt; HTTP/1.1 200 OK&#xA;&amp;lt; Access-Control-Allow-Methods: GET,PUT,PATCH,OPTIONS&#xA;&amp;lt; Access-Control-Allow-Origin: *&#xA;&amp;lt; Date: Fri, 28 Jun 2019 20:13:30 GMT&#xA;&amp;lt; Content-Length: 3&#xA;&amp;lt; Content-Type: text/plain; charset=utf-8&#xA;&amp;lt; &#xA;* Connection #0 to host localhost left intact&#xA;foo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing Handlers&lt;/h3&gt; &#xA;&lt;p&gt;Testing handlers in a Go web application is straightforward, and &lt;em&gt;mux&lt;/em&gt; doesn&#39;t complicate this any further. Given two files: &lt;code&gt;endpoints.go&lt;/code&gt; and &lt;code&gt;endpoints_test.go&lt;/code&gt;, here&#39;s how we&#39;d test an application using &lt;em&gt;mux&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First, our simple HTTP handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// endpoints.go&#xA;package main&#xA;&#xA;func HealthCheckHandler(w http.ResponseWriter, r *http.Request) {&#xA;    // A very simple health check.&#xA;    w.Header().Set(&#34;Content-Type&#34;, &#34;application/json&#34;)&#xA;    w.WriteHeader(http.StatusOK)&#xA;&#xA;    // In the future we could report back on the status of our DB, or our cache&#xA;    // (e.g. Redis) by performing a simple PING, and include them in the response.&#xA;    io.WriteString(w, `{&#34;alive&#34;: true}`)&#xA;}&#xA;&#xA;func main() {&#xA;    r := mux.NewRouter()&#xA;    r.HandleFunc(&#34;/health&#34;, HealthCheckHandler)&#xA;&#xA;    log.Fatal(http.ListenAndServe(&#34;localhost:8080&#34;, r))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our test code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// endpoints_test.go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;net/http&#34;&#xA;    &#34;net/http/httptest&#34;&#xA;    &#34;testing&#34;&#xA;)&#xA;&#xA;func TestHealthCheckHandler(t *testing.T) {&#xA;    // Create a request to pass to our handler. We don&#39;t have any query parameters for now, so we&#39;ll&#xA;    // pass &#39;nil&#39; as the third parameter.&#xA;    req, err := http.NewRequest(&#34;GET&#34;, &#34;/health&#34;, nil)&#xA;    if err != nil {&#xA;        t.Fatal(err)&#xA;    }&#xA;&#xA;    // We create a ResponseRecorder (which satisfies http.ResponseWriter) to record the response.&#xA;    rr := httptest.NewRecorder()&#xA;    handler := http.HandlerFunc(HealthCheckHandler)&#xA;&#xA;    // Our handlers satisfy http.Handler, so we can call their ServeHTTP method&#xA;    // directly and pass in our Request and ResponseRecorder.&#xA;    handler.ServeHTTP(rr, req)&#xA;&#xA;    // Check the status code is what we expect.&#xA;    if status := rr.Code; status != http.StatusOK {&#xA;        t.Errorf(&#34;handler returned wrong status code: got %v want %v&#34;,&#xA;            status, http.StatusOK)&#xA;    }&#xA;&#xA;    // Check the response body is what we expect.&#xA;    expected := `{&#34;alive&#34;: true}`&#xA;    if rr.Body.String() != expected {&#xA;        t.Errorf(&#34;handler returned unexpected body: got %v want %v&#34;,&#xA;            rr.Body.String(), expected)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the case that our routes have &lt;a href=&#34;https://raw.githubusercontent.com/gorilla/mux/master/#examples&#34;&gt;variables&lt;/a&gt;, we can pass those in the request. We could write &lt;a href=&#34;https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go&#34;&gt;table-driven tests&lt;/a&gt; to test multiple possible route variables as needed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// endpoints.go&#xA;func main() {&#xA;    r := mux.NewRouter()&#xA;    // A route with a route variable:&#xA;    r.HandleFunc(&#34;/metrics/{type}&#34;, MetricsHandler)&#xA;&#xA;    log.Fatal(http.ListenAndServe(&#34;localhost:8080&#34;, r))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our test file, with a table-driven test of &lt;code&gt;routeVariables&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// endpoints_test.go&#xA;func TestMetricsHandler(t *testing.T) {&#xA;    tt := []struct{&#xA;        routeVariable string&#xA;        shouldPass bool&#xA;    }{&#xA;        {&#34;goroutines&#34;, true},&#xA;        {&#34;heap&#34;, true},&#xA;        {&#34;counters&#34;, true},&#xA;        {&#34;queries&#34;, true},&#xA;        {&#34;adhadaeqm3k&#34;, false},&#xA;    }&#xA;&#xA;    for _, tc := range tt {&#xA;        path := fmt.Sprintf(&#34;/metrics/%s&#34;, tc.routeVariable)&#xA;        req, err := http.NewRequest(&#34;GET&#34;, path, nil)&#xA;        if err != nil {&#xA;            t.Fatal(err)&#xA;        }&#xA;&#xA;        rr := httptest.NewRecorder()&#xA;&#x9;&#xA;&#x9;// Need to create a router that we can pass the request through so that the vars will be added to the context&#xA;&#x9;router := mux.NewRouter()&#xA;        router.HandleFunc(&#34;/metrics/{type}&#34;, MetricsHandler)&#xA;        router.ServeHTTP(rr, req)&#xA;&#xA;        // In this case, our MetricsHandler returns a non-200 response&#xA;        // for a route variable it doesn&#39;t know about.&#xA;        if rr.Code == http.StatusOK &amp;amp;&amp;amp; !tc.shouldPass {&#xA;            t.Errorf(&#34;handler should have failed on routeVariable %s: got %v want %v&#34;,&#xA;                tc.routeVariable, rr.Code, http.StatusOK)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Full Example&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a complete, runnable example of a small &lt;code&gt;mux&lt;/code&gt; based server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;    &#34;net/http&#34;&#xA;    &#34;log&#34;&#xA;    &#34;github.com/gorilla/mux&#34;&#xA;)&#xA;&#xA;func YourHandler(w http.ResponseWriter, r *http.Request) {&#xA;    w.Write([]byte(&#34;Gorilla!\n&#34;))&#xA;}&#xA;&#xA;func main() {&#xA;    r := mux.NewRouter()&#xA;    // Routes consist of a path and a handler function.&#xA;    r.HandleFunc(&#34;/&#34;, YourHandler)&#xA;&#xA;    // Bind to a port and pass our router in&#xA;    log.Fatal(http.ListenAndServe(&#34;:8000&#34;, r))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;BSD licensed. See the LICENSE file for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Mikaelemmmm/go-zero-looklook</title>
    <updated>2022-08-11T01:41:36Z</updated>
    <id>tag:github.com,2022-08-11:/Mikaelemmmm/go-zero-looklook</id>
    <link href="https://github.com/Mikaelemmmm/go-zero-looklook" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üî•Âü∫‰∫égo-zero(go zero) ÂæÆÊúçÂä°ÂÖ®ÊäÄÊúØÊ†àÂºÄÂèëÊúÄ‰Ω≥ÂÆûË∑µÈ°πÁõÆ„ÄÇDevelop best practice projects based on the full technology stack of go zero (go zero) microservices.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;go-zero-looklook&lt;/h2&gt; &#xA;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/Mikaelemmmm/go-zero-looklook/main/README-cn.md&#34;&gt;ÁÆÄ‰Ωì‰∏≠Êñá&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;h4&gt;The old rule is to give a star before you see it. Ha ~ ~, if the star is caught, you have to spank, ha ha&lt;/h4&gt; &#xA;&lt;p&gt;I may have contacted go zero earlier. I have been using go zero since about 1000star. Later, I became familiar with the go zero author through wechat. The go zero author was very enthusiastic and patient to help me answer many questions. I also want to actively help go zero promote the community, Basically, I answered the relevant questions in the community group, because in this process, I found that many people felt that go zero did not have a complete project example. As a member of the community who wanted to promote the community, I made an available version open source. The main technology stack includes the followingÔºö&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;k8s&lt;/li&gt; &#xA; &lt;li&gt;go-zero&lt;/li&gt; &#xA; &lt;li&gt;nginx-gateway&lt;/li&gt; &#xA; &lt;li&gt;filebeat&lt;/li&gt; &#xA; &lt;li&gt;kafka&lt;/li&gt; &#xA; &lt;li&gt;go-stash&lt;/li&gt; &#xA; &lt;li&gt;elasticsearch&lt;/li&gt; &#xA; &lt;li&gt;kibana&lt;/li&gt; &#xA; &lt;li&gt;prometheus&lt;/li&gt; &#xA; &lt;li&gt;grafana&lt;/li&gt; &#xA; &lt;li&gt;jaeger&lt;/li&gt; &#xA; &lt;li&gt;go-queue&lt;/li&gt; &#xA; &lt;li&gt;asynq&lt;/li&gt; &#xA; &lt;li&gt;asynqmon&lt;/li&gt; &#xA; &lt;li&gt;dtm&lt;/li&gt; &#xA; &lt;li&gt;docker&lt;/li&gt; &#xA; &lt;li&gt;docker-compose&lt;/li&gt; &#xA; &lt;li&gt;mysql&lt;/li&gt; &#xA; &lt;li&gt;redis&lt;/li&gt; &#xA; &lt;li&gt;modd&lt;/li&gt; &#xA; &lt;li&gt;jenkins&lt;/li&gt; &#xA; &lt;li&gt;gitlab&lt;/li&gt; &#xA; &lt;li&gt;harbor&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tutorial video&lt;/h2&gt; &#xA;&lt;p&gt;This is the go zero tutorial I&#39;m recording Ôºö&lt;a href=&#34;https://www.bilibili.com/medialist/play/389552232?from=space&amp;amp;business=space_series&amp;amp;business_id=2122723&amp;amp;desc=1&#34;&gt;https://www.bilibili.com/medialist/play/389552232?from=space&amp;amp;business=space_series&amp;amp;business_id=2122723&amp;amp;desc=1&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;At the end of this tutorial, we will also share go-zero -looklook. Please look forward to itÔΩû&lt;/p&gt; &#xA;&lt;h2&gt;Doc&lt;/h2&gt; &#xA;&lt;p&gt;Documentation can de found under &lt;a href=&#34;https://raw.githubusercontent.com/Mikaelemmmm/go-zero-looklook/main/doc/english/&#34;&gt;doc/english&lt;/a&gt; in the project.&lt;/p&gt; &#xA;&lt;p&gt;Docker compose is recommended in the development environment of the project. The direct chain method is used to give up the trouble caused by service registration and discovery middleware (etcd, nacos, consul ...)&lt;/p&gt; &#xA;&lt;p&gt;For testing and online deployment, k8s (etcd, Nacos, consumer, etc.) has detailed tutorials (build + deploy), which can be communicated in the go zero community group, which is very easy&lt;/p&gt; &#xA;&lt;h2&gt;Project Summary&lt;/h2&gt; &#xA;&lt;p&gt;The whole project uses the micro services developed by go zero, which basically includes go zero and some middleware developed by relevant go zero authors. The technology stack used is basically the self-developed component of the go zero project team, which is basically the go zero software&lt;/p&gt; &#xA;&lt;p&gt;The project directory structure is as followsÔºö&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;appÔºöAll business codes include API, RPC and MQ (message queue, delay queue, scheduled task)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;commonÔºöGeneral components ( error„ÄÅmiddleware„ÄÅinterceptor„ÄÅtool„ÄÅctxdata ...)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;dataÔºöThe project contains the data generated by the directory relying on all middleware (mysql, ES, redis, grafana, ...). All contents in this directory should be in Git ignore files and do not need to be submitted.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deployÔºö&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;filebeat: docker deployment filebeat config&lt;/li&gt; &#xA;   &lt;li&gt;go-stashÔºögo-stash config&lt;/li&gt; &#xA;   &lt;li&gt;nginx: nginx-gateway config&lt;/li&gt; &#xA;   &lt;li&gt;prometheus Ôºö prometheus config&lt;/li&gt; &#xA;   &lt;li&gt;scriptÔºö &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;gencodeÔºöauto generate api„ÄÅrpcÔºåand use kafka script Ôºåcopy and paste use&lt;/li&gt; &#xA;     &lt;li&gt;mysqlÔºöauto generate model code shell script&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;goctl: The template and goctl of the project generate custom code templates. For the usage of template, refer to the go zero document and copy it to the home directory Goctl is enough&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;doc : This project series documents&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;modd.conf : Don&#39;t be afraid of Modd hot loading configuration file. It&#39;s very simple to use. You can learn more about Modd usage here: &lt;a href=&#34;https://github.com/cortesi/modd&#34;&gt;https://github.com/cortesi/modd&lt;/a&gt; , the image of this project only uses golang-1.17.7-alpine as the basic image and installs Modd internally. If you want to add goctl, protoc, golint, etc., it&#39;s the same to directly create an image without my image&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;System architecture diagram&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Mikaelemmmm/go-zero-looklook/main/doc/chinese/images/1/gozerolooklook.png&#34; alt=&#34;jiagou&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Business architecture diagram&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Mikaelemmmm/go-zero-looklook/main/doc/chinese/images/1/go-zero-looklook-service.png&#34; alt=&#34;jiagou&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Gateway&lt;/h2&gt; &#xA;&lt;p&gt;nginx do external gateway, gateway in front of the slb, in addition, many students feel that nginx do not do gateway is not very good, this piece of principle is basically the same, you can replace it with apisix, kong, etc.&lt;/p&gt; &#xA;&lt;h2&gt;Development mode&lt;/h2&gt; &#xA;&lt;p&gt;This project uses microservice development, API (HTTP) + RPC (grpc). The API acts as an aggregation service, and the complex and related business calls are uniformly written in RPC. If some simple businesses will not be relied on by other services, they can be directly written in the logic of API&lt;/p&gt; &#xA;&lt;h2&gt;Log&lt;/h2&gt; &#xA;&lt;p&gt;For logs, filebeat is used to collect them and report them to Kafka. Because logstash knows everything and the resource occupation is too exaggerated, go stash is used instead of logstash&lt;/p&gt; &#xA;&lt;p&gt;Link: &lt;a href=&#34;https://github.com/kevwan/go-stash&#34;&gt;https://github.com/kevwan/go-stash&lt;/a&gt; , go stash is developed by the go zero development team. It has high performance and does not occupy resources. There is not much main code. It can be used only by configuration. It is very simple. The Kafka data source is synchronized to elasticsearch. The elasticsearch account and password are not supported by default. I fork a copy and modify it. It simply supports the account and password&lt;/p&gt; &#xA;&lt;h2&gt;Monitor&lt;/h2&gt; &#xA;&lt;p&gt;Prometheus is used for monitoring. This go zero native support only requires configuration. Here you can see the configuration in the project&lt;/p&gt; &#xA;&lt;h2&gt;Link tracking&lt;/h2&gt; &#xA;&lt;p&gt;Go zero supports Jaeger and Zipkin by default. You only need to configure it. You can see the configuration&lt;/p&gt; &#xA;&lt;h2&gt;Pub\Sub&lt;/h2&gt; &#xA;&lt;p&gt;kafka ÔºåPublish subscription using go-zero development team developed by go-queue, link: &lt;a href=&#34;https://github.com/zeromicro/go-queue&#34;&gt;https://github.com/zeromicro/go-queue&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here we use kq, kq is based on kafka to do high-performance publish subscriptions&lt;/p&gt; &#xA;&lt;h2&gt;Message queues, delayed queues, timed tasks&lt;/h2&gt; &#xA;&lt;p&gt;Message queues, delay queues, timed tasks This project uses asynq, a simple middleware developed based on redis.&lt;/p&gt; &#xA;&lt;p&gt;Of course, the message queue you can also use go-queue&lt;/p&gt; &#xA;&lt;p&gt;Link: &lt;a href=&#34;https://github.com/hibiken/asynq&#34;&gt;https://github.com/hibiken/asynq&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Distributed transaction&lt;/h2&gt; &#xA;&lt;p&gt;DTM is used for distributed transactions. Well, it&#39;s very comfortable. I wrote a &#34;go zero nanny tutorial on connecting distributed transactions with DTM&#34; link address: &lt;a href=&#34;https://github.com/Mikaelemmmm/gozerodtm&#34;&gt;https://github.com/Mikaelemmmm/gozerodtm&lt;/a&gt; , this project has not been used yet. It&#39;s good to prepare for direct integration in the future. If readers use it, they can directly look at the source code&lt;/p&gt; &#xA;&lt;p&gt;Dtm Link : &lt;a href=&#34;https://github.com/dtm-labs/dtm&#34;&gt;https://github.com/dtm-labs/dtm&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Deploy&lt;/h2&gt; &#xA;&lt;p&gt;Docker compose is recommended in the development environment of the project. The direct chain method is used to give up the trouble caused by service registration and discovery middleware (etcd, Nacos, consul, ...)&lt;/p&gt; &#xA;&lt;p&gt;For testing and online deployment, k8s (etcd, Nacos, consumer, etc.) has detailed tutorials (build + deploy), which can be communicated in the go zero community group, which is very easy&lt;/p&gt; &#xA;&lt;p&gt;project doc Ôºö&lt;a href=&#34;https://raw.githubusercontent.com/Mikaelemmmm/go-zero-looklook/main/doc/&#34;&gt;https://github.com/Mikaelemmmm/go-zero-looklook/tree/main/doc&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;gitlab + jenkins + harbor + k8s&lt;/p&gt; &#xA;&lt;p&gt;Click in jenkins to deploy the corresponding service, will go to gitlab to pull the code --&amp;gt; then go to pull the online configuration (online configuration of a separate git repository, why not use the configuration center, the deployment documentation has an introduction) ----&amp;gt; automatically build the image --&amp;gt; push to harbor mirror repository --&amp;gt; use kubectl to automatically publish to k8s ----&amp;gt; in front to hang a nginx do gateway unified portal&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;go-zero : &lt;a href=&#34;https://github.com/zeromicro/go-zero&#34;&gt;https://github.com/zeromicro/go-zero&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;dtmÔºö&lt;a href=&#34;https://github.com/dtm-labs/dtm&#34;&gt;https://github.com/dtm-labs/dtm&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>DataDog/datadog-agent</title>
    <updated>2022-08-11T01:41:36Z</updated>
    <id>tag:github.com,2022-08-11:/DataDog/datadog-agent</id>
    <link href="https://github.com/DataDog/datadog-agent" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Datadog Agent&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Datadog Agent&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/DataDog/datadog-agent/tree/main&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/DataDog/datadog-agent/tree/main.svg?style=svg&amp;amp;circle-token=dbcee3f02b9c3fe5f142bfc5ecb735fdec34b643&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/DataDog/datadog-agent/actions/workflows/windows-unittests.yml&#34;&gt;&lt;img src=&#34;https://github.com/DataDog/datadog-agent/actions/workflows/windows-unittests.yml/badge.svg?sanitize=true&#34; alt=&#34;Windows unit tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/github/DataDog/datadog-agent?branch=main&#34;&gt;&lt;img src=&#34;https://codecov.io/github/DataDog/datadog-agent/coverage.svg?branch=main&#34; alt=&#34;Coverage status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/DataDog/datadog-agent&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/DataDog/datadog-agent?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/DataDog/datadog-agent&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/DataDog/datadog-agent&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The present repository contains the source code of the Datadog Agent version 7 and version 6. Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/docs/agent&#34;&gt;Agent user documentation&lt;/a&gt; for information about differences between Agent v5, Agent v6 and Agent v7. Additionally, we provide a list of prepackaged binaries for an easy install process &lt;a href=&#34;https://app.datadoghq.com/account/settings#agent&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the source code of Datadog Agent v5 is located in the &lt;a href=&#34;https://github.com/DataDog/dd-agent&#34;&gt;dd-agent&lt;/a&gt; repository.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The general documentation of the project, including instructions for installation and development, is located under &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/docs&#34;&gt;the docs directory&lt;/a&gt; of the present repo.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;To build the Agent you need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://golang.org/doc/install&#34;&gt;Go&lt;/a&gt; 1.17 or later. You&#39;ll also need to set your &lt;code&gt;$GOPATH&lt;/code&gt; and have &lt;code&gt;$GOPATH/bin&lt;/code&gt; in your path.&lt;/li&gt; &#xA; &lt;li&gt;Python 3.7+ along with development libraries for tooling. You will also need Python 2.7 if you are building the Agent with Python 2 support.&lt;/li&gt; &#xA; &lt;li&gt;Python dependencies. You may install these with &lt;code&gt;pip install -r requirements.txt&lt;/code&gt; This will also pull in &lt;a href=&#34;http://www.pyinvoke.org&#34;&gt;Invoke&lt;/a&gt; if not yet installed.&lt;/li&gt; &#xA; &lt;li&gt;CMake version 3.12 or later and a C++ compiler&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; you may want to use a python virtual environment to avoid polluting your system-wide python environment with the agent build/dev dependencies. You can create a virtual environment using &lt;code&gt;virtualenv&lt;/code&gt; and then use the &lt;code&gt;invoke agent.build&lt;/code&gt; parameters &lt;code&gt;--python-home-2=&amp;lt;venv_path&amp;gt;&lt;/code&gt; and/or &lt;code&gt;--python-home-3=&amp;lt;venv_path&amp;gt;&lt;/code&gt; (depending on the python versions you are using) to use the virtual environment&#39;s interpreter and libraries. By default, this environment is only used for dev dependencies listed in &lt;code&gt;requirements.txt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You may have previously installed &lt;code&gt;invoke&lt;/code&gt; via brew on MacOS, or &lt;code&gt;pip&lt;/code&gt; in any other platform. We recommend you use the version pinned in the requirements file for a smooth development/build experience.&lt;/p&gt; &#xA;&lt;p&gt;Builds and tests are orchestrated with &lt;code&gt;invoke&lt;/code&gt;, type &lt;code&gt;invoke --list&lt;/code&gt; on a shell to see the available tasks.&lt;/p&gt; &#xA;&lt;p&gt;To start working on the Agent, you can build the &lt;code&gt;main&lt;/code&gt; branch:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Checkout the repo: &lt;code&gt;git clone https://github.com/DataDog/datadog-agent.git $GOPATH/src/github.com/DataDog/datadog-agent&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;cd into the project folder: &lt;code&gt;cd $GOPATH/src/github.com/DataDog/datadog-agent&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install go tools: &lt;code&gt;invoke install-tools&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a development &lt;code&gt;datadog.yaml&lt;/code&gt; configuration file in &lt;code&gt;dev/dist/datadog.yaml&lt;/code&gt;, containing a valid API key: &lt;code&gt;api_key: &amp;lt;API_KEY&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the agent with &lt;code&gt;invoke agent.build --build-exclude=systemd&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;By default, the Agent will be built to use Python 3 but you can select which Python version you want to use:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;invoke agent.build --python-runtimes 2&lt;/code&gt; for Python2 only&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;invoke agent.build --python-runtimes 3&lt;/code&gt; for Python3 only&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;invoke agent.build --python-runtimes 2,3&lt;/code&gt; for both Python2 and Python3&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;You can specify a custom Python location for the agent (useful when using virtualenvs):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;invoke agent.build \&#xA;  --python-runtimes 2,3 \&#xA;  --python-home-2=$GOPATH/src/github.com/DataDog/datadog-agent/venv2 \&#xA;  --python-home-3=$GOPATH/src/github.com/DataDog/datadog-agent/venv3 .&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Running &lt;code&gt;invoke agent.build&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Discards any changes done in &lt;code&gt;bin/agent/dist&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Builds the Agent and writes the binary to &lt;code&gt;bin/agent/agent&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Copies files from &lt;code&gt;dev/dist&lt;/code&gt; to &lt;code&gt;bin/agent/dist&lt;/code&gt;. See &lt;code&gt;https://github.com/DataDog/datadog-agent/blob/main/dev/dist/README.md&lt;/code&gt; for more information.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;If you built an older version of the agent, you may have the error &lt;code&gt;make: *** No targets specified and no makefile found. Stop.&lt;/code&gt;. To solve the issue, you should remove &lt;code&gt;CMakeCache.txt&lt;/code&gt; from &lt;code&gt;rtloader&lt;/code&gt; folder with &lt;code&gt;rm rtloader/CMakeCache.txt&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/docs/dev/README.md&#34;&gt;Agent Developer Guide&lt;/a&gt; for more details. For instructions on setting up a windows dev environment, refer to &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/devenv&#34;&gt;Windows Dev Env&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Run tests using &lt;code&gt;invoke test&lt;/code&gt;. During development, add the &lt;code&gt;--skip-linters&lt;/code&gt; option to skip straight to the tests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;invoke test --targets=./pkg/aggregator/... --skip-linters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When testing code that depends on &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/rtloader&#34;&gt;rtloader&lt;/a&gt;, build and install it first.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;invoke rtloader.make &amp;amp;&amp;amp; invoke rtloader.install&#xA;invoke test --targets=./pkg/collector/python --skip-linters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Run&lt;/h2&gt; &#xA;&lt;p&gt;You can run the agent with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./bin/agent/agent run -c bin/agent/dist/datadog.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The file &lt;code&gt;bin/agent/dist/datadog.yaml&lt;/code&gt; is copied from &lt;code&gt;dev/dist/datadog.yaml&lt;/code&gt; by &lt;code&gt;invoke agent.build&lt;/code&gt; and must contain a valid api key.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing code&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;ll find information and help on how to contribute code to this project under &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/docs/dev&#34;&gt;the &lt;code&gt;docs/dev&lt;/code&gt; directory&lt;/a&gt; of the present repo.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The Datadog agent user space components are licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/LICENSE&#34;&gt;Apache License, Version 2.0&lt;/a&gt;. The BPF code is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/datadog-agent/main/pkg/ebpf/c/COPYING&#34;&gt;General Public License, Version 2.0&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>