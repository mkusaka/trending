<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-03T01:33:31Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Carpe-Wang/GoRedis</title>
    <updated>2023-01-03T01:33:31Z</updated>
    <id>tag:github.com,2023-01-03:/Carpe-Wang/GoRedis</id>
    <link href="https://github.com/Carpe-Wang/GoRedis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Go实现简易redis&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GoRedis(该项目为本人2023年河南工业大学本科毕业课设)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carpe-Wang/GoRedis#readme&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carpe-Wang/GoRedis/raw/main/English.md&#34;&gt;English&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;项目简介&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;使用go语言实现Redis的基础命令，比如set，get和AOF等基础功能。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;使用方法&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;单机启动&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;直接启动程序即可。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;集群启动&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;通过&lt;code&gt;go build&lt;/code&gt;命令生成可执行文件。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;把可执行文件单独放到一个文件夹，注：文件夹中需要包含配置(redis.conf)。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;port不可重复，self为自己的ip+端口号，peers为集群中另外的ip+端口号。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;pre&gt;&lt;code&gt;bind 0.0.0.0&#xA;port 6379&#xA;&#xA;appendonly yes&#xA;appendfilename appendonly.aof&#xA;&#xA;self 127.0.0.1:6379&#xA;peers 127.0.0.1:6380&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;之后macOS或者linux进入相对应的文件夹执行&lt;code&gt;./goRedis&lt;/code&gt;即可运行&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;运行之后可以看到&lt;code&gt;[INFO][server.go:42] 2022/10/09 10:36:47 bind: 0.0.0.0:6380, start listening...&lt;/code&gt;。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;通过网络调试助手连接TCP客户端&lt;code&gt;[INFO][server.go:71] 2022/10/09 10:37:30 accept link&lt;/code&gt;。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;即可正常发送命令。&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;日志&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;日志信息信息主要记录项目启动时间。&lt;/li&gt; &#xA; &lt;li&gt;是否有连接，连接时间等。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;AOF&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;主要通过项目下的appendonly.aof记录操作信息。&lt;/li&gt; &#xA; &lt;li&gt;再重启系统时进行LoadAof防止重启机器信息丢失。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;注：简易先看一下Resp协议，方便后期发送请求&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;*3/r/n$3/r/nset/r/n$4/r/nname/r/n$5/r/npdudo/r/n&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;注释：mac&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;因为我本身使用的是macOS，在使用RESP的时候没办法直接用网络调试助手发送tcp，只能采用telnet命令。 注意重点就是需要先下载Homebrew，才能在mac的终端上执行命令。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;成果展示&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;启动 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Carpe-Wang/GoRedis/main/img/img.png&#34; alt=&#34;img.png&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;set测试 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Carpe-Wang/GoRedis/main/img/img_1.png&#34; alt=&#34;img_1.png&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;AOF效果 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Carpe-Wang/GoRedis/main/img/img_3.png&#34; alt=&#34;img_3.png&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Get测试 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Carpe-Wang/GoRedis/main/img/img_2.png&#34; alt=&#34;img_2.png&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;毕设准备&lt;/h1&gt; &#xA;&lt;h3&gt;为什么选择本课题&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;因为看到Http3弃用TCP作为传输层协议通信方式，于是我想用自己的方式记录一下TCP。&lt;/li&gt; &#xA; &lt;li&gt;对于后端软件开发来说，Redis是一个仅次于数据库的至关重要的部分。并且可以弥补多次请求数据库带来的IO请求的时间浪费。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Redis为什么快&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;因为在计算机组成原理中，我们可以了解到，访问时间的快慢排序为：寄存器&amp;lt;L1,L2,L3缓存&amp;lt;内存&amp;lt;固态硬盘&amp;lt;机械硬盘。在Redis中，存储在内存中，然后持久化是存储在硬盘上，所以速度也会比传统数据库要更快。&lt;/li&gt; &#xA; &lt;li&gt;Redis的多路复用“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。&lt;/li&gt; &#xA; &lt;li&gt;完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;和传统数据库的区别&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Redis是非关系型数据库，是基于键值对的对应关系，用于超大规模数据的存储。&lt;/li&gt; &#xA; &lt;li&gt;nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。&lt;/li&gt; &#xA; &lt;li&gt;性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;设计细节&lt;/h1&gt; &#xA;&lt;h3&gt;简易TCP服务器&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TCP相关配置参考&lt;code&gt;config.config&lt;/code&gt;和&lt;code&gt;redis.conf&lt;/code&gt;配置文件&lt;/li&gt; &#xA; &lt;li&gt;项目中源码&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (h *EchoHandler) Handle(ctx context.Context, conn net.Conn) {&#xA;&#x9;if h.closing.Get() {&#xA;&#x9;&#x9;// closing handler refuse new connection&#xA;&#x9;&#x9;_ = conn.Close()&#xA;&#x9;}&#xA;&#xA;&#x9;client := &amp;amp;EchoClient{&#xA;&#x9;&#x9;Conn: conn,&#xA;&#x9;}&#xA;&#x9;h.activeConn.Store(client, struct{}{})&#xA;&#xA;&#x9;reader := bufio.NewReader(conn)&#xA;&#x9;for {&#xA;&#x9;&#x9;// may occurs: client EOF, client timeout, handler early close&#xA;&#x9;&#x9;msg, err := reader.ReadString(&#39;\n&#39;)&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;if err == io.EOF {&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(&#34;connection close&#34;)&#xA;&#x9;&#x9;&#x9;&#x9;h.activeConn.Delete(client)&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;logger.Warn(err)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;client.Waiting.Add(1)&#xA;&#x9;&#x9;b := []byte(msg)&#xA;&#x9;&#x9;_, _ = conn.Write(b)&#xA;&#x9;&#x9;client.Waiting.Done()&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;其中Context包主要用来传递超时时间，目前环境，参数等，Conn主要用来处理&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Config struct {&#xA;&#x9;Address    string        `yaml:&#34;address&#34;`&#xA;&#x9;MaxConnect uint32        `yaml:&#34;max-connect&#34;`&#xA;&#x9;Timeout    time.Duration `yaml:&#34;timeout&#34;`&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;在tcp包下的server层定义结构体，用来设定一些链接细节。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ListenAndServeWithSignal(cfg *Config, handler tcp.Handler) error {&#xA;&#x9;closeChan := make(chan struct{})&#xA;&#x9;sigCh := make(chan os.Signal)&#xA;&#x9;signal.Notify(sigCh, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)&#xA;&#x9;go func() {&#xA;&#x9;&#x9;sig := &amp;lt;-sigCh&#xA;&#x9;&#x9;switch sig {&#xA;&#x9;&#x9;case syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:&#xA;&#x9;&#x9;&#x9;closeChan &amp;lt;- struct{}{}&#xA;&#x9;&#x9;}&#xA;&#x9;}()&#xA;&#x9;listener, err := net.Listen(&#34;tcp&#34;, cfg.Address)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return err&#xA;&#x9;}&#xA;&#x9;logger.Info(fmt.Sprintf(&#34;bind: %s, start listening...&#34;, cfg.Address))&#xA;&#x9;ListenAndServe(listener, handler, closeChan)&#xA;&#x9;return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;用来监听连接，所以&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ListenAndServe(listener net.Listener, handler tcp.Handler, closeChan &amp;lt;-chan struct{}) {&#xA;&#x9;// listen signal&#xA;&#x9;go func() {&#xA;&#x9;&#x9;&amp;lt;-closeChan&#xA;&#x9;&#x9;logger.Info(&#34;shutting down...&#34;)&#xA;&#x9;&#x9;_ = listener.Close() // listener.Accept() will return err immediately&#xA;&#x9;&#x9;_ = handler.Close()  // close connections&#xA;&#x9;}()&#xA;&#xA;&#x9;// listen port&#xA;&#x9;defer func() {&#xA;&#x9;&#x9;// close during unexpected error&#xA;&#x9;&#x9;_ = listener.Close()&#xA;&#x9;&#x9;_ = handler.Close()&#xA;&#x9;}()&#xA;&#x9;ctx := context.Background()&#xA;&#x9;var waitDone sync.WaitGroup&#xA;&#x9;for {&#xA;&#x9;&#x9;conn, err := listener.Accept()&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// handle&#xA;&#x9;&#x9;logger.Info(&#34;accept link&#34;)&#xA;&#x9;&#x9;waitDone.Add(1)&#xA;&#x9;&#x9;go func() {&#xA;&#x9;&#x9;&#x9;defer func() {&#xA;&#x9;&#x9;&#x9;&#x9;waitDone.Done()&#xA;&#x9;&#x9;&#x9;}()&#xA;&#x9;&#x9;&#x9;handler.Handle(ctx, conn)&#xA;&#x9;&#x9;}()&#xA;&#x9;}&#xA;&#x9;waitDone.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;一直死循环，除非连接出问题。这样实现一直在等待链接。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;RESP协议&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;什么是RESP协议&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;RESP 是 Redis 序列化协议的简写。它是⼀种直观的⽂本协议，优势在于实现异常简单，解析性能极好。 Redis 协议将传输的结构数据分为 5 种最⼩单元类型，单元结束时统⼀加上回⻋换⾏符号\r\n。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;细节如下： &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt;单⾏字符串 以 + 符号开头。&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &#xA;    &lt;ol start=&#34;2&#34;&gt; &#xA;     &lt;li&gt;多⾏字符串 以 $ 符号开头，后跟字符串⻓度。&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &#xA;    &lt;ol start=&#34;3&#34;&gt; &#xA;     &lt;li&gt;整数值 以 : 符号开头，后跟整数的字符串形式。&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &#xA;    &lt;ol start=&#34;4&#34;&gt; &#xA;     &lt;li&gt;错误消息 以 - 符号开头。&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &#xA;    &lt;ol start=&#34;5&#34;&gt; &#xA;     &lt;li&gt;数组 以 * 号开头，后跟数组的⻓度。&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;示例： &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &#xA;    &lt;blockquote&gt; &#xA;     &lt;p&gt;单⾏字符串 hello world +hello world\r\n&lt;/p&gt; &#xA;    &lt;/blockquote&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &#xA;    &lt;blockquote&gt; &#xA;     &lt;p&gt;多⾏字符串 hello world $11\r\nhello world\r\n&lt;/p&gt; &#xA;    &lt;/blockquote&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &#xA;    &lt;blockquote&gt; &#xA;     &lt;p&gt;整数 1024 :1024\r\n&lt;/p&gt; &#xA;    &lt;/blockquote&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;go语言实现RESP协议解析&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;详细参考resp目录下的代码实现，这里只展示核心 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Connection struct {&#xA;    conn net.Conn&#xA;    // waiting until reply finished&#xA;    waitingReply wait.Wait&#xA;    // lock while handler sending response&#xA;    mu sync.Mutex&#xA;    // selected db&#xA;    selectedDB int&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt;细节参考resp.parser.parser.go&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;为什么选择go语言&lt;/h1&gt; &#xA;&lt;h3&gt;go语言的特点&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;性能&lt;/li&gt; &#xA; &lt;li&gt;轻量级&lt;/li&gt; &#xA; &lt;li&gt;开发者效率(特别是web开发)&lt;/li&gt; &#xA; &lt;li&gt;并发性较好(Goroutines)&lt;/li&gt; &#xA; &lt;li&gt;快速的编译时间&lt;/li&gt; &#xA; &lt;li&gt;强大的生态系统&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;go和java的区别&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go语言拥有简明的类型系统、函数式编程范式和先进的并发编程模型。因此其代码块更小更简洁、可重用性更高，并可在多核计算环境下更快地运行。&lt;/li&gt; &#xA; &lt;li&gt;Java是一种静态面向对象编程语言，继承了很多的C++优点，功能强大、简单易用、跨平台可移植，具有多线程、分布式等特点。入门学习不难，随着项目经验的积累逐步提升进阶。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;@Author:Wangkaipeng&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>miniflux/v2</title>
    <updated>2023-01-03T01:33:31Z</updated>
    <id>tag:github.com,2023-01-03:/miniflux/v2</id>
    <link href="https://github.com/miniflux/v2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimalist and opinionated feed reader&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Miniflux 2&lt;/h1&gt; &#xA;&lt;p&gt;Miniflux is a minimalist and opinionated feed reader:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Written in Go (Golang)&lt;/li&gt; &#xA; &lt;li&gt;Works only with Postgresql&lt;/li&gt; &#xA; &lt;li&gt;Doesn&#39;t use any ORM&lt;/li&gt; &#xA; &lt;li&gt;Doesn&#39;t use any complicated framework&lt;/li&gt; &#xA; &lt;li&gt;Use only modern vanilla Javascript (ES6 and Fetch API)&lt;/li&gt; &#xA; &lt;li&gt;Single binary compiled statically without dependency&lt;/li&gt; &#xA; &lt;li&gt;The number of features is voluntarily limited&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It&#39;s simple, fast, lightweight and super easy to install.&lt;/p&gt; &#xA;&lt;p&gt;Official website: &lt;a href=&#34;https://miniflux.app&#34;&gt;https://miniflux.app&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The Miniflux documentation is available here: &lt;a href=&#34;https://miniflux.app/docs/&#34;&gt;https://miniflux.app/docs/&lt;/a&gt; (&lt;a href=&#34;https://miniflux.app/miniflux.1.html&#34;&gt;Man page&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/opinionated.html&#34;&gt;Opinionated?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/features.html&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/requirements.html&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/installation.html&#34;&gt;Installation Instructions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/upgrade.html&#34;&gt;Upgrading to a New Version&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/configuration.html&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/cli.html&#34;&gt;Command Line Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/ui.html&#34;&gt;User Interface Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/keyboard_shortcuts.html&#34;&gt;Keyboard Shortcuts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/services.html&#34;&gt;Integration with External Services&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/rules.html&#34;&gt;Rewrite and Scraper Rules&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/api.html&#34;&gt;API Reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/development.html&#34;&gt;Development&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/docs/i18n.html&#34;&gt;Internationalization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://miniflux.app/faq.html&#34;&gt;Frequently Asked Questions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;p&gt;Default theme:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://miniflux.app/images/overview.png&#34; alt=&#34;Default theme&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Dark theme when using keyboard navigation:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://miniflux.app/images/item-selection-black-theme.png&#34; alt=&#34;Dark theme&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Authors: Frédéric Guillot - &lt;a href=&#34;https://github.com/miniflux/v2/graphs/contributors&#34;&gt;List of contributors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Distributed under Apache 2.0 License&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>lucas-clemente/quic-go</title>
    <updated>2023-01-03T01:33:31Z</updated>
    <id>tag:github.com,2023-01-03:/lucas-clemente/quic-go</id>
    <link href="https://github.com/lucas-clemente/quic-go" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A QUIC implementation in pure go&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A QUIC implementation in pure Go&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lucas-clemente/quic-go/master/docs/quic.png&#34; width=&#34;303&#34; height=&#34;124&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/lucas-clemente/quic-go&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/lucas-clemente/quic-go&#34; alt=&#34;PkgGoDev&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/lucas-clemente/quic-go/&#34;&gt;&lt;img src=&#34;https://img.shields.io/codecov/c/github/lucas-clemente/quic-go/master.svg?style=flat-square&#34; alt=&#34;Code Coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;quic-go is an implementation of the QUIC protocol (&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9000&#34;&gt;RFC 9000&lt;/a&gt;, &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9001&#34;&gt;RFC 9001&lt;/a&gt;, &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9002&#34;&gt;RFC 9002&lt;/a&gt;) in Go, including the Unreliable Datagram Extension (&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9221&#34;&gt;RFC 9221&lt;/a&gt;) and Datagram Packetization Layer Path MTU Discovery (DPLPMTUD, &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc8899&#34;&gt;RFC 8899&lt;/a&gt;). It has support for HTTP/3 (&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9114&#34;&gt;RFC 9114&lt;/a&gt;), including QPACK (&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9204&#34;&gt;RFC 9204&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;In addition to the RFCs listed above, it currently implements the &lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-quic-transport-29&#34;&gt;IETF QUIC draft-29&lt;/a&gt;. Support for draft-29 will eventually be dropped, as it is phased out of the ecosystem.&lt;/p&gt; &#xA;&lt;h2&gt;Guides&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;We currently support Go 1.18.x and Go 1.19.x.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Running tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go test ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;QUIC without HTTP/3&lt;/h3&gt; &#xA;&lt;p&gt;Take a look at &lt;a href=&#34;https://raw.githubusercontent.com/lucas-clemente/quic-go/master/example/echo/echo.go&#34;&gt;this echo example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;As a server&lt;/h3&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/lucas-clemente/quic-go/master/example/main.go&#34;&gt;example server&lt;/a&gt;. Starting a QUIC server is very similar to the standard lib http in go:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;http.Handle(&#34;/&#34;, http.FileServer(http.Dir(wwwDir)))&#xA;http3.ListenAndServeQUIC(&#34;localhost:4242&#34;, &#34;/path/to/cert/chain.pem&#34;, &#34;/path/to/privkey.pem&#34;, nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;As a client&lt;/h3&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/lucas-clemente/quic-go/master/example/client/main.go&#34;&gt;example client&lt;/a&gt;. Use a &lt;code&gt;http3.RoundTripper&lt;/code&gt; as a &lt;code&gt;Transport&lt;/code&gt; in a &lt;code&gt;http.Client&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;http.Client{&#xA;  Transport: &amp;amp;http3.RoundTripper{},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Projects using quic-go&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Project&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Stars&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/xyproto/algernon&#34;&gt;algernon&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Small self-contained pure-Go web server with Lua, Markdown, HTTP/2, QUIC, Redis and PostgreSQL support&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/xyproto/algernon?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/caddyserver/caddy/&#34;&gt;caddy&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fast, multi-platform web server with automatic HTTPS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/caddyserver/caddy?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ipfs/go-ipfs&#34;&gt;go-ipfs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;IPFS implementation in go&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/ipfs/go-ipfs?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/syncthing/syncthing/&#34;&gt;syncthing&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Open Source Continuous File Synchronization&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/syncthing/syncthing?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/traefik/traefik&#34;&gt;traefik&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The Cloud Native Application Proxy&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/traefik/traefik?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/v2fly/v2ray-core&#34;&gt;v2ray-core&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A platform for building proxies to bypass network restrictions&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/v2fly/v2ray-core?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/cloudflare/cloudflared&#34;&gt;cloudflared&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A tunneling daemon that proxies traffic from the Cloudflare network to your origins&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/cloudflare/cloudflared?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ooni/probe-cli&#34;&gt;OONI Probe&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The Open Observatory of Network Interference (OONI) aims to empower decentralized efforts in documenting Internet censorship around the world.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/ooni/probe-cli?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/yomorun/yomo&#34;&gt;YoMo&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Streaming Serverless Framework for Geo-distributed System&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://img.shields.io/github/stars/yomorun/yomo?style=flat-square&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We are always happy to welcome new contributors! We have a number of self-contained issues that are suitable for first-time contributors, they are tagged with &lt;a href=&#34;https://github.com/lucas-clemente/quic-go/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22&#34;&gt;help wanted&lt;/a&gt;. If you have any questions, please feel free to reach out by opening an issue or leaving a comment.&lt;/p&gt;</summary>
  </entry>
</feed>