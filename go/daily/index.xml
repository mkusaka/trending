<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-13T01:50:18Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>goccy/go-yaml</title>
    <updated>2025-04-13T01:50:18Z</updated>
    <id>tag:github.com,2025-04-13:/goccy/go-yaml</id>
    <link href="https://github.com/goccy/go-yaml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;YAML support for the Go language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;YAML support for the Go language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/goccy/go-yaml&#34; alt=&#34;PkgGoDev&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/goccy/go-yaml/workflows/Go/badge.svg?sanitize=true&#34; alt=&#34;Go&#34;&gt; &lt;a href=&#34;https://codecov.io/gh/goccy/go-yaml&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/goccy/go-yaml/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/goccy/go-yaml&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/goccy/go-yaml&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img width=&#34;300px&#34; src=&#34;https://user-images.githubusercontent.com/209884/67159116-64d94b80-f37b-11e9-9b28-f8379636a43c.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;This library has &lt;strong&gt;NO&lt;/strong&gt; relation to the go-yaml/yaml library&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] This library is developed from scratch to replace &lt;a href=&#34;https://github.com/go-yaml/yaml&#34;&gt;&lt;code&gt;go-yaml/yaml&lt;/code&gt;&lt;/a&gt;. If you&#39;re looking for a better YAML library, this one should be helpful.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Why a new library?&lt;/h1&gt; &#xA;&lt;p&gt;As of this writing, there already exists a de facto standard library for YAML processing for Go: &lt;a href=&#34;https://github.com/go-yaml/yaml&#34;&gt;https://github.com/go-yaml/yaml&lt;/a&gt;. However, we believe that a new YAML library is necessary for the following reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Not actively maintained&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;go-yaml/yaml&lt;/code&gt; has ported the libyaml written in C to Go, so the source code is not written in Go style&lt;/li&gt; &#xA; &lt;li&gt;There is a lot of content that cannot be parsed&lt;/li&gt; &#xA; &lt;li&gt;YAML is often used for configuration, and it is common to include validation along with it. However, the errors in &lt;code&gt;go-yaml/yaml&lt;/code&gt; are not intuitive, and it is difficult to provide meaningful validation errors&lt;/li&gt; &#xA; &lt;li&gt;When creating tools that use YAML, there are cases where reversible transformation of YAML is required. However, to perform reversible transformations of content that includes Comments or Anchors/Aliases, manipulating the AST is the only option&lt;/li&gt; &#xA; &lt;li&gt;Non-intuitive &lt;a href=&#34;https://pkg.go.dev/gopkg.in/yaml.v3#Marshaler&#34;&gt;Marshaler&lt;/a&gt; / &lt;a href=&#34;https://pkg.go.dev/gopkg.in/yaml.v3#Unmarshaler&#34;&gt;Unmarshaler&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By the way, libraries such as &lt;a href=&#34;https://github.com/ghodss/yaml&#34;&gt;ghodss/yaml&lt;/a&gt; and &lt;a href=&#34;https://github.com/kubernetes-sigs/yaml&#34;&gt;sigs.k8s.io/yaml&lt;/a&gt; also depend on go-yaml/yaml, so if you are using these libraries, the same issues apply: they cannot parse things that go-yaml/yaml cannot parse, and they inherit many of the problems that go-yaml/yaml has.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No dependencies&lt;/li&gt; &#xA; &lt;li&gt;A better parser than &lt;code&gt;go-yaml/yaml&lt;/code&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/apple/device-management/raw/release/docs/schema.yaml&#34;&gt;Support recursive processing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Higher coverage in the &lt;a href=&#34;https://github.com/yaml/yaml-test-suite?tab=readme-ov-file&#34;&gt;YAML Test Suite&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;YAML Test Suite consists of 402 cases in total, of which &lt;code&gt;gopkg.in/yaml.v3&lt;/code&gt; passes &lt;code&gt;295&lt;/code&gt;. In addition to passing all those test cases, &lt;code&gt;goccy/go-yaml&lt;/code&gt; successfully passes nearly 60 additional test cases ( 2024/12/15 )&lt;/li&gt; &#xA;     &lt;li&gt;The test code is &lt;a href=&#34;https://github.com/goccy/go-yaml/raw/master/yaml_test_suite_test.go#L77&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Ease and sustainability of maintenance &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The main maintainer is &lt;a href=&#34;https://github.com/goccy&#34;&gt;@goccy&lt;/a&gt;, but we are also building a system to develop as a team with trusted developers&lt;/li&gt; &#xA;   &lt;li&gt;Since it is written from scratch, the code is easy to read for Gophers&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;An API structure that allows the use of not only &lt;code&gt;Encoder&lt;/code&gt;/&lt;code&gt;Decoder&lt;/code&gt; but also &lt;code&gt;Tokenizer&lt;/code&gt; and &lt;code&gt;Parser&lt;/code&gt; functionalities. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml@v1.15.4/lexer#Tokenize&#34;&gt;lexer.Tokenize&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml@v1.15.4/parser#Parse&#34;&gt;parser.Parse&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Filtering, replacing, and merging YAML content using YAML Path&lt;/li&gt; &#xA; &lt;li&gt;Reversible transformation without using the AST for YAML that includes Anchors, Aliases, and Comments&lt;/li&gt; &#xA; &lt;li&gt;Customize the Marshal/Unmarshal behavior for primitive types and third-party library types (&lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml#RegisterCustomMarshaler&#34;&gt;RegisterCustomMarshaler&lt;/a&gt;, &lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml#RegisterCustomUnmarshaler&#34;&gt;RegisterCustomUnmarshaler&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Respects &lt;code&gt;encoding/json&lt;/code&gt; behavior &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Accept the &lt;code&gt;json&lt;/code&gt; tag. Note that not all options from the &lt;code&gt;json&lt;/code&gt; tag will have significance when parsing YAML documents. If both tags exist, &lt;code&gt;yaml&lt;/code&gt; tag will take precedence.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/encoding/json#Marshaler&#34;&gt;json.Marshaler&lt;/a&gt; style &lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml#BytesMarshaler&#34;&gt;marshaler&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/encoding/json#Unmarshaler&#34;&gt;json.Unmarshaler&lt;/a&gt; style &lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml#BytesUnmarshaler&#34;&gt;unmarshaler&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Options for using &lt;code&gt;MarshalJSON&lt;/code&gt; and &lt;code&gt;UnmarshalJSON&lt;/code&gt; (&lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml#UseJSONMarshaler&#34;&gt;UseJSONMarshaler&lt;/a&gt;, &lt;a href=&#34;https://pkg.go.dev/github.com/goccy/go-yaml#UseJSONUnmarshaler&#34;&gt;UseJSONUnmarshaler&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Pretty format for error notifications&lt;/li&gt; &#xA; &lt;li&gt;Smart validation processing combined with &lt;a href=&#34;https://github.com/go-playground/validator&#34;&gt;go-playground/validator&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/goccy/go-yaml/raw/45889c98b0a0967240eb595a1bd6896e2f575106/testdata/validate_test.go#L12&#34;&gt;example test code is here&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Allow referencing elements declared in another file via anchors&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Users&lt;/h1&gt; &#xA;&lt;p&gt;The repositories that use goccy/go-yaml are listed here.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/goccy/go-yaml/wiki/Users&#34;&gt;https://github.com/goccy/go-yaml/wiki/Users&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The source data is &lt;a href=&#34;https://github.com/goccy/go-yaml/network/dependents&#34;&gt;here&lt;/a&gt;. It is already being used in many repositories. Now it&#39;s your turn ðŸ˜„&lt;/p&gt; &#xA;&lt;h1&gt;Playground&lt;/h1&gt; &#xA;&lt;p&gt;The Playground visualizes how go-yaml processes YAML text. Use it to assist with your debugging or issue reporting.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://goccy.github.io/go-yaml&#34;&gt;https://goccy.github.io/go-yaml&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get github.com/goccy/go-yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Synopsis&lt;/h1&gt; &#xA;&lt;h2&gt;1. Simple Encode/Decode&lt;/h2&gt; &#xA;&lt;p&gt;Has an interface like &lt;code&gt;go-yaml/yaml&lt;/code&gt; using &lt;code&gt;reflect&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var v struct {&#xA;&#x9;A int&#xA;&#x9;B string&#xA;}&#xA;v.A = 1&#xA;v.B = &#34;hello&#34;&#xA;bytes, err := yaml.Marshal(v)&#xA;if err != nil {&#xA;&#x9;//...&#xA;}&#xA;fmt.Println(string(bytes)) // &#34;a: 1\nb: hello\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#x9;yml := `&#xA;%YAML 1.2&#xA;---&#xA;a: 1&#xA;b: c&#xA;`&#xA;var v struct {&#xA;&#x9;A int&#xA;&#x9;B string&#xA;}&#xA;if err := yaml.Unmarshal([]byte(yml), &amp;amp;v); err != nil {&#xA;&#x9;//...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To control marshal/unmarshal behavior, you can use the &lt;code&gt;yaml&lt;/code&gt; tag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#x9;yml := `---&#xA;foo: 1&#xA;bar: c&#xA;`&#xA;var v struct {&#xA;&#x9;A int    `yaml:&#34;foo&#34;`&#xA;&#x9;B string `yaml:&#34;bar&#34;`&#xA;}&#xA;if err := yaml.Unmarshal([]byte(yml), &amp;amp;v); err != nil {&#xA;&#x9;//...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For convenience, we also accept the &lt;code&gt;json&lt;/code&gt; tag. Note that not all options from the &lt;code&gt;json&lt;/code&gt; tag will have significance when parsing YAML documents. If both tags exist, &lt;code&gt;yaml&lt;/code&gt; tag will take precedence.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#x9;yml := `---&#xA;foo: 1&#xA;bar: c&#xA;`&#xA;var v struct {&#xA;&#x9;A int    `json:&#34;foo&#34;`&#xA;&#x9;B string `json:&#34;bar&#34;`&#xA;}&#xA;if err := yaml.Unmarshal([]byte(yml), &amp;amp;v); err != nil {&#xA;&#x9;//...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For custom marshal/unmarshaling, implement either &lt;code&gt;Bytes&lt;/code&gt; or &lt;code&gt;Interface&lt;/code&gt; variant of marshaler/unmarshaler. The difference is that while &lt;code&gt;BytesMarshaler&lt;/code&gt;/&lt;code&gt;BytesUnmarshaler&lt;/code&gt; behaves like &lt;a href=&#34;https://pkg.go.dev/encoding/json&#34;&gt;&lt;code&gt;encoding/json&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;InterfaceMarshaler&lt;/code&gt;/&lt;code&gt;InterfaceUnmarshaler&lt;/code&gt; behaves like &lt;a href=&#34;https://pkg.go.dev/gopkg.in/yaml.v2&#34;&gt;&lt;code&gt;gopkg.in/yaml.v2&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Semantically both are the same, but they differ in performance. Because indentation matters in YAML, you cannot simply accept a valid YAML fragment from a Marshaler, and expect it to work when it is attached to the parent container&#39;s serialized form. Therefore when we receive use the &lt;code&gt;BytesMarshaler&lt;/code&gt;, which returns &lt;code&gt;[]byte&lt;/code&gt;, we must decode it once to figure out how to make it work in the given context. If you use the &lt;code&gt;InterfaceMarshaler&lt;/code&gt;, we can skip the decoding.&lt;/p&gt; &#xA;&lt;p&gt;If you are repeatedly marshaling complex objects, the latter is always better performance wise. But if you are, for example, just providing a choice between a config file format that is read only once, the former is probably easier to code.&lt;/p&gt; &#xA;&lt;h2&gt;2. Reference elements declared in another file&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;testdata&lt;/code&gt; directory contains &lt;code&gt;anchor.yml&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;â”œâ”€â”€ testdata&#xA;&amp;nbsp;&amp;nbsp; â””â”€â”€ anchor.yml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And &lt;code&gt;anchor.yml&lt;/code&gt; is defined as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;a: &amp;amp;a&#xA;  b: 1&#xA;  c: hello&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, if &lt;code&gt;yaml.ReferenceDirs(&#34;testdata&#34;)&lt;/code&gt; option is passed to &lt;code&gt;yaml.Decoder&lt;/code&gt;, &lt;code&gt;Decoder&lt;/code&gt; tries to find the anchor definition from YAML files the under &lt;code&gt;testdata&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;buf := bytes.NewBufferString(&#34;a: *a\n&#34;)&#xA;dec := yaml.NewDecoder(buf, yaml.ReferenceDirs(&#34;testdata&#34;))&#xA;var v struct {&#xA;&#x9;A struct {&#xA;&#x9;&#x9;B int&#xA;&#x9;&#x9;C string&#xA;&#x9;}&#xA;}&#xA;if err := dec.Decode(&amp;amp;v); err != nil {&#xA;&#x9;//...&#xA;}&#xA;fmt.Printf(&#34;%+v\n&#34;, v) // {A:{B:1 C:hello}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;3. Encode with &lt;code&gt;Anchor&lt;/code&gt; and &lt;code&gt;Alias&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;3.1. Explicitly declared &lt;code&gt;Anchor&lt;/code&gt; name and &lt;code&gt;Alias&lt;/code&gt; name&lt;/h3&gt; &#xA;&lt;p&gt;If you want to use &lt;code&gt;anchor&lt;/code&gt;, you can define it as a struct tag. If the value specified for an anchor is a pointer type and the same address as the pointer is found, the value is automatically set to alias. If an explicit alias name is specified, an error is raised if its value is different from the value specified in the anchor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {&#xA;  A int&#xA;  B string&#xA;}&#xA;var v struct {&#xA;  C *T `yaml:&#34;c,anchor=x&#34;`&#xA;  D *T `yaml:&#34;d,alias=x&#34;`&#xA;}&#xA;v.C = &amp;amp;T{A: 1, B: &#34;hello&#34;}&#xA;v.D = v.C&#xA;bytes, err := yaml.Marshal(v)&#xA;if err != nil {&#xA;  panic(err)&#xA;}&#xA;fmt.Println(string(bytes))&#xA;/*&#xA;c: &amp;amp;x&#xA;  a: 1&#xA;  b: hello&#xA;d: *x&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3.2. Implicitly declared &lt;code&gt;Anchor&lt;/code&gt; and &lt;code&gt;Alias&lt;/code&gt; names&lt;/h3&gt; &#xA;&lt;p&gt;If you do not explicitly declare the anchor name, the default behavior is to use the equivalent of &lt;code&gt;strings.ToLower($FieldName)&lt;/code&gt; as the name of the anchor. If the value specified for an anchor is a pointer type and the same address as the pointer is found, the value is automatically set to alias.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {&#xA;&#x9;I int&#xA;&#x9;S string&#xA;}&#xA;var v struct {&#xA;&#x9;A *T `yaml:&#34;a,anchor&#34;`&#xA;&#x9;B *T `yaml:&#34;b,anchor&#34;`&#xA;&#x9;C *T `yaml:&#34;c&#34;`&#xA;&#x9;D *T `yaml:&#34;d&#34;`&#xA;}&#xA;v.A = &amp;amp;T{I: 1, S: &#34;hello&#34;}&#xA;v.B = &amp;amp;T{I: 2, S: &#34;world&#34;}&#xA;v.C = v.A // C has same pointer address to A&#xA;v.D = v.B // D has same pointer address to B&#xA;bytes, err := yaml.Marshal(v)&#xA;if err != nil {&#xA;&#x9;//...&#xA;}&#xA;fmt.Println(string(bytes)) &#xA;/*&#xA;a: &amp;amp;a&#xA;  i: 1&#xA;  s: hello&#xA;b: &amp;amp;b&#xA;  i: 2&#xA;  s: world&#xA;c: *a&#xA;d: *b&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3.3 MergeKey and Alias&lt;/h3&gt; &#xA;&lt;p&gt;Merge key and alias ( &lt;code&gt;&amp;lt;&amp;lt;: *alias&lt;/code&gt; ) can be used by embedding a structure with the &lt;code&gt;inline,alias&lt;/code&gt; tag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Person struct {&#xA;&#x9;*Person `yaml:&#34;,omitempty,inline,alias&#34;` // embed Person type for default value&#xA;&#x9;Name    string `yaml:&#34;,omitempty&#34;`&#xA;&#x9;Age     int    `yaml:&#34;,omitempty&#34;`&#xA;}&#xA;defaultPerson := &amp;amp;Person{&#xA;&#x9;Name: &#34;John Smith&#34;,&#xA;&#x9;Age:  20,&#xA;}&#xA;people := []*Person{&#xA;&#x9;{&#xA;&#x9;&#x9;Person: defaultPerson, // assign default value&#xA;&#x9;&#x9;Name:   &#34;Ken&#34;,         // override Name property&#xA;&#x9;&#x9;Age:    10,            // override Age property&#xA;&#x9;},&#xA;&#x9;{&#xA;&#x9;&#x9;Person: defaultPerson, // assign default value only&#xA;&#x9;},&#xA;}&#xA;var doc struct {&#xA;&#x9;Default *Person   `yaml:&#34;default,anchor&#34;`&#xA;&#x9;People  []*Person `yaml:&#34;people&#34;`&#xA;}&#xA;doc.Default = defaultPerson&#xA;doc.People = people&#xA;bytes, err := yaml.Marshal(doc)&#xA;if err != nil {&#xA;&#x9;//...&#xA;}&#xA;fmt.Println(string(bytes))&#xA;/*&#xA;default: &amp;amp;default&#xA;  name: John Smith&#xA;  age: 20&#xA;people:&#xA;- &amp;lt;&amp;lt;: *default&#xA;  name: Ken&#xA;  age: 10&#xA;- &amp;lt;&amp;lt;: *default&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;4. Pretty Formatted Errors&lt;/h2&gt; &#xA;&lt;p&gt;Error values produced during parsing have two extra features over regular error values.&lt;/p&gt; &#xA;&lt;p&gt;First, by default, they contain extra information on the location of the error from the source YAML document, to make it easier to find the error location.&lt;/p&gt; &#xA;&lt;p&gt;Second, the error messages can optionally be colorized.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to control exactly how the output looks like, consider using &lt;code&gt;yaml.FormatError&lt;/code&gt;, which accepts two boolean values to control turning these features on or off.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/209884/67358124-587f0980-f59a-11e9-96fc-7205aab77695.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;5. Use YAMLPath&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;yml := `&#xA;store:&#xA;  book:&#xA;    - author: john&#xA;      price: 10&#xA;    - author: ken&#xA;      price: 12&#xA;  bicycle:&#xA;    color: red&#xA;    price: 19.95&#xA;`&#xA;path, err := yaml.PathString(&#34;$.store.book[*].author&#34;)&#xA;if err != nil {&#xA;  //...&#xA;}&#xA;var authors []string&#xA;if err := path.Read(strings.NewReader(yml), &amp;amp;authors); err != nil {&#xA;  //...&#xA;}&#xA;fmt.Println(authors)&#xA;// [john ken]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;5.1 Print customized error with YAML source code&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;  &#34;fmt&#34;&#xA;&#xA;  &#34;github.com/goccy/go-yaml&#34;&#xA;)&#xA;&#xA;func main() {&#xA;  yml := `&#xA;a: 1&#xA;b: &#34;hello&#34;&#xA;`&#xA;  var v struct {&#xA;    A int&#xA;    B string&#xA;  }&#xA;  if err := yaml.Unmarshal([]byte(yml), &amp;amp;v); err != nil {&#xA;    panic(err)&#xA;  }&#xA;  if v.A != 2 {&#xA;    // output error with YAML source&#xA;    path, err := yaml.PathString(&#34;$.a&#34;)&#xA;    if err != nil {&#xA;      panic(err)&#xA;    }&#xA;    source, err := path.AnnotateSource([]byte(yml), true)&#xA;    if err != nil {&#xA;      panic(err)&#xA;    }&#xA;    fmt.Printf(&#34;a value expected 2 but actual %d:\n%s\n&#34;, v.A, string(source))&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;output result is the following:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/209884/84148813-7aca8680-aa9a-11ea-8fc9-37dece2ebdac.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Tools&lt;/h1&gt; &#xA;&lt;h2&gt;ycat&lt;/h2&gt; &#xA;&lt;p&gt;print yaml file with color&lt;/p&gt; &#xA;&lt;img width=&#34;713&#34; alt=&#34;ycat&#34; src=&#34;https://user-images.githubusercontent.com/209884/66986084-19b00600-f0f9-11e9-9f0e-1f91eb072fe0.png&#34;&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/goccy/go-yaml.git&#xA;cd go-yaml/cmd/ycat &amp;amp;&amp;amp; go install .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;For Developers&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] In this project, we manage such test code under the &lt;code&gt;testdata&lt;/code&gt; directory to avoid adding dependencies on libraries that are only needed for testing to the top &lt;code&gt;go.mod&lt;/code&gt; file. Therefore, if you want to add test cases that use 3rd party libraries, please add the test code to the &lt;code&gt;testdata&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Looking for Sponsors&lt;/h1&gt; &#xA;&lt;p&gt;I&#39;m looking for sponsors this library. This library is being developed as a personal project in my spare time. If you want a quick response or problem resolution when using this library in your project, please register as a &lt;a href=&#34;https://github.com/sponsors/goccy&#34;&gt;sponsor&lt;/a&gt;. I will cooperate as much as possible. Of course, this library is developed as an MIT license, so you can use it freely for free.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
</feed>