<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-11T02:30:49Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>uber-go/goleak</title>
    <updated>2023-11-11T02:30:49Z</updated>
    <id>tag:github.com,2023-11-11:/uber-go/goleak</id>
    <link href="https://github.com/uber-go/goleak" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Goroutine leak detector&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;goleak &lt;a href=&#34;https://godoc.org/go.uber.org/goleak&#34;&gt;&lt;img src=&#34;https://godoc.org/go.uber.org/goleak?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/uber-go/goleak/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/uber-go/goleak/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/uber-go/goleak&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/uber-go/goleak/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Goroutine leak detector to help avoid Goroutine leaks.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;go get&lt;/code&gt; to get the latest version:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;go get -u go.uber.org/goleak&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;goleak&lt;/code&gt; also supports semver releases.&lt;/p&gt; &#xA;&lt;p&gt;Note that go-leak only &lt;a href=&#34;https://go.dev/doc/devel/release#policy&#34;&gt;supports&lt;/a&gt; the two most recent minor versions of Go.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;To verify that there are no unexpected goroutines running at the end of a test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestA(t *testing.T) {&#xA;&#x9;defer goleak.VerifyNone(t)&#xA;&#xA;&#x9;// test logic here.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of checking for leaks at the end of every test, &lt;code&gt;goleak&lt;/code&gt; can also be run at the end of every test package by creating a &lt;code&gt;TestMain&lt;/code&gt; function for your package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestMain(m *testing.M) {&#xA;&#x9;goleak.VerifyTestMain(m)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Determine Source of Package Leaks&lt;/h2&gt; &#xA;&lt;p&gt;When verifying leaks using &lt;code&gt;TestMain&lt;/code&gt;, the leak test is only run once after all tests have been run. This is typically enough to ensure there&#39;s no goroutines leaked from tests, but when there are leaks, it&#39;s hard to determine which test is causing them.&lt;/p&gt; &#xA;&lt;p&gt;You can use the following bash script to determine the source of the failing test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Create a test binary which will be used to run each test individually&#xA;$ go test -c -o tests&#xA;&#xA;# Run each test individually, printing &#34;.&#34; for successful tests, or the test name&#xA;# for failing tests.&#xA;$ for test in $(go test -list . | grep -E &#34;^(Test|Example)&#34;); do ./tests -test.run &#34;^$test\$&#34; &amp;amp;&amp;gt;/dev/null &amp;amp;&amp;amp; echo -n &#34;.&#34; || echo -e &#34;\n$test failed&#34;; done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will only print names of failing tests which can be investigated individually. E.g.,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.....&#xA;TestLeakyTest failed&#xA;.......&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Stability&lt;/h2&gt; &#xA;&lt;p&gt;goleak is v1 and follows &lt;a href=&#34;http://semver.org/&#34;&gt;SemVer&lt;/a&gt; strictly.&lt;/p&gt; &#xA;&lt;p&gt;No breaking changes will be made to exported APIs before 2.0.&lt;/p&gt;</summary>
  </entry>
</feed>