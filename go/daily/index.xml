<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-23T01:36:24Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>go-task/task</title>
    <updated>2023-05-23T01:36:24Z</updated>
    <id>tag:github.com,2023-05-23:/go-task/task</id>
    <link href="https://github.com/go-task/task" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A task runner / simpler Make alternative written in Go&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://taskfile.dev&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/go-task/task/main/docs/static/img/logo.svg?sanitize=true&#34; width=&#34;200px&#34; height=&#34;200px&#34;&gt; &lt;/a&gt; &#xA; &lt;h1&gt;Task&lt;/h1&gt; &#xA; &lt;p&gt; Task is a task runner / build tool that aims to be simpler and easier to use than, for example, &lt;a href=&#34;https://www.gnu.org/software/make/&#34;&gt;GNU Make&lt;/a&gt;&lt;a&gt;. &lt;/a&gt;&lt;/p&gt;&#xA; &lt;a&gt; &lt;/a&gt;&#xA; &lt;p&gt;&lt;a&gt; &lt;/a&gt;&lt;a href=&#34;https://taskfile.dev/installation/&#34;&gt;Installation&lt;/a&gt; | &lt;a href=&#34;https://taskfile.dev/usage/&#34;&gt;Documentation&lt;/a&gt; | &lt;a href=&#34;https://twitter.com/taskfiledev&#34;&gt;Twitter&lt;/a&gt; | &lt;a href=&#34;https://fosstodon.org/@task&#34;&gt;Mastodon&lt;/a&gt; | &lt;a href=&#34;https://discord.gg/6TY36E39UK&#34;&gt;Discord&lt;/a&gt; &lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Gold Sponsors&lt;/h2&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;th&gt;&lt;a href=&#34;https://appwrite.io/?utm_source=task_github&amp;amp;utm_medium=social&amp;amp;utm_campaign=task_oss_fund&#34;&gt;Appwrite&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;a href=&#34;https://appwrite.io/?utm_source=task_github&amp;amp;utm_medium=social&amp;amp;utm_campaign=task_oss_fund&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/go-task/task/main/docs/static/img/appwrite.svg?sanitize=true&#34; alt=&#34;Appwrite&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/div&gt; &#xA;&lt;!-- prettier-ignore-start --&gt; &#xA;&lt;!-- prettier-ignore-end --&gt;</summary>
  </entry>
  <entry>
    <title>benbjohnson/wtf</title>
    <updated>2023-05-23T01:36:24Z</updated>
    <id>tag:github.com,2023-05-23:/benbjohnson/wtf</id>
    <link href="https://github.com/benbjohnson/wtf" rel="alternate"></link>
    <summary type="html">&lt;p&gt;WTF Dial is an example web application written in Go.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WTF Dial &lt;img src=&#34;https://img.shields.io/github/v/release/benbjohnson/wtf&#34; alt=&#34;GitHub release&#34;&gt; &lt;img src=&#34;https://github.com/benbjohnson/wtf/workflows/test/badge.svg?sanitize=true&#34; alt=&#34;test&#34;&gt; &lt;img src=&#34;https://github.com/benbjohnson/wtf/workflows/deploy/badge.svg?sanitize=true&#34; alt=&#34;deploy&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;This project provides a real-time dashboard for teams to view how f-cked up they currently are. Each team member provides input to specify the level at which they feel the team is currently messed up. These values range from 0% (meaning team feels there are no WTF situations) to 100% (meaning the members feel the team is completely f-cked).&lt;/p&gt; &#xA;&lt;p&gt;The idea for this came from &lt;a href=&#34;https://twitter.com/peterbourgon/status/765935213507649537&#34;&gt;Peter Bourgon&#39;s tweets&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to use this repository&lt;/h2&gt; &#xA;&lt;p&gt;This repository was built to help others learn how to build a fully functioning Go application. It can be used in several ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;As a reference—the code is well documented. Honestly, too documented for most projects but the goal here is to be as clear as possible for anyone reading the code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;As a walkthrough—companion blog posts will be added to the &lt;a href=&#34;https://www.gobeyond.dev/&#34;&gt;Go Beyond&lt;/a&gt; web site that walk through the various parts of the application and explain the design choices. You can find the initial blog post here: &lt;a href=&#34;https://www.gobeyond.dev/wtf-dial/&#34;&gt;https://www.gobeyond.dev/wtf-dial/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ask questions in the &lt;a href=&#34;https://github.com/benbjohnson/wtf/discussions&#34;&gt;GitHub Discussions&lt;/a&gt; board.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You can also see the project structure overview below to get a quick overview of the application structure.&lt;/p&gt; &#xA;&lt;h2&gt;Project structure&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;wtf&lt;/code&gt; project organizes code with the following approach:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Application domain types go in the root—&lt;code&gt;User&lt;/code&gt;, &lt;code&gt;UserService&lt;/code&gt;, &lt;code&gt;Dial&lt;/code&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;Implementations of the application domain go in subpackages—&lt;code&gt;sqlite&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;Everything is tied together in the &lt;code&gt;cmd&lt;/code&gt; subpackages—&lt;code&gt;cmd/wtf&lt;/code&gt; &amp;amp; &lt;code&gt;cmd/wtfd&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Application domain&lt;/h3&gt; &#xA;&lt;p&gt;The application domain is the collection of types which define what your application does without defining how it does it. For example, if you were to describe what WTF Dial does to a non-technical person, you would describe it in terms of &lt;em&gt;Users&lt;/em&gt; and &lt;em&gt;Dials&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We also include interfaces for managing our application domain data types which are used as contracts for the underlying implementations. For example, we define a &lt;code&gt;wtf.DialService&lt;/code&gt; interface for CRUD (Create/Read/Update/Delete) actions and SQLite does the actual implementation.&lt;/p&gt; &#xA;&lt;p&gt;This allows all packages to share a common understanding of what each service does. We can swap out implementations, or more importantly, we can layer implementations on top of one another. We could, for example, add a Redis caching layer on top of our database layer without having the two layers know about one another as long as they both implement the same common interface.&lt;/p&gt; &#xA;&lt;h3&gt;Implementation subpackages&lt;/h3&gt; &#xA;&lt;p&gt;Most subpackages are used as an adapter between our application domain and the technology that we&#39;re using to implement the domain. For example, &lt;code&gt;sqlite.DialService&lt;/code&gt; implements the &lt;code&gt;wtf.DialService&lt;/code&gt; using SQLite.&lt;/p&gt; &#xA;&lt;p&gt;The subpackages generally should not know about one another and should communicate in terms of the application domain.&lt;/p&gt; &#xA;&lt;p&gt;These are separated out into the following packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;http&lt;/code&gt;—Implements services over HTTP transport layer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;inmem&lt;/code&gt;—Implements in-memory event listener service &amp;amp; subscriptions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sqlite&lt;/code&gt;—Implements services on SQLite storage layer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is also a &lt;code&gt;mock&lt;/code&gt; package which implements simple mocks for each of the application domain interfaces. This allows each subpackage&#39;s unit tests to share a common set of mocks so layers can be tested in isolation.&lt;/p&gt; &#xA;&lt;h3&gt;Binary packages&lt;/h3&gt; &#xA;&lt;p&gt;The implementation subpackages are loosely coupled so they need to be wired together by another package to actually make working software. That&#39;s the job of the &lt;code&gt;cmd&lt;/code&gt; subpackages which produce the final binary.&lt;/p&gt; &#xA;&lt;p&gt;There are two binaries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;wtfd&lt;/code&gt;—the WTF server&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;wtf&lt;/code&gt;—the client CLI application&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each of these binaries collect the services together in different ways depending on the use case.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;wtfd&lt;/code&gt; server binary creates a &lt;code&gt;sqlite&lt;/code&gt; storage layer and adds the &lt;code&gt;http&lt;/code&gt; transport layer on top. The &lt;code&gt;wtf&lt;/code&gt; client binary doesn&#39;t have a storage layer. It only needs the client side &lt;code&gt;http&lt;/code&gt; transport layer.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;cmd&lt;/code&gt; packages are ultimately the interface between the application domain and the operator. That means that configuration types &amp;amp; CLI flags should live in these packages.&lt;/p&gt; &#xA;&lt;h3&gt;Other packages&lt;/h3&gt; &#xA;&lt;p&gt;A few smaller packages don&#39;t fall into the organization listed above:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;csv&lt;/code&gt;—implements a &lt;code&gt;csv.DialEncoder&lt;/code&gt; for encoding a list of Dial objects to a writer using the CSV format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;http/html&lt;/code&gt;-groups together HTML templates used by the &lt;code&gt;http&lt;/code&gt; package.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;You can build &lt;code&gt;wtf&lt;/code&gt; locally by cloning the repository, then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make &#xA;$ go install ./cmd/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;wtfd&lt;/code&gt; server uses GitHub for authentication so you&#39;ll need to &lt;a href=&#34;https://github.com/settings/applications/new&#34;&gt;create a new GitHub OAuth App&lt;/a&gt;. Set the value of the authorization callback URL to &lt;code&gt;http://HOST[:PORT]/oauth/github/callback&lt;/code&gt;, where &lt;code&gt;HOST[:PORT]&lt;/code&gt; is the host name or IP address at which clients can access the &lt;code&gt;wtfd&lt;/code&gt; server, with an optional port number (e.g. &lt;code&gt;localhost:3000&lt;/code&gt; when running locally).&lt;/p&gt; &#xA;&lt;p&gt;Next, you&#39;ll need to setup a configuration file in &lt;code&gt;~/wtfd.conf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[github]&#xA;client-id     = &#34;00000000000000000000&#34;&#xA;client-secret = &#34;0000000000000000000000000000000000000000&#34;&#xA;&#xA;[http]&#xA;addr      = &#34;:3000&#34;&#xA;block-key = &#34;0000000000000000000000000000000000000000000000000000000000000000&#34;&#xA;hash-key  = &#34;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace the GitHub &lt;code&gt;client-id&lt;/code&gt; &amp;amp; &lt;code&gt;client-secret&lt;/code&gt; with the values from the GitHub OAuth application you registered.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;[http]&lt;/code&gt; section can be left as-is for a local environment. The key fields need random hex values for generating secure cookies but all zeros is ok for local testing.&lt;/p&gt; &#xA;&lt;p&gt;Finally, run the &lt;code&gt;wtfd&lt;/code&gt; server and open the web site at &lt;a href=&#34;http://localhost:3000&#34;&gt;&lt;code&gt;http://localhost:3000&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ $GOPATH/bin/wtfd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Storybook&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;wtf-storybook&lt;/code&gt; binary allows you to test UI views with prepopulated data. This can make it easier to quickly test certain scenarios without needing to set up your backend database.&lt;/p&gt; &#xA;&lt;p&gt;To run storybook, simply build it and run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go install ./cmd/wtf-storybook&#xA;$ wtf-storybook&#xA;Listening on http://localhost:3001&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To add a new view, add an entry to the &lt;code&gt;routes&lt;/code&gt; variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var routes = []*Route{&#xA;&#x9;// Show dial listing when user has no dials.&#xA;&#x9;{&#xA;&#x9;&#x9;Name: &#34;Dial listing with data&#34;,&#xA;&#x9;&#x9;Path: &#34;/dials-with-no-data&#34;,&#xA;&#x9;&#x9;Renderer: &amp;amp;html.DialIndexTemplate{&#xA;&#x9;&#x9;&#x9;Dials: []*wtf.Dial{},&#xA;&#x9;&#x9;},&#xA;&#x9;},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then navigate to &lt;a href=&#34;https://localhost:3001&#34;&gt;https://localhost:3001&lt;/a&gt; and you&#39;ll see it displayed in the list.&lt;/p&gt; &#xA;&lt;h3&gt;SQLite&lt;/h3&gt; &#xA;&lt;p&gt;By default, the SQLite tests run against in-memory databases. However, you can specify the &lt;code&gt;-dump&lt;/code&gt; flag for the tests to write data out to temporary files. This works best when running against a single test.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go test -run=MyTest -dump ./sqlite&#xA;DUMP=/tmp/sy9j7nks0zq2vr4s_nswrx8h0000gn/T/375403844/db&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then inspect that database using the &lt;code&gt;sqlite3&lt;/code&gt; CLI to see its contents.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This application is built for educational purposes so additional functionality will likely be rejected. Please feel free to submit an issue if you&#39;re interested in seeing something added. Please do not simply submit a pull request.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>leomos/dwgd</title>
    <updated>2023-05-23T01:36:24Z</updated>
    <id>tag:github.com,2023-05-23:/leomos/dwgd</id>
    <link href="https://github.com/leomos/dwgd" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Docker WireGuard Driver&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dwgd: Docker WireGuard Driver&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;dwgd&lt;/strong&gt; is a Docker plugin that let your containers connect to a WireGuard network. This is achieved by &lt;a href=&#34;https://www.wireguard.com/netns/&#34;&gt;moving a WireGuard network interface&lt;/a&gt; from &lt;code&gt;dwgd&lt;/code&gt; running namespace into the designated container namespace.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Credits&lt;/strong&gt;: this is a rewrite of the proof of concept presented in &lt;a href=&#34;https://www.bestov.io/blog/using-wireguard-as-the-network-for-a-docker-container&#34;&gt;this great article&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Disclaimer&lt;/h3&gt; &#xA;&lt;p&gt;This software is by no means ready for production. I use it in personal projects, but it has not been tested anywhere else other than my machine (as far as I know). Use it at your own (high) risk.&lt;/p&gt; &#xA;&lt;p&gt;Also it misses tests and documentation...eventually I&#39;ll write them, I swear.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Generate the public key given your seed and the IP address that your container will have:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ dwgd pubkey -s supersecretseed -i 10.0.0.2&#xA;oKetpvdq/I/c7hTW6/AtQPqVlSzgx3q2ClWCx/OXS00=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start dwgd:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo dwgd -d /var/lib/dwgd.db&#xA;[...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create the docker network with the same seed you used above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ docker network create \&#xA;    --driver=dwgd \&#xA;    -o dwgd.endpoint=example.com:51820 \&#xA;    -o dwgd.seed=supersecretseed \&#xA;    -o dwgd.pubkey=&#34;your server&#39;s public key&#34; \&#xA;    --subnet=10.0.0.0/24 \&#xA;    --gateway=10.0.0.1 \&#xA;    dwgd_net&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start a docker container with the network you just created:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ docker run -it --rm --network=dwgd_net --ip=10.0.0.2 busybox&#xA;/ # ip a&#xA;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue qlen 1000&#xA;    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&#xA;    inet 127.0.0.1/8 scope host lo&#xA;       valid_lft forever preferred_lft forever&#xA;5: wg0: &amp;lt;POINTOPOINT,NOARP,UP,LOWER_UP&amp;gt; mtu 1420 qdisc noqueue qlen 1000&#xA;    link/[65534]&#xA;    inet 10.0.0.2/24 brd 10.0.0.255 scope global wg0&#xA;       valid_lft forever preferred_lft forever&#xA;/ # ping 10.0.0.1&#xA;PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.&#xA;64 bytes from 10.0.0.1: icmp_seq=1 ttl=54 time=9.98 ms&#xA;64 bytes from 10.0.0.1: icmp_seq=2 ttl=54 time=8.65 ms&#xA;64 bytes from 10.0.0.1: icmp_seq=3 ttl=54 time=8.34 ms&#xA;^C&#xA;--- 10.0.0.1 ping statistics ---&#xA;3 packets transmitted, 3 received, 0% packet loss, time 2003ms&#xA;rtt min/avg/max/mdev = 8.343/8.990/9.976/0.708 ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;So far it has been tested in a Linux machine with Ubuntu 20.04, but I guess it could work on any reasonably recent Linux system that respects the dependencies.&lt;/p&gt; &#xA;&lt;p&gt;After cloning the repository you can build the binary and optionally install the systemd unit.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ go build -o /usr/bin/dwgd ./cmd/dwgd.go&#xA;$ chmod +x /usr/bin/dwgd&#xA;$ install init/* /etc/systemd/system/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;You need to have WireGuard installed on your system and the &lt;code&gt;iproute2&lt;/code&gt; package: &lt;code&gt;dwgd&lt;/code&gt; uses the &lt;code&gt;ip&lt;/code&gt; command to create and delete the WireGuard interfaces.&lt;/p&gt; &#xA;&lt;p&gt;You will also need the &lt;code&gt;nsenter&lt;/code&gt; binary if you want &lt;code&gt;dwgd&lt;/code&gt; to work with docker rootless.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;You can develop on your own machine by compiling &lt;code&gt;dwgd&lt;/code&gt;, creating a WireGuard network and starting &lt;code&gt;dwgd&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build ./cmd/dwgd.go&#xA;# create server keys&#xA;SERVER_PRIVATE_KEY=$(wg genkey)&#xA;SERVER_PUBLIC_KEY=$(echo $SERVER_PRIVATE_KEY | wg pubkey)&#xA;# create new dwgd0 wireguard interface&#xA;sudo ip link add dwgd0 type wireguard&#xA;echo $SERVER_PRIVATE_KEY | sudo wg set dwgd0 private-key /dev/fd/0 listen-port 51820&#xA;sudo ip address add 10.0.0.1/24 dev dwgd0&#xA;# bring interface up&#xA;sudo ip link set up dev dwgd0&#xA;# generate your container&#39;s public key with a specific seed&#xA;CLIENT_PUBLIC_KEY=$(./dwgd pubkey -i 10.0.0.2 -s supersecretseed)&#xA;sudo wg set dwgd0 peer $CLIENT_PUBLIC_KEY allowed-ips 10.0.0.2/32&#xA;# run dwgd driver&#xA;sudo ./dwgd -v &amp;amp;&#xA;# create docker network with the previously set server public key and seed&#xA;docker network create --driver=dwgd -o dwgd.endpoint=localhost:51820 -o dwgd.seed=supersecretseed -o dwgd.pubkey=$SERVER_PUBLIC_KEY --subnet=&#34;10.0.0.0/24&#34; --gateway=10.0.0.1 dwgd-net&#xA;# run your container&#xA;docker run -it --rm --network=dwgd-net --ip=10.0.0.2 busybox&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>