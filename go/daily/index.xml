<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-18T01:32:03Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>JoyalAJohney/Realtime-Distributed-Chat</title>
    <updated>2024-01-18T01:32:03Z</updated>
    <id>tag:github.com,2024-01-18:/JoyalAJohney/Realtime-Distributed-Chat</id>
    <link href="https://github.com/JoyalAJohney/Realtime-Distributed-Chat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;High throughput üöÄ low latency - realtime chat built in Go and React ‚ù§Ô∏è&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Real-time Distributed Chat&lt;/h1&gt; &#xA;&lt;p&gt;This repo contains the &lt;strong&gt;frontend&lt;/strong&gt; (React.js), &lt;strong&gt;backend&lt;/strong&gt; (Go-Fiber) and &lt;strong&gt;Infrastructure&lt;/strong&gt; (Terraform, CI/CD) code for building a distributed, real-time, scalable messaging platform. If you are a developer seeking to learn system design or even looking to find how end-to-end projects are build, I hope you find this useful ‚ù§Ô∏è&lt;/p&gt; &#xA;&lt;br&gt; I will be writing articles on multiple features about the project like Configuring nginx as a reverse proxy for loadbalancing, TLS/SSL certificate for HTTPS communication, Setting up infrastructure using Terraform etc. So do follow me on HashNode (https://joyalajohney.hashnode.dev/). if you like the repo, please consider giving it a ‚≠ê! &#xA;&lt;p&gt;. &lt;img src=&#34;https://raw.githubusercontent.com/JoyalAJohney/Realtime-Distributed-Chat/main/assets/babylon.png&#34; alt=&#34;landing page&#34;&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;br&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/React-20232A?style=for-the-badge&amp;amp;logo=react&amp;amp;logoColor=61DAFB&#34; alt=&#34;React Badge&#34;&gt; * &#xA; &lt;img src=&#34;https://img.shields.io/badge/nginx-%23009639.svg?style=for-the-badge&amp;amp;logo=nginx&amp;amp;logoColor=white&#34; alt=&#34;Nginx Badge&#34;&gt; * &#xA; &lt;img src=&#34;https://img.shields.io/badge/Go-00ADD8?style=for-the-badge&amp;amp;logo=go&amp;amp;logoColor=white&#34; alt=&#34;Golang Badge&#34;&gt; * &#xA; &lt;img src=&#34;https://img.shields.io/badge/redis-%23DD0031.svg?&amp;amp;style=for-the-badge&amp;amp;logo=redis&amp;amp;logoColor=white&#34; alt=&#34;Redis Badge&#34;&gt; * &#xA; &lt;img src=&#34;https://img.shields.io/badge/postgres-%23316192.svg?style=for-the-badge&amp;amp;logo=postgresql&amp;amp;logoColor=white&#34; alt=&#34;Postgres Badge&#34;&gt; * &#xA; &lt;img src=&#34;https://img.shields.io/badge/Apache%20Kafka-000?style=for-the-badge&amp;amp;logo=apachekafka&#34; alt=&#34;Kafka Badge&#34;&gt; * &#xA; &lt;img src=&#34;https://img.shields.io/badge/terraform-%235835CC.svg?style=for-the-badge&amp;amp;logo=terraform&amp;amp;logoColor=white&#34; alt=&#34;Terraform Badge&#34;&gt; * &#xA; &lt;img src=&#34;https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&amp;amp;logo=docker&amp;amp;logoColor=white&#34; alt=&#34;Docker Badge&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Product Demo üöÄ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/JoyalAJohney/Realtime-Distributed-Chat/assets/31545426/db55bf32-1e35-4071-a80e-9f4944614e71&#34;&gt;https://github.com/JoyalAJohney/Realtime-Distributed-Chat/assets/31545426/db55bf32-1e35-4071-a80e-9f4944614e71&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About the Project üåå&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Multiple Go-fiber servers providing API endpoints (JWT authentication) and WebSocket connections for full-duplex communication. These Go instances are configured under Nginx (reverse proxy) Which act a layer 7 loadbalancer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To propagate messages for users within the same room but connected to multiple instances, we utilize Redis (Pub/Sub model). Each instance is subscribed to a particular channel in Redis and gets notified on receiving messages. All messages are stored in Postgres.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The database can undergo a heavy write load if we receive 100 messages/sec. To avoid this, we use kafka, a message stream designed for high throughput and low latency processing. A consumer (Go instance) will consume messages from kafka in batches and writes them to postgres.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The frontend for application is build using React.js and served in an Nginx container. All the nodes are containarized using Docker and Configured using Docker-Compose. We only expose the Reverse-Proxy (Nginx) to the outside world. Al requests are redirected from there.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Next step is to deploy the application on AWS. A CI/CD pipeline is implemented using github actions. We use Terraform for setting up Infrastructure on AWS, configuring an EC2 instance, S3 storage, Security groups and Elastic IP. This is ntegrated into the CI/CD pipeline.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For secure HTTPS access, Issue certificate and configure it in Nginx for secure TLS/SSL communication.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setting Up üîß&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create a .env file from the env.sample file.&lt;/li&gt; &#xA; &lt;li&gt;Fill in the values based on your required configuration.&lt;/li&gt; &#xA; &lt;li&gt;Make sure that the .env file is in the same level as docker-compose.yml file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Redis Config&#xA;REDIS_PORT=6379&#xA;REDIS_HOST=redis&#xA;&#xA;# Database Config&#xA;POSTGRES_DATABASE=chat_db&#xA;POSTGRES_USER=postgres&#xA;POSTGRES_PASSWORD=postgres&#xA;POSTGRES_HOST=postgres&#xA;POSTGRES_PORT=5432&#xA;&#xA;# Kafka config&#xA;KAFKA_HOST=kafka&#xA;KAFKA_PORT=9092&#xA;KAFKA_TOPIC=chat_messages&#xA;KAFKA_GROUP_ID=chat_group&#xA;ZOOKEEPER_PORT=2181&#xA;&#xA;# Authentication&#xA;JWT_SECRET=secret&#xA;&#xA;# Reverse proxy config&#xA;NGINX_ENV=local&#xA;NGINX_PORT=8080&#xA;NGINX_HOST=localhost&#xA;&#xA;# Backend Servers&#xA;SERVER_PORT=8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I have only shared the template code for &lt;strong&gt;Infrastructre&lt;/strong&gt; (pipeline &amp;amp; terraform). You need to configure the AWS credentials, Terraform, and Pipeline according to your requirements. Additionally, you&#39;ll have to set up TLS/SSL for HTTPS (since all of this information is sensitive, it has been omitted)&lt;/p&gt; &#xA;&lt;h2&gt;Running the app&lt;/h2&gt; &#xA;&lt;p&gt;Execute the below command to build the application containers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up --build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the application starts perfectly fine, you should be able to head over to &lt;a href=&#34;http://localhost:8080/&#34;&gt;http://localhost:8080/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>