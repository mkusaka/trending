<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-17T01:28:53Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nalgeon/redka</title>
    <updated>2024-04-17T01:28:53Z</updated>
    <id>tag:github.com,2024-04-17:/nalgeon/redka</id>
    <link href="https://github.com/nalgeon/redka" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Redis re-implemented with SQLite&lt;/p&gt;&lt;hr&gt;&lt;img alt=&#34;Redka&#34; src=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/logo.svg?sanitize=true&#34; height=&#34;80&#34; align=&#34;center&#34;&gt; &#xA;&lt;p&gt;Redka aims to reimplement the good parts of Redis with SQLite, while remaining compatible with Redis API.&lt;/p&gt; &#xA;&lt;p&gt;Notable features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Data does not have to fit in RAM.&lt;/li&gt; &#xA; &lt;li&gt;ACID transactions.&lt;/li&gt; &#xA; &lt;li&gt;SQL views for better introspection and reporting.&lt;/li&gt; &#xA; &lt;li&gt;Both in-process (Go API) and standalone (RESP) servers.&lt;/li&gt; &#xA; &lt;li&gt;Redis-compatible commands and wire protocol.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a work in progress. See below for the current status and roadmap.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/#commands&#34;&gt;Commands&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/#installation&#34;&gt;Installation&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/#usage&#34;&gt;Usage&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/#persistence&#34;&gt;Persistence&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/#performance&#34;&gt;Performance&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/#roadmap&#34;&gt;Roadmap&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/#more-information&#34;&gt;More&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;Redka aims to support five core Redis data types: strings, lists, sets, hashes, and sorted sets.&lt;/p&gt; &#xA;&lt;h3&gt;Strings&lt;/h3&gt; &#xA;&lt;p&gt;Strings are the most basic Redis type, representing a sequence of bytes. Redka supports the following string-related commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Command      Go API                 Description&#xA;-------      ------                 -----------&#xA;DECR         DB.Str().Incr          Decrements the integer value of a key by one.&#xA;DECRBY       DB.Str().Incr          Decrements a number from the integer value of a key.&#xA;GET          DB.Str().Get           Returns the value of a key.&#xA;GETSET       DB.Str().GetSet        Sets the key to a new value and returns the prev value.&#xA;INCR         DB.Str().Incr          Increments the integer value of a key by one.&#xA;INCRBY       DB.Str().Incr          Increments the integer value of a key by a number.&#xA;INCRBYFLOAT  DB.Str().IncrFloat     Increments the float value of a key by a number.&#xA;MGET         DB.Str().GetMany       Returns the values of one or more keys.&#xA;MSET         DB.Str().SetMany       Sets the values of one or more keys.&#xA;MSETNX       DB.Str().SetManyNX     Sets the values of one or more keys when all keys don&#39;t exist.&#xA;PSETEX       DB.Str().SetExpires    Sets the value and expiration time (in ms) of a key.&#xA;SET          DB.Str().Set           Sets the value of a key.&#xA;SETEX        DB.Str().SetExpires    Sets the value and expiration (in sec) time of a key.&#xA;SETNX        DB.Str().SetNotExists  Sets the value of a key when the key doesn&#39;t exist.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following string-related commands are not planned for 1.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;APPEND  GETDEL  GETEX  GETRANGE  LCS  SETRANGE  STRLEN  SUBSTR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lists&lt;/h3&gt; &#xA;&lt;p&gt;Lists are lists of strings sorted by insertion order. Redka aims to support the following list-related commands in 1.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;LINDEX  LINSERT  LLEN  LPOP  LPUSHX  LRANGE  LREM  LSET&#xA;LTRIM  RPOP  RPOPLPUSH  RPUSH  RPUSHX&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sets&lt;/h3&gt; &#xA;&lt;p&gt;Sets are unordered collections of unique strings. Redka aims to support the following set-related commands in 1.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SADD  SCARD  SDIFF  SDIFFSTORE  SINTER  SINTERSTORE&#xA;SISMEMBER  SMEMBERS  SMOVE  SPOP  SRANDMEMBER  SREM&#xA;SUNION  SUNIONSTORE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Hashes&lt;/h3&gt; &#xA;&lt;p&gt;Hashes are field-value (hash)maps. Redka supports the following hash-related commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Command       Go API                  Description&#xA;-------       ------------------      -----------&#xA;HDEL          DB.Hash().Delete        Deletes one or more fields and their values.&#xA;HEXISTS       DB.Hash().Exists        Determines whether a field exists.&#xA;HGET          DB.Hash().Get           Returns the value of a field.&#xA;HGETALL       DB.Hash().Items         Returns all fields and values.&#xA;HINCRBY       DB.Hash().Incr          Increments the integer value of a field.&#xA;HINCRBYFLOAT  DB.Hash().IncrFloat     Increments the float value of a field.&#xA;HKEYS         DB.Hash().Keys          Returns all fields.&#xA;HLEN          DB.Hash().Len           Returns the number of fields.&#xA;HMGET         DB.Hash().GetMany       Returns the values of multiple fields.&#xA;HMSET         DB.Hash().SetMany       Sets the values of multiple fields.&#xA;HSCAN         DB.Hash().Scanner       Iterates over fields and values.&#xA;HSET          DB.Hash().SetMany       Sets the values of one or more fields.&#xA;HSETNX        DB.Hash().SetNotExists  Sets the value of a field when it doesn&#39;t exist.&#xA;HVALS         DB.Hash().Exists        Returns all values.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following hash-related commands are not planned for 1.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;HRANDFIELD  HSTRLEN&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sorted sets&lt;/h3&gt; &#xA;&lt;p&gt;Sorted sets are collections of unique strings ordered by each string&#39;s associated score. Redka aims to support the following sorted set related commands in 1.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ZADD  ZCARD  ZCOUNT  ZINCRBY  ZINTERSTORE  ZRANGE&#xA;ZRANK  ZREM  ZSCORE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Key management&lt;/h3&gt; &#xA;&lt;p&gt;Redka supports the following key management (generic) commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Command    Go API                    Description&#xA;-------    ------                    -----------&#xA;DEL        DB.Key().Delete           Deletes one or more keys.&#xA;EXISTS     DB.Key().Count            Determines whether one or more keys exist.&#xA;EXPIRE     DB.Key().Expire           Sets the expiration time of a key (in seconds).&#xA;EXPIREAT   DB.Key().ExpireAt         Sets the expiration time of a key to a Unix timestamp.&#xA;KEYS       DB.Key().Keys             Returns all key names that match a pattern.&#xA;PERSIST    DB.Key().Persist          Removes the expiration time of a key.&#xA;PEXPIRE    DB.Key().Expire           Sets the expiration time of a key in ms.&#xA;PEXPIREAT  DB.Key().ExpireAt         Sets the expiration time of a key to a Unix ms timestamp.&#xA;RANDOMKEY  DB.Key().Random           Returns a random key name from the database.&#xA;RENAME     DB.Key().Rename           Renames a key and overwrites the destination.&#xA;RENAMENX   DB.Key().RenameNotExists  Renames a key only when the target key name doesn&#39;t exist.&#xA;SCAN       DB.Key().Scanner          Iterates over the key names in the database.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following generic commands are not planned for 1.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;COPY  DUMP  EXPIRETIME  MIGRATE  MOVE  OBJECT  PEXPIRETIME&#xA;PTTL  RESTORE  SORT  SORT_RO  TOUCH  TTL  TYPE  UNLINK&#xA;WAIT  WAITAOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transactions&lt;/h3&gt; &#xA;&lt;p&gt;Redka supports the following transaction commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Command    Go API                 Description&#xA;-------    ------                 -----------&#xA;DISCARD    DB.View / DB.Update    Discards a transaction.&#xA;EXEC       DB.View / DB.Update    Executes all commands in a transaction.&#xA;MULTI      DB.View / DB.Update    Starts a transaction.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike Redis, Redka&#39;s transactions are fully ACID, providing automatic rollback in case of failure.&lt;/p&gt; &#xA;&lt;p&gt;The following transaction commands are not planned for 1.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;UNWATCH  WATCH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Server/connection management&lt;/h3&gt; &#xA;&lt;p&gt;Redka supports only a couple of server and connection management commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Command    Go API                Description&#xA;-------    ------                -----------&#xA;ECHO       -                     Returns the given string.&#xA;FLUSHDB    DB.Key().DeleteAll    Remove all keys from the database.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The rest of the server and connection management commands are not planned for 1.0.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Redka can be installed as a standalone Redis-compatible server, or as a Go module for in-process use.&lt;/p&gt; &#xA;&lt;h2&gt;Standalone server&lt;/h2&gt; &#xA;&lt;p&gt;Redka server is a single-file binary. Download it from the &lt;a href=&#34;https://github.com/nalgeon/redka/releases&#34;&gt;releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Linux (x86 CPU only):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -L -O &#34;https://github.com/nalgeon/redka/releases/download/v0.2.0/redka_linux_amd64.zip&#34;&#xA;unzip redka_linux_amd64.zip&#xA;chmod +x redka&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;macOS (both x86 and ARM/Apple Silicon CPU):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -L -O &#34;https://github.com/nalgeon/redka/releases/download/v0.2.0/redka_darwin_amd64.zip&#34;&#xA;unzip redka_darwin_amd64.zip&#xA;# remove the build from quarantine&#xA;# (macOS disables unsigned binaries)&#xA;xattr -d com.apple.quarantine redka&#xA;chmod +x redka&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or pull with Docker as follows (x86/ARM):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull nalgeon/redka&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or build from source (requires Go 1.22 and GCC):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/nalgeon/redka.git&#xA;cd redka&#xA;make setup build&#xA;# the path to the binary after the build&#xA;# will be ./build/redka&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Go module&lt;/h2&gt; &#xA;&lt;p&gt;Install the module as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/nalgeon/redka&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll also need an SQLite driver. Use &lt;code&gt;github.com/mattn/go-sqlite3&lt;/code&gt; if you don&#39;t mind CGO. Otherwise use a pure Go driver &lt;code&gt;modernc.org/sqlite&lt;/code&gt;. Install either with &lt;code&gt;go get&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/mattn/go-sqlite3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Redka can be used as a standalone Redis-compatible server, or as an embeddable in-process server with Go API.&lt;/p&gt; &#xA;&lt;h3&gt;Standalone server&lt;/h3&gt; &#xA;&lt;p&gt;Redka server is a single-file binary. After downloading and unpacking the release asset, run it as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;redka [-h host] [-p port] [db-path]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./redka&#xA;./redka data.db&#xA;./redka -h 0.0.0.0 -p 6379 data.db&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Server defaults are host &lt;code&gt;localhost&lt;/code&gt;, port &lt;code&gt;6379&lt;/code&gt; and empty DB path.&lt;/p&gt; &#xA;&lt;p&gt;Running without a DB path creates an in-memory database. The data is not persisted in this case, and will be gone when the server is stopped.&lt;/p&gt; &#xA;&lt;p&gt;You can also run Redka with Docker as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# database inside the container&#xA;# will be lost when the container stops&#xA;docker run --rm -p 6379:6379 nalgeon/redka&#xA;&#xA;# persistent database&#xA;# using the /path/to/data host directory&#xA;docker run --rm -p 6379:6379 -v /path/to/data:/data nalgeon/redka&#xA;&#xA;# in-memory database, custom post&#xA;docker run --rm -p 6380:6380 nalgeon/redka redka -h 0.0.0.0 -p 6380&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Server defaults in Docker are host &lt;code&gt;0.0.0.0&lt;/code&gt;, port &lt;code&gt;6379&lt;/code&gt; and DB path &lt;code&gt;/data/redka.db&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Once the server is running, connect to it using &lt;code&gt;redis-cli&lt;/code&gt; or an API client like &lt;code&gt;redis-py&lt;/code&gt; or &lt;code&gt;go-redis&lt;/code&gt; — just as you would with Redis.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;redis-cli -h localhost -p 6379&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; echo hello&#xA;&#34;hello&#34;&#xA;127.0.0.1:6379&amp;gt; set name alice&#xA;OK&#xA;127.0.0.1:6379&amp;gt; get name&#xA;&#34;alice&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;In-process server&lt;/h3&gt; &#xA;&lt;p&gt;The primary object in Redka is the &lt;code&gt;DB&lt;/code&gt;. To open or create your database, use the &lt;code&gt;redka.Open()&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;    &#34;log&#34;&#xA;&#xA;    _ &#34;github.com/mattn/go-sqlite3&#34;&#xA;    &#34;github.com/nalgeon/redka&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    // Open or create the data.db file.&#xA;    db, err := redka.Open(&#34;data.db&#34;, nil)&#xA;    if err != nil {&#xA;        log.Fatal(err)&#xA;    }&#xA;    // Always close the database when you are finished.&#xA;    defer db.Close()&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Don&#39;t forget to import the driver (here I use &lt;code&gt;github.com/mattn/go-sqlite3&lt;/code&gt;). Using &lt;code&gt;modernc.org/sqlite&lt;/code&gt; is slightly different, see &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/example/modernc/main.go&#34;&gt;example/modernc/main.go&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;To open an in-memory database that doesn&#39;t persist to disk, use the following path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// All data is lost when the database is closed.&#xA;redka.Open(&#34;file:redka?mode=memory&amp;amp;cache=shared&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After opening the database, call &lt;code&gt;redka.DB&lt;/code&gt; methods to run individual commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;db.Str().Set(&#34;name&#34;, &#34;alice&#34;)&#xA;db.Str().Set(&#34;age&#34;, 25)&#xA;&#xA;count, err := db.Key().Count(&#34;name&#34;, &#34;age&#34;, &#34;city&#34;)&#xA;slog.Info(&#34;count&#34;, &#34;count&#34;, count, &#34;err&#34;, err)&#xA;&#xA;name, err := db.Str().Get(&#34;name&#34;)&#xA;slog.Info(&#34;get&#34;, &#34;name&#34;, name, &#34;err&#34;, err)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;count count=2 err=&amp;lt;nil&amp;gt;&#xA;get name=&#34;alice&#34; err=&amp;lt;nil&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the full example in &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/example/simple/main.go&#34;&gt;example/simple/main.go&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Use transactions to batch commands. There are &lt;code&gt;View&lt;/code&gt; (read-only transaction) and &lt;code&gt;Update&lt;/code&gt; (writable transaction) methods for this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;updCount := 0&#xA;err := db.Update(func(tx *redka.Tx) error {&#xA;    err := tx.Str().Set(&#34;name&#34;, &#34;bob&#34;)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    updCount++&#xA;&#xA;    err = tx.Str().Set(&#34;age&#34;, 50)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    updCount++&#xA;    return nil&#xA;})&#xA;slog.Info(&#34;updated&#34;, &#34;count&#34;, updCount, &#34;err&#34;, err)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;updated count=2 err=&amp;lt;nil&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the full example in &lt;a href=&#34;https://raw.githubusercontent.com/nalgeon/redka/main/example/tx/main.go&#34;&gt;example/tx/main.go&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://pkg.go.dev/github.com/nalgeon/redka&#34;&gt;package documentation&lt;/a&gt; for API reference.&lt;/p&gt; &#xA;&lt;h2&gt;Persistence&lt;/h2&gt; &#xA;&lt;p&gt;Redka stores data in a SQLite database using the following tables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rkey&#xA;---&#xA;id       integer primary key&#xA;key      text not null&#xA;type     integer not null    -- 1 string, 2 list, 3 set, 4 hash, 5 sorted set&#xA;version  integer not null    -- incremented when the key value is updated&#xA;etime    integer             -- expiration timestamp in unix milliseconds&#xA;mtime    integer not null    -- modification timestamp in unix milliseconds&#xA;&#xA;rstring&#xA;---&#xA;key_id   integer not null    -- FK -&amp;gt; rkey.id&#xA;value    blob not null&#xA;&#xA;rhash&#xA;---&#xA;key_id   integer not null    -- FK -&amp;gt; rkey.id&#xA;field    text not null&#xA;value    blob not null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To access the data with SQL, use views instead of tables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from vstring;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;┌────────┬──────┬───────┬───────┬─────────────────────┐&#xA;│ key_id │ key  │ value │ etime │        mtime        │&#xA;├────────┼──────┼───────┼───────┼─────────────────────┤&#xA;│ 1      │ name │ alice │       │ 2024-04-03 16:58:14 │&#xA;│ 2      │ age  │ 50    │       │ 2024-04-03 16:34:52 │&#xA;└────────┴──────┴───────┴───────┴─────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;etime&lt;/code&gt; and &lt;code&gt;mtime&lt;/code&gt; are in UTC.&lt;/p&gt; &#xA;&lt;p&gt;There is a separate view for every data type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vstring  vhash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;ve compared Redka with Redis using &lt;a href=&#34;https://redis.io/docs/management/optimization/benchmarks/&#34;&gt;redis-benchmark&lt;/a&gt; with the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;10 parallel connections&lt;/li&gt; &#xA; &lt;li&gt;1000000 requests&lt;/li&gt; &#xA; &lt;li&gt;10000 randomized keys&lt;/li&gt; &#xA; &lt;li&gt;GET/SET commands&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SQLite settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pragma journal_mode = wal;&#xA;pragma synchronous = normal;&#xA;pragma temp_store = memory;&#xA;pragma mmap_size = 268435456;&#xA;pragma foreign_keys = on;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hardware: Apple M1 8-core CPU, 16GB RAM&lt;/p&gt; &#xA;&lt;p&gt;Redis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;redis-server --appendonly no&#xA;redis-benchmark -p 6379 -q -c 10 -n 1000000 -r 10000 -t get,set&#xA;&#xA;SET: 133262.25 requests per second, p50=0.055 msec&#xA;GET: 139217.59 requests per second, p50=0.055 msec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Redka (in-memory):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./redka -p 6380&#xA;redis-benchmark -p 6380 -q -c 10 -n 1000000 -r 10000 -t get,set&#xA;&#xA;SET: 30084.24 requests per second, p50=0.255 msec&#xA;GET: 63011.97 requests per second, p50=0.103 msec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Redka (persisted to disk):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./redka -p 6380 data.db&#xA;redis-benchmark -p 6380 -q -c 10 -n 1000000 -r 10000 -t get,set&#xA;&#xA;SET: 21913.01 requests per second, p50=0.335 msec&#xA;GET: 56795.59 requests per second, p50=0.119 msec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So while Redka is 2-6 times slower than Redis (not surprising, since we are comparing a relational database to a key-value data store), it can still do 22K writes/sec and 57K reads/sec, which is pretty good if you ask me.&lt;/p&gt; &#xA;&lt;p&gt;Note that running in a container may result in poorer performance.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;The project is on its way to 1.0.&lt;/p&gt; &#xA;&lt;p&gt;The 1.0 release will include the following features from Redis 2.x (which I consider the &#34;golden age&#34; of the Redis API):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;✅ Strings.&lt;/li&gt; &#xA; &lt;li&gt;⬜ Lists.&lt;/li&gt; &#xA; &lt;li&gt;⬜ Sets.&lt;/li&gt; &#xA; &lt;li&gt;✅ Hashes.&lt;/li&gt; &#xA; &lt;li&gt;⏳ Sorted sets.&lt;/li&gt; &#xA; &lt;li&gt;✅ Key management.&lt;/li&gt; &#xA; &lt;li&gt;✅ Transactions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;✅ = done, ⏳ = in progress, ⬜ = next in line&lt;/p&gt; &#xA;&lt;p&gt;Future versions may include additional data types (such as streams, HyperLogLog or geo), features like publish/subscribe, and more commands for existing types.&lt;/p&gt; &#xA;&lt;p&gt;Features I&#39;d rather not implement even in future versions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lua scripting.&lt;/li&gt; &#xA; &lt;li&gt;Authentication and ACLs.&lt;/li&gt; &#xA; &lt;li&gt;Multiple databases.&lt;/li&gt; &#xA; &lt;li&gt;Watch/unwatch.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Features I definitely don&#39;t want to implement:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cluster.&lt;/li&gt; &#xA; &lt;li&gt;Sentinel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;More information&lt;/h2&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;Contributions are welcome. For anything other than bugfixes, please first open an issue to discuss what you want to change.&lt;/p&gt; &#xA;&lt;p&gt;Be sure to add or update tests as appropriate.&lt;/p&gt; &#xA;&lt;h3&gt;Acknowledgements&lt;/h3&gt; &#xA;&lt;p&gt;Redka would not be possible without these great projects and their creators:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://redis.io/&#34;&gt;Redis&lt;/a&gt; (&lt;a href=&#34;https://github.com/antirez&#34;&gt;Salvatore Sanfilippo&lt;/a&gt;). It&#39;s such an amazing idea to go beyond the get-set paradigm and provide a convenient API for more complex data structures.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://sqlite.org/&#34;&gt;SQLite&lt;/a&gt; (&lt;a href=&#34;https://www.sqlite.org/crew.html&#34;&gt;D. Richard Hipp&lt;/a&gt;). The in-process database powering the world.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tidwall/redcon&#34;&gt;Redcon&lt;/a&gt; (&lt;a href=&#34;https://github.com/tidwall&#34;&gt;Josh Baker&lt;/a&gt;). A very clean and convenient implementation of a RESP server.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Logo font by &lt;a href=&#34;https://ektype.in/&#34;&gt;Ek Type&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;Copyright 2024 &lt;a href=&#34;https://antonz.org/&#34;&gt;Anton Zhiyanov&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The software is available under the BSD-3-Clause license.&lt;/p&gt; &#xA;&lt;h3&gt;Stay tuned&lt;/h3&gt; &#xA;&lt;p&gt;★ &lt;a href=&#34;https://antonz.org/subscribe/&#34;&gt;Subscribe&lt;/a&gt; to stay on top of new features.&lt;/p&gt;</summary>
  </entry>
</feed>