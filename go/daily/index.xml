<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-02T01:30:12Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kosmos-io/kosmos</title>
    <updated>2023-12-02T01:30:12Z</updated>
    <id>tag:github.com,2023-12-02:/kosmos-io/kosmos</id>
    <link href="https://github.com/kosmos-io/kosmos" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KOSMOS&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/kosmos-io/kosmos/main/README_zh.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Kosmos is an open-source, all-in-one distributed cloud-native solution. The name &#34;kosmos&#34; combines &#39;k&#39; representing Kubernetes and &#39;cosmos&#39; which means universe in Greek, symbolizing the limitless expansion of Kubernetes. Currently, Kosmos primarily consists of three major modules: ClusterLink, ClusterTree and Scheduler. Additionally, Kosmos is equipped with a tool called kosmosctl, which allows for quick deployment of Kosmos components, adding clusters, and testing network connectivity.&lt;/p&gt; &#xA;&lt;h2&gt;ClusterLink&lt;/h2&gt; &#xA;&lt;p&gt;The target of Kosmos networking is to establish connectivity between multiple Kubernetes clusters. This module can be deployed and used independently. Kosmos networking enables &lt;code&gt;Pods&lt;/code&gt; to access &lt;code&gt;Pods&lt;/code&gt; and &lt;code&gt;Services&lt;/code&gt; across clusters, as if they were in the same cluster. Currently, this module primarily offers the following ability:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cross-cluster PodIP and ServiceIP Make communication&lt;/strong&gt;: Linux vxlan base on tunneling technology, this enables L3 network connectivity across multiple Kubernetes clusters. This allows users to conduct &lt;code&gt;Pod-to-Pod&lt;/code&gt; and &lt;code&gt;Pod-to-Service&lt;/code&gt; communication within the global clusters scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Multi-Mode Support&lt;/strong&gt;: When join clusters, you can choose &lt;code&gt;P2P&lt;/code&gt; or &lt;code&gt;Gateway&lt;/code&gt; mode. When selecting the &lt;code&gt;P2P&lt;/code&gt; mode, it is applicable for underlay network interconnection,offering shorter network paths and superior performance. When selecting the &lt;code&gt;Gateway&lt;/code&gt; mode, it demonstrates superior compatibility, which is well-suited for hybrid and multi-cloud scenarios.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Support for Global IP Allocation&lt;/strong&gt;: Kosmos networking allows for the presence of two or more clusters within the global clusters to use the same &lt;code&gt;Pod/Service&lt;/code&gt; network segments, making it convenient for users to manage subnet. Kosmos supports configuring the mapping relationship between &lt;code&gt;PodCIDR/ServiceCIDR&lt;/code&gt; and &lt;code&gt;GlobalCIDR&lt;/code&gt;. &lt;code&gt;GlobalIP&lt;/code&gt; is globally unique, enabling cross-cluster communication for services with conflicting network segments through &lt;code&gt;GlobalIP&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;IPv6/IPv4 Dual-Stack Support&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Network Architecture&lt;/h3&gt; &#xA;&lt;p&gt;The Kosmos ClusterLink module currently includes the following key components:&lt;/p&gt; &#xA;&lt;div&gt;&#xA; &lt;img src=&#34;https://raw.githubusercontent.com/kosmos-io/kosmos/main/docs/images/link-arch.png&#34; style=&#34;width:900px;&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Controller-Manager&lt;/code&gt;：Collectes network information of the current cluster and monitors changes in network settings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Network-manager&lt;/code&gt;：Calculates the network configurations required for each node.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Agent&lt;/code&gt;：A DaemonSet used for configuring the host network, including tasks such as tunnel creation, routing, NAT, and so on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Multi-Cluster-Coredns&lt;/code&gt;：Implements multi-cluster service discovery.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Elector&lt;/code&gt;：Elects the gateway node.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ClusterTree&lt;/h2&gt; &#xA;&lt;p&gt;The Kosmos clustertree module realizes the tree-like scaling of Kubernetes and achieves cross-cluster orchestration of applications.&lt;/p&gt; &#xA;&lt;div&gt;&#xA; &lt;img src=&#34;https://raw.githubusercontent.com/kosmos-io/kosmos/main/docs/images/clustertree-arch.png&#34; style=&#34;width:900px;&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;p&gt;Currently, it primarily supports the following ability:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Full Compatibility with k8s API&lt;/strong&gt;: Users can interact with the host cluster&#39;s &lt;code&gt;kube-apiserver&lt;/code&gt; using tools like &lt;code&gt;kubectl&lt;/code&gt;, &lt;code&gt;client-go&lt;/code&gt;, and others just like they normally would. However, the &lt;code&gt;Pods&lt;/code&gt; are actually distributed across the entire multi-cloud, multi-cluster environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Support for Stateful and k8s-native Applications&lt;/strong&gt;: In addition to stateless applications, Kosmos also facilitates the orchestration of stateful applications and k8s-native applications (interacting with &lt;code&gt;kube-apiserver&lt;/code&gt;). Kosmos will automatically detect the storage and permission resources that &lt;code&gt;Pods&lt;/code&gt;depend on, such as pv/pvc, sa, etc., and perform automatic bothway synchronization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Diverse Pod Topology Constraints&lt;/strong&gt;: Users can easily control the distribution of Pods within the global clusters, such as by region, availability zone, cluster, or node. This helps achieve high availability and improve resource utilization.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Scheduler&lt;/h2&gt; &#xA;&lt;p&gt;The Kosmos scheduling module is an extension developed on top of the Kubernetes scheduling framework, aiming to meet the container management needs in mixed-node and sub-cluster environments. It provides the following core features to enhance the flexibility and efficiency of container management:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Flexible Node and Cluster Hybrid Scheduling&lt;/strong&gt;: The Kosmos scheduling module allows users to intelligently schedule workloads between real nodes and sub-clusters based on custom configurations. This enables users to make optimal use of resources across different nodes, ensuring the best performance and availability of workloads. Based on this capability, Kosmos enables workloads to achieve flexible cross-cloud and cross-cluster deployments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Fine-grained Container Distribution Strategy&lt;/strong&gt;: By introducing Custom Resource Definitions (CRD), users can exert precise control over the distribution of workloads. The configuration of CRD allows users to explicitly specify the number of pods for the workload in different clusters and adjust the distribution ratio as needed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Fine-grained Fragmented Resource Handling&lt;/strong&gt;: The Kosmos scheduling module intelligently detects fragmented resources within sub-clusters, effectively avoiding situations where pod deployment encounters insufficient resources in the sub-cluster. This helps ensure a more balanced allocation of resources across different nodes, enhancing system stability and performance. Whether building a hybrid cloud environment or requiring flexible deployment of workloads across different clusters, the Kosmos scheduling module serves as a reliable solution, assisting users in managing containerized applications more efficiently.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;The following command allows you to quickly run an experimental environment with three clusters. Install the control plane in the host cluster.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;kosmosctl install  --cni calico --default-nic eth0 (We build a network tunnel based the network interface value passed by the arg default-nic)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Join the two member clusters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;kosmosctl join cluster --name cluster1 --kubeconfig ~/kubeconfig/cluster1-kubeconfig  --cni calico --default-nic eth0  --enable-all&#xA;kosmosctl join cluster --name cluster2 --kubeconfig ~/kubeconfig/cluster2-kubeconfig  --cni calico --default-nic eth0  --enable-all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then we can Use the Kosmos clusters like single cluster.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;If you have questions, feel free to reach out to us in the following ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:wuyingjun@cmss.chinamobile.com&#34;&gt;Email&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kosmos-io/kosmos/main/docs/images/kosmos-WechatIMG.jpg&#34;&gt;WeChat&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/kosmos-io/clusterlink/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=kosmos-io/kosmos&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;Made with &lt;a href=&#34;https://contrib.rocks&#34;&gt;contrib.rocks&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright 2023 the KOSMOS Authors. All rights reserved.&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bracesdev/errtrace</title>
    <updated>2023-12-02T01:30:12Z</updated>
    <id>tag:github.com,2023-12-02:/bracesdev/errtrace</id>
    <link href="https://github.com/bracesdev/errtrace" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An alternative to stack traces for your Go errors&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;errtrace&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;What if every function added its location to returned errors?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/assets/logo.png&#34; alt=&#34;errtrace logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bracesdev/errtrace/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/bracesdev/errtrace/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/braces.dev/errtrace&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/braces.dev/errtrace.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/bracesdev/errtrace&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/bracesdev/errtrace/graph/badge.svg?token=KDY04XEEJ9&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#introduction&#34;&gt;Introduction&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#comparison-with-stack-traces&#34;&gt;Comparison with stack traces&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#try-it-out&#34;&gt;Try it out&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#why-is-this-useful&#34;&gt;Why is this useful&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#manual-instrumentation&#34;&gt;Manual instrumentation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#automatic-instrumentation&#34;&gt;Automatic instrumentation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#caveats&#34;&gt;Caveats&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#error-wrapping&#34;&gt;Error wrapping&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#safety&#34;&gt;Safety&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;errtrace is an &lt;strong&gt;experimental&lt;/strong&gt; package to trace an error&#39;s return path — the return trace — through a Go program.&lt;/p&gt; &#xA;&lt;p&gt;Where a stack trace tracks the code path that led to an error, a return trace tracks the code path that the error took to get to the user. Often these are the same path, but in Go they can diverge, since errors are values that can be transported across goroutines (e.g. with channels). When that happens, a return trace can be more useful than a stack trace.&lt;/p&gt; &#xA;&lt;p&gt;This library is inspired by &lt;a href=&#34;https://ziglang.org/documentation/0.11.0/#Error-Return-Traces&#34;&gt;Zig&#39;s error return traces&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight&lt;/strong&gt;&lt;br&gt; errtrace brings no other runtime dependencies with it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#manual-instrumentation&#34;&gt;Simple&lt;/a&gt;&lt;/strong&gt;&lt;br&gt; The library API is simple, straightforward, and idiomatic.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#automatic-instrumentation&#34;&gt;Easy&lt;/a&gt;&lt;/strong&gt;&lt;br&gt; The errtrace CLI will automatically instrument your code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#performance&#34;&gt;Fast&lt;/a&gt;&lt;/strong&gt;&lt;br&gt; On popular 64-bit systems, errtrace is much faster than capturing a stack trace.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Comparison with stack traces&lt;/h3&gt; &#xA;&lt;p&gt;With stack traces, caller information for the goroutine is captured once when the error is created.&lt;/p&gt; &#xA;&lt;p&gt;In constrast, errtrace records the caller information incrementally, following the return path the error takes to get to the user. This approach works even if the error isn&#39;t propagated directly through function returns, and across goroutines.&lt;/p&gt; &#xA;&lt;p&gt;Both approaches look similar when the error flows through function calls within the same goroutine, but can differ significantly when errors are passed outside of functions and across goroutines (e.g., channels).&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a real-world example that shows the benefits of errtrace tracing the return path by comparing a custom dial error returned for a HTTP request, which the net/http library uses a background goroutine for.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;errtrace compared to a stack trace&lt;/summary&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt;&#xA;    &lt;td&gt;errtrace&lt;/td&gt;&#xA;    &lt;td&gt;stack trace&lt;/td&gt;&#xA;   &lt;/tr&gt; &#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt;&#xA;    &lt;td&gt; &lt;pre&gt;&lt;code&gt;Error: connect rate limited&#xA;&#xA;braces.dev/errtrace_test.rateLimitDialer&#xA;&#x9;/path/to/errtrace/example_http_test.go:72&#xA;braces.dev/errtrace_test.(*PackageStore).updateIndex&#xA;&#x9;/path/to/errtrace/example_http_test.go:59&#xA;braces.dev/errtrace_test.(*PackageStore).Get&#xA;&#x9;/path/to/errtrace/example_http_test.go:49&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;&#xA;    &lt;td&gt; &lt;pre&gt;&lt;code&gt;Error: connect rate limited&#xA;braces.dev/errtrace_test.rateLimitDialer&#xA;&#x9;/errtrace/example_stack_test.go:81&#xA;net/http.(*Transport).dial&#xA;&#x9;/goroot/src/net/http/transport.go:1190&#xA;net/http.(*Transport).dialConn&#xA;&#x9;/goroot/src/net/http/transport.go:1625&#xA;net/http.(*Transport).dialConnFor&#xA;&#x9;/goroot/src/net/http/transport.go:1467&#xA;runtime.goexit&#xA;&#x9;/goroot/src/runtime/asm_arm64.s:1197&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;&#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;errtrace reports the method that triggered the HTTP request&lt;/td&gt; &#xA;    &lt;td&gt;stack trace shows details of how the HTTP client creates a connection&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;errtrace also reduces the performance impact of capturing caller information for errors that are handled rather than returned to the user, as the information is captured incrementally. Stack traces pay a fixed cost to capture caller information even if the error is handled immediately by the caller close to where the error is created.&lt;/p&gt; &#xA;&lt;h3&gt;Try it out&lt;/h3&gt; &#xA;&lt;p&gt;Try out errtrace with your own code:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the CLI.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install braces.dev/errtrace/cmd/errtrace@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Switch to your Git repository and instrument your code.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git ls-files -- &#39;*.go&#39; | xargs errtrace -w&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Let &lt;code&gt;go mod tidy&lt;/code&gt; install the errtrace Go module for you.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go mod tidy&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run your tests to ensure everything still works. You may see failures if you&#39;re comparing errors with &lt;code&gt;==&lt;/code&gt; on critical paths or if you&#39;re type-casting errors directly. See &lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#error-wrapping&#34;&gt;Error wrapping&lt;/a&gt; for more details.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go test ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Print return traces for errors in your code. To do this, you can use the &lt;code&gt;errtrace.FormatString&lt;/code&gt; function or format the error with &lt;code&gt;%+v&lt;/code&gt; in &lt;code&gt;fmt.Printf&lt;/code&gt;-style functions.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err != nil {&#xA;  fmt.Fprintf(os.Stderr, &#34;%+v&#34;, err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Return traces printed by errtrace will include the error message and the path the error took until it was printed. The output will look roughly like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;error message&#xA;&#xA;example.com/myproject.MyFunc&#xA;&#x9;/home/user/myproject/myfile.go:123&#xA;example.com/myproject.CallerOfMyFunc&#xA;&#x9;/home/user/myproject/another_file.go:456&#xA;[...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s a real-world example of errtrace in action:&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code&gt;doc2go: parse file: /path/to/project/example/foo.go:3:1: expected declaration, found invalid&#xA;&#xA;go.abhg.dev/doc2go/internal/gosrc.parseFiles&#xA;        /path/to/project/internal/gosrc/parser.go:85&#xA;go.abhg.dev/doc2go/internal/gosrc.(*Parser).ParsePackage&#xA;        /path/to/project/internal/gosrc/parser.go:44&#xA;main.(*Generator).renderPackage&#xA;        /path/to/project/generate.go:193&#xA;main.(*Generator).renderTree&#xA;        /path/to/project/generate.go:141&#xA;main.(*Generator).renderTrees&#xA;        /path/to/project/generate.go:118&#xA;main.(*Generator).renderPackageIndex&#xA;        /path/to/project/generate.go:149&#xA;main.(*Generator).renderTree&#xA;        /path/to/project/generate.go:137&#xA;main.(*Generator).renderTrees&#xA;        /path/to/project/generate.go:118&#xA;main.(*Generator).renderPackageIndex&#xA;        /path/to/project/generate.go:149&#xA;main.(*Generator).renderTree&#xA;        /path/to/project/generate.go:137&#xA;main.(*Generator).renderTrees&#xA;        /path/to/project/generate.go:118&#xA;main.(*Generator).Generate&#xA;        /path/to/project/generate.go:110&#xA;main.(*mainCmd).run&#xA;        /path/to/project/main.go:199&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Note the some functions repeat in this trace because the functions are mutually recursive.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Why is this useful?&lt;/h3&gt; &#xA;&lt;p&gt;In Go, &lt;a href=&#34;https://go.dev/blog/errors-are-values&#34;&gt;errors are values&lt;/a&gt;. This means that an error can be passed around like any other value. You can store it in a struct, pass it through a channel, etc. This level of flexibility is great, but it can also make it difficult to track down the source of an error. A stack trace stored in an error — recorded at the error site — becomes less useful as the error moves through the program. When it&#39;s eventually surfaced to the user, we&#39;ve lost a lot of context about its origin.&lt;/p&gt; &#xA;&lt;p&gt;With errtrace, we instead record the path the program took from the error site to get to the user — the &lt;strong&gt;return trace&lt;/strong&gt;. Not only can this be more useful than a stack trace, it tends to be much faster and more lightweight as well.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install errtrace with Go modules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get braces.dev/errtrace@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use the CLI, use &lt;code&gt;go install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install braces.dev/errtrace/cmd/errtrace@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;errtrace offers the following modes of usage:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#manual-instrumentation&#34;&gt;Manual instrumentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#automatic-instrumentation&#34;&gt;Automatic instrumentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Manual instrumentation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &#34;braces.dev/errtrace&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Under manual instrumentation, you&#39;re expected to import errtrace, and wrap errors at all return sites like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ...&#xA;if err != nil {&#xA;    return errtrace.Wrap(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example&lt;/summary&gt; &#xA; &lt;p&gt;Given a function like the following:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func writeToFile(path string, src io.Reader) error {&#xA;  dst, err := os.Create(path)&#xA;  if err != nil {&#xA;    return err&#xA;  }&#xA;  defer dst.Close()&#xA;&#xA;  if _, err := io.Copy(dst, src); err != nil {&#xA;    return err&#xA;  }&#xA;&#xA;  return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;With errtrace, you&#39;d change it to:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func writeToFile(path string, src io.Reader) error {&#xA;  dst, err := os.Create(path)&#xA;  if err != nil {&#xA;    return errtrace.Wrap(err)&#xA;  }&#xA;  defer dst.Close()&#xA;&#xA;  if _, err := io.Copy(dst, src); err != nil {&#xA;    return errtrace.Wrap(err)&#xA;  }&#xA;&#xA;  return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;It&#39;s important that the &lt;code&gt;errtrace.Wrap&lt;/code&gt; function is called inside the same function that&#39;s actually returning the error. A helper function will not suffice.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Automatic instrumentation&lt;/h3&gt; &#xA;&lt;p&gt;If manual instrumentation is too much work (we agree), we&#39;ve included a tool that will automatically instrument all your code with errtrace.&lt;/p&gt; &#xA;&lt;p&gt;First, &lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#installation&#34;&gt;install the tool&lt;/a&gt;. Then, run it on your code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;errtrace -w path/to/file.go path/to/another/file.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run it on all Go files in your project, if you use Git, run the following command on a Unix-like system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git ls-files -- &#39;*.go&#39; | xargs errtrace -w&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;errtrace can be set be setup as a custom formatter in your editor, similar to gofmt or goimports.&lt;/p&gt; &#xA;&lt;h4&gt;Opting-out during automatic instrumentation&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re relying on automatic instrumentation and want to ignore specific lines from being instrumented, you can add a comment in one of the following forms on relevant lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//errtrace:skip&#xA;//errtrace:skip(explanation)&#xA;//errtrace:skip // explanation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can be especially useful if the returned error has to match another error exactly because the caller still uses &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you&#39;re implementing &lt;code&gt;io.Reader&lt;/code&gt;, you need to return &lt;code&gt;io.EOF&lt;/code&gt; when you reach the end of the input. Wrapping it will cause functions like &lt;code&gt;io.ReadAll&lt;/code&gt; to misbehave.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type myReader struct{/* ... */}&#xA;&#xA;func (*myReader) Read(bs []byte) (int, error) {&#xA;  // ...&#xA;  return 0, io.EOF //errtrace:skip(io.Reader expects io.EOF)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;errtrace is designed to have very low overhead on &lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#supported-systems&#34;&gt;supported systems&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Benchmark results for linux/amd64 on an Intel Core i5-13600 (best of 10):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;BenchmarkFmtErrorf      11574928               103.5 ns/op            40 B/op          2 allocs/op&#xA;# default build, uses Go assembly.&#xA;BenchmarkWrap           78173496                14.70 ns/op           24 B/op          0 allocs/op&#xA;# build with -tags safe to avoid assembly.&#xA;BenchmarkWrap            5958579               198.5 ns/op            24 B/op          0 allocs/op&#xA;&#xA;# benchext compares capturing stacks using pkg/errors vs errtrace&#xA;# both tests capture ~10 frames,&#xA;BenchmarkErrtrace        6388651               188.4 ns/op           280 B/op          1 allocs/op&#xA;BenchmarkPkgErrors       1673145               716.8 ns/op           304 B/op          3 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Stack traces have a large initial cost, while errtrace scales with each frame that an error is returned through.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;h3&gt;Error wrapping&lt;/h3&gt; &#xA;&lt;p&gt;errtrace operates by wrapping your errors to add caller information. As a result of this, error comparisons and type-casting may not work as expected. You can no longer use &lt;code&gt;==&lt;/code&gt; to compare errors, or type-cast them directly. You must use the standard library&#39;s &lt;a href=&#34;https://pkg.go.dev/errors#Is&#34;&gt;errors.Is&lt;/a&gt; and &lt;a href=&#34;https://pkg.go.dev/errors#As&#34;&gt;errors.As&lt;/a&gt; functions.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you have a function &lt;code&gt;readFile&lt;/code&gt; that wraps an &lt;code&gt;io.EOF&lt;/code&gt; error with errtrace:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Matching errors&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err := readFile() // returns errtrace.Wrap(io.EOF)&#xA;&#xA;// This will not work.&#xA;fmt.Println(err == io.EOF)          // false&#xA;&#xA;// Use errors.Is instead.&#xA;fmt.Println(errors.Is(err, io.EOF)) // true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, if you have a function &lt;code&gt;runCmd&lt;/code&gt; that wraps an &lt;code&gt;exec.ExitError&lt;/code&gt; error with errtrace:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Type-casting errors&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err := runCmd() // returns errtrace.Wrap(&amp;amp;exec.ExitError{...})&#xA;&#xA;// This will not work.&#xA;exitErr, ok := err.(*exec.ExitError) // ok = false&#xA;&#xA;// Use errors.As instead.&#xA;var exitErr *exec.ExitError&#xA;ok := errors.As(err, &amp;amp;exitErr)       // ok = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Linting&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://github.com/polyfloyd/go-errorlint&#34;&gt;go-errorlint&lt;/a&gt; to find places in your code where you&#39;re comparing errors with &lt;code&gt;==&lt;/code&gt; instead of using &lt;code&gt;errors.Is&lt;/code&gt; or type-casting them directly instead of using &lt;code&gt;errors.As&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Safety&lt;/h3&gt; &#xA;&lt;p&gt;To achieve the performance above on &lt;a href=&#34;https://raw.githubusercontent.com/bracesdev/errtrace/main/#supported-systems&#34;&gt;supported systems&lt;/a&gt;, errtrace makes use of unsafe operations using Go assembly to read the caller information directly from the stack. This is part of the reason why we have the disclaimer on top.&lt;/p&gt; &#xA;&lt;p&gt;errtrace includes an opt-in safe mode that drops these unsafe operations in exchange for poorer performance. To opt into safe mode, use the &lt;code&gt;safe&lt;/code&gt; build tag when compiling code that uses errtrace.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build -tags safe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Supported systems&lt;/h4&gt; &#xA;&lt;p&gt;errtrace&#39;s unsafe operations are currently implemented for &lt;code&gt;GOARCH=amd64&lt;/code&gt; and &lt;code&gt;GOARCH=arm64&lt;/code&gt; only. Other systems are supported but they will use safe mode, which is slower.&lt;/p&gt; &#xA;&lt;p&gt;Contributions to support unsafe mode for other architectures are welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome. However, we ask that before contributing new features, you &lt;a href=&#34;https://github.com/bracesdev/errtrace/issues&#34;&gt;open an issue&lt;/a&gt; to discuss the feature with us.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;The idea of tracing return paths instead of stack traces comes from &lt;a href=&#34;https://ziglang.org/documentation/0.11.0/#Error-Return-Traces&#34;&gt;Zig&#39;s error return traces&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This software is made available under the BSD3 license. See LICENSE file for details.&lt;/p&gt;</summary>
  </entry>
</feed>