<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-12T01:28:15Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zknill/sqledge</title>
    <updated>2023-08-12T01:28:15Z</updated>
    <id>tag:github.com,2023-08-12:/zknill/sqledge</id>
    <link href="https://github.com/zknill/sqledge" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Replicate postgres to SQLite on the edge&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SQLedge&lt;/h1&gt; &#xA;&lt;p&gt;[State: alpha]&lt;/p&gt; &#xA;&lt;p&gt;SQLedge uses Postgres logical replication to stream the changes in a source Postgres database to a SQLite database that can run on the edge. SQLedge serves reads from its local SQLite database, and forwards writes to the upstream Postgres server that it&#39;s replicating from.&lt;/p&gt; &#xA;&lt;p&gt;This lets you run your apps on the edge, and have local, fast, and eventually consistent access to your data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/zknill/sqledge/raw/main/etc/sqledge.png?raw=true&#34; alt=&#34;SQLedge&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;SQL generation&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;pkg/sqlgen&lt;/code&gt; package has an SQL generator in it, which will generate the SQLite insert, update, delete statements based on the logical replication messages received.&lt;/p&gt; &#xA;&lt;h2&gt;SQL parsing&lt;/h2&gt; &#xA;&lt;p&gt;When the database is started, we look at which tables already exist in the sqlite copy, and make sure new tables are created automatically on the fly.&lt;/p&gt; &#xA;&lt;h2&gt;Postgres wire proxy&lt;/h2&gt; &#xA;&lt;p&gt;SQLedge contains a Postgres wire proxy, default on &lt;code&gt;localhost:5433&lt;/code&gt;. This proxy uses the local SQlite database for reads, and forwards writes to the upstream Postgres server.&lt;/p&gt; &#xA;&lt;h3&gt;Compatibility&lt;/h3&gt; &#xA;&lt;p&gt;When running, the SQL statements interact with two databases; Postgres (for writes) and SQLite (for reads).&lt;/p&gt; &#xA;&lt;p&gt;The Postgres wire proxy (which forwards reads to SQLite) doesn&#39;t currently translate any of the SQL statements from the Postgres query format/functions to the SQLite format/functions. Read queries issued against the Postgres wire proxy need to be compatible with SQLite directly. This is fine for simple &lt;code&gt;SELECT&lt;/code&gt; queries, but you will have trouble with Postgres-specific query functions or syntax.&lt;/p&gt; &#xA;&lt;h2&gt;Copy on startup&lt;/h2&gt; &#xA;&lt;p&gt;SQLEdge maintains a table called &lt;code&gt;postgres_pos&lt;/code&gt;, this tracks the LSN (log sequence number) of the received logical replication messages so it can pick up processing where it left off.&lt;/p&gt; &#xA;&lt;p&gt;If no LSN is found, SQLedge will start a postgres &lt;code&gt;COPY&lt;/code&gt; of all tables in the &lt;code&gt;public&lt;/code&gt; schema. Creating the appropriate SQLite tables, and inserting data.&lt;/p&gt; &#xA;&lt;p&gt;When the replication slot is first created, it exports a transaction snapshot. This snapshot is used for the initial copy. This means that the &lt;code&gt;COPY&lt;/code&gt; command will read the data from the transaction at the moment the replication slot was created.&lt;/p&gt; &#xA;&lt;h2&gt;Trying it out&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a database&lt;/p&gt; &lt;pre&gt;&lt;code&gt;create database myappdatabase;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a user -- must be a super user because we create a publication on all tables&lt;/p&gt; &lt;pre&gt;&lt;code&gt;create user sqledger with login superuser password &#39;secret&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the example&lt;/p&gt; &lt;pre&gt;&lt;code&gt;SQLEDGE_UPSTREAM_USER=sqledger SQLEDGE_UPSTREAM_PASSWORD=secret SQLEDGE_UPSTREAM_NAME=myappdatabase go run ./cmd/sqledge/main.go&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Connect to the postgres wire proxy&lt;/p&gt; &lt;pre&gt;&lt;code&gt;psql -h localhost -p 5433&#xA;&#xA;$ CREATE TABLE my_table (id serial not null primary key, names text);&#xA;$ INSERT INTO my_table (names) VALUES (&#39;Jane&#39;), (&#39;John&#39;);&#xA;&#xA;$ SELECT * FROM my_table;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The read will be served from the local database&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Connect to the local sqlite db&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sqlite3 ./sqledge.db&#xA;&#xA;.schema&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Config&lt;/h2&gt; &#xA;&lt;p&gt;All config is read from environment variables. The full list is available in the struct tags on the fields in &lt;code&gt;pkg/config/config.go&lt;/code&gt;&lt;/p&gt;</summary>
  </entry>
</feed>