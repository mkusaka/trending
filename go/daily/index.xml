<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-11T01:36:05Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kelindar/column</title>
    <updated>2023-07-11T01:36:05Z</updated>
    <id>tag:github.com,2023-07-11:/kelindar/column</id>
    <link href="https://github.com/kelindar/column" rel="alternate"></link>
    <summary type="html">&lt;p&gt;High-performance, columnar, in-memory store with bitmap indexing in Go&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;330&#34; height=&#34;110&#34; src=&#34;https://raw.githubusercontent.com/kelindar/column/main/.github/logo.png&#34; border=&#34;0&#34; alt=&#34;kelindar/column&#34;&gt; &lt;br&gt; &lt;img src=&#34;https://img.shields.io/github/go-mod/go-version/kelindar/column&#34; alt=&#34;Go Version&#34;&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/kelindar/column&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/kelindar/column&#34; alt=&#34;PkgGoDev&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/kelindar/column&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/kelindar/column&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/kelindar/column&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/kelindar/column/badge.svg?sanitize=true&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Columnar In-Memory Store with Bitmap Indexing&lt;/h2&gt; &#xA;&lt;p&gt;This package contains a &lt;strong&gt;high-performance, columnar, in-memory storage engine&lt;/strong&gt; that supports fast querying, update and iteration with zero-allocations and bitmap indexing.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optimized, cache-friendly &lt;strong&gt;columnar data layout&lt;/strong&gt; that minimizes cache-misses.&lt;/li&gt; &#xA; &lt;li&gt;Optimized for &lt;strong&gt;zero heap allocation&lt;/strong&gt; during querying (see benchmarks below).&lt;/li&gt; &#xA; &lt;li&gt;Optimized &lt;strong&gt;batch updates/deletes&lt;/strong&gt;, an update during a transaction takes around &lt;code&gt;12ns&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;SIMD-enabled aggregate functions&lt;/strong&gt; such as &#34;sum&#34;, &#34;avg&#34;, &#34;min&#34; and &#34;max&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;SIMD-enabled filtering&lt;/strong&gt; (i.e. &#34;where&#34; clause) by leveraging &lt;a href=&#34;https://github.com/kelindar/bitmap&#34;&gt;bitmap indexing&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;columnar projection&lt;/strong&gt; (i.e. &#34;select&#34; clause) for fast retrieval.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;computed indexes&lt;/strong&gt; that are dynamically calculated based on provided predicate.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;concurrent updates&lt;/strong&gt; using sharded latches to keep things fast.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;transaction isolation&lt;/strong&gt;, allowing you to create transactions and commit/rollback.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;expiration&lt;/strong&gt; of rows based on time-to-live or expiration column.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;atomic merging&lt;/strong&gt; of any values, transactionally.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;primary keys&lt;/strong&gt; for use-cases where offset can&#39;t be used.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;change data stream&lt;/strong&gt; that streams all commits consistently.&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;strong&gt;concurrent snapshotting&lt;/strong&gt; allowing to store the entire collection into a file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The general idea is to leverage cache-friendly ways of organizing data in &lt;a href=&#34;https://en.wikipedia.org/wiki/AoS_and_SoA&#34;&gt;structures of arrays (SoA)&lt;/a&gt; otherwise known &#34;columnar&#34; storage in database design. This, in turn allows us to iterate and filter over columns very efficiently. On top of that, this package also adds &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitmap_index&#34;&gt;bitmap indexing&lt;/a&gt; to the columnar storage, allowing to build filter queries using binary &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;and not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;xor&lt;/code&gt; (see &lt;a href=&#34;https://github.com/kelindar/bitmap&#34;&gt;kelindar/bitmap&lt;/a&gt; with SIMD support).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#collection-and-columns&#34;&gt;Collection and Columns&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#querying-and-indexing&#34;&gt;Querying and Indexing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#iterating-over-results&#34;&gt;Iterating over Results&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#updating-values&#34;&gt;Updating Values&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#expiring-values&#34;&gt;Expiring Values&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#transaction-commit-and-rollback&#34;&gt;Transaction Commit and Rollback&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#using-primary-keys&#34;&gt;Using Primary Keys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#storing-binary-records&#34;&gt;Storing Binary Records&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#streaming-changes&#34;&gt;Streaming Changes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#snapshot-and-restore&#34;&gt;Snapshot and Restore&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#benchmarks&#34;&gt;Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Collection and Columns&lt;/h2&gt; &#xA;&lt;p&gt;In order to get data into the store, you&#39;ll need to first create a &lt;code&gt;Collection&lt;/code&gt; by calling &lt;code&gt;NewCollection()&lt;/code&gt; method. Each collection requires a schema, which needs to be specified by calling &lt;code&gt;CreateColumn()&lt;/code&gt; multiple times or automatically inferred from an object by calling &lt;code&gt;CreateColumnsOf()&lt;/code&gt; function. In the example below we create a new collection with several columns.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Create a new collection with some columns&#xA;players := column.NewCollection()&#xA;players.CreateColumn(&#34;name&#34;, column.ForString())&#xA;players.CreateColumn(&#34;class&#34;, column.ForString())&#xA;players.CreateColumn(&#34;balance&#34;, column.ForFloat64())&#xA;players.CreateColumn(&#34;age&#34;, column.ForInt16())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we have created a collection, we can insert a single record by using &lt;code&gt;Insert()&lt;/code&gt; method on the collection. In this example we&#39;re inserting a single row and manually specifying values. Note that this function returns an &lt;code&gt;index&lt;/code&gt; that indicates the row index for the inserted row.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;index, err := players.Insert(func(r column.Row) error {&#xA;&#x9;r.SetString(&#34;name&#34;, &#34;merlin&#34;)&#xA;&#x9;r.SetString(&#34;class&#34;, &#34;mage&#34;)&#xA;&#x9;r.SetFloat64(&#34;balance&#34;, 99.95)&#xA;&#x9;r.SetInt16(&#34;age&#34;, 107)&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While the previous example demonstrated how to insert a single row, inserting multiple rows this way is rather inefficient. This is due to the fact that each &lt;code&gt;Insert()&lt;/code&gt; call directly on the collection initiates a separate transacion and there&#39;s a small performance cost associated with it. If you want to do a bulk insert and insert many values, faster, that can be done by calling &lt;code&gt;Insert()&lt;/code&gt; on a transaction, as demonstrated in the example below. Note that the only difference is instantiating a transaction by calling the &lt;code&gt;Query()&lt;/code&gt; method and calling the &lt;code&gt;txn.Insert()&lt;/code&gt; method on the transaction instead the one on the collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Query(func(txn *column.Txn) error {&#xA;&#x9;for _, v := range myRawData {&#xA;&#x9;&#x9;txn.Insert(...)&#xA;&#x9;}&#xA;&#x9;return nil // Commit&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Querying and Indexing&lt;/h2&gt; &#xA;&lt;p&gt;The store allows you to query the data based on a presence of certain attributes or their values. In the example below we are querying our collection and applying a &lt;em&gt;filtering&lt;/em&gt; operation bu using &lt;code&gt;WithValue()&lt;/code&gt; method on the transaction. This method scans the values and checks whether a certain predicate evaluates to &lt;code&gt;true&lt;/code&gt;. In this case, we&#39;re scanning through all of the players and looking up their &lt;code&gt;class&lt;/code&gt;, if their class is equal to &#34;rogue&#34;, we&#39;ll take it. At the end, we&#39;re calling &lt;code&gt;Count()&lt;/code&gt; method that simply counts the result set.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// This query performs a full scan of &#34;class&#34; column&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;count := txn.WithValue(&#34;class&#34;, func(v interface{}) bool {&#xA;&#x9;&#x9;return v == &#34;rogue&#34;&#xA;&#x9;}).Count()&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, what if we&#39;ll need to do this query very often? It is possible to simply &lt;em&gt;create an index&lt;/em&gt; with the same predicate and have this computation being applied every time (a) an object is inserted into the collection and (b) an value of the dependent column is updated. Let&#39;s look at the example below, we&#39;re fist creating a &lt;code&gt;rogue&lt;/code&gt; index which depends on &#34;class&#34; column. This index applies the same predicate which only returns &lt;code&gt;true&lt;/code&gt; if a class is &#34;rogue&#34;. We then can query this by simply calling &lt;code&gt;With()&lt;/code&gt; method and providing the index name.&lt;/p&gt; &#xA;&lt;p&gt;An index is essentially akin to a boolean column, so you could technically also select it&#39;s value when querying it. Now, in this example the query would be around &lt;code&gt;10-100x&lt;/code&gt; faster to execute as behind the scenes it uses &lt;a href=&#34;https://github.com/kelindar/bitmap&#34;&gt;bitmap indexing&lt;/a&gt; for the &#34;rogue&#34; index and performs a simple logical &lt;code&gt;AND&lt;/code&gt; operation on two bitmaps when querying. This avoid the entire scanning and applying of a predicate during the &lt;code&gt;Query&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Create the index &#34;rogue&#34; in advance&#xA;out.CreateIndex(&#34;rogue&#34;, &#34;class&#34;, func(v interface{}) bool {&#xA;&#x9;return v == &#34;rogue&#34;&#xA;})&#xA;&#xA;// This returns the same result as the query before, but much faster&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;count := txn.With(&#34;rogue&#34;).Count()&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The query can be further expanded as it allows indexed &lt;code&gt;intersection&lt;/code&gt;, &lt;code&gt;difference&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; operations. This allows you to ask more complex questions of a collection. In the examples below let&#39;s assume we have a bunch of indexes on the &lt;code&gt;class&lt;/code&gt; column and we want to ask different questions.&lt;/p&gt; &#xA;&lt;p&gt;First, let&#39;s try to merge two queries by applying a &lt;code&gt;Union()&lt;/code&gt; operation with the method named the same. Here, we first select only rogues but then merge them together with mages, resulting in selection containing both rogues and mages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// How many rogues and mages?&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;txn.With(&#34;rogue&#34;).Union(&#34;mage&#34;).Count()&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, let&#39;s count everyone who isn&#39;t a rogue, for that we can use a &lt;code&gt;Without()&lt;/code&gt; method which performs a difference (i.e. binary &lt;code&gt;AND NOT&lt;/code&gt; operation) on the collection. This will result in a count of all players in the collection except the rogues.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// How many rogues and mages?&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;txn.Without(&#34;rogue&#34;).Count()&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, you can combine all of the methods and keep building more complex queries. When querying indexed and non-indexed fields together it is important to know that as every scan will apply to only the selection, speeding up the query. So if you have a filter on a specific index that selects 50% of players and then you perform a scan on that (e.g. &lt;code&gt;WithValue()&lt;/code&gt;), it will only scan 50% of users and hence will be 2x faster.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// How many rogues that are over 30 years old?&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;txn.With(&#34;rogue&#34;).WithFloat(&#34;age&#34;, func(v float64) bool {&#xA;&#x9;&#x9;return v &amp;gt;= 30&#xA;&#x9;}).Count()&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Iterating over Results&lt;/h2&gt; &#xA;&lt;p&gt;In all of the previous examples, we&#39;ve only been doing &lt;code&gt;Count()&lt;/code&gt; operation which counts the number of elements in the result set. In this section we&#39;ll look how we can iterate over the result set.&lt;/p&gt; &#xA;&lt;p&gt;As before, a transaction needs to be started using the &lt;code&gt;Query()&lt;/code&gt; method on the collection. After which, we can call the &lt;code&gt;txn.Range()&lt;/code&gt; method which allows us to iterate over the result set in the transaction. Note that it can be chained right after &lt;code&gt;With..()&lt;/code&gt; methods, as expected.&lt;/p&gt; &#xA;&lt;p&gt;In order to access the results of the iteration, prior to calling &lt;code&gt;Range()&lt;/code&gt; method, we need to &lt;strong&gt;first load column reader(s)&lt;/strong&gt; we are going to need, using methods such as &lt;code&gt;txn.String()&lt;/code&gt;, &lt;code&gt;txn.Float64()&lt;/code&gt;, etc. These prepare read/write buffers necessary to perform efficient lookups while iterating.&lt;/p&gt; &#xA;&lt;p&gt;In the example below we select all of the rogues from our collection and print out their name by using the &lt;code&gt;Range()&lt;/code&gt; method and accessing the &#34;name&#34; column using a column reader which is created by calling &lt;code&gt;txn.String(&#34;name&#34;)&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Query(func(txn *column.Txn) error {&#xA;&#x9;names := txn.String(&#34;name&#34;) // Create a column reader&#xA;&#xA;&#x9;return txn.With(&#34;rogue&#34;).Range(func(i uint32) {&#xA;&#x9;&#x9;name, _ := names.Get()&#xA;&#x9;&#x9;println(&#34;rogue name&#34;, name)&#xA;&#x9;})&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, if you need to access more columns, you can simply create the appropriate column reader(s) and use them as shown in the example before.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Query(func(txn *column.Txn) error {&#xA;&#x9;names := txn.String(&#34;name&#34;)&#xA;&#x9;ages  := txn.Int64(&#34;age&#34;)&#xA;&#xA;&#x9;return txn.With(&#34;rogue&#34;).Range(func(i uint32) {&#xA;&#x9;&#x9;name, _ := names.Get()&#xA;&#x9;&#x9;age,  _ := ages.Get()&#xA;&#xA;&#x9;&#x9;println(&#34;rogue name&#34;, name)&#xA;&#x9;&#x9;println(&#34;rogue age&#34;, age)&#xA;&#x9;})&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Taking the &lt;code&gt;Sum()&lt;/code&gt; of a (numeric) column reader will take into account a transaction&#39;s current filtering index.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Query(func(txn *column.Txn) error {&#xA;&#x9;totalAge := txn.With(&#34;rouge&#34;).Int64(&#34;age&#34;).Sum()&#xA;&#x9;totalRouges := int64(txn.Count())&#xA;&#xA;&#x9;avgAge := totalAge / totalRouges&#xA;&#xA;&#x9;txn.WithInt(&#34;age&#34;, func(v float64) bool {&#xA;&#x9;&#x9;return v &amp;lt; avgAge&#xA;&#x9;})&#xA;&#xA;&#x9;// get total balance for &#39;all rouges younger than the average rouge&#39;&#xA;&#x9;balance := txn.Float64(&#34;balance&#34;).Sum()&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sorted Indexes&lt;/h2&gt; &#xA;&lt;p&gt;Along with bitmap indexing, collections support consistently sorted indexes. These indexes are transient, and must be recreated when a collection is loading a snapshot.&lt;/p&gt; &#xA;&lt;p&gt;In the example below, we create a SortedIndex object and use it to sort filtered records in a transaction.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Create the sorted index &#34;sortedNames&#34; in advance&#xA;out.CreateSortIndex(&#34;richest&#34;, &#34;balance&#34;)&#xA;&#xA;// This filters the transaction with the `rouge` index before&#xA;// ranging through the remaining balances by ascending order&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;name    := txn.String(&#34;name&#34;)&#xA;&#x9;balance := txn.Float64(&#34;balance&#34;)&#xA;&#xA;&#x9;txn.With(&#34;rogue&#34;).Ascend(&#34;richest&#34;, func (i uint32) {&#xA;&#x9;&#x9;// save or do something with sorted record&#xA;&#x9;&#x9;curName, _ := name.Get()&#xA;&#x9;&#x9;balance.Set(newBalance(curName))&#xA;&#x9;})&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Updating Values&lt;/h2&gt; &#xA;&lt;p&gt;In order to update certain items in the collection, you can simply call &lt;code&gt;Range()&lt;/code&gt; method and use column accessor&#39;s &lt;code&gt;Set()&lt;/code&gt; or &lt;code&gt;Add()&lt;/code&gt; methods to update a value of a certain column atomically. The updates won&#39;t be instantly reflected given that our store supports transactions. Only when transaction is commited, then the update will be applied to the collection, allowing for isolation and rollbacks.&lt;/p&gt; &#xA;&lt;p&gt;In the example below we&#39;re selecting all of the rogues and updating both their balance and age to certain values. The transaction returns &lt;code&gt;nil&lt;/code&gt;, hence it will be automatically committed when &lt;code&gt;Query()&lt;/code&gt; method returns.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Query(func(txn *column.Txn) error {&#xA;&#x9;balance := txn.Float64(&#34;balance&#34;)&#xA;&#x9;age     := txn.Int64(&#34;age&#34;)&#xA;&#xA;&#x9;return txn.With(&#34;rogue&#34;).Range(func(i uint32) {&#xA;&#x9;&#x9;balance.Set(10.0) // Update the &#34;balance&#34; to 10.0&#xA;&#x9;&#x9;age.Set(50)       // Update the &#34;age&#34; to 50&#xA;&#x9;})&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In certain cases, you might want to atomically increment or decrement numerical values. In order to accomplish this you can use the provided &lt;code&gt;Merge()&lt;/code&gt; operation. Note that the indexes will also be updated accordingly and the predicates re-evaluated with the most up-to-date values. In the below example we&#39;re incrementing the balance of all our rogues by &lt;em&gt;500&lt;/em&gt; atomically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Query(func(txn *column.Txn) error {&#xA;&#x9;balance := txn.Float64(&#34;balance&#34;)&#xA;&#xA;&#x9;return txn.With(&#34;rogue&#34;).Range(func(i uint32) {&#xA;&#x9;&#x9;balance.Merge(500.0) // Increment the &#34;balance&#34; by 500&#xA;&#x9;})&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While atomic increment/decrement for numerical values is relatively straightforward, this &lt;code&gt;Merge()&lt;/code&gt; operation can be specified using &lt;code&gt;WithMerge()&lt;/code&gt; option and also used for other data types, such as strings. In the example below we are creating a merge function that concatenates two strings together and when &lt;code&gt;MergeString()&lt;/code&gt; is called, the new string gets appended automatically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A merging function that simply concatenates 2 strings together&#xA;concat := func(value, delta string) string {&#xA;&#x9;if len(value) &amp;gt; 0 {&#xA;&#x9;&#x9;value += &#34;, &#34;&#xA;&#x9;}&#xA;&#x9;return value + delta&#xA;}&#xA;&#xA;// Create a column with a specified merge function&#xA;db := column.NewCollection()&#xA;db.CreateColumn(&#34;alphabet&#34;, column.ForString(column.WithMerge(concat)))&#xA;&#xA;// Insert letter &#34;A&#34;&#xA;db.Insert(func(r column.Row) error {&#xA;&#x9;r.SetString(&#34;alphabet&#34;, &#34;A&#34;) // now contains &#34;A&#34;&#xA;&#x9;return nil&#xA;})&#xA;&#xA;// Insert letter &#34;B&#34;&#xA;db.QueryAt(0, func(r column.Row) error {&#xA;&#x9;r.MergeString(&#34;alphabet&#34;, &#34;B&#34;) // now contains &#34;A, B&#34;&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Expiring Values&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes, it is useful to automatically delete certain rows when you do not need them anymore. In order to do this, the library automatically adds an &lt;code&gt;expire&lt;/code&gt; column to each new collection and starts a cleanup goroutine aynchronously that runs periodically and cleans up the expired objects. In order to set this, you can simply use &lt;code&gt;Insert...()&lt;/code&gt; method on the collection that allows to insert an object with a time-to-live duration defined.&lt;/p&gt; &#xA;&lt;p&gt;In the example below we are inserting an object to the collection and setting the time-to-live to &lt;em&gt;5 seconds&lt;/em&gt; from the current time. After this time, the object will be automatically evicted from the collection and its space can be reclaimed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Insert(func(r column.Row) error {&#xA;&#x9;r.SetString(&#34;name&#34;, &#34;Merlin&#34;)&#xA;&#x9;r.SetString(&#34;class&#34;, &#34;mage&#34;)&#xA;&#x9;r.SetTTL(5 * time.Second) // time-to-live of 5 seconds&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On an interesting note, since &lt;code&gt;expire&lt;/code&gt; column which is automatically added to each collection is an actual normal column, you can query and even update it. In the example below we query and extend the time-to-live by 1 hour using the &lt;code&gt;Extend()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.Query(func(txn *column.Txn) error {&#xA;&#x9;ttl := txn.TTL()&#xA;&#x9;return txn.Range(func(i uint32) {&#xA;&#x9;&#x9;ttl.Extend(1 * time.Hour) // Add some time&#xA;&#x9;})&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transaction Commit and Rollback&lt;/h2&gt; &#xA;&lt;p&gt;Transactions allow for isolation between two concurrent operations. In fact, all of the batch queries must go through a transaction in this library. The &lt;code&gt;Query&lt;/code&gt; method requires a function which takes in a &lt;code&gt;column.Txn&lt;/code&gt; pointer which contains various helper methods that support querying. In the example below we&#39;re trying to iterate over all of the players and update their balance by setting it to &lt;code&gt;10.0&lt;/code&gt;. The &lt;code&gt;Query&lt;/code&gt; method automatically calls &lt;code&gt;txn.Commit()&lt;/code&gt; if the function returns without any error. On the flip side, if the provided function returns an error, the query will automatically call &lt;code&gt;txn.Rollback()&lt;/code&gt; so none of the changes will be applied.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Range over all of the players and update (successfully their balance)&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;balance := txn.Float64(&#34;balance&#34;)&#xA;&#x9;txn.Range(func(i uint32) {&#xA;&#x9;&#x9;v.Set(10.0) // Update the &#34;balance&#34; to 10.0&#xA;&#x9;})&#xA;&#xA;&#x9;// No error, transaction will be committed&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, in this example, we try to update balance but a query callback returns an error, in which case none of the updates will be actually reflected in the underlying collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Range over all of the players and update (successfully their balance)&#xA;players.Query(func(txn *column.Txn) error {&#xA;&#x9;balance := txn.Float64(&#34;balance&#34;)&#xA;&#x9;txn.Range(func(i uint32) {&#xA;&#x9;&#x9;v.Set(10.0) // Update the &#34;balance&#34; to 10.0&#xA;&#x9;})&#xA;&#xA;&#x9;// Returns an error, transaction will be rolled back&#xA;&#x9;return fmt.Errorf(&#34;bug&#34;)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using Primary Keys&lt;/h2&gt; &#xA;&lt;p&gt;In certain cases it is useful to access a specific row by its primary key instead of an index which is generated internally by the collection. For such use-cases, the library provides &lt;code&gt;Key&lt;/code&gt; column type that enables a seamless lookup by a user-defined &lt;em&gt;primary key&lt;/em&gt;. In the example below we create a collection with a primary key &lt;code&gt;name&lt;/code&gt; using &lt;code&gt;CreateColumn()&lt;/code&gt; method with a &lt;code&gt;ForKey()&lt;/code&gt; column type. Then, we use &lt;code&gt;InsertKey()&lt;/code&gt; method to insert a value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players := column.NewCollection()&#xA;players.CreateColumn(&#34;name&#34;, column.ForKey())     // Create a &#34;name&#34; as a primary-key&#xA;players.CreateColumn(&#34;class&#34;, column.ForString()) // .. and some other columns&#xA;&#xA;// Insert a player with &#34;merlin&#34; as its primary key&#xA;players.InsertKey(&#34;merlin&#34;, func(r column.Row) error {&#xA;&#x9;r.SetString(&#34;class&#34;, &#34;mage&#34;)&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, you can use primary key to query that data directly, without knowing the exact offset. Do note that using primary keys will have an overhead, as it requires an additional step of looking up the offset using a hash table managed internally.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Query merlin&#39;s class&#xA;players.QueryKey(&#34;merlin&#34;, func(r column.Row) error {&#xA;&#x9;class, _ := r.String(&#34;class&#34;)&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Storing Binary Records&lt;/h2&gt; &#xA;&lt;p&gt;If you find yourself in need of encoding a more complex structure as a single column, you may do so by using &lt;code&gt;column.ForRecord()&lt;/code&gt; function. This allows you to specify a &lt;code&gt;BinaryMarshaler&lt;/code&gt; / &lt;code&gt;BinaryUnmarshaler&lt;/code&gt; type that will get automatically encoded as a single column. In th example below we are creating a &lt;code&gt;Location&lt;/code&gt; type that implements the required methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Location struct {&#xA;&#x9;X float64 `json:&#34;x&#34;`&#xA;&#x9;Y float64 `json:&#34;y&#34;`&#xA;}&#xA;&#xA;func (l Location) MarshalBinary() ([]byte, error) {&#xA;&#x9;return json.Marshal(l)&#xA;}&#xA;&#xA;func (l *Location) UnmarshalBinary(b []byte) error {&#xA;&#x9;return json.Unmarshal(b, l)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we have a record implementation, we can create a column for this struct by using &lt;code&gt;ForRecord()&lt;/code&gt; function as shown below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;players.CreateColumn(&#34;location&#34;, ForRecord(func() *Location {&#xA;&#x9;return new(Location)&#xA;}))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to manipulate the record, we can use the appropriate &lt;code&gt;Record()&lt;/code&gt;, &lt;code&gt;SetRecord()&lt;/code&gt; methods of the &lt;code&gt;Row&lt;/code&gt;, similarly to other column types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Insert a new location&#xA;idx, _ := players.Insert(func(r Row) error {&#xA;&#x9;r.SetRecord(&#34;location&#34;, &amp;amp;Location{X: 1, Y: 2})&#xA;&#x9;return nil&#xA;})&#xA;&#xA;// Read the location back&#xA;players.QueryAt(idx, func(r Row) error {&#xA;&#x9;location, ok := r.Record(&#34;location&#34;)&#xA;&#x9;return nil&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Streaming Changes&lt;/h2&gt; &#xA;&lt;p&gt;This library also supports streaming out all transaction commits consistently, as they happen. This allows you to implement your own change data capture (CDC) listeners, stream data into kafka or into a remote database for durability. In order to enable it, you can simply provide an implementation of a &lt;code&gt;commit.Logger&lt;/code&gt; interface during the creation of the collection.&lt;/p&gt; &#xA;&lt;p&gt;In the example below we take advantage of the &lt;code&gt;commit.Channel&lt;/code&gt; implementation of a &lt;code&gt;commit.Logger&lt;/code&gt; which simply publishes the commits into a go channel. Here we create a buffered channel and keep consuming the commits with a separate goroutine, allowing us to view transactions as they happen in the store.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Create a new commit writer (simple channel) and a new collection&#xA;writer  := make(commit.Channel, 1024)&#xA;players := NewCollection(column.Options{&#xA;&#x9;Writer: writer,&#xA;})&#xA;&#xA;// Read the changes from the channel&#xA;go func(){&#xA;&#x9;for commit := range writer {&#xA;&#x9;&#x9;fmt.Printf(&#34;commit %v\n&#34;, commit.ID)&#xA;&#x9;}&#xA;}()&#xA;&#xA;// ... insert, update or delete&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On a separate note, this change stream is guaranteed to be consistent and serialized. This means that you can also replicate those changes on another database and synchronize both. In fact, this library also provides &lt;code&gt;Replay()&lt;/code&gt; method on the collection that allows to do just that. In the example below we create two collections &lt;code&gt;primary&lt;/code&gt; and &lt;code&gt;replica&lt;/code&gt; and asychronously replicating all of the commits from the &lt;code&gt;primary&lt;/code&gt; to the &lt;code&gt;replica&lt;/code&gt; using the &lt;code&gt;Replay()&lt;/code&gt; method together with the change stream.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Create a primary collection&#xA;writer  := make(commit.Channel, 1024)&#xA;primary := column.NewCollection(column.Options{&#xA;&#x9;Writer: &amp;amp;writer,&#xA;})&#xA;primary.CreateColumnsOf(object)&#xA;&#xA;// Replica with the same schema&#xA;replica := column.NewCollection()&#xA;replica.CreateColumnsOf(object)&#xA;&#xA;// Keep 2 collections in sync&#xA;go func() {&#xA;&#x9;for change := range writer {&#xA;&#x9;&#x9;replica.Replay(change)&#xA;&#x9;}&#xA;}()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Snapshot and Restore&lt;/h2&gt; &#xA;&lt;p&gt;The collection can also be saved in a single binary format while the transactions are running. This can allow you to periodically schedule backups or make sure all of the data is persisted when your application terminates.&lt;/p&gt; &#xA;&lt;p&gt;In order to take a snapshot, you must first create a valid &lt;code&gt;io.Writer&lt;/code&gt; destination and then call the &lt;code&gt;Snapshot()&lt;/code&gt; method on the collection in order to create a snapshot, as demonstrated in the example below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;dst, err := os.Create(&#34;snapshot.bin&#34;)&#xA;if err != nil {&#xA;&#x9;panic(err)&#xA;}&#xA;&#xA;// Write a snapshot into the dst&#xA;err := players.Snapshot(dst)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Conversely, in order to restore an existing snapshot, you need to first open an &lt;code&gt;io.Reader&lt;/code&gt; and then call the &lt;code&gt;Restore()&lt;/code&gt; method on the collection. Note that the collection and its schema must be already initialized, as our snapshots do not carry this information within themselves.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;src, err := os.Open(&#34;snapshot.bin&#34;)&#xA;if err != nil {&#xA;&#x9;panic(err)&#xA;}&#xA;&#xA;// Restore from an existing snapshot&#xA;err := players.Restore(src)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Multiple complete usage examples of this library can be found in the &lt;a href=&#34;https://github.com/kelindar/column/tree/main/examples&#34;&gt;examples&lt;/a&gt; directory in this repository.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;The benchmarks below were ran on a collection of &lt;strong&gt;100,000 items&lt;/strong&gt; containing a dozen columns. Feel free to explore the benchmarks but I strongly recommend testing it on your actual dataset.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cpu: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz&#xA;BenchmarkCollection/insert-8            2523     469481 ns/op    24356 B/op    500 allocs/op&#xA;BenchmarkCollection/select-at-8     22194190      54.23 ns/op        0 B/op      0 allocs/op&#xA;BenchmarkCollection/scan-8              2068     568953 ns/op      122 B/op      0 allocs/op&#xA;BenchmarkCollection/count-8           571449       2057 ns/op        0 B/op      0 allocs/op&#xA;BenchmarkCollection/range-8            28660      41695 ns/op        3 B/op      0 allocs/op&#xA;BenchmarkCollection/update-at-8      5911978      202.8 ns/op        0 B/op      0 allocs/op&#xA;BenchmarkCollection/update-all-8        1280     946272 ns/op     3726 B/op      0 allocs/op&#xA;BenchmarkCollection/delete-at-8      6405852      188.9 ns/op        0 B/op      0 allocs/op&#xA;BenchmarkCollection/delete-all-8     2073188      562.6 ns/op        0 B/op      0 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When testing for larger collections, I added a small example (see &lt;code&gt;examples&lt;/code&gt; folder) and ran it with &lt;strong&gt;20 million rows&lt;/strong&gt; inserted, each entry has &lt;strong&gt;12 columns and 4 indexes&lt;/strong&gt; that need to be calculated, and a few queries and scans around them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;running insert of 20000000 rows...&#xA;-&amp;gt; insert took 20.4538183s&#xA;&#xA;running snapshot of 20000000 rows...&#xA;-&amp;gt; snapshot took 2.57960038s&#xA;&#xA;running full scan of age &amp;gt;= 30...&#xA;-&amp;gt; result = 10200000&#xA;-&amp;gt; full scan took 61.611822ms&#xA;&#xA;running full scan of class == &#34;rogue&#34;...&#xA;-&amp;gt; result = 7160000&#xA;-&amp;gt; full scan took 81.389954ms&#xA;&#xA;running indexed query of human mages...&#xA;-&amp;gt; result = 1360000&#xA;-&amp;gt; indexed query took 608.51µs&#xA;&#xA;running indexed query of human female mages...&#xA;-&amp;gt; result = 640000&#xA;-&amp;gt; indexed query took 794.49µs&#xA;&#xA;running update of balance of everyone...&#xA;-&amp;gt; updated 20000000 rows&#xA;-&amp;gt; update took 214.182216ms&#xA;&#xA;running update of age of mages...&#xA;-&amp;gt; updated 6040000 rows&#xA;-&amp;gt; update took 81.292378ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We are open to contributions, feel free to submit a pull request and we&#39;ll review it as quickly as we can. This library is maintained by &lt;a href=&#34;https://www.linkedin.com/in/atachiants/&#34;&gt;Roman Atachiants&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Tile is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/kelindar/column/main/LICENSE.md&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bitquark/shortscan</title>
    <updated>2023-07-11T01:36:05Z</updated>
    <id>tag:github.com,2023-07-11:/bitquark/shortscan</id>
    <link href="https://github.com/bitquark/shortscan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An IIS short filename enumeration tool&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Shortscan&lt;/h1&gt; &#xA;&lt;p&gt;An IIS short filename enumeration tool.&lt;/p&gt; &#xA;&lt;h2&gt;Functionality&lt;/h2&gt; &#xA;&lt;p&gt;Shortscan is designed to quickly determine which files with short filenames exist on an IIS webserver. Once a short filename has been identified the tool will try to automatically identify the full filename.&lt;/p&gt; &#xA;&lt;p&gt;In addition to standard discovery methods Shortscan also uses a unique checksum matching approach to attempt to find the long filename where the short filename is based on Windows&#39; propriatary shortname collision avoidance checksum algorithm (more on this research at a later date).&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Quick install&lt;/h3&gt; &#xA;&lt;p&gt;Using a recent version of &lt;a href=&#34;https://golang.org/&#34;&gt;go&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install github.com/bitquark/shortscan/cmd/shortscan@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manual install&lt;/h3&gt; &#xA;&lt;p&gt;To build (and optionally install) locally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get &amp;amp;&amp;amp; go build&#xA;go install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Basic usage&lt;/h3&gt; &#xA;&lt;p&gt;Shortscan is easy to use with minimal configuration. Basic usage looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ shortscan http://example.org/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Advanced features&lt;/h3&gt; &#xA;&lt;p&gt;The following options allow further tweaks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ shortscan --help&#xA;Shortscan v0.5 · an IIS short filename enumeration tool by bitquark&#xA;Usage: main [--wordlist FILE] [--header HEADER] [--concurrency CONCURRENCY] [--timeout SECONDS] [--verbosity VERBOSITY] [--fullurl] [--stabilise] [--patience LEVEL] [--characters CHARACTERS] [--autocomplete mode] [--isvuln] URL&#xA;&#xA;Positional arguments:&#xA;  URL                    url to scan&#xA;&#xA;Options:&#xA;  --wordlist FILE, -w FILE&#xA;                         combined wordlist + rainbow table generated with shortutil&#xA;  --header HEADER, -H HEADER&#xA;                         header to send with each request (use multiple times for multiple headers)&#xA;  --concurrency CONCURRENCY, -c CONCURRENCY&#xA;                         number of requests to make at once [default: 20]&#xA;  --timeout SECONDS, -t SECONDS&#xA;                         per-request timeout in seconds [default: 10]&#xA;  --verbosity VERBOSITY, -v VERBOSITY&#xA;                         how much noise to make (0 = quiet; 1 = debug; 2 = trace) [default: 0]&#xA;  --fullurl, -F          display the full URL for confirmed files rather than just the filename [default: false]&#xA;  --stabilise, -s        attempt to get coherent autocomplete results from an unstable server (generates more requests) [default: false]&#xA;  --patience LEVEL, -p LEVEL&#xA;                         patience level when determining vulnerability (0 = patient; 1 = very patient) [default: 0]&#xA;  --characters CHARACTERS, -C CHARACTERS&#xA;                         filename characters to enumerate [default: JFKGOTMYVHSPCANDXLRWEBQUIZ8549176320-_()&amp;amp;&#39;!#$%@^{}~]&#xA;  --autocomplete mode, -a mode&#xA;                         autocomplete detection mode (auto = autoselect; method = HTTP method magic; status = HTTP status; distance = Levenshtein distance; none = disable) [default: auto]&#xA;  --isvuln, -V           bail after determining whether the service is vulnerable [default: false]&#xA;  --help, -h             display this help and exit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Utility&lt;/h2&gt; &#xA;&lt;p&gt;Shortscan comes with a utility named &lt;code&gt;shortutil&lt;/code&gt; for performing various short filename operations and to make custom rainbow tables for use with the tool.&lt;/p&gt; &#xA;&lt;p&gt;For example, to create a rainbow table from an existing wordlist use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;shortutil wordlist input.txt &amp;gt; output.rainbow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Full usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;Shortutil v0.2 // a short filename utility by bitquark&#xA;Usage: main &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]&#xA;&#xA;Options:&#xA;  --help, -h             display this help and exit&#xA;&#xA;Commands:&#xA;  wordlist               add hashes to a wordlist for use with, for example, shortscan&#xA;  checksum               generate a one-off checksum for the given filename&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Credit&lt;/h2&gt; &#xA;&lt;p&gt;Original IIS short filename &lt;a href=&#34;https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf&#34;&gt;research&lt;/a&gt; by Soroush Dalili.&lt;/p&gt; &#xA;&lt;p&gt;Additional research and this short filename scanner by &lt;a href=&#34;https://github.com/bitquark&#34;&gt;bitquark&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>