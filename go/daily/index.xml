<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-24T01:34:59Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ublue-os/fleek</title>
    <updated>2023-04-24T01:34:59Z</updated>
    <id>tag:github.com,2023-04-24:/ublue-os/fleek</id>
    <link href="https://github.com/ublue-os/fleek" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Own your $HOME&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fleek - &#34;Home as Code&#34; for Humans&lt;/h1&gt; &#xA;&lt;p&gt;Fleek is an all-in-one management system for everything you need to be productive on your computer.&lt;/p&gt; &#xA;&lt;p&gt;Status: ALPHA. Probably won&#39;t eat your computer. Probably won&#39;t break your system, at least beyond simple recoverability.&lt;/p&gt; &#xA;&lt;h2&gt;Own your $HOME&lt;/h2&gt; &#xA;&lt;h3&gt;Instant Productivity&lt;/h3&gt; &#xA;&lt;p&gt;Fleek takes you from an empty slate to a fully productive working environment in less than five minutes.&lt;/p&gt; &#xA;&lt;h3&gt;Take It With You&lt;/h3&gt; &#xA;&lt;p&gt;No matter whether you work on a shiny new M2 MacBook Air, a well-loved ThinkPad running Linux, or Windows with WSL, Fleek lets you take the exact same environment, tools, and configuration wherever you go.&lt;/p&gt; &#xA;&lt;h3&gt;Zero Learning Curve To Start&lt;/h3&gt; &#xA;&lt;p&gt;You don&#39;t need to master a fancy DSL or spelunk through pages of online manuals to get started with Fleek. Answer two questions and you&#39;re instantly off to the races. Fleek gives you opinionated starter configurations for &lt;code&gt;bash&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt; in four different levels of BLING. You can choose a standard close-to-stock experience, or dial your environment to 11 with all the latest desktop and terminal bling. And switching between them takes less than a minute when you change your mind.&lt;/p&gt; &#xA;&lt;h3&gt;Every Tool At Your Fingertips&lt;/h3&gt; &#xA;&lt;p&gt;Whether you need to install a new programming language&#39;s toolset or the latest social media application, Fleek has you covered with the largest set of programs and packages in the world. Add a line to your &lt;code&gt;.fleek.yml&lt;/code&gt; file and &lt;code&gt;fleek apply&lt;/code&gt; yourself into freedom.&lt;/p&gt; &#xA;&lt;h3&gt;Eject Button Optional&lt;/h3&gt; &#xA;&lt;p&gt;If you reach a point where you&#39;ve grown beyond Fleek&#39;s opinions and you want more, just &lt;code&gt;fleek eject&lt;/code&gt; and manage your configurations manually.&lt;/p&gt; &#xA;&lt;h2&gt;Party in the Front, Business in the Back&lt;/h2&gt; &#xA;&lt;p&gt;Fleek is a user-friendly wrapper around Nix and Nix Home Manager, but the friendly &lt;code&gt;fleek&lt;/code&gt; command hides all the complexity from you. Edit a 10 line YAML file and Fleek harnesses the power of Nix behind the scenes.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;You need &lt;code&gt;nix&lt;/code&gt;. We love the &lt;a href=&#34;https://zero-to-nix.com/&#34;&gt;Determinate Systems Installer&lt;/a&gt;, but any &lt;code&gt;nix&lt;/code&gt; is good. If you&#39;re on Fedora Silverblue &lt;a href=&#34;https://github.com/dnkmmr69420/nix-installer-scripts/raw/main/installer-scripts/silverblue-nix-installer.sh&#34;&gt;this script&lt;/a&gt; is the good stuff.&lt;/p&gt; &#xA;&lt;p&gt;After Nix is installed you need to enable &lt;a href=&#34;https://nixos.wiki/wiki/Flakes&#34;&gt;flakes and the nix command&lt;/a&gt;. It can be as simple as this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p ~/.config/nix&#xA;echo &#34;experimental-features = nix-command flakes&#34; &amp;gt;&amp;gt; ~/.config/nix/nix.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next you&#39;ll need &lt;code&gt;fleek&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nix profile install github:ublue-os/fleek/main&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, run &lt;code&gt;fleek init&lt;/code&gt;. This will create your configuration file and symlink it to &lt;code&gt;$HOME/.fleek.yml&lt;/code&gt;. Open it with your favorite editor and take a look.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ublue-os/fleek/main/fleek-init.gif&#34; alt=&#34;fleek-init.gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s what mine looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-file&#34;&gt;───────┬───────────────────────────────────────────────────&#xA;       │ File: .fleek.yml&#xA;───────┼───────────────────────────────────────────────────&#xA;   1   │ aliases:&#xA;   3   │     cdfleek: cd ~/projects/ublue/fleek&#xA;   4   │     fleeks: cd ~/.config/home-manager&#xA;   5   │     projects: cd ~/projects&#xA;   7   │ bling: high&#xA;   8   │ ejected: false&#xA;   9   │ flakedir: .config/home-manager&#xA;  10   │ name: Brians Fleek Configuration&#xA;  11   │ packages:&#xA;  12   │     - go&#xA;  13   │     - gcc&#xA;  14   │     - nodejs&#xA;  15   │     - yarn&#xA;  16   │     - rustup&#xA;  17   │     - vhs&#xA;  18   │ paths:&#xA;  19   │     - $HOME/bin&#xA;  20   │     - $HOME/.local/bin&#xA;  21   │ programs:&#xA;  22   │     - dircolors&#xA;  23   │ repo: git@github.com:bketelsen/fleeks&#xA;  24   │ shell: zsh&#xA;  25   │ systems:&#xA;  26   │     - arch: x86_64&#xA;  27   │       git:&#xA;  28   │         email: bketelsen@gmail.com&#xA;  29   │         name: Brian Ketelsen&#xA;  30   │       hostname: ghanima&#xA;  31   │       os: linux&#xA;  32   │       username: bjk&#xA;  47   │     - arch: aarch64&#xA;  48   │       git:&#xA;  49   │         email: Brian Ketelsen&#xA;  50   │         name: bketelsen@gmail.com&#xA;  51   │       hostname: chapterhouse&#xA;  52   │       os: darwin&#xA;  53   │       username: bjk&#xA;  68   │ unfree: true&#xA;───────┴──────────────────────────────────────────&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I removed some of the aliases and systems just to make the example shorter, that&#39;s why the line numbering isn&#39;t sequential.&lt;/p&gt; &#xA;&lt;p&gt;Line 7: &lt;code&gt;bling: high&lt;/code&gt; tells &lt;code&gt;fleek&lt;/code&gt; that I want lots of extras in my $HOME setup. If you don&#39;t have a strong opinion I recommend &lt;code&gt;high&lt;/code&gt;, it isn&#39;t a lot of extra stuff and the set we chose to add is really strong. Options are &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Line 11: &lt;code&gt;packages:&lt;/code&gt; starts a list of the packages I want installed. Mine are mostly focused around software development, but any package available in &lt;a href=&#34;https://search.nixos.org/packages&#34;&gt;nixpkgs&lt;/a&gt; is available.&lt;/p&gt; &#xA;&lt;p&gt;Line 18: &lt;code&gt;paths:&lt;/code&gt; starts a list of directories I want to add to my $PATH.&lt;/p&gt; &#xA;&lt;p&gt;Line 24: &lt;code&gt;shell: zsh&lt;/code&gt; tells fleek which shell I use so it can write the proper configurations.&lt;/p&gt; &#xA;&lt;p&gt;Line 25: &lt;code&gt;systems:&lt;/code&gt; These are added by &lt;code&gt;fleek&lt;/code&gt; when you run &lt;code&gt;fleek init&lt;/code&gt;, you shouldn&#39;t need to edit this part manually. Note that &lt;code&gt;fleek&lt;/code&gt; and &lt;code&gt;nix&lt;/code&gt; support macOS, Linux and more, so your configurations are fully portable.&lt;/p&gt; &#xA;&lt;p&gt;Now that you&#39;ve seen some of the possibile changes you can make, edit your &lt;code&gt;~/.fleek.yml&lt;/code&gt; file and save it.&lt;/p&gt; &#xA;&lt;p&gt;To apply your changes run &lt;code&gt;fleek apply&lt;/code&gt;. &lt;code&gt;fleek&lt;/code&gt; spins for a bit, and makes all the changes you requested. You may need to close and re-open your terminal application to see some of the changes, particularly if you add or remove fonts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ublue-os/fleek/main/fleek-add.gif&#34; alt=&#34;fleek-add.gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s the quick start! From here, you can try &lt;code&gt;fleek add&lt;/code&gt; to add packages from the CLI, &lt;code&gt;fleek search&lt;/code&gt; to search for available packages, and explore &lt;code&gt;fleek remote&lt;/code&gt; to share the same &lt;code&gt;fleek&lt;/code&gt; configurations with multiple computers.&lt;/p&gt; &#xA;&lt;h3&gt;Behind the Scenes&lt;/h3&gt; &#xA;&lt;p&gt;Fancy animated gifs and long-winded README&#39;s are great, but what really happens when you run &lt;code&gt;fleek apply&lt;/code&gt; the first time? I&#39;m glad you asked...&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;fleek&lt;/code&gt; creates a &lt;a href=&#34;https://github.com/nix-community/home-manager&#34;&gt;nix home-manager&lt;/a&gt; configuration based on the &lt;a href=&#34;https://github.com/ublue-os/fleek/raw/main/internal/flake/home.nix.tmpl&#34;&gt;templates here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fleek&lt;/code&gt; compiles the templates and writes them to disk at &lt;code&gt;~/.config/home-manager&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fleek&lt;/code&gt; calls the &lt;code&gt;nix&lt;/code&gt; command, which does &lt;code&gt;nix&lt;/code&gt; things to download and install all the packages in your &lt;code&gt;.fleek.yml&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;The libraries and binaries you specify get installed in the &lt;code&gt;/nix&lt;/code&gt; folder, and symlinked into your very own personal &lt;code&gt;nix&lt;/code&gt; profile. This is stored in your $HOME directory under &lt;code&gt;~/.nix-profile&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;home-manager&lt;/code&gt; command in the configuration assembles shell scripts and configurations for you based on the shell specified in your &lt;code&gt;.fleek.yml&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;Your existing shell configuration files get renamed with a &lt;code&gt;.bak&lt;/code&gt; extension, so you can go back to your business if &lt;code&gt;fleek&lt;/code&gt; isn&#39;t for you.&lt;/li&gt; &#xA; &lt;li&gt;New configurations are written, either &lt;code&gt;.zshrc&lt;/code&gt; or &lt;code&gt;.bashrc&lt;/code&gt;, and these configuration files add your &lt;code&gt;~/.nix-profile&lt;/code&gt; and the packages you&#39;ve installed to your $PATH&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Fleek&#39;s goal is to give you 90% of the power of a fully customized, hand-written, artisinally crafted &lt;code&gt;home-manager&lt;/code&gt; configuration -- without forcing you to learn &lt;code&gt;nix&lt;/code&gt;, which can be (ok, it IS) intimidating.&lt;/p&gt; &#xA;&lt;p&gt;You may like &lt;code&gt;fleek&lt;/code&gt; and use it on one or more of your machines to install the things you need and use every day.&lt;/p&gt; &#xA;&lt;p&gt;You might eventually be curious about how it all works. If that&#39;s the case you can always look at the nix flake that&#39;s generated for you and see what&#39;s going on behind the scenes. Cool! There&#39;s a lot you can do with &lt;code&gt;nix&lt;/code&gt; that &lt;code&gt;fleek&lt;/code&gt; doesn&#39;t even attempt.&lt;/p&gt; &#xA;&lt;p&gt;Or you might be a practical pragmatist sort of computer user and not care about what&#39;s happening behind the curtain. That&#39;s fine with &lt;code&gt;fleek&lt;/code&gt;. We&#39;re just here to help you go from zero to productive faster, more reliably, without a bunch of fuss.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;fleek&lt;/code&gt; is born out of frustration.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s annoying setting up a new computer just right. It&#39;s annoying having completely different configurations and tools each place I need to work. It&#39;s nearly impossible to configure a Mac and an Ubuntu server to have the same look &amp;amp; feel, much less the same tools.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s a huge time sink spending time configuring everything, and even worse when you try to do it in a way you can share it between computers.&lt;/p&gt; &#xA;&lt;p&gt;It wasn&#39;t until I was talking with Jorge Castro and he pointed out how complex my &lt;code&gt;home-manager&lt;/code&gt; config was compared to a simple YAML file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ublue-os/fleek/main/nixmeup.png&#34; alt=&#34;nixmeup&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Jorge is a smart dude. That night the first bits of &lt;code&gt;fleek&lt;/code&gt; were written.&lt;/p&gt; &#xA;&lt;p&gt;Within 24 hours I took the plunge and dog-fooded &lt;code&gt;fleek&lt;/code&gt; on my development laptop. That was a great moment. A day later I added &lt;code&gt;fleek remote&lt;/code&gt; commands to push my configs to GitHub, then added the code to detect your arch &amp;amp; os and change the flake accordingly.&lt;/p&gt; &#xA;&lt;p&gt;I spent the next two weeks tweaking the user experience and testing over and over. Countless virtual machines were provisioned and destroyed.&lt;/p&gt; &#xA;&lt;p&gt;| &lt;em&gt;countless&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;And now we&#39;re here. &lt;code&gt;fleek&lt;/code&gt; is ready for a broader audience than me and Jorge - who is the biggest inspriation for all the features &lt;code&gt;fleek&lt;/code&gt; has, and maybe just as importantly, doesn&#39;t have.&lt;/p&gt; &#xA;&lt;h2&gt;Shoulders&lt;/h2&gt; &#xA;&lt;p&gt;Standing on the shoulders of giants:&lt;/p&gt; &#xA;&lt;p&gt;This flake template was the thing that got everything started!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Misterio77/nix-starter-configs&#34;&gt;flake template&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Misterio77/nix-starter-configs/raw/main/LICENSE&#34;&gt;template license&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In my third rewrite, I looked at devbox and loved how they organized everything. I &lt;em&gt;borrowed&lt;/em&gt; a LOT from this. And by &lt;em&gt;borrowed&lt;/em&gt; I mean outright copy &amp;amp; pasted. Many supporting functions in this code were written by the JetPack team, and very lightly modified by me.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jetpack-io/devbox&#34;&gt;devbox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jetpack-io/devbox/raw/main/LICENSE&#34;&gt;devbox license&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Tasty release shell script inspired by and copied from ssh-to-age.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Mic92/ssh-to-age/raw/main/bin/create-release.sh&#34;&gt;ssh-to-age&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Mic92/ssh-to-age/raw/main/LICENSE&#34;&gt;ssh-to-age license&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Fleek&#39;s development flake was created by &lt;a href=&#34;https://github.com/lucperkins&#34;&gt;Luc Perkins&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Great terminal display code inspired by and copied from pcli.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pterm/pcli/&#34;&gt;pcli&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pterm/pcli/raw/main/LICENSE&#34;&gt;pcli license&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;None of this is possible without Nix and Nix Home Manager:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nixos.org/&#34;&gt;nix&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nix-community/home-manager&#34;&gt;home manager&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>optiv/ScareCrow</title>
    <updated>2023-04-24T01:34:59Z</updated>
    <id>tag:github.com,2023-04-24:/optiv/ScareCrow</id>
    <link href="https://github.com/optiv/ScareCrow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ScareCrow - Payload creation framework designed around EDR bypass.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; &lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/optiv/ScareCrow/main/Screenshots/ScareCrow.png&#34;&gt; &lt;br&gt; ScareCrow &lt;/h1&gt; &#xA;&lt;h2&gt;More Information&lt;/h2&gt; &#xA;&lt;p&gt;If you want to learn more about the techniques utilized in this framework please take a look at &lt;a href=&#34;https://www.optiv.com/explore-optiv-insights/source-zero/endpoint-detection-and-response-how-hackers-have-evolved&#34;&gt;Part 1&lt;/a&gt; and &lt;a href=&#34;https://www.optiv.com/explore-optiv-insights/source-zero/edr-and-blending-how-attackers-avoid-getting-caught&#34;&gt;Part 2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;ScareCrow is a payload creation framework for side loading (not injecting) into a legitimate Windows process (bypassing Application Whitelisting controls). Once the DLL loader is loaded into memory, it utilizes a technique to flush an EDR’s hook out of the system DLLs running in the process&#39;s memory. This works because we know the EDR’s hooks are placed when a process is spawned.&lt;/p&gt; &#xA;&lt;p&gt;ScareCrow can target these DLLs and manipulate them in memory by using the API function VirtualProtect, which changes a section of a process’ memory permissions to a different value, specifically from Execute–Read to Read-Write-Execute.&lt;/p&gt; &#xA;&lt;p&gt;ScareCrow uses 1 of 2 methods to unhook&lt;/p&gt; &#xA;&lt;h3&gt;Disk&lt;/h3&gt; &#xA;&lt;p&gt;When executed, ScareCrow will copy the bytes of the system DLLs stored on disk in &lt;code&gt;C:\Windows\System32\&lt;/code&gt;. These DLLs are stored on disk “clean” of EDR hooks because they are used by the system to load an unaltered copy into a new process when it’s spawned. Since EDR’s only hook these processes in memory, they remain unaltered. ScareCrow does not copy the entire DLL file, instead it only focuses on the .text section of the DLLs. This section of a DLL contains the executable assembly, and by doing this, ScareCrow helps reduce the likelihood of detection as re-reading entire files can cause an EDR to detect that there is a modification to a system resource. The data is then copied into the right region of memory by using each function’s offset. Each function has an offset which denotes the exact number of bytes from the base address where they reside, providing the function’s location on the stack.&lt;/p&gt; &#xA;&lt;p&gt;To do this, ScareCrow changes the permissions of the .text region of memory using VirtualProtect. Even though this is a system DLL, since it has been loaded into our process (that we control), we can change the memory permissions without requiring elevated privileges.&lt;/p&gt; &#xA;&lt;h4&gt;Indirect Syscalls&lt;/h4&gt; &#xA;&lt;p&gt;ScareCrow loads the shellcode into memory by first decrypting the shellcode, which is encrypted by one of three encryption methods (outlined below). Once decrypted and loaded, the shellcode is then executed. Depending on the loader options specified, ScareCrow will set up different export functions for the DLL. The loaded DLL also does not contain the standard DLLMain function which all DLLs typically need to operate. The DLL will still execute without any issue because the process we load into will look for those export functions and not worry about DLLMain being there.&lt;/p&gt; &#xA;&lt;h3&gt;Binary Sample&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/optiv/ScareCrow/main/Screenshots/PreRefreshed_Dlls.png&#34; border=&#34;2px solid #555&#34;&gt; &lt;/p&gt;&#xA;&lt;p&gt;After&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/optiv/ScareCrow/main/Screenshots/Refreshed_Dlls.png&#34; border=&#34;2px solid #555&#34;&gt; &lt;/p&gt;&#xA;&lt;h3&gt;KnownDLLs&lt;/h3&gt; &#xA;&lt;p&gt;KnownDLLs is a list of DLLs that are loaded by Windows during the system startup process. Because these DLLs are considered to be essential to the functioning of the operating system, they are cached to help reduce load times and improve performance when applications start up. KnownDLLs includes DLLs such as kernel32.dll, kernelbase.dll, and ntdll.dll.&lt;/p&gt; &#xA;&lt;p&gt;Utilizing these KnownDlls, ScareCrow maps a copy of the DLL from &lt;code&gt;\KnownDlls\&amp;lt;dllname&amp;gt;&lt;/code&gt; using a combination of NtOpenSection and NtMapViewOfSection to load it into the process&#39;s memory. ScareCrow doesn&#39;t load the entire DLL, rather it only loads in the .text section of the DLL (as this contains all the syscalls). From there ScareCrow use indirect Syscalls to call NtProtectVirtualMemory and change the permissions of the dll&#39;s .text memory section to allow Scarecrow to overwrite the EDR’s hooks before restoring permissions.&lt;/p&gt; &#xA;&lt;p&gt;For more information you can read modexp&#39;s detailed &lt;a href=&#34;https://raw.githubusercontent.com/optiv/ScareCrow/main/%22https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/%22&#34;&gt;article&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once these the hooks are removed, ScareCrow then utilizes custom System Calls to load and run shellcode in memory. ScareCrow does this even after the EDR hooks are removed to help avoid detection by non-userland, hook-based telemetry gathering tools such as Event Tracing for Windows (ETW) or other event logging mechanisms. These custom system calls are also used to perform the VirtualProtect call to remove the hooks placed by EDRs, described above, to avoid detection by any EDR’s anti-tamper controls. This is done by calling a custom version of the VirtualProtect syscall, NtProtectVirtualMemory. ScareCrow utilizes Golang to generate these loaders and then assembly for these custom syscall functions.&lt;/p&gt; &#xA;&lt;p&gt;During the creation process of the loader, ScareCrow utilizes a library for blending into the background after a beacon calls home. This library does two things:&lt;/p&gt; &#xA;&lt;p&gt;Files that are signed with code signing certificates are often put under less scrutiny, making it easier to be executed without being challenged, as files signed by a trusted name are often less suspicious than others. Most antimalware products don’t have the time to validate and verify these certificates (now some do but typically the common vendor names are included in a whitelist). ScareCrow creates these certificates by using a go package version of the tool &lt;code&gt;limelighter&lt;/code&gt; to create a pfx12 file. This package takes an inputted domain name, specified by the user, to create a code signing certificate for that domain. If needed, you can also use your own code signing certificate if you have one, using the valid command-line option.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ScareCrow also contains the ability to take the full chain and all attributes from a legitimate code-signing certificate from a file and copy it onto another file. This includes the signing date, counter signatures, and other measurable attributes. This option can use DLL or .exe files to copy using the &lt;code&gt;clone&lt;/code&gt; command-line option, along with the path to the file you want to copy the certificate from.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;OpSec Consideration:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;  When signing the loader with microsoft.com, using them against WINDOWS DEFENDER ATP products may not be as effective as they can validate the cert as it belongs to them. If you are using a loader against a windows product, possibly use a different domain.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Spoof the attributes of the loader: This is done by using syso files which are a form of embedded resource files that when compiled along with our loader, will modify the attribute portions of our compiled code. Prior to generating a syso file, ScareCrow will generate a random file name (based on the loader type) to use. Once chosen, this file name will map to the associated attributes for that file name, ensuring that the right values are assigned.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;File Attribute Sample&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/optiv/ScareCrow/main/Screenshots/File_Attributes.png&#34; border=&#34;2px solid #555&#34;&gt; &lt;/p&gt;&#xA;&lt;p&gt;With these files and the go code, ScareCrow will cross compile them into DLLs using the c-shared library option. Once the DLL is compiled, it is obfuscated into a broken base64 string that will be embedded into a file. This allows for the file to be remotely pulled, accessed, and programmatically executed.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Attribute Files&lt;/h3&gt; &#xA;&lt;p&gt;While ScareCrow has an extensive list of file attributes, there are some circumstances where a custom (maybe environment-specific) set of attributes is required. To accommodate this, ScareCrow allows for the inputting of a JSON file containing attributes. Using the &lt;code&gt;-configfile&lt;/code&gt; command-line option, ScareCrow will use these attributes and filename instead of the pre-existing ones in ScareCrow. The file &lt;code&gt;main.json&lt;/code&gt; contains a sample template of what the JSON structure needs to be to properly work. Note whatever you use as the &#34;InternalName&#34; will be the file name.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;ScareCrow now requires golang 1.19.1 or later to compile loaders. If you are running an older version, please use version 1.19.1 or later.&lt;/p&gt; &#xA;&lt;p&gt;See for new versions: &lt;a href=&#34;https://golang.org/dl/&#34;&gt;https://golang.org/dl/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;The first step as always is to clone the repo. Before you compile ScareCrow, you&#39;ll need to install the dependencies.&lt;/p&gt; &#xA;&lt;p&gt;To install them, run following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get github.com/fatih/color&#xA;go get github.com/yeka/zip&#xA;go get github.com/josephspurrier/goversioninfo&#xA;go get github.com/Binject/debug/pe&#xA;go get github.com/awgh/rawreader&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure that the following are installed on your OS:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;openssl&#xA;osslsigncode&#xA;mingw-w64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then build it&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go build ScareCrow.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, ScareCrow utilizes &lt;a href=&#34;https://github.com/burrowers/garble&#34;&gt;Garble&lt;/a&gt; for obfuscating all loaders.&lt;/p&gt; &#xA;&lt;p&gt;Note: Several of the dependencies do not play well on Windows when compiling, because of this it is recommended to compile your loaders on OSX or Linux.&lt;/p&gt; &#xA;&lt;h2&gt;Help&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;./ScareCrow -h&#xA;&#xA;  _________                           _________                       &#xA; /   _____/ ____ _____ _______   ____ \_   ___ \_______  ______  _  __&#xA; \_____  \_/ ___\\__  \\_  __ \_/ __ \/    \  \/\_  __ \/  _ \ \/ \/ /&#xA; /        \  \___ / __ \|  | \/\  ___/\     \____|  | \(  &amp;lt;_&amp;gt; )     / &#xA;/_______  /\___  &amp;gt;____  /__|    \___  &amp;gt;\______  /|__|   \____/ \/\_/  &#xA;        \/     \/     \/            \/        \/                      &#xA;                                                        (@Tyl0us)&#xA;        “Fear, you must understand is more than a mere obstacle. &#xA;        Fear is a TEACHER. the first one you ever had.”&#xA;&#xA;Usage of ./ScareCrow:&#xA;  -Evasion string&#xA;        Sets the type of EDR unhooking technique:&#xA;        [*] Disk - Retrives a clean version of the DLLs &#34;.text&#34; field from files stored on disk.&#xA;        [*] KnownDLL - Retrives a clean version of the DLLs &#34;.text&#34; field from the KnownDLLs directory in the object namespace.&#xA;        [*] None - The Loader that WILL NOT removing the EDR hooks in system DLLs and only use custom syscalls. (default &#34;Disk&#34;)&#xA;  -Exec string&#xA;        Set the template to execute the shellcode:&#xA;        [*] RtlCopy - Using RtlCopy to move the shellcode into the allocated address in the current running process by making a Syscall.&#xA;        [*] ProcessInjection - Process Injection Mode.&#xA;        [*] NtQueueApcThreadEx - Executes the shellcode by creating an asynchronous procedure call (APC) to a target thread.&#xA;        [*] VirtualAlloc - Allocates shellcode into the process using custom syscalls in the current running process (default &#34;RtlCopy&#34;)&#xA;  -I string&#xA;        Path to the raw 64-bit shellcode.&#xA;  -Loader string&#xA;        Sets the type of process that will sideload the malicious payload:&#xA;        [*] binary - Generates a binary based payload. (This type does not benefit from any sideloading)&#xA;        [*] control - Loads a hidden control applet - the process name would be rundll32 if -O is specified a JScript loader will be generated.&#xA;        [*] dll - Generates just a DLL file. Can be executed with commands such as rundll32 or regsvr32 with DllRegisterServer, DllGetClassObject as export functions.&#xA;        [*] excel - Loads into a hidden Excel process using a JScript loader.&#xA;        [*] msiexec - Loads into MSIexec process using a JScript loader.&#xA;        [*] wscript - Loads into WScript process using a JScript loader. (default &#34;binary&#34;)&#xA;  -O string&#xA;        Name of output file (e.g. loader.js or loader.hta). If Loader is set to dll or binary this option is not required.&#xA;  -clone string&#xA;        Path to the file containing the certificate you want to clone&#xA;  -configfile string&#xA;        The path to a json based configuration file to generate custom file attributes. This will not use the default ones.&#xA;  -console&#xA;        Only for Binary Payloads - Generates verbose console information when the payload is executed. This will disable the hidden window feature.&#xA;  -delivery string&#xA;        Generates a one-liner command to download and execute the payload remotely:&#xA;        [*] bits - Generates a Bitsadmin one liner command to download, execute and remove the loader (Compatible with Binary, Control, Excel, and Wscript Loaders).&#xA;        [*] hta - Generates a blank hta file containing the loader along with an MSHTA command to execute the loader remotely in the background (Compatible with Control and Excel Loaders). &#xA;        [*] macro - Generates an office macro that will download and execute the loader remotely (Compatible with Control, Excel, and Wscript Loaders).&#xA;  -domain string&#xA;        The domain name to use for creating a fake code signing cert. (e.g. www.acme.com) &#xA;  -encryptionmode string&#xA;        Sets the type of encryption to encrypt the shellcode:&#xA;                [*] AES - Enables AES 256 encryption.&#xA;                [*] ELZMA - Enables ELZMA encryption.&#xA;                [*] RC4 - Enables RC4 encryption. (default &#34;ELZMA&#34;)&#xA;  -export string&#xA;        For DLL Loaders Only - Specify an Export function for a loader to have.&#xA;  -injection string&#xA;        Enables Process Injection Mode and specify the path to the process to create/inject into (use \ for the path).&#xA;  -noamsi&#xA;        Disables the AMSI patching that prevents AMSI BufferScanner.&#xA;  -noetw&#xA;        Disables the ETW patching that prevents ETW events from being generated.&#xA;  -nosign&#xA;        Disables file signing, making -domain/-valid/-password parameters not required.&#xA;  -nosleep&#xA;        Disables the sleep delay before the loader unhooks and executes the shellcode.&#xA;  -obfu&#xA;        Enables Garbles Literal flag replaces golang libray strings with more complex variants, resolving to the same value at run-time. This creates a larger loader and times longer to compile&#xA;  -outpath string&#xA;        The path to put the final Payload/Loader once it&#39;s compiled.&#xA;  -password string&#xA;        The password for code signing cert. Required when -valid is used.&#xA;  -sandbox&#xA;        Enables sandbox evasion using IsDomainJoined calls.&#xA;  -url string&#xA;        URL associated with the Delivery option to retrieve the payload. (e.g. https://acme.com/)&#xA;  -valid string&#xA;        The path to a valid code signing cert. Used instead -domain if a valid code signing cert is desired.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Loader&lt;/h2&gt; &#xA;&lt;p&gt;The Loader determines the type of technique type used to load the shellcode into the target system. If no Loader option is chosen, ScareCrow will just compile a standard DLL file, that can be used by rundll32, regsvr32, or other techniques that utilize a DLL. ScareCrow utilizes three different types of loaders to load shellcode into memory:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Control Panel – This generates a control panel applet (i.e. Program and Features, or AutoPlay). By compiling the loader to have specific DLL export functions in combination with a file extension .cpl, it will spawn a control panel process (rundll32.exe) and the loader will be loaded into memory.&lt;/li&gt; &#xA; &lt;li&gt;WScript – Spawns a WScript process that utilizes a manifest file and registration-free Com techniques to load (not inject) the DLL loader into its own process, side-by-side. This avoids registering the DLL in memory as the manifest file tells the process which, where, and what version of a DLL to load.&lt;/li&gt; &#xA; &lt;li&gt;Excel – Generates an XLL file which are Excel-based DLL files that when loaded into Excel will execute the loader. A hidden Excel process will be spawned, forcing the XLL file to be loaded.&lt;/li&gt; &#xA; &lt;li&gt;Msiexec - Spawns a hidden MSIExec process that will load the DLL into memory and execute the shellcode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;ScareCrow can also generate binary based payloads if needed by using the &lt;code&gt;-Loader&lt;/code&gt; command line option. These binaries do not benefit from any side-by-side loading techniques but serve as an additional technique to execute shellcode depending on the situation.&lt;/p&gt; &#xA;&lt;h2&gt;Console&lt;/h2&gt; &#xA;&lt;p&gt;ScareCrow utilizes a technique to first create the process and then move it into the background. This does two things, first it helps keep the process hidden and second, avoids being detected by any EDR product. Spawning a process right away in the background can be very suspicious and an indicator of maliciousness. ScareCrow does this by calling the ‘GetConsoleWindow’ and ‘ShowWindow’ Windows function after the process is created and the EDR’s hooks are loaded, and then changes the windows attributes to hidden. ScareCrow utilizes these APIs rather than using the traditional &lt;code&gt;-ldflags -H=windowsgui&lt;/code&gt; as this is highly signatured and classified in most security products as an Indicator of Compromise.&lt;/p&gt; &#xA;&lt;p&gt;If the &lt;code&gt;-console&lt;/code&gt; command-line option is selected, ScareCrow will not hide the process in the background. Instead, ScareCrow will add several debug messages displaying what the loader is doing.&lt;/p&gt; &#xA;&lt;h2&gt;Execution Methods&lt;/h2&gt; &#xA;&lt;p&gt;ScareCrow uses different templates to execute shellcode. To choose which template use the &lt;code&gt;-Exec&lt;/code&gt; command-line option. These templates include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RtlCopy&lt;/li&gt; &#xA; &lt;li&gt;NtQueueApcThreadEx&lt;/li&gt; &#xA; &lt;li&gt;VirtualAlloc&lt;/li&gt; &#xA; &lt;li&gt;ProcessInjection&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Process Injection&lt;/h3&gt; &#xA;&lt;p&gt;ScareCrow contains the ability to do process injection attacks. To avoid any hooking or detection in either the loader process or the injected process itself, ScareCrow first unhooks the loader process as it would normally, to ensure there are no hooks in the process. Once completed, the loader will then spawn the process specified in the creation command. Once spawned, the loader will then create a handle to the process to retrieve a list of loaded DLLs. Once it finds DLLs, it will enumerate the base address of each DLL in the remote process. Using the function WriteProcessMemory, the loader will then write the bytes of the system DLLs stored on disk (since they are “clean” of EDR hooks) without the need to change the memory permissions first. ScareCrow uses WriteProcessMemory because this function contains a feature primarily used in debugging where even if a section of memory is read-only, if everything is correct in the call to Write¬Process¬Memory, it will temporarily change the permission to read-write, update the memory section and then restore the original permissions. Once this is done, the loader can inject shellcode into the spawned process with no issue, as there are no EDR hooks in either process.&lt;/p&gt; &#xA;&lt;p&gt;This option can be used with any of the loader options. To enable process injection, use the &lt;code&gt;-injection&lt;/code&gt; ccommand-line option along with the full path to the process you want to use to inject into. When putting the path in as an argument, it is important to either surround the full path with &lt;code&gt;&#34;&#34;&lt;/code&gt; or use double &lt;code&gt;\&lt;/code&gt; for each directory in the path.&lt;/p&gt; &#xA;&lt;h2&gt;AMSI &amp;amp; ETW Bypass&lt;/h2&gt; &#xA;&lt;p&gt;ScareCrow contains the ability to patch AMSI (Antimalware Scan Interface) and ETW functions, preventing any event from being generated by the process.&lt;/p&gt; &#xA;&lt;p&gt;AMSI is a Windows native API that allows Windows Defender (or other antimalware products) to interface deep in the Windows operating system and provide enhanced protection, specifically around in-memory-based attacks. AMSI allows security products to better detect malicious indicators and help stop threats. Since AMSI is native to Windows, products don&#39;t need to &#34;hook&#34; AMSI, rather they load the necessary DLL to gain enhanced insight into the process. Because of this, ScareCrow loads the AMSI.dll DLL and then patches, to ensure that any results from the scanning interface come back clean. Patching AMSI is default in all loaders, if you wish to not patch AMSI use the &lt;code&gt;-noamsi&lt;/code&gt; command-line option to disable it in your loader.&lt;/p&gt; &#xA;&lt;p&gt;ETW utilizes built-in Syscalls to generate this telemetry. Since ETW is also a native feature built into Windows, security products do not need to &#34;hook&#34; the ETW syscalls to gain the information. As a result, to prevent ETW, ScareCrow patches numerous ETW syscalls, flushing out the registers and returning the execution flow to the next instruction. Patching ETW is now default in all loaders, if you wish to not patch ETW, use the &lt;code&gt;-noetw&lt;/code&gt; command-line option to disable it in your loader.&lt;/p&gt; &#xA;&lt;p&gt;Currently, these options only work for the parent process, if the &lt;code&gt;-injection&lt;/code&gt; command-line option is used the primary process will patch AMSI and ETW but the injected process&lt;/p&gt; &#xA;&lt;h2&gt;Encryption&lt;/h2&gt; &#xA;&lt;p&gt;Encrypting shellcode is an important technique used to protect it from being detected and analyzed by EDRs and other security products. ScareCrow comes with multiple methods to encrypt shellcode, these include AES, ELZMA, and RC4.&lt;/p&gt; &#xA;&lt;h3&gt;AES&lt;/h3&gt; &#xA;&lt;p&gt;AES (Advanced Encryption Standard) is a symmetric encryption algorithm that is widely used to encrypt data. ScareCrow uses AES 256 bit size to encrypt the shellcode. The advantage of using AES to encrypt shellcode is that it provides strong encryption and is widely supported by cryptographic libraries. However, the use of a fixed block size can make it vulnerable to certain attacks, such as the padding oracle attack.&lt;/p&gt; &#xA;&lt;h3&gt;ELZMA&lt;/h3&gt; &#xA;&lt;p&gt;ELZMA is a compression and encryption algorithm that is often used in malware to obfuscate the code. To encrypt shellcode using ELZMA, the shellcode is first compressed using the ELZMA algorithm. The compressed data is then encrypted using a random key. The encrypted data and the key are then embedded in the exploit code. The advantage of using ELZMA to encrypt shellcode is that it provides both compression and encryption in a single algorithm. This can help to reduce the size of the exploit code and make it more difficult to detect.&lt;/p&gt; &#xA;&lt;h3&gt;RC4&lt;/h3&gt; &#xA;&lt;p&gt;RC4 is a symmetric encryption algorithm that is often used in malware to encrypt shellcode. It is a stream cipher that can use variable-length keys and is known for its simplicity and speed.&lt;/p&gt; &#xA;&lt;h2&gt;Obfuscate&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;code&gt;-obfu&lt;/code&gt; ccommand-line option enables Garbles Literal flag during the compilation process. This replaces any golang library references and strings with a more complex version, that resolves to the same value during run-time. This process takes a longer time to complete, resulting in a larger GO file. Once the file is compiled ScareCrow parses the newly created file, stripping out any GO string-based IOCs.&lt;/p&gt; &#xA;&lt;h2&gt;Delivery&lt;/h2&gt; &#xA;&lt;p&gt;The delivery command-line argument allows you to generate a command or string of code (in the macro case) to remotely pull the file from a remote source to the victim’s host. These delivery methods include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bits – This will generate a bitsadmin command that downloads the loader remotely, executes it and removes it. This delivery command is compatible with Binary, Control, Excel and Wscript loaders.&lt;/li&gt; &#xA; &lt;li&gt;HTA – This will generate a blank HTA file containing the loader. This option will also provide a command line that will execute the HTA remotely. This delivery command is compatible with Control and Excel loaders.&lt;/li&gt; &#xA; &lt;li&gt;Macro – This will generate an Office macro that can be put into an Excel or Word macro document. When this macro is executed, the loader will be downloaded from a remote source and executed, and then removed. This delivery command is compatible with Control, Excel and Wscript loaders. (Please note that this method may take longer then the default timer depending on how slow the victim&#39;s endpoints available resources)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;To Do&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Some older versions of Window&#39;s OSes (i.e. Windows 7 or Windows 8.1), have issues reloading the systems DLLs, as a result a version check is built in to ensure stability&lt;/li&gt; &#xA; &lt;li&gt;Patch ETW and AMSI in Injected processes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credit&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Special thanks to josephspurrier for his &lt;a href=&#34;https://github.com/josephspurrier/goversioninfo&#34;&gt;repo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Special thanks to mvdan for developing &lt;a href=&#34;https://github.com/burrowers/garble&#34;&gt;Garble&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Special thanks to mvdan for developing &lt;a href=&#34;https://raw.githubusercontent.com/optiv/ScareCrow/main/github.com/Binject/debug/pe&#34;&gt;Binject&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Special thanks to modexp&#39;s detailed &lt;a href=&#34;https://raw.githubusercontent.com/optiv/ScareCrow/main/%22https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/%22&#34;&gt;article&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>