<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-30T01:42:06Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>k3s-io/k3s</title>
    <updated>2022-06-30T01:42:06Z</updated>
    <id>tag:github.com,2022-06-30:/k3s-io/k3s</id>
    <link href="https://github.com/k3s-io/k3s" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight Kubernetes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;K3s - Lightweight Kubernetes&lt;/h1&gt; &#xA;&lt;p&gt;Lightweight Kubernetes. Production ready, easy to install, half the memory, all in a binary less than 100 MB.&lt;/p&gt; &#xA;&lt;p&gt;Great for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Edge&lt;/li&gt; &#xA; &lt;li&gt;IoT&lt;/li&gt; &#xA; &lt;li&gt;CI&lt;/li&gt; &#xA; &lt;li&gt;Development&lt;/li&gt; &#xA; &lt;li&gt;ARM&lt;/li&gt; &#xA; &lt;li&gt;Embedding k8s&lt;/li&gt; &#xA; &lt;li&gt;Situations where a PhD in k8s clusterology is infeasible&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What is this?&lt;/h2&gt; &#xA;&lt;p&gt;K3s is a &lt;a href=&#34;https://github.com/cncf/k8s-conformance/pulls?q=is%3Apr+k3s&#34;&gt;fully conformant&lt;/a&gt; production-ready Kubernetes distribution with the following changes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It is packaged as a single binary.&lt;/li&gt; &#xA; &lt;li&gt;It adds support for sqlite3 as the default storage backend. Etcd3, MySQL, and Postgres are also supported.&lt;/li&gt; &#xA; &lt;li&gt;It wraps Kubernetes and other components in a single, simple launcher.&lt;/li&gt; &#xA; &lt;li&gt;It is secure by default with reasonable defaults for lightweight environments.&lt;/li&gt; &#xA; &lt;li&gt;It has minimal to no OS dependencies (just a sane kernel and cgroup mounts needed).&lt;/li&gt; &#xA; &lt;li&gt;It eliminates the need to expose a port on Kubernetes worker nodes for the kubelet API by exposing this API to the Kubernetes control plane nodes over a websocket tunnel.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;K3s bundles the following technologies together into a single cohesive distribution:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://containerd.io/&#34;&gt;Containerd&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/opencontainers/runc&#34;&gt;runc&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/coreos/flannel&#34;&gt;Flannel&lt;/a&gt; for CNI&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://coredns.io/&#34;&gt;CoreDNS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/metrics-server&#34;&gt;Metrics Server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://containo.us/traefik/&#34;&gt;Traefik&lt;/a&gt; for ingress&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/k3s-io/klipper-lb&#34;&gt;Klipper-lb&lt;/a&gt; as an embedded service load balancer provider&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.kube-router.io/&#34;&gt;Kube-router&lt;/a&gt; netpol controller for network policy&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/k3s-io/helm-controller&#34;&gt;Helm-controller&lt;/a&gt; to allow for CRD-driven deployment of helm manifests&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/k3s-io/kine&#34;&gt;Kine&lt;/a&gt; as a datastore shim that allows etcd to be replaced with other databases&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rancher/local-path-provisioner&#34;&gt;Local-path-provisioner&lt;/a&gt; for provisioning volumes using local storage&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/k3s-io/k3s-root&#34;&gt;Host utilities&lt;/a&gt; such as iptables/nftables, ebtables, ethtool, &amp;amp; socat&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These technologies can be disabled or swapped out for technologies of your choice.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, K3s simplifies Kubernetes operations by maintaining functionality for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Managing the TLS certificates of Kubernetes components&lt;/li&gt; &#xA; &lt;li&gt;Managing the connection between worker and server nodes&lt;/li&gt; &#xA; &lt;li&gt;Auto-deploying Kubernetes resources from local manifests in realtime as they are changed.&lt;/li&gt; &#xA; &lt;li&gt;Managing an embedded etcd cluster (work in progress)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What&#39;s with the name?&lt;/h2&gt; &#xA;&lt;p&gt;We wanted an installation of Kubernetes that was half the size in terms of memory footprint. Kubernetes is a 10 letter word stylized as k8s. So something half as big as Kubernetes would be a 5 letter word stylized as K3s. There is neither a long-form of K3s nor official pronunciation.&lt;/p&gt; &#xA;&lt;h2&gt;Is this a fork?&lt;/h2&gt; &#xA;&lt;p&gt;No, it&#39;s a distribution. A fork implies continued divergence from the original. This is not K3s&#39;s goal or practice. K3s explicitly intends not to change any core Kubernetes functionality. We seek to remain as close to upstream Kubernetes as possible. However, we maintain a small set of patches (well under 1000 lines) important to K3s&#39;s use case and deployment model. We maintain patches for other components as well. When possible, we contribute these changes back to the upstream projects, for example, with &lt;a href=&#34;https://github.com/containerd/cri/pull/1487/commits/24209b91bf361e131478d15cfea1ab05694dc3eb&#34;&gt;SELinux support in containerd&lt;/a&gt;. This is a common practice amongst software distributions.&lt;/p&gt; &#xA;&lt;p&gt;K3s is a distribution because it packages additional components and services necessary for a fully functional cluster that go beyond vanilla Kubernetes. These are opinionated choices on technologies for components like ingress, storage class, network policy, service load balancer, and even container runtime. These choices and technologies are touched on in more detail in the &lt;a href=&#34;https://raw.githubusercontent.com/k3s-io/k3s/master/#what-is-this&#34;&gt;What is this?&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;How is this lightweight or smaller than upstream Kubernetes?&lt;/h2&gt; &#xA;&lt;p&gt;There are two major ways that K3s is lighter weight than upstream Kubernetes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The memory footprint to run it is smaller&lt;/li&gt; &#xA; &lt;li&gt;The binary, which contains all the non-containerized components needed to run a cluster, is smaller&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The memory footprint is reduced primarily by running many components inside of a single process. This eliminates significant overhead that would otherwise be duplicated for each component.&lt;/p&gt; &#xA;&lt;p&gt;The binary is smaller by removing third-party storage drivers and cloud providers, explained in more detail below.&lt;/p&gt; &#xA;&lt;h2&gt;What have you removed from upstream Kubernetes?&lt;/h2&gt; &#xA;&lt;p&gt;This is a common point of confusion because it has changed over time. Early versions of K3s had much more removed than the current version. K3s currently removes two things:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In-tree storage drivers&lt;/li&gt; &#xA; &lt;li&gt;In-tree cloud provider&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Both of these have out-of-tree alternatives in the form of &lt;a href=&#34;https://github.com/container-storage-interface/spec/raw/master/spec.md&#34;&gt;CSI&lt;/a&gt; and &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/&#34;&gt;CCM&lt;/a&gt;, which work in K3s and which upstream is moving towards.&lt;/p&gt; &#xA;&lt;p&gt;We remove these to achieve a smaller binary size. They can be removed while remaining conformant because neither affects core Kubernetes functionality. They are also dependent on third-party cloud or data center technologies/services, which may not be available in many K3s&#39; use cases.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s next?&lt;/h2&gt; &#xA;&lt;p&gt;Check out our &lt;a href=&#34;https://raw.githubusercontent.com/k3s-io/k3s/master/ROADMAP.md&#34;&gt;roadmap&lt;/a&gt; to see what we have planned moving forward.&lt;/p&gt; &#xA;&lt;h2&gt;Release cadence&lt;/h2&gt; &#xA;&lt;p&gt;K3s maintains pace with upstream Kubernetes releases. Our goal is to release patch releases on the same day as upstream and minor releases within a few days.&lt;/p&gt; &#xA;&lt;p&gt;Our release versioning reflects the version of upstream Kubernetes that is being released. For example, the K3s release &lt;a href=&#34;https://github.com/k3s-io/k3s/releases/tag/v1.18.6%2Bk3s1&#34;&gt;v1.18.6+k3s1&lt;/a&gt; maps to the &lt;code&gt;v1.18.6&lt;/code&gt; Kubernetes release. We add a postfix in the form of &lt;code&gt;+k3s&amp;lt;number&amp;gt;&lt;/code&gt; to allow us to make additional releases using the same version of upstream Kubernetes while remaining &lt;a href=&#34;https://semver.org/&#34;&gt;semver&lt;/a&gt; compliant. For example, if we discovered a high severity bug in &lt;code&gt;v1.18.6+k3s1&lt;/code&gt; and needed to release an immediate fix for it, we would release &lt;code&gt;v1.18.6+k3s2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://rancher.com/docs/k3s/latest/en/&#34;&gt;the official docs site&lt;/a&gt; for complete documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Quick-Start - Install Script&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;install.sh&lt;/code&gt; script provides a convenient way to download K3s and add a service to systemd or openrc.&lt;/p&gt; &#xA;&lt;p&gt;To install k3s as a service, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -sfL https://get.k3s.io | sh -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A kubeconfig file is written to &lt;code&gt;/etc/rancher/k3s/k3s.yaml&lt;/code&gt; and the service is automatically started or restarted. The install script will install K3s and additional utilities, such as &lt;code&gt;kubectl&lt;/code&gt;, &lt;code&gt;crictl&lt;/code&gt;, &lt;code&gt;k3s-killall.sh&lt;/code&gt;, and &lt;code&gt;k3s-uninstall.sh&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo kubectl get nodes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;K3S_TOKEN&lt;/code&gt; is created at &lt;code&gt;/var/lib/rancher/k3s/server/node-token&lt;/code&gt; on your server. To install on worker nodes, pass &lt;code&gt;K3S_URL&lt;/code&gt; along with &lt;code&gt;K3S_TOKEN&lt;/code&gt; or &lt;code&gt;K3S_CLUSTER_SECRET&lt;/code&gt; environment variables, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=XXX sh -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Manual Download&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download &lt;code&gt;k3s&lt;/code&gt; from latest &lt;a href=&#34;https://github.com/k3s-io/k3s/releases/latest&#34;&gt;release&lt;/a&gt;, x86_64, armhf, arm64 and s390x are supported.&lt;/li&gt; &#xA; &lt;li&gt;Run the server.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo k3s server &amp;amp;&#xA;# Kubeconfig is written to /etc/rancher/k3s/k3s.yaml&#xA;sudo k3s kubectl get nodes&#xA;&#xA;# On a different node run the below. NODE_TOKEN comes from&#xA;# /var/lib/rancher/k3s/server/node-token on your server&#xA;sudo k3s agent --server https://myserver:6443 --token ${NODE_TOKEN}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please check out our &lt;a href=&#34;https://raw.githubusercontent.com/k3s-io/k3s/master/CONTRIBUTING.md&#34;&gt;contributing guide&lt;/a&gt; if you&#39;re interested in contributing to K3s.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Security issues in K3s can be reported by sending an email to &lt;a href=&#34;mailto:security@k3s.io&#34;&gt;security@k3s.io&lt;/a&gt;. Please do not file issues about security issues.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bitnami-labs/sealed-secrets</title>
    <updated>2022-06-30T01:42:06Z</updated>
    <id>tag:github.com,2022-06-30:/bitnami-labs/sealed-secrets</id>
    <link href="https://github.com/bitnami-labs/sealed-secrets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Kubernetes controller and tool for one-way encrypted Secrets&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&#34;Sealed Secrets&#34; for Kubernetes&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#Installation&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/install-docs-brightgreen.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bitnami-labs/sealed-secrets/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/bitnami-labs/sealed-secrets.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://formulae.brew.sh/formula/kubeseal&#34;&gt;&lt;img src=&#34;https://img.shields.io/homebrew/v/kubeseal&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bitnami-labs/sealed-secrets/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/bitnami-labs/sealed-secrets/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bitnami-labs/sealed-secrets/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/bitnami-labs/sealed-secrets?include_prereleases&amp;amp;label=helm&amp;amp;sort=semver&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bitnami-labs/sealed-secrets/actions/workflows/helm-vib.yaml&#34;&gt;&lt;img src=&#34;https://github.com/bitnami-labs/sealed-secrets/actions/workflows/helm-vib.yaml/badge.svg?sanitize=true&#34; alt=&#34;Verification Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/bitnami-labs/sealed-secrets&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/bitnami-labs/sealed-secrets&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/downloads/bitnami-labs/sealed-secrets/total.svg?sanitize=true&#34; alt=&#34;Downloads&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Problem:&lt;/strong&gt; &#34;I can manage all my K8s config in git, except Secrets.&#34;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt; Encrypt your Secret into a SealedSecret, which &lt;em&gt;is&lt;/em&gt; safe to store - even to a public repository. The SealedSecret can be decrypted only by the controller running in the target cluster and nobody else (not even the original author) is able to obtain the original Secret from the SealedSecret.&lt;/p&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#sealedsecrets-as-templates-for-secrets&#34;&gt;SealedSecrets as templates for secrets&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#public-key--certificate&#34;&gt;Public key / Certificate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#scopes&#34;&gt;Scopes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#controller&#34;&gt;Controller&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#kustomize&#34;&gt;Kustomize&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#helm-chart&#34;&gt;Helm Chart&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#homebrew&#34;&gt;Homebrew&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#macports&#34;&gt;MacPorts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#installation-from-source&#34;&gt;Installation from source&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#upgrade&#34;&gt;Upgrade&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#managing-existing-secrets&#34;&gt;Managing existing secrets&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#update-existing-secrets&#34;&gt;Update existing secrets&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#raw-mode-experimental&#34;&gt;Raw mode (experimental)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#secret-rotation&#34;&gt;Secret Rotation&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#sealing-key-renewal&#34;&gt;Sealing key renewal&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#user-secret-rotation&#34;&gt;User secret rotation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#early-key-renewal&#34;&gt;Early key renewal&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#common-misconceptions-about-key-renewal&#34;&gt;Common misconceptions about key renewal&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#manual-key-management-advanced&#34;&gt;Manual key management (advanced)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#re-encryption-advanced&#34;&gt;Re-encryption (advanced)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#details-advanced&#34;&gt;Details (advanced)&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#crypto&#34;&gt;Crypto&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#developing&#34;&gt;Developing&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#will-you-still-be-able-to-decrypt-if-you-no-longer-have-access-to-your-cluster&#34;&gt;Will you still be able to decrypt if you no longer have access to your cluster?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#how-can-i-do-a-backup-of-my-sealedsecrets&#34;&gt;How can I do a backup of my SealedSecrets?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#can-i-decrypt-my-secrets-offline-with-a-backup-key&#34;&gt;Can I decrypt my secrets offline with a backup key?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#what-flags-are-available-for-kubeseal&#34;&gt;What flags are available for kubeseal?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#how-do-i-update-parts-of-jsonyamltoml-file-encrypted-with-sealed-secrets&#34;&gt;How do I update parts of JSON/YAML/TOML/.. file encrypted with sealed secrets?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#can-i-bring-my-own-pre-generated-certificates&#34;&gt;Can I bring my own (pre-generated) certificates?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#how-to-use-kubeseal-if-the-controller-is-not-running-within-the-kube-system-namespace&#34;&gt;How to use kubeseal if the controller is not running within the &lt;code&gt;kube-system&lt;/code&gt; namespace?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#how-to-verify-the-images&#34;&gt;How to verify the images?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#How-to-use-one-controller-for-a-subset-of-namespaces&#34;&gt;How to use one controller for a subset of namespaces&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#community&#34;&gt;Community&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#related-projects&#34;&gt;Related projects&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Sealed Secrets is composed of two parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A cluster-side controller / operator&lt;/li&gt; &#xA; &lt;li&gt;A client-side utility: &lt;code&gt;kubeseal&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;kubeseal&lt;/code&gt; utility uses asymmetric crypto to encrypt secrets that only the controller can decrypt.&lt;/p&gt; &#xA;&lt;p&gt;These encrypted secrets are encoded in a &lt;code&gt;SealedSecret&lt;/code&gt; resource, which you can see as a recipe for creating a secret. Here is how it looks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: bitnami.com/v1alpha1&#xA;kind: SealedSecret&#xA;metadata:&#xA;  name: mysecret&#xA;  namespace: mynamespace&#xA;spec:&#xA;  encryptedData:&#xA;    foo: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once unsealed this will produce a secret equivalent to this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Secret&#xA;metadata:&#xA;  name: mysecret&#xA;  namespace: mynamespace&#xA;data:&#xA;  foo: bar  # &amp;lt;- base64 encoded &#34;bar&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This normal &lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/secret/&#34;&gt;kubernetes secret&lt;/a&gt; will appear in the cluster after a few seconds you can use it as you would use any secret that you would have created directly (e.g. reference it from a &lt;code&gt;Pod&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Jump to the &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#installation&#34;&gt;Installation&lt;/a&gt; section to get up and running.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#usage&#34;&gt;Usage&lt;/a&gt; section explores in more detail how you craft &lt;code&gt;SealedSecret&lt;/code&gt; resources.&lt;/p&gt; &#xA;&lt;h3&gt;SealedSecrets as templates for secrets&lt;/h3&gt; &#xA;&lt;p&gt;The previous example only focused on the encrypted secret items themselves, but the relationship between a &lt;code&gt;SealedSecret&lt;/code&gt; custom resource and the &lt;code&gt;Secret&lt;/code&gt; it unseals into is similar in many ways (but not in all of them) to the familiar &lt;code&gt;Deployment&lt;/code&gt; vs &lt;code&gt;Pod&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In particular, the annotations and labels of a &lt;code&gt;SealedSecret&lt;/code&gt; resource are not the same as the annotations of the &lt;code&gt;Secret&lt;/code&gt; that gets generated out of it.&lt;/p&gt; &#xA;&lt;p&gt;To capture this distinction, the &lt;code&gt;SealedSecret&lt;/code&gt; object has a &lt;code&gt;template&lt;/code&gt; section which encodes all the fields you want the controller to put in the unsealed &lt;code&gt;Secret&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This includes metadata such as labels or annotations, but also things like the &lt;code&gt;type&lt;/code&gt; of the secret.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: bitnami.com/v1alpha1&#xA;kind: SealedSecret&#xA;metadata:&#xA;  name: mysecret&#xA;  namespace: mynamespace&#xA;  annotations:&#xA;    &#34;kubectl.kubernetes.io/last-applied-configuration&#34;: ....&#xA;spec:&#xA;  encryptedData:&#xA;    .dockerconfigjson: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....&#xA;  template:&#xA;    type: kubernetes.io/dockerconfigjson&#xA;    # this is an example of labels and annotations that will be added to the output secret&#xA;    metadata:&#xA;      labels:&#xA;        &#34;jenkins.io/credentials-type&#34;: usernamePassword&#xA;      annotations:&#xA;        &#34;jenkins.io/credentials-description&#34;: credentials from Kubernetes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The controller would unseal that into something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Secret&#xA;metadata:&#xA;  name: mysecret&#xA;  namespace: mynamespace&#xA;  labels:&#xA;    &#34;jenkins.io/credentials-type&#34;: usernamePassword&#xA;  annotations:&#xA;    &#34;jenkins.io/credentials-description&#34;: credentials from Kubernetes&#xA;  ownerReferences:&#xA;  - apiVersion: bitnami.com/v1alpha1&#xA;    controller: true&#xA;    kind: SealedSecret&#xA;    name: mysecret&#xA;    uid: 5caff6a0-c9ac-11e9-881e-42010aac003e&#xA;type: kubernetes.io/dockerconfigjson&#xA;data:&#xA;  .dockerconfigjson: ewogICJjcmVk...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the generated &lt;code&gt;Secret&lt;/code&gt; resource is a &#34;dependent object&#34; of the &lt;code&gt;SealedSecret&lt;/code&gt; and as such it will be updated and deleted whenever the &lt;code&gt;SealedSecret&lt;/code&gt; object gets updated or deleted.&lt;/p&gt; &#xA;&lt;h3&gt;Public key / Certificate&lt;/h3&gt; &#xA;&lt;p&gt;The key certificate (public key portion) is used for sealing secrets, and needs to be available wherever &lt;code&gt;kubeseal&lt;/code&gt; is going to be used. The certificate is not secret information, although you need to ensure you are using the correct one.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;kubeseal&lt;/code&gt; will fetch the certificate from the controller at runtime (requires secure access to the Kubernetes API server), which is convenient for interactive use, but it&#39;s known to be brittle when users have clusters with special configurations such as &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/docs/GKE.md#private-gke-clusters&#34;&gt;private GKE clusters&lt;/a&gt; that have firewalls between master and nodes.&lt;/p&gt; &#xA;&lt;p&gt;An alternative workflow is to store the certificate somewhere (e.g. local disk) with &lt;code&gt;kubeseal --fetch-cert &amp;gt;mycert.pem&lt;/code&gt;, and use it offline with &lt;code&gt;kubeseal --cert mycert.pem&lt;/code&gt;. The certificate is also printed to the controller log on startup.&lt;/p&gt; &#xA;&lt;p&gt;Since v0.9.x certificates get automatically renewed every 30 days. It&#39;s good practice that you and your team update your offline certificate periodically. To help you with that, since v0.9.2 &lt;code&gt;kubeseal&lt;/code&gt; accepts URLs too. You can set up your internal automation to publish certificates somewhere you trust.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubeseal --cert https://your.intranet.company.com/sealed-secrets/your-cluster.cert&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It also recognizes the &lt;code&gt;SEALED_SECRETS_CERT&lt;/code&gt; env var. (pro-tip: see also &lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: we are working on providing key management mechanisms that offload the encryption to HSM based modules or managed cloud crypto solutions such as KMS.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Scopes&lt;/h3&gt; &#xA;&lt;p&gt;SealedSecrets are from the POV of an end user a &#34;write only&#34; device.&lt;/p&gt; &#xA;&lt;p&gt;The idea is that the SealedSecret can be decrypted only by the controller running in the target cluster and nobody else (not even the original author) is able to obtain the original Secret from the SealedSecret.&lt;/p&gt; &#xA;&lt;p&gt;The user may or may not have direct access to the target cluster. More specifically, the user might or might not have access to the Secret unsealed by the controller.&lt;/p&gt; &#xA;&lt;p&gt;There are many ways to configure RBAC on k8s, but it&#39;s quite common to forbid low-privilege users from reading Secrets. It&#39;s also common to give users one or more namespaces where they have higher privileges, which would allow them to create and read secrets (and/or create deployments that can reference those secrets).&lt;/p&gt; &#xA;&lt;p&gt;Encrypted SealedSecret resources are designed to be safe to be looked at without gaining any knowledge about the secrets it conceals. This implies that we cannot allow users to read a SealedSecret meant for a namespace they wouldn&#39;t have access to and just push a copy of it in a namespace where they can read secrets from.&lt;/p&gt; &#xA;&lt;p&gt;Sealed-secrets thus behaves &lt;em&gt;as if&lt;/em&gt; each namespace had its own independent encryption key and thus once you seal a secret for a namespace, it cannot be moved in another namespace and decrypted there.&lt;/p&gt; &#xA;&lt;p&gt;We don&#39;t technically use an independent private key for each namespace, but instead we &lt;em&gt;include&lt;/em&gt; the namespace name during the encryption process, effectively achieving the same result.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, namespaces are not the only level at which RBAC configurations can decide who can see which secret. In fact, it&#39;s possible that users can access a secret called &lt;code&gt;foo&lt;/code&gt; in a given namespace but not any other secret in the same namespace. We cannot thus by default let users freely rename SealedSecret resources otherwise a malicious user would be able to decrypt any SealedSecret for that namespace by just renaming it to overwrite the one secret she does have access to. We use the same mechanism used to include the namespace in the encryption key to also include the secret name.&lt;/p&gt; &#xA;&lt;p&gt;That said, there are many scenarios where you might not care about this level of protection. For example, the only people who have access to your clusters are either admins or they cannot read any secret resource at all. You might have a use case for moving a sealed secret to other namespaces (e.g. you might not know the namespace name upfront), or you might not know the name of the secret (e.g. it could contain a unique suffix based on the hash of the contents etc).&lt;/p&gt; &#xA;&lt;p&gt;These are the possible scopes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;strict&lt;/code&gt; (default): the secret must be sealed with exactly the same &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;namespace&lt;/em&gt;. These attributes become &lt;em&gt;part of the encrypted data&lt;/em&gt; and thus changing name and/or namespace would lead to &#34;decryption error&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;namespace-wide&lt;/code&gt;: you can freely &lt;em&gt;rename&lt;/em&gt; the sealed secret within a given namespace.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster-wide&lt;/code&gt;: the secret can be unsealed in &lt;em&gt;any&lt;/em&gt; namespace and can be given &lt;em&gt;any&lt;/em&gt; name.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In contrast to the restrictions of &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;namespace&lt;/em&gt;, secret &lt;em&gt;items&lt;/em&gt; (i.e. JSON object keys like &lt;code&gt;spec.encryptedData.my-key&lt;/code&gt;) can be renamed at will without losing the ability to decrypt the sealed secret.&lt;/p&gt; &#xA;&lt;p&gt;The scope is selected with the &lt;code&gt;--scope&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubeseal --scope cluster-wide &amp;lt;secret.yaml &amp;gt;sealed-secret.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible to request a scope via annotations in the input secret you pass to &lt;code&gt;kubeseal&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;sealedsecrets.bitnami.com/namespace-wide: &#34;true&#34;&lt;/code&gt; -&amp;gt; for &lt;code&gt;namespace-wide&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sealedsecrets.bitnami.com/cluster-wide: &#34;true&#34;&lt;/code&gt; -&amp;gt; for &lt;code&gt;cluster-wide&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The lack of any of such annotations means &lt;code&gt;strict&lt;/code&gt; mode. If both are set, &lt;code&gt;cluster-wide&lt;/code&gt; takes precedence.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: next release will consolidate this into a single &lt;code&gt;sealedsecrets.bitnami.com/scope&lt;/code&gt; annotation.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/bitnami-labs/sealed-secrets/releases&#34;&gt;https://github.com/bitnami-labs/sealed-secrets/releases&lt;/a&gt; for the latest release and detailed installation instructions.&lt;/p&gt; &#xA;&lt;p&gt;Cloud platform specific notes and instructions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/docs/GKE.md&#34;&gt;GKE&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Controller&lt;/h3&gt; &#xA;&lt;p&gt;Once you deploy the manifest it will create the &lt;code&gt;SealedSecret&lt;/code&gt; resource and install the controller into &lt;code&gt;kube-system&lt;/code&gt; namespace, create a service account and necessary RBAC roles.&lt;/p&gt; &#xA;&lt;p&gt;After a few moments, the controller will start, generate a key pair, and be ready for operation. If it does not, check the controller logs.&lt;/p&gt; &#xA;&lt;h4&gt;Kustomize&lt;/h4&gt; &#xA;&lt;p&gt;The official controller manifest installation mechanism is just a YAML file.&lt;/p&gt; &#xA;&lt;p&gt;In some cases you might need to apply your own customizations, like set a custom namespace or set some env variables.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;kubectl&lt;/code&gt; has native support for that, see &lt;a href=&#34;https://kustomize.io/&#34;&gt;kustomize&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Helm Chart&lt;/h4&gt; &#xA;&lt;p&gt;The Sealed Secrets helm chart is now official supported and hosted in this GitHub repo.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: The versioning scheme of the helm chart differs from the versioning scheme of the sealed secrets project itself.&lt;/p&gt; &#xA;&lt;p&gt;Originally the helm chart was maintained by the community and the first version adopted a major version of 1 while the sealed secrets project itself is still at major 0. This is ok because the version of the helm chart itself is not meant to be necessarily the version of the app itself. However this is confusing, so our current versioning rule is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The sealed secret controller version scheme: 0.X.Y&lt;/li&gt; &#xA; &lt;li&gt;The helm chart version scheme: 1.X.Y-rZ&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;There can be thus multiple revisions of the helm chart, with fixes that apply only to the helm chart without affecting the static YAML manifests or the controller image itself.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: the helm chart readme still contains a deprecation notice, but it&#39;s no longer reflects reality and will be removed upon next release.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: the helm chart by default installs the controller with the name &lt;code&gt;sealed-secrets&lt;/code&gt;, while the &lt;code&gt;kubeseal&lt;/code&gt; command line interface (CLI) tries to access the controller with the name &lt;code&gt;sealed-secrets-controller&lt;/code&gt;. You can explicitly pass &lt;code&gt;--controller-name&lt;/code&gt; to the CLI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubeseal --controller-name sealed-secrets &amp;lt;args&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can override &lt;code&gt;fullnameOverride&lt;/code&gt; on the helm chart install.&lt;/p&gt; &#xA;&lt;h3&gt;Homebrew&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;kubeseal&lt;/code&gt; client is also available on &lt;a href=&#34;https://formulae.brew.sh/formula/kubeseal&#34;&gt;homebrew&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install kubeseal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MacPorts&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;kubeseal&lt;/code&gt; client is also available on &lt;a href=&#34;https://ports.macports.org/port/kubeseal/summary&#34;&gt;MacPorts&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;port install kubeseal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nixpkgs&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;kubeseal&lt;/code&gt; client is also available on &lt;a href=&#34;https://search.nixos.org/packages?channel=unstable&amp;amp;show=kubeseal&amp;amp;from=0&amp;amp;size=50&amp;amp;sort=relevance&amp;amp;type=packages&amp;amp;query=kubeseal&#34;&gt;Nixpkgs&lt;/a&gt;: (&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: Not maintained by bitnami-labs)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix-env -iA nixpkgs.kubeseal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation from source&lt;/h3&gt; &#xA;&lt;p&gt;If you just want the latest client tool, it can be installed into &lt;code&gt;$GOPATH/bin&lt;/code&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(cd /; GO111MODULE=on go get github.com/bitnami-labs/sealed-secrets/cmd/kubeseal@main)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify a release tag or a commit SHA instead of &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrade&lt;/h2&gt; &#xA;&lt;p&gt;Don&#39;t forget to check the &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/RELEASE-NOTES.md&#34;&gt;release notes&lt;/a&gt; for guidance about possible breaking changes when you upgrade the client tool and/or the controller.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Create a json/yaml-encoded Secret somehow:&#xA;# (note use of `--dry-run` - this is just a local file!)&#xA;echo -n bar | kubectl create secret generic mysecret --dry-run=client --from-file=foo=/dev/stdin -o json &amp;gt;mysecret.json&#xA;&#xA;# This is the important bit:&#xA;# (note default format is json!)&#xA;kubeseal &amp;lt;mysecret.json &amp;gt;mysealedsecret.json&#xA;&#xA;# mysealedsecret.json is safe to upload to github, post to twitter,&#xA;# etc.  Eventually:&#xA;kubectl create -f mysealedsecret.json&#xA;&#xA;# Profit!&#xA;kubectl get secret mysecret&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the &lt;code&gt;SealedSecret&lt;/code&gt; and &lt;code&gt;Secret&lt;/code&gt; must have &lt;strong&gt;the same namespace and name&lt;/strong&gt;. This is a feature to prevent other users on the same cluster from re-using your sealed secrets. See the &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#scopes&#34;&gt;Scopes&lt;/a&gt; section for more info.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;kubeseal&lt;/code&gt; reads the namespace from the input secret, accepts an explicit &lt;code&gt;--namespace&lt;/code&gt; arg, and uses the &lt;code&gt;kubectl&lt;/code&gt; default namespace (in that order). Any labels, annotations, etc on the original &lt;code&gt;Secret&lt;/code&gt; are preserved, but not automatically reflected in the &lt;code&gt;SealedSecret&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By design, this scheme &lt;em&gt;does not authenticate the user&lt;/em&gt;. In other words, &lt;em&gt;anyone&lt;/em&gt; can create a &lt;code&gt;SealedSecret&lt;/code&gt; containing any &lt;code&gt;Secret&lt;/code&gt; they like (provided the namespace/name matches). It is up to your existing config management workflow, cluster RBAC rules, etc to ensure that only the intended &lt;code&gt;SealedSecret&lt;/code&gt; is uploaded to the cluster. The only change from existing Kubernetes is that the &lt;em&gt;contents&lt;/em&gt; of the &lt;code&gt;Secret&lt;/code&gt; are now hidden while outside the cluster.&lt;/p&gt; &#xA;&lt;h3&gt;Managing existing secrets&lt;/h3&gt; &#xA;&lt;p&gt;If you want &lt;code&gt;SealedSecret&lt;/code&gt; controller to take management of an existing &lt;code&gt;Secret&lt;/code&gt; (i.e. overwrite it when unsealing a &lt;code&gt;SealedSecret&lt;/code&gt; with the same name and namespace), then you have to annotate that &lt;code&gt;Secret&lt;/code&gt; with the annotation &lt;code&gt;sealedsecrets.bitnami.com/managed: &#34;true&#34;&lt;/code&gt; ahead applying the &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#usage&#34;&gt;Usage&lt;/a&gt; steps.&lt;/p&gt; &#xA;&lt;h3&gt;Update existing secrets&lt;/h3&gt; &#xA;&lt;p&gt;If you want to add or update existing sealed secrets without having the cleartext for the other items, you can just copy&amp;amp;paste the new encrypted data items and merge it into an existing sealed secret.&lt;/p&gt; &#xA;&lt;p&gt;You must take care of sealing the updated items with a compatible name and namespace (see note about scopes above).&lt;/p&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;--merge-into&lt;/code&gt; command to update an existing sealed secrets if you don&#39;t want to copy&amp;amp;paste:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo -n bar | kubectl create secret generic mysecret --dry-run=client --from-file=foo=/dev/stdin -o json \&#xA;  | kubeseal &amp;gt; mysealedsecret.json&#xA;echo -n baz | kubectl create secret generic mysecret --dry-run=client --from-file=bar=/dev/stdin -o json \&#xA;  | kubeseal --merge-into mysealedsecret.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Raw mode (experimental)&lt;/h3&gt; &#xA;&lt;p&gt;Creating temporary Secret with the &lt;code&gt;kubectl&lt;/code&gt; command, only to throw it away once piped to &lt;code&gt;kubeseal&lt;/code&gt; can be a quite unfriendly user experience. We&#39;re working on an overhaul of the CLI experience. In the meantime, we offer an alternative mode where kubeseal only cares about encrypting a value to stdout, and it&#39;s your responsibility to put it inside a &lt;code&gt;SealedSecret&lt;/code&gt; resource (not unlike any of the other k8s resources).&lt;/p&gt; &#xA;&lt;p&gt;It can also be useful as a building block for editor/IDE integrations.&lt;/p&gt; &#xA;&lt;p&gt;The downside is that you have to be careful to be consistent with the sealing scope, the namespace and the name.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#scopes&#34;&gt;Scopes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;strict&lt;/code&gt; scope (default):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ echo -n foo | kubeseal --raw --from-file=/dev/stdin --namespace bar --name mysecret&#xA;AgBChHUWLMx...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;namespace-wide&lt;/code&gt; scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ echo -n foo | kubeseal --raw --from-file=/dev/stdin --namespace bar --scope namespace-wide&#xA;AgAbbFNkM54...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Include the &lt;code&gt;sealedsecrets.bitnami.com/namespace-wide&lt;/code&gt; annotation in the &lt;code&gt;SealedSecret&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;metadata:&#xA;  annotations:&#xA;    sealedsecrets.bitnami.com/namespace-wide: &#34;true&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;cluster-wide&lt;/code&gt; scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ echo -n foo | kubeseal --raw --from-file=/dev/stdin --scope cluster-wide&#xA;AgAjLKpIYV+...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Include the &lt;code&gt;sealedsecrets.bitnami.com/cluster-wide&lt;/code&gt; annotation in the &lt;code&gt;SealedSecret&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;metadata:&#xA;  annotations:&#xA;    sealedsecrets.bitnami.com/cluster-wide: &#34;true&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Secret Rotation&lt;/h2&gt; &#xA;&lt;p&gt;You should always rotate your secrets. But since your secrets are encrypted with another secret, you need to understand how these two layers relate in order to take the right decisions.&lt;/p&gt; &#xA;&lt;p&gt;TL;DR:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If a &lt;em&gt;sealing&lt;/em&gt; private key is compromised, you need to follow the instructions below in &#34;Early key renewal&#34; section before rotating any of your actual secret values.&lt;/p&gt; &#xA; &lt;p&gt;SealedSecret key renewal and re-encryption features are &lt;strong&gt;not a substitute&lt;/strong&gt; for periodical rotation of your actual secret values.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Sealing key renewal&lt;/h3&gt; &#xA;&lt;p&gt;Sealing keys are automatically renewed every 30 days. Which means a new sealing key is created and appended to the set of active sealing keys the controller can use to unseal Sealed Secret resources.&lt;/p&gt; &#xA;&lt;p&gt;The most recently created sealing key is the one used to seal new secrets when you use &lt;code&gt;kubeseal&lt;/code&gt; and it&#39;s the one whose certificate is downloaded when you use &lt;code&gt;kubeseal --fetch-cert&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The renewal time of 30d is a reasonable default, but it can be tweaked as needed with the &lt;code&gt;--key-renew-period=&amp;lt;value&amp;gt;&lt;/code&gt; flag for the command in the pod template of the sealed secret controller. The &lt;code&gt;value&lt;/code&gt; field can be given as golang duration flag (eg: &lt;code&gt;720h30m&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;A value of &lt;code&gt;0&lt;/code&gt; will disable automatic key renewal. Of course, it&#39;s possible you have a valid use case for disabling automatic sealing key renewal; but experience has shown that new users often tend to jump to conclusions that they want control over key renewal, before fully understanding how sealed secrets work. Read more about this in the &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/#common-misconceptions-about-key-renewal&#34;&gt;common misconceptions&lt;/a&gt; section below.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Unfortunately you cannot use e.g. &#34;d&#34; as a unit for days because that&#39;s not supported by the Go stdlib. Instead of hitting your face with a palm, take this as an opportunity to meditate on the &lt;a href=&#34;https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time&#34;&gt;falsehoods programmers believe about time&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;A common misunderstanding is that key renewal is often thought of as a form of key rotation, where the old key is not only obsolete but actually bad and that you thus want to get rid of it. It doesn&#39;t help that this feature has been historically called &#34;key rotation&#34;, which can add to the confusion.&lt;/p&gt; &#xA;&lt;p&gt;Sealed secrets are not automatically rotated and old keys are not deleted when new keys are generated. Old sealed secrets resources can be still decrypted (that&#39;s because old sealing keys are not deleted).&lt;/p&gt; &#xA;&lt;h3&gt;User secret rotation&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;em&gt;sealing key&lt;/em&gt; renewal and SealedSecret rotation are &lt;strong&gt;not a substitute&lt;/strong&gt; for rotating your actual secrets.&lt;/p&gt; &#xA;&lt;p&gt;A core value proposition of this tool is:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Encrypt your Secret into a SealedSecret, which &lt;em&gt;is&lt;/em&gt; safe to store - even to a public repository.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you store anything in a version control storage, and in a public one in particular, you must assume you cannot ever delete that information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;If&lt;/em&gt; a sealing key somehow leaks out of the cluster you must consider all your SealedSecret resources encrypted with that key as compromised. No amount of sealing key rotation in the cluster or even re-encryption of existing SealedSecrets files can change that.&lt;/p&gt; &#xA;&lt;p&gt;The best practice is to periodically rotate all your actual secrets (e.g. change the password) &lt;strong&gt;and&lt;/strong&gt; craft new SealedSecret resource with those new secrets.&lt;/p&gt; &#xA;&lt;p&gt;But if the sealed secrets controller were not renewing the &lt;em&gt;sealing key&lt;/em&gt; that rotation would be moot, since the attacker could just decrypt the new secrets as well. Thus, you need to do both: periodically renew the sealing key and rotate your actual secrets!&lt;/p&gt; &#xA;&lt;h3&gt;Early key renewal&lt;/h3&gt; &#xA;&lt;p&gt;If you know or suspect a &lt;em&gt;sealing key&lt;/em&gt; has been compromised you should renew the key ASAP before you start sealing your new rotated secrets, otherwise you&#39;ll be giving attackers access to your new secrets as well.&lt;/p&gt; &#xA;&lt;p&gt;A key can be generated early by passing the current timestamp to the controller into a flag called &lt;code&gt;--key-cutoff-time&lt;/code&gt; or an env var called &lt;code&gt;SEALED_SECRETS_KEY_CUTOFF_TIME&lt;/code&gt;. Expected format is RFC1123, you can generate it with the &lt;code&gt;date -R&lt;/code&gt; unix command.&lt;/p&gt; &#xA;&lt;h3&gt;Common misconceptions about key renewal&lt;/h3&gt; &#xA;&lt;p&gt;Sealed secrets sealing keys are not access control keys (e.g. like a password); they are more like the GPG key you might use to read encrypted mail sent to you. Let&#39;s continue with the email analogy for a bit:&lt;/p&gt; &#xA;&lt;p&gt;Imagine you have reasons to believe your private GPG key might have been compromised. You&#39;d have more to lose than to gain if the first thing you do is to just delete your private key. All the previous emails sent with that key are no longer accessible to you (unless you have a decrypted copy of those emails), nor are new emails sent by your friends whom you have not yet managed to tell to use the new key.&lt;/p&gt; &#xA;&lt;p&gt;Sure, the content of those encrypted emails is not secure, as an attacker might now be able to decrypt them, but what&#39;s done is done. Your sudden loss of ability to read those emails surely doesn&#39;t undo the damage; if anything, it&#39;s worse because you no longer know for sure what secret the attacker got to know. What you really want to do is to make sure that your friend stops using your old key and that from now on all further communication is encrypted with a new key pair (i.e. your friend must know about that new key).&lt;/p&gt; &#xA;&lt;p&gt;The same logic applies to SealedSecrets. The ultimate goal is securing your actual &#34;user&#34; secrets. The &#34;sealing&#34; secrets are just a mechanism, an &#34;envelope&#34;. If a secret is leaked there is no going back; what&#39;s done is done.&lt;/p&gt; &#xA;&lt;p&gt;You first need to ensure that new secrets don&#39;t get encrypted with that old compromised key (in the email analogy above that&#39;s: create a new key pair and give all your friends your new public key).&lt;/p&gt; &#xA;&lt;p&gt;The second logical step is to neutralize the damage, which depends on the nature of the secret. A simple example is a database password: if you accidentally leak your database password, the thing you&#39;re supposed to do is simply to change your database password (on the database; and revoke the old one!) &lt;em&gt;and&lt;/em&gt; update the SealedSecret resource with the new password (i.e. running &lt;code&gt;kubeseal&lt;/code&gt; again).&lt;/p&gt; &#xA;&lt;p&gt;Both steps are described in the previous sections, albeit in a less verbose way. There is no shame in reading them again, now that you have a more in-depth grasp of the underlying rationale.&lt;/p&gt; &#xA;&lt;h3&gt;Manual key management (advanced)&lt;/h3&gt; &#xA;&lt;p&gt;The sealed secrets controller and the associated workflow is designed to keep old sealing keys around and periodically add new ones. You should not delete old keys unless you know what you&#39;re doing.&lt;/p&gt; &#xA;&lt;p&gt;That said, if you want you can manually manage (create, move, delete) &lt;em&gt;sealing keys&lt;/em&gt;. They are just normal k8s secrets living in the same namespace where the sealed secret controller lives (usually &lt;code&gt;kube-system&lt;/code&gt;, but it&#39;s configurable).&lt;/p&gt; &#xA;&lt;p&gt;There are advanced use cases that you can address by creative management of the sealing keys. For example, you can share the same sealing key among a few clusters so that you can apply exactly the same sealed secret in multiple clusters. Since sealing keys are just normal k8s secrets you can even use sealed secrets itself and use a GitOps workflow to manage your sealing keys (useful when you want to share the same key among different clusters)!&lt;/p&gt; &#xA;&lt;p&gt;Labelling a &lt;em&gt;sealing key&lt;/em&gt; secret with anything other than &lt;code&gt;active&lt;/code&gt; effectively deletes the key from the sealed secrets controller, but it is still available in k8s for manual encryption/decryption if need be.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; Sealed secrets currently does not automatically pick up manually created, deleted or relabeled sealing keys, an admin must restart the controller before the effect will apply.&lt;/p&gt; &#xA;&lt;h3&gt;Re-encryption (advanced)&lt;/h3&gt; &#xA;&lt;p&gt;Before you can get rid of some old sealing keys you need to re-encrypt your SealedSecrets with the latest private key.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubeseal --re-encrypt &amp;lt;my_sealed_secret.json &amp;gt;tmp.json \&#xA;  &amp;amp;&amp;amp; mv tmp.json my_sealed_secret.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The invocation above will produce a new sealed secret file freshly encrypted with the latest key, without making the secrets leave the cluster to the client. You can then save that file in your version control system (&lt;code&gt;kubeseal --re-encrypt&lt;/code&gt; doesn&#39;t update the in-cluster object).&lt;/p&gt; &#xA;&lt;p&gt;Currently, old keys are not garbage collected automatically.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s a good idea to periodically re-encrypt your SealedSecrets. But as mentioned above, don&#39;t lull yourself in a false sense of security: you must assume the old version of the SealedSecret (the one encrypted with a key you think of as dead) is still potentially around and accessible to attackers. I.e. re-encryption is not a substitute for periodically rotating your actual secrets.&lt;/p&gt; &#xA;&lt;h2&gt;Details (advanced)&lt;/h2&gt; &#xA;&lt;p&gt;This controller adds a new &lt;code&gt;SealedSecret&lt;/code&gt; custom resource. The interesting part of a &lt;code&gt;SealedSecret&lt;/code&gt; is a base64-encoded asymmetrically encrypted &lt;code&gt;Secret&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The controller maintains a set of private/public key pairs as kubernetes secrets. Keys are labelled with &lt;code&gt;sealedsecrets.bitnami.com/sealed-secrets-key&lt;/code&gt; and identified in the label as either &lt;code&gt;active&lt;/code&gt; or &lt;code&gt;compromised&lt;/code&gt;. On startup, The sealed secrets controller will...&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Search for these keys and add them to its local store if they are labelled as active.&lt;/li&gt; &#xA; &lt;li&gt;Create a new key&lt;/li&gt; &#xA; &lt;li&gt;Start the key rotation cycle&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Crypto&lt;/h3&gt; &#xA;&lt;p&gt;More details about crypto can be found &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/docs/developer/crypto.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Developing&lt;/h2&gt; &#xA;&lt;p&gt;More details about crypto can be found &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/docs/developer/README.md&#34;&gt;in the Developer Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Will you still be able to decrypt if you no longer have access to your cluster?&lt;/h3&gt; &#xA;&lt;p&gt;No, the private keys are only stored in the Secret managed by the controller (unless you have some other backup of your k8s objects). There are no backdoors - without that private key used to encrypt a given SealedSecrets, you can&#39;t decrypt it. If you can&#39;t get to the Secrets with the encryption keys, and you also can&#39;t get to the decrypted versions of your Secrets live in the cluster, then you will need to regenerate new passwords for everything, seal them again with a new sealing key, etc.&lt;/p&gt; &#xA;&lt;h3&gt;How can I do a backup of my SealedSecrets?&lt;/h3&gt; &#xA;&lt;p&gt;If you do want to make a backup of the encryption private keys, it&#39;s easy to do from an account with suitable access and:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml &amp;gt;master.key&#xA;kubectl get secret -n kube-system sealed-secrets-key -o yaml &amp;gt;&amp;gt;master.key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: you need the second statement only if you ever installed sealed-secrets older than version 0.9.x on your cluster.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: This file will contain the controller&#39;s public + private keys and should be kept omg-safe!&lt;/p&gt; &#xA;&lt;p&gt;To restore from a backup after some disaster, just put that secrets back before starting the controller - or if the controller was already started, replace the newly-created secrets and restart the controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f master.key&#xA;kubectl delete pod -n kube-system -l name=sealed-secrets-controller&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Can I decrypt my secrets offline with a backup key?&lt;/h3&gt; &#xA;&lt;p&gt;While treating sealed-secrets as long term storage system for secrets is not the recommended use case, some people do have a legitimate requirement for being able to recover secrets when the k8s cluster is down and restoring a backup into a new sealed-secrets controller deployment is not practical.&lt;/p&gt; &#xA;&lt;p&gt;If you have backed up one or more of your private keys (see previous question), you can use the &lt;code&gt;kubeseal --recovery-unseal --recovery-private-key file1.key,file2.key,...&lt;/code&gt; command to decrypt a sealed secrets file.&lt;/p&gt; &#xA;&lt;h3&gt;What flags are available for kubeseal?&lt;/h3&gt; &#xA;&lt;p&gt;You can check the flags available using &lt;code&gt;kubeseal --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How do I update parts of JSON/YAML/TOML/.. file encrypted with sealed secrets?&lt;/h3&gt; &#xA;&lt;p&gt;A kubernetes secret resource contains multiple items, basically a flat map of key/value pairs. SealedSecrets operate at that level, and does not care what you put in the values. In other words it cannot make sense of any structured configuration file you might have put in a secret and thus cannot help you update individual fields in it.&lt;/p&gt; &#xA;&lt;p&gt;Since this is a common problem, especially when dealing with legacy applications, we do offer an &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/docs/examples/config-template&#34;&gt;example&lt;/a&gt; of a possible workaround.&lt;/p&gt; &#xA;&lt;h3&gt;Can I bring my own (pre-generated) certificates?&lt;/h3&gt; &#xA;&lt;p&gt;Yes, you can provide the controller with your own certificates, and it will consume them. Please check &lt;a href=&#34;https://raw.githubusercontent.com/bitnami-labs/sealed-secrets/main/docs/bring-your-own-certificates.md&#34;&gt;here&lt;/a&gt; for a workaround.&lt;/p&gt; &#xA;&lt;h3&gt;How to use kubeseal if the controller is not running within the &lt;code&gt;kube-system&lt;/code&gt; namespace?&lt;/h3&gt; &#xA;&lt;p&gt;If you installed the controller in a different namespace than the default &lt;code&gt;kube-system&lt;/code&gt;, you need to provide this namespace to the &lt;code&gt;kubeseal&lt;/code&gt; commandline tool. There are two options: You can specify the namespace via the command line option &lt;code&gt;--controller-namespace &amp;lt;namespace&amp;gt;&lt;/code&gt; or via the environment variable &lt;code&gt;SEALED_SECRETS_CONTROLLER_NAMESPACE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Provide the namespace via the command line option&#xA;kubeseal --controller-namespace sealed-secrets &amp;lt;mysecret.json &amp;gt;mysealedsecret.json&#xA;&#xA;# Provide the namespace via the environment variable&#xA;export SEALED_SECRETS_CONTROLLER_NAMESPACE=sealed-secrets&#xA;kubeseal &amp;lt;mysecret.json &amp;gt;mysealedsecret.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to verify the images?&lt;/h3&gt; &#xA;&lt;p&gt;Our images are being signed using &lt;a href=&#34;https://github.com/sigstore/cosign&#34;&gt;cosign&lt;/a&gt;. The signatures have been saved in our &lt;a href=&#34;https://github.com/bitnami-labs/sealed-secrets/pkgs/container/sealed-secrets/signs&#34;&gt;GitHub Container Registry&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is pretty simple to verify the images:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# export the COSIGN_VARIABLE setting up the GitHub container registry signs path&#xA;export COSIGN_REPOSITORY=ghcr.io/bitnami-labs/sealed-secrets-controller/signs&#xA;&#xA;# verify the image uploaded in GHCR&#xA;cosign verify --key .github/workflows/cosign.pub ghcr.io/bitnami-labs/sealed-secrets-controller:latest&#xA;&#xA;# verify the image uploaded in Dockerhub&#xA;cosign verify --key .github/workflows/cosign.pub docker.io/bitnami/sealed-secrets-controller:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to use one controller for a subset of namespaces&lt;/h3&gt; &#xA;&lt;p&gt;If you want to use one controller for more than one namespace, but not all namespaces, you can provide additional namespaces using the command line flag &lt;code&gt;--additional-namespaces=&amp;lt;namespace1&amp;gt;,&amp;lt;namespace2&amp;gt;,&amp;lt;...&amp;gt;&lt;/code&gt;. Make sure you provide appropriate roles and rolebindings in the target namespaces, so the controller can manage the secrets in there.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.slack.com/messages/sealed-secrets&#34;&gt;#sealed-secrets on Kubernetes Slack&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Click &lt;a href=&#34;http://slack.k8s.io&#34;&gt;here&lt;/a&gt; to sign up to the Kubernetes Slack org.&lt;/p&gt; &#xA;&lt;h3&gt;Related projects&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Visual Studio Code extension: &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=codecontemplator.kubeseal&#34;&gt;https://marketplace.visualstudio.com/items?itemName=codecontemplator.kubeseal&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;WebSeal: generates secrets in the browser : &lt;a href=&#34;https://socialgouv.github.io/webseal&#34;&gt;https://socialgouv.github.io/webseal&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;HybridEncrypt TypeScript implementation : &lt;a href=&#34;https://github.com/SocialGouv/aes-gcm-rsa-oaep&#34;&gt;https://github.com/SocialGouv/aes-gcm-rsa-oaep&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;[DEPRACATED] Sealed Secrets Operator: &lt;a href=&#34;https://github.com/disposab1e/sealed-secrets-operator-helm&#34;&gt;https://github.com/disposab1e/sealed-secrets-operator-helm&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>thanos-io/thanos</title>
    <updated>2022-06-30T01:42:06Z</updated>
    <id>tag:github.com,2022-06-30:/thanos-io/thanos</id>
    <link href="https://github.com/thanos-io/thanos" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Highly available Prometheus setup with long term storage capabilities. A CNCF Incubating project.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/docs/img/Thanos-logo_fullmedium.png&#34; alt=&#34;Thanos Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/thanos-io/thanos/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/thanos-io/thanos.svg?style=flat-square&#34; alt=&#34;Latest Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/thanos-io/thanos&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/thanos-io/thanos&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/thanos-io/thanos?tab=subdirectories&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/code%20reference-go.dev-darkblue.svg?sanitize=true&#34; alt=&#34;Go Code reference&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://slack.cncf.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/join%20slack-%23thanos-brightgreen.svg?sanitize=true&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.netlify.com/sites/thanos-io/deploys&#34;&gt;&lt;img src=&#34;https://api.netlify.com/api/v1/badges/664a5091-934c-4b0e-a7b6-bc12f822a590/deploy-status&#34; alt=&#34;Netlify Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bestpractices.coreinfrastructure.org/projects/3048&#34;&gt;&lt;img src=&#34;https://bestpractices.coreinfrastructure.org/projects/3048/badge&#34; alt=&#34;CII Best Practices&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/thanos-io/thanos/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/thanos-io/thanos/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/thanos-io/thanos&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/thanos-io/thanos.svg?style=svg&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/thanos-io/thanos/actions?query=workflow%3Ago&#34;&gt;&lt;img src=&#34;https://github.com/thanos-io/thanos/workflows/go/badge.svg?sanitize=true&#34; alt=&#34;go&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/thanos-io/thanos/actions?query=workflow%3Areact&#34;&gt;&lt;img src=&#34;https://github.com/thanos-io/thanos/workflows/react/badge.svg?sanitize=true&#34; alt=&#34;react&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/thanos-io/thanos/actions?query=workflow%3Adocs&#34;&gt;&lt;img src=&#34;https://github.com/thanos-io/thanos/workflows/docs/badge.svg?sanitize=true&#34; alt=&#34;docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitpod.io/#https://github.com/thanos-io/thanos&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Gitpod-ready--to--code-blue?logo=gitpod&#34; alt=&#34;Gitpod ready-to-code&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Thanos is a set of components that can be composed into a highly available metric system with unlimited storage capacity, which can be added seamlessly on top of existing Prometheus deployments.&lt;/p&gt; &#xA;&lt;p&gt;Thanos is a &lt;a href=&#34;https://www.cncf.io/&#34;&gt;CNCF&lt;/a&gt; Incubating project.&lt;/p&gt; &#xA;&lt;p&gt;Thanos leverages the Prometheus 2.0 storage format to cost-efficiently store historical metric data in any object storage while retaining fast query latencies. Additionally, it provides a global query view across all Prometheus installations and can merge data from Prometheus HA pairs on the fly.&lt;/p&gt; &#xA;&lt;p&gt;Concretely the aims of the project are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Global query view of metrics.&lt;/li&gt; &#xA; &lt;li&gt;Unlimited retention of metrics.&lt;/li&gt; &#xA; &lt;li&gt;High availability of components, including Prometheus.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://thanos.io/tip/thanos/getting-started.md/&#34;&gt;Getting Started&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://thanos.io/tip/thanos/design.md/&#34;&gt;Design&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/docs/getting-started.md#blog-posts&#34;&gt;Blog posts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/docs/getting-started.md#talks&#34;&gt;Talks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/docs/proposals-done&#34;&gt;Proposals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/docs/integrations.md&#34;&gt;Integrations&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Global querying view across all connected Prometheus servers&lt;/li&gt; &#xA; &lt;li&gt;Deduplication and merging of metrics collected from Prometheus HA pairs&lt;/li&gt; &#xA; &lt;li&gt;Seamless integration with existing Prometheus setups&lt;/li&gt; &#xA; &lt;li&gt;Any object storage as its only, optional dependency&lt;/li&gt; &#xA; &lt;li&gt;Downsampling historical data for massive query speedup&lt;/li&gt; &#xA; &lt;li&gt;Cross-cluster federation&lt;/li&gt; &#xA; &lt;li&gt;Fault-tolerant query routing&lt;/li&gt; &#xA; &lt;li&gt;Simple gRPC &#34;Store API&#34; for unified data access across all metric data&lt;/li&gt; &#xA; &lt;li&gt;Easy integration points for custom metric providers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Architecture Overview&lt;/h2&gt; &#xA;&lt;p&gt;Deployment with Sidecar:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://docs.google.com/drawings/d/e/2PACX-1vTBFKKgf8YDInJyRakPE8eZZg9phTlOsBB2ogNkFvhNGbZ8YDvz_cGMbxWZBG1G6hpsQfSX145FpYcv/pub?w=960&amp;amp;h=720&#34; alt=&#34;Sidecar&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Deployment with Receive:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://docs.google.com/drawings/d/e/2PACX-1vTfko27YB_3ab7ZL8ODNG5uCcrpqKxhmqaz3lW-yhGN3_oNxkTrqXmwwlcZjaWf3cGgAJIM4CMwwkEV/pub?w=960&amp;amp;h=720&#34; alt=&#34;Receive&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Thanos Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;The philosophy of Thanos and our community is borrowing much from UNIX philosophy and the golang programming language.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each subcommand should do one thing and do it well &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;eg. thanos query proxies incoming calls to known store API endpoints merging the result&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Write components that work together &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;e.g. blocks should be stored in native prometheus format&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Make it easy to read, write, and, run components &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;e.g. reduce complexity in system design and implementation&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;Main branch should be stable and usable. Every commit to main builds docker image named &lt;code&gt;main-&amp;lt;date&amp;gt;-&amp;lt;sha&amp;gt;&lt;/code&gt; in &lt;a href=&#34;https://quay.io/repository/thanos/thanos&#34;&gt;quay.io/thanos/thanos&lt;/a&gt; and &lt;a href=&#34;https://hub.docker.com/r/thanosio/thanos&#34;&gt;thanosio/thanos dockerhub (mirror)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We also perform minor releases every 6 weeks.&lt;/p&gt; &#xA;&lt;p&gt;During that, we build tarballs for major platforms and release docker images.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/docs/release-process.md&#34;&gt;release process docs&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are very welcome! See our &lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;Thanos is an open source project and we value and welcome new contributors and members of the community. Here are ways to get in touch with the community:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Slack: &lt;a href=&#34;https://slack.cncf.io/&#34;&gt;#thanos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Issue Tracker: &lt;a href=&#34;https://github.com/thanos-io/thanos/issues&#34;&gt;GitHub Issues&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Adopters&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/website/data/adopters.yml&#34;&gt;&lt;code&gt;Adopters List&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Maintainers&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/thanos-io/thanos/main/MAINTAINERS.md&#34;&gt;MAINTAINERS.md&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>