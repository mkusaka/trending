<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-25T01:34:59Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sjlleo/nexttrace</title>
    <updated>2023-05-25T01:34:59Z</updated>
    <id>tag:github.com,2023-05-25:/sjlleo/nexttrace</id>
    <link href="https://github.com/sjlleo/nexttrace" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An open source visual route tracking CLI tool&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/sjlleo/nexttrace/main/asset/logo.png&#34; height=&#34;200px&#34; alt=&#34;NextTrace Logo&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;NextTrace&lt;/h2&gt; &#xA;&lt;p&gt;An open source visual routing tool that pursues light weight, developed using Golang.&lt;/p&gt; &#xA;&lt;p&gt;NextTrace is part of the &lt;a href=&#34;https://github.com/OwO-Network&#34;&gt;OwO Network&lt;/a&gt; project. The project is a joint initiative of Leo and Vincent.&lt;/p&gt; &#xA;&lt;p&gt;If you like this project, &lt;a href=&#34;https://afdian.net/a/sjlleo/plan&#34;&gt;Donate us&lt;/a&gt; to help us to provide long-lasting API cost expenses.&lt;/p&gt; &#xA;&lt;h2&gt;How To Use&lt;/h2&gt; &#xA;&lt;p&gt;Document Language: English | &lt;a href=&#34;https://raw.githubusercontent.com/sjlleo/nexttrace/main/README_zh_CN.md&#34;&gt;简体中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Automated Installation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Linux one-click install script&#xA;bash -c &#34;$(curl -Ls https://raw.githubusercontent.com/sjlleo/nexttrace/main/nt_install.sh)&#34;&#xA;&#xA;# macOS brew install command&#xA;brew tap xgadget-lab/nexttrace &amp;amp;&amp;amp; brew install nexttrace&#xA;&#xA;# GHProxy Mirror (For China Mainland User)&#xA;bash -c &#34;$(curl -Ls https://ghproxy.com/https://raw.githubusercontent.com/sjlleo/nexttrace/main/nt_install.sh)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Windows users please go to &lt;a href=&#34;https://github.com/sjlleo/nexttrace/releases/latest&#34;&gt;Release Page&lt;/a&gt; directly and download exe file.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Release&lt;/code&gt; provides compiled executables for many systems and architectures, if not, you can compile it yourself.&lt;/li&gt; &#xA; &lt;li&gt;Some of the necessary dependencies of this project are not fully implemented in &lt;code&gt;Golang&lt;/code&gt; on &lt;code&gt;Windows&lt;/code&gt;, so currently &lt;code&gt;NextTrace&lt;/code&gt; is experimental on &lt;code&gt;Windows&lt;/code&gt; platform.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Get Started&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace&lt;/code&gt; uses the &lt;code&gt;ICMP&lt;/code&gt; protocol to perform TraceRoute requests by default, which supports both &lt;code&gt;IPv4&lt;/code&gt; and &lt;code&gt;IPv6&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# IPv4 ICMP Trace&#xA;nexttrace 1.0.0.1&#xA;# URL&#xA;nexttrace http://example.com:8080/index.html?q=1&#xA;&#xA;# Form printing&#xA;nexttrace --table 1.0.0.1&#xA;&#xA;# An Output Easy to Parse&#xA;nexttrace --raw 1.0.0.1&#xA;&#xA;# IPv6 ICMP Trace&#xA;nexttrace 2606:4700:4700::1111&#xA;&#xA;# Disable Path Visualization With the -M parameter&#xA;nexttrace koreacentral.blob.core.windows.net&#xA;# MapTrace URL: https://api.leo.moe/tracemap/html/c14e439e-3250-5310-8965-42a1e3545266.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;PS: The routing visualization drawing module was written by &lt;a href=&#34;https://github.com/tsosunchia&#34;&gt;@tsosunchia&lt;/a&gt;, and the specific code can be viewed at &lt;a href=&#34;https://github.com/tsosunchia/traceMap&#34;&gt;tsosunchia/traceMap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that in LeoMoeAPI 2.0, due to the addition of geographical location data, &lt;strong&gt;we have deprecated the online query part of the OpenStreetMap API in the traceMap plugin and are using location information from our own database&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The routing visualization function requires the geographical coordinates of each Hop, but third-party APIs generally do not provide this information, so this function is currently only supported when used with LeoMoeAPI.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace&lt;/code&gt; now supports quick testing, and friends who have a one-time backhaul routing test requirement can use it&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# IPv4 ICMP Fast Test (Beijing + Shanghai + Guangzhou + Hangzhou) in China Telecom / Unicom / Mobile / Education Network&#xA;nexttrace --fast-trace&#xA;&#xA;# You can also use TCP SYN for testing&#xA;nexttrace --fast-trace --tcp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace&lt;/code&gt; already supports route tracing for specified Network Devices&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Use eth0 network interface&#xA;nexttrace --dev eth0 2606:4700:4700::1111&#xA;&#xA;# Use eth0 network interface&#39;s IP&#xA;# When using the network interface&#39;s IP for route tracing, note that the IP type to be traced should be the same as network interface&#39;s IP type (e.g. both IPv4)&#xA;nexttrace --source 204.98.134.56 9.9.9.9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace&lt;/code&gt; can also use &lt;code&gt;TCP&lt;/code&gt; and &lt;code&gt;UDP&lt;/code&gt; protocols to perform &lt;code&gt;Traceroute&lt;/code&gt; requests, but &lt;code&gt;UDP&lt;/code&gt; protocols only supports &lt;code&gt;IPv4&lt;/code&gt; now&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# TCP SYN Trace&#xA;nexttrace --tcp www.bing.com&#xA;&#xA;# You can specify the port by yourself [here is 443], the default port is 80&#xA;nexttrace --tcp --port 443 2001:4860:4860::8888&#xA;&#xA;# UDP Trace&#xA;nexttrace --udp 1.0.0.1&#xA;&#xA;nexttrace --udp --port 53 1.0.0.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace&lt;/code&gt; also supports some advanced functions, such as ttl control, concurrent probe packet count control, mode switching, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Send 2 probe packets per hop&#xA;nexttrace --queries 2 www.hkix.net&#xA;&#xA;# No concurrent probe packets, only one probe packet is sent at a time&#xA;nexttrace --parallel-requests 1 www.hkix.net&#xA;&#xA;# Start Trace with TTL of 5, end at TTL of 10&#xA;nexttrace --first 5 --max-hops 10 www.decix.net&#xA;&#xA;# Turn off the IP reverse parsing function&#xA;nexttrace --no-rdns www.bbix.net&#xA;&#xA;# Feature: print Route-Path diagram&#xA;# Route-Path diagram example:&#xA;# AS6453 Tata Communication「Singapore『Singapore』」&#xA;#  ╭╯&#xA;#  ╰AS9299 Philippine Long Distance Telephone Co.「Philippines『Metro Manila』」&#xA;#  ╭╯&#xA;#  ╰AS36776 Five9 Inc.「Philippines『Metro Manila』」&#xA;#  ╭╯&#xA;#  ╰AS37963 Aliyun「ALIDNS.COM『ALIDNS.COM』」&#xA;nexttrace --route-path www.time.com.my&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace&lt;/code&gt; supports users to select their own IP API (currently supports: &lt;code&gt;LeoMoeAPI&lt;/code&gt;, &lt;code&gt;IP.SB&lt;/code&gt;, &lt;code&gt;IPInfo&lt;/code&gt;, &lt;code&gt;IPInsight&lt;/code&gt;, &lt;code&gt;IPAPI.com&lt;/code&gt;, &lt;code&gt;Ip2region&lt;/code&gt;, &lt;code&gt;IPInfoLocal&lt;/code&gt;, &lt;code&gt;CHUNZHEN&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# You can specify the IP database by yourself [IP-API.com here], if not specified, LeoMoeAPI will be used&#xA;nexttrace --data-provider ip-api.com&#xA;## Note There are frequency limits for free queries of the ipinfo and IPInsight APIs. You can purchase services from these providers to remove the limits&#xA;##      If necessary, you can clone this project, add the token provided by ipinfo or IPInsight and compile it yourself&#xA;## Note For the offline database IPInfoLocal, please download it manually and rename it to ipinfoLocal.mmdb. (You can download it from here: https://ipinfo.io/signup?ref=free-database-downloads)&#xA;##      For the offline database Ip2region, you can download it manually and rename it to ip2region.db, or let NextTrace download it automatically&#xA;## Fill the token to: ipgeo/tokens.go&#xA;## Please be aware: Due to the serious abuse of IP.SB, you will often be not able to query IP data from this source&#xA;## IP-API.com has a stricter restiction on API calls, if you can&#39;t query IP data from this source, please try again in a few minutes&#xA;&#xA;# The Pure-FTPd IP database defaults to using http://127.0.0.1:2060 as the query interface. To customize it, please use environment variables&#xA;export NEXTTRACE_CHUNZHENURL=http://127.0.0.1:2060&#xA;## You can use https://github.com/freshcn/qqwry to build your own Pure-FTPd IP database service&#xA;&#xA;# You can also specify the default IP database by setting an environment variable&#xA;export NEXTTRACE_DATAPROVIDER=ipinfo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace&lt;/code&gt; supports mixed parameters and shortened parameters&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Example:&#xA;nexttrace --data-provider IPAPI.com --max-hops 20 --tcp --port 443 --queries 5 --no-rdns 1.1.1.1&#xA;nexttrace -tcp --queries 2 --parallel-requests 1 --table --route-path 2001:4860:4860::8888&#xA;&#xA;Equivalent to:&#xA;nexttrace -d IPAPI.com -m 20 -T -p 443 -q 5 -n 1.1.1.1&#xA;nexttrace -T -q 2 --parallel-requests 1 -t -R 2001:4860:4860::8888&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;IP Database&lt;/h3&gt; &#xA;&lt;h4&gt;We use &lt;a href=&#34;https://bgp.tools&#34;&gt;bgp.tools&lt;/a&gt; as a data provider for routing tables.&lt;/h4&gt; &#xA;&lt;p&gt;NextTrace BackEnd is now open-source.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sjlleo/nexttrace-backend&#34;&gt;https://github.com/sjlleo/nexttrace-backend&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;All NextTrace IP geolocation &lt;code&gt;API DEMO&lt;/code&gt; can refer to &lt;a href=&#34;https://github.com/xgadget-lab/nexttrace/raw/main/ipgeo/&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;For full usage list, please refer to the usage menu&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Usage: nexttrace [-h|--help] [-T|--tcp] [-U|--udp] [-F|--fast-trace] [-p|--port&#xA;                 &amp;lt;integer&amp;gt;] [-q|--queries &amp;lt;integer&amp;gt;] [--parallel-requests&#xA;                 &amp;lt;integer&amp;gt;] [-m|--max-hops &amp;lt;integer&amp;gt;] [-d|--data-provider&#xA;                 (Ip2region|ip2region|IP.SB|ip.sb|IPInfo|ipinfo|IPInsight|ipinsight|IPAPI.com|ip-api.com|IPInfoLocal|ipinfolocal|chunzhen)]&#xA;                 [-n|--no-rdns] [-a|--always-rdns] [-P|--route-path]&#xA;                 [-r|--report] [--dn42] [-o|--output] [-t|--table] [--raw]&#xA;                 [-c|--classic] [-f|--first &amp;lt;integer&amp;gt;] [-M|--map]&#xA;                 [-v|--version] [-s|--source &#34;&amp;lt;value&amp;gt;&#34;] [-D|--dev &#34;&amp;lt;value&amp;gt;&#34;]&#xA;                 [-R|--route] [-z|--send-time &amp;lt;integer&amp;gt;] [-i|--ttl-time&#xA;                 &amp;lt;integer&amp;gt;] [_positionalArg_nexttrace_25 &#34;&amp;lt;value&amp;gt;&#34;]&#xA;                 [--dot-server (dnssb|aliyun|dnspod|google|cloudflare)]&#xA;                 [-g|--language (en|cn)]&#xA;&#xA;Arguments:&#xA;&#xA;  -h  --help                         Print help information&#xA;  -T  --tcp                          Use TCP SYN for tracerouting (default port&#xA;                                     is 80)&#xA;  -U  --udp                          Use UDP SYN for tracerouting (default port&#xA;                                     is 53)&#xA;  -F  --fast-trace                   One-Key Fast Trace to China ISPs&#xA;  -p  --port                         Set the destination port to use. It is&#xA;                                     either initial udp port value for&#xA;                                     &#34;default&#34;method (incremented by each&#xA;                                     probe, default is 33434), or initial seq&#xA;                                     for &#34;icmp&#34; (incremented as well, default&#xA;                                     from 1), or some constantdestination port&#xA;                                     for other methods (with default of 80 for&#xA;                                     &#34;tcp&#34;, 53 for &#34;udp&#34;, etc.)&#xA;  -q  --queries                      Set the number of probes per each hop.&#xA;                                     Default: 3&#xA;      --parallel-requests            Set ParallelRequests number. It should be&#xA;                                     1 when there is a multi-routing. Default:&#xA;                                     18&#xA;  -m  --max-hops                     Set the max number of hops (max TTL to be&#xA;                                     reached). Default: 30&#xA;  -d  --data-provider                Choose IP Geograph Data Provider [IP.SB,&#xA;                                     IPInfo, IPInsight, IP-API.com, Ip2region,&#xA;                                     IPInfoLocal, CHUNZHEN]. Default: LeoMoeAPI&#xA;  -n  --no-rdns                      Do not resolve IP addresses to their&#xA;                                     domain names&#xA;  -a  --always-rdns                  Always resolve IP addresses to their&#xA;                                     domain names&#xA;  -P  --route-path                   Print traceroute hop path by ASN and&#xA;                                     location&#xA;  -r  --report                       output using report mode&#xA;      --dn42                         DN42 Mode&#xA;  -o  --output                       Write trace result to file&#xA;                                     (RealTimePrinter ONLY)&#xA;  -t  --table                        Output trace results as table&#xA;      --raw                          An Output Easy to Parse&#xA;  -c  --classic                      Classic Output trace results like&#xA;                                     BestTrace&#xA;  -f  --first                        Start from the first_ttl hop (instead from&#xA;                                     1). Default: 1&#xA;  -M  --map                          Disable Print Trace Map&#xA;  -v  --version                      Print version info and exit&#xA;  -s  --source                       Use source src_addr for outgoing packets&#xA;  -D  --dev                          Use the following Network Devices as the&#xA;                                     source address in outgoing packets&#xA;  -R  --route                        Show Routing Table [Provided By BGP.Tools]&#xA;  -z  --send-time                    Set the time interval for sending every&#xA;                                     packet. Useful when some routers use&#xA;                                     rate-limit for ICMP messages. Default: 100&#xA;  -i  --ttl-time                     Set the time interval for sending packets&#xA;                                     groups by TTL. Useful when some routers&#xA;                                     use rate-limit for ICMP messages. Default:&#xA;                                     500&#xA;      --_positionalArg_nexttrace_25  IP Address or domain name&#xA;      --dot-server                   Use DoT Server for DNS Parse [dnssb,&#xA;                                     aliyun, dnspod, google, cloudflare]&#xA;  -g  --language                     Choose the language for displaying [en,&#xA;                                     cn]. Default: cn&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Project screenshot&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/13616352/216064486-5e0a4ad5-01d6-4b3c-85e9-2e6d2519dc5d.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/59512455/218501311-1ceb9b79-79e6-4eb6-988a-9d38f626cdb8.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;NextTrace Enhanced&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;NextTrace Enhanced&lt;/code&gt; is an enhanced version for enthusiasts, &lt;code&gt;Enhanced&lt;/code&gt; provides trace route calls in the form of Web API and a simple Looking Glass webpage with built-in visualization.&lt;/p&gt; &#xA;&lt;p&gt;Please Notice that &lt;code&gt;NextTrace Enhanced&lt;/code&gt; is currently not supported in English.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/OwO-Network/nexttrace-enhanced&#34;&gt;https://github.com/OwO-Network/nexttrace-enhanced&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;LeoMoeAPI Credit&lt;/h2&gt; &#xA;&lt;p&gt;NextTrace focuses on Golang Traceroute implementations, and its LeoMoeAPI geolocation information is not supported by raw data, so a commercial version is not possible.&lt;/p&gt; &#xA;&lt;p&gt;The LeoMoeAPI data is subject to copyright restrictions from multiple data sources, and is only used for the purpose of displaying the geolocation of route tracing.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;We would like to credit samleong123 for providing nodes in Malaysia, TOHUNET Looking Glass for global nodes, and Ping.sx from Misaka, where more than 80% of reliable calibration data comes from ping/mtr reports.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;At the same time, we would like to credit isyekong for their contribution on rDNS-based calibration ideas and data. LeoMoeAPI is accelerating the development of rDNS resolution function, and has already achieved automated geolocation resolution for some backbone networks, but there are some misjudgments. We hope that NextTrace will become a One-Man ISP-friendly traceroute tool in the future, and we are working on improving the calibration of these ASN micro-backbones as much as possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In terms of development, I would like to credit missuo and zhshch for their help with Go cross-compilation, design concepts and TCP/UDP Traceroute refactoring, and tsosunchia for their support on TraceMap.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;I would also like to credit FFEE_CO, TheresaQWQ, stydxm and others for their help. leoMoeAPI has received a lot of support since its first release, so I would like to credit them all!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We hope you can give us as much feedback as possible on IP geolocation errors (see issue) so that it can be calibrated in the first place and others can benefit from it.&lt;/p&gt; &#xA;&lt;h2&gt;JetBrain Support&lt;/h2&gt; &#xA;&lt;h4&gt;This Project uses &lt;a href=&#34;https://jb.gg/OpenSourceSupport&#34;&gt;JetBrain Open-Source Project License&lt;/a&gt;. We Proudly Develop By Goland.&lt;/h4&gt; &#xA;&lt;img src=&#34;https://resources.jetbrains.com/storage/products/company/brand/logos/GoLand.png&#34; title=&#34;&#34; alt=&#34;GoLand logo&#34; width=&#34;331&#34;&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;BGP.TOOLS provided some data support for this project and we would like to express our sincere gratitude.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/missuo&#34;&gt;Vincent Young&lt;/a&gt; (&lt;a href=&#34;mailto:i@yyt.moe&#34;&gt;i@yyt.moe&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/samleong123&#34;&gt;Sam Sam&lt;/a&gt; (&lt;a href=&#34;mailto:samsam123@samsam123.name.my&#34;&gt;samsam123@samsam123.name.my&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tsosunchia&#34;&gt;tsosunchia&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/waiting4new&#34;&gt;waiting4new&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fkx4-p&#34;&gt;FFEE_CO&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Others&lt;/h3&gt; &#xA;&lt;p&gt;Although other third-party APIs are integrated in this project, please refer to the official website of the third-party APIs for specific TOS and AUP. If you encounter IP data errors, please contact them directly to correct them.&lt;/p&gt; &#xA;&lt;h2&gt;Star History&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://star-history.com/#sjlleo/nexttrace&amp;amp;Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=sjlleo/nexttrace&amp;amp;type=Date&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/go-cmp</title>
    <updated>2023-05-25T01:34:59Z</updated>
    <id>tag:github.com,2023-05-25:/google/go-cmp</id>
    <link href="https://github.com/google/go-cmp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Package for comparing Go values in tests&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Package for equality of Go values&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/google/go-cmp/cmp&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=godev&amp;amp;message=reference&amp;amp;color=00add8&#34; alt=&#34;GoDev&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/google/go-cmp/actions&#34;&gt;&lt;img src=&#34;https://github.com/google/go-cmp/actions/workflows/test.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package is intended to be a more powerful and safer alternative to &lt;code&gt;reflect.DeepEqual&lt;/code&gt; for comparing whether two values are semantically equal.&lt;/p&gt; &#xA;&lt;p&gt;The primary features of &lt;code&gt;cmp&lt;/code&gt; are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When the default behavior of equality does not suit the needs of the test, custom equality functions can override the equality operation. For example, an equality function may report floats as equal so long as they are within some tolerance of each other.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Types that have an &lt;code&gt;Equal&lt;/code&gt; method may use that method to determine equality. This allows package authors to determine the equality operation for the types that they define.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If no custom equality functions are used and no &lt;code&gt;Equal&lt;/code&gt; method is defined, equality is determined by recursively comparing the primitive kinds on both values, much like &lt;code&gt;reflect.DeepEqual&lt;/code&gt;. Unlike &lt;code&gt;reflect.DeepEqual&lt;/code&gt;, unexported fields are not compared by default; they result in panics unless suppressed by using an &lt;code&gt;Ignore&lt;/code&gt; option (see &lt;code&gt;cmpopts.IgnoreUnexported&lt;/code&gt;) or explicitly compared using the &lt;code&gt;AllowUnexported&lt;/code&gt; option.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://pkg.go.dev/github.com/google/go-cmp/cmp&#34;&gt;documentation&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;This is not an official Google product.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/google/go-cmp/cmp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;BSD - See &lt;a href=&#34;https://github.com/google/go-cmp/raw/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>go-logr/logr</title>
    <updated>2023-05-25T01:34:59Z</updated>
    <id>tag:github.com,2023-05-25:/go-logr/logr</id>
    <link href="https://github.com/go-logr/logr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple logging interface for Go&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A minimal logging API for Go&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/go-logr/logr&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/go-logr/logr.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;logr offers an(other) opinion on how Go programs and libraries can do logging without becoming coupled to a particular logging implementation. This is not an implementation of logging - it is an API. In fact it is two APIs with two different sets of users.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Logger&lt;/code&gt; type is intended for application and library authors. It provides a relatively small API which can be used everywhere you want to emit logs. It defers the actual act of writing logs (to files, to stdout, or whatever) to the &lt;code&gt;LogSink&lt;/code&gt; interface.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;LogSink&lt;/code&gt; interface is intended for logging library implementers. It is a pure interface which can be implemented by logging frameworks to provide the actual logging functionality.&lt;/p&gt; &#xA;&lt;p&gt;This decoupling allows application and library developers to write code in terms of &lt;code&gt;logr.Logger&lt;/code&gt; (which has very low dependency fan-out) while the implementation of logging is managed &#34;up stack&#34; (e.g. in or near &lt;code&gt;main()&lt;/code&gt;.) Application developers can then switch out implementations as necessary.&lt;/p&gt; &#xA;&lt;p&gt;Many people assert that libraries should not be logging, and as such efforts like this are pointless. Those people are welcome to convince the authors of the tens-of-thousands of libraries that &lt;em&gt;DO&lt;/em&gt; write logs that they are all wrong. In the meantime, logr takes a more practical approach.&lt;/p&gt; &#xA;&lt;h2&gt;Typical usage&lt;/h2&gt; &#xA;&lt;p&gt;Somewhere, early in an application&#39;s life, it will make a decision about which logging library (implementation) it actually wants to use. Something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    func main() {&#xA;        // ... other setup code ...&#xA;&#xA;        // Create the &#34;root&#34; logger.  We have chosen the &#34;logimpl&#34; implementation,&#xA;        // which takes some initial parameters and returns a logr.Logger.&#xA;        logger := logimpl.New(param1, param2)&#xA;&#xA;        // ... other setup code ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most apps will call into other libraries, create structures to govern the flow, etc. The &lt;code&gt;logr.Logger&lt;/code&gt; object can be passed to these other libraries, stored in structs, or even used as a package-global variable, if needed. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    app := createTheAppObject(logger)&#xA;    app.Run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Outside of this early setup, no other packages need to know about the choice of implementation. They write logs in terms of the &lt;code&gt;logr.Logger&lt;/code&gt; that they received:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    type appObject struct {&#xA;        // ... other fields ...&#xA;        logger logr.Logger&#xA;        // ... other fields ...&#xA;    }&#xA;&#xA;    func (app *appObject) Run() {&#xA;        app.logger.Info(&#34;starting up&#34;, &#34;timestamp&#34;, time.Now())&#xA;&#xA;        // ... app code ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;If the Go standard library had defined an interface for logging, this project probably would not be needed. Alas, here we are.&lt;/p&gt; &#xA;&lt;h3&gt;Inspiration&lt;/h3&gt; &#xA;&lt;p&gt;Before you consider this package, please read &lt;a href=&#34;http://dave.cheney.net/2015/11/05/lets-talk-about-logging&#34;&gt;this blog post by the inimitable Dave Cheney&lt;/a&gt;. We really appreciate what he has to say, and it largely aligns with our own experiences.&lt;/p&gt; &#xA;&lt;h3&gt;Differences from Dave&#39;s ideas&lt;/h3&gt; &#xA;&lt;p&gt;The main differences are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Dave basically proposes doing away with the notion of a logging API in favor of &lt;code&gt;fmt.Printf()&lt;/code&gt;. We disagree, especially when you consider things like output locations, timestamps, file and line decorations, and structured logging. This package restricts the logging API to just 2 types of logs: info and error.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Info logs are things you want to tell the user which are not errors. Error logs are, well, errors. If your code receives an &lt;code&gt;error&lt;/code&gt; from a subordinate function call and is logging that &lt;code&gt;error&lt;/code&gt; &lt;em&gt;and not returning it&lt;/em&gt;, use error logs.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Verbosity-levels on info logs. This gives developers a chance to indicate arbitrary grades of importance for info logs, without assigning names with semantic meaning such as &#34;warning&#34;, &#34;trace&#34;, and &#34;debug.&#34; Superficially this may feel very similar, but the primary difference is the lack of semantics. Because verbosity is a numerical value, it&#39;s safe to assume that an app running with higher verbosity means more (and less important) logs will be generated.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Implementations (non-exhaustive)&lt;/h2&gt; &#xA;&lt;p&gt;There are implementations for the following logging libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;a function&lt;/strong&gt; (can bridge to non-structured libraries): &lt;a href=&#34;https://github.com/go-logr/logr/tree/master/funcr&#34;&gt;funcr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;a testing.T&lt;/strong&gt; (for use in Go tests, with JSON-like output): &lt;a href=&#34;https://github.com/go-logr/logr/tree/master/testr&#34;&gt;testr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;github.com/google/glog&lt;/strong&gt;: &lt;a href=&#34;https://github.com/go-logr/glogr&#34;&gt;glogr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;k8s.io/klog&lt;/strong&gt; (for Kubernetes): &lt;a href=&#34;https://git.k8s.io/klog/klogr&#34;&gt;klogr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;a testing.T&lt;/strong&gt; (with klog-like text output): &lt;a href=&#34;https://git.k8s.io/klog/ktesting&#34;&gt;ktesting&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;go.uber.org/zap&lt;/strong&gt;: &lt;a href=&#34;https://github.com/go-logr/zapr&#34;&gt;zapr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;log&lt;/strong&gt; (the Go standard library logger): &lt;a href=&#34;https://github.com/go-logr/stdr&#34;&gt;stdr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;github.com/sirupsen/logrus&lt;/strong&gt;: &lt;a href=&#34;https://github.com/bombsimon/logrusr&#34;&gt;logrusr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;github.com/wojas/genericr&lt;/strong&gt;: &lt;a href=&#34;https://github.com/wojas/genericr&#34;&gt;genericr&lt;/a&gt; (makes it easy to implement your own backend)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;logfmt&lt;/strong&gt; (Heroku style &lt;a href=&#34;https://www.brandur.org/logfmt&#34;&gt;logging&lt;/a&gt;): &lt;a href=&#34;https://github.com/iand/logfmtr&#34;&gt;logfmtr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;github.com/rs/zerolog&lt;/strong&gt;: &lt;a href=&#34;https://github.com/go-logr/zerologr&#34;&gt;zerologr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;github.com/go-kit/log&lt;/strong&gt;: &lt;a href=&#34;https://github.com/tonglil/gokitlogr&#34;&gt;gokitlogr&lt;/a&gt; (also compatible with github.com/go-kit/kit/log since v0.12.0)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;bytes.Buffer&lt;/strong&gt; (writing to a buffer): &lt;a href=&#34;https://github.com/tonglil/buflogr&#34;&gt;bufrlogr&lt;/a&gt; (useful for ensuring values were logged, like during testing)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Conceptual&lt;/h3&gt; &#xA;&lt;h4&gt;Why structured logging?&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Structured logs are more easily queryable&lt;/strong&gt;: Since you&#39;ve got key-value pairs, it&#39;s much easier to query your structured logs for particular values by filtering on the contents of a particular key -- think searching request logs for error codes, Kubernetes reconcilers for the name and namespace of the reconciled object, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Structured logging makes it easier to have cross-referenceable logs&lt;/strong&gt;: Similarly to searchability, if you maintain conventions around your keys, it becomes easy to gather all log lines related to a particular concept.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Structured logs allow better dimensions of filtering&lt;/strong&gt;: if you have structure to your logs, you&#39;ve got more precise control over how much information is logged -- you might choose in a particular configuration to log certain keys but not others, only log lines where a certain key matches a certain value, etc., instead of just having v-levels and names to key off of.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Structured logs better represent structured data&lt;/strong&gt;: sometimes, the data that you want to log is inherently structured (think tuple-link objects.) Structured logs allow you to preserve that structure when outputting.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Why V-levels?&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;V-levels give operators an easy way to control the chattiness of log operations&lt;/strong&gt;. V-levels provide a way for a given package to distinguish the relative importance or verbosity of a given log message. Then, if a particular logger or package is logging too many messages, the user of the package can simply change the v-levels for that library.&lt;/p&gt; &#xA;&lt;h4&gt;Why not named levels, like Info/Warning/Error?&lt;/h4&gt; &#xA;&lt;p&gt;Read &lt;a href=&#34;http://dave.cheney.net/2015/11/05/lets-talk-about-logging&#34;&gt;Dave Cheney&#39;s post&lt;/a&gt;. Then read &lt;a href=&#34;https://raw.githubusercontent.com/go-logr/logr/master/#differences-from-daves-ideas&#34;&gt;Differences from Dave&#39;s ideas&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Why not allow format strings, too?&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Format strings negate many of the benefits of structured logs&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;They&#39;re not easily searchable without resorting to fuzzy searching, regular expressions, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;They don&#39;t store structured data well, since contents are flattened into a string.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;They&#39;re not cross-referenceable.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;They don&#39;t compress easily, since the message is not constant.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(Unless you turn positional parameters into key-value pairs with numerical keys, at which point you&#39;ve gotten key-value logging with meaningless keys.)&lt;/p&gt; &#xA;&lt;h3&gt;Practical&lt;/h3&gt; &#xA;&lt;h4&gt;Why key-value pairs, and not a map?&lt;/h4&gt; &#xA;&lt;p&gt;Key-value pairs are &lt;em&gt;much&lt;/em&gt; easier to optimize, especially around allocations. Zap (a structured logger that inspired logr&#39;s interface) has &lt;a href=&#34;https://github.com/uber-go/zap#performance&#34;&gt;performance measurements&lt;/a&gt; that show this quite nicely.&lt;/p&gt; &#xA;&lt;p&gt;While the interface ends up being a little less obvious, you get potentially better performance, plus avoid making users type &lt;code&gt;map[string]string{}&lt;/code&gt; every time they want to log.&lt;/p&gt; &#xA;&lt;h4&gt;What if my V-levels differ between libraries?&lt;/h4&gt; &#xA;&lt;p&gt;That&#39;s fine. Control your V-levels on a per-logger basis, and use the &lt;code&gt;WithName&lt;/code&gt; method to pass different loggers to different libraries.&lt;/p&gt; &#xA;&lt;p&gt;Generally, you should take care to ensure that you have relatively consistent V-levels within a given logger, however, as this makes deciding on what verbosity of logs to request easier.&lt;/p&gt; &#xA;&lt;h4&gt;But I really want to use a format string!&lt;/h4&gt; &#xA;&lt;p&gt;That&#39;s not actually a question. Assuming your question is &#34;how do I convert my mental model of logging with format strings to logging with constant messages&#34;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Figure out what the error actually is, as you&#39;d write in a TL;DR style, and use that as a message.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For every place you&#39;d write a format specifier, look to the word before it, and add that as a key value pair.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For instance, consider the following examples (all taken from spots in the Kubernetes codebase):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;klog.V(4).Infof(&#34;Client is returning errors: code %v, error %v&#34;, responseCode, err)&lt;/code&gt; becomes &lt;code&gt;logger.Error(err, &#34;client returned an error&#34;, &#34;code&#34;, responseCode)&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;klog.V(4).Infof(&#34;Got a Retry-After %ds response for attempt %d to %v&#34;, seconds, retries, url)&lt;/code&gt; becomes &lt;code&gt;logger.V(4).Info(&#34;got a retry-after response when requesting url&#34;, &#34;attempt&#34;, retries, &#34;after seconds&#34;, seconds, &#34;url&#34;, url)&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you &lt;em&gt;really&lt;/em&gt; must use a format string, use it in a key&#39;s value, and call &lt;code&gt;fmt.Sprintf&lt;/code&gt; yourself. For instance: &lt;code&gt;log.Printf(&#34;unable to reflect over type %T&#34;)&lt;/code&gt; becomes &lt;code&gt;logger.Info(&#34;unable to reflect over type&#34;, &#34;type&#34;, fmt.Sprintf(&#34;%T&#34;))&lt;/code&gt;. In general though, the cases where this is necessary should be few and far between.&lt;/p&gt; &#xA;&lt;h4&gt;How do I choose my V-levels?&lt;/h4&gt; &#xA;&lt;p&gt;This is basically the only hard constraint: increase V-levels to denote more verbose or more debug-y logs.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, you can start out with &lt;code&gt;0&lt;/code&gt; as &#34;you always want to see this&#34;, &lt;code&gt;1&lt;/code&gt; as &#34;common logging that you might &lt;em&gt;possibly&lt;/em&gt; want to turn off&#34;, and &lt;code&gt;10&lt;/code&gt; as &#34;I would like to performance-test your log collection stack.&#34;&lt;/p&gt; &#xA;&lt;p&gt;Then gradually choose levels in between as you need them, working your way down from 10 (for debug and trace style logs) and up from 1 (for chattier info-type logs.)&lt;/p&gt; &#xA;&lt;h4&gt;How do I choose my keys?&lt;/h4&gt; &#xA;&lt;p&gt;Keys are fairly flexible, and can hold more or less any string value. For best compatibility with implementations and consistency with existing code in other projects, there are a few conventions you should consider.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Make your keys human-readable.&lt;/li&gt; &#xA; &lt;li&gt;Constant keys are generally a good idea.&lt;/li&gt; &#xA; &lt;li&gt;Be consistent across your codebase.&lt;/li&gt; &#xA; &lt;li&gt;Keys should naturally match parts of the message string.&lt;/li&gt; &#xA; &lt;li&gt;Use lower case for simple keys and &lt;a href=&#34;https://en.wiktionary.org/wiki/lowerCamelCase&#34;&gt;lowerCamelCase&lt;/a&gt; for more complex ones. Kubernetes is one example of a project that has &lt;a href=&#34;https://github.com/kubernetes/community/raw/HEAD/contributors/devel/sig-instrumentation/migration-to-structured-logging.md#name-arguments&#34;&gt;adopted that convention&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;While key names are mostly unrestricted (and spaces are acceptable), it&#39;s generally a good idea to stick to printable ascii characters, or at least match the general character set of your log lines.&lt;/p&gt; &#xA;&lt;h4&gt;Why should keys be constant values?&lt;/h4&gt; &#xA;&lt;p&gt;The point of structured logging is to make later log processing easier. Your keys are, effectively, the schema of each log message. If you use different keys across instances of the same log line, you will make your structured logs much harder to use. &lt;code&gt;Sprintf()&lt;/code&gt; is for values, not for keys!&lt;/p&gt; &#xA;&lt;h4&gt;Why is this not a pure interface?&lt;/h4&gt; &#xA;&lt;p&gt;The Logger type is implemented as a struct in order to allow the Go compiler to optimize things like high-V &lt;code&gt;Info&lt;/code&gt; logs that are not triggered. Not all of these implementations are implemented yet, but this structure was suggested as a way to ensure they &lt;em&gt;can&lt;/em&gt; be implemented. All of the real work is behind the &lt;code&gt;LogSink&lt;/code&gt; interface.&lt;/p&gt;</summary>
  </entry>
</feed>