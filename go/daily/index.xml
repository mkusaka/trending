<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-25T01:37:16Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>google/gvisor</title>
    <updated>2023-02-25T01:37:16Z</updated>
    <id>tag:github.com,2023-02-25:/google/gvisor</id>
    <link href="https://github.com/google/gvisor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Application Kernel for Containers&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/gvisor/master/g3doc/logo.png&#34; alt=&#34;gVisor&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://buildkite.com/gvisor/pipeline&#34;&gt;&lt;img src=&#34;https://badge.buildkite.com/3b159f20b9830461a71112566c4171c0bdfd2f980a8e4c0ae6.svg?branch=master&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/google/gvisor/actions/workflows/issue_reviver.yml&#34;&gt;&lt;img src=&#34;https://github.com/google/gvisor/actions/workflows/issue_reviver.yml/badge.svg?sanitize=true&#34; alt=&#34;Issue reviver&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/gvisor/community&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/gvisor/community.png&#34; alt=&#34;gVisor chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cs.opensource.google/gvisor/gvisor&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/code-search-blue&#34; alt=&#34;code search&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is gVisor?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;gVisor&lt;/strong&gt; is an application kernel, written in Go, that implements a substantial portion of the Linux system surface. It includes an &lt;a href=&#34;https://www.opencontainers.org&#34;&gt;Open Container Initiative (OCI)&lt;/a&gt; runtime called &lt;code&gt;runsc&lt;/code&gt; that provides an isolation boundary between the application and the host kernel. The &lt;code&gt;runsc&lt;/code&gt; runtime integrates with Docker and Kubernetes, making it simple to run sandboxed containers.&lt;/p&gt; &#xA;&lt;h2&gt;Why does gVisor exist?&lt;/h2&gt; &#xA;&lt;p&gt;Containers are not a &lt;a href=&#34;https://en.wikipedia.org/wiki/Sandbox_(computer_security)&#34;&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/a&gt;. While containers have revolutionized how we develop, package, and deploy applications, using them to run untrusted or potentially malicious code without additional isolation is not a good idea. While using a single, shared kernel allows for efficiency and performance gains, it also means that container escape is possible with a single vulnerability.&lt;/p&gt; &#xA;&lt;p&gt;gVisor is an application kernel for containers. It limits the host kernel surface accessible to the application while still giving the application access to all the features it expects. Unlike most kernels, gVisor does not assume or require a fixed set of physical resources; instead, it leverages existing host kernel functionality and runs as a normal process. In other words, gVisor implements Linux by way of Linux.&lt;/p&gt; &#xA;&lt;p&gt;gVisor should not be confused with technologies and tools to harden containers against external threats, provide additional integrity checks, or limit the scope of access for a service. One should always be careful about what data is made available to a container.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;User documentation and technical architecture, including quick start guides, can be found at &lt;a href=&#34;https://gvisor.dev&#34;&gt;gvisor.dev&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing from source&lt;/h2&gt; &#xA;&lt;p&gt;gVisor builds on x86_64 and ARM64. Other architectures may become available in the future.&lt;/p&gt; &#xA;&lt;p&gt;For the purposes of these instructions, &lt;a href=&#34;https://bazel.build&#34;&gt;bazel&lt;/a&gt; and other build dependencies are wrapped in a build container. It is possible to use &lt;a href=&#34;https://bazel.build&#34;&gt;bazel&lt;/a&gt; directly, or type &lt;code&gt;make help&lt;/code&gt; for standard targets.&lt;/p&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;p&gt;Make sure the following dependencies are installed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux 4.14.77+ (&lt;a href=&#34;https://gvisor.dev/docs/user_guide/networking/#gso&#34;&gt;older linux&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.docker.com&#34;&gt;Docker version 17.09.0 or greater&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;Build and install the &lt;code&gt;runsc&lt;/code&gt; binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir -p bin&#xA;make copy TARGETS=runsc DESTINATION=bin/&#xA;sudo cp ./bin/runsc /usr/local/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;To run standard test suites, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make unit-tests&#xA;make tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run specific tests, you can specify the target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make test TARGETS=&#34;//runsc:version_test&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;go get&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This project uses &lt;a href=&#34;https://bazel.build&#34;&gt;bazel&lt;/a&gt; to build and manage dependencies. A synthetic &lt;code&gt;go&lt;/code&gt; branch is maintained that is compatible with standard &lt;code&gt;go&lt;/code&gt; tooling for convenience.&lt;/p&gt; &#xA;&lt;p&gt;For example, to build and install &lt;code&gt;runsc&lt;/code&gt; directly from this branch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &#34;module runsc&#34; &amp;gt; go.mod&#xA;GO111MODULE=on go get gvisor.dev/gvisor/runsc@go&#xA;CGO_ENABLED=0 GO111MODULE=on sudo -E go build -o /usr/local/bin/runsc gvisor.dev/gvisor/runsc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Subsequently, you can build and install the shim binary for &lt;code&gt;containerd&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;GO111MODULE=on sudo -E go build -o /usr/local/bin/containerd-shim-runsc-v1 gvisor.dev/gvisor/shim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this branch is supported in a best effort capacity, and direct development on this branch is not supported. Development should occur on the &lt;code&gt;master&lt;/code&gt; branch, which is then reflected into the &lt;code&gt;go&lt;/code&gt; branch.&lt;/p&gt; &#xA;&lt;h2&gt;Community &amp;amp; Governance&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/google/gvisor/master/GOVERNANCE.md&#34;&gt;GOVERNANCE.md&lt;/a&gt; for project governance information.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://groups.google.com/forum/#!forum/gvisor-users&#34;&gt;gvisor-users mailing list&lt;/a&gt; and &lt;a href=&#34;https://groups.google.com/forum/#!forum/gvisor-dev&#34;&gt;gvisor-dev mailing list&lt;/a&gt; are good starting points for questions and discussion.&lt;/p&gt; &#xA;&lt;h2&gt;Security Policy&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/google/gvisor/master/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/google/gvisor/master/CONTRIBUTING.md&#34;&gt;Contributing.md&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>loxilb-io/loxilb</title>
    <updated>2023-02-25T01:37:16Z</updated>
    <id>tag:github.com,2023-02-25:/loxilb-io/loxilb</id>
    <link href="https://github.com/loxilb-io/loxilb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;eBPF based cloud-native service load-balancer. Powering K8s|Edge|5G|IoT|XaaS Apps.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://ebpf.io/projects#loxilb&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/ebpf.io-Emerging--App-success&#34; alt=&#34;eBPF Emerging Project&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/loxilb-io/loxilb&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/loxilb-io/loxilb&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/loxilb-io/loxilb/actions/workflows/docker-image.yml/badge.svg?sanitize=true&#34; alt=&#34;build workflow&#34;&gt; &lt;img src=&#34;https://github.com/loxilb-io/loxilb/actions/workflows/basic-sanity.yml/badge.svg?sanitize=true&#34; alt=&#34;sanity workflow&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/license-Apache-blue.svg?sanitize=true&#34; alt=&#34;apache&#34;&gt; &lt;a href=&#34;https://loxilb-io.github.io/loxilbdocs/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/info-documentation-blue&#34; alt=&#34;Info&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is loxilb&lt;/h2&gt; &#xA;&lt;p&gt;loxilb is an open source hyper-scale software load-balancer for cloud-native workloads. It uses eBPF as its core-engine and is based on Golang. It is designed primarily to support on-premise, edge and public-cloud Kubernetes cluster deployments, but it should work equally well as a standalone load-balancer. loxilb aims to provide the following :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Service type external load-balancer for kubernetes&lt;/li&gt; &#xA; &lt;li&gt;L4/NAT stateful loadbalancer &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;NAT44, NAT66, NAT64 with One-ARM, FullNAT, DSR etc&lt;/li&gt; &#xA;   &lt;li&gt;High-availability support with hitless clustering&lt;/li&gt; &#xA;   &lt;li&gt;Full compliance for K8s loadbalancer Spec&lt;/li&gt; &#xA;   &lt;li&gt;High-perf replacement for the &lt;em&gt;aging&lt;/em&gt; iptables/ipvs&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Optimized SRv6 implementation in eBPF&lt;/li&gt; &#xA; &lt;li&gt;L7 proxy support&lt;/li&gt; &#xA; &lt;li&gt;Make GTP tunnels first class citizens of the Linux world &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Support for QFI and other extension headers&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;eBPF based data-path forwarding (Dual BSD/GPLv2 license) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Complete kernel networking bypass with home-grown stack for advanced features like &lt;a href=&#34;https://thermalcircle.de/doku.php?id=blog:linux:connection_tracking_1_modules_and_hooks&#34;&gt;Conntrack&lt;/a&gt;, QoS etc&lt;/li&gt; &#xA;   &lt;li&gt;Highly scalable with low-latency &amp;amp; high througput&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;goLang based control plane components (Apache license)&lt;/li&gt; &#xA; &lt;li&gt;Seamless integration with goBGP based routing stack&lt;/li&gt; &#xA; &lt;li&gt;GoLang based easy to use APIs/Interfaces for developers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Check loxilb &lt;a href=&#34;https://loxilb-io.github.io/loxilbdocs/&#34;&gt;Documentation&lt;/a&gt; for more info.&lt;/h3&gt;</summary>
  </entry>
</feed>