<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-27T01:35:52Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>GoAdminGroup/go-admin</title>
    <updated>2023-02-27T01:35:52Z</updated>
    <id>tag:github.com,2023-02-27:/GoAdminGroup/go-admin</id>
    <link href="https://github.com/GoAdminGroup/go-admin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A golang framework helps gopher to build a data visualization and admin panel in ten minutes&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/GoAdminGroup/go-admin&#34;&gt; &lt;img width=&#34;48%&#34; alt=&#34;go-admin&#34; src=&#34;http://quick.go-admin.cn/official/assets/imgs/github_logo.png&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; the missing golang data admin panel builder tool. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://book.go-admin.cn/en&#34;&gt;Documentation&lt;/a&gt; | &lt;a href=&#34;http://doc.go-admin.cn/zh/&#34;&gt;‰∏≠ÊñáÊñáÊ°£&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/GoAdminGroup/go-admin/master/README_CN.md&#34;&gt;‰∏≠Êñá‰ªãÁªç&lt;/a&gt; | &lt;a href=&#34;https://demo.go-admin.com&#34;&gt;DEMO&lt;/a&gt; | &lt;a href=&#34;https://demo.go-admin.cn&#34;&gt;‰∏≠ÊñáDEMO&lt;/a&gt; | &lt;a href=&#34;https://twitter.com/cg3365688034&#34;&gt;Twitter&lt;/a&gt; | &lt;a href=&#34;http://discuss.go-admin.com&#34;&gt;Forum&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;http://drone.go-admin.com/GoAdminGroup/go-admin&#34;&gt;&lt;img alt=&#34;Build Status&#34; src=&#34;http://drone.go-admin.com/api/badges/GoAdminGroup/go-admin/status.svg?ref=refs/heads/master&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/GoAdminGroup/go-admin&#34;&gt;&lt;img alt=&#34;Go Report Card&#34; src=&#34;https://camo.githubusercontent.com/59eed852617e19c272a4a4764fd09c669957fe75/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f6368656e6867352f676f2d61646d696e&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/GoAdminGroup/go-admin&#34;&gt;&lt;img alt=&#34;golang&#34; src=&#34;https://img.shields.io/badge/awesome-golang-blue.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/joinchat/NlyH6Bch2QARZkArithKvg&#34; rel=&#34;nofollow&#34;&gt;&lt;img alt=&#34;telegram&#34; src=&#34;https://img.shields.io/badge/chat%20on-telegram-blue&#34; style=&#34;max-width:100%;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goadmin.slack.com&#34;&gt;&lt;img alt=&#34;slack&#34; src=&#34;https://img.shields.io/badge/chat on-Slack-yellow.svg&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/GoAdminGroup/go-admin&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/a9a286d43bdfff9fb41b88b25b35ea8edd2634fc/68747470733a2f2f676f646f632e6f72672f6769746875622e636f6d2f646572656b7061726b65722f64656c76653f7374617475732e737667&#34; alt=&#34;GoDoc&#34; data-canonical-src=&#34;https://godoc.org/github.com/derekparker/delve?status.svg&#34; style=&#34;max-width:100%;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/GoAdminGroup/go-admin/master/LICENSE&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-Apache2.0-blue.svg?sanitize=true&#34; alt=&#34;license&#34; data-canonical-src=&#34;https://img.shields.io/badge/license-Apache2.0-blue.svg&#34; style=&#34;max-width:100%;&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Inspired by &lt;a href=&#34;https://github.com/z-song/laravel-admin&#34; target=&#34;_blank&#34;&gt;laravel-admin&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Preface&lt;/h2&gt; &#xA;&lt;p&gt;GoAdmin is a toolkit to help you build a data visualization admin panel for your golang app.&lt;/p&gt; &#xA;&lt;p&gt;Online demo: &lt;a href=&#34;https://demo.go-admin.com&#34;&gt;https://demo.go-admin.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Quick follow up example: &lt;a href=&#34;https://github.com/GoAdminGroup/example&#34;&gt;https://github.com/GoAdminGroup/example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;GoAdmin+vue example: &lt;a href=&#34;https://github.com/GoAdminGroup/goadmin-vue-example&#34;&gt;https://github.com/GoAdminGroup/goadmin-vue-example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://file.go-admin.cn/introduction/interface_en_3.png&#34; alt=&#34;interface&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üöÄ &lt;strong&gt;Fast&lt;/strong&gt;: build a production admin panel app in &lt;strong&gt;ten&lt;/strong&gt; minutes.&lt;/li&gt; &#xA; &lt;li&gt;üé® &lt;strong&gt;Theming&lt;/strong&gt;: beautiful ui themes supported(default adminlte, more themes are coming.)&lt;/li&gt; &#xA; &lt;li&gt;üî¢ &lt;strong&gt;Plugins&lt;/strong&gt;: many plugins to use(more useful and powerful plugins are coming.)&lt;/li&gt; &#xA; &lt;li&gt;‚úÖ &lt;strong&gt;Rbac&lt;/strong&gt;: out of box rbac auth system.&lt;/li&gt; &#xA; &lt;li&gt;‚öôÔ∏è &lt;strong&gt;Frameworks&lt;/strong&gt;: support most of the go web frameworks.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Translation&lt;/h2&gt; &#xA;&lt;p&gt;We need your help: &lt;a href=&#34;https://github.com/GoAdminGroup/docs/issues/1&#34;&gt;https://github.com/GoAdminGroup/docs/issues/1&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Who is using&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/GoAdminGroup/go-admin/issues/71&#34;&gt;Comment the issue to tell us&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to&lt;/h2&gt; &#xA;&lt;p&gt;Following three steps to run it.&lt;/p&gt; &#xA;&lt;p&gt;Note: now you can quickly start by doing like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go install github.com/GoAdminGroup/adm@latest&#xA;$ mkdir new_project &amp;amp;&amp;amp; cd new_project&#xA;$ adm init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or (use adm whose version higher or equal than v1.2.16)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir new_project &amp;amp;&amp;amp; cd new_project&#xA;$ go install github.com/GoAdminGroup/adm@latest&#xA;$ adm init web&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 1: import sql&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/GoAdminGroup/go-admin/master/data/admin.sql&#34;&gt;mysql&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/GoAdminGroup/go-admin/master/data/admin.mssql&#34;&gt;mssql&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/GoAdminGroup/go-admin/master/data/admin.pgsql&#34;&gt;postgresql&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/GoAdminGroup/go-admin/master/data/admin.db&#34;&gt;sqlite&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Step 2: create main.go&lt;/h3&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;main.go&lt;/summary&gt; &#xA; &lt;p&gt; &lt;/p&gt;&#xA; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;github.com/gin-gonic/gin&#34;&#xA;&#x9;_ &#34;github.com/GoAdminGroup/go-admin/adapter/gin&#34;&#xA;&#x9;_ &#34;github.com/GoAdminGroup/go-admin/modules/db/drivers/mysql&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/engine&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/plugins/admin&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/modules/config&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/themes/adminlte&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/template&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/template/chartjs&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/template/types&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/examples/datamodel&#34;&#xA;&#x9;&#34;github.com/GoAdminGroup/go-admin/modules/language&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;r := gin.Default()&#xA;&#xA;&#x9;eng := engine.Default()&#xA;&#xA;&#x9;// global config&#xA;&#x9;cfg := config.Config{&#xA;&#x9;&#x9;Databases: config.DatabaseList{&#xA;&#x9;&#x9;&#x9;&#34;default&#34;: {&#xA;&#x9;&#x9;&#x9;&#x9;Host:         &#34;127.0.0.1&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;Port:         &#34;3306&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;User:         &#34;root&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;Pwd:          &#34;root&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;Name:         &#34;goadmin&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;MaxIdleConns: 50,&#xA;&#x9;&#x9;&#x9;&#x9;MaxOpenConns: 150,&#xA;&#x9;&#x9;&#x9;&#x9;ConnMaxLifetime: time.Hour,&#xA;&#x9;&#x9;&#x9;&#x9;Driver:       &#34;mysql&#34;,&#xA;&#x9;&#x9;&#x9;},&#xA;        &#x9;},&#xA;&#x9;&#x9;UrlPrefix: &#34;admin&#34;,&#xA;&#x9;&#x9;// STORE is important. And the directory should has permission to write.&#xA;&#x9;&#x9;Store: config.Store{&#xA;&#x9;&#x9;    Path:   &#34;./uploads&#34;, &#xA;&#x9;&#x9;    Prefix: &#34;uploads&#34;,&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;Language: language.EN,&#xA;&#x9;&#x9;// debug mode&#xA;&#x9;&#x9;Debug: true,&#xA;&#x9;&#x9;// log file absolute path&#xA;&#x9;&#x9;InfoLogPath: &#34;/var/logs/info.log&#34;,&#xA;&#x9;&#x9;AccessLogPath: &#34;/var/logs/access.log&#34;,&#xA;&#x9;&#x9;ErrorLogPath: &#34;/var/logs/error.log&#34;,&#xA;&#x9;&#x9;ColorScheme: adminlte.ColorschemeSkinBlack,&#xA;&#x9;}&#xA;&#xA;&#x9;// add component chartjs&#xA;&#x9;template.AddComp(chartjs.NewChart())&#xA;&#xA;&#x9;_ = eng.AddConfig(&amp;amp;cfg).&#xA;&#x9;&#x9;AddGenerators(datamodel.Generators).&#xA;&#x9;        // add generator, first parameter is the url prefix of table when visit.&#xA;    &#x9;        // example:&#xA;    &#x9;        //&#xA;    &#x9;        // &#34;user&#34; =&amp;gt; http://localhost:9033/admin/info/user&#xA;    &#x9;        //&#x9;&#x9;&#xA;&#x9;&#x9;AddGenerator(&#34;user&#34;, datamodel.GetUserTable).&#xA;&#x9;&#x9;Use(r)&#xA;&#x9;&#xA;&#x9;// customize your pages&#xA;&#x9;eng.HTML(&#34;GET&#34;, &#34;/admin&#34;, datamodel.GetContent)&#xA;&#xA;&#x9;_ = r.Run(&#34;:9033&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;More framework examples: &lt;a href=&#34;https://github.com/GoAdminGroup/go-admin/tree/master/examples&#34;&gt;https://github.com/GoAdminGroup/go-admin/tree/master/examples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Step 3: run&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;GO111MODULE=on go run main.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;visit: &lt;a href=&#34;http://localhost:9033/admin&#34;&gt;http://localhost:9033/admin&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;account: admin password: admin&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/GoAdminGroup/example&#34;&gt;A super simple example here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://book.go-admin.cn&#34;&gt;docs&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Backers&lt;/h2&gt; &#xA;&lt;p&gt;Your support will help me do better! [&lt;a href=&#34;https://opencollective.com/go-admin#backer&#34;&gt;Become a backer&lt;/a&gt;] &lt;a href=&#34;https://opencollective.com/go-admin#backers&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/go-admin/backers.svg?width=890&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/GoAdminGroup/go-admin/master/CONTRIBUTING.md&#34;&gt;here for contribution guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;here to join into the develop team&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://t.me/joinchat/NlyH6Bch2QARZkArithKvg&#34;&gt;join telegram&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>knadh/koanf</title>
    <updated>2023-02-27T01:35:52Z</updated>
    <id>tag:github.com,2023-02-27:/knadh/koanf</id>
    <link href="https://github.com/knadh/koanf" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, lightweight, extensible, configuration management library for Go. Support for JSON, TOML, YAML, env, command line, file, S3 etc. Alternative to viper.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://zerodha.tech&#34;&gt;&lt;img src=&#34;https://zerodha.tech/static/images/github-badge.svg?sanitize=true&#34; align=&#34;right&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/547147/72681838-6981dd00-3aed-11ea-8f5d-310816c70c08.png&#34; alt=&#34;koanf&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;koanf&lt;/strong&gt; is a library for reading configuration from different sources in different formats in Go applications. It is a cleaner, lighter &lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#alternative-to-viper&#34;&gt;alternative to spf13/viper&lt;/a&gt; with better abstractions and extensibility and far fewer dependencies.&lt;/p&gt; &#xA;&lt;p&gt;koanf v2 has modules (Providers) for reading configuration from a variety of sources such as files, command line flags, environment variables, Vault, and S3 and for parsing (Parsers) formats such as JSON, YAML, TOML, Hashicorp HCL. It is easy to plug in custom parsers and providers.&lt;/p&gt; &#xA;&lt;p&gt;All external dependencies in providers and parsers are detatched from the core and can be installed separately as necessary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/knadh/koanf/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/knadh/koanf/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Run Tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/knadh/koanf&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/knadh/koanf?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Install the core.&#xA;go get -u github.com/knadh/koanf/v2&#xA;&#xA;# Install the necessary Provider(s).&#xA;# Available: file, env, posflag, basicflag, confmap, rawbytes,&#xA;#            structs, appconfig, consul, etcd, fs, s3, vault&#xA;# go get -u github.com/knadh/koanf/providers/$provider&#xA;&#xA;go get -u github.com/knadh/koanf/providers/file&#xA;&#xA;&#xA;# Install the necessary Parser(s).&#xA;# Available: toml, json, yaml, dotenv, hcl, hjson, nestedtext&#xA;# go get -u github.com/knadh/koanf/parsers/$parser&#xA;&#xA;go get -u github.com/knadh/koanf/parsers/toml&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#api&#34;&gt;See the list&lt;/a&gt; of all bundled Providers and Parsers.&lt;/p&gt; &#xA;&lt;h3&gt;Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#concepts&#34;&gt;Concepts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#reading-config-from-files&#34;&gt;Reading config from files&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#watching-file-for-changes&#34;&gt;Watching file for changes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#reading-from-command-line&#34;&gt;Reading from command line&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#reading-environment-variables&#34;&gt;Reading environment variables&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#reading-raw-bytes&#34;&gt;Reading raw bytes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#reading-from-nested-maps&#34;&gt;Reading from maps and structs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#unmarshalling-and-marshalling&#34;&gt;Unmarshalling and marshalling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#order-of-merge-and-key-case-sensitivity&#34;&gt;Order of merge and key case senstivity&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#custom-providers-and-parsers&#34;&gt;Custom Providers and Parsers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#custom-merge-strategies&#34;&gt;Custom merge strategies&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/knadh/koanf/master/#api&#34;&gt;List of installable Providers and Parsers&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Concepts&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;koanf.Provider&lt;/code&gt; is a generic interface that provides configuration, for example, from files, environment variables, HTTP sources, or anywhere. The configuration can either be raw bytes that a parser can parse, or it can be a nested &lt;code&gt;map[string]interface{}&lt;/code&gt; that can be directly loaded.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;koanf.Parser&lt;/code&gt; is a generic interface that takes raw bytes, parses, and returns a nested &lt;code&gt;map[string]interface{}&lt;/code&gt;. For example, JSON and YAML parsers.&lt;/li&gt; &#xA; &lt;li&gt;Once loaded into koanf, configuration are values queried by a delimited key path syntax. eg: &lt;code&gt;app.server.port&lt;/code&gt;. Any delimiter can be chosen.&lt;/li&gt; &#xA; &lt;li&gt;Configuration from multiple sources can be loaded and merged into a koanf instance, for example, load from a file first and override certain values with flags from the command line.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With these two interface implementations, koanf can obtain configuration in any format from any source, parse it, and make it available to an application.&lt;/p&gt; &#xA;&lt;h3&gt;Reading config from files&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/yaml&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use &#34;.&#34; as the key path delimiter. This can be &#34;/&#34; or any character.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;func main() {&#xA;&#x9;// Load JSON config.&#xA;&#x9;if err := k.Load(file.Provider(&#34;mock/mock.json&#34;), json.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;// Load YAML config and merge into the previously loaded config (because we can).&#xA;&#x9;k.Load(file.Provider(&#34;mock/mock.yml&#34;), yaml.Parser())&#xA;&#xA;&#x9;fmt.Println(&#34;parent&#39;s name is = &#34;, k.String(&#34;parent1.name&#34;))&#xA;&#x9;fmt.Println(&#34;parent&#39;s ID is = &#34;, k.Int(&#34;parent1.id&#34;))&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Watching file for changes&lt;/h3&gt; &#xA;&lt;p&gt;Some providers expose a &lt;code&gt;Watch()&lt;/code&gt; method that makes the provider watch for changes in configuration and trigger a callback to reload the configuration. This is not goroutine safe if there are concurrent &lt;code&gt;*Get()&lt;/code&gt; calls happening on the koanf object while it is doing a &lt;code&gt;Load()&lt;/code&gt;. Such scenarios will need mutex locking.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;file, appconfig, vault, consul&lt;/code&gt; providers have a &lt;code&gt;Watch()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/yaml&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use &#34;.&#34; as the key path delimiter. This can be &#34;/&#34; or any character.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;func main() {&#xA;&#x9;// Load JSON config.&#xA;&#x9;f := file.Provider(&#34;mock/mock.json&#34;)&#xA;&#x9;if err := k.Load(f, json.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;// Load YAML config and merge into the previously loaded config (because we can).&#xA;&#x9;k.Load(file.Provider(&#34;mock/mock.yml&#34;), yaml.Parser())&#xA;&#xA;&#x9;fmt.Println(&#34;parent&#39;s name is = &#34;, k.String(&#34;parent1.name&#34;))&#xA;&#x9;fmt.Println(&#34;parent&#39;s ID is = &#34;, k.Int(&#34;parent1.id&#34;))&#xA;&#xA;&#x9;// Watch the file and get a callback on change. The callback can do whatever,&#xA;&#x9;// like re-load the configuration.&#xA;&#x9;// File provider always returns a nil `event`.&#xA;&#x9;f.Watch(func(event interface{}, err error) {&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Printf(&#34;watch error: %v&#34;, err)&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Throw away the old config and load a fresh copy.&#xA;&#x9;&#x9;log.Println(&#34;config changed. Reloading ...&#34;)&#xA;&#x9;&#x9;k = koanf.New(&#34;.&#34;)&#xA;&#x9;&#x9;k.Load(f, json.Parser())&#xA;&#x9;&#x9;k.Print()&#xA;&#x9;})&#xA;&#xA;&#x9;// Block forever (and manually make a change to mock/mock.json) to&#xA;&#x9;// reload the config.&#xA;&#x9;log.Println(&#34;waiting forever. Try making a change to mock/mock.json to live reload&#34;)&#xA;&#x9;&amp;lt;-make(chan bool)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reading from command line&lt;/h3&gt; &#xA;&lt;p&gt;The following example shows the use of &lt;code&gt;posflag.Provider&lt;/code&gt;, a wrapper over the &lt;a href=&#34;https://github.com/spf13/pflag&#34;&gt;spf13/pflag&lt;/a&gt; library, an advanced commandline lib. For Go&#39;s built in &lt;code&gt;flag&lt;/code&gt; package, use &lt;code&gt;basicflag.Provider&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/toml&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/posflag&#34;&#xA;&#x9;flag &#34;github.com/spf13/pflag&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use &#34;.&#34; as the key path delimiter. This can be &#34;/&#34; or any character.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;func main() {&#xA;&#x9;// Use the POSIX compliant pflag lib instead of Go&#39;s flag lib.&#xA;&#x9;f := flag.NewFlagSet(&#34;config&#34;, flag.ContinueOnError)&#xA;&#x9;f.Usage = func() {&#xA;&#x9;&#x9;fmt.Println(f.FlagUsages())&#xA;&#x9;&#x9;os.Exit(0)&#xA;&#x9;}&#xA;&#x9;// Path to one or more config files to load into koanf along with some config params.&#xA;&#x9;f.StringSlice(&#34;conf&#34;, []string{&#34;mock/mock.toml&#34;}, &#34;path to one or more .toml config files&#34;)&#xA;&#x9;f.String(&#34;time&#34;, &#34;2020-01-01&#34;, &#34;a time string&#34;)&#xA;&#x9;f.String(&#34;type&#34;, &#34;xxx&#34;, &#34;type of the app&#34;)&#xA;&#x9;f.Parse(os.Args[1:])&#xA;&#xA;&#x9;// Load the config files provided in the commandline.&#xA;&#x9;cFiles, _ := f.GetStringSlice(&#34;conf&#34;)&#xA;&#x9;for _, c := range cFiles {&#xA;&#x9;&#x9;if err := k.Load(file.Provider(c), toml.Parser()); err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatalf(&#34;error loading file: %v&#34;, err)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;// &#34;time&#34; and &#34;type&#34; may have been loaded from the config file, but&#xA;&#x9;// they can still be overridden with the values from the command line.&#xA;&#x9;// The bundled posflag.Provider takes a flagset from the spf13/pflag lib.&#xA;&#x9;// Passing the Koanf instance to posflag helps it deal with default command&#xA;&#x9;// line flag values that are not present in conf maps from previously loaded&#xA;&#x9;// providers.&#xA;&#x9;if err := k.Load(posflag.Provider(f, &#34;.&#34;, k), nil); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Println(&#34;time is = &#34;, k.String(&#34;time&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reading environment variables&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;strings&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/env&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use . as the key path delimiter. This can be / or anything.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;func main() {&#xA;&#x9;// Load JSON config.&#xA;&#x9;if err := k.Load(file.Provider(&#34;mock/mock.json&#34;), json.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;// Load environment variables and merge into the loaded config.&#xA;&#x9;// &#34;MYVAR&#34; is the prefix to filter the env vars by.&#xA;&#x9;// &#34;.&#34; is the delimiter used to represent the key hierarchy in env vars.&#xA;&#x9;// The (optional, or can be nil) function can be used to transform&#xA;&#x9;// the env var names, for instance, to lowercase them.&#xA;&#x9;//&#xA;&#x9;// For example, env vars: MYVAR_TYPE and MYVAR_PARENT1_CHILD1_NAME&#xA;&#x9;// will be merged into the &#34;type&#34; and the nested &#34;parent1.child1.name&#34;&#xA;&#x9;// keys in the config file here as we lowercase the key, &#xA;&#x9;// replace `_` with `.` and strip the MYVAR_ prefix so that &#xA;&#x9;// only &#34;parent1.child1.name&#34; remains.&#xA;&#x9;k.Load(env.Provider(&#34;MYVAR_&#34;, &#34;.&#34;, func(s string) string {&#xA;&#x9;&#x9;return strings.Replace(strings.ToLower(&#xA;&#x9;&#x9;&#x9;strings.TrimPrefix(s, &#34;MYVAR_&#34;)), &#34;_&#34;, &#34;.&#34;, -1)&#xA;&#x9;}), nil)&#xA;&#xA;&#x9;fmt.Println(&#34;name is = &#34;, k.String(&#34;parent1.child1.name&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use the &lt;code&gt;env.ProviderWithValue&lt;/code&gt; with a callback that supports mutating both the key and value to return types other than a string. For example, here, env values separated by spaces are returned as string slices or arrays. eg: &lt;code&gt;MYVAR_slice=a b c&lt;/code&gt; becomes &lt;code&gt;slice: [a, b, c]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#x9;k.Load(env.ProviderWithValue(&#34;MYVAR_&#34;, &#34;.&#34;, func(s string, v string) (string, interface{}) {&#xA;&#x9;&#x9;// Strip out the MYVAR_ prefix and lowercase and get the key while also replacing&#xA;&#x9;&#x9;// the _ character with . in the key (koanf delimeter).&#xA;&#x9;&#x9;key := strings.Replace(strings.ToLower(strings.TrimPrefix(s, &#34;MYVAR_&#34;)), &#34;_&#34;, &#34;.&#34;, -1)&#xA;&#xA;&#x9;&#x9;// If there is a space in the value, split the value into a slice by the space.&#xA;&#x9;&#x9;if strings.Contains(v, &#34; &#34;) {&#xA;&#x9;&#x9;&#x9;return key, strings.Split(v, &#34; &#34;)&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Otherwise, return the plain string.&#xA;&#x9;&#x9;return key, v&#xA;&#x9;}), nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reading from an S3 bucket&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Load JSON config from s3.&#xA;if err := k.Load(s3.Provider(s3.Config{&#xA;&#x9;AccessKey: os.Getenv(&#34;AWS_S3_ACCESS_KEY&#34;),&#xA;&#x9;SecretKey: os.Getenv(&#34;AWS_S3_SECRET_KEY&#34;),&#xA;&#x9;Region:    os.Getenv(&#34;AWS_S3_REGION&#34;),&#xA;&#x9;Bucket:    os.Getenv(&#34;AWS_S3_BUCKET&#34;),&#xA;&#x9;ObjectKey: &#34;dir/config.json&#34;,&#xA;}), json.Parser()); err != nil {&#xA;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reading raw bytes&lt;/h3&gt; &#xA;&lt;p&gt;The bundled &lt;code&gt;rawbytes&lt;/code&gt; Provider can be used to read arbitrary bytes from a source, like a database or an HTTP call.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/rawbytes&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use . as the key path delimiter. This can be / or anything.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;func main() {&#xA;&#x9;b := []byte(`{&#34;type&#34;: &#34;rawbytes&#34;, &#34;parent1&#34;: {&#34;child1&#34;: {&#34;type&#34;: &#34;rawbytes&#34;}}}`)&#xA;&#x9;k.Load(rawbytes.Provider(b), json.Parser())&#xA;&#x9;fmt.Println(&#34;type is = &#34;, k.String(&#34;parent1.child1.type&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unmarshalling and marshalling&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Parser&lt;/code&gt;s can be used to unmarshal and scan the values in a Koanf instance into a struct based on the field tags, and to marshal a Koanf instance back into serialized bytes, for example, back to JSON or YAML, to write back to files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use . as the key path delimiter. This can be / or anything.&#xA;var (&#xA;&#x9;k      = koanf.New(&#34;.&#34;)&#xA;&#x9;parser = json.Parser()&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// Load JSON config.&#xA;&#x9;if err := k.Load(file.Provider(&#34;mock/mock.json&#34;), parser); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;// Structure to unmarshal nested conf to.&#xA;&#x9;type childStruct struct {&#xA;&#x9;&#x9;Name       string            `koanf:&#34;name&#34;`&#xA;&#x9;&#x9;Type       string            `koanf:&#34;type&#34;`&#xA;&#x9;&#x9;Empty      map[string]string `koanf:&#34;empty&#34;`&#xA;&#x9;&#x9;GrandChild struct {&#xA;&#x9;&#x9;&#x9;Ids []int `koanf:&#34;ids&#34;`&#xA;&#x9;&#x9;&#x9;On  bool  `koanf:&#34;on&#34;`&#xA;&#x9;&#x9;} `koanf:&#34;grandchild1&#34;`&#xA;&#x9;}&#xA;&#xA;&#x9;var out childStruct&#xA;&#xA;&#x9;// Quick unmarshal.&#xA;&#x9;k.Unmarshal(&#34;parent1.child1&#34;, &amp;amp;out)&#xA;&#x9;fmt.Println(out)&#xA;&#xA;&#x9;// Unmarshal with advanced config.&#xA;&#x9;out = childStruct{}&#xA;&#x9;k.UnmarshalWithConf(&#34;parent1.child1&#34;, &amp;amp;out, koanf.UnmarshalConf{Tag: &#34;koanf&#34;})&#xA;&#x9;fmt.Println(out)&#xA;&#xA;&#x9;// Marshal the instance back to JSON.&#xA;&#x9;// The paser instance can be anything, eg: json.Paser(), yaml.Parser() etc.&#xA;&#x9;b, _ := k.Marshal(parser)&#xA;&#x9;fmt.Println(string(b))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unmarshalling with flat paths&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes it is necessary to unmarshal an assortment of keys from various nested structures into a flat target structure. This is possible with the &lt;code&gt;UnmarshalConf.FlatPaths&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use . as the key path delimiter. This can be / or anything.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;func main() {&#xA;&#x9;// Load JSON config.&#xA;&#x9;if err := k.Load(file.Provider(&#34;mock/mock.json&#34;), json.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;type rootFlat struct {&#xA;&#x9;&#x9;Type                        string            `koanf:&#34;type&#34;`&#xA;&#x9;&#x9;Empty                       map[string]string `koanf:&#34;empty&#34;`&#xA;&#x9;&#x9;Parent1Name                 string            `koanf:&#34;parent1.name&#34;`&#xA;&#x9;&#x9;Parent1ID                   int               `koanf:&#34;parent1.id&#34;`&#xA;&#x9;&#x9;Parent1Child1Name           string            `koanf:&#34;parent1.child1.name&#34;`&#xA;&#x9;&#x9;Parent1Child1Type           string            `koanf:&#34;parent1.child1.type&#34;`&#xA;&#x9;&#x9;Parent1Child1Empty          map[string]string `koanf:&#34;parent1.child1.empty&#34;`&#xA;&#x9;&#x9;Parent1Child1Grandchild1IDs []int             `koanf:&#34;parent1.child1.grandchild1.ids&#34;`&#xA;&#x9;&#x9;Parent1Child1Grandchild1On  bool              `koanf:&#34;parent1.child1.grandchild1.on&#34;`&#xA;&#x9;}&#xA;&#xA;&#x9;// Unmarshal the whole root with FlatPaths: True.&#xA;&#x9;var o1 rootFlat&#xA;&#x9;k.UnmarshalWithConf(&#34;&#34;, &amp;amp;o1, koanf.UnmarshalConf{Tag: &#34;koanf&#34;, FlatPaths: true})&#xA;&#x9;fmt.Println(o1)&#xA;&#xA;&#x9;// Unmarshal a child structure of &#34;parent1&#34;.&#xA;&#x9;type subFlat struct {&#xA;&#x9;&#x9;Name                 string            `koanf:&#34;name&#34;`&#xA;&#x9;&#x9;ID                   int               `koanf:&#34;id&#34;`&#xA;&#x9;&#x9;Child1Name           string            `koanf:&#34;child1.name&#34;`&#xA;&#x9;&#x9;Child1Type           string            `koanf:&#34;child1.type&#34;`&#xA;&#x9;&#x9;Child1Empty          map[string]string `koanf:&#34;child1.empty&#34;`&#xA;&#x9;&#x9;Child1Grandchild1IDs []int             `koanf:&#34;child1.grandchild1.ids&#34;`&#xA;&#x9;&#x9;Child1Grandchild1On  bool              `koanf:&#34;child1.grandchild1.on&#34;`&#xA;&#x9;}&#xA;&#xA;&#x9;var o2 subFlat&#xA;&#x9;k.UnmarshalWithConf(&#34;parent1&#34;, &amp;amp;o2, koanf.UnmarshalConf{Tag: &#34;koanf&#34;, FlatPaths: true})&#xA;&#x9;fmt.Println(o2)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Reading from nested maps&lt;/h4&gt; &#xA;&lt;p&gt;The bundled &lt;code&gt;confmap&lt;/code&gt; provider takes a &lt;code&gt;map[string]interface{}&lt;/code&gt; that can be loaded into a koanf instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/confmap&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/yaml&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use &#34;.&#34; as the key path delimiter. This can be &#34;/&#34; or any character.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;func main() {&#xA;&#x9;// Load default values using the confmap provider.&#xA;&#x9;// We provide a flat map with the &#34;.&#34; delimiter.&#xA;&#x9;// A nested map can be loaded by setting the delimiter to an empty string &#34;&#34;.&#xA;&#x9;k.Load(confmap.Provider(map[string]interface{}{&#xA;&#x9;&#x9;&#34;parent1.name&#34;: &#34;Default Name&#34;,&#xA;&#x9;&#x9;&#34;parent3.name&#34;: &#34;New name here&#34;,&#xA;&#x9;}, &#34;.&#34;), nil)&#xA;&#xA;&#x9;// Load JSON config on top of the default values.&#xA;&#x9;if err := k.Load(file.Provider(&#34;mock/mock.json&#34;), json.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;// Load YAML config and merge into the previously loaded config (because we can).&#xA;&#x9;k.Load(file.Provider(&#34;mock/mock.yml&#34;), yaml.Parser())&#xA;&#xA;&#x9;fmt.Println(&#34;parent&#39;s name is = &#34;, k.String(&#34;parent1.name&#34;))&#xA;&#x9;fmt.Println(&#34;parent&#39;s ID is = &#34;, k.Int(&#34;parent1.id&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Reading from struct&lt;/h4&gt; &#xA;&lt;p&gt;The bundled &lt;code&gt;structs&lt;/code&gt; provider can be used to read data from a struct to load into a koanf instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/structs&#34;&#xA;)&#xA;&#xA;// Global koanf instance. Use &#34;.&#34; as the key path delimiter. This can be &#34;/&#34; or any character.&#xA;var k = koanf.New(&#34;.&#34;)&#xA;&#xA;type parentStruct struct {&#xA;&#x9;Name   string      `koanf:&#34;name&#34;`&#xA;&#x9;ID     int         `koanf:&#34;id&#34;`&#xA;&#x9;Child1 childStruct `koanf:&#34;child1&#34;`&#xA;}&#xA;type childStruct struct {&#xA;&#x9;Name        string            `koanf:&#34;name&#34;`&#xA;&#x9;Type        string            `koanf:&#34;type&#34;`&#xA;&#x9;Empty       map[string]string `koanf:&#34;empty&#34;`&#xA;&#x9;Grandchild1 grandchildStruct  `koanf:&#34;grandchild1&#34;`&#xA;}&#xA;type grandchildStruct struct {&#xA;&#x9;Ids []int `koanf:&#34;ids&#34;`&#xA;&#x9;On  bool  `koanf:&#34;on&#34;`&#xA;}&#xA;type sampleStruct struct {&#xA;&#x9;Type    string            `koanf:&#34;type&#34;`&#xA;&#x9;Empty   map[string]string `koanf:&#34;empty&#34;`&#xA;&#x9;Parent1 parentStruct      `koanf:&#34;parent1&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;// Load default values using the structs provider.&#xA;&#x9;// We provide a struct along with the struct tag `koanf` to the&#xA;&#x9;// provider.&#xA;&#x9;k.Load(structs.Provider(sampleStruct{&#xA;&#x9;&#x9;Type:  &#34;json&#34;,&#xA;&#x9;&#x9;Empty: make(map[string]string),&#xA;&#x9;&#x9;Parent1: parentStruct{&#xA;&#x9;&#x9;&#x9;Name: &#34;parent1&#34;,&#xA;&#x9;&#x9;&#x9;ID:   1234,&#xA;&#x9;&#x9;&#x9;Child1: childStruct{&#xA;&#x9;&#x9;&#x9;&#x9;Name:  &#34;child1&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;Type:  &#34;json&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;Empty: make(map[string]string),&#xA;&#x9;&#x9;&#x9;&#x9;Grandchild1: grandchildStruct{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Ids: []int{1, 2, 3},&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;On:  true,&#xA;&#x9;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;},&#xA;&#x9;}, &#34;koanf&#34;), nil)&#xA;&#xA;&#x9;fmt.Printf(&#34;name is = `%s`\n&#34;, k.String(&#34;parent1.child1.name&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Merge behavior&lt;/h3&gt; &#xA;&lt;h4&gt;Default behavior&lt;/h4&gt; &#xA;&lt;p&gt;The default behavior when you create Koanf this way is: &lt;code&gt;koanf.New(delim)&lt;/code&gt; that the latest loaded configuration will merge with the previous one.&lt;/p&gt; &#xA;&lt;p&gt;For example: &lt;code&gt;first.yml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;key: [1,2,3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;second.yml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;key: &#39;string&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When &lt;code&gt;second.yml&lt;/code&gt; is loaded it will override the type of the &lt;code&gt;first.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If this behavior is not desired, you can merge &#39;strictly&#39;. In the same scenario, &lt;code&gt;Load&lt;/code&gt; will return an error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;errors&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/maps&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/yaml&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;)&#xA;&#xA;var conf = koanf.Conf{&#xA;&#x9;Delim:       &#34;.&#34;,&#xA;&#x9;StrictMerge: true,&#xA;}&#xA;var k = koanf.NewWithConf(conf)&#xA;&#xA;func main() {&#xA;&#x9;yamlPath := &#34;mock/mock.yml&#34;&#xA;&#x9;if err := k.Load(file.Provider(yamlPath), yaml.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;jsonPath := &#34;mock/mock.json&#34;&#xA;&#x9;if err := k.Load(file.Provider(jsonPath), json.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; When merging different extensions, each parser can treat his types differently, meaning even though you the load same types there is a probability that it will fail with &lt;code&gt;StrictMerge: true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example: merging JSON and YAML will most likely fail because JSON treats integers as float64 and YAML treats them as integers.&lt;/p&gt; &#xA;&lt;h3&gt;Order of merge and key case sensitivity&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Config keys are case-sensitive in koanf. For example, &lt;code&gt;app.server.port&lt;/code&gt; and &lt;code&gt;APP.SERVER.port&lt;/code&gt; are not the same.&lt;/li&gt; &#xA; &lt;li&gt;koanf does not impose any ordering on loading config from various providers. Every successive &lt;code&gt;Load()&lt;/code&gt; or &lt;code&gt;Merge()&lt;/code&gt; merges new config into the existing config. That is, it is possible to load environment variables first, then files on top of it, and then command line variables on top of it, or any such order.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Custom Providers and Parsers&lt;/h3&gt; &#xA;&lt;p&gt;A Provider returns a nested &lt;code&gt;map[string]interface{}&lt;/code&gt; config that can be loaded directly into koanf with &lt;code&gt;koanf.Load()&lt;/code&gt; or it can return raw bytes that can be parsed with a Parser (again, loaded using &lt;code&gt;koanf.Load()&lt;/code&gt;. Writing Providers and Parsers are easy. See the bundled implementations in the &lt;a href=&#34;https://github.com/knadh/koanf/tree/master/providers&#34;&gt;providers&lt;/a&gt; and &lt;a href=&#34;https://github.com/knadh/koanf/tree/master/parsers&#34;&gt;parsers&lt;/a&gt; directories.&lt;/p&gt; &#xA;&lt;h3&gt;Custom merge strategies&lt;/h3&gt; &#xA;&lt;p&gt;By default, when merging two config sources using &lt;code&gt;Load()&lt;/code&gt;, koanf recursively merges keys of nested maps (&lt;code&gt;map[string]interface{}&lt;/code&gt;), while static values are overwritten (slices, strings, etc). This behaviour can be changed by providing a custom merge function with the &lt;code&gt;WithMergeFunc&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;errors&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/knadh/koanf/v2&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/maps&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/json&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/parsers/yaml&#34;&#xA;&#x9;&#34;github.com/knadh/koanf/providers/file&#34;&#xA;)&#xA;&#xA;var conf = koanf.Conf{&#xA;&#x9;Delim:       &#34;.&#34;,&#xA;&#x9;StrictMerge: true,&#xA;}&#xA;var k = koanf.NewWithConf(conf)&#xA;&#xA;func main() {&#xA;&#x9;yamlPath := &#34;mock/mock.yml&#34;&#xA;&#x9;if err := k.Load(file.Provider(yamlPath), yaml.Parser()); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;&#xA;&#x9;jsonPath := &#34;mock/mock.json&#34;&#xA;&#x9;if err := k.Load(file.Provider(jsonPath), json.Parser(), koanf.WithMergeFunc(func(src, dest map[string]interface{}) error {&#xA;     // Your custom logic, copying values from src into dst&#xA;     return nil&#xA;    })); err != nil {&#xA;&#x9;&#x9;log.Fatalf(&#34;error loading config: %v&#34;, err)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;See the full API documentation of all available methods at &lt;a href=&#34;https://pkg.go.dev/github.com/knadh/koanf/v2#section-documentation&#34;&gt;https://pkg.go.dev/github.com/knadh/koanf/v2#section-documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Bundled Providers&lt;/h3&gt; &#xA;&lt;p&gt;Install with &lt;code&gt;go get -u github.com/knadh/koanf/providers/$provider&lt;/code&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Package&lt;/th&gt; &#xA;   &lt;th&gt;Provider&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;file&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;file.Provider(filepath string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Reads a file and returns the raw bytes to be parsed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;fs&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;fs.Provider(f fs.FS, filepath string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(&lt;strong&gt;Experimental&lt;/strong&gt;) Reads a file from fs.FS and returns the raw bytes to be parsed. The provider requires &lt;code&gt;go v1.16&lt;/code&gt; or higher.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;basicflag&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;basicflag.Provider(f *flag.FlagSet, delim string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes an stdlib &lt;code&gt;flag.FlagSet&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;posflag&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;posflag.Provider(f *pflag.FlagSet, delim string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes an &lt;code&gt;spft3/pflag.FlagSet&lt;/code&gt; (advanced POSIX compatible flags with multiple types) and provides a nested config map based on delim.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;env&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;env.Provider(prefix, delim string, f func(s string) string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes an optional prefix to filter env variables by, an optional function that takes and returns a string to transform env variables, and returns a nested config map based on delim.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;confmap&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;confmap.Provider(mp map[string]interface{}, delim string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes a premade &lt;code&gt;map[string]interface{}&lt;/code&gt; conf map. If delim is provided, the keys are assumed to be flattened, thus unflattened using delim.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;structs&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;structs.Provider(s interface{}, tag string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes a struct and struct tag.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;s3&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;s3.Provider(s3.S3Config{})&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes a s3 config struct.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;rawbytes&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;rawbytes.Provider(b []byte)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes a raw &lt;code&gt;[]byte&lt;/code&gt; slice to be parsed with a koanf.Parser&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;vault&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;vault.Provider(vault.Config{})&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Hashicorp Vault provider&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;appconfig&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;vault.AppConfig(appconfig.Config{})&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AWS AppConfig provider&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;etcd&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;etcd.Provider(etcd.Config{})&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CNCF etcd provider&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;consul&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;consul.Provider(consul.Config{})&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Hashicorp Consul provider&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Bundled Parsers&lt;/h3&gt; &#xA;&lt;p&gt;Install with &lt;code&gt;go get -u github.com/knadh/koanf/parsers/$parser&lt;/code&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Package&lt;/th&gt; &#xA;   &lt;th&gt;Parser&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;json&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;json.Parser()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parses JSON bytes into a nested map&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;yaml&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;yaml.Parser()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parses YAML bytes into a nested map&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;toml&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toml.Parser()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parses TOML bytes into a nested map&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dotenv&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;dotenv.Parser()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parses DotEnv bytes into a flat map&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;hcl&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;hcl.Parser(flattenSlices bool)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parses Hashicorp HCL bytes into a nested map. &lt;code&gt;flattenSlices&lt;/code&gt; is recommended to be set to true. &lt;a href=&#34;https://github.com/hashicorp/hcl/issues/162&#34;&gt;Read more&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;nestedtext&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nestedtext.Parser()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parses NestedText bytes into a flat map&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;hjson&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;hjson.Parser()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parses HJSON bytes into a nested map&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;|&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Third-party Providers&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Package&lt;/th&gt; &#xA;   &lt;th&gt;Provider&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;github.com/defensestation/koanf/providers/secretsmanager&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;vault.SecretsMananger(secretsmanager.Config{}, f func(s string) string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AWS Secrets Manager provider, takes map or string as a value from store&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;github.com/defensestation/koanf/providers/parameterstore&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;vault.ParameterStore(parameterstore.Config{}, f func(s string) string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AWS ParameterStore provider, an optional function that takes and returns a string to transform env variables&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Alternative to viper&lt;/h3&gt; &#xA;&lt;p&gt;koanf is a lightweight alternative to the popular &lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;spf13/viper&lt;/a&gt;. It was written as a result of multiple stumbling blocks encountered with some of viper&#39;s fundamental flaws.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;viper breaks JSON, YAML, TOML, HCL language specs by &lt;a href=&#34;https://github.com/spf13/viper/pull/635&#34;&gt;forcibly lowercasing keys&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Significantly bloats &lt;a href=&#34;https://github.com/knadh/koanf/wiki/Comparison-with-spf13-viper&#34;&gt;build sizes&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Tightly couples config parsing with file extensions.&lt;/li&gt; &#xA; &lt;li&gt;Has poor semantics and abstractions. Commandline, env, file etc. and various parses are hardcoded in the core. There are no primitives that can be extended.&lt;/li&gt; &#xA; &lt;li&gt;Pulls a large number of &lt;a href=&#34;https://github.com/spf13/viper/issues/707&#34;&gt;third party dependencies&lt;/a&gt; into the core package. For instance, even if you do not use YAML or flags, the dependencies are still pulled as a result of the coupling.&lt;/li&gt; &#xA; &lt;li&gt;Imposes arbitrary ordering conventions (eg: flag -&amp;gt; env -&amp;gt; config etc.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get()&lt;/code&gt; returns references to slices and maps. Mutations made outside change the underlying values inside the conf map.&lt;/li&gt; &#xA; &lt;li&gt;Does non-idiomatic things such as &lt;a href=&#34;https://github.com/spf13/viper/raw/3b4aca75714a37276c4b1883630bd98c02498b73/viper.go#L1524&#34;&gt;throwing away O(1) on flat maps&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Viper treats keys that contain an empty map (eg: &lt;code&gt;my_key: {}&lt;/code&gt;) as if they were not set (ie: &lt;code&gt;IsSet(&#34;my_key&#34;) == false&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;There are a large number of &lt;a href=&#34;https://github.com/spf13/viper/issues&#34;&gt;open issues&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>OwO-Network/DeepLX</title>
    <updated>2023-02-27T01:35:52Z</updated>
    <id>tag:github.com,2023-02-27:/OwO-Network/DeepLX</id>
    <link href="https://github.com/OwO-Network/DeepLX" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DeepL Free API (No TOKEN required)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DeepL X&lt;/h1&gt; &#xA;&lt;p&gt;Permanently free DeepL API written in Golang&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;deeplx&lt;/code&gt; in only run in port &lt;code&gt;1188&lt;/code&gt;, later versions will do the specified port.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deeplx&lt;/code&gt; is listening to &lt;code&gt;0.0.0.0:1188&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deeplx&lt;/code&gt; is using &lt;code&gt;DeepL&lt;/code&gt; Free API.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deeplx&lt;/code&gt; is unlimited to the number of requests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Request Parameters&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;text: string&lt;/li&gt; &#xA; &lt;li&gt;source_lang: string&lt;/li&gt; &#xA; &lt;li&gt;target_lang: string&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;code&#34;: 200,&#xA;  &#34;data&#34;: &#34;Hello world&#34;,&#xA;  &#34;id&#34;: 8305092005&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run on Linux Server&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash &amp;lt;(curl -Ls https://cpp.li/deeplx)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run on Mac&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the latest release of DeepL X.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo mv deeplx_darwin_amd64 /usr/local/bin/deeplx&#xA;sudo chmod +x /usr/local/bin/deeplx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Download the &lt;code&gt;me.missuo.deeplx.plist&lt;/code&gt; to &lt;code&gt;~/Library/LaunchAgents&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://raw.githubusercontent.com/OwO-Network/DeepLX/main/me.missuo.deeplx.plist -O ~/Library/LaunchAgents/me.missuo.deeplx.plist&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Run following command.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;launchctl load ~/Library/LaunchAgents/me.missuo.deeplx.plist&#xA;launchctl start ~/Library/LaunchAgents/me.missuo.deeplx.plist&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install from AUR&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;paru -S deeplx-bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After installation, start the daemon with the following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl daemon-reload&#xA;systemctl enable deeplx&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Setup on &lt;a href=&#34;https://bobtranslate.com/&#34;&gt;Bob App&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;a href=&#34;https://github.com/clubxdev/bob-plugin-deeplx&#34;&gt;bob-plugin-deeplx&lt;/a&gt; on Bob.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Setup the API. &lt;img src=&#34;https://missuo.ru/file/c5c19dd89df6fae1a256d.png&#34; alt=&#34;c5c19dd89df6fae1a256d&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Backup the Docker Image of zu1k&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -itd -p 1188:80 missuo/deeplx-bk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;This docker image is not related to this project, as the original author deleted the image, it is only for backup.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;DeepL X&lt;/strong&gt; ¬© &lt;a href=&#34;https://github.com/OwO-Network/DeepLX/graphs/contributors&#34;&gt;DeepL X Contributors&lt;/a&gt;, Released under the &lt;a href=&#34;https://raw.githubusercontent.com/OwO-Network/DeepLX/main/LICENSE&#34;&gt;MIT&lt;/a&gt; License.&lt;br&gt;&lt;/p&gt;</summary>
  </entry>
</feed>