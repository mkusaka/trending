<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-23T01:34:10Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>riverqueue/river</title>
    <updated>2023-11-23T01:34:10Z</updated>
    <id>tag:github.com,2023-11-23:/riverqueue/river</id>
    <link href="https://github.com/riverqueue/river" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast and reliable background jobs in Go&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;River &lt;a href=&#34;https://github.com/riverqueue/river/actions&#34;&gt;&lt;img src=&#34;https://github.com/riverqueue/river/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/riverqueue/river&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/riverqueue/river.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;River is a robust high-performance job processing system for Go and Postgres.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://riverqueue.com&#34;&gt;homepage&lt;/a&gt;, &lt;a href=&#34;https://riverqueue.com/docs&#34;&gt;docs&lt;/a&gt;, and &lt;a href=&#34;https://pkg.go.dev/github.com/riverqueue/river&#34;&gt;godoc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Being built for Postgres, River encourages the use of the same database for application data and job queue. By enqueueing jobs transactionally along with other database changes, whole classes of distributed systems problems are avoided. Jobs are guaranteed to be enqueued if their transaction commits, are removed if their transaction rolls back, and aren&#39;t visible for work &lt;em&gt;until&lt;/em&gt; commit. See &lt;a href=&#34;https://riverqueue.com/docs/transactional-enqueueing&#34;&gt;transactional enqueueing&lt;/a&gt; for more background on this philosophy.&lt;/p&gt; &#xA;&lt;h2&gt;Job args and workers&lt;/h2&gt; &#xA;&lt;p&gt;Jobs are defined in struct pairs, with an implementation of &lt;a href=&#34;https://pkg.go.dev/github.com/riverqueue/river#JobArgs&#34;&gt;&lt;code&gt;JobArgs&lt;/code&gt;&lt;/a&gt; and one of &lt;a href=&#34;https://pkg.go.dev/github.com/riverqueue/river#Worker&#34;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Job args contain &lt;code&gt;json&lt;/code&gt; annotations and define how jobs are serialized to and from the database, along with a &#34;kind&#34;, a stable string that uniquely identifies the job.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type SortArgs struct {&#xA;    // Strings is a slice of strings to sort.&#xA;    Strings []string `json:&#34;strings&#34;`&#xA;}&#xA;&#xA;func (SortArgs) Kind() string { return &#34;sort&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Workers expose a &lt;code&gt;Work&lt;/code&gt; function that dictates how jobs run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type SortWorker struct {&#xA;    // An embedded WorkerDefaults sets up default methods to fulfill the rest of&#xA;    // the Worker interface:&#xA;    river.WorkerDefaults[SortArgs]&#xA;}&#xA;&#xA;func (w *SortWorker) Work(ctx context.Context, job *river.Job[SortArgs]) error {&#xA;    sort.Strings(job.Args.Strings)&#xA;    fmt.Printf(&#34;Sorted strings: %+v\n&#34;, job.Args.Strings)&#xA;    return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Registering workers&lt;/h2&gt; &#xA;&lt;p&gt;Jobs are uniquely identified by their &#34;kind&#34; string. Workers are registered on start up so that River knows how to assign jobs to workers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;workers := river.NewWorkers()&#xA;// AddWorker panics if the worker is already registered or invalid:&#xA;river.AddWorker(workers, &amp;amp;SortWorker{})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Starting a client&lt;/h2&gt; &#xA;&lt;p&gt;A River &lt;a href=&#34;https://pkg.go.dev/github.com/riverqueue/river#Client&#34;&gt;&lt;code&gt;Client&lt;/code&gt;&lt;/a&gt; provides an interface for job insertion and manages job processing and &lt;a href=&#34;https://riverqueue.com/docs/maintenance-services&#34;&gt;maintenance services&lt;/a&gt;. A client&#39;s created with a database pool, &lt;a href=&#34;https://riverqueue.com/docs/database-drivers&#34;&gt;driver&lt;/a&gt;, and config struct containing a &lt;code&gt;Workers&lt;/code&gt; bundle and other settings. Here&#39;s a client &lt;code&gt;Client&lt;/code&gt; working one queue (&lt;code&gt;&#34;default&#34;&lt;/code&gt;) with up to 100 worker goroutines at a time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;riverClient, err := river.NewClient(riverpgxv5.New(dbPool), &amp;amp;river.Config{&#xA;    Queues: map[string]river.QueueConfig{&#xA;        river.DefaultQueue: {MaxWorkers: 100},&#xA;    },&#xA;    Workers: workers,&#xA;})&#xA;&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;&#xA;// Run the client inline. All executed jobs will inherit from ctx:&#xA;if err := riverClient.Start(ctx); err != nil {&#xA;    panic(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stopping&lt;/h3&gt; &#xA;&lt;p&gt;The client should also be stopped on program shutdown:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Stop fetching new work and wait for active jobs to finish.&#xA;if err := riverClient.Stop(ctx); err != nil {&#xA;    panic(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are some complexities around ensuring clients stop cleanly, but also in a timely manner. See &lt;a href=&#34;https://riverqueue.com/docs/graceful-shutdown&#34;&gt;graceful shutdown&lt;/a&gt; for more details on River&#39;s stop modes.&lt;/p&gt; &#xA;&lt;h2&gt;Inserting jobs&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/riverqueue/river#Client.InsertTx&#34;&gt;&lt;code&gt;Client.InsertTx&lt;/code&gt;&lt;/a&gt; is used in conjunction with an instance of job args to insert a job to work on a transaction:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_, err = riverClient.InsertTx(ctx, tx, SortArgs{&#xA;    Strings: []string{&#xA;        &#34;whale&#34;, &#34;tiger&#34;, &#34;bear&#34;,&#xA;    },&#xA;}, nil)&#xA;&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://pkg.go.dev/github.com/riverqueue/river#example-package-InsertAndWork&#34;&gt;&lt;code&gt;InsertAndWork&lt;/code&gt; example&lt;/a&gt; for complete code.&lt;/p&gt; &#xA;&lt;h2&gt;Other features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/batch-job-insertion&#34;&gt;Batch job insertion&lt;/a&gt; for efficiently inserting many jobs at once using Postgres &lt;code&gt;COPY FROM&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/cancelling-jobs&#34;&gt;Cancelling jobs&lt;/a&gt; from inside a work function.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/error-handling&#34;&gt;Error and panic handling&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/periodic-jobs&#34;&gt;Periodic and cron jobs&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/snoozing-jobs&#34;&gt;Snoozing jobs&lt;/a&gt; from inside a work function.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/subscriptions&#34;&gt;Subscriptions&lt;/a&gt; to queue activity and statistics, providing easy hooks for telemetry like logging and metrics.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/transactional-job-completion&#34;&gt;Transactional job completion&lt;/a&gt; to guarantee job completion commits with other changes in a transaction.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/unique-jobs&#34;&gt;Unique jobs&lt;/a&gt; by args, period, queue, and state.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://riverqueue.com/docs/work-functions&#34;&gt;Work functions&lt;/a&gt; for simplified worker implementation.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/riverqueue/river/raw/master/docs/development.md&#34;&gt;developing River&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Thank you&lt;/h2&gt; &#xA;&lt;p&gt;River was in large part inspired by our experiences with other background job libaries over the years, most notably:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sorentwo/oban&#34;&gt;Oban&lt;/a&gt; in Elixir&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/que-rb/que&#34;&gt;que&lt;/a&gt;, &lt;a href=&#34;https://github.com/sidekiq/sidekiq&#34;&gt;sidekiq&lt;/a&gt;, &lt;a href=&#34;https://github.com/collectiveidea/delayed_job&#34;&gt;delayed_job&lt;/a&gt;, and &lt;a href=&#34;https://github.com/bensheldon/good_job&#34;&gt;GoodJob&lt;/a&gt; in Ruby&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.hangfire.io/&#34;&gt;Hangfire&lt;/a&gt; in .NET&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thank you for driving the software ecosystem forward.&lt;/p&gt;</summary>
  </entry>
</feed>