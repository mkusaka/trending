<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-29T01:31:48Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>valyala/fasthttp</title>
    <updated>2022-12-29T01:31:48Z</updated>
    <id>tag:github.com,2022-12-29:/valyala/fasthttp</id>
    <link href="https://github.com/valyala/fasthttp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast HTTP package for Go. Tuned for high performance. Zero memory allocations in hot paths. Up to 10x faster than net/http&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;fasthttp &lt;a href=&#34;http://godoc.org/github.com/valyala/fasthttp&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/valyala/fasthttp?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/valyala/fasthttp&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/valyala/fasthttp&#34; alt=&#34;Go Report&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/fasthttp/docs-assets/raw/master/banner@0.5.png&#34; alt=&#34;FastHTTP –&amp;nbsp;Fastest and reliable HTTP implementation in Go&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Fast HTTP implementation for Go.&lt;/p&gt; &#xA;&lt;h1&gt;fasthttp might not be for you!&lt;/h1&gt; &#xA;&lt;p&gt;fasthttp was design for some high performance edge cases. &lt;strong&gt;Unless&lt;/strong&gt; your server/client needs to handle &lt;strong&gt;thousands of small to medium requests per seconds&lt;/strong&gt; and needs a consistent low millisecond response time fasthttp might not be for you. &lt;strong&gt;For most cases &lt;code&gt;net/http&lt;/code&gt; is much better&lt;/strong&gt; as it&#39;s easier to use and can handle more cases. For most cases you won&#39;t even notice the performance difference.&lt;/p&gt; &#xA;&lt;h2&gt;General info and links&lt;/h2&gt; &#xA;&lt;p&gt;Currently fasthttp is successfully used by &lt;a href=&#34;https://vertamedia.com/&#34;&gt;VertaMedia&lt;/a&gt; in a production serving up to 200K rps from more than 1.5M concurrent keep-alive connections per physical server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.techempower.com/benchmarks/#section=data-r19&amp;amp;hw=ph&amp;amp;test=plaintext&#34;&gt;TechEmpower Benchmark round 19 results&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#http-server-performance-comparison-with-nethttp&#34;&gt;Server Benchmarks&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#http-client-comparison-with-nethttp&#34;&gt;Client Benchmarks&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#install&#34;&gt;Install&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#pkg-examples&#34;&gt;Examples from docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/examples&#34;&gt;Code examples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fasthttp&#34;&gt;Awesome fasthttp tools&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#switching-from-nethttp-to-fasthttp&#34;&gt;Switching from net/http to fasthttp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#fasthttp-best-practices&#34;&gt;Fasthttp best practices&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#tricks-with-byte-buffers&#34;&gt;Tricks with byte buffers&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#related-projects&#34;&gt;Related projects&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;HTTP server performance comparison with &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;net/http&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;In short, fasthttp server is up to 10 times faster than net/http. Below are benchmark results.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;GOMAXPROCS=1&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;net/http server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=1 go test -bench=NetHTTPServerGet -benchmem -benchtime=10s&#xA;BenchmarkNetHTTPServerGet1ReqPerConn                &#x9; 1000000&#x9;     12052 ns/op&#x9;    2297 B/op&#x9;      29 allocs/op&#xA;BenchmarkNetHTTPServerGet2ReqPerConn                &#x9; 1000000&#x9;     12278 ns/op&#x9;    2327 B/op&#x9;      24 allocs/op&#xA;BenchmarkNetHTTPServerGet10ReqPerConn               &#x9; 2000000&#x9;      8903 ns/op&#x9;    2112 B/op&#x9;      19 allocs/op&#xA;BenchmarkNetHTTPServerGet10KReqPerConn              &#x9; 2000000&#x9;      8451 ns/op&#x9;    2058 B/op&#x9;      18 allocs/op&#xA;BenchmarkNetHTTPServerGet1ReqPerConn10KClients      &#x9;  500000&#x9;     26733 ns/op&#x9;    3229 B/op&#x9;      29 allocs/op&#xA;BenchmarkNetHTTPServerGet2ReqPerConn10KClients      &#x9; 1000000&#x9;     23351 ns/op&#x9;    3211 B/op&#x9;      24 allocs/op&#xA;BenchmarkNetHTTPServerGet10ReqPerConn10KClients     &#x9; 1000000&#x9;     13390 ns/op&#x9;    2483 B/op&#x9;      19 allocs/op&#xA;BenchmarkNetHTTPServerGet100ReqPerConn10KClients    &#x9; 1000000&#x9;     13484 ns/op&#x9;    2171 B/op&#x9;      18 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;fasthttp server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=1 go test -bench=kServerGet -benchmem -benchtime=10s&#xA;BenchmarkServerGet1ReqPerConn                       &#x9;10000000&#x9;      1559 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet2ReqPerConn                       &#x9;10000000&#x9;      1248 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet10ReqPerConn                      &#x9;20000000&#x9;       797 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet10KReqPerConn                     &#x9;20000000&#x9;       716 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet1ReqPerConn10KClients             &#x9;10000000&#x9;      1974 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet2ReqPerConn10KClients             &#x9;10000000&#x9;      1352 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet10ReqPerConn10KClients            &#x9;20000000&#x9;       789 ns/op&#x9;       2 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet100ReqPerConn10KClients           &#x9;20000000&#x9;       604 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;GOMAXPROCS=4&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;net/http server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=4 go test -bench=NetHTTPServerGet -benchmem -benchtime=10s&#xA;BenchmarkNetHTTPServerGet1ReqPerConn-4                  &#x9; 3000000&#x9;      4529 ns/op&#x9;    2389 B/op&#x9;      29 allocs/op&#xA;BenchmarkNetHTTPServerGet2ReqPerConn-4                  &#x9; 5000000&#x9;      3896 ns/op&#x9;    2418 B/op&#x9;      24 allocs/op&#xA;BenchmarkNetHTTPServerGet10ReqPerConn-4                 &#x9; 5000000&#x9;      3145 ns/op&#x9;    2160 B/op&#x9;      19 allocs/op&#xA;BenchmarkNetHTTPServerGet10KReqPerConn-4                &#x9; 5000000&#x9;      3054 ns/op&#x9;    2065 B/op&#x9;      18 allocs/op&#xA;BenchmarkNetHTTPServerGet1ReqPerConn10KClients-4        &#x9; 1000000&#x9;     10321 ns/op&#x9;    3710 B/op&#x9;      30 allocs/op&#xA;BenchmarkNetHTTPServerGet2ReqPerConn10KClients-4        &#x9; 2000000&#x9;      7556 ns/op&#x9;    3296 B/op&#x9;      24 allocs/op&#xA;BenchmarkNetHTTPServerGet10ReqPerConn10KClients-4       &#x9; 5000000&#x9;      3905 ns/op&#x9;    2349 B/op&#x9;      19 allocs/op&#xA;BenchmarkNetHTTPServerGet100ReqPerConn10KClients-4      &#x9; 5000000&#x9;      3435 ns/op&#x9;    2130 B/op&#x9;      18 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;fasthttp server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=4 go test -bench=kServerGet -benchmem -benchtime=10s&#xA;BenchmarkServerGet1ReqPerConn-4                         &#x9;10000000&#x9;      1141 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet2ReqPerConn-4                         &#x9;20000000&#x9;       707 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet10ReqPerConn-4                        &#x9;30000000&#x9;       341 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet10KReqPerConn-4                       &#x9;50000000&#x9;       310 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet1ReqPerConn10KClients-4               &#x9;10000000&#x9;      1119 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet2ReqPerConn10KClients-4               &#x9;20000000&#x9;       644 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet10ReqPerConn10KClients-4              &#x9;30000000&#x9;       346 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkServerGet100ReqPerConn10KClients-4             &#x9;50000000&#x9;       282 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;HTTP client comparison with net/http&lt;/h2&gt; &#xA;&lt;p&gt;In short, fasthttp client is up to 10 times faster than net/http. Below are benchmark results.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;GOMAXPROCS=1&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;net/http client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=1 go test -bench=&#39;HTTPClient(Do|GetEndToEnd)&#39; -benchmem -benchtime=10s&#xA;BenchmarkNetHTTPClientDoFastServer                  &#x9; 1000000&#x9;     12567 ns/op&#x9;    2616 B/op&#x9;      35 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd1TCP               &#x9;  200000&#x9;     67030 ns/op&#x9;    5028 B/op&#x9;      56 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd10TCP              &#x9;  300000&#x9;     51098 ns/op&#x9;    5031 B/op&#x9;      56 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd100TCP             &#x9;  300000&#x9;     45096 ns/op&#x9;    5026 B/op&#x9;      55 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd1Inmemory          &#x9;  500000&#x9;     24779 ns/op&#x9;    5035 B/op&#x9;      57 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd10Inmemory         &#x9; 1000000&#x9;     26425 ns/op&#x9;    5035 B/op&#x9;      57 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd100Inmemory        &#x9;  500000&#x9;     28515 ns/op&#x9;    5045 B/op&#x9;      57 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd1000Inmemory       &#x9;  500000&#x9;     39511 ns/op&#x9;    5096 B/op&#x9;      56 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;fasthttp client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=1 go test -bench=&#39;kClient(Do|GetEndToEnd)&#39; -benchmem -benchtime=10s&#xA;BenchmarkClientDoFastServer                         &#x9;20000000&#x9;       865 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd1TCP                      &#x9; 1000000&#x9;     18711 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd10TCP                     &#x9; 1000000&#x9;     14664 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd100TCP                    &#x9; 1000000&#x9;     14043 ns/op&#x9;       1 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd1Inmemory                 &#x9; 5000000&#x9;      3965 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd10Inmemory                &#x9; 3000000&#x9;      4060 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd100Inmemory               &#x9; 5000000&#x9;      3396 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd1000Inmemory              &#x9; 5000000&#x9;      3306 ns/op&#x9;       2 B/op&#x9;       0 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;GOMAXPROCS=4&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;net/http client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=4 go test -bench=&#39;HTTPClient(Do|GetEndToEnd)&#39; -benchmem -benchtime=10s&#xA;BenchmarkNetHTTPClientDoFastServer-4                    &#x9; 2000000&#x9;      8774 ns/op&#x9;    2619 B/op&#x9;      35 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd1TCP-4                 &#x9;  500000&#x9;     22951 ns/op&#x9;    5047 B/op&#x9;      56 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd10TCP-4                &#x9; 1000000&#x9;     19182 ns/op&#x9;    5037 B/op&#x9;      55 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd100TCP-4               &#x9; 1000000&#x9;     16535 ns/op&#x9;    5031 B/op&#x9;      55 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd1Inmemory-4            &#x9; 1000000&#x9;     14495 ns/op&#x9;    5038 B/op&#x9;      56 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd10Inmemory-4           &#x9; 1000000&#x9;     10237 ns/op&#x9;    5034 B/op&#x9;      56 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd100Inmemory-4          &#x9; 1000000&#x9;     10125 ns/op&#x9;    5045 B/op&#x9;      56 allocs/op&#xA;BenchmarkNetHTTPClientGetEndToEnd1000Inmemory-4         &#x9; 1000000&#x9;     11132 ns/op&#x9;    5136 B/op&#x9;      56 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;fasthttp client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GOMAXPROCS=4 go test -bench=&#39;kClient(Do|GetEndToEnd)&#39; -benchmem -benchtime=10s&#xA;BenchmarkClientDoFastServer-4                           &#x9;50000000&#x9;       397 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd1TCP-4                        &#x9; 2000000&#x9;      7388 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd10TCP-4                       &#x9; 2000000&#x9;      6689 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd100TCP-4                      &#x9; 3000000&#x9;      4927 ns/op&#x9;       1 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd1Inmemory-4                   &#x9;10000000&#x9;      1604 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd10Inmemory-4                  &#x9;10000000&#x9;      1458 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd100Inmemory-4                 &#x9;10000000&#x9;      1329 ns/op&#x9;       0 B/op&#x9;       0 allocs/op&#xA;BenchmarkClientGetEndToEnd1000Inmemory-4                &#x9;10000000&#x9;      1316 ns/op&#x9;       5 B/op&#x9;       0 allocs/op&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/valyala/fasthttp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Switching from net/http to fasthttp&lt;/h2&gt; &#xA;&lt;p&gt;Unfortunately, fasthttp doesn&#39;t provide API identical to net/http. See the &lt;a href=&#34;https://raw.githubusercontent.com/valyala/fasthttp/master/#faq&#34;&gt;FAQ&lt;/a&gt; for details. There is &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp/fasthttpadaptor&#34;&gt;net/http -&amp;gt; fasthttp handler converter&lt;/a&gt;, but it is better to write fasthttp request handlers by hand in order to use all of the fasthttp advantages (especially high performance :) ).&lt;/p&gt; &#xA;&lt;p&gt;Important points:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Fasthttp works with &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHandler&#34;&gt;RequestHandler functions&lt;/a&gt; instead of objects implementing &lt;a href=&#34;https://golang.org/pkg/net/http/#Handler&#34;&gt;Handler interface&lt;/a&gt;. Fortunately, it is easy to pass bound struct methods to fasthttp:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MyHandler struct {&#xA;&#x9;foobar string&#xA;}&#xA;&#xA;// request handler in net/http style, i.e. method bound to MyHandler struct.&#xA;func (h *MyHandler) HandleFastHTTP(ctx *fasthttp.RequestCtx) {&#xA;&#x9;// notice that we may access MyHandler properties here - see h.foobar.&#xA;&#x9;fmt.Fprintf(ctx, &#34;Hello, world! Requested path is %q. Foobar is %q&#34;,&#xA;&#x9;&#x9;ctx.Path(), h.foobar)&#xA;}&#xA;&#xA;// request handler in fasthttp style, i.e. just plain function.&#xA;func fastHTTPHandler(ctx *fasthttp.RequestCtx) {&#xA;&#x9;fmt.Fprintf(ctx, &#34;Hi there! RequestURI is %q&#34;, ctx.RequestURI())&#xA;}&#xA;&#xA;// pass bound struct method to fasthttp&#xA;myHandler := &amp;amp;MyHandler{&#xA;&#x9;foobar: &#34;foobar&#34;,&#xA;}&#xA;fasthttp.ListenAndServe(&#34;:8080&#34;, myHandler.HandleFastHTTP)&#xA;&#xA;// pass plain function to fasthttp&#xA;fasthttp.ListenAndServe(&#34;:8081&#34;, fastHTTPHandler)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHandler&#34;&gt;RequestHandler&lt;/a&gt; accepts only one argument - &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx&#34;&gt;RequestCtx&lt;/a&gt;. It contains all the functionality required for http request processing and response writing. Below is an example of a simple request handler conversion from net/http to fasthttp.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// net/http request handler&#xA;requestHandler := func(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;switch r.URL.Path {&#xA;&#x9;case &#34;/foo&#34;:&#xA;&#x9;&#x9;fooHandler(w, r)&#xA;&#x9;case &#34;/bar&#34;:&#xA;&#x9;&#x9;barHandler(w, r)&#xA;&#x9;default:&#xA;&#x9;&#x9;http.Error(w, &#34;Unsupported path&#34;, http.StatusNotFound)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// the corresponding fasthttp request handler&#xA;requestHandler := func(ctx *fasthttp.RequestCtx) {&#xA;&#x9;switch string(ctx.Path()) {&#xA;&#x9;case &#34;/foo&#34;:&#xA;&#x9;&#x9;fooHandler(ctx)&#xA;&#x9;case &#34;/bar&#34;:&#xA;&#x9;&#x9;barHandler(ctx)&#xA;&#x9;default:&#xA;&#x9;&#x9;ctx.Error(&#34;Unsupported path&#34;, fasthttp.StatusNotFound)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fasthttp allows setting response headers and writing response body in an arbitrary order. There is no &#39;headers first, then body&#39; restriction like in net/http. The following code is valid for fasthttp:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;requestHandler := func(ctx *fasthttp.RequestCtx) {&#xA;&#x9;// set some headers and status code first&#xA;&#x9;ctx.SetContentType(&#34;foo/bar&#34;)&#xA;&#x9;ctx.SetStatusCode(fasthttp.StatusOK)&#xA;&#xA;&#x9;// then write the first part of body&#xA;&#x9;fmt.Fprintf(ctx, &#34;this is the first part of body\n&#34;)&#xA;&#xA;&#x9;// then set more headers&#xA;&#x9;ctx.Response.Header.Set(&#34;Foo-Bar&#34;, &#34;baz&#34;)&#xA;&#xA;&#x9;// then write more body&#xA;&#x9;fmt.Fprintf(ctx, &#34;this is the second part of body\n&#34;)&#xA;&#xA;&#x9;// then override already written body&#xA;&#x9;ctx.SetBody([]byte(&#34;this is completely new body contents&#34;))&#xA;&#xA;&#x9;// then update status code&#xA;&#x9;ctx.SetStatusCode(fasthttp.StatusNotFound)&#xA;&#xA;&#x9;// basically, anything may be updated many times before&#xA;&#x9;// returning from RequestHandler.&#xA;&#x9;//&#xA;&#x9;// Unlike net/http fasthttp doesn&#39;t put response to the wire until&#xA;&#x9;// returning from RequestHandler.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fasthttp doesn&#39;t provide &lt;a href=&#34;https://golang.org/pkg/net/http/#ServeMux&#34;&gt;ServeMux&lt;/a&gt;, but there are more powerful third-party routers and web frameworks with fasthttp support:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/qiangxue/fasthttp-routing&#34;&gt;fasthttp-routing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/fasthttp/router&#34;&gt;router&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/vincentLiuxiang/lu&#34;&gt;lu&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/savsgio/atreugo&#34;&gt;atreugo&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/gofiber/fiber&#34;&gt;Fiber&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/gogearbox/gearbox&#34;&gt;Gearbox&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Net/http code with simple ServeMux is trivially converted to fasthttp code:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// net/http code&#xA;&#xA;m := &amp;amp;http.ServeMux{}&#xA;m.HandleFunc(&#34;/foo&#34;, fooHandlerFunc)&#xA;m.HandleFunc(&#34;/bar&#34;, barHandlerFunc)&#xA;m.Handle(&#34;/baz&#34;, bazHandler)&#xA;&#xA;http.ListenAndServe(&#34;:80&#34;, m)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// the corresponding fasthttp code&#xA;m := func(ctx *fasthttp.RequestCtx) {&#xA;&#x9;switch string(ctx.Path()) {&#xA;&#x9;case &#34;/foo&#34;:&#xA;&#x9;&#x9;fooHandlerFunc(ctx)&#xA;&#x9;case &#34;/bar&#34;:&#xA;&#x9;&#x9;barHandlerFunc(ctx)&#xA;&#x9;case &#34;/baz&#34;:&#xA;&#x9;&#x9;bazHandler.HandlerFunc(ctx)&#xA;&#x9;default:&#xA;&#x9;&#x9;ctx.Error(&#34;not found&#34;, fasthttp.StatusNotFound)&#xA;&#x9;}&#xA;}&#xA;&#xA;fasthttp.ListenAndServe(&#34;:80&#34;, m)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Because creating a new channel for every request is just too expensive, so the channel returned by RequestCtx.Done() is only closed when the server is shutting down.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;  fasthttp.ListenAndServe(&#34;:8080&#34;, fasthttp.TimeoutHandler(func(ctx *fasthttp.RequestCtx) {&#xA;  &#x9;select {&#xA;  &#x9;case &amp;lt;-ctx.Done():&#xA;  &#x9;&#x9;// ctx.Done() is only closed when the server is shutting down.&#xA;  &#x9;&#x9;log.Println(&#34;context cancelled&#34;)&#xA;  &#x9;&#x9;return&#xA;  &#x9;case &amp;lt;-time.After(10 * time.Second):&#xA;  &#x9;&#x9;log.Println(&#34;process finished ok&#34;)&#xA;  &#x9;}&#xA;  }, time.Second*2, &#34;timeout&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;net/http -&amp;gt; fasthttp conversion table:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;All the pseudocode below assumes w, r and ctx have these types:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  var (&#xA;  &#x9;w http.ResponseWriter&#xA;  &#x9;r *http.Request&#xA;  &#x9;ctx *fasthttp.RequestCtx&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;r.Body -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostBody&#34;&gt;ctx.PostBody()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.URL.Path -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Path&#34;&gt;ctx.Path()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.URL -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.URI&#34;&gt;ctx.URI()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.Method -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Method&#34;&gt;ctx.Method()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.Header -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHeader&#34;&gt;ctx.Request.Header&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.Header.Get() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHeader.Peek&#34;&gt;ctx.Request.Header.Peek()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.Host -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Host&#34;&gt;ctx.Host()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.Form -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.QueryArgs&#34;&gt;ctx.QueryArgs()&lt;/a&gt; + &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostArgs&#34;&gt;ctx.PostArgs()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.PostForm -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostArgs&#34;&gt;ctx.PostArgs()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.FormValue() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.FormValue&#34;&gt;ctx.FormValue()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.FormFile() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.FormFile&#34;&gt;ctx.FormFile()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.MultipartForm -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.MultipartForm&#34;&gt;ctx.MultipartForm()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.RemoteAddr -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.RemoteAddr&#34;&gt;ctx.RemoteAddr()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.RequestURI -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.RequestURI&#34;&gt;ctx.RequestURI()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.TLS -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.IsTLS&#34;&gt;ctx.IsTLS()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.Cookie() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHeader.Cookie&#34;&gt;ctx.Request.Header.Cookie()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.Referer() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Referer&#34;&gt;ctx.Referer()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;r.UserAgent() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.UserAgent&#34;&gt;ctx.UserAgent()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;w.Header() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#ResponseHeader&#34;&gt;ctx.Response.Header&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;w.Header().Set() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#ResponseHeader.Set&#34;&gt;ctx.Response.Header.Set()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;w.Header().Set(&#34;Content-Type&#34;) -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetContentType&#34;&gt;ctx.SetContentType()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;w.Header().Set(&#34;Set-Cookie&#34;) -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#ResponseHeader.SetCookie&#34;&gt;ctx.Response.Header.SetCookie()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;w.Write() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Write&#34;&gt;ctx.Write()&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetBody&#34;&gt;ctx.SetBody()&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetBodyStream&#34;&gt;ctx.SetBodyStream()&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetBodyStreamWriter&#34;&gt;ctx.SetBodyStreamWriter()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;w.WriteHeader() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetStatusCode&#34;&gt;ctx.SetStatusCode()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;w.(http.Hijacker).Hijack() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Hijack&#34;&gt;ctx.Hijack()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;http.Error() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Error&#34;&gt;ctx.Error()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;http.FileServer() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#FSHandler&#34;&gt;fasthttp.FSHandler()&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#FS&#34;&gt;fasthttp.FS&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;http.ServeFile() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#ServeFile&#34;&gt;fasthttp.ServeFile()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;http.Redirect() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Redirect&#34;&gt;ctx.Redirect()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;http.NotFound() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.NotFound&#34;&gt;ctx.NotFound()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;http.StripPrefix() -&amp;gt; &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#PathRewriteFunc&#34;&gt;fasthttp.PathRewriteFunc&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;VERY IMPORTANT!&lt;/em&gt; Fasthttp disallows holding references to &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx&#34;&gt;RequestCtx&lt;/a&gt; or to its&#39; members after returning from &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHandler&#34;&gt;RequestHandler&lt;/a&gt;. Otherwise &lt;a href=&#34;http://blog.golang.org/race-detector&#34;&gt;data races&lt;/a&gt; are inevitable. Carefully inspect all the net/http request handlers converted to fasthttp whether they retain references to RequestCtx or to its&#39; members after returning. RequestCtx provides the following &lt;em&gt;band aids&lt;/em&gt; for this case:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Wrap RequestHandler into &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#TimeoutHandler&#34;&gt;TimeoutHandler&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Call &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.TimeoutError&#34;&gt;TimeoutError&lt;/a&gt; before returning from RequestHandler if there are references to RequestCtx or to its&#39; members. See &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#example-RequestCtx-TimeoutError&#34;&gt;the example&lt;/a&gt; for more details.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Use this brilliant tool - &lt;a href=&#34;http://blog.golang.org/race-detector&#34;&gt;race detector&lt;/a&gt; - for detecting and eliminating data races in your program. If you detected data race related to fasthttp in your program, then there is high probability you forgot calling &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.TimeoutError&#34;&gt;TimeoutError&lt;/a&gt; before returning from &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHandler&#34;&gt;RequestHandler&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Blind switching from net/http to fasthttp won&#39;t give you performance boost. While fasthttp is optimized for speed, its&#39; performance may be easily saturated by slow &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHandler&#34;&gt;RequestHandler&lt;/a&gt;. So &lt;a href=&#34;http://blog.golang.org/profiling-go-programs&#34;&gt;profile&lt;/a&gt; and optimize your code after switching to fasthttp. For instance, use &lt;a href=&#34;https://github.com/valyala/quicktemplate&#34;&gt;quicktemplate&lt;/a&gt; instead of &lt;a href=&#34;https://golang.org/pkg/html/template/&#34;&gt;html/template&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;See also &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp/fasthttputil&#34;&gt;fasthttputil&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp/fasthttpadaptor&#34;&gt;fasthttpadaptor&lt;/a&gt; and &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp/expvarhandler&#34;&gt;expvarhandler&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance optimization tips for multi-core systems&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp/reuseport&#34;&gt;reuseport&lt;/a&gt; listener.&lt;/li&gt; &#xA; &lt;li&gt;Run a separate server instance per CPU core with GOMAXPROCS=1.&lt;/li&gt; &#xA; &lt;li&gt;Pin each server instance to a separate CPU core using &lt;a href=&#34;http://linux.die.net/man/1/taskset&#34;&gt;taskset&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Ensure the interrupts of multiqueue network card are evenly distributed between CPU cores. See &lt;a href=&#34;https://blog.cloudflare.com/how-to-achieve-low-latency/&#34;&gt;this article&lt;/a&gt; for details.&lt;/li&gt; &#xA; &lt;li&gt;Use the latest version of Go as each version contains performance improvements.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Fasthttp best practices&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Do not allocate objects and &lt;code&gt;[]byte&lt;/code&gt; buffers - just reuse them as much as possible. Fasthttp API design encourages this.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/sync/#Pool&#34;&gt;sync.Pool&lt;/a&gt; is your best friend.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://blog.golang.org/profiling-go-programs&#34;&gt;Profile your program&lt;/a&gt; in production. &lt;code&gt;go tool pprof --alloc_objects your-program mem.pprof&lt;/code&gt; usually gives better insights for optimization opportunities than &lt;code&gt;go tool pprof your-program cpu.pprof&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Write &lt;a href=&#34;https://golang.org/pkg/testing/&#34;&gt;tests and benchmarks&lt;/a&gt; for hot paths.&lt;/li&gt; &#xA; &lt;li&gt;Avoid conversion between &lt;code&gt;[]byte&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;, since this may result in memory allocation+copy. Fasthttp API provides functions for both &lt;code&gt;[]byte&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; - use these functions instead of converting manually between &lt;code&gt;[]byte&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;. There are some exceptions - see &lt;a href=&#34;https://github.com/golang/go/wiki/CompilerOptimizations#string-and-byte&#34;&gt;this wiki page&lt;/a&gt; for more details.&lt;/li&gt; &#xA; &lt;li&gt;Verify your tests and production code under &lt;a href=&#34;https://golang.org/doc/articles/race_detector.html&#34;&gt;race detector&lt;/a&gt; on a regular basis.&lt;/li&gt; &#xA; &lt;li&gt;Prefer &lt;a href=&#34;https://github.com/valyala/quicktemplate&#34;&gt;quicktemplate&lt;/a&gt; instead of &lt;a href=&#34;https://golang.org/pkg/html/template/&#34;&gt;html/template&lt;/a&gt; in your webserver.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tricks with &lt;code&gt;[]byte&lt;/code&gt; buffers&lt;/h2&gt; &#xA;&lt;p&gt;The following tricks are used by fasthttp. Use them in your code too.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Standard Go functions accept nil buffers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (&#xA;&#x9;// both buffers are uninitialized&#xA;&#x9;dst []byte&#xA;&#x9;src []byte&#xA;)&#xA;dst = append(dst, src...)  // is legal if dst is nil and/or src is nil&#xA;copy(dst, src)  // is legal if dst is nil and/or src is nil&#xA;(string(src) == &#34;&#34;)  // is true if src is nil&#xA;(len(src) == 0)  // is true if src is nil&#xA;src = src[:0]  // works like a charm with nil src&#xA;&#xA;// this for loop doesn&#39;t panic if src is nil&#xA;for i, ch := range src {&#xA;&#x9;doSomething(i, ch)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So throw away nil checks for &lt;code&gt;[]byte&lt;/code&gt; buffers from you code. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;srcLen := 0&#xA;if src != nil {&#xA;&#x9;srcLen = len(src)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;becomes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;srcLen := len(src)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;String may be appended to &lt;code&gt;[]byte&lt;/code&gt; buffer with &lt;code&gt;append&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;dst = append(dst, &#34;foobar&#34;...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[]byte&lt;/code&gt; buffer may be extended to its&#39; capacity.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;buf := make([]byte, 100)&#xA;a := buf[:10]  // len(a) == 10, cap(a) == 100.&#xA;b := a[:100]  // is valid, since cap(a) == 100.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All fasthttp functions accept nil &lt;code&gt;[]byte&lt;/code&gt; buffer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;statusCode, body, err := fasthttp.Get(nil, &#34;http://google.com/&#34;)&#xA;uintBuf := fasthttp.AppendUint(nil, 1234)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;String and &lt;code&gt;[]byte&lt;/code&gt; buffers may converted without memory allocations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func b2s(b []byte) string {&#xA;    return *(*string)(unsafe.Pointer(&amp;amp;b))&#xA;}&#xA;&#xA;func s2b(s string) (b []byte) {&#xA;    bh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;b))&#xA;    sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))&#xA;    bh.Data = sh.Data&#xA;    bh.Cap = sh.Len&#xA;    bh.Len = sh.Len&#xA;    return b&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Warning:&lt;/h3&gt; &#xA;&lt;p&gt;This is an &lt;strong&gt;unsafe&lt;/strong&gt; way, the result string and &lt;code&gt;[]byte&lt;/code&gt; buffer share the same bytes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Please make sure not to modify the bytes in the &lt;code&gt;[]byte&lt;/code&gt; buffer if the string still survives!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fasthttp&#34;&gt;fasthttp&lt;/a&gt; - various useful helpers for projects based on fasthttp.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qiangxue/fasthttp-routing&#34;&gt;fasthttp-routing&lt;/a&gt; - fast and powerful routing package for fasthttp servers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dgrr/http2&#34;&gt;http2&lt;/a&gt; - HTTP/2 implementation for fasthttp.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fasthttp/router&#34;&gt;router&lt;/a&gt; - a high performance fasthttp request router that scales well.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fasthttp/fastws&#34;&gt;fastws&lt;/a&gt; - Bloatless WebSocket package made for fasthttp to handle Read/Write operations concurrently.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gramework/gramework&#34;&gt;gramework&lt;/a&gt; - a web framework made by one of fasthttp maintainers&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vincentLiuxiang/lu&#34;&gt;lu&lt;/a&gt; - a high performance go middleware web framework which is based on fasthttp.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fasthttp/websocket&#34;&gt;websocket&lt;/a&gt; - Gorilla-based websocket implementation for fasthttp.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dgrr/websocket&#34;&gt;websocket&lt;/a&gt; - Event-based high-performance WebSocket library for zero-allocation websocket servers and clients.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/phachon/fasthttpsession&#34;&gt;fasthttpsession&lt;/a&gt; - a fast and powerful session package for fasthttp servers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/savsgio/atreugo&#34;&gt;atreugo&lt;/a&gt; - High performance and extensible micro web framework with zero memory allocations in hot paths.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/savsgio/kratgo&#34;&gt;kratgo&lt;/a&gt; - Simple, lightweight and ultra-fast HTTP Cache to speed up your websites.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wencan/kit-plugins/tree/master/transport/fasthttp&#34;&gt;kit-plugins&lt;/a&gt; - go-kit transport implementation for fasthttp.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gofiber/fiber&#34;&gt;Fiber&lt;/a&gt; - An Expressjs inspired web framework running on Fasthttp&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gogearbox/gearbox&#34;&gt;Gearbox&lt;/a&gt; - &lt;span&gt;⚙&lt;/span&gt; gearbox is a web framework written in Go with a focus on high performance and memory optimization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Why creating yet another http package instead of optimizing net/http?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Because net/http API limits many optimization opportunities. For example:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;net/http Request object lifetime isn&#39;t limited by request handler execution time. So the server must create a new request object per each request instead of reusing existing objects like fasthttp does.&lt;/li&gt; &#xA;   &lt;li&gt;net/http headers are stored in a &lt;code&gt;map[string][]string&lt;/code&gt;. So the server must parse all the headers, convert them from &lt;code&gt;[]byte&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; and put them into the map before calling user-provided request handler. This all requires unnecessary memory allocations avoided by fasthttp.&lt;/li&gt; &#xA;   &lt;li&gt;net/http client API requires creating a new response object per each request.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Why fasthttp API is incompatible with net/http?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Because net/http API limits many optimization opportunities. See the answer above for more details. Also certain net/http API parts are suboptimal for use:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Compare &lt;a href=&#34;https://golang.org/pkg/net/http/#Hijacker&#34;&gt;net/http connection hijacking&lt;/a&gt; to &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Hijack&#34;&gt;fasthttp connection hijacking&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Compare &lt;a href=&#34;https://golang.org/pkg/net/http/#Request&#34;&gt;net/http Request.Body reading&lt;/a&gt; to &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostBody&#34;&gt;fasthttp request body reading&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Why fasthttp doesn&#39;t support HTTP/2.0 and WebSockets?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/fasthttp/http2&#34;&gt;HTTP/2.0 support&lt;/a&gt; is in progress. &lt;a href=&#34;https://github.com/fasthttp/websockets&#34;&gt;WebSockets&lt;/a&gt; has been done already. Third parties also may use &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Hijack&#34;&gt;RequestCtx.Hijack&lt;/a&gt; for implementing these goodies.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Are there known net/http advantages comparing to fasthttp?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Yes:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;net/http supports &lt;a href=&#34;https://http2.golang.org/&#34;&gt;HTTP/2.0 starting from go1.6&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;net/http API is stable, while fasthttp API constantly evolves.&lt;/li&gt; &#xA;   &lt;li&gt;net/http handles more HTTP corner cases.&lt;/li&gt; &#xA;   &lt;li&gt;net/http can stream both request and response bodies&lt;/li&gt; &#xA;   &lt;li&gt;net/http can handle bigger bodies as it doesn&#39;t read the whole body into memory&lt;/li&gt; &#xA;   &lt;li&gt;net/http should contain less bugs, since it is used and tested by much wider audience.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Why fasthttp API prefers returning &lt;code&gt;[]byte&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Because &lt;code&gt;[]byte&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; conversion isn&#39;t free - it requires memory allocation and copy. Feel free wrapping returned &lt;code&gt;[]byte&lt;/code&gt; result into &lt;code&gt;string()&lt;/code&gt; if you prefer working with strings instead of byte slices. But be aware that this has non-zero overhead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Which GO versions are supported by fasthttp?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Go 1.15.x. Older versions won&#39;t be supported.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Please provide real benchmark data and server information&lt;/em&gt;&lt;/p&gt; &lt;p&gt;See &lt;a href=&#34;https://github.com/valyala/fasthttp/issues/4&#34;&gt;this issue&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Are there plans to add request routing to fasthttp?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;There are no plans to add request routing into fasthttp. Use third-party routers and web frameworks with fasthttp support:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/qiangxue/fasthttp-routing&#34;&gt;fasthttp-routing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/fasthttp/router&#34;&gt;router&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/gramework/gramework&#34;&gt;gramework&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/vincentLiuxiang/lu&#34;&gt;lu&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/savsgio/atreugo&#34;&gt;atreugo&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/gofiber/fiber&#34;&gt;Fiber&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/gogearbox/gearbox&#34;&gt;Gearbox&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;See also &lt;a href=&#34;https://github.com/valyala/fasthttp/issues/9&#34;&gt;this issue&lt;/a&gt; for more info.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;I detected data race in fasthttp!&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Cool! &lt;a href=&#34;https://github.com/valyala/fasthttp/issues/new&#34;&gt;File a bug&lt;/a&gt;. But before doing this check the following in your code:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Make sure there are no references to &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx&#34;&gt;RequestCtx&lt;/a&gt; or to its&#39; members after returning from &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHandler&#34;&gt;RequestHandler&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Make sure you call &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx.TimeoutError&#34;&gt;TimeoutError&lt;/a&gt; before returning from &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestHandler&#34;&gt;RequestHandler&lt;/a&gt; if there are references to &lt;a href=&#34;https://godoc.org/github.com/valyala/fasthttp#RequestCtx&#34;&gt;RequestCtx&lt;/a&gt; or to its&#39; members, which may be accessed by other goroutines.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;I didn&#39;t find an answer for my question here&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Try exploring &lt;a href=&#34;https://github.com/valyala/fasthttp/issues?q=label%3Aquestion&#34;&gt;these questions&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>yannh/kubeconform</title>
    <updated>2022-12-29T01:31:48Z</updated>
    <id>tag:github.com,2022-12-29:/yannh/kubeconform</id>
    <link href="https://github.com/yannh/kubeconform" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A FAST Kubernetes manifests validator, with support for Custom Resources!&lt;/p&gt;&lt;hr&gt;&lt;img width=&#34;50%&#34; alt=&#34;Kubeconform-GitHub-Hero&#34; src=&#34;https://user-images.githubusercontent.com/19731161/142411871-f695e40c-bfa8-43ca-97c0-94c256749732.png&#34;&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/yannh/kubeconform/actions?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/yannh/kubeconform/workflows/build/badge.svg?branch=master&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://formulae.brew.sh/formula/kubeconform&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/json.svg?url=https://formulae.brew.sh/api/formula/kubeconform.json&amp;amp;query=$.versions.stable&amp;amp;label=homebrew&#34; alt=&#34;Homebrew&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/yannh/kubeconform&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/yannh/kubeconform&#34; alt=&#34;Go Report card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/yannh/kubeconform/pkg/validator&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/yannh/kubeconform/pkg/validator&#34; alt=&#34;PkgGoDev&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Kubeconform&lt;/code&gt; is a Kubernetes manifest validation tool. Incorporate it into your CI, or use it locally to validate your Kubernetes configuration!&lt;/p&gt; &#xA;&lt;p&gt;It is inspired by, contains code from and is designed to stay close to &lt;a href=&#34;https://github.com/instrumenta/kubeval&#34;&gt;Kubeval&lt;/a&gt;, but with the following improvements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;high performance&lt;/strong&gt;: will validate &amp;amp; download manifests over multiple routines, caching downloaded files in memory&lt;/li&gt; &#xA; &lt;li&gt;configurable list of &lt;strong&gt;remote, or local schemas locations&lt;/strong&gt;, enabling validating Kubernetes custom resources (CRDs) and offline validation capabilities&lt;/li&gt; &#xA; &lt;li&gt;uses by default a &lt;a href=&#34;https://github.com/yannh/kubernetes-json-schema&#34;&gt;self-updating fork&lt;/a&gt; of the schemas registry maintained by the kubernetes-json-schema project - which guarantees up-to-date &lt;strong&gt;schemas for all recent versions of Kubernetes&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;h4&gt;Speed comparison with Kubeval&lt;/h4&gt;&lt;/summary&gt;&#xA; &lt;p&gt; Running on a pretty large kubeconfigs setup, on a laptop with 4 cores: &lt;/p&gt;&#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ time kubeconform -ignore-missing-schemas -n 8 -summary  preview staging production&#xA;Summary: 50714 resources found in 35139 files - Valid: 27334, Invalid: 0, Errors: 0 Skipped: 23380&#xA;real&#x9;0m6,710s&#xA;user&#x9;0m38,701s&#xA;sys&#x9;0m1,161s&#xA;$ time kubeval -d preview,staging,production --ignore-missing-schemas --quiet&#xA;[... Skipping output]&#xA;real&#x9;0m35,336s&#xA;user&#x9;0m0,717s&#xA;sys&#x9;0m1,069s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;/p&gt;&#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#a-small-overview-of-kubernetes-manifest-validation&#34;&gt;A small overview of Kubernetes manifest validation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Limits-of-Kubeconform-validation&#34;&gt;Limits of Kubeconform validation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Usage-examples&#34;&gt;Usage examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Proxy-support&#34;&gt;Proxy support&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Overriding-schemas-location&#34;&gt;Overriding schemas location&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#CustomResourceDefinition-(CRD)-Support&#34;&gt;CustomResourceDefinition (CRD) Support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#OpenShift-schema-Support&#34;&gt;OpenShift schema Support&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Integrating-Kubeconform-in-the-CI&#34;&gt;Integrating Kubeconform in the CI&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Github-Workflow&#34;&gt;Github Workflow&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Gitlab-CI&#34;&gt;Gitlab-CI&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#helm-charts&#34;&gt;Helm charts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Using-kubeconform-as-a-Go-Module&#34;&gt;Using kubeconform as a Go Module&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/#Credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;A small overview of Kubernetes manifest validation&lt;/h2&gt; &#xA;&lt;p&gt;Kubernetes&#39;s API is described using the &lt;a href=&#34;https://www.openapis.org&#34;&gt;OpenAPI (formerly swagger) specification&lt;/a&gt;, in a &lt;a href=&#34;https://github.com/kubernetes/kubernetes/raw/master/api/openapi-spec/swagger.json&#34;&gt;file&lt;/a&gt; checked into the main Kubernetes repository.&lt;/p&gt; &#xA;&lt;p&gt;Because of the state of the tooling to perform validation against OpenAPI schemas, projects usually convert the OpenAPI schemas to &lt;a href=&#34;https://json-schema.org/&#34;&gt;JSON schemas&lt;/a&gt; first. Kubeval relies on &lt;a href=&#34;https://github.com/instrumenta/openapi2jsonschema&#34;&gt;instrumenta/OpenApi2JsonSchema&lt;/a&gt; to convert Kubernetes&#39; Swagger file and break it down into multiple JSON schemas, stored in github at &lt;a href=&#34;https://github.com/instrumenta/kubernetes-json-schema&#34;&gt;instrumenta/kubernetes-json-schema&lt;/a&gt; and published on &lt;a href=&#34;https://kubernetesjsonschema.dev/&#34;&gt;kubernetesjsonschema.dev&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Kubeconform&lt;/code&gt; relies on &lt;a href=&#34;https://github.com/yannh/kubernetes-json-schema/&#34;&gt;a fork of kubernetes-json-schema&lt;/a&gt; that is more meticulously kept up-to-date, and contains schemas for all recent versions of Kubernetes.&lt;/p&gt; &#xA;&lt;h3&gt;Limits of Kubeconform validation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Kubeconform&lt;/code&gt;, similar to &lt;code&gt;kubeval&lt;/code&gt;, only validates manifests using the official Kubernetes OpenAPI specifications. The Kubernetes controllers still perform additional server-side validations that are not part of the OpenAPI specifications. Those server-side validations are not covered by &lt;code&gt;Kubeconform&lt;/code&gt; (examples: &lt;a href=&#34;https://github.com/yannh/kubeconform/issues/65&#34;&gt;#65&lt;/a&gt;, &lt;a href=&#34;https://github.com/yannh/kubeconform/issues/122&#34;&gt;#122&lt;/a&gt;, &lt;a href=&#34;https://github.com/yannh/kubeconform/issues/142&#34;&gt;#142&lt;/a&gt;). You can use a 3rd-party tool or the &lt;code&gt;kubectl --dry-run=server&lt;/code&gt; command to fill the missing (validation) gap.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;If you are a &lt;a href=&#34;https://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; user, you can install by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew install kubeconform&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also download the latest version from the &lt;a href=&#34;https://github.com/yannh/kubeconform/releases&#34;&gt;release page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Another way of installation is via Golang&#39;s package manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# With a specific version tag&#xA;$ go install github.com/yannh/kubeconform/cmd/kubeconform@v0.4.13&#xA;&#xA;# Latest version&#xA;$ go install github.com/yannh/kubeconform/cmd/kubeconform@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubeconform -h&#xA;Usage: ./bin/kubeconform [OPTION]... [FILE OR FOLDER]...&#xA;  -cache string&#xA;        cache schemas downloaded via HTTP to this folder&#xA;  -debug&#xA;        print debug information&#xA;  -exit-on-error&#xA;        immediately stop execution when the first error is encountered&#xA;  -h    show help information&#xA;  -ignore-filename-pattern value&#xA;        regular expression specifying paths to ignore (can be specified multiple times)&#xA;  -ignore-missing-schemas&#xA;        skip files with missing schemas instead of failing&#xA;  -insecure-skip-tls-verify&#xA;        disable verification of the server\&#39;s SSL certificate. This will make your HTTPS connections insecure&#xA;  -kubernetes-version string&#xA;        version of Kubernetes to validate against, e.g.: 1.18.0 (default &#34;master&#34;)&#xA;  -n int&#xA;        number of goroutines to run concurrently (default 4)&#xA;  -output string&#xA;        output format - json, junit, tap, text (default &#34;text&#34;)&#xA;  -reject string&#xA;        comma-separated list of kinds or GVKs to reject&#xA;  -schema-location value&#xA;        override schemas location search path (can be specified multiple times)&#xA;  -skip string&#xA;        comma-separated list of kinds or GVKs to ignore&#xA;  -strict&#xA;        disallow additional properties not in schema or duplicated keys&#xA;  -summary&#xA;        print a summary at the end (ignored for junit output)&#xA;  -v    show version information&#xA;  -verbose&#xA;        print results for all resources (ignored for tap and junit output)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage examples&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Validating a single, valid file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubeconform fixtures/valid.yaml&#xA;$ echo $?&#xA;0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Validating a single invalid file, setting output to json, and printing a summary&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubeconform -summary -output json fixtures/invalid.yaml&#xA;{&#xA;  &#34;resources&#34;: [&#xA;    {&#xA;      &#34;filename&#34;: &#34;fixtures/invalid.yaml&#34;,&#xA;      &#34;kind&#34;: &#34;ReplicationController&#34;,&#xA;      &#34;version&#34;: &#34;v1&#34;,&#xA;      &#34;status&#34;: &#34;INVALID&#34;,&#xA;      &#34;msg&#34;: &#34;Additional property templates is not allowed - Invalid type. Expected: [integer,null], given: string&#34;&#xA;    }&#xA;  ],&#xA;  &#34;summary&#34;: {&#xA;    &#34;valid&#34;: 0,&#xA;    &#34;invalid&#34;: 1,&#xA;    &#34;errors&#34;: 0,&#xA;    &#34;skipped&#34;: 0&#xA;  }&#xA;}&#xA;$ echo $?&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Passing manifests via Stdin&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat fixtures/valid.yaml  | ./bin/kubeconform -summary&#xA;Summary: 1 resource found parsing stdin - Valid: 1, Invalid: 0, Errors: 0 Skipped: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Validating a file, ignoring its resource using both Kind, and GVK (Group, Version, Kind) notations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;# This will ignore ReplicationController for all apiVersions&#xA;$ kubeconform -summary -skip ReplicationController fixtures/valid.yaml&#xA;Summary: 1 resource found in 1 file - Valid: 0, Invalid: 0, Errors: 0, Skipped: 1&#xA;&#xA;# This will ignore ReplicationController only for apiVersion v1&#xA;$ kubeconform -summary -skip v1/ReplicationController fixtures/valid.yaml&#xA;Summary: 1 resource found in 1 file - Valid: 0, Invalid: 0, Errors: 0, Skipped: 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Validating a folder, increasing the number of parallel workers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubeconform -summary -n 16 fixtures&#xA;fixtures/crd_schema.yaml - CustomResourceDefinition trainingjobs.sagemaker.aws.amazon.com failed validation: could not find schema for CustomResourceDefinition&#xA;fixtures/invalid.yaml - ReplicationController bob is invalid: Invalid type. Expected: [integer,null], given: string&#xA;[...]&#xA;Summary: 65 resources found in 34 files - Valid: 55, Invalid: 2, Errors: 8 Skipped: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Proxy support&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Kubeconform&lt;/code&gt; will respect the &lt;strong&gt;HTTPS_PROXY&lt;/strong&gt; variable when downloading schema files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ HTTPS_PROXY=proxy.local bin/kubeconform fixtures/valid.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Overriding schemas location&lt;/h2&gt; &#xA;&lt;p&gt;When the &lt;code&gt;-schema-location&lt;/code&gt; parameter is not used, or set to &lt;code&gt;default&lt;/code&gt;, kubeconform will default to downloading schemas from &lt;a href=&#34;https://github.com/yannh/kubernetes-json-schema&#34;&gt;https://github.com/yannh/kubernetes-json-schema&lt;/a&gt;. Kubeconform however supports passing one, or multiple, schemas locations - HTTP(s) URLs, or local filesystem paths, in which case it will lookup for schema definitions in each of them, in order, stopping as soon as a matching file is found.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the &lt;code&gt;-schema-location&lt;/code&gt; value does not end with &lt;code&gt;.json&lt;/code&gt;, Kubeconform will assume filenames / a file structure identical to that of &lt;a href=&#34;https://kubernetesjsonschema.dev/&#34;&gt;kubernetesjsonschema.dev&lt;/a&gt; or &lt;a href=&#34;https://github.com/yannh/kubernetes-json-schema&#34;&gt;yannh/kubernetes-json-schema&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;if the &lt;code&gt;-schema-location&lt;/code&gt; value ends with &lt;code&gt;.json&lt;/code&gt; - Kubeconform assumes the value is a &lt;strong&gt;Go templated string&lt;/strong&gt; that indicates how to search for JSON schemas.&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;-schema-location&lt;/code&gt; value of &lt;code&gt;default&lt;/code&gt; is an alias for &lt;code&gt;https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master/{{.NormalizedKubernetesVersion}}-standalone{{.StrictSuffix}}/{{.ResourceKind}}{{.KindSuffix}}.json&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;The following command lines are equivalent:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubeconform fixtures/valid.yaml&#xA;$ kubeconform -schema-location default fixtures/valid.yaml&#xA;$ kubeconform -schema-location &#39;https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master/{{.NormalizedKubernetesVersion}}-standalone{{.StrictSuffix}}/{{.ResourceKind}}{{.KindSuffix}}.json&#39; fixtures/valid.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here are the variables you can use in -schema-location:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;NormalizedKubernetesVersion&lt;/em&gt; - Kubernetes Version, prefixed by v&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;StrictSuffix&lt;/em&gt; - &#34;-strict&#34; or &#34;&#34; depending on whether validation is running in strict mode or not&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;ResourceKind&lt;/em&gt; - Kind of the Kubernetes Resource&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;ResourceAPIVersion&lt;/em&gt; - Version of API used for the resource - &#34;v1&#34; in &#34;apiVersion: monitoring.coreos.com/v1&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Group&lt;/em&gt; - the group name as stated in this resource&#39;s definition - &#34;monitoring.coreos.com&#34; in &#34;apiVersion: monitoring.coreos.com/v1&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;KindSuffix&lt;/em&gt; - suffix computed from apiVersion - for compatibility with &lt;code&gt;Kubeval&lt;/code&gt; schema registries&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;CustomResourceDefinition (CRD) Support&lt;/h3&gt; &#xA;&lt;p&gt;Because Custom Resources (CR) are not native Kubernetes objects, they are not included in the default schema.&lt;br&gt; If your CRs are present in &lt;a href=&#34;https://github.com/datreeio/CRDs-catalog&#34;&gt;Datree&#39;s CRDs-catalog&lt;/a&gt;, you can specify this project as an additional registry to lookup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Look in the CRDs-catalog for the desired schema/s&#xA;$ kubeconform -schema-location default -schema-location &#39;https://raw.githubusercontent.com/datreeio/CRDs-catalog/main/{{.Group}}/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json&#39; [MANIFEST]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your CRs are not present in the CRDs-catalog, you will need to manually pull the CRDs manifests from your cluster and convert the &lt;code&gt;OpenAPI.spec&lt;/code&gt; to JSON schema format.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Converting an OpenAPI file to a JSON Schema&lt;/summary&gt; &#xA; &lt;p&gt; &lt;/p&gt;&#xA; &lt;p&gt;&lt;code&gt;Kubeconform&lt;/code&gt; uses JSON schemas to validate Kubernetes resources. For Custom Resource, the CustomResourceDefinition first needs to be converted to JSON Schema. A script is provided to convert these CustomResourceDefinitions to JSON schema. Here is an example how to use it:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python ./scripts/openapi2jsonschema.py https://raw.githubusercontent.com/aws/amazon-sagemaker-operator-for-k8s/master/config/crd/bases/sagemaker.aws.amazon.com_trainingjobs.yaml&#xA;JSON schema written to trainingjob_v1.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;By default, the file name output format is &lt;code&gt;{kind}_{version}&lt;/code&gt;. The &lt;code&gt;FILENAME_FORMAT&lt;/code&gt; environment variable can be used to change the output file name (Available variables: &lt;code&gt;kind&lt;/code&gt;, &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;version&lt;/code&gt;):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;$ export FILENAME_FORMAT=&#39;{kind}-{group}-{version}&#39;&#xA;$ ./scripts/openapi2jsonschema.py https://raw.githubusercontent.com/aws/amazon-sagemaker-operator-for-k8s/master/config/crd/bases/sagemaker.aws.amazon.com_trainingjobs.yaml&#xA;JSON schema written to trainingjob-sagemaker-v1.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;After converting your CRDs to JSON schema files, you can use &lt;code&gt;kubeconform&lt;/code&gt; to validate your CRs against them:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;# If the resource Kind is not found in default, also lookup in the schemas/ folder for a matching file&#xA;$ kubeconform -schema-location default -schema-location &#39;schemas/{{ .ResourceKind }}{{ .KindSuffix }}.json&#39; fixtures/custom-resource.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;ℹ️ Datree&#39;s &lt;a href=&#34;https://github.com/datreeio/CRDs-catalog#crd-extractor&#34;&gt;CRD Extractor&lt;/a&gt; is a utility that can be used instead of this manual process.&lt;/p&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;OpenShift schema Support&lt;/h3&gt; &#xA;&lt;p&gt;You can validate Openshift manifests using a custom schema location. Set the OpenShift version (v3.10.0-4.1.0) to validate against using &lt;code&gt;-kubernetes-version&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kubeconform -kubernetes-version 3.8.0  -schema-location &#39;https://raw.githubusercontent.com/garethr/openshift-json-schema/master/{{ .NormalizedKubernetesVersion }}-standalone{{ .StrictSuffix }}/{{ .ResourceKind }}.json&#39;  -summary fixtures/valid.yaml&#xA;Summary: 1 resource found in 1 file - Valid: 1, Invalid: 0, Errors: 0 Skipped: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integrating Kubeconform in the CI&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Kubeconform&lt;/code&gt; publishes Docker Images to Github&#39;s new Container Registry (ghcr.io). These images can be used directly in a Github Action, once logged in using a &lt;a href=&#34;https://github.blog/changelog/2021-03-24-packages-container-registry-now-supports-github_token/&#34;&gt;&lt;em&gt;Github Token&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Github Workflow&lt;/h3&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: kubeconform&#xA;on: push&#xA;jobs:&#xA;  kubeconform:&#xA;    runs-on: ubuntu-latest&#xA;    steps:&#xA;      - name: login to Github Packages&#xA;        run: echo &#34;${{ github.token }}&#34; | docker login https://ghcr.io -u ${GITHUB_ACTOR} --password-stdin&#xA;      - uses: actions/checkout@v2&#xA;      - uses: docker://ghcr.io/yannh/kubeconform:master&#xA;        with:&#xA;          entrypoint: &#39;/kubeconform&#39;&#xA;          args: &#34;-summary -output json kubeconfigs/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note on pricing&lt;/em&gt;: Kubeconform relies on Github Container Registry which is currently in Beta. During that period, &lt;a href=&#34;https://docs.github.com/en/packages/guides/about-github-container-registry&#34;&gt;bandwidth is free&lt;/a&gt;. After that period, bandwidth costs might be applicable. Since bandwidth from Github Packages within Github Actions is free, I expect Github Container Registry to also be usable for free within Github Actions in the future. If that were not to be the case, I might publish the Docker image to a different platform.&lt;/p&gt; &#xA;&lt;h3&gt;Gitlab-CI&lt;/h3&gt; &#xA;&lt;p&gt;The Kubeconform Docker image can be used in Gitlab-CI. Here is an example of a Gitlab-CI job:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;lint-kubeconform:&#xA;  stage: validate&#xA;  image:&#xA;    name: ghcr.io/yannh/kubeconform:latest-alpine&#xA;    entrypoint: [&#34;&#34;]&#xA;  script:&#xA;  - kubeconform&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/yannh/kubeconform/issues/106&#34;&gt;issue 106&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Helm charts&lt;/h2&gt; &#xA;&lt;p&gt;There is a 3rd party &lt;a href=&#34;https://github.com/jtyr/kubeconform-helm&#34;&gt;repository&lt;/a&gt; that allows to use &lt;code&gt;kubeconform&lt;/code&gt; to test &lt;a href=&#34;https://helm.sh&#34;&gt;Helm charts&lt;/a&gt; in the form of a &lt;a href=&#34;https://helm.sh/docs/topics/plugins/&#34;&gt;Helm plugin&lt;/a&gt; and &lt;a href=&#34;https://pre-commit.com/&#34;&gt;&lt;code&gt;pre-commit&lt;/code&gt; hook&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Using kubeconform as a Go Module&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: This is a work-in-progress, the interface is not yet considered stable. Feedback is encouraged.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Kubeconform&lt;/code&gt; contains a package that can be used as a library. An example of usage can be found in &lt;a href=&#34;https://raw.githubusercontent.com/yannh/kubeconform/master/examples/main.go&#34;&gt;examples/main.go&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additional documentation on &lt;a href=&#34;https://pkg.go.dev/github.com/yannh/kubeconform/pkg/validator&#34;&gt;pkg.go.dev&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;@garethr for the &lt;a href=&#34;https://github.com/instrumenta/kubeval&#34;&gt;Kubeval&lt;/a&gt; and &lt;a href=&#34;https://github.com/instrumenta/kubernetes-json-schema&#34;&gt;kubernetes-json-schema&lt;/a&gt; projects ❤️&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ZeStream/zestream-server</title>
    <updated>2022-12-29T01:31:48Z</updated>
    <id>tag:github.com,2022-12-29:/ZeStream/zestream-server</id>
    <link href="https://github.com/ZeStream/zestream-server" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An adaptive video streaming self-deployable service&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZeStream - An adaptive video streaming server&lt;/h1&gt; &#xA;&lt;h2&gt;What is adaptive video streaming?&lt;/h2&gt; &#xA;&lt;p&gt;Ever wonder how Youtube/Netflix/Tiktok changes the resolution of the video, you are watching depending on your network speed?&lt;/p&gt; &#xA;&lt;p&gt;You want to implement the similar feature in your own product, without any hassle?&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;ZeStream is the backend service which you can self-deploy, and use its API to process the video and store it on a storage bucket like AWS S3/Google Cloud/Azure....&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/ZeStream/zestream-server/dev/docs/static/ZeStream.svg?sanitize=true&#34; width=&#34;500&#34;&gt; &#xA;&lt;h2&gt;Implementation&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;User calls API to prcoess the video.&lt;/li&gt; &#xA; &lt;li&gt;The API controller queues the event in a message queue (Kafka) and calls the given webhook.&lt;/li&gt; &#xA; &lt;li&gt;A ZeStream worker polls the event from queue which contains file url&lt;/li&gt; &#xA; &lt;li&gt;Worker fetches the file to local disk&lt;/li&gt; &#xA; &lt;li&gt;Another worker starts a FFmpeg thread to process the video&lt;/li&gt; &#xA; &lt;li&gt;Output is stored in local disk&lt;/li&gt; &#xA; &lt;li&gt;After FFmpeg finishes processing, another worker pushes the files to cloud storage&lt;/li&gt; &#xA; &lt;li&gt;CDN is connected to storage for fetching the files.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Dev Setup&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Golang v1.9 from &lt;a href=&#34;https://go.dev/doc/install&#34;&gt;Go.dev&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fork this repo, and clone the forked repo&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd zestream-server&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;go get .&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;go run main.go&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How to contribute?&lt;/h2&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://github.com/ZeStream/zestream-server/raw/main/CONTRIBUTING.md&#34;&gt;contribution guidelines&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>