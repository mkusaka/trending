<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-03T01:34:24Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>anchore/grype</title>
    <updated>2022-11-03T01:34:24Z</updated>
    <id>tag:github.com,2022-11-03:/anchore/grype</id>
    <link href="https://github.com/anchore/grype" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A vulnerability scanner for container images and filesystems&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img alt=&#34;Grype logo&#34; src=&#34;https://user-images.githubusercontent.com/5199289/136855393-d0a9eef9-ccf1-4e2b-9d7c-7aad16a567e5.png&#34; width=&#34;234&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/anchore/grype/actions?query=workflow%3A%22Static+Analysis+%2B+Unit+%2B+Integration%22&#34;&gt;&lt;img src=&#34;https://github.com/anchore/grype/workflows/Static%20Analysis%20+%20Unit%20+%20Integration/badge.svg?sanitize=true&#34; alt=&#34;Static Analysis + Unit + Integration&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/anchore/grype/actions?query=workflow%3AAcceptance&#34;&gt;&lt;img src=&#34;https://github.com/anchore/grype/workflows/Acceptance/badge.svg?sanitize=true&#34; alt=&#34;Acceptance&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/anchore/grype&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/anchore/grype&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/anchore/grype/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/anchore/grype.svg?sanitize=true&#34; alt=&#34;GitHub release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/anchore/grype&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/go-mod/go-version/anchore/grype.svg?sanitize=true&#34; alt=&#34;GitHub go.mod Go version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/anchore/grype/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License: Apache-2.0&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://anchore.com/slack&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Slack-Join-blue?logo=slack&#34; alt=&#34;Slack Invite&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A vulnerability scanner for container images and filesystems. Easily &lt;a href=&#34;https://raw.githubusercontent.com/anchore/grype/main/#installation&#34;&gt;install the binary&lt;/a&gt; to try it out. Works with &lt;a href=&#34;https://github.com/anchore/syft&#34;&gt;Syft&lt;/a&gt;, the powerful SBOM (software bill of materials) tool for container images and filesystems.&lt;/p&gt; &#xA;&lt;h3&gt;Join our community meetings!&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Calendar: &lt;a href=&#34;https://calendar.google.com/calendar/u/0/r?cid=Y182OTM4dGt0MjRtajI0NnNzOThiaGtnM29qNEBncm91cC5jYWxlbmRhci5nb29nbGUuY29t&#34;&gt;https://calendar.google.com/calendar/u/0/r?cid=Y182OTM4dGt0MjRtajI0NnNzOThiaGtnM29qNEBncm91cC5jYWxlbmRhci5nb29nbGUuY29t&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Agenda: &lt;a href=&#34;https://docs.google.com/document/d/1ZtSAa6fj2a6KRWviTn3WoJm09edvrNUp4Iz_dOjjyY8/edit?usp=sharing&#34;&gt;https://docs.google.com/document/d/1ZtSAa6fj2a6KRWviTn3WoJm09edvrNUp4Iz_dOjjyY8/edit?usp=sharing&lt;/a&gt; (join &lt;a href=&#34;https://groups.google.com/g/anchore-oss-community&#34;&gt;this group&lt;/a&gt; for write access)&lt;/li&gt; &#xA; &lt;li&gt;All are welcome!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For commercial support options with Syft or Grype, please &lt;a href=&#34;https://get.anchore.com/contact/&#34;&gt;contact Anchore&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/590471/90276236-9868f300-de31-11ea-8068-4268b6b68529.gif&#34; alt=&#34;grype-demo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Scan the contents of a container image or filesystem to find known vulnerabilities.&lt;/li&gt; &#xA; &lt;li&gt;Find vulnerabilities for major operating system packages: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Alpine&lt;/li&gt; &#xA;   &lt;li&gt;Amazon Linux&lt;/li&gt; &#xA;   &lt;li&gt;BusyBox&lt;/li&gt; &#xA;   &lt;li&gt;CentOS&lt;/li&gt; &#xA;   &lt;li&gt;Debian&lt;/li&gt; &#xA;   &lt;li&gt;Distroless&lt;/li&gt; &#xA;   &lt;li&gt;Oracle Linux&lt;/li&gt; &#xA;   &lt;li&gt;Red Hat (RHEL)&lt;/li&gt; &#xA;   &lt;li&gt;Ubuntu&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Find vulnerabilities for language-specific packages: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ruby (Gems)&lt;/li&gt; &#xA;   &lt;li&gt;Java (JAR, WAR, EAR, JPI, HPI)&lt;/li&gt; &#xA;   &lt;li&gt;JavaScript (NPM, Yarn)&lt;/li&gt; &#xA;   &lt;li&gt;Python (Egg, Wheel, Poetry, requirements.txt/setup.py files)&lt;/li&gt; &#xA;   &lt;li&gt;Dotnet (deps.json)&lt;/li&gt; &#xA;   &lt;li&gt;Golang (go.mod)&lt;/li&gt; &#xA;   &lt;li&gt;PHP (Composer)&lt;/li&gt; &#xA;   &lt;li&gt;Rust (Cargo)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Supports Docker, OCI and &lt;a href=&#34;https://github.com/sylabs/singularity&#34;&gt;Singularity&lt;/a&gt; image formats.&lt;/li&gt; &#xA; &lt;li&gt;Consume SBOM &lt;a href=&#34;https://github.com/anchore/syft#sbom-attestation&#34;&gt;attestations&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you encounter an issue, please &lt;a href=&#34;https://github.com/anchore/grype/issues&#34;&gt;let us know using the issue tracker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Recommended&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also choose another destination directory and release version for the installation. The destination directory doesn&#39;t need to be &lt;code&gt;/usr/local/bin&lt;/code&gt;, it just needs to be a location found in the user&#39;s PATH and writable by the user that&#39;s installing Grype.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b &amp;lt;DESTINATION_DIR&amp;gt; &amp;lt;RELEASE_VERSION&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Homebrew&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew tap anchore/grype&#xA;brew install grype&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MacPorts&lt;/h3&gt; &#xA;&lt;p&gt;On macOS, Grype can additionally be installed from the &lt;a href=&#34;https://ports.macports.org/port/grype/&#34;&gt;community maintained port&lt;/a&gt; via MacPorts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo port install grype&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Currently, Grype is built only for macOS and Linux.&lt;/p&gt; &#xA;&lt;h3&gt;From source&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/anchore/grype/main/DEVELOPING.md#native-development&#34;&gt;DEVELOPING.md&lt;/a&gt; for instructions to build and run from source.&lt;/p&gt; &#xA;&lt;h3&gt;GitHub Actions&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using GitHub Actions, you can simply use our &lt;a href=&#34;https://github.com/marketplace/actions/anchore-container-scan&#34;&gt;Grype-based action&lt;/a&gt; to run vulnerability scans on your code or container images during your CI workflows.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/anchore/grype/main/#installation&#34;&gt;Install the binary&lt;/a&gt;, and make sure that &lt;code&gt;grype&lt;/code&gt; is available in your path. To scan for vulnerabilities in an image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;grype &amp;lt;image&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above command scans for vulnerabilities that are visible in the container (i.e., the squashed representation of the image). To include software from all image layers in the vulnerability scan, regardless of its presence in the final image, provide &lt;code&gt;--scope all-layers&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;grype &amp;lt;image&amp;gt; --scope all-layers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run grype from a Docker container so it can scan a running container, use the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;docker run --rm \&#xA;--volume /var/run/docker.sock:/var/run/docker.sock \&#xA;--name Grype anchore/grype:latest \&#xA;$(ImageName):$(ImageTag)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Supported sources&lt;/h3&gt; &#xA;&lt;p&gt;Grype can scan a variety of sources beyond those found in Docker.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# scan a container image archive (from the result of `docker image save ...`, `podman save ...`, or `skopeo copy` commands)&#xA;grype path/to/image.tar&#xA;&#xA;# scan a Singularity Image Format (SIF) container&#xA;grype path/to/image.sif&#xA;&#xA;# scan a directory&#xA;grype dir:path/to/dir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sources can be explicitly provided with a scheme:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;podman:yourrepo/yourimage:tag          use images from the Podman daemon&#xA;docker:yourrepo/yourimage:tag          use images from the Docker daemon&#xA;docker-archive:path/to/yourimage.tar   use a tarball from disk for archives created from &#34;docker save&#34;&#xA;oci-archive:path/to/yourimage.tar      use a tarball from disk for OCI archives (from Skopeo or otherwise)&#xA;oci-dir:path/to/yourimage              read directly from a path on disk for OCI layout directories (from Skopeo or otherwise)&#xA;singularity:path/to/yourimage.sif      read directly from a Singularity Image Format (SIF) container on disk&#xA;dir:path/to/yourproject                read directly from a path on disk (any directory)&#xA;sbom:path/to/syft.json                 read Syft JSON from path on disk&#xA;registry:yourrepo/yourimage:tag        pull image directly from a registry (no container runtime required)&#xA;att:attestation.json --key cosign.pub  explicitly use the input as an attestation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use SBOMs for even faster vulnerability scanning in Grype:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Then scan for new vulnerabilities as frequently as needed&#xA;grype sbom:./sbom.json&#xA;&#xA;# (You can also pipe the SBOM into Grype)&#xA;cat ./sbom.json | grype&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Grype supports input of &lt;a href=&#34;https://github.com/anchore/syft&#34;&gt;Syft&lt;/a&gt;, &lt;a href=&#34;https://spdx.dev/&#34;&gt;SPDX&lt;/a&gt;, and &lt;a href=&#34;https://cyclonedx.org/&#34;&gt;CycloneDX&lt;/a&gt; SBOM formats. If Syft has generated any of these file types, they should have the appropriate information to work properly with Grype. It is also possible to use SBOMs generated by other tools with varying degrees of success. Two things that make Grype matching more successful are inclusion of CPE and Linux distribution information. If an SBOM does not include any CPE information, it is possible to generate these based on package information using the &lt;code&gt;--add-cpes-if-none&lt;/code&gt; flag. To specify a distribution, use the &lt;code&gt;--distro &amp;lt;distro&amp;gt;:&amp;lt;version&amp;gt;&lt;/code&gt; flag. A full example is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;grype --add-cpes-if-none --distro alpine:3.10 sbom:some-apline-3.10.spdx.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scan attestations&lt;/h3&gt; &#xA;&lt;p&gt;Grype can scan SBOMs from attestations as long as they are encoded &lt;a href=&#34;https://github.com/in-toto/attestation/raw/main/spec/README.md#envelope&#34;&gt;in-toto envelopes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# generate cosign key pair&#xA;cosign generate-key-pair # after that you&#39;ll have two files: cosign.key and cosign.pub&#xA;&#xA;# attest an image with Syft and your cosign private key (cosign.key)&#xA;syft attest --output json --key cosign.key alpine:latest &amp;gt; alpine.att.json&#xA;&#xA;# scan an SBOM from an attestation file with the cosign public key (cosign.pub)&#xA;grype alpine.json --key cosign.pub&#xA;&#xA;# explicitly tell Grype the input is an attestation file with the scheme `att:`&#xA;grype att:alpine.json --key cosign.pub&#xA;&#xA;# generate an attestation for an image with Syft and pipe it into Grype, just because you can :)&#xA;syft attest --output json --key cosign.key alpine:latest | grype --key cosign.pub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Vulnerability Summary&lt;/h3&gt; &#xA;&lt;h4&gt;Basic Grype Vulnerability Data Shape&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt; {&#xA;  &#34;vulnerability&#34;: {&#xA;    ...&#xA;  },&#xA;  &#34;relatedVulnerabilities&#34;: [&#xA;    ...&#xA;  ],&#xA;  &#34;matchDetails&#34;: [&#xA;    ...&#xA;  ],&#xA;  &#34;artifact&#34;: {&#xA;    ...&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Vulnerability&lt;/strong&gt;: All information on the specific vulnerability that was directly matched on (e.g. ID, severity, CVSS score, fix information, links for more information)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;RelatedVulnerabilities&lt;/strong&gt;: Information pertaining to vulnerabilities found to be related to the main reported vulnerability. Maybe the vulnerability we matched on was a GitHub Security Advisory, which has an upstream CVE (in the authoritative national vulnerability database). In these cases we list the upstream vulnerabilities here.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;MatchDetails&lt;/strong&gt;: This section tries to explain what we searched for while looking for a match and exactly what details on the package and vulnerability that lead to a match.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Artifact&lt;/strong&gt;: This is a subset of the information that we know about the package (when compared to the &lt;a href=&#34;https://github.com/anchore/syft&#34;&gt;Syft&lt;/a&gt; json output, we summarize the metadata section). This has information about where within the container image or directory we found the package, what kind of package it is, licensing info, pURLs, CPEs, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Excluding file paths&lt;/h3&gt; &#xA;&lt;p&gt;Grype can exclude files and paths from being scanned within a source by using glob expressions with one or more &lt;code&gt;--exclude&lt;/code&gt; parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;grype &amp;lt;source&amp;gt; --exclude &#39;./out/**/*.json&#39; --exclude /etc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; in the case of &lt;em&gt;image scanning&lt;/em&gt;, since the entire filesystem is scanned it is possible to use absolute paths like &lt;code&gt;/etc&lt;/code&gt; or &lt;code&gt;/usr/**/*.txt&lt;/code&gt; whereas &lt;em&gt;directory scans&lt;/em&gt; exclude files &lt;em&gt;relative to the specified directory&lt;/em&gt;. For example: scanning &lt;code&gt;/usr/foo&lt;/code&gt; with &lt;code&gt;--exclude ./package.json&lt;/code&gt; would exclude &lt;code&gt;/usr/foo/package.json&lt;/code&gt; and &lt;code&gt;--exclude &#39;**/package.json&#39;&lt;/code&gt; would exclude all &lt;code&gt;package.json&lt;/code&gt; files under &lt;code&gt;/usr/foo&lt;/code&gt;. For &lt;em&gt;directory scans&lt;/em&gt;, it is required to begin path expressions with &lt;code&gt;./&lt;/code&gt;, &lt;code&gt;*/&lt;/code&gt;, or &lt;code&gt;**/&lt;/code&gt;, all of which will be resolved &lt;em&gt;relative to the specified scan directory&lt;/em&gt;. Keep in mind, your shell may attempt to expand wildcards, so put those parameters in single quotes, like: &lt;code&gt;&#39;**/*.json&#39;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;External Sources&lt;/h3&gt; &#xA;&lt;p&gt;Grype can be configured to incorporate external data sources for added fidelity in vulnerability matching. This feature is currently disabled by default. To enable this feature add the following to the grype config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;external-sources:&#xA;  enable: true&#xA;  maven:&#xA;    search-upstream-by-sha1: true&#xA;    base-url: https://search.maven.org/solrsearch/select&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also configure the base-url if you&#39;re using another registry as your maven endpoint.&lt;/p&gt; &#xA;&lt;h3&gt;Output formats&lt;/h3&gt; &#xA;&lt;p&gt;The output format for Grype is configurable as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;grype &amp;lt;image&amp;gt; -o &amp;lt;format&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where the &lt;code&gt;format&lt;/code&gt;s available are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;table&lt;/code&gt;: A columnar summary (default).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cyclonedx&lt;/code&gt;: An XML report conforming to the &lt;a href=&#34;https://cyclonedx.org/&#34;&gt;CycloneDX 1.2&lt;/a&gt; specification.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;json&lt;/code&gt;: Use this to get as much information out of Grype as possible!&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;template&lt;/code&gt;: Lets the user specify the output format. See &lt;a href=&#34;https://raw.githubusercontent.com/anchore/grype/main/#using-templates&#34;&gt;&#34;Using templates&#34;&lt;/a&gt; below.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Using templates&lt;/h3&gt; &#xA;&lt;p&gt;Grype lets you define custom output formats, using &lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;Go templates&lt;/a&gt;. Here&#39;s how it works:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Define your format as a Go template, and save this template as a file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set the output format to &#34;template&#34; (&lt;code&gt;-o template&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Specify the path to the template file (&lt;code&gt;-t ./path/to/custom.template&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Grype&#39;s template processing uses the same data models as the &lt;code&gt;json&lt;/code&gt; output format — so if you&#39;re wondering what data is available as you author a template, you can use the output from &lt;code&gt;grype &amp;lt;image&amp;gt; -o json&lt;/code&gt; as a reference.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; You could make Grype output data in CSV format by writing a Go template that renders CSV data and then running &lt;code&gt;grype &amp;lt;image&amp;gt; -o template -t ~/path/to/csv.tmpl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s what the &lt;code&gt;csv.tmpl&lt;/code&gt; file might look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gotemplate&#34;&gt;&#34;Package&#34;,&#34;Version Installed&#34;,&#34;Vulnerability ID&#34;,&#34;Severity&#34;&#xA;{{- range .Matches}}&#xA;&#34;{{.Artifact.Name}}&#34;,&#34;{{.Artifact.Version}}&#34;,&#34;{{.Vulnerability.ID}}&#34;,&#34;{{.Vulnerability.Severity}}&#34;&#xA;{{- end}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which would produce output like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;&#34;Package&#34;,&#34;Version Installed&#34;,&#34;Vulnerability ID&#34;,&#34;Severity&#34;&#xA;&#34;coreutils&#34;,&#34;8.30-3ubuntu2&#34;,&#34;CVE-2016-2781&#34;,&#34;Low&#34;&#xA;&#34;libc-bin&#34;,&#34;2.31-0ubuntu9&#34;,&#34;CVE-2016-10228&#34;,&#34;Negligible&#34;&#xA;&#34;libc-bin&#34;,&#34;2.31-0ubuntu9&#34;,&#34;CVE-2020-6096&#34;,&#34;Low&#34;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Grype also includes a vast array of utility templating functions from &lt;a href=&#34;http://masterminds.github.io/sprig/&#34;&gt;sprig&lt;/a&gt; apart from the default golang &lt;a href=&#34;https://pkg.go.dev/text/template#hdr-Functions&#34;&gt;text/template&lt;/a&gt; to allow users to customize the output from Grype.&lt;/p&gt; &#xA;&lt;h3&gt;Gating on severity of vulnerabilities&lt;/h3&gt; &#xA;&lt;p&gt;You can have Grype exit with an error if any vulnerabilities are reported at or above the specified severity level. This comes in handy when using Grype within a script or CI pipeline. To do this, use the &lt;code&gt;--fail-on &amp;lt;severity&amp;gt;&lt;/code&gt; CLI flag.&lt;/p&gt; &#xA;&lt;p&gt;For example, here&#39;s how you could trigger a CI pipeline failure if any vulnerabilities are found in the &lt;code&gt;ubuntu:latest&lt;/code&gt; image with a severity of &#34;medium&#34; or higher:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;grype ubuntu:latest --fail-on medium&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying matches to ignore&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re seeing Grype report &lt;strong&gt;false positives&lt;/strong&gt; or any other vulnerability matches that you just don&#39;t want to see, you can tell Grype to &lt;strong&gt;ignore&lt;/strong&gt; matches by specifying one or more &lt;em&gt;&#34;ignore rules&#34;&lt;/em&gt; in your Grype configuration file (e.g. &lt;code&gt;~/.grype.yaml&lt;/code&gt;). This causes Grype not to report any vulnerability matches that meet the criteria specified by any of your ignore rules.&lt;/p&gt; &#xA;&lt;p&gt;Each rule can specify any combination of the following criteria:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;vulnerability ID (e.g. &lt;code&gt;&#34;CVE-2008-4318&#34;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;namespace (e.g. &lt;code&gt;&#34;nvd&#34;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;fix state (allowed values: &lt;code&gt;&#34;fixed&#34;&lt;/code&gt;, &lt;code&gt;&#34;not-fixed&#34;&lt;/code&gt;, &lt;code&gt;&#34;wont-fix&#34;&lt;/code&gt;, or &lt;code&gt;&#34;unknown&#34;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;package name (e.g. &lt;code&gt;&#34;libcurl&#34;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;package version (e.g. &lt;code&gt;&#34;1.5.1&#34;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;package language (e.g. &lt;code&gt;&#34;python&#34;&lt;/code&gt;; these values are defined &lt;a href=&#34;https://github.com/anchore/syft/raw/main/syft/pkg/language.go#L14-L23&#34;&gt;here&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;package type (e.g. &lt;code&gt;&#34;npm&#34;&lt;/code&gt;; these values are defined &lt;a href=&#34;https://github.com/anchore/syft/raw/main/syft/pkg/type.go#L10-L24&#34;&gt;here&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;package location (e.g. &lt;code&gt;&#34;/usr/local/lib/node_modules/**&#34;&lt;/code&gt;; supports glob patterns)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example &lt;code&gt;~/.grype.yaml&lt;/code&gt; that demonstrates the expected format for ignore rules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ignore:&#xA;  # This is the full set of supported rule fields:&#xA;  - vulnerability: CVE-2008-4318&#xA;    fix-state: unknown&#xA;    package:&#xA;      name: libcurl&#xA;      version: 1.5.1&#xA;      type: npm&#xA;      location: &#34;/usr/local/lib/node_modules/**&#34;&#xA;&#xA;  # We can make rules to match just by vulnerability ID:&#xA;  - vulnerability: CVE-2017-41432&#xA;&#xA;  # ...or just by a single package field:&#xA;  - package:&#xA;      type: gem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Vulnerability matches will be ignored if &lt;strong&gt;any&lt;/strong&gt; rules apply to the match. A rule is considered to apply to a given vulnerability match only if &lt;strong&gt;all&lt;/strong&gt; fields specified in the rule apply to the vulnerability match.&lt;/p&gt; &#xA;&lt;p&gt;When you run Grype while specifying ignore rules, the following happens to the vulnerability matches that are &#34;ignored&#34;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Ignored matches are &lt;strong&gt;completely hidden&lt;/strong&gt; from Grype&#39;s output, except for when using the &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; output formats; however, in these two formats, the ignored matches are &lt;strong&gt;removed&lt;/strong&gt; from the existing &lt;code&gt;matches&lt;/code&gt; array field, and they are placed in a new &lt;code&gt;ignoredMatches&lt;/code&gt; array field. Each listed ignored match also has an additional field, &lt;code&gt;appliedIgnoreRules&lt;/code&gt;, which is an array of any rules that caused Grype to ignore this vulnerability match.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ignored matches &lt;strong&gt;do not&lt;/strong&gt; factor into Grype&#39;s exit status decision when using &lt;code&gt;--fail-on &amp;lt;severity&amp;gt;&lt;/code&gt;. For instance, if a user specifies &lt;code&gt;--fail-on critical&lt;/code&gt;, and all of the vulnerability matches found with a &#34;critical&#34; severity have been &lt;em&gt;ignored&lt;/em&gt;, Grype will exit zero.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Please continue to &lt;strong&gt;&lt;a href=&#34;https://github.com/anchore/grype/issues/new/choose&#34;&gt;report&lt;/a&gt;&lt;/strong&gt; any false positives you see! Even if you can reliably filter out false positives using ignore rules, it&#39;s very helpful to the Grype community if we have as much knowledge about Grype&#39;s false positives as possible. This helps us continuously improve Grype!&lt;/p&gt; &#xA;&lt;h3&gt;Showing only &#34;fixed&#34; vulnerabilities&lt;/h3&gt; &#xA;&lt;p&gt;If you only want Grype to report vulnerabilities &lt;strong&gt;that have a confirmed fix&lt;/strong&gt;, you can use the &lt;code&gt;--only-fixed&lt;/code&gt; flag. (This automatically adds &lt;a href=&#34;https://raw.githubusercontent.com/anchore/grype/main/#specifying-matches-to-ignore&#34;&gt;ignore rules&lt;/a&gt; into Grype&#39;s configuration, such that vulnerabilities that aren&#39;t fixed will be ignored.)&lt;/p&gt; &#xA;&lt;p&gt;For example, here&#39;s a scan of Alpine 3.10:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;NAME          INSTALLED  FIXED-IN   VULNERABILITY   SEVERITY&#xA;apk-tools     2.10.6-r0  2.10.7-r0  CVE-2021-36159  Critical&#xA;libcrypto1.1  1.1.1k-r0             CVE-2021-3711   Critical&#xA;libcrypto1.1  1.1.1k-r0             CVE-2021-3712   High&#xA;libssl1.1     1.1.1k-r0             CVE-2021-3712   High&#xA;libssl1.1     1.1.1k-r0             CVE-2021-3711   Critical&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...and here&#39;s the same scan, but adding the flag &lt;code&gt;--only-fixed&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;NAME       INSTALLED  FIXED-IN   VULNERABILITY   SEVERITY&#xA;apk-tools  2.10.6-r0  2.10.7-r0  CVE-2021-36159  Critical&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want Grype to only report vulnerabilities &lt;strong&gt;that do not have a confirmed fix&lt;/strong&gt;, you can use the &lt;code&gt;--only-notfixed&lt;/code&gt; flag. (This automatically adds &lt;a href=&#34;https://raw.githubusercontent.com/anchore/grype/main/#specifying-matches-to-ignore&#34;&gt;ignore rules&lt;/a&gt; into Grype&#39;s configuration, such that vulnerabilities that are fixed will be ignored.)&lt;/p&gt; &#xA;&lt;h2&gt;Grype&#39;s database&lt;/h2&gt; &#xA;&lt;p&gt;When Grype performs a scan for vulnerabilities, it does so using a vulnerability database that&#39;s stored on your local filesystem, which is constructed by pulling data from a variety of publicly available vulnerability data sources. These sources include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alpine Linux SecDB: &lt;a href=&#34;https://secdb.alpinelinux.org/&#34;&gt;https://secdb.alpinelinux.org/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Amazon Linux ALAS: &lt;a href=&#34;https://alas.aws.amazon.com/AL2/alas.rss&#34;&gt;https://alas.aws.amazon.com/AL2/alas.rss&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;RedHat RHSAs: &lt;a href=&#34;https://www.redhat.com/security/data/oval/&#34;&gt;https://www.redhat.com/security/data/oval/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Debian Linux CVE Tracker: &lt;a href=&#34;https://security-tracker.debian.org/tracker/data/json&#34;&gt;https://security-tracker.debian.org/tracker/data/json&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Github GHSAs: &lt;a href=&#34;https://github.com/advisories&#34;&gt;https://github.com/advisories&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;National Vulnerability Database (NVD): &lt;a href=&#34;https://nvd.nist.gov/vuln/data-feeds&#34;&gt;https://nvd.nist.gov/vuln/data-feeds&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Oracle Linux OVAL: &lt;a href=&#34;https://linux.oracle.com/security/oval/&#34;&gt;https://linux.oracle.com/security/oval/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;RedHat Linux Security Data: &lt;a href=&#34;https://access.redhat.com/hydra/rest/securitydata/&#34;&gt;https://access.redhat.com/hydra/rest/securitydata/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Suse Linux OVAL: &lt;a href=&#34;https://ftp.suse.com/pub/projects/security/oval/&#34;&gt;https://ftp.suse.com/pub/projects/security/oval/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu Linux Security: &lt;a href=&#34;https://people.canonical.com/~ubuntu-security/&#34;&gt;https://people.canonical.com/~ubuntu-security/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, Grype automatically manages this database for you. Grype checks for new updates to the vulnerability database to make sure that every scan uses up-to-date vulnerability information. This behavior is configurable. For more information, see the &lt;a href=&#34;https://raw.githubusercontent.com/anchore/grype/main/#managing-grypes-database&#34;&gt;Managing Grype&#39;s database&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h3&gt;How database updates work&lt;/h3&gt; &#xA;&lt;p&gt;Grype&#39;s vulnerability database is a SQLite file, named &lt;code&gt;vulnerability.db&lt;/code&gt;. Updates to the database are atomic: the entire database is replaced and then treated as &#34;readonly&#34; by Grype.&lt;/p&gt; &#xA;&lt;p&gt;Grype&#39;s first step in a database update is discovering databases that are available for retrieval. Grype does this by requesting a &#34;listing file&#34; from a public endpoint:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;https://toolbox-data.anchore.io/grype/databases/listing.json&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The listing file contains entries for every database that&#39;s available for download.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of an entry in the listing file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;built&#34;: &#34;2021-10-21T08:13:41Z&#34;,&#xA;  &#34;version&#34;: 3,&#xA;  &#34;url&#34;: &#34;https://toolbox-data.anchore.io/grype/databases/vulnerability-db_v3_2021-10-21T08:13:41Z.tar.gz&#34;,&#xA;  &#34;checksum&#34;: &#34;sha256:8c99fb4e516f10b304f026267c2a73a474e2df878a59bf688cfb0f094bfe7a91&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this information, Grype can select the correct database (the most recently built database with the current schema version), download the database, and verify the database&#39;s integrity using the listed &lt;code&gt;checksum&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;h3&gt;Managing Grype&#39;s database&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; During normal usage, &lt;em&gt;there is no need for users to manage Grype&#39;s database!&lt;/em&gt; Grype manages its database behind the scenes. However, for users that need more control, Grype provides options to manage the database more explicitly.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Local database cache directory&lt;/h4&gt; &#xA;&lt;p&gt;By default, the database is cached on the local filesystem in the directory &lt;code&gt;$XDG_CACHE_HOME/grype/db/&amp;lt;SCHEMA-VERSION&amp;gt;/&lt;/code&gt;. For example, on macOS, the database would be stored in &lt;code&gt;~/Library/Caches/grype/db/3/&lt;/code&gt;. (For more information on XDG paths, refer to the &lt;a href=&#34;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&#34;&gt;XDG Base Directory Specification&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;You can set the cache directory path using the environment variable &lt;code&gt;GRYPE_DB_CACHE_DIR&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Data staleness&lt;/h4&gt; &#xA;&lt;p&gt;Grype needs up-to-date vulnerability information to provide accurate matches. By default, it will fail execution if the local database was not built in the last 5 days. The data staleness check is configurable via the environment variable &lt;code&gt;GRYPE_DB_MAX_ALLOWED_BUILT_AGE&lt;/code&gt; and &lt;code&gt;GRYPE_DB_VALIDATE_AGE&lt;/code&gt; or the field &lt;code&gt;max-allowed-built-age&lt;/code&gt; and &lt;code&gt;validate-age&lt;/code&gt;, under &lt;code&gt;db&lt;/code&gt;. It uses &lt;a href=&#34;https://pkg.go.dev/time#ParseDuration&#34;&gt;golang&#39;s time duration syntax&lt;/a&gt;. Set &lt;code&gt;GRYPE_DB_VALIDATE_AGE&lt;/code&gt; or &lt;code&gt;validate-age&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; to disable staleness check.&lt;/p&gt; &#xA;&lt;h4&gt;Offline and air-gapped environments&lt;/h4&gt; &#xA;&lt;p&gt;By default, Grype checks for a new database on every run, by making a network call over the Internet. You can tell Grype not to perform this check by setting the environment variable &lt;code&gt;GRYPE_DB_AUTO_UPDATE&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As long as you place Grype&#39;s &lt;code&gt;vulnerability.db&lt;/code&gt; and &lt;code&gt;metadata.json&lt;/code&gt; files in the cache directory for the expected schema version, Grype has no need to access the network. Additionally, you can get a listing of the database archives available for download from the &lt;code&gt;grype db list&lt;/code&gt; command in an online environment, download the database archive, transfer it to your offline environment, and use &lt;code&gt;grype db import &amp;lt;db-archive-path&amp;gt;&lt;/code&gt; to use the given database in an offline capacity.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to distribute your own Grype databases internally without needing to use &lt;code&gt;db import&lt;/code&gt; manually you can leverage Grype&#39;s DB update mechanism. To do this you can craft your own &lt;code&gt;listing.json&lt;/code&gt; file similar to the one found publically (see &lt;code&gt;grype db list -o raw&lt;/code&gt; for an example of our public &lt;code&gt;listing.json&lt;/code&gt; file) and change the download URL to point to an internal endpoint (e.g. a private S3 bucket, an internal file server, etc). Any internal installation of Grype can receive database updates automatically by configuring the &lt;code&gt;db.update-url&lt;/code&gt; (same as the &lt;code&gt;GRYPE_DB_UPDATE_URL&lt;/code&gt; environment variable) to point to the hosted &lt;code&gt;listing.json&lt;/code&gt; file you&#39;ve crafted.&lt;/p&gt; &#xA;&lt;h4&gt;CLI commands for database management&lt;/h4&gt; &#xA;&lt;p&gt;Grype provides database-specific CLI commands for users that want to control the database from the command line. Here are some of the useful commands provided:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;grype db status&lt;/code&gt; — report the current status of Grype&#39;s database (such as its location, build date, and checksum)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;grype db check&lt;/code&gt; — see if updates are available for the database&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;grype db update&lt;/code&gt; — ensure the latest database has been downloaded to the cache directory (Grype performs this operation at the beginning of every scan by default)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;grype db list&lt;/code&gt; — download the listing file configured at &lt;code&gt;db.update-url&lt;/code&gt; and show databases that are available for download&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;grype db import&lt;/code&gt; — provide grype with a database archive to explicitly use (useful for offline DB updates)&lt;/p&gt; &#xA;&lt;p&gt;Find complete information on Grype&#39;s database commands by running &lt;code&gt;grype db --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Shell completion&lt;/h2&gt; &#xA;&lt;p&gt;Grype supplies shell completion through its CLI implementation (&lt;a href=&#34;https://github.com/spf13/cobra/raw/master/shell_completions.md&#34;&gt;cobra&lt;/a&gt;). Generate the completion code for your shell by running one of the following commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;grype completion &amp;lt;bash|zsh|fish&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;go run main.go completion &amp;lt;bash|zsh|fish&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This will output a shell script to STDOUT, which can then be used as a completion script for Grype. Running one of the above commands with the &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; flags will provide instructions on how to do that for your chosen shell.&lt;/p&gt; &#xA;&lt;h2&gt;Private Registry Authentication&lt;/h2&gt; &#xA;&lt;h3&gt;Local Docker Credentials&lt;/h3&gt; &#xA;&lt;p&gt;When a container runtime is not present, grype can still utilize credentials configured in common credential sources (such as &lt;code&gt;~/.docker/config.json&lt;/code&gt;). It will pull images from private registries using these credentials. The config file is where your credentials are stored when authenticating with private registries via some command like &lt;code&gt;docker login&lt;/code&gt;. For more information see the &lt;code&gt;go-containerregistry&lt;/code&gt; &lt;a href=&#34;https://github.com/google/go-containerregistry/tree/main/pkg/authn&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;An example &lt;code&gt;config.json&lt;/code&gt; looks something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// config.json&#xA;{&#xA;&#x9;&#34;auths&#34;: {&#xA;&#x9;&#x9;&#34;registry.example.com&#34;: {&#xA;&#x9;&#x9;&#x9;&#34;username&#34;: &#34;AzureDiamond&#34;,&#xA;&#x9;&#x9;&#x9;&#34;password&#34;: &#34;hunter2&#34;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run the following command as an example. It details the mount/environment configuration a container needs to access a private registry:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;docker run -v ./config.json:/config/config.json -e &#34;DOCKER_CONFIG=/config&#34; anchore/grype:latest &amp;lt;private_image&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Docker Credentials in Kubernetes&lt;/h3&gt; &#xA;&lt;p&gt;The below section shows a simple workflow on how to mount this config file as a secret into a container on kubernetes.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a secret. The value of &lt;code&gt;config.json&lt;/code&gt; is important. It refers to the specification detailed &lt;a href=&#34;https://github.com/google/go-containerregistry/tree/main/pkg/authn#the-config-file&#34;&gt;here&lt;/a&gt;. Below this section is the &lt;code&gt;secret.yaml&lt;/code&gt; file that the pod configuration will consume as a volume. The key &lt;code&gt;config.json&lt;/code&gt; is important. It will end up being the name of the file when mounted into the pod. &lt;pre&gt;&lt;code class=&#34;language-#&#34;&gt;&#xA;    apiVersion: v1&#xA;    kind: Secret&#xA;    metadata:&#xA;      name: registry-config&#xA;      namespace: grype&#xA;    data:&#xA;      config.json: &amp;lt;base64 encoded config.json&amp;gt;&#xA;    ```&#xA;&#xA;    `kubectl apply -f secret.yaml`&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Create your pod running grype. The env &lt;code&gt;DOCKER_CONFIG&lt;/code&gt; is important because it advertises where to look for the credential file. In the below example, setting &lt;code&gt;DOCKER_CONFIG=/config&lt;/code&gt; informs grype that credentials can be found at &lt;code&gt;/config/config.json&lt;/code&gt;. This is why we used &lt;code&gt;config.json&lt;/code&gt; as the key for our secret. When mounted into containers the secrets&#39; key is used as the filename. The &lt;code&gt;volumeMounts&lt;/code&gt; section mounts our secret to &lt;code&gt;/config&lt;/code&gt;. The &lt;code&gt;volumes&lt;/code&gt; section names our volume and leverages the secret we created in step one. &lt;pre&gt;&lt;code class=&#34;language-#&#34;&gt;&#xA;    apiVersion: v1&#xA;    kind: Pod&#xA;    spec:&#xA;      containers:&#xA;        - image: anchore/grype:latest&#xA;          name: grype-private-registry-demo&#xA;          env:&#xA;            - name: DOCKER_CONFIG&#xA;              value: /config&#xA;          volumeMounts:&#xA;          - mountPath: /config&#xA;            name: registry-config&#xA;            readOnly: true&#xA;          args:&#xA;            - &amp;lt;private_image&amp;gt;&#xA;      volumes:&#xA;      - name: registry-config&#xA;        secret:&#xA;          secretName: registry-config&#xA;    ```&#xA;&#xA;    `kubectl apply -f pod.yaml`&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;The user can now run &lt;code&gt;kubectl logs grype-private-registry-demo&lt;/code&gt;. The logs should show the grype analysis for the &lt;code&gt;&amp;lt;private_image&amp;gt;&lt;/code&gt; provided in the pod configuration.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Using the above information, users should be able to configure private registry access without having to do so in the &lt;code&gt;grype&lt;/code&gt; or &lt;code&gt;syft&lt;/code&gt; configuration files. They will also not be dependent on a docker daemon, (or some other runtime software) for registry configuration and access.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Configuration search paths:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.grype.yaml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.grype/config.yaml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;~/.grype.yaml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;XDG_CONFIG_HOME&amp;gt;/grype/config.yaml&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Configuration options (example values are the default):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# enable/disable checking for application updates on startup&#xA;# same as GRYPE_CHECK_FOR_APP_UPDATE env var&#xA;check-for-app-update: true&#xA;&#xA;# upon scanning, if a severity is found at or above the given severity then the return code will be 1&#xA;# default is unset which will skip this validation (options: negligible, low, medium, high, critical)&#xA;# same as --fail-on ; GRYPE_FAIL_ON_SEVERITY env var&#xA;fail-on-severity: &#34;&#34;&#xA;&#xA;# the output format of the vulnerability report (options: table, json, cyclonedx)&#xA;# same as -o ; GRYPE_OUTPUT env var&#xA;output: &#34;table&#34;&#xA;&#xA;# suppress all output (except for the vulnerability list)&#xA;# same as -q ; GRYPE_QUIET env var&#xA;quiet: false&#xA;&#xA;# write output report to a file (default is to write to stdout)&#xA;# same as --file; GRYPE_FILE env var&#xA;file: &#34;&#34;&#xA;&#xA;# a list of globs to exclude from scanning, for example:&#xA;# exclude:&#xA;#   - &#39;/etc/**&#39;&#xA;#   - &#39;./out/**/*.json&#39;&#xA;# same as --exclude ; GRYPE_EXCLUDE env var&#xA;exclude: []&#xA;&#xA;# os and/or architecture to use when referencing container images (e.g. &#34;windows/armv6&#34; or &#34;arm64&#34;)&#xA;# same as --platform; GRYPE_PLATFORM env var&#xA;platform: &#34;&#34;&#xA;&#xA;# If using SBOM input, automatically generate CPEs when packages have none&#xA;add-cpes-if-none: false&#xA;&#xA;# Explicitly specify a linux distribution to use as &amp;lt;distro&amp;gt;:&amp;lt;version&amp;gt; like alpine:3.10&#xA;distro:&#xA;&#xA;external-sources:&#xA;  enable: false&#xA;  maven:&#xA;    search-upstream-by-sha1: true&#xA;    base-url: https://search.maven.org/solrsearch/select&#xA;&#xA;db:&#xA;  # check for database updates on execution&#xA;  # same as GRYPE_DB_AUTO_UPDATE env var&#xA;  auto-update: true&#xA;&#xA;  # location to write the vulnerability database cache&#xA;  # same as GRYPE_DB_CACHE_DIR env var&#xA;  cache-dir: &#34;$XDG_CACHE_HOME/grype/db&#34;&#xA;&#xA;  # URL of the vulnerability database&#xA;  # same as GRYPE_DB_UPDATE_URL env var&#xA;  update-url: &#34;https://toolbox-data.anchore.io/grype/databases/listing.json&#34;&#xA;&#xA;  # it ensures db build is no older than the max-allowed-built-age&#xA;  # set to false to disable check&#xA;  validate-age: true&#xA;&#xA;  # Max allowed age for vulnerability database,&#xA;  # age being the time since it was built&#xA;  # Default max age is 120h (or five days)&#xA;  max-allowed-built-age: &#34;120h&#34;&#xA;&#xA;search:&#xA;  # the search space to look for packages (options: all-layers, squashed)&#xA;  # same as -s ; GRYPE_SEARCH_SCOPE env var&#xA;  scope: &#34;squashed&#34;&#xA;&#xA;  # search within archives that do contain a file index to search against (zip)&#xA;  # note: for now this only applies to the java package cataloger&#xA;  # same as GRYPE_PACKAGE_SEARCH_INDEXED_ARCHIVES env var&#xA;  indexed-archives: true&#xA;&#xA;  # search within archives that do not contain a file index to search against (tar, tar.gz, tar.bz2, etc)&#xA;  # note: enabling this may result in a performance impact since all discovered compressed tars will be decompressed&#xA;  # note: for now this only applies to the java package cataloger&#xA;  # same as GRYPE_PACKAGE_SEARCH_UNINDEXED_ARCHIVES env var&#xA;  unindexed-archives: false&#xA;&#xA;# options when pulling directly from a registry via the &#34;registry:&#34; scheme&#xA;registry:&#xA;  # skip TLS verification when communicating with the registry&#xA;  # same as GRYPE_REGISTRY_INSECURE_SKIP_TLS_VERIFY env var&#xA;  insecure-skip-tls-verify: false&#xA;  # use http instead of https when connecting to the registry&#xA;  # same as GRYPE_REGISTRY_INSECURE_USE_HTTP env var&#xA;  insecure-use-http: false&#xA;&#xA;  # credentials for specific registries&#xA;  auth:&#xA;    - # the URL to the registry (e.g. &#34;docker.io&#34;, &#34;localhost:5000&#34;, etc.)&#xA;      # same as GRYPE_REGISTRY_AUTH_AUTHORITY env var&#xA;      authority: &#34;&#34;&#xA;      # same as GRYPE_REGISTRY_AUTH_USERNAME env var&#xA;      username: &#34;&#34;&#xA;      # same as GRYPE_REGISTRY_AUTH_PASSWORD env var&#xA;      password: &#34;&#34;&#xA;      # note: token and username/password are mutually exclusive&#xA;      # same as GRYPE_REGISTRY_AUTH_TOKEN env var&#xA;      token: &#34;&#34;&#xA;    - ... # note, more credentials can be provided via config file only&#xA;&#xA;log:&#xA;  # use structured logging&#xA;  # same as GRYPE_LOG_STRUCTURED env var&#xA;  structured: false&#xA;&#xA;  # the log level; note: detailed logging suppress the ETUI&#xA;  # same as GRYPE_LOG_LEVEL env var&#xA;  # Uses logrus logging levels: https://github.com/sirupsen/logrus#level-logging&#xA;  level: &#34;error&#34;&#xA;&#xA;  # location to write the log file (default is not to have a log file)&#xA;  # same as GRYPE_LOG_FILE env var&#xA;  file: &#34;&#34;&#xA;&#xA;match:&#xA;  # sets the matchers below to use cpes when trying to find &#xA;  # vulnerability matches. The stock matcher is the default&#xA;  # when no primary matcher can be identified &#xA;  java:&#xA;    using-cpes: true&#xA;  python:&#xA;    using-cpes: true&#xA;  javascript:&#xA;    using-cpes: true&#xA;  ruby:&#xA;    using-cpes: true&#xA;  dotnet:&#xA;    using-cpes: true&#xA;  golang:&#xA;    using-cpes: true&#xA;  stock:&#xA;    using-cpes: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Future plans&lt;/h2&gt; &#xA;&lt;p&gt;The following areas of potential development are currently being investigated:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for allowlist, package mapping&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>vmware-tanzu/community-edition</title>
    <updated>2022-11-03T01:34:24Z</updated>
    <id>tag:github.com,2022-11-03:/vmware-tanzu/community-edition</id>
    <link href="https://github.com/vmware-tanzu/community-edition" rel="alternate"></link>
    <summary type="html">&lt;p&gt;VMware Tanzu Community Edition is no longer an actively maintained project. Code is available for historical purposes only.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Tanzu Community Edition&lt;/h1&gt; &#xA;&lt;p&gt;Acting on insights gained through community engagement over the past year, VMware has decided to offer a free download of VMware Tanzu Kubernetes Grid in place of VMware Tanzu Community Edition software and to retire the Tanzu Community Edition open source project.&lt;/p&gt; &#xA;&lt;p&gt;This project is no longer being updated or maintained and code related to the project will be removed by the end of this calendar year (Dec 2022). Users can download Tanzu Kubernetes Grid &lt;a href=&#34;https://www.vmware.com/go/get-tkg&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>