<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-05T01:31:46Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sigstore/cosign</title>
    <updated>2023-01-05T01:31:46Z</updated>
    <id>tag:github.com,2023-01-05:/sigstore/cosign</id>
    <link href="https://github.com/sigstore/cosign" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Signing containers (and other artifacts) using Sigstore&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img style=&#34;max-width: 100%;width: 300px;&#34; src=&#34;https://raw.githubusercontent.com/sigstore/community/main/artwork/cosign/horizontal/color/sigstore_cosign-horizontal-color.svg?sanitize=true&#34; alt=&#34;Cosign logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;cosign&lt;/h1&gt; &#xA;&lt;p&gt;Signing OCI containers (and other artifacts) using &lt;a href=&#34;https://sigstore.dev/&#34;&gt;Sigstore&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://goreportcard.com/report/github.com/sigstore/cosign&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/sigstore/cosign&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sigstore/cosign/actions/workflows/e2e-tests.yml&#34;&gt;&lt;img src=&#34;https://github.com/sigstore/cosign/actions/workflows/e2e-tests.yml/badge.svg?sanitize=true&#34; alt=&#34;e2e-tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bestpractices.coreinfrastructure.org/projects/5715&#34;&gt;&lt;img src=&#34;https://bestpractices.coreinfrastructure.org/projects/5715/badge&#34; alt=&#34;CII Best Practices&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://api.securityscorecards.dev/projects/github.com/sigstore/cosign&#34;&gt;&lt;img src=&#34;https://api.securityscorecards.dev/projects/github.com/sigstore/cosign/badge&#34; alt=&#34;OpenSSF Scorecard&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Cosign aims to make signatures &lt;strong&gt;invisible infrastructure&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Cosign supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Hardware and KMS signing&lt;/li&gt; &#xA; &lt;li&gt;Container Signing, Verification and Storage in an OCI registry.&lt;/li&gt; &#xA; &lt;li&gt;Bring-your-own PKI&lt;/li&gt; &#xA; &lt;li&gt;Our free OIDC PKI (&lt;a href=&#34;https://github.com/sigstore/fulcio&#34;&gt;Fulcio&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Built-in binary transparency and timestamping service (&lt;a href=&#34;https://github.com/sigstore/rekor&#34;&gt;Rekor&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/images/intro.gif&#34; alt=&#34;intro&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Info&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Cosign&lt;/code&gt; is developed as part of the &lt;a href=&#34;https://sigstore.dev&#34;&gt;&lt;code&gt;sigstore&lt;/code&gt;&lt;/a&gt; project. We also use a &lt;a href=&#34;https://sigstore.slack.com&#34;&gt;slack channel&lt;/a&gt;! Click &lt;a href=&#34;https://join.slack.com/t/sigstore/shared_invite/zt-mhs55zh0-XmY3bcfWn4XEyMqUUutbUQ&#34;&gt;here&lt;/a&gt; for the invite link.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;For Homebrew, Arch, Nix, GitHub Action, and Kubernetes installs see the &lt;a href=&#34;https://docs.sigstore.dev/cosign/installation&#34;&gt;installation docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Linux and macOS binaries see the &lt;a href=&#34;https://github.com/sigstore/cosign/releases/latest&#34;&gt;GitHub release assets&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Developer Installation&lt;/h2&gt; &#xA;&lt;p&gt;If you have Go 1.19+, you can setup a development environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git clone https://github.com/sigstore/cosign&#xA;$ cd cosign&#xA;$ go install ./cmd/cosign&#xA;$ $(go env GOPATH)/bin/cosign&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you are interested in contributing to &lt;code&gt;cosign&lt;/code&gt;, please read the &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/CONTRIBUTING.md&#34;&gt;contributing documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Dockerfile&lt;/h2&gt; &#xA;&lt;p&gt;Here is how to install and use cosign inside a Dockerfile through the gcr.io/projectsigstore/cosign image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM gcr.io/projectsigstore/cosign:v1.13.0 as cosign-bin&#xA;&#xA;# Source: https://github.com/chainguard-images/static&#xA;FROM cgr.dev/chainguard/static:latest&#xA;COPY --from=cosign-bin /ko-app/cosign /usr/local/bin/cosign&#xA;ENTRYPOINT [ &#34;cosign&#34; ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;This shows how to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;generate a keypair&lt;/li&gt; &#xA; &lt;li&gt;sign a container image and store that signature in the registry&lt;/li&gt; &#xA; &lt;li&gt;find signatures for a container image, and verify them against a public key&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/USAGE.md&#34;&gt;Usage documentation&lt;/a&gt; for more commands!&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/FUN.md&#34;&gt;FUN.md&lt;/a&gt; documentation for some fun tips and tricks!&lt;/p&gt; &#xA;&lt;p&gt;NOTE: you will need access to a container registry for cosign to work with. &lt;a href=&#34;https://ttl.sh&#34;&gt;ttl.sh&lt;/a&gt; offers free, short-lived (ie: hours), anonymous container image hosting if you just want to try these commands out.&lt;/p&gt; &#xA;&lt;p&gt;For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ SRC_IMAGE=busybox&#xA;$ SRC_DIGEST=$(crane digest busybox)&#xA;$ IMAGE_URI=ttl.sh/$(uuidgen | head -c 8 | tr &#39;A-Z&#39; &#39;a-z&#39;)&#xA;$ crane cp $SRC_IMAGE@$SRC_DIGEST $IMAGE_URI:1h&#xA;$ IMAGE_URI_DIGEST=$IMAGE_URI@$SRC_DIGEST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generate a keypair&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign generate-key-pair&#xA;Enter password for private key:&#xA;Enter again:&#xA;Private key written to cosign.key&#xA;Public key written to cosign.pub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sign a container and store the signature in the registry&lt;/h3&gt; &#xA;&lt;p&gt;Note that you should always sign images based on their digest (&lt;code&gt;@sha256:...&lt;/code&gt;) rather than a tag (&lt;code&gt;:latest&lt;/code&gt;) because otherwise you might sign something you didn&#39;t intend to!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign sign --key cosign.key $IMAGE_URI_DIGEST&#xA;Enter password for private key:&#xA;Pushing signature to: index.docker.io/dlorenc/demo:sha256-87ef60f558bad79beea6425a3b28989f01dd417164150ab3baab98dcbf04def8.sig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The cosign command above prompts the user to enter the password for the private key. The user can either manually enter the password, or if the environment variable &lt;code&gt;COSIGN_PASSWORD&lt;/code&gt; is set then it is used automatically.&lt;/p&gt; &#xA;&lt;h3&gt;Verify a container against a public key&lt;/h3&gt; &#xA;&lt;p&gt;This command returns &lt;code&gt;0&lt;/code&gt; if &lt;em&gt;at least one&lt;/em&gt; &lt;code&gt;cosign&lt;/code&gt; formatted signature for the image is found matching the public key. See the detailed usage below for information and caveats on other signature formats.&lt;/p&gt; &#xA;&lt;p&gt;Any valid payloads are printed to stdout, in json format. Note that these signed payloads include the digest of the container image, which is how we can be sure these &#34;detached&#34; signatures cover the correct image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign verify --key cosign.pub $IMAGE_URI&#xA;The following checks were performed on these signatures:&#xA;  - The cosign claims were validated&#xA;  - The signatures were verified against the specified public key&#xA;{&#34;Critical&#34;:{&#34;Identity&#34;:{&#34;docker-reference&#34;:&#34;&#34;},&#34;Image&#34;:{&#34;Docker-manifest-digest&#34;:&#34;sha256:87ef60f558bad79beea6425a3b28989f01dd417164150ab3baab98dcbf04def8&#34;},&#34;Type&#34;:&#34;cosign container image signature&#34;},&#34;Optional&#34;:null}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;Cosign&lt;/code&gt; is 1.0!&lt;/h2&gt; &#xA;&lt;p&gt;This means the core feature set of &lt;code&gt;cosign&lt;/code&gt; is considered ready for production use. This core set includes:&lt;/p&gt; &#xA;&lt;h3&gt;Key Management&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;fixed, text-based keys generated using &lt;code&gt;cosign generate-key-pair&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;cloud KMS-based keys generated using &lt;code&gt;cosign generate-key-pair -kms&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;keys generated on hardware tokens using the PIV interface using &lt;code&gt;cosign piv-tool&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Kubernetes-secret based keys generated using &lt;code&gt;cosign generate-key-pair k8s://namespace/secretName&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Artifact Types&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OCI and Docker Images&lt;/li&gt; &#xA; &lt;li&gt;Other artifacts that can be stored in a container registry, including: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Tekton Bundles&lt;/li&gt; &#xA;   &lt;li&gt;Helm Charts&lt;/li&gt; &#xA;   &lt;li&gt;WASM modules&lt;/li&gt; &#xA;   &lt;li&gt;eBPF modules&lt;/li&gt; &#xA;   &lt;li&gt;(probably anything else, feel free to add things to this list)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Text files and other binary blobs, using &lt;code&gt;cosign sign-blob&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;What ** is not ** production ready?&lt;/h3&gt; &#xA;&lt;p&gt;While parts of &lt;code&gt;cosign&lt;/code&gt; are stable, we are continuing to experiment and add new features. The following feature set is not considered stable yet, but we are committed to stabilizing it over time!&lt;/p&gt; &#xA;&lt;h4&gt;Anything under the &lt;code&gt;COSIGN_EXPERIMENTAL&lt;/code&gt; environment variable&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Integration with the &lt;code&gt;Rekor&lt;/code&gt; transparency log&lt;/li&gt; &#xA; &lt;li&gt;Keyless signatures using the &lt;code&gt;Fulcio&lt;/code&gt; CA&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Formats/Specifications&lt;/h4&gt; &#xA;&lt;p&gt;While the &lt;code&gt;cosign&lt;/code&gt; code for uploading, signing, retrieving, and verifying several artifact types is stable, the format specifications for some of those types may not be considered stable yet. Some of these are developed outside of the &lt;code&gt;cosign&lt;/code&gt; project, so we are waiting for them to stabilize first.&lt;/p&gt; &#xA;&lt;p&gt;These include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The SBOM specification for storing SBOMs in a container registry&lt;/li&gt; &#xA; &lt;li&gt;The In-Toto attestation format&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Working with Other Artifacts&lt;/h2&gt; &#xA;&lt;p&gt;OCI registries are useful for storing more than just container images! &lt;code&gt;Cosign&lt;/code&gt; also includes some utilities for publishing generic artifacts, including binaries, scripts, and configuration files using the OCI protocol.&lt;/p&gt; &#xA;&lt;p&gt;This section shows how to leverage these for an easy-to-use, backwards-compatible artifact distribution system that integrates well with the rest of Sigstore.&lt;/p&gt; &#xA;&lt;h3&gt;Blobs&lt;/h3&gt; &#xA;&lt;p&gt;You can publish an artifact with &lt;code&gt;cosign upload blob&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ echo &#34;my first artifact&#34; &amp;gt; artifact&#xA;$ BLOB_SUM=$(shasum -a 256 artifact | cut -d&#39; &#39; -f 1)&#xA;c69d72c98b55258f9026f984e4656f0e9fd3ef024ea3fac1d7e5c7e6249f1626  artifact&#xA;BLOB_NAME=my-artifact-(uuidgen | head -c 8 | tr &#39;A-Z&#39; &#39;a-z&#39;)&#xA;$ BLOB_URI=ttl.sh/$BLOB_NAME:1h&#xA;$ BLOB_URI_DIGEST=$(cosign upload blob -f artifact $BLOB_URI)&#xA;Uploading file from [artifact] to [ttl.sh/my-artifact-f42c22e0:5m] with media type [text/plain]&#xA;File [artifact] is available directly at [ttl.sh/v2/my-artifact-f42c22e0/blobs/sha256:c69d72c98b55258f9026f984e4656f0e9fd3ef024ea3fac1d7e5c7e6249f1626]&#xA;Uploaded image to:&#xA;ttl.sh/my-artifact-f42c22e0@sha256:790d47850411e902aabebc3a684eeb78fcae853d4dd6e1cc554d70db7f05f99f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Your users can download it from the &#34;direct&#34; url with standard tools like curl or wget:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -L ttl.sh/v2/$BLOB_NAME/blobs/sha256:$BLOB_SUM &amp;gt; artifact-fetched&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The digest is baked right into the URL, so they can check that as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cat artifact-fetched | shasum -a 256&#xA;c69d72c98b55258f9026f984e4656f0e9fd3ef024ea3fac1d7e5c7e6249f1626  -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can sign it with the normal &lt;code&gt;cosign sign&lt;/code&gt; command and flags:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign sign --key cosign.key $BLOB_URI_DIGEST&#xA;Enter password for private key:&#xA;Pushing signature to: ttl.sh/my-artifact-f42c22e0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As usual, make sure to reference any images you sign by their digest to make sure you don&#39;t sign the wrong thing!&lt;/p&gt; &#xA;&lt;h4&gt;sget&lt;/h4&gt; &#xA;&lt;p&gt;We also include the &lt;code&gt;sget&lt;/code&gt; command for safer, automatic verification of signatures and integration with our binary transparency log, Rekor.&lt;/p&gt; &#xA;&lt;p&gt;To install &lt;code&gt;sget&lt;/code&gt;, if you have Go 1.16+, you can directly run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ go install github.com/sigstore/cosign/v2/cmd/sget@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and the resulting binary will be placed at &lt;code&gt;$GOPATH/bin/sget&lt;/code&gt; (or &lt;code&gt;$GOBIN/sget&lt;/code&gt;, if set).&lt;/p&gt; &#xA;&lt;p&gt;Just like &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;sget&lt;/code&gt; can be used to fetch artifacts by digest using the OCI URL. Digest verification is automatic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sget us.gcr.io/dlorenc-vmtest2/readme@sha256:4aa3054270f7a70b4528f2064ee90961788e1e1518703592ae4463de3b889dec &amp;gt; artifact&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use &lt;code&gt;sget&lt;/code&gt; to fetch contents by tag. Fetching contents without verifying them is dangerous, so we require the artifact be signed in this case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sget gcr.io/dlorenc-vmtest2/artifact&#xA;error: public key must be specified when fetching by tag, you must fetch by digest or supply a public key&#xA;&#xA;$ sget --key cosign.pub us.gcr.io/dlorenc-vmtest2/readme &amp;gt; foo&#xA;&#xA;Verification for us.gcr.io/dlorenc-vmtest2/readme --&#xA;The following checks were performed on each of these signatures:&#xA;  - The cosign claims were validated&#xA;  - Existence of the claims in the transparency log was verified offline&#xA;  - The signatures were verified against the specified public key&#xA;  - Any certificates were verified against the Fulcio roots.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The signature, claims and transparency log proofs are all verified automatically by sget as part of the download.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;curl | bash&lt;/code&gt; isn&#39;t a great idea, but &lt;code&gt;sget | bash&lt;/code&gt; is less-bad.&lt;/p&gt; &#xA;&lt;h4&gt;Tekton Bundles&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://tekton.dev&#34;&gt;Tekton&lt;/a&gt; bundles can be uploaded and managed within an OCI registry. The specification is &lt;a href=&#34;https://tekton.dev/docs/pipelines/tekton-bundle-contracts/&#34;&gt;here&lt;/a&gt;. This means they can also be signed and verified with &lt;code&gt;cosign&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Tekton Bundles can currently be uploaded with the &lt;a href=&#34;https://github.com/tektoncd/cli&#34;&gt;tkn cli&lt;/a&gt;, but we may add this support to &lt;code&gt;cosign&lt;/code&gt; in the future.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ tkn bundle push us.gcr.io/dlorenc-vmtest2/pipeline:latest -f task-output-image.yaml&#xA;Creating Tekton Bundle:&#xA;        - Added TaskRun:  to image&#xA;&#xA;Pushed Tekton Bundle to us.gcr.io/dlorenc-vmtest2/pipeline@sha256:124e1fdee94fe5c5f902bc94da2d6e2fea243934c74e76c2368acdc8d3ac7155&#xA;$ cosign sign --key cosign.key us.gcr.io/dlorenc-vmtest2/pipeline@sha256:124e1fdee94fe5c5f902bc94da2d6e2fea243934c74e76c2368acdc8d3ac7155&#xA;Enter password for private key:&#xA;tlog entry created with index: 5086&#xA;Pushing signature to: us.gcr.io/dlorenc-vmtest2/demo:sha256-124e1fdee94fe5c5f902bc94da2d6e2fea243934c74e76c2368acdc8d3ac7155.sig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;WASM&lt;/h4&gt; &#xA;&lt;p&gt;Web Assembly Modules can also be stored in an OCI registry, using this &lt;a href=&#34;https://github.com/solo-io/wasm/tree/master/spec&#34;&gt;specification&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Cosign can upload these using the &lt;code&gt;cosign wasm upload&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign upload wasm -f hello.wasm us.gcr.io/dlorenc-vmtest2/wasm&#xA;$ cosign sign --key cosign.key us.gcr.io/dlorenc-vmtest2/wasm@sha256:9e7a511fb3130ee4641baf1adc0400bed674d4afc3f1b81bb581c3c8f613f812&#xA;Enter password for private key:&#xA;tlog entry created with index: 5198&#xA;Pushing signature to: us.gcr.io/dlorenc-vmtest2/wasm:sha256-9e7a511fb3130ee4641baf1adc0400bed674d4afc3f1b81bb581c3c8f613f812.sig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;eBPF&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ebpf.io&#34;&gt;eBPF&lt;/a&gt; modules can also be stored in an OCI registry, using this &lt;a href=&#34;https://github.com/solo-io/bumblebee/tree/main/spec&#34;&gt;specification&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The image below was built using the &lt;code&gt;bee&lt;/code&gt; tool. More information can be found &lt;a href=&#34;https://github.com/solo-io/bumblebee/&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Cosign can then sign these images as they can any other OCI image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ bee build ./examples/tcpconnect/tcpconnect.c localhost:5000/tcpconnect:test&#xA;$ bee push localhost:5000/tcpconnect:test&#xA;$ cosign sign  --key cosign.key localhost:5000/tcpconnect@sha256:7a91c50d922925f152fec96ed1d84b7bc6b2079c169d68826f6cf307f22d40e6&#xA;Enter password for private key:&#xA;Pushing signature to: localhost:5000/tcpconnect&#xA;$ cosign verify --key cosign.pub localhost:5000/tcpconnect:test&#xA;&#xA;Verification for localhost:5000/tcpconnect:test --&#xA;The following checks were performed on each of these signatures:&#xA;  - The cosign claims were validated&#xA;  - The signatures were verified against the specified public key&#xA;&#xA;[{&#34;critical&#34;:{&#34;identity&#34;:{&#34;docker-reference&#34;:&#34;localhost:5000/tcpconnect&#34;},&#34;image&#34;:{&#34;docker-manifest-digest&#34;:&#34;sha256:7a91c50d922925f152fec96ed1d84b7bc6b2079c169d68826f6cf307f22d40e6&#34;},&#34;type&#34;:&#34;cosign container image signature&#34;},&#34;optional&#34;:null}]&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;In-Toto Attestations&lt;/h4&gt; &#xA;&lt;p&gt;Cosign also has built-in support for &lt;a href=&#34;https://in-toto.io&#34;&gt;in-toto&lt;/a&gt; attestations. The specification for these is defined &lt;a href=&#34;https://github.com/in-toto/attestation&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can create and sign one from a local predicate file using the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign attest --predicate &amp;lt;file&amp;gt; --key cosign.key $IMAGE_URI_DIGEST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All of the standard key management systems are supported. Payloads are signed using the DSSE signing spec, defined &lt;a href=&#34;https://github.com/secure-systems-lab/dsse&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To verify:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign verify-attestation --key cosign.pub $IMAGE_URI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Detailed Usage&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/USAGE.md&#34;&gt;Usage documentation&lt;/a&gt; for more commands!&lt;/p&gt; &#xA;&lt;h2&gt;Hardware-based Tokens&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/TOKENS.md&#34;&gt;Hardware Tokens documentation&lt;/a&gt; for information on how to use &lt;code&gt;cosign&lt;/code&gt; with hardware.&lt;/p&gt; &#xA;&lt;h2&gt;Keyless&lt;/h2&gt; &#xA;&lt;p&gt;🚨 🚨 🚨 See &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/KEYLESS.md&#34;&gt;here&lt;/a&gt; for info on the experimental Keyless signatures mode. 🚨 🚨 🚨&lt;/p&gt; &#xA;&lt;h2&gt;Registry Support&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; uses &lt;a href=&#34;https://github.com/google/go-containerregistry&#34;&gt;go-containerregistry&lt;/a&gt; for registry interactions, which has generally excellent compatibility, but some registries may have quirks.&lt;/p&gt; &#xA;&lt;p&gt;Today, &lt;code&gt;cosign&lt;/code&gt; has been tested and works against the following registries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AWS Elastic Container Registry&lt;/li&gt; &#xA; &lt;li&gt;GCP&#39;s Artifact Registry and Container Registry&lt;/li&gt; &#xA; &lt;li&gt;Docker Hub&lt;/li&gt; &#xA; &lt;li&gt;Azure Container Registry&lt;/li&gt; &#xA; &lt;li&gt;JFrog Artifactory Container Registry&lt;/li&gt; &#xA; &lt;li&gt;The CNCF distribution/distribution Registry&lt;/li&gt; &#xA; &lt;li&gt;GitLab Container Registry&lt;/li&gt; &#xA; &lt;li&gt;GitHub Container Registry&lt;/li&gt; &#xA; &lt;li&gt;The CNCF Harbor Registry&lt;/li&gt; &#xA; &lt;li&gt;Digital Ocean Container Registry&lt;/li&gt; &#xA; &lt;li&gt;Sonatype Nexus Container Registry&lt;/li&gt; &#xA; &lt;li&gt;Alibaba Cloud Container Registry&lt;/li&gt; &#xA; &lt;li&gt;Red Hat Quay Container Registry 3.6+ / Red Hat quay.io&lt;/li&gt; &#xA; &lt;li&gt;Elastic Container Registry&lt;/li&gt; &#xA; &lt;li&gt;IBM Cloud Container Registry&lt;/li&gt; &#xA; &lt;li&gt;Cloudsmith Container Registry&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We aim for wide registry support. To &lt;code&gt;sign&lt;/code&gt; images in registries which do not yet fully support &lt;a href=&#34;https://github.com/sigstore/cosign/raw/main/SPEC.md#object-types&#34;&gt;OCI media types&lt;/a&gt;, one may need to use &lt;code&gt;COSIGN_DOCKER_MEDIA_TYPES&lt;/code&gt; to fall back to legacy equivalents. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;COSIGN_DOCKER_MEDIA_TYPES=1 cosign sign --key cosign.key legacy-registry.example.com/my/image@$DIGEST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please help test and file bugs if you see issues! Instructions can be found in the &lt;a href=&#34;https://github.com/sigstore/cosign/issues/40&#34;&gt;tracking issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Rekor Support&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: this is an experimental feature&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;To publish signed artifacts to a Rekor transparency log and verify their existence in the log set the &lt;code&gt;COSIGN_EXPERIMENTAL=1&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ COSIGN_EXPERIMENTAL=1 cosign sign --key cosign.key $IMAGE_URI_DIGEST&#xA;$ COSIGN_EXPERIMENTAL=1 cosign verify --key cosign.pub $IMAGE_URI&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; defaults to using the public instance of rekor at &lt;a href=&#34;https://rekor.sigstore.dev&#34;&gt;rekor.sigstore.dev&lt;/a&gt;. To configure the rekor server, use the -&lt;code&gt;rekor-url&lt;/code&gt; flag&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;h3&gt;Intentionally Missing Features&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; only generates ECDSA-P256 keys and uses SHA256 hashes. Keys are stored in PEM-encoded PKCS8 format. However, you can use &lt;code&gt;cosign&lt;/code&gt; to store and retrieve signatures in any format, from any algorithm.&lt;/p&gt; &#xA;&lt;h3&gt;Unintentionally Missing Features&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; will integrate with transparency logs! See &lt;a href=&#34;https://github.com/sigstore/cosign/issues/34&#34;&gt;https://github.com/sigstore/cosign/issues/34&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; will integrate with even more transparency logs, and a PKI. See &lt;a href=&#34;https://github.com/sigStore/fulcio&#34;&gt;https://github.com/sigStore/fulcio&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; will also support The Update Framework for delegations, key discovery and expiration. See &lt;a href=&#34;https://github.com/sigstore/cosign/issues/86&#34;&gt;https://github.com/sigstore/cosign/issues/86&lt;/a&gt; for more info!&lt;/p&gt; &#xA;&lt;h3&gt;Things That Should Probably Change&lt;/h3&gt; &#xA;&lt;h4&gt;Payload Formats&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; only supports Red Hat&#39;s &lt;a href=&#34;https://www.redhat.com/en/blog/container-image-signing&#34;&gt;simple signing&lt;/a&gt; format for payloads. That looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;critical&#34;: {&#xA;           &#34;identity&#34;: {&#xA;               &#34;docker-reference&#34;: &#34;testing/manifest&#34;&#xA;           },&#xA;           &#34;image&#34;: {&#xA;               &#34;Docker-manifest-digest&#34;: &#34;sha256:20be...fe55&#34;&#xA;           },&#xA;           &#34;type&#34;: &#34;cosign container image signature&#34;&#xA;    },&#xA;    &#34;optional&#34;: {&#xA;           &#34;creator&#34;: &#34;Bob the Builder&#34;,&#xA;           &#34;timestamp&#34;: 1458239713&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This can be generated for an image reference using &lt;code&gt;cosign generate $IMAGE_URI_DIGEST&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m happy to switch this format to something else if it makes sense. See &lt;a href=&#34;https://github.com/notaryproject/nv2/issues/40&#34;&gt;https://github.com/notaryproject/nv2/issues/40&lt;/a&gt; for one option.&lt;/p&gt; &#xA;&lt;h4&gt;Registry Details&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; signatures are stored as separate objects in the OCI registry, with only a weak reference back to the object they &#34;sign&#34;. This means this relationship is opaque to the registry, and signatures &lt;em&gt;will not&lt;/em&gt; be deleted or garbage-collected when the image is deleted. Similarly, they &lt;strong&gt;can&lt;/strong&gt; easily be copied from one environment to another, but this is not automatic.&lt;/p&gt; &#xA;&lt;p&gt;Multiple signatures are stored in a list which is unfortunately a race condition today. To add a signature, clients orchestrate a &#34;read-append-write&#34; operation, so the last write will win in the case of contention.&lt;/p&gt; &#xA;&lt;h5&gt;Specifying Registry&lt;/h5&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; will default to storing signatures in the same repo as the image it is signing. To specify a different repo for signatures, you can set the &lt;code&gt;COSIGN_REPOSITORY&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;p&gt;This will replace the repo in the provided image like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ export COSIGN_REPOSITORY=gcr.io/my-new-repo&#xA;$ cosign sign --key cosign.key $IMAGE_URI_DIGEST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So the signature for &lt;code&gt;gcr.io/dlorenc-vmtest2/demo&lt;/code&gt; will be stored in &lt;code&gt;gcr.io/my-new-repo/demo:sha256-DIGEST.sig&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note: different registries might expect different formats for the &#34;repository.&#34;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;To use &lt;a href=&#34;https://cloud.google.com/container-registry&#34;&gt;GCR&lt;/a&gt;, a registry name like &lt;code&gt;gcr.io/$REPO&lt;/code&gt; is sufficient, as in the example above.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To use &lt;a href=&#34;https://cloud.google.com/artifact-registry&#34;&gt;Artifact Registry&lt;/a&gt;, specify a full image name like &lt;code&gt;$LOCATION-docker.pkg.dev/$PROJECT/$REPO/$STORAGE_IMAGE&lt;/code&gt;, not just a repository. For example,&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ export COSIGN_REPOSITORY=us-docker.pkg.dev/my-new-repo/demo&#xA;$ cosign sign --key cosign.key $IMAGE_URI_DIGEST&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;where the &lt;code&gt;sha256-DIGEST&lt;/code&gt; will match the digest for &lt;code&gt;gcr.io/dlorenc-vmtest2/demo&lt;/code&gt;. Specifying just a repo like &lt;code&gt;$LOCATION-docker.pkg.dev/$PROJECT/$REPO&lt;/code&gt; will not work in Artifact Registry.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Signature Specification&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; is inspired by tools like &lt;a href=&#34;https://jedisct1.github.io/minisign/&#34;&gt;minisign&lt;/a&gt; and &lt;a href=&#34;https://www.openbsd.org/papers/bsdcan-signify.html&#34;&gt;signify&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Generated private keys are stored in PEM format. The keys encrypted under a password using scrypt as a KDF and nacl/secretbox for encryption.&lt;/p&gt; &#xA;&lt;p&gt;They have a PEM header of &lt;code&gt;ENCRYPTED COSIGN PRIVATE KEY&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-----BEGIN ENCRYPTED COSIGN PRIVATE KEY-----&#xA;...&#xA;-----END ENCRYPTED COSIGN PRIVATE KEY-----&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Public keys are stored on disk in PEM-encoded standard PKIX format with a header of &lt;code&gt;PUBLIC KEY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-----BEGIN PUBLIC KEY-----&#xA;MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELigCnlLNKgOglRTx1D7JhI7eRw99&#xA;QolE9Jo4QUxnbMy5nUuBL+UZF9qqfm/Dg1BNeHRThHzWh2ki9vAEgWEDOw==&#xA;-----END PUBLIC KEY-----&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Storage Specification&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; stores signatures in an OCI registry, and uses a naming convention (tag based on the sha256 of what we&#39;re signing) for locating the signature index.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/images/signatures.dot.svg?sanitize=true&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;reg.example.com/ubuntu@sha256:703218c0465075f4425e58fac086e09e1de5c340b12976ab9eb8ad26615c3715&lt;/code&gt; has signatures located at &lt;code&gt;reg.example.com/ubuntu:sha256-703218c0465075f4425e58fac086e09e1de5c340b12976ab9eb8ad26615c3715.sig&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Roughly (ignoring ports in the hostname): &lt;code&gt;s/:/-/g&lt;/code&gt; and &lt;code&gt;s/@/:/g&lt;/code&gt; to find the signature index.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/#registry-details&#34;&gt;Race conditions&lt;/a&gt; for some caveats around this strategy.&lt;/p&gt; &#xA;&lt;p&gt;Alternative implementations could use transparency logs, local filesystem, a separate repository registry, an explicit reference to a signature index, a new registry API, grafeas, etc.&lt;/p&gt; &#xA;&lt;h3&gt;Signing subjects&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; only works for artifacts stored as &#34;manifests&#34; in the registry today. The proposed mechanism is flexible enough to support signing arbitrary things.&lt;/p&gt; &#xA;&lt;h3&gt;KMS Support&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; supports using a KMS provider to generate and sign keys. Right now cosign supports Hashicorp Vault, AWS KMS, GCP KMS, Azure Key Vault and we are hoping to support more in the future!&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/KMS.md&#34;&gt;KMS docs&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;OCI Artifacts&lt;/h3&gt; &#xA;&lt;p&gt;Push an artifact to a registry using &lt;a href=&#34;https://github.com/deislabs/oras&#34;&gt;oras&lt;/a&gt; (in this case, &lt;code&gt;cosign&lt;/code&gt; itself!):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ oras push us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact ./cosign&#xA;Uploading f53604826795 cosign&#xA;Pushed us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact&#xA;Digest: sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now sign it! Using &lt;code&gt;cosign&lt;/code&gt; of course:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign sign --key cosign.key us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact@sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef&#xA;Enter password for private key:&#xA;Pushing signature to: us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact:sha256-551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef.sig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, verify &lt;code&gt;cosign&lt;/code&gt; with &lt;code&gt;cosign&lt;/code&gt; again:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign verify --key cosign.pub  us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact@sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef&#xA;The following checks were performed on each of these signatures:&#xA;  - The cosign claims were validated&#xA;  - The claims were present in the transparency log&#xA;  - The signatures were integrated into the transparency log when the certificate was valid&#xA;  - The signatures were verified against the specified public key&#xA;  - Any certificates were verified against the Fulcio roots.&#xA;&#xA;{&#34;Critical&#34;:{&#34;Identity&#34;:{&#34;docker-reference&#34;:&#34;&#34;},&#34;Image&#34;:{&#34;Docker-manifest-digest&#34;:&#34;sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef&#34;},&#34;Type&#34;:&#34;cosign container image signature&#34;},&#34;Optional&#34;:null}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Why not use Notary v2&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s hard to answer this briefly. This post contains some comparisons:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://medium.com/@dlorenc/notary-v2-and-cosign-b816658f044d&#34;&gt;Notary V2 and Cosign&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you find other comparison posts, please send a PR here and we&#39;ll link them all.&lt;/p&gt; &#xA;&lt;h3&gt;Why not use containers/image signing&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;containers/image&lt;/code&gt; signing is close to &lt;code&gt;cosign&lt;/code&gt;, and we reuse payload formats. &lt;code&gt;cosign&lt;/code&gt; differs in that it signs with ECDSA-P256 keys instead of PGP, and stores signatures in the registry.&lt;/p&gt; &#xA;&lt;h3&gt;Why not use TUF?&lt;/h3&gt; &#xA;&lt;p&gt;I believe this tool is complementary to TUF, and they can be used together. I haven&#39;t tried yet, but think we can also reuse a registry for TUF storage.&lt;/p&gt; &#xA;&lt;h3&gt;Why not use Blockchain?&lt;/h3&gt; &#xA;&lt;p&gt;Just kidding. Nobody actually asked this. Don&#39;t be that person.&lt;/p&gt; &#xA;&lt;h3&gt;Why not use $FOO?&lt;/h3&gt; &#xA;&lt;p&gt;See the next section, &lt;a href=&#34;https://raw.githubusercontent.com/sigstore/cosign/main/#Requirements&#34;&gt;Requirements&lt;/a&gt;. I designed this tool to meet a few specific requirements, and didn&#39;t find anything else that met all of these. If you&#39;re aware of another system that does meet these, please let me know!&lt;/p&gt; &#xA;&lt;h2&gt;Design Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No external services for signature storage, querying, or retrieval&lt;/li&gt; &#xA; &lt;li&gt;We aim for as much registry support as possible&lt;/li&gt; &#xA; &lt;li&gt;Everything should work over the registry API&lt;/li&gt; &#xA; &lt;li&gt;PGP should not be required at all.&lt;/li&gt; &#xA; &lt;li&gt;Users must be able to find all signatures for an image&lt;/li&gt; &#xA; &lt;li&gt;Signers can sign an image after push&lt;/li&gt; &#xA; &lt;li&gt;Multiple entities can sign an image&lt;/li&gt; &#xA; &lt;li&gt;Signing an image does not mutate the image&lt;/li&gt; &#xA; &lt;li&gt;Pure-go implementation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Future Ideas&lt;/h2&gt; &#xA;&lt;h3&gt;Registry API Changes&lt;/h3&gt; &#xA;&lt;p&gt;The naming convention and read-modify-write update patterns we use to store things in a registry are a bit, well, &#34;hacky&#34;. I think they&#39;re the best (only) real option available today, but if the registry API changes we can improve these.&lt;/p&gt; &#xA;&lt;h3&gt;Other Types&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; can sign anything in a registry. These examples show signing a single image, but you could also sign a multi-platform &lt;code&gt;Index&lt;/code&gt;, or any other type of artifact. This includes Helm Charts, Tekton Pipelines, and anything else currently using OCI registries for distribution.&lt;/p&gt; &#xA;&lt;p&gt;This also means new artifact types can be uploaded to a registry and signed. One interesting type to store and sign would be TUF repositories. I haven&#39;t tried yet, but I&#39;m fairly certain TUF could be implemented on top of this.&lt;/p&gt; &#xA;&lt;h3&gt;Tag Signing&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cosign&lt;/code&gt; signatures protect the digests of objects stored in a registry. The optional &lt;code&gt;annotations&lt;/code&gt; support (via the &lt;code&gt;-a&lt;/code&gt; flag to &lt;code&gt;cosign sign&lt;/code&gt;) can be used to add extra data to the payload that is signed and protected by the signature. One use-case for this might be to sign a tag-&amp;gt;digest mapping.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to attest that a specific tag (or set of tags) should point at a digest, you can run something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker push $IMAGE_URI&#xA;The push refers to repository [dlorenc/demo]&#xA;994393dc58e7: Pushed&#xA;5m: digest: sha256:1304f174557314a7ed9eddb4eab12fed12cb0cd9809e4c28f29af86979a3c870 size: 528&#xA;$ TAG=sign-me&#xA;$ cosign sign --key cosign.key -a tag=$TAG $IMAGE_URI_DIGEST&#xA;Enter password for private key:&#xA;Pushing signature to: dlorenc/demo:1304f174557314a7ed9eddb4eab12fed12cb0cd9809e4c28f29af86979a3c870.sig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can verify that the tag-&amp;gt;digest mapping is also covered in the signature, using the &lt;code&gt;-a&lt;/code&gt; flag to &lt;code&gt;cosign verify&lt;/code&gt;. This example verifies that the digest &lt;code&gt;$TAG&lt;/code&gt; which points to (&lt;code&gt;sha256:1304f174557314a7ed9eddb4eab12fed12cb0cd9809e4c28f29af86979a3c870&lt;/code&gt;) has been signed, &lt;strong&gt;and also&lt;/strong&gt; that the &lt;code&gt;tag&lt;/code&gt; annotation has the value &lt;code&gt;sign-me&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign verify --key cosign.pub -a tag=$TAG $IMAGE_URI | jq .&#xA;{&#xA;  &#34;Critical&#34;: {&#xA;    &#34;Identity&#34;: {&#xA;      &#34;docker-reference&#34;: &#34;&#34;&#xA;    },&#xA;    &#34;Image&#34;: {&#xA;      &#34;Docker-manifest-digest&#34;: &#34;97fc222cee7991b5b061d4d4afdb5f3428fcb0c9054e1690313786befa1e4e36&#34;&#xA;    },&#xA;    &#34;Type&#34;: &#34;cosign container image signature&#34;&#xA;  },&#xA;  &#34;Optional&#34;: {&#xA;    &#34;tag&#34;: &#34;sign-me&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Timestamps could also be added here, to implement TUF-style freeze-attack prevention.&lt;/p&gt; &#xA;&lt;h3&gt;Base Image/Layer Signing&lt;/h3&gt; &#xA;&lt;p&gt;Again, &lt;code&gt;cosign&lt;/code&gt; can sign anything in a registry. You could use &lt;code&gt;cosign&lt;/code&gt; to sign an image that is intended to be used as a base image, and include that provenance metadata in resulting derived images. This could be used to enforce that an image was built from an authorized base image.&lt;/p&gt; &#xA;&lt;p&gt;Rough Idea:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OCI manifests have an ordered list of &lt;code&gt;layer&lt;/code&gt; &lt;code&gt;Descriptors&lt;/code&gt;, which can contain annotations. See &lt;a href=&#34;https://github.com/opencontainers/image-spec/raw/master/manifest.md&#34;&gt;here&lt;/a&gt; for the specification.&lt;/li&gt; &#xA; &lt;li&gt;A base image is an ordered list of layers to which other layers are appended, as well as an initial configuration object that is mutated. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A derived image is free to completely delete/destroy/recreate the config from its base image, so signing the config would provided limited value.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;We can sign the full set of ordered base layers, and attach that signature as an annotation to the &lt;strong&gt;last&lt;/strong&gt; layer in the resulting child image.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This example manifest manifest represents an image that has been built from a base image with two layers. One additional layer is added, forming the final image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;schemaVersion&#34;: 2,&#xA;  &#34;config&#34;: {&#xA;    &#34;mediaType&#34;: &#34;application/vnd.oci.image.config.v1+json&#34;,&#xA;    &#34;size&#34;: 7023,&#xA;    &#34;digest&#34;: &#34;sha256:b5b2b2c507a0944348e0303114d8d93aaaa081732b86451d9bce1f432a537bc7&#34;&#xA;  },&#xA;  &#34;layers&#34;: [&#xA;    {&#xA;      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,&#xA;      &#34;size&#34;: 32654,&#xA;      &#34;digest&#34;: &#34;sha256:9834876dcfb05cb167a5c24953eba58c4ac89b1adf57f28f2f9d09af107ee8f0&#34;&#xA;    },&#xA;    {&#xA;      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,&#xA;      &#34;size&#34;: 16724,&#xA;      &#34;digest&#34;: &#34;sha256:3c3a4604a545cdc127456d94e421cd355bca5b528f4a9c1905b15da2eb4a4c6b&#34;,&#xA;      &#34;annotations&#34;: {&#xA;        &#34;dev.cosign.signature.baseimage&#34;: &#34;Ejy6ipGJjUzMDoQFePWixqPBYF0iSnIvpMWps3mlcYNSEcRRZelL7GzimKXaMjxfhy5bshNGvDT5QoUJ0tqUAg==&#34;&#xA;      }&#xA;    },&#xA;    {&#xA;      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,&#xA;      &#34;size&#34;: 73109,&#xA;      &#34;digest&#34;: &#34;sha256:ec4b8955958665577945c89419d1af06b5f7636b4ac3da7f12184802ad867736&#34;&#xA;    }&#xA;  ],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this could be applied recursively, for multiple intermediate base images.&lt;/p&gt; &#xA;&lt;h3&gt;Counter-Signing&lt;/h3&gt; &#xA;&lt;p&gt;Cosign signatures (and their protected payloads) are stored as artifacts in a registry. These signature objects can also be signed, resulting in a new, &#34;counter-signature&#34; artifact. This &#34;counter-signature&#34; protects the signature (or set of signatures) &lt;strong&gt;and&lt;/strong&gt; the referenced artifact, which allows it to act as an attestation to the &lt;strong&gt;signature(s) themselves&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before we sign the signature artifact, we first give it a memorable name so we can find it later.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cosign sign --key cosign.key -a sig=original $IMAGE_URI_DIGEST&#xA;Enter password for private key:&#xA;Pushing signature to: dlorenc/demo:sha256-97fc222cee7991b5b061d4d4afdb5f3428fcb0c9054e1690313786befa1e4e36.sig&#xA;$ cosign verify --key cosign.pub dlorenc/demo | jq .&#xA;{&#xA;  &#34;Critical&#34;: {&#xA;    &#34;Identity&#34;: {&#xA;      &#34;docker-reference&#34;: &#34;&#34;&#xA;    },&#xA;    &#34;Image&#34;: {&#xA;      &#34;Docker-manifest-digest&#34;: &#34;97fc222cee7991b5b061d4d4afdb5f3428fcb0c9054e1690313786befa1e4e36&#34;&#xA;    },&#xA;    &#34;Type&#34;: &#34;cosign container image signature&#34;&#xA;  },&#xA;  &#34;Optional&#34;: {&#xA;    &#34;sig&#34;: &#34;original&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- TODO: https://github.com/sigstore/cosign/issues/2333 --&gt; &#xA;&lt;p&gt;Now give that signature a memorable name, then sign that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ crane tag $(cosign triangulate $IMAGE_URI) mysignature&#xA;2021/02/15 20:22:55 dlorenc/demo:mysignature: digest: sha256:71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e size: 556&#xA;$ cosign sign --key cosign.key -a sig=counter dlorenc/demo:mysignature&#xA;Enter password for private key:&#xA;Pushing signature to: dlorenc/demo:sha256-71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e.sig&#xA;$ cosign verify --key cosign.pub dlorenc/demo:mysignature&#xA;{&#34;Critical&#34;:{&#34;Identity&#34;:{&#34;docker-reference&#34;:&#34;&#34;},&#34;Image&#34;:{&#34;Docker-manifest-digest&#34;:&#34;71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e&#34;},&#34;Type&#34;:&#34;cosign container image signature&#34;},&#34;Optional&#34;:{&#34;sig&#34;:&#34;counter&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, check the original signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ crane manifest dlorenc/demo@sha256:71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e&#xA;{&#xA;  &#34;schemaVersion&#34;: 2,&#xA;  &#34;config&#34;: {&#xA;    &#34;mediaType&#34;: &#34;application/vnd.oci.image.config.v1+json&#34;,&#xA;    &#34;size&#34;: 233,&#xA;    &#34;digest&#34;: &#34;sha256:3b25a088710d03f39be26629d22eb68cd277a01673b9cb461c4c24fbf8c81c89&#34;&#xA;  },&#xA;  &#34;layers&#34;: [&#xA;    {&#xA;      &#34;mediaType&#34;: &#34;application/vnd.oci.descriptor.v1+json&#34;,&#xA;      &#34;size&#34;: 217,&#xA;      &#34;digest&#34;: &#34;sha256:0e79a356609f038089088ec46fd95f4649d04de989487220b1a0adbcc63fadae&#34;,&#xA;      &#34;annotations&#34;: {&#xA;        &#34;dev.sigstore.cosign/signature&#34;: &#34;5uNZKEP9rm8zxAL0VVX7McMmyArzLqtxMTNPjPO2ns+5GJpBeXg+i9ILU+WjmGAKBCqiexTxzLC1/nkOzD4cDA==&#34;&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Release Cadence&lt;/h2&gt; &#xA;&lt;p&gt;We are intending to move to a monthly cadence for minor releases. Minor releases will be published around the beginning of the month. We may cut a patch release instead, if the changes are small enough not to warrant a minor release. We will also cut patch releases periodically as needed to address bugs.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Should you discover any security issues, please refer to sigstore&#39;s &lt;a href=&#34;https://github.com/sigstore/.github/raw/main/SECURITY.md&#34;&gt;security process&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sjkhsl/study_xxqg</title>
    <updated>2023-01-05T01:31:46Z</updated>
    <id>tag:github.com,2023-01-05:/sjkhsl/study_xxqg</id>
    <link href="https://github.com/sjkhsl/study_xxqg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;克隆自原作者johlanse的项目&lt;/h1&gt; &#xA;&lt;h3&gt;学习强国自动化学习&lt;/h3&gt; &#xA;&lt;p&gt;该项目基于&lt;a href=&#34;https://github.com/mxschmitt/playwright-go&#34;&gt;playwright-go&lt;/a&gt; 开发，支持&lt;em&gt;windows&lt;/em&gt;，&lt;em&gt;linux&lt;/em&gt;,&lt;em&gt;mac&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;文档地址: &lt;a href=&#34;https://johlanse.shhy.xyz&#34;&gt;https://johlanse.shhy.xyz&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;请先看文档再提出问题&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;申明，该项目仅用于学习。&lt;/h2&gt; &#xA;&lt;h2&gt;鸣谢&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;&lt;a href=&#34;https://github.com/imkenf/XueQG&#34;&gt;imkenf/XueQG&lt;/a&gt;&lt;/h3&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;windows使用教程&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;浏览器访问&lt;a href=&#34;https://github.com/sjkhsl/study_xxqg/releases&#34;&gt;Release&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;选择最新版本下载&amp;nbsp;&lt;code&gt;study_xxqg_amd64.zip&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;将其解压到合适的位置&lt;/li&gt; &#xA; &lt;li&gt;进入解压后的文件夹，双击运行&lt;code&gt;study_xxqg.exe&lt;/code&gt;,第一次打开可能会出现闪退，发现文件夹下生成了config文件夹&lt;/li&gt; &#xA; &lt;li&gt;打开config目录下的&lt;code&gt;confif.yml&lt;/code&gt;文件，进行编辑，详情内容见&lt;u&gt;配置文件&lt;/u&gt;&lt;/li&gt; &#xA; &lt;li&gt;再次进行运行&lt;code&gt;study_xxqg.exe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;使用浏览器打开&lt;code&gt;http://127.0.0.1:8080&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;推送配置请参考&lt;u&gt;推送&lt;/u&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;自定义浏览器位置&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;windows默认调用系统的edge浏览器，调用目录&lt;strong&gt;C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;若不存在该浏览器会自动尝试下载浏览器到目录下的tools文件夹下，当然也可以自定义配置浏览器位置&lt;/p&gt; &#xA; &lt;p&gt;修改配置文件的&lt;strong&gt;edge_path&lt;/strong&gt;选项即可配置，配置为配置可执行文件的路径&lt;/p&gt; &#xA; &lt;p&gt;自定义浏览器支持chromium内核的系列浏览器，但是版本不能太高&lt;/p&gt; &#xA; &lt;p&gt;例如，我的chrome.exe文件在D盘的browser文件夹下，配置为&lt;strong&gt;D:/browser/chrome.exe&lt;/strong&gt;或者&lt;strong&gt;D:\browser\chrome.exe&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;可执行文件运行&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;本地访问&lt;a href=&#34;https://johlanse.shhy.xyz/%5BRelease%5D(https://github.com/johlanse/study_xxqg/releases)&#34;&gt;Releases&lt;/a&gt;&amp;nbsp;,查找对应版本并复制链接&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;使用wget下载对应版本压缩包&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;tar -xzvf study_xxqg_linux_amd64.tar.gz&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;运行&amp;nbsp;&lt;code&gt;./study_xxqg --init&lt;/code&gt;,首次运行会生成默认配置文件&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;使用vim修改对应配置文件，linux建议使用tg模式运行，详情配置参考&lt;a href=&#34;https://johlanse.shhy.xyz/#/../config&#34;&gt;配置&lt;/a&gt;,推送方式查看&lt;a href=&#34;https://johlanse.shhy.xyz/#/../push&#34;&gt;push&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;再次运行即可&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;一键安装脚本 废弃&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget  https://raw.githubusercontent.com/johlanse/study_xxqg/main/docs/study_xxqg_install.py &amp;amp;&amp;amp; python3 study_xxqg_install.py  废弃&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;docker运行&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --name study_xxqg -d -p 8080:8080 -v /etc/study_xxqg/:/opt/config/  sjkhsl/study_xxqg:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;各个参数的含义：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;--name study_xxqg&lt;/strong&gt;&amp;nbsp;运行的容器的名称，可以根据自己实际情况进行修改&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-p 8080:8080&lt;/strong&gt;&amp;nbsp;将容器内部的8080端口映射到容器外面，前面是宿主机的端口，就是网页上访问的端口，后面是容器内部需要运行的端口，对应配置文件内web配置的端口就好&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-v /etc/study_xxqg/:/opt/config/&lt;/strong&gt;&amp;nbsp;将容器内的/opt/config/目录映射到宿主机的/etc/study_xxqg/目录，可根据实际情况修改前面宿主机路径，映射后对应的config.yml配置文件位置就在该目录下&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;jolanse/study_xxqg:latest&lt;/strong&gt;镜像名称和镜像的版本，latest代表开发中的最新版本&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;docker-compose运行&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://raw.githubusercontent.com/sjkhsl/study_xxqg/main/docker-compose.yml&#xA;docker-compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;二种运行方式的区别&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h4&gt;可执行文件运行&lt;/h4&gt; &lt;p&gt;可执行文件运行节省存储空间，拥有更低的占用，但是可能会存在浏览器依赖安装的问题，适合拥有一定linux基础的用户使用 ，如果系统为debian11用户，可以参考DockerFile文件中的依赖安装语句执行即可，centos用户推荐使用docker.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h4&gt;docker运行&lt;/h4&gt; &lt;p&gt;docker运行不需要解决依赖问题，但是可能面临更高的运行占用，建议使用docker控制内存占用&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;源码运行&lt;/h2&gt; &#xA;&lt;h3&gt;安装golang环境&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;去golang&lt;a href=&#34;https://studygolang.com/dl&#34;&gt;官网&lt;/a&gt;&amp;nbsp;下载对应系统的安装包，建议安装golang 1.7+&lt;/li&gt; &#xA; &lt;li&gt;配置环境变量&lt;/li&gt; &#xA; &lt;li&gt;具体可百度搜索golang环境安装&lt;/li&gt; &#xA; &lt;li&gt;验证，任意终端中输入&lt;code&gt;go version&lt;/code&gt;,显示版本信息即安装完成&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;运行项目&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;再任意终端输入一下命令&lt;/p&gt; &lt;pre&gt;&lt;code&gt;cd study_xxqg&#xA;go mod tidy&#xA;go build ./&#xA;./study_xxqg&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;推送配置&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;一共有以下五种推送方式&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;微信公众号测试号推送&lt;/li&gt; &#xA; &lt;li&gt;网页推送&lt;/li&gt; &#xA; &lt;li&gt;telegram推送&lt;/li&gt; &#xA; &lt;li&gt;微信pushPlus推送&lt;/li&gt; &#xA; &lt;li&gt;钉钉推送&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;其中pushPlus和钉钉推送相互冲突，因为两种推送模式都只能单方面配合定时运行功能使用，只能接收消息，不能发送消息；&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;在公众号测试号和tg推送以及定时三种只要配置了任意一种，程序将自动卡住等待用户指令。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;若您想打开程序就运行，请关闭这三项配置；当前程序默认开启cron定时,所以新版若不想程序一直等待则关闭cron即可。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;微信公众号和网页需要公网ip,若没有建议更换其他推送方式，或者自行配置内网穿透，tg推送需要配置代理或者自己反代tg的api，钉钉和pushPlus仅支持单向推送，一般配合定时使用&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;定时配置&lt;/h3&gt; &#xA;&lt;p&gt;定时任务和一下所有推送均可配合一起使用，cron的语法遵循linux标准cron语法，详情可百度自行查询&lt;/p&gt; &#xA;&lt;p&gt;因为一些不知名的bug,观看视频时可能卡住不加分，所以建议一天运行三次左右定时，同时多次定时之间间隔不要太短&lt;/p&gt; &#xA;&lt;p&gt;为防止定时任务每天在同一时间触发，可以配置&lt;strong&gt;cron_random_wait&lt;/strong&gt;,等待随机时间再运行任务&lt;/p&gt; &#xA;&lt;p&gt;除此之外，还支持以下语法&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;@yearly：也可以写作@annually，表示每年第一天的 0 点。等价于0 0 1 1 *；&lt;/li&gt; &#xA; &lt;li&gt;@monthly：表示每月第一天的 0 点。等价于0 0 1 * *；&lt;/li&gt; &#xA; &lt;li&gt;@weekly：表示每周第一天的 0 点，注意第一天为周日，即周六结束，周日开始的那个 0 点。等价于0 0 * * 0；&lt;/li&gt; &#xA; &lt;li&gt;@daily：也可以写作@midnight，表示每天 0 点。等价于0 0 * * *；&lt;/li&gt; &#xA; &lt;li&gt;@hourly：表示每小时的开始。等价于0 * * * *。&lt;/li&gt; &#xA; &lt;li&gt;@every duration: duration为任意时间端，例如 1h,1s,1s，1h30m2s，代表间隔时间段就指向一次&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;微信公众号推送&lt;/h3&gt; &#xA;&lt;p&gt;配置config.yml的如下部分&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# 微信公众号测试号配置&#xA;wechat:&#xA;  # 是否启用&#xA;  enable: false&#xA;  # 开发者平台设置的token&#xA;  token: &#34;&#34;&#xA;  # 开发者平台的secret&#xA;  secret: &#34;&#34;&#xA;  # 开发者平台的appId&#xA;  app_id: &#34;&#34;&#xA;  # 发送登录消息需要使用的消息模板&#xA;  # 模板标题，随意  模板内容：  点我登录，然后在浏览器中打开！！&#xA;  login_temp_id: &#34;&#34;&#xA;  # 发送普通消息需要使用的消息模板&#xA;  # 模板标题：随意 模板内容： {{data.DATA}}&#xA;  normal_temp_id: &#34;&#34;&#xA;  # xxqg会每隔两小时左右检查所有用户的ck有效性，若开启该选项，会在检查失败时推送提醒消息&#xA;  push_login_warn: false&#xA;  # 微信管理员的openid,可点击关于按钮获得，配置后请重启程序&#xA;  super_open_id: &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;前往微信&lt;a href=&#34;http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&#34;&gt;公众号开发者平台&lt;/a&gt;，手机微信扫码登录&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;配置url为**&lt;a href=&#34;http://ip:port/wx&#34;&gt;http://ip:port/wx&lt;/a&gt;**,ip为你运行机器的公网ip,若使用docker运行，端口则为宿主机中映射出来的端口，ip和端口的配置和web使用同一个配置&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;设置token,需和配置项中一样&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;分别添加登录模板消息和普通模板消息，添加要求:&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;在配置文件中配置所有内容，启动程序&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;运行程序后，在浏览器中访问配置的url,页面会返回&lt;code&gt;No Signature!&lt;/code&gt;,然后提交配置，若成功则关注公众号尝试运行&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;docker运行方式参考&lt;u&gt;linux运行&lt;/u&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;配置成功后可点击关于按钮获取open_id，然后填写到配置项的super_open_id中，然后重启容器生效&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;web推送&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;适用于部署在服务器上或者家里有公网IP的设备上&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;配置config.yml的如下部分&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;web:&#xA;  # 启用web&#xA;  enable: true&#xA;  # 监听的ip,若只需要本机访问则设置为127.0.0.1，监听本机所有ip为0.0.0.0&#xA;  host: 0.0.0.0&#xA;  # 监听的端口号 0-65535可选&#xA;  port: 8081&#xA;  # web端登录管理员的账号&#xA;  account：admin&#xA;  # web端登录管理员的密码&#xA;  password: admin&#xA;  # web端登录普通用户的账号密码，支持多个用户,普通用户只能看到自己的信息&#xA;  common_user:&#xA;    # 代表账号为user,密码为123的普通用户，可添加多个，继续在下面写就好了&#xA;    user: 123&#xA;&#xA;    # user1: 123&#xA;    # user2: 123&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;开启后通过浏览器访问&amp;nbsp;*&lt;a href=&#34;http://ip:port/&#34;&gt;http://ip:port&lt;/a&gt;&lt;em&gt;或者&lt;/em&gt;&lt;a href=&#34;http://ip:port/new&#34;&gt;http://ip:port/new&lt;/a&gt;*即可打开网址 ,若为docker运行，则ip为宿主机公网ip,端口为docker映射到宿主机的端口&lt;/li&gt; &#xA; &lt;li&gt;若无法访问，首先检查程序运行日志，查看有无报错，其次查看docker的运行情况，端口是否映射正常，然后可以通过curl命令检测在宿主机中能否访问，然后检查防火墙之类的&lt;/li&gt; &#xA; &lt;li&gt;若点击登录之后出现一个小框然后无反应，则说明账户密码错误，请重新配置程序账户密码并重启程序&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;登录的账号密码是在配置文件中配置，不是学习强国的登录账号，管理员登录支持删除用户，同时能看到所有人的用户信息，普通用户就是&lt;code&gt;common_user&lt;/code&gt;下面配置的用户，支持多个用户，键是账号，值是密码&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;钉钉推送&lt;/h3&gt; &#xA;&lt;p&gt;配置config.yml的如下部分,具体使用教程详情参考&lt;a href=&#34;https://developers.dingtalk.com/document/robots/custom-robot-access?spm=ding_open_doc.document.0.0.7f875e5903iVpC#topic-2026027&#34;&gt;钉钉&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ding:&#xA;    enable: true&#xA;    access_token: &#34;&#34;&#xA;    secret: &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;在电脑端钉钉中创建群聊，在聊天设置中选择只能群助手，选择添加机器人，机器人类别选择webhook自定义机器人&lt;/li&gt; &#xA; &lt;li&gt;机器人名字任意，机器人安全设置勾选加签，复制加签的密钥，作为secret配置项填入配置文件中&lt;/li&gt; &#xA; &lt;li&gt;勾选协议，确认添加，会出现一个webhook地址，形如这样：&lt;code&gt;https://oapi.dingtalk.com/robot/send?access_token=aaabbbbcccc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;将上述地址中的后半段，就是access_token=之后的内容作为access_token配置项填入配置文件中，例如上述网址，则填入aaabbbccc到access_token中&lt;/li&gt; &#xA; &lt;li&gt;设置定时cron,启动程序，程序会在定时时间运行脚本&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;pushplus推送&lt;/h3&gt; &#xA;&lt;p&gt;配置config.yml的如下部分，具体使用教程参考&lt;a href=&#34;https://www.pushplus.plus/&#34;&gt;pushplus&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  push_plus:&#xA;    enable: true&#xA;    token: &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;telegram推送&lt;/h3&gt; &#xA;&lt;h2&gt;Telegram Bot&lt;/h2&gt; &#xA;&lt;p&gt;配置 config.yml的如下部分&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tg:&#xA;  enable: false&#xA;  chat_id: 0&#xA;  token: &#34;&#34;&#xA;  # telegram的代理，不配置默认走系统代理&#xA;  proxy: &#34;&#34;&#xA;  # 自定义tg的api,可通过cloudflare搭建，需自备域名&#xA;  custom_api: &#34;https://api.telegram.org&#34;&#xA;  # 白名单id,包括群id或者用户id,若为空，则允许所有群所有用户使用，若仅用于单人，直接配置上面的chat_id就可以&#xA;  white_list:&#xA;    - 123&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;配置&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;在 Tg 中搜索&lt;a href=&#34;https://t.me/BotFather&#34;&gt;&lt;code&gt;@BotFather&lt;/code&gt;&lt;/a&gt;&amp;nbsp;，发送指令&lt;code&gt;/newbot&lt;/code&gt;创建一个 bot&lt;/li&gt; &#xA; &lt;li&gt;获取你创建好的 API Token 格式为&lt;code&gt;123456789:AAaaaa-Uuuuuuuuuuu&lt;/code&gt;&amp;nbsp;,要完整复制&lt;strong&gt;全部内容&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;在 Tg 中搜索&lt;a href=&#34;https://t.me/userinfobot&#34;&gt;&lt;code&gt;@userinfobot&lt;/code&gt;&lt;/a&gt;&amp;nbsp;，点击&lt;code&gt;START&lt;/code&gt;，它就会给你发送你的信息，记住 Id 即可，是一串数字。&lt;/li&gt; &#xA; &lt;li&gt;跟你创建的 bot 会话，点击&lt;code&gt;START&lt;/code&gt;，或者发送&lt;code&gt;/start&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;将第 2 步获取的 token 放在&lt;code&gt;tokenn&lt;/code&gt;中，第 3 步获取的 Id 放到&lt;code&gt;chat_id&lt;/code&gt;中，&lt;code&gt;enable&lt;/code&gt;设置为 true。&lt;/li&gt; &#xA; &lt;li&gt;因为众所周知的原因，telegram推送需要进行配置代理，例如clash的代理配置为&lt;code&gt;http://127.0.0.1:7890&lt;/code&gt;即可，若通过cf反代的api,,则填写到&lt;strong&gt;custom_api&lt;/strong&gt;配置项&lt;/li&gt; &#xA; &lt;li&gt;若不配置代理的情况下会默认走系统代理，white_list建议填写自己的chat_id,为可以使用机器人的白名单，若需要在群组中使用，请相应进行配置&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;增加 telegram bot 指令支持&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/login&lt;/code&gt;&amp;nbsp;添加一个用户&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/get_users&lt;/code&gt;&amp;nbsp;获取所有cookie有效的用户&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/study 张三&lt;/code&gt;&amp;nbsp;指定账号学习,若只存在一个用户则自动选择学习&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/get_scores&lt;/code&gt;&amp;nbsp;获取账户积分&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/quit&lt;/code&gt;&amp;nbsp;退出正在学习的实例，当长时间无响应时建议退出并查看日志然后提交issue&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/study_all&lt;/code&gt;&amp;nbsp;按顺序对cookie有效的所有用户进行学习&lt;/p&gt; &#xA;&lt;h3&gt;PushDeer推送配置&lt;/h3&gt; &#xA;&lt;p&gt;pishDeer也仅支持单向推送&lt;/p&gt; &#xA;&lt;p&gt;配置：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;push_deer:&#xA;  enable: true&#xA;  api: &#34;https://api2.pushdeer.com&#34;&#xA;  token: &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;自行注册pushDeer后获取token,配置token到配置文件即可，api默认为官方api,若为自建，则配置对应接口即可&lt;/p&gt; &#xA;&lt;h2&gt;配置文件&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;配置文件修改后需要重启程序才能生效&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code&gt;# 刷课模式，默认为3，&#xA;# 1：只刷文章何视频&#xA;# 2：只刷文章和视频和每日答题&#xA;# 3：刷文章和视频和每日答题每周答题和专项答题&#xA;model: 3&#xA;&#xA;# 日志等级&#xA;# panic&#xA;# fatal&#xA;# error&#xA;# warn, warning&#xA;# info&#xA;# debug&#xA;# trace&#xA;log_level: &#34;info&#34;&#xA;&#xA;# 是否显示浏览器&#xA;show_browser: false&#xA;&#xA;# 跳转学习强国的scheme,默认使用本仓库的action自建scheme,若需自行修改，可直接复制仓库下/docs/scheme.html到任意静态文件服务器&#xA;scheme: &#34;https://johlanse.github.io/study_xxqg/scheme.html?&#34;&#xA;&#xA;&#xA;push:&#xA;  ding:&#xA;    enable: false&#xA;    access_token: &#34;&#34;&#xA;    secret: &#34;&#34;&#xA;  # 目前仅支持push-plus推送二维码，默认建议使用push-plus推送&#xA;  # push-plus使用方法见：http://www.pushplus.plus/&#xA;  push_plus:&#xA;    enable: false&#xA;    token: &#34;&#34;&#xA;&#xA;# telegram交互模式配置&#xA;tg:&#xA;  enable: false&#xA;  chat_id: 0&#xA;  token: &#34;&#34;&#xA;  # telegram的代理，不配置默认走系统代理&#xA;  proxy: &#34;&#34;&#xA;  # 自定义tg的api,可通过cloudflare搭建，需自备域名&#xA;  custom_api: &#34;https://api.telegram.org&#34;&#xA;  # 白名单id,包括群id或者用户id,若为空，则允许所有群所有用户使用，若仅用于单人，直接配置上面的chat_id就可以&#xA;  white_list:&#xA;    - 123&#xA;# 网页端配置&#xA;web:&#xA;  # 是否启用网页&#xA;  enable: true&#xA;  #&#xA;  host: 0.0.0.0&#xA;  port: 8080&#xA;  # 网页端登录账号&#xA;  account: admin&#xA;  # 网页端登录密码&#xA;  password: admin&#xA;&#xA;# 微信公众号测试号配置&#xA;wechat:&#xA;  # 是否启用&#xA;  enable: false&#xA;  # 开发者平台设置的token&#xA;  token: &#34;&#34;&#xA;  # 开发者平台的secret&#xA;  secret: &#34;&#34;&#xA;  # 开发者平台的appId&#xA;  app_id: &#34;&#34;&#xA;  # 发送登录消息需要使用的消息模板&#xA;  # 模板标题，随意  模板内容：  点我登录，然后在浏览器中打开！！&#xA;  login_temp_id: &#34;&#34;&#xA;  # 发送普通消息需要使用的消息模板&#xA;  # 模板标题：随意 模板内容： {{data.DATA}}&#xA;  normal_temp_id: &#34;&#34;&#xA;  # xxqg会每隔两小时左右检查所有用户的ck有效性，若开启该选项，会在检查失败时推送提醒消息&#xA;  push_login_warn: false&#xA;  # 微信管理员的openid,可点击关于按钮获得，配置后请重启程序&#xA;  super_open_id: &#34;&#34;&#xA;&#xA;&#xA;# pushDeer推送配置,详情参考psuhDeer官网：http://www.pushdeer.com/official.html&#xA;push_deer:&#xA;  enable: false&#xA;  api: &#34;https://api2.pushdeer.com&#34;&#xA;  token: &#34;&#34;&#xA;&#xA;# 登录重试配置&#xA;retry:&#xA;  # 重试次数&#xA;  times: 0&#xA;&#xA;  # 重试之间的时间间隔，单位为分钟&#xA;  intervals: 5&#xA;&#xA;&#xA;# 设置是否定时执行学习程序，格式为cron格式&#xA;# &#34;9 19 * * *&#34; 每天19点9分执行一次&#xA;# &#34;* 10 * * *” 每天早上十点执行一次&#xA;cron: &#34;0 0 * * *&#34;&#xA;&#xA;# 定时任务随机等待时间，单位：分钟&#xA;cron_random_wait: 0&#xA;&#xA;#windows环境自定义浏览器路径，仅支持chromium系列&#xA;edge_path: &#34;&#34;&#xA;&#xA;# 是否推送二维码&#xA;qr_code: false&#xA;&#xA;# 启动时等待时间，为了防止代理启动比软件慢而报错，默认不等待，单位秒&#xA;start_wait: 0&#xA;&#xA;# 专项答题可接受的最小分值，因一天重复运行的时候，若专项答题未能答满会继续答新的一套题，会浪费题&#xA;special_min_score: 10&#xA;&#xA;# 题目搜索的顺序，为true则从2018年最开始搜题，否则从现在最新开始搜题&#xA;reverse_order: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;跳板搭建&lt;/h2&gt; &#xA;&lt;p&gt;因为学习强国官方app的scheme是dtxuexi://，但是大部分浏览器并不能识别该scheme,所以可以通过自行搭建跳板进行跳转。&lt;/p&gt; &#xA;&lt;p&gt;study_xxqg官方搭建的跳板是使用github page进行搭建的，可能访问情况会比较慢，所以可以进自行搭建跳板。&lt;/p&gt; &#xA;&lt;h2&gt;搭建方法&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;在config目录下的创建dist目录&lt;/li&gt; &#xA; &lt;li&gt;将仓库下docs目录里面的&lt;strong&gt;scheme.html&lt;/strong&gt;和&lt;strong&gt;qrcode.js&lt;/strong&gt;放入该目录&lt;/li&gt; &#xA; &lt;li&gt;配置scheme为**&lt;a href=&#34;http://ip:port/dist/scheme.html&#34;&gt;http://ip:port/dist/scheme.html&lt;/a&gt;?**&lt;/li&gt; &#xA; &lt;li&gt;重启程序&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;也可以通过其他静态文件服务器搭建，如 nginx等&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;常见问题&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;遇到问题的常用解决办法&lt;/h3&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;首先将日志项中的日志等级调整为debug&#xA;&#xA;复现出现的错误，在issue中查找错误日志的关键字&#xA;&#xA;通过搜索引擎查找问题&#xA;&#xA;在群聊中查找聊天记录，查找置顶信息&#xA;&#xA;若无解决方案，可附上关键日志和相关配置文件，在群聊中提出问题或者在github提出issue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;windows打开&lt;strong&gt;study_xxqg.exe&lt;/strong&gt;出现直接闪退&lt;/h3&gt; &lt;pre&gt;&lt;code&gt;在文件路径栏输入**cmd**,然后再黑色命令窗口中输入```./study_xxqg.exe```,&#xA;然后查看报错内容截图并在[github](https://github.com/johlanse/study_xxqg/issues) 提交issue&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;web端账号密码&lt;/h3&gt; &lt;pre&gt;&lt;code&gt;web端账号密码默认都是admin，不是你学习强国的手机号，需要修改可自行修改配置文件&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;关于cookie的时间问题&lt;/h3&gt; &lt;pre&gt;&lt;code&gt;原理是是通过带上当前cookie访问一个api即可，在1.0.35版本之后我通过cron定时执行保活，默认的cron是 0 */1 * * *&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;目前暂不知道能够续期的次数&lt;/p&gt; &#xA;&lt;p&gt;如果你想让访问间隔时间更短或者更长，可以通过添加环境变量 CHECK_ENV 为cron值&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;+ ### windows下出现找不到浏览器的问题&#xA;&#xA;```yaml&#xA;&#xA;自行安装chromium内核的浏览器，包括chrome，edge浏览器之类，然后在配置文件中配置 edge_path 配置项，配置时将路径中的 \ 换成 / 或者 \\ &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;arm设备报错&lt;code&gt;could not download driver: could not check if driver is up2date: could not run driver: exit status 127&lt;/code&gt;&lt;/h3&gt; &lt;pre&gt;&lt;code&gt;因为playwright官方对arm设备支持会出现一些问题，所以需要手动安装node.js和chromium，并创建软连接&#xA;&#xA;apt-get install nodejs&#xA;&#xA;apt-get install chromium&#xA;&#xA;ln -s /usr/bin/chromium ./tools/browser/chromium-978106/chrome-linux/chrome&#xA;&#xA;ln -s /usr/bin/node ./tools/driver/ms-playwright-go/1.20.0-beta-1647057403000/node&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;linux退出终端后脚本停止运行&lt;/h3&gt; &lt;pre&gt;&lt;code&gt;可以使用screen或者nohup等命令后台运行，具体命令自行百度&#xA;&#xA;nohup参考命令&#xA;&#xA;nohup ./study_xxqg &amp;gt; xxqg.log 2&amp;gt;&amp;amp;1&#xA;&#xA;退出程序可以通过**cat pid.pid**查看程序pid,然后kill对应pid进行退出&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;+ ### linux上退出后台正在执行的进程&#xA;&#xA;```yaml&#xA;study_xxqg进程会在运行的时候将pid输出到目录下的pid.pid文件，使用kil -9 命令即可退出后台进程&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;刷文章或者视频无法加分&lt;/h3&gt; &lt;pre&gt;&lt;code&gt;偶尔出现视频和文章无法加分的bug,可以进行等待一段时间后重启程序再次测试，目前尚不清楚造成原因&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;Host system is missing&lt;/h3&gt; &lt;p&gt;报错大概为这样：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;[ERROR]: [core]  初始化chrome失败 &#xA;[2022-05-13 13:43:47] [ERROR]: [core]  could not send message: could not send message to server: Host system is missing dependencies!&#xA;&#xA;Missing libraries are:&#xA;    libgtk-3.so.0&#xA;    libgdk-3.so.0&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;```shell&#xA;sudo ./tools/driver/ms-playwright-go/1.20.0-beta-1647057403000/playwright.sh install-deps&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;若运行后显示未找到apt-get，可百度对应系统安装apt-get的方法&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;为什么运行了就卡住了&lt;/h3&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;当开启了cron定时配置，微信公众号测试号配置，telegram配置这三项的任意一项后，&lt;/p&gt; &#xA;&lt;p&gt;程序就会等待用户的指令从而卡住，所以只需要修改配置文件就可以解决&lt;/p&gt; &#xA;&lt;p&gt;study_xxqg作为一个开源程序，欢迎大家尽自己的一份力做出贡献&lt;/p&gt; &#xA;&lt;h2&gt;贡献要求&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h6&gt;热爱祖国&lt;/h6&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;愿意参与开源贡献&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;贡献文档&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;文档采用docsify框架加上github page进行自动部署，&lt;/p&gt; &#xA; &lt;p&gt;你只需要在docs目录进行marikdown编写，提交pr后会&lt;/p&gt; &#xA; &lt;p&gt;自动生成，本地可通过docsify进行查看运行结果&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;贡献代码&lt;/h2&gt; &#xA;&lt;h3&gt;技术需求&lt;/h3&gt; &#xA;&lt;p&gt;项目采用go语言编写&lt;br&gt; web框架采用gin框架&lt;br&gt; 爬虫框架采用req库&lt;br&gt; 浏览器自动化框架采用playwright-go库&lt;/p&gt; &#xA;&lt;h3&gt;目录结构&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;*&lt;em&gt;.github*&lt;/em&gt;&amp;nbsp;github的相关配置目录，主要存储了action自动化脚本&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\conf*&lt;/em&gt;&amp;nbsp;程序的配置文件解析，默认配置文件存放目录&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\lib*&lt;/em&gt;&amp;nbsp;程序的主要代码目录，包含了核心的各项功能，包括答题，看文章，看视频，telegram&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\model*&lt;/em&gt;&amp;nbsp;程序的用户数据存储，封装了对sqlite的操作&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\push*&lt;/em&gt;&amp;nbsp;程序的推送配置，主要包括钉钉推送和pushplus推送&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\web*&lt;/em&gt;&amp;nbsp;程序的web端操作和微信公众的操作&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\utils*&lt;/em&gt;&amp;nbsp;程序的一些工具类封装&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;运行时生成的目录&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;*&lt;em&gt;\config*&lt;/em&gt;&amp;nbsp;程序的配置文件config.yml的存放目录&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\config\logs*&lt;/em&gt;&amp;nbsp;程序的日志文件存放目录&lt;/li&gt; &#xA; &lt;li&gt;*&lt;em&gt;\dist*&lt;/em&gt;&amp;nbsp;留给用户存放自定义静态文件的目录，映射路径为 \dist，需手动添加并重启程序&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>