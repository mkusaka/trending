<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-27T01:26:23Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Dhravya/radish</title>
    <updated>2024-04-27T01:26:23Z</updated>
    <id>tag:github.com,2024-04-27:/Dhravya/radish</id>
    <link href="https://github.com/Dhravya/radish" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Super fast drop-in replacement of the in memory key-value store Redis, made in Golang&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;!-- logo --&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Dhravya/radish/main/assets/icon.png&#34; width=&#34;300&#34;&gt; &#xA; &lt;h1 align=&#34;center&#34;&gt;Radish&lt;/h1&gt; &#xA; &lt;img alt=&#34;License: MIT&#34; src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34;&gt;&#xA; &lt;br&gt; Super fast drop-in replacement of the in memory key-value store redis in golang &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Dhravya/radish/main/code_of_conduct.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg?sanitize=true&#34; alt=&#34;Contributor Covenant&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Dhravya/radish/main/#installation&#34;&gt;Try it out instantly&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üëÄ What is this? Why?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Radish&lt;/code&gt; is a super fast drop-in replacement of the in memory key-value store redis, built with golang.&lt;/p&gt; &#xA;&lt;p&gt;Why? Redis recently (Last week, as of Mar 25 2024) changed their license to a &lt;a href=&#34;https://news.ycombinator.com/item?id=39772562&#34;&gt;dual &#39;source-available&#39; license&lt;/a&gt; - which means that it can&#39;t be used for commercial purposes without paying for a license. Everyone hated it. This is a problem for many companies and developers who use redis in their projects.&lt;/p&gt; &#xA;&lt;p&gt;And, I was kinda bored and wanted to learn golang properly, so I built this.&lt;/p&gt; &#xA;&lt;p&gt;Should you use this in production? Probably, probably not. It&#39;s not battle tested yet, but i (as a single person team) have tried to do my best to make it as reliable as possible.&lt;/p&gt; &#xA;&lt;p&gt;I even made a cute mascot (Godis crushing Redis)&lt;/p&gt; &#xA;&lt;p&gt;Annddd all i ask in return is a little ‚≠ê so that i dont have to rely on twitter for my dopamine hit.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Dhravya/radish/main/assets/godis.png&#34; alt=&#34;Godis&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üìú Features&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Redis&lt;/th&gt; &#xA;   &lt;th&gt;Radish&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;In-memory key-value store&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Strings&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Lists&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Sets&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Sorted sets&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Hashes&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Streams&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚ùå&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HyperLogLogs&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚ùå&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Bitmaps&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚ùå&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Persistence&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Pub/Sub&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Transactions&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Lua scripting&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚ùå&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;LRU eviction&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚ùå&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TTL&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;üòÖ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Clustering&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚ùå&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Auth&lt;/td&gt; &#xA;   &lt;td&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td&gt;‚ùå&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Available commands&lt;/h3&gt; &#xA;&lt;p&gt;For now, these commands are available (more to come)&lt;/p&gt; &#xA;&lt;h4&gt;MISC&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;INFO&lt;/code&gt; &lt;code&gt;PING&lt;/code&gt; &lt;code&gt;FLUSHALL&lt;/code&gt; &lt;code&gt;SHUTDOWN&lt;/code&gt; &lt;code&gt;SAVE&lt;/code&gt; &lt;code&gt;BGSAVE&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Keys&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;DEL&lt;/code&gt; &lt;code&gt;EXISTS&lt;/code&gt; &lt;code&gt;KEYS&lt;/code&gt; &lt;code&gt;EXPIRE&lt;/code&gt; &lt;code&gt;TTL&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Strings&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SET&lt;/code&gt; &lt;code&gt;GET&lt;/code&gt; &lt;code&gt;APPEND&lt;/code&gt; &lt;code&gt;INCR&lt;/code&gt; &lt;code&gt;INCRBY&lt;/code&gt; &lt;code&gt;DECR&lt;/code&gt; &lt;code&gt;DECRBY&lt;/code&gt; &lt;code&gt;MSET&lt;/code&gt; &lt;code&gt;MGET&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Lists&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;LPUSH&lt;/code&gt; &lt;code&gt;LPOP&lt;/code&gt; &lt;code&gt;RPUSH&lt;/code&gt; &lt;code&gt;RPOP&lt;/code&gt; &lt;code&gt;LRANGE&lt;/code&gt; &lt;code&gt;LLEN&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Hashes&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;HSET&lt;/code&gt; &lt;code&gt;HGET&lt;/code&gt; &lt;code&gt;HMSET&lt;/code&gt; &lt;code&gt;HMGET&lt;/code&gt; &lt;code&gt;HGETALL&lt;/code&gt; &lt;code&gt;HDEL&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Sets&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SADD&lt;/code&gt; &lt;code&gt;SMEMBERS&lt;/code&gt; &lt;code&gt;SISMEMBER&lt;/code&gt; &lt;code&gt;SREM&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Sorted Sets&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;ZADD&lt;/code&gt; &lt;code&gt;ZRANGE&lt;/code&gt; &lt;code&gt;ZREM&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Pub/Sub&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SUBSCRIBE&lt;/code&gt; &lt;code&gt;PUBLISH&lt;/code&gt; &lt;code&gt;UNSUBSCRIBE&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Transactions&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MULTI&lt;/code&gt; &lt;code&gt;EXEC&lt;/code&gt; &lt;code&gt;DISCARD&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;docker&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;To get it up and running instantly, you can use the docker image&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -d -p 6379:6379 dhravyashah/radish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;go&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install github.com/dhravya/radish@latest &amp;amp;&amp;amp; radish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then just build and run the binary&lt;/p&gt; &#xA;&lt;h3&gt;Using the binary&lt;/h3&gt; &#xA;&lt;p&gt;Download the binary executables from &lt;code&gt;./bin/radish&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Click here to get it &lt;a href=&#34;https://github.com/dhrvyashah/radish/releases/download/v0.1.0/radish-0.1.0-linux-amd64.tar.gz&#34;&gt;instantly&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Having fun&lt;/h2&gt; &#xA;&lt;p&gt;This IS compatible with the existing redis tooling and client libraries! Try it out with some of them.&lt;/p&gt; &#xA;&lt;p&gt;For eg.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm i -g redis-cli&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(make sure the server is running - docker is the easiest and fastest way)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;‚ùØ rdcli&#xA;127.0.0.1:6379&amp;gt; incr mycounter&#xA;(integer) 1&#xA;127.0.0.1:6379&amp;gt; incr mycounter&#xA;(integer) 2&#xA;127.0.0.1:6379&amp;gt; set foo bar&#xA;OK&#xA;127.0.0.1:6379&amp;gt; get foo&#xA;bar&#xA;127.0.0.1:6379&amp;gt; get bar&#xA;(nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;radish is &lt;em&gt;completely&lt;/em&gt; open source. If you want to contribute, please create an issue on the repo and I will assign the task to someone (or you).&lt;/p&gt; &#xA;&lt;p&gt;Steps to contribute:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the repo&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/dhravya/radish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a new branch&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure to build and test the code before creating a PR&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;go build -o ./bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Create a PR&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Help and the community&lt;/h2&gt; &#xA;&lt;p&gt;If you need any help, or want to ask questions, or suggest features, please feel free to DM me on twitter - &lt;a href=&#34;https://dm.new/dhravya&#34;&gt;https://dm.new/dhravya&lt;/a&gt; or create an issue on the repo.&lt;/p&gt; &#xA;&lt;p&gt;You can also join our &lt;a href=&#34;https://discord.gg/z7MZYhmx6w&#34;&gt;Discord server&lt;/a&gt; where we have a community of developers ready to help you out.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Unlike redis, radish is licensed under the MIT license. You can use it for commercial purposes without any restrictions. Go wild!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>zk-Call/zkp-hmac-communication-go</title>
    <updated>2024-04-27T01:26:23Z</updated>
    <id>tag:github.com,2024-04-27:/zk-Call/zkp-hmac-communication-go</id>
    <link href="https://github.com/zk-Call/zkp-hmac-communication-go" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&#34;Zero-Knowledge&#34; Proof Implementation with HMAC Communication in Go&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;assets/zk-Call - Preview [Go].png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;zk-Call &amp;amp; Labs&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;strong&gt;&#34;Zero-Knowledge&#34; Proof Implementation with HMAC Communication in Go&lt;/strong&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;http://badges.github.io/stability-badges/dist/experimental.svg?sanitize=true&#34; alt=&#34;Experimental&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;sub&gt; Built by &lt;a href=&#34;https://github.com/zk-Call&#34;&gt; zk-Call&lt;/a&gt; :) &lt;/sub&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/#purpose&#34;&gt;Purpose&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/#how-it-works&#34;&gt;How it Works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/#api&#34;&gt;API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/#example-usage&#34;&gt;Example Usage&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;p&gt;This repository hosts a refined implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Schnorr_signature&#34;&gt;&lt;strong&gt;Schnorr&#39;s Protocol&lt;/strong&gt;&lt;/a&gt;, innovatively incorporating a state seed for enhanced security measures. While the underlying proofs may appear intricate, I aim to elucidate their functionality to the best of my ability. However, for a deeper understanding, I encourage referencing the seminal research papers underpinning this implementation, as they offer comprehensive insights.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/Schnorr&#39;s%20Protocol.png&#34; alt=&#34;Detailed Schematic Overview of Schnorr&#39;s Protocol (Example)&#34;&gt; &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;For further exploration:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/1107.1626.pdf&#34;&gt;&lt;strong&gt;Elliptic Curve Based &#34;Zero-Knowledge&#34; Proofs and Their Applicability on Resource Constrained Devices by Ioannis Chatzigiannakis, Apostolos Pyrgelis, Paul G. Spirakis, and Yannis C. Stamatiou&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/Elliptic%20Curve.png&#34; alt=&#34;Detailed Schematic Overview of Elliptic Curves (Example)&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additionally, this repository delves into the concepts of &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; and &lt;strong&gt;Hash-based Message Authentication Codes (HMACs)&lt;/strong&gt;. &lt;strong&gt;ZKPs&lt;/strong&gt; are cryptographic protocols that allow one party &lt;strong&gt;(the prover)&lt;/strong&gt; to prove to another party &lt;strong&gt;(the verifier)&lt;/strong&gt; that a given statement is true, without revealing any additional information beyond the validity of the statement itself. This property is particularly valuable for preserving privacy while establishing trust. &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, &lt;strong&gt;HMACs&lt;/strong&gt; are a type of cryptographic hash function used for message authentication. They involve a cryptographic hash function &lt;strong&gt;(such as SHA-256)&lt;/strong&gt; and a secret cryptographic key. &lt;strong&gt;HMACs&lt;/strong&gt; provide a way to verify both the data integrity and the authenticity of a message, ensuring that it has not been altered or tampered with during transmission and that it indeed originates from the purported sender. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Purpose&lt;/h1&gt; &#xA;&lt;p&gt;In today&#39;s rapidly evolving IT and application development landscape, &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; emerge as a pivotal paradigm for authentication security. Their capacity to affirm the validity of a claim, such as proving possession of a secret password ‚Äî without revealing any sensitive information about the claim itself, such as passwords or hashes, revolutionizes the assurance of secure &lt;strong&gt;AAA operations&lt;/strong&gt; (&lt;strong&gt;authentication&lt;/strong&gt;, &lt;strong&gt;authorization&lt;/strong&gt;, and &lt;strong&gt;accounting&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/Purpose-1.png&#34; alt=&#34;The Purpose of our Repositories and The Overall Technology&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;zk-Call &amp;amp; Labs&lt;/strong&gt; represents an implementation of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof&#34;&gt;&lt;strong&gt;Non-Interactive &#34;Zero-Knowledge&#34; Proof&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;(NIZKP)&lt;/strong&gt; protocol tailored specifically for validating text-based secrets. This framework proves invaluable for safeguarding passwords and other authentication mechanisms, ensuring robust security measures without compromising privacy. Additionally, the integration of &lt;strong&gt;HMAC (Hash-Based Message Authentication Code)&lt;/strong&gt; further fortifies the authentication process, enhancing data integrity and thwarting potential security breaches. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;How It Works&lt;/h1&gt; &#xA;&lt;p&gt;The authentication protocol employed in this system operates based on two fundamental concepts: &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; and &lt;strong&gt;Hash-Based Message Authentication Code (HMAC)&lt;/strong&gt;. Let&#39;s delve into each of these components and understand how they synergize to ensure secure authentication in messaging applications. &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs):&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;ZKPs&lt;/strong&gt; form the bedrock of privacy-preserving authentication mechanisms. These proofs allow one party &lt;strong&gt;(the prover)&lt;/strong&gt; to demonstrate the validity of a claim to another party &lt;strong&gt;(the verifier)&lt;/strong&gt; without revealing any additional information beyond the claim&#39;s validity. In essence, &lt;strong&gt;ZKPs&lt;/strong&gt; enable authentication without the need for the prover to disclose sensitive data, such as passwords or cryptographic keys.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/ZKP-HMAC-1.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (1)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/ZKP-HMAC-2.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (2)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/ZKP-HMAC-3.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (3)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/ZKP-HMAC-4.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (4)&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Application in Authentication:&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;In the context of messaging applications, &lt;strong&gt;ZKPs&lt;/strong&gt; play a pivotal role in verifying a user&#39;s identity without the need to transmit explicit credentials over the network. Instead, users can generate cryptographic proofs attesting to their identity or possession of certain credentials without exposing those credentials themselves. This ensures that sensitive information remains confidential during the authentication process, bolstering security and privacy. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hash-Based Message Authentication Code (HMAC)&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Hash-Based Message Authentication Code (HMAC):&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;HMAC&lt;/strong&gt; provides a robust mechanism for verifying the integrity and authenticity of messages exchanged between parties. It involves the use of a cryptographic hash function in conjunction with a secret key to generate a unique code &lt;strong&gt;(the HMAC)&lt;/strong&gt; for each message. This code serves as a digital signature, allowing the recipient to verify that the message has not been tampered with or altered during transmission.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/HMAC.png&#34; alt=&#34;Detailed Schematic Overview of HMAC Encryption&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Application in Authentication:&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;In messaging applications, &lt;strong&gt;HMAC&lt;/strong&gt; can be employed to authenticate message senders and ensure the integrity of communication channels. By appending an &lt;strong&gt;HMAC&lt;/strong&gt; to each message using a shared secret key, both the sender and recipient can validate the message&#39;s authenticity upon receipt. Any unauthorized modifications to the message would result in a mismatch between the &lt;strong&gt;computed HMAC&lt;/strong&gt; and the &lt;strong&gt;received HMAC&lt;/strong&gt;, thereby alerting the recipient to potential tampering. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Synergistic Operation&lt;/h2&gt; &#xA;&lt;p&gt;When combined, &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs&lt;/strong&gt; and &lt;strong&gt;HMAC&lt;/strong&gt; create a formidable framework for secure authentication in messaging applications. &lt;strong&gt;ZKPs&lt;/strong&gt; facilitate identity verification without divulging sensitive information, while &lt;strong&gt;HMAC&lt;/strong&gt; ensures the integrity and authenticity of messages exchanged between parties. Together, these mechanisms uphold the confidentiality, integrity, and authenticity of communication channels, safeguarding users&#39; privacy and security in the digital realm.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/Synergistic%20Operation.png&#34; alt=&#34;The Advantages of Synergy between &amp;quot;Zero-Knowledge&amp;quot; Proof and HMAC&#34;&gt; &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;API&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;&#34;Zero-Knowledge&#34;&lt;/code&gt;&lt;/strong&gt; Go API is meant to be simple and intuitive:&lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Core Components&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;Core Components&lt;/code&gt;&lt;/strong&gt; are key for establishing a secure and efficient framework for cryptographic protocols; streamlining the creation and validation of &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt;. They enhance anonymous, data-safe proof validations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/Core%20Components%20(Go).png&#34; alt=&#34;Detailed Schematic Overview of Core Components&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;ZeroKnowledge.models.ZeroKnowledgeParams&lt;/h4&gt; &#xA;&lt;p&gt;The parameters &lt;strong&gt;used to initialize the &#34;Zero-Knowledge&#34;&lt;/strong&gt; crypto system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct ZeroKnowledgeParams():&#xA;    &#34;&#34;&#34;&#xA;    Parameters used to construct a Zero-Knowledge Proof state, utilizing an elliptic curve and a random salt&#xA;    &#34;&#34;&#34;&#xA;    algorithm: string                    # Hashing algorithm name&#xA;    curve: string                  # Standard Elliptic Curve name to use&#xA;    s: []byte                      # Random salt for the state&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ZeroKnowledge.models.ZeroKnowledgeSignature&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;strong&gt;cryptographic &#34;Zero-Knowledge&#34;&lt;/strong&gt; signature that can be used to verify future messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct ZeroKnowledgeSignature():&#xA;    &#34;&#34;&#34;&#xA;    Cryptographic public signature designed to verify future messages&#xA;    &#34;&#34;&#34;&#xA;    params: ZeroKnowledgeParams       # Reference ZeroKnowledge Parameters&#xA;    signature: []byte              # The public key derived from your original secret&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ZeroKnowledge.models.ZeroKnowledgeProof&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;strong&gt;cryptographic proof&lt;/strong&gt; that can be verified against a signature.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct ZeroKnowledgeProof(NamedTuple):&#xA;    &#34;&#34;&#34;&#xA;    Non-deterministic cryptographic Zero-Knowledge Proof designed to confirm that the&#xA;    private key creating the proof matches the key used to generate the signature&#xA;    &#34;&#34;&#34;&#xA;    params: ZeroKnowledgeParams        # Reference ZeroKnowledge Parameters&#xA;    c: []byte                      # The hash of the signed data and random point, R&#xA;    m: []byte                      # The offset from the secret `r` (`R=r*g`) from c * Hash(secret)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ZeroKnowledge.models.ZeroKnowledgeData&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Wrapper&lt;/strong&gt; that contains &lt;strong&gt;a proof and the necessary data&lt;/strong&gt; to validate the proof against a signature.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class ZeroKnowledgeData(NamedTuple):&#xA;    &#34;&#34;&#34;&#xA;    Wrapper designed to hold data along with its corresponding signed proof&#xA;    &#34;&#34;&#34;&#xA;    data: string&#xA;    proof: ZeroKnowledgeProof&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;ZeroKnowledge&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;ZeroKnowledge&lt;/code&gt;&lt;/strong&gt; class is the central component of &lt;strong&gt;&lt;code&gt;ZeroKnowledge&lt;/code&gt;&lt;/strong&gt; and its state (defined by &lt;strong&gt;&lt;code&gt;ZeroKnowledgeParams&lt;/code&gt;&lt;/strong&gt;) should be inherently known to both the &lt;strong&gt;Client (Prover)&lt;/strong&gt; and &lt;strong&gt;Server (Verifier)&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-go/main/assets/ZeroKnowledge%20(Go).png&#34; alt=&#34;Comprehensive Visual Guide to ZeroKnowledge Framework&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Instance Methods&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th width=&#34;9%&#34;&gt;Method&lt;/th&gt; &#xA;   &lt;th width=&#34;46%&#34;&gt;Params&lt;/th&gt; &#xA;   &lt;th width=&#34;10%&#34;&gt;Role&lt;/th&gt; &#xA;   &lt;th width=&#34;35%&#34;&gt;Purpose&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CreateSignature&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;secret: []byte&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prover&lt;/td&gt; &#xA;   &lt;td&gt;Create a cryptographic &lt;code&gt;signature&lt;/code&gt; derived from the value &lt;code&gt;secret&lt;/code&gt; to be generated during initial registration and stored for subsequent &lt;code&gt;challenge&lt;/code&gt; proofs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;secret: []byte&lt;/code&gt; &lt;br&gt; &lt;code&gt;data: interface{}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prover&lt;/td&gt; &#xA;   &lt;td&gt;Create a &lt;code&gt;ZeroKnowledgeData&lt;/code&gt; object using the &lt;code&gt;secret&lt;/code&gt; and any additional data. &lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;verify&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;challenge: interface{}&lt;/code&gt; &lt;br&gt; &lt;code&gt;signature: ZeroKnowledgeSignature&lt;/code&gt; &lt;br&gt; &lt;code&gt;data: Optional[Union[str, bytes, int]]&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Verifier&lt;/td&gt; &#xA;   &lt;td&gt;Verify the user-provided &lt;code&gt;challenge&lt;/code&gt; against the stored &lt;code&gt;signature&lt;/code&gt; and randomly generated token to verify the validity of the &lt;code&gt;challenge&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Example Usage&lt;/h1&gt; &#xA;&lt;p&gt;TODO: Include &lt;strong&gt;&lt;code&gt;Example Usage&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example 1&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;package main // Declares that this file is part of the main package&#xA;&#xA;import (&#xA;  &#34;fmt&#34;                                  // Import the &#34;fmt&#34; package for formatted I/O&#xA;  &#34;sync&#34;                                 // Import the &#34;sync&#34; package for synchronization primitives&#xA;  HMAC_env &#34;tmp/src/HMAC/core&#34;           // Import the HMAC core package and alias it as &#34;HMAC_env&#34;&#xA;  seed_env &#34;tmp/src/SeedGeneration/core&#34; // Import the SeedGeneration core package and alias it as &#34;seed_env&#34;&#xA;)&#xA;&#xA;var DEBUG = true // Define a global variable DEBUG and set it to true&#xA;&#xA;func printMsg(who string, message string) { // Define a function named printMsg that takes two string parameters&#xA;    if DEBUG { // If DEBUG is true, execute the following block&#xA;        fmt.Printf(&#34;[%s] %s\n&#34;, who, message) // Print a formatted message to standard output&#xA;    }&#xA;}&#xA;&#xA;func client(clientSocket chan string, serverSocket chan string, wg *sync.WaitGroup) { // Define a function named client with three parameters&#xA;    defer wg.Done() // Decrement the WaitGroup counter when this function exits&#xA;&#xA;    // Generating the main seed&#xA;    mainSeed := seed_env.NewSeedGenerator(&#34;jack&#34;).Generate() // Generate a main seed using the SeedGenerator with a specified username&#xA;    obj := HMAC_env.NewHMACClient(&#34;sha256&#34;, mainSeed, 1)     // Create a new HMACClient object with SHA-256 hash algorithm, main seed, and iteration count&#xA;    obj.InitDecryptDict()                                    // Initialize the decryption dictionary for the HMACClient&#xA;&#xA;    // Sending the main seed to the server through the serverSocket channel&#xA;    serverSocket &amp;lt;- string(mainSeed) // Convert the main seed to a string and send it to the serverSocket channel&#xA;&#xA;    // Checking if the server has successfully received the seed&#xA;    if &amp;lt;-clientSocket == obj.EncryptMessage(&#34;&#34;) { // Wait for a response from the server via the clientSocket channel and compare it with an encrypted empty message&#xA;        // If successful, send a message to the server&#xA;        message := &#34;hello&#34;                                                 // Define a message to send to the server&#xA;        serverSocket &amp;lt;- obj.EncryptMessageByChunks(message)                // Encrypt and send the message to the server through the serverSocket channel&#xA;        printMsg(&#34;client&#34;, fmt.Sprintf(&#34;client sent message %s&#34;, message)) // Print a message indicating that the client has sent a message&#xA;&#xA;        // Checking if the server has successfully decrypted the message&#xA;        if &amp;lt;-clientSocket == obj.EncryptMessage(message) { // Wait for a response from the server via the clientSocket channel and compare it with the encrypted message&#xA;            printMsg(&#34;client&#34;, &#34;server has decrypt message&#34;) // If the message matches, print a message indicating that the server has decrypted the message&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;func server(serverSocket chan string, clientSocket chan string, wg *sync.WaitGroup) { // Define a function named server with three parameters&#xA;    defer wg.Done() // Decrement the WaitGroup counter when this function exits&#xA;&#xA;    // Receiving the main seed from the client through the serverSocket channel&#xA;    mainSeed := &amp;lt;-serverSocket // Receive the main seed from the client via the serverSocket channel&#xA;&#xA;    // Create a new HMACClient object with SHA-256 hash algorithm, received main seed, and iteration count&#xA;    obj := HMAC_env.NewHMACClient(&#34;sha256&#34;, []byte(mainSeed), 1)&#xA;    obj.InitDecryptDict() // Initialize the decryption dictionary for the HMACClient&#xA;&#xA;    // Sending an empty message to the client as acknowledgment&#xA;    clientSocket &amp;lt;- obj.EncryptMessage(&#34;&#34;) // Encrypt and send an empty message to the client through the clientSocket channel&#xA;&#xA;    // Receiving the message from the client through the serverSocket channel&#xA;    client_mes := &amp;lt;-serverSocket                                    // Receive the encrypted message from the client via the serverSocket channel&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;msg encrypted %s&#34;, client_mes)) // Print a message indicating the encrypted message received&#xA;&#xA;    // Decrypt the received message by chunks&#xA;    msg := obj.DecryptMessageByChunks(client_mes)            // Decrypt the received message by chunks&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;msg decrypted %s&#34;, msg)) // Print a message indicating the decrypted message&#xA;&#xA;    // Sending the decrypted message back to the client through the clientSocket channel&#xA;    clientSocket &amp;lt;- obj.EncryptMessageByChunks(msg) // Encrypt and send the decrypted message back to the client&#xA;}&#xA;&#xA;func main() { // The entry point of the program&#xA;    clientSocket := make(chan string) // Create an unbuffered channel of string type named clientSocket&#xA;    serverSocket := make(chan string) // Create an unbuffered channel of string type named serverSocket&#xA;    var wg sync.WaitGroup             // Declare a WaitGroup variable named wg&#xA;    wg.Add(2)                         // Increment the WaitGroup counter by 2&#xA;    &#xA;    go func() { // Start a new goroutine&#xA;        defer close(clientSocket) // Close the clientSocket channel when this goroutine finishes&#xA;        defer close(serverSocket) // Close the serverSocket channel when this goroutine finishes&#xA;        wg.Wait()                 // Wait until the WaitGroup counter becomes zero&#xA;    }()&#xA;    &#xA;    go client(clientSocket, serverSocket, &amp;amp;wg) // Start a new goroutine for the client function&#xA;    go server(serverSocket, clientSocket, &amp;amp;wg) // Start a new goroutine for the server function&#xA;    &#xA;    wg.Wait() // Wait until all goroutines are finished&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example 2&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;package main // Declares that this file is part of the main package&#xA;&#xA;import (&#xA;    &#34;fmt&#34; // Import the &#34;fmt&#34; package for formatted I/O&#xA;    &#34;sync&#34; // Import the &#34;sync&#34; package for synchronization primitives&#xA;    zkx &#34;tmp/src/ZeroKnowledge/core&#34; // Import the ZeroKnowledge core package and alias it as &#34;zkx&#34;&#xA;    zkx_models &#34;tmp/src/ZeroKnowledge/models&#34; // Import the ZeroKnowledge models package and alias it as &#34;zkx_models&#34;&#xA;)&#xA;&#xA;var DEBUG = true // Define a global variable DEBUG and set it to true&#xA;&#xA;func printMsg(who string, message string) { // Define a function named printMsg that takes two string parameters&#xA;    if DEBUG { // If DEBUG is true, execute the following block&#xA;        fmt.Printf(&#34;[%s] %s\n&#34;, who, message) // Print a formatted message to standard output&#xA;    }&#xA;}&#xA;&#xA;func client(clientSocket chan string, serverSocket chan string, wg *sync.WaitGroup) { // Define a function named client with three parameters&#xA;    defer wg.Done() // Decrement the WaitGroup counter when this function exits&#xA;&#xA;    // Create a ZeroKnowledge object for the client with specified curve and hash algorithm&#xA;    clientObject := zkx.New(&#34;Ed25519&#34;, &#34;blake2b&#34;, nil, &#34;HB2B&#34;, 16)&#xA;&#xA;    // Generate a signature for the client identity&#xA;    identity := &#34;John&#34;&#xA;    signature := clientObject.CreateSignature(identity)&#xA;&#xA;    // Send the signature to the server through the serverSocket channel&#xA;    serverSocket &amp;lt;- zkx_models.ZeroKnowledgeSignature.ToJSON(signature)&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Sent signature: %s&#34;, zkx_models.ZeroKnowledgeSignature.ToJSON()))&#xA;&#xA;    // Receive token from the server through the clientSocket channel&#xA;    token := &amp;lt;-clientSocket&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Received token: %s&#34;, token))&#xA;&#xA;    // Generate a proof using client identity and token&#xA;    proof := zkx_models.ZeroKnowledgeSignature.ToJSON(clientObject.Sign(identity, token))&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Proof: %s&#34;, proof))&#xA;&#xA;    // Send proof to the server through the serverSocket channel&#xA;    serverSocket &amp;lt;- proof&#xA;&#xA;    // Receive result from the server through the clientSocket channel&#xA;    result := &amp;lt;-clientSocket&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Result: %s&#34;, result))&#xA;}&#xA;&#xA;func server(serverSocket chan string, clientSocket chan string, wg *sync.WaitGroup) { // Define a function named server with three parameters&#xA;    defer wg.Done() // Decrement the WaitGroup counter when this function exits&#xA;&#xA;    // Set the server password&#xA;    serverPassword := &#34;SecretServerPassword&#34;&#xA;&#xA;    // Create a ZeroKnowledge object for the server with specified curve and hash algorithm&#xA;    serverZK := zkx.New(&#34;Ed25519&#34;, &#34;blake2b&#34;, nil, &#34;HB2B&#34;, 16)&#xA;&#xA;    // Receive client signature from the client through the serverSocket channel&#xA;    clientSig := &amp;lt;-serverSocket&#xA;    clientSignature := zkx_models.ZeroKnowledgeSignature.FromJSON(clientSig)&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Received client signature: %s&#34;, clientSignature)&#xA;&#xA;    // Generate a token signed by the server for the client&#xA;    token := serverZK.Sign(serverPassword, zkx.Token(serverZK))&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Generated token: %s&#34;, token))&#xA;&#xA;    // Send the token to the client through the clientSocket channel&#xA;    clientSocket &amp;lt;- zkx_models.ZeroKnowledgeData.ToJSON(token)&#xA;&#xA;    // Receive proof from the client through the serverSocket channel&#xA;    proof := &amp;lt;-serverSocket&#xA;    clientProof := zkx_models.ZeroKnowledgeData.FromJSON(proof)&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Received proof: %s&#34;, proof))&#xA;&#xA;    // Verify the received proof&#xA;    tokenData := zkx_models.ZeroKnowledgeData.FromJSON(clientProof.Data)&#xA;    serverVerification := serverZK.Verify(tokenData, clientSignature)&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Server verification result: %t&#34;, serverVerification))&#xA;&#xA;    // If server verification fails, notify the client through the clientSocket channel&#xA;    if !serverVerification {&#xA;        clientSocket &amp;lt;- &#34;Server verification failed&#34;&#xA;    } else {&#xA;        // Otherwise, verify the proof using client signature&#xA;        clientVerification := clientSignature.Verify(clientProof, tokenData)&#xA;        printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Client verification result: %t&#34;, clientVerification))&#xA;        if clientVerification {&#xA;            clientSocket &amp;lt;- &#34;Verification successful&#34;&#xA;        } else {&#xA;            clientSocket &amp;lt;- &#34;Verification failed&#34;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;func main() { // Entry point of the program&#xA;    clientSocket := make(chan string) // Create a unbuffered channel of string type named clientSocket&#xA;    serverSocket := make(chan string) // Create a unbuffered channel of string type named serverSocket&#xA;    var wg sync.WaitGroup // Declare a WaitGroup variable named wg&#xA;    wg.Add(2) // Increment the WaitGroup counter by 2&#xA;&#xA;    go func() { // Start a new goroutine&#xA;        defer close(clientSocket) // Close the clientSocket channel when this goroutine finishes&#xA;        defer close(serverSocket) // Close the serverSocket channel when this goroutine finishes&#xA;        wg.Wait() // Wait until the WaitGroup counter becomes zero&#xA;    }()&#xA;&#xA;    go client(clientSocket, serverSocket, &amp;amp;wg) // Start a new goroutine for the client function&#xA;    go server(serverSocket, clientSocket, &amp;amp;wg) // Start a new goroutine for the server function&#xA;&#xA;    wg.Wait() // Wait until all goroutines are finished&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example 3&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;package main // Declares that this file is part of the main package&#xA;&#xA;import (&#xA;    &#34;fmt&#34;  // Import the &#34;fmt&#34; package for formatted I/O&#xA;    &#34;sync&#34; // Import the &#34;sync&#34; package for synchronization primitives&#xA;    HMAC_env &#34;tmp/src/HMAC/core&#34;&#xA;    seed_env &#34;tmp/src/SeedGeneration/core&#34;&#xA;    zkx &#34;tmp/src/ZeroKnowledge/core&#34;          // Import the ZeroKnowledge core package and alias it as &#34;zkx&#34;&#xA;    zkx_models &#34;tmp/src/ZeroKnowledge/models&#34; // Import the ZeroKnowledge models package and alias it as &#34;zkx_models&#34;&#xA;)&#xA;&#xA;var DEBUG = true // Define a global variable DEBUG and set it to true&#xA;&#xA;func printMsg(who string, message string) { // Define a function named printMsg that takes two string parameters&#xA;    if DEBUG {                              // If DEBUG is true, execute the following block&#xA;      fmt.Printf(&#34;[%s] %s\n&#34;, who, message) // Print a formatted message to standard output&#xA;    }&#xA;}&#xA;&#xA;func client(clientSocket chan string, serverSocket chan string, wg *sync.WaitGroup) { // Define a function named client with three parameters&#xA;    defer wg.Done() // Decrement the WaitGroup counter when this function exits&#xA;&#xA;    // Create a ZeroKnowledge object for the client with specified curve and hash algorithm&#xA;    clientObject := zkx.New(&#34;Ed25519&#34;, &#34;blake2b&#34;, nil, &#34;HB2B&#34;, 16)&#xA;&#xA;    // Generate a signature for the client identity&#xA;    identity := &#34;John&#34;&#xA;    signature := clientObject.CreateSignature(identity)&#xA;&#xA;    // Send the signature to the server through the serverSocket channel&#xA;    serverSocket &amp;lt;- zkx_models.ZeroKnowledgeSignature.ToJSON(signature)&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Sent signature: %s&#34;, zkx_models.ZeroKnowledgeSignature.ToJSON()))&#xA;&#xA;    // Receive token from the server through the clientSocket channel&#xA;    token := &amp;lt;-clientSocket&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Received token: %s&#34;, token))&#xA;&#xA;    // Generate a proof using client identity and token&#xA;    proof := zkx_models.ZeroKnowledgeSignature.ToJSON(clientObject.Sign(identity, token))&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Proof: %s&#34;, proof))&#xA;&#xA;    // Send proof to the server through the serverSocket channel&#xA;    serverSocket &amp;lt;- proof&#xA;&#xA;    // Receive result from the server through the clientSocket channel&#xA;    result := &amp;lt;-clientSocket&#xA;    printMsg(&#34;client&#34;, fmt.Sprintf(&#34;Result: %s&#34;, result))&#xA;    if result {&#xA;        mainSeed := seed_env.NewSeedGenerator(&#34;jack&#34;).Generate() // Generate a main seed using the SeedGenerator with a specified username&#xA;        obj := HMAC_env.NewHMACClient(&#34;sha256&#34;, mainSeed, 1)     // Create a new HMACClient object with SHA-256 hash algorithm, main seed, and iteration count&#xA;        obj.InitDecryptDict()                                    // Initialize the decryption dictionary for the HMACClient&#xA;&#xA;        // Sending the main seed to the server through the serverSocket channel&#xA;        serverSocket &amp;lt;- string(mainSeed) // Convert the main seed to a string and send it to the serverSocket channel&#xA;&#xA;        // Checking if the server has successfully received the seed&#xA;        if &amp;lt;-clientSocket == obj.EncryptMessage(&#34;&#34;) { // Wait for a response from the server via the clientSocket channel and compare it with an encrypted empty message&#xA;            // If successful, send a message to the server&#xA;            message := &#34;hello&#34;                                                 // Define a message to send to the server&#xA;            serverSocket &amp;lt;- obj.EncryptMessageByChunks(message)                // Encrypt and send the message to the server through the serverSocket channel&#xA;            printMsg(&#34;client&#34;, fmt.Sprintf(&#34;client sent message %s&#34;, message)) // Print a message indicating that the client has sent a message&#xA;&#xA;            // Checking if the server has successfully decrypted the message&#xA;            if &amp;lt;-clientSocket == obj.EncryptMessage(message) { // Wait for a response from the server via the clientSocket channel and compare it with the encrypted message&#xA;                printMsg(&#34;client&#34;, &#34;server has decrypt message&#34;) // If the message matches, print a message indicating that the server has decrypted the message&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;func server(serverSocket chan string, clientSocket chan string, wg *sync.WaitGroup) { // Define a function named server with three parameters&#xA;    defer wg.Done() // Decrement the WaitGroup counter when this function exits&#xA;&#xA;    // Set the server password&#xA;    serverPassword := &#34;SecretServerPassword&#34;&#xA;&#xA;    // Create a ZeroKnowledge object for the server with specified curve and hash algorithm&#xA;    serverZK := zkx.New(&#34;Ed25519&#34;, &#34;blake2b&#34;, nil, &#34;HB2B&#34;, 16)&#xA;&#xA;    // Receive client signature from the client through the serverSocket channel&#xA;    clientSig := &amp;lt;-serverSocket&#xA;    clientSignature := zkx_models.ZeroKnowledgeSignature.FromJSON(clientSig)&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Received client signature: %s&#34;, clientSignature)&#xA;&#xA;    // Generate a token signed by the server for the client&#xA;    token := serverZK.Sign(serverPassword, zkx.Token(serverZK))&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Generated token: %s&#34;, token))&#xA;&#xA;    // Send the token to the client through the clientSocket channel&#xA;    clientSocket &amp;lt;- zkx_models.ZeroKnowledgeData.ToJSON(token)&#xA;&#xA;    // Receive proof from the client through the serverSocket channel&#xA;    proof := &amp;lt;-serverSocket&#xA;    clientProof := zkx_models.ZeroKnowledgeData.FromJSON(proof)&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Received proof: %s&#34;, proof))&#xA;&#xA;    // Verify the received proof&#xA;    tokenData := zkx_models.ZeroKnowledgeData.FromJSON(clientProof.Data)&#xA;    serverVerification := serverZK.Verify(tokenData, clientSignature)&#xA;    printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Server verification result: %t&#34;, serverVerification))&#xA;&#xA;    // If server verification fails, notify the client through the clientSocket channel&#xA;    if !serverVerification {&#xA;        clientSocket &amp;lt;- &#34;Server verification failed&#34;&#xA;    } else {&#xA;        // Otherwise, verify the proof using client signature&#xA;        clientVerification := clientSignature.Verify(clientProof, tokenData)&#xA;        printMsg(&#34;server&#34;, fmt.Sprintf(&#34;Client verification result: %t&#34;, clientVerification))&#xA;        if clientVerification {&#xA;            clientSocket &amp;lt;- &#34;Verification successful&#34;&#xA;            mainSeed := &amp;lt;-serverSocket // Receive the main seed from the client via the serverSocket channel&#xA;&#xA;            // Create a new HMACClient object with SHA-256 hash algorithm, received main seed, and iteration count&#xA;            obj := HMAC_env.NewHMACClient(&#34;sha256&#34;, []byte(mainSeed), 1)&#xA;            obj.InitDecryptDict() // Initialize the decryption dictionary for the HMACClient&#xA;&#xA;            // Sending an empty message to the client as acknowledgment&#xA;            clientSocket &amp;lt;- obj.EncryptMessage(&#34;&#34;) // Encrypt and send an empty message to the client through the clientSocket channel&#xA;&#xA;            // Receiving the message from the client through the serverSocket channel&#xA;            client_mes := &amp;lt;-serverSocket                                    // Receive the encrypted message from the client via the serverSocket channel&#xA;            printMsg(&#34;server&#34;, fmt.Sprintf(&#34;msg encrypted %s&#34;, client_mes)) // Print a message indicating the encrypted message received&#xA;&#xA;            // Decrypt the received message by chunks&#xA;            msg := obj.DecryptMessageByChunks(client_mes)            // Decrypt the received message by chunks&#xA;            printMsg(&#34;server&#34;, fmt.Sprintf(&#34;msg decrypted %s&#34;, msg)) // Print a message indicating the decrypted message&#xA;&#xA;            // Sending the decrypted message back to the client through the clientSocket channel&#xA;            clientSocket &amp;lt;- obj.EncryptMessageByChunks(msg) // Encrypt and send the decrypted message back to the client&#xA;&#xA;        } else {&#xA;            clientSocket &amp;lt;- &#34;Verification failed&#34;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;func main() { // Entry point of the program&#xA;    clientSocket := make(chan string) // Create a unbuffered channel of string type named clientSocket&#xA;    serverSocket := make(chan string) // Create a unbuffered channel of string type named serverSocket&#xA;    var wg sync.WaitGroup             // Declare a WaitGroup variable named wg&#xA;    wg.Add(2)                         // Increment the WaitGroup counter by 2&#xA;&#xA;    go func() { // Start a new goroutine&#xA;        defer close(clientSocket) // Close the clientSocket channel when this goroutine finishes&#xA;        defer close(serverSocket) // Close the serverSocket channel when this goroutine finishes&#xA;        wg.Wait()                 // Wait until the WaitGroup counter becomes zero&#xA;    }()&#xA;&#xA;    go client(clientSocket, serverSocket, &amp;amp;wg) // Start a new goroutine for the client function&#xA;    go server(serverSocket, clientSocket, &amp;amp;wg) // Start a new goroutine for the server function&#xA;&#xA;    wg.Wait() // Wait until all goroutines are finished&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>