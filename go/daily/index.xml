<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-10T01:36:49Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mvdan/sh</title>
    <updated>2023-01-10T01:36:49Z</updated>
    <id>tag:github.com,2023-01-10:/mvdan/sh</id>
    <link href="https://github.com/mvdan/sh" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A shell parser, formatter, and interpreter with bash support; includes shfmt&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sh&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/mvdan.cc/sh/v3&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/mvdan.cc/sh/v3.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A shell parser, formatter, and interpreter. Supports &lt;a href=&#34;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html&#34;&gt;POSIX Shell&lt;/a&gt;, &lt;a href=&#34;https://www.gnu.org/software/bash/&#34;&gt;Bash&lt;/a&gt;, and &lt;a href=&#34;http://www.mirbsd.org/mksh.htm&#34;&gt;mksh&lt;/a&gt;. Requires Go 1.18 or later.&lt;/p&gt; &#xA;&lt;h3&gt;Quick start&lt;/h3&gt; &#xA;&lt;p&gt;To parse shell scripts, inspect them, and print them out, see the &lt;a href=&#34;https://pkg.go.dev/mvdan.cc/sh/v3/syntax#pkg-examples&#34;&gt;syntax examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For high-level operations like performing shell expansions on strings, see the &lt;a href=&#34;https://pkg.go.dev/mvdan.cc/sh/v3/shell#pkg-examples&#34;&gt;shell examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;shfmt&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install mvdan.cc/sh/v3/cmd/shfmt@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;shfmt&lt;/code&gt; formats shell programs. See &lt;a href=&#34;https://raw.githubusercontent.com/mvdan/sh/master/syntax/canonical.sh&#34;&gt;canonical.sh&lt;/a&gt; for a quick look at its default style. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;shfmt -l -w script.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information, see &lt;a href=&#34;https://raw.githubusercontent.com/mvdan/sh/master/cmd/shfmt/shfmt.1.scd&#34;&gt;its manpage&lt;/a&gt;, which can be viewed directly as Markdown or rendered with &lt;a href=&#34;https://sr.ht/~sircmpwn/scdoc/&#34;&gt;scdoc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Packages are available on &lt;a href=&#34;https://pkgs.alpinelinux.org/packages?name=shfmt&#34;&gt;Alpine&lt;/a&gt;, &lt;a href=&#34;https://archlinux.org/packages/community/x86_64/shfmt/&#34;&gt;Arch&lt;/a&gt;, &lt;a href=&#34;https://tracker.debian.org/pkg/golang-mvdan-sh&#34;&gt;Debian&lt;/a&gt;, &lt;a href=&#34;https://hub.docker.com/r/mvdan/shfmt/&#34;&gt;Docker&lt;/a&gt;, &lt;a href=&#34;https://packages.fedoraproject.org/pkgs/golang-mvdan-sh-3/shfmt/&#34;&gt;Fedora&lt;/a&gt;, &lt;a href=&#34;https://www.freshports.org/devel/shfmt&#34;&gt;FreeBSD&lt;/a&gt;, &lt;a href=&#34;https://formulae.brew.sh/formula/shfmt&#34;&gt;Homebrew&lt;/a&gt;, &lt;a href=&#34;https://ports.macports.org/port/shfmt/summary/&#34;&gt;MacPorts&lt;/a&gt;, &lt;a href=&#34;https://github.com/NixOS/nixpkgs/raw/HEAD/pkgs/tools/text/shfmt/default.nix&#34;&gt;NixOS&lt;/a&gt;, &lt;a href=&#34;https://github.com/ScoopInstaller/Main/raw/HEAD/bucket/shfmt.json&#34;&gt;Scoop&lt;/a&gt;, &lt;a href=&#34;https://snapcraft.io/shfmt&#34;&gt;Snapcraft&lt;/a&gt;, &lt;a href=&#34;https://github.com/void-linux/void-packages/raw/HEAD/srcpkgs/shfmt/template&#34;&gt;Void&lt;/a&gt; and &lt;a href=&#34;https://webinstall.dev/shfmt/&#34;&gt;webi&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;gosh&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install mvdan.cc/sh/v3/cmd/gosh@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Proof of concept shell that uses &lt;code&gt;interp&lt;/code&gt;. Note that it&#39;s not meant to replace a POSIX shell at the moment, and its options are intentionally minimalistic.&lt;/p&gt; &#xA;&lt;h3&gt;Fuzzing&lt;/h3&gt; &#xA;&lt;p&gt;We use Go&#39;s native fuzzing support. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd syntax&#xA;go test -run=- -fuzz=ParsePrint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Caveats&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When indexing Bash associative arrays, always use quotes. The static parser will otherwise have to assume that the index is an arithmetic expression.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo &#39;${array[spaced string]}&#39; | shfmt&#xA;1:16: not a valid arithmetic operator: string&#xA;$ echo &#39;${array[dash-string]}&#39; | shfmt&#xA;${array[dash - string]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$((&lt;/code&gt; and &lt;code&gt;((&lt;/code&gt; ambiguity is not supported. Backtracking would complicate the parser and make streaming support via &lt;code&gt;io.Reader&lt;/code&gt; impossible. The POSIX spec recommends to &lt;a href=&#34;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_03&#34;&gt;space the operands&lt;/a&gt; if &lt;code&gt;$( (&lt;/code&gt; is meant.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo &#39;$((foo); (bar))&#39; | shfmt&#xA;1:1: reached ) without matching $(( with ))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Some builtins like &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; are parsed as keywords. This allows statically building their syntax tree, as opposed to keeping the arguments as a slice of words. It is also required to support &lt;code&gt;declare foo=(bar)&lt;/code&gt;. Note that this means expansions like &lt;code&gt;declare {a,b}=c&lt;/code&gt; are not supported.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;JavaScript&lt;/h3&gt; &#xA;&lt;p&gt;A subset of the Go packages are available as an npm package called &lt;a href=&#34;https://www.npmjs.com/package/mvdan-sh&#34;&gt;mvdan-sh&lt;/a&gt;. See the &lt;a href=&#34;https://raw.githubusercontent.com/mvdan/sh/master/_js&#34;&gt;_js&lt;/a&gt; directory for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;All release tags are published via &lt;a href=&#34;https://hub.docker.com/r/mvdan/shfmt/&#34;&gt;Docker&lt;/a&gt;, such as &lt;code&gt;v3.5.1&lt;/code&gt;. The latest stable release is currently published as &lt;code&gt;v3&lt;/code&gt;, and the latest development version as &lt;code&gt;latest&lt;/code&gt;. The images only include &lt;code&gt;shfmt&lt;/code&gt;; &lt;code&gt;-alpine&lt;/code&gt; variants exist on Alpine Linux.&lt;/p&gt; &#xA;&lt;p&gt;To build a Docker image, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker build -t my:tag -f cmd/shfmt/Dockerfile .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use a Docker image, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --rm -u &#34;$(id -u):$(id -g)&#34; -v &#34;$PWD:/mnt&#34; -w /mnt my:tag &amp;lt;shfmt arguments&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Related projects&lt;/h3&gt; &#xA;&lt;p&gt;The following editor integrations wrap &lt;code&gt;shfmt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.bashsupport.com/manual/editor/formatter/&#34;&gt;BashSupport-Pro&lt;/a&gt; - Bash plugin for JetBrains IDEs&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://atom.io/packages/format-shell&#34;&gt;format-shell&lt;/a&gt; - Atom plugin&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/help/idea/shell-scripts.html&#34;&gt;intellij-shellcript&lt;/a&gt; - Intellij Jetbrains &lt;code&gt;shell script&lt;/code&gt; plugin&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://micro-editor.github.io/&#34;&gt;micro&lt;/a&gt; - Editor with a built-in plugin&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=foxundermoon.shell-format&#34;&gt;shell-format&lt;/a&gt; - VS Code plugin&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=mkhl.shfmt&#34;&gt;vscode-shfmt&lt;/a&gt; - VS Code plugin&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/purcell/emacs-shfmt/&#34;&gt;shfmt.el&lt;/a&gt; - Emacs package&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/aerobounce/Sublime-Pretty-Shell&#34;&gt;Sublime-Pretty-Shell&lt;/a&gt; - Sublime Text 3 plugin&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://trunk.io/products/check&#34;&gt;Trunk&lt;/a&gt; - Universal linter, available as a CLI, VS Code plugin, and GitHub action&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/z0mbix/vim-shfmt&#34;&gt;vim-shfmt&lt;/a&gt; - Vim plugin&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other noteworthy integrations include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cortesi/modd&#34;&gt;modd&lt;/a&gt; - A developer tool that responds to filesystem changes&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/un-ts/prettier/tree/master/packages/sh&#34;&gt;prettier-plugin-sh&lt;/a&gt; - &lt;a href=&#34;https://prettier.io&#34;&gt;Prettier&lt;/a&gt; plugin using &lt;a href=&#34;https://www.npmjs.com/package/mvdan-sh&#34;&gt;mvdan-sh&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/luizm/action-sh-checker&#34;&gt;sh-checker&lt;/a&gt; - A GitHub Action that performs static analysis for shell scripts&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hukkin/mdformat-shfmt&#34;&gt;mdformat-shfmt&lt;/a&gt; - &lt;a href=&#34;https://github.com/executablebooks/mdformat&#34;&gt;mdformat&lt;/a&gt; plugin to format shell scripts embedded in Markdown with shfmt&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/scop/pre-commit-shfmt&#34;&gt;pre-commit-shfmt&lt;/a&gt; - &lt;a href=&#34;https://pre-commit.com&#34;&gt;pre-commit&lt;/a&gt; shfmt hook&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>kubernetes-sigs/kwok</title>
    <updated>2023-01-10T01:36:49Z</updated>
    <id>tag:github.com,2023-01-10:/kubernetes-sigs/kwok</id>
    <link href="https://github.com/kubernetes-sigs/kwok" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Kubernetes WithOut Kubelet - Simulates thousands of Nodes and Clusters.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;KWOK&lt;/code&gt; (&lt;code&gt;K&lt;/code&gt;ubernetes &lt;code&gt;W&lt;/code&gt;ith&lt;code&gt;O&lt;/code&gt;ut &lt;code&gt;K&lt;/code&gt;ubelet)&lt;/h1&gt; &#xA;&lt;img align=&#34;right&#34; width=&#34;180px&#34; src=&#34;https://raw.githubusercontent.com/kubernetes-sigs/kwok/main/logo/kwok.svg?sanitize=true&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sigs.k8s.io/kwok&#34;&gt;kwok&lt;/a&gt; is a toolkit that enables setting up a cluster of thousands of Nodes in seconds. Under the scene, all Nodes are simulated to behave like real ones, so the overall approach employs a pretty low resource footprint that you can easily play around on your laptop.&lt;/p&gt; &#xA;&lt;p&gt;So far we provide two tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Kwok:&lt;/strong&gt; Core of this repo. It simulates thousands of fake Nodes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Kwokctl:&lt;/strong&gt; A CLI to facilitate creating and managing clusters simulated by Kwok.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://kwok-demo.netlify.app&#34;&gt;https://kwok-demo.netlify.app&lt;/a&gt; for more in-depth information. But it will be replaced in the future when &lt;a href=&#34;https://kwok.sigs.k8s.io&#34;&gt;https://kwok.sigs.k8s.io&lt;/a&gt; is available.&lt;/p&gt; &#xA;&lt;img width=&#34;700px&#34; src=&#34;https://raw.githubusercontent.com/kubernetes-sigs/kwok/main/demo/manage-clusters.svg?sanitize=true&#34;&gt; &#xA;&lt;h2&gt;Community, discussion, contribution, and support&lt;/h2&gt; &#xA;&lt;p&gt;Learn how to engage with the Kubernetes community on the &lt;a href=&#34;http://kubernetes.io/community/&#34;&gt;community page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can reach the maintainers of this project at:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.slack.com/messages/sig-scheduling&#34;&gt;Slack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/kubernetes-sig-scheduling&#34;&gt;Mailing List&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Code of conduct&lt;/h3&gt; &#xA;&lt;p&gt;Participation in the Kubernetes community is governed by the &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/kwok/main/code-of-conduct.md&#34;&gt;Kubernetes Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>u-root/u-root</title>
    <updated>2023-01-10T01:36:49Z</updated>
    <id>tag:github.com,2023-01-10:/u-root/u-root</id>
    <link href="https://github.com/u-root/u-root" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fully Go userland with Linux bootloaders! u-root can create a one-binary root file system (initramfs) containing a busybox-like set of tools written in Go.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;u-root&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/u-root/u-root/tree/main&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/u-root/u-root/tree/main.png?style=shield&amp;amp;circle-token=8d9396e32f76f82bf4257b60b414743e57734244&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/u-root/u-root&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/u-root/u-root/branch/main/graph/badge.svg?token=1qjHT02oCB&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/u-root/u-root&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/u-root/u-root&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/u-root/u-root/actions?query=workflow%3ACodeQL&#34;&gt;&lt;img src=&#34;https://github.com/u-root/u-root/workflows/CodeQL/badge.svg?sanitize=true&#34; alt=&#34;CodeQL&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/u-root/u-root&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/u-root/u-root?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://slack.osfw.dev&#34;&gt;&lt;img src=&#34;https://slack.osfw.dev/badge.svg?sanitize=true&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/u-root/u-root/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-BSD%203--Clause-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;u-root embodies four different projects.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Go versions of many standard Linux tools, such as &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/core/ls/ls.go&#34;&gt;ls&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/core/cp/cp.go&#34;&gt;cp&lt;/a&gt;, or &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/core/shutdown/shutdown_linux.go&#34;&gt;shutdown&lt;/a&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/core&#34;&gt;cmds/core&lt;/a&gt; for most of these.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A way to compile many Go programs into a single binary with &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/pkg/bb/README.md&#34;&gt;busybox mode&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A way to create initramfs (an archive of files) to use with Linux kernels.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Go bootloaders that use &lt;code&gt;kexec&lt;/code&gt; to boot Linux or multiboot kernels such as ESXi, Xen, or tboot. They are meant to be used with &lt;a href=&#34;https://www.linuxboot.org&#34;&gt;LinuxBoot&lt;/a&gt;. With that, parsers for &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/pkg/boot/grub&#34;&gt;GRUB config files&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/pkg/boot/syslinux&#34;&gt;syslinux config files&lt;/a&gt; are to make transition to LinuxBoot easier.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Make sure your Go version is &amp;gt;=1.19.&lt;/p&gt; &#xA;&lt;p&gt;Download and install u-root either via git:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/u-root/u-root&#xA;cd u-root&#xA;go build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting binary will the be placed where &lt;code&gt;go build&lt;/code&gt; was invoked&lt;/p&gt; &#xA;&lt;p&gt;Or install directly with go:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go install github.com/u-root/u-root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note: The &lt;code&gt;u-root&lt;/code&gt; command will end up in &lt;code&gt;$GOPATH/bin/u-root&lt;/code&gt;, so you may need to add &lt;code&gt;$GOPATH/bin&lt;/code&gt; to your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can now use the u-root command to build an initramfs. Here are some examples with $UROOT_PATH being the path to where the u-root sources are on the disk (explicitly specifiying this is only necessary if not runnig u-root inside the root of the repository):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Build an initramfs of all the Go cmds in ./cmds/core/... (default)&#xA;u-root&#xA;&#xA;# Build an initramfs of all the Go cmds in ./cmds/core/...&#xA;# But running the command outside of the repository root&#xA;(cd /tmp &amp;amp;&amp;amp; GBB_PATH=$UROOT_PATH u-root)&#xA;&#xA;# Generate an archive with bootloaders&#xA;#&#xA;# core and boot are templates that expand to sets of commands&#xA;u-root core boot&#xA;&#xA;# Generate an archive with only these given commands&#xA;u-root ./cmds/core/{init,ls,ip,dhclient,wget,cat,elvish}&#xA;&#xA;# Generate an archive with all of the core tools with some exceptions&#xA;u-root core -cmds/core/{ls,losetup}&#xA;&#xA;# Generate an archive with a tool outside of u-root&#xA;git clone https://github.com/u-root/cpu&#xA;u-root ./cmds/core/{init,ls,elvish} ./cpu/cmds/cpud&#xA;&#xA;# Generate an archive with a tool outside of u-root, in any PWD&#xA;(cd /tmp &amp;amp;&amp;amp; GBB_PATH=$UROOT_PATH:$CPU_PATH u-root ./cmds/core/{init,ls,elvish} ./cmds/cpud)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default set of packages included is all packages in &lt;code&gt;github.com/u-root/u-root/cmds/core/...&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can build the initramfs built by u-root into the kernel via the &lt;code&gt;CONFIG_INITRAMFS_SOURCE&lt;/code&gt; config variable or you can load it separately via an option in for example Grub or the QEMU command line or coreboot config variable.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;GBB_PATH&lt;/code&gt; is a place that u-root will look for commands. Each colon-separated &lt;code&gt;GBB_PATH&lt;/code&gt; element is concatenated with patterns from the command-line and checked for existence. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;GBB_PATH=$HOME/u-root:$HOME/u-bmc u-root \&#xA;    cmds/core/init \&#xA;    cmds/core/elvish \&#xA;    cmd/socreset&#xA;&#xA;# matches:&#xA;#   $HOME/u-root/cmds/core/init&#xA;#   $HOME/u-root/cmds/core/elvish&#xA;#   $HOME/u-bmc/cmd/socreset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Extra Files&lt;/h2&gt; &#xA;&lt;p&gt;You may also include additional files in the initramfs using the &lt;code&gt;-files&lt;/code&gt; flag. If you add binaries with &lt;code&gt;-files&lt;/code&gt; are listed, their ldd dependencies will be included as well. As example for Debian, you want to add two kernel modules for testing, executing your currently booted kernel:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: these files will be placed in the &lt;code&gt;$HOME&lt;/code&gt; dir in the initramfs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;u-root -files &#34;$HOME/hello.ko $HOME/hello2.ko&#34;&#xA;qemu-system-x86_64 -kernel /boot/vmlinuz-$(uname -r) -initrd /tmp/initramfs.linux_amd64.cpio&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To specify the location in the initramfs, use &lt;code&gt;&amp;lt;sourcefile&amp;gt;:&amp;lt;destinationfile&amp;gt;&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;u-root -files &#34;root-fs/usr/bin/runc:usr/bin/run&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Init and Uinit&lt;/h2&gt; &#xA;&lt;p&gt;u-root has a very simple (exchangable) init system controlled by the &lt;code&gt;-initcmd&lt;/code&gt; and &lt;code&gt;-uinitcmd&lt;/code&gt; command-line flags.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-initcmd&lt;/code&gt; determines what &lt;code&gt;/init&lt;/code&gt; is symlinked to. &lt;code&gt;-initcmd&lt;/code&gt; may be a u-root command name or a symlink target.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-uinitcmd&lt;/code&gt; is run by the default u-root &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/core/init&#34;&gt;init&lt;/a&gt; after some basic file system setup. There is no default, users should optionally supply their own. &lt;code&gt;-uinitcmd&lt;/code&gt; may be a u-root command name with arguments or a symlink target with arguments.&lt;/li&gt; &#xA; &lt;li&gt;After running a uinit (if there is one), &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/core/init&#34;&gt;init&lt;/a&gt; will start a shell determined by the &lt;code&gt;-defaultsh&lt;/code&gt; argument.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We expect most users to keep their &lt;code&gt;-initcmd&lt;/code&gt; as &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/core/init&#34;&gt;init&lt;/a&gt;, but to supply their own uinit for additional initialization or to immediately load another operating system.&lt;/p&gt; &#xA;&lt;p&gt;All three command-line args accept both a u-root command name or a target symlink path. &lt;strong&gt;Only &lt;code&gt;-uinitcmd&lt;/code&gt; accepts command-line arguments, however.&lt;/strong&gt; For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;u-root -uinitcmd=&#34;echo Go Gopher&#34; ./cmds/core/{init,echo,elvish}&#xA;&#xA;cpio -ivt &amp;lt; /tmp/initramfs.linux_amd64.cpio&#xA;# ...&#xA;# lrwxrwxrwx   0 root     root           12 Dec 31  1969 bin/uinit -&amp;gt; ../bbin/echo&#xA;# lrwxrwxrwx   0 root     root            9 Dec 31  1969 init -&amp;gt; bbin/init&#xA;&#xA;qemu-system-x86_64 -kernel $KERNEL -initrd /tmp/initramfs.linux_amd64.cpio -nographic -append &#34;console=ttyS0&#34;&#xA;# ...&#xA;# [    0.848021] Freeing unused kernel memory: 896K&#xA;# 2020/05/01 04:04:39 Welcome to u-root!&#xA;#                              _&#xA;#   _   _      _ __ ___   ___ | |_&#xA;#  | | | |____| &#39;__/ _ \ / _ \| __|&#xA;#  | |_| |____| | | (_) | (_) | |_&#xA;#   \__,_|    |_|  \___/ \___/ \__|&#xA;#&#xA;# Go Gopher&#xA;# ~/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Passing command line arguments like above is equivalent to passing the arguments to uinit via a flags file in &lt;code&gt;/etc/uinit.flags&lt;/code&gt;, see &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/#extra-files&#34;&gt;Extra Files&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, you can pass arguments to uinit via the &lt;code&gt;uroot.uinitargs&lt;/code&gt; kernel parameters, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;u-root -uinitcmd=&#34;echo Gopher&#34; ./cmds/core/{init,echo,elvish}&#xA;&#xA;cpio -ivt &amp;lt; /tmp/initramfs.linux_amd64.cpio&#xA;# ...&#xA;# lrwxrwxrwx   0 root     root           12 Dec 31  1969 bin/uinit -&amp;gt; ../bbin/echo&#xA;# lrwxrwxrwx   0 root     root            9 Dec 31  1969 init -&amp;gt; bbin/init&#xA;&#xA;qemu-system-x86_64 -kernel $KERNEL -initrd /tmp/initramfs.linux_amd64.cpio -nographic -append &#34;console=ttyS0 uroot.uinitargs=Go&#34;&#xA;# ...&#xA;# [    0.848021] Freeing unused kernel memory: 896K&#xA;# 2020/05/01 04:04:39 Welcome to u-root!&#xA;#                              _&#xA;#   _   _      _ __ ___   ___ | |_&#xA;#  | | | |____| &#39;__/ _ \ / _ \| __|&#xA;#  | |_| |____| | | (_) | (_) | |_&#xA;#   \__,_|    |_|  \___/ \___/ \__|&#xA;#&#xA;# Go Gopher&#xA;# ~/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the order of the passed arguments in the above example.&lt;/p&gt; &#xA;&lt;p&gt;The command you name must be present in the command set. The following will &lt;em&gt;not work&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;u-root -uinitcmd=&#34;echo Go Gopher&#34; ./cmds/core/{init,elvish}&#xA;# 2020/04/30 21:05:57 could not create symlink from &#34;bin/uinit&#34; to &#34;echo&#34;: command or path &#34;echo&#34; not included in u-root build: specify -uinitcmd=&#34;&#34; to ignore this error and build without a uinit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also refer to non-u-root-commands; they will be added as symlinks. We don&#39;t presume to know whether your symlink target is correct or not.&lt;/p&gt; &#xA;&lt;p&gt;This will build, but not work unless you add a /bin/foobar to the initramfs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;u-root -uinitcmd=&#34;/bin/foobar Go Gopher&#34; ./cmds/core/{init,elvish}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will boot the same as the above.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;u-root -uinitcmd=&#34;/bin/foobar Go Gopher&#34; -files /bin/echo:bin/foobar ./cmds/core/{init,elvish}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will bypass the regular u-root init and just launch a shell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;u-root -initcmd=elvish ./cmds/core/{elvish,ls}&#xA;&#xA;cpio -ivt &amp;lt; /tmp/initramfs.linux_amd64.cpio&#xA;# ...&#xA;# lrwxrwxrwx   0 root     root            9 Dec 31  1969 init -&amp;gt; bbin/elvish&#xA;&#xA;qemu-system-x86_64 -kernel $KERNEL -initrd /tmp/initramfs.linux_amd64.cpio -nographic -append &#34;console=ttyS0&#34;&#xA;# ...&#xA;# [    0.848021] Freeing unused kernel memory: 896K&#xA;# failed to put myself in foreground: ioctl: inappropriate ioctl for device&#xA;# ~/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(It fails to do that because some initialization is missing when the shell is started without a proper init.)&lt;/p&gt; &#xA;&lt;h2&gt;Cross Compilation (targeting different architectures and OSes)&lt;/h2&gt; &#xA;&lt;p&gt;Cross-OS and -architecture compilation comes for free with Go. In fact, every PR to the u-root repo is built against the following architectures: amd64, x86 (i.e. 32bit), mipsle, armv7, arm64, and ppc64le.&lt;/p&gt; &#xA;&lt;p&gt;Further, we run integration tests on linux/amd64, freebsd/amd64 and linux/arm64, using several CI systems. If you need to add another CI system, processor or OS, please let us know.&lt;/p&gt; &#xA;&lt;p&gt;To cross compile for an ARM, on Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;GOARCH=arm u-root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are on OSX, and wish to build for Linux on AMD64:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;GOOS=linux GOARCH=amd64 u-root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing in QEMU&lt;/h2&gt; &#xA;&lt;p&gt;A good way to test the initramfs generated by u-root is with qemu:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;qemu-system-x86_64 -nographic -kernel path/to/kernel -initrd /tmp/initramfs.linux_amd64.cpio&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you do not have to build a special kernel on your own, it is sufficient to use an existing one. Usually you can find one in &lt;code&gt;/boot&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you quickly need to obtain a kernel, for example, when you are on a non-Linux system, you can assemble a URL to download one through Arch Linux&#39;s &lt;a href=&#34;https://www.archlinux.org/releng/netboot/archlinux.ipxe&#34;&gt;iPXE menu file&lt;/a&gt;. It would download from &lt;code&gt;${mirrorurl}iso/${release}/arch/boot/x86_64/vmlinuz-linux&lt;/code&gt;, so just search for a mirror URL you prefer and a release version, for example, &lt;code&gt;http://mirror.rackspace.com/archlinux/iso/2022.05.01/arch/boot/x86_64/vmlinuz-linux&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Framebuffer&lt;/h3&gt; &#xA;&lt;p&gt;For framebuffer support, append a VESA mode via the &lt;code&gt;vga&lt;/code&gt; kernel parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;qemu-system-x86_64 \&#xA;  -kernel path/to/kernel \&#xA;  -initrd /tmp/initramfs.linux_amd64.cpio \&#xA;  -append &#34;vga=786&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a list of modes, refer to the &lt;a href=&#34;https://github.com/torvalds/linux/raw/master/Documentation/fb/vesafb.rst#how-to-use-it&#34;&gt;Linux kernel documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Entropy / Random Number Generator&lt;/h3&gt; &#xA;&lt;p&gt;Some utilities, e.g., &lt;code&gt;dhclient&lt;/code&gt;, require entropy to be present. For a speedy virtualized random number generator, the kernel should have the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;CONFIG_VIRTIO_PCI=y&#xA;CONFIG_HW_RANDOM_VIRTIO=y&#xA;CONFIG_CRYPTO_DEV_VIRTIO=y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can run your kernel in QEMU with a &lt;code&gt;virtio-rng-pci&lt;/code&gt; device:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;qemu-system-x86_64 \&#xA;    -device virtio-rng-pci \&#xA;    -kernel vmlinuz \&#xA;    -initrd /tmp/initramfs.linux_amd64.cpio&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, you can pass your host&#39;s RNG:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;qemu-system-x86_64 \&#xA;    -object rng-random,filename=/dev/urandom,id=rng0 \&#xA;    -device virtio-rng-pci,rng=rng0 \&#xA;    -kernel vmlinuz \&#xA;    -initrd /tmp/initramfs.linux_amd64.cpio&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;u-root with Go package paths&lt;/h2&gt; &#xA;&lt;p&gt;For Go package paths to be usable, the path passed to &lt;code&gt;u-root&lt;/code&gt; must be in the go.mod of the working directory or one of its parents. This is mostly useful for repositories making programmatic use of u-root&#39;s APIs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd ./u-root&#xA;&#xA;# In u-root&#39;s directory itself, github.com/u-root/u-root is resolvable. There is&#xA;# a go.mod here that can refer to u-root.&#xA;u-root github.com/u-root/u-root/cmds/core/...&#xA;u-root github.com/u-root/u-root/cmds/core/*&#xA;u-root github.com/u-root/u-root/cmds/core/i*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To depend on commands outside of ones own repository, the easiest way to depend on Go commands is the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;TMPDIR=$(mktemp -d)&#xA;cd $TMPDIR&#xA;go mod init foobar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a file with some unused build tag like this to create dependencies on commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//go:build tools&#xA;&#xA;package something&#xA;&#xA;import (&#xA;        &#34;github.com/u-root/u-root/cmds/core/ip&#34;&#xA;        &#34;github.com/u-root/u-root/cmds/core/init&#34;&#xA;        &#34;github.com/hugelgupf/p9/cmd/p9ufs&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The unused build tag keeps it from being compiled, but its existence forces &lt;code&gt;go mod tidy&lt;/code&gt; to add these dependencies to &lt;code&gt;go.mod&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go mod tidy&#xA;&#xA;u-root \&#xA;  github.com/u-root/u-root/cmds/core/ip \&#xA;  github.com/u-root/u-root/cmds/core/init \&#xA;  github.com/hugelgupf/p9/cmd/p9ufs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;SystemBoot&lt;/h2&gt; &#xA;&lt;p&gt;SystemBoot is a set of bootloaders written in Go. It is meant to be a distribution for LinuxBoot to create a system firmware + bootloader. All of these use &lt;code&gt;kexec&lt;/code&gt; to boot. The commands are in &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/cmds/boot&#34;&gt;cmds/boot&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;pxeboot&lt;/code&gt;: a network boot client that uses DHCP and HTTP or TFTP to get a boot configuration which can be parsed as PXELinux or iPXE configuration files to get a boot program.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;boot&lt;/code&gt;: finds all bootable kernels on local disk, shows a menu, and boots them. Supports (basic) GRUB, (basic) syslinux, (non-EFI) BootLoaderSpec, and ESXi configurations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;fbnetboot&lt;/code&gt;: a network boot client that uses DHCP and HTTP to get a boot program based on Linux, and boots it. To be merged with &lt;code&gt;pxeboot&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;localboot&lt;/code&gt;: a tool that finds bootable kernel configurations on the local disks and boots them.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;systemboot&lt;/code&gt;: a wrapper around &lt;code&gt;fbnetboot&lt;/code&gt; and &lt;code&gt;localboot&lt;/code&gt; that just mimicks a BIOS/UEFI BDS behaviour, by looping between network booting and local booting. Use &lt;code&gt;-uinitcmd&lt;/code&gt; argument to the u-root build tool to make it the boot program.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This project started as a loose collection of programs in u-root by various LinuxBoot contributors, as well as a personal experiment by &lt;a href=&#34;https://github.com/insomniacslk&#34;&gt;Andrea Barberio&lt;/a&gt; that has since been merged in. It is now an effort of a broader community and graduated to a real project for system firmwares.&lt;/p&gt; &#xA;&lt;p&gt;More detailed information about the build process for a full LinuxBoot firmware image using u-root/systemboot and coreboot can be found in the &lt;a href=&#34;https://github.com/linuxboot/book&#34;&gt;LinuxBoot book&lt;/a&gt; chapter about &lt;a href=&#34;https://github.com/linuxboot/book/raw/master/coreboot.u-root.systemboot/README.md&#34;&gt;LinuxBoot using coreboot, u-root and systemboot&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can build systemboot like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;u-root -uinitcmd=systemboot core ./cmds/boot/{systemboot,localboot,fbnetboot}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compression&lt;/h2&gt; &#xA;&lt;p&gt;You can compress the initramfs. However, for xz compression, the kernel has some restrictions on the compression options and it is suggested to align the file to 512 byte boundaries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;xz --check=crc32 -9 --lzma2=dict=1MiB \&#xA;   --stdout /tmp/initramfs.linux_amd64.cpio \&#xA;   | dd conv=sync bs=512 \&#xA;   of=/tmp/initramfs.linux_amd64.cpio.xz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Packages of TinyCore&lt;/h2&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;tcz&lt;/code&gt; command included in u-root, you can install tinycore linux packages for things you want.&lt;/p&gt; &#xA;&lt;p&gt;You can use QEMU NAT to allow you to fetch packages. Let&#39;s suppose, for example, you want bash. Once u-root is running, you can do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;% tcz bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tcz command computes and fetches all dependencies. If you can&#39;t get to tinycorelinux.net, or you want package fetching to be faster, you can run your own server for tinycore packages.&lt;/p&gt; &#xA;&lt;p&gt;You can do this to get a local server using the u-root srvfiles command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;% srvfiles -p 80 -d path-to-local-tinycore-packages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course you have to fetch all those packages first somehow :-)&lt;/p&gt; &#xA;&lt;h2&gt;Build an Embeddable U-root&lt;/h2&gt; &#xA;&lt;p&gt;You can build this environment into a kernel as an initramfs, and further embed that into firmware as a coreboot payload.&lt;/p&gt; &#xA;&lt;p&gt;In the kernel and coreboot case, you need to configure ethernet. We have a &lt;code&gt;dhclient&lt;/code&gt; command that works for both ipv4 and ipv6. Since v6 does not yet work that well for most people, a typical invocation looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;% dhclient -ipv4 -ipv6=false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, on newer linux kernels (&amp;gt; 4.x) boot with ip=dhcp in the command line, assuming your kernel is configured to work that way.&lt;/p&gt; &#xA;&lt;h2&gt;Build Modes&lt;/h2&gt; &#xA;&lt;p&gt;u-root can create an initramfs in two different modes, specified by &lt;code&gt;-build&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;bb&lt;/code&gt;/&lt;code&gt;gbb&lt;/code&gt; mode: One busybox-like binary comprising all the Go tools you ask to include. See &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/pkg/bb/README.md&#34;&gt;here for how it works&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;In this mode, u-root copies and rewrites the source of the tools you asked to include to be able to compile everything into one busybox-like binary.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;binary&lt;/code&gt; mode: each specified binary is compiled separately and all binaries are added to the initramfs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Updating Dependencies&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get -u&#xA;go mod tidy&#xA;go mod vendor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building without network access&lt;/h2&gt; &#xA;&lt;p&gt;Go modules require network access. If you need to make a repeatable build with no network access, make sure that your code is under &lt;code&gt;$GOPATH&lt;/code&gt; and the environment variable &lt;code&gt;GO111MODULE&lt;/code&gt; is set to &lt;code&gt;off&lt;/code&gt;. This is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Pick a location for your off-network build, it can be anywhere and the directory does not need to exist ahead of time:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOPATH=$(mktemp -d)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Fetch the code, you can use &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;go get&lt;/code&gt; or even a release file, just make sure that the code ends in: &lt;code&gt;${GOPATH}/src/github.com/u-root/u-root&lt;/code&gt; E.g:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p ${GOPATH}/src/github.com/u-root/&#xA;cd ${GOPATH}/src/github.com/u-root/&#xA;git clone https://github.com/u-root/u-root.git&#xA;cd u-root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or simply:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;GO111MODULE=off go get github.com/u-root/u-root&#xA;cd $GOPATH/src/github.com/u-root/u-root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Build u-root and use it normally:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;GO111MODULE=off GOPROXY=off go build&#xA;GO111MODULE=off GOPROXY=off ./u-root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Hardware&lt;/h1&gt; &#xA;&lt;p&gt;If you want to see u-root on real hardware, this &lt;a href=&#34;https://www.pcengines.ch/apu2.htm&#34;&gt;board&lt;/a&gt; is a good start.&lt;/p&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;For information about contributing, including how we sign off commits, please see &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Improving existing commands (e.g., additional currently unsupported flags) is very welcome. In this case it is not even required to build an initramfs, just enter the &lt;code&gt;cmds/&lt;/code&gt; directory and start coding. A list of commands that are on the roadmap can be found &lt;a href=&#34;https://raw.githubusercontent.com/u-root/u-root/main/roadmap.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>