<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-21T01:29:11Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bootun/veronica</title>
    <updated>2023-08-21T01:29:11Z</updated>
    <id>tag:github.com,2023-08-21:/bootun/veronica</id>
    <link href="https://github.com/bootun/veronica" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Goé¡¹ç›®å·®å¼‚æ„å»ºå·¥å…·&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Veronica&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;Veronica&lt;/code&gt; çš„ç›®æ ‡æ˜¯æˆä¸º&lt;strong&gt;Goé¡¹ç›®&lt;/strong&gt;çš„å·®å¼‚åŒ–æ„å»ºæŒ‡å¯¼å·¥å…·ã€‚è¯•æƒ³ä¸€ä¸‹ï¼Œå¦‚æœä½ çš„é¡¹ç›®åˆ†ä¸ºè®¸å¤šå¾®æœåŠ¡ï¼Œè€Œè¿™ä¸ªé¡¹ç›®æ˜¯ä»¥&lt;a href=&#34;https://en.wikipedia.org/wiki/Monorepo&#34;&gt;Monorepo&lt;/a&gt;çš„å½¢å¼ç»„ç»‡çš„ï¼Œé‚£ä¹ˆæ¯æ¬¡æ„å»ºæ—¶ï¼Œå› ä¸ºæ— æ³•çŸ¥é“ä¿®æ”¹çš„æ–‡ä»¶ä¼šå½±å“å“ªäº›æœåŠ¡ï¼Œå› æ­¤å¿…é¡»è¦æ„å»ºæ‰€æœ‰çš„æœåŠ¡ã€‚&lt;code&gt;Veronica&lt;/code&gt; å°±æ˜¯ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜è€Œè¯ç”Ÿçš„ï¼Œç»™å®šä¸€ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶ï¼Œ&lt;code&gt;Veronica&lt;/code&gt; ä¼šå¸®æ‚¨åˆ†æé¡¹ç›®çš„ä¾èµ–, å¹¶å‘ŠçŸ¥æ‚¨è¯¥æ–‡ä»¶å¯èƒ½ä¼šäº§ç”Ÿå“ªäº›å½±å“ã€‚&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;ğŸš§&lt;/span&gt; æœ¬é¡¹ç›®ä»å¤„äºæ—©æœŸé˜¶æ®µï¼Œ å¯èƒ½ä¼šç»å¸¸å˜åŠ¨&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;å‰ç½®æ¡ä»¶&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Git&lt;/li&gt; &#xA; &lt;li&gt;é¡¹ç›®ä½¿ç”¨go module&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ç”¨æ³•&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;å®‰è£…veronica&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install github.com/bootun/veronica@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;åœ¨é¡¹ç›®çš„æ ¹ç›®å½•æ”¾ç½®&lt;a href=&#34;https://raw.githubusercontent.com/bootun/veronica/master/veronica_example.yaml&#34;&gt;veronica.yaml&lt;/a&gt;æ–‡ä»¶&lt;/li&gt; &#xA; &lt;li&gt;åˆ‡æ¢è‡³é¡¹ç›®ç›®å½•ï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç :&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git log --name-only -1 --pretty=format:&#34;&#34; | veronica&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;è¯¦ç»†è¾“å‡ºæ•ˆæœ:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;pre&gt;&#xA;æ”¹åŠ¨äº† pkg/apigateway/spec åŒ…ä¸­çš„ pkg/apigateway/spec/api.swagger.json æ–‡ä»¶,å¯èƒ½ä¼šå½±å“è¿™äº›åŒ…çš„æ„å»º:&#xA;    - cmd/api-gateway&#xA;æ”¹åŠ¨äº† pkg/apigateway/spec åŒ…ä¸­çš„ pkg/apigateway/spec/static.go æ–‡ä»¶,å¯èƒ½ä¼šå½±å“è¿™äº›åŒ…çš„æ„å»º:&#xA;    - cmd/api-gateway&#xA;&lt;p&gt;æ”¹åŠ¨äº† pkg/pb åŒ…ä¸­çš„ pkg/pb/merchant_assets.pb.go æ–‡ä»¶,å¯èƒ½ä¼šå½±å“è¿™äº›åŒ…çš„æ„å»º:&#xA;- cmd/api-gateway&#xA;- cmd/assets-cron&#xA;- cmd/currency-cron&#xA;- cmd/iam-cron&#xA;- cmd/iam-manager&#xA;- cmd/across-cron&#xA;- cmd/assets-manager&#xA;- cmd/currency-manager&#xA;- cmd/system-cron&#xA;- cmd/system-manager&#xA;- cmd/across-manager&lt;/p&gt;&#xA;&lt;p&gt;æ”¹åŠ¨äº† pkg/pb åŒ…ä¸­çš„ pkg/pb/merchant_assets.pb.gw.go æ–‡ä»¶,å¯èƒ½ä¼šå½±å“è¿™äº›åŒ…çš„æ„å»º:&#xA;- cmd/api-gateway&#xA;- cmd/assets-cron&#xA;- cmd/currency-cron&#xA;- cmd/iam-cron&#xA;- cmd/iam-manager&#xA;- cmd/across-cron&#xA;- cmd/assets-manager&#xA;- cmd/currency-manager&#xA;- cmd/system-cron&#xA;- cmd/system-manager&#xA;- cmd/across-manager&lt;/p&gt;&#xA;&lt;p&gt;æ”¹åŠ¨äº† pkg/service/assets åŒ…ä¸­çš„ pkg/service/assets/handler_merchant_assets.go æ–‡ä»¶,å¯èƒ½ä¼šå½±å“è¿™äº›åŒ…çš„æ„å»º:&#xA;- cmd/assets-manager&#xA;&lt;/p&gt;&lt;/pre&gt;&#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;strong&gt;ç®€ç•¥è¾“å‡ºæ•ˆæœï¼š&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;pre&gt;&#xA;cmd/api-gateway&#xA;cmd/across-cron&#xA;cmd/currency-cron&#xA;cmd/iam-manager&#xA;cmd/system-cron&#xA;cmd/system-manager&#xA;cmd/across-manager&#xA;cmd/assets-cron&#xA;cmd/assets-manager&#xA;cmd/currency-manager&#xA;cmd/iam-cron&#xA;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;åœ¨0.0.2ç‰ˆæœ¬ä¹‹åï¼Œé»˜è®¤è¾“å‡ºç²¾ç®€æ¨¡å¼ï¼Œæƒ³è¦è·å–è¯¦ç»†è¾“å‡ºï¼Œéœ€è¦åœ¨&lt;code&gt;veronica.go&lt;/code&gt;ä¸­è°ƒç”¨&lt;code&gt;project.ReportImpact()&lt;/code&gt;å¹¶è‡ªè¡Œç¼–è¯‘ã€‚ç›®å‰æˆ‘æ­£åœ¨ç§¯ææ¢ç´¢æ›´åŠ çµæ´»çš„è¾“å‡ºæ–¹å¼ã€‚&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;å·²å®ç°åŠŸèƒ½&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;è§£ææ‰€æœ‰æ–‡ä»¶/ç›®å½•ä¹‹é—´çš„ä¾èµ–å…³ç³»&lt;/li&gt; &#xA; &lt;li&gt;æŠ¥å‘Šå¯èƒ½å½±å“æ„å»ºçš„åŒ…&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;å‘½åèƒŒæ™¯&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Veronica&lt;/code&gt;å–è‡ªé’¢é“ä¾ çš„åŒåå¤–å¤ªç©ºæ”¯æ´ç³»ç»Ÿï¼Œåœ¨ä½ éœ€è¦å‡çº§æˆ˜ç”²æ—¶ï¼Œåªéœ€è¦é€šçŸ¥ç»´ç½—å¦®å¡ï¼Œå®ƒå°±ä¼šå°†æˆ˜ç”²çš„æ¨¡å—ä»å¤–å¤ªç©ºå‘é€ç»™ä½ ï¼Œé‡æ–°ç»„åˆåå®Œæˆå‡çº§ã€‚&lt;/p&gt; &#xA;&lt;h2&gt;æœªæ¥è§„åˆ’&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;åˆ†æé¡¹ç›®å®Œæ•´çš„ASTï¼Œå°†veronicaçš„ç²’åº¦æ§åˆ¶åœ¨&lt;a href=&#34;https://github.com/bootun/veronica/issues/11&#34;&gt;æºç çº§åˆ«&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ç›¸å…³é˜…è¯»&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/XQqDyJyh1u6jU0PmUdS0LA&#34;&gt;åŸºäºå¤§ä»“åº“çš„å¾®æœåŠ¡å·®å¼‚åŒ–æ„å»ºå·¥å…·&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>IBM/fp-go</title>
    <updated>2023-08-21T01:29:11Z</updated>
    <id>tag:github.com,2023-08-21:/IBM/fp-go</id>
    <link href="https://github.com/IBM/fp-go" rel="alternate"></link>
    <summary type="html">&lt;p&gt;functional programming library for golang&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Functional programming library for golang&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;ğŸš§ Work in progress! ğŸš§&lt;/strong&gt; Despite major version 1 because of &lt;a href=&#34;https://github.com/semantic-release/semantic-release/issues/1507&#34;&gt;https://github.com/semantic-release/semantic-release/issues/1507&lt;/a&gt;. Trying to not make breaking changes, but devil is in the details.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IBM/fp-go/main/resources/images/logo.png&#34; alt=&#34;logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This library is strongly influenced by the awesome &lt;a href=&#34;https://github.com/gcanti/fp-ts&#34;&gt;fp-ts&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get github.com/IBM/fp-go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refer to the &lt;a href=&#34;https://raw.githubusercontent.com/IBM/fp-go/main/samples/&#34;&gt;samples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Design Goal&lt;/h2&gt; &#xA;&lt;p&gt;This library aims to provide a set of data types and functions that make it easy and fun to write maintainable and testable code in golang. It encourages the following patterns:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;write many small, testable and pure functions, i.e. functions that produce output only depending on their input and that do not execute side effects&lt;/li&gt; &#xA; &lt;li&gt;offer helpers to isolate side effects into lazily executed functions (IO)&lt;/li&gt; &#xA; &lt;li&gt;expose a consistent set of composition to create new functions from existing ones &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;for each data type there exists a small set of composition functions&lt;/li&gt; &#xA;   &lt;li&gt;these functions are called the same across all data types, so you only have to learn a small number of function names&lt;/li&gt; &#xA;   &lt;li&gt;the semantic of functions of the same name is consistent across all data types&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How does this play with the &lt;a href=&#34;https://the-zen-of-go.netlify.app/&#34;&gt;ğŸ§˜ğŸ½ Zen Of Go&lt;/a&gt;?&lt;/h3&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Each package fulfils a single purpose&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ Each of the top level packages (e.g. Option, Either, ReaderIOEither, ...) fulfils the purpose of defining the respective data type and implementing the set of common operations for this data type.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Handle errors explicitly&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ The library makes a clear distinction between that operations that cannot fail by design and operations that can fail. Failure is represented via the &lt;code&gt;Either&lt;/code&gt; type and errors are handled explicitly by using &lt;code&gt;Either&lt;/code&gt;&#39;s monadic set of operations.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Return early rather than nesting deeply&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ We recommend to implement simple, small functions that implement one feature and that would typically not invoke other functions. Interaction with other functions is done by function composition and the composition makes sure to run one function after the other. In the error case the &lt;code&gt;Either&lt;/code&gt; monad makes sure to skip the error path.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Leave concurrency to the caller&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ All pure are synchronous by default. The I/O operations are asynchronous per default.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Before you launch a goroutine, know when it will stop&lt;/h4&gt; &#xA;&lt;p&gt;ğŸ¤·ğŸ½ This is left to the user of the library since the library itself will not start goroutines on its own. The Task monad offers support for cancellation via the golang context, though.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Avoid package level state&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ No package level state anywhere, this would be a significant anti-pattern&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Simplicity matters&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ The library is simple in the sense that it offers a small, consistent interface to a variety of data types. Users can concentrate on implementing business logic rather than dealing with low level data structures.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Write tests to lock in the behaviour of your packageâ€™s API&lt;/h4&gt; &#xA;&lt;p&gt;ğŸŸ¡ The programming pattern suggested by this library encourages writing test cases. The library itself also has a growing number of tests, but not enough, yet. TBD&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ If you think itâ€™s slow, first prove it with a benchmark&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ Absolutely. If you think the function composition offered by this library is too slow, please provide a benchmark.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Moderation is a virtue&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ The library does not implement its own goroutines and also does not require any expensive synchronization primitives. Coordination of IO operations is implemented via atomic counters without additional primitives.&lt;/p&gt; &#xA;&lt;h4&gt;ğŸ§˜ğŸ½ Maintainability counts&lt;/h4&gt; &#xA;&lt;p&gt;âœ”ï¸ Code that consumes this library is easy to maintain because of the small and concise set of operations exposed. Also the suggested programming paradigm to decompose an application into small functions increases maintainability, because these functions are easy to understand and if they are pure, it&#39;s often sufficient to look at the type signature to understand the purpose.&lt;/p&gt; &#xA;&lt;p&gt;The library itself also comprises many small functions, but it&#39;s admittedly harder to maintain than code that uses it. However this asymmetry is intended because it offloads complexity from users into a central component.&lt;/p&gt; &#xA;&lt;h2&gt;Comparation to Idiomatic Go&lt;/h2&gt; &#xA;&lt;p&gt;In this section we discuss how the functional APIs differ from idiomatic go function signatures and how to convert back and forth.&lt;/p&gt; &#xA;&lt;h3&gt;Pure functions&lt;/h3&gt; &#xA;&lt;p&gt;Pure functions are functions that take input parameters and that compute an output without changing any global state and without mutating the input parameters. They will always return the same output for the same input.&lt;/p&gt; &#xA;&lt;h4&gt;Without Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your pure function does not return an error, the idiomatic signature is just fine and no changes are required.&lt;/p&gt; &#xA;&lt;h4&gt;With Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your pure function can return an error, then it will have a &lt;code&gt;(T, error)&lt;/code&gt; return value in idiomatic go. In functional style the return value is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/either&#34;&gt;Either[error, T]&lt;/a&gt; because function composition is easier with such a return type. Use the &lt;code&gt;EitherizeXXX&lt;/code&gt; methods in &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/either&#34;&gt;&#34;github.com/IBM/fp-go/either&#34;&lt;/a&gt; to convert from idiomatic to functional style and &lt;code&gt;UneitherizeXXX&lt;/code&gt; to convert from functional to idiomatic style.&lt;/p&gt; &#xA;&lt;h3&gt;Effectful functions&lt;/h3&gt; &#xA;&lt;p&gt;An effectful function (or function with a side effect) is one that changes data outside the scope of the function or that does not always produce the same output for the same input (because it depends on some external, mutable state). There is no special way in idiomatic go to identify such a function other than documentation. In functional style we represent them as functions that do not take an input but that produce an output. The base type for these functions is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/io&#34;&gt;IO[T]&lt;/a&gt; because in many cases such functions represent &lt;code&gt;I/O&lt;/code&gt; operations.&lt;/p&gt; &#xA;&lt;h4&gt;Without Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your effectful function does not return an error, the functional signature is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/io&#34;&gt;IO[T]&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;With Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your effectful function can return an error, the functional signature is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/ioeither&#34;&gt;IOEither[error, T]&lt;/a&gt;. Use &lt;code&gt;EitherizeXXX&lt;/code&gt; from &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/ioeither&#34;&gt;&#34;github.com/IBM/fp-go/ioeither&#34;&lt;/a&gt; to convert an idiomatic go function to functional style.&lt;/p&gt; &#xA;&lt;h3&gt;Go Context&lt;/h3&gt; &#xA;&lt;p&gt;Functions that take a &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; are per definition effectful because they depend on the context parameter that is designed to be mutable (it can e.g. be used to cancel a running operation). Furthermore in idiomatic go the parameter is typically passed as the first parameter to a function.&lt;/p&gt; &#xA;&lt;p&gt;In functional style we isolate the &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; and represent the nature of the effectful function as an &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/ioeither&#34;&gt;IOEither[error, T]&lt;/a&gt;. The resulting type is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/context/readerioeither&#34;&gt;ReaderIOEither[T]&lt;/a&gt;, a function taking a &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; that returns a function without parameters returning an &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/either&#34;&gt;Either[error, T]&lt;/a&gt;. Use the &lt;code&gt;EitherizeXXX&lt;/code&gt; methods from &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/context/readerioeither&#34;&gt;&#34;github.com/IBM/fp-go/context/readerioeither&#34;&lt;/a&gt; to convert an idiomatic go function with a &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; to functional style.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Notes&lt;/h2&gt; &#xA;&lt;h3&gt;Generics&lt;/h3&gt; &#xA;&lt;p&gt;All monadic operations are implemented via generics, i.e. they offer a type safe way to compose operations. This allows for convenient IDE support and also gives confidence about the correctness of the composition at compile time.&lt;/p&gt; &#xA;&lt;p&gt;Downside is that this will result in different versions of each operation per type, these versions are generated by the golang compiler at build time (unlike type erasure in languages such as Java of TypeScript). This might lead to large binaries for codebases with many different types. If this is a concern, you can always implement type erasure on top, i.e. use the monadic operations with the &lt;code&gt;any&lt;/code&gt; type as if generics were not supported. You loose type safety, but this might result in smaller binaries.&lt;/p&gt; &#xA;&lt;h3&gt;Ordering of Generic Type Parameters&lt;/h3&gt; &#xA;&lt;p&gt;In go we need to specify all type parameters of a function on the global function definition, even if the function returns a higher order function and some of the type parameters are only applicable to the higher order function. So the following is not possible:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[A, B any](f func(A) B) [R, E any]func(fa ReaderIOEither[R, E, A]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the parameters &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are not needed by the first level of &lt;code&gt;Map&lt;/code&gt; but only by the resulting higher order function. Instead we need to specify the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[R, E, A, B any](f func(A) B) func(fa ReaderIOEither[R, E, A]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which overspecifies &lt;code&gt;Map&lt;/code&gt; on the global scope. As a result the go compiler will not be able to auto-detect these parameters, it can only auto detect &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; since they appear in the argument of &lt;code&gt;Map&lt;/code&gt;. We need to explicitly pass values for these type parameters when &lt;code&gt;Map&lt;/code&gt; is being used.&lt;/p&gt; &#xA;&lt;p&gt;Because of this limitation the order of parameters on a function matters. We want to make sure that we define those parameters that cannot be auto-detected, first, and the parameters that can be auto-detected, last. This can lead to inconsistencies in parameter ordering, but we believe that the gain in convenience is worth it. The parameter order of &lt;code&gt;Ap&lt;/code&gt; is e.g. different from that of &lt;code&gt;Map&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Ap[B, R, E, A any](fa ReaderIOEither[R, E, A]) func(fab ReaderIOEither[R, E, func(A) B]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;because &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; can be determined from the argument to &lt;code&gt;Ap&lt;/code&gt; but &lt;code&gt;B&lt;/code&gt; cannot.&lt;/p&gt; &#xA;&lt;h3&gt;Use of the &lt;a href=&#34;https://go.googlesource.com/proposal/+/master/design/47781-parameterized-go-ast.md&#34;&gt;~ Operator&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The FP library attempts to be easy to consume and one aspect of this is the definition of higher level type definitions instead of having to use their low level equivalent. It is e.g. more convenient and readable to use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ReaderIOEither[R, E, A]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;than&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func(R) func() Either.Either[E, A]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;although both are logically equivalent. At the time of this writing the go type system does not support generic type aliases, only generic type definition, i.e. it is not possible to write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReaderIOEither[R, E, A any] = RD.Reader[R, IOE.IOEither[E, A]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;only&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReaderIOEither[R, E, A any] RD.Reader[R, IOE.IOEither[E, A]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This makes a big difference, because in the second case the type &lt;code&gt;ReaderIOEither[R, E, A any]&lt;/code&gt; is considered a completely new type, not compatible to its right hand side, so it&#39;s not just a shortcut but a fully new type.&lt;/p&gt; &#xA;&lt;p&gt;From the implementation perspective however there is no reason to restrict the implementation to the new type, it can be generic for all compatible types. The way to express this in go is the &lt;a href=&#34;https://go.googlesource.com/proposal/+/master/design/47781-parameterized-go-ast.md&#34;&gt;~&lt;/a&gt; operator. This comes with some quite complicated type declarations in some cases, which undermines the goal of the library to be easy to use.&lt;/p&gt; &#xA;&lt;p&gt;For that reason there exist sub-packages called &lt;code&gt;Generic&lt;/code&gt; for all higher level types. These packages contain the fully generic implementation of the operations, preferring abstraction over usability. These packages are not meant to be used by end-users but are meant to be used by library extensions. The implementation for the convenient higher level types specializes the generic implementation for the particular higher level type, i.e. this layer does not contain any business logic but only &lt;em&gt;type magic&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Higher Kinded Types&lt;/h3&gt; &#xA;&lt;p&gt;Go does not support higher kinded types (HKT). Such types occur if a generic type itself is parametrized by another generic type. Example:&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Map&lt;/code&gt; operation for &lt;code&gt;ReaderIOEither&lt;/code&gt; is defined as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[R, E, A, B any](f func(A) B) func(fa ReaderIOEither[R, E, A]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and in fact the equivalent operations for all other mondas follow the same pattern, we could try to introduce a new type for &lt;code&gt;ReaderIOEither&lt;/code&gt; (without a parameter) as a HKT, e.g. like so (made-up syntax, does not work in go):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[HKT, R, E, A, B any](f func(A) B) func(HKT[R, E, A]) HKT[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this would be the completely generic method signature for all possible monads. In particular in many cases it is possible to compose functions independent of the concrete knowledge of the actual &lt;code&gt;HKT&lt;/code&gt;. From the perspective of a library this is the ideal situation because then a particular algorithm only has to be implemented and tested once.&lt;/p&gt; &#xA;&lt;p&gt;This FP library addresses this by introducing the HKTs as individual types, e.g. &lt;code&gt;HKT[A]&lt;/code&gt; would be represented as a new generic type &lt;code&gt;HKTA&lt;/code&gt;. This loses the correlation to the type &lt;code&gt;A&lt;/code&gt; but allows to implement generic algorithms, at the price of readability.&lt;/p&gt; &#xA;&lt;p&gt;For that reason these implementations are kept in the &lt;code&gt;internal&lt;/code&gt; package. These are meant to be used by the library itself or by extensions, not by end users.&lt;/p&gt;</summary>
  </entry>
</feed>