<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-21T01:29:11Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bootun/veronica</title>
    <updated>2023-08-21T01:29:11Z</updated>
    <id>tag:github.com,2023-08-21:/bootun/veronica</id>
    <link href="https://github.com/bootun/veronica" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Go项目差异构建工具&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Veronica&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;Veronica&lt;/code&gt; 的目标是成为&lt;strong&gt;Go项目&lt;/strong&gt;的差异化构建指导工具。试想一下，如果你的项目分为许多微服务，而这个项目是以&lt;a href=&#34;https://en.wikipedia.org/wiki/Monorepo&#34;&gt;Monorepo&lt;/a&gt;的形式组织的，那么每次构建时，因为无法知道修改的文件会影响哪些服务，因此必须要构建所有的服务。&lt;code&gt;Veronica&lt;/code&gt; 就是为了解决这一问题而诞生的，给定一个或多个文件，&lt;code&gt;Veronica&lt;/code&gt; 会帮您分析项目的依赖, 并告知您该文件可能会产生哪些影响。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;🚧&lt;/span&gt; 本项目仍处于早期阶段， 可能会经常变动&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;前置条件&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Git&lt;/li&gt; &#xA; &lt;li&gt;项目使用go module&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;用法&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;安装veronica&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install github.com/bootun/veronica@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;在项目的根目录放置&lt;a href=&#34;https://raw.githubusercontent.com/bootun/veronica/master/veronica_example.yaml&#34;&gt;veronica.yaml&lt;/a&gt;文件&lt;/li&gt; &#xA; &lt;li&gt;切换至项目目录，输入以下代码:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git log --name-only -1 --pretty=format:&#34;&#34; | veronica&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;详细输出效果:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;pre&gt;&#xA;改动了 pkg/apigateway/spec 包中的 pkg/apigateway/spec/api.swagger.json 文件,可能会影响这些包的构建:&#xA;    - cmd/api-gateway&#xA;改动了 pkg/apigateway/spec 包中的 pkg/apigateway/spec/static.go 文件,可能会影响这些包的构建:&#xA;    - cmd/api-gateway&#xA;&lt;p&gt;改动了 pkg/pb 包中的 pkg/pb/merchant_assets.pb.go 文件,可能会影响这些包的构建:&#xA;- cmd/api-gateway&#xA;- cmd/assets-cron&#xA;- cmd/currency-cron&#xA;- cmd/iam-cron&#xA;- cmd/iam-manager&#xA;- cmd/across-cron&#xA;- cmd/assets-manager&#xA;- cmd/currency-manager&#xA;- cmd/system-cron&#xA;- cmd/system-manager&#xA;- cmd/across-manager&lt;/p&gt;&#xA;&lt;p&gt;改动了 pkg/pb 包中的 pkg/pb/merchant_assets.pb.gw.go 文件,可能会影响这些包的构建:&#xA;- cmd/api-gateway&#xA;- cmd/assets-cron&#xA;- cmd/currency-cron&#xA;- cmd/iam-cron&#xA;- cmd/iam-manager&#xA;- cmd/across-cron&#xA;- cmd/assets-manager&#xA;- cmd/currency-manager&#xA;- cmd/system-cron&#xA;- cmd/system-manager&#xA;- cmd/across-manager&lt;/p&gt;&#xA;&lt;p&gt;改动了 pkg/service/assets 包中的 pkg/service/assets/handler_merchant_assets.go 文件,可能会影响这些包的构建:&#xA;- cmd/assets-manager&#xA;&lt;/p&gt;&lt;/pre&gt;&#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;strong&gt;简略输出效果：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;pre&gt;&#xA;cmd/api-gateway&#xA;cmd/across-cron&#xA;cmd/currency-cron&#xA;cmd/iam-manager&#xA;cmd/system-cron&#xA;cmd/system-manager&#xA;cmd/across-manager&#xA;cmd/assets-cron&#xA;cmd/assets-manager&#xA;cmd/currency-manager&#xA;cmd/iam-cron&#xA;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;在0.0.2版本之后，默认输出精简模式，想要获取详细输出，需要在&lt;code&gt;veronica.go&lt;/code&gt;中调用&lt;code&gt;project.ReportImpact()&lt;/code&gt;并自行编译。目前我正在积极探索更加灵活的输出方式。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;已实现功能&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;解析所有文件/目录之间的依赖关系&lt;/li&gt; &#xA; &lt;li&gt;报告可能影响构建的包&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;命名背景&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Veronica&lt;/code&gt;取自钢铁侠的同名外太空支援系统，在你需要升级战甲时，只需要通知维罗妮卡，它就会将战甲的模块从外太空发送给你，重新组合后完成升级。&lt;/p&gt; &#xA;&lt;h2&gt;未来规划&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;分析项目完整的AST，将veronica的粒度控制在&lt;a href=&#34;https://github.com/bootun/veronica/issues/11&#34;&gt;源码级别&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;相关阅读&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/XQqDyJyh1u6jU0PmUdS0LA&#34;&gt;基于大仓库的微服务差异化构建工具&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>IBM/fp-go</title>
    <updated>2023-08-21T01:29:11Z</updated>
    <id>tag:github.com,2023-08-21:/IBM/fp-go</id>
    <link href="https://github.com/IBM/fp-go" rel="alternate"></link>
    <summary type="html">&lt;p&gt;functional programming library for golang&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Functional programming library for golang&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;🚧 Work in progress! 🚧&lt;/strong&gt; Despite major version 1 because of &lt;a href=&#34;https://github.com/semantic-release/semantic-release/issues/1507&#34;&gt;https://github.com/semantic-release/semantic-release/issues/1507&lt;/a&gt;. Trying to not make breaking changes, but devil is in the details.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IBM/fp-go/main/resources/images/logo.png&#34; alt=&#34;logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This library is strongly influenced by the awesome &lt;a href=&#34;https://github.com/gcanti/fp-ts&#34;&gt;fp-ts&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get github.com/IBM/fp-go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refer to the &lt;a href=&#34;https://raw.githubusercontent.com/IBM/fp-go/main/samples/&#34;&gt;samples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Design Goal&lt;/h2&gt; &#xA;&lt;p&gt;This library aims to provide a set of data types and functions that make it easy and fun to write maintainable and testable code in golang. It encourages the following patterns:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;write many small, testable and pure functions, i.e. functions that produce output only depending on their input and that do not execute side effects&lt;/li&gt; &#xA; &lt;li&gt;offer helpers to isolate side effects into lazily executed functions (IO)&lt;/li&gt; &#xA; &lt;li&gt;expose a consistent set of composition to create new functions from existing ones &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;for each data type there exists a small set of composition functions&lt;/li&gt; &#xA;   &lt;li&gt;these functions are called the same across all data types, so you only have to learn a small number of function names&lt;/li&gt; &#xA;   &lt;li&gt;the semantic of functions of the same name is consistent across all data types&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How does this play with the &lt;a href=&#34;https://the-zen-of-go.netlify.app/&#34;&gt;🧘🏽 Zen Of Go&lt;/a&gt;?&lt;/h3&gt; &#xA;&lt;h4&gt;🧘🏽 Each package fulfils a single purpose&lt;/h4&gt; &#xA;&lt;p&gt;✔️ Each of the top level packages (e.g. Option, Either, ReaderIOEither, ...) fulfils the purpose of defining the respective data type and implementing the set of common operations for this data type.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Handle errors explicitly&lt;/h4&gt; &#xA;&lt;p&gt;✔️ The library makes a clear distinction between that operations that cannot fail by design and operations that can fail. Failure is represented via the &lt;code&gt;Either&lt;/code&gt; type and errors are handled explicitly by using &lt;code&gt;Either&lt;/code&gt;&#39;s monadic set of operations.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Return early rather than nesting deeply&lt;/h4&gt; &#xA;&lt;p&gt;✔️ We recommend to implement simple, small functions that implement one feature and that would typically not invoke other functions. Interaction with other functions is done by function composition and the composition makes sure to run one function after the other. In the error case the &lt;code&gt;Either&lt;/code&gt; monad makes sure to skip the error path.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Leave concurrency to the caller&lt;/h4&gt; &#xA;&lt;p&gt;✔️ All pure are synchronous by default. The I/O operations are asynchronous per default.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Before you launch a goroutine, know when it will stop&lt;/h4&gt; &#xA;&lt;p&gt;🤷🏽 This is left to the user of the library since the library itself will not start goroutines on its own. The Task monad offers support for cancellation via the golang context, though.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Avoid package level state&lt;/h4&gt; &#xA;&lt;p&gt;✔️ No package level state anywhere, this would be a significant anti-pattern&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Simplicity matters&lt;/h4&gt; &#xA;&lt;p&gt;✔️ The library is simple in the sense that it offers a small, consistent interface to a variety of data types. Users can concentrate on implementing business logic rather than dealing with low level data structures.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Write tests to lock in the behaviour of your package’s API&lt;/h4&gt; &#xA;&lt;p&gt;🟡 The programming pattern suggested by this library encourages writing test cases. The library itself also has a growing number of tests, but not enough, yet. TBD&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 If you think it’s slow, first prove it with a benchmark&lt;/h4&gt; &#xA;&lt;p&gt;✔️ Absolutely. If you think the function composition offered by this library is too slow, please provide a benchmark.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Moderation is a virtue&lt;/h4&gt; &#xA;&lt;p&gt;✔️ The library does not implement its own goroutines and also does not require any expensive synchronization primitives. Coordination of IO operations is implemented via atomic counters without additional primitives.&lt;/p&gt; &#xA;&lt;h4&gt;🧘🏽 Maintainability counts&lt;/h4&gt; &#xA;&lt;p&gt;✔️ Code that consumes this library is easy to maintain because of the small and concise set of operations exposed. Also the suggested programming paradigm to decompose an application into small functions increases maintainability, because these functions are easy to understand and if they are pure, it&#39;s often sufficient to look at the type signature to understand the purpose.&lt;/p&gt; &#xA;&lt;p&gt;The library itself also comprises many small functions, but it&#39;s admittedly harder to maintain than code that uses it. However this asymmetry is intended because it offloads complexity from users into a central component.&lt;/p&gt; &#xA;&lt;h2&gt;Comparation to Idiomatic Go&lt;/h2&gt; &#xA;&lt;p&gt;In this section we discuss how the functional APIs differ from idiomatic go function signatures and how to convert back and forth.&lt;/p&gt; &#xA;&lt;h3&gt;Pure functions&lt;/h3&gt; &#xA;&lt;p&gt;Pure functions are functions that take input parameters and that compute an output without changing any global state and without mutating the input parameters. They will always return the same output for the same input.&lt;/p&gt; &#xA;&lt;h4&gt;Without Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your pure function does not return an error, the idiomatic signature is just fine and no changes are required.&lt;/p&gt; &#xA;&lt;h4&gt;With Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your pure function can return an error, then it will have a &lt;code&gt;(T, error)&lt;/code&gt; return value in idiomatic go. In functional style the return value is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/either&#34;&gt;Either[error, T]&lt;/a&gt; because function composition is easier with such a return type. Use the &lt;code&gt;EitherizeXXX&lt;/code&gt; methods in &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/either&#34;&gt;&#34;github.com/IBM/fp-go/either&#34;&lt;/a&gt; to convert from idiomatic to functional style and &lt;code&gt;UneitherizeXXX&lt;/code&gt; to convert from functional to idiomatic style.&lt;/p&gt; &#xA;&lt;h3&gt;Effectful functions&lt;/h3&gt; &#xA;&lt;p&gt;An effectful function (or function with a side effect) is one that changes data outside the scope of the function or that does not always produce the same output for the same input (because it depends on some external, mutable state). There is no special way in idiomatic go to identify such a function other than documentation. In functional style we represent them as functions that do not take an input but that produce an output. The base type for these functions is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/io&#34;&gt;IO[T]&lt;/a&gt; because in many cases such functions represent &lt;code&gt;I/O&lt;/code&gt; operations.&lt;/p&gt; &#xA;&lt;h4&gt;Without Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your effectful function does not return an error, the functional signature is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/io&#34;&gt;IO[T]&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;With Errors&lt;/h4&gt; &#xA;&lt;p&gt;If your effectful function can return an error, the functional signature is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/ioeither&#34;&gt;IOEither[error, T]&lt;/a&gt;. Use &lt;code&gt;EitherizeXXX&lt;/code&gt; from &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/ioeither&#34;&gt;&#34;github.com/IBM/fp-go/ioeither&#34;&lt;/a&gt; to convert an idiomatic go function to functional style.&lt;/p&gt; &#xA;&lt;h3&gt;Go Context&lt;/h3&gt; &#xA;&lt;p&gt;Functions that take a &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; are per definition effectful because they depend on the context parameter that is designed to be mutable (it can e.g. be used to cancel a running operation). Furthermore in idiomatic go the parameter is typically passed as the first parameter to a function.&lt;/p&gt; &#xA;&lt;p&gt;In functional style we isolate the &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; and represent the nature of the effectful function as an &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/ioeither&#34;&gt;IOEither[error, T]&lt;/a&gt;. The resulting type is &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/context/readerioeither&#34;&gt;ReaderIOEither[T]&lt;/a&gt;, a function taking a &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; that returns a function without parameters returning an &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/either&#34;&gt;Either[error, T]&lt;/a&gt;. Use the &lt;code&gt;EitherizeXXX&lt;/code&gt; methods from &lt;a href=&#34;https://pkg.go.dev/github.com/IBM/fp-go/context/readerioeither&#34;&gt;&#34;github.com/IBM/fp-go/context/readerioeither&#34;&lt;/a&gt; to convert an idiomatic go function with a &lt;a href=&#34;https://pkg.go.dev/context&#34;&gt;context&lt;/a&gt; to functional style.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Notes&lt;/h2&gt; &#xA;&lt;h3&gt;Generics&lt;/h3&gt; &#xA;&lt;p&gt;All monadic operations are implemented via generics, i.e. they offer a type safe way to compose operations. This allows for convenient IDE support and also gives confidence about the correctness of the composition at compile time.&lt;/p&gt; &#xA;&lt;p&gt;Downside is that this will result in different versions of each operation per type, these versions are generated by the golang compiler at build time (unlike type erasure in languages such as Java of TypeScript). This might lead to large binaries for codebases with many different types. If this is a concern, you can always implement type erasure on top, i.e. use the monadic operations with the &lt;code&gt;any&lt;/code&gt; type as if generics were not supported. You loose type safety, but this might result in smaller binaries.&lt;/p&gt; &#xA;&lt;h3&gt;Ordering of Generic Type Parameters&lt;/h3&gt; &#xA;&lt;p&gt;In go we need to specify all type parameters of a function on the global function definition, even if the function returns a higher order function and some of the type parameters are only applicable to the higher order function. So the following is not possible:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[A, B any](f func(A) B) [R, E any]func(fa ReaderIOEither[R, E, A]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the parameters &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are not needed by the first level of &lt;code&gt;Map&lt;/code&gt; but only by the resulting higher order function. Instead we need to specify the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[R, E, A, B any](f func(A) B) func(fa ReaderIOEither[R, E, A]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which overspecifies &lt;code&gt;Map&lt;/code&gt; on the global scope. As a result the go compiler will not be able to auto-detect these parameters, it can only auto detect &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; since they appear in the argument of &lt;code&gt;Map&lt;/code&gt;. We need to explicitly pass values for these type parameters when &lt;code&gt;Map&lt;/code&gt; is being used.&lt;/p&gt; &#xA;&lt;p&gt;Because of this limitation the order of parameters on a function matters. We want to make sure that we define those parameters that cannot be auto-detected, first, and the parameters that can be auto-detected, last. This can lead to inconsistencies in parameter ordering, but we believe that the gain in convenience is worth it. The parameter order of &lt;code&gt;Ap&lt;/code&gt; is e.g. different from that of &lt;code&gt;Map&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Ap[B, R, E, A any](fa ReaderIOEither[R, E, A]) func(fab ReaderIOEither[R, E, func(A) B]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;because &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; can be determined from the argument to &lt;code&gt;Ap&lt;/code&gt; but &lt;code&gt;B&lt;/code&gt; cannot.&lt;/p&gt; &#xA;&lt;h3&gt;Use of the &lt;a href=&#34;https://go.googlesource.com/proposal/+/master/design/47781-parameterized-go-ast.md&#34;&gt;~ Operator&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The FP library attempts to be easy to consume and one aspect of this is the definition of higher level type definitions instead of having to use their low level equivalent. It is e.g. more convenient and readable to use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ReaderIOEither[R, E, A]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;than&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func(R) func() Either.Either[E, A]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;although both are logically equivalent. At the time of this writing the go type system does not support generic type aliases, only generic type definition, i.e. it is not possible to write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReaderIOEither[R, E, A any] = RD.Reader[R, IOE.IOEither[E, A]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;only&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReaderIOEither[R, E, A any] RD.Reader[R, IOE.IOEither[E, A]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This makes a big difference, because in the second case the type &lt;code&gt;ReaderIOEither[R, E, A any]&lt;/code&gt; is considered a completely new type, not compatible to its right hand side, so it&#39;s not just a shortcut but a fully new type.&lt;/p&gt; &#xA;&lt;p&gt;From the implementation perspective however there is no reason to restrict the implementation to the new type, it can be generic for all compatible types. The way to express this in go is the &lt;a href=&#34;https://go.googlesource.com/proposal/+/master/design/47781-parameterized-go-ast.md&#34;&gt;~&lt;/a&gt; operator. This comes with some quite complicated type declarations in some cases, which undermines the goal of the library to be easy to use.&lt;/p&gt; &#xA;&lt;p&gt;For that reason there exist sub-packages called &lt;code&gt;Generic&lt;/code&gt; for all higher level types. These packages contain the fully generic implementation of the operations, preferring abstraction over usability. These packages are not meant to be used by end-users but are meant to be used by library extensions. The implementation for the convenient higher level types specializes the generic implementation for the particular higher level type, i.e. this layer does not contain any business logic but only &lt;em&gt;type magic&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Higher Kinded Types&lt;/h3&gt; &#xA;&lt;p&gt;Go does not support higher kinded types (HKT). Such types occur if a generic type itself is parametrized by another generic type. Example:&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Map&lt;/code&gt; operation for &lt;code&gt;ReaderIOEither&lt;/code&gt; is defined as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[R, E, A, B any](f func(A) B) func(fa ReaderIOEither[R, E, A]) ReaderIOEither[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and in fact the equivalent operations for all other mondas follow the same pattern, we could try to introduce a new type for &lt;code&gt;ReaderIOEither&lt;/code&gt; (without a parameter) as a HKT, e.g. like so (made-up syntax, does not work in go):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Map[HKT, R, E, A, B any](f func(A) B) func(HKT[R, E, A]) HKT[R, E, B]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this would be the completely generic method signature for all possible monads. In particular in many cases it is possible to compose functions independent of the concrete knowledge of the actual &lt;code&gt;HKT&lt;/code&gt;. From the perspective of a library this is the ideal situation because then a particular algorithm only has to be implemented and tested once.&lt;/p&gt; &#xA;&lt;p&gt;This FP library addresses this by introducing the HKTs as individual types, e.g. &lt;code&gt;HKT[A]&lt;/code&gt; would be represented as a new generic type &lt;code&gt;HKTA&lt;/code&gt;. This loses the correlation to the type &lt;code&gt;A&lt;/code&gt; but allows to implement generic algorithms, at the price of readability.&lt;/p&gt; &#xA;&lt;p&gt;For that reason these implementations are kept in the &lt;code&gt;internal&lt;/code&gt; package. These are meant to be used by the library itself or by extensions, not by end users.&lt;/p&gt;</summary>
  </entry>
</feed>