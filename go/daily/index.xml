<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-10T01:35:23Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sa7mon/S3Scanner</title>
    <updated>2023-08-10T01:35:23Z</updated>
    <id>tag:github.com,2023-08-10:/sa7mon/S3Scanner</id>
    <link href="https://github.com/sa7mon/S3Scanner" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scan for misconfigured S3 buckets across S3-compatible APIs!&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; S3Scanner &lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sponsors/sa7mon/&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/sponsors/sa7mon&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sa7mon/S3Scanner/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sa7mon/S3Scanner/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/sa7mon/s3scanner&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/sa7mon/S3Scanner/main/#features&#34;&gt;Features&lt;/a&gt; - &lt;a href=&#34;https://raw.githubusercontent.com/sa7mon/S3Scanner/main/#usage&#34;&gt;Usage&lt;/a&gt; - &lt;a href=&#34;https://raw.githubusercontent.com/sa7mon/S3Scanner/main/#quick-start&#34;&gt;Quick Start&lt;/a&gt; - &lt;a href=&#34;https://raw.githubusercontent.com/sa7mon/S3Scanner/main/#installation&#34;&gt;Installation&lt;/a&gt; - &lt;a href=&#34;https://github.com/sa7mon/S3Scanner/discussions&#34;&gt;Discuss&lt;/a&gt; &lt;/p&gt; &#xA;&lt;br&gt; A tool to find open S3 buckets in AWS or other cloud providers: &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AWS&lt;/li&gt; &#xA; &lt;li&gt;DigitalOcean&lt;/li&gt; &#xA; &lt;li&gt;DreamHost&lt;/li&gt; &#xA; &lt;li&gt;GCP&lt;/li&gt; &#xA; &lt;li&gt;Linode&lt;/li&gt; &#xA; &lt;li&gt;Custom&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img alt=&#34;demo&#34; src=&#34;https://github.com/sa7mon/S3Scanner/assets/3712226/cfa16801-2a44-4ae9-ad85-9dd466390cd9&#34;&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;‚ö°Ô∏è Multi-threaded scanning&lt;/li&gt; &#xA; &lt;li&gt;üî≠ Supports many built-in S3 storage providers or custom&lt;/li&gt; &#xA; &lt;li&gt;üïµÔ∏è‚Äç‚ôÄÔ∏è Scans all bucket permissions to find misconfigurations&lt;/li&gt; &#xA; &lt;li&gt;üíæ Save results to Postgres database&lt;/li&gt; &#xA; &lt;li&gt;üêá Connect to RabbitMQ for automated scanning at scale&lt;/li&gt; &#xA; &lt;li&gt;üê≥ Docker support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;INPUT: (1 required)&#xA;  -bucket        string  Name of bucket to check.&#xA;  -bucket-file   string  File of bucket names to check.&#xA;  -mq                    Connect to RabbitMQ to get buckets. Requires config file key &#34;mq&#34;. Default: &#34;false&#34;&#xA;&#xA;OUTPUT:&#xA;  -db       Save results to a Postgres database. Requires config file key &#34;db.uri&#34;. Default: &#34;false&#34;&#xA;  -json     Print logs to stdout in JSON format instead of human-readable. Default: &#34;false&#34;&#xA;&#xA;OPTIONS:&#xA;  -enumerate           Enumerate bucket objects (can be time-consuming). Default: &#34;false&#34;&#xA;  -provider    string  Object storage provider: aws, custom, digitalocean, dreamhost, gcp, linode - custom requires config file. Default: &#34;aws&#34;&#xA;  -threads     int     Number of threads to scan with. Default: &#34;4&#34;&#xA;&#xA;DEBUG:&#xA;  -verbose     Enable verbose logging. Default: &#34;false&#34;&#xA;  -version     Print version Default: &#34;false&#34;&#xA;&#xA;If config file is required these locations will be searched for config.yml: &#34;.&#34; &#34;/etc/s3scanner/&#34; &#34;$HOME/.s3scanner/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;üöÄ Support&lt;/h1&gt; &#xA;&lt;p&gt;If you&#39;ve found this tool useful, please consider donating to support its development. You can find sponsor options on the side of this repo page or in &lt;a href=&#34;https://raw.githubusercontent.com/sa7mon/S3Scanner/main/.github/FUNDING.yml&#34;&gt;FUNDING.yml&lt;/a&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;a href=&#34;https://www.tines.com/?utm_source=oss&amp;amp;utm_medium=sponsorship&amp;amp;utm_campaign=s3scanner&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/3712226/146481766-a331b010-29c4-4537-ac30-9a4b4aad06b3.png&#34; height=&#34;50&#34; width=&#34;140&#34;&gt;&lt;/a&gt;&#xA;&lt;/div&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Huge thank you to &lt;a href=&#34;https://www.tines.com/?utm_source=oss&amp;amp;utm_medium=sponsorship&amp;amp;utm_campaign=s3scanner&#34;&gt;tines&lt;/a&gt; for being an ongoing sponsor of this project.&lt;/p&gt; &#xA;&lt;h1&gt;Quick Start&lt;/h1&gt; &#xA;&lt;p&gt;Scan AWS for bucket names listed in a file, enumerate all objects&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ s3scanner -bucket-file names.txt -enumerate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scan a bucket in GCP, enumerate all objects, and save results to database&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ s3scanner -provider gcp -db -bucket my-bucket -enumerate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Homebrew&lt;/strong&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install s3scanner&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Docker&lt;/strong&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run --rm -it ghcr.io/sa7mon/s3scanner:latest -bucket my-bucket&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Go&lt;/strong&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# replace version with latest release&#xA;go install -v github.com/sa7mon/s3scanner@v3.0.1&#xA;# or&#xA;go install -v github.com/sa7mon/s3scanner@latest &#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Build from source&lt;/strong&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone git@github.com:sa7mon/S3Scanner.git &amp;amp;&amp;amp; cd S3Scanner&#xA;go build -o s3scanner .&#xA;./s3scanner -bucket my-bucket&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Using&lt;/h1&gt; &#xA;&lt;h2&gt;Input&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;s3scanner&lt;/code&gt; requires exactly one type of input: &lt;code&gt;-bucket&lt;/code&gt;, &lt;code&gt;-bucket-file&lt;/code&gt;, or &lt;code&gt;-mq&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;INPUT: (1 required)&#xA;  -bucket        string  Name of bucket to check.&#xA;  -bucket-file   string  File of bucket names to check.&#xA;  -mq                    Connect to RabbitMQ to get buckets. Requires config file key &#34;mq&#34;. Default: &#34;false&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-bucket&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Scan a single bucket&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -bucket secret_uploads&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-bucket-file&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Scans every bucket name listed in file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;s3scanner -bucket-file names.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;names.txt&lt;/code&gt; contains one bucket name per line&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cat names.txt&#xA;bucket123&#xA;assets&#xA;image-uploads&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-mq&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Connects to a RabbitMQ server and consumes messages containing bucket names to scan.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;s3scanner -mq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Messages should be JSON-encoded &lt;a href=&#34;https://github.com/sa7mon/s3scanner/raw/main/bucket/bucket.go&#34;&gt;&lt;code&gt;Bucket&lt;/code&gt;&lt;/a&gt; objects - refer to &lt;a href=&#34;https://github.com/sa7mon/s3scanner/raw/main/cmd/mqingest/mqingest.go&#34;&gt;&lt;code&gt;mqingest&lt;/code&gt;&lt;/a&gt; for a Golang publishing example.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-mq&lt;/code&gt; requires the &lt;code&gt;mq.uri&lt;/code&gt; and &lt;code&gt;mq.queue_name&lt;/code&gt; config file keys. See Config File section for example.&lt;/p&gt; &#xA;&lt;h2&gt;Output&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;OUTPUT:&#xA;  -db       Save results to a Postgres database. Requires config file key &#34;db.uri&#34;. Default: &#34;false&#34;&#xA;  -json     Print logs to stdout in JSON format instead of human-readable. Default: &#34;false&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-db&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Saves all scan results to a PostgreSQL database&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -bucket images -db&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Requires the &lt;code&gt;db.uri&lt;/code&gt; config file key. See Config File section for example.&lt;/li&gt; &#xA; &lt;li&gt;If using &lt;code&gt;-db&lt;/code&gt;, results will also be printed to the console if using &lt;code&gt;-json&lt;/code&gt; or the default human-readable output mode.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s3scanner&lt;/code&gt; runs Gorm&#39;s &lt;a href=&#34;https://gorm.io/docs/migration.html#Auto-Migration&#34;&gt;Auto Migration&lt;/a&gt; feature each time it connects two the database. If the schema already has tables with names Gorm expects, it may change these tables&#39; structure. It is recommended to create a Postgres schema dedicated to &lt;code&gt;s3scanner&lt;/code&gt; results.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-json&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Instead of outputting scan results to console in human-readable format, output machine-readable JSON.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -bucket images -json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will print one JSON object per line to the console, which can then be piped to &lt;code&gt;jq&lt;/code&gt; or other tools that accept JSON input.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;: Print bucket name and region for all buckets that exist&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ s3scanner -bucket-file names.txt -json | jq -r &#39;. | select(.bucket.exists==1) | [.bucket.name, .bucket.region] | join(&#34; - &#34;)&#39;       &#xA;10000 - eu-west-1&#xA;10000.pizza - ap-southeast-1&#xA;images_staging - us-west-2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;OPTIONS:&#xA;  -enumerate           Enumerate bucket objects (can be time-consuming). Default: &#34;false&#34;&#xA;  -provider    string  Object storage provider: aws, custom, digitalocean, dreamhost, gcp, linode - custom requires config file. Default: &#34;aws&#34;&#xA;  -threads     int     Number of threads to scan with. Default: &#34;4&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-enumerate&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Enumerate all objects stored in bucket. By default, &lt;code&gt;s3scanner&lt;/code&gt; will only check permissions of buckets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -bucket attachments -enumerate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Note:&lt;/strong&gt; This can take a long time if there are a large number of objects stored.&lt;/li&gt; &#xA; &lt;li&gt;When enumerating, &lt;code&gt;s3scanner&lt;/code&gt; will request &#34;pages&#34; of 1,000 objects. If there are more than 5,000 pages of objects, it will skip the rest.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-provider&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Name of storage provider to use when checking buckets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -bucket assets -provider gcp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use &#34;custom&#34; when targeting a currently unsupported or local network storage provider.&lt;/li&gt; &#xA; &lt;li&gt;&#34;custom&#34; provider requires config file keys under &lt;code&gt;providers.custom&lt;/code&gt; listed in the Config File section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-threads&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Number of threads to scan with.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -bucket secret_docs -threads 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Increasing threads will increase the number of buckets being scanned simultaneously, but will not speed up object enumeration. Enumeration is currently single-threaded per bucket.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Debug&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;DEBUG:&#xA;  -verbose     Enable verbose logging. Default: &#34;false&#34;&#xA;  -version     Print version Default: &#34;false&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-verbose&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Enables verbose logging of debug messages. This option will produce a lot of logs and is not recommended to use unless filing a bug report.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -bucket spreadsheets -verbose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;em&gt;&lt;code&gt;-version&lt;/code&gt;&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Print the version info and exit.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;s3scanner -version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Will print &lt;code&gt;dev&lt;/code&gt; if compiled from source.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Config File&lt;/h1&gt; &#xA;&lt;p&gt;If using flags that require config options, &lt;code&gt;s3scanner&lt;/code&gt; will search for &lt;code&gt;config.yml&lt;/code&gt; in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(current directory)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/etc/s3scanner/&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$HOME/.s3scanner/&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Required by -db&#xA;db:&#xA;  uri: &#34;postgresql://user:pass@db.host.name:5432/schema_name&#34;&#xA;&#xA;# Required by -mq&#xA;mq:&#xA;  queue_name: &#34;aws&#34;&#xA;  uri: &#34;amqp://user:pass@localhost:5672&#34;&#xA;&#xA;# providers.custom required by `-provider custom`&#xA;#   address_style - Addressing style used by endpoints.&#xA;#     type: string&#xA;#     values: &#34;path&#34; or &#34;vhost&#34;&#xA;#   endpoint_format - Format of endpoint URLs. Should contain &#39;$REGION&#39; as placeholder for region name&#xA;#     type: string&#xA;#   insecure - Ignore SSL errors&#xA;#     type: boolean&#xA;# regions must contain at least one option&#xA;providers:&#xA;  custom: &#xA;    address_style: &#34;path&#34;&#xA;    endpoint_format: &#34;https://$REGION.vultrobjects.com&#34;&#xA;    insecure: false&#xA;    regions:&#xA;      - &#34;ewr1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When &lt;code&gt;s3scanner&lt;/code&gt; parses the config file, it will take the &lt;code&gt;endpoint_format&lt;/code&gt; and replace &lt;code&gt;$REGION&lt;/code&gt; for all &lt;code&gt;regions&lt;/code&gt; listed to create a list of endpoint URLs.&lt;/p&gt; &#xA;&lt;h1&gt;S3 compatible APIs&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;S3Scanner&lt;/code&gt; currently only supports scanning for anonymous user permissions of non-AWS services&lt;/p&gt; &#xA;&lt;p&gt;üìö More information on non-AWS APIs can be found &lt;a href=&#34;https://github.com/sa7mon/S3Scanner/wiki/S3-Compatible-APIs&#34;&gt;in the project wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Permissions&lt;/h2&gt; &#xA;&lt;p&gt;This tool will attempt to get all available information about a bucket, but it&#39;s up to you to interpret the results.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/AmazonS3/latest/user-guide/set-bucket-permissions.html&#34;&gt;Possible permissions&lt;/a&gt; for buckets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Read - List and view all files&lt;/li&gt; &#xA; &lt;li&gt;Write - Write files to bucket&lt;/li&gt; &#xA; &lt;li&gt;Read ACP - Read all Access Control Policies attached to bucket&lt;/li&gt; &#xA; &lt;li&gt;Write ACP - Write Access Control Policies to bucket&lt;/li&gt; &#xA; &lt;li&gt;Full Control - All above permissions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Any or all of these permissions can be set for the 2 main user groups:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Authenticated Users&lt;/li&gt; &#xA; &lt;li&gt;Public Users (those without AWS credentials set)&lt;/li&gt; &#xA; &lt;li&gt;Individual users/groups (out of scope of this tool)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;What this means:&lt;/strong&gt; Just because a bucket doesn&#39;t allow reading/writing ACLs doesn&#39;t mean you can&#39;t read/write files in the bucket. Conversely, you may be able to list ACLs but not read/write to the bucket&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NVIDIA/k8s-device-plugin</title>
    <updated>2023-08-10T01:35:23Z</updated>
    <id>tag:github.com,2023-08-10:/NVIDIA/k8s-device-plugin</id>
    <link href="https://github.com/NVIDIA/k8s-device-plugin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NVIDIA device plugin for Kubernetes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NVIDIA device plugin for Kubernetes&lt;/h1&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#about&#34;&gt;About&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#prerequisites&#34;&gt;Prerequisites&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#quick-start&#34;&gt;Quick Start&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#preparing-your-gpu-nodes&#34;&gt;Preparing your GPU Nodes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#enabling-gpu-support-in-kubernetes&#34;&gt;Enabling GPU Support in Kubernetes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#running-gpu-jobs&#34;&gt;Running GPU Jobs&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#configuring-the-nvidia-device-plugin-binary&#34;&gt;Configuring the NVIDIA device plugin binary&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#as-command-line-flags-or-envvars&#34;&gt;As command line flags or envvars&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#as-a-configuration-file&#34;&gt;As a configuration file&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#configuration-option-details&#34;&gt;Configuration Option Details&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#shared-access-to-gpus-with-cuda-time-slicing&#34;&gt;Shared Access to GPUs with CUDA Time-Slicing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#deployment-via-helm&#34;&gt;Deployment via &lt;code&gt;helm&lt;/code&gt;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#configuring-the-device-plugins-helm-chart&#34;&gt;Configuring the device plugin&#39;s &lt;code&gt;helm&lt;/code&gt; chart&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#passing-configuration-to-the-plugin-via-a-configmap&#34;&gt;Passing configuration to the plugin via a &lt;code&gt;ConfigMap&lt;/code&gt;.&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#single-config-file-example&#34;&gt;Single Config File Example&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#multiple-config-file-example&#34;&gt;Multiple Config File Example&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#updating-per-node-configuration-with-a-node-label&#34;&gt;Updating Per-Node Configuration With a Node Label&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#setting-other-helm-chart-values&#34;&gt;Setting other helm chart values&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#deploying-with-gpu-feature-discovery-for-automatic-node-labels&#34;&gt;Deploying with gpu-feature-discovery for automatic node labels&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#deploying-via-helm-install-with-a-direct-url-to-the-helm-package&#34;&gt;Deploying via &lt;code&gt;helm install&lt;/code&gt; with a direct URL to the &lt;code&gt;helm&lt;/code&gt; package&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#building-and-running-locally&#34;&gt;Building and Running Locally&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#changelog&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#issues-and-contributing&#34;&gt;Issues and Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;The NVIDIA device plugin for Kubernetes is a Daemonset that allows you to automatically:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Expose the number of GPUs on each nodes of your cluster&lt;/li&gt; &#xA; &lt;li&gt;Keep track of the health of your GPUs&lt;/li&gt; &#xA; &lt;li&gt;Run GPU enabled containers in your Kubernetes cluster.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repository contains NVIDIA&#39;s official implementation of the &lt;a href=&#34;https://github.com/kubernetes/community/raw/master/contributors/design-proposals/resource-management/device-plugin.md&#34;&gt;Kubernetes device plugin&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please note that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The NVIDIA device plugin API is beta as of Kubernetes v1.10.&lt;/li&gt; &#xA; &lt;li&gt;The NVIDIA device plugin is currently lacking &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Comprehensive GPU health checking features&lt;/li&gt; &#xA;   &lt;li&gt;GPU cleanup features&lt;/li&gt; &#xA;   &lt;li&gt;...&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Support will only be provided for the official NVIDIA device plugin (and not for forks or other variants of this plugin).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;The list of prerequisites for running the NVIDIA device plugin is described below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NVIDIA drivers ~= 384.81&lt;/li&gt; &#xA; &lt;li&gt;nvidia-docker &amp;gt;= 2.0 || nvidia-container-toolkit &amp;gt;= 1.7.0 (&amp;gt;= 1.11.0 to use integrated GPUs on Tegra-based systems)&lt;/li&gt; &#xA; &lt;li&gt;nvidia-container-runtime configured as the default low-level runtime&lt;/li&gt; &#xA; &lt;li&gt;Kubernetes version &amp;gt;= 1.10&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;h3&gt;Preparing your GPU Nodes&lt;/h3&gt; &#xA;&lt;p&gt;The following steps need to be executed on all your GPU nodes. This README assumes that the NVIDIA drivers and the &lt;code&gt;nvidia-container-toolkit&lt;/code&gt; have been pre-installed. It also assumes that you have configured the &lt;code&gt;nvidia-container-runtime&lt;/code&gt; as the default low-level runtime to use.&lt;/p&gt; &#xA;&lt;p&gt;Please see: &lt;a href=&#34;https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html&#34;&gt;https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Example for debian-based systems with &lt;code&gt;docker&lt;/code&gt; and &lt;code&gt;containerd&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;h5&gt;Install the &lt;code&gt;nvidia-container-toolkit&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;distribution=$(. /etc/os-release;echo $ID$VERSION_ID)&#xA;curl -s -L https://nvidia.github.io/libnvidia-container/gpgkey | sudo apt-key add -&#xA;curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | sudo tee /etc/apt/sources.list.d/libnvidia-container.list&#xA;&#xA;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y nvidia-container-toolkit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Configure &lt;code&gt;docker&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;When running &lt;code&gt;kubernetes&lt;/code&gt; with &lt;code&gt;docker&lt;/code&gt;, edit the config file which is usually present at &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; to set up &lt;code&gt;nvidia-container-runtime&lt;/code&gt; as the default low-level runtime:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;default-runtime&#34;: &#34;nvidia&#34;,&#xA;    &#34;runtimes&#34;: {&#xA;        &#34;nvidia&#34;: {&#xA;            &#34;path&#34;: &#34;/usr/bin/nvidia-container-runtime&#34;,&#xA;            &#34;runtimeArgs&#34;: []&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then restart &lt;code&gt;docker&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Configure &lt;code&gt;containerd&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;When running &lt;code&gt;kubernetes&lt;/code&gt; with &lt;code&gt;containerd&lt;/code&gt;, edit the config file which is usually present at &lt;code&gt;/etc/containerd/config.toml&lt;/code&gt; to set up &lt;code&gt;nvidia-container-runtime&lt;/code&gt; as the default low-level runtime:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;version = 2&#xA;[plugins]&#xA;  [plugins.&#34;io.containerd.grpc.v1.cri&#34;]&#xA;    [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd]&#xA;      default_runtime_name = &#34;nvidia&#34;&#xA;&#xA;      [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes]&#xA;        [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.nvidia]&#xA;          privileged_without_host_devices = false&#xA;          runtime_engine = &#34;&#34;&#xA;          runtime_root = &#34;&#34;&#xA;          runtime_type = &#34;io.containerd.runc.v2&#34;&#xA;          [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.nvidia.options]&#xA;            BinaryName = &#34;/usr/bin/nvidia-container-runtime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then restart &lt;code&gt;containerd&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart containerd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enabling GPU Support in Kubernetes&lt;/h3&gt; &#xA;&lt;p&gt;Once you have configured the options above on all the GPU nodes in your cluster, you can enable GPU support by deploying the following Daemonset:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v0.14.1/nvidia-device-plugin.yml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This is a simple static daemonset meant to demonstrate the basic features of the &lt;code&gt;nvidia-device-plugin&lt;/code&gt;. Please see the instructions below for &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#deployment-via-helm&#34;&gt;Deployment via &lt;code&gt;helm&lt;/code&gt;&lt;/a&gt; when deploying the plugin in a production setting.&lt;/p&gt; &#xA;&lt;h3&gt;Running GPU Jobs&lt;/h3&gt; &#xA;&lt;p&gt;With the daemonset deployed, NVIDIA GPUs can now be requested by a container using the &lt;code&gt;nvidia.com/gpu&lt;/code&gt; resource type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat &amp;lt;&amp;lt;EOF | kubectl apply -f -&#xA;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: gpu-pod&#xA;spec:&#xA;  restartPolicy: Never&#xA;  containers:&#xA;    - name: cuda-container&#xA;      image: nvcr.io/nvidia/k8s/cuda-sample:vectoradd-cuda10.2&#xA;      resources:&#xA;        limits:&#xA;          nvidia.com/gpu: 1 # requesting 1 GPU&#xA;  tolerations:&#xA;  - key: nvidia.com/gpu&#xA;    operator: Exists&#xA;    effect: NoSchedule&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl logs gpu-pod&#xA;[Vector addition of 50000 elements]&#xA;Copy input data from the host memory to the CUDA device&#xA;CUDA kernel launch with 196 blocks of 256 threads&#xA;Copy output data from the CUDA device to the host memory&#xA;Test PASSED&#xA;Done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;WARNING:&lt;/strong&gt; &lt;em&gt;if you don&#39;t request GPUs when using the device plugin with NVIDIA images all the GPUs on the machine will be exposed inside your container.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Configuring the NVIDIA device plugin binary&lt;/h2&gt; &#xA;&lt;p&gt;The NVIDIA device plugin has a number of options that can be configured for it. These options can be configured as command line flags, environment variables, or via a config file when launching the device plugin. Here we explain what each of these options are and how to configure them directly against the plugin binary. The following section explains how to set these configurations when deploying the plugin via &lt;code&gt;helm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;As command line flags or envvars&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Flag&lt;/th&gt; &#xA;   &lt;th&gt;Envvar&lt;/th&gt; &#xA;   &lt;th&gt;Default Value&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--mig-strategy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;$MIG_STRATEGY&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;none&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--fail-on-init-error&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;$FAIL_ON_INIT_ERROR&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--nvidia-driver-root&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;$NVIDIA_DRIVER_ROOT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;/&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--pass-device-specs&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;$PASS_DEVICE_SPECS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--device-list-strategy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;$DEVICE_LIST_STRATEGY&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;envvar&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--device-id-strategy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;$DEVICE_ID_STRATEGY&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;uuid&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--config-file&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;$CONFIG_FILE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;As a configuration file&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;version: v1&#xA;flags:&#xA;  migStrategy: &#34;none&#34;&#xA;  failOnInitError: true&#xA;  nvidiaDriverRoot: &#34;/&#34;&#xA;  plugin:&#xA;    passDeviceSpecs: false&#xA;    deviceListStrategy: &#34;envvar&#34;&#xA;    deviceIDStrategy: &#34;uuid&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The configuration file has an explicit &lt;code&gt;plugin&lt;/code&gt; section because it is a shared configuration between the plugin and &lt;a href=&#34;https://github.com/NVIDIA/gpu-feature-discovery&#34;&gt;&lt;code&gt;gpu-feature-discovery&lt;/code&gt;&lt;/a&gt;. All options inside the &lt;code&gt;plugin&lt;/code&gt; section are specific to the plugin. All options outside of this section are shared.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration Option Details&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;MIG_STRATEGY&lt;/code&gt;&lt;/strong&gt;: the desired strategy for exposing MIG devices on GPUs that support it&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;[none | single | mixed] (default &#39;none&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;MIG_STRATEGY&lt;/code&gt; option configures the daemonset to be able to expose Multi-Instance GPUs (MIG) on GPUs that support them. More information on what these strategies are and how they should be used can be found in &lt;a href=&#34;https://docs.google.com/document/d/1mdgMQ8g7WmaI_XVVRrCvHPFPOMCm5LQD5JefgAh6N8g&#34;&gt;Supporting Multi-Instance GPUs (MIG) in Kubernetes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; With a &lt;code&gt;MIG_STRATEGY&lt;/code&gt; of mixed, you will have additional resources available to you of the form &lt;code&gt;nvidia.com/mig-&amp;lt;slice_count&amp;gt;g.&amp;lt;memory_size&amp;gt;gb&lt;/code&gt; that you can set in your pod spec to get access to a specific MIG device.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;FAIL_ON_INIT_ERROR&lt;/code&gt;&lt;/strong&gt;: fail the plugin if an error is encountered during initialization, otherwise block indefinitely&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(default &#39;true&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;When set to true, the &lt;code&gt;FAIL_ON_INIT_ERROR&lt;/code&gt; option fails the plugin if an error is encountered during initialization. When set to false, it prints an error message and blocks the plugin indefinitely instead of failing. Blocking indefinitely follows legacy semantics that allow the plugin to deploy successfully on nodes that don&#39;t have GPUs on them (and aren&#39;t supposed to have GPUs on them) without throwing an error. In this way, you can blindly deploy a daemonset with the plugin on all nodes in your cluster, whether they have GPUs on them or not, without encountering an error. However, doing so means that there is no way to detect an actual error on nodes that are supposed to have GPUs on them. Failing if an initialization error is encountered is now the default and should be adopted by all new deployments.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;NVIDIA_DRIVER_ROOT&lt;/code&gt;&lt;/strong&gt;: the root path for the NVIDIA driver installation&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(default &#39;/&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;When the NVIDIA drivers are installed directly on the host, this should be set to &lt;code&gt;&#39;/&#39;&lt;/code&gt;. When installed elsewhere (e.g. via a driver container), this should be set to the root filesystem where the drivers are installed (e.g. &lt;code&gt;&#39;/run/nvidia/driver&#39;&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This option is only necessary when used in conjunction with the &lt;code&gt;$PASS_DEVICE_SPECS&lt;/code&gt; option described below. It tells the plugin what prefix to add to any device file paths passed back as part of the device specs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;PASS_DEVICE_SPECS&lt;/code&gt;&lt;/strong&gt;: pass the paths and desired device node permissions for any NVIDIA devices being allocated to the container&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(default &#39;false&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This option exists for the sole purpose of allowing the device plugin to interoperate with the &lt;code&gt;CPUManager&lt;/code&gt; in Kubernetes. Setting this flag also requires one to deploy the daemonset with elevated privileges, so only do so if you know you need to interoperate with the &lt;code&gt;CPUManager&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;DEVICE_LIST_STRATEGY&lt;/code&gt;&lt;/strong&gt;: the desired strategy for passing the device list to the underlying runtime&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;[envvar | volume-mounts] (default &#39;envvar&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;DEVICE_LIST_STRATEGY&lt;/code&gt; flag allows one to choose which strategy the plugin will use to advertise the list of GPUs allocated to a container. This is traditionally done by setting the &lt;code&gt;NVIDIA_VISIBLE_DEVICES&lt;/code&gt; environment variable as described &lt;a href=&#34;https://github.com/NVIDIA/nvidia-container-runtime#nvidia_visible_devices&#34;&gt;here&lt;/a&gt;. This strategy can be selected via the (default) &lt;code&gt;envvar&lt;/code&gt; option. Support has been added to the &lt;code&gt;nvidia-container-toolkit&lt;/code&gt; to also allow passing the list of devices as a set of volume mounts instead of as an environment variable. This strategy can be selected via the &lt;code&gt;volume-mounts&lt;/code&gt; option. Details for the rationale behind this strategy can be found &lt;a href=&#34;https://docs.google.com/document/d/1uXVF-NWZQXgP1MLb87_kMkQvidpnkNWicdpO2l9g-fw/edit#heading=h.b3ti65rojfy5&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;DEVICE_ID_STRATEGY&lt;/code&gt;&lt;/strong&gt;: the desired strategy for passing device IDs to the underlying runtime&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;[uuid | index] (default &#39;uuid&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;DEVICE_ID_STRATEGY&lt;/code&gt; flag allows one to choose which strategy the plugin will use to pass the device ID of the GPUs allocated to a container. The device ID has traditionally been passed as the UUID of the GPU. This flag lets a user decide if they would like to use the UUID or the index of the GPU (as seen in the output of &lt;code&gt;nvidia-smi&lt;/code&gt;) as the identifier passed to the underlying runtime. Passing the index may be desirable in situations where pods that have been allocated GPUs by the plugin get restarted with different physical GPUs attached to them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;CONFIG_FILE&lt;/code&gt;&lt;/strong&gt;: point the plugin at a configuration file instead of relying on command line flags or environment variables&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(default &#39;&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The order of precedence for setting each option is (1) command line flag, (2) environment variable, (3) configuration file. In this way, one could use a pre-defined configuration file, but then override the values set in it at launch time. As described below, a &lt;code&gt;ConfigMap&lt;/code&gt; can be used to point the plugin at a desired configuration file when deploying via &lt;code&gt;helm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Shared Access to GPUs with CUDA Time-Slicing&lt;/h3&gt; &#xA;&lt;p&gt;The NVIDIA device plugin allows oversubscription of GPUs through a set of extended options in its configuration file. Under the hood, CUDA time-slicing is used to allow workloads that land on oversubscribed GPUs to interleave with one another. However, nothing special is done to isolate workloads that are granted replicas from the same underlying GPU, and each workload has access to the GPU memory and runs in the same fault-domain as of all the others (meaning if one workload crashes, they all do).&lt;/p&gt; &#xA;&lt;p&gt;These extended options can be seen below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;version: v1&#xA;sharing:&#xA;  timeSlicing:&#xA;    renameByDefault: &amp;lt;bool&amp;gt;&#xA;    failRequestsGreaterThanOne: &amp;lt;bool&amp;gt;&#xA;    resources:&#xA;    - name: &amp;lt;resource-name&amp;gt;&#xA;      replicas: &amp;lt;num-replicas&amp;gt;&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is, for each named resource under &lt;code&gt;sharing.timeSlicing.resources&lt;/code&gt;, a number of replicas can now be specified for that resource type. These replicas represent the number of shared accesses that will be granted for a GPU represented by that resource type.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;renameByDefault=true&lt;/code&gt;, then each resource will be advertised under the name &lt;code&gt;&amp;lt;resource-name&amp;gt;.shared&lt;/code&gt; instead of simply &lt;code&gt;&amp;lt;resource-name&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;failRequestsGreaterThanOne=true&lt;/code&gt;, then the plugin will fail to allocate any shared resources to a container if they request more than one. The container‚Äôs pod will fail with an &lt;code&gt;UnexpectedAdmissionError&lt;/code&gt; and need to be manually deleted, updated, and redeployed.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;version: v1&#xA;sharing:&#xA;  timeSlicing:&#xA;    resources:&#xA;    - name: nvidia.com/gpu&#xA;      replicas: 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If this configuration were applied to a node with 8 GPUs on it, the plugin would now advertise 80 &lt;code&gt;nvidia.com/gpu&lt;/code&gt; resources to Kubernetes instead of 8.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl describe node&#xA;...&#xA;Capacity:&#xA;  nvidia.com/gpu: 80&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Likewise, if the following configuration were applied to a node, then 80 &lt;code&gt;nvidia.com/gpu.shared&lt;/code&gt; resources would be advertised to Kubernetes instead of 8 &lt;code&gt;nvidia.com/gpu&lt;/code&gt; resources.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;version: v1&#xA;sharing:&#xA;  timeSlicing:&#xA;    renameByDefault: true&#xA;    resources:&#xA;    - name: nvidia.com/gpu&#xA;      replicas: 10&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl describe node&#xA;...&#xA;Capacity:&#xA;  nvidia.com/gpu.shared: 80&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In both cases, the plugin simply creates 10 references to each GPU and indiscriminately hands them out to anyone that asks for them.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;failRequestsGreaterThanOne=true&lt;/code&gt; were set in either of these configurations and a user requested more than one &lt;code&gt;nvidia.com/gpu&lt;/code&gt; or &lt;code&gt;nvidia.com/gpu.shared&lt;/code&gt; resource in their pod spec, then the container would fail with the resulting error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl describe pod gpu-pod&#xA;...&#xA;Events:&#xA;  Type     Reason                    Age   From               Message&#xA;  ----     ------                    ----  ----               -------&#xA;  Warning  UnexpectedAdmissionError  13s   kubelet            Allocate failed due to rpc error: code = Unknown desc = request for &#39;nvidia.com/gpu: 2&#39; too large: maximum request size for shared resources is 1, which is unexpected&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Unlike with &#34;normal&#34; GPU requests, requesting more than one shared GPU does not imply that you will get guaranteed access to a proportional amount of compute power. It only implies that you will get access to a GPU that is shared by other clients (each of which has the freedom to run as many processes on the underlying GPU as they want). Under the hood CUDA will simply give an equal share of time to all of the GPU processes across all of the clients. The &lt;code&gt;failRequestsGreaterThanOne&lt;/code&gt; flag is meant to help users understand this subtlety, by treating a request of &lt;code&gt;1&lt;/code&gt; as an access request rather than an exclusive resource request. Setting &lt;code&gt;failRequestsGreaterThanOne=true&lt;/code&gt; is recommended, but it is set to &lt;code&gt;false&lt;/code&gt; by default to retain backwards compatibility.&lt;/p&gt; &#xA;&lt;p&gt;As of now, the only supported resource available for time-slicing are &lt;code&gt;nvidia.com/gpu&lt;/code&gt; as well as any of the resource types that emerge from configuring a node with the mixed MIG strategy.&lt;/p&gt; &#xA;&lt;p&gt;For example, the full set of time-sliceable resources on a T4 card would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nvidia.com/gpu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the full set of time-sliceable resources on an A100 40GB card would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nvidia.com/gpu&#xA;nvidia.com/mig-1g.5gb&#xA;nvidia.com/mig-2g.10gb&#xA;nvidia.com/mig-3g.20gb&#xA;nvidia.com/mig-7g.40gb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Likewise, on an A100 80GB card, they would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nvidia.com/gpu&#xA;nvidia.com/mig-1g.10gb&#xA;nvidia.com/mig-2g.20gb&#xA;nvidia.com/mig-3g.40gb&#xA;nvidia.com/mig-7g.80gb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deployment via &lt;code&gt;helm&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The preferred method to deploy the device plugin is as a daemonset using &lt;code&gt;helm&lt;/code&gt;. Instructions for installing &lt;code&gt;helm&lt;/code&gt; can be found &lt;a href=&#34;https://helm.sh/docs/intro/install/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Begin by setting up the plugin&#39;s &lt;code&gt;helm&lt;/code&gt; repository and updating it at follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ helm repo add nvdp https://nvidia.github.io/k8s-device-plugin&#xA;$ helm repo update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then verify that the latest release (&lt;code&gt;v0.14.1&lt;/code&gt;) of the plugin is available:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ helm search repo nvdp --devel&#xA;NAME                     &#x9;  CHART VERSION  APP VERSION&#x9;DESCRIPTION&#xA;nvdp/nvidia-device-plugin&#x9;  0.14.1&#x9; 0.14.1&#x9;&#x9;A Helm chart for ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once this repo is updated, you can begin installing packages from it to deploy the &lt;code&gt;nvidia-device-plugin&lt;/code&gt; helm chart.&lt;/p&gt; &#xA;&lt;p&gt;The most basic installation command without any options is then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;  --namespace nvidia-device-plugin \&#xA;  --create-namespace \&#xA;  --version 0.14.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You only need the to pass the &lt;code&gt;--devel&lt;/code&gt; flag to &lt;code&gt;helm search repo&lt;/code&gt; and the &lt;code&gt;--version&lt;/code&gt; flag to &lt;code&gt;helm upgrade -i&lt;/code&gt; if this is a pre-release version (e.g. &lt;code&gt;&amp;lt;version&amp;gt;-rc.1&lt;/code&gt;). Full releases will be listed without this.&lt;/p&gt; &#xA;&lt;h3&gt;Configuring the device plugin&#39;s &lt;code&gt;helm&lt;/code&gt; chart&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;helm&lt;/code&gt; chart for the latest release of the plugin (&lt;code&gt;v0.14.1&lt;/code&gt;) includes a number of customizable values.&lt;/p&gt; &#xA;&lt;p&gt;Prior to &lt;code&gt;v0.12.0&lt;/code&gt; the most commonly used values were those that had direct mappings to the command line options of the plugin binary. As of &lt;code&gt;v0.12.0&lt;/code&gt;, the preferred method to set these options is via a &lt;code&gt;ConfigMap&lt;/code&gt;. The primary use case of the original values is then to override an option from the &lt;code&gt;ConfigMap&lt;/code&gt; if desired. Both methods are discussed in more detail below.&lt;/p&gt; &#xA;&lt;p&gt;The full set of values that can be set are found here: &lt;a href=&#34;https://github.com/NVIDIA/k8s-device-plugin/raw/v0.14.1/deployments/helm/nvidia-device-plugin/values.yaml&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Passing configuration to the plugin via a &lt;code&gt;ConfigMap&lt;/code&gt;.&lt;/h4&gt; &#xA;&lt;p&gt;In general, we provide a mechanism to pass &lt;em&gt;multiple&lt;/em&gt; configuration files to to the plugin&#39;s &lt;code&gt;helm&lt;/code&gt; chart, with the ability to choose which configuration file should be applied to a node via a node label.&lt;/p&gt; &#xA;&lt;p&gt;In this way, a single chart can be used to deploy each component, but custom configurations can be applied to different nodes throughout the cluster.&lt;/p&gt; &#xA;&lt;p&gt;There are two ways to provide a &lt;code&gt;ConfigMap&lt;/code&gt; for use by the plugin:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Via an external reference to a pre-defined &lt;code&gt;ConfigMap&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;As a set of named config files to build an integrated &lt;code&gt;ConfigMap&lt;/code&gt; associated with the chart&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;These can be set via the chart values &lt;code&gt;config.name&lt;/code&gt; and &lt;code&gt;config.map&lt;/code&gt; respectively. In both cases, the value &lt;code&gt;config.default&lt;/code&gt; can be set to point to one of the named configs in the &lt;code&gt;ConfigMap&lt;/code&gt; and provide a default configuration for nodes that have not been customized via a node label (more on this later).&lt;/p&gt; &#xA;&lt;h5&gt;Single Config File Example&lt;/h5&gt; &#xA;&lt;p&gt;As an example, create a valid config file on your local filesystem, such as the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /tmp/dp-example-config0.yaml&#xA;version: v1&#xA;flags:&#xA;  migStrategy: &#34;none&#34;&#xA;  failOnInitError: true&#xA;  nvidiaDriverRoot: &#34;/&#34;&#xA;  plugin:&#xA;    passDeviceSpecs: false&#xA;    deviceListStrategy: envvar&#xA;    deviceIDStrategy: uuid&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And deploy the device plugin via helm (pointing it at this config file and giving it a name):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set-file config.map.config=/tmp/dp-example-config0.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Under the hood this will deploy a &lt;code&gt;ConfigMap&lt;/code&gt; associated with the plugin and put the contents of the &lt;code&gt;dp-example-config0.yaml&lt;/code&gt; file into it, using the name &lt;code&gt;config&lt;/code&gt; as its key. It will then start the plugin such that this config gets applied when the plugin comes online.&lt;/p&gt; &#xA;&lt;p&gt;If you don‚Äôt want the plugin‚Äôs helm chart to create the &lt;code&gt;ConfigMap&lt;/code&gt; for you, you can also point it at a pre-created &lt;code&gt;ConfigMap&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl create ns nvidia-device-plugin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl create cm -n nvidia-device-plugin nvidia-plugin-configs \&#xA;    --from-file=config=/tmp/dp-example-config0.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set config.name=nvidia-plugin-configs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Multiple Config File Example&lt;/h5&gt; &#xA;&lt;p&gt;For multiple config files, the procedure is similar.&lt;/p&gt; &#xA;&lt;p&gt;Create a second &lt;code&gt;config&lt;/code&gt; file with the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /tmp/dp-example-config1.yaml&#xA;version: v1&#xA;flags:&#xA;  migStrategy: &#34;mixed&#34; # Only change from config0.yaml&#xA;  failOnInitError: true&#xA;  nvidiaDriverRoot: &#34;/&#34;&#xA;  plugin:&#xA;    passDeviceSpecs: false&#xA;    deviceListStrategy: envvar&#xA;    deviceIDStrategy: uuid&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And redeploy the device plugin via helm (pointing it at both configs with a specified default).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set config.default=config0 \&#xA;    --set-file config.map.config0=/tmp/dp-example-config0.yaml \&#xA;    --set-file config.map.config1=/tmp/dp-example-config1.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As before, this can also be done with a pre-created &lt;code&gt;ConfigMap&lt;/code&gt; if desired:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl create ns nvidia-device-plugin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ kubectl create cm -n nvidia-device-plugin nvidia-plugin-configs \&#xA;    --from-file=config0=/tmp/dp-example-config0.yaml \&#xA;    --from-file=config1=/tmp/dp-example-config1.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set config.default=config0 \&#xA;    --set config.name=nvidia-plugin-configs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If the &lt;code&gt;config.default&lt;/code&gt; flag is not explicitly set, then a default value will be inferred from the config if one of the config names is set to &#39;&lt;code&gt;default&lt;/code&gt;&#39;. If neither of these are set, then the deployment will fail unless there is only &lt;strong&gt;&lt;em&gt;one&lt;/em&gt;&lt;/strong&gt; config provided. In the case of just a single config being provided, it will be chosen as the default because there is no other option.&lt;/p&gt; &#xA;&lt;h5&gt;Updating Per-Node Configuration With a Node Label&lt;/h5&gt; &#xA;&lt;p&gt;With this setup, plugins on all nodes will have &lt;code&gt;config0&lt;/code&gt; configured for them by default. However, the following label can be set to change which configuration is applied:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kubectl label nodes &amp;lt;node-name&amp;gt; ‚Äì-overwrite \&#xA;    nvidia.com/device-plugin.config=&amp;lt;config-name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, applying a custom config for all nodes that have T4 GPUs installed on them might be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kubectl label node \&#xA;    --overwrite \&#xA;    --selector=nvidia.com/gpu.product=TESLA-T4 \&#xA;    nvidia.com/device-plugin.config=t4-config&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This label can be applied either &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; the plugin is started to get the desired configuration applied on the node. Anytime it changes value, the plugin will immediately be updated to start serving the desired configuration. If it is set to an unknown value, it will skip reconfiguration. If it is ever unset, it will fallback to the default.&lt;/p&gt; &#xA;&lt;h4&gt;Setting other helm chart values&lt;/h4&gt; &#xA;&lt;p&gt;As mentioned previously, the device plugin&#39;s helm chart continues to provide direct values to set the configuration options of the plugin without using a &lt;code&gt;ConfigMap&lt;/code&gt;. These should only be used to set globally applicable options (which should then never be embedded in the set of config files provided by the &lt;code&gt;ConfigMap&lt;/code&gt;), or used to override these options as desired.&lt;/p&gt; &#xA;&lt;p&gt;These values are as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  migStrategy:&#xA;      the desired strategy for exposing MIG devices on GPUs that support it&#xA;      [none | single | mixed] (default &#34;none&#34;)&#xA;  failOnInitError:&#xA;      fail the plugin if an error is encountered during initialization, otherwise block indefinitely&#xA;      (default &#39;true&#39;)&#xA;  compatWithCPUManager:&#xA;      run with escalated privileges to be compatible with the static CPUManager policy&#xA;      (default &#39;false&#39;)&#xA;  deviceListStrategy:&#xA;      the desired strategy for passing the device list to the underlying runtime&#xA;      [envvar | volume-mounts] (default &#34;envvar&#34;)&#xA;  deviceIDStrategy:&#xA;      the desired strategy for passing device IDs to the underlying runtime&#xA;      [uuid | index] (default &#34;uuid&#34;)&#xA;  nvidiaDriverRoot:&#xA;      the root path for the NVIDIA driver installation (typical values are &#39;/&#39; or &#39;/run/nvidia/driver&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; There is no value that directly maps to the &lt;code&gt;PASS_DEVICE_SPECS&lt;/code&gt; configuration option of the plugin. Instead a value called &lt;code&gt;compatWithCPUManager&lt;/code&gt; is provided which acts as a proxy for this option. It both sets the &lt;code&gt;PASS_DEVICE_SPECS&lt;/code&gt; option of the plugin to true &lt;strong&gt;AND&lt;/strong&gt; makes sure that the plugin is started with elevated privileges to ensure proper compatibility with the &lt;code&gt;CPUManager&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Besides these custom configuration options for the plugin, other standard helm chart values that are commonly overridden are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  legacyDaemonsetAPI:&#xA;      use the legacy daemonset API version &#39;extensions/v1beta1&#39;&#xA;      (default &#39;false&#39;)&#xA;  runtimeClassName:&#xA;      the runtimeClassName to use, for use with clusters that have multiple runtimes. (typical value is &#39;nvidia&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please take a look in the &lt;a href=&#34;https://github.com/NVIDIA/k8s-device-plugin/raw/v0.14.1/deployments/helm/nvidia-device-plugin/values.yaml&#34;&gt;&lt;code&gt;values.yaml&lt;/code&gt;&lt;/a&gt; file to see the full set of overridable parameters for the device plugin.&lt;/p&gt; &#xA;&lt;p&gt;Examples of setting these options include:&lt;/p&gt; &#xA;&lt;p&gt;Enabling compatibility with the &lt;code&gt;CPUManager&lt;/code&gt; and running with a request for 100ms of CPU time and a limit of 512MB of memory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set compatWithCPUManager=true \&#xA;    --set resources.requests.cpu=100m \&#xA;    --set resources.limits.memory=512Mi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the legacy Daemonset API (only available on Kubernetes &amp;lt; &lt;code&gt;v1.16&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set legacyDaemonsetAPI=true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enabling compatibility with the &lt;code&gt;CPUManager&lt;/code&gt; and the &lt;code&gt;mixed&lt;/code&gt; &lt;code&gt;migStrategy&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set compatWithCPUManager=true \&#xA;    --set migStrategy=mixed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Deploying with gpu-feature-discovery for automatic node labels&lt;/h4&gt; &#xA;&lt;p&gt;As of &lt;code&gt;v0.12.0&lt;/code&gt;, the device plugin&#39;s helm chart has integrated support to deploy &lt;a href=&#34;https://github.com/NVIDIA/gpu-feature-discovery&#34;&gt;&lt;code&gt;gpu-feature-discovery&lt;/code&gt;&lt;/a&gt; (GFD) as a subchart. One can use GFD to automatically generate labels for the set of GPUs available on a node. Under the hood, it leverages Node Feature Discovery to perform this labeling.&lt;/p&gt; &#xA;&lt;p&gt;To enable it, simply set &lt;code&gt;gfd.enabled=true&lt;/code&gt; during helm install.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;helm upgrade -i nvdp nvdp/nvidia-device-plugin \&#xA;    --version=0.14.1 \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    --set gfd.enabled=true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Under the hood this will also deploy &lt;a href=&#34;https://github.com/kubernetes-sigs/node-feature-discovery&#34;&gt;&lt;code&gt;node-feature-discovery&lt;/code&gt;&lt;/a&gt; (NFD) since it is a prerequisite of GFD. If you already have NFD deployed on your cluster and do not wish for it to be pulled in by this installation, you can disable it with &lt;code&gt;nfd.enabled=false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the standard node labels applied by GFD, the following label will also be included when deploying the plugin with the time-slicing extensions described &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/#shared-access-to-gpus-with-cuda-time-slicing&#34;&gt;above&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nvidia.com/&amp;lt;resource-name&amp;gt;.replicas = &amp;lt;num-replicas&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, the &lt;code&gt;nvidia.com/&amp;lt;resource-name&amp;gt;.product&lt;/code&gt; will be modified as follows if &lt;code&gt;renameByDefault=false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nvidia.com/&amp;lt;resource-name&amp;gt;.product = &amp;lt;product name&amp;gt;-SHARED&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using these labels, users have a way of selecting a shared vs. non-shared GPU in the same way they would traditionally select one GPU model over another. That is, the &lt;code&gt;SHARED&lt;/code&gt; annotation ensures that a &lt;code&gt;nodeSelector&lt;/code&gt; can be used to attract pods to nodes that have shared GPUs on them.&lt;/p&gt; &#xA;&lt;p&gt;Since having &lt;code&gt;renameByDefault=true&lt;/code&gt; already encodes the fact that the resource is shared on the resource name , there is no need to annotate the product name with &lt;code&gt;SHARED&lt;/code&gt;. Users can already find the shared resources they need by simply requesting it in their pod spec.&lt;/p&gt; &#xA;&lt;p&gt;Note: When running with &lt;code&gt;renameByDefault=false&lt;/code&gt; and &lt;code&gt;migStrategy=single&lt;/code&gt; both the MIG profile name and the new &lt;code&gt;SHARED&lt;/code&gt; annotation will be appended to the product name, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nvidia.com/gpu.product = A100-SXM4-40GB-MIG-1g.5gb-SHARED&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deploying via &lt;code&gt;helm install&lt;/code&gt; with a direct URL to the &lt;code&gt;helm&lt;/code&gt; package&lt;/h3&gt; &#xA;&lt;p&gt;If you prefer not to install from the &lt;code&gt;nvidia-device-plugin&lt;/code&gt; &lt;code&gt;helm&lt;/code&gt; repo, you can run &lt;code&gt;helm install&lt;/code&gt; directly against the tarball of the plugin&#39;s &lt;code&gt;helm&lt;/code&gt; package. The example below installs the same chart as the method above, except that it uses a direct URL to the &lt;code&gt;helm&lt;/code&gt; chart instead of via the &lt;code&gt;helm&lt;/code&gt; repo.&lt;/p&gt; &#xA;&lt;p&gt;Using the default values for the flags:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ helm upgrade -i nvdp \&#xA;    --namespace nvidia-device-plugin \&#xA;    --create-namespace \&#xA;    https://nvidia.github.io/k8s-device-plugin/stable/nvidia-device-plugin-0.14.1.tgz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building and Running Locally&lt;/h2&gt; &#xA;&lt;p&gt;The next sections are focused on building the device plugin locally and running it. It is intended purely for development and testing, and not required by most users. It assumes you are pinning to the latest release tag (i.e. &lt;code&gt;v0.14.1&lt;/code&gt;), but can easily be modified to work with any available tag or branch.&lt;/p&gt; &#xA;&lt;h3&gt;With Docker&lt;/h3&gt; &#xA;&lt;h4&gt;Build&lt;/h4&gt; &#xA;&lt;p&gt;Option 1, pull the prebuilt image from &lt;a href=&#34;https://hub.docker.com/r/nvidia/k8s-device-plugin&#34;&gt;Docker Hub&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker pull nvcr.io/nvidia/k8s-device-plugin:v0.14.1&#xA;$ docker tag nvcr.io/nvidia/k8s-device-plugin:v0.14.1 nvcr.io/nvidia/k8s-device-plugin:devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Option 2, build without cloning the repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker build \&#xA;    -t nvcr.io/nvidia/k8s-device-plugin:devel \&#xA;    -f deployments/container/Dockerfile.ubuntu \&#xA;    https://github.com/NVIDIA/k8s-device-plugin.git#v0.14.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Option 3, if you want to modify the code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git clone https://github.com/NVIDIA/k8s-device-plugin.git &amp;amp;&amp;amp; cd k8s-device-plugin&#xA;$ docker build \&#xA;    -t nvcr.io/nvidia/k8s-device-plugin:devel \&#xA;    -f deployments/container/Dockerfile.ubuntu \&#xA;    .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Run&lt;/h4&gt; &#xA;&lt;p&gt;Without compatibility for the &lt;code&gt;CPUManager&lt;/code&gt; static policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run \&#xA;    -it \&#xA;    --security-opt=no-new-privileges \&#xA;    --cap-drop=ALL \&#xA;    --network=none \&#xA;    -v /var/lib/kubelet/device-plugins:/var/lib/kubelet/device-plugins \&#xA;    nvcr.io/nvidia/k8s-device-plugin:devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With compatibility for the &lt;code&gt;CPUManager&lt;/code&gt; static policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run \&#xA;    -it \&#xA;    --privileged \&#xA;    --network=none \&#xA;    -v /var/lib/kubelet/device-plugins:/var/lib/kubelet/device-plugins \&#xA;    nvcr.io/nvidia/k8s-device-plugin:devel --pass-device-specs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Without Docker&lt;/h3&gt; &#xA;&lt;h4&gt;Build&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ C_INCLUDE_PATH=/usr/local/cuda/include LIBRARY_PATH=/usr/local/cuda/lib64 go build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Run&lt;/h4&gt; &#xA;&lt;p&gt;Without compatibility for the &lt;code&gt;CPUManager&lt;/code&gt; static policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./k8s-device-plugin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With compatibility for the &lt;code&gt;CPUManager&lt;/code&gt; static policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./k8s-device-plugin --pass-device-specs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;h3&gt;Version v0.14.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix parsing of &lt;code&gt;deviceListStrategy&lt;/code&gt; in config file to correctly support strings as well as slices.&lt;/li&gt; &#xA; &lt;li&gt;Update GFD subchart to v0.8.1&lt;/li&gt; &#xA; &lt;li&gt;Bumped CUDA base images version to 12.2.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.14.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Promote v0.14.0-rc.3 to v0.14.0&lt;/li&gt; &#xA; &lt;li&gt;Bumped &lt;code&gt;nvidia-container-toolkit&lt;/code&gt; dependency to latest version for newer CDI spec generation code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.14.0-rc.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Removed &lt;code&gt;--cdi-enabled&lt;/code&gt; config option and instead trigger CDI injection based on &lt;code&gt;cdi-annotation&lt;/code&gt; strategy.&lt;/li&gt; &#xA; &lt;li&gt;Bumped &lt;code&gt;go-nvlib&lt;/code&gt; dependency to latest version for support of new MIG profiles.&lt;/li&gt; &#xA; &lt;li&gt;Added &lt;code&gt;cdi-annotation-prefix&lt;/code&gt; config option to control how CDI annotations are generated.&lt;/li&gt; &#xA; &lt;li&gt;Renamed &lt;code&gt;driver-root-ctr-path&lt;/code&gt; config option added in &lt;code&gt;v0.14.0-rc.1&lt;/code&gt; to &lt;code&gt;container-driver-root&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Updated GFD subchart to version 0.8.0-rc.2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.14.0-rc.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix bug from v0.14.0-rc.1 when using cdi-enabled=false&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.14.0-rc.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added --cdi-enabled flag to GPU Device Plugin. With this enabled, the device plugin will generate CDI specifications for available NVIDIA devices. Allocation will add CDI anntiations (&lt;code&gt;cdi.k8s.io/*&lt;/code&gt;) to the response. These are read by a CDI-enabled runtime to make the required modifications to a container being created.&lt;/li&gt; &#xA; &lt;li&gt;Updated GFD subchart to version 0.8.0-rc.1&lt;/li&gt; &#xA; &lt;li&gt;Bumped Golang version to 1.20.1&lt;/li&gt; &#xA; &lt;li&gt;Bumped CUDA base images version to 12.1.0&lt;/li&gt; &#xA; &lt;li&gt;Switched to klog for logging&lt;/li&gt; &#xA; &lt;li&gt;Added a static deployment file for Microshift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.13.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Promote v0.13.0-rc.3 to v0.13.0&lt;/li&gt; &#xA; &lt;li&gt;Fail on startup if no valid resources are detected&lt;/li&gt; &#xA; &lt;li&gt;Ensure that display adapters are skipped when enumerating devices&lt;/li&gt; &#xA; &lt;li&gt;Bump GFD subchart to version 0.7.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.13.0-rc.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use &lt;code&gt;nodeAffinity&lt;/code&gt; instead of &lt;code&gt;nodeSelector&lt;/code&gt; by default in daemonsets&lt;/li&gt; &#xA; &lt;li&gt;Mount &lt;code&gt;/sys&lt;/code&gt; instead of &lt;code&gt;/sys/class/dmi/id/product_name&lt;/code&gt; in GPU Feature Discovery daemonset&lt;/li&gt; &#xA; &lt;li&gt;Bump GFD subchart to version 0.7.0-rc.3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.13.0-rc.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bump cuda base image to 11.8.0&lt;/li&gt; &#xA; &lt;li&gt;Use consistent indentation in YAML manifests&lt;/li&gt; &#xA; &lt;li&gt;Fix bug from v0.13.0-rc.1 when using mig-strategy=&#34;mixed&#34;&lt;/li&gt; &#xA; &lt;li&gt;Add logged error message if setting up health checks fails&lt;/li&gt; &#xA; &lt;li&gt;Support MIG devices with 1g.10gb+me profile&lt;/li&gt; &#xA; &lt;li&gt;Distribute replicas evenly across GPUs during allocation&lt;/li&gt; &#xA; &lt;li&gt;Bump GFD subchart to version 0.7.0-rc.2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.13.0-rc.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Improve health checks to detect errors when waiting on device events&lt;/li&gt; &#xA; &lt;li&gt;Log ECC error events detected during health check&lt;/li&gt; &#xA; &lt;li&gt;Add the GIT sha to version information for the CLI and container images&lt;/li&gt; &#xA; &lt;li&gt;Use NVML interfaces from go-nvlib to query devices&lt;/li&gt; &#xA; &lt;li&gt;Refactor plugin creation from resources&lt;/li&gt; &#xA; &lt;li&gt;Add a CUDA-based resource manager that can be used to expose integrated devices on Tegra-based systems&lt;/li&gt; &#xA; &lt;li&gt;Bump GFD subchart to version 0.7.0-rc.1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bump cuda base image to 11.7.1&lt;/li&gt; &#xA; &lt;li&gt;Remove CUDA compat libs from the device-plugin image in favor of libs installed by the driver&lt;/li&gt; &#xA; &lt;li&gt;Fix securityContext.capabilities indentation&lt;/li&gt; &#xA; &lt;li&gt;Add namespace override for multi-namespace deployments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add an &#39;empty&#39; config fallback (but don&#39;t apply it by default)&lt;/li&gt; &#xA; &lt;li&gt;Make config fallbacks for config-manager a configurable, ordered list&lt;/li&gt; &#xA; &lt;li&gt;Allow an empty config file and default to &#34;version: v1&#34;&lt;/li&gt; &#xA; &lt;li&gt;Bump GFD subchart to version 0.6.1&lt;/li&gt; &#xA; &lt;li&gt;Move NFD servicAccount info under &#39;master&#39; in helm chart&lt;/li&gt; &#xA; &lt;li&gt;Make priorityClassName configurable through helm&lt;/li&gt; &#xA; &lt;li&gt;Fix assertions for panicking on uniformity with migStrategy=single&lt;/li&gt; &#xA; &lt;li&gt;Fix example configmap settings in values.yaml file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Exit the plugin and GFD sidecar containers on error instead of logging and continuing&lt;/li&gt; &#xA; &lt;li&gt;Only force restart of daemonsets when using config file and allow overrides&lt;/li&gt; &#xA; &lt;li&gt;Fix bug in calculation for GFD security context in helm chart&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Promote v0.12.0-rc.6 to v0.12.0&lt;/li&gt; &#xA; &lt;li&gt;Update README.md with all of the v0.12.0 features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.0-rc.6&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Send SIGHUP from GFD sidecar to GFD main container on config change&lt;/li&gt; &#xA; &lt;li&gt;Reuse main container&#39;s securityContext in sidecar containers&lt;/li&gt; &#xA; &lt;li&gt;Update GFD subchart to v0.6.0-rc.1&lt;/li&gt; &#xA; &lt;li&gt;Bump CUDA base image version to 11.7.0&lt;/li&gt; &#xA; &lt;li&gt;Add a flag called FailRequestsGreaterThanOne for TimeSlicing resources&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.0-rc.5&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Allow either an external ConfigMap name or a set of configs in helm&lt;/li&gt; &#xA; &lt;li&gt;Handle cases where no default config is specified to config-manager&lt;/li&gt; &#xA; &lt;li&gt;Update API used to pass config files to helm to use map instead of list&lt;/li&gt; &#xA; &lt;li&gt;Fix bug that wasn&#39;t properly stopping plugins across a soft restart&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.0-rc.4&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Make GFD and NFD (optional) subcharts of the device plugin&#39;s helm chart&lt;/li&gt; &#xA; &lt;li&gt;Add new config-manager binary to run as sidecar and update the plugin&#39;s configuration via a node label&lt;/li&gt; &#xA; &lt;li&gt;Add support to helm to provide multiple config files for the config map&lt;/li&gt; &#xA; &lt;li&gt;Refactor main to allow configs to be reloaded across a (soft) restart&lt;/li&gt; &#xA; &lt;li&gt;Add field for &lt;code&gt;TimeSlicing.RenameByDefault&lt;/code&gt; to rename all replicated resources to &lt;code&gt;&amp;lt;resource-name&amp;gt;.shared&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Disable support for resource-renaming in the config (will no longer be part of this release)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.0-rc.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add ability to parse Duration fields from config file&lt;/li&gt; &#xA; &lt;li&gt;Omit either the Plugin or GFD flags from the config when not present&lt;/li&gt; &#xA; &lt;li&gt;Fix bug when falling back to none strategy from single strategy&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.0-rc.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Move MigStrategy from Sharing.Mig.Strategy back to Flags.MigStrategy&lt;/li&gt; &#xA; &lt;li&gt;Remove timeSlicing.strategy and any allocation policies built around it&lt;/li&gt; &#xA; &lt;li&gt;Add support for specifying a config file to the helm chart&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.12.0-rc.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add API for specifying time-slicing parameters to support GPU sharing&lt;/li&gt; &#xA; &lt;li&gt;Add API for specifying explicit resource naming in the config file&lt;/li&gt; &#xA; &lt;li&gt;Update config file to be used across plugin and GFD&lt;/li&gt; &#xA; &lt;li&gt;Stop publishing images to dockerhub (now only published to nvcr.io)&lt;/li&gt; &#xA; &lt;li&gt;Add NVIDIA_MIG_MONITOR_DEVICES=all to daemonset envvars when mig mode is enabled&lt;/li&gt; &#xA; &lt;li&gt;Print the plugin configuration at startup&lt;/li&gt; &#xA; &lt;li&gt;Add the ability to load the plugin configuration from a file&lt;/li&gt; &#xA; &lt;li&gt;Remove deprecated tolerations for critical-pod&lt;/li&gt; &#xA; &lt;li&gt;Drop critical-pod annotation(removed from 1.16+) in favor of priorityClassName&lt;/li&gt; &#xA; &lt;li&gt;Pass all parameters as env in helm chart and example daemonset.yamls files for consistency&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.11.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update CUDA base image version to 11.6.0&lt;/li&gt; &#xA; &lt;li&gt;Add support for multi-arch images&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.10.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update CUDA base images to 11.4.2&lt;/li&gt; &#xA; &lt;li&gt;Ignore Xid=13 (Graphics Engine Exception) critical errors in device health-check&lt;/li&gt; &#xA; &lt;li&gt;Ignore Xid=68 (Video processor exception) critical errors in device health-check&lt;/li&gt; &#xA; &lt;li&gt;Build multi-arch container images for linux/amd64 and linux/arm64&lt;/li&gt; &#xA; &lt;li&gt;Use Ubuntu 20.04 for Ubuntu-based container images&lt;/li&gt; &#xA; &lt;li&gt;Remove Centos7 images&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.9.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix bug when using CPUManager and the device plugin MIG mode not set to &#34;none&#34;&lt;/li&gt; &#xA; &lt;li&gt;Allow passing list of GPUs by device index instead of uuid&lt;/li&gt; &#xA; &lt;li&gt;Move to urfave/cli to build the CLI&lt;/li&gt; &#xA; &lt;li&gt;Support setting command line flags via environment variables&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.8.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update all dockerhub references to nvcr.io&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.8.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix permission error when using NewDevice instead of NewDeviceLite when constructing MIG device map&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.8.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Raise an error if a device has migEnabled=true but has no MIG devices&lt;/li&gt; &#xA; &lt;li&gt;Allow mig.strategy=single on nodes with non-MIG gpus&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update vendoring to include bug fix for &lt;code&gt;nvmlEventSetWait_v2&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix bug in dockfiles for ubi8 and centos using CMD not ENTRYPOINT&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update all Dockerfiles to point to latest cuda-base on nvcr.io&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Promote v0.7.0-rc.8 to v0.7.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.8&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Permit configuration of alternative container registry through environment variables.&lt;/li&gt; &#xA; &lt;li&gt;Add an alternate set of gitlab-ci directives under .nvidia-ci.yml&lt;/li&gt; &#xA; &lt;li&gt;Update all k8s dependencies to v1.19.1&lt;/li&gt; &#xA; &lt;li&gt;Update vendoring for NVML Go bindings&lt;/li&gt; &#xA; &lt;li&gt;Move restart loop to force recreate of plugins on SIGHUP&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.7&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix bug which only allowed running the plugin on machines with CUDA 10.2+ installed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.6&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add logic to skip / error out when unsupported MIG device encountered&lt;/li&gt; &#xA; &lt;li&gt;Fix bug treating memory as multiple of 1000 instead of 1024&lt;/li&gt; &#xA; &lt;li&gt;Switch to using CUDA base images&lt;/li&gt; &#xA; &lt;li&gt;Add a set of standard tests to the .gitlab-ci.yml file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.5&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add deviceListStrategyFlag to allow device list passing as volume mounts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.4&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Allow one to override selector.matchLabels in the helm chart&lt;/li&gt; &#xA; &lt;li&gt;Allow one to override the udateStrategy in the helm chart&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fail the plugin if NVML cannot be loaded&lt;/li&gt; &#xA; &lt;li&gt;Update logging to print to stderr on error&lt;/li&gt; &#xA; &lt;li&gt;Add best effort removal of socket file before serving&lt;/li&gt; &#xA; &lt;li&gt;Add logic to implement GetPreferredAllocation() call from kubelet&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add the ability to set &#39;resources&#39; as part of a helm install&lt;/li&gt; &#xA; &lt;li&gt;Add overrides for name and fullname in helm chart&lt;/li&gt; &#xA; &lt;li&gt;Add ability to override image related parameters helm chart&lt;/li&gt; &#xA; &lt;li&gt;Add conditional support for overriding secutiryContext in helm chart&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.7.0-rc.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added &lt;code&gt;migStrategy&lt;/code&gt; as a parameter to select the MIG strategy to the helm chart&lt;/li&gt; &#xA; &lt;li&gt;Add support for MIG with different strategies {none, single, mixed}&lt;/li&gt; &#xA; &lt;li&gt;Update vendored NVML bindings to latest (to include MIG APIs)&lt;/li&gt; &#xA; &lt;li&gt;Add license in UBI image&lt;/li&gt; &#xA; &lt;li&gt;Update UBI image with certification requirements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.6.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update CI, build system, and vendoring mechanism&lt;/li&gt; &#xA; &lt;li&gt;Change versioning scheme to v0.x.x instead of v1.0.0-betax&lt;/li&gt; &#xA; &lt;li&gt;Introduced helm charts as a mechanism to deploy the plugin&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.5.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add a new plugin.yml variant that is compatible with the CPUManager&lt;/li&gt; &#xA; &lt;li&gt;Change CMD in Dockerfile to ENTRYPOINT&lt;/li&gt; &#xA; &lt;li&gt;Add flag to optionally return list of device nodes in Allocate() call&lt;/li&gt; &#xA; &lt;li&gt;Refactor device plugin to eventually handle multiple resource types&lt;/li&gt; &#xA; &lt;li&gt;Move plugin error retry to event loop so we can exit with a signal&lt;/li&gt; &#xA; &lt;li&gt;Update all vendored dependencies to their latest versions&lt;/li&gt; &#xA; &lt;li&gt;Fix bug that was inadvertently &lt;em&gt;always&lt;/em&gt; disabling health checks&lt;/li&gt; &#xA; &lt;li&gt;Update minimal driver version to 384.81&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.4.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixes a bug with a nil pointer dereference around &lt;code&gt;getDevices:CPUAffinity&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.3.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Manifest is updated for Kubernetes 1.16+ (apps/v1)&lt;/li&gt; &#xA; &lt;li&gt;Adds more logging information&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.2.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Adds the Topology field for Kubernetes 1.16+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.1.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If gRPC throws an error, the device plugin no longer ends up in a non responsive state.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v0.0.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Reversioned to SEMVER as device plugins aren&#39;t tied to a specific version of kubernetes anymore.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v1.11&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No change.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v1.10&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The device Plugin API is now v1beta1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version v1.9&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The device Plugin API changed and is no longer compatible with 1.8&lt;/li&gt; &#xA; &lt;li&gt;Error messages were added&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Issues and Contributing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/main/CONTRIBUTING.md&#34;&gt;Checkout the Contributing document!&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can report a bug by &lt;a href=&#34;https://github.com/NVIDIA/k8s-device-plugin/issues/new&#34;&gt;filing a new issue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;You can contribute by opening a &lt;a href=&#34;https://help.github.com/articles/using-pull-requests/&#34;&gt;pull request&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Versioning&lt;/h3&gt; &#xA;&lt;p&gt;Before v1.10 the versioning scheme of the device plugin had to match exactly the version of Kubernetes. After the promotion of device plugins to beta this condition was was no longer required. We quickly noticed that this versioning scheme was very confusing for users as they still expected to see a version of the device plugin for each version of Kubernetes.&lt;/p&gt; &#xA;&lt;p&gt;This versioning scheme applies to the tags &lt;code&gt;v1.8&lt;/code&gt;, &lt;code&gt;v1.9&lt;/code&gt;, &lt;code&gt;v1.10&lt;/code&gt;, &lt;code&gt;v1.11&lt;/code&gt;, &lt;code&gt;v1.12&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We have now changed the versioning to follow &lt;a href=&#34;https://semver.org/&#34;&gt;SEMVER&lt;/a&gt;. The first version following this scheme has been tagged &lt;code&gt;v0.0.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Going forward, the major version of the device plugin will only change following a change in the device plugin API itself. For example, version &lt;code&gt;v1beta1&lt;/code&gt; of the device plugin API corresponds to version &lt;code&gt;v0.x.x&lt;/code&gt; of the device plugin. If a new &lt;code&gt;v2beta2&lt;/code&gt; version of the device plugin API comes out, then the device plugin will increase its major version to &lt;code&gt;1.x.x&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As of now, the device plugin API for Kubernetes &amp;gt;= v1.10 is &lt;code&gt;v1beta1&lt;/code&gt;. If you have a version of Kubernetes &amp;gt;= 1.10 you can deploy any device plugin version &amp;gt; &lt;code&gt;v0.0.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Upgrading Kubernetes with the Device Plugin&lt;/h3&gt; &#xA;&lt;p&gt;Upgrading Kubernetes when you have a device plugin deployed doesn&#39;t require you to do any, particular changes to your workflow. The API is versioned and is pretty stable (though it is not guaranteed to be non breaking). Starting with Kubernetes version 1.10, you can use &lt;code&gt;v0.3.0&lt;/code&gt; of the device plugin to perform upgrades, and Kubernetes won&#39;t require you to deploy a different version of the device plugin. Once a node comes back online after the upgrade, you will see GPUs re-registering themselves automatically.&lt;/p&gt; &#xA;&lt;p&gt;Upgrading the device plugin itself is a more complex task. It is recommended to drain GPU tasks as we cannot guarantee that GPU tasks will survive a rolling upgrade. However we make best efforts to preserve GPU tasks during an upgrade.&lt;/p&gt;</summary>
  </entry>
</feed>