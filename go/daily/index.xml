<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-26T01:31:25Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cloudflare/cfssl</title>
    <updated>2025-04-26T01:31:25Z</updated>
    <id>tag:github.com,2025-04-26:/cloudflare/cfssl</id>
    <link href="https://github.com/cloudflare/cfssl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CFSSL: Cloudflare&#39;s PKI and TLS toolkit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CFSSL&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/cloudflare/cfssl&#34;&gt;&lt;img src=&#34;https://travis-ci.org/cloudflare/cfssl.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://codecov.io/github/cloudflare/cfssl?branch=master&#34;&gt;&lt;img src=&#34;http://codecov.io/github/cloudflare/cfssl/coverage.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/cloudflare/cfssl&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/cloudflare/cfssl?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CloudFlare&#39;s PKI/TLS toolkit&lt;/h2&gt; &#xA;&lt;p&gt;CFSSL is CloudFlare&#39;s PKI/TLS swiss army knife. It is both a command line tool and an HTTP API server for signing, verifying, and bundling TLS certificates. It requires Go 1.20+ to build.&lt;/p&gt; &#xA;&lt;p&gt;Note that certain linux distributions have certain algorithms removed (RHEL-based distributions in particular), so the golang from the official repositories will not work. Users of these distributions should &lt;a href=&#34;https://raw.githubusercontent.com/golang.org/dl&#34;&gt;install go manually&lt;/a&gt; to install CFSSL.&lt;/p&gt; &#xA;&lt;p&gt;CFSSL consists of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a set of packages useful for building custom TLS PKI tools&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;cfssl&lt;/code&gt; program, which is the canonical command line utility using the CFSSL packages.&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;multirootca&lt;/code&gt; program, which is a certificate authority server that can use multiple signing keys.&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;mkbundle&lt;/code&gt; program is used to build certificate pool bundles.&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;cfssljson&lt;/code&gt; program, which takes the JSON output from the &lt;code&gt;cfssl&lt;/code&gt; and &lt;code&gt;multirootca&lt;/code&gt; programs and writes certificates, keys, CSRs, and bundles to disk.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;Building cfssl requires a &lt;a href=&#34;http://golang.org/doc/install&#34;&gt;working Go 1.20+ installation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:cloudflare/cfssl.git&#xA;$ cd cfssl&#xA;$ make&#xA;$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting binaries will be in the bin folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ tree bin&#xA;bin&#xA;├── cfssl&#xA;├── cfssl-bundle&#xA;├── cfssl-certinfo&#xA;├── cfssl-newkey&#xA;├── cfssl-scan&#xA;├── cfssljson&#xA;├── mkbundle&#xA;└── multirootca&#xA;&#xA;0 directories, 8 files&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Cross Compilation&lt;/h4&gt; &#xA;&lt;p&gt;You can set the &lt;code&gt;GOOS&lt;/code&gt; and &lt;code&gt;GOARCH&lt;/code&gt; environment variables to have Go cross compile for alternative platforms; however, cfssl requires cgo, and cgo requires a working compiler toolchain for the target platform.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Installation requires a &lt;a href=&#34;http://golang.org/doc/install&#34;&gt;working Go 1.20+ installation&lt;/a&gt;. Alternatively, &lt;a href=&#34;https://github.com/cloudflare/cfssl/releases&#34;&gt;prebuilt binaries are available&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ go install github.com/cloudflare/cfssl/cmd/...@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will download, build, and install all of the utility programs (including &lt;code&gt;cfssl&lt;/code&gt;, &lt;code&gt;cfssljson&lt;/code&gt;, and &lt;code&gt;mkbundle&lt;/code&gt; among others).&lt;/p&gt; &#xA;&lt;h3&gt;Using the Command Line Tool&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;cfssl&lt;/code&gt; command line tool takes a command to specify what operation it should carry out:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   sign             signs a certificate&#xA;   bundle           build a certificate bundle&#xA;   genkey           generate a private key and a certificate request&#xA;   gencert          generate a private key and a certificate&#xA;   serve            start the API server&#xA;   version          prints out the current version&#xA;   selfsign         generates a self-signed certificate&#xA;   print-defaults   print default configurations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;cfssl [command] -help&lt;/code&gt; to find out more about a command. The &lt;code&gt;version&lt;/code&gt; command takes no arguments.&lt;/p&gt; &#xA;&lt;h4&gt;Signing&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl sign [-ca cert] [-ca-key key] [-hostname comma,separated,hostnames] csr [subject]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;csr&lt;/code&gt; is the client&#39;s certificate request. The &lt;code&gt;-ca&lt;/code&gt; and &lt;code&gt;-ca-key&lt;/code&gt; flags are the CA&#39;s certificate and private key, respectively. By default, they are &lt;code&gt;ca.pem&lt;/code&gt; and &lt;code&gt;ca_key.pem&lt;/code&gt;. The &lt;code&gt;-hostname&lt;/code&gt; is a comma separated hostname list that overrides the DNS names and IP address in the certificate SAN extension. For example, assuming the CA&#39;s private key is in &lt;code&gt;/etc/ssl/private/cfssl_key.pem&lt;/code&gt; and the CA&#39;s certificate is in &lt;code&gt;/etc/ssl/certs/cfssl.pem&lt;/code&gt;, to sign the &lt;code&gt;cloudflare.pem&lt;/code&gt; certificate for cloudflare.com:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl sign -ca     /etc/ssl/certs/cfssl.pem       \&#xA;           -ca-key /etc/ssl/private/cfssl_key.pem \&#xA;           -hostname cloudflare.com               \&#xA;           ./cloudflare.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to specify CSR with the &lt;code&gt;-csr&lt;/code&gt; flag. By doing so, flag values take precedence and will overwrite the argument.&lt;/p&gt; &#xA;&lt;p&gt;The subject is an optional file that contains subject information that should be used in place of the information from the CSR. It should be a JSON file as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;CN&#34;: &#34;example.com&#34;,&#xA;    &#34;names&#34;: [&#xA;        {&#xA;            &#34;C&#34;:  &#34;US&#34;,&#xA;            &#34;L&#34;:  &#34;San Francisco&#34;,&#xA;            &#34;O&#34;:  &#34;Internet Widgets, Inc.&#34;,&#xA;            &#34;OU&#34;: &#34;WWW&#34;,&#xA;            &#34;ST&#34;: &#34;California&#34;&#xA;        }&#xA;    ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; As of Go 1.7, self-signed certificates will not include &lt;a href=&#34;https://go.googlesource.com/go/+/b623b71509b2d24df915d5bc68602e1c6edf38ca&#34;&gt;the AKI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Bundling&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl bundle [-ca-bundle bundle] [-int-bundle bundle] \&#xA;             [-metadata metadata_file] [-flavor bundle_flavor] \&#xA;             -cert certificate_file [-key key_file]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bundles are used for the root and intermediate certificate pools. In addition, platform metadata is specified through &lt;code&gt;-metadata&lt;/code&gt;. The bundle files, metadata file (and auxiliary files) can be found at:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    https://github.com/cloudflare/cfssl_trust&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Specify PEM-encoded client certificate and key through &lt;code&gt;-cert&lt;/code&gt; and &lt;code&gt;-key&lt;/code&gt; respectively. If key is specified, the bundle will be built and verified with the key. Otherwise the bundle will be built without a private key. Instead of file path, use &lt;code&gt;-&lt;/code&gt; for reading certificate PEM from stdin. It is also acceptable that the certificate file should contain a (partial) certificate bundle.&lt;/p&gt; &#xA;&lt;p&gt;Specify bundling flavor through &lt;code&gt;-flavor&lt;/code&gt;. There are three flavors: &lt;code&gt;optimal&lt;/code&gt; to generate a bundle of shortest chain and most advanced cryptographic algorithms, &lt;code&gt;ubiquitous&lt;/code&gt; to generate a bundle of most widely acceptance across different browsers and OS platforms, and &lt;code&gt;force&lt;/code&gt; to find an acceptable bundle which is identical to the content of the input certificate file.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, the client certificate can be pulled directly from a domain. It is also possible to connect to the remote address through &lt;code&gt;-ip&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl bundle [-ca-bundle bundle] [-int-bundle bundle] \&#xA;             [-metadata metadata_file] [-flavor bundle_flavor] \&#xA;             -domain domain_name [-ip ip_address]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bundle output form should follow the example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;bundle&#34;: &#34;CERT_BUNDLE_IN_PEM&#34;,&#xA;    &#34;crt&#34;: &#34;LEAF_CERT_IN_PEM&#34;,&#xA;    &#34;crl_support&#34;: true,&#xA;    &#34;expires&#34;: &#34;2015-12-31T23:59:59Z&#34;,&#xA;    &#34;hostnames&#34;: [&#34;example.com&#34;],&#xA;    &#34;issuer&#34;: &#34;ISSUER CERT SUBJECT&#34;,&#xA;    &#34;key&#34;: &#34;KEY_IN_PEM&#34;,&#xA;    &#34;key_size&#34;: 2048,&#xA;    &#34;key_type&#34;: &#34;2048-bit RSA&#34;,&#xA;    &#34;ocsp&#34;: [&#34;http://ocsp.example-ca.com&#34;],&#xA;    &#34;ocsp_support&#34;: true,&#xA;    &#34;root&#34;: &#34;ROOT_CA_CERT_IN_PEM&#34;,&#xA;    &#34;signature&#34;: &#34;SHA1WithRSA&#34;,&#xA;    &#34;subject&#34;: &#34;LEAF CERT SUBJECT&#34;,&#xA;    &#34;status&#34;: {&#xA;        &#34;rebundled&#34;: false,&#xA;        &#34;expiring_SKIs&#34;: [],&#xA;        &#34;untrusted_root_stores&#34;: [],&#xA;        &#34;messages&#34;: [],&#xA;        &#34;code&#34;: 0&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Generating certificate signing request and private key&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl genkey csr.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate a private key and corresponding certificate request, specify the key request as a JSON file. This file should follow the form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;hosts&#34;: [&#xA;        &#34;example.com&#34;,&#xA;        &#34;www.example.com&#34;,&#xA;        &#34;https://www.example.com&#34;,&#xA;        &#34;jdoe@example.com&#34;,&#xA;        &#34;127.0.0.1&#34;&#xA;    ],&#xA;    &#34;key&#34;: {&#xA;        &#34;algo&#34;: &#34;rsa&#34;,&#xA;        &#34;size&#34;: 2048&#xA;    },&#xA;    &#34;names&#34;: [&#xA;        {&#xA;            &#34;C&#34;:  &#34;US&#34;,&#xA;            &#34;L&#34;:  &#34;San Francisco&#34;,&#xA;            &#34;O&#34;:  &#34;Internet Widgets, Inc.&#34;,&#xA;            &#34;OU&#34;: &#34;WWW&#34;,&#xA;            &#34;ST&#34;: &#34;California&#34;&#xA;        }&#xA;    ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Generating self-signed root CA certificate and private key&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl genkey -initca csr.json | cfssljson -bare ca&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate a self-signed root CA certificate, specify the key request as a JSON file in the same format as in &#39;genkey&#39;. Three PEM-encoded entities will appear in the output: the private key, the csr, and the self-signed certificate.&lt;/p&gt; &#xA;&lt;h4&gt;Generating a remote-issued certificate and private key.&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl gencert -remote=remote_server [-hostname=comma,separated,hostnames] csr.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This calls &lt;code&gt;genkey&lt;/code&gt; but has a remote CFSSL server sign and issue the certificate. You may use &lt;code&gt;-hostname&lt;/code&gt; to override certificate SANs.&lt;/p&gt; &#xA;&lt;h4&gt;Generating a local-issued certificate and private key.&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl gencert -ca cert -ca-key key [-hostname=comma,separated,hostnames] csr.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This generates and issues a certificate and private key from a local CA via a JSON request. You may use &lt;code&gt;-hostname&lt;/code&gt; to override certificate SANs.&lt;/p&gt; &#xA;&lt;h4&gt;Updating an OCSP responses file with a newly issued certificate&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl ocspsign -ca cert -responder key -responder-key key -cert cert \&#xA; | cfssljson -bare -stdout &amp;gt;&amp;gt; responses&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate an OCSP response for the &lt;code&gt;cert&lt;/code&gt; and add it to the &lt;code&gt;responses&lt;/code&gt; file. You can then pass &lt;code&gt;responses&lt;/code&gt; to &lt;code&gt;ocspserve&lt;/code&gt; to start an OCSP server.&lt;/p&gt; &#xA;&lt;h3&gt;Starting the API Server&lt;/h3&gt; &#xA;&lt;p&gt;CFSSL comes with an HTTP-based API server; the endpoints are documented in &lt;a href=&#34;https://raw.githubusercontent.com/cloudflare/cfssl/master/doc/api/intro.txt&#34;&gt;&lt;code&gt;doc/api/intro.txt&lt;/code&gt;&lt;/a&gt;. The server is started with the &lt;code&gt;serve&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl serve [-address address] [-ca cert] [-ca-bundle bundle] \&#xA;            [-ca-key key] [-int-bundle bundle] [-int-dir dir] [-port port] \&#xA;            [-metadata file] [-remote remote_host] [-config config] \&#xA;            [-responder cert] [-responder-key key] [-db-config db-config]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Address and port default to &#34;127.0.0.1:8888&#34;. The &lt;code&gt;-ca&lt;/code&gt; and &lt;code&gt;-ca-key&lt;/code&gt; arguments should be the PEM-encoded certificate and private key to use for signing; by default, they are &lt;code&gt;ca.pem&lt;/code&gt; and &lt;code&gt;ca_key.pem&lt;/code&gt;. The &lt;code&gt;-ca-bundle&lt;/code&gt; and &lt;code&gt;-int-bundle&lt;/code&gt; should be the certificate bundles used for the root and intermediate certificate pools, respectively. These default to &lt;code&gt;ca-bundle.crt&lt;/code&gt; and &lt;code&gt;int-bundle.crt&lt;/code&gt; respectively. If the &lt;code&gt;-remote&lt;/code&gt; option is specified, all signature operations will be forwarded to the remote CFSSL.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-int-dir&lt;/code&gt; specifies an intermediates directory. &lt;code&gt;-metadata&lt;/code&gt; is a file for root certificate presence. The content of the file is a json dictionary (k,v) such that each key k is an SHA-1 digest of a root certificate while value v is a list of key store filenames. &lt;code&gt;-config&lt;/code&gt; specifies a path to a configuration file. &lt;code&gt;-responder&lt;/code&gt; and &lt;code&gt;-responder-key&lt;/code&gt; are the certificate and the private key for the OCSP responder, respectively.&lt;/p&gt; &#xA;&lt;p&gt;The amount of logging can be controlled with the &lt;code&gt;-loglevel&lt;/code&gt; option. This comes &lt;em&gt;after&lt;/em&gt; the serve command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cfssl serve -loglevel 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The levels are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;0 - DEBUG&lt;/li&gt; &#xA; &lt;li&gt;1 - INFO (this is the default level)&lt;/li&gt; &#xA; &lt;li&gt;2 - WARNING&lt;/li&gt; &#xA; &lt;li&gt;3 - ERROR&lt;/li&gt; &#xA; &lt;li&gt;4 - CRITICAL&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The multirootca&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;cfssl&lt;/code&gt; program can act as an online certificate authority, but it only uses a single key. If multiple signing keys are needed, the &lt;code&gt;multirootca&lt;/code&gt; program can be used. It only provides the &lt;code&gt;sign&lt;/code&gt;, &lt;code&gt;authsign&lt;/code&gt; and &lt;code&gt;info&lt;/code&gt; endpoints. The documentation contains instructions for configuring and running the CA.&lt;/p&gt; &#xA;&lt;h3&gt;The mkbundle Utility&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;mkbundle&lt;/code&gt; is used to build the root and intermediate bundles used in verifying certificates. It can be installed with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get github.com/cloudflare/cfssl/cmd/mkbundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It takes a collection of certificates, checks for CRL revocation (OCSP support is planned for the next release) and expired certificates, and bundles them into one file. It takes directories of certificates and certificate files (which may contain multiple certificates). For example, if the directory &lt;code&gt;intermediates&lt;/code&gt; contains a number of intermediate certificates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkbundle -f int-bundle.crt intermediates&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will check those certificates and combine valid certificates into a single &lt;code&gt;int-bundle.crt&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;-f&lt;/code&gt; flag specifies an output name; &lt;code&gt;-loglevel&lt;/code&gt; specifies the verbosity of the logging (using the same loglevels as above), and &lt;code&gt;-nw&lt;/code&gt; controls the number of revocation-checking workers.&lt;/p&gt; &#xA;&lt;h3&gt;The cfssljson Utility&lt;/h3&gt; &#xA;&lt;p&gt;Most of the output from &lt;code&gt;cfssl&lt;/code&gt; is in JSON. The &lt;code&gt;cfssljson&lt;/code&gt; utility can take this output and split it out into separate &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;certificate&lt;/code&gt;, &lt;code&gt;CSR&lt;/code&gt;, and &lt;code&gt;bundle&lt;/code&gt; files as appropriate. The tool takes a single flag, &lt;code&gt;-f&lt;/code&gt;, that specifies the input file, and an argument that specifies the base name for the files produced. If the input filename is &lt;code&gt;-&lt;/code&gt; (which is the default), cfssljson reads from standard input. It maps keys in the JSON file to filenames in the following way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;if &lt;strong&gt;cert&lt;/strong&gt; or &lt;strong&gt;certificate&lt;/strong&gt; is specified, &lt;strong&gt;basename.pem&lt;/strong&gt; will be produced.&lt;/li&gt; &#xA; &lt;li&gt;if &lt;strong&gt;key&lt;/strong&gt; or &lt;strong&gt;private_key&lt;/strong&gt; is specified, &lt;strong&gt;basename-key.pem&lt;/strong&gt; will be produced.&lt;/li&gt; &#xA; &lt;li&gt;if &lt;strong&gt;csr&lt;/strong&gt; or &lt;strong&gt;certificate_request&lt;/strong&gt; is specified, &lt;strong&gt;basename.csr&lt;/strong&gt; will be produced.&lt;/li&gt; &#xA; &lt;li&gt;if &lt;strong&gt;bundle&lt;/strong&gt; is specified, &lt;strong&gt;basename-bundle.pem&lt;/strong&gt; will be produced.&lt;/li&gt; &#xA; &lt;li&gt;if &lt;strong&gt;ocspResponse&lt;/strong&gt; is specified, &lt;strong&gt;basename-response.der&lt;/strong&gt; will be produced.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Instead of saving to a file, you can pass &lt;code&gt;-stdout&lt;/code&gt; to output the encoded contents to standard output.&lt;/p&gt; &#xA;&lt;h3&gt;Static Builds&lt;/h3&gt; &#xA;&lt;p&gt;By default, the web assets are accessed from disk, based on their relative locations. If you wish to distribute a single, statically-linked, &lt;code&gt;cfssl&lt;/code&gt; binary, you’ll want to embed these resources before building. This can by done with the &lt;a href=&#34;https://github.com/GeertJohan/go.rice&#34;&gt;go.rice&lt;/a&gt; tool.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pushd cli/serve &amp;amp;&amp;amp; rice embed-go &amp;amp;&amp;amp; popd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then building with &lt;code&gt;go build&lt;/code&gt; will use the embedded resources.&lt;/p&gt; &#xA;&lt;h3&gt;Additional Documentation&lt;/h3&gt; &#xA;&lt;p&gt;Additional documentation can be found in the &#34;doc&#34; directory:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cloudflare/cfssl/master/doc/api/intro.txt&#34;&gt;doc/api/intro.txt&lt;/a&gt;: documents the API endpoints&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>