<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-06T01:34:10Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ansible-semaphore/semaphore</title>
    <updated>2023-05-06T01:34:10Z</updated>
    <id>tag:github.com,2023-05-06:/ansible-semaphore/semaphore</id>
    <link href="https://github.com/ansible-semaphore/semaphore" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern UI for Ansible&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ansible Semaphore&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitter.com/semaphoreui&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/semaphoreui?style=social&amp;amp;logo=twitter&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://snapcraft.io/semaphore&#34;&gt;&lt;img src=&#34;https://snapcraft.io/semaphore/badge.svg?sanitize=true&#34; alt=&#34;semaphore&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stackshare.io/ansible-semaphore&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/tech-stack-008ff9&#34; alt=&#34;StackShare&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/AnsibleSemaphore/semaphore?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://img.shields.io/gitter/room/AnsibleSemaphore/semaphore?logo=gitter&#34; alt=&#34;Join the chat at https://gitter.im/AnsibleSemaphore/semaphore&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- [![Release](https://img.shields.io/github/v/release/ansible-semaphore/semaphore.svg)](https://stackshare.io/ansible-semaphore) --&gt; &#xA;&lt;!-- [![Godoc Reference](https://pkg.go.dev/badge/github.com/ansible-semaphore/semaphore?utm_source=godoc)](https://godoc.org/github.com/ansible-semaphore/semaphore) --&gt; &#xA;&lt;!-- [![Codacy Badge](https://api.codacy.com/project/badge/Grade/89e0129c6ba64fe2b1ebe983f72a4eff)](https://www.codacy.com/app/ansible-semaphore/semaphore?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=ansible-semaphore/semaphore&amp;amp;utm_campaign=Badge_Grade)&#xA;[![Codacy Badge](https://api.codacy.com/project/badge/Coverage/89e0129c6ba64fe2b1ebe983f72a4eff)](https://www.codacy.com/app/ansible-semaphore/semaphore?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=ansible-semaphore/semaphore&amp;utm_campaign=Badge_Coverage) --&gt; &#xA;&lt;p&gt;Ansible Semaphore is a modern UI for Ansible. It lets you easily run Ansible playbooks, get notifications about fails, control access to deployment system.&lt;/p&gt; &#xA;&lt;p&gt;If your project has grown and deploying from the terminal is no longer for you then Ansible Semaphore is what you need.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/914224/134777345-8789d9e4-ff0d-439c-b80e-ddc56b74fcee.png&#34; alt=&#34;responsive-ui-phone1&#34;&gt;&lt;/p&gt; &#xA;&lt;!--&#xA;![image](https://user-images.githubusercontent.com/914224/134411082-48235676-06d2-4d4b-b674-4ffe1e8d0d0d.png)&#xA;&#xA;![semaphore](https://user-images.githubusercontent.com/914224/125253358-c214ed80-e312-11eb-952e-d96a1eba93f6.png)&#xA;--&gt; &#xA;&lt;!--&#xA;- [Releases](https://github.com/ansible-semaphore/semaphore/releases)&#xA;- [Installation](https://docs.ansible-semaphore.com/administration-guide/installation)&#xA;- [Docker Hub](https://hub.docker.com/r/semaphoreui/semaphore/)&#xA;- [Contribution](https://github.com/ansible-semaphore/semaphore/blob/develop/CONTRIBUTING.md)&#xA;- [Troubleshooting](https://github.com/ansible-semaphore/semaphore/wiki/Troubleshooting)&#xA;- [Roadmap](https://github.com/ansible-semaphore/semaphore/projects)&#xA;- [UI Walkthrough](https://blog.strangeman.info/ansible/2017/08/05/semaphore-ui-guide.html) (external blog)&#xA;--&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Full documentation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.ansible-semaphore.com/administration-guide/installation&#34;&gt;https://docs.ansible-semaphore.com/administration-guide/installation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Snap&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo snap install semaphore&#xA;sudo semaphore user add --admin --name &#34;Your Name&#34; --login your_login --email your-email@examaple.com --password your_password&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://snapcraft.io/semaphore&#34;&gt;&lt;img src=&#34;https://snapcraft.io/static/images/badges/en/snap-store-black.svg?sanitize=true&#34; alt=&#34;Get it from the Snap Store&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; for minimal configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;services:&#xA;  semaphore:&#xA;    ports:&#xA;      - 3000:3000&#xA;    image: semaphoreui/semaphore:latest&#xA;    environment:&#xA;      SEMAPHORE_DB_DIALECT: bolt&#xA;      SEMAPHORE_ADMIN_PASSWORD: changeme&#xA;      SEMAPHORE_ADMIN_NAME: admin&#xA;      SEMAPHORE_ADMIN_EMAIL: admin@localhost&#xA;      SEMAPHORE_ADMIN: admin&#xA;    volumes:&#xA;      - /path/to/data/home:/etc/semaphore # config.json location&#xA;      - /path/to/data/lib:/var/lib/semaphore # database.boltdb location (Not required if using mysql or postgres)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/semaphoreui/semaphore&#34;&gt;https://hub.docker.com/r/semaphoreui/semaphore&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;You can test latest version of Semaphore on &lt;a href=&#34;https://demo.ansible-semaphore.com&#34;&gt;https://demo.ansible-semaphore.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Docs&lt;/h2&gt; &#xA;&lt;p&gt;Admin and user docs: &lt;a href=&#34;https://docs.ansible-semaphore.com&#34;&gt;https://docs.ansible-semaphore.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;API description: &lt;a href=&#34;https://ansible-semaphore.com/api-docs/&#34;&gt;https://ansible-semaphore.com/api-docs/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;PR&#39;s &amp;amp; UX reviews are welcome!&lt;/p&gt; &#xA;&lt;p&gt;Please follow the &lt;a href=&#34;https://github.com/ansible-semaphore/semaphore/raw/develop/CONTRIBUTING.md&#34;&gt;contribution&lt;/a&gt; guide. Any questions, please open an issue.&lt;/p&gt; &#xA;&lt;h2&gt;Release Signing&lt;/h2&gt; &#xA;&lt;p&gt;All releases after 2.5.1 are signed with the gpg public key &lt;code&gt;8CDE D132 5E96 F1D9 EABF 17D4 2C96 CF7D D27F AB82&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;If you like Ansible Semaphore, you can support the project development on &lt;a href=&#34;https://ko-fi.com/fiftin&#34;&gt;Ko-fi&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ko-fi.com/fiftin&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/914224/203517453-4febf7f6-debb-4be9-b6a2-a3b19f5d9f9a.png&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT License&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2016 Castaway Consulting LLC&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>umputun/spot</title>
    <updated>2023-05-06T01:34:10Z</updated>
    <id>tag:github.com,2023-05-06:/umputun/spot</id>
    <link href="https://github.com/umputun/spot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A user-friendly and efficient tool for the effortless deployment and configuration of resources on remote machines.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Spot&lt;/h1&gt; &#xA;&lt;p&gt;Spot (aka &lt;code&gt;simplotask&lt;/code&gt;) is a powerful and easy-to-use tool for effortless deployment and configuration management. It allows users to define a playbook with the list of tasks and targets, where each task consists of a series of commands that can be executed on remote hosts concurrently. Spot supports running scripts, copying files, syncing directories, and deleting files or directories, as well as custom inventory files or inventory URLs.&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img class=&#34;logo&#34; src=&#34;https://github.com/umputun/simplotask/raw/master/site/spot-bg.png&#34; width=&#34;400px&#34; alt=&#34;Spot | Effortless Deployment&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Define tasks with a list of commands and the list of target hosts.&lt;/li&gt; &#xA; &lt;li&gt;Support for remote hosts specified directly or through inventory files/URLs.&lt;/li&gt; &#xA; &lt;li&gt;Everything can be defined in a simple YAML or TOML file.&lt;/li&gt; &#xA; &lt;li&gt;Run scripts on remote hosts as well as on the localhost.&lt;/li&gt; &#xA; &lt;li&gt;Built-in commands: copy, sync, delete and wait.&lt;/li&gt; &#xA; &lt;li&gt;Concurrent execution of task on multiple hosts.&lt;/li&gt; &#xA; &lt;li&gt;Ability to wait for a specific condition before executing the next command.&lt;/li&gt; &#xA; &lt;li&gt;Customizable environment variables.&lt;/li&gt; &#xA; &lt;li&gt;Ability to override list of destination hosts, ssh username and ssh key file.&lt;/li&gt; &#xA; &lt;li&gt;Skip or execute only specific commands.&lt;/li&gt; &#xA; &lt;li&gt;Catch errors and execute a command hook on the local host.&lt;/li&gt; &#xA; &lt;li&gt;Debug mode to print out the commands to be executed, output of the commands, and all the other details.&lt;/li&gt; &#xA; &lt;li&gt;Dry-run mode to print out the commands to be executed without actually executing them.&lt;/li&gt; &#xA; &lt;li&gt;Ad-hoc mode to execute a single command on a list of hosts.&lt;/li&gt; &#xA; &lt;li&gt;A single binary with no dependencies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/umputun/spot/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/umputun/spot/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://coveralls.io/github/umputun/spot?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/umputun/spot/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://goreportcard.com/report/github.com/umputun/spot&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/umputun/spot&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://pkg.go.dev/github.com/umputun/spot&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/umputun/spot.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://github.com/umputun/spot/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/umputun/spot.svg?sanitize=true&#34; alt=&#34;GitHub release&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install Spot by download the latest release from the &lt;a href=&#34;https://github.com/umputun/spot/releases&#34;&gt;Releases&lt;/a&gt; page.&lt;/li&gt; &#xA; &lt;li&gt;Create a configuration file, as shown in the &lt;a href=&#34;https://raw.githubusercontent.com/umputun/spot/master/#full-playbook-example&#34;&gt;example below&lt;/a&gt;, and save it as &lt;code&gt;spot.yml&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run Spot using the following command: &lt;code&gt;spot&lt;/code&gt;. This will execute all the tasks defined in the default &lt;code&gt;spot.yml&lt;/code&gt; file for the &lt;code&gt;default&lt;/code&gt; target with a concurrency of 1.&lt;/li&gt; &#xA; &lt;li&gt;To execute a specific task, use the &lt;code&gt;--task&lt;/code&gt; flag: &lt;code&gt;spot --task=deploy-things&lt;/code&gt;. This will execute only the &lt;code&gt;deploy-things&lt;/code&gt; task.&lt;/li&gt; &#xA; &lt;li&gt;To execute a specific task for a specific target, use the &lt;code&gt;--task&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; flags: &lt;code&gt;spot --task=deploy-things -t prod&lt;/code&gt;. This will execute only the &lt;code&gt;deploy-things&lt;/code&gt; task for the &lt;code&gt;prod&lt;/code&gt; target.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details markdown&gt; &#xA; &lt;summary&gt;Screenshots&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;spot&lt;/code&gt; with playbook &lt;code&gt;spot.yml&lt;/code&gt;: &lt;code&gt;spot -p spot.yml -t prod&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/umputun/spot/raw/master/site/docs/screen-playbook.jpg&#34; alt=&#34;spot-playbook&#34;&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;spot&lt;/code&gt; with the same playbook in dry mode: &lt;code&gt;spot -p spot.yml -t prod -v&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/umputun/spot/raw/master/site/docs/screen-playbook-dry.jpg&#34; alt=&#34;spot-playbook-dry&#34;&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;spot&lt;/code&gt; ad-hoc command on given hosts: &lt;code&gt;spot &#34;ls -la /tmp -t dev1.umputun.com -t dev2.umputun.com&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/umputun/spot/raw/master/site/docs/screen-adhoc.jpg&#34; alt=&#34;spot-adhoc&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;p&gt;Spot supports the following command-line options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-p&lt;/code&gt;, &lt;code&gt;--playbook=&lt;/code&gt;: Specifies the playbook file to be used. Defaults to &lt;code&gt;spot.yml&lt;/code&gt;. You can also set the environment variable &lt;code&gt;$SPOT_PLAYBOOK&lt;/code&gt; to define the playbook file path.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--task=&lt;/code&gt;: Specifies the task name to execute. The task should be defined in the playbook file. If not specified all the tasks will be executed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;--target=&lt;/code&gt;: Specifies the target name to use for the task execution. The target should be defined in the playbook file and can represent remote hosts, inventory files, or inventory URLs. If not specified the &lt;code&gt;default&lt;/code&gt; target will be used. User can pass a host name, group name, tag or IP instead of the target name for a quick override. Providing the &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;--target&lt;/code&gt; flag multiple times with different targets sets multiple destination targets or multiple hosts, e.g., &lt;code&gt;-t prod -t dev&lt;/code&gt; or &lt;code&gt;-t example1.com -t example2.com&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;--concurrent=&lt;/code&gt;: Sets the number of concurrent hosts to execute tasks. Defaults to &lt;code&gt;1&lt;/code&gt;, which means hosts will be handled sequentially.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--timeout&lt;/code&gt;: Sets the SSH timeout. Defaults to &lt;code&gt;30s&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-i&lt;/code&gt;, &lt;code&gt;--inventory=&lt;/code&gt;: Specifies the inventory file or url to use for the task execution. Overrides the inventory file defined in the playbook file. User can also set the environment variable &lt;code&gt;$SPOT_INVENTORY&lt;/code&gt; to define the default inventory file path or url.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-u&lt;/code&gt;, &lt;code&gt;--user=&lt;/code&gt;: Specifies the SSH user to use when connecting to remote hosts. Overrides the user defined in the playbook file .&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-k&lt;/code&gt;, &lt;code&gt;--key=&lt;/code&gt;: Specifies the SSH key to use when connecting to remote hosts. Overrides the key defined in the playbook file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;--skip=&lt;/code&gt;: Skips the specified commands during the task execution. Providing the &lt;code&gt;-s&lt;/code&gt; flag multiple times with different command names skips multiple commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;--only=&lt;/code&gt;: Runs only the specified commands during the task execution. Providing the &lt;code&gt;-o&lt;/code&gt; flag multiple times with different command names runs only multiple commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;--env=&lt;/code&gt;: Sets the environment variables to be used during the task execution. Providing the &lt;code&gt;-e&lt;/code&gt; flag multiple times with different environment variables sets multiple environment variables, e.g., &lt;code&gt;-e VAR1=VALUE1 -e VAR2=VALUE2&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--dry&lt;/code&gt;: Enables dry-run mode, which prints out the commands to be executed without actually executing them.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;--verbose&lt;/code&gt;: Enables verbose mode, providing more detailed output and error messages during the task execution.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--dbg&lt;/code&gt;: Enables debug mode, providing even more detailed output and error messages during the task execution as well as diagnostic messages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-h&lt;/code&gt; &lt;code&gt;--help&lt;/code&gt;: Displays the help message, listing all available command-line options.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Full playbook example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;user: umputun                       # default ssh user. Can be overridden by -u flag or by inventory or host definition&#xA;ssh_key: keys/id_rsa                # ssh key&#xA;inventory: /etc/spot/inventory.yml  # default inventory file. Can be overridden by --inventory flag&#xA;&#xA;# list of targets, i.e. hosts, inventory files or inventory URLs&#xA;targets:&#xA;  prod:&#xA;    hosts: # list of hosts, user, name and port optional. &#xA;      - {host: &#34;h1.example.com&#34;, user: &#34;user2&#34;, name: &#34;h1&#34;}&#xA;      - {host: &#34;h2.example.com&#34;, port: 2222}&#xA;  staging:&#xA;    groups: [&#34;dev&#34;, &#34;staging&#34;] # list of groups from inventory file&#xA;  dev:&#xA;    names: [&#34;devbox1&#34;, &#34;devbox2&#34;] # list of server names from inventory file&#xA;  all:&#xA;    groups: [&#34;all&#34;] # all hosts from all groups from inventory file&#xA;&#xA;# list of tasks, i.e. commands to execute&#xA;tasks:&#xA;  - name: deploy-things&#xA;    on_error: &#34;curl -s localhost:8080/error?msg={SPOT_ERROR}&#34; # call hook on error&#xA;    commands:&#xA;      - name: wait&#xA;        script: sleep 5s&#xA;      &#xA;      - name: copy configuration&#xA;        copy: {&#34;src&#34;: &#34;testdata/conf.yml&#34;, &#34;dst&#34;: &#34;/tmp/conf.yml&#34;, &#34;mkdir&#34;: true}&#xA;&#xA;      - name: copy other files&#xA;        copy:&#xA;          - {&#34;src&#34;: &#34;testdata/f1.csv&#34;, &#34;dst&#34;: &#34;/tmp/things/f1.csv&#34;, &#34;recur&#34;: true}&#xA;          - {&#34;src&#34;: &#34;testdata/f2.csv&#34;, &#34;dst&#34;: &#34;/tmp/things/f2.csv&#34;, &#34;recur&#34;: true}&#xA;&#xA;      - name: sync things&#xA;        sync: {&#34;src&#34;: &#34;testdata&#34;, &#34;dst&#34;: &#34;/tmp/things&#34;}&#xA;      &#xA;      - name: some command&#xA;        script: |&#xA;          ls -laR /tmp&#xA;          du -hcs /srv&#xA;          cat /tmp/conf.yml&#xA;          echo all good, 123&#xA;      &#xA;      - name: delete things&#xA;        delete: {&#34;path&#34;: &#34;/tmp/things&#34;, &#34;recur&#34;: true}&#xA;      &#xA;      - name: show content&#xA;        script: ls -laR /tmp&#xA;&#xA;  - name: docker&#xA;    commands:&#xA;      - name: docker pull and start&#xA;        script: |&#xA;          docker pull umputun/remark42:latest&#xA;          docker stop remark42 || true&#xA;          docker rm remark42 || true&#xA;          docker run -d --name remark42 -p 8080:8080 umputun/remark42:latest&#xA;        env: {FOO: bar, BAR: qux} # set environment variables for the command&#xA;      - wait: {cmd: &#34;curl -s localhost:8080/health&#34;, timeout: &#34;10s&#34;, interval: &#34;1s&#34;} # wait for health check to pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Alternatively, the playbook can be represented using the TOML format.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Simplified playbook example&lt;/h2&gt; &#xA;&lt;p&gt;In some cases the rich syntax of the full playbook is not needed and can felt over-engineered and even overwhelming. For those situations, Spot supports a simplified playbook format, which is easier to read and write, but also more limited in its capabilities.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;user: umputun                       # default ssh user. Can be overridden by -u flag or by inventory or host definition&#xA;ssh_key: keys/id_rsa                # ssh key&#xA;inventory: /etc/spot/inventory.yml  # default inventory file. Can be overridden by --inventory flag&#xA;&#xA;target: [&#34;devbox1&#34;, &#34;devbox2&#34;, &#34;h1.example.com:2222&#34;, &#34;h2.example.com&#34;] # list of host names from inventory and direct host ips&#xA;&#xA;# the actual list of commands to execute&#xA;task:&#xA;  - name: wait&#xA;    script: sleep 5s&#xA;  &#xA;  - name: copy configuration&#xA;    copy: {&#34;src&#34;: &#34;testdata/conf.yml&#34;, &#34;dst&#34;: &#34;/tmp/conf.yml&#34;, &#34;mkdir&#34;: true}&#xA;  &#xA;  - name: copy other files&#xA;    copy: &#xA;      - {&#34;src&#34;: &#34;testdata/f1.csv&#34;, &#34;dst&#34;: &#34;/tmp/things/f1.csv&#34;, &#34;recur&#34;: true}&#xA;      - {&#34;src&#34;: &#34;testdata/f2.csv&#34;, &#34;dst&#34;: &#34;/tmp/things/f2.csv&#34;, &#34;recur&#34;: true}&#xA;  &#xA;  - name: sync things&#xA;    sync: {&#34;src&#34;: &#34;testdata&#34;, &#34;dst&#34;: &#34;/tmp/things&#34;}&#xA;  &#xA;  - name: some command&#xA;    script: |&#xA;      ls -laR /tmp&#xA;      du -hcs /srv&#xA;      cat /tmp/conf.yml&#xA;      echo all good, 123&#xA;  &#xA;  - name: delete things&#xA;    delete: {&#34;path&#34;: &#34;/tmp/things&#34;, &#34;recur&#34;: true}&#xA;  &#xA;  - name: show content&#xA;    script: ls -laR /tmp&#xA;&#xA;  - name: docker pull and start&#xA;    script: |&#xA;      docker pull umputun/remark42:latest&#xA;      docker stop remark42 || true&#xA;      docker rm remark42 || true&#xA;      docker run -d --name remark42 -p 8080:8080 umputun/remark42:latest&#xA;    env: {FOO: bar, BAR: qux} # set environment variables for the command&#xA;    &#xA;  - wait: {cmd: &#34;curl -s localhost:8080/health&#34;, timeout: &#34;10s&#34;, interval: &#34;1s&#34;} # wait for health check to pass&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Playbook Types&lt;/h2&gt; &#xA;&lt;p&gt;Spot supports two types of playbooks: full and simplified. Both can be represented in either YAML or TOML format. The full playbook is more powerful and flexible but also more verbose and complex. The simplified playbook, on the other hand, is easier to read and write but has more limited capabilities.&lt;/p&gt; &#xA;&lt;p&gt;Here are the main differences between the two types of playbooks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The full playbook supports multiple target sets, while the simplified playbook only supports a single target set. In other words, the full playbook can execute the same set of commands on multiple environments, with each environment defined as a separate target set. The simplified playbook can execute the same set of commands on just one environment.&lt;/li&gt; &#xA; &lt;li&gt;The full playbook supports multiple tasks, while the simplified playbook only supports a single task. This means that the full playbook can execute multiple sets of commands, whereas the simplified playbook can only execute one set of commands.&lt;/li&gt; &#xA; &lt;li&gt;The full playbook supports various target types, such as &lt;code&gt;hosts&lt;/code&gt;, &lt;code&gt;groups&lt;/code&gt;, and &lt;code&gt;names&lt;/code&gt;, while the simplified playbook only supports a single type, which is a list of names or host addresses. See the &lt;a href=&#34;https://raw.githubusercontent.com/umputun/spot/master/#targets&#34;&gt;Targets&lt;/a&gt; section for more details.&lt;/li&gt; &#xA; &lt;li&gt;The simplified playbook does not support task-level &lt;code&gt;on_error&lt;/code&gt;, &lt;code&gt;user&lt;/code&gt;, and &lt;code&gt;ssh_key&lt;/code&gt; fields, while the full playbook does. See the &lt;a href=&#34;https://raw.githubusercontent.com/umputun/spot/master/#task-details&#34;&gt;Task details&lt;/a&gt; section for more information.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both types of playbooks support the remaining fields and options.&lt;/p&gt; &#xA;&lt;h2&gt;Task details&lt;/h2&gt; &#xA;&lt;p&gt;Each task consists of a list of commands that will be executed on the remote host(s). The task can also define the following optional fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;on_error&lt;/code&gt;: specifies the command to execute on the local host (the one running the &lt;code&gt;spot&lt;/code&gt; command) in case of an error. The command can use the &lt;code&gt;{SPOT_ERROR}&lt;/code&gt; variable to access the last error message. Example: &lt;code&gt;on_error: &#34;curl -s localhost:8080/error?msg={SPOT_ERROR}&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;user&lt;/code&gt;: specifies the SSH user to use when connecting to remote hosts. Overrides the user defined in the top section of playbook file for the specified task.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: these fields supported in the full playbook type only&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;All tasks are executed sequentially one a given host, one after another. If a task fails, the execution of the playbook will stop and the &lt;code&gt;on_error&lt;/code&gt; command will be executed on the local host, if defined. Every task has to have &lt;code&gt;name&lt;/code&gt; field defined, which is used to identify the task everywhere. Playbook with missing &lt;code&gt;name&lt;/code&gt; field will fail to execute immediately. Duplicate task names are not allowed either.&lt;/p&gt; &#xA;&lt;h2&gt;Relative paths resolution&lt;/h2&gt; &#xA;&lt;p&gt;Relative path resolution is a frequent issue in systems that involve file references or inclusion. Different systems handle this in various ways. Spot uses a widely-adopted method of resolving relative paths based on the current working directory of the process. This means that if you run Spot from different directories, the way relative paths are resolved will change. In simpler terms, Spot doesn&#39;t resolve relative paths according to the location of the playbook file itself.&lt;/p&gt; &#xA;&lt;p&gt;This approach is intentional to prevent confusion and make it easier to comprehend relative path resolution. Generally, it&#39;s a good practice to run Spot from the same directory where the playbook file is located when using relative paths. Alternatively, you can use absolute paths for even better results.&lt;/p&gt; &#xA;&lt;h2&gt;Command Types&lt;/h2&gt; &#xA;&lt;p&gt;Spot supports the following command types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;script&lt;/code&gt;: can be any valid shell script. The script will be executed on the remote host(s) using SSH, inside a shell.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;copy&lt;/code&gt;: copies a file from the local machine to the remote host(s). Example: &lt;code&gt;copy: {&#34;src&#34;: &#34;testdata/conf.yml&#34;, &#34;dst&#34;: &#34;/tmp/conf.yml&#34;, &#34;mkdir&#34;: true}&lt;/code&gt;. If &lt;code&gt;mkdir&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; the command will create the destination directory if it doesn&#39;t exist, same as &lt;code&gt;mkdir -p&lt;/code&gt; in bash. Note: &lt;code&gt;copy&lt;/code&gt; command type supports multiple commands too, the same way as &lt;code&gt;mcopy&lt;/code&gt; below.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mcopy&lt;/code&gt;: copies multiple files from the local machine to the remote host(s). Example: &lt;code&gt;mcopy: [{&#34;src&#34;: &#34;testdata/1.yml&#34;, &#34;dst&#34;: &#34;/tmp/1.yml&#34;, &#34;mkdir&#34;: true}, {&#34;src&#34;: &#34;testdata/1.txt&#34;, &#34;dst&#34;: &#34;/tmp/1.txt&#34;}]&lt;/code&gt;. This is just a shortcut for multiple &lt;code&gt;copy&lt;/code&gt; commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sync&lt;/code&gt;: syncs directory from the local machine to the remote host(s). Optionally supports deleting files on the remote host(s) that don&#39;t exist locally. Example: &lt;code&gt;sync: {&#34;src&#34;: &#34;testdata&#34;, &#34;dst&#34;: &#34;/tmp/things&#34;, &#34;delete&#34;: true}&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;delete&lt;/code&gt;: deletes a file or directory on the remote host(s), optionally can remove recursively. Example: &lt;code&gt;delete: {&#34;path&#34;: &#34;/tmp/things&#34;, &#34;recur&#34;: true}&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;wait&lt;/code&gt;: waits for the specified command to finish on the remote host(s) with 0 error code. This command is useful when you need to wait for a service to start before executing the next command. Allows to specify the timeout as well as check interval. Example: &lt;code&gt;wait: {&#34;cmd&#34;: &#34;curl -s --fail localhost:8080&#34;, &#34;timeout&#34;: &#34;30s&#34;, &#34;interval&#34;: &#34;1s&#34;}&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Command options&lt;/h3&gt; &#xA;&lt;p&gt;Each command type supports the following options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_errors&lt;/code&gt;: if set to &lt;code&gt;true&lt;/code&gt; the command will not fail the task in case of an error.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;no_auto&lt;/code&gt;: if set to &lt;code&gt;true&lt;/code&gt; the command will not be executed automatically, but can be executed manually using the &lt;code&gt;--only&lt;/code&gt; flag.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;local&lt;/code&gt;: if set to &lt;code&gt;true&lt;/code&gt; the command will be executed on the local host (the one running the &lt;code&gt;spot&lt;/code&gt; command) instead of the remote host(s).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;example setting &lt;code&gt;ignore_errors&lt;/code&gt; and &lt;code&gt;no_auto&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  commands:&#xA;      - name: wait&#xA;        script: sleep 5s&#xA;        options: {ignore_errors: true, no_auto: true}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Script Execution&lt;/h3&gt; &#xA;&lt;p&gt;Spot allows executing scripts on remote hosts, or locally if &lt;code&gt;options.local&lt;/code&gt; is set to true. Scripts can be executed in two different ways, depending on whether they are single-line or multi-line scripts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Single-line Script Execution&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;For single-line scripts, they are executed directly inside the shell with the optional parameters set to the command line. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  commands:&#xA;      - name: some command&#xA;        script: ls -laR /tmp&#xA;        env: {FOO: bar, BAR: qux} &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this will be executed as: &lt;code&gt;FOO=&#39;bar&#39; BAR=&#39;qux&#39;ls -laR /tmp FOO=bar BAR=qux&lt;/code&gt; inside the shell on the remote host(s), i.e. &lt;code&gt;sh -c &#34;FOO=&#39;bar&#39; BAR=&#39;qux&#39;ls -laR /tmp FOO=bar BAR=qux&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Multi-line Script Execution&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;For multi-line scripts, Spot creates a temporary script containing all the commands, uploads it to the remote host (or keeps it locally if &lt;code&gt;options.local&lt;/code&gt; is set to true), and executes the script. Environment variables are set inside the script, allowing the user to create complex scripts that include setting variables, conditionals, loops, and other advanced functionality. Scripts run with &#34;set -e&#34; to fail on error. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;commands:&#xA;  - name: multi_line_script&#xA;    script: |&#xA;      touch /tmp/file1&#xA;      echo &#34;Hello World&#34; &amp;gt; /tmp/file2&#xA;      echo &#34;Executing loop...&#34;&#xA;      for i in {1..5}; do&#xA;        echo &#34;Iteration $i&#34;&#xA;      done&#xA;      echo &#34;All done! $FOO $BAR&#xA;    env: {FOO: bar, BAR: qux}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this will create a temporary script on the remote host(s) with the following content and execute it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh&#xA;set -e&#xA;export FOO=&#39;bar&#39;&#xA;export BAR=&#39;qux&#39;&#xA;touch /tmp/file1&#xA;echo &#34;Hello World&#34; &amp;gt; /tmp/file2&#xA;echo &#34;Executing loop...&#34;&#xA;for i in {1..5}; do&#xA;  echo &#34;Iteration $i&#34;&#xA;done&#xA;echo &#34;All done! $FOO $BAR&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By using this approach, Spot enables users to write and execute more complex scripts, providing greater flexibility and power in managing remote hosts or local environments.&lt;/p&gt; &#xA;&lt;h2&gt;Targets&lt;/h2&gt; &#xA;&lt;p&gt;Targets are used to define the remote hosts to execute the tasks on. Targets can be defined in the playbook file or passed as a command-line argument. The following target types are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;hosts&lt;/code&gt;: a list of destination host names or IP addresses, with optional port and username, to execute the tasks on. Example: &lt;code&gt;hosts: [{host: &#34;h1.example.com&#34;, user: &#34;test&#34;, name: &#34;h1}, {host: &#34;h2.example.com&#34;, &#34;port&#34;: 2222}]&lt;/code&gt;. If no user is specified, the user defined in the top section of the playbook file (or override) will be used. If no port is specified, port 22 will be used.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;groups&lt;/code&gt;: a list of groups from inventory to use. Example: &lt;code&gt;groups: [&#34;dev&#34;, &#34;staging&#34;}&lt;/code&gt;. Special group &lt;code&gt;all&lt;/code&gt; combines all the groups.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tags&lt;/code&gt;: a list of tags from inventory to use. Example: &lt;code&gt;tags: [&#34;tag1&#34;, &#34;tag2&#34;}&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;names&lt;/code&gt;: a list of host names from inventory to use. Example: &lt;code&gt;names: [&#34;host1&#34;, &#34;host2&#34;}&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All the target types can be combined, i.e. &lt;code&gt;hosts&lt;/code&gt;, &lt;code&gt;groups&lt;/code&gt;, &lt;code&gt;tags&lt;/code&gt;, &lt;code&gt;hosts&lt;/code&gt; and &lt;code&gt;names&lt;/code&gt; all can be used together in the same target. To avoid possible duplicates, the final list of hosts is deduplicated by the host+ip+user.&lt;/p&gt; &#xA;&lt;p&gt;example of targets in the playbook file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;targets:&#xA;  prod:&#xA;    hosts: [{host: &#34;h1.example.com&#34;, user: &#34;test&#34;}, {&#34;h2.example.com&#34;, &#34;port&#34;: 2222, name: &#34;h2&#34;}]&#xA;  staging:&#xA;    groups: [&#34;staging&#34;]&#xA;  dev:&#xA;    groups: [&#34;dev&#34;, &#34;staging&#34;]&#xA;    names: [&#34;host1&#34;, &#34;host2&#34;]&#xA;  all-servers:&#xA;    groups: [&#34;all&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: All the target types available in the full playbook file only. The simplified playbook file only supports a single, anonymous target type combining &lt;code&gt;hosts&lt;/code&gt; and &lt;code&gt;names&lt;/code&gt; together.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;targets: [&#34;host1&#34;, &#34;host2&#34;, &#34;host3.example.com&#34;, &#34;host4.example.com:2222&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this example, the playbook will be executed on hosts named &lt;code&gt;host1&lt;/code&gt; and &lt;code&gt;host2&lt;/code&gt; from the inventory and on hosts &lt;code&gt;host3.example.com&lt;/code&gt; with port &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;host4.example.com&lt;/code&gt; with port &lt;code&gt;2222&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Target overrides&lt;/h3&gt; &#xA;&lt;p&gt;There are several ways to override or alter the target defined in the playbook file via command-line arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--inventory&lt;/code&gt; set hosts from the provided inventory file or url. Example: &lt;code&gt;--inventory=inventory.yml&lt;/code&gt; or &lt;code&gt;--inventory=http://localhost:8080/inventory&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--target&lt;/code&gt; set groups, names, tags from inventory or directly hosts to run playbook on. Example: &lt;code&gt;--target=prod&lt;/code&gt; (will run on all hosts in group &lt;code&gt;prod&lt;/code&gt;) or &lt;code&gt;--target=example.com:2222&lt;/code&gt; (will run on host &lt;code&gt;example.com&lt;/code&gt; with port &lt;code&gt;2222&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--user&lt;/code&gt; set the ssh user to run the playbook on remote hosts. Example: &lt;code&gt;--user=test&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--key&lt;/code&gt; set the ssh key to run the playbook on remote hosts. Example: &lt;code&gt;--key=/path/to/key&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Target selection&lt;/h3&gt; &#xA;&lt;p&gt;The target selection is done in the following order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;if &lt;code&gt;--target&lt;/code&gt; is set, it will be used. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;first Spot will try to match on target name in the playbook file.&lt;/li&gt; &#xA;   &lt;li&gt;if no match found, Spot will try to match on group name in the inventory file.&lt;/li&gt; &#xA;   &lt;li&gt;if no match found, Spot will try to match on tags in the inventory file.&lt;/li&gt; &#xA;   &lt;li&gt;if no match found, Spot will try to match on host name in the inventory file.&lt;/li&gt; &#xA;   &lt;li&gt;if no match found, Spot will try to match on host address in the playbook file.&lt;/li&gt; &#xA;   &lt;li&gt;if no match found, Spot will use it as a host address.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;if &lt;code&gt;--target&lt;/code&gt; is not discovered, Spot will assume the &lt;code&gt;default&lt;/code&gt; target.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Inventory&lt;/h3&gt; &#xA;&lt;p&gt;The inventory file is a simple yml (ot toml) what can represent a list of hosts or a list of groups with hosts. In case if both groups and hosts defined, the hosts will be merged with groups and will add a new group named &lt;code&gt;hosts&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, inventory loaded from the file/url set in &lt;code&gt;SPOT_INVENTORY&lt;/code&gt; environment variable. This is the lowest priority and can be overridden by &lt;code&gt;inventory&lt;/code&gt; from the playbook (next priority) and &lt;code&gt;--inventory&lt;/code&gt; flag (highest priority) . This is an example of the inventory file with groups&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;groups:&#xA;  dev:&#xA;    - {host: &#34;h1.example.com&#34;, name: &#34;h1&#34;, tags:[&#34;us-east1&#34;, &#34;vpc-1234567&#34;]}&#xA;    - {host: &#34;h2.example.com&#34;, port: 2233, name: &#34;h2&#34;}&#xA;    - {host: &#34;h3.example.com&#34;, user: &#34;user1&#34;}&#xA;    - {host: &#34;h4.example.com&#34;, user: &#34;user2&#34;, name: &#34;h4&#34;}&#xA;  staging:&#xA;    - {host: &#34;h5.example.com&#34;, port: 2233, name: &#34;h5&#34;}&#xA;    - {host: &#34;h6.example.com&#34;, user: &#34;user3&#34;, name: &#34;h6&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;host: the host name or IP address of the remote host.&lt;/li&gt; &#xA; &lt;li&gt;port: the ssh port of the remote host. Optional, default is 22.&lt;/li&gt; &#xA; &lt;li&gt;user: the ssh user of the remote host. Optional, default is the user defined in the playbook file or &lt;code&gt;--user&lt;/code&gt; flag.&lt;/li&gt; &#xA; &lt;li&gt;name: the name of the remote host. Optional.&lt;/li&gt; &#xA; &lt;li&gt;tags: the list of tags of the remote host. Optional.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In case if port not defined, the default port 22 will be used. If user not defined, the playbook&#39;s user will be used.&lt;/p&gt; &#xA;&lt;p&gt;This is an example of the inventory file with hosts only (no groups)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;hosts:&#xA;  - {host: &#34;hh1.example.com&#34;, name: &#34;hh1&#34;}&#xA;  - {host: &#34;hh2.example.com&#34;, port: 2233, name: &#34;hh2&#34;, user: &#34;user1&#34;}&#xA;  - {host: &#34;h2.example.com&#34;, port: 2233, name: &#34;h2&#34;, tags:[&#34;us-east1&#34;, &#34;vpc-1234567&#34;]}&#xA;  - {host: &#34;h3.example.com&#34;, user: &#34;user1&#34;, name: &#34;h3&#34;}&#xA;  - {host: &#34;h4.example.com&#34;, user: &#34;user2&#34;, name: &#34;h4&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This format is useful when you want to define a list of hosts without groups.&lt;/p&gt; &#xA;&lt;p&gt;In each case inventory automatically merged and a special group &lt;code&gt;all&lt;/code&gt; will be created that contains all the hosts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Alternatively, the inventory can be represented using the TOML format.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Runtime variables&lt;/h2&gt; &#xA;&lt;p&gt;Spot supports runtime variables that can be used in the playbook file. The following variables are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;{SPOT_REMOTE_HOST}&lt;/code&gt;: The remote host name or IP address.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{SPOT_REMOTE_NAME}&lt;/code&gt;: The remote custom name, set in inventory or playbook as &lt;code&gt;name&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{SPOT_REMOTE_USER}&lt;/code&gt;: The remote username.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{SPOT_COMMAND}&lt;/code&gt;: The command name.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{SPOT_TASK}&lt;/code&gt;: The task name.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{SPOT_ERROR}&lt;/code&gt;: The error message, if any.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Variables can be used in the following places: &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;sync&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;env&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tasks:&#xA;  deploy-things:&#xA;    commands:&#xA;      - name: copy configuration&#xA;        copy: {&#34;src&#34;: &#34;{SPOT_REMOTE_HOST}/conf.yml&#34;, &#34;dst&#34;: &#34;/tmp/conf.yml&#34;, &#34;mkdir&#34;: true}&#xA;      - name: sync things&#xA;        sync: {&#34;src&#34;: &#34;testdata&#34;, &#34;dst&#34;: &#34;/tmp/{SPOT_TASK}/things&#34;}&#xA;      - name: some command&#xA;        script: |&#xA;          ls -laR /tmp/${SPOT_COMMAND}&#xA;        env: { FOO: bar, BAR: &#34;{SPOT_COMMAND}-blah&#34; }&#xA;      - name: delete things&#xA;        delete: {&#34;loc&#34;: &#34;/tmp/things/{SPOT_REMOTE_USER}&#34;, &#34;recur&#34;: true}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Ad-hoc commands&lt;/h2&gt; &#xA;&lt;p&gt;Spot supports ad-hoc commands that can be executed on the remote hosts. This is useful when all is needed is to execute a command on the remote hosts without creating a playbook file. This command optionally passed as a first argument, i.e. &lt;code&gt;spot &#34;la -la /tmp&#34;&lt;/code&gt; and usually accompanied by the &lt;code&gt;--target=&amp;lt;host&amp;gt;&lt;/code&gt; (&lt;code&gt;-t &amp;lt;host&amp;gt;&lt;/code&gt;) flags. Example: &lt;code&gt;spot &#34;ls -la&#34; -t h1.example.com -t h2.example.com&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All other overrides can be used with adhoc commands as well, for example &lt;code&gt;--user&lt;/code&gt;and &lt;code&gt;--key&lt;/code&gt; to specify the user and sshkey to use when connecting to the remote hosts. By default, Spot will use the current user and the default ssh key. Inventory can be passed to such commands as well, for example &lt;code&gt;--inventory=inventory.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Adhoc commands always sets &lt;code&gt;verbose&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; automatically, so the user can see the output of the command.&lt;/p&gt; &#xA;&lt;h2&gt;Rolling Updates&lt;/h2&gt; &#xA;&lt;p&gt;Spot supports rolling updates, which means that the tasks will be executed on the hosts one by one, waiting for the previous host to finish before starting the next one. This is useful when you need to update a service running on multiple hosts, but want to avoid downtime. To enable rolling updates, use the &lt;code&gt;--concurrent=N&lt;/code&gt; flag when running the &lt;code&gt;spot&lt;/code&gt; command. &lt;code&gt;N&lt;/code&gt; is the number of hosts to execute the tasks on concurrently. Example: &lt;code&gt;spot --concurrent=2&lt;/code&gt;. In addition, user can use a builtin &lt;code&gt;wait&lt;/code&gt; command to wait for a service to start before executing the next command. See the &lt;a href=&#34;https://raw.githubusercontent.com/umputun/spot/master/#command-types&#34;&gt;Command Types&lt;/a&gt; section for more details. Practically, user will have a task with a series of commands, where the last command will wait for the service to start by running a command like &lt;code&gt;curl -s --fail localhost:8080&lt;/code&gt; and then the task will be executed on the next host.&lt;/p&gt; &#xA;&lt;h2&gt;Why Spot?&lt;/h2&gt; &#xA;&lt;p&gt;Spot is designed to provide a simple, efficient, and flexible solution for deployment and configuration management. It addresses the need for a tool that is easy to set up and use, while still offering powerful features for managing infrastructure. Below are some of the reasons why you should consider using Spot:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Simplicity&lt;/strong&gt;: Spot&#39;s primary goal is to be as simple as possible without sacrificing functionality. Its configuration is written in YAML, making it easy to read and understand. You can quickly create and manage tasks, targets, and commands without dealing with complex structures or concepts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Flexibility&lt;/strong&gt;: Spot is designed to be flexible and adaptable to various deployment and configuration scenarios. You can use it to manage different targets, such as production, staging, and development environments. It supports executing tasks on remote hosts directly or through inventory files and URLs, allowing you to use existing inventory management solutions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Extensibility&lt;/strong&gt;: Spot is built to be extensible, allowing you to define custom scripts for execution on remote hosts, as well as offering built-in commands for common operations such as copy, sync, and delete. This extensibility enables you to create complex workflows for deployment and configuration management, tailored to your specific needs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Concurrent Execution&lt;/strong&gt;: Spot supports concurrent execution of tasks, allowing you to speed up the deployment and configuration processes by running multiple tasks simultaneously. This can be particularly helpful when managing large-scale infrastructure or when time is of the essence.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Customizable&lt;/strong&gt;: Spot provides various command-line options and environment variables that enable you to customize its behavior according to your requirements. You can easily modify the playbook file, task, target, and other parameters, as well as control the execution flow by skipping or running specific commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight&lt;/strong&gt;: Spot is a lightweight tool, written in Go, that does not require heavy dependencies or a complex setup process. It can be easily installed and run on various platforms, making it an ideal choice for teams looking for a low-overhead solution for deployment and configuration management.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In conclusion, Spot is a powerful and easy-to-use tool that simplifies the process of deployment and configuration management while offering the flexibility and extensibility needed to cater to various use cases. If you value simplicity, efficiency, and a customizable experience, Spot is a great choice for your infrastructure management needs.&lt;/p&gt; &#xA;&lt;h3&gt;Is it replacing Ansible?&lt;/h3&gt; &#xA;&lt;p&gt;Spot is not intended to be a direct replacement for Ansible. While both tools can be used for deployment and configuration management, there are some key differences between them:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Complexity&lt;/strong&gt;: Ansible is a more feature-rich and mature tool, offering a wide range of modules and plugins that can automate many different aspects of infrastructure management. Spot, on the other hand, is designed to be simple and lightweight, focusing on a few core features to streamline the deployment and configuration process.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Learning Curve&lt;/strong&gt;: Due to its simplicity, Spot has a lower learning curve compared to Ansible. It&#39;s easier to get started with Spot, making it more suitable for smaller projects or teams with limited experience in infrastructure automation. Ansible, while more powerful, can be more complex to learn and configure, especially for newcomers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Customization&lt;/strong&gt;: While both tools offer customization options, Ansible has a more extensive set of built-in modules and plugins that can handle a wide range of tasks out-of-the-box. Spot, in contrast, relies on custom scripts and a limited set of built-in commands for its functionality, which might require more manual configuration and scripting for certain use cases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Community and Ecosystem&lt;/strong&gt;: Ansible has a large and active community, as well as a vast ecosystem of roles, modules, and integrations. This can be beneficial when dealing with common tasks or integrating with third-party systems. Spot, being a smaller and simpler tool, doesn&#39;t have the same level of community support or ecosystem.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ease of installation and external dependencies&lt;/strong&gt;: One of the most significant benefits of Spot is that it has no dependencies. Being written in Go, it is compiled into a single binary that can be easily distributed and executed on various platforms. This eliminates the need to install or manage any additional software, libraries, or dependencies to use Spot. Ansible, on the other hand, is written in Python and requires Python to be installed on both the control host (where Ansible is run) and the managed nodes (remote hosts being managed). Additionally, Ansible depends on several Python libraries, which need to be installed and maintained on the control host. Some Ansible modules may also require specific libraries or packages to be installed on the managed nodes, adding to the complexity of managing dependencies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Spot can be a good choice if you&#39;re looking for a lightweight, simple, and easy-to-use tool for deployment and configuration management, particularly for smaller projects or when you don&#39;t need the extensive features offered by Ansible. However, if you require a more comprehensive solution with a wide range of built-in modules, plugins, and integrations, Ansible might be a better fit for your needs.&lt;/p&gt; &#xA;&lt;p&gt;The simplicity of Spot&#39;s single binary distribution and lack of dependencies make it an attractive choice for teams who want a lightweight, easy-to-install, and low-maintenance solution for deployment and configuration management. While Ansible offers more advanced features and a comprehensive ecosystem, its dependency on Python and additional libraries can be a hurdle for some users, particularly in environments with strict control over software installations or limited resources.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;The project is currently in active development, and breaking changes may occur until the release of version 1.0. However, we strive to minimize disruptions and will only introduce breaking changes when there is a compelling reason to do so.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please feel free to open a discussion, submit issues, fork the repository, and send pull requests. See &lt;a href=&#34;https://github.com/umputun/spot/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the MIT License. See the LICENSE file for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>axllent/mailpit</title>
    <updated>2023-05-06T01:34:10Z</updated>
    <id>tag:github.com,2023-05-06:/axllent/mailpit</id>
    <link href="https://github.com/axllent/mailpit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An email and SMTP testing tool with API for developers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mailpit - email testing for developers&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/axllent/mailpit/actions/workflows/tests.yml/badge.svg?sanitize=true&#34; alt=&#34;Tests&#34;&gt; &lt;img src=&#34;https://github.com/axllent/mailpit/actions/workflows/release-build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt; &lt;img src=&#34;https://github.com/axllent/mailpit/actions/workflows/build-docker.yml/badge.svg?sanitize=true&#34; alt=&#34;Docker builds&#34;&gt; &lt;img src=&#34;https://github.com/axllent/mailpit/actions/workflows/codeql-analysis.yml/badge.svg?sanitize=true&#34; alt=&#34;CodeQL&#34;&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/axllent/mailpit&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/axllent/mailpit&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Mailpit is a multi-platform email testing tool &amp;amp; API for developers.&lt;/p&gt; &#xA;&lt;p&gt;It acts as both an SMTP server, and provides a web interface to view all captured emails.&lt;/p&gt; &#xA;&lt;p&gt;Mailpit is inspired by &lt;a href=&#34;https://raw.githubusercontent.com/axllent/mailpit/develop/#why-rewrite-mailhog&#34;&gt;MailHog&lt;/a&gt;, but much, much faster.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/axllent/mailpit/develop/docs/screenshot.png&#34; alt=&#34;Mailpit&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Runs entirely from a single binary, no installation required&lt;/li&gt; &#xA; &lt;li&gt;SMTP server (default &lt;code&gt;0.0.0.0:1025&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Web UI to view emails (formatted HTML, highlighted HTML source, text, headers, raw source and MIME attachments including image thumbnails)&lt;/li&gt; &#xA; &lt;li&gt;Mobile and tablet HTML preview toggle in desktop mode&lt;/li&gt; &#xA; &lt;li&gt;Advanced mail search (&lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Mail-search&#34;&gt;see wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Message tagging (&lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Tagging&#34;&gt;see wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Real-time web UI updates using web sockets for new mail&lt;/li&gt; &#xA; &lt;li&gt;Optional browser notifications for new mail (HTTPS only)&lt;/li&gt; &#xA; &lt;li&gt;Configurable automatic email pruning (default keeps the most recent 500 emails)&lt;/li&gt; &#xA; &lt;li&gt;Email storage either in a temporary or persistent database (&lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Email-storage&#34;&gt;see wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Fast SMTP processing &amp;amp; storing - approximately 70-100 emails per second depending on CPU, network speed &amp;amp; email size, easily handling tens of thousands of emails&lt;/li&gt; &#xA; &lt;li&gt;SMTP relaying / message release - relay messages via a different SMTP server including an optional allowlist of accepted recipients (&lt;a href=&#34;https://github.com/axllent/mailpit/wiki/SMTP-relay&#34;&gt;see wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Optional SMTP with STARTTLS &amp;amp; SMTP authentication, including an &#34;accept anything&#34; mode (&lt;a href=&#34;https://github.com/axllent/mailpit/wiki/SMTP-with-STARTTLS-and-authentication&#34;&gt;see wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Optional HTTPS for web UI (&lt;a href=&#34;https://github.com/axllent/mailpit/wiki/HTTPS&#34;&gt;see wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Optional basic authentication for web UI (&lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Basic-authentication&#34;&gt;see wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;A simple REST API (&lt;a href=&#34;https://raw.githubusercontent.com/axllent/mailpit/develop/docs/apiv1/README.md&#34;&gt;see docs&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Multi-architecture &lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Docker-images&#34;&gt;Docker images&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The Mailpit web UI listens by default on &lt;code&gt;http://0.0.0.0:8025&lt;/code&gt;, and the SMTP port on &lt;code&gt;0.0.0.0:1025&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Mailpit runs as a single binary and can be installed in different ways:&lt;/p&gt; &#xA;&lt;h3&gt;Install via Brew (Mac)&lt;/h3&gt; &#xA;&lt;p&gt;Add the repository to your taps with &lt;code&gt;brew tap axllent/apps&lt;/code&gt;, and then install Mailpit with &lt;code&gt;brew install mailpit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Install via bash script (Linux &amp;amp; Mac)&lt;/h3&gt; &#xA;&lt;p&gt;Linux &amp;amp; Mac users can install it directly to &lt;code&gt;/usr/local/bin/mailpit&lt;/code&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo bash &amp;lt; &amp;lt;(curl -sL https://raw.githubusercontent.com/axllent/mailpit/develop/install.sh)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Download static binary (Windows, Linux and Mac)&lt;/h3&gt; &#xA;&lt;p&gt;Static binaries can always be found on the &lt;a href=&#34;https://github.com/axllent/mailpit/releases/latest&#34;&gt;releases&lt;/a&gt;. The &lt;code&gt;mailpit&lt;/code&gt; binary can extracted and copied to your &lt;code&gt;$PATH&lt;/code&gt;, or simply run as &lt;code&gt;./mailpit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Docker-images&#34;&gt;Docker instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Compile from source&lt;/h3&gt; &#xA;&lt;p&gt;To build Mailpit from source see &lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Building-from-source&#34;&gt;building from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Testing Mailpit&lt;/h3&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Testing-Mailpit&#34;&gt;the documentation&lt;/a&gt; of how to easily test email delivery to Mailpit.&lt;/p&gt; &#xA;&lt;h3&gt;Configuring sendmail&lt;/h3&gt; &#xA;&lt;p&gt;Mailpit&#39;s SMTP server (by default on port 1025), so you will likely need to configure your sending application to deliver mail via that port. A common MTA (Mail Transfer Agent) that delivers system emails to a SMTP server is &lt;code&gt;sendmail&lt;/code&gt;, used by many applications including PHP. Mailpit can also act as substitute for sendmail. For instructions of how to set this up, please refer to the &lt;a href=&#34;https://github.com/axllent/mailpit/wiki/Configuring-sendmail&#34;&gt;sendmail documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Why rewrite MailHog?&lt;/h2&gt; &#xA;&lt;p&gt;I had been using MailHog for a few years to intercept and test emails generated from several projects. MailHog has a number of performance issues, many of the frontend and Go modules are horribly out of date, and it is not actively developed.&lt;/p&gt; &#xA;&lt;p&gt;Initially I tried to upgrade a fork of MailHog (both the UI as well as the HTTP server &amp;amp; API), but soon discovered that it is (with all due respect to its authors) poorly designed. It is in my opinion over-engineered (split over 9 separate projects), and performs very poorly when dealing with large amounts of emails or processing emails with an attachments (a single email with a 3MB attachment can take over a minute to ingest). Finally, the API transmits a lot of duplicate and unnecessary data on every browser request, and there is no HTTP compression.&lt;/p&gt; &#xA;&lt;p&gt;In order to improve it I felt it needed to be completely rewritten, and so Mailpit was born.&lt;/p&gt;</summary>
  </entry>
</feed>