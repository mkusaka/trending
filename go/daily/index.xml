<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-08T01:35:49Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>shopspring/decimal</title>
    <updated>2023-01-08T01:35:49Z</updated>
    <id>tag:github.com,2023-01-08:/shopspring/decimal</id>
    <link href="https://github.com/shopspring/decimal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Arbitrary-precision fixed-point decimal numbers in go&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;decimal&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/shopspring/decimal/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/shopspring/decimal/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Github Actions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/shopspring/decimal&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/shopspring/decimal?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/shopspring/decimal&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/shopspring/decimal&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Arbitrary-precision fixed-point decimal numbers in go.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Decimal library can &#34;only&#34; represent numbers with a maximum of 2^31 digits after the decimal point.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The zero-value is 0, and is safe to use without initialization&lt;/li&gt; &#xA; &lt;li&gt;Addition, subtraction, multiplication with no loss of precision&lt;/li&gt; &#xA; &lt;li&gt;Division with specified precision&lt;/li&gt; &#xA; &lt;li&gt;Database/sql serialization/deserialization&lt;/li&gt; &#xA; &lt;li&gt;JSON and XML serialization/deserialization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Run &lt;code&gt;go get github.com/shopspring/decimal&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Decimal library requires Go version &lt;code&gt;&amp;gt;=1.7&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;github.com/shopspring/decimal&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;price, err := decimal.NewFromString(&#34;136.02&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;quantity := decimal.NewFromInt(3)&#xA;&#xA;&#x9;fee, _ := decimal.NewFromString(&#34;.035&#34;)&#xA;&#x9;taxRate, _ := decimal.NewFromString(&#34;.08875&#34;)&#xA;&#xA;&#x9;subtotal := price.Mul(quantity)&#xA;&#xA;&#x9;preTax := subtotal.Mul(fee.Add(decimal.NewFromFloat(1)))&#xA;&#xA;&#x9;total := preTax.Mul(taxRate.Add(decimal.NewFromFloat(1)))&#xA;&#xA;&#x9;fmt.Println(&#34;Subtotal:&#34;, subtotal)                      // Subtotal: 408.06&#xA;&#x9;fmt.Println(&#34;Pre-tax:&#34;, preTax)                         // Pre-tax: 422.3421&#xA;&#x9;fmt.Println(&#34;Taxes:&#34;, total.Sub(preTax))                // Taxes: 37.482861375&#xA;&#x9;fmt.Println(&#34;Total:&#34;, total)                            // Total: 459.824961375&#xA;&#x9;fmt.Println(&#34;Tax rate:&#34;, total.Sub(preTax).Div(preTax)) // Tax rate: 0.08875&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://godoc.org/github.com/shopspring/decimal&#34;&gt;http://godoc.org/github.com/shopspring/decimal&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Production Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://shopspring.com/&#34;&gt;Spring&lt;/a&gt;, since August 14, 2014.&lt;/li&gt; &#xA; &lt;li&gt;If you are using this in production, please let us know!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h4&gt;Why don&#39;t you just use float64?&lt;/h4&gt; &#xA;&lt;p&gt;Because float64 (or any binary floating point type, actually) can&#39;t represent numbers such as &lt;code&gt;0.1&lt;/code&gt; exactly.&lt;/p&gt; &#xA;&lt;p&gt;Consider this code: &lt;a href=&#34;http://play.golang.org/p/TQBd4yJe6B&#34;&gt;http://play.golang.org/p/TQBd4yJe6B&lt;/a&gt; You might expect that it prints out &lt;code&gt;10&lt;/code&gt;, but it actually prints &lt;code&gt;9.999999999999831&lt;/code&gt;. Over time, these small errors can really add up!&lt;/p&gt; &#xA;&lt;h4&gt;Why don&#39;t you just use big.Rat?&lt;/h4&gt; &#xA;&lt;p&gt;big.Rat is fine for representing rational numbers, but Decimal is better for representing money. Why? Here&#39;s a (contrived) example:&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say you use big.Rat, and you have two numbers, x and y, both representing 1/3, and you have &lt;code&gt;z = 1 - x - y = 1/3&lt;/code&gt;. If you print each one out, the string output has to stop somewhere (let&#39;s say it stops at 3 decimal digits, for simplicity), so you&#39;ll get 0.333, 0.333, and 0.333. But where did the other 0.001 go?&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s the above example as code: &lt;a href=&#34;http://play.golang.org/p/lCZZs0w9KE&#34;&gt;http://play.golang.org/p/lCZZs0w9KE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;With Decimal, the strings being printed out represent the number exactly. So, if you have &lt;code&gt;x = y = 1/3&lt;/code&gt; (with precision 3), they will actually be equal to 0.333, and when you do &lt;code&gt;z = 1 - x - y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; will be equal to .334. No money is unaccounted for!&lt;/p&gt; &#xA;&lt;p&gt;You still have to be careful. If you want to split a number &lt;code&gt;N&lt;/code&gt; 3 ways, you can&#39;t just send &lt;code&gt;N/3&lt;/code&gt; to three different people. You have to pick one to send &lt;code&gt;N - (2/3*N)&lt;/code&gt; to. That person will receive the fraction of a penny remainder.&lt;/p&gt; &#xA;&lt;p&gt;But, it is much easier to be careful with Decimal than with big.Rat.&lt;/p&gt; &#xA;&lt;h4&gt;Why isn&#39;t the API similar to big.Int&#39;s?&lt;/h4&gt; &#xA;&lt;p&gt;big.Int&#39;s API is built to reduce the number of memory allocations for maximal performance. This makes sense for its use-case, but the trade-off is that the API is awkward and easy to misuse.&lt;/p&gt; &#xA;&lt;p&gt;For example, to add two big.Ints, you do: &lt;code&gt;z := new(big.Int).Add(x, y)&lt;/code&gt;. A developer unfamiliar with this API might try to do &lt;code&gt;z := a.Add(a, b)&lt;/code&gt;. This modifies &lt;code&gt;a&lt;/code&gt; and sets &lt;code&gt;z&lt;/code&gt; as an alias for &lt;code&gt;a&lt;/code&gt;, which they might not expect. It also modifies any other aliases to &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of the subtle bugs you can introduce with big.Int&#39;s API: &lt;a href=&#34;https://play.golang.org/p/x2R_78pa8r&#34;&gt;https://play.golang.org/p/x2R_78pa8r&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;In contrast, it&#39;s difficult to make such mistakes with decimal. Decimals behave like other go numbers types: even though &lt;code&gt;a = b&lt;/code&gt; will not deep copy &lt;code&gt;b&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt;, it is impossible to modify a Decimal, since all Decimal methods return new Decimals and do not modify the originals. The downside is that this causes extra allocations, so Decimal is less performant. My assumption is that if you&#39;re using Decimals, you probably care more about correctness than performance.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt; &#xA;&lt;p&gt;This is a heavily modified fork of &lt;a href=&#34;https://github.com/oguzbilgic/fpd&#34;&gt;fpd.Decimal&lt;/a&gt;, which was also released under the MIT License.&lt;/p&gt;</summary>
  </entry>
</feed>