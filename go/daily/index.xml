<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-22T01:32:56Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>felixge/fgtrace</title>
    <updated>2022-09-22T01:32:56Z</updated>
    <id>tag:github.com,2022-09-22:/felixge/fgtrace</id>
    <link href="https://github.com/felixge/fgtrace" rel="alternate"></link>
    <summary type="html">&lt;p&gt;fgtrace is an experimental profiler/tracer that is capturing wallclock timelines for each goroutine. It&#39;s very similar to the Chrome profiler.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;fgtrace - The Full Go Tracer&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/felixge/fgtrace/actions/workflows/go.yml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/felixge/fgtrace/Go?label=tests&#34; alt=&#34;ci test status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/felixge/fgtrace&#34;&gt;&lt;img src=&#34;http://img.shields.io/badge/godoc-reference-blue.svg?sanitize=true&#34; alt=&#34;documentation&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;fgtrace is an experimental profiler/tracer that is capturing wallclock timelines for each goroutine. It&#39;s very similar to the Chrome profiler.&lt;/p&gt; &#xA;&lt;p&gt;⚠️ fgtrace may cause noticeable stop-the-world pauses in your applications. It is intended for dev and testing environments for now.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/assets/fgtrace-example.png&#34;&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;To capture an fgtrace of your program, simply add the one-liner shown below. This will cause the creation of a &lt;code&gt;fgtrace.json&lt;/code&gt; file in the current working directory that you can view by opening it in the &lt;a href=&#34;https://ui.perfetto.dev/&#34;&gt;Perfetto UI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import &#34;github.com/felixge/fgtrace&#34;&#xA;&#xA;func main() {&#xA;&#x9;defer fgtrace.Config{Dst: fgtrace.File(&#34;fgtrace.json&#34;)}.Trace().Stop()&#xA;&#xA;&#x9;// &amp;lt;code to trace&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively you can configure fgtrace as a &lt;code&gt;http.Handler&lt;/code&gt; and request traces on-demand by hitting &lt;code&gt;http://localhost:1234/debug/fgtrace?seconds=30&amp;amp;hz=100&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;github.com/felixge/fgtrace&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;http.DefaultServeMux.Handle(&#34;/debug/fgtrace&#34;, fgtrace.Config{})&#xA;&#x9;http.ListenAndServe(&#34;:1234&#34;, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced use cases, have a look at the &lt;a href=&#34;https://pkg.go.dev/github.com/felixge/fgtrace#Config&#34;&gt;API Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Comparison with Similar Tools&lt;/h2&gt; &#xA;&lt;p&gt;Below is a &lt;a href=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/testdata/readme/&#34;&gt;simple program&lt;/a&gt; that spends its time sleeping, requesting a website, capturing the response body and then hashing it a few times.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; 10; i++ {&#xA;&#x9;time.Sleep(10 * time.Millisecond)&#xA;}&#xA;&#xA;res, err := http.Get(&#34;https://github.com/&#34;)&#xA;if err != nil {&#xA;&#x9;panic(err)&#xA;}&#xA;defer res.Body.Close()&#xA;&#xA;var buf bytes.Buffer&#xA;if _, err := io.Copy(&amp;amp;buf, res.Body); err != nil {&#xA;&#x9;panic(err)&#xA;}&#xA;&#xA;for i := 0; i &amp;lt; 1000; i++ {&#xA;&#x9;sha1.Sum(buf.Bytes())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now let&#39;s have a look at how fgtrace and other tools allow you to understand the performance of such a program.&lt;/p&gt; &#xA;&lt;h3&gt;fgtrace&lt;/h3&gt; &#xA;&lt;p&gt;Looking at our main goroutine (G1), we can easily recognize the operations of the program, their order, and how long they are taking (~100ms &lt;code&gt;time.Sleep&lt;/code&gt;, ~65ms &lt;code&gt;http.Get&lt;/code&gt;, ~30ms &lt;code&gt;io.Copy&lt;/code&gt;ing the response and ~300ms calling &lt;code&gt;sha1.Sum&lt;/code&gt; to hash it).&lt;/p&gt; &#xA;&lt;p&gt;However, it&#39;s important to note that this data is captured by sampling goroutine stack traces rather than actual tracing. Therefore fgtrace does not know that there were ten &lt;code&gt;time.Sleep()&lt;/code&gt; function calls lasting &lt;code&gt;10ms&lt;/code&gt; each. Instead it just merges its samples into one big &lt;code&gt;time.Sleep()&lt;/code&gt; call that appears to take &lt;code&gt;100ms&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Another detail are the virtual goroutine state indicators on top, e.g. &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;sync.Cond.Wait&lt;/code&gt; and &lt;code&gt;running/runnable&lt;/code&gt;. These are not part of the real stack traces and meant to help understanding On-CPU activity (&lt;code&gt;running/runnable&lt;/code&gt;) vs Off-CPU states. You can disable them via configuration.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/assets/fgtrace-example.png&#34;&gt; &#xA;&lt;p&gt;To break down the latency of our main goroutine, we can also look at other goroutines used by the program. E.g. below is a closer look on how the &lt;code&gt;http.Get&lt;/code&gt; operation is broken down into resolving the IP address, connecting to it, and performing a TLS handshake.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/assets/fgtrace-example2.png&#34;&gt; &#xA;&lt;p&gt;So as you can see, fgtrace offers an intuitive, yet powerful way to understand the operation of Go programs. However, since it always captures the activity of all goroutines and has no information about how they communicate with each other, it may create overwhelming amounts of data in some cases.&lt;/p&gt; &#xA;&lt;h3&gt;fgprof&lt;/h3&gt; &#xA;&lt;p&gt;You can think of &lt;a href=&#34;https://github.com/felixge/fgprof&#34;&gt;fgprof&lt;/a&gt; as a more simplified version of fgtrace. Instead of capturing a timeline for each goroutine, it aggregates the same data into a single profile as shown in the flame graph below.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/assets/fgprof-example.png&#34;&gt; &#xA;&lt;p&gt;This means that the x-axis represents duration rather than time, so function calls are ordered alphabetically rather than chronologically. E.g. notice how &lt;code&gt;time.Sleep&lt;/code&gt; is shown after &lt;code&gt;sha1.Sum&lt;/code&gt; in the graph above even so it&#39;s the first operation completed by our program.&lt;/p&gt; &#xA;&lt;p&gt;Additionally the data of all goroutines ends up in the same graph which can be difficult to read without having a good understanding of the underlaying code and number of goroutines that are involved.&lt;/p&gt; &#xA;&lt;p&gt;Despite these disadvantages, fgprof may still be useful in certain situations where the detail provided by the timeline may be overwhelming and a simpler view of the average program behavior is desirable. Additionally fgprof under Go 1.19 has less &lt;a href=&#34;https://go-review.googlesource.com/c/go/+/387415&#34;&gt;negative impact&lt;/a&gt; on the performance of the profiled program than fgtrace.&lt;/p&gt; &#xA;&lt;h3&gt;runtime/trace&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;runtime/trace&lt;/code&gt; package is a true execution tracer that is capable of capturing even more detailed information than fgtrace. However, it&#39;s mostly designed to understand the decisions made by the Go scheduler. So the default timeline is focused on how goroutines are scheduled onto the CPU (processors). This means only the &lt;code&gt;sha1.Sum&lt;/code&gt; operation stands out in green, and full stack traces can only be seen by clicking on the individual scheduler activities.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/assets/runtime-example.png&#34;&gt; &#xA;&lt;p&gt;The goroutine analysis view offers a more useful breakdown. Here we can see that our goroutine is spending &lt;code&gt;271ms&lt;/code&gt; in &lt;code&gt;Execution&lt;/code&gt; on CPU, but it&#39;s not clear from this view alone that this is the &lt;code&gt;sha1.Sum&lt;/code&gt; operation. Our networking activity (&lt;code&gt;http.Get&lt;/code&gt; and &lt;code&gt;io.Copy&lt;/code&gt;) gets grouped into &lt;code&gt;Sync block&lt;/code&gt; rather than &lt;code&gt;Network wait&lt;/code&gt; because the networking is done through channels via other goroutines. And our &lt;code&gt;time.Sleep&lt;/code&gt; activity is shown as a grey component of the bar diagram, but not explicitly listed in the table. So while a lot of information is available here, it&#39;s difficult to interpret for casual users.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/assets/runtime-example2.png&#34;&gt; &#xA;&lt;p&gt;Last but not least it&#39;s possible to click on the goroutine id in the view above in order to see a timeline for the individual goroutine, as well as the other goroutines it is communicating with. However, the view is also CPU-centric, so remains difficult to understand the sleep and networking operations of our program.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/felixge/fgtrace/main/assets/runtime-example3.png&#34;&gt; &#xA;&lt;p&gt;That being said, some of the limitations of &lt;code&gt;runtime/trace&lt;/code&gt; could probably be resolved with changes to the UI or converting the traces into a format that &lt;a href=&#34;https://ui.perfetto.dev/&#34;&gt;Perfetto UI&lt;/a&gt; can understand which might be a fun project for another time.&lt;/p&gt; &#xA;&lt;h2&gt;How it Works&lt;/h2&gt; &#xA;&lt;p&gt;The current implementation of fgtrace is incredibly hacky. It calls &lt;a href=&#34;https://pkg.go.dev/runtime#Stack&#34;&gt;&lt;code&gt;runtime.Stack()&lt;/code&gt;&lt;/a&gt; on a regular frequency (default 100 Hz) to capture textual stack traces of all goroutines and parses them using the &lt;a href=&#34;https://github.com/DataDog/gostackparse&#34;&gt;gostackparse&lt;/a&gt; package. Each call to &lt;code&gt;runtime.Stack()&lt;/code&gt; is a blocking stop-the-world operation, so it scales very poorly to programs using ten thousand or more goroutines.&lt;/p&gt; &#xA;&lt;p&gt;After the data is captured, it is converted into the &lt;a href=&#34;https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview&#34;&gt;Trace Event Format&lt;/a&gt; which is one of the data formats understood by &lt;a href=&#34;https://ui.perfetto.dev/&#34;&gt;Perfetto UI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;The Future&lt;/h2&gt; &#xA;&lt;p&gt;fgtrace is mostly a &lt;a href=&#34;http://paulgraham.com/ds.html&#34;&gt;&#34;Do Things that Don&#39;t Scale&#34;&lt;/a&gt; kind of project. If enough people like it, it will motivate me and perhaps others to invest into putting it on a solid technical foundation.&lt;/p&gt; &#xA;&lt;p&gt;The Go team has previously &lt;a href=&#34;https://github.com/golang/go/issues/41324#issuecomment-703796820&#34;&gt;declined&lt;/a&gt; the idea of adding wallclock profiling capabilities similar to fgprof (which is similar to fgtrace) to the Go project and is more likely to invest in &lt;code&gt;runtime/trace&lt;/code&gt; going forward.&lt;/p&gt; &#xA;&lt;p&gt;That being said, I still think fgtrace can help by:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Showing the usefulness of stack-trace/wallclock focused timeline views in addition to the CPU-centric views used by &lt;code&gt;runtime/trace&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Starting a conversation (link to GH issue will follow ...) to offer more powerful goroutine profiling APIs to allow user-space tooling like this to thrive without having to hack around the &lt;a href=&#34;https://github.com/DataDog/go-profiler-notes/raw/main/goroutine.md#feature-matrix&#34;&gt;existing APIs&lt;/a&gt; while reducing their overhead.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;fgtrace is licensed under the MIT License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>itchyny/gojq</title>
    <updated>2022-09-22T01:32:56Z</updated>
    <id>tag:github.com,2022-09-22:/itchyny/gojq</id>
    <link href="https://github.com/itchyny/gojq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Pure Go implementation of jq&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gojq&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/itchyny/gojq/actions&#34;&gt;&lt;img src=&#34;https://github.com/itchyny/gojq/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/itchyny/gojq&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/itchyny/gojq&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/itchyny/gojq/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;MIT License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/itchyny/gojq/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/itchyny/gojq/all.svg?sanitize=true&#34; alt=&#34;release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/itchyny/gojq&#34; alt=&#34;pkg.go.dev&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Pure Go implementation of &lt;a href=&#34;https://github.com/stedolan/jq&#34;&gt;jq&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This is an implementation of jq command written in Go language. You can also embed gojq as a library to your Go products.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt; $ echo &#39;{&#34;foo&#34;: 128}&#39; | gojq &#39;.foo&#39;&#xA;128&#xA; $ echo &#39;{&#34;a&#34;: {&#34;b&#34;: 42}}&#39; | gojq &#39;.a.b&#39;&#xA;42&#xA; $ echo &#39;{&#34;id&#34;: &#34;sample&#34;, &#34;10&#34;: {&#34;b&#34;: 42}}&#39; | gojq &#39;{(.id): .[&#34;10&#34;].b}&#39;&#xA;{&#xA;  &#34;sample&#34;: 42&#xA;}&#xA; $ echo &#39;[{&#34;id&#34;:1},{&#34;id&#34;:2},{&#34;id&#34;:3}]&#39; | gojq &#39;.[] | .id&#39;&#xA;1&#xA;2&#xA;3&#xA; $ echo &#39;{&#34;a&#34;:1,&#34;b&#34;:2}&#39; | gojq &#39;.a += 1 | .b *= 2&#39;&#xA;{&#xA;  &#34;a&#34;: 2,&#xA;  &#34;b&#34;: 4&#xA;}&#xA; $ echo &#39;{&#34;a&#34;:1} [2] 3&#39; | gojq &#39;. as {$a} ?// [$a] ?// $a | $a&#39;&#xA;1&#xA;2&#xA;3&#xA; $ echo &#39;{&#34;foo&#34;: 4722366482869645213696}&#39; | gojq .foo&#xA;4722366482869645213696  # keeps the precision of large numbers&#xA; $ gojq -n &#39;def fact($n): if $n &amp;lt; 1 then 1 else $n * fact($n - 1) end; fact(50)&#39;&#xA;30414093201713378043612608166064768844377641568960512000000000000 # arbitrary-precision integer calculation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nice error messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt; $ echo &#39;[1,2,3]&#39; | gojq &#39;.foo &amp;amp; .bar&#39;&#xA;gojq: invalid query: .foo &amp;amp; .bar&#xA;    .foo &amp;amp; .bar&#xA;         ^  unexpected token &#34;&amp;amp;&#34;&#xA; $ echo &#39;{&#34;foo&#34;: { bar: [] } }&#39; | gojq &#39;.&#39;&#xA;gojq: invalid json: &amp;lt;stdin&amp;gt;&#xA;    {&#34;foo&#34;: { bar: [] } }&#xA;              ^  invalid character &#39;b&#39; looking for beginning of object key string&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Homebrew&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install gojq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Zero Install&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;0install add gojq https://apps.0install.net/utils/gojq.xml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build from source&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go install github.com/itchyny/gojq/cmd/gojq@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -i --rm itchyny/gojq&#xA;docker run -i --rm ghcr.io/itchyny/gojq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Difference to jq&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;gojq is purely implemented with Go language and is completely portable. jq depends on the C standard library so the availability of math functions depends on the library. jq also depends on the regular expression library and it makes build scripts complex.&lt;/li&gt; &#xA; &lt;li&gt;gojq implements nice error messages for invalid query and JSON input. The error message of jq is sometimes difficult to tell where to fix the query.&lt;/li&gt; &#xA; &lt;li&gt;gojq does not keep the order of object keys. I understand this might cause problems for some scripts but basically, we should not rely on the order of object keys. Due to this limitation, gojq does not have &lt;code&gt;keys_unsorted&lt;/code&gt; function and &lt;code&gt;--sort-keys&lt;/code&gt; (&lt;code&gt;-S&lt;/code&gt;) option. I would implement when ordered map is implemented in the standard library of Go but I&#39;m less motivated.&lt;/li&gt; &#xA; &lt;li&gt;gojq supports arbitrary-precision integer calculation while jq does not; jq loses the precision of large integers when calculation is involved. Note that even with gojq, all mathematical functions, including &lt;code&gt;floor&lt;/code&gt; and &lt;code&gt;round&lt;/code&gt;, convert integers to floating-point numbers; only addition, subtraction, multiplication, modulo, and division operators (when divisible) keep the integer precision. To calculate floor division of integers without losing the precision, use &lt;code&gt;def idivide($n): (. - . % $n) / $n;&lt;/code&gt;. To round down floating-point numbers to integers, use &lt;code&gt;def ifloor: floor | tostring | tonumber;&lt;/code&gt;, but note that this function does not work with large floating-point numbers and also loses the precision of large integers.&lt;/li&gt; &#xA; &lt;li&gt;gojq fixes various bugs of jq. gojq correctly deletes elements of arrays by &lt;code&gt;|= empty&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/2051&#34;&gt;jq#2051&lt;/a&gt;). gojq fixes &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; handling (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1859&#34;&gt;jq#1859&lt;/a&gt;, &lt;a href=&#34;https://github.com/stedolan/jq/issues/1885&#34;&gt;jq#1885&lt;/a&gt;, &lt;a href=&#34;https://github.com/stedolan/jq/issues/2140&#34;&gt;jq#2140&lt;/a&gt;). gojq fixes &lt;code&gt;nth/2&lt;/code&gt; to output nothing when the count is equal to or larger than the stream size (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1867&#34;&gt;jq#1867&lt;/a&gt;). gojq consistently counts by characters (not by bytes) in &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;rindex&lt;/code&gt;, and &lt;code&gt;indices&lt;/code&gt; functions; &lt;code&gt;&#34;１２３４５&#34; | .[index(&#34;３&#34;):]&lt;/code&gt; results in &lt;code&gt;&#34;３４５&#34;&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1430&#34;&gt;jq#1430&lt;/a&gt;, &lt;a href=&#34;https://github.com/stedolan/jq/issues/1624&#34;&gt;jq#1624&lt;/a&gt;). gojq handles overlapping occurrence differently in &lt;code&gt;rindex&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt;; &lt;code&gt;&#34;ababa&#34; | [rindex(&#34;aba&#34;), indices(&#34;aba&#34;)]&lt;/code&gt; results in &lt;code&gt;[2,[0,2]]&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/2433&#34;&gt;jq#2433&lt;/a&gt;). gojq supports string indexing; &lt;code&gt;&#34;abcde&#34;[2]&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1520&#34;&gt;jq#1520&lt;/a&gt;). gojq accepts indexing query &lt;code&gt;.e0&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1526&#34;&gt;jq#1526&lt;/a&gt;, &lt;a href=&#34;https://github.com/stedolan/jq/issues/1651&#34;&gt;jq#1651&lt;/a&gt;), and allows &lt;code&gt;gsub&lt;/code&gt; to handle patterns including &lt;code&gt;&#34;^&#34;&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/2148&#34;&gt;jq#2148&lt;/a&gt;). gojq improves variable lexer to allow using keywords for variable names, especially in binding patterns, also disallows spaces after &lt;code&gt;$&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/526&#34;&gt;jq#526&lt;/a&gt;). gojq fixes handling files with no newline characters at the end (&lt;a href=&#34;https://github.com/stedolan/jq/issues/2374&#34;&gt;jq#2374&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;gojq implements &lt;code&gt;@uri&lt;/code&gt; to escape all the reserved characters defined in RFC 3986, Sec. 2.2 (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1506&#34;&gt;jq#1506&lt;/a&gt;), and fixes &lt;code&gt;@base64d&lt;/code&gt; to allow binary string as the decoded string (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1931&#34;&gt;jq#1931&lt;/a&gt;). gojq improves time formatting and parsing; deals with &lt;code&gt;%f&lt;/code&gt; in &lt;code&gt;strftime&lt;/code&gt; and &lt;code&gt;strptime&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1409&#34;&gt;jq#1409&lt;/a&gt;), parses timezone offsets with &lt;code&gt;fromdate&lt;/code&gt; and &lt;code&gt;fromdateiso8601&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1053&#34;&gt;jq#1053&lt;/a&gt;), supports timezone name/offset with &lt;code&gt;%Z&lt;/code&gt;/&lt;code&gt;%z&lt;/code&gt; in &lt;code&gt;strptime&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/929&#34;&gt;jq#929&lt;/a&gt;, &lt;a href=&#34;https://github.com/stedolan/jq/issues/2195&#34;&gt;jq#2195&lt;/a&gt;), and looks up correct timezone during daylight saving time on formatting with &lt;code&gt;%Z&lt;/code&gt; (&lt;a href=&#34;https://github.com/stedolan/jq/issues/1912&#34;&gt;jq#1912&lt;/a&gt;). gojq supports nanoseconds in date and time functions.&lt;/li&gt; &#xA; &lt;li&gt;gojq does not support some functions intentionally; &lt;code&gt;get_jq_origin&lt;/code&gt;, &lt;code&gt;get_prog_origin&lt;/code&gt;, &lt;code&gt;get_search_list&lt;/code&gt; (unstable, not listed in jq document), &lt;code&gt;input_line_number&lt;/code&gt;, &lt;code&gt;$__loc__&lt;/code&gt; (performance issue), &lt;code&gt;recurse_down&lt;/code&gt; (deprecated in jq). gojq does not support some flags; &lt;code&gt;--ascii-output, -a&lt;/code&gt; (performance issue), &lt;code&gt;--seq&lt;/code&gt; (not used commonly), &lt;code&gt;--sort-keys, -S&lt;/code&gt; (sorts by default because &lt;code&gt;map[string]interface{}&lt;/code&gt; does not keep the order), &lt;code&gt;--unbuffered&lt;/code&gt; (unbuffered by default). gojq does not parse JSON extensions supported by jq; &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, and &lt;code&gt;[000]&lt;/code&gt;. gojq normalizes floating-point numbers to fit to double-precision floating-point numbers. gojq does not support some regular expression flags (regular expression engine differences). gojq does not support BOM (&lt;code&gt;encoding/json&lt;/code&gt; does not support this). gojq disallows using keywords for function names (declaration of &lt;code&gt;def true: .;&lt;/code&gt; is a confusing query).&lt;/li&gt; &#xA; &lt;li&gt;gojq supports reading from YAML input (&lt;code&gt;--yaml-input&lt;/code&gt;) while jq does not. gojq also supports YAML output (&lt;code&gt;--yaml-output&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Color configuration&lt;/h3&gt; &#xA;&lt;p&gt;The gojq command automatically disables coloring output when the output is not a tty. To force coloring output, specify &lt;code&gt;--color-output&lt;/code&gt; (&lt;code&gt;-C&lt;/code&gt;) option. When &lt;a href=&#34;https://no-color.org/&#34;&gt;&lt;code&gt;NO_COLOR&lt;/code&gt; environment variable&lt;/a&gt; is present or &lt;code&gt;--monochrome-output&lt;/code&gt; (&lt;code&gt;-M&lt;/code&gt;) option is specified, gojq disables coloring output.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;GOJQ_COLORS&lt;/code&gt; environment variable to configure individual colors. The variable is a colon-separated list of ANSI escape sequences of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, numbers, strings, object keys, arrays, and objects. The default configuration is &lt;code&gt;90:33:33:36:32:34;1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage as a library&lt;/h2&gt; &#xA;&lt;p&gt;You can use the gojq parser and interpreter from your Go products.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/itchyny/gojq&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;query, err := gojq.Parse(&#34;.foo | ..&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatalln(err)&#xA;&#x9;}&#xA;&#x9;input := map[string]interface{}{&#34;foo&#34;: []interface{}{1, 2, 3}}&#xA;&#x9;iter := query.Run(input) // or query.RunWithContext&#xA;&#x9;for {&#xA;&#x9;&#x9;v, ok := iter.Next()&#xA;&#x9;&#x9;if !ok {&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if err, ok := v.(error); ok {&#xA;&#x9;&#x9;&#x9;log.Fatalln(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Printf(&#34;%#v\n&#34;, v)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Firstly, use &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Parse&#34;&gt;&lt;code&gt;gojq.Parse(string) (*Query, error)&lt;/code&gt;&lt;/a&gt; to get the query from a string.&lt;/li&gt; &#xA; &lt;li&gt;Secondly, get the result iterator &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;using &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Query.Run&#34;&gt;&lt;code&gt;query.Run&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Query.RunWithContext&#34;&gt;&lt;code&gt;query.RunWithContext&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;or alternatively, compile the query using &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Compile&#34;&gt;&lt;code&gt;gojq.Compile&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Code.Run&#34;&gt;&lt;code&gt;code.Run&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Code.RunWithContext&#34;&gt;&lt;code&gt;code.RunWithContext&lt;/code&gt;&lt;/a&gt;. You can reuse the &lt;code&gt;*Code&lt;/code&gt; against multiple inputs to avoid compilation of the same query. But for arguments of &lt;code&gt;code.Run&lt;/code&gt;, do not give values sharing same data between multiple calls.&lt;/li&gt; &#xA;   &lt;li&gt;In either case, you cannot use custom type values as the query input. The type should be &lt;code&gt;[]interface{}&lt;/code&gt; for an array and &lt;code&gt;map[string]interface{}&lt;/code&gt; for a map (just like decoded to an &lt;code&gt;interface{}&lt;/code&gt; using the &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34;&gt;encoding/json&lt;/a&gt; package). You can&#39;t use &lt;code&gt;[]int&lt;/code&gt; or &lt;code&gt;map[string]string&lt;/code&gt;, for example. If you want to query your custom struct, marshal to JSON, unmarshal to &lt;code&gt;interface{}&lt;/code&gt; and use it as the query input.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Thirdly, iterate through the results using &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Iter&#34;&gt;&lt;code&gt;iter.Next() (interface{}, bool)&lt;/code&gt;&lt;/a&gt;. The iterator can emit an error so make sure to handle it. The method returns &lt;code&gt;true&lt;/code&gt; with results, and &lt;code&gt;false&lt;/code&gt; when the iterator terminates. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The return type is not &lt;code&gt;(interface{}, error)&lt;/code&gt; because iterators can emit multiple errors and you can continue after an error. It is difficult for the iterator to tell the termination in this situation.&lt;/li&gt; &#xA;   &lt;li&gt;Note that the result iterator may emit infinite number of values; &lt;code&gt;repeat(0)&lt;/code&gt; and &lt;code&gt;range(infinite)&lt;/code&gt;. It may stuck with no output value; &lt;code&gt;def f: f; f&lt;/code&gt;. Use &lt;code&gt;RunWithContext&lt;/code&gt; when you want to limit the execution time.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Compile&#34;&gt;&lt;code&gt;gojq.Compile&lt;/code&gt;&lt;/a&gt; allows to configure the following compiler options.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#WithModuleLoader&#34;&gt;&lt;code&gt;gojq.WithModuleLoader&lt;/code&gt;&lt;/a&gt; allows to load modules. By default, the module feature is disabled. If you want to load modules from the file system, use &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#NewModuleLoader&#34;&gt;&lt;code&gt;gojq.NewModuleLoader&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#WithEnvironLoader&#34;&gt;&lt;code&gt;gojq.WithEnvironLoader&lt;/code&gt;&lt;/a&gt; allows to configure the environment variables referenced by &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;$ENV&lt;/code&gt;. By default, OS environment variables are not accessible due to security reasons. You can use &lt;code&gt;gojq.WithEnvironLoader(os.Environ)&lt;/code&gt; if you want.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#WithVariables&#34;&gt;&lt;code&gt;gojq.WithVariables&lt;/code&gt;&lt;/a&gt; allows to configure the variables which can be used in the query. Pass the values of the variables to &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Code.Run&#34;&gt;&lt;code&gt;code.Run&lt;/code&gt;&lt;/a&gt; in the same order.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#WithFunction&#34;&gt;&lt;code&gt;gojq.WithFunction&lt;/code&gt;&lt;/a&gt; allows to add a custom internal function. An internal function can return a single value (which can be an error) each invocation. To add a jq function (which may include a comma operator to emit multiple values, &lt;code&gt;empty&lt;/code&gt; function, accept a filter for its argument, or call another built-in function), use &lt;code&gt;LoadInitModules&lt;/code&gt; of the module loader.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#WithIterFunction&#34;&gt;&lt;code&gt;gojq.WithIterFunction&lt;/code&gt;&lt;/a&gt; allows to add a custom iterator function. An iterator function returns an iterator to emit multiple values. You cannot define both iterator and non-iterator functions of the same name (with possibly different arities). You can use &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#NewIter&#34;&gt;&lt;code&gt;gojq.NewIter&lt;/code&gt;&lt;/a&gt; to convert values or an error to a &lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#Iter&#34;&gt;&lt;code&gt;gojq.Iter&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/itchyny/gojq#WithInputIter&#34;&gt;&lt;code&gt;gojq.WithInputIter&lt;/code&gt;&lt;/a&gt; allows to use &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;inputs&lt;/code&gt; functions. By default, these functions are disabled.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Bug Tracker&lt;/h2&gt; &#xA;&lt;p&gt;Report bug at &lt;a href=&#34;https://github.com/itchyny/gojq/issues&#34;&gt;Issues・itchyny/gojq - GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;itchyny (&lt;a href=&#34;https://github.com/itchyny&#34;&gt;https://github.com/itchyny&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This software is released under the MIT License, see LICENSE.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>coroot/coroot</title>
    <updated>2022-09-22T01:32:56Z</updated>
    <id>tag:github.com,2022-09-22:/coroot/coroot</id>
    <link href="https://github.com/coroot/coroot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A monitoring and troubleshooting tool for microservice architectures.&lt;/p&gt;&lt;hr&gt;&lt;img width=&#34;200&#34; src=&#34;https://coroot.com/static/logo_u.png&#34;&gt; &#xA;&lt;p&gt;Coroot is a monitoring and troubleshooting tool for microservice architectures.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/coroot/coroot/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;&#34;&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/coroot/coroot&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/coroot/coroot&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache_2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;800&#34; src=&#34;https://user-images.githubusercontent.com/194465/187667684-224cfa32-96cd-44f0-87f7-0528b3dd7bb9.gif&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h3&gt;eBPF-based service mapping&lt;/h3&gt; &#xA;&lt;p&gt;Thanks to eBPF, Coroot shows you a comprehensive &lt;a href=&#34;https://coroot.com/blog/building-a-service-map-using-ebpf&#34;&gt;map of your services&lt;/a&gt; without any code changes.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;800&#34; src=&#34;https://raw.githubusercontent.com/coroot/coroot/main/front/public/readme/service-map.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Log analysis without storage costs&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/coroot/coroot-node-agent&#34;&gt;Node-agent&lt;/a&gt; turns terabytes of logs into just a few dozen metrics by extracting &lt;a href=&#34;https://coroot.com/blog/mining-logs-from-unstructured-logs&#34;&gt;repeated patterns&lt;/a&gt; right on the node. Using these metrics allows you to quickly and cost-effectively find the errors relevant to a particular outage.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;800&#34; src=&#34;https://raw.githubusercontent.com/coroot/coroot/main/front/public/readme/logs.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Cloud topology awareness&lt;/h3&gt; &#xA;&lt;p&gt;Coroot uses &lt;a href=&#34;https://coroot.com/blog/cloud-metadata&#34;&gt;cloud metadata&lt;/a&gt; to show which regions and availability zones each application runs in. This is very important to known, because:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Network latency between availability zones within the same region can be higher than within one particular zone.&lt;/li&gt; &#xA; &lt;li&gt;Data transfer between availability zones in the same region is paid, while data transfer within a zone is free.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;800&#34; src=&#34;https://raw.githubusercontent.com/coroot/coroot/main/front/public/readme/topology.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Advanced Postgres observability&lt;/h3&gt; &#xA;&lt;p&gt;Coroot &lt;a href=&#34;https://coroot.com/blog/pg-agent&#34;&gt;makes&lt;/a&gt; troubleshooting Postgres-related issues easier not only for experienced DBAs but also for engineers not specialized in databases.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;800&#34; src=&#34;https://raw.githubusercontent.com/coroot/coroot/main/front/public/readme/postgres.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Integration into your existing monitoring stack&lt;/h3&gt; &#xA;&lt;p&gt;Coroot uses Prometheus as a Time-Series Database (TSDB):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The agents are Prometheus-compatible exporters&lt;/li&gt; &#xA; &lt;li&gt;Coroot itself is a Prometheus client (like Grafana)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;600&#34; src=&#34;https://raw.githubusercontent.com/coroot/coroot/main/front/public/readme/prometheus.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Built-in Prometheus cache&lt;/h3&gt; &#xA;&lt;p&gt;The built-in Prometheus cache allows Coroot to provide you with a blazing fast UI without overloading your Prometheus.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can run Coroot as a Docker container or deploy it into any Kubernetes cluster. Check out the &lt;a href=&#34;https://coroot.com/docs/coroot-community-edition/getting-started/installation&#34;&gt;Installation guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The Coroot documentation is available at &lt;a href=&#34;https://coroot.com/docs/coroot-community-edition&#34;&gt;coroot.com/docs/coroot-community-edition&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Coroot is licensed under the &lt;a href=&#34;https://github.com/coroot/coroot/raw/main/LICENSE&#34;&gt;Apache License, Version 2.0&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>