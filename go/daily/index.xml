<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-21T01:35:13Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>luraproject/lura</title>
    <updated>2024-01-21T01:35:13Z</updated>
    <id>tag:github.com,2024-01-21:/luraproject/lura</id>
    <link href="https://github.com/luraproject/lura" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ultra performant API Gateway with middlewares. A project hosted at The Linux Foundation&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://luraproject.org/images/lura-logo-header.svg?sanitize=true&#34; width=&#34;300&#34;&gt; &#xA;&lt;h1&gt;The Lura Project framework&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://goreportcard.com/report/github.com/luraproject/lura&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/luraproject/lura&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/luraproject/lura&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/luraproject/lura?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://bestpractices.coreinfrastructure.org/projects/3151/badge&#34; alt=&#34;CII Best Practices&#34;&gt; &lt;img src=&#34;https://img.shields.io/docker/pulls/devopsfaith/krakend.svg?sanitize=true&#34; alt=&#34;Docker Pulls&#34;&gt; &lt;a href=&#34;https://gophers.slack.com/messages/lura&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/join-us%20on%20slack-gray.svg?longCache=true&amp;amp;logo=slack&amp;amp;colorB=red&#34; alt=&#34;Slack Widget&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.fossa.com/projects/git%2Bgithub.com%2Fluraproject%2Flura?ref=badge_shield&amp;amp;issueType=license&#34;&gt;&lt;img src=&#34;https://app.fossa.com/api/projects/git%2Bgithub.com%2Fluraproject%2Flura.svg?type=shield&amp;amp;issueType=license&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An open framework to assemble ultra performance API Gateways with middlewares; formerly known as &lt;em&gt;KrakenD framework&lt;/em&gt;, and core service of the &lt;a href=&#34;http://www.krakend.io&#34;&gt;KrakenD API Gateway&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Consumers of REST API content (specially in microservices) often query backend services that weren&#39;t coded for the UI implementation. This is of course a good practice, but the UI consumers need to do implementations that suffer a lot of complexity and burden with the sizes of their microservices responses.&lt;/p&gt; &#xA;&lt;p&gt;Lura is an &lt;strong&gt;API Gateway&lt;/strong&gt; builder and proxy generator that sits between the client and all the source servers, adding a new layer that removes all the complexity to the clients, providing them only the information that the UI needs. Lura acts as an &lt;strong&gt;aggregator&lt;/strong&gt; of many sources into single endpoints and allows you to group, wrap, transform and shrink responses. Additionally it supports a myriad of middlewares and plugins that allow you to extend the functionality, such as adding Oauth authorization or security layers.&lt;/p&gt; &#xA;&lt;p&gt;Lura not only supports HTTP(S), but because it is a set of generic libraries you can build all type of API Gateways and proxies, including for instance, an RPC gateway.&lt;/p&gt; &#xA;&lt;h3&gt;Practical Example&lt;/h3&gt; &#xA;&lt;p&gt;A mobile developer needs to construct a single front page that requires data from 4 different calls to their backend services, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1) api.store.server/products&#xA;2) api.store.server/marketing-promos&#xA;3) api.users.server/users/{id_user}&#xA;4) api.users.server/shopping-cart/{id_user}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The screen is very simple, and the mobile client &lt;em&gt;only&lt;/em&gt; needs to retrieve data from 4 different sources, wait for the round trip and then hand pick only a few fields from the response.&lt;/p&gt; &#xA;&lt;p&gt;What if the mobile could call a single endpoint?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1) lura.server/frontpage/{id_user}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s something Lura can do for you. And this is how it would look like:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://luraproject.org/images/docs/lura-gateway.png&#34; alt=&#34;Gateway&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Lura would merge all the data and return only the fields you need (the difference in size in the graph).&lt;/p&gt; &#xA;&lt;p&gt;Visit the &lt;a href=&#34;https://luraproject.org&#34;&gt;Lura Project website&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s in this repository?&lt;/h2&gt; &#xA;&lt;p&gt;The source code for the &lt;a href=&#34;https://luraproject.org&#34;&gt;Lura project&lt;/a&gt; framework. It is designed to work with your own middleware and extend the functionality by using small, independent, reusable components following the Unix philosophy.&lt;/p&gt; &#xA;&lt;p&gt;Use this repository if you want to &lt;strong&gt;build from source your API Gateway&lt;/strong&gt; or if you want to &lt;strong&gt;reuse the components in another application&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you need a fully functional API Gateway you can &lt;a href=&#34;http://www.krakend.io/download&#34;&gt;download the KrakenD binary for your architecture&lt;/a&gt; or &lt;a href=&#34;https://github.com/krakendio/krakend-ce&#34;&gt;build it yourself&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Library Usage&lt;/h2&gt; &#xA;&lt;p&gt;The Lura project is presented as a &lt;strong&gt;Go library&lt;/strong&gt; that you can include in your own Go application to build a powerful proxy or API gateway. For a complete example, check the &lt;a href=&#34;https://github.com/krakendio/krakend-ce&#34;&gt;KrakenD CE repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Of course, you will need &lt;a href=&#34;https://golang.org/doc/install&#34;&gt;Go installed&lt;/a&gt; in your system to compile the code.&lt;/p&gt; &#xA;&lt;p&gt;A ready to use example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    package main&#xA;&#xA;    import (&#xA;        &#34;flag&#34;&#xA;        &#34;log&#34;&#xA;        &#34;os&#34;&#xA;&#xA;        &#34;github.com/luraproject/lura/config&#34;&#xA;        &#34;github.com/luraproject/lura/logging&#34;&#xA;        &#34;github.com/luraproject/lura/proxy&#34;&#xA;        &#34;github.com/luraproject/lura/router/gin&#34;&#xA;    )&#xA;&#xA;    func main() {&#xA;        port := flag.Int(&#34;p&#34;, 0, &#34;Port of the service&#34;)&#xA;        logLevel := flag.String(&#34;l&#34;, &#34;ERROR&#34;, &#34;Logging level&#34;)&#xA;        debug := flag.Bool(&#34;d&#34;, false, &#34;Enable the debug&#34;)&#xA;        configFile := flag.String(&#34;c&#34;, &#34;/etc/lura/configuration.json&#34;, &#34;Path to the configuration filename&#34;)&#xA;        flag.Parse()&#xA;&#xA;        parser := config.NewParser()&#xA;        serviceConfig, err := parser.Parse(*configFile)&#xA;        if err != nil {&#xA;            log.Fatal(&#34;ERROR:&#34;, err.Error())&#xA;        }&#xA;        serviceConfig.Debug = serviceConfig.Debug || *debug&#xA;        if *port != 0 {&#xA;            serviceConfig.Port = *port&#xA;        }&#xA;&#xA;        logger, _ := logging.NewLogger(*logLevel, os.Stdout, &#34;[LURA]&#34;)&#xA;&#xA;        routerFactory := gin.DefaultFactory(proxy.DefaultFactory(logger), logger)&#xA;&#xA;        routerFactory.New().Run(serviceConfig)&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Visit the &lt;a href=&#34;https://raw.githubusercontent.com/luraproject/lura/master/docs/OVERVIEW.md&#34;&gt;framework overview&lt;/a&gt; for more details about the components of the Lura project.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration file&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/luraproject/lura/master/docs/CONFIG.md&#34;&gt;Lura config file&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://raw.githubusercontent.com/luraproject/lura/master/docs/BENCHMARKS.md&#34;&gt;benchmark results&lt;/a&gt; of several Lura components&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We are always happy to receive contributions. If you have questions, suggestions, bugs please open an issue. If you want to submit the code, create the issue and send us a pull request for review.&lt;/p&gt; &#xA;&lt;p&gt;Read &lt;a href=&#34;https://raw.githubusercontent.com/luraproject/lura/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Want more?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Follow us on Twitter: &lt;a href=&#34;https://twitter.com/luraproject&#34;&gt;@luraproject&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Visit our &lt;a href=&#34;https://gophers.slack.com/messages/lura&#34;&gt;Slack channel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Read the &lt;a href=&#34;https://raw.githubusercontent.com/luraproject/lura/master/docs/OVERVIEW.md&#34;&gt;documentation&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Enjoy Lura!&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.fossa.com/projects/git%2Bgithub.com%2Fluraproject%2Flura?ref=badge_large&#34;&gt;&lt;img src=&#34;https://app.fossa.com/api/projects/git%2Bgithub.com%2Fluraproject%2Flura.svg?type=large&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kubewharf/godel-scheduler</title>
    <updated>2024-01-21T01:35:13Z</updated>
    <id>tag:github.com,2024-01-21:/kubewharf/godel-scheduler</id>
    <link href="https://github.com/kubewharf/godel-scheduler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;an unified scheduler for online and offline tasks&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Gödel Unified Scheduling System&lt;/h2&gt; &#xA;&lt;p&gt;Gödel represents a comprehensive scheduling and resource management platform designed for various business groups to efficiently operate their diverse cloud-native workloads. It features an integrated quota management system and a scheduler that administers a consolidated resource pool. The Gödel scheduling system is a critical component in the management of clusters.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to the Gödel architecture, we can realize enhanced performance in terms of resource utilization, resource elasticity, and scheduling throughput, optimizing the overall functionality and efficiency of cluster management.&lt;/p&gt; &#xA;&lt;h2&gt;Overall Architecture&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kubewharf/godel-scheduler/main/docs/images/godel-arch.png&#34; alt=&#34;godel-arch&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Drawing inspiration from the Kubernetes scheduler and incorporating the concept of optimistic concurrency, we have optimized the most time-intensive process of matching application nodes—encompassing both filtering and scoring—within the scheduler component. This approach allows for concurrent execution, enhancing the scheduling throughput for large-scale clusters.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Our two-tiered scheduling semantic abstraction, comprising Unit and Pod, along with its framework implementation, offers a more versatile &#34;batch&#34; scheduling capability. This significantly bolsters support for offline services while simultaneously enhancing throughput and scalability.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The system boasts a plethora of features coupled with outstanding performance, fulfilling a diverse range of business requirements including online, offline (batch, stream), and training operations, thereby achieving truly unified scheduling.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;While remaining compatible with the Kubernetes ecosystem and serving as a potential substitute for the Kubernetes scheduler, our framework distinguishes itself through performance and architectural advancements. Although the framework interface deviates slightly from that of the Kubernetes scheduler, its extensibility remains uncompromised. Scheduling plugins can be developed in a manner akin to Kubernetes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start Guide for Key Features&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to the below links for quick start guides on key features. Please note that Gödel supports Kubernetes versions from 1.21.4 up to 1.24.6. Using lower or higher Kubernetes versions may cause compatibility issues.&lt;/p&gt; &#xA;&lt;!-- TODO: Link the corresponding Markdown pages below --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubewharf/godel-scheduler/main/docs/features/basic-pod.md&#34;&gt;Basic Pod Scheduling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubewharf/godel-scheduler/main/docs/features/gang-scheduling.md&#34;&gt;Gang Scheduling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubewharf/godel-scheduler/main/docs/features/preemption.md&#34;&gt;Preemption&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubewharf/godel-scheduler/main/docs/features/job-level-affinity.md&#34;&gt;Job Level Affinity&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubewharf/godel-scheduler/main/docs/features/concurrent-scheduling.md&#34;&gt;SubCluster Concurrent Scheduling&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contribution Guide&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://raw.githubusercontent.com/kubewharf/godel-scheduler/main/CONTRIBUTING.md&#34;&gt;Contribution&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>