<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-03T01:36:50Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>go-micro/go-micro</title>
    <updated>2022-10-03T01:36:50Z</updated>
    <id>tag:github.com,2022-10-03:/go-micro/go-micro</id>
    <link href="https://github.com/go-micro/go-micro" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Go microservices framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Go Micro &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/:license-apache-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/go-micro.dev/v4?tab=doc&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/go.dev-reference-007d9c?logo=go&amp;amp;logoColor=white&amp;amp;style=flat-square&#34; alt=&#34;Go.Dev reference&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/go-micro/go-micro&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/go-micro/go-micro&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/qV3HvnEJfB&#34;&gt;&lt;img src=&#34;https://dcbadge.vercel.app/api/server/qV3HvnEJfB?style=flat-square&amp;amp;theme=default-inverted&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Go Micro is a framework for distributed systems development.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Go Micro provides the core requirements for distributed systems development including RPC and Event driven communication. The Go Micro philosophy is sane defaults with a pluggable architecture. We provide defaults to get you started quickly but everything can be easily swapped out.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Go Micro abstracts away the details of distributed systems. Here are the main features.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Authentication&lt;/strong&gt; - Auth is built in as a first class citizen. Authentication and authorization enable secure zero trust networking by providing every service an identity and certificates. This additionally includes rule based access control.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Dynamic Config&lt;/strong&gt; - Load and hot reload dynamic config from anywhere. The config interface provides a way to load application level config from any source such as env vars, file, etcd. You can merge the sources and even define fallbacks.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Data Storage&lt;/strong&gt; - A simple data store interface to read, write and delete records. It includes support for memory, file and CockroachDB by default. State and persistence becomes a core requirement beyond prototyping and Micro looks to build that into the framework.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Service Discovery&lt;/strong&gt; - Automatic service registration and name resolution. Service discovery is at the core of micro service development. When service A needs to speak to service B it needs the location of that service. The default discovery mechanism is multicast DNS (mdns), a zeroconf system.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Load Balancing&lt;/strong&gt; - Client side load balancing built on service discovery. Once we have the addresses of any number of instances of a service we now need a way to decide which node to route to. We use random hashed load balancing to provide even distribution across the services and retry a different node if there&#39;s a problem.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Message Encoding&lt;/strong&gt; - Dynamic message encoding based on content-type. The client and server will use codecs along with content-type to seamlessly encode and decode Go types for you. Any variety of messages could be encoded and sent from different clients. The client and server handle this by default. This includes protobuf and json by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;RPC Client/Server&lt;/strong&gt; - RPC based request/response with support for bidirectional streaming. We provide an abstraction for synchronous communication. A request made to a service will be automatically resolved, load balanced, dialled and streamed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Async Messaging&lt;/strong&gt; - PubSub is built in as a first class citizen for asynchronous communication and event driven architectures. Event notifications are a core pattern in micro service development. The default messaging system is a HTTP event message broker.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Event Streaming&lt;/strong&gt; - PubSub is great for async notifications but for more advanced use cases event streaming is preferred. Offering persistent storage, consuming from offsets and acking. Go Micro includes support for NATS Jetstream and Redis streams.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt; - Distributed systems are often built in an eventually consistent manner. Support for distributed locking and leadership are built in as a Sync interface. When using an eventually consistent database or scheduling use the Sync interface.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Pluggable Interfaces&lt;/strong&gt; - Go Micro makes use of Go interfaces for each distributed system abstraction. Because of this these interfaces are pluggable and allows Go Micro to be runtime agnostic. You can plugin any underlying technology.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;To make use of Go Micro&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;import &#34;go-micro.dev/v4&#34;&#xA;&#xA;// create a new service&#xA;service := micro.NewService(&#xA;    micro.Name(&#34;helloworld&#34;),&#xA;)&#xA;&#xA;// initialise flags&#xA;service.Init()&#xA;&#xA;// start the service&#xA;service.Run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/go-micro/examples&#34;&gt;examples&lt;/a&gt; for detailed information on usage.&lt;/p&gt; &#xA;&lt;h2&gt;Toolkit&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/go-micro&#34;&gt;github.com/go-micro&lt;/a&gt; for tooling.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/go-micro/api&#34;&gt;API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/go-micro/cli&#34;&gt;CLI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/go-micro/demo&#34;&gt;Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/go-micro/plugins&#34;&gt;Plugins&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/go-micro/examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/go-micro/dashboard&#34;&gt;Dashboard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/go-micro/generator&#34;&gt;Generator&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/micro/go-micro/tree/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt; for release history.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Go Micro is Apache 2.0 licensed.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>noisetorch/NoiseTorch</title>
    <updated>2022-10-03T01:36:50Z</updated>
    <id>tag:github.com,2022-10-03:/noisetorch/NoiseTorch</id>
    <link href="https://github.com/noisetorch/NoiseTorch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Real-time microphone noise suppression on Linux.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; NoiseTorch-ng&lt;/h1&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt; Noise Supression Application for PulseAudio or Pipewire&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/noisetorch/NoiseTorch/master/assets/icon/noisetorch.png&#34; width=&#34;100&#34; height=&#34;100&#34;&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-GPLv3-blue.svg?sanitize=true&#34; alt=&#34;Licence&#34;&gt;&lt;/a&gt; &lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/noisetorch/NoiseTorch/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/noisetorch/NoiseTorch?label=Latest&amp;amp;style=flat&#34; alt=&#34;Latest&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;NoiseTorch-ng is an easy to use open source application for Linux with PulseAudio or PipeWire. It creates a virtual microphone that suppresses noise, in any application. Use whichever conferencing or VOIP application you like and simply select the filtered Virtual Microphone as input to torch the sound of your mechanical keyboard, computer fans, trains and the likes.&lt;/p&gt; &#xA;&lt;p&gt;Don&#39;t forget to leave a star ‚≠ê if this sounds useful to you!&lt;/p&gt; &#xA;&lt;h2&gt;Regarding the recent security incident&lt;/h2&gt; &#xA;&lt;p&gt;Due to a suspected security breach of the update server and code repository, there&#39;s been a concerted effort by the NoiseTorch community to ensure the source code and binaries are free from malicious code.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;No malicious code has been found.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can read more about the audit that was done &lt;a href=&#34;https://github.com/noisetorch/NoiseTorch/discussions/275&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/noisetorch/NoiseTorch/discussions/264&#34;&gt;here&lt;/a&gt;. Updates will now be retrieved from the project&#39;s releases page to avoid any risk of this reoccurring. We thank everyone for their trust and the love that they&#39;ve shown towards the project in this unpleasant time.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/T2wH0bl.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then simply select &#34;Filtered&#34; as your microphone in any application. OBS, Mumble, Discord, anywhere.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nimi7Ne.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;Linux For Everyone has a good demo video &lt;a href=&#34;https://www.youtube.com/watch?v=DzN9rYNeeIU&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Two click setup of your virtual denoising microphone&lt;/li&gt; &#xA; &lt;li&gt;A single, small, statically linked, self-contained binary&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Download &amp;amp; Install&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/noisetorch/NoiseTorch/releases&#34;&gt;Download the latest release from GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unpack the &lt;code&gt;tgz&lt;/code&gt; file, into your home directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tar -C $HOME -h -xzf NoiseTorch_x64_v0.12.2.tgz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will unpack the application, icon and desktop entry to the correct place.&lt;br&gt; Depending on your desktop environment you may need to wait for it to rescan for applications, or tell it to do a refresh now.&lt;/p&gt; &#xA;&lt;p&gt;With gnome this can be done with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gtk-update-icon-cache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You now have a &lt;code&gt;noisetorch&lt;/code&gt; binary and desktop entry on your system.&lt;/p&gt; &#xA;&lt;p&gt;Give it the required permissions with &lt;code&gt;setcap&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo setcap &#39;CAP_SYS_RESOURCE=+ep&#39; ~/.local/bin/noisetorch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If NoiseTorch-ng doesn&#39;t start after installation, you may also have to make sure that &lt;code&gt;~/.local/bin&lt;/code&gt; is in your PATH. On most distributions e.g. Ubuntu, this should be the case by default. If it&#39;s not, make sure to append&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;if [ -d &#34;$HOME/.local/bin&#34; ] ; then&#xA;    PATH=&#34;$HOME/.local/bin:$PATH&#34;&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your &lt;code&gt;~/.profile&lt;/code&gt;. If you do already have that, you may have to log in and out for it to actually apply if this is the first time you&#39;re using &lt;code&gt;~/.local/bin&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Uninstall&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rm ~/.local/bin/noisetorch&#xA;rm ~/.local/share/applications/noisetorch.desktop&#xA;rm ~/.local/share/icons/hicolor/256x256/apps/noisetorch.png &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://github.com/noisetorch/NoiseTorch/wiki/Troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt; section in the wiki.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Select the microphone you want to denoise, and click &#34;Load&#34;, NoiseTorch-ng will create a virtual microphone called &#34;Filtered Microphone&#34; that you can select in any application. Output filtering works the same way, simply output the applications you want to filter to &#34;Filtered Headphones&#34;.&lt;/p&gt; &#xA;&lt;p&gt;When you&#39;re done using it, simply click &#34;Unload&#34; to remove it again, until you need it next time.&lt;/p&gt; &#xA;&lt;p&gt;The slider &#34;Voice Activation Threshold&#34; under settings, allows you to choose how strict NoiseTorch-ng should be in only allowing your microphone to send sounds when it detects voice.. Generally you want this up as high as possible. With a decent microphone, you can turn this to the maximum of 95%. If you cut out during talking, slowly lower this strictness until you find a value that works for you.&lt;/p&gt; &#xA;&lt;p&gt;If you set this to 0%, NoiseTorch-ng will still dampen noise, but not deactivate your microphone if it doesn&#39;t detect voice.&lt;/p&gt; &#xA;&lt;p&gt;Please keep in mind that you will need to reload NoiseTorch-ng for these changes to apply.&lt;/p&gt; &#xA;&lt;p&gt;Once NoiseTorch-ng has been loaded, feel free to close the window, the virtual microphone will continue working until you explicitly unload it. The NoiseTorch-ng process is not required anymore once it has been loaded.&lt;/p&gt; &#xA;&lt;h2&gt;Latency&lt;/h2&gt; &#xA;&lt;p&gt;NoiseTorch-ng may introduce a small amount of latency for microphone filtering. The amount of inherent latency introduced by noise supression is 10ms, this is very low and should not be a problem. Additionally PulseAudio currently introduces a variable amount of latency that depends on your system. Lowering this latency &lt;a href=&#34;https://gitlab.freedesktop.org/pulseaudio/pulseaudio/-/issues/120&#34;&gt;requires a change in PulseAudio&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Output filtering currently introduces something on the order of ~100ms with pulseaudio. This should still be fine for regular conferences, VOIPing and gaming. Maybe not for competitive gaming teams.&lt;/p&gt; &#xA;&lt;h2&gt;Building from source&lt;/h2&gt; &#xA;&lt;p&gt;Install the Go compiler from &lt;a href=&#34;https://golang.org/&#34;&gt;golang.org&lt;/a&gt;. And make sure you have a working C++ compiler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; git clone https://github.com/noisetorch/NoiseTorch # Clone the repository&#xA; cd NoiseTorch # cd into the cloned repository&#xA; make # build it&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To install it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cp ./bin/noisetorch ~/.local/bin&#xA;cp ./assets/noisetorch.desktop ~/.local/share/applications&#xA;cp ./assets/icon/noisetorch.png ~/.local/share/icons/hicolor/256x256/apps&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Special thanks to&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lawl&#34;&gt;@lawl&lt;/a&gt; Creator of NoiseTorch&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://xiph.org&#34;&gt;xiph.org&lt;/a&gt;/&lt;a href=&#34;https://mozilla.org&#34;&gt;Mozilla&#39;s&lt;/a&gt; excellent &lt;a href=&#34;https://jmvalin.ca/demo/rnnoise/&#34;&gt;RNNoise&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/werman/&#34;&gt;@werman&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/werman/noise-suppression-for-voice/&#34;&gt;noise-suppression-for-voice&lt;/a&gt; for the inspiration&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/aarzilli/&#34;&gt;@aarzilli&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/aarzilli/nucular&#34;&gt;nucular&lt;/a&gt; GUI toolkit for Go.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.salleedesign.com&#34;&gt;Sallee Design&lt;/a&gt; (&lt;a href=&#34;mailto:info@salleedesign.com&#34;&gt;info@salleedesign.com&lt;/a&gt;)&#39;s Microphone Icon under &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;CC BY 4.0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>procyon-projects/chrono</title>
    <updated>2022-10-03T01:36:50Z</updated>
    <id>tag:github.com,2022-10-03:/procyon-projects/chrono</id>
    <link href="https://github.com/procyon-projects/chrono" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Chrono is a scheduler library that lets you run your task and code periodically&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/5354910/118358070-739adb00-b57d-11eb-989b-68baf83f9584.png&#34; alt=&#34;chrono&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://goreportcard.com/report/github.com/procyon-projects/chrono&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/procyon-projects/chrono&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dl.circleci.com/status-badge/redirect/gh/procyon-projects/chrono/tree/main&#34;&gt;&lt;img src=&#34;https://dl.circleci.com/status-badge/img/gh/procyon-projects/chrono/tree/main.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/procyon-projects/chrono&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/procyon-projects/chrono/branch/main/graph/badge.svg?token=OREV0YI8VU&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Chrono is a scheduler library that lets you run your tasks and code periodically. It provides different scheduling functionalities to make it easier to create a scheduling task.&lt;/p&gt; &#xA;&lt;h2&gt;Scheduling a One-Shot&amp;nbsp;Task&lt;/h2&gt; &#xA;&lt;p&gt;The Schedule method helps us schedule the task to run once at the specified time. In the following example, the task will first be executed 1 second after the current time. &lt;strong&gt;WithTime&lt;/strong&gt; option is used to specify the execution time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;taskScheduler := chrono.NewDefaultTaskScheduler()&#xA;now := time.Now()&#xA;startTime := now.Add(time.Second * 1)&#xA;&#xA;task, err := taskScheduler.Schedule(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;One-Shot Task&#34;)&#xA;}, chrono.WithTime(startTime))&#xA;&#xA;if err == nil {&#xA;&#x9;log.Print(&#34;Task has been scheduled successfully.&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, &lt;strong&gt;WithStartTime&lt;/strong&gt; option can be used to specify the execution time. &lt;strong&gt;But It&#39;s deprecated.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;taskScheduler := chrono.NewDefaultTaskScheduler()&#xA;&#xA;task, err := taskScheduler.Schedule(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;One-Shot Task&#34;)&#xA;}, chrono.WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()+1))&#xA;&#xA;if err == nil {&#xA;&#x9;log.Print(&#34;Task has been scheduled successfully.&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scheduling a Task with Fixed&amp;nbsp;Delay&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s schedule a task to run with a fixed delay between the finish time of the last execution of the task and the start time of the next execution of the task. The fixed delay counts the delay after the completion of the last execution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;taskScheduler := chrono.NewDefaultTaskScheduler()&#xA;&#xA;task, err := taskScheduler.ScheduleWithFixedDelay(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;Fixed Delay Task&#34;)&#xA;&#x9;time.Sleep(3 * time.Second)&#xA;}, 5 * time.Second)&#xA;&#xA;if err == nil {&#xA;&#x9;log.Print(&#34;Task has been scheduled successfully.&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since the task itself takes 3 seconds to complete and we have specified a delay of 5 seconds between the finish time of the last execution of the task and the start time of the next execution of the task, there will be a delay of 8 seconds between each execution.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;WithStartTime&lt;/strong&gt; and &lt;strong&gt;WithLocation&lt;/strong&gt; options can be combined with this.&lt;/p&gt; &#xA;&lt;h2&gt;Schedule Task at a Fixed Rate&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s schedule a task to run at a fixed rate of seconds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;taskScheduler := chrono.NewDefaultTaskScheduler()&#xA;&#xA;task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;Fixed Rate of 5 seconds&#34;)&#xA;}, 5 * time.Second)&#xA;&#xA;if err == nil {&#xA;&#x9;log.Print(&#34;Task has been scheduled successfully.&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The next task will run always after 5 seconds no matter the status of the previous task, which may be still running. So even if the previous task isn&#39;t done, the next task will run. We can also use the &lt;strong&gt;WithStartTime&lt;/strong&gt; option to specify the desired first execution time of the task.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;now := time.Now()&#xA;&#xA;task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;Fixed Rate of 5 seconds&#34;)&#xA;}, 5 * time.Second, chrono.WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second() + 2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we use this option, the task will run at the specified execution time and subsequently with the given period. In the above example, the task will first be executed 2 seconds after the current time.&lt;/p&gt; &#xA;&lt;p&gt;We can also combine this option with &lt;strong&gt;WithLocation&lt;/strong&gt; based on our requirements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;now := time.Now()&#xA;&#xA;task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;Fixed Rate of 5 seconds&#34;)&#xA;}, 5 * time.Second, chrono.WithStartTime(now.Year(), now.Month(), now.Day(), 18, 45, 0),&#xA;chrono.WithLocation(&#34;America/New_York&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, the task will first be executed at 18:45 of the current date in America/New York time. &lt;strong&gt;If the start time is in the past, the task will be executed immediately.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Scheduling a Task using Cron Expression&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes Fixed Rate and Fixed Delay can not fulfill your needs, and we need the flexibility of cron expressions to schedule the execution of your tasks. With the help of the provided &lt;strong&gt;ScheduleWithCron method&lt;/strong&gt;, we can schedule a task based on a cron expression.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;taskScheduler := chrono.NewDefaultTaskScheduler()&#xA;&#xA;task, err := taskScheduler.ScheduleWithCron(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;Scheduled Task With Cron&#34;)&#xA;}, &#34;0 45 18 10 * *&#34;)&#xA;&#xA;if err == nil {&#xA;&#x9;log.Print(&#34;Task has been scheduled&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, we&#39;re scheduling a task to be executed at 18:45 on the 10th day of every month&lt;/p&gt; &#xA;&lt;p&gt;By default, the local time is used for the cron expression. However, we can use the &lt;strong&gt;WithLocation&lt;/strong&gt; option to change this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;task, err := taskScheduler.ScheduleWithCron(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;Scheduled Task With Cron&#34;)&#xA;}, &#34;0 45 18 10 * *&#34;, chrono.WithLocation(&#34;America/New_York&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, Task will be scheduled to be executed at 18:45 on the 10th day of every month in America/New York time.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;WithStartTimeoption&lt;/strong&gt; cannot be used with &lt;strong&gt;ScheduleWithCron&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Canceling a Scheduled Task&lt;/h2&gt; &#xA;&lt;p&gt;Schedule methods return an instance of type ScheduledTask, which allows us to cancel a task or to check if the task is canceled. The Cancel method cancels the scheduled task but running tasks won&#39;t be interrupted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;taskScheduler := chrono.NewDefaultTaskScheduler()&#xA;&#xA;task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {&#xA;&#x9;log.Print(&#34;Fixed Rate of 5 seconds&#34;)&#xA;}, 5 * time.Second)&#xA;&#xA;/* ... */&#xA;&#x9;&#xA;task.Cancel()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Shutting Down a Scheduler&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;Shutdown()&lt;/strong&gt; method doesn&#39;t cause immediate shut down of the Scheduler and returns a channel. It will make the Scheduler stop accepting new tasks and shut down after all running tasks finish their current work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;taskScheduler := chrono.NewDefaultTaskScheduler()&#xA;&#xA;/* ... */&#xA;&#xA;shutdownChannel := taskScheduler.Shutdown()&#xA;&amp;lt;- shutdownChannel&#xA;&#x9;&#xA;/* after all running task finished their works */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Stargazers&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/procyon-projects/chrono/stargazers&#34;&gt;&lt;img src=&#34;https://reporoster.com/stars/procyon-projects/chrono&#34; alt=&#34;Stargazers repo roster for @procyon-projects/chrono&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Forkers&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/procyon-projects/chrono/network/members&#34;&gt;&lt;img src=&#34;https://reporoster.com/forks/procyon-projects/chrono&#34; alt=&#34;Forkers repo roster for @procyon-projects/chrono&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Chrono is released under MIT License.&lt;/p&gt;</summary>
  </entry>
</feed>