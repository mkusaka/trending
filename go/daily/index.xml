<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-01T01:33:09Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>onsi/ginkgo</title>
    <updated>2022-09-01T01:33:09Z</updated>
    <id>tag:github.com,2022-09-01:/onsi/ginkgo</id>
    <link href="https://github.com/onsi/ginkgo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Modern Testing Framework for Go&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://onsi.github.io/ginkgo/images/ginkgo.png&#34; alt=&#34;Ginkgo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/onsi/ginkgo/actions?query=workflow%3Atest+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/onsi/ginkgo/workflows/test/badge.svg?branch=master&#34; alt=&#34;test&#34;&gt;&lt;/a&gt; | &lt;a href=&#34;https://onsi.github.io/ginkgo/&#34;&gt;Ginkgo Docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Ginkgo 2.0 is now Generally Available!&lt;/h1&gt; &#xA;&lt;p&gt;You can learn more about 2.0 in the &lt;a href=&#34;https://onsi.github.io/ginkgo/MIGRATING_TO_V2&#34;&gt;Migration Guide&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Ginkgo is a mature testing framework for Go designed to help you write expressive specs. Ginkgo builds on top of Go&#39;s &lt;code&gt;testing&lt;/code&gt; foundation and is complemented by the &lt;a href=&#34;https://github.com/onsi/gomega&#34;&gt;Gomega&lt;/a&gt; matcher library. Together, Ginkgo and Gomega let you express the intent behind your specs clearly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    . &#34;github.com/onsi/ginkgo/v2&#34;&#xA;    . &#34;github.com/onsi/gomega&#34;&#xA;    ...&#xA;)&#xA;&#xA;Describe(&#34;Checking books out of the library&#34;, Label(&#34;library&#34;), func() {&#xA;    var library *libraries.Library&#xA;    var book *books.Book&#xA;    var valjean *users.User&#xA;    BeforeEach(func() {&#xA;        library = libraries.NewClient()&#xA;        book = &amp;amp;books.Book{&#xA;            Title: &#34;Les Miserables&#34;,&#xA;            Author: &#34;Victor Hugo&#34;,&#xA;        }&#xA;        valjean = users.NewUser(&#34;Jean Valjean&#34;)&#xA;    })&#xA;&#xA;    When(&#34;the library has the book in question&#34;, func() {&#xA;        BeforeEach(func() {&#xA;            Expect(library.Store(book)).To(Succeed())&#xA;        })&#xA;&#xA;        Context(&#34;and the book is available&#34;, func() {&#xA;            It(&#34;lends it to the reader&#34;, func() {&#xA;                Expect(valjean.Checkout(library, &#34;Les Miserables&#34;)).To(Succeed())&#xA;                Expect(valjean.Books()).To(ContainElement(book))&#xA;                Expect(library.UserWithBook(book)).To(Equal(valjean))&#xA;            })&#xA;        })&#xA;&#xA;        Context(&#34;but the book has already been checked out&#34;, func() {&#xA;            var javert *users.User&#xA;            BeforeEach(func() {&#xA;                javert = users.NewUser(&#34;Javert&#34;)&#xA;                Expect(javert.Checkout(library, &#34;Les Miserables&#34;)).To(Succeed())&#xA;            })&#xA;&#xA;            It(&#34;tells the user&#34;, func() {&#xA;                err := valjean.Checkout(library, &#34;Les Miserables&#34;)&#xA;                Expect(error).To(MatchError(&#34;Les Miserables is currently checked out&#34;))&#xA;            })&#xA;&#xA;            It(&#34;lets the user place a hold and get notified later&#34;, func() {&#xA;                Expect(valjean.Hold(library, &#34;Les Miserables&#34;)).To(Succeed())&#xA;                Expect(valjean.Holds()).To(ContainElement(book))&#xA;&#xA;                By(&#34;when Javert returns the book&#34;)&#xA;                Expect(javert.Return(library, book)).To(Succeed())&#xA;&#xA;                By(&#34;it eventually informs Valjean&#34;)&#xA;                notification := &#34;Les Miserables is ready for pick up&#34;&#xA;                Eventually(valjean.Notifications).Should(ContainElement(notification))&#xA;&#xA;                Expect(valjean.Checkout(library, &#34;Les Miserables&#34;)).To(Succeed())&#xA;                Expect(valjean.Books()).To(ContainElement(book))&#xA;                Expect(valjean.Holds()).To(BeEmpty())&#xA;            })&#xA;        })  &#xA;    })&#xA;&#xA;    When(&#34;the library does not have the book in question&#34;, func() {&#xA;        It(&#34;tells the reader the book is unavailable&#34;, func() {&#xA;            err := valjean.Checkout(library, &#34;Les Miserables&#34;)&#xA;            Expect(error).To(MatchError(&#34;Les Miserables is not in the library catalog&#34;))&#xA;        })&#xA;    })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Jump to the &lt;a href=&#34;https://onsi.github.io/ginkgo/&#34;&gt;docs&lt;/a&gt; to learn more. It&#39;s easy to &lt;a href=&#34;https://onsi.github.io/ginkgo/#bootstrapping-a-suite&#34;&gt;bootstrap&lt;/a&gt; and start writing your &lt;a href=&#34;https://onsi.github.io/ginkgo/#adding-specs-to-a-suite&#34;&gt;first specs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have a question, comment, bug report, feature request, etc. please open a &lt;a href=&#34;https://github.com/onsi/ginkgo/issues/new&#34;&gt;GitHub issue&lt;/a&gt;, or visit the &lt;a href=&#34;https://app.slack.com/client/T029RQSE6/CQQ50BBNW&#34;&gt;Ginkgo Slack channel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Capabilities&lt;/h2&gt; &#xA;&lt;p&gt;Whether writing basic unit specs, complex integration specs, or even performance specs - Ginkgo gives you an expressive Domain-Specific Language (DSL) that will be familiar to users coming from frameworks such as &lt;a href=&#34;https://github.com/Quick/Quick&#34;&gt;Quick&lt;/a&gt;, &lt;a href=&#34;https://rspec.info&#34;&gt;RSpec&lt;/a&gt;, &lt;a href=&#34;https://jasmine.github.io&#34;&gt;Jasmine&lt;/a&gt;, and &lt;a href=&#34;https://olivinelabs.com/busted/&#34;&gt;Busted&lt;/a&gt;. This style of testing is sometimes referred to as &#34;Behavior-Driven Development&#34; (BDD) though Ginkgo&#39;s utility extends beyond acceptance-level testing.&lt;/p&gt; &#xA;&lt;p&gt;With Ginkgo&#39;s DSL you can use nestable &lt;a href=&#34;https://onsi.github.io/ginkgo/#organizing-specs-with-container-nodes&#34;&gt;&lt;code&gt;Describe&lt;/code&gt;, &lt;code&gt;Context&lt;/code&gt; and &lt;code&gt;When&lt;/code&gt; container nodes&lt;/a&gt; to help you organize your specs. &lt;a href=&#34;https://onsi.github.io/ginkgo/#extracting-common-setup-beforeeach&#34;&gt;&lt;code&gt;BeforeEach&lt;/code&gt; and &lt;code&gt;AfterEach&lt;/code&gt; setup nodes&lt;/a&gt; for setup and cleanup. &lt;a href=&#34;https://onsi.github.io/ginkgo/#spec-subjects-it&#34;&gt;&lt;code&gt;It&lt;/code&gt; and &lt;code&gt;Specify&lt;/code&gt; subject nodes&lt;/a&gt; that hold your assertions. &lt;a href=&#34;https://onsi.github.io/ginkgo/#suite-setup-and-cleanup-beforesuite-and-aftersuite&#34;&gt;&lt;code&gt;BeforeSuite&lt;/code&gt; and &lt;code&gt;AfterSuite&lt;/code&gt; nodes&lt;/a&gt; to prep for and cleanup after a suite... and &lt;a href=&#34;https://onsi.github.io/ginkgo/#writing-specs&#34;&gt;much more!&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;At runtime, Ginkgo can run your specs in reproducibly &lt;a href=&#34;https://onsi.github.io/ginkgo/#spec-randomization&#34;&gt;random order&lt;/a&gt; and has sophisticated support for &lt;a href=&#34;https://onsi.github.io/ginkgo/#spec-parallelization&#34;&gt;spec parallelization&lt;/a&gt;. In fact, running specs in parallel is as easy as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ginkgo -p&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By following &lt;a href=&#34;https://onsi.github.io/ginkgo/#patterns-for-parallel-integration-specs&#34;&gt;established patterns for writing parallel specs&lt;/a&gt; you can build even large, complex integration suites that parallelize cleanly and run performantly.&lt;/p&gt; &#xA;&lt;p&gt;As your suites grow Ginkgo helps you keep your specs organized with &lt;a href=&#34;https://onsi.github.io/ginkgo/#spec-labels&#34;&gt;labels&lt;/a&gt; and lets you easily run &lt;a href=&#34;https://onsi.github.io/ginkgo/#filtering-specs&#34;&gt;subsets of specs&lt;/a&gt;, either &lt;a href=&#34;https://onsi.github.io/ginkgo/#focused-specs&#34;&gt;programmatically&lt;/a&gt; or on the &lt;a href=&#34;https://onsi.github.io/ginkgo/#combining-filters&#34;&gt;command line&lt;/a&gt;. And Ginkgo&#39;s reporting infrastructure generates machine-readable output in a &lt;a href=&#34;https://onsi.github.io/ginkgo/#generating-machine-readable-reports&#34;&gt;variety of formats&lt;/a&gt; &lt;em&gt;and&lt;/em&gt; allows you to build your own &lt;a href=&#34;https://onsi.github.io/ginkgo/#generating-reports-programmatically&#34;&gt;custom reporting infrastructure&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Ginkgo ships with &lt;code&gt;ginkgo&lt;/code&gt;, a &lt;a href=&#34;https://onsi.github.io/ginkgo/#ginkgo-cli-overview&#34;&gt;command line tool&lt;/a&gt; with support for generating, running, filtering, and profiling Ginkgo suites. You can even have Ginkgo automatically run your specs when it detects a change with &lt;code&gt;ginkgo watch&lt;/code&gt;, enabling rapid feedback loops during test-driven development.&lt;/p&gt; &#xA;&lt;p&gt;And that&#39;s just Ginkgo! &lt;a href=&#34;https://onsi.github.io/gomega/&#34;&gt;Gomega&lt;/a&gt; brings a rich, mature, family of &lt;a href=&#34;https://onsi.github.io/gomega/#provided-matchers&#34;&gt;assertions and matchers&lt;/a&gt; to your suites. With Gomega you can easily mix &lt;a href=&#34;https://onsi.github.io/ginkgo/#patterns-for-asynchronous-testing&#34;&gt;synchronous and asynchronous assertions&lt;/a&gt; in your specs. You can even build your own set of expressive domain-specific matchers quickly and easily by composing Gomega&#39;s &lt;a href=&#34;https://onsi.github.io/ginkgo/#building-custom-matchers&#34;&gt;existing building blocks&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Happy Testing!&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Ginkgo is MIT-Licensed&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/onsi/ginkgo/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>guangzhengli/k8s-tutorials</title>
    <updated>2022-09-01T01:33:09Z</updated>
    <id>tag:github.com,2022-09-01:/guangzhengli/k8s-tutorials</id>
    <link href="https://github.com/guangzhengli/k8s-tutorials" rel="alternate"></link>
    <summary type="html">&lt;p&gt;k8s tutorials | k8s 教程&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;Kubernetes Tutorials ｜ k8s 教程&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/guangzhengli/k8s-tutorials/network&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/forks/guangzhengli/k8s-tutorials&#34; alt=&#34;GitHub forks&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/guangzhengli/k8s-tutorials/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/guangzhengli/k8s-tutorials&#34; alt=&#34;GitHub stars&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/guangzhengli/k8s-tutorials/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues/guangzhengli/k8s-tutorials&#34; alt=&#34;GitHub issues&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/guangzhengli/k8s-tutorials/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/guangzhengli/k8s-tutorials&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4 align=&#34;center&#34;&gt;🌈 Kubernetes | 📰 Tutorials&lt;/h4&gt; &#xA;&lt;p&gt;k8s 作为云原生时代的操作系统，学习它的必要性不言而喻，如果你遇到了任何问题，可以在 &lt;a href=&#34;https://github.com/guangzhengli/k8s-tutorials/discussions&#34;&gt;Discussions&lt;/a&gt; 中评论或者 Issue 中提出，如果你觉得这个仓库对你有价值，欢迎 start 或者提 PR / Issue，让它变得更好！&lt;/p&gt; &#xA;&lt;p&gt;在学习本教程前，需要注意本教程侧重于实战引导，以渐进式修改代码的方式，将从最基础的 container 容器的定义开始，经过 &lt;code&gt;pod&lt;/code&gt;, &lt;code&gt;deployment&lt;/code&gt;, &lt;code&gt;servcie&lt;/code&gt;, &lt;code&gt;ingress&lt;/code&gt;, &lt;code&gt;configmap&lt;/code&gt;, &lt;code&gt;secret&lt;/code&gt; 等资源直到用 &lt;code&gt;helm&lt;/code&gt; 来打包部署一套完整服务。所以如果你对容器和 k8s 的基础理论知识不甚了解的话，建议先从 &lt;a href=&#34;https://kubernetes.io/zh-cn/docs/home/&#34;&gt;官网文档&lt;/a&gt; 或者其它教程获取基础理论知识，再通过实战加深对知识的掌握！&lt;/p&gt; &#xA;&lt;p&gt;这里是文档的索引：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/pre.md&#34;&gt;准备工作&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/container.md&#34;&gt;container&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/pod.md&#34;&gt;pod&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/deployment.md&#34;&gt;deployment&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/service.md&#34;&gt;service&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/ingress.md&#34;&gt;ingress&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/namespace.md&#34;&gt;namespace&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/configmap.md&#34;&gt;configmap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/secret.md&#34;&gt;secret&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/job.md&#34;&gt;job/cronjob&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/helm.md&#34;&gt;helm(待完成)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/docs/dashboard.md&#34;&gt;dashboard(待完成)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;翻译英文(未完成)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;下面是所有文档的集合：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#kubernetes-tutorials&#34;&gt;kubernetes tutorials&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C&#34;&gt;准备工作&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%AE%89%E8%A3%85-docker&#34;&gt;安装 docker&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E6%8E%A8%E8%8D%90%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95&#34;&gt;推荐安装方法&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%85%B6%E5%AE%83%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95&#34;&gt;其它安装方法&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%AE%89%E8%A3%85-minikube&#34;&gt;安装 minikube&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%90%AF%E5%8A%A8-minikube&#34;&gt;启动 minikube&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%AE%89%E8%A3%85-kubectl&#34;&gt;安装 kubectl&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E6%B3%A8%E5%86%8C-docker-hub-%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95&#34;&gt;注册 docker hub 账号登录&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#container&#34;&gt;Container&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#pod&#34;&gt;Pod&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#pod-%E4%B8%8E-container-%E7%9A%84%E4%B8%8D%E5%90%8C&#34;&gt;Pod 与 Container 的不同&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#pod-%E5%85%B6%E5%AE%83%E5%91%BD%E4%BB%A4&#34;&gt;Pod 其它命令&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#deployment&#34;&gt;Deployment&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E6%89%A9%E5%AE%B9&#34;&gt;扩容&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC&#34;&gt;升级版本&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#rolling-update%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0&#34;&gt;Rolling Update(滚动更新)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%AD%98%E6%B4%BB%E6%8E%A2%E9%92%88-livenessprob&#34;&gt;存活探针 (livenessProb)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88-readiness&#34;&gt;就绪探针 (readiness)&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#service&#34;&gt;Service&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#clusterip&#34;&gt;ClusterIP&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#nodeport&#34;&gt;NodePort&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#loadbalancer&#34;&gt;LoadBalancer&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#ingress&#34;&gt;ingress&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#namespace&#34;&gt;Namespace&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#configmap&#34;&gt;Configmap&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#secret&#34;&gt;Secret&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#job&#34;&gt;Job&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#cronjob&#34;&gt;CronJob&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#helmtodo&#34;&gt;Helm(TODO)&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%AE%89%E8%A3%85-hellok8s-chart-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8Btodo&#34;&gt;安装 hellok8s chart 快速开始(TODO)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E5%88%9B%E5%BB%BA-helm-charts&#34;&gt;创建 helm charts&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%85%B6%E5%AE%83-helm-chart-%E4%BD%BF%E7%94%A8-todo&#34;&gt;上传和下载其它 helm chart 使用 (TODO)&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#dashboardtodo&#34;&gt;Dashboard(TODO)&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/guangzhengli/k8s-tutorials/main/#k9stodo&#34;&gt;K9s(TODO)&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;kubernetes tutorials&lt;/h1&gt; &#xA;&lt;h2&gt;准备工作&lt;/h2&gt; &#xA;&lt;p&gt;在开始本教程之前，需要配置好本地环境，以下是需要安装的依赖和包。&lt;/p&gt; &#xA;&lt;h3&gt;安装 docker&lt;/h3&gt; &#xA;&lt;p&gt;首先我们需要安装 &lt;code&gt;docker&lt;/code&gt; 来打包镜像，如果你本地已经安装了 &lt;code&gt;docker&lt;/code&gt;，那么你可以选择跳过这一小节。&lt;/p&gt; &#xA;&lt;h4&gt;推荐安装方法&lt;/h4&gt; &#xA;&lt;p&gt;目前使用 &lt;a href=&#34;https://www.docker.com/products/docker-desktop/&#34;&gt;Docker Desktop&lt;/a&gt; 来安装 docker 还是最简单的方案，打开官网下载对应你电脑操作系统的包即可 (&lt;a href=&#34;https://www.docker.com/products/docker-desktop/)%EF%BC%8C&#34;&gt;https://www.docker.com/products/docker-desktop/)，&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;当安装完成后，可以通过 &lt;code&gt;docker run hello-world&lt;/code&gt; 来快速校验是否安装成功！&lt;/p&gt; &#xA;&lt;h4&gt;其它安装方法&lt;/h4&gt; &#xA;&lt;p&gt;目前 Docker 公司宣布 &lt;a href=&#34;https://www.docker.com/products/docker-desktop/&#34;&gt;Docker Desktop&lt;/a&gt; 只对个人开发者或者小型团体免费 (2021年起对大型公司不再免费)，所以如果你不能通过 &lt;a href=&#34;https://www.docker.com/products/docker-desktop/&#34;&gt;Docker Desktop&lt;/a&gt; 的方式下载安装 &lt;code&gt;docker&lt;/code&gt;，可以参考 &lt;a href=&#34;https://dhwaneetbhatt.com/blog/run-docker-without-docker-desktop-on-macos&#34;&gt;这篇文章&lt;/a&gt; 只安装 &lt;a href=&#34;https://github.com/docker/cli&#34;&gt;Docker CLI&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;安装 minikube&lt;/h3&gt; &#xA;&lt;p&gt;我们还需要搭建一套 k8s 本地集群 (使用云厂商或者其它 k8s 集群都可) 。本地搭建 k8s 集群的方式推荐使用 &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/&#34;&gt;minikube&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;可以根据 &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/start/&#34;&gt;minikube 快速安装&lt;/a&gt; 来进行下载安装，这里简单列举 MacOS 的安装方式，Linux &amp;amp; Windows 操作系统可以参考&lt;a href=&#34;https://minikube.sigs.k8s.io/docs/start/&#34;&gt;官方文档&lt;/a&gt; 快速安装。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install minikube&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;启动 minikube&lt;/h4&gt; &#xA;&lt;p&gt;因为 minikube 支持很多容器和虚拟化技术 (&lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/docker/&#34;&gt;Docker&lt;/a&gt;, &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/hyperkit/&#34;&gt;Hyperkit&lt;/a&gt;, &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/hyperv/&#34;&gt;Hyper-V&lt;/a&gt;, &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/kvm2/&#34;&gt;KVM&lt;/a&gt;, &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/parallels/&#34;&gt;Parallels&lt;/a&gt;, &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/podman/&#34;&gt;Podman&lt;/a&gt;, &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/virtualbox/&#34;&gt;VirtualBox&lt;/a&gt;, or &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/drivers/vmware/&#34;&gt;VMware Fusion/Workstation&lt;/a&gt;)，也是问题出现比较多的地方，所以这里还是稍微说明一下。&lt;/p&gt; &#xA;&lt;p&gt;如果你使用 &lt;code&gt;docker&lt;/code&gt; 的方案是上面推荐的 &lt;a href=&#34;https://www.docker.com/products/docker-desktop/&#34;&gt;Docker Desktop&lt;/a&gt; ，那么你以下面的命令启动 minikube 即可，需要耐心等待下载依赖。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;minikube start --vm-driver docker --container-runtime=docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;启动完成后，运行 &lt;code&gt;minikube status&lt;/code&gt; 查看当前状态确定是否启动成功！&lt;/p&gt; &#xA;&lt;p&gt;如果你本地只有 Docker CLI，判断标准如果执行 &lt;code&gt;docker ps&lt;/code&gt; 等命令，返回错误 &lt;code&gt;Cannot connect to the Docker daemon at unix:///Users/xxxx/.colima/docker.sock. Is the docker daemon running?&lt;/code&gt; 那么就需要操作下面的命令。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install hyperkit&#xA;minikube start --vm-driver hyperkit --container-runtime=docker&#xA;&#xA;# Tell Docker CLI to talk to minikube&#39;s VM&#xA;eval $(minikube docker-env)&#xA;&#xA;# Save IP to a hostname&#xA;echo &#34;`minikube ip` docker.local&#34; | sudo tee -a /etc/hosts &amp;gt; /dev/null&#xA;&#xA;# Test&#xA;docker run hello-world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;minikube 命令速查&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;minikube stop&lt;/code&gt; 不会删除任何数据，只是停止 VM 和 k8s 集群。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;minikube delete&lt;/code&gt; 删除所有 minikube 启动后的数据。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;minikube ip&lt;/code&gt; 查看集群和 docker enginer 运行的 IP 地址。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;minikube pause&lt;/code&gt; 暂停当前的资源和 k8s 集群&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;minikube status&lt;/code&gt; 查看当前集群状态&lt;/p&gt; &#xA;&lt;h3&gt;安装 kubectl&lt;/h3&gt; &#xA;&lt;p&gt;这一步是可选的，如果不安装的话，后续所有 &lt;code&gt;kubectl&lt;/code&gt; 相关的命令，使用 &lt;code&gt;minikube kubectl&lt;/code&gt; 命令替代即可。&lt;/p&gt; &#xA;&lt;p&gt;如果你不想使用 &lt;code&gt;minikube kubectl&lt;/code&gt; 或者配置相关环境变量来进行下面的教学的话，可以考虑直接安装 &lt;code&gt;kubectl&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install kubectl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;注册 docker hub 账号登录&lt;/h3&gt; &#xA;&lt;p&gt;因为默认 minikube 使用的镜像地址是 DockerHub，所以我们还需要在 DockerHub (&lt;a href=&#34;https://hub.docker.com/&#34;&gt;https://hub.docker.com/&lt;/a&gt;) 中注册账号，并且使用 login 命令登录账号。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker login&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Container&lt;/h2&gt; &#xA;&lt;p&gt;我们的旅程从一段代码开始。新建一个 &lt;code&gt;main.go&lt;/code&gt; 文件，复制下面的代码到文件中。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func hello(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;io.WriteString(w, &#34;[v1] Hello, Kubernetes!&#34;)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;http.HandleFunc(&#34;/&#34;, hello)&#xA;&#x9;http.ListenAndServe(&#34;:3000&#34;, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上面是一串用 &lt;a href=&#34;https://go.dev/&#34;&gt;Go&lt;/a&gt; 写的代码，代码逻辑非常的简单，首先启动 HTTP 服务器，监听 &lt;code&gt;3000&lt;/code&gt; 端口，当访问路由 &lt;code&gt;/&lt;/code&gt;的时候 返回字符串 &lt;code&gt;[v1] Hello, Kubernetes!&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;在以前，如果你想将这段代码运行起来并测试一下。你首先需要懂得如何下载 golang 的安装包进行安装，接着需要懂得 &lt;code&gt;golang module&lt;/code&gt; 的基本使用，最后还需要了解 golang 的编译和运行命令，才能将该代码运行起来。甚至在过程中，可能会因为环境变量问题、操作系统问题、处理器架构等问题导致编译或运行失败。&lt;/p&gt; &#xA;&lt;p&gt;但是通过容器技术，只需要上面的代码，附带着对应的容器 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，那么你就不需要 golang 的任何知识，也能将代码顺利运行起来。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Container (容器) 是一种沙盒技术。它是基于 Linux 中 Namespace / Cgroups / chroot 等技术结合而成，更多技术细节可以参看这个视频 &lt;a href=&#34;https://www.youtube.com/watch?v=8fi7uSYlOdc&#34;&gt;如何自己实现一个容器&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;下面就是 Go 代码对应的 &lt;code&gt;Dockerfile&lt;/code&gt;，简单的方案是直接使用 golang 的 alpine 镜像来打包，但是因为我们后续练习需要频繁的推送镜像到 DockerHub 和拉取镜像到 k8s 集群中，为了优化网络速度，我们选择先在 &lt;code&gt;golang:1.16-buster&lt;/code&gt; 中将上述 Go 代码编译成二进制文件，再将二进制文件复制到 &lt;code&gt;base-debian10&lt;/code&gt; 镜像中运行 (Dockerfile 不理解没有关系，不影响后续教程学习)。&lt;/p&gt; &#xA;&lt;p&gt;这样我们可以将 300MB 大小的镜像变成只有 20MB 的镜像，甚至压缩上传到 DockerHub 后大小只有 10MB！&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# Dockerfile&#xA;FROM golang:1.16-buster AS builder&#xA;RUN mkdir /src&#xA;ADD . /src&#xA;WORKDIR /src&#xA;&#xA;RUN go env -w GO111MODULE=auto&#xA;RUN go build -o main .&#xA;&#xA;FROM gcr.io/distroless/base-debian10&#xA;&#xA;WORKDIR /&#xA;&#xA;COPY --from=builder /src/main /main&#xA;EXPOSE 3000&#xA;ENTRYPOINT [&#34;/main&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;需要注意 &lt;code&gt;main.go&lt;/code&gt; 文件需要和 &lt;code&gt;Dockerfile&lt;/code&gt; 文件在同一个目录下，执行下方 &lt;code&gt;docker build&lt;/code&gt; 命令，第一次需要耐心等待拉取基础镜像。并且&lt;strong&gt;需要注意将 &lt;code&gt;guangzhengli&lt;/code&gt; 替换成自己的 &lt;code&gt;DockerHub&lt;/code&gt; 账号名称&lt;/strong&gt;。 这样我们后续可以推送镜像到自己注册的 &lt;code&gt;DockerHub&lt;/code&gt; 仓库当中。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build . -t guangzhengli/hellok8s:v1&#xA;# Step 1/11 : FROM golang:1.16-buster AS builder&#xA;# ...&#xA;# ...&#xA;# Step 11/11 : ENTRYPOINT [&#34;/main&#34;]&#xA;# Successfully tagged guangzhengli/hellok8s:v1&#xA;&#xA;&#xA;docker images&#xA;# guangzhengli/hellok8s          v1         f956e8cf7d18   8 days ago      25.4MB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt; 命令完成后我们可以通过 &lt;code&gt;docker images&lt;/code&gt; 命令查看镜像是否 build 成功，最后我们执行 &lt;code&gt;docker run&lt;/code&gt; 命令将容器启动， &lt;code&gt;-p&lt;/code&gt; 指定 &lt;code&gt;3000&lt;/code&gt; 作为端口，&lt;code&gt;-d&lt;/code&gt; 指定刚打包成功的镜像名称。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -p 3000:3000 --name hellok8s -d guangzhengli/hellok8s:v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;运行成功后，可以通过浏览器或者 &lt;code&gt;curl&lt;/code&gt; 来访问 &lt;code&gt;http://127.0.0.1:3000&lt;/code&gt; , 查看是否成功返回字符串 &lt;code&gt;[v1] Hello, Kubernetes!&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;这里因为我本地只用 Docker CLI，而 docker runtime 是使用 &lt;code&gt;minikube&lt;/code&gt;，所以我需要先调用 &lt;code&gt;minikube ip&lt;/code&gt; 来返回 minikube IP 地址，例如返回了 &lt;code&gt;192.168.59.100&lt;/code&gt;，所以我需要访问 &lt;code&gt;http://192.168.59.100:3000&lt;/code&gt; 来判断是否成功返回字符串 &lt;code&gt;[v1] Hello, Kubernetes!&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;最后确认没有问题，使用 &lt;code&gt;docker push&lt;/code&gt; 将镜像上传到远程的 &lt;code&gt;DockerHub&lt;/code&gt; 仓库当中，这样可以供他人下载使用，也方便后续 &lt;code&gt;Minikube&lt;/code&gt; 下载镜像使用。 &lt;strong&gt;需要注意将 &lt;code&gt;guangzhengli&lt;/code&gt; 替换成自己的 &lt;code&gt;DockerHub&lt;/code&gt; 账号名称&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker push guangzhengli/hellok8s:v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;经过这一节的练习，有没有对容器的强大有一个初步的认识呢？可以想象当你想部署一个更复杂的服务时，例如 Nginx，MySQL，Redis。你只需要到 &lt;a href=&#34;https://hub.docker.com/search?q=&#34;&gt;DockerHub 搜索&lt;/a&gt; 中搜索对应的镜像，通过 &lt;code&gt;docker pull&lt;/code&gt; 下载镜像，&lt;code&gt;docker run&lt;/code&gt; 启动服务即可！而无需关系依赖和各种配置！&lt;/p&gt; &#xA;&lt;h2&gt;Pod&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;pod&lt;/code&gt; 是我们练习的第一个 k8s 资源，在了解 &lt;code&gt;pod&lt;/code&gt; 和 &lt;code&gt;container&lt;/code&gt; 的区别之前，我们可以先创建一个简单的 pod 试试，&lt;/p&gt; &#xA;&lt;p&gt;我们先创建 &lt;code&gt;nginx.yaml&lt;/code&gt; 文件。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# nginx.yaml&#xA;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: nginx-pod&#xA;spec:&#xA;  containers:&#xA;    - name: nginx-container&#xA;      image: nginx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;其中 &lt;code&gt;kind&lt;/code&gt; 表示我们要创建的资源是 &lt;code&gt;Pod&lt;/code&gt; 类型， &lt;code&gt;metadata.name&lt;/code&gt; 表示要创建的 pod 的名字，这个名字需要是唯一的。 &lt;code&gt;spec.containers&lt;/code&gt; 表示要运行的容器的名称和镜像名称。镜像默认来源 &lt;code&gt;DockerHub&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;我们运行第一条 k8s 命令 &lt;code&gt;kubectl apply -f nginx.yaml&lt;/code&gt; 命令启动 pod。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f nginx.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;我们可以通过 &lt;code&gt;kubectl get pods&lt;/code&gt; 来查看 pod 是否正常启动，&lt;/p&gt; &#xA;&lt;p&gt;通过命令下面的命令来配置 &lt;code&gt;nginx&lt;/code&gt; 的首页内容&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl exec -it nginx-pod /bin/bash&#xA;&#xA;echo &#34;hello kubernetes by nginx!&#34; &amp;gt; /usr/share/nginx/html/index.html&#xA;&#xA;kubectl port-forward nginx-pod 4000:80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;最后可以通过浏览器或者 &lt;code&gt;curl&lt;/code&gt; 来访问 &lt;code&gt;http://127.0.0.1:4000&lt;/code&gt; , 查看是否成功启动 &lt;code&gt;nginx&lt;/code&gt; 和返回字符串 &lt;code&gt;hello kubernetes by nginx!&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;Pod 与 Container 的不同&lt;/h3&gt; &#xA;&lt;p&gt;回到 &lt;code&gt;pod&lt;/code&gt; 和 &lt;code&gt;container&lt;/code&gt; 的区别，我们会发现刚刚创建出来的资源如下图所示，在最内层是我们的服务 &lt;code&gt;nginx&lt;/code&gt;，运行在 &lt;code&gt;container&lt;/code&gt; 中， &lt;code&gt;container&lt;/code&gt; (容器) 的本质是进程，而 &lt;code&gt;pod&lt;/code&gt; 是管理这一组进程的资源。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/nginx_pod.png&#34; alt=&#34;nginx_pod&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;所以自然 &lt;code&gt;pod&lt;/code&gt; 可以管理多个 &lt;code&gt;container&lt;/code&gt;，在某些场景例如 &lt;code&gt;container&lt;/code&gt; 之间需要文件交换(日志收集)，本地网络通信需求(使用 localhost 或者 Socket 文件进行本地通信)，在这些场景中使用 &lt;code&gt;pod&lt;/code&gt; 管理多个 &lt;code&gt;container&lt;/code&gt; 就非常的推荐。如下图所示：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/pod.png&#34; alt=&#34;pod&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Pod 其它命令&lt;/h3&gt; &#xA;&lt;p&gt;我们可以通过 &lt;code&gt;logs&lt;/code&gt; 或者 &lt;code&gt;logs -f&lt;/code&gt; 命令查看 pod 日志，可以通过 &lt;code&gt;exec -it&lt;/code&gt; 进入 pod 或者调用容器命令，通过 &lt;code&gt;delete pod&lt;/code&gt; 或者 &lt;code&gt;delete -f nginx.yaml&lt;/code&gt; 的方式删除 pod 资源。这里可以看到 &lt;a href=&#34;https://kubernetes.io/docs/reference/kubectl/cheatsheet/&#34;&gt;kubectl 所有命令&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl&amp;nbsp;logs&amp;nbsp;--follow&amp;nbsp;nginx&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xA;kubectl exec nginx -- ls&#xA;&#xA;kubectl delete pod nginx&#xA;# pod &#34;nginx&#34; deleted&#xA;&#xA;kubectl delete -f nginx.yaml&#xA;# pod &#34;nginx&#34; deleted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;根据我们在 &lt;code&gt;container&lt;/code&gt; 的那节构建的 &lt;code&gt;hellok8s:v1&lt;/code&gt; 的镜像，同时参考 &lt;code&gt;nginx&lt;/code&gt; pod 的资源定义，我们很容易的编写出 &lt;code&gt;hellok8s:v1&lt;/code&gt; &lt;code&gt;pod&lt;/code&gt; 的资源文件。并通过 &lt;code&gt;port-forward&lt;/code&gt; 到本地的 &lt;code&gt;3000&lt;/code&gt; 端口进行访问，最终得到字符串 &lt;code&gt;[v1] Hello, Kubernetes!&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# hellok8s.yaml&#xA;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: hellok8s&#xA;spec:&#xA;  containers:&#xA;    - name: hellok8s-container&#xA;      image: guangzhengli/hellok8s:v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl get pods&#xA;&#xA;kubectl port-forward hellok8s 3000:3000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;p&gt;在生产环境中，我们基本上不会直接管理 pod，我们需要 &lt;code&gt;kubernetes&lt;/code&gt; 来帮助我们来完成一些自动化操作，例如自动扩容或者自动升级版本。可以想象在生产环境中，我们手动部署了 10 个 &lt;code&gt;hellok8s:v1&lt;/code&gt; 的 pod，这个时候我们需要升级成 &lt;code&gt;hellok8s:v2&lt;/code&gt; 版本，我们难道需要一个一个的将 &lt;code&gt;hellok8s:v1&lt;/code&gt; 的 pod 手动升级吗？&lt;/p&gt; &#xA;&lt;p&gt;这个时候就需要我们来看 &lt;code&gt;kubernetes&lt;/code&gt; 的另外一个资源 &lt;code&gt;deployment&lt;/code&gt;，来帮助我们管理 pod。&lt;/p&gt; &#xA;&lt;h3&gt;扩容&lt;/h3&gt; &#xA;&lt;p&gt;首先可以创建一个 &lt;code&gt;deployment.yaml&lt;/code&gt; 的文件。来管理 &lt;code&gt;hellok8s&lt;/code&gt; pod。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  replicas: 1&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:v1&#xA;          name: hellok8s-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;其中 &lt;code&gt;kind&lt;/code&gt; 表示我们要创建的资源是 &lt;code&gt;deployment&lt;/code&gt; 类型， &lt;code&gt;metadata.name&lt;/code&gt; 表示要创建的 deployment 的名字，这个名字需要是&lt;strong&gt;唯一&lt;/strong&gt;的。&lt;/p&gt; &#xA;&lt;p&gt;在 &lt;code&gt;spec&lt;/code&gt; 里面表示，首先 &lt;code&gt;replicas&lt;/code&gt; 表示的是部署的 pod 副本数量，&lt;code&gt;selector&lt;/code&gt; 里面表示的是 &lt;code&gt;deployment&lt;/code&gt; 资源和 &lt;code&gt;pod&lt;/code&gt; 资源关联的方式，这里表示 &lt;code&gt;deployment&lt;/code&gt; 会管理 (selector) 所有 &lt;code&gt;labels=hellok8s&lt;/code&gt; 的 pod。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;template&lt;/code&gt; 的内容是用来定义 &lt;code&gt;pod&lt;/code&gt; 资源的，你会发现和 Hellok8s Pod 资源的定义是差不多的，唯一的区别是我们需要加上 &lt;code&gt;metadata.labels&lt;/code&gt; 来和上面的 &lt;code&gt;selector.matchLabels&lt;/code&gt; 对应起来。来表明 pod 是被 deployment 管理，不用在&lt;code&gt;template&lt;/code&gt; 里面加上 &lt;code&gt;metadata.name&lt;/code&gt; 是因为 deployment 会自动为我们创建 pod 的唯一&lt;code&gt;name&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;接下来输入下面的命令，可以创建 &lt;code&gt;deployment&lt;/code&gt; 资源。通过 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;delete pod&lt;/code&gt; 命令，我们会初步感受 deployment 的魅力。&lt;strong&gt;每次创建的 pod 名称都会变化，某些命令记得替换成你的 pod 的名称&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f deployment.yaml&#xA;&#xA;kubectl get deployments&#xA;#NAME                  READY   UP-TO-DATE   AVAILABLE   AGE&#xA;#hellok8s-deployment   1/1     1            1           39s&#xA;&#xA;kubectl get pods             &#xA;#NAME                                   READY   STATUS    RESTARTS   AGE&#xA;#hellok8s-deployment-77bffb88c5-qlxss   1/1     Running   0          119s&#xA;&#xA;kubectl delete pod hellok8s-deployment-77bffb88c5-qlxss &#xA;#pod &#34;hellok8s-deployment-77bffb88c5-qlxss&#34; deleted&#xA;&#xA;kubectl get pods                                       &#xA;#NAME                                   READY   STATUS    RESTARTS   AGE&#xA;#hellok8s-deployment-77bffb88c5-xp8f7   1/1     Running   0          18s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;我们会发现一个有趣的现象，当手动删除一个 &lt;code&gt;pod&lt;/code&gt; 资源后，deployment 会自动创建一个新的 &lt;code&gt;pod&lt;/code&gt;，这和我们之前手动创建 pod 资源有本质的区别！这代表着当生产环境管理着成千上万个 pod 时，我们不需要关心具体的情况，只需要维护好这份 &lt;code&gt;deployment.yaml&lt;/code&gt; 文件的资源定义即可。&lt;/p&gt; &#xA;&lt;p&gt;接下来我们通过自动扩容来加深这个知识点，当我们想要将 &lt;code&gt;hellok8s:v1&lt;/code&gt; 的资源扩容到 3 个副本时，只需要将 &lt;code&gt;replicas&lt;/code&gt; 的值设置成 3，接着重新输入 &lt;code&gt;kubectl apply -f deployment.yaml&lt;/code&gt; 即可。如下所示：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:v1&#xA;          name: hellok8s-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;可以在 &lt;code&gt;kubectl apply&lt;/code&gt; 之前通过新建窗口执行 &lt;code&gt;kubectl get pods --watch&lt;/code&gt; 命令来观察 pod 启动和删除的记录，想要减少副本数时也很简单，你可以尝试将副本数随意增大或者缩小，再通过 &lt;code&gt;watch&lt;/code&gt; 来观察它的状态。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/deployment.png&#34; alt=&#34;deployment&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;升级版本&lt;/h3&gt; &#xA;&lt;p&gt;我们接下来尝试将所有 &lt;code&gt;v1&lt;/code&gt; 版本的 &lt;code&gt;pod&lt;/code&gt; 升级到 &lt;code&gt;v2&lt;/code&gt; 版本。首先我们需要构建一份 &lt;code&gt;hellok8s:v2&lt;/code&gt; 的版本镜像。唯一的区别就是字符串替换成了 &lt;code&gt;[v2] Hello, Kubernetes!&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func hello(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;io.WriteString(w, &#34;[v2] Hello, Kubernetes!&#34;)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;http.HandleFunc(&#34;/&#34;, hello)&#xA;&#x9;http.ListenAndServe(&#34;:3000&#34;, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;将 &lt;code&gt;hellok8s:v2&lt;/code&gt; 推到 DockerHub 仓库中。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build . -t guangzhengli/hellok8s:v2&#xA;docker push guangzhengli/hellok8s:v2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接着编写 &lt;code&gt;v2&lt;/code&gt; 版本的 deployment 资源文件。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:v2&#xA;          name: hellok8s-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f deployment.yaml&#xA;# deployment.apps/hellok8s-deployment configured&#xA;&#xA;kubectl get pods                &#xA;# NAME                                   READY   STATUS    RESTARTS   AGE&#xA;# hellok8s-deployment-66799848c4-kpc6q   1/1     Running   0          3s&#xA;# hellok8s-deployment-66799848c4-pllj6   1/1     Running   0          3s&#xA;# hellok8s-deployment-66799848c4-r7qtg   1/1     Running   0          3s&#xA;&#xA;kubectl port-forward hellok8s-deployment-66799848c4-kpc6q 3000:3000&#xA;# Forwarding from 127.0.0.1:3000 -&amp;gt; 3000&#xA;# Forwarding from [::1]:3000 -&amp;gt; 3000&#xA;&#xA;# open another terminal&#xA;curl http://localhost:3000&#xA;# [v2] Hello, Kubernetes!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;你也可以输入 &lt;code&gt;kubectl describe pod hellok8s-deployment-66799848c4-kpc6q&lt;/code&gt; 来看是否是 &lt;code&gt;v2&lt;/code&gt; 版本的镜像。&lt;/p&gt; &#xA;&lt;h3&gt;Rolling Update(滚动更新)&lt;/h3&gt; &#xA;&lt;p&gt;如果我们在生产环境上，管理着多个副本的 &lt;code&gt;hellok8s:v1&lt;/code&gt; 版本的 pod，我们需要更新到 &lt;code&gt;v2&lt;/code&gt; 的版本，像上面那样的部署方式是可以的，但是也会带来一个问题，就是所有的副本在同一时间更新，这会导致我们 &lt;code&gt;hellok8s&lt;/code&gt; 服务在短时间内是不可用的，因为所有 pod 都在升级到 &lt;code&gt;v2&lt;/code&gt; 版本的过程中，需要等待某个 pod 升级完成后才能提供服务。&lt;/p&gt; &#xA;&lt;p&gt;这个时候我们就需要滚动更新 (rolling update)，在保证新版本 &lt;code&gt;v2&lt;/code&gt; 的 pod 还没有 &lt;code&gt;ready&lt;/code&gt; 之前，先不删除 &lt;code&gt;v1&lt;/code&gt; 版本的 pod。&lt;/p&gt; &#xA;&lt;p&gt;在 deployment 的资源定义中, &lt;code&gt;spec.strategy.type&lt;/code&gt; 有两种选择:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;RollingUpdate:&lt;/strong&gt; 逐渐增加新版本的 pod，逐渐减少旧版本的 pod。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Recreate:&lt;/strong&gt; 在新版本的 pod 增加前，先将所有旧版本 pod 删除。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;大多数情况下我们会采用滚动更新 (RollingUpdate) 的方式，滚动更新又可以通过 &lt;code&gt;maxSurge&lt;/code&gt; 和 &lt;code&gt;maxUnavailable&lt;/code&gt; 字段来控制升级 pod 的速率，具体可以详细看&lt;a href=&#34;https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/&#34;&gt;官网定义&lt;/a&gt;。：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-surge&#34;&gt;&lt;strong&gt;maxSurge:&lt;/strong&gt;&lt;/a&gt; 最大峰值，用来指定可以创建的超出期望 Pod 个数的 Pod 数量。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-unavailable,&#34;&gt;&lt;strong&gt;maxUnavailable:&lt;/strong&gt;&lt;/a&gt; 最大不可用，用来指定更新过程中不可用的 Pod 的个数上限。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;我们先输入命令回滚我们的 deployment，输入 &lt;code&gt;kubectl describe pod&lt;/code&gt; 会发现 deployment 已经把 &lt;code&gt;v2&lt;/code&gt; 版本的 pod 回滚到 &lt;code&gt; v1&lt;/code&gt; 的版本。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl&amp;nbsp;rollout&amp;nbsp;undo&amp;nbsp;deployment&amp;nbsp;hellok8s-deployment&#xA;&#xA;kubectl get pods                                    &#xA;# NAME                                   READY   STATUS    RESTARTS   AGE&#xA;# hellok8s-deployment-77bffb88c5-cvm5c   1/1     Running   0          39s&#xA;# hellok8s-deployment-77bffb88c5-lktbl   1/1     Running   0          41s&#xA;# hellok8s-deployment-77bffb88c5-nh82z   1/1     Running   0          37s&#xA;&#xA;kubectl describe pod hellok8s-deployment-77bffb88c5-cvm5c&#xA;# Image: guangzhengli/hellok8s:v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;除了上面的命令，还可以用 &lt;code&gt;history&lt;/code&gt; 来查看历史版本，&lt;code&gt;--to-revision=2&lt;/code&gt; 来回滚到指定版本。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl rollout history deployment hellok8s-deployment&#xA;kubectl rollout undo deployment/hellok8s-deployment --to-revision=2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接着设置 &lt;code&gt;strategy=rollingUpdate&lt;/code&gt; , &lt;code&gt;maxSurge=1&lt;/code&gt; , &lt;code&gt;maxUnavailable=1&lt;/code&gt; 和 &lt;code&gt;replicas=3&lt;/code&gt; 到 deployment.yaml 文件中。这个参数配置意味着最大可能会创建 4 个 hellok8s pod (replicas + maxSurge)，最小会有 2 个 hellok8s pod 存活 (replicas - maxUnavailable)。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  strategy:&#xA;     rollingUpdate:&#xA;      maxSurge: 1&#xA;      maxUnavailable: 1&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;      - image: guangzhengli/hellok8s:v2&#xA;        name: hellok8s-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;使用 &lt;code&gt;kubectl apply -f deployment.yaml&lt;/code&gt; 来重新创建 &lt;code&gt;v2&lt;/code&gt; 的资源，可以通过 &lt;code&gt;kubectl get pods --watch&lt;/code&gt; 来观察 pod 的创建销毁情况，是否如下图所示。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/rollingupdate.png&#34; alt=&#34;rollingupdate&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;存活探针 (livenessProb)&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;存活探测器来确定什么时候要重启容器。 例如，存活探测器可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。 重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。-- &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&#34;&gt;LivenessProb&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;在生产中，有时候因为某些 bug 导致应用死锁或者线程耗尽了，最终会导致应用无法继续提供服务，这个时候如果没有手段来自动监控和处理这一问题的话，可能会导致很长一段时间无人发现。&lt;a href=&#34;https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/&#34;&gt;kubelet&lt;/a&gt; 使用存活探测器 (livenessProb) 来确定什么时候要重启容器。&lt;/p&gt; &#xA;&lt;p&gt;接下来我们写一个 &lt;code&gt;/healthz&lt;/code&gt; 接口来说明 &lt;code&gt;livenessProb&lt;/code&gt; 如何使用。 &lt;code&gt;/healthz&lt;/code&gt; 接口会在启动成功的 15s 内正常返回 200 状态码，在 15s 后，会一直返回 500 的状态码。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func hello(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;io.WriteString(w, &#34;[v2] Hello, Kubernetes!&#34;)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;started := time.Now()&#xA;&#x9;http.HandleFunc(&#34;/healthz&#34;, func(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;&#x9;duration := time.Since(started)&#xA;&#x9;&#x9;if duration.Seconds() &amp;gt; 15 {&#xA;&#x9;&#x9;&#x9;w.WriteHeader(500)&#xA;&#x9;&#x9;&#x9;w.Write([]byte(fmt.Sprintf(&#34;error: %v&#34;, duration.Seconds())))&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;w.WriteHeader(200)&#xA;&#x9;&#x9;&#x9;w.Write([]byte(&#34;ok&#34;))&#xA;&#x9;&#x9;}&#xA;&#x9;})&#xA;&#xA;&#x9;http.HandleFunc(&#34;/&#34;, hello)&#xA;&#x9;http.ListenAndServe(&#34;:3000&#34;, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Dockerfile&#xA;FROM golang:1.16-buster AS builder&#xA;RUN mkdir /src&#xA;ADD . /src&#xA;WORKDIR /src&#xA;&#xA;RUN go env -w GO111MODULE=auto&#xA;RUN go build -o main .&#xA;&#xA;FROM gcr.io/distroless/base-debian10&#xA;&#xA;WORKDIR /&#xA;&#xA;COPY --from=builder /src/main /main&#xA;EXPOSE 3000&#xA;ENTRYPOINT [&#34;/main&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt; 的编写和原来保持一致，我们把 &lt;code&gt;tag&lt;/code&gt; 修改为 &lt;code&gt;liveness&lt;/code&gt; 并推送到远程仓库。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build . -t guangzhengli/hellok8s:liveness&#xA;docker push guangzhengli/hellok8s:liveness&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;最后编写 deployment 的定义，这里使用存活探测方式是使用 HTTP GET 请求，请求的是刚才定义的 &lt;code&gt;/healthz&lt;/code&gt; 接口，&lt;code&gt;periodSeconds&lt;/code&gt; 字段指定了 kubelet 每隔 3 秒执行一次存活探测。 &lt;code&gt;initialDelaySeconds&lt;/code&gt; 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。如果服务器上 &lt;code&gt;/healthz&lt;/code&gt; 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。 如果处理程序返回失败代码，则 kubelet 会杀死这个容器并将其重启。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  strategy:&#xA;     rollingUpdate:&#xA;      maxSurge: 1&#xA;      maxUnavailable: 1&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:liveness&#xA;          name: hellok8s-container&#xA;          livenessProbe:&#xA;            httpGet:&#xA;              path: /healthz&#xA;              port: 3000&#xA;            initialDelaySeconds: 3&#xA;            periodSeconds: 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;通过 &lt;code&gt;get&lt;/code&gt; 或者 &lt;code&gt;describe&lt;/code&gt; 命令可以发现 pod 一直处于重启当中。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f deployment.yaml&#xA;&#xA;kubectl get pods&#xA;# NAME                                   READY   STATUS    RESTARTS     AGE&#xA;# hellok8s-deployment-5995ff9447-d5fbz   1/1     Running   4 (6s ago)   102s&#xA;# hellok8s-deployment-5995ff9447-gz2cx   1/1     Running   4 (5s ago)   101s&#xA;# hellok8s-deployment-5995ff9447-rh29x   1/1     Running   4 (6s ago)   102s&#xA;&#xA;kubectl describe pod hellok8s-68f47f657c-zwn6g&#xA;&#xA;# ...&#xA;# ...&#xA;# ...&#xA;# Events:&#xA;#  Type     Reason     Age                   From               Message&#xA;#  ----     ------     ----                  ----               -------&#xA;#  Normal   Scheduled  12m                   default-scheduler  Successfully assigned default/hellok8s-deployment-5995ff9447-rh29x to minikube&#xA;#  Normal   Pulled     11m (x4 over 12m)     kubelet            Container image &#34;guangzhengli/hellok8s:liveness&#34; already present on machine&#xA;#  Normal   Created    11m (x4 over 12m)     kubelet            Created container hellok8s-container&#xA;#  Normal   Started    11m (x4 over 12m)     kubelet            Started container hellok8s-container&#xA;#  Normal   Killing    11m (x3 over 12m)     kubelet            Container hellok8s-container failed liveness probe, will be restarted&#xA;#  Warning  Unhealthy  11m (x10 over 12m)    kubelet            Liveness probe failed: HTTP probe failed with statuscode: 500&#xA;#  Warning  BackOff    2m41s (x36 over 10m)  kubelet            Back-off restarting failed container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;就绪探针 (readiness)&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;就绪探测器可以知道容器何时准备好接受请求流量，当一个 Pod 内的所有容器都就绪时，才能认为该 Pod 就绪。 这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。 若 Pod 尚未就绪，会被从 Service 的负载均衡器中剔除。-- &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&#34;&gt;ReadinessProb&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;在生产环境中，升级服务的版本是日常的需求，这时我们需要考虑一种场景，即当发布的版本存在问题，就不应该让它升级成功。kubelet 使用就绪探测器可以知道容器何时准备好接受请求流量，当一个 pod 升级后不能就绪，即不应该让流量进入该 pod，在配合 &lt;code&gt;rollingUpate&lt;/code&gt; 的功能下，也不能允许升级版本继续下去，否则服务会出现全部升级完成，导致所有服务均不可用的情况。&lt;/p&gt; &#xA;&lt;p&gt;这里我们把服务回滚到 &lt;code&gt;hellok8s:v2&lt;/code&gt; 的版本，可以通过上面学习的方法进行回滚。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl rollout undo deployment hellok8s-deployment --to-revision=2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;这里我们将应用的 &lt;code&gt;/healthz&lt;/code&gt; 接口直接设置成返回 500 状态码，代表该版本是一个有问题的版本。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func hello(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;io.WriteString(w, &#34;[v2] Hello, Kubernetes!&#34;)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;http.HandleFunc(&#34;/healthz&#34;, func(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;&#x9;&#x9;w.WriteHeader(500)&#xA;&#x9;})&#xA;&#xA;&#x9;http.HandleFunc(&#34;/&#34;, hello)&#xA;&#x9;http.ListenAndServe(&#34;:3000&#34;, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在 &lt;code&gt;build&lt;/code&gt; 阶段我们将 &lt;code&gt;tag&lt;/code&gt; 设置为 &lt;code&gt;bad&lt;/code&gt;，打包后 push 到远程仓库。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build . -t guangzhengli/hellok8s:bad&#xA;&#xA;docker push guangzhengli/hellok8s:bad&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接着编写 deployment 资源文件，&lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core&#34;&gt;Probe&lt;/a&gt; 有很多配置字段，可以使用这些字段精确地控制就绪检测的行为：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;initialDelaySeconds&lt;/code&gt;：容器启动后要等待多少秒后才启动存活和就绪探测器， 默认是 0 秒，最小值是 0。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;periodSeconds&lt;/code&gt;：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timeoutSeconds&lt;/code&gt;：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;successThreshold&lt;/code&gt;：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;failureThreshold&lt;/code&gt;：当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器。 对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  strategy:&#xA;     rollingUpdate:&#xA;      maxSurge: 1&#xA;      maxUnavailable: 1&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:bad&#xA;          name: hellok8s-container&#xA;          readinessProbe:&#xA;            httpGet:&#xA;              path: /healthz&#xA;              port: 3000&#xA;            initialDelaySeconds: 1&#xA;            successThreshold: 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;通过 &lt;code&gt;get&lt;/code&gt; 命令可以发现两个 pod 一直处于还没有 Ready 的状态当中，通过 &lt;code&gt;describe&lt;/code&gt; 命令可以看到是因为 &lt;code&gt;Readiness probe failed: HTTP probe failed with statuscode: 500&lt;/code&gt; 的原因。又因为设置了最小不可用的服务数量为&lt;code&gt;maxUnavailable=1&lt;/code&gt;，这样能保证剩下两个 &lt;code&gt;v2&lt;/code&gt; 版本的 &lt;code&gt;hellok8s&lt;/code&gt; 能继续提供服务！&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f deployment.yaml&#xA;&#xA;kubectl get pods                &#xA;# NAME                                   READY   STATUS    RESTARTS   AGE&#xA;# hellok8s-deployment-66799848c4-8xzsz   1/1     Running   0          102s&#xA;# hellok8s-deployment-66799848c4-m9dl5   1/1     Running   0          102s&#xA;# hellok8s-deployment-9c57c7f56-rww7k    0/1     Running   0          26s&#xA;# hellok8s-deployment-9c57c7f56-xt9tw    0/1     Running   0          26s&#xA;&#xA;&#xA;kubectl describe pod hellok8s-deployment-9c57c7f56-rww7k&#xA;# Events:&#xA;#   Type     Reason     Age                From               Message&#xA;#   ----     ------     ----               ----               -------&#xA;#   Normal   Scheduled  74s                default-scheduler  Successfully assigned default/hellok8s-deployment-9c57c7f56-rww7k to minikube&#xA;#   Normal   Pulled     73s                kubelet            Container image &#34;guangzhengli/hellok8s:bad&#34; already present on machine&#xA;#   Normal   Created    73s                kubelet            Created container hellok8s-container&#xA;#   Normal   Started    73s                kubelet            Started container hellok8s-container&#xA;#   Warning  Unhealthy  0s (x10 over 72s)  kubelet            Readiness probe failed: HTTP probe failed with statuscode: 500&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Service&lt;/h2&gt; &#xA;&lt;p&gt;经过前面几节的练习，可能你会有一些疑惑：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;为什么 pod 不就绪 (Ready) 的话，&lt;code&gt;kubernetes&lt;/code&gt; 不会将流量重定向到该 pod，这是怎么做到的？&lt;/li&gt; &#xA; &lt;li&gt;前面访问服务的方式是通过 &lt;code&gt;port-forword&lt;/code&gt; 将 pod 的端口暴露到本地，不仅需要写对 pod 的名字，一旦 deployment 重新创建新的 pod，pod 名字和 pod 的 IP 地址也会随之变化，有没有一个地址能让我们稳定访问？&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port-forword&lt;/code&gt; 的方式需要有权限访问 &lt;code&gt;kubernetes&lt;/code&gt; 集群才能做到，难道生产环境也能这么做吗？&lt;/li&gt; &#xA; &lt;li&gt;如果部署了多个副本 pod，如何做负载均衡？&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt; 提供了一种名叫 &lt;code&gt;Service&lt;/code&gt; 的资源帮助解决这些问题，它为 pod 提供一个稳定的 Endpoint。Servie 位于 pod 的前面，负责接收请求并将它们传递给它后面的所有pod。一旦服务中的 Pod 集合发生更改，Endpoints 就会被更新，请求的重定向自然也会导向最新的 pod。&lt;/p&gt; &#xA;&lt;h3&gt;ClusterIP&lt;/h3&gt; &#xA;&lt;p&gt;我们先来看看 &lt;code&gt;Service&lt;/code&gt; 默认使用的 &lt;code&gt;ClusterIP&lt;/code&gt; 类型，首先做一些准备工作，在之前的 &lt;code&gt;hellok8s:v2&lt;/code&gt; 版本上加上返回当前服务所在的 &lt;code&gt;hostname&lt;/code&gt; 功能，升级到 &lt;code&gt;v3&lt;/code&gt; 版本。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func hello(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;host, _ := os.Hostname()&#xA;&#x9;io.WriteString(w, fmt.Sprintf(&#34;[v3] Hello, Kubernetes!, From host: %s&#34;, host))&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;http.HandleFunc(&#34;/&#34;, hello)&#xA;&#x9;http.ListenAndServe(&#34;:3000&#34;, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt; 和之前保持一致，打包 &lt;code&gt;tag=v3&lt;/code&gt; 并推送到远程仓库。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build . -t guangzhengli/hellok8s:v3&#xA;&#xA;docker push guangzhengli/hellok8s:v3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;修改 deployment 的 &lt;code&gt;hellok8s&lt;/code&gt; 为 &lt;code&gt;v3&lt;/code&gt; 版本。执行 &lt;code&gt;kubectl apply -f deployment.yaml&lt;/code&gt; 更新 deployment。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:v3&#xA;          name: hellok8s-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接下来是 &lt;code&gt;Service&lt;/code&gt; 资源的定义，我们使用 &lt;code&gt;ClusterIP&lt;/code&gt; 的方式定义 Service，通过 &lt;code&gt;kubernetes&lt;/code&gt; 集群的内部 IP 暴露服务，当我们只需要让集群中运行的其他应用程序访问我们的pod时，就可以使用这种类型的服务。创建一个 service-hellok8s-clusterip.yaml` 文件。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: service-hellok8s-clusterip&#xA;spec:&#xA;  type: ClusterIP&#xA;  selector:&#xA;    app: hellok8s&#xA;  ports:&#xA;  - port: 3000&#xA;    targetPort: 3000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f service-hellok8s-clusterip.yaml&#xA;&#xA;kubectl get service&#xA;# NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE&#xA;# service-hellok8s-clusterip   ClusterIP   10.104.96.153   &amp;lt;none&amp;gt;        3000/TCP   10s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;我们可以通过在集群其它应用中访问 &lt;code&gt;service-hellok8s-clusterip&lt;/code&gt; 的 IP 地址 &lt;code&gt;10.104.96.153&lt;/code&gt; 来访问 &lt;code&gt;hellok8s:v3&lt;/code&gt; 服务。&lt;/p&gt; &#xA;&lt;p&gt;这里通过在集群内创建一个 &lt;code&gt;nginx&lt;/code&gt; 来访问。创建后进入 &lt;code&gt;nginx&lt;/code&gt; 容器来用 &lt;code&gt;curl&lt;/code&gt; 命令访问 &lt;code&gt;service-hellok8s-clusterip&lt;/code&gt; 。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: nginx&#xA;  labels:&#xA;    app: nginx&#xA;spec:&#xA;  containers:&#xA;    - name: nginx-container&#xA;      image: nginx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl get pods&#xA;# NAME                                   READY   STATUS    RESTARTS   AGE&#xA;# hellok8s-deployment-5d5545b69c-24lw5   1/1     Running   0          27m&#xA;# hellok8s-deployment-5d5545b69c-9g94t   1/1     Running   0          27m&#xA;# hellok8s-deployment-5d5545b69c-9gm8r   1/1     Running   0          27m&#xA;# nginx                                  1/1     Running   0          41m&#xA;&#xA;kubectl get service&#xA;# NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE&#xA;# service-hellok8s-clusterip   ClusterIP   10.104.96.153   &amp;lt;none&amp;gt;        3000/TCP   10s&#xA;&#xA;kubectl exec -it nginx-pod /bin/bash&#xA;# root@nginx-pod:/# curl 10.104.96.153:3000&#xA;# [v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-9gm8r&#xA;# root@nginx-pod:/# curl 10.104.96.153:3000&#xA;#[v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-9g94t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;可以看到，我们多次 &lt;code&gt;curl 10.104.96.153:3000&lt;/code&gt; 访问 &lt;code&gt;hellok8s&lt;/code&gt; Service IP 地址，返回的 &lt;code&gt;hellok8s:v3&lt;/code&gt; &lt;code&gt;hostname&lt;/code&gt; 不一样，说明 Service 可以接收请求并将它们传递给它后面的所有 pod，还可以自动负载均衡。你也可以试试增加或者减少 &lt;code&gt;hellok8s:v3&lt;/code&gt; pod 副本数量，观察 Service 的请求是否会动态变更。调用过程如下图所示：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/service-clusterip-fix-name.png&#34; alt=&#34;service-clusterip-fix-name&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;除了上述的 &lt;code&gt;ClusterIp&lt;/code&gt; 的方式外，Kubernetes &lt;code&gt;ServiceTypes&lt;/code&gt; 允许指定你所需要的 Service 类型，默认是 &lt;code&gt;ClusterIP&lt;/code&gt;。&lt;code&gt;Type&lt;/code&gt; 的值包括如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ClusterIP&lt;/code&gt;：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 &lt;code&gt;ServiceType&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport&#34;&gt;&lt;code&gt;NodePort&lt;/code&gt;&lt;/a&gt;：通过每个节点上的 IP 和静态端口（&lt;code&gt;NodePort&lt;/code&gt;）暴露服务。 &lt;code&gt;NodePort&lt;/code&gt; 服务会路由到自动创建的 &lt;code&gt;ClusterIP&lt;/code&gt; 服务。 通过请求 &lt;code&gt;&amp;lt;节点 IP&amp;gt;:&amp;lt;节点端口&amp;gt;&lt;/code&gt;，你可以从集群的外部访问一个 &lt;code&gt;NodePort&lt;/code&gt; 服务。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer&#34;&gt;&lt;code&gt;LoadBalancer&lt;/code&gt;&lt;/a&gt;：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 &lt;code&gt;NodePort&lt;/code&gt; 服务和 &lt;code&gt;ClusterIP&lt;/code&gt; 服务上。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#externalname&#34;&gt;&lt;code&gt;ExternalName&lt;/code&gt;&lt;/a&gt;：通过返回 &lt;code&gt;CNAME&lt;/code&gt; 和对应值，可以将服务映射到 &lt;code&gt;externalName&lt;/code&gt; 字段的内容（例如，&lt;code&gt;foo.bar.example.com&lt;/code&gt;）。 无需创建任何类型代理。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;NodePort&lt;/h3&gt; &#xA;&lt;p&gt;我们知道&lt;code&gt;kubernetes&lt;/code&gt; 集群并不是单机运行，它管理着多台节点即 &lt;a href=&#34;https://kubernetes.io/docs/concepts/architecture/nodes/&#34;&gt;Node&lt;/a&gt;，可以通过每个节点上的 IP 和静态端口（&lt;code&gt;NodePort&lt;/code&gt;）暴露服务。如下图所示，如果集群内有两台 Node 运行着 &lt;code&gt;hellok8s:v3&lt;/code&gt;，我们创建一个 &lt;code&gt;NodePort&lt;/code&gt; 类型的 Service，将 &lt;code&gt;hellok8s:v3&lt;/code&gt; 的 &lt;code&gt;3000&lt;/code&gt; 端口映射到 Node 机器的 &lt;code&gt;30000&lt;/code&gt; 端口 (在 30000-32767 范围内)，就可以通过访问 &lt;code&gt;http://node1-ip:30000&lt;/code&gt; 或者 &lt;code&gt;http://node2-ip:30000&lt;/code&gt; 访问到服务。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/service-nodeport-fix-name.png&#34; alt=&#34;service-nodeport-fix-name&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;这里以 &lt;code&gt;minikube&lt;/code&gt; 为例，我们可以通过 &lt;code&gt;minikube ip&lt;/code&gt; 命令拿到 k8s cluster node IP地址。下面的教程都以我本机的 &lt;code&gt;192.168.59.100&lt;/code&gt; 为例，需要替换成你的 IP 地址。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;minikube ip&#xA;# 192.168.59.100&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接着以 NodePort 的 ServiceType 创建一个 Service 来接管 pod 流量。通过&lt;code&gt;minikube&lt;/code&gt; 节点上的 IP &lt;code&gt;192.168.59.100&lt;/code&gt; 暴露服务。 &lt;code&gt;NodePort&lt;/code&gt; 服务会路由到自动创建的 &lt;code&gt;ClusterIP&lt;/code&gt; 服务。 通过请求 &lt;code&gt;&amp;lt;节点 IP&amp;gt;:&amp;lt;节点端口&amp;gt;&lt;/code&gt; -- &lt;code&gt;192.168.59.100&lt;/code&gt;:30000，你可以从集群的外部访问一个 &lt;code&gt;NodePort&lt;/code&gt; 服务，最终重定向到 &lt;code&gt;hellok8s:v3&lt;/code&gt; 的 &lt;code&gt;3000&lt;/code&gt; 端口。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: service-hellok8s-nodeport&#xA;spec:&#xA;  type: NodePort&#xA;  selector:&#xA;    app: hellok8s&#xA;  ports:&#xA;  - port: 3000&#xA;    nodePort: 30000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;创建 &lt;code&gt;service-hellok8s-nodeport&lt;/code&gt; Servcie 后，使用 &lt;code&gt;curl&lt;/code&gt; 命令或者浏览器访问 &lt;code&gt;http://192.168.59.100:30000&lt;/code&gt; 可以得到结果。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl&amp;nbsp;apply&amp;nbsp;-f&amp;nbsp;service-hellok8s-nodeport.yaml&#xA;&#xA;kubectl get service&#xA;# NAME                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE&#xA;# service-hellok8s-nodeport    NodePort    10.109.188.161   &amp;lt;none&amp;gt;        3000:30000/TCP   28s&#xA;&#xA;kubectl get pods&#xA;# NAME                                   READY   STATUS    RESTARTS   AGE&#xA;# hellok8s-deployment-5d5545b69c-24lw5   1/1     Running   0          27m&#xA;# hellok8s-deployment-5d5545b69c-9g94t   1/1     Running   0          27m&#xA;# hellok8s-deployment-5d5545b69c-9gm8r   1/1     Running   0          27m&#xA;&#xA;curl http://192.168.59.100:30000&#xA;# [v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-9g94t&#xA;&#xA;curl http://192.168.59.100:30000&#xA;# [v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-24lw5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LoadBalancer&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer&#34;&gt;&lt;code&gt;LoadBalancer&lt;/code&gt;&lt;/a&gt; 是使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 &lt;code&gt;NodePort&lt;/code&gt; 服务和 &lt;code&gt;ClusterIP&lt;/code&gt; 服务上，假如你在 &lt;a href=&#34;https://aws.amazon.com&#34;&gt;AWS&lt;/a&gt; 的 &lt;a href=&#34;https://aws.amazon.com/eks/&#34;&gt;EKS&lt;/a&gt; 集群上创建一个 Type 为 &lt;code&gt;LoadBalancer&lt;/code&gt; 的 Service。它会自动创建一个 ELB (&lt;a href=&#34;https://aws.amazon.com/elasticloadbalancing&#34;&gt;Elastic Load Balancer&lt;/a&gt;) ，并可以根据配置的 IP 池中自动分配一个独立的 IP 地址，可以供外部访问。&lt;/p&gt; &#xA;&lt;p&gt;这里因为我们使用的是 &lt;code&gt;minikube&lt;/code&gt;，可以使用 &lt;code&gt;minikube tunnel&lt;/code&gt; 来辅助创建 LoadBalancer 的 &lt;code&gt;EXTERNAL_IP&lt;/code&gt;，具体教程可以查看&lt;a href=&#34;https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access&#34;&gt;官网文档&lt;/a&gt;，但是和实际云提供商的 LoadBalancer 还是有本质区别，所以 &lt;a href=&#34;https://github.com/guangzhengli/kubernetes_workshop&#34;&gt;Repository&lt;/a&gt; 不做更多阐述，有条件的可以使用 &lt;a href=&#34;https://aws.amazon.com&#34;&gt;AWS&lt;/a&gt; 的 &lt;a href=&#34;https://aws.amazon.com/eks/&#34;&gt;EKS&lt;/a&gt; 集群上创建一个 ELB (&lt;a href=&#34;https://aws.amazon.com/elasticloadbalancing&#34;&gt;Elastic Load Balancer&lt;/a&gt;) 试试。&lt;/p&gt; &#xA;&lt;p&gt;下图显示 LoadBalancer 的 Service 架构图。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/service-loadbalancer-fix-name.png&#34; alt=&#34;service-loadbalancer-fix-name&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ingress&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#ingress-v1beta1-networking-k8s-io&#34;&gt;Ingress&lt;/a&gt; 公开从集群外部到集群内&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34;&gt;服务&lt;/a&gt;的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、 SSL/TLS，以及基于名称的虚拟托管。你必须拥有一个 &lt;a href=&#34;https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers&#34;&gt;Ingress 控制器&lt;/a&gt; 才能满足 Ingress 的要求。 仅创建 Ingress 资源本身没有任何效果。 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress-controllers&#34;&gt;Ingress 控制器&lt;/a&gt; 通常负责通过负载均衡器来实现 Ingress，例如 &lt;code&gt;minikube&lt;/code&gt; 默认使用的是 &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/tutorials/nginx_tcp_udp_ingress/&#34;&gt;nginx-ingress&lt;/a&gt;，目前 &lt;code&gt;minikube&lt;/code&gt; 也支持 &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/handbook/addons/kong-ingress/&#34;&gt;Kong-Ingress&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;Ingress 可以“简单理解”为服务的网关 Gateway，它是所有流量的入口，经过配置的路由规则，将流量重定向到后端的服务。&lt;/p&gt; &#xA;&lt;p&gt;在 &lt;code&gt;minikube&lt;/code&gt; 中，可以通过下面命令开启 Ingress-Controller 的功能。默认使用的是 &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/tutorials/nginx_tcp_udp_ingress/&#34;&gt;nginx-ingress&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;minikube addons enable ingress&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接着删除之前创建的所有 &lt;code&gt;pod&lt;/code&gt;, &lt;code&gt;deployment&lt;/code&gt;, &lt;code&gt;service&lt;/code&gt; 资源。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl delete deployment,service --all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接着根据之前的教程，创建 &lt;code&gt;hellok8s:v3&lt;/code&gt; 和 &lt;code&gt;nginx&lt;/code&gt; 的&lt;code&gt;deployment&lt;/code&gt;与 &lt;code&gt;service&lt;/code&gt; 资源。Service 的 type 为 ClusterIP 即可。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;hellok8s:v3&lt;/code&gt; 的端口映射为 &lt;code&gt;3000:3000&lt;/code&gt;，&lt;code&gt;nginx&lt;/code&gt; 的端口映射为 &lt;code&gt;4000:80&lt;/code&gt;，这里后续写 Ingress Route 规则时会用到。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: service-hellok8s-clusterip&#xA;spec:&#xA;  type: ClusterIP&#xA;  selector:&#xA;    app: hellok8s&#xA;  ports:&#xA;  - port: 3000&#xA;    targetPort: 3000&#xA;&#xA;---&#xA;&#xA;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:v3&#xA;          name: hellok8s-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: service-nginx-clusterip&#xA;spec:&#xA;  type: ClusterIP&#xA;  selector:&#xA;    app: nginx&#xA;  ports:&#xA;  - port: 4000&#xA;    targetPort: 80&#xA;&#xA;---&#xA;&#xA;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: nginx-deployment&#xA;spec:&#xA;  replicas: 2&#xA;  selector:&#xA;    matchLabels:&#xA;      app: nginx&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: nginx&#xA;    spec:&#xA;      containers:&#xA;      - image: nginx&#xA;        name: nginx-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f hellok8s.yaml                 &#xA;# service/service-hellok8s-clusterip created&#xA;# deployment.apps/hellok8s-deployment created&#xA;&#xA;kubectl apply -f nginx.yaml   &#xA;# service/service-nginx-clusterip created&#xA;# deployment.apps/nginx-deployment created&#xA;&#xA;kubectl get pods            &#xA;# NAME                                   READY   STATUS    RESTARTS   AGE&#xA;# hellok8s-deployment-5d5545b69c-4wvmf   1/1     Running   0          55s&#xA;# hellok8s-deployment-5d5545b69c-qcszp   1/1     Running   0          55s&#xA;# hellok8s-deployment-5d5545b69c-sn7mn   1/1     Running   0          55s&#xA;# nginx-deployment-d47fd7f66-d9r7x       1/1     Running   0          34s&#xA;# nginx-deployment-d47fd7f66-hp5nf       1/1     Running   0          34s&#xA;&#xA;kubectl get service&#xA;# NAME                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE&#xA;# service-hellok8s-clusterip   ClusterIP   10.97.88.18      &amp;lt;none&amp;gt;        3000/TCP   77s&#xA;# service-nginx-clusterip      ClusterIP   10.103.161.247   &amp;lt;none&amp;gt;        4000/TCP   56s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;这样在 k8s 集群中，就有 3 个 &lt;code&gt;hellok8s:v3&lt;/code&gt; 的 pod，2 个 &lt;code&gt;nginx&lt;/code&gt; 的 pod。并且&lt;code&gt;hellok8s:v3&lt;/code&gt; 的端口映射为 &lt;code&gt;3000:3000&lt;/code&gt;，&lt;code&gt;nginx&lt;/code&gt; 的端口映射为 &lt;code&gt;4000:80&lt;/code&gt;。在这个基础上，接下来编写 Ingress 资源的定义，&lt;code&gt;nginx.ingress.kubernetes.io/ssl-redirect: &#34;false&#34;&lt;/code&gt; 的意思是这里关闭 &lt;code&gt;https&lt;/code&gt; 连接，只使用 &lt;code&gt;http&lt;/code&gt; 连接。&lt;/p&gt; &#xA;&lt;p&gt;匹配前缀为 &lt;code&gt;/hello&lt;/code&gt; 的路由规则，重定向到 &lt;code&gt;hellok8s:v3&lt;/code&gt; 服务，匹配前缀为 &lt;code&gt;/&lt;/code&gt; 的跟路径重定向到 &lt;code&gt;nginx&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.k8s.io/v1&#xA;kind: Ingress&#xA;metadata:&#xA;  name: hello-ingress&#xA;  annotations:&#xA;    # We are defining this annotation to prevent nginx&#xA;    # from redirecting requests to `https` for now&#xA;    nginx.ingress.kubernetes.io/ssl-redirect: &#34;false&#34;&#xA;spec:&#xA;  rules:&#xA;    - http:&#xA;        paths:&#xA;          - path: /hello&#xA;            pathType: Prefix&#xA;            backend:&#xA;              service:&#xA;                name: service-hellok8s-clusterip&#xA;                port:&#xA;                  number: 3000&#xA;          - path: /&#xA;            pathType: Prefix&#xA;            backend:&#xA;              service:&#xA;                name: service-nginx-clusterip&#xA;                port:&#xA;                  number: 4000&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f ingress.yaml&#xA;# ingress.extensions/hello-ingress created&#xA;&#xA;kubectl get ingress          &#xA;# NAME            CLASS   HOSTS   ADDRESS   PORTS   AGE&#xA;# hello-ingress   nginx   *                 80      16s&#xA;&#xA;# replace 192.168.59.100 by your minikube ip&#xA;curl http://192.168.59.100/hello&#xA;# [v3] Hello, Kubernetes!, From host: hellok8s-deployment-5d5545b69c-sn7mn&#xA;&#xA;curl http://192.168.59.100/&#xA;# (....Thank you for using nginx.....)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上面的教程中将所有流量都发送到 Ingress 中，如下图所示：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/ingress.png&#34; alt=&#34;ingress&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Namespace&lt;/h2&gt; &#xA;&lt;p&gt;在实际的开发当中，有时候我们需要不同的环境来做开发和测试，例如 &lt;code&gt;dev&lt;/code&gt; 环境给开发使用，&lt;code&gt;test&lt;/code&gt; 环境给 QA 使用，那么 k8s 能不能在不同环境 &lt;code&gt;dev&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; &lt;code&gt;uat&lt;/code&gt; &lt;code&gt;prod&lt;/code&gt; 中区分资源，让不同环境的资源独立互相不影响呢，答案是肯定的，k8s 提供了名为 Namespace 的资源来帮助隔离资源。&lt;/p&gt; &#xA;&lt;p&gt;在 Kubernetes 中，&lt;strong&gt;名字空间（Namespace）&lt;/strong&gt; 提供一种机制，将同一集群中的资源划分为相互隔离的组。 同一名字空间内的资源名称要唯一，但跨名字空间时没有这个要求。 名字空间作用域仅针对带有名字空间的对象，例如 Deployment、Service 等。&lt;/p&gt; &#xA;&lt;p&gt;前面的教程中，默认使用的 namespace 是 &lt;code&gt;default&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;下面展示如何创建一个新的 namespace， &lt;code&gt;namespace.yaml&lt;/code&gt; 文件定义了两个不同的 namespace，分别是 &lt;code&gt;dev&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Namespace&#xA;metadata:&#xA;  name: dev&#xA;  &#xA;---&#xA;&#xA;apiVersion: v1&#xA;kind: Namespace&#xA;metadata:&#xA;  name: test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;可以通过&lt;code&gt;kubectl apply -f namespaces.yaml&lt;/code&gt; 创建两个新的 namespace，分别是 &lt;code&gt;dev&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kubectl apply -f namespaces.yaml    &#xA;# namespace/dev created&#xA;# namespace/test created&#xA;&#xA;&#xA;kubectl get namespaces          &#xA;# NAME              STATUS   AGE&#xA;# default           Active   215d&#xA;# dev               Active   2m44s&#xA;# ingress-nginx     Active   110d&#xA;# kube-node-lease   Active   215d&#xA;# kube-public       Active   215d&#xA;# kube-system       Active   215d&#xA;# test              Active   2m44s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;那么如何在新的 namespace 下创建资源和获取资源呢？只需要在命令后面加上 &lt;code&gt;-n namespace&lt;/code&gt; 即可。例如根据上面教程中，在名为 &lt;code&gt;dev&lt;/code&gt; 的 namespace 下创建 &lt;code&gt;hellok8s:v3&lt;/code&gt; 的 deployment 资源。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f deployment.yaml -n dev&#xA;&#xA;kubectl get pods -n dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configmap&lt;/h2&gt; &#xA;&lt;p&gt;上面的教程提到，我们在不同环境 &lt;code&gt;dev&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; &lt;code&gt;uat&lt;/code&gt; &lt;code&gt;prod&lt;/code&gt; 中区分资源，可以让其资源独立互相不受影响，但是随之而来也会带来一些问题，例如不同环境的数据库的地址往往是不一样的，那么如果在代码中写同一个数据库的地址，就会出现问题。&lt;/p&gt; &#xA;&lt;p&gt;K8S 使用 ConfigMap 来将你的配置数据和应用程序代码分开，将非机密性的数据保存到键值对中。ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过 1 MiB。如果你需要保存超出此尺寸限制的数据，你可能考虑挂载存储卷。&lt;/p&gt; &#xA;&lt;p&gt;下面我们可以来看一个例子，我们修改之前代码，假设不同环境的数据库地址不同，下面代码从环境变量中获取 &lt;code&gt;DB_URL&lt;/code&gt;，并将它返回。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func hello(w http.ResponseWriter, r *http.Request) {&#xA;&#x9;host, _ := os.Hostname()&#xA;&#x9;dbURL := os.Getenv(&#34;DB_URL&#34;)&#xA;&#x9;io.WriteString(w, fmt.Sprintf(&#34;[v4] Hello, Kubernetes! From host: %s, Get Database Connect URL: %s&#34;, host, dbURL))&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;http.HandleFunc(&#34;/&#34;, hello)&#xA;&#x9;http.ListenAndServe(&#34;:3000&#34;, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;构建 &lt;code&gt;hellok8s:v4&lt;/code&gt; 的镜像，推送到远程仓库。并删除之前创建的所有资源。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build . -t guangzhengli/hellok8s:v4&#xA;docker push guangzhengli/hellok8s:v4&#xA;&#xA;kubectl delete deployment,service,ingress --all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接下来创建不同 namespace 的 configmap 来存放 &lt;code&gt;DB_URL&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;p&gt;创建 &lt;code&gt;hellok8s-config-dev.yaml&lt;/code&gt; 文件&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: ConfigMap&#xA;metadata:&#xA;  name: hellok8s-config&#xA;data:&#xA;  DB_URL: &#34;http://DB_ADDRESS_DEV&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;创建 &lt;code&gt;hellok8s-config-test.yaml&lt;/code&gt; 文件&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: ConfigMap&#xA;metadata:&#xA;  name: hellok8s-config&#xA;data:&#xA;  DB_URL: &#34;http://DB_ADDRESS_TEST&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;分别在 &lt;code&gt;dev&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; 两个 namespace 下创建相同的 &lt;code&gt;ConfigMap&lt;/code&gt;，名字都叫 hellok8s-config，但是存放的 Pair 对中 Value 值不一样。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f hellok8s-config-dev.yaml -n dev&#xA;# configmap/hellok8s-config created&#xA;&#xA;kubectl apply -f hellok8s-config-test.yaml -n test &#xA;# configmap/hellok8s-config created&#xA;&#xA;kubectl get configmap --all-namespaces&#xA;NAMESPACE         NAME                                 DATA   AGE&#xA;dev               hellok8s-config                      1      3m12s&#xA;test              hellok8s-config                      1      2m1s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;接着使用 POD 的方式来部署 &lt;code&gt;hellok8s:v4&lt;/code&gt;，其中 &lt;code&gt;env.name&lt;/code&gt; 表示的是将 configmap 中的值写进环境变量，这样代码从环境变量中获取 &lt;code&gt;DB_URL&lt;/code&gt;，这个 KEY 名称必须保持一致。&lt;code&gt;valueFrom&lt;/code&gt; 代表从哪里读取，&lt;code&gt;configMapKeyRef&lt;/code&gt; 这里表示从名为 &lt;code&gt;hellok8s-config&lt;/code&gt; 的 &lt;code&gt;configMap&lt;/code&gt; 中读取 &lt;code&gt;KEY=DB_URL&lt;/code&gt; 的 Value。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: hellok8s-pod&#xA;spec:&#xA;  containers:&#xA;    - name: hellok8s-container&#xA;      image: guangzhengli/hellok8s:v4&#xA;      env:&#xA;        - name: DB_URL&#xA;          valueFrom:&#xA;            configMapKeyRef:&#xA;              name: hellok8s-config&#xA;              key: DB_URL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;下面分别在 &lt;code&gt;dev&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; 两个 namespace 下创建 &lt;code&gt;hellok8s:v4&lt;/code&gt;，接着通过 &lt;code&gt;port-forward&lt;/code&gt; 的方式访问不同 namespace 的服务，可以看到返回的 &lt;code&gt;Get Database Connect URL: http://DB_ADDRESS_TEST&lt;/code&gt; 是不一样的！&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f hellok8s.yaml -n dev             &#xA;# pod/hellok8s-pod created&#xA;&#xA;kubectl apply -f hellok8s.yaml -n test&#xA;# pod/hellok8s-pod created&#xA;&#xA;kubectl port-forward hellok8s-pod 3000:3000 -n dev&#xA;&#xA;curl http://localhost:3000&#xA;# [v4] Hello, Kubernetes! From host: hellok8s-pod, Get Database Connect URL: http://DB_ADDRESS_DEV&#xA;&#xA;kubectl port-forward hellok8s-pod 3000:3000 -n test&#xA;&#xA;curl http://localhost:3000&#xA;# [v4] Hello, Kubernetes! From host: hellok8s-pod, Get Database Connect URL: http://DB_ADDRESS_TEST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Secret&lt;/h2&gt; &#xA;&lt;p&gt;上面提到，我们会选择以 configmap 的方式挂载配置信息，但是当我们的配置信息需要加密的时候， configmap 就无法满足这个要求。例如上面要挂载数据库密码的时候，就需要明文挂载。&lt;/p&gt; &#xA;&lt;p&gt;这个时候就需要 Secret 来存储加密信息，虽然在资源文件的编码上，只是通过 Base64 的方式简单编码，但是在实际生产过程中，可以通过 pipeline 或者专业的 &lt;a href=&#34;https://aws.amazon.com/kms/&#34;&gt;AWS KMS&lt;/a&gt; 服务进行密钥管理。这样就大大减少了安全事故。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。由于创建 Secret 可以独立于使用它们的 Pod， 因此在创建、查看和编辑 Pod 的工作流程中暴露 Secret（及其数据）的风险较小。 Kubernetes 和在集群中运行的应用程序也可以对 Secret 采取额外的预防措施， 例如避免将机密数据写入非易失性存储。&lt;/p&gt; &#xA; &lt;p&gt;默认情况下，Kubernetes Secret 未加密地存储在 API 服务器的底层数据存储（etcd）中。 任何拥有 API 访问权限的人都可以检索或修改 Secret，任何有权访问 etcd 的人也可以。 此外，任何有权限在命名空间中创建 Pod 的人都可以使用该访问权限读取该命名空间中的任何 Secret； 这包括间接访问，例如创建 Deployment 的能力。&lt;/p&gt; &#xA; &lt;p&gt;为了安全地使用 Secret，请至少执行以下步骤：&lt;/p&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;为 Secret &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&#34;&gt;启用静态加密&lt;/a&gt;；&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authorization/&#34;&gt;启用或配置 RBAC 规则&lt;/a&gt;来限制读取和写入 Secret 的数据（包括通过间接方式）。需要注意的是，被准许创建 Pod 的人也隐式地被授权获取 Secret 内容。&lt;/li&gt; &#xA;  &lt;li&gt;在适当的情况下，还可以使用 RBAC 等机制来限制允许哪些主体创建新 Secret 或替换现有 Secret。&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Secret 的资源定义和 ConfigMap 结构基本一致，唯一区别在于 kind 是 &lt;code&gt;Secret&lt;/code&gt;，还有 Value 需要 Base64 编码，你可以通过下面命令快速 Base64 编解码。当然 Secret 也提供了一种 &lt;code&gt;stringData&lt;/code&gt;，可以不需要 Base64 编码。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &#34;db_password&#34; | base64&#xA;# ZGJfcGFzc3dvcmQK&#xA;&#xA;echo &#34;ZGJfcGFzc3dvcmQK&#34; | base64 -d&#xA;# db_password&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Secret&#xA;metadata:&#xA;  name: hellok8s-secret&#xA;data:&#xA;  DB_PASSWORD: &#34;ZGJfcGFzc3dvcmQK&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: hellok8s-pod&#xA;spec:&#xA;  containers:&#xA;    - name: hellok8s-container&#xA;      image: guangzhengli/hellok8s:v4&#xA;      env:&#xA;        - name: DB_PASSWORD&#xA;          valueFrom:&#xA;            secretKeyRef:&#xA;              name: hellok8s-secret&#xA;              key: DB_PASSWORD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Secret 的使用方法和前面教程中 ConfigMap 基本一致，这里就不再过多赘述。&lt;/p&gt; &#xA;&lt;h2&gt;Job&lt;/h2&gt; &#xA;&lt;p&gt;在实际的开发过程中，还有一类任务是之前的资源不能满足的，即一次性任务。例如常见的计算任务，只需要拿到相关数据计算后得出结果即可，无需一直运行。而处理这一类任务的资源就是 Job。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。&lt;/p&gt; &#xA; &lt;p&gt;一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;下面来看一个 Job 的资源定义，其中 Kind 和 metadata.name 是资源类型和名字就不再解释，&lt;code&gt;completions&lt;/code&gt; 指的是会创建 Pod 的数量，每个 pod 都会完成下面的任务。&lt;code&gt;parallelism&lt;/code&gt; 指的是并发执行最大数量，例如下面就会先创建 3 个 pod 并发执行任务，一旦某个 pod 执行完成，就会再创建新的 pod 来执行，直到 5 个 pod 执行完成，Job 才会被标记为完成。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;restartPolicy = &#34;OnFailure&lt;/code&gt; 的含义和 Pod 生命周期相关，Pod 中的容器可能因为退出时返回值非零， 或者容器因为超出内存约束而被杀死等等。 如果发生这类事件，并且 &lt;code&gt;.spec.template.spec.restartPolicy = &#34;OnFailure&#34;&lt;/code&gt;， Pod 则继续留在当前节点，但容器会被重新运行。因此，你的程序需要能够处理在本地被重启的情况，或者要设置 &lt;code&gt;.spec.template.spec.restartPolicy = &#34;Never&#34;&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: batch/v1&#xA;kind: Job&#xA;metadata:&#xA;  name: hello-job&#xA;spec:&#xA;  parallelism: 3&#xA;  completions: 5&#xA;  template:&#xA;    spec:&#xA;      restartPolicy: OnFailure&#xA;      containers:&#xA;        - name: echo&#xA;          image: busybox&#xA;          command: [for i in 9 8 7 6 5 4 3 2 1 ; do echo $i ; done]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;通过下面的命令创建 job，可以通过 &lt;code&gt;kubectl get pods -w&lt;/code&gt; 来观察 job 创建 pod 的过程和结果。最后可以通过 &lt;code&gt;logs&lt;/code&gt; 命令查看日志。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f hello-job.yaml&#xA;&#xA;kubectl get jobs                  &#xA;# NAME        COMPLETIONS   DURATION   AGE&#xA;# hello-job   5/5           19s        83s&#xA;&#xA;kubectl get pods                      &#xA;# NAME                                   READY   STATUS      RESTARTS   AGE&#xA;# hello-job--1-5gjjr                     0/1     Completed   0          34s&#xA;# hello-job--1-8ffmn                     0/1     Completed   0          26s&#xA;# hello-job--1-ltsvm                     0/1     Completed   0          34s&#xA;# hello-job--1-mttwv                     0/1     Completed   0          29s&#xA;# hello-job--1-ww2qp                     0/1     Completed   0          34s&#xA;&#xA;kubectl logs -f hello-job--1-5gjjr &#xA;# 1&#xA;# ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Job 完成时不会再创建新的 Pod，不过已有的 Pod &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy&#34;&gt;通常&lt;/a&gt;也不会被删除。 保留这些 Pod 使得你可以查看已完成的 Pod 的日志输出，以便检查错误、警告或者其它诊断性输出。 可以使用 &lt;code&gt;kubectl&lt;/code&gt; 来删除 Job（例如 &lt;code&gt;kubectl delete -f hello-job.yaml&lt;/code&gt;)。当使用 &lt;code&gt;kubectl&lt;/code&gt; 来删除 Job 时，该 Job 所创建的 Pod 也会被删除。&lt;/p&gt; &#xA;&lt;h2&gt;CronJob&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;CronJob&lt;/em&gt; 可以理解为定时任务，创建基于 Cron 时间调度的 &lt;a href=&#34;https://kubernetes.ion/docs/concepts/workloads/controllers/job/&#34;&gt;Jobs&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;CronJob 用于执行周期性的动作，例如备份、报告生成等。 这些任务中的每一个都应该配置为周期性重复的（例如：每天/每周/每月一次）； 你可以定义任务开始执行的时间间隔。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Cron 时间表语法&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# ┌───────────── 分钟 (0 - 59)&#xA;# │ ┌───────────── 小时 (0 - 23)&#xA;# │ │ ┌───────────── 月的某天 (1 - 31)&#xA;# │ │ │ ┌───────────── 月份 (1 - 12)&#xA;# │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周一；在某些系统上，7 也是星期日）&#xA;# │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat&#xA;# │ │ │ │ │&#xA;# │ │ │ │ │&#xA;# * * * * *&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;用法除了需要加上 cron 表达式之外，其余基本和 Job 保持一致。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: batch/v1&#xA;kind: CronJob&#xA;metadata:&#xA;  name: hello-cronjob&#xA;spec:&#xA;  schedule: &#34;* * * * *&#34; # Every minute&#xA;  jobTemplate:&#xA;    spec:&#xA;      template:&#xA;        spec:&#xA;          restartPolicy: OnFailure&#xA;          containers:&#xA;            - name: echo&#xA;              image: busybox&#xA;              command: [for i in 9 8 7 6 5 4 3 2 1 ; do echo $i ; done]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;使用命令和 Job 也基本保持一致，这里就不过多赘述。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl apply -f hello-cronjob.yaml&#xA;# cronjob.batch/hello-cronjob created&#xA;&#xA;kubectl get cronjob                &#xA;# NAME            SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE&#xA;# hello-cronjob   * * * * *   False     0        &amp;lt;none&amp;gt;          8s&#xA;&#xA;kubectl get pods   &#xA;# NAME                                   READY   STATUS      RESTARTS   AGE&#xA;# hello-cronjob-27694609--1-2nmdx        0/1     Completed   0          15s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Helm(TODO)&lt;/h2&gt; &#xA;&lt;p&gt;经过前面的教程，想必你已经对 kubernetes 的使用有了一定的理解。但是不知道你是否想过这样一个问题，就是我们前面教程中提到的所有资源，包括用 &lt;code&gt;pod&lt;/code&gt;, &lt;code&gt;deployment&lt;/code&gt;, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;ingress&lt;/code&gt;, &lt;code&gt;configmap&lt;/code&gt;,&lt;code&gt;secret&lt;/code&gt; 所有资源来部署一套完整的 &lt;code&gt;hellok8s&lt;/code&gt; 服务的话，难道需要一个一个的 &lt;code&gt;kubectl apply -f&lt;/code&gt; 来创建吗？如果换一个 namespace，或者说换一套 kubernetes 集群部署的话，又要重复性的操作创建的过程吗？&lt;/p&gt; &#xA;&lt;p&gt;我们平常使用操作系统时，需要安装一个应用的话，可以直接使用 &lt;code&gt;apt&lt;/code&gt; 或者 &lt;code&gt;brew&lt;/code&gt; 来直接安装，而不需要关心这个应用需要哪些依赖，哪些配置。在使用 kubernetes 安装应用服务 &lt;code&gt;hellok8s&lt;/code&gt; 时，我们自然也希望能够一个命令就安装完成，而提供这个能力的，就是 CNCF 的毕业项目 &lt;a href=&#34;https://github.com/helm/helm&#34;&gt;Helm&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Helm 帮助您管理 Kubernetes 应用—— Helm Chart，Helm 是查找、分享和使用软件构建 &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; 的最优方式。&lt;/p&gt; &#xA; &lt;p&gt;复杂性管理 ——即使是最复杂的应用，Helm Chart 依然可以描述， 提供使用单点授权的可重复安装应用程序。&lt;/p&gt; &#xA; &lt;p&gt;易于升级 ——随时随地升级和自定义的钩子消除您升级的痛苦。&lt;/p&gt; &#xA; &lt;p&gt;分发简单 —— Helm Chart 很容易在公共或私有化服务器上发版，分发和部署站点。&lt;/p&gt; &#xA; &lt;p&gt;回滚 —— 使用 &lt;code&gt;helm rollback&lt;/code&gt; 可以轻松回滚到之前的发布版本。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;我们通过 brew 来安装 helm。更多方式可以参考&lt;a href=&#34;https://helm.sh/zh/docs/intro/install/&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install helm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Helm 的使用方式可以解释为：Helm 安装 &lt;em&gt;charts&lt;/em&gt; 到 Kubernetes 集群中，每次安装都会创建一个新的 &lt;em&gt;release&lt;/em&gt;。你可以在 Helm 的 chart &lt;em&gt;repositories&lt;/em&gt; 中寻找新的 chart。&lt;/p&gt; &#xA;&lt;h3&gt;安装 hellok8s chart 快速开始(TODO)&lt;/h3&gt; &#xA;&lt;p&gt;//TODO&lt;/p&gt; &#xA;&lt;h3&gt;创建 helm charts&lt;/h3&gt; &#xA;&lt;p&gt;我们来手把手创建一个自己的 helm charts，完成我们之前的那些功能。&lt;/p&gt; &#xA;&lt;p&gt;使用 &lt;code&gt;helm create&lt;/code&gt; 命令默认会帮你创建一些 k8s 资源定义的初始文件，如下所示：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;helm create hello-helm&#xA;&#xA;.&#xA;├── Chart.yaml&#xA;├── _helpers.tpl&#xA;├── charts&#xA;├── templates&#xA;│&amp;nbsp;&amp;nbsp; ├── hellok8s-configmaps.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── hellok8s-deployment.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── hellok8s-service.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── ingress.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── nginx-deployment.yaml&#xA;│&amp;nbsp;&amp;nbsp; └── nginx-service.yaml&#xA;└── values.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;而我们删减一下这些文件，用之前教程中 ingress + configmaps 那节中的资源文件替代它，最终的结构长这样：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.&#xA;├── Chart.yaml&#xA;├── _helpers.tpl&#xA;├── charts&#xA;├── templates&#xA;│&amp;nbsp;&amp;nbsp; ├── hellok8s-configmaps.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── hellok8s-deployment.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── hellok8s-service.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── ingress.yaml&#xA;│&amp;nbsp;&amp;nbsp; ├── nginx-deployment.yaml&#xA;│&amp;nbsp;&amp;nbsp; └── nginx-service.yaml&#xA;└── values.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;其中 &lt;code&gt;hellok8s-configmaps.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: ConfigMap&#xA;metadata:&#xA;  name: hellok8s-config&#xA;data:&#xA;  DB_URL: &#34;http://DB_ADDRESS_DEV&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;hellok8s-deployment.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: hellok8s-deployment&#xA;spec:&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: hellok8s&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: hellok8s&#xA;    spec:&#xA;      containers:&#xA;        - image: guangzhengli/hellok8s:v4&#xA;          name: hellok8s-container&#xA;          env:&#xA;            - name: DB_URL&#xA;              valueFrom:&#xA;                configMapKeyRef:&#xA;                  name: hellok8s-config&#xA;                  key: DB_URL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;hellok8s-service.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: service-hellok8s-clusterip&#xA;spec:&#xA;  type: ClusterIP&#xA;  selector:&#xA;    app: hellok8s&#xA;  ports:&#xA;  - port: 3000&#xA;    targetPort: 3000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ingress.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.k8s.io/v1&#xA;kind: Ingress&#xA;metadata:&#xA;  name: hello-ingress&#xA;  annotations:&#xA;    # We are defining this annotation to prevent nginx&#xA;    # from redirecting requests to `https` for now&#xA;    nginx.ingress.kubernetes.io/ssl-redirect: &#34;false&#34;&#xA;spec:&#xA;  rules:&#xA;    - http:&#xA;        paths:&#xA;          - path: /hello&#xA;            pathType: Prefix&#xA;            backend:&#xA;              service:&#xA;                name: service-hellok8s-clusterip&#xA;                port:&#xA;                  number: 3000&#xA;          - path: /&#xA;            pathType: Prefix&#xA;            backend:&#xA;              service:&#xA;                name: service-nginx-clusterip&#xA;                port:&#xA;                  number: 4000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;nginx-deployment.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: nginx-deployment&#xA;spec:&#xA;  replicas: 2&#xA;  selector:&#xA;    matchLabels:&#xA;      app: nginx&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: nginx&#xA;    spec:&#xA;      containers:&#xA;      - image: nginx&#xA;        name: nginx-container&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;nginx-service.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: service-nginx-clusterip&#xA;spec:&#xA;  type: ClusterIP&#xA;  selector:&#xA;    app: nginx&#xA;  ports:&#xA;  - port: 4000&#xA;    targetPort: 80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Chart.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v2&#xA;name: hello-helm&#xA;description: A k8s tutorials in https://github.com/guangzhengli/k8s-tutorials&#xA;type: application&#xA;version: 0.1.0&#xA;appVersion: &#34;1.16.0&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在 &lt;code&gt;hello-helm&lt;/code&gt; 的跟路径下执行命令进行安装 chart，执行 curl 命令便能直接得到结果！查看 pod 和 service 等资源，便会发现 helm 能一键安装所有资源！&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;helm upgrade --install hello-helm --values values.yaml .&#xA;&#xA;curl http://192.168.59.100/hello&#xA;#[v4] Hello, Kubernetes! From host: hellok8s-deployment-f88f984c6-nzwg6, Get Database Connect URL: http://DB_ADDRESS_DEV&#xA;&#xA;kubectl get pods&#xA;# NAME                                  READY   STATUS    RESTARTS   AGE&#xA;# hellok8s-deployment-f88f984c6-k8hpz   1/1     Running   0          32m&#xA;# hellok8s-deployment-f88f984c6-nzwg6   1/1     Running   0          32m&#xA;# hellok8s-deployment-f88f984c6-s89s7   1/1     Running   0          32m&#xA;# nginx-deployment-d47fd7f66-6w76b      1/1     Running   0          32m&#xA;# nginx-deployment-d47fd7f66-tsqj5      1/1     Running   0          32m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;上传和下载其它 helm chart 使用 (TODO)&lt;/h3&gt; &#xA;&lt;p&gt;//TODO&lt;/p&gt; &#xA;&lt;h2&gt;Dashboard(TODO)&lt;/h2&gt; &#xA;&lt;p&gt;//TODO: 介绍 kubernetes dashboard&lt;/p&gt; &#xA;&lt;h3&gt;K9s(TODO)&lt;/h3&gt; &#xA;&lt;p&gt;//TODO: 介绍 k9s client&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/guangzhengli/PicURL@master/uPic/83ybd4.png&#34; alt=&#34;83ybd4&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>moby/buildkit</title>
    <updated>2022-09-01T01:33:09Z</updated>
    <id>tag:github.com,2022-09-01:/moby/buildkit</id>
    <link href="https://github.com/moby/buildkit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;concurrent, cache-efficient, and Dockerfile-agnostic builder toolkit&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/gPEIEo1NzmDTUu2bEPsUboqmU&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/gPEIEo1NzmDTUu2bEPsUboqmU.png&#34; alt=&#34;asciicinema example&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;BuildKit &#xA; &lt;!-- omit in toc --&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/moby/buildkit/client/llb&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/moby/buildkit?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/moby/buildkit/actions?query=workflow%3Abuild&#34;&gt;&lt;img src=&#34;https://github.com/moby/buildkit/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/moby/buildkit&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/moby/buildkit&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/moby/buildkit&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/moby/buildkit/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;BuildKit is a toolkit for converting source code to build artifacts in an efficient, expressive and repeatable manner.&lt;/p&gt; &#xA;&lt;p&gt;Key features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatic garbage collection&lt;/li&gt; &#xA; &lt;li&gt;Extendable frontend formats&lt;/li&gt; &#xA; &lt;li&gt;Concurrent dependency resolution&lt;/li&gt; &#xA; &lt;li&gt;Efficient instruction caching&lt;/li&gt; &#xA; &lt;li&gt;Build cache import/export&lt;/li&gt; &#xA; &lt;li&gt;Nested build job invocations&lt;/li&gt; &#xA; &lt;li&gt;Distributable workers&lt;/li&gt; &#xA; &lt;li&gt;Multiple output formats&lt;/li&gt; &#xA; &lt;li&gt;Pluggable architecture&lt;/li&gt; &#xA; &lt;li&gt;Execution without root privileges&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Read the proposal from &lt;a href=&#34;https://github.com/moby/moby/issues/32925&#34;&gt;https://github.com/moby/moby/issues/32925&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Introductory blog post &lt;a href=&#34;https://blog.mobyproject.org/introducing-buildkit-17e056cc5317&#34;&gt;https://blog.mobyproject.org/introducing-buildkit-17e056cc5317&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Join &lt;code&gt;#buildkit&lt;/code&gt; channel on &lt;a href=&#34;http://dockr.ly/slack&#34;&gt;Docker Community Slack&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;If you are visiting this repo for the usage of BuildKit-only Dockerfile features like &lt;code&gt;RUN --mount=type=(bind|cache|tmpfs|secret|ssh)&lt;/code&gt;, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/frontend/dockerfile/docs/reference.md&#34;&gt;&lt;code&gt;frontend/dockerfile/docs/reference.md&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://docs.docker.com/develop/develop-images/build_enhancements/&#34;&gt;BuildKit has been integrated to &lt;code&gt;docker build&lt;/code&gt; since Docker 18.09&lt;/a&gt;. You don&#39;t need to read this document unless you want to use the full-featured standalone version of BuildKit.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#used-by&#34;&gt;Used by&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#quick-start&#34;&gt;Quick start&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#starting-the-buildkitd-daemon&#34;&gt;Starting the &lt;code&gt;buildkitd&lt;/code&gt; daemon&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#exploring-llb&#34;&gt;Exploring LLB&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#exploring-dockerfiles&#34;&gt;Exploring Dockerfiles&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#building-a-dockerfile-with-buildctl&#34;&gt;Building a Dockerfile with &lt;code&gt;buildctl&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#building-a-dockerfile-using-external-frontend&#34;&gt;Building a Dockerfile using external frontend&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#output&#34;&gt;Output&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#imageregistry&#34;&gt;Image/Registry&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#local-directory&#34;&gt;Local directory&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#docker-tarball&#34;&gt;Docker tarball&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#oci-tarball&#34;&gt;OCI tarball&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#containerd-image-store&#34;&gt;containerd image store&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#cache&#34;&gt;Cache&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#garbage-collection&#34;&gt;Garbage collection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#export-cache&#34;&gt;Export cache&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#inline-push-image-and-cache-together&#34;&gt;Inline (push image and cache together)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#registry-push-image-and-cache-separately&#34;&gt;Registry (push image and cache separately)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#local-directory-1&#34;&gt;Local directory&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#github-actions-cache-experimental&#34;&gt;GitHub Actions cache (experimental)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#s3-cache-experimental&#34;&gt;S3 cache (experimental)&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#consistent-hashing&#34;&gt;Consistent hashing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#metadata&#34;&gt;Metadata&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#systemd-socket-activation&#34;&gt;Systemd socket activation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#expose-buildkit-as-a-tcp-service&#34;&gt;Expose BuildKit as a TCP service&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#load-balancing&#34;&gt;Load balancing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#containerizing-buildkit&#34;&gt;Containerizing BuildKit&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#podman&#34;&gt;Podman&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#kubernetes&#34;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#daemonless&#34;&gt;Daemonless&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#opentracing-support&#34;&gt;Opentracing support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#running-buildkit-without-root-privileges&#34;&gt;Running BuildKit without root privileges&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#building-multi-platform-images&#34;&gt;Building multi-platform images&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#configuring-buildctl&#34;&gt;Configuring &lt;code&gt;buildctl&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#color-output-controls&#34;&gt;Color Output Controls&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Used by&lt;/h2&gt; &#xA;&lt;p&gt;BuildKit is used by the following projects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/moby/moby/pull/37151&#34;&gt;Moby &amp;amp; Docker&lt;/a&gt; (&lt;code&gt;DOCKER_BUILDKIT=1 docker build&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/genuinetools/img&#34;&gt;img&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openfaas/openfaas-cloud&#34;&gt;OpenFaaS Cloud&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/containerbuilding/cbi&#34;&gt;container build interface&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tektoncd/catalog&#34;&gt;Tekton Pipelines&lt;/a&gt; (formerly &lt;a href=&#34;https://github.com/knative/build-templates&#34;&gt;Knative Build Templates&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/distributed-containers-inc/sanic&#34;&gt;the Sanic build tool&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/stellarproject/vab&#34;&gt;vab&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rancher/rio&#34;&gt;Rio&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rancher/kim&#34;&gt;kim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/pouch&#34;&gt;PouchContainer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/docker/buildx&#34;&gt;Docker buildx&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://okteto.com/&#34;&gt;Okteto Cloud&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vladaionescu/earthly&#34;&gt;Earthly earthfiles&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gitpod-io/gitpod&#34;&gt;Gitpod&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dagger.io&#34;&gt;Dagger&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tensorchord/envd/&#34;&gt;envd&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick start&lt;/h2&gt; &#xA;&lt;p&gt;&lt;span&gt;ℹ&lt;/span&gt; For Kubernetes deployments, see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/examples/kubernetes&#34;&gt;&lt;code&gt;examples/kubernetes&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;BuildKit is composed of the &lt;code&gt;buildkitd&lt;/code&gt; daemon and the &lt;code&gt;buildctl&lt;/code&gt; client. While the &lt;code&gt;buildctl&lt;/code&gt; client is available for Linux, macOS, and Windows, the &lt;code&gt;buildkitd&lt;/code&gt; daemon is only available for Linux currently.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;buildkitd&lt;/code&gt; daemon requires the following components to be installed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/opencontainers/runc&#34;&gt;runc&lt;/a&gt; or &lt;a href=&#34;https://github.com/containers/crun&#34;&gt;crun&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/containerd/containerd&#34;&gt;containerd&lt;/a&gt; (if you want to use containerd worker)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The latest binaries of BuildKit are available &lt;a href=&#34;https://github.com/moby/buildkit/releases&#34;&gt;here&lt;/a&gt; for Linux, macOS, and Windows.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://formulae.brew.sh/formula/buildkit&#34;&gt;Homebrew package&lt;/a&gt; (unofficial) is available for macOS.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ brew install buildkit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build BuildKit from source, see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/.github/CONTRIBUTING.md&#34;&gt;&lt;code&gt;.github/CONTRIBUTING.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Starting the &lt;code&gt;buildkitd&lt;/code&gt; daemon&lt;/h3&gt; &#xA;&lt;p&gt;You need to run &lt;code&gt;buildkitd&lt;/code&gt; as the root user on the host.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo buildkitd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run &lt;code&gt;buildkitd&lt;/code&gt; as a non-root user, see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/rootless.md&#34;&gt;&lt;code&gt;docs/rootless.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The buildkitd daemon supports two worker backends: OCI (runc) and containerd.&lt;/p&gt; &#xA;&lt;p&gt;By default, the OCI (runc) worker is used. You can set &lt;code&gt;--oci-worker=false --containerd-worker=true&lt;/code&gt; to use the containerd worker.&lt;/p&gt; &#xA;&lt;p&gt;We are open to adding more backends.&lt;/p&gt; &#xA;&lt;p&gt;To start the buildkitd daemon using systemd socket activiation, you can install the buildkit systemd unit files. See &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#systemd-socket-activation&#34;&gt;Systemd socket activation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The buildkitd daemon listens gRPC API on &lt;code&gt;/run/buildkit/buildkitd.sock&lt;/code&gt; by default, but you can also use TCP sockets. See &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#expose-buildkit-as-a-tcp-service&#34;&gt;Expose BuildKit as a TCP service&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Exploring LLB&lt;/h3&gt; &#xA;&lt;p&gt;BuildKit builds are based on a binary intermediate format called LLB that is used for defining the dependency graph for processes running part of your build. tl;dr: LLB is to Dockerfile what LLVM IR is to C.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Marshaled as Protobuf messages&lt;/li&gt; &#xA; &lt;li&gt;Concurrently executable&lt;/li&gt; &#xA; &lt;li&gt;Efficiently cacheable&lt;/li&gt; &#xA; &lt;li&gt;Vendor-neutral (i.e. non-Dockerfile languages can be easily implemented)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/solver/pb/ops.proto&#34;&gt;&lt;code&gt;solver/pb/ops.proto&lt;/code&gt;&lt;/a&gt; for the format definition, and see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/examples/README.md&#34;&gt;&lt;code&gt;./examples/README.md&lt;/code&gt;&lt;/a&gt; for example LLB applications.&lt;/p&gt; &#xA;&lt;p&gt;Currently, the following high-level languages has been implemented for LLB:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dockerfile (See &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#exploring-dockerfiles&#34;&gt;Exploring Dockerfiles&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tonistiigi/buildkit-pack&#34;&gt;Buildpacks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://matt-rickard.com/building-a-new-dockerfile-frontend/&#34;&gt;Mockerfile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/po3rin/gockerfile&#34;&gt;Gockerfile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/talos-systems/bldr/&#34;&gt;bldr (Pkgfile)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openllb/hlb&#34;&gt;HLB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/earthly/earthly&#34;&gt;Earthfile (Earthly)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/denzp/cargo-wharf&#34;&gt;Cargo Wharf (Rust)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AkihiroSuda/buildkit-nix&#34;&gt;Nix&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cmdjulian/mopy&#34;&gt;mopy (Python)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tensorchord/envd/&#34;&gt;envd (starlark)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;(open a PR to add your own language)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Exploring Dockerfiles&lt;/h3&gt; &#xA;&lt;p&gt;Frontends are components that run inside BuildKit and convert any build definition to LLB. There is a special frontend called gateway (&lt;code&gt;gateway.v0&lt;/code&gt;) that allows using any image as a frontend.&lt;/p&gt; &#xA;&lt;p&gt;During development, Dockerfile frontend (&lt;code&gt;dockerfile.v0&lt;/code&gt;) is also part of the BuildKit repo. In the future, this will be moved out, and Dockerfiles can be built using an external image.&lt;/p&gt; &#xA;&lt;h4&gt;Building a Dockerfile with &lt;code&gt;buildctl&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build \&#xA;    --frontend=dockerfile.v0 \&#xA;    --local context=. \&#xA;    --local dockerfile=.&#xA;# or&#xA;buildctl build \&#xA;    --frontend=dockerfile.v0 \&#xA;    --local context=. \&#xA;    --local dockerfile=. \&#xA;    --opt target=foo \&#xA;    --opt build-arg:foo=bar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;--local&lt;/code&gt; exposes local source files from client to the builder. &lt;code&gt;context&lt;/code&gt; and &lt;code&gt;dockerfile&lt;/code&gt; are the names Dockerfile frontend looks for build context and Dockerfile location.&lt;/p&gt; &#xA;&lt;h4&gt;Building a Dockerfile using external frontend&lt;/h4&gt; &#xA;&lt;p&gt;External versions of the Dockerfile frontend are pushed to &lt;a href=&#34;https://hub.docker.com/r/docker/dockerfile-upstream&#34;&gt;https://hub.docker.com/r/docker/dockerfile-upstream&lt;/a&gt; and &lt;a href=&#34;https://hub.docker.com/r/docker/dockerfile&#34;&gt;https://hub.docker.com/r/docker/dockerfile&lt;/a&gt; and can be used with the gateway frontend. The source for the external frontend is currently located in &lt;code&gt;./frontend/dockerfile/cmd/dockerfile-frontend&lt;/code&gt; but will move out of this repository in the future (&lt;a href=&#34;https://github.com/moby/buildkit/issues/163&#34;&gt;#163&lt;/a&gt;). For automatic build from master branch of this repository &lt;code&gt;docker/dockerfile-upstream:master&lt;/code&gt; or &lt;code&gt;docker/dockerfile-upstream:master-labs&lt;/code&gt; image can be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build \&#xA;    --frontend gateway.v0 \&#xA;    --opt source=docker/dockerfile \&#xA;    --local context=. \&#xA;    --local dockerfile=.&#xA;buildctl build \&#xA;    --frontend gateway.v0 \&#xA;    --opt source=docker/dockerfile \&#xA;    --opt context=https://github.com/moby/moby.git \&#xA;    --opt build-arg:APT_MIRROR=cdn-fastly.deb.debian.org&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Output&lt;/h3&gt; &#xA;&lt;p&gt;By default, the build result and intermediate cache will only remain internally in BuildKit. An output needs to be specified to retrieve the result.&lt;/p&gt; &#xA;&lt;h4&gt;Image/Registry&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --output type=image,name=docker.io/username/image,push=true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To export the image to multiple registries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --output type=image,\&#34;name=docker.io/username/image,docker.io/username2/image2\&#34;,push=true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To export the cache embed with the image and pushing them to registry together, type &lt;code&gt;registry&lt;/code&gt; is required to import the cache, you should specify &lt;code&gt;--export-cache type=inline&lt;/code&gt; and &lt;code&gt;--import-cache type=registry,ref=...&lt;/code&gt;. To export the cache to a local directy, you should specify &lt;code&gt;--export-cache type=local&lt;/code&gt;. Details in &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#export-cache&#34;&gt;Export cache&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ...\&#xA;  --output type=image,name=docker.io/username/image,push=true \&#xA;  --export-cache type=inline \&#xA;  --import-cache type=registry,ref=docker.io/username/image&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Keys supported by image output:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;name=&amp;lt;value&amp;gt;&lt;/code&gt;: specify image name(s)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;push=true&lt;/code&gt;: push after creating the image&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;push-by-digest=true&lt;/code&gt;: push unnamed image&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;registry.insecure=true&lt;/code&gt;: push to insecure HTTP registry&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;oci-mediatypes=true&lt;/code&gt;: use OCI mediatypes in configuration JSON instead of Docker&#39;s&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unpack=true&lt;/code&gt;: unpack image after creation (for use with containerd)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dangling-name-prefix=&amp;lt;value&amp;gt;&lt;/code&gt;: name image with &lt;code&gt;prefix@&amp;lt;digest&amp;gt;&lt;/code&gt;, used for anonymous images&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;name-canonical=true&lt;/code&gt;: add additional canonical name &lt;code&gt;name@&amp;lt;digest&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;compression=&amp;lt;uncompressed|gzip|estargz|zstd&amp;gt;&lt;/code&gt;: choose compression type for layers newly created and cached, gzip is default value. estargz should be used with &lt;code&gt;oci-mediatypes=true&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;compression-level=&amp;lt;value&amp;gt;&lt;/code&gt;: compression level for gzip, estargz (0-9) and zstd (0-22)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;force-compression=true&lt;/code&gt;: forcefully apply &lt;code&gt;compression&lt;/code&gt; option to all layers (including already existing layers)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;buildinfo=true&lt;/code&gt;: attach inline build info in &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/build-repro.md#image-config&#34;&gt;image config&lt;/a&gt; (default &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;buildinfo-attrs=true&lt;/code&gt;: attach inline build info attributes in &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/build-repro.md#image-config&#34;&gt;image config&lt;/a&gt; (default &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;store=true&lt;/code&gt;: store the result images to the worker&#39;s (e.g. containerd) image store as well as ensures that the image has all blobs in the content store (default &lt;code&gt;true&lt;/code&gt;). Ignored if the worker doesn&#39;t have image store (e.g. OCI worker).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;annotation.&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;: attach an annotation with the respective &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; to the built image &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Using the extended syntaxes, &lt;code&gt;annotation-&amp;lt;type&amp;gt;.&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;, &lt;code&gt;annotation[&amp;lt;platform&amp;gt;].&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; and both combined with &lt;code&gt;annotation-&amp;lt;type&amp;gt;[&amp;lt;platform&amp;gt;].&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;, allows configuring exactly where to attach the annotation.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; specifies what object to attach to, and can be any of &lt;code&gt;manifest&lt;/code&gt; (the default), &lt;code&gt;manifest-descriptor&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;index-descriptor&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&amp;lt;platform&amp;gt;&lt;/code&gt; specifies which objects to attach to (by default, all), and is the same key passed into the &lt;code&gt;platform&lt;/code&gt; opt, see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/multi-platform.md&#34;&gt;&lt;code&gt;docs/multi-platform.md&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/annotations.md&#34;&gt;&lt;code&gt;docs/annotations.md&lt;/code&gt;&lt;/a&gt; for more details.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If credentials are required, &lt;code&gt;buildctl&lt;/code&gt; will attempt to read Docker configuration file &lt;code&gt;$DOCKER_CONFIG/config.json&lt;/code&gt;. &lt;code&gt;$DOCKER_CONFIG&lt;/code&gt; defaults to &lt;code&gt;~/.docker&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Local directory&lt;/h4&gt; &#xA;&lt;p&gt;The local client will copy the files directly to the client. This is useful if BuildKit is being used for building something else than container images.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --output type=local,dest=path/to/output-dir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To export specific files use multi-stage builds with a scratch stage and copy the needed files into that stage with &lt;code&gt;COPY --from&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;...&#xA;FROM scratch as testresult&#xA;&#xA;COPY --from=builder /usr/src/app/testresult.xml .&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --opt target=testresult --output type=local,dest=path/to/output-dir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tar exporter is similar to local exporter but transfers the files through a tarball.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --output type=tar,dest=out.tar&#xA;buildctl build ... --output type=tar &amp;gt; out.tar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Docker tarball&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# exported tarball is also compatible with OCI spec&#xA;buildctl build ... --output type=docker,name=myimage | docker load&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;OCI tarball&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --output type=oci,dest=path/to/output.tar&#xA;buildctl build ... --output type=oci &amp;gt; output.tar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;containerd image store&lt;/h4&gt; &#xA;&lt;p&gt;The containerd worker needs to be used&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --output type=image,name=docker.io/username/image&#xA;ctr --namespace=buildkit images ls&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To change the containerd namespace, you need to change &lt;code&gt;worker.containerd.namespace&lt;/code&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/buildkitd.toml.md&#34;&gt;&lt;code&gt;/etc/buildkit/buildkitd.toml&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Cache&lt;/h2&gt; &#xA;&lt;p&gt;To show local build cache (&lt;code&gt;/var/lib/buildkit&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl du -v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To prune local build cache:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl prune&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Garbage collection&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/buildkitd.toml.md&#34;&gt;&lt;code&gt;./docs/buildkitd.toml.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Export cache&lt;/h3&gt; &#xA;&lt;p&gt;BuildKit supports the following cache exporters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;inline&lt;/code&gt;: embed the cache into the image, and push them to the registry together&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;registry&lt;/code&gt;: push the image and the cache separately&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;local&lt;/code&gt;: export to a local directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gha&lt;/code&gt;: export to GitHub Actions cache&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In most case you want to use the &lt;code&gt;inline&lt;/code&gt; cache exporter. However, note that the &lt;code&gt;inline&lt;/code&gt; cache exporter only supports &lt;code&gt;min&lt;/code&gt; cache mode. To enable &lt;code&gt;max&lt;/code&gt; cache mode, push the image and the cache separately by using &lt;code&gt;registry&lt;/code&gt; cache exporter.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;registry&lt;/code&gt; exporters both store the cache in the registry. For importing the cache, &lt;code&gt;type=registry&lt;/code&gt; is sufficient for both, as specifying the cache format is not necessary.&lt;/p&gt; &#xA;&lt;h4&gt;Inline (push image and cache together)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... \&#xA;  --output type=image,name=docker.io/username/image,push=true \&#xA;  --export-cache type=inline \&#xA;  --import-cache type=registry,ref=docker.io/username/image&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the inline cache is not imported unless &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#registry-push-image-and-cache-separately&#34;&gt;&lt;code&gt;--import-cache type=registry,ref=...&lt;/code&gt;&lt;/a&gt; is provided.&lt;/p&gt; &#xA;&lt;p&gt;Inline cache embeds cache metadata into the image config. The layers in the image will be left untouched compared to the image with no cache information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;ℹ&lt;/span&gt; Docker-integrated BuildKit (&lt;code&gt;DOCKER_BUILDKIT=1 docker build&lt;/code&gt;) and &lt;code&gt;docker buildx&lt;/code&gt;requires &lt;code&gt;--build-arg BUILDKIT_INLINE_CACHE=1&lt;/code&gt; to be specified to enable the &lt;code&gt;inline&lt;/code&gt; cache exporter. However, the standalone &lt;code&gt;buildctl&lt;/code&gt; does NOT require &lt;code&gt;--opt build-arg:BUILDKIT_INLINE_CACHE=1&lt;/code&gt; and the build-arg is simply ignored.&lt;/p&gt; &#xA;&lt;h4&gt;Registry (push image and cache separately)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... \&#xA;  --output type=image,name=localhost:5000/myrepo:image,push=true \&#xA;  --export-cache type=registry,ref=localhost:5000/myrepo:buildcache \&#xA;  --import-cache type=registry,ref=localhost:5000/myrepo:buildcache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;--export-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=registry&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mode=&amp;lt;min|max&amp;gt;&lt;/code&gt;: specify cache layers to export (default: &lt;code&gt;min&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;min&lt;/code&gt;: only export layers for the resulting image&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;max&lt;/code&gt;: export all the layers of all intermediate steps&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ref=&amp;lt;ref&amp;gt;&lt;/code&gt;: specify repository reference to store cache, e.g. &lt;code&gt;docker.io/user/image:tag&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;oci-mediatypes=&amp;lt;true|false&amp;gt;&lt;/code&gt;: whether to use OCI mediatypes in exported manifests (default: &lt;code&gt;true&lt;/code&gt;, since BuildKit &lt;code&gt;v0.8&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;compression=&amp;lt;uncompressed|gzip|estargz|zstd&amp;gt;&lt;/code&gt;: choose compression type for layers newly created and cached, gzip is default value. estargz and zstd should be used with &lt;code&gt;oci-mediatypes=true&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;compression-level=&amp;lt;value&amp;gt;&lt;/code&gt;: choose compression level for gzip, estargz (0-9) and zstd (0-22)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;force-compression=true&lt;/code&gt;: forcibly apply &lt;code&gt;compression&lt;/code&gt; option to all layers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;--import-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=registry&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ref=&amp;lt;ref&amp;gt;&lt;/code&gt;: specify repository reference to retrieve cache from, e.g. &lt;code&gt;docker.io/user/image:tag&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Local directory&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --export-cache type=local,dest=path/to/output-dir&#xA;buildctl build ... --import-cache type=local,src=path/to/input-dir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The directory layout conforms to OCI Image Spec v1.0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--export-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=local&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mode=&amp;lt;min|max&amp;gt;&lt;/code&gt;: specify cache layers to export (default: &lt;code&gt;min&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;min&lt;/code&gt;: only export layers for the resulting image&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;max&lt;/code&gt;: export all the layers of all intermediate steps&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dest=&amp;lt;path&amp;gt;&lt;/code&gt;: destination directory for cache exporter&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;oci-mediatypes=&amp;lt;true|false&amp;gt;&lt;/code&gt;: whether to use OCI mediatypes in exported manifests (default &lt;code&gt;true&lt;/code&gt;, since BuildKit &lt;code&gt;v0.8&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;compression=&amp;lt;uncompressed|gzip|estargz|zstd&amp;gt;&lt;/code&gt;: choose compression type for layers newly created and cached, gzip is default value. estargz and zstd should be used with &lt;code&gt;oci-mediatypes=true&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;compression-level=&amp;lt;value&amp;gt;&lt;/code&gt;: compression level for gzip, estargz (0-9) and zstd (0-22)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;force-compression=true&lt;/code&gt;: forcibly apply &lt;code&gt;compression&lt;/code&gt; option to all layers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;--import-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=local&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src=&amp;lt;path&amp;gt;&lt;/code&gt;: source directory for cache importer&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;digest=sha256:&amp;lt;sha256digest&amp;gt;&lt;/code&gt;: specify explicit digest of the manifest list to import&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tag=&amp;lt;tag&amp;gt;&lt;/code&gt;: determine custom tag of image. Defaults &#34;latest&#34; tag digest in &lt;code&gt;index.json&lt;/code&gt; is for digest, not for tag&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;GitHub Actions cache (experimental)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... \&#xA;  --output type=image,name=docker.io/username/image,push=true \&#xA;  --export-cache type=gha \&#xA;  --import-cache type=gha&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Github Actions cache saves both cache metadata and layers to GitHub&#39;s Cache service. This cache currently has a &lt;a href=&#34;https://docs.github.com/en/actions/advanced-guides/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy&#34;&gt;size limit of 10GB&lt;/a&gt; that is shared accross different caches in the repo. If you exceed this limit, GitHub will save your cache but will begin evicting caches until the total size is less than 10 GB. Recycling caches too often can result in slower runtimes overall.&lt;/p&gt; &#xA;&lt;p&gt;Similarly to using &lt;a href=&#34;https://github.com/actions/cache&#34;&gt;actions/cache&lt;/a&gt;, caches are &lt;a href=&#34;https://docs.github.com/en/actions/advanced-guides/caching-dependencies-to-speed-up-workflows#restrictions-for-accessing-a-cache&#34;&gt;scoped by branch&lt;/a&gt;, with the default and target branches being available to every branch.&lt;/p&gt; &#xA;&lt;p&gt;Following attributes are required to authenticate against the &lt;a href=&#34;https://github.com/tonistiigi/go-actions-cache/raw/master/api.md#authentication&#34;&gt;Github Actions Cache service API&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;url&lt;/code&gt;: Cache server URL (default &lt;code&gt;$ACTIONS_CACHE_URL&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;token&lt;/code&gt;: Access token (default &lt;code&gt;$ACTIONS_RUNTIME_TOKEN&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;span&gt;ℹ&lt;/span&gt; This type of cache can be used with &lt;a href=&#34;https://github.com/docker/build-push-action&#34;&gt;Docker Build Push Action&lt;/a&gt; where &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;token&lt;/code&gt; will be automatically set. To use this backend in a inline &lt;code&gt;run&lt;/code&gt; step, you have to include &lt;a href=&#34;https://github.com/crazy-max/ghaction-github-runtime&#34;&gt;crazy-max/ghaction-github-runtime&lt;/a&gt; in your workflow to expose the runtime.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--export-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=gha&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mode=&amp;lt;min|max&amp;gt;&lt;/code&gt;: specify cache layers to export (default: &lt;code&gt;min&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;min&lt;/code&gt;: only export layers for the resulting image&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;max&lt;/code&gt;: export all the layers of all intermediate steps&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scope=&amp;lt;scope&amp;gt;&lt;/code&gt;: which scope cache object belongs to (default &lt;code&gt;buildkit&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;--import-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=gha&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scope=&amp;lt;scope&amp;gt;&lt;/code&gt;: which scope cache object belongs to (default &lt;code&gt;buildkit&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;S3 cache (experimental)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... \&#xA;  --output type=image,name=docker.io/username/image,push=true \&#xA;  --export-cache type=s3,region=eu-west-1,bucket=my_bucket,name=my_image \&#xA;  --import-cache type=s3,region=eu-west-1,bucket=my_bucket,name=my_image&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following attributes are required:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;bucket&lt;/code&gt;: AWS S3 bucket (default: &lt;code&gt;$AWS_BUCKET&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;region&lt;/code&gt;: AWS region (default: &lt;code&gt;$AWS_REGION&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Storage locations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;blobs: &lt;code&gt;s3://&amp;lt;bucket&amp;gt;/&amp;lt;prefix&amp;gt;&amp;lt;blobs_prefix&amp;gt;/&amp;lt;sha256&amp;gt;&lt;/code&gt;, default: &lt;code&gt;s3://&amp;lt;bucket&amp;gt;/blobs/&amp;lt;sha256&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;manifests: &lt;code&gt;s3://&amp;lt;bucket&amp;gt;/&amp;lt;prefix&amp;gt;&amp;lt;manifests_prefix&amp;gt;/&amp;lt;name&amp;gt;&lt;/code&gt;, default: &lt;code&gt;s3://&amp;lt;bucket&amp;gt;/manifests/&amp;lt;name&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;S3 configuration:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;blobs_prefix&lt;/code&gt;: global prefix to store / read blobs on s3 (default: &lt;code&gt;blobs/&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;manifests_prefix&lt;/code&gt;: global prefix to store / read blobs on s3 (default: &lt;code&gt;manifests/&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;endpoint_url&lt;/code&gt;: specify a specific S3 endpoint (default: empty)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;use_path_style&lt;/code&gt;: if set to &lt;code&gt;true&lt;/code&gt;, put the bucket name in the URL instead of in the hostname (default: &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;AWS Authentication:&lt;/p&gt; &#xA;&lt;p&gt;The simplest way is to use an IAM Instance profile. Others options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Any system using environment variables / config files supported by the &lt;a href=&#34;https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html&#34;&gt;AWS Go SDK&lt;/a&gt;. The configuration must be available for the buildkit daemon, not for the client.&lt;/li&gt; &#xA; &lt;li&gt;Using the following attributes: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;access_key_id&lt;/code&gt;: Access Key ID&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;secret_access_key&lt;/code&gt;: Secret Access Key&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;session_token&lt;/code&gt;: Session Token&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;--export-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=s3&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mode=&amp;lt;min|max&amp;gt;&lt;/code&gt;: specify cache layers to export (default: &lt;code&gt;min&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;min&lt;/code&gt;: only export layers for the resulting image&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;max&lt;/code&gt;: export all the layers of all intermediate steps&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prefix=&amp;lt;prefix&amp;gt;&lt;/code&gt;: set global prefix to store / read files on s3 (default: empty)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;name=&amp;lt;manifest&amp;gt;&lt;/code&gt;: specify name of the manifest to use (default &lt;code&gt;buildkit&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Multiple manifest names can be specified at the same time, separated by &lt;code&gt;;&lt;/code&gt;. The standard use case is to use the git sha1 as name, and the branch name as duplicate, and load both with 2 &lt;code&gt;import-cache&lt;/code&gt; commands.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;--import-cache&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type=s3&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prefix=&amp;lt;prefix&amp;gt;&lt;/code&gt;: set global prefix to store / read files on s3 (default: empty)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;blobs_prefix=&amp;lt;prefix&amp;gt;&lt;/code&gt;: set global prefix to store / read blobs on s3 (default: &lt;code&gt;blobs/&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;manifests_prefix=&amp;lt;prefix&amp;gt;&lt;/code&gt;: set global prefix to store / read manifests on s3 (default: &lt;code&gt;manifests/&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;name=&amp;lt;manifest&amp;gt;&lt;/code&gt;: name of the manifest to use (default &lt;code&gt;buildkit&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Consistent hashing&lt;/h3&gt; &#xA;&lt;p&gt;If you have multiple BuildKit daemon instances but you don&#39;t want to use registry for sharing cache across the cluster, consider client-side load balancing using consistent hashing.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/examples/kubernetes/consistenthash&#34;&gt;&lt;code&gt;./examples/kubernetes/consistenthash&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Metadata&lt;/h2&gt; &#xA;&lt;p&gt;To output build metadata such as the image digest, pass the &lt;code&gt;--metadata-file&lt;/code&gt; flag. The metadata will be written as a JSON object to the specified file. The directory of the specified file must already exist and be writable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl build ... --metadata-file metadata.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jq &#39;.&#39; metadata.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;containerimage.buildinfo&#34;: {&#xA;    &#34;frontend&#34;: &#34;dockerfile.v0&#34;,&#xA;    &#34;attrs&#34;: {&#xA;      &#34;context&#34;: &#34;https://github.com/crazy-max/buildkit-buildsources-test.git#master&#34;,&#xA;      &#34;filename&#34;: &#34;Dockerfile&#34;,&#xA;      &#34;source&#34;: &#34;docker/dockerfile:master&#34;&#xA;    },&#xA;    &#34;sources&#34;: [&#xA;      {&#xA;        &#34;type&#34;: &#34;docker-image&#34;,&#xA;        &#34;ref&#34;: &#34;docker.io/docker/buildx-bin:0.6.1@sha256:a652ced4a4141977c7daaed0a074dcd9844a78d7d2615465b12f433ae6dd29f0&#34;,&#xA;        &#34;pin&#34;: &#34;sha256:a652ced4a4141977c7daaed0a074dcd9844a78d7d2615465b12f433ae6dd29f0&#34;&#xA;      },&#xA;      {&#xA;        &#34;type&#34;: &#34;docker-image&#34;,&#xA;        &#34;ref&#34;: &#34;docker.io/library/alpine:3.13&#34;,&#xA;        &#34;pin&#34;: &#34;sha256:026f721af4cf2843e07bba648e158fb35ecc876d822130633cc49f707f0fc88c&#34;&#xA;      }&#xA;    ]&#xA;  },&#xA;  &#34;containerimage.config.digest&#34;: &#34;sha256:2937f66a9722f7f4a2df583de2f8cb97fc9196059a410e7f00072fc918930e66&#34;,&#xA;  &#34;containerimage.descriptor&#34;: {&#xA;    &#34;annotations&#34;: {&#xA;      &#34;config.digest&#34;: &#34;sha256:2937f66a9722f7f4a2df583de2f8cb97fc9196059a410e7f00072fc918930e66&#34;,&#xA;      &#34;org.opencontainers.image.created&#34;: &#34;2022-02-08T21:28:03Z&#34;&#xA;    },&#xA;    &#34;digest&#34;: &#34;sha256:19ffeab6f8bc9293ac2c3fdf94ebe28396254c993aea0b5a542cfb02e0883fa3&#34;,&#xA;    &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,&#xA;    &#34;size&#34;: 506&#xA;  },&#xA;  &#34;containerimage.digest&#34;: &#34;sha256:19ffeab6f8bc9293ac2c3fdf94ebe28396254c993aea0b5a542cfb02e0883fa3&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Systemd socket activation&lt;/h2&gt; &#xA;&lt;p&gt;On Systemd based systems, you can communicate with the daemon via &lt;a href=&#34;http://0pointer.de/blog/projects/socket-activation.html&#34;&gt;Systemd socket activation&lt;/a&gt;, use &lt;code&gt;buildkitd --addr fd://&lt;/code&gt;. You can find examples of using Systemd socket activation with BuildKit and Systemd in &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/examples/systemd&#34;&gt;&lt;code&gt;./examples/systemd&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Expose BuildKit as a TCP service&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;buildkitd&lt;/code&gt; daemon can listen the gRPC API on a TCP socket.&lt;/p&gt; &#xA;&lt;p&gt;It is highly recommended to create TLS certificates for both the daemon and the client (mTLS). Enabling TCP without mTLS is dangerous because the executor containers (aka Dockerfile &lt;code&gt;RUN&lt;/code&gt; containers) can call BuildKit API as well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildkitd \&#xA;  --addr tcp://0.0.0.0:1234 \&#xA;  --tlscacert /path/to/ca.pem \&#xA;  --tlscert /path/to/cert.pem \&#xA;  --tlskey /path/to/key.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;buildctl \&#xA;  --addr tcp://example.com:1234 \&#xA;  --tlscacert /path/to/ca.pem \&#xA;  --tlscert /path/to/clientcert.pem \&#xA;  --tlskey /path/to/clientkey.pem \&#xA;  build ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Load balancing&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;buildctl build&lt;/code&gt; can be called against randomly load balanced the &lt;code&gt;buildkitd&lt;/code&gt; daemon.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/#consistenthashing&#34;&gt;Consistent hashing&lt;/a&gt; for client-side load balancing.&lt;/p&gt; &#xA;&lt;h2&gt;Containerizing BuildKit&lt;/h2&gt; &#xA;&lt;p&gt;BuildKit can also be used by running the &lt;code&gt;buildkitd&lt;/code&gt; daemon inside a Docker container and accessing it remotely.&lt;/p&gt; &#xA;&lt;p&gt;We provide the container images as &lt;a href=&#34;https://hub.docker.com/r/moby/buildkit/tags/&#34;&gt;&lt;code&gt;moby/buildkit&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;moby/buildkit:latest&lt;/code&gt;: built from the latest regular &lt;a href=&#34;https://github.com/moby/buildkit/releases&#34;&gt;release&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;moby/buildkit:rootless&lt;/code&gt;: same as &lt;code&gt;latest&lt;/code&gt; but runs as an unprivileged user, see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/rootless.md&#34;&gt;&lt;code&gt;docs/rootless.md&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;moby/buildkit:master&lt;/code&gt;: built from the master branch&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;moby/buildkit:master-rootless&lt;/code&gt;: same as master but runs as an unprivileged user, see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/rootless.md&#34;&gt;&lt;code&gt;docs/rootless.md&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To run daemon in a container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d --name buildkitd --privileged moby/buildkit:latest&#xA;export BUILDKIT_HOST=docker-container://buildkitd&#xA;buildctl build --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Podman&lt;/h3&gt; &#xA;&lt;p&gt;To connect to a BuildKit daemon running in a Podman container, use &lt;code&gt;podman-container://&lt;/code&gt; instead of &lt;code&gt;docker-container://&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;podman run -d --name buildkitd --privileged moby/buildkit:latest&#xA;buildctl --addr=podman-container://buildkitd build --frontend dockerfile.v0 --local context=. --local dockerfile=. --output type=oci | podman load foo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; is not required.&lt;/p&gt; &#xA;&lt;h3&gt;Kubernetes&lt;/h3&gt; &#xA;&lt;p&gt;For Kubernetes deployments, see &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/examples/kubernetes&#34;&gt;&lt;code&gt;examples/kubernetes&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Daemonless&lt;/h3&gt; &#xA;&lt;p&gt;To run the client and an ephemeral daemon in a single container (&#34;daemonless mode&#34;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run \&#xA;    -it \&#xA;    --rm \&#xA;    --privileged \&#xA;    -v /path/to/dir:/tmp/work \&#xA;    --entrypoint buildctl-daemonless.sh \&#xA;    moby/buildkit:master \&#xA;        build \&#xA;        --frontend dockerfile.v0 \&#xA;        --local context=/tmp/work \&#xA;        --local dockerfile=/tmp/work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run \&#xA;    -it \&#xA;    --rm \&#xA;    --security-opt seccomp=unconfined \&#xA;    --security-opt apparmor=unconfined \&#xA;    -e BUILDKITD_FLAGS=--oci-worker-no-process-sandbox \&#xA;    -v /path/to/dir:/tmp/work \&#xA;    --entrypoint buildctl-daemonless.sh \&#xA;    moby/buildkit:master-rootless \&#xA;        build \&#xA;        --frontend \&#xA;        dockerfile.v0 \&#xA;        --local context=/tmp/work \&#xA;        --local dockerfile=/tmp/work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Opentracing support&lt;/h2&gt; &#xA;&lt;p&gt;BuildKit supports opentracing for buildkitd gRPC API and buildctl commands. To capture the trace to &lt;a href=&#34;https://github.com/jaegertracing/jaeger&#34;&gt;Jaeger&lt;/a&gt;, set &lt;code&gt;JAEGER_TRACE&lt;/code&gt; environment variable to the collection address.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d -p6831:6831/udp -p16686:16686 jaegertracing/all-in-one:latest&#xA;export JAEGER_TRACE=0.0.0.0:6831&#xA;# restart buildkitd and buildctl so they know JAEGER_TRACE&#xA;# any buildctl command should be traced to http://127.0.0.1:16686/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running BuildKit without root privileges&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/rootless.md&#34;&gt;&lt;code&gt;docs/rootless.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building multi-platform images&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/docs/multi-platform.md&#34;&gt;&lt;code&gt;docs/multi-platform.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Configuring &lt;code&gt;buildctl&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;h4&gt;Color Output Controls&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;buildctl&lt;/code&gt; has support for modifying the colors that are used to output information to the terminal. You can set the environment variable &lt;code&gt;BUILDKIT_COLORS&lt;/code&gt; to something like &lt;code&gt;run=green:warning=yellow:error=red:cancel=255,165,0&lt;/code&gt; to set the colors that you would like to use. Setting &lt;code&gt;NO_COLOR&lt;/code&gt; to anything will disable any colorized output as recommended by &lt;a href=&#34;https://no-color.org/&#34;&gt;no-color.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Parsing errors will be reported but ignored. This will result in default color values being used where needed.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/moby/buildkit/raw/master/util/progress/progressui/colors.go&#34;&gt;The list of pre-defined colors&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Want to contribute to BuildKit? Awesome! You can find information about contributing to this project in the &lt;a href=&#34;https://raw.githubusercontent.com/moby/buildkit/master/.github/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>