<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-22T01:36:05Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Layr-Labs/eigenda</title>
    <updated>2024-04-22T01:36:05Z</updated>
    <id>tag:github.com,2024-04-22:/Layr-Labs/eigenda</id>
    <link href="https://github.com/Layr-Labs/eigenda" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Secure, high-throughput, and decentralized Data Availability&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/Layr-Labs/eigenda/actions/workflows/unit-tests.yml/badge.svg?sanitize=true&#34; alt=&#34;Unit Tests&#34;&gt; &lt;img src=&#34;https://github.com/Layr-Labs/eigenda/actions/workflows/integration-tests.yml/badge.svg?sanitize=true&#34; alt=&#34;Integration Tests&#34;&gt; &lt;img src=&#34;https://github.com/Layr-Labs/eigenda/actions/workflows/golangci-lint.yml/badge.svg?sanitize=true&#34; alt=&#34;Linter&#34;&gt; &lt;img src=&#34;https://github.com/Layr-Labs/eigenda/actions/workflows/test-contracts.yml/badge.svg?sanitize=true&#34; alt=&#34;Contracts&#34;&gt; &lt;img src=&#34;https://github.com/Layr-Labs/eigenda/wiki/coverage.svg?sanitize=true&#34; alt=&#34;Go Coverage&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;EigenDA&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;EigenDA is a secure, high-throughput, and decentralized data availability (DA) service built on top of Ethereum using the &lt;a href=&#34;https://github.com/Layr-Labs/eigenlayer-contracts&#34;&gt;EigenLayer&lt;/a&gt; restaking primitives.&lt;/p&gt; &#xA;&lt;p&gt;To understand more how EigenDA works and how it transforms the modern landscape of data availability, continue reading &lt;a href=&#34;https://www.blog.eigenlayer.xyz/intro-to-eigenda-hyperscale-data-availability-for-rollups/&#34;&gt;EigenDA introduction&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To dive deep into the technical details, continue reading &lt;a href=&#34;https://github.com/Layr-Labs/eigenda/raw/master/docs/spec/overview.md&#34;&gt;EigenDA protocol spec&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re interested in integrating your rollup with EigenDA, please fill out the &lt;a href=&#34;https://docs.google.com/forms/d/e/1FAIpQLSez6PG-BL6C6Mc4QY1M--vbV219OGL_0Euv2zhJ1HmcUiU7cw/viewform&#34;&gt;EigenDA questionnaire&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;API Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The EigenDA public API is documented &lt;a href=&#34;https://github.com/Layr-Labs/eigenda/tree/master/api/docs&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Operating EigenDA Node&lt;/h2&gt; &#xA;&lt;p&gt;If you want to be an EigenDA operator and run a node, please clone &lt;a href=&#34;https://github.com/Layr-Labs/eigenda-operator-setup&#34;&gt;Operator Setup Guide&lt;/a&gt; GitHub repo and follow the instructions there.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We welcome all contributions! There are many ways to contribute to the project, including but not limited to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Opening a PR&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Layr-Labs/eigenda/issues/new/choose&#34;&gt;Submitting feature requests or bugs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Improving our product or contribution documentation&lt;/li&gt; &#xA; &lt;li&gt;Voting on &lt;a href=&#34;https://github.com/Layr-Labs/eigenda/issues&#34;&gt;open issues&lt;/a&gt; or contributing use cases to a feature request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Layr-Labs/eigenda/issues/new/choose&#34;&gt;Open an Issue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://forum.eigenlayer.xyz/c/eigenda/9&#34;&gt;EigenLayer/EigenDA forum&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:eigenda-support@eigenlabs.org&#34;&gt;Email&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/eigenlayer&#34;&gt;Follow us on Twitter&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>bom-squad/protobom</title>
    <updated>2024-04-22T01:36:05Z</updated>
    <id>tag:github.com,2024-04-22:/bom-squad/protobom</id>
    <link href="https://github.com/bom-squad/protobom" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A universal SBOM representation in protocol buffers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;protobom&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;protobom&lt;/code&gt; is a &lt;a href=&#34;https://protobuf.dev/getting-started/&#34;&gt;protocol buffers&lt;/a&gt; representation of SBOM data able to ingest documents in modern &lt;a href=&#34;https://spdx.dev/&#34;&gt;SPDX&lt;/a&gt; and &lt;a href=&#34;https://cyclonedx.org/&#34;&gt;CycloneDX&lt;/a&gt; versions without loss. It has an accompanying Go library generated from the protocol buffers definiton that also implements ingesters for those formats.&lt;/p&gt; &#xA;&lt;p&gt;Standard SBOMs are read by a reader using &lt;a href=&#34;https://raw.githubusercontent.com/bom-squad/protobom/main/docs/parsers.md&#34;&gt;parsers&lt;/a&gt; that understand the common formats. Parsers create a neutral protobom from data read from CycloneDX or SPDX documents.&lt;/p&gt; &#xA;&lt;p&gt;A protobom can be rendered into standard SBOM formats by the writer using &lt;a href=&#34;https://raw.githubusercontent.com/bom-squad/protobom/main/docs/serializers.md&#34;&gt;serializers&lt;/a&gt; that know how to generate those documents.&lt;/p&gt; &#xA;&lt;h2&gt;Supported Versions and Formats&lt;/h2&gt; &#xA;&lt;p&gt;The following table summarizes the current support for formats and encodings in the golang library.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Format&lt;/th&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;   &lt;th&gt;Encoding&lt;/th&gt; &#xA;   &lt;th&gt;Read&lt;/th&gt; &#xA;   &lt;th&gt;Write&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SPDX&lt;/td&gt; &#xA;   &lt;td&gt;2.2&lt;/td&gt; &#xA;   &lt;td&gt;JSON&lt;/td&gt; &#xA;   &lt;td&gt;planned&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SPDX&lt;/td&gt; &#xA;   &lt;td&gt;2.2&lt;/td&gt; &#xA;   &lt;td&gt;tag-value&lt;/td&gt; &#xA;   &lt;td&gt;planned&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SPDX&lt;/td&gt; &#xA;   &lt;td&gt;2.3&lt;/td&gt; &#xA;   &lt;td&gt;JSON&lt;/td&gt; &#xA;   &lt;td&gt;supported&lt;/td&gt; &#xA;   &lt;td&gt;supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SPDX&lt;/td&gt; &#xA;   &lt;td&gt;2.3&lt;/td&gt; &#xA;   &lt;td&gt;tag-value&lt;/td&gt; &#xA;   &lt;td&gt;planned&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SPDX&lt;/td&gt; &#xA;   &lt;td&gt;3.0&lt;/td&gt; &#xA;   &lt;td&gt;JSON&lt;/td&gt; &#xA;   &lt;td&gt;planned&lt;/td&gt; &#xA;   &lt;td&gt;planned&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CycloneDX&lt;/td&gt; &#xA;   &lt;td&gt;1.4&lt;/td&gt; &#xA;   &lt;td&gt;JSON&lt;/td&gt; &#xA;   &lt;td&gt;supported&lt;/td&gt; &#xA;   &lt;td&gt;supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CycloneDX&lt;/td&gt; &#xA;   &lt;td&gt;1.5&lt;/td&gt; &#xA;   &lt;td&gt;JSON&lt;/td&gt; &#xA;   &lt;td&gt;supported&lt;/td&gt; &#xA;   &lt;td&gt;supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Other read and write implementations can potentially be written in other &lt;a href=&#34;https://protobuf.dev/getting-started/&#34;&gt;languages supported by protobuf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;protobom&lt;/code&gt; library can be used to read in and write out SBOM documents in any of the above formats.&lt;/p&gt; &#xA;&lt;h3&gt;Example 1: The sbom-convert project&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bom-squad/sbom-convert&#34;&gt;https://github.com/bom-squad/sbom-convert&lt;/a&gt; provides a complete example of using the library to ingest an SBOM into the protobom intermediate format and then write out a new SBOM document in a different format.&lt;/p&gt; &#xA;&lt;h3&gt;Example 2: Read in SBOM document to work with specific field(s)&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;protobom&lt;/code&gt; library is the best and easiest way to interact with SBOM documents using the Go programming language. In this example, we show how to easily access the SBOM programmatically by creating a new protobom &lt;code&gt;Reader&lt;/code&gt;, and calling &lt;code&gt;reader.ParseFile()&lt;/code&gt; to read an SBOM document file and return a protobom sbom.Document. In this example, protobom handles the document unserialization regardless of the format. The developer using protobom can then work with a consistent protobom intermediate representation with the actual file format abstracted away.&lt;/p&gt; &#xA;&lt;p&gt;This particular example iterates over each node of the SBOM document&#39;s list of nodes and prints the ID, Name, and Version of each node. If the input document is an SPDX SBOM, each protobom Node will describe a single SPDX package. If the input document is a CycloneDX SBOM, each protobom Node will describe a CycloneDX component. The developer using protobom does not need to change the code based on the input format. The protobom library parses the input document to present an intermediate format of the data allowing the developer to work with a consistent intermediate format instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#xA;&#x9;&#34;github.com/bom-squad/protobom/pkg/reader&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// Create a new protobom SBOM reader:&#xA;&#x9;reader := reader.New()&#xA;&#x9;document, err := reader.ParseFile(&#34;sbom.spdx.json&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Printf(&#34;ERROR: %v\n&#34;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;// List all nodes in the SBOM and print some information about them:&#xA;&#x9;for _, node := range document.GetNodeList().GetNodes() {&#xA;&#x9;&#x9;fmt.Printf(&#34;Node ID [%v]: name: %v version: %v\n&#34;, node.GetId(), node.GetName(), node.GetVersion())&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 3: Generate an SBOM document programmatically&lt;/h3&gt; &#xA;&lt;p&gt;Developers can use the &lt;code&gt;protobom&lt;/code&gt; library to generate SBOM documents based on the content of a separate SBOM document, as shown by the sbom-convert project (&lt;a href=&#34;https://github.com/bom-squad/sbom-convert&#34;&gt;https://github.com/bom-squad/sbom-convert&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;However, the &lt;code&gt;protobom&lt;/code&gt; intermediate representation could also be used to create a new SBOM document. Developers could create a new &lt;code&gt;protobom&lt;/code&gt; document and use the Go programming language to populate the fields needed in the SBOM document. The developer would then create a new Writer to define where the SBOM should be written, and to which format the SBOM should be written passing in the programmatically-defined SBOM structure. The protobom v0.2.0 release includes five registered serializer formats for Writer.New(): SPDX23JSON, CDX12JSON, CDX13JSON, CDX14JSON, and CDX15JSON.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;&#34;github.com/bom-squad/protobom/pkg/formats&#34;&#xA;&#x9;&#34;github.com/bom-squad/protobom/pkg/sbom&#34;&#xA;&#x9;&#34;github.com/bom-squad/protobom/pkg/writer&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// Create a new protobom document&#xA;&#x9;document := sbom.NewDocument()&#xA;&#x9;// Populate some of the document metadata:&#xA;&#xA;&#x9;// ...for example the author:&#xA;&#x9;document.Metadata.Authors = append(&#xA;&#x9;&#x9;document.Metadata.Authors,&#xA;&#x9;&#x9;&amp;amp;sbom.Person{Name: &#34;John Doe&#34;},&#xA;&#x9;)&#xA;&#xA;&#x9;// ...and the tool that produced the SBOM:&#xA;&#x9;document.Metadata.Tools = append(&#xA;&#x9;&#x9;document.Metadata.Tools,&#xA;&#x9;&#x9;&amp;amp;sbom.Tool{&#xA;&#x9;&#x9;&#x9;Name:    &#34;ACME SBOM Tool&#34;,&#xA;&#x9;&#x9;&#x9;Version: &#34;1.0&#34;,&#xA;&#x9;&#x9;&#x9;Vendor:  &#34;ACME Corporation&#34;},&#xA;&#x9;)&#xA;&#xA;&#x9;// Create a node to represent the application:&#xA;&#x9;appNode := &amp;amp;sbom.Node{&#xA;&#x9;&#x9;Id:               &#34;pkg:generic/my-software@v1.0.0&#34;,&#xA;&#x9;&#x9;PrimaryPurpose:   []sbom.Purpose{sbom.Purpose_APPLICATION},&#xA;&#x9;&#x9;Name:             &#34;My Software Name&#34;,&#xA;&#x9;&#x9;Version:          &#34;v1.0.0&#34;,&#xA;&#x9;&#x9;Licenses:         []string{&#34;Apache-2.0&#34;},&#xA;&#x9;&#x9;LicenseConcluded: &#34;Apache-2.0&#34;,&#xA;&#x9;&#x9;LicenseComments:  &#34;Apache License&#34;,&#xA;&#x9;}&#xA;&#xA;&#x9;// Add the application node to the document&#39;s nodelist:&#xA;&#x9;document.NodeList.AddRootNode(appNode)&#xA;&#xA;&#x9;// Create two nodes to describe files in the application&#xA;&#xA;&#x9;node1 := &amp;amp;sbom.Node{&#xA;&#x9;&#x9;Id:          &#34;File--usr-lib-libsoftware.so&#34;,&#xA;&#x9;&#x9;Type:        sbom.Node_FILE,&#xA;&#x9;&#x9;Name:        &#34;/usr/lib/libsoftware.so&#34;,&#xA;&#x9;&#x9;Version:     &#34;1&#34;,&#xA;&#x9;&#x9;Copyright:   &#34;Copyright 2023 The ACME Corporation&#34;,&#xA;&#x9;&#x9;Description: &#34;Software Lib&#34;,&#xA;&#x9;}&#xA;&#xA;&#x9;node1.AddHash(sbom.HashAlgorithm_SHA1, &#34;f3ae11065cafc14e27a1410ae8be28e600bb8336&#34;)&#xA;&#x9;node1.AddHash(sbom.HashAlgorithm_SHA256, &#34;4f232eeb99e1663d07f0af1af6ea262bf594934b694228e71fd8f159f9a19f32&#34;)&#xA;&#x9;node1.AddHash(sbom.HashAlgorithm_SHA512, &#34;8044d0df34242699ad73bfe99b9ac3d6bbdaa4f8ebce1e23ee5c7f9fe59db8ad7b01fe94e886941793aee802008a35b05a30bc51426db796aa21e5e91b7ed9be&#34;)&#xA;&#xA;&#x9;document.NodeList.AddNode(node1)&#xA;&#xA;&#x9;node2 := &amp;amp;sbom.Node{&#xA;&#x9;&#x9;Id:          &#34;File--usr-bin-software&#34;,&#xA;&#x9;&#x9;Type:        sbom.Node_FILE,&#xA;&#x9;&#x9;Name:        &#34;/usr/bin/software&#34;,&#xA;&#x9;&#x9;Version:     &#34;1.0&#34;,&#xA;&#x9;&#x9;Copyright:   &#34;Copyright 2023 The ACME Corporation&#34;,&#xA;&#x9;&#x9;Description: &#34;Software binary&#34;,&#xA;&#x9;}&#xA;&#xA;&#x9;node2.AddHash(sbom.HashAlgorithm_SHA1, &#34;defee82004d22fc92ab81c0c952a62a2172bda8c&#34;)&#xA;&#x9;node2.AddHash(sbom.HashAlgorithm_SHA256, &#34;ad291c9572af8fc2ec8fd78d295adf7132c60ad3d10488fb63d120fc967a4132&#34;)&#xA;&#x9;node2.AddHash(sbom.HashAlgorithm_SHA512,  &#34;5940d8647907831e77ec00d81b318ca06655dbb0fd36d112684b03947412f0f98ea85b32548bc0877f3d7ce8f4de9b2c964062df44742b98c8e9bd851faecce9&#34;)&#xA;&#xA;&#x9;// Relate the application package and the files. This adds the nodes to &#xA;&#x9;// the document graph:&#xA;&#x9;document.RelateNodeAtID(node1, appNode.Id, sbom.Edge_contains)&#xA;&#x9;document.RelateNodeAtID(node2, appNode.Id, sbom.Edge_contains)&#xA;&#xA;&#x9;// Now render the document to STDOUT:&#xA;&#x9;w := writer.New()&#xA;&#xA;&#x9;// Write the SBOM to STDOUT in SPDX 2.3:&#xA;&#x9;w.WriteStreamWithOptions(&#xA;&#x9;&#x9;document, os.Stdout, &amp;amp;writer.Options{Format: formats.SPDX23JSON},&#xA;&#x9;)&#xA;&#xA;&#x9;// Write the SBOM to STDOUT in CycloneDX 1.4:&#xA;&#x9;w.WriteStreamWithOptions(&#xA;&#x9;&#x9;document, os.Stdout, &amp;amp;writer.Options{Format: formats.CDX14JSON},&#xA;&#x9;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>