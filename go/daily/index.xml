<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-27T01:35:51Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>BishopFox/jsluice</title>
    <updated>2023-06-27T01:35:51Z</updated>
    <id>tag:github.com,2023-06-27:/BishopFox/jsluice</id>
    <link href="https://github.com/BishopFox/jsluice" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;jsluice&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/BishopFox/jsluice&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/BishopFox/jsluice.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;jsluice&lt;/code&gt; is a Go package and &lt;a href=&#34;https://raw.githubusercontent.com/BishopFox/jsluice/main/cmd/jsluice/&#34;&gt;command-line tool&lt;/a&gt; for extracting URLs, paths, secrets, and other interesting data from JavaScript source code.&lt;/p&gt; &#xA;&lt;p&gt;If you want to do those things right away: look at the &lt;a href=&#34;https://raw.githubusercontent.com/BishopFox/jsluice/main/cmd/jsluice/&#34;&gt;command-line tool&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to integrate &lt;code&gt;jsluice&lt;/code&gt;&#39;s capabilities with your own project: look at the &lt;a href=&#34;https://raw.githubusercontent.com/BishopFox/jsluice/main/examples/&#34;&gt;examples&lt;/a&gt;, and read the &lt;a href=&#34;https://pkg.go.dev/github.com/BishopFox/jsluice&#34;&gt;package documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;To install the command-line tool, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;▶ go install github.com/BishopFox/jsluice/cmd/jsluice@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To add the package to your project, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;▶ go get github.com/BishopFox/jsluice&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Extracting URLs&lt;/h2&gt; &#xA;&lt;p&gt;Rather than using regular expressions alone, &lt;code&gt;jsluice&lt;/code&gt; uses &lt;code&gt;go-tree-sitter&lt;/code&gt; to look for places that URLs are known to be used, such as being assigned to &lt;code&gt;document.location&lt;/code&gt;, passed to &lt;code&gt;window.open()&lt;/code&gt;, or passed to &lt;code&gt;fetch()&lt;/code&gt; etc.&lt;/p&gt; &#xA;&lt;p&gt;A simple example program is provided &lt;a href=&#34;https://raw.githubusercontent.com/BishopFox/jsluice/main/examples/basic/main.go&#34;&gt;here&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;analyzer := jsluice.NewAnalyzer([]byte(`&#xA;    const login = (redirect) =&amp;gt; {&#xA;        document.location = &#34;/login?redirect=&#34; + redirect + &#34;&amp;amp;method=oauth&#34;&#xA;    }&#xA;`))&#xA;&#xA;for _, url := range analyzer.GetURLs() {&#xA;    j, err := json.MarshalIndent(url, &#34;&#34;, &#34;  &#34;)&#xA;    if err != nil {&#xA;        continue&#xA;    }&#xA;&#xA;    fmt.Printf(&#34;%s\n&#34;, j)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running the example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;▶ go run examples/basic/main.go&#xA;{&#xA;  &#34;url&#34;: &#34;/login?redirect=EXPR\u0026method=oauth&#34;,&#xA;  &#34;queryParams&#34;: [&#xA;    &#34;method&#34;,&#xA;    &#34;redirect&#34;&#xA;  ],&#xA;  &#34;bodyParams&#34;: [],&#xA;  &#34;method&#34;: &#34;GET&#34;,&#xA;  &#34;type&#34;: &#34;locationAssignment&#34;,&#xA;  &#34;source&#34;: &#34;document.location = \&#34;/login?redirect=\&#34; + redirect + \&#34;\u0026method=oauth\&#34;&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the value of the &lt;code&gt;redirect&lt;/code&gt; query string parameter is &lt;code&gt;EXPR&lt;/code&gt;. Code like this is common in JavaScript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.location = &#34;/login?redirect=&#34; + redirect + &#34;&amp;amp;method=oauth&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;jsluice&lt;/code&gt; understands string concatenation, and replaces any expressions it cannot know the value of with &lt;code&gt;EXPR&lt;/code&gt;. Although not a foolproof solution, this approach results in a valid URL or path more often than not, and means that it&#39;s possible to discover things that aren&#39;t easily found using other approaches. In this case, a naive regular expression may well miss the &lt;code&gt;method&lt;/code&gt; query string parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;▶ JS=&#39;document.location = &#34;/login?redirect=&#34; + redirect + &#34;&amp;amp;method=oauth&#34;&#39;&#xA;▶ echo $JS | grep -oE &#39;document\.location = &#34;[^&#34;]+&#34;&#39;&#xA;document.location = &#34;/login?redirect=&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom URL Matchers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;jsluice&lt;/code&gt; comes with some built-in URL matchers for common scenarios, but you can add more with the &lt;code&gt;AddURLMatcher&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;analyzer := jsluice.NewAnalyzer([]byte(`&#xA;    var fn = () =&amp;gt; {&#xA;        var meta = {&#xA;            contact: &#34;mailto:contact@example.com&#34;,&#xA;            home: &#34;https://example.com&#34;&#xA;        }&#xA;        return meta&#xA;    }&#xA;`))&#xA;&#xA;analyzer.AddURLMatcher(&#xA;    // The first value in the jsluice.URLMatcher struct is the type of node to look for.&#xA;    // It can be one of &#34;string&#34;, &#34;assignment_expression&#34;, or &#34;call_expression&#34;&#xA;    jsluice.URLMatcher{&#34;string&#34;, func(n *jsluice.Node) *jsluice.URL {&#xA;        val := n.DecodedString()&#xA;        if !strings.HasPrefix(val, &#34;mailto:&#34;) {&#xA;            return nil&#xA;        }&#xA;&#xA;        return &amp;amp;jsluice.URL{&#xA;            URL:  val,&#xA;            Type: &#34;mailto&#34;,&#xA;        }&#xA;    }},&#xA;)&#xA;&#xA;for _, match := range analyzer.GetURLs() {&#xA;    fmt.Println(match.URL)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s a copy of this example &lt;a href=&#34;https://raw.githubusercontent.com/BishopFox/jsluice/main/examples/urlmatcher/main.go&#34;&gt;here&lt;/a&gt;. You can run it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;▶ go run examples/urlmatcher/main.go&#xA;mailto:contact@example.com&#xA;https://example.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;jsluice&lt;/code&gt; doesn&#39;t match &lt;code&gt;mailto:&lt;/code&gt; URIs by default, it was found by the custom &lt;code&gt;URLMatcher&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Extracting Secrets&lt;/h2&gt; &#xA;&lt;p&gt;As well as URLs, &lt;code&gt;jsluice&lt;/code&gt; can extract secrets. As with URL extraction, custom matchers can be supplied to supplement the default matchers. There&#39;s a short example program &lt;a href=&#34;https://raw.githubusercontent.com/BishopFox/jsluice/main/examples/secrets/main.go&#34;&gt;here&lt;/a&gt; that does just that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;analyzer := jsluice.NewAnalyzer([]byte(`&#xA;    var config = {&#xA;        apiKey: &#34;AUTH_1a2b3c4d5e6f&#34;,&#xA;        apiURL: &#34;https://api.example.com/v2/&#34;&#xA;    }&#xA;`))&#xA;&#xA;analyzer.AddSecretMatcher(&#xA;    // The first value in the jsluice.SecretMatcher struct is a&#xA;    // tree-sitter query to run on the JavaScript source.&#xA;    jsluice.SecretMatcher{&#34;(pair) @match&#34;, func(n *jsluice.Node) *jsluice.Secret {&#xA;        key := n.ChildByFieldName(&#34;key&#34;).DecodedString()&#xA;        value := n.ChildByFieldName(&#34;value&#34;).DecodedString()&#xA;&#xA;        if !strings.Contains(key, &#34;api&#34;) {&#xA;            return nil&#xA;        }&#xA;&#xA;        if !strings.HasPrefix(value, &#34;AUTH_&#34;) {&#xA;            return nil&#xA;        }&#xA;&#xA;        return &amp;amp;jsluice.Secret{&#xA;            Kind: &#34;fakeApi&#34;,&#xA;            Data: map[string]string{&#xA;                &#34;key&#34;:   key,&#xA;                &#34;value&#34;: value,&#xA;            },&#xA;            Severity: jsluice.SeverityLow,&#xA;            Context:  n.Parent().AsMap(),&#xA;        }&#xA;    }},&#xA;)&#xA;&#xA;for _, match := range analyzer.GetSecrets() {&#xA;    j, err := json.MarshalIndent(match, &#34;&#34;, &#34;  &#34;)&#xA;    if err != nil {&#xA;        continue&#xA;    }&#xA;&#xA;    fmt.Printf(&#34;%s\n&#34;, j)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running the example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;▶ go run examples/secrets/main.go&#xA;[2023-06-14T13:04:16+0100]&#xA;{&#xA;  &#34;kind&#34;: &#34;fakeApi&#34;,&#xA;  &#34;data&#34;: {&#xA;    &#34;key&#34;: &#34;apiKey&#34;,&#xA;    &#34;value&#34;: &#34;AUTH_1a2b3c4d5e6f&#34;&#xA;  },&#xA;  &#34;severity&#34;: &#34;low&#34;,&#xA;  &#34;context&#34;: {&#xA;    &#34;apiKey&#34;: &#34;AUTH_1a2b3c4d5e6f&#34;,&#xA;    &#34;apiURL&#34;: &#34;https://api.example.com/v2/&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because we have a syntax tree available for the entire JavaScript source, it was possible to inspect both the &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;, and also to easily provide the parent object as context for the match.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>youshandefeiyang/LiveRedirect</title>
    <updated>2023-06-27T01:35:51Z</updated>
    <id>tag:github.com,2023-06-27:/youshandefeiyang/LiveRedirect</id>
    <link href="https://github.com/youshandefeiyang/LiveRedirect" rel="alternate"></link>
    <summary type="html">&lt;p&gt;LiveRedirect&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LiveRedirect&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;肥羊影音数码综合Telegram交流群:&lt;a href=&#34;https://t.me/feiyangdigital&#34;&gt;点击加入&lt;/a&gt;&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;肥羊影音数码综合Telegram频道:&lt;a href=&#34;https://t.me/feiyangofficalchannel&#34;&gt;点击加入&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;免责声明&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;本仓库或本仓库相关的仓库, 以下简称为本仓库&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库全部资源均搜集于互联网，如侵权请联系我删除&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库或本仓库相关的仓库的管理者, 以下简称为本仓库管理者&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库或本仓库相关的仓库的任何人员, 以下简称为本仓库人员&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库或本仓库相关的仓库内分享的任何内容, 以下简称为本仓库内容&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库内容，仅用于测试和学习研究，禁止用于商业用途，不得将其用于违反国家/地区/组织等的法律法规或相关规定的其他用途. 本仓库人员均不能保证其合法性，准确性，完整性和有效性，请根据情况自行判断. 禁止任何公众号、自媒体进行任何形式的转载、发布&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库内容的域名地址信息可以被任何人通过开发人员工具获取，没有经过逆向工程或网络攻击，不构成入侵计算机系统&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库人员对任何本仓库内容问题概不负责，包括但不限于由任何本仓库内容错误导致的任何损失或损害&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;间接使用本仓库内容的任何用户，包括但不限于建立 VPS 或在某些行为违反国家/地区法律或相关法规的情况下进行传播, 本仓库人员对于由此引起的任何隐私泄漏或其他后果概不负责&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;请勿将本仓库内容用于商业或非法目的，否则后果自负&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;如果任何单位或个人认为本仓库内容可能涉嫌侵犯其权利，则应及时通知并提供身份证明，所有权证明，本仓库管理者将在收到认证文件后删除相关本仓库内容&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;任何以任何方式查看本仓库内容的人或直接或间接使用本仓库内容的使用者都应仔细阅读此声明。本仓库管理者保留随时更改或补充此免责声明的权利。一旦使用/复制/修改了本仓库内容，则视为您已接受此免责声明&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库内容中涉及的第三方硬件、软件等，与本仓库内容没有任何直接或间接的关系。本仓库内容仅对部署和使用过程进行客观描述，不代表支持使用任何第三方硬件、软件。使用任何第三方硬件、软件，所造成的一切后果由使用的个人或组织承担，与本仓库内容无关&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;所有基于本仓库内容的源代码，进行的任何修改，为其他个人或组织的自发行为，与本仓库内容没有任何直接或间接的关系，所造成的一切后果亦与本仓库内容和本仓库人员无关&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;本仓库管理者保留随时对免责声明进行补充或更改的权利，直接或间接使用本仓库内容的个人或组织，视为接受本仓库分享的内容的免责声明&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;请不要在中华人民共和国境内使用本仓库内容&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;所有直接或间接使用本仓库内容的个人和组织，应 24 小时内完成学习和研究，并及时删除本仓库内容。如对本仓库内容的功能有需求，应自行开发相关功能&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;您必须在下载后的 24 小时内从您以任何形式存放或使用本仓库内容的任何硬件/软件/介质中完全删除本仓库内容&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;您以任何形式阅读/使用/复制/修改了本仓库内容，则视为已接受此免责声明，请仔细阅读&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;致谢&lt;/h1&gt; &#xA;&lt;h2&gt;非常感谢JetBrains对本项目的大力支持：&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://resources.jetbrains.com/storage/products/company/brand/logos/jetbrains-training-partner.png&#34; alt=&#34;Training Partner logo&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>