<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-23T01:36:36Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>psilva261/opossum</title>
    <updated>2023-02-23T01:36:36Z</updated>
    <id>tag:github.com,2023-02-23:/psilva261/opossum</id>
    <link href="https://github.com/psilva261/opossum" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rudimentary web browser written in Golang&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Opossum Web Browser&lt;/h1&gt; &#xA;&lt;p&gt;Basic portable Web browser; only needs a Go compiler to compile. Optimized for use on 9front and 9legacy, supports plan9port and 9pi as well.&lt;/p&gt; &#xA;&lt;p&gt;The UI is built with &lt;a href=&#34;https://github.com/mjl-/duit&#34;&gt;https://github.com/mjl-/duit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://psilva.sdf.org/browsing.png&#34; width=&#34;550&#34;&gt; &#xA;&lt;p&gt;Still experimental and a lot of features are missing.&lt;/p&gt; &#xA;&lt;p&gt;Supported features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;rudimentary HTML5 and CSS support, large parts like float/flex layout are just stub implementations&lt;/li&gt; &#xA; &lt;li&gt;Server-side rendered websites&lt;/li&gt; &#xA; &lt;li&gt;Images (pre-loaded all at once though)&lt;/li&gt; &#xA; &lt;li&gt;TLS&lt;/li&gt; &#xA; &lt;li&gt;experimental JS/DOM can be activated (very basic jQuery examples work)&lt;/li&gt; &#xA; &lt;li&gt;file downloads&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;h2&gt;Plan 9&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Setup TLS&#xA;hget https://curl.haxx.se/ca/cacert.pem &amp;gt; /sys/lib/tls/ca.pem&#xA;# Create mountpoints (needed on 9legacy)&#xA;mkdir /mnt/opossum&#xA;mkdir /mnt/sparkle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Binary&lt;/h3&gt; &#xA;&lt;p&gt;Binaries for amd64 and 386 can be downloaded from &lt;a href=&#34;https://psilva.sdf.org/opossum.html&#34;&gt;https://psilva.sdf.org/opossum.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Compile from Source&lt;/h3&gt; &#xA;&lt;p&gt;Set &lt;code&gt;$GOPROXY&lt;/code&gt; to &lt;code&gt;https://proxy.golang.org&lt;/code&gt; and then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install ./cmd/opossum&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Command line options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-h                   help&#xA;-v                   verbose&#xA;-vv                  print debug messages&#xA;-jsinsecure          activate js&#xA;-cpuprofile filename create cpuprofile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(-v and -vv produce a lot of output, consider turning on scroll since processing waits for that...)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;$font&lt;/code&gt; is used to select the font. Very large fonts will set dpi to 200.&lt;/p&gt; &#xA;&lt;h2&gt;macOS&lt;/h2&gt; &#xA;&lt;p&gt;Requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go&lt;/li&gt; &#xA; &lt;li&gt;Plan9Port&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install ./cmd/opossum&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;JS support&lt;/h1&gt; &#xA;&lt;p&gt;It&#39;s more like a demo and it&#39;s not really clear right now how much sandboxing is really needed. A rudimentary AJAX implementation is there though.&lt;/p&gt; &#xA;&lt;p&gt;Use on your own Risk!&lt;/p&gt; &#xA;&lt;p&gt;JS implementation forked from goja (and thus otto). Since the implementation is very limited anyway, DOM changes are only computed initially and during click events. A handful of jQuery UI widgets work though, e.g. jQuery UI Tab view &lt;a href=&#34;https://jqueryui.com/resources/demos/tabs/default.html&#34;&gt;https://jqueryui.com/resources/demos/tabs/default.html&lt;/a&gt;. There is also highly experimental ES6 support with Babel. (&lt;a href=&#34;https://github.com/psilva261/6to5&#34;&gt;https://github.com/psilva261/6to5&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Install the js engine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ..&#xA;git/clone https://github.com/psilva261/sparklefs&#xA;cd sparklefs&#xA;go install ./cmd/sparklefs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On 9legacy also the folders &lt;code&gt;/mnt/opossum&lt;/code&gt; and &lt;code&gt;/mnt/sparkle&lt;/code&gt; need to exist.&lt;/p&gt; &#xA;&lt;p&gt;Then it can be tested with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;opossum -jsinsecure https://jqueryui.com/resources/demos/tabs/default.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;TODO&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;load images on the fly&lt;/li&gt; &#xA; &lt;li&gt;implement more parts of HTML5 and CSS&lt;/li&gt; &#xA; &lt;li&gt;create a widget for div/span&lt;/li&gt; &#xA; &lt;li&gt;clean up code, support webfs, snarf&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>marmotedu/iam</title>
    <updated>2023-02-23T01:36:36Z</updated>
    <id>tag:github.com,2023-02-23:/marmotedu/iam</id>
    <link href="https://github.com/marmotedu/iam" rel="alternate"></link>
    <summary type="html">&lt;p&gt;企业级的 Go 语言实战项目：认证和授权系统（带配套课程）&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;IAM - 身份识别与访问管理系统&lt;/h1&gt; &#xA;&lt;p&gt;IAM = &lt;strong&gt;I&lt;/strong&gt;dentity and &lt;strong&gt;A&lt;/strong&gt;ccess &lt;strong&gt;M&lt;/strong&gt;anagement&lt;/p&gt; &#xA;&lt;p&gt;IAM 是一个基于 Go 语言开发的身份识别与访问管理系统，用于对资源访问进行授权。&lt;strong&gt;最新稳定版本为：v1.6.2，建议基于稳定版安装测试&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;p&gt;这里需要注意：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;如果你是极客时间《Go 语言项目开发实战》专栏的读者，请使用 v1.1.0 版本（tag）&lt;/li&gt; &#xA; &lt;li&gt;如果你是图书《从零构建企业级 Go 项目》的读者，请使用 v1.6.t2 版本（tag）&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;更详细的版本映射请参考：&lt;a href=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/guide/zh-CN/version_map.md&#34;&gt;版本映射&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;IAM 同时也具有以下能力：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;配合极客时间专栏 &lt;strong&gt;《&lt;a href=&#34;https://time.geekbang.org/column/intro/100079601?tab=intro&#34;&gt;Go 语言项目开发实战&lt;/a&gt;》&lt;/strong&gt;，讲解如何用 Go 做企业级应用的开发，是该项目的理论课程，包含了项目各个知识点和构建思路的讲解，也会包含我的一线研发经验和建议。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;作为一个开发脚手架，供开发者克隆后二次开发，快速构建自己的应用。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;IAM 项目会长期维护、定期更新，&lt;strong&gt;欢迎兄弟们 Star &amp;amp; Contribute&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;功能特性&lt;/h2&gt; &#xA;&lt;p&gt;本项目用到了Go企业开发的大部分核心技能点，见下图：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/images/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png&#34; alt=&#34;技术思维导图&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;更多请参考：&lt;a href=&#34;https://github.com/marmotedu/gocollect&#34;&gt;marmotedu/gocollect&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;软件架构&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/images/IAM%E6%9E%B6%E6%9E%84.png&#34; alt=&#34;IAM架构&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;架构解析见：&lt;a href=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/guide/zh-CN/installation/installation-architecture.md&#34;&gt;IAM 架构 &amp;amp; 能力说明&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;快速开始&lt;/h2&gt; &#xA;&lt;h3&gt;依赖检查&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;服务器能访问外网&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;操作系统：CentOS Linux 8.x (64-bit)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;本安装脚本基于 CentOS 8.2 安装，建议你选择 CentOS 8.x 系统。其它Linux发行版、macOS也能安装，不过需要手动安装。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;快速部署&lt;/h3&gt; &#xA;&lt;p&gt;快速部署请参考：&lt;a href=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/guide/zh-CN/installation/README.md#%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2&#34;&gt;IAM 部署指南&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;IAM 项目还提供了更详细的部署文档，请参考：&lt;a href=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/guide/zh-CN/installation/installation-procedures.md&#34;&gt;手把手教你部署IAM系统&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;构建&lt;/h3&gt; &#xA;&lt;p&gt;如果你需要重新编译IAM项目，可以执行以下 2 步：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;克隆源码&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/marmotedu/iam $GOPATH/src/github.com/marmotedu/iam&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;编译&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd $GOPATH/src/github.com/marmotedu/iam&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;构建后的二进制文件保存在 &lt;code&gt;_output/platforms/linux/amd64/&lt;/code&gt; 目录下。&lt;/p&gt; &#xA;&lt;h2&gt;使用指南&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/guide/zh-CN&#34;&gt;IAM Documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;如何贡献&lt;/h2&gt; &#xA;&lt;p&gt;欢迎贡献代码，贡献流程可以参考 &lt;a href=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/docs/devel/zh-CN/development.md&#34;&gt;developer&#39;s documentation&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;社区&lt;/h2&gt; &#xA;&lt;p&gt;You are encouraged to communicate most things via &lt;a href=&#34;https://github.com/marmotedu/iam/issues/new/choose&#34;&gt;GitHub issues&lt;/a&gt; or pull requests.&lt;/p&gt; &#xA;&lt;h2&gt;关于作者&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lingfei Kong &lt;a href=&#34;mailto:colin404@foxmail.com&#34;&gt;colin404@foxmail.com&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;为了方便交流，我建了微信群，可以加我 &lt;strong&gt;微信：nightskong&lt;/strong&gt;，拉你入群，方便交流。&lt;/p&gt; &#xA;&lt;h2&gt;谁在用&lt;/h2&gt; &#xA;&lt;p&gt;如果你有项目在使用iam系统模板，也欢迎联系作者，加入使用案例。&lt;/p&gt; &#xA;&lt;h2&gt;许可证&lt;/h2&gt; &#xA;&lt;p&gt;IAM is licensed under the MIT. See &lt;a href=&#34;https://raw.githubusercontent.com/marmotedu/iam/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for the full license text.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>allegro/bigcache</title>
    <updated>2023-02-23T01:36:36Z</updated>
    <id>tag:github.com,2023-02-23:/allegro/bigcache</id>
    <link href="https://github.com/allegro/bigcache" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Efficient cache for gigabytes of data written in Go.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BigCache &lt;a href=&#34;https://github.com/allegro/bigcache/actions?query=workflow%3Abuild&#34;&gt;&lt;img src=&#34;https://github.com/allegro/bigcache/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://coveralls.io/github/allegro/bigcache?branch=main&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/allegro/bigcache/badge.svg?branch=main&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://godoc.org/github.com/allegro/bigcache/v3&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/allegro/bigcache/v3?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://goreportcard.com/report/github.com/allegro/bigcache/v3&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/allegro/bigcache/v3&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Fast, concurrent, evicting in-memory cache written to keep big number of entries without impact on performance. BigCache keeps entries on heap but omits GC for them. To achieve that, operations on byte slices take place, therefore entries (de)serialization in front of the cache will be needed in most use cases.&lt;/p&gt; &#xA;&lt;p&gt;Requires Go 1.12 or newer.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Simple initialization&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;context&#34;&#xA;&#x9;&#34;github.com/allegro/bigcache/v3&#34;&#xA;)&#xA;&#xA;cache, _ := bigcache.New(context.Background(), bigcache.DefaultConfig(10 * time.Minute))&#xA;&#xA;cache.Set(&#34;my-unique-key&#34;, []byte(&#34;value&#34;))&#xA;&#xA;entry, _ := cache.Get(&#34;my-unique-key&#34;)&#xA;fmt.Println(string(entry))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom initialization&lt;/h3&gt; &#xA;&lt;p&gt;When cache load can be predicted in advance then it is better to use custom initialization because additional memory allocation can be avoided in that way.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;&#x9;&#34;log&#34;&#xA;&#xA;&#x9;&#34;github.com/allegro/bigcache/v3&#34;&#xA;)&#xA;&#xA;config := bigcache.Config {&#xA;&#x9;&#x9;// number of shards (must be a power of 2)&#xA;&#x9;&#x9;Shards: 1024,&#xA;&#xA;&#x9;&#x9;// time after which entry can be evicted&#xA;&#x9;&#x9;LifeWindow: 10 * time.Minute,&#xA;&#xA;&#x9;&#x9;// Interval between removing expired entries (clean up).&#xA;&#x9;&#x9;// If set to &amp;lt;= 0 then no action is performed.&#xA;&#x9;&#x9;// Setting to &amp;lt; 1 second is counterproductive — bigcache has a one second resolution.&#xA;&#x9;&#x9;CleanWindow: 5 * time.Minute,&#xA;&#xA;&#x9;&#x9;// rps * lifeWindow, used only in initial memory allocation&#xA;&#x9;&#x9;MaxEntriesInWindow: 1000 * 10 * 60,&#xA;&#xA;&#x9;&#x9;// max entry size in bytes, used only in initial memory allocation&#xA;&#x9;&#x9;MaxEntrySize: 500,&#xA;&#xA;&#x9;&#x9;// prints information about additional memory allocation&#xA;&#x9;&#x9;Verbose: true,&#xA;&#xA;&#x9;&#x9;// cache will not allocate more memory than this limit, value in MB&#xA;&#x9;&#x9;// if value is reached then the oldest entries can be overridden for the new ones&#xA;&#x9;&#x9;// 0 value means no size limit&#xA;&#x9;&#x9;HardMaxCacheSize: 8192,&#xA;&#xA;&#x9;&#x9;// callback fired when the oldest entry is removed because of its expiration time or no space left&#xA;&#x9;&#x9;// for the new entry, or because delete was called. A bitmask representing the reason will be returned.&#xA;&#x9;&#x9;// Default value is nil which means no callback and it prevents from unwrapping the oldest entry.&#xA;&#x9;&#x9;OnRemove: nil,&#xA;&#xA;&#x9;&#x9;// OnRemoveWithReason is a callback fired when the oldest entry is removed because of its expiration time or no space left&#xA;&#x9;&#x9;// for the new entry, or because delete was called. A constant representing the reason will be passed through.&#xA;&#x9;&#x9;// Default value is nil which means no callback and it prevents from unwrapping the oldest entry.&#xA;&#x9;&#x9;// Ignored if OnRemove is specified.&#xA;&#x9;&#x9;OnRemoveWithReason: nil,&#xA;&#x9;}&#xA;&#xA;cache, initErr := bigcache.New(context.Background(), config)&#xA;if initErr != nil {&#xA;&#x9;log.Fatal(initErr)&#xA;}&#xA;&#xA;cache.Set(&#34;my-unique-key&#34;, []byte(&#34;value&#34;))&#xA;&#xA;if entry, err := cache.Get(&#34;my-unique-key&#34;); err == nil {&#xA;&#x9;fmt.Println(string(entry))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;LifeWindow&lt;/code&gt; &amp;amp; &lt;code&gt;CleanWindow&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;LifeWindow&lt;/code&gt; is a time. After that time, an entry can be called dead but not deleted.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CleanWindow&lt;/code&gt; is a time. After that time, all the dead entries will be deleted, but not the entries that still have life.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://github.com/allegro/bigcache-bench&#34;&gt;Benchmarks&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Three caches were compared: bigcache, &lt;a href=&#34;https://github.com/coocood/freecache&#34;&gt;freecache&lt;/a&gt; and map. Benchmark tests were made using an i7-6700K CPU @ 4.00GHz with 32GB of RAM on Ubuntu 18.04 LTS (5.2.12-050212-generic).&lt;/p&gt; &#xA;&lt;p&gt;Benchmarks source code can be found &lt;a href=&#34;https://github.com/allegro/bigcache-bench&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Writes and reads&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go version&#xA;go version go1.13 linux/amd64&#xA;&#xA;go test -bench=. -benchmem -benchtime=4s ./... -timeout 30m&#xA;goos: linux&#xA;goarch: amd64&#xA;pkg: github.com/allegro/bigcache/v3/caches_bench&#xA;BenchmarkMapSet-8                     &#x9;12999889&#x9;       376 ns/op&#x9;     199 B/op&#x9;       3 allocs/op&#xA;BenchmarkConcurrentMapSet-8           &#x9; 4355726&#x9;      1275 ns/op&#x9;     337 B/op&#x9;       8 allocs/op&#xA;BenchmarkFreeCacheSet-8               &#x9;11068976&#x9;       703 ns/op&#x9;     328 B/op&#x9;       2 allocs/op&#xA;BenchmarkBigCacheSet-8                &#x9;10183717&#x9;       478 ns/op&#x9;     304 B/op&#x9;       2 allocs/op&#xA;BenchmarkMapGet-8                     &#x9;16536015&#x9;       324 ns/op&#x9;      23 B/op&#x9;       1 allocs/op&#xA;BenchmarkConcurrentMapGet-8           &#x9;13165708&#x9;       401 ns/op&#x9;      24 B/op&#x9;       2 allocs/op&#xA;BenchmarkFreeCacheGet-8               &#x9;10137682&#x9;       690 ns/op&#x9;     136 B/op&#x9;       2 allocs/op&#xA;BenchmarkBigCacheGet-8                &#x9;11423854&#x9;       450 ns/op&#x9;     152 B/op&#x9;       4 allocs/op&#xA;BenchmarkBigCacheSetParallel-8        &#x9;34233472&#x9;       148 ns/op&#x9;     317 B/op&#x9;       3 allocs/op&#xA;BenchmarkFreeCacheSetParallel-8       &#x9;34222654&#x9;       268 ns/op&#x9;     350 B/op&#x9;       3 allocs/op&#xA;BenchmarkConcurrentMapSetParallel-8   &#x9;19635688&#x9;       240 ns/op&#x9;     200 B/op&#x9;       6 allocs/op&#xA;BenchmarkBigCacheGetParallel-8        &#x9;60547064&#x9;        86.1 ns/op&#x9;     152 B/op&#x9;       4 allocs/op&#xA;BenchmarkFreeCacheGetParallel-8       &#x9;50701280&#x9;       147 ns/op&#x9;     136 B/op&#x9;       3 allocs/op&#xA;BenchmarkConcurrentMapGetParallel-8   &#x9;27353288&#x9;       175 ns/op&#x9;      24 B/op&#x9;       2 allocs/op&#xA;PASS&#xA;ok  &#x9;github.com/allegro/bigcache/v3/caches_bench&#x9;256.257s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Writes and reads in bigcache are faster than in freecache. Writes to map are the slowest.&lt;/p&gt; &#xA;&lt;h3&gt;GC pause time&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go version&#xA;go version go1.13 linux/amd64&#xA;&#xA;go run caches_gc_overhead_comparison.go&#xA;&#xA;Number of entries:  20000000&#xA;GC pause for bigcache:  1.506077ms&#xA;GC pause for freecache:  5.594416ms&#xA;GC pause for map:  9.347015ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;go version&#xA;go version go1.13 linux/arm64&#xA;&#xA;go run caches_gc_overhead_comparison.go&#xA;Number of entries:  20000000&#xA;GC pause for bigcache:  22.382827ms&#xA;GC pause for freecache:  41.264651ms&#xA;GC pause for map:  72.236853ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Test shows how long are the GC pauses for caches filled with 20mln of entries. Bigcache and freecache have very similar GC pause time.&lt;/p&gt; &#xA;&lt;h3&gt;Memory usage&lt;/h3&gt; &#xA;&lt;p&gt;You may encounter system memory reporting what appears to be an exponential increase, however this is expected behaviour. Go runtime allocates memory in chunks or &#39;spans&#39; and will inform the OS when they are no longer required by changing their state to &#39;idle&#39;. The &#39;spans&#39; will remain part of the process resource usage until the OS needs to repurpose the address. Further reading available &lt;a href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoNoMemoryFreeing&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;BigCache relies on optimization presented in 1.5 version of Go (&lt;a href=&#34;https://github.com/golang/go/issues/9477&#34;&gt;issue-9477&lt;/a&gt;). This optimization states that if map without pointers in keys and values is used then GC will omit its content. Therefore BigCache uses &lt;code&gt;map[uint64]uint32&lt;/code&gt; where keys are hashed and values are offsets of entries.&lt;/p&gt; &#xA;&lt;p&gt;Entries are kept in byte slices, to omit GC again. Byte slices size can grow to gigabytes without impact on performance because GC will only see single pointer to it.&lt;/p&gt; &#xA;&lt;h3&gt;Collisions&lt;/h3&gt; &#xA;&lt;p&gt;BigCache does not handle collisions. When new item is inserted and it&#39;s hash collides with previously stored item, new item overwrites previously stored value.&lt;/p&gt; &#xA;&lt;h2&gt;Bigcache vs Freecache&lt;/h2&gt; &#xA;&lt;p&gt;Both caches provide the same core features but they reduce GC overhead in different ways. Bigcache relies on &lt;code&gt;map[uint64]uint32&lt;/code&gt;, freecache implements its own mapping built on slices to reduce number of pointers.&lt;/p&gt; &#xA;&lt;p&gt;Results from benchmark tests are presented above. One of the advantage of bigcache over freecache is that you don’t need to know the size of the cache in advance, because when bigcache is full, it can allocate additional memory for new entries instead of overwriting existing ones as freecache does currently. However hard max size in bigcache also can be set, check &lt;a href=&#34;https://godoc.org/github.com/allegro/bigcache#Config&#34;&gt;HardMaxCacheSize&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;HTTP Server&lt;/h2&gt; &#xA;&lt;p&gt;This package also includes an easily deployable HTTP implementation of BigCache, which can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/allegro/bigcache/main/server&#34;&gt;server&lt;/a&gt; package.&lt;/p&gt; &#xA;&lt;h2&gt;More&lt;/h2&gt; &#xA;&lt;p&gt;Bigcache genesis is described in allegro.tech blog post: &lt;a href=&#34;http://allegro.tech/2016/03/writing-fast-cache-service-in-go.html&#34;&gt;writing a very fast cache service in Go&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;BigCache is released under the Apache 2.0 license (see &lt;a href=&#34;https://raw.githubusercontent.com/allegro/bigcache/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt;)&lt;/p&gt;</summary>
  </entry>
</feed>