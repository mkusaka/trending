<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-01T01:39:55Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>google/mangle</title>
    <updated>2022-12-01T01:39:55Z</updated>
    <id>tag:github.com,2022-12-01:/google/mangle</id>
    <link href="https://github.com/google/mangle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mangle&lt;/h1&gt; &#xA;&lt;p&gt;Mangle is a programming language for deductive database programming. It is an extension of Datalog, with various extensions like aggregation, function calls and optional type-checking.&lt;/p&gt; &#xA;&lt;p&gt;Deductive database is useful for bringing data from multiple data sources together since it enables us to represent and query that data in a uniform way. It can also be used to model domain knowledge, similar to machine-readable ontology but without being restricted to binary predicates.&lt;/p&gt; &#xA;&lt;p&gt;Datalog is an expressive declarative language similar to relational calculus (think SQL and relational views). Unlike relational calculus, it also supports recursive rules and program structuring in a straightforward way.&lt;/p&gt; &#xA;&lt;p&gt;Mangle contains Datalog as a fragment and adds extensions that make its use more practical. Some of the good properties like guaranteed termination are lost when extensions are used.&lt;/p&gt; &#xA;&lt;p&gt;The goal of Mangle as an open source project is to convey the concepts in a way that is accessible to developers and lends itself to easy experimentation. This repository contains an implementation of Mangle as a go library that can be easily embedded into applications.&lt;/p&gt; &#xA;&lt;p&gt;This is not an officially supported Google product.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/mangle/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/mangle/main/#building&#34;&gt;Building&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Simple Queries&lt;/h3&gt; &#xA;&lt;p&gt;Imagine you were asked to spot software affected by the &lt;a href=&#34;https://www.cisa.gov/uscert/apache-log4j-vulnerability-guidance&#34;&gt;log4j vulnerability discovered in late 2021&lt;/a&gt;. We want to look for projects that contain a Java archive (jar file) of log4j that is not updated to the patched version.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;projects_with_vulnerable_log4j(P) :-&#xA;  projects(P),&#xA;  contains_jar(P, &#34;log4j&#34;, Version),&#xA;  Version != &#34;2.17.1&#34;,&#xA;  Version != &#34;2.12.4&#34;,&#xA;  Version != &#34;2.3.2&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a Mangle &lt;em&gt;rule&lt;/em&gt;: conceptually, the implementation retrieve all possible values for variables &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Version&lt;/code&gt; that make all the subgoals true.&lt;/p&gt; &#xA;&lt;p&gt;Simple Mangle rules like this correspond to select-project-join relational queries. The same query in SQL would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT projects.id as P&#xA;FROM projects JOIN contains_jar ON projects.id = contains_jar.project_id&#xA;WHERE contains_jar.version NOT IN (&#34;2.17.1&#34;, &#34;2.12.4&#34;, &#34;2.3.2&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike SQL, our Mangle rule &lt;code&gt;projects_with_vulnerable_log4j&lt;/code&gt; has a name and can be referenced in other queries.&lt;/p&gt; &#xA;&lt;p&gt;(If translating non-recursive Datalog into SQL queries sounds interesting, you should check out the &lt;a href=&#34;https://logica.dev/&#34;&gt;Logica&lt;/a&gt; open source project.)&lt;/p&gt; &#xA;&lt;h3&gt;Aggregation&lt;/h3&gt; &#xA;&lt;p&gt;In practice, querying is rarely enough and we also need grouping and aggregation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;count_projects_with_vulnerable_log4j(Num) :-&#xA;  projects_with_vulnerable_log4j(P) |&amp;gt; do fn:group_by(), let Num = fn:Count().&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recursive Queries&lt;/h3&gt; &#xA;&lt;p&gt;The example does not specify what &lt;code&gt;contains_jar&lt;/code&gt; does. Here is a possible implementation for &lt;code&gt;contains_jar&lt;/code&gt; that walks a dependency graph. This shows that Mangle rules can be recursive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;contains_jar(P, Name, Version) :-&#xA;  contains_jar_directly(P, Name, Version).&#xA;&#xA;contains_jar(P, Name, Version) :-&#xA;  project_depends(P, Q),&#xA;  contains_jar(Q, Name, Version).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The two rules correspond to two cases in which a project may &#34;contain&#34; a jar: either directly, or through some dependency.&lt;/p&gt; &#xA;&lt;h3&gt;Knowledge Graphs, Property Graphs&lt;/h3&gt; &#xA;&lt;p&gt;When engineering requirements, it is useful to model a slice of the real world through a domain model and controlled vocabulary. Description logics use roles to describe how concepts interact, but the relationships are always binary. Mangle can represent binary predicates, but also arbitrary n-ary relations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;one_or_two_leg_trip(Codes, Start, Destination, Price) :-&#xA;  direct_conn(Code, Start, Destination, Price)&#xA;  |&amp;gt; let Codes = [Code].&#xA;&#xA;one_or_two_leg_trip(Codes, Start, Destination, Price) :-&#xA;  direct_conn(FirstCode, Start, Connecting, FirstLegPrice).&#xA;  direct_conn(SecondCode, Connecting, Destination, SecondLegPrice)&#xA;  |&amp;gt; let Code = [FirstCode, SecondCode],&#xA;     let Price = fn:sum(FirstLegPrice, SecondLegPrice).&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR&#xA;    /zurich --&amp;gt;|/code/ZL &amp;lt;br /&amp;gt; 60 CHF| /lausanne&#xA;    /zurich --&amp;gt;|/code/ZB &amp;lt;br /&amp;gt; 30 CHF| /bern&#xA;    /bern --&amp;gt;|/code/ZL &amp;lt;br /&amp;gt; 30 CHF| /lausanne&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;If you want to build from source, you need to set up ANTLR first, which requires Java runtime environment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget http://www.antlr.org/download/antlr-4.11.1-complete.jar&#xA;alias antlr=&#39;java -jar $PWD/antlr-4.11.1-complete.jar&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can generate the parser sources&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;antlr -Dlanguage=Go -package gen -o ./ parse/gen/Mangle.g4 -visitor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... and finally get the dependencies (see &lt;a href=&#34;https://raw.githubusercontent.com/google/mangle/main/go.mod&#34;&gt;go.mod&lt;/a&gt;) and build the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get ...&#xA;go build ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;The Mangle maintainers welcome external contributions to spec, documentation and this implementation (see &lt;a href=&#34;https://raw.githubusercontent.com/google/mangle/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;) and also other implementations. Pull requests will be handled &lt;a href=&#34;https://github.com/tensorflow/tensorflow/raw/master/CONTRIBUTING.md&#34;&gt;like for tensorflow&lt;/a&gt;, to ensure our internal usage and tests will pass.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dominikh/go-tools</title>
    <updated>2022-12-01T01:39:55Z</updated>
    <id>tag:github.com,2022-12-01:/dominikh/go-tools</id>
    <link href="https://github.com/dominikh/go-tools" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Staticcheck - The advanced Go linter&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;&lt;img alt=&#34;Staticcheck logo&#34; src=&#34;https://raw.githubusercontent.com/dominikh/go-tools/master/images/logo.svg?sanitize=true&#34; height=&#34;300&#34;&gt;&lt;br&gt; The advanced Go linter &lt;/h1&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;Staticcheck is a state of the art linter for the &lt;a href=&#34;https://go.dev/&#34;&gt;Go programming language&lt;/a&gt;. Using static analysis, it finds bugs and performance issues, offers simplifications, and enforces style rules.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Financial support by &lt;a href=&#34;http://staticcheck.io/sponsors&#34;&gt;private and corporate sponsors&lt;/a&gt; guarantees the tool&#39;s continued development. Please &lt;a href=&#34;https://github.com/users/dominikh/sponsorship&#34;&gt;become a sponsor&lt;/a&gt; if you or your company rely on Staticcheck.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;You can find extensive documentation on Staticcheck on &lt;a href=&#34;https://staticcheck.io/docs/&#34;&gt;its website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Releases&lt;/h3&gt; &#xA;&lt;p&gt;It is recommended that you run released versions of the tools. These releases can be found as git tags (e.g. &lt;code&gt;2022.1&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The easiest way of installing a release is by using &lt;code&gt;go install&lt;/code&gt;, for example &lt;code&gt;go install honnef.co/go/tools/cmd/staticcheck@2022.1&lt;/code&gt;. Alternatively, we also offer &lt;a href=&#34;https://github.com/dominikh/go-tools/releases&#34;&gt;prebuilt binaries&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can find more information about installation and releases in the &lt;a href=&#34;https://staticcheck.io/docs/getting-started/&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Master&lt;/h3&gt; &#xA;&lt;p&gt;You can also run the master branch instead of a release. Note that while the master branch is usually stable, it may still contain new checks or backwards incompatible changes that break your build. By using the master branch you agree to become a beta tester.&lt;/p&gt; &#xA;&lt;h2&gt;Tools&lt;/h2&gt; &#xA;&lt;p&gt;All of the following tools can be found in the cmd/ directory. Each tool is accompanied by its own README, describing it in more detail.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Tool&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dominikh/go-tools/master/cmd/keyify/&#34;&gt;keyify&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Transforms an unkeyed struct literal into a keyed one.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dominikh/go-tools/master/cmd/staticcheck/&#34;&gt;staticcheck&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Go static analysis, detecting bugs, performance issues, and much more.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dominikh/go-tools/master/cmd/structlayout/&#34;&gt;structlayout&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Displays the layout (field sizes and padding) of structs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dominikh/go-tools/master/cmd/structlayout-optimize&#34;&gt;structlayout-optimize&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Reorders struct fields to minimize the amount of padding.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dominikh/go-tools/master/cmd/structlayout-pretty&#34;&gt;structlayout-pretty&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Formats the output of structlayout with ASCII art.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Libraries&lt;/h2&gt; &#xA;&lt;p&gt;In addition to the aforementioned tools, this repository contains the libraries necessary to implement these tools.&lt;/p&gt; &#xA;&lt;p&gt;Unless otherwise noted, none of these libraries have stable APIs. Their main purpose is to aid the implementation of the tools. You&#39;ll have to expect semiregular backwards-incompatible changes if you decide to use these libraries.&lt;/p&gt; &#xA;&lt;h2&gt;System requirements&lt;/h2&gt; &#xA;&lt;p&gt;Releases support the current and previous version of Go at the time of release. The master branch supports the current version of Go.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hazcod/ransomwhere</title>
    <updated>2022-12-01T01:39:55Z</updated>
    <id>tag:github.com,2022-12-01:/hazcod/ransomwhere</id>
    <link href="https://github.com/hazcod/ransomwhere" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A PoC ransomware sample to test out your ransomware response strategy.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ransomwhere&lt;/h1&gt; &#xA;&lt;p&gt;A Proof of Concept ransomware sample that encrypts your files to test out your ransomware detection &amp;amp; prevention strategies. If no arguments are provided, &lt;code&gt;ransomwhere&lt;/code&gt;will automatically execute the &lt;code&gt;encrypt&lt;/code&gt; mode without deleting the original files.&lt;/p&gt; &#xA;&lt;p&gt;I am not responsible for any damage caused by this software.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# with make and Go installed&#xA;% make build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;% ransomwhere -h&#xA;Usage of ransomwhere:&#xA;  -delete&#xA;        Delete files after encrypting.&#xA;  -log string&#xA;        The log level to use. (default &#34;error&#34;)&#xA;  -mode string&#xA;        Encrypt or decrypt the ransomware files. (default &#34;encrypt&#34;)&#xA;  -path string&#xA;        Path to the directory where to traverse files to ransom. (default &#34;/Users/niels&#34;)&#xA;  -wipe&#xA;        Wipe local snapshots while encrypting.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# straight from source, encrypt in our home directory&#xA;% make FLAGS=&#34;-log=warn -delete=false -mode=encrypt&#34;&#xA;&#xA;# from the binary, encrypt /home/ransom/&#xA;% ./app -log=warn -delete=false -mode=encrypt -path=/home/ransom/&#xA;&#xA;# encrypt, delete original files and wipe backups like a real ransomware (DANGEROUS)&#xA;% ./app -delete=true -wipe=true&#xA;&#xA;# revert the ransom operation and restore any files&#xA;% ./app -mode=decrypt&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>