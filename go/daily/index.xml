<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-08T01:43:38Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tiancai110a/go-rpc</title>
    <updated>2022-07-08T01:43:38Z</updated>
    <id>tag:github.com,2022-07-08:/tiancai110a/go-rpc</id>
    <link href="https://github.com/tiancai110a/go-rpc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;go-rpc&lt;/h1&gt; &#xA;&lt;p&gt;主要参考 &lt;a href=&#34;https://github.com/megaredfan/rpc-demo&#34;&gt;https://github.com/megaredfan/rpc-demo&lt;/a&gt; 实现的微服务框架RPC框架&lt;/p&gt; &#xA;&lt;p&gt;其他的实现阅读：&lt;br&gt; &lt;a href=&#34;https://github.com/smallnest/rpcx&#34;&gt;https://github.com/smallnest/rpcx&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/koding/kite&#34;&gt;https://github.com/koding/kite&lt;/a&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;支持服务治理的相关功能，包括：&lt;br&gt; 超时控制 &lt;br&gt; 服务注册与发现&lt;br&gt; 服务负载均衡&lt;br&gt; 限流和熔断&lt;br&gt; 身份认证&lt;br&gt; 监控和链路追踪&lt;br&gt; 健康检查，包括端到端的心跳以及注册中心对服务实例的检查&lt;br&gt; 暂时没实现idl的方式 &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;系统设计&lt;br&gt; &lt;img src=&#34;http://176.122.170.140/wp-content/uploads/2019/04/169438cf843524b3.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;service 是面向用户的接口，比如客户端和服务端实例的初始化和运行等等&lt;br&gt; client和server表示客户端和服务端的实例，它们负责发出请求和返回响应&lt;br&gt; selector 表示负载均衡，它负责决定具体要向哪个server发出请求 registery 表示注册中心，server在初始化完毕甚至是运行时都要向注册中心注册自身的相关信息，client能从注册中心查找到需要的server&lt;br&gt; codec 表示编解码，也就是将对象和二进制数据互相转换&lt;br&gt; protocol 表示通信协议 &lt;br&gt; transport 表示通讯，它负责具体的网络通讯，将按照protocol组装好的二进制数据通过网络发送出去，并根据protocol指定的方式从网络读取数据&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;过滤器链&lt;br&gt; 采用类似过滤器链一样的方式处理请求和响应，以此来达到对扩展开放，对修改关闭的效果。这熔断降级和限流、身份认证，鉴权，日志，链路追踪等功能在过滤器中实现。&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;消息协议&lt;br&gt; 接下来设计具体的消息协议，所谓消息协议大概就是两台计算机为了互相通信而做的约定。举个例子，TCP协议约定了一个TCP数据包的具体格式，比如前2个byte表示源端口，第3和第4个byte表示目标端口，接下来是序号和确认序号等等。而在我们的RPC框架中，也需要定义自己的协议。一般来说，网络协议都分为head和body部分，head是一些元数据，是协议自身需要的数据，body则是上一层传递来的数据，只需要原封不动的接着传递下去就是了。&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;-------------------------------------------------------------------------------------------------&lt;br&gt; |2byte|1byte |4byte |4byte | header length |(total length - header length - 4byte)|&lt;br&gt; -------------------------------------------------------------------------------------------------&lt;br&gt; |magic|version|total length|header length| header | body |&lt;br&gt; -------------------------------------------------------------------------------------------------&lt;br&gt; 两个byte的magic number开头，这样一来我们就可以快速的识别出非法的请求&lt;br&gt; 一个byte表示协议的版本，目前可以一律设置为0&lt;br&gt; 4个byte表示消息体剩余部分的总长度（total length）&lt;br&gt; 4个byte表示消息头的长度（header length）&lt;br&gt; 消息头（header），其长度根据前面解析出的长度（header length）决定&lt;br&gt; 消息体（body），其长度为前面解析出的总长度减去消息头所占的长度（total length - 4 - header length)&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;三方组件：&lt;br&gt; 日志库：&lt;br&gt; &lt;a href=&#34;https://github.com/golang/glog&#34;&gt;https://github.com/golang/glog&lt;/a&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;序列化库：&lt;br&gt; &lt;a href=&#34;https://github.com/vmihailenco/msgpack&#34;&gt;https://github.com/vmihailenco/msgpack&lt;/a&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;kv客户端&lt;br&gt; &lt;a href=&#34;https://github.com/docker/libkv&#34;&gt;https://github.com/docker/libkv&lt;/a&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;链路跟踪api&lt;br&gt; github.com/opentracing/opentracing-go&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;自增序列号： &lt;a href=&#34;https://github.com/google/uuid&#34;&gt;https://github.com/google/uuid&lt;/a&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;使用方法：&lt;br&gt; ·启动服务，创建客户端：&lt;br&gt; 1，服务端：&lt;br&gt; 配置服务端：每个配置项都可以自定义添加插件，自由选用&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;servertOption := server.Option{&#xA;&#x9;&#x9;ProtocolType:   protocol.Default,&#xA;&#x9;&#x9;SerializeType:  protocol.SerializeTypeMsgpack,&#xA;&#x9;&#x9;CompressType:   protocol.CompressTypeNone,&#xA;&#x9;&#x9;TransportType:  transport.TCPTransport,&#xA;&#x9;&#x9;ShutDownWait:   time.Second * 12,&#xA;&#x9;&#x9;Registry:       r1,&#xA;&#x9;&#x9;RegisterOption: registry.RegisterOption{&#34;my-app&#34;},&#xA;    &#xA;    //基于标签的路由策略&#xA;&#x9;&#x9;Tags:           map[string]string{&#34;idc&#34;: &#34;lf&#34;}, //只允许机房为lf的请求，客户端取到信息会自己进行转移&#xA;&#x9;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;启动服务：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;func StartServer(op *server.Option) {&#xA;&#x9;go func() {&#xA;&#x9;&#x9;s, err := server.NewSGServer(op)&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;glog.Error(&#34;new serializer failed&#34;, err)&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;go s.Serve(&#34;tcp&#34;, &#34;127.0.0.1:8888&#34;, nil)&#xA;&#x9;}()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;·添加服务：&lt;br&gt; 定义服务的结构体：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;type TestService struct {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;添加他的方法：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;func (t TestService) Add(ctx context.Context, req *TestRequest, res *TestResponse) error {&#xA;&#x9;res.Reply = req.A + req.B&#xA;&#x9;return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;同时定义 request和response&lt;br&gt; 的结构&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;type TestRequest struct {&#xA;&#x9;A int //发送的参数&#xA;&#x9;B int&#xA;}&#xA;&#xA;type TestResponse struct {&#xA;&#x9;Reply int //返回的参数&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在sgserver中注册这个服务&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;s.Register(service.TestService{})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;2客户端：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;配置：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;op := &amp;amp;client.DefaultSGOption&#xA;&#x9;op.AppKey = &#34;my-app&#34;&#xA;&#x9;op.RequestTimeout = time.Millisecond * 100&#xA;&#x9;op.DialTimeout = time.Millisecond * 100&#xA;  &#xA;  //心跳、降级&#xA;&#x9;op.HeartbeatInterval = time.Second&#xA;&#x9;op.HeartbeatDegradeThreshold = 5&#xA;&#x9;op.Heartbeat = true&#xA;  &#xA;  &#xA;&#x9;op.SerializeType = protocol.SerializeTypeMsgpack&#xA;&#x9;op.CompressType = protocol.CompressTypeNone&#xA;&#x9;op.TransportType = transport.TCPTransport&#xA;&#x9;op.ProtocolType = protocol.Default&#xA;  &#xA;  //容错&#xA;&#x9;op.FailMode = client.FailRetry&#xA;&#x9;op.Retries = 3&#xA;  &#xA;  //鉴权&#xA;&#x9;op.Auth = &#34;hello01&#34;&#xA;  &#xA;  &#xA;  //熔断&#xA;&#x9;//一秒钟失败20次 就会进入贤者模式.. 因为lastupdate时间在不断更新，熔断后继续调用有可能恢复&#xA;&#x9;op.CircuitBreakerThreshold = 20&#xA;&#x9;op.CircuitBreakerWindow = time.Second&#xA;&#xA;&#x9;//基于标签的路由策略&#xA;&#x9;op.Tagged = true&#xA;&#x9;op.Tags = map[string]string{&#34;idc&#34;: &#34;lf&#34;}&#xA;  r2 := libkv.NewKVRegistry(store.ZK, &#34;my-app&#34;, &#34;/root/lizongrong/service&#34;,&#xA;&#x9;&#x9;[]string{&#34;127.0.0.1:1181&#34;, &#34;127.0.0.1:2181&#34;, &#34;127.0.0.1:3181&#34;}, 1e10, nil)&#xA;&#x9;&#xA;&#x9;op.Registry = r2&#xA;  &#xA;  //限流&#xA;        op.Wrappers = append(op.Wrappers, &amp;amp;client.RateLimitInterceptor{Limit: ratelimit.NewRateLimiter(10, 2)}) //一秒10个，最多有两个排队&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;创建客户端：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#x9;c := client.NewSGClient(*op)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;使用客户端调用：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;c.Call(ctx, &#34;ArithService.Add&#34;, &amp;amp;Testrequest, &amp;amp;Testresponse)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;添加中间件：&lt;br&gt; client接口：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;type Wrapper interface {&#xA;&#x9;WrapCall(option *SGOption, callFunc CallFunc) CallFunc&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;服务端接口：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;type Wrapper interface {&#xA;&#x9;WrapServe(s *SGServer, serveFunc ServeFunc) ServeFunc&#xA;&#x9;WrapHandleRequest(s *SGServer, requestFunc HandleRequestFunc) HandleRequestFunc&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;实现接口，并且在客户端和服务端初始化的时候或者之前加入到option中去：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;s.option.Wrappers = append(s.option.Wrappers, &amp;amp;DefaultServerWrapper{})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果需要扩展接口方法，需要实现把之前的wrapper都添加上扩展的方法，并且在wrapper.go中添加函数原型&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;http网关的使用方法： demo： &lt;a href=&#34;https://github.com/tiancai110a/go-restful/tree/http-demo&#34;&gt;https://github.com/tiancai110a/go-restful/tree/http-demo&lt;/a&gt; 接口仿照的gin，使用方法很像&lt;/p&gt; &#xA;&lt;p&gt;配置：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#x9;servertOption := server.Option{&#xA;&#x9;&#x9;ProtocolType:   protocol.Default,&#xA;&#x9;&#x9;SerializeType:  protocol.SerializeTypeMsgpack,&#xA;&#x9;&#x9;CompressType:   protocol.CompressTypeNone,&#xA;&#x9;&#x9;TransportType:  transport.TCPTransport,&#xA;&#x9;&#x9;ShutDownWait:   time.Second * 12,&#xA;&#x9;&#x9;Registry:       r1,&#xA;&#x9;&#x9;RegisterOption: registry.RegisterOption{&#34;my-app&#34;},&#xA;&#x9;&#x9;Tags:           map[string]string{&#34;idc&#34;: &#34;lf&#34;}, //只允许机房为lf的请求，客户端取到信息会自己进行转移&#xA;&#x9;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;设置路由和中间件&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;func Load(s server.RPCServer) {&#xA;&#x9;// Middlewares.&#xA;&#xA;&#x9;s.Use(middleware.TestMiddleware1)&#xA;&#x9;s.Use(middleware.TestMiddleware2)&#xA;&#x9;s.Use(middleware.TestMiddleware3)&#xA;&#xA;&#x9;// The health check handlers&#xA;&#x9;svcd := s.Group(service.GET, &#34;/view&#34;)&#xA;&#x9;{&#xA;&#x9;&#x9;svcd.Route(&#34;/health&#34;, view.HealthCheck)&#xA;&#x9;&#x9;svcd.Route(&#34;/disk&#34;, view.DiskCheck)&#xA;&#x9;&#x9;svcd.Route(&#34;/cpu&#34;, view.CPUCheck)&#xA;&#x9;&#x9;svcd.Route(&#34;/ram&#34;, view.RAMCheck)&#xA;&#x9;}&#xA;&#xA;&#x9;return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;启动：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;func StartServer(op *server.Option) {&#xA;&#x9;go func() {&#xA;&#x9;&#x9;s, err := server.NewSGServer(op)&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;glog.Error(&#34;new serializer failed&#34;, err)&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;router.Load(s)&#xA;&#x9;&#x9;go s.Serve(&#34;tcp&#34;, &#34;127.0.0.1:8888&#34;, nil)&#xA;&#x9;}()&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;实现：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;网络通信模型：&lt;br&gt; &lt;img src=&#34;http://176.122.170.140/wp-content/uploads/2019/04/20190415192710.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;用户调用方法：&lt;br&gt; 方法的参数必须为三个，而且第一个必须是context.Context类型&lt;br&gt; 第二个是服务名.方法名&lt;br&gt; 后面两个是request和response&lt;br&gt; 方法返回值必须是error类型&lt;br&gt; 客户端通过&#34;Type.Method&#34;的形式来引用服务方法，其中Type是方法实现类的全类名，Method就是方法名&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;服务发现中心：&lt;br&gt; 使用zookeeper，可以自由选用其他 如ETCD，cousul&#xA; &lt;!-- wp:paragraph --&gt;&lt;/p&gt; &#xA;&lt;p&gt; 定时拉取和监听数据 ，推拉结合&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt; 定时拉取服务列表并缓存本地&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;查询时直接返回缓存&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt; 注册时在zk添加节点 注销时在zk删除节点&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt; 监听时并不监听每个服务提供者，而是监听其父级目录，有变更时再统一拉取服务提供者列表&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;注册和注销时需要更改父级目录的内容（lastUpdate）来触发监听&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;使用了libkv的库来做zk的客户端，所以不能使用临时节点自动触发下线，其他注册中心也不支持临时节点，需要客户端做探活&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;开一个heartbeat协程做探活：&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;发送方法名为空的rpc调用请求作为探活，ptorocol里面request类型为探活类型&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;探活不受到降级，鉴权，和标签路由的拦截&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;!-- wp:paragraph --&gt; &#xA;&lt;p&gt;探活的结果会触发降级&lt;/p&gt; &#xA;&lt;!-- /wp:paragraph --&gt; &#xA;&lt;p&gt;负载均衡：&lt;br&gt; 只有随机选择，面对本地缓存的服务列表，从中随机选择一个&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;长连接及网络重连：&lt;br&gt; 为了减少频繁创建和断开网络连接的开销，我们维持了客户端到服务端的长连接，并把创建好的连接（RPCClient对象）用map缓存起来，key就是对应的服务端的标识。客户端在调用前根据负载均衡的结果检索到缓存好的RPCClient然后发起调用。当我们检索不到对应的客户端或者发现缓存的客户端已经失效时，需要重新建立连接（重新创建RPCClient对象）&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;集群容错：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;客户端中配置：&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;type FailMode byte&#xA;const (&#xA;&#x9;FailFast FailMode = iota //快速失败&#xA;&#x9;FailOver //重试其他服务器&#xA;&#x9;FailRetry //重试同一个服务器&#xA;&#x9;FailSafe //忽略失败，直接返回&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;客户端心跳：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;发送方法名为空的rpc调用请求作为探活，ptorocol里面request类型为探活类型&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;探活不能受到降级，鉴权，和标签路由的拦截&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;探活的结果会触发降级&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;降级机制：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;调用里设置fileter，触发降级的时候标记相关服务为降级，filter会过滤掉，建立一个degradwraaper来实现&lt;br&gt; 设置一个计数器&lt;br&gt; 探活成功会将计数器置0，连续失败多次触发降级，如果再次成功，会触发服务标记为非降级正常工作&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;鉴权：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;meta信息中带有标签，不符合规则的标签会被屏蔽，并且发送失败的response，同样使用中间件来完成&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;熔断：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;调用失败的时候触发不再重试 分数量阈值x和时间阈值y，必须在时间y内失败次数够x次。才会触发熔断，每次调用之前在wapper中触发 AllowRequest 判断是否触发熔断，触发的话就禁止请求，同样放到selector里面&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;同时实现了服务端和客户端的，服务端主要用来做集群熔断，待以后实现&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;限流：ratelimiter&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;机制：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;开一个额外的协程，每隔一段时间往里面放一个时间戳作为token，每次判断是否响应的或者是否请求的时候从中取一个，如果已经被取光了就阻塞住等待，协程的大小决定了允许瞬间峰值的大小，客户端和服务端都有实现，选一边就行，同样基于wrapper&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;链路追踪：使用开源的opentracing&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;1，根据请求方法名等信息生成链路信息&lt;br&gt; 2，通过rpc metadata传递追踪信息&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;基于标签的路由策略：&lt;br&gt; 用于流量转移，切断某些rpc或者某些身份的流量&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;跟降级差不多，实现一个filter，放到client中供selector调用&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;并且服务端和客户端在meta中打入自己的标签，不匹配的请求将会被禁止&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;实现http网关：&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;通过http来请求服务而不是通过rpc请求，需要将http请求转换成rpc交给自己运行，收到rpcx的启发，gateway是实现resultful的前提&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;实现方法是 将原先rpc的协议头放到http中，接收到以后再将http头中的内容提取出来，合成rpc包，交给原先的接口&lt;br&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>marcel-dempers/docker-development-youtube-series</title>
    <updated>2022-07-08T01:43:38Z</updated>
    <id>tag:github.com,2022-07-08:/marcel-dempers/docker-development-youtube-series</id>
    <link href="https://github.com/marcel-dempers/docker-development-youtube-series" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Ultimate Engineer Toolbox &lt;img src=&#34;https://www.shareicon.net/data/128x128/2017/04/11/883708_media_512x512.png&#34; alt=&#34;YouTube&#34; width=&#34;5%&#34; height=&#34;5%&#34;&gt; &lt;span&gt;🔨&lt;/span&gt;&lt;span&gt;🔧&lt;/span&gt;&lt;/h1&gt; &#xA;&lt;p&gt;A Collection of tools, hands-on walkthroughs with source code. &lt;br&gt; The Ultimate Swiss Army knife for DevOps, Developers and Platform Engineers&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Steps&lt;/th&gt; &#xA;   &lt;th&gt;Playlist &lt;span&gt;📺&lt;/span&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Source &lt;img alt=&#34;octocat&#34; src=&#34;https://github.githubassets.com/images/icons/emoji/octocat.png?v8&#34;&gt;)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcel-dempers/docker-development-youtube-series/master/kubernetes/README.md&#34;&gt;Learn Kubernetes&lt;/a&gt; &lt;span&gt;❄&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLHq1uqvAteVvUEdqaBeMK2awVThNujwMd&#34; title=&#34;Kubernetes&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/8h4FoWK7tIA/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Kubernetes Guide&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcel-dempers/docker-development-youtube-series/master/kubernetes/readme.md&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Learn about CI/CD tools &lt;span&gt;🐳&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLHq1uqvAteVsSsrnZimHEf7NJ1MlRhQUj&#34; title=&#34;CI/CD&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/myCcJJ_Fk10/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;CI/CD Guide&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Deploy Kubernetes to the cloud &lt;span&gt;⛅&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLHq1uqvAteVsUhzNBkn-rPzXtPNpJu1-k&#34; title=&#34;Cloud K8s&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/3jA9EfkSAUU/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Cloud Guide&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcel-dempers/docker-development-youtube-series/master/kubernetes/cloud/readme.md&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Monitoring Kubernetes &lt;span&gt;🔍&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLHq1uqvAteVuEXCrRkPFWLXRKWNLOVUHn&#34; title=&#34;Cloud K8s&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/5o37CGlNLr8/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Cloud Guide&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcel-dempers/docker-development-youtube-series/master/monitoring/prometheus/kubernetes/readme.md&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Guide to Logging &lt;span&gt;📃&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLHq1uqvAteVvfDxFW50Mdezk0xum-tyHT&#34; title=&#34;Cloud K8s&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/MMVdkzeQ848/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Cloud Guide&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcel-dempers/docker-development-youtube-series/master/monitoring/logging/readme.md&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Guide to ServiceMesh &lt;span&gt;🌐&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLHq1uqvAteVsmxHpGsMjTOROn3i99lzTA&#34; title=&#34;Cloud K8s&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/rVNPnHeGYBE/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Cloud Guide&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcel-dempers/docker-development-youtube-series/master/kubernetes/servicemesh/readme.md&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Docker Development Basics&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Step &lt;span&gt;✔&lt;/span&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Video &lt;span&gt;🎥&lt;/span&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Source Code &lt;img alt=&#34;octocat&#34; src=&#34;https://github.githubassets.com/images/icons/emoji/octocat.png?v8&#34;&gt;)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Working with &lt;code&gt;Dockerfiles&lt;/code&gt; &lt;br&gt;(.NET, Golang, Python, NodeJS)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/wyjNpxLRmLg&#34; title=&#34;Docker 1&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/wyjNpxLRmLg/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Docker 1&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marcel-dempers/docker-development-youtube-series/tree/part1&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Working with code &lt;br&gt;(.NET, Golang, Python, NodeJS)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/EdmKENqnQUw&#34; title=&#34;Docker 1&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/EdmKENqnQUw/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Docker 1&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marcel-dempers/docker-development-youtube-series/tree/part2&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Docker Multistage explained&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/2lQ7WrwpZfI&#34; title=&#34;Docker 1&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/2lQ7WrwpZfI/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Docker 1&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marcel-dempers/docker-development-youtube-series/tree/part3&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Debugging Go in Docker&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/kToyI16IFxs&#34; title=&#34;Docker 1&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/kToyI16IFxs/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Docker 1&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marcel-dempers/docker-development-youtube-series/tree/master/golang&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Debugging .NET in Docker&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/ds2bud0ZYTY&#34; title=&#34;Docker 1&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/ds2bud0ZYTY/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Docker 1&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marcel-dempers/docker-development-youtube-series/tree/part5&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Debugging Python in Docker&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/b78Tg-YmJZI&#34; title=&#34;Docker 1&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/b78Tg-YmJZI/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Docker 1&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marcel-dempers/docker-development-youtube-series/tree/debugging-python&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Debugging NodeJS in Docker&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://youtu.be/ktvgr9VZ4dc&#34; title=&#34;Docker 1&#34;&gt;&lt;img src=&#34;https://i.ytimg.com/vi/ktvgr9VZ4dc/hqdefault.jpg&#34; width=&#34;50%&#34; alt=&#34;Docker 1&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marcel-dempers/docker-development-youtube-series/tree/master/nodejs&#34;&gt;source&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Engineering Toolbox &lt;span&gt;🔨&lt;/span&gt;&lt;span&gt;🔧&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Checkout the toolbox &lt;a href=&#34;https://marceldempers.dev/toolbox&#34;&gt;website&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://marceldempers.dev/toolbox&#34; title=&#34;toolbox 1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/marcel-dempers/docker-development-youtube-series/master/toolbox.png&#34; alt=&#34;toolbox 1&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/go-containerregistry</title>
    <updated>2022-07-08T01:43:38Z</updated>
    <id>tag:github.com,2022-07-08:/google/go-containerregistry</id>
    <link href="https://github.com/google/go-containerregistry" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Go library and CLIs for working with container registries&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;go-containerregistry&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/google/go-containerregistry/actions?query=workflow%3ABuild&#34;&gt;&lt;img src=&#34;https://github.com/google/go-containerregistry/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;GitHub Actions Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/google/go-containerregistry?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/google/go-containerregistry&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/google/go-containerregistry/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;Code Coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;This is a golang library for working with container registries. It&#39;s largely based on the &lt;a href=&#34;https://github.com/google/containerregistry&#34;&gt;Python library of the same name&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following diagram shows the main types that this library handles. &lt;img src=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/images/ociimage.jpeg&#34; alt=&#34;OCI image representation&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;The overarching design philosophy of this library is to define interfaces that present an immutable view of resources (e.g. &lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1#Image&#34;&gt;&lt;code&gt;Image&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1#Layer&#34;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1#ImageIndex&#34;&gt;&lt;code&gt;ImageIndex&lt;/code&gt;&lt;/a&gt;), which can be backed by a variety of medium (e.g. &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/v1/remote/README.md&#34;&gt;registry&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/v1/tarball/README.md&#34;&gt;tarball&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/v1/daemon/README.md&#34;&gt;daemon&lt;/a&gt;, ...).&lt;/p&gt; &#xA;&lt;p&gt;To complement these immutable views, we support functional mutations that produce new immutable views of the resulting resource (e.g. &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/v1/mutate/README.md&#34;&gt;mutate&lt;/a&gt;). The end goal is to provide a set of versatile primitives that can compose to do extraordinarily powerful things efficiently and easily.&lt;/p&gt; &#xA;&lt;p&gt;Both the resource views and mutations may be lazy, eager, memoizing, etc, and most are optimized for common paths based on the tooling we have seen in the wild (e.g. writing new images from disk to the registry as a compressed tarball).&lt;/p&gt; &#xA;&lt;h3&gt;Experiments&lt;/h3&gt; &#xA;&lt;p&gt;Over time, we will add new functionality under experimental environment variables listed here.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Env Var&lt;/th&gt; &#xA;   &lt;th&gt;Value(s)&lt;/th&gt; &#xA;   &lt;th&gt;What is does&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;GGCR_EXPERIMENT_ESTARGZ&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;1&#34;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;When enabled this experiment will direct &lt;code&gt;tarball.LayerFromOpener&lt;/code&gt; to emit &lt;a href=&#34;https://github.com/opencontainers/image-spec/issues/815&#34;&gt;estargz&lt;/a&gt; compatible layers, which enable them to be lazily loaded by an appropriately configured containerd.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;code&gt;v1.Image&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;h4&gt;Sources&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/remote#Image&#34;&gt;&lt;code&gt;remote.Image&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/tarball#Image&#34;&gt;&lt;code&gt;tarball.Image&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/daemon#Image&#34;&gt;&lt;code&gt;daemon.Image&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/layout#Path.Image&#34;&gt;&lt;code&gt;layout.Image&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/random#Image&#34;&gt;&lt;code&gt;random.Image&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Sinks&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/remote#Write&#34;&gt;&lt;code&gt;remote.Write&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/tarball#Write&#34;&gt;&lt;code&gt;tarball.Write&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/daemon#Write&#34;&gt;&lt;code&gt;daemon.Write&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/legacy/tarball#Write&#34;&gt;&lt;code&gt;legacy/tarball.Write&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/layout#Path.AppendImage&#34;&gt;&lt;code&gt;layout.AppendImage&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;v1.ImageIndex&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;h4&gt;Sources&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/remote#Index&#34;&gt;&lt;code&gt;remote.Index&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/random#Index&#34;&gt;&lt;code&gt;random.Index&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/layout#ImageIndexFromPath&#34;&gt;&lt;code&gt;layout.ImageIndexFromPath&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Sinks&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/remote#WriteIndex&#34;&gt;&lt;code&gt;remote.WriteIndex&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/layout#Write&#34;&gt;&lt;code&gt;layout.Write&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;v1.Layer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;h4&gt;Sources&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/remote#Layer&#34;&gt;&lt;code&gt;remote.Layer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/tarball#LayerFromFile&#34;&gt;&lt;code&gt;tarball.LayerFromFile&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/random#Layer&#34;&gt;&lt;code&gt;random.Layer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/stream#Layer&#34;&gt;&lt;code&gt;stream.Layer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Sinks&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/google/go-containerregistry/pkg/v1/remote#WriteLayer&#34;&gt;&lt;code&gt;remote.WriteLayer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;mutate&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The simplest use for these libraries is to read from one source and write to another.&lt;/p&gt; &#xA;&lt;p&gt;For example,&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;crane pull&lt;/code&gt; is &lt;code&gt;remote.Image -&amp;gt; tarball.Write&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;crane push&lt;/code&gt; is &lt;code&gt;tarball.Image -&amp;gt; remote.Write&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;crane cp&lt;/code&gt; is &lt;code&gt;remote.Image -&amp;gt; remote.Write&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However, often you actually want to &lt;em&gt;change something&lt;/em&gt; about an image. This is the purpose of the &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/v1/mutate&#34;&gt;&lt;code&gt;mutate&lt;/code&gt;&lt;/a&gt; package, which exposes some commonly useful things to change about an image.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;partial&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re trying to use this library with a different source or sink than it already supports, it can be somewhat cumbersome. The &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Layer&lt;/code&gt; interfaces are pretty wide, with a lot of redundant information. This is somewhat by design, because we want to expose this information as efficiently as possible where we can, but again it is a pain to implement yourself.&lt;/p&gt; &#xA;&lt;p&gt;The purpose of the &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/v1/partial&#34;&gt;&lt;code&gt;partial&lt;/code&gt;&lt;/a&gt; package is to make implementing a &lt;code&gt;v1.Image&lt;/code&gt; much easier, by filling in all the derived accessors for you if you implement a minimal subset of &lt;code&gt;v1.Image&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;transport&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You might think our abstractions are bad and you just want to authenticate and send requests to a registry.&lt;/p&gt; &#xA;&lt;p&gt;This is the purpose of the &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/v1/remote/transport&#34;&gt;&lt;code&gt;transport&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/authn&#34;&gt;&lt;code&gt;authn&lt;/code&gt;&lt;/a&gt; packages.&lt;/p&gt; &#xA;&lt;h2&gt;Tools&lt;/h2&gt; &#xA;&lt;p&gt;This repo hosts some tools built on top of the library.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;crane&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/cmd/crane/README.md&#34;&gt;&lt;code&gt;crane&lt;/code&gt;&lt;/a&gt; is a tool for interacting with remote images and registries.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;gcrane&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/cmd/gcrane/README.md&#34;&gt;&lt;code&gt;gcrane&lt;/code&gt;&lt;/a&gt; is a GCR-specific variant of &lt;code&gt;crane&lt;/code&gt; that has richer output for the &lt;code&gt;ls&lt;/code&gt; subcommand and some basic garbage collection support.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;krane&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/cmd/krane/README.md&#34;&gt;&lt;code&gt;krane&lt;/code&gt;&lt;/a&gt; is a drop-in replacement for &lt;code&gt;crane&lt;/code&gt; that supports common Kubernetes-based workload identity mechanisms using &lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/#k8schain&#34;&gt;&lt;code&gt;k8schain&lt;/code&gt;&lt;/a&gt; as a fallback to traditional authentication mechanisms.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;k8schain&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/go-containerregistry/main/pkg/authn/k8schain/README.md&#34;&gt;&lt;code&gt;k8schain&lt;/code&gt;&lt;/a&gt; implements the authentication semantics used by kubelets in a way that is easily consumable by this library.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;k8schain&lt;/code&gt; is not a standalone tool, but it is linked here for visibility.&lt;/p&gt; &#xA;&lt;h3&gt;Emeritus: &lt;a href=&#34;https://github.com/google/ko&#34;&gt;&lt;code&gt;ko&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This tool was originally developed in this repo but has since been moved to its own repo.&lt;/p&gt;</summary>
  </entry>
</feed>