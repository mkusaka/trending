<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-21T01:29:09Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>skx/cpmulator</title>
    <updated>2024-05-21T01:29:09Z</updated>
    <id>tag:github.com,2024-05-21:/skx/cpmulator</id>
    <link href="https://github.com/skx/cpmulator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Golang CP/M emulator for playing zork, lighthouse-of-doom, etc&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;cpmulator - A CP/M emulator written in golang&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains a CP/M emulator, with integrated CCP, which is designed to run CP/M binaries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The project was initially created to run &lt;a href=&#34;https://github.com/skx/lighthouse-of-doom/&#34;&gt;my text-based adventure game&lt;/a&gt;, which I wrote a few years ago, to amuse my child. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;That was written in Z80 assembly language and initially targeted CP/M, although it was later ported to the ZX Spectrum.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Over time this project has become more complete, and more complex, and I&#39;ve implemented enough functionity to run simple binaries and many of the well-known CP/M programs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Aztec C-Compiler. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You can edit and compile C code within the emulator, then run it!&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Borland&#39;s Turbo Pascal &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You can edit and compile Pascal code within the emulator, then run it!&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Many early Infocom games: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Zork 1, 2, &amp;amp; 3.&lt;/li&gt; &#xA;   &lt;li&gt;Planetfall.&lt;/li&gt; &#xA;   &lt;li&gt;etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Microsoft BASIC&lt;/li&gt; &#xA; &lt;li&gt;Wordstar&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The biggest caveat is that I&#39;ve not implemented any notion of disk-based access. This means that, for example, opening, reading/writing, and closing files is absolutely fine, but any API call that refers to tracks, sectors, or disks will fail.&lt;/p&gt; &#xA;&lt;p&gt;A companion repository contains a collection of vintage CP/M software you can use with this, or any other, emulator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skx/cpm-dist&#34;&gt;https://github.com/skx/cpm-dist&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation &amp;amp; Versioning&lt;/h1&gt; &#xA;&lt;p&gt;This emulator is written using golang, so if you have a working golang toolchain you can install in the standard way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install github.com/skx/cpmulator@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you were to clone this repository to your local system you could then build and install by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go install .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If neither of these options are suitable you may download the latest binary from &lt;a href=&#34;https://github.com/skx/cpmulator/releases&#34;&gt;the release page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Releases will be made as/when features seem to justify it, but it should be noted that I consider the CLI tool, and the emulator itself, the &#34;product&#34;. That means that the internal APIs will change around as/when necessary.&lt;/p&gt; &#xA;&lt;p&gt;If you wish to import any of the internal APIs you do so at the risk of changes happening at any time - although so far these have been minor I&#39;m not averse to changing parameters to internal packages, or adding/renaming/removing methods as necessary without any regard for external users.&lt;/p&gt; &#xA;&lt;h1&gt;Quick Start&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Build/Install this application.&lt;/li&gt; &#xA; &lt;li&gt;Clone the associated repository of binaries &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;git clone https://github.com/skx/cpm-dist.git /tmp/cpm-dist&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Launch the emulator, pointing at the binaries &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;cpmulator -cd /tmp/cpm-dist -directories&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Start something: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&#34;B:&#34;, then &#34;MBASIC&#34; - to run BASIC. (&#34;SYSTEM&#34; to exit)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;G:&#34;, then &#34;ZORK1&#34; - to play zork1.&lt;/li&gt; &#xA;   &lt;li&gt;&#34;P:&#34;, then &#34;TURBO&#34; - to run turbo pascal.&lt;/li&gt; &#xA;   &lt;li&gt;&#34;E:&#34;, then &#34;WS&#34; - to run worstar.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Portability&lt;/h1&gt; &#xA;&lt;p&gt;The CP/M input handlers need to disable echoing when reading (single) characters from STDIN. There isn&#39;t a simple and portable solution for this in golang - so I&#39;ve resorted to the naive approach of executing &lt;code&gt;stty&lt;/code&gt; when necessary.&lt;/p&gt; &#xA;&lt;p&gt;This means the code in this repository isn&#39;t 100% portable; it will work on Linux and MacOS hosts, but not Windows.&lt;/p&gt; &#xA;&lt;p&gt;There &lt;em&gt;is&lt;/em&gt; code to set a console into RAW mode, and disable echoing input, for example you can &lt;a href=&#34;https://cs.opensource.google/go/x/term/+/refs/tags/v0.20.0:term_unix.go&#34;&gt;consider the code in the readPassword function&lt;/a&gt; in &lt;code&gt;x/term&lt;/code&gt;. Unfortunately the facilities there are only sufficient for reading a &lt;em&gt;line&lt;/em&gt;, not a &lt;em&gt;character&lt;/em&gt; which means we&#39;ll need to essentially copy and paste their implementations inline to take advantage of this, and restore portability.&lt;/p&gt; &#xA;&lt;p&gt;This is tracked in #65.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;If you launch &lt;code&gt;cpmulator&lt;/code&gt; with no arguments then one of the integrated CCPs (&#34;console command processor&#34;) will be launched, dropping you into a familiar shell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cpmulator&#xA;A&amp;gt;dir&#xA;&#xA;A: LICENSE .    | README  .MD  | CPMULATO.    | GO      .MOD&#xA;A: GO      .SUM | MAIN    .GO  | RET     .COM&#xA;&#xA;A&amp;gt;TYPE LICENSE&#xA;The MIT License (MIT)&#xA;..&#xA;A&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can terminate the CCP by pressing Ctrl-C, or typing &lt;code&gt;EXIT&lt;/code&gt;. The following built-in commands are available:&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Show the built-in commands of the default CCP:&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;CLS&lt;/code&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;Clear the screen.&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;DIR&lt;/code&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;List files, by default this uses &#34;&lt;code&gt;*.*&lt;/code&gt;&#34;. &#xA;     &lt;ul&gt; &#xA;      &lt;li&gt;Try &#34;&lt;code&gt;DIR *.COM&lt;/code&gt;&#34; if you want to see something more specific, for example.&lt;/li&gt; &#xA;     &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;EXIT&lt;/code&gt; / &lt;code&gt;HALT&lt;/code&gt; / &lt;code&gt;QUIT&lt;/code&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;Terminate the CCP.&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;ERA&lt;/code&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;Erase the named files, wildcards are permitted.&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;TYPE&lt;/code&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;View the contents of the named file - wildcards are not permitted.&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;REN&lt;/code&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;Rename files, so &#34;&lt;code&gt;REN NEW=OLD&lt;/code&gt;&#34; - again note that wildcards are not permitted, nor is cross-drive renaming.&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;There are currently a pair of CCP implementations included within the emulator, and they can be selected via the &lt;code&gt;-ccp&lt;/code&gt; command-line flag:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;ccp&#34; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This is the default, but you can choose it explicitly via &lt;code&gt;cpmulator -ccp=ccp ..&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;The original/default one, from Digital Research&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&#34;ccpz&#34; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Launch this via &lt;code&gt;cpmulate -ccp=ccpz ..&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;An enhanced one with extra built-in commands.&lt;/li&gt; &#xA;   &lt;li&gt;Notably &#34;GET 0100 FOO.COM&#34; will load a binary into RAM, at address 0x100. Then &#34;JMP 0100&#34; will launch it.&lt;/li&gt; &#xA;   &lt;li&gt;The prompt changes to show user-number, for example if you run &#34;USER 3&#34;.&lt;/li&gt; &#xA;   &lt;li&gt;If a command isn&#39;t found in the current drive A: will be searched instead, which is handy.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also launch a binary directly by specifying it&#39;s path upon the command-line, followed by any optional arguments that the binary accepts or requires:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cpmulator /path/to/binary [optional-args]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other options are shown in the output of &lt;code&gt;cpmulator -help&lt;/code&gt;, but in brief:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-cd /path/to/directory&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Change to the given directory before running.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-directories&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Use directories on the host for drive-contents, discussed later in this document.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-log-path /path/to/file&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Output debug-logs to the given file, creating it if necessary.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-prn-path /path/to/file&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;All output which CP/M sends to the &#34;printer&#34; will be written to the given file.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Sample Binaries&lt;/h1&gt; &#xA;&lt;p&gt;I&#39;ve placed some games within the &lt;code&gt;dist/&lt;/code&gt; directory, to make it easier for you to get started:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cd dist/&#xA;$ cpmulator ZORK1.COM&#xA;ZORK I: The Great Underground Empire&#xA;Copyright (c) 1981, 1982, 1983 Infocom, Inc. All rights&#xA;reserved.&#xA;ZORK is a registered trademark of Infocom, Inc.&#xA;Revision 88 / Serial number 840726&#xA;&#xA;West of House&#xA;You are standing in an open field west of a white house, with&#xA;a boarded front door.&#xA;There is a small mailbox here.&#xA;&#xA;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A companion repository contains a larger collection of vintage CP/M software you can use with this emulator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skx/cpm-dist&#34;&gt;https://github.com/skx/cpm-dist&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Drives vs. Directories&lt;/h1&gt; &#xA;&lt;p&gt;By default when you launch &lt;code&gt;cpmulator&lt;/code&gt; with no arguments you&#39;ll be presented with the CCP interface, with A: as the current drive. In this mode A:, B:, C:, and all other drives, will refer to the current-working directory where you launched the emulator from (i.e. they have the same view of files). This is perhaps the most practical way to get started, but it means that files are repeated across drives:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;i.e. &#34;&lt;code&gt;A:FOO&lt;/code&gt;&#34; is the same as &#34;&lt;code&gt;B:FOO&lt;/code&gt;&#34;, and if you delete &#34;&lt;code&gt;C:FOO&lt;/code&gt;&#34; you&#39;ll find it has vanished from all drives. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;In short &#34;&lt;code&gt;FOO&lt;/code&gt;&#34; will exist on drives &lt;code&gt;A:&lt;/code&gt; all the way through to &lt;code&gt;P:&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you prefer you may configure drives to be distinct, each drive referring to a distinct sub-directory upon the host system (i.e. the machine you&#39;re running on):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir A/  ; touch A/LS.COM ; touch A/FOO.COM&#xA;$ mkdir B/  ; touch B/DU.COM ; touch B/BAR.COM&#xA;$ mkdir G/  ; touch G/ME.COM ; touch G/BAZ.COM&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now if you launch the emulator you&#39;ll see only the files which &lt;em&gt;should&lt;/em&gt; be visible on the appropriate drive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cpmulator -directories&#xA;A&amp;gt;DIR A:&#xA;A: FOO     .COM | LS      .COM&#xA;&#xA;A&amp;gt;DIR B:&#xA;B: BAR     .COM | DU      .COM&#xA;&#xA;A&amp;gt;DIR G:&#xA;G: BAZ     .COM | ME      .COM&#xA;&#xA;A&amp;gt;DIR E:&#xA;No file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A companion repository contains a larger collection of vintage CP/M software you can use with this emulator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skx/cpm-dist&#34;&gt;https://github.com/skx/cpm-dist&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is arranged into subdirectories, on the assumption you&#39;ll run with the &lt;code&gt;-directories&lt;/code&gt; flag, and the drives are thus used as a means of organization. For example you might want to look at games, on the &lt;code&gt;G:&lt;/code&gt; drive, or the BASIC interpreters on the &lt;code&gt;B:&lt;/code&gt; drive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;frodo ~/Repos/github.com/skx/cpm-dist $ cpmulator  -directories&#xA;A&amp;gt;g:&#xA;G&amp;gt;dir *.com&#xA;G: HITCH   .COM | LEATHER .COM | LIHOUSE .COM | PLANET  .COM&#xA;G: ZORK1   .COM | ZORK2   .COM | ZORK3   .COM&#xA;&#xA;G&amp;gt;dir b:*.com&#xA;B: MBASIC  .COM | OBASIC  .COM | TBASIC  .COM&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that it isn&#39;t currently possibly to point different drives to arbitrary paths on your computer, but that might be considered if you have a use-case for it.&lt;/p&gt; &#xA;&lt;h1&gt;Implemented Syscalls&lt;/h1&gt; &#xA;&lt;p&gt;You can see the list of implemented syscalls, along with a mention of how complete their implementation is, by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cpmulator -syscalls&#xA;BDOS&#xA;&#x9;00 P_TERMCPM&#xA;&#x9;01 C_READ&#xA;&#x9;02 C_WRITE&#xA;&#x9;03 A_READ&#xA;..snip..&#xA;BIOS&#xA;&#x9;00  BOOT&#xA;&#x9;01  WBOOT&#xA;..snip..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Items marked &#34;FAKE&#34; return &#34;appropriate&#34; values, rather than real values. Or are otherwise incomplete.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The only functions with significantly different behaviour are those which should send a single character to the printer (BDOS &#34;L_WRITE&#34; / BIOS &#34;LIST&#34;), they actually send their output to the file &lt;code&gt;print.log&lt;/code&gt; in the current-directory, creating it if necessary. (The path may be altered via the &lt;code&gt;-prn-path&lt;/code&gt; command-line argument.)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The implementation of the syscalls is the core of our emulator, and they can be found here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/skx/cpmulator/master/cpm/cpm_bdos.go&#34;&gt;cpm/cpm_bdos.go&lt;/a&gt; - BDOS functions. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.seasip.info/Cpm/bdos.html&#34;&gt;https://www.seasip.info/Cpm/bdos.html&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/skx/cpmulator/master/cpm/cpm_bios.go&#34;&gt;cpm/cpm_bios.go&lt;/a&gt; - BIOS functions. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.seasip.info/Cpm/bios.html&#34;&gt;https://www.seasip.info/Cpm/bios.html&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Debugging Failures &amp;amp; Tweaking Behaviour&lt;/h1&gt; &#xA;&lt;p&gt;When an unimplemented BIOS call is attempted the program it will abort with a fatal error, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./cpmulator FOO.COM&#xA;{&#34;time&#34;:&#34;2024-04-14T15:39:34.560609302+03:00&#34;,&#xA;  &#34;level&#34;:&#34;ERROR&#34;,&#xA;  &#34;msg&#34;:&#34;Unimplemented syscall&#34;,&#xA;  &#34;syscall&#34;:255,&#xA;  &#34;syscallHex&#34;:&#34;0xFF&#34;}&#xA;Error running FOO.COM: UNIMPLEMENTED&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If things are &lt;em&gt;mostly&lt;/em&gt; working, but something is not quite producing the correct result then we have some notes on debugging:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/skx/cpmulator/master/DEBUGGING.md&#34;&gt;DEBUGGING.md&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following environmental variables influence runtime behaviour:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Variable&lt;/th&gt; &#xA;   &lt;th&gt;Purpose&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SIMPLE_CHAR&lt;/td&gt; &#xA;   &lt;td&gt;Avoid the attempted VT52 output conversion.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For reference the memory map of our CP/M looks like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;0x0000 - Start of RAM&lt;/li&gt; &#xA; &lt;li&gt;0xDE00 - The CCP&lt;/li&gt; &#xA; &lt;li&gt;0xF000 - The BDOS (fake)&lt;/li&gt; &#xA; &lt;li&gt;0xFE00 - The BIOS (fake)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Sample Programs&lt;/h1&gt; &#xA;&lt;p&gt;You&#39;ll see some Z80 assembly programs beneath &lt;a href=&#34;https://raw.githubusercontent.com/skx/cpmulator/master/samples/&#34;&gt;samples&lt;/a&gt; which are used to check my understanding. If you have the &lt;code&gt;pasmo&lt;/code&gt; compiler enabled you can build them all by running &#34;make&#34;, in case you don&#39;t I&#39;ve also committed the generated binaries.&lt;/p&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Much of the functionality of this repository comes from the &lt;a href=&#34;https://github.com/koron-go/z80&#34;&gt;excellent Z80 emulator library&lt;/a&gt; it is using, written by &lt;a href=&#34;https://github.com/koron-go&#34;&gt;@koron-go&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The CCP comes from &lt;a href=&#34;https://github.com/skx/z80-playground-cpm-fat/&#34;&gt;my fork&lt;/a&gt; of the original &lt;a href=&#34;https://github.com/z80playground/cpm-fat/&#34;&gt;cpm-fat&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;However this is largely unchanged from the &lt;a href=&#34;http://www.cpm.z80.de/source.html&#34;&gt;original CCP&lt;/a&gt; from Digital Research, although I did add the &lt;code&gt;CLS&lt;/code&gt;, &lt;code&gt;EXIT&lt;/code&gt;, &lt;code&gt;HALT&lt;/code&gt; &amp;amp; &lt;code&gt;QUIT&lt;/code&gt; built-in commands.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When I was uncertain of how to implement a specific system call the following two emulators were also useful:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ivanizag/iz-cpm&#34;&gt;https://github.com/ivanizag/iz-cpm&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Portable CP/M emulation to run CP/M 2.2 binaries for Z80. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Has a handy &#34;download&#34; script to fetch some CP/M binaries, including BASIC, Turbo Pascal, and WordStar.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Written in Rust.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jhallen/cpm&#34;&gt;https://github.com/jhallen/cpm&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Run CP/M commands in Linux/Cygwin with this Z80 / BDOS / ADM-3A emulator.&lt;/li&gt; &#xA;   &lt;li&gt;Written in C.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;References&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.gaby.de/cpm/manuals/archive/cpm22htm/&#34;&gt;Digital Research - CP/M Operating System Manual&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Particularly the syscall reference in &lt;a href=&#34;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm&#34;&gt;Section 5: CP/M 2 System Interface&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Sample code &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Laci1953/RC2014-CPM/tree/main&#34;&gt;https://github.com/Laci1953/RC2014-CPM/tree/main&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Release Checklist&lt;/h1&gt; &#xA;&lt;p&gt;The testing that I should do before a release:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Play lighthouse of doom to completion, either victory or death.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Compile a program with ASM &amp;amp; LOAD. Confirm it runs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Compile HELLO.C and ECHO.C with Aztec C Compiler. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Confirm the generated binaries run.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Run BBC Basic, and play a game. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test &#34;SAVE&#34; and &#34;LOAD&#34; commands.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test saving tokenized AND raw versions. (i.e &lt;code&gt;SAVE &#34;FOO&#34;&lt;/code&gt;, and &lt;code&gt;SAVE &#34;FOO&#34;, A&lt;/code&gt;.)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Compile a program with Turbo Pascal. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Confirm the generated binary runs.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Play Zork1 for a few turns. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test SAVE and RESTORE commands, and confirm they work.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test BE.COM&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test STAT.COM&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test some built-in shell-commands; ERA TYPE, and EXIT.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test &lt;code&gt;samples/INTEST.COM&lt;/code&gt; &lt;code&gt;samples/READ.COM&lt;/code&gt;, &lt;code&gt;samples/WRITE.COM&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Bugs?&lt;/h2&gt; &#xA;&lt;p&gt;Let me know by filing an issue. If your program is &#34;real&#34; then it is highly likely it will try to invoke an unimplemented BIOS function.&lt;/p&gt; &#xA;&lt;p&gt;Known issues:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Wordstar is broken. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Don&#39;t care, because I have no strong attachment to it.&lt;/li&gt; &#xA;   &lt;li&gt;Seems to be related to console I/O via &#34;&lt;code&gt;RST xx&lt;/code&gt;&#34; instructions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;SUBMIT.COM doesn&#39;t work. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;I suspect at least part of this is CCP-related.&lt;/li&gt; &#xA;   &lt;li&gt;It can &lt;em&gt;print&lt;/em&gt; the last record of a file, but not execute it.&lt;/li&gt; &#xA;   &lt;li&gt;I think it also doesn&#39;t work in reverse like it is supposed to.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Steve&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NibiruChain/nibiru</title>
    <updated>2024-05-21T01:29:09Z</updated>
    <id>tag:github.com,2024-05-21:/NibiruChain/nibiru</id>
    <link href="https://github.com/NibiruChain/nibiru" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nibiru Chain: The breakthrough smart contract platform ushering in the next era of money. Nibiru powers an ecosystem of dApps including perps, RWAs, and more.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nibiru Chain&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/NibiruChain/nibiru&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/NibiruChain/nibiru.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/NibiruChain/nibiru/actions/workflows/golangci-lint.yml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/NibiruChain/nibiru/actions/workflows/golangci-lint.yml/badge.svg?query=branch%3Amain&#34; alt=&#34;Nibiru Test workflow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/NibiruChain/nibiru/actions/workflows/goreleaser.yml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/NibiruChain/nibiru/actions/workflows/goreleaser.yml/badge.svg?query=branch%3Amain&#34; alt=&#34;Nibiru Test workflow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/NibiruChain/nibiru/raw/main/LICENSE.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-blue.svg?sanitize=true&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/nibirufi&#34;&gt;&lt;img src=&#34;https://dcbadge.vercel.app/api/server/nibirufi?style=flat&#34; alt=&#34;Discord Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Nibiru Chain&lt;/strong&gt; is a breakthrough Layer 1 blockchain and smart contract ecosystem providing superior throughput, improved security, and a high-performance EVM execution layer. Nibiru aims to be the most developer-friendly and user-friendly smart contract ecosystem, leading the charge toward mainstream Web3 adoption by innovating at each layer of the stack: dApp development, scalable blockchain data indexing, consensus optimizations, a comprehensive developer toolkit, and composability across multiple VMs.&lt;/p&gt; &#xA;&lt;h2&gt;⚙️ — Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nibiru.fi/docs/&#34;&gt;Docs | Nibiru Chain&lt;/a&gt;: Conceptual and technical documentation can be found here.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/NibiruChain/nibiru&#34;&gt;Complete Golang reference docs&lt;/a&gt;: (&lt;code&gt;pkg.go.dev&lt;/code&gt;) For the blockchain implementation .&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nibiru.fi/docs/dev/x/&#34;&gt;Nibiru Modules&lt;/a&gt;: Module-specific documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;💬 — Community&lt;/h2&gt; &#xA;&lt;p&gt;If you have questions or concerns, feel free to connect with a developer or community member in the &lt;a href=&#34;https://discord.gg/nibirufi&#34;&gt;Nibiru Discord&lt;/a&gt;. We also have active communities on &lt;a href=&#34;https://twitter.com/NibiruChain&#34;&gt;Twitter&lt;/a&gt; and &lt;a href=&#34;https://t.me/nibiruchain&#34;&gt;Telegram&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p style=&#34;display: flex; gap: 24px; justify-content: center; text-align:center&#34;&gt; &lt;a href=&#34;https://discord.gg/nibiruchain&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Discord-7289DA?&amp;amp;logo=discord&amp;amp;logoColor=white&#34; alt=&#34;Discord&#34; height=&#34;22&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/NibiruChain&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Twitter-1DA1F2?&amp;amp;logo=twitter&amp;amp;logoColor=white&#34; alt=&#34;Tweet&#34; height=&#34;22&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/nibiruchain&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Telegram-2CA5E0?&amp;amp;logo=telegram&amp;amp;logoColor=white&#34; alt=&#34;Telegram&#34; height=&#34;22&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;🧱 — Components of Nibiru&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Module&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://nibiru.fi/docs/wasm/&#34;&gt;Wasm&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implements the execution environment for WebAssembly (WASM) smart contracts. CosmWasm smart contracts are Rust-based, Wasm smart contracts built for enhanced security, performance, and interoperability. See our &lt;a href=&#34;https://github.com/NibiruChain/cw-nibiru/tree/main&#34;&gt;CosmWasm sandbox monorepo (cw-nibiru)&lt;/a&gt; for the protocol&#39;s core smart contracts.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/NibiruChain/nibiru/tree/main/x/evm&#34;&gt;EVM&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implements Nibiru EVM, which manages an Ethereum Virtual Machine (EVM) state database and enables the execution of Ethereum smart contracts. Nibiru EVM is an extension of &#34;&lt;a href=&#34;https://github.com/ethereum/go-ethereum&#34;&gt;geth&lt;/a&gt;&#34; along with &#34;web3&#34; and &#34;eth&#34; JSON-RPC methods.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://nibiru.fi/docs/dev/x/nibiru-chain/devgas.html&#34;&gt;Devgas&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The &lt;code&gt;devgas&lt;/code&gt; module of Nibiru Chain shares contract execution fees with smart contract developers. This aims to increase the adoption of Nibiru by offering CosmWasm smart contract developers a direct source of income based on usage.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/NibiruChain/nibiru/tree/main/x/epochs&#34;&gt;Epochs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The &lt;code&gt;epochs&lt;/code&gt; module allows other modules to set hooks to be called to execute code automatically on a period basis. For example, &#34;once a week, starting at UTC-time = x&#34;. &lt;code&gt;epochs&lt;/code&gt; creates a generalized epoch interface.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/NibiruChain/nibiru/tree/main/x/inflation&#34;&gt;Inflation&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implements the &lt;a href=&#34;https://nibiru.fi/docs/learn/tokenomics.html&#34;&gt;tokenomics&lt;/a&gt; for Nibiru.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/NibiruChain/nibiru/tree/main/x/oracle&#34;&gt;Oracle&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Nibiru accurately prices assets using a native, system of decentralized oracles, and communicates with other Cosmos layer-1 chains using the Inter-Blockchain Communication (IBC) protocol. Nibi-Oracle handles the voting process for validators that act as oracles by updating data feeds.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/NibiruChain/nibiru/tree/main/x/common&#34;&gt;Common&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Helper and utility functions to be utilized by other &lt;code&gt;x/&lt;/code&gt; modules.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Nibiru is built with the &lt;a href=&#34;https://github.com/cosmos/cosmos-sdk&#34;&gt;Cosmos-SDK&lt;/a&gt; on &lt;a href=&#34;https://tendermint.com/core/&#34;&gt;Tendermint Core&lt;/a&gt; consensus and communicates with other blockchain chains using the &lt;a href=&#34;https://github.com/cosmos/ibc&#34;&gt;Inter-Blockchain Communication (IBC)&lt;/a&gt; protocol.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;⛓️ — Building: &lt;code&gt;make&lt;/code&gt; commands&lt;/h2&gt; &#xA;&lt;p&gt;Installation instructions for the &lt;code&gt;nibid&lt;/code&gt; binary can be found in &lt;a href=&#34;https://raw.githubusercontent.com/NibiruChain/nibiru/main/INSTALL.md&#34;&gt;INSTALL.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Recommended minimum specs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2CPU, 4GB RAM, 100GB SSD&lt;/li&gt; &#xA; &lt;li&gt;Unix system: MacOS or Ubuntu 18+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Nibid CLI&lt;/h3&gt; &#xA;&lt;p&gt;To simply access the &lt;code&gt;nibid&lt;/code&gt; CLI, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Usage instructions for the &lt;code&gt;nibid&lt;/code&gt; CLI are available at &lt;a href=&#34;https://docs.nibiru.fi/dev/cli/&#34;&gt;docs.nibiru.fi/dev/cli&lt;/a&gt; and the &lt;a href=&#34;https://docs.nibiru.fi/dev/x/&#34;&gt;Nibiru Module Reference&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Running a Local Node&lt;/h3&gt; &#xA;&lt;p&gt;On a fresh clone of the repo, simply run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make localnet&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and open another terminal.&lt;/p&gt; &#xA;&lt;h3&gt;Generate the protobufs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make proto-gen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Linter&lt;/h3&gt; &#xA;&lt;p&gt;We use the &lt;a href=&#34;https://golangci-lint.run/&#34;&gt;golangci-lint&lt;/a&gt; linter. Install it and run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;golangci-lint run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;at the root directory. You can also install the VSCode or Goland IDE plugins.&lt;/p&gt; &#xA;&lt;h3&gt;Multiple Nodes&lt;/h3&gt; &#xA;&lt;p&gt;Run the following commands to set up a local network of Docker containers running the chain.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make build-docker-nibidnode&#xA;&#xA;make localnet-start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Unless a file notes otherwise, it will fall under the &lt;a href=&#34;https://raw.githubusercontent.com/NibiruChain/nibiru/main/LICENSE.md&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;!--&#xA;[![Twitter Follow](https://img.shields.io/twitter/follow/nibiru_platform.svg?label=Follow&amp;style=social)][social-twitter]&#xA;&#xA;[![version](https://img.shields.io/github/tag/nibiru-labs/nibiru.svg)](https://github.com/NibiruChain/nibiru/releases/latest)&#xA;&#xA;[![Go Report Card](https://goreportcard.com/badge/github.com/NibiruChain/nibiru)](https://goreportcard.com/report/github.com/NibiruChain/nibiru)&#xA;&#xA;[![API Reference](https://godoc.org/github.com/NibiruChain/nibiru?status.svg)](https://godoc.org/github.com/NibiruChain/nibiru)&#xA;&#xA;[![Discord Chat](https://img.shields.io/discord/704389840614981673.svg)][social-discord]&#xA;--&gt;</summary>
  </entry>
</feed>