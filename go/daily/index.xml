<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-23T01:36:40Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kubernetes-sigs/descheduler</title>
    <updated>2023-06-23T01:36:40Z</updated>
    <id>tag:github.com,2023-06-23:/kubernetes-sigs/descheduler</id>
    <link href="https://github.com/kubernetes-sigs/descheduler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Descheduler for Kubernetes&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://goreportcard.com/report/sigs.k8s.io/descheduler&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/sigs.k8s.io/descheduler&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/kubernetes-sigs/descheduler/workflows/Release%20Charts/badge.svg?sanitize=true&#34; alt=&#34;Release Charts&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;left&#34;&gt; ↖️ Click at the [bullet list icon] at the top left corner of the Readme visualization for the github generated table of contents. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/assets/logo/descheduler-stacked-color.png&#34; width=&#34;40%&#34; align=&#34;center&#34; alt=&#34;descheduler&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;Descheduler for Kubernetes&lt;/h1&gt; &#xA;&lt;p&gt;Scheduling in Kubernetes is the process of binding pending pods to nodes, and is performed by a component of Kubernetes called kube-scheduler. The scheduler&#39;s decisions, whether or where a pod can or can not be scheduled, are guided by its configurable policy which comprises of set of rules, called predicates and priorities. The scheduler&#39;s decisions are influenced by its view of a Kubernetes cluster at that point of time when a new pod appears for scheduling. As Kubernetes clusters are very dynamic and their state changes over time, there may be desire to move already running pods to some other nodes for various reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Some nodes are under or over utilized.&lt;/li&gt; &#xA; &lt;li&gt;The original scheduling decision does not hold true any more, as taints or labels are added to or removed from nodes, pod/node affinity requirements are not satisfied any more.&lt;/li&gt; &#xA; &lt;li&gt;Some nodes failed and their pods moved to other nodes.&lt;/li&gt; &#xA; &lt;li&gt;New nodes are added to clusters.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Consequently, there might be several pods scheduled on less desired nodes in a cluster. Descheduler, based on its policy, finds pods that can be moved and evicts them. Please note, in current implementation, descheduler does not schedule replacement of evicted pods but relies on the default scheduler for that.&lt;/p&gt; &#xA;&lt;h2&gt;⚠️ Documentation Versions by Release&lt;/h2&gt; &#xA;&lt;p&gt;If you are using a published release of Descheduler (such as &lt;code&gt;registry.k8s.io/descheduler/descheduler:v0.26.1&lt;/code&gt;), follow the documentation in that version&#39;s release branch, as listed below:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Descheduler Version&lt;/th&gt; &#xA;   &lt;th&gt;Docs link&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.27.x&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/descheduler/raw/release-1.27/README.md&#34;&gt;&lt;code&gt;release-1.27&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.26.x&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/descheduler/raw/release-1.26/README.md&#34;&gt;&lt;code&gt;release-1.26&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.25.x&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/descheduler/raw/release-1.25/README.md&#34;&gt;&lt;code&gt;release-1.25&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.24.x&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/descheduler/raw/release-1.24/README.md&#34;&gt;&lt;code&gt;release-1.24&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/kubernetes-sigs/descheduler/raw/master/README.md&#34;&gt;&lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is considered in-development and the information presented in it may not work for previous versions.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;The descheduler can be run as a &lt;code&gt;Job&lt;/code&gt;, &lt;code&gt;CronJob&lt;/code&gt;, or &lt;code&gt;Deployment&lt;/code&gt; inside of a k8s cluster. It has the advantage of being able to be run multiple times without needing user intervention. The descheduler pod is run as a critical pod in the &lt;code&gt;kube-system&lt;/code&gt; namespace to avoid being evicted by itself or by the kubelet.&lt;/p&gt; &#xA;&lt;h3&gt;Run As A Job&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;kubectl create -f kubernetes/base/rbac.yaml&#xA;kubectl create -f kubernetes/base/configmap.yaml&#xA;kubectl create -f kubernetes/job/job.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run As A CronJob&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;kubectl create -f kubernetes/base/rbac.yaml&#xA;kubectl create -f kubernetes/base/configmap.yaml&#xA;kubectl create -f kubernetes/cronjob/cronjob.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run As A Deployment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;kubectl create -f kubernetes/base/rbac.yaml&#xA;kubectl create -f kubernetes/base/configmap.yaml&#xA;kubectl create -f kubernetes/deployment/deployment.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install Using Helm&lt;/h3&gt; &#xA;&lt;p&gt;Starting with release v0.18.0 there is an official helm chart that can be used to install the descheduler. See the &lt;a href=&#34;https://github.com/kubernetes-sigs/descheduler/raw/master/charts/descheduler/README.md&#34;&gt;helm chart README&lt;/a&gt; for detailed instructions.&lt;/p&gt; &#xA;&lt;p&gt;The descheduler helm chart is also listed on the &lt;a href=&#34;https://artifacthub.io/packages/helm/descheduler/descheduler&#34;&gt;artifact hub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Install Using Kustomize&lt;/h3&gt; &#xA;&lt;p&gt;You can use kustomize to install descheduler. See the &lt;a href=&#34;https://kubectl.docs.kubernetes.io/references/kustomize/cmd/build/&#34;&gt;resources | Kustomize&lt;/a&gt; for detailed instructions.&lt;/p&gt; &#xA;&lt;p&gt;Run As A Job&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kustomize build &#39;github.com/kubernetes-sigs/descheduler/kubernetes/job?ref=v0.26.1&#39; | kubectl apply -f -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run As A CronJob&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kustomize build &#39;github.com/kubernetes-sigs/descheduler/kubernetes/cronjob?ref=v0.26.1&#39; | kubectl apply -f -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run As A Deployment&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kustomize build &#39;github.com/kubernetes-sigs/descheduler/kubernetes/deployment?ref=v0.26.1&#39; | kubectl apply -f -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;User Guide&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/docs/user-guide.md&#34;&gt;user guide&lt;/a&gt; in the &lt;code&gt;/docs&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Policy, Default Evictor and Strategy plugins&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;⚠️ v1alpha1 configuration is still supported, but deprecated (and soon will be removed). Please consider migrating to v1alpha2 (described bellow). For previous v1alpha1 documentation go to &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/docs/deprecated/v1alpha1.md&#34;&gt;docs/deprecated/v1alpha1.md&lt;/a&gt; ⚠️&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Descheduler Policy is configurable and includes default strategy plugins that can be enabled or disabled. It includes a common eviction configuration at the top level, as well as configuration from the Evictor plugin (Default Evictor, if not specified otherwise). Top-level configuration and Evictor plugin configuration are applied to all evictions.&lt;/p&gt; &#xA;&lt;h3&gt;Top Level configuration&lt;/h3&gt; &#xA;&lt;p&gt;These are top level keys in the Descheduler Policy that you can use to configure all evictions.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;type&lt;/th&gt; &#xA;   &lt;th&gt;Default Value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;nodeSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;limiting the nodes which are processed. Only used when &lt;code&gt;nodeFit&lt;/code&gt;=&lt;code&gt;true&lt;/code&gt; and only by the PreEvictionFilter Extension Point&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;maxNoOfPodsToEvictPerNode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;maximum number of pods evicted from each node (summed through all strategies)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;maxNoOfPodsToEvictPerNamespace&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;maximum number of pods evicted from each namespace (summed through all strategies)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Evictor Plugin configuration (Default Evictor)&lt;/h3&gt; &#xA;&lt;p&gt;The Default Evictor Plugin is used by default for filtering pods before processing them in an strategy plugin, or for applying a PreEvictionFilter of pods before eviction. You can also create your own Evictor Plugin or use the Default one provided by Descheduler. Other uses for the Evictor plugin can be to sort, filter, validate or group pods by different criteria, and that&#39;s why this is handled by a plugin and not configured in the top level config.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;type&lt;/th&gt; &#xA;   &lt;th&gt;Default Value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;nodeSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;limiting the nodes which are processed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;evictLocalStoragePods&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;allows eviction of pods with local storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;evictSystemCriticalPods&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[Warning: Will evict Kubernetes system pods] allows eviction of pods with any priority, including system pods like kube-dns&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ignorePvcPods&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;set whether PVC pods should be evicted or ignored&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;evictFailedBarePods&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;allow eviction of pods without owner references and in failed phase&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;metav1.LabelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;priorityThreshold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;priorityThreshold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#priority-filtering&#34;&gt;priority filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;nodeFit&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#node-fit-filtering&#34;&gt;node fit filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Example policy&lt;/h3&gt; &#xA;&lt;p&gt;As part of the policy, you will start deciding which top level configuration to use, then which Evictor plugin to use (if you have your own, the Default Evictor if not), followed by deciding the configuration passed to the Evictor Plugin. By default, the Default Evictor is enabled for both &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;preEvictionFilter&lt;/code&gt; extension points. After that you will enable/disable eviction strategies plugins and configure them properly.&lt;/p&gt; &#xA;&lt;p&gt;See each strategy plugin section for details on available parameters.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Policy:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;nodeSelector: &#34;node=node1&#34; # you don&#39;t need to set this, if not set all will be processed&#xA;maxNoOfPodsToEvictPerNode: 5000 # you don&#39;t need to set this, unlimited if not set&#xA;maxNoOfPodsToEvictPerNamespace: 5000 # you don&#39;t need to set this, unlimited if not set&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;DefaultEvictor&#34;&#xA;      args:&#xA;        evictSystemCriticalPods: true&#xA;        evictFailedBarePods: true&#xA;        evictLocalStoragePods: true&#xA;        nodeFit: true&#xA;    plugins:&#xA;      # DefaultEvictor is enabled for both `filter` and `preEvictionFilter`&#xA;      # filter:&#xA;      #   enabled:&#xA;      #     - &#34;DefaultEvictor&#34;&#xA;      # preEvictionFilter:&#xA;      #   enabled:&#xA;      #     - &#34;DefaultEvictor&#34;&#xA;      deschedule:&#xA;        enabled:&#xA;          - ...&#xA;      balance:&#xA;        enabled:&#xA;          - ...&#xA;      [...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following diagram provides a visualization of most of the strategies to help categorize how strategies fit together.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/strategies_diagram.png&#34; alt=&#34;Strategies diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The following sections provide an overview of the different strategy plugins available. These plugins are grouped based on their implementation of extension points: Deschedule or Balance.&lt;/p&gt; &#xA;&lt;p&gt;Deschedule Plugins: These plugins process pods one by one, and evict them in a sequential manner.&lt;/p&gt; &#xA;&lt;p&gt;Balance Plugins: These plugins process all pods, or groups of pods, and determine which pods to evict based on how the group was intended to be spread.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Extension Point Implemented&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#removeduplicates&#34;&gt;RemoveDuplicates&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Balance&lt;/td&gt; &#xA;   &lt;td&gt;Spreads replicas&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#lownodeutilization&#34;&gt;LowNodeUtilization&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Balance&lt;/td&gt; &#xA;   &lt;td&gt;Spreads pods according to pods resource requests and node resources available&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#highnodeutilization&#34;&gt;HighNodeUtilization&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Balance&lt;/td&gt; &#xA;   &lt;td&gt;Spreads pods according to pods resource requests and node resources available&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#removepodsviolatinginterpodantiaffinity&#34;&gt;RemovePodsViolatingInterPodAntiAffinity&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deschedule&lt;/td&gt; &#xA;   &lt;td&gt;Evicts pods violating pod anti affinity&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#removepodsviolatingnodeaffinity&#34;&gt;RemovePodsViolatingNodeAffinity&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deschedule&lt;/td&gt; &#xA;   &lt;td&gt;Evicts pods violating node affinity&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#removepodsviolatingnodetaints&#34;&gt;RemovePodsViolatingNodeTaints&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deschedule&lt;/td&gt; &#xA;   &lt;td&gt;Evicts pods violating node taints&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#removepodsviolatingtopologyspreadconstraint&#34;&gt;RemovePodsViolatingTopologySpreadConstraint&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Balance&lt;/td&gt; &#xA;   &lt;td&gt;Evicts pods violating TopologySpreadConstraints&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#removepodshavingtoomanyrestarts&#34;&gt;RemovePodsHavingTooManyRestarts&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deschedule&lt;/td&gt; &#xA;   &lt;td&gt;Evicts pods having too many restarts&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#podlifetime&#34;&gt;PodLifeTime&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deschedule&lt;/td&gt; &#xA;   &lt;td&gt;Evicts pods that have exceeded a specified age limit&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#removefailedpods&#34;&gt;RemoveFailedPods&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deschedule&lt;/td&gt; &#xA;   &lt;td&gt;Evicts pods with certain failed reasons&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;RemoveDuplicates&lt;/h3&gt; &#xA;&lt;p&gt;This strategy plugin makes sure that there is only one pod associated with a ReplicaSet (RS), ReplicationController (RC), StatefulSet, or Job running on the same node. If there are more, those duplicate pods are evicted for better spreading of pods in a cluster. This issue could happen if some nodes went down due to whatever reasons, and pods on them were moved to other nodes leading to more than one pod associated with a RS or RC, for example, running on the same node. Once the failed nodes are ready again, this strategy could be enabled to evict those duplicate pods.&lt;/p&gt; &#xA;&lt;p&gt;It provides one optional parameter, &lt;code&gt;excludeOwnerKinds&lt;/code&gt;, which is a list of OwnerRef &lt;code&gt;Kind&lt;/code&gt;s. If a pod has any of these &lt;code&gt;Kind&lt;/code&gt;s listed as an &lt;code&gt;OwnerRef&lt;/code&gt;, that pod will not be considered for eviction. Note that pods created by Deployments are considered for eviction by this strategy. The &lt;code&gt;excludeOwnerKinds&lt;/code&gt; parameter should include &lt;code&gt;ReplicaSet&lt;/code&gt; to have pods created by Deployments excluded.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;excludeOwnerKinds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;list(string)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;RemoveDuplicates&#34;&#xA;      args:&#xA;        excludeOwnerKinds:&#xA;          - &#34;ReplicaSet&#34;&#xA;    plugins:&#xA;      balance:&#xA;        enabled:&#xA;          - &#34;RemoveDuplicates&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LowNodeUtilization&lt;/h3&gt; &#xA;&lt;p&gt;This strategy finds nodes that are under utilized and evicts pods, if possible, from other nodes in the hope that recreation of evicted pods will be scheduled on these underutilized nodes. The parameters of this strategy are configured under &lt;code&gt;nodeResourceUtilizationThresholds&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The under utilization of nodes is determined by a configurable threshold &lt;code&gt;thresholds&lt;/code&gt;. The threshold &lt;code&gt;thresholds&lt;/code&gt; can be configured for cpu, memory, number of pods, and extended resources in terms of percentage (the percentage is calculated as the current resources requested on the node vs &lt;a href=&#34;https://kubernetes.io/docs/concepts/architecture/nodes/#capacity&#34;&gt;total allocatable&lt;/a&gt;. For pods, this means the number of pods on the node as a fraction of the pod capacity set for that node).&lt;/p&gt; &#xA;&lt;p&gt;If a node&#39;s usage is below threshold for all (cpu, memory, number of pods and extended resources), the node is considered underutilized. Currently, pods request resource requirements are considered for computing node resource utilization.&lt;/p&gt; &#xA;&lt;p&gt;There is another configurable threshold, &lt;code&gt;targetThresholds&lt;/code&gt;, that is used to compute those potential nodes from where pods could be evicted. If a node&#39;s usage is above targetThreshold for any (cpu, memory, number of pods, or extended resources), the node is considered over utilized. Any node between the thresholds, &lt;code&gt;thresholds&lt;/code&gt; and &lt;code&gt;targetThresholds&lt;/code&gt; is considered appropriately utilized and is not considered for eviction. The threshold, &lt;code&gt;targetThresholds&lt;/code&gt;, can be configured for cpu, memory, and number of pods too in terms of percentage.&lt;/p&gt; &#xA;&lt;p&gt;These thresholds, &lt;code&gt;thresholds&lt;/code&gt; and &lt;code&gt;targetThresholds&lt;/code&gt;, could be tuned as per your cluster requirements. Note that this strategy evicts pods from &lt;code&gt;overutilized nodes&lt;/code&gt; (those with usage above &lt;code&gt;targetThresholds&lt;/code&gt;) to &lt;code&gt;underutilized nodes&lt;/code&gt; (those with usage below &lt;code&gt;thresholds&lt;/code&gt;), it will abort if any number of &lt;code&gt;underutilized nodes&lt;/code&gt; or &lt;code&gt;overutilized nodes&lt;/code&gt; is zero.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, the strategy accepts a &lt;code&gt;useDeviationThresholds&lt;/code&gt; parameter. If that parameter is set to &lt;code&gt;true&lt;/code&gt;, the thresholds are considered as percentage deviations from mean resource usage. &lt;code&gt;thresholds&lt;/code&gt; will be deducted from the mean among all nodes and &lt;code&gt;targetThresholds&lt;/code&gt; will be added to the mean. A resource consumption above (resp. below) this window is considered as overutilization (resp. underutilization).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Node resource consumption is determined by the requests and limits of pods, not actual usage. This approach is chosen in order to maintain consistency with the kube-scheduler, which follows the same design for scheduling pods onto nodes. This means that resource usage as reported by Kubelet (or commands like &lt;code&gt;kubectl top&lt;/code&gt;) may differ from the calculated consumption, due to these components reporting actual usage metrics. Implementing metrics-based descheduling is currently TODO for the project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;useDeviationThresholds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bool&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;thresholds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;map(string:int)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;targetThresholds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;map(string:int)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;numberOfNodes&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;int&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;evictableNamespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;LowNodeUtilization&#34;&#xA;      args:&#xA;        thresholds:&#xA;          &#34;cpu&#34; : 20&#xA;          &#34;memory&#34;: 20&#xA;          &#34;pods&#34;: 20&#xA;        targetThresholds:&#xA;          &#34;cpu&#34; : 50&#xA;          &#34;memory&#34;: 50&#xA;          &#34;pods&#34;: 50&#xA;    plugins:&#xA;      balance:&#xA;        enabled:&#xA;          - &#34;LowNodeUtilization&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Policy should pass the following validation checks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Three basic native types of resources are supported: &lt;code&gt;cpu&lt;/code&gt;, &lt;code&gt;memory&lt;/code&gt; and &lt;code&gt;pods&lt;/code&gt;. If any of these resource types is not specified, all its thresholds default to 100% to avoid nodes going from underutilized to overutilized.&lt;/li&gt; &#xA; &lt;li&gt;Extended resources are supported. For example, resource type &lt;code&gt;nvidia.com/gpu&lt;/code&gt; is specified for GPU node utilization. Extended resources are optional, and will not be used to compute node&#39;s usage if it&#39;s not specified in &lt;code&gt;thresholds&lt;/code&gt; and &lt;code&gt;targetThresholds&lt;/code&gt; explicitly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;thresholds&lt;/code&gt; or &lt;code&gt;targetThresholds&lt;/code&gt; can not be nil and they must configure exactly the same types of resources.&lt;/li&gt; &#xA; &lt;li&gt;The valid range of the resource&#39;s percentage value is [0, 100]&lt;/li&gt; &#xA; &lt;li&gt;Percentage value of &lt;code&gt;thresholds&lt;/code&gt; can not be greater than &lt;code&gt;targetThresholds&lt;/code&gt; for the same resource.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is another parameter associated with the &lt;code&gt;LowNodeUtilization&lt;/code&gt; strategy, called &lt;code&gt;numberOfNodes&lt;/code&gt;. This parameter can be configured to activate the strategy only when the number of under utilized nodes are above the configured value. This could be helpful in large clusters where a few nodes could go under utilized frequently or for a short period of time. By default, &lt;code&gt;numberOfNodes&lt;/code&gt; is set to zero.&lt;/p&gt; &#xA;&lt;h3&gt;HighNodeUtilization&lt;/h3&gt; &#xA;&lt;p&gt;This strategy finds nodes that are under utilized and evicts pods from the nodes in the hope that these pods will be scheduled compactly into fewer nodes. Used in conjunction with node auto-scaling, this strategy is intended to help trigger down scaling of under utilized nodes. This strategy &lt;strong&gt;must&lt;/strong&gt; be used with the scheduler scoring strategy &lt;code&gt;MostAllocated&lt;/code&gt;. The parameters of this strategy are configured under &lt;code&gt;nodeResourceUtilizationThresholds&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: On GKE, it is not possible to customize the default scheduler config. Instead, you can use the &lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler#:~:text=The%20optimize%2Dutilization%20autoscaling%20profile,custom%20scheduler%20are%20not%20affected&#34;&gt;&lt;code&gt;optimze-utilization&lt;/code&gt; autoscaling strategy&lt;/a&gt;, which has the same effect as enabling the &lt;code&gt;MostAllocated&lt;/code&gt; scheduler plugin. Alternatively, you can deploy a second custom scheduler and edit that scheduler&#39;s config yourself.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The under utilization of nodes is determined by a configurable threshold &lt;code&gt;thresholds&lt;/code&gt;. The threshold &lt;code&gt;thresholds&lt;/code&gt; can be configured for cpu, memory, number of pods, and extended resources in terms of percentage. The percentage is calculated as the current resources requested on the node vs &lt;a href=&#34;https://kubernetes.io/docs/concepts/architecture/nodes/#capacity&#34;&gt;total allocatable&lt;/a&gt;. For pods, this means the number of pods on the node as a fraction of the pod capacity set for that node.&lt;/p&gt; &#xA;&lt;p&gt;If a node&#39;s usage is below threshold for all (cpu, memory, number of pods and extended resources), the node is considered underutilized. Currently, pods request resource requirements are considered for computing node resource utilization. Any node above &lt;code&gt;thresholds&lt;/code&gt; is considered appropriately utilized and is not considered for eviction.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;thresholds&lt;/code&gt; param could be tuned as per your cluster requirements. Note that this strategy evicts pods from &lt;code&gt;underutilized nodes&lt;/code&gt; (those with usage below &lt;code&gt;thresholds&lt;/code&gt;) so that they can be recreated in appropriately utilized nodes. The strategy will abort if any number of &lt;code&gt;underutilized nodes&lt;/code&gt; or &lt;code&gt;appropriately utilized nodes&lt;/code&gt; is zero.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Node resource consumption is determined by the requests and limits of pods, not actual usage. This approach is chosen in order to maintain consistency with the kube-scheduler, which follows the same design for scheduling pods onto nodes. This means that resource usage as reported by Kubelet (or commands like &lt;code&gt;kubectl top&lt;/code&gt;) may differ from the calculated consumption, due to these components reporting actual usage metrics. Implementing metrics-based descheduling is currently TODO for the project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;thresholds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;map(string:int)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;numberOfNodes&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;int&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;evictableNamespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;HighNodeUtilization&#34;&#xA;      args:&#xA;        thresholds:&#xA;          &#34;cpu&#34; : 20&#xA;          &#34;memory&#34;: 20&#xA;          &#34;pods&#34;: 20&#xA;        evictableNamespaces:&#xA;          namespaces:&#xA;            exclude:&#xA;            - &#34;kube-system&#34;&#xA;            - &#34;namespace1&#34;&#xA;    plugins:&#xA;      balance:&#xA;        enabled:&#xA;          - &#34;HighNodeUtilization&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Policy should pass the following validation checks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Three basic native types of resources are supported: &lt;code&gt;cpu&lt;/code&gt;, &lt;code&gt;memory&lt;/code&gt; and &lt;code&gt;pods&lt;/code&gt;. If any of these resource types is not specified, all its thresholds default to 100%.&lt;/li&gt; &#xA; &lt;li&gt;Extended resources are supported. For example, resource type &lt;code&gt;nvidia.com/gpu&lt;/code&gt; is specified for GPU node utilization. Extended resources are optional, and will not be used to compute node&#39;s usage if it&#39;s not specified in &lt;code&gt;thresholds&lt;/code&gt; explicitly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;thresholds&lt;/code&gt; can not be nil.&lt;/li&gt; &#xA; &lt;li&gt;The valid range of the resource&#39;s percentage value is [0, 100]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is another parameter associated with the &lt;code&gt;HighNodeUtilization&lt;/code&gt; strategy, called &lt;code&gt;numberOfNodes&lt;/code&gt;. This parameter can be configured to activate the strategy only when the number of under utilized nodes is above the configured value. This could be helpful in large clusters where a few nodes could go under utilized frequently or for a short period of time. By default, &lt;code&gt;numberOfNodes&lt;/code&gt; is set to zero.&lt;/p&gt; &#xA;&lt;h3&gt;RemovePodsViolatingInterPodAntiAffinity&lt;/h3&gt; &#xA;&lt;p&gt;This strategy makes sure that pods violating interpod anti-affinity are removed from nodes. For example, if there is podA on a node and podB and podC (running on the same node) have anti-affinity rules which prohibit them to run on the same node, then podA will be evicted from the node so that podB and podC could run. This issue could happen, when the anti-affinity rules for podB and podC are created when they are already running on node.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;RemovePodsViolatingInterPodAntiAffinity&#34;&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;RemovePodsViolatingInterPodAntiAffinity&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RemovePodsViolatingNodeAffinity&lt;/h3&gt; &#xA;&lt;p&gt;This strategy makes sure all pods violating &lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#node-affinity&#34;&gt;node affinity&lt;/a&gt; are eventually removed from nodes. Node affinity rules allow a pod to specify &lt;code&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/code&gt; type, which tells the scheduler to respect node affinity when scheduling the pod but kubelet to ignore in case node changes over time and no longer respects the affinity. When enabled, the strategy serves as a temporary implementation of &lt;code&gt;requiredDuringSchedulingRequiredDuringExecution&lt;/code&gt; and evicts pod for kubelet that no longer respects node affinity.&lt;/p&gt; &#xA;&lt;p&gt;For example, there is podA scheduled on nodeA which satisfies the node affinity rule &lt;code&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/code&gt; at the time of scheduling. Over time nodeA stops to satisfy the rule. When the strategy gets executed and there is another node available that satisfies the node affinity rule, podA gets evicted from nodeA.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;nodeAffinityType&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;list(string)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;RemovePodsViolatingNodeAffinity&#34;&#xA;      args:&#xA;        nodeAffinityType:&#xA;        - &#34;requiredDuringSchedulingIgnoredDuringExecution&#34;&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;RemovePodsViolatingNodeAffinity&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RemovePodsViolatingNodeTaints&lt;/h3&gt; &#xA;&lt;p&gt;This strategy makes sure that pods violating NoSchedule taints on nodes are removed. For example there is a pod &#34;podA&#34; with a toleration to tolerate a taint &lt;code&gt;key=value:NoSchedule&lt;/code&gt; scheduled and running on the tainted node. If the node&#39;s taint is subsequently updated/removed, taint is no longer satisfied by its pods&#39; tolerations and will be evicted.&lt;/p&gt; &#xA;&lt;p&gt;Node taints can be excluded from consideration by specifying a list of excludedTaints. If a node taint key &lt;strong&gt;or&lt;/strong&gt; key=value matches an excludedTaints entry, the taint will be ignored.&lt;/p&gt; &#xA;&lt;p&gt;For example, excludedTaints entry &#34;dedicated&#34; would match all taints with key &#34;dedicated&#34;, regardless of value. excludedTaints entry &#34;dedicated=special-user&#34; would match taints with key &#34;dedicated&#34; and value &#34;special-user&#34;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;excludedTaints&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;list(string)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;includePreferNoSchedule&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bool&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;RemovePodsViolatingNodeTaints&#34;&#xA;      args:&#xA;        excludedTaints:&#xA;        - dedicated=special-user # exclude taints with key &#34;dedicated&#34; and value &#34;special-user&#34;&#xA;        - reserved # exclude all taints with key &#34;reserved&#34;&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;RemovePodsViolatingNodeTaints&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RemovePodsViolatingTopologySpreadConstraint&lt;/h3&gt; &#xA;&lt;p&gt;This strategy makes sure that pods violating &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/&#34;&gt;topology spread constraints&lt;/a&gt; are evicted from nodes. Specifically, it tries to evict the minimum number of pods required to balance topology domains to within each constraint&#39;s &lt;code&gt;maxSkew&lt;/code&gt;. This strategy requires k8s version 1.18 at a minimum.&lt;/p&gt; &#xA;&lt;p&gt;By default, this strategy only includes hard constraints, you can explicitly set &lt;code&gt;constraints&lt;/code&gt; as shown below to include both:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;constraints:&#xA;- DoNotSchedule&#xA;- ScheduleAnyway&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;topologyBalanceNodeFit&lt;/code&gt; arg is used when balancing topology domains while the Default Evictor&#39;s &lt;code&gt;nodeFit&lt;/code&gt; is used in pre-eviction to determine if a pod can be evicted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;topologyBalanceNodeFit: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Strategy parameter &lt;code&gt;labelSelector&lt;/code&gt; is not utilized when balancing topology domains and is only applied during eviction to determine if the pod can be evicted.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;constraints&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#topologyspreadconstraint-v1-core&#34;&gt;whenUnsatisfiable&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;topologyBalanceNodeFit&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bool&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;RemovePodsViolatingTopologySpreadConstraint&#34;&#xA;      args:&#xA;        constraints:&#xA;          - DoNotSchedule&#xA;    plugins:&#xA;      balance:&#xA;        enabled:&#xA;          - &#34;RemovePodsViolatingTopologySpreadConstraint&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RemovePodsHavingTooManyRestarts&lt;/h3&gt; &#xA;&lt;p&gt;This strategy makes sure that pods having too many restarts are removed from nodes. For example a pod with EBS/PD that can&#39;t get the volume/disk attached to the instance, then the pod should be re-scheduled to other nodes. Its parameters include &lt;code&gt;podRestartThreshold&lt;/code&gt;, which is the number of restarts (summed over all eligible containers) at which a pod should be evicted, and &lt;code&gt;includingInitContainers&lt;/code&gt;, which determines whether init container restarts should be factored into that calculation.&lt;/p&gt; &#xA;&lt;p&gt;You can also specify &lt;code&gt;states&lt;/code&gt; parameter to &lt;strong&gt;only&lt;/strong&gt; evict pods matching the following conditions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase&#34;&gt;Pod Phase&lt;/a&gt; status of: &lt;code&gt;Running&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting&#34;&gt;Container State Waiting&lt;/a&gt; of: &lt;code&gt;CrashLoopBackOff&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If a value for &lt;code&gt;states&lt;/code&gt; or &lt;code&gt;podStatusPhases&lt;/code&gt; is not specified, Pods in any state (even &lt;code&gt;Running&lt;/code&gt;) are considered for eviction.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;podRestartThreshold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;int&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;includingInitContainers&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bool&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;states&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;list(string)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;RemovePodsHavingTooManyRestarts&#34;&#xA;      args:&#xA;        podRestartThreshold: 100&#xA;        includingInitContainers: true&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;RemovePodsHavingTooManyRestarts&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PodLifeTime&lt;/h3&gt; &#xA;&lt;p&gt;This strategy evicts pods that are older than &lt;code&gt;maxPodLifeTimeSeconds&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also specify &lt;code&gt;states&lt;/code&gt; parameter to &lt;strong&gt;only&lt;/strong&gt; evict pods matching the following conditions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase&#34;&gt;Pod Phase&lt;/a&gt; status of: &lt;code&gt;Running&lt;/code&gt;, &lt;code&gt;Pending&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting&#34;&gt;Container State Waiting&lt;/a&gt; condition of: &lt;code&gt;PodInitializing&lt;/code&gt;, &lt;code&gt;ContainerCreating&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If a value for &lt;code&gt;states&lt;/code&gt; or &lt;code&gt;podStatusPhases&lt;/code&gt; is not specified, Pods in any state (even &lt;code&gt;Running&lt;/code&gt;) are considered for eviction.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;maxPodLifeTimeSeconds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;int&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;states&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;list(string)&lt;/td&gt; &#xA;   &lt;td&gt;Only supported in v0.25+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;PodLifeTime&#34;&#xA;      args:&#xA;        maxPodLifeTimeSeconds: 86400&#xA;        states:&#xA;        - &#34;Pending&#34;&#xA;        - &#34;PodInitializing&#34;&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;PodLifeTime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RemoveFailedPods&lt;/h3&gt; &#xA;&lt;p&gt;This strategy evicts pods that are in failed status phase. You can provide an optional parameter to filter by failed &lt;code&gt;reasons&lt;/code&gt;. &lt;code&gt;reasons&lt;/code&gt; can be expanded to include reasons of InitContainers as well by setting the optional parameter &lt;code&gt;includingInitContainers&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. You can specify an optional parameter &lt;code&gt;minPodLifetimeSeconds&lt;/code&gt; to evict pods that are older than specified seconds. Lastly, you can specify the optional parameter &lt;code&gt;excludeOwnerKinds&lt;/code&gt; and if a pod has any of these &lt;code&gt;Kind&lt;/code&gt;s listed as an &lt;code&gt;OwnerRef&lt;/code&gt;, that pod will not be considered for eviction.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;minPodLifetimeSeconds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;uint&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;excludeOwnerKinds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;list(string)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;reasons&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;list(string)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;includingInitContainers&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bool&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;namespaces&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#namespace-filtering&#34;&gt;namespace filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labelSelector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(see &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/#label-filtering&#34;&gt;label filtering&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;RemoveFailedPods&#34;&#xA;      args:&#xA;        reasons:&#xA;        - &#34;NodeAffinity&#34;&#xA;        includingInitContainers: true&#xA;        excludeOwnerKinds:&#xA;        - &#34;Job&#34;&#xA;        minPodLifetimeSeconds: 3600&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;RemoveFailedPods&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Filter Pods&lt;/h2&gt; &#xA;&lt;h3&gt;Namespace filtering&lt;/h3&gt; &#xA;&lt;p&gt;The following strategies accept a &lt;code&gt;namespaces&lt;/code&gt; parameter which allows to specify a list of including, resp. excluding namespaces:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;PodLifeTime&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsHavingTooManyRestarts&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingNodeTaints&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingNodeAffinity&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingInterPodAntiAffinity&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemoveDuplicates&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingTopologySpreadConstraint&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemoveFailedPods&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following strategies accept a &lt;code&gt;evictableNamespaces&lt;/code&gt; parameter which allows to specify a list of excluding namespaces:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;LowNodeUtilization&lt;/code&gt; and &lt;code&gt;HighNodeUtilization&lt;/code&gt; (Only filtered right before eviction)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example with PodLifeTime:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;PodLifeTime&#34;&#xA;      args:&#xA;        maxPodLifeTimeSeconds: 86400&#xA;        namespaces:&#xA;          include:&#xA;          - &#34;namespace1&#34;&#xA;          - &#34;namespace2&#34;&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;PodLifeTime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example &lt;code&gt;PodLifeTime&lt;/code&gt; gets executed only over &lt;code&gt;namespace1&lt;/code&gt; and &lt;code&gt;namespace2&lt;/code&gt;. The similar holds for &lt;code&gt;exclude&lt;/code&gt; field:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;PodLifeTime&#34;&#xA;      args:&#xA;        maxPodLifeTimeSeconds: 86400&#xA;        namespaces:&#xA;          exclude:&#xA;          - &#34;namespace1&#34;&#xA;          - &#34;namespace2&#34;&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;PodLifeTime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The strategy gets executed over all namespaces but &lt;code&gt;namespace1&lt;/code&gt; and &lt;code&gt;namespace2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s not allowed to compute &lt;code&gt;include&lt;/code&gt; with &lt;code&gt;exclude&lt;/code&gt; field.&lt;/p&gt; &#xA;&lt;h3&gt;Priority filtering&lt;/h3&gt; &#xA;&lt;p&gt;Priority threshold can be configured via the Default Evictor Filter, and, only pods under the threshold can be evicted. You can specify this threshold by setting &lt;code&gt;priorityThreshold.name&lt;/code&gt;(setting the threshold to the value of the given priority class) or &lt;code&gt;priorityThreshold.value&lt;/code&gt;(directly setting the threshold) parameters. By default, this threshold is set to the value of &lt;code&gt;system-cluster-critical&lt;/code&gt; priority class.&lt;/p&gt; &#xA;&lt;p&gt;Note: Setting &lt;code&gt;evictSystemCriticalPods&lt;/code&gt; to true disables priority filtering entirely.&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;priorityThreshold value&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;DefaultEvictor&#34;&#xA;      args:&#xA;        priorityThreshold:&#xA;          value: 10000&#xA;    - name: &#34;PodLifeTime&#34;&#xA;      args:&#xA;        maxPodLifeTimeSeconds: 86400&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;PodLifeTime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;Priority Threshold Class Name (priorityThreshold.name)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;DefaultEvictor&#34;&#xA;      args:&#xA;        priorityThreshold:&#xA;          name: &#34;priorityClassName1&#34;&#xA;    - name: &#34;PodLifeTime&#34;&#xA;      args:&#xA;        maxPodLifeTimeSeconds: 86400&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;PodLifeTime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you can&#39;t configure both &lt;code&gt;priorityThreshold.name&lt;/code&gt; and &lt;code&gt;priorityThreshold.value&lt;/code&gt;, if the given priority class does not exist, descheduler won&#39;t create it and will throw an error.&lt;/p&gt; &#xA;&lt;h3&gt;Label filtering&lt;/h3&gt; &#xA;&lt;p&gt;The following strategies can configure a &lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#labelselector-v1-meta&#34;&gt;standard kubernetes labelSelector&lt;/a&gt; to filter pods by their labels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;PodLifeTime&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsHavingTooManyRestarts&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingNodeTaints&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingNodeAffinity&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingInterPodAntiAffinity&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemovePodsViolatingTopologySpreadConstraint&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RemoveFailedPods&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This allows running strategies among pods the descheduler is interested in.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;PodLifeTime&#34;&#xA;      args:&#xA;        maxPodLifeTimeSeconds: 86400&#xA;        labelSelector:&#xA;          matchLabels:&#xA;            component: redis&#xA;          matchExpressions:&#xA;            - {key: tier, operator: In, values: [cache]}&#xA;            - {key: environment, operator: NotIn, values: [dev]}&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;PodLifeTime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Node Fit filtering&lt;/h3&gt; &#xA;&lt;p&gt;NodeFit can be configured via the Default Evictor Filter. If set to &lt;code&gt;true&lt;/code&gt; the descheduler will consider whether or not the pods that meet eviction criteria will fit on other nodes before evicting them. If a pod cannot be rescheduled to another node, it will not be evicted. Currently the following criteria are considered when setting &lt;code&gt;nodeFit&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;code&gt;nodeSelector&lt;/code&gt; on the pod&lt;/li&gt; &#xA; &lt;li&gt;Any &lt;code&gt;tolerations&lt;/code&gt; on the pod and any &lt;code&gt;taints&lt;/code&gt; on the other nodes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nodeAffinity&lt;/code&gt; on the pod&lt;/li&gt; &#xA; &lt;li&gt;Resource &lt;code&gt;requests&lt;/code&gt; made by the pod and the resources available on other nodes&lt;/li&gt; &#xA; &lt;li&gt;Whether any of the other nodes are marked as &lt;code&gt;unschedulable&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &#34;descheduler/v1alpha2&#34;&#xA;kind: &#34;DeschedulerPolicy&#34;&#xA;profiles:&#xA;  - name: ProfileName&#xA;    pluginConfig:&#xA;    - name: &#34;DefaultEvictor&#34;&#xA;      args:&#xA;        nodeFit: true&#xA;    - name: &#34;PodLifeTime&#34;&#xA;      args:&#xA;        maxPodLifeTimeSeconds: 86400&#xA;    plugins:&#xA;      deschedule:&#xA;        enabled:&#xA;          - &#34;PodLifeTime&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that node fit filtering references the current pod spec, and not that of it&#39;s owner. Thus, if the pod is owned by a ReplicationController (and that ReplicationController was modified recently), the pod may be running with an outdated spec, which the descheduler will reference when determining node fit. This is expected behavior as the descheduler is a &#34;best-effort&#34; mechanism.&lt;/p&gt; &#xA;&lt;p&gt;Using Deployments instead of ReplicationControllers provides an automated rollout of pod spec changes, therefore ensuring that the descheduler has an up-to-date view of the cluster state.&lt;/p&gt; &#xA;&lt;h2&gt;Pod Evictions&lt;/h2&gt; &#xA;&lt;p&gt;When the descheduler decides to evict pods from a node, it employs the following general mechanism:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/&#34;&gt;Critical pods&lt;/a&gt; (with priorityClassName set to system-cluster-critical or system-node-critical) are never evicted (unless &lt;code&gt;evictSystemCriticalPods: true&lt;/code&gt; is set).&lt;/li&gt; &#xA; &lt;li&gt;Pods (static or mirrored pods or standalone pods) not part of an ReplicationController, ReplicaSet(Deployment), StatefulSet, or Job are never evicted because these pods won&#39;t be recreated. (Standalone pods in failed status phase can be evicted by setting &lt;code&gt;evictFailedBarePods: true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Pods associated with DaemonSets are never evicted.&lt;/li&gt; &#xA; &lt;li&gt;Pods with local storage are never evicted (unless &lt;code&gt;evictLocalStoragePods: true&lt;/code&gt; is set).&lt;/li&gt; &#xA; &lt;li&gt;Pods with PVCs are evicted (unless &lt;code&gt;ignorePvcPods: true&lt;/code&gt; is set).&lt;/li&gt; &#xA; &lt;li&gt;In &lt;code&gt;LowNodeUtilization&lt;/code&gt; and &lt;code&gt;RemovePodsViolatingInterPodAntiAffinity&lt;/code&gt;, pods are evicted by their priority from low to high, and if they have same priority, best effort pods are evicted before burstable and guaranteed pods.&lt;/li&gt; &#xA; &lt;li&gt;All types of pods with the annotation &lt;code&gt;descheduler.alpha.kubernetes.io/evict&lt;/code&gt; are eligible for eviction. This annotation is used to override checks which prevent eviction and users can select which pod is evicted. Users should know how and if the pod will be recreated. The annotation only affects internal descheduler checks. The anti-disruption protection provided by the &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/api-eviction/&#34;&gt;/eviction&lt;/a&gt; subresource is still respected.&lt;/li&gt; &#xA; &lt;li&gt;Pods with a non-nil DeletionTimestamp are not evicted by default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;--v=4&lt;/code&gt; or greater on the Descheduler will log all reasons why any pod is not evictable.&lt;/p&gt; &#xA;&lt;h3&gt;Pod Disruption Budget (PDB)&lt;/h3&gt; &#xA;&lt;p&gt;Pods subject to a Pod Disruption Budget(PDB) are not evicted if descheduling violates its PDB. The pods are evicted by using the eviction subresource to handle PDB.&lt;/p&gt; &#xA;&lt;h2&gt;High Availability&lt;/h2&gt; &#xA;&lt;p&gt;In High Availability mode, Descheduler starts &lt;a href=&#34;https://github.com/kubernetes/client-go/tree/master/tools/leaderelection&#34;&gt;leader election&lt;/a&gt; process in Kubernetes. You can activate HA mode if you choose to deploy your application as Deployment.&lt;/p&gt; &#xA;&lt;p&gt;Deployment starts with 1 replica by default. If you want to use more than 1 replica, you must consider enable High Availability mode since we don&#39;t want to run descheduler pods simultaneously.&lt;/p&gt; &#xA;&lt;h3&gt;Configure HA Mode&lt;/h3&gt; &#xA;&lt;p&gt;The leader election process can be enabled by setting &lt;code&gt;--leader-elect&lt;/code&gt; in the CLI. You can also set &lt;code&gt;--set=leaderElection.enabled=true&lt;/code&gt; flag if you are using Helm.&lt;/p&gt; &#xA;&lt;p&gt;To get best results from HA mode some additional configurations might require:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configure a &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node&#34;&gt;podAntiAffinity&lt;/a&gt; rule if you want to schedule onto a node only if that node is in the same zone as at least one already-running descheduler&lt;/li&gt; &#xA; &lt;li&gt;Set the replica count greater than 1&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Metrics&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;type&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;build_info&lt;/td&gt; &#xA;   &lt;td&gt;gauge&lt;/td&gt; &#xA;   &lt;td&gt;constant 1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;pods_evicted&lt;/td&gt; &#xA;   &lt;td&gt;CounterVec&lt;/td&gt; &#xA;   &lt;td&gt;total number of pods evicted&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The metrics are served through &lt;a href=&#34;https://localhost:10258/metrics&#34;&gt;https://localhost:10258/metrics&lt;/a&gt; by default. The address and port can be changed by setting &lt;code&gt;--binding-address&lt;/code&gt; and &lt;code&gt;--secure-port&lt;/code&gt; flags.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility Matrix&lt;/h2&gt; &#xA;&lt;p&gt;The below compatibility matrix shows the k8s client package(client-go, apimachinery, etc) versions that descheduler is compiled with. At this time descheduler does not have a hard dependency to a specific k8s release. However a particular descheduler release is only tested against the three latest k8s minor versions. For example descheduler v0.18 should work with k8s v1.18, v1.17, and v1.16.&lt;/p&gt; &#xA;&lt;p&gt;Starting with descheduler release v0.18 the minor version of descheduler matches the minor version of the k8s client packages that it is compiled with.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Descheduler&lt;/th&gt; &#xA;   &lt;th&gt;Supported Kubernetes Version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.27&lt;/td&gt; &#xA;   &lt;td&gt;v1.27&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.26&lt;/td&gt; &#xA;   &lt;td&gt;v1.26&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.25&lt;/td&gt; &#xA;   &lt;td&gt;v1.25&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.24&lt;/td&gt; &#xA;   &lt;td&gt;v1.24&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.23&lt;/td&gt; &#xA;   &lt;td&gt;v1.23&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.22&lt;/td&gt; &#xA;   &lt;td&gt;v1.22&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.21&lt;/td&gt; &#xA;   &lt;td&gt;v1.21&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.20&lt;/td&gt; &#xA;   &lt;td&gt;v1.20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.19&lt;/td&gt; &#xA;   &lt;td&gt;v1.19&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.18&lt;/td&gt; &#xA;   &lt;td&gt;v1.18&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.10&lt;/td&gt; &#xA;   &lt;td&gt;v1.17&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.4-v0.9&lt;/td&gt; &#xA;   &lt;td&gt;v1.9+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v0.1-v0.3&lt;/td&gt; &#xA;   &lt;td&gt;v1.7-v1.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Getting Involved and Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Are you interested in contributing to descheduler? We, the maintainers and community, would love your suggestions, contributions, and help! Also, the maintainers can be contacted at any time to learn more about how to get involved.&lt;/p&gt; &#xA;&lt;p&gt;To get started writing code see the &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/docs/contributor-guide.md&#34;&gt;contributor guide&lt;/a&gt; in the &lt;code&gt;/docs&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;In the interest of getting more new people involved we tag issues with [&lt;code&gt;good first issue&lt;/code&gt;][good_first_issue]. These are typically issues that have smaller scope but are good ways to start to get acquainted with the codebase.&lt;/p&gt; &#xA;&lt;p&gt;We also encourage ALL active community participants to act as if they are maintainers, even if you don&#39;t have &#34;official&#34; write permissions. This is a community effort, we are here to serve the Kubernetes community. If you have an active interest and you want to get involved, you have real power! Don&#39;t assume that the only people who can get things done around here are the &#34;maintainers&#34;.&lt;/p&gt; &#xA;&lt;p&gt;We also would love to add more &#34;official&#34; maintainers, so show us what you can do!&lt;/p&gt; &#xA;&lt;p&gt;This repository uses the Kubernetes bots. See a full list of the commands [here][prow].&lt;/p&gt; &#xA;&lt;h3&gt;Communicating With Contributors&lt;/h3&gt; &#xA;&lt;p&gt;You can reach the contributors of this project at:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kubernetes.slack.com/messages/sig-scheduling&#34;&gt;Slack channel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/kubernetes-sig-scheduling&#34;&gt;Mailing list&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Learn how to engage with the Kubernetes community on the &lt;a href=&#34;http://kubernetes.io/community/&#34;&gt;community page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;This roadmap is not in any particular order.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Consideration of pod affinity&lt;/li&gt; &#xA; &lt;li&gt;Strategy to consider number of pending pods&lt;/li&gt; &#xA; &lt;li&gt;Integration with cluster autoscaler&lt;/li&gt; &#xA; &lt;li&gt;Integration with metrics providers for obtaining real load metrics&lt;/li&gt; &#xA; &lt;li&gt;Consideration of Kubernetes&#39;s scheduler&#39;s predicates&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Code of conduct&lt;/h3&gt; &#xA;&lt;p&gt;Participation in the Kubernetes community is governed by the &lt;a href=&#34;https://raw.githubusercontent.com/kubernetes-sigs/descheduler/master/code-of-conduct.md&#34;&gt;Kubernetes Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>