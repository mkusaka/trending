<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-26T01:35:09Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nginxinc/kubernetes-ingress</title>
    <updated>2023-05-26T01:35:09Z</updated>
    <id>tag:github.com,2023-05-26:/nginxinc/kubernetes-ingress</id>
    <link href="https://github.com/nginxinc/kubernetes-ingress" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NGINX and NGINX Plus Ingress Controllers for Kubernetes&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://api.securityscorecards.dev/projects/github.com/nginxinc/kubernetes-ingress&#34;&gt;&lt;img src=&#34;https://api.securityscorecards.dev/projects/github.com/nginxinc/kubernetes-ingress/badge&#34; alt=&#34;OpenSSF Scorecard&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/nginxinc/kubernetes-ingress/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.fossa.com/projects/custom%2B5618%2Fgithub.com%2Fnginxinc%2Fkubernetes-ingress?ref=badge_shield&#34;&gt;&lt;img src=&#34;https://app.fossa.com/api/projects/custom%2B5618%2Fgithub.com%2Fnginxinc%2Fkubernetes-ingress.svg?type=shield&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/nginxinc/kubernetes-ingress&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/nginxinc/kubernetes-ingress&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/nginxinc/kubernetes-ingress&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/nginxinc/kubernetes-ingress/branch/main/graph/badge.svg?token=snCn7Y0zC7&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/nginxinc/kubernetes-ingress?logo=github&amp;amp;sort=semver&#34; alt=&#34;GitHub release (latest SemVer)&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/go-mod/go-version/nginxinc/kubernetes-ingress?logo=go&#34; alt=&#34;GitHub go.mod Go version&#34;&gt; &lt;a href=&#34;https://hub.docker.com/r/nginx/nginx-ingress&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/nginx/nginx-ingress?logo=docker&amp;amp;logoColor=white&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/docker/image-size/nginx/nginx-ingress?logo=docker&amp;amp;logoColor=white&amp;amp;sort=semver&#34; alt=&#34;Docker Image Size (latest semver)&#34;&gt; &lt;a href=&#34;https://artifacthub.io/packages/container/nginx-ingress/kubernetes-ingress&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https://artifacthub.io/badge/repository/nginx-ingress&#34; alt=&#34;Artifact Hub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://nginxcommunity.slack.com/channels/nginx-ingress-controller&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/slack-%23nginx--ingress--controller-green?logo=slack&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;ðŸš€ &lt;em&gt;Help make the NGINX Ingress Controller better by participating in our &lt;a href=&#34;https://forms.office.com/Pages/ResponsePage.aspx?id=L_093Ttq0UCb4L-DJ9gcUKLQ7uTJaE1PitM_37KR881UMEs0Rk5PMkYzMTJTWVA0V1hUVTRLUUMyNS4u&#34;&gt;survey&lt;/a&gt;!&lt;/em&gt; ðŸš€&lt;/h1&gt; &#xA;&lt;h1&gt;NGINX Ingress Controller&lt;/h1&gt; &#xA;&lt;p&gt;This repo provides an implementation of an Ingress Controller for NGINX and NGINX Plus.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: this project is different from the NGINX Ingress Controller in &lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34;&gt;kubernetes/ingress-nginx&lt;/a&gt; repo. See &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/intro/nginx-ingress-controllers&#34;&gt;this doc&lt;/a&gt; to find out about the key differences.&lt;/p&gt; &#xA;&lt;h2&gt;What is the Ingress?&lt;/h2&gt; &#xA;&lt;p&gt;The Ingress is a Kubernetes resource that lets you configure an HTTP load balancer for applications running on Kubernetes, represented by one or more &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34;&gt;Services&lt;/a&gt;. Such a load balancer is necessary to deliver those applications to clients outside of the Kubernetes cluster.&lt;/p&gt; &#xA;&lt;p&gt;The Ingress resource supports the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Content-based routing&lt;/strong&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;em&gt;Host-based routing&lt;/em&gt;. For example, routing requests with the host header &lt;code&gt;foo.example.com&lt;/code&gt; to one group of services and the host header &lt;code&gt;bar.example.com&lt;/code&gt; to another group.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;em&gt;Path-based routing&lt;/em&gt;. For example, routing requests with the URI that starts with &lt;code&gt;/serviceA&lt;/code&gt; to service A and requests with the URI that starts with &lt;code&gt;/serviceB&lt;/code&gt; to service B.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;TLS/SSL termination&lt;/strong&gt; for each hostname, such as &lt;code&gt;foo.example.com&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://kubernetes.io/docs/user-guide/ingress/&#34;&gt;Ingress User Guide&lt;/a&gt; to learn more about the Ingress resource.&lt;/p&gt; &#xA;&lt;h2&gt;What is the Ingress Controller?&lt;/h2&gt; &#xA;&lt;p&gt;The Ingress Controller is an application that runs in a cluster and configures an HTTP load balancer according to Ingress resources. The load balancer can be a software load balancer running in the cluster or a hardware or cloud load balancer running externally. Different load balancers require different Ingress Controller implementations.&lt;/p&gt; &#xA;&lt;p&gt;In the case of NGINX, the Ingress Controller is deployed in a pod along with the load balancer.&lt;/p&gt; &#xA;&lt;h2&gt;NGINX Ingress Controller&lt;/h2&gt; &#xA;&lt;p&gt;NGINX Ingress Controller works with both NGINX and NGINX Plus and supports the standard Ingress features - content-based routing and TLS/SSL termination.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, several NGINX and NGINX Plus features are available as extensions to the Ingress resource via annotations and the ConfigMap resource. In addition to HTTP, NGINX Ingress Controller supports load balancing Websocket, gRPC, TCP and UDP applications. See &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/configuration/global-configuration/configmap-resource/&#34;&gt;ConfigMap&lt;/a&gt; and &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-annotations/&#34;&gt;Annotations&lt;/a&gt; docs to learn more about the supported features and customization options.&lt;/p&gt; &#xA;&lt;p&gt;As an alternative to the Ingress, NGINX Ingress Controller supports the VirtualServer and VirtualServerRoute resources. They enable use cases not supported with the Ingress resource, such as traffic splitting and advanced content-based routing. See &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/&#34;&gt;VirtualServer and VirtualServerRoute resources doc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;TCP, UDP and TLS Passthrough load balancing is also supported. See the &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/configuration/transportserver-resource/&#34;&gt;TransportServer resource doc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Read &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/intro/nginx-plus&#34;&gt;this doc&lt;/a&gt; to learn more about NGINX Ingress Controller with NGINX Plus.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install the NGINX Ingress Controller using the Kubernetes &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-manifests/&#34;&gt;manifests&lt;/a&gt; or the &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-helm/&#34;&gt;helm chart&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Configure load balancing for a simple web application: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Use the Ingress resource. See the &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/examples/ingress-resources/complete-example&#34;&gt;Cafe example&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Or the VirtualServer resource. See the &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/examples/custom-resources/basic-configuration&#34;&gt;Basic configuration&lt;/a&gt; example.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;See additional configuration &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/examples&#34;&gt;examples&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Learn more about all available configuration and customization in the &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/&#34;&gt;docs&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;NGINX Ingress Controller Releases&lt;/h2&gt; &#xA;&lt;p&gt;We publish Ingress Controller releases on GitHub. See our &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/releases&#34;&gt;releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The latest stable release is &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/releases/tag/v3.1.1&#34;&gt;3.1.1&lt;/a&gt;. For production use, we recommend that you choose the latest stable release.&lt;/p&gt; &#xA;&lt;p&gt;The edge version is useful for experimenting with new features that are not yet published in a stable release. To use it, choose the &lt;em&gt;edge&lt;/em&gt; version built from the &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/commits/main&#34;&gt;latest commit&lt;/a&gt; from the main branch.&lt;/p&gt; &#xA;&lt;p&gt;To use the Ingress Controller, you need to have access to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An Ingress Controller image.&lt;/li&gt; &#xA; &lt;li&gt;Installation manifests or a Helm chart.&lt;/li&gt; &#xA; &lt;li&gt;Documentation and examples.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is important that the versions of those things above match.&lt;/p&gt; &#xA;&lt;p&gt;The table below summarizes the options regarding the images, manifests, helm chart, documentation and examples and gives your links to the correct versions:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Image for NGINX&lt;/th&gt; &#xA;   &lt;th&gt;Image for NGINX Plus&lt;/th&gt; &#xA;   &lt;th&gt;Installation Manifests and Helm Chart&lt;/th&gt; &#xA;   &lt;th&gt;Documentation and Examples&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Latest stable release&lt;/td&gt; &#xA;   &lt;td&gt;For production use&lt;/td&gt; &#xA;   &lt;td&gt;Use the 3.1.1 images from &lt;a href=&#34;https://hub.docker.com/r/nginx/nginx-ingress/&#34;&gt;DockerHub&lt;/a&gt;, &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/pkgs/container/kubernetes-ingress&#34;&gt;GitHub Container&lt;/a&gt;, &lt;a href=&#34;https://gallery.ecr.aws/nginx/nginx-ingress&#34;&gt;Amazon ECR Public Gallery&lt;/a&gt; or &lt;a href=&#34;https://quay.io/repository/nginx/nginx-ingress&#34;&gt;Quay.io&lt;/a&gt; or &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/installation/building-ingress-controller-image/&#34;&gt;build your own image&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;Use the 3.1.1 images from the &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/installation/pulling-ingress-controller-image/&#34;&gt;F5 Container Registry&lt;/a&gt; or the &lt;a href=&#34;https://aws.amazon.com/marketplace/search/?CREATOR=741df81b-dfdc-4d36-b8da-945ea66b522c&amp;amp;FULFILLMENT_OPTION_TYPE=CONTAINER&amp;amp;filters=CREATOR%2CFULFILLMENT_OPTION_TYPE&#34;&gt;AWS Marketplace&lt;/a&gt; or &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/installation/building-ingress-controller-image/&#34;&gt;Build your own image&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/v3.1.1/deployments&#34;&gt;Manifests&lt;/a&gt;. &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/v3.1.1/deployments/helm-chart&#34;&gt;Helm chart&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/&#34;&gt;Documentation&lt;/a&gt;. &lt;a href=&#34;https://docs.nginx.com/nginx-ingress-controller/configuration/configuration-examples/&#34;&gt;Examples&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Edge/Nightly&lt;/td&gt; &#xA;   &lt;td&gt;For testing and experimenting&lt;/td&gt; &#xA;   &lt;td&gt;Use the edge or nightly images from &lt;a href=&#34;https://hub.docker.com/r/nginx/nginx-ingress/&#34;&gt;DockerHub&lt;/a&gt;, &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/pkgs/container/kubernetes-ingress&#34;&gt;GitHub Container&lt;/a&gt;, &lt;a href=&#34;https://gallery.ecr.aws/nginx/nginx-ingress&#34;&gt;Amazon ECR Public Gallery&lt;/a&gt; or &lt;a href=&#34;https://quay.io/repository/nginx/nginx-ingress&#34;&gt;Quay.io&lt;/a&gt; or &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/docs/content/installation/building-ingress-controller-image.md&#34;&gt;build your own image&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/docs/content/installation/building-ingress-controller-image.md&#34;&gt;Build your own image&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/deployments&#34;&gt;Manifests&lt;/a&gt;. &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/deployments/helm-chart&#34;&gt;Helm chart&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/docs/content&#34;&gt;Documentation&lt;/a&gt;. &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/tree/main/examples&#34;&gt;Examples&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;SBOM (Software Bill of Materials)&lt;/h2&gt; &#xA;&lt;p&gt;We generate SBOMs for the binaries and the Docker images.&lt;/p&gt; &#xA;&lt;h3&gt;Binaries&lt;/h3&gt; &#xA;&lt;p&gt;The SBOMs for the binaries are available in the releases page. The SBOMs are generated using &lt;a href=&#34;https://github.com/anchore/syft&#34;&gt;syft&lt;/a&gt; and are available in SPDX format.&lt;/p&gt; &#xA;&lt;h3&gt;Docker Images&lt;/h3&gt; &#xA;&lt;p&gt;The SBOMs for the Docker images are available in the &lt;a href=&#34;https://hub.docker.com/r/nginx/nginx-ingress/&#34;&gt;DockerHub&lt;/a&gt;, &lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress/pkgs/container/kubernetes-ingress&#34;&gt;GitHub Container&lt;/a&gt;, &lt;a href=&#34;https://gallery.ecr.aws/nginx/nginx-ingress&#34;&gt;Amazon ECR Public Gallery&lt;/a&gt; or &lt;a href=&#34;https://quay.io/repository/nginx/nginx-ingress&#34;&gt;Quay.io&lt;/a&gt; repositories. The SBOMs are generated using &lt;a href=&#34;https://github.com/anchore/syft&#34;&gt;syft&lt;/a&gt; and stored as an attestation in the image manifest.&lt;/p&gt; &#xA;&lt;p&gt;For example to retrieve the SBOM for &lt;code&gt;linux/amd64&lt;/code&gt; from Docker Hub and analyze it using &lt;a href=&#34;https://github.com/anchore/grype&#34;&gt;grype&lt;/a&gt; you can run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ docker buildx imagetools inspect nginx/nginx-ingress:edge --format &#39;{{ json (index .SBOM &#34;linux/amd64&#34;).SPDX }}&#39; | grype&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contacts&lt;/h2&gt; &#xA;&lt;p&gt;Weâ€™d like to hear your feedback! If you have any suggestions or experience issues with our Ingress Controller, please create an issue or send a pull request on GitHub. You can contact us directly via &lt;a href=&#34;mailto:kubernetes@nginx.com&#34;&gt;kubernetes@nginx.com&lt;/a&gt; or on the &lt;a href=&#34;https://nginxcommunity.slack.com/channels/nginx-ingress-controller&#34;&gt;NGINX Community Slack&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to contribute to the project, please read our &lt;a href=&#34;https://raw.githubusercontent.com/nginxinc/kubernetes-ingress/main/CONTRIBUTING.md&#34;&gt;Contributing guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;For NGINX Plus customers NGINX Ingress Controller (when used with NGINX Plus) is covered by the support contract.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Workiva/go-datastructures</title>
    <updated>2023-05-26T01:35:09Z</updated>
    <id>tag:github.com,2023-05-26:/Workiva/go-datastructures</id>
    <link href="https://github.com/Workiva/go-datastructures" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A collection of useful, performant, and threadsafe Go datastructures.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;go-datastructures&lt;/h1&gt; &#xA;&lt;p&gt;Go-datastructures is a collection of useful, performant, and threadsafe Go datastructures.&lt;/p&gt; &#xA;&lt;h3&gt;NOTE: only tested with Go 1.3+.&lt;/h3&gt; &#xA;&lt;h4&gt;Augmented Tree&lt;/h4&gt; &#xA;&lt;p&gt;Interval tree for collision in n-dimensional ranges. Implemented via a red-black augmented tree. Extra dimensions are handled in simultaneous inserts/queries to save space although this may result in suboptimal time complexity. Intersection determined using bit arrays. In a single dimension, inserts, deletes, and queries should be in O(log n) time.&lt;/p&gt; &#xA;&lt;h4&gt;Bitarray&lt;/h4&gt; &#xA;&lt;p&gt;Bitarray used to detect existence without having to resort to hashing with hashmaps. Requires entities have a uint64 unique identifier. Two implementations exist, regular and sparse. Sparse saves a great deal of space but insertions are O(log n). There are some useful functions on the BitArray interface to detect intersection between two bitarrays. This package also includes bitmaps of length 32 and 64 that provide increased speed and O(1) for all operations by storing the bitmaps in unsigned integers rather than arrays.&lt;/p&gt; &#xA;&lt;h4&gt;Futures&lt;/h4&gt; &#xA;&lt;p&gt;A helpful tool to send a &#34;broadcast&#34; message to listeners. Channels have the issue that once one listener takes a message from a channel the other listeners aren&#39;t notified. There were many cases when I wanted to notify many listeners of a single event and this package helps.&lt;/p&gt; &#xA;&lt;h4&gt;Queue&lt;/h4&gt; &#xA;&lt;p&gt;Package contains both a normal and priority queue. Both implementations never block on send and grow as much as necessary. Both also only return errors if you attempt to push to a disposed queue and will not panic like sending a message on a closed channel. The priority queue also allows you to place items in priority order inside the queue. If you give a useful hint to the regular queue, it is actually faster than a channel. The priority queue is somewhat slow currently and targeted for an update to a Fibonacci heap.&lt;/p&gt; &#xA;&lt;p&gt;Also included in the queue package is a MPMC threadsafe ring buffer. This is a block full/empty queue, but will return a blocked thread if the queue is disposed while a thread is blocked. This can be used to synchronize goroutines and ensure goroutines quit so objects can be GC&#39;d. Threadsafety is achieved using only CAS operations making this queue quite fast. Benchmarks can be found in that package.&lt;/p&gt; &#xA;&lt;h4&gt;Fibonacci Heap&lt;/h4&gt; &#xA;&lt;p&gt;A standard Fibonacci heap providing the usual operations. Can be useful in executing Dijkstra or Prim&#39;s algorithms in the theoretically minimal time. Also useful as a general-purpose priority queue. The special thing about Fibonacci heaps versus other heap variants is the cheap decrease-key operation. This heap has a constant complexity for find minimum, insert and merge of two heaps, an amortized constant complexity for decrease key and O(log(n)) complexity for a deletion or dequeue minimum. In practice the constant factors are large, so Fibonacci heaps could be slower than Pairing heaps, depending on usage. Benchmarks - in the project subfolder. The heap has not been designed for thread-safety.&lt;/p&gt; &#xA;&lt;h4&gt;Range Tree&lt;/h4&gt; &#xA;&lt;p&gt;Useful to determine if n-dimensional points fall within an n-dimensional range. Not a typical range tree however, as we are actually using an n-dimensional sorted list of points as this proved to be simpler and faster than attempting a traditional range tree while saving space on any dimension greater than one. Inserts are typical BBST times at O(log n^d) where d is the number of dimensions.&lt;/p&gt; &#xA;&lt;h4&gt;Set&lt;/h4&gt; &#xA;&lt;p&gt;Our Set implementation is very simple, accepts items of type &lt;code&gt;interface{}&lt;/code&gt; and includes only a few methods. If your application requires a richer Set implementation over lists of type &lt;code&gt;sort.Interface&lt;/code&gt;, see &lt;a href=&#34;https://github.com/xtgo/set&#34;&gt;xtgo/set&lt;/a&gt; and &lt;a href=&#34;https://github.com/goware/set&#34;&gt;goware/set&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Threadsafe&lt;/h4&gt; &#xA;&lt;p&gt;A package that is meant to contain some commonly used items but in a threadsafe way. Example: there&#39;s a threadsafe error in there as I commonly found myself wanting to set an error in many threads at the same time (yes, I know, but channels are slow).&lt;/p&gt; &#xA;&lt;h4&gt;AVL Tree&lt;/h4&gt; &#xA;&lt;p&gt;This is an example of a branch copy immutable AVL BBST. Any operation on a node makes a copy of that node&#39;s branch. Because of this, this tree is inherently threadsafe although the writes will likely still need to be serialized. This structure is good if your use case is a large number of reads and infrequent writes as reads will be highly available but writes somewhat slow due to the copying. This structure serves as a basis for a large number of functional data structures.&lt;/p&gt; &#xA;&lt;h4&gt;X-Fast Trie&lt;/h4&gt; &#xA;&lt;p&gt;An interesting design that treats integers as words and uses a trie structure to reduce time complexities by matching prefixes. This structure is really fast for finding values or making predecessor/successor types of queries, but also results in greater than linear space consumption. The exact time complexities can be found in that package.&lt;/p&gt; &#xA;&lt;h4&gt;Y-Fast Trie&lt;/h4&gt; &#xA;&lt;p&gt;An extension of the X-Fast trie in which an X-Fast trie is combined with some other ordered data structure to reduce space consumption and improve CRUD types of operations. These secondary structures are often BSTs, but our implementation uses a simple ordered list as I believe this improves cache locality. We also use fixed size buckets to aid in parallelization of operations. Exact time complexities are in that package.&lt;/p&gt; &#xA;&lt;h4&gt;Fast integer hashmap&lt;/h4&gt; &#xA;&lt;p&gt;A datastructure used for checking existence but without knowing the bounds of your data. If you have a limited small bounds, the bitarray package might be a better choice. This implementation uses a fairly simple hashing algorithm combined with linear probing and a flat datastructure to provide optimal performance up to a few million integers (faster than the native Golang implementation). Beyond that, the native implementation is faster (I believe they are using a large -ary B-tree). In the future, this will be implemented with a B-tree for scale.&lt;/p&gt; &#xA;&lt;h4&gt;Skiplist&lt;/h4&gt; &#xA;&lt;p&gt;An ordered structure that provides amortized logarithmic operations but without the complication of rotations that are required by BSTs. In testing, however, the performance of the skip list is often far worse than the guaranteed log n time of a BBST. Tall nodes tend to &#34;cast shadows&#34;, especially when large bitsizes are required as the optimum maximum height for a node is often based on this. More detailed performance characteristics are provided in that package.&lt;/p&gt; &#xA;&lt;h4&gt;Sort&lt;/h4&gt; &#xA;&lt;p&gt;The sort package implements a multithreaded bucket sort that can be up to 3x faster than the native Golang sort package. These buckets are then merged using a symmetrical merge, similar to the stable sort in the Golang package. However, our algorithm is modified so that two sorted lists can be merged by using symmetrical decomposition.&lt;/p&gt; &#xA;&lt;h4&gt;Numerics&lt;/h4&gt; &#xA;&lt;p&gt;Early work on some nonlinear optimization problems. The initial implementation allows a simple use case with either linear or nonlinear constraints. You can find min/max or target an optimal value. The package currently employs a probabilistic global restart system in an attempt to avoid local critical points. More details can be found in that package.&lt;/p&gt; &#xA;&lt;h4&gt;B+ Tree&lt;/h4&gt; &#xA;&lt;p&gt;Initial implementation of a B+ tree. Delete method still needs added as well as some performance optimization. Specific performance characteristics can be found in that package. Despite the theoretical superiority of BSTs, the B-tree often has better all around performance due to cache locality. The current implementation is mutable, but the immutable AVL tree can be used to build an immutable version. Unfortunately, to make the B-tree generic we require an interface and the most expensive operation in CPU profiling is the interface method which in turn calls into runtime.assertI2T. We need generics.&lt;/p&gt; &#xA;&lt;h4&gt;Immutable B Tree&lt;/h4&gt; &#xA;&lt;p&gt;A btree based on two principals, immutablability and concurrency. Somewhat slow for single value lookups and puts, it is very fast for bulk operations. A persister can be injected to make this index persistent.&lt;/p&gt; &#xA;&lt;h4&gt;Ctrie&lt;/h4&gt; &#xA;&lt;p&gt;A concurrent, lock-free hash array mapped trie with efficient non-blocking snapshots. For lookups, Ctries have comparable performance to concurrent skip lists and concurrent hashmaps. One key advantage of Ctries is they are dynamically allocated. Memory consumption is always proportional to the number of keys in the Ctrie, while hashmaps typically have to grow and shrink. Lookups, inserts, and removes are O(logn).&lt;/p&gt; &#xA;&lt;p&gt;One interesting advantage Ctries have over traditional concurrent data structures is support for lock-free, linearizable, constant-time snapshots. Most concurrent data structures do not support snapshots, instead opting for locks or requiring a quiescent state. This allows Ctries to have O(1) iterator creation and clear operations and O(logn) size retrieval.&lt;/p&gt; &#xA;&lt;h4&gt;Dtrie&lt;/h4&gt; &#xA;&lt;p&gt;A persistent hash trie that dynamically expands or shrinks to provide efficient memory allocation. Being persistent, the Dtrie is immutable and any modification yields a new version of the Dtrie rather than changing the original. Bitmapped nodes allow for O(log32(n)) get, remove, and update operations. Insertions are O(n) and iteration is O(1).&lt;/p&gt; &#xA;&lt;h4&gt;Persistent List&lt;/h4&gt; &#xA;&lt;p&gt;A persistent, immutable linked list. All write operations yield a new, updated structure which preserve and reuse previous versions. This uses a very functional, cons-style of list manipulation. Insert, get, remove, and size operations are O(n) as you would expect.&lt;/p&gt; &#xA;&lt;h4&gt;Simple Graph&lt;/h4&gt; &#xA;&lt;p&gt;A mutable, non-persistent undirected graph where parallel edges and self-loops are not permitted. Operations to add an edge as well as retrieve the total number of vertices/edges are O(1) while the operation to retrieve the vertices adjacent to a target is O(n). For more details see &lt;a href=&#34;https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Simple_graph&#34;&gt;wikipedia&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Go 1.3 or higher.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;go get github.com/Workiva/go-datastructures/...&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Updating&lt;/h3&gt; &#xA;&lt;p&gt;When new code is merged to master, you can use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/Workiva/go-datastructures/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To retrieve the latest version of go-datastructures.&lt;/p&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;To run all the unit tests use these commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd $GOPATH/src/github.com/Workiva/go-datastructures&#xA;go get -t -u ./...&#xA;go test ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you&#39;ve done this once, you can simply use this command to run all unit tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go test ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;Requirements to commit here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Branch off master, PR back to master.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gofmt&lt;/code&gt;&#39;d code.&lt;/li&gt; &#xA; &lt;li&gt;Compliance with &lt;a href=&#34;https://code.google.com/p/go-wiki/wiki/CodeReviewComments&#34;&gt;these guidelines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Unit test coverage&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html&#34;&gt;Good commit messages&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Maintainers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dustin Hiatt &amp;lt;&lt;a href=&#34;mailto:dustin.hiatt@workiva.com&#34;&gt;dustin.hiatt@workiva.com&lt;/a&gt;&amp;gt;&lt;/li&gt; &#xA; &lt;li&gt;Alexander Campbell &amp;lt;&lt;a href=&#34;mailto:alexander.campbell@workiva.com&#34;&gt;alexander.campbell@workiva.com&lt;/a&gt;&amp;gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>