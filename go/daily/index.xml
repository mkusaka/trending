<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-13T01:30:23Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nlpodyssey/waveny</title>
    <updated>2023-11-13T01:30:23Z</updated>
    <id>tag:github.com,2023-11-13:/nlpodyssey/waveny</id>
    <link href="https://github.com/nlpodyssey/waveny" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emulate guitar amps and pedals with deep learning, in Go.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Waveny&lt;/h1&gt; &#xA;&lt;p&gt;Waveny is a Go library and command-line utility designed for emulating guitar amplifiers and pedals through deep learning.&lt;/p&gt; &#xA;&lt;p&gt;The project takes inspiration from &lt;a href=&#34;https://www.neuralampmodeler.com&#34;&gt;Neural Amp Modeler&lt;/a&gt; (NAM) and has adapted significant components from related repositories into Go:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sdatkinson/neural-amp-modeler&#34;&gt;neural-amp-modeler&lt;/a&gt;: a Python project for model training and WAVE file processing (reamping), leveraging PyTorch and Lightning.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sdatkinson/NeuralAmpModelerCore&#34;&gt;NeuralAmpModelerCore&lt;/a&gt;: the core DSP library, written in C++, suited to real-time plugin development.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development Status and Constraints&lt;/h2&gt; &#xA;&lt;p&gt;Waveny is in the early stages of development, and as such, the public APIs and functionalities are subject to change. The current codebase includes placeholders, indicating ongoing development, and minimal documentation.&lt;/p&gt; &#xA;&lt;p&gt;The project ambitiously applies digital signal processing in Go. The &lt;code&gt;live&lt;/code&gt; command aims to offer decent real-time processing on modern CPUs, but optimization is ongoing.&lt;/p&gt; &#xA;&lt;p&gt;Key technical constraints include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sole support for the WaveNet model.&lt;/li&gt; &#xA; &lt;li&gt;Support limited to a 48kHz sample rate.&lt;/li&gt; &#xA; &lt;li&gt;Requirement for WAVE files to be PCM 48kHz 24-bit mono, for training or reamping.&lt;/li&gt; &#xA; &lt;li&gt;Training on CPU only.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Future updates will address these limitations.&lt;/p&gt; &#xA;&lt;h2&gt;Utilization Guide&lt;/h2&gt; &#xA;&lt;h3&gt;Command Line Interface&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;waveny&lt;/code&gt; command-line interface offers several commands to interact with the deep learning models for guitar amp emulation.&lt;/p&gt; &#xA;&lt;p&gt;Build it with &lt;code&gt;go build ./cmd/waveny&lt;/code&gt;, or compile-and-run it with &lt;code&gt;go run ./cmd/waveny&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The single executable allows to run different sub-commands, in this form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;waveny COMMAND [arguments...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;waveny help&lt;/code&gt; to see a list of available commands. Here is a recap:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;train&lt;/code&gt;: train a new WaveNet model using SpaGO, producing both SpaGO and &lt;code&gt;.nam&lt;/code&gt; models.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;process-spago&lt;/code&gt;: process a WAVE file using a pre-trained WaveNet SpaGO model, loaded from a file in &#34;native&#34; format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;process-rt&lt;/code&gt;: process a WAVE file using the custom Waveny real-time-capable WaveNet model, loaded from a &lt;code&gt;.nam&lt;/code&gt; model-data file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;process-torch&lt;/code&gt;: process a WAVE file using a WaveNet SpaGO model, loaded and converted from a pre-trained NAM PyTorch/Lightning checkpoint file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;live&lt;/code&gt;: process audio input in real-time using the custom Waveny WaveNet model, loaded from a &lt;code&gt;.nam&lt;/code&gt; model-data file. It uses PortAudio for I/O.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For detailed usage and arguments of each command, execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;waveny COMMAND -h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following sections illustrate several use cases.&lt;/p&gt; &#xA;&lt;h4&gt;Training&lt;/h4&gt; &#xA;&lt;p&gt;To train a new WaveNet model from scratch, we first need to prepare some files.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A clean/unprocessed audio file (WAVE PCM 48kHz 24-bit mono). You are free to create or record your own. However, &lt;a href=&#34;https://github.com/sdatkinson/neural-amp-modeler&#34;&gt;neural-amp-modeler&lt;/a&gt; Python project comes with a set of standardized files: see &lt;a href=&#34;https://github.com/sdatkinson/neural-amp-modeler/raw/v0.7.3/README.md#standardized-reamping-files&#34;&gt;this section&lt;/a&gt; from the README. We recommend to use v3.0.0.&lt;/li&gt; &#xA; &lt;li&gt;A &#34;reamped&#34; target audio file (same format as above), that is, the audio signal from the previous file processed through the real amp or pedal that you want to emulate.&lt;/li&gt; &#xA; &lt;li&gt;A JSON configuration that describes structure and shapes of the WaveNet model. A good starting point is this &lt;a href=&#34;https://github.com/sdatkinson/neural-amp-modeler/raw/v0.7.3/bin/train/inputs/models/wavenet.json&#34;&gt;wavenet.json&lt;/a&gt; file from NAM Python project.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Clean and reamped files must have the same size and be perfectly aligned. Their coupled audio content will be split into a training set and a validation set: the splitting points can be specified with dedicated command line arguments. If you are using NAM standardized reamping file &lt;a href=&#34;https://drive.google.com/file/d/1Pgf8PdE0rKB1TD4TRPKbpNo1ByR3IOm9/view?usp=drive_link&#34;&gt;v3_0_0.wav&lt;/a&gt;, then the default values are already a good fit.&lt;/p&gt; &#xA;&lt;p&gt;Please have a look at the output of &lt;code&gt;waveny train -h&lt;/code&gt; to learn about additional arguments.&lt;/p&gt; &#xA;&lt;p&gt;Here is a minimal example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;waveny train \&#xA;  -config path/to/wavenet.json \&#xA;  -input path/to/v3_0_0.wav \&#xA;  -target path/to/v3_0_0_reamped.wav \&#xA;  -out path/to/output-folder/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A new sub-folder, named with the current date and time, is created under the specified output directory. Here, at the end of each training epoch, two checkpoint files are created: a SpaGo binary model file, with extension &lt;code&gt;.spago&lt;/code&gt;, and an equivalent &lt;code&gt;.nam&lt;/code&gt; data-model file. The latter is a JSON file in the so-called &#34;exported&#34; NAM format, compatible with Neural Amp Modeler projects and plugins.&lt;/p&gt; &#xA;&lt;p&gt;Loss values are shown for each epoch, and they also become part of the checkpoint file names, for convenience.&lt;/p&gt; &#xA;&lt;p&gt;You can stop the training manually at any moment with Ctrl+C.&lt;/p&gt; &#xA;&lt;p&gt;When you are satisfied with the accuracy, pick the best pair of model files from the output folder, and see further steps described below.&lt;/p&gt; &#xA;&lt;h4&gt;Process an audio file with pre-trained models&lt;/h4&gt; &#xA;&lt;h5&gt;Loading a SpaGO model&lt;/h5&gt; &#xA;&lt;p&gt;If you trained your own model as described above, a &lt;code&gt;.spago&lt;/code&gt; checkpoint file is created at the end of each training epoch. You can now use a pre-trained &lt;code&gt;.spago&lt;/code&gt; model to process an audio file.&lt;/p&gt; &#xA;&lt;p&gt;Get or record a &#34;clean&#34; audio file (WAVE PCM 48kHz 24-bit mono), choose your preferred model, and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;waveny process-spago \&#xA;  -input path/to/input.wav \&#xA;  -output path/to/output.wav \&#xA;  -model path/to/model.spago&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command creates the output WAVE file, processing your input with the given amp/pedal emulation model.&lt;/p&gt; &#xA;&lt;h5&gt;Loading a PyTorch model, running with SpaGO&lt;/h5&gt; &#xA;&lt;p&gt;If you trained a WaveNet model with &lt;a href=&#34;https://github.com/sdatkinson/neural-amp-modeler&#34;&gt;neural-amp-modeler&lt;/a&gt; Python project, you can use another command to load a PyTorch/Lightning model/checkpoint file, convert it into a corresponding SpaGO model (on-the-fly, in memory), and process an input file just like we did above. In this case, you also need the accompanying WaveNet JSON model-configuration file. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;waveny process-torch \&#xA;  -input path/to/input.wav \&#xA;  -output path/to/output.wav \&#xA;  -config path/to/config_model.json \&#xA;  -model path/torch_model.ckpt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Loading a &lt;code&gt;.nam&lt;/code&gt; model, running with Waveny custom implementation&lt;/h5&gt; &#xA;&lt;p&gt;There is yet another way to process an audio file. This time, we are going to provide a &lt;code&gt;.nam&lt;/code&gt; data-model file. This is NAM &#34;exported&#34; format, most commonly used to share NAM models, and intended to work with existing NAM audio plugins.&lt;/p&gt; &#xA;&lt;p&gt;If you trained your own model as described some sections above, a &lt;code&gt;.nam&lt;/code&gt; checkpoint file is created at the end of each training epoch.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, an amazing source for pre-trained models in this special format is &lt;a href=&#34;https://tonehunt.org&#34;&gt;ToneHunt&lt;/a&gt; website. Download your desired amp/pedal emulation model, and make sure it uses WaveNet architecture.&lt;/p&gt; &#xA;&lt;p&gt;Once you have a &lt;code&gt;.nam&lt;/code&gt; model file, you can run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;waveny process-rt \&#xA;  -input path/to/input.wav \&#xA;  -output path/to/output.wav \&#xA;  -model path/to/model.nam&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &#34;rt&#34; suffix in the command name indicates that we are using a custom WaveNet DSP processor: this implementation is most suitable for real-time processing, a topic discussed in the next section.&lt;/p&gt; &#xA;&lt;h4&gt;Process audio in real-time&lt;/h4&gt; &#xA;&lt;p&gt;Pre-trained &lt;code&gt;.nam&lt;/code&gt; models can also be used for real-time processing. Plug in your musical instrument, and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;waveny live -model path/to/model.nam&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command uses Waveny custom WaveNet implementation to process audio input in real-time. I/O is possible thanks to &lt;a href=&#34;https://github.com/gordonklaus/portaudio&#34;&gt;PortAudio&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Library Integration&lt;/h3&gt; &#xA;&lt;p&gt;Integrate Waveny as a Go module in your projects with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/nlpodyssey/waveny&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From now on, we will refer to the root package &lt;code&gt;github.com/nlpodyssey/waveny&lt;/code&gt; as simply &lt;code&gt;waveny&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently, the library only implements the WaveNet deep learning network. Under &lt;code&gt;waveny/models&lt;/code&gt; you will find two different model implementations.&lt;/p&gt; &#xA;&lt;p&gt;Package &lt;code&gt;waveny/models/spago/wavenet&lt;/code&gt; implements the model with &lt;a href=&#34;https://github.com/nlpodyssey/spago&#34;&gt;SpaGO&lt;/a&gt; machine learning library.&lt;/p&gt; &#xA;&lt;p&gt;A WaveNet SpaGO model can be trained from scratch - see &lt;code&gt;waveny/models/spago/wavenet/training&lt;/code&gt; subpackage. The training process produces SpaGO model files (&lt;code&gt;.spago&lt;/code&gt;), and equivalent models in NAM &#34;exported&#34; format (&lt;code&gt;.nam&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also possible to load a PyTorch model file, pre-trained with &lt;a href=&#34;https://github.com/sdatkinson/neural-amp-modeler&#34;&gt;neural-amp-modeler&lt;/a&gt; Python project, and convert it into a SpaGO model - see &lt;code&gt;waveny/models/spago/wavenet/torchconv&lt;/code&gt; subpackage. It uses &lt;a href=&#34;https://github.com/nlpodyssey/gopickle&#34;&gt;GoPickle&lt;/a&gt; library to read torch models without the need to run Python.&lt;/p&gt; &#xA;&lt;p&gt;A pre-trained SpaGO model can be effectively used to process WAVE files (non-real-time reamping). It is less suitable for real-time processing, mostly due to memory allocations and usage of goroutines.&lt;/p&gt; &#xA;&lt;p&gt;For real-time use, we provide another custom implementation of WaveNet, in package &lt;code&gt;waveny/models/realtime/wavenet&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The real-time-capable model can load &lt;code&gt;.nam&lt;/code&gt; files (the ones trained with Waveny, or NAM WaveNet models from sources like &lt;a href=&#34;https://tonehunt.org&#34;&gt;ToneHunt&lt;/a&gt;). This implementation takes advantage of a self-contained package for handling matrices and vectors, implemented in &lt;code&gt;waveny/models/realtime/mat&lt;/code&gt;. Inspired by the original &lt;a href=&#34;https://github.com/sdatkinson/NeuralAmpModelerCore&#34;&gt;NeuralAmpModelerCore&lt;/a&gt; implementation, and the underlying &lt;a href=&#34;https://eigen.tuxfamily.org&#34;&gt;Eigen&lt;/a&gt; library, it allows to minimize the amount of memory allocations, permitting a predictable execution time, suitable for real-time processing.&lt;/p&gt; &#xA;&lt;p&gt;Package &lt;code&gt;waveny/liveplay&lt;/code&gt; implements real-time processing procedures, using &lt;a href=&#34;https://github.com/gordonklaus/portaudio&#34;&gt;PortAudio&lt;/a&gt; go bindings for I/O.&lt;/p&gt; &#xA;&lt;p&gt;Package &lt;code&gt;waveny/wave&lt;/code&gt; provides utilities for reading and writing WAVE files.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Enelg52/OffensiveGo</title>
    <updated>2023-11-13T01:30:23Z</updated>
    <id>tag:github.com,2023-11-13:/Enelg52/OffensiveGo</id>
    <link href="https://github.com/Enelg52/OffensiveGo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Golang weaponization for red teamers.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OffensiveGo - Golang Weaponization for red teamers.&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/75935486/220217814-242de1ba-1f62-4b0b-a1be-6cf8b82ab0da.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;This repo is made by &lt;a href=&#34;https://twitter.com/RistBs&#34;&gt;@RistBS&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/Enelg_&#34;&gt;@Enelg&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://twitter.com/dreamkinn&#34;&gt;@dreamkinn&lt;/a&gt; and contains some examples of offensives tools &amp;amp; utilities rewrote in Golang that can be used in a red team engagement.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Table of Content&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#previous-work&#34;&gt;Previous work&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#about-golang&#34;&gt;About Golang&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#setup&#34;&gt;Workspace Setup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#compilation&#34;&gt;Compilation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#assembly-in-go&#34;&gt;Assembly in Go&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#obfuscate-go-builds&#34;&gt;Obfuscate Go Builds&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#golang-binary&#34;&gt;Golang Binary&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#interesting-tools-in-golang&#34;&gt;Interesting Tools in Golang&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;️💾 Previous works&lt;/h2&gt; &#xA;&lt;p&gt;These repo inspires us to make &lt;a href=&#34;https://github.com/RistBS/OffensiveGo&#34;&gt;OffensiveGo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/trickster0/OffensiveRust&#34;&gt;OffensiveRust&lt;/a&gt; : this project contains a bunch of examples made in &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/byt3bl33d3r/OffensiveNim&#34;&gt;OffensiveNim&lt;/a&gt; : this one contains examples written in &lt;a href=&#34;https://nim-lang.org/&#34;&gt;Nim&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/matterpreter/OffensiveCSharp&#34;&gt;OffensiveCSharp&lt;/a&gt; : A Collection of Offensive C# Tooling.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/byt3bl33d3r/OffensiveDLR&#34;&gt;OffensiveDLR&lt;/a&gt; : Toolbox containing research notes &amp;amp; PoC code for weaponizing .NET&#39;s &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/dynamic-language-runtime-overview&#34;&gt;DLR&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/S3cur3Th1sSh1t/OffensiveVBA&#34;&gt;OffensiveVBA&lt;/a&gt; : This repo covers some code execution and AV Evasion methods for Macros in Office documents.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/darkr4y/OffensiveZig&#34;&gt;OffensiveZig&lt;/a&gt; : Some attempts at using &lt;a href=&#34;https://ziglang.org/&#34;&gt;Zig&lt;/a&gt; in penetration testing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;📝 About Golang&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Simpler syntax&lt;/strong&gt;: Go&#39;s syntax is simpler and easier to learn.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Garbage collection&lt;/strong&gt;: Go uses garbage collection, which makes memory management easier for developers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cross-platform support&lt;/strong&gt;: Go has excellent cross-platform support and can be compiled to run on a wide range of platforms, including Windows, Linux, and macOS. Rust also has good cross-platform support, but its compilation process can be more complex.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Goroutine&lt;/strong&gt;: Goroutines are lightweight threads of execution that enable concurrent programming in Go, making it easy to write efficient, safe, and scalable concurrent programs, allowing for non-blocking concurrent execution and communication via channels.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;OPSEC Consideration &amp;amp; Caveat of Golang&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Go binaries generally have no installation dependencies, compiler statically links Go runtime and needed packages. Static linking results in larger binaries. 1.9 MB for &#34;Hello World&#34; compared to 54 KB in C.&lt;/p&gt; &#xA;&lt;h3&gt;🏗 Workspace Setup&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;create a &lt;code&gt;go.mod&lt;/code&gt; file in your project directory, which will be used to manage dependencies :&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ps&#34;&gt;&amp;gt; go mod init offensivego &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ensure that all your project&#39;s dependencies are up to date :&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ps&#34;&gt;&amp;gt; go mod tidy &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compilation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use &lt;code&gt;go build file.go&lt;/code&gt; for compilation.&lt;/li&gt; &#xA; &lt;li&gt;Omit debug symbols and strip the symbol table. it can also reduce binary size by about 30% : &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build -ldflags=&#34;-s -w&#34; file.go&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Hide console, to avoid Go program displaying console windows on execution : &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build -ldflags -H=windowsgui rshell.go&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Assembly in Go&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://go.dev/doc/asm&#34;&gt;assembly language&lt;/a&gt; used with Go is based on &lt;a href=&#34;https://9p.io/sys/doc/asm.html&#34;&gt;Plan9 (P9)&lt;/a&gt; and is a high-level architecture-independent language that includes mnemonics like &lt;code&gt;CALL&lt;/code&gt; and &lt;code&gt;RET&lt;/code&gt;, as well as higher-level constructs like loops and conditionals, which are implemented using lower-level assembly instructions by the assembler.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;That&#39;s how you declare function : &lt;img src=&#34;https://user-images.githubusercontent.com/75935486/234733526-bacaf609-b59a-4b99-a4f2-f708f65a0909.png&#34; alt=&#34;image&#34;&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;NOSPLIT&lt;/strong&gt; : Don&#39;t insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space remaining in the current stack segment. Used to protect routines such as the stack splitting code itself, which can improve performance.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;NOFRAME&lt;/strong&gt; : skip the generation of a function prologue and epilogue, even if this is not a leaf function, which can also improve performance by reducing the overhead of setting up and tearing down the stack frame for each call.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; : It can be useful to use Assembly in Go for your loaders if you want to build &lt;a href=&#34;https://github.com/C-Sto/BananaPhone&#34;&gt;direct&lt;/a&gt; / &lt;a href=&#34;https://github.com/f1zm0/acheron&#34;&gt;indirect&lt;/a&gt; syscall stub.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=9jpnFmJr2PE&amp;amp;t=1s&amp;amp;ab_channel=GopherConUK&#34;&gt;https://www.youtube.com/watch?v=9jpnFmJr2PE&amp;amp;t=1s&amp;amp;ab_channel=GopherConUK&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Obfuscate Go Builds&lt;/h3&gt; &#xA;&lt;p&gt;you can obfuscate Go builds using garble to replace strings and many other indcators with base64 encoding and removes extra intformations if necessary : &lt;a href=&#34;https://github.com/burrowers/garble&#34;&gt;https://github.com/burrowers/garble&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;garble build [build flags] [packages]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Golang Binary&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;symtab&lt;/code&gt; (symbol table) section contains symbol table information to map program addresses to their corresponding function and variable names. The symtab section in a Golang binary is generated by the Go linker. &lt;img src=&#34;https://user-images.githubusercontent.com/75935486/233974681-182d7770-c709-4035-ad23-637d3d1c136f.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If your implant use net/http lib with the default http headers, GO will put &lt;code&gt;Go-http-client/1.1&lt;/code&gt; has the user-agent.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/75935486/234994520-f26d7db4-c14e-410a-a23c-35bb9b56d5f9.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;File&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/injection_native_apc/main.go&#34;&gt;Process Injection - APC&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Execute a shellcode with &lt;code&gt;NtQueueApcThread&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/injection_thread&#34;&gt;Process Injection - CreateThread&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Execute a shellcode with &lt;code&gt;NtCreateThreadEx&lt;/code&gt; and &lt;code&gt;CreateThread&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/amsi_bypasses/&#34;&gt;AMSI Patching&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bypass AMSI by patching in memory &lt;code&gt;AmsiScanBuffer&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/etw_bypasses/&#34;&gt;ETW Patching&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bypass ETW, by patching in memory with &lt;code&gt;ret&lt;/code&gt; on &lt;code&gt;NtTraceControl&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/network&#34;&gt;Network&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;TCP, HTTP, and named pipes servers and clients for different communication channels.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/wmi/wmi.go&#34;&gt;WMI Query&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;List the AV/EDR solution with a wmi query&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/srdi/srdi.go&#34;&gt;sRDI&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Convert DLL files to position independent shellcode&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/crypto&#34;&gt;Cryptography&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Encryption algorithms for various usage. Contains AES, RC4, chacha20 and xor.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/self_remove/self_remove.go&#34;&gt;Self Remove&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Self remove a executable. Golang implementation of &lt;a href=&#34;https://github.com/LloydLabs/delete-self-poc&#34;&gt;delete-self-poc&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/process_dump/process_dump.go&#34;&gt;Process Dump&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Dump any process with &lt;code&gt;MiniDumpWriteDump&lt;/code&gt;. In this example, it dumps LSASS&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/dll_main&#34;&gt;Dllmain&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;DllMain()&lt;/code&gt; entrypoint in Golang from &lt;a href=&#34;https://gist.github.com/NaniteFactory/7a82b68e822b7d2de44037d6e7511734&#34;&gt;this&lt;/a&gt;. Can be used for dll hijacking.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/token&#34;&gt;Token Manipulation&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Play with windows token. List all the token, &lt;code&gt;ImpersonateLoggedOnUser&lt;/code&gt; and &lt;code&gt;CreateProcessWithToken&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/sandbox&#34;&gt;Sandbox detection/evasion&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sandbox detection and evasion techniques&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/callback_injection&#34;&gt;Callback Injection&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Callback shellcode injection using &lt;code&gt;GrayStringA&lt;/code&gt;, &lt;code&gt;EnumFonts&lt;/code&gt; and more...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Enelg52/OffensiveGo/main/instrumentation_callback&#34;&gt;Instrumentation Callback&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Disable Instrumentation Callback on your process to reduce any potential direct syscall detection&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; : The &lt;a href=&#34;https://github.com/RistBS/OffensiveGo/tree/main/misc&#34;&gt;misc&lt;/a&gt; folder contains some scripts like &lt;a href=&#34;https://github.com/RistBS/OffensiveGo/raw/main/misc/convert_to_golang_shellcode_format.sh&#34;&gt;convert_to_golang_shellcode_format.sh&lt;/a&gt; that can be written in other languages but but still relates to the Golang language.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; : More Examples will be added in the future :D&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;🔎 Interesting Tools in Golang&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/darkr4y/geacon&#34;&gt;Geacon&lt;/a&gt; : implementation of CobaltStrike&#39;s Beacon in Go.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/f1zm0/acheron&#34;&gt;Acheron&lt;/a&gt; : Indirect syscalls for AV/EDR evasion in Go assembly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/BishopFox/sliver&#34;&gt;Sliver&lt;/a&gt; : An Adversary Emulation Framework fully written in Golang with advanced evasion capabilities.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Ne0nd0g/merlin&#34;&gt;Merlin&lt;/a&gt; : cross-platform post-exploitation HTTP/2 Command &amp;amp; Control server and agent&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/C-Sto/BananaPhone&#34;&gt;BananaPhone&lt;/a&gt; : An easy to use GO variant of &lt;a href=&#34;https://github.com/am0nsec/HellsGate&#34;&gt;Hells gate&lt;/a&gt; with automatic SSN parsing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Tylous/SourcePoint&#34;&gt;SourcePoint&lt;/a&gt; : C2 profile generator for Cobalt Strike command and control servers designed to ensure evasion by reducing the Indicators of Compromise IoCs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/optiv/ScareCrow&#34;&gt;ScareCrow&lt;/a&gt; : Payload creation framework designed around EDR bypass such as AMSI &amp;amp; ETW Bypass, Encryption, Stealth Process Injections, ect.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/D3Ext/Hooka&#34;&gt;Hooka&lt;/a&gt; : Implant drop-in with multiple features.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wikiZ/RedGuard&#34;&gt;RedGuard&lt;/a&gt; : a C2 front flow control tool, Can avoid Blue Teams, AVs, EDRs check.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/optiv/Freeze&#34;&gt;Freeze&lt;/a&gt; : Payload toolkit for bypassing EDRs using suspended processes, direct syscalls, and alternative execution methods.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/optiv/Mangle&#34;&gt;Mangle&lt;/a&gt; : A tool that manipulates aspects of compiled executables (.exe or DLL) to avoid detection from EDRs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/optiv/Dent&#34;&gt;Dent&lt;/a&gt; : A framework for creating COM-based bypasses utilizing vulnerabilities in Microsoft&#39;s WDAPT sensors.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/optiv/Ivy&#34;&gt;Ivy&lt;/a&gt; : Payload creation framework for the execution of arbitrary VBA (macro) source code directly in memory. Ivy’s loader does this by utilizing programmatical access in the VBA object environment to load, decrypt and execute shellcode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I would also mention the &lt;a href=&#34;https://github.com/timwhitez/&#34;&gt;timwhitez&#39;s github&lt;/a&gt; that contains many re-implementations in Golang.&lt;/p&gt; &#xA;&lt;h2&gt;🎖 Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/joff_thyer&#34;&gt;@joff_thyer&lt;/a&gt; - &lt;a href=&#34;https://www.youtube.com/watch?v=gH9qyHVc9-M&amp;amp;t=1131s&amp;amp;ab_channel=BlackHillsInformationSecurity&#34;&gt;https://www.youtube.com/watch?v=gH9qyHVc9-M&amp;amp;t=1131s&amp;amp;ab_channel=BlackHillsInformationSecurity&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/BlueSentinelSec&#34;&gt;@BlueSentinelSec&lt;/a&gt; - &lt;a href=&#34;https://github.com/bluesentinelsec/OffensiveGoLang/raw/master/Offensive%20GoLang%202.0%20-%20SANS%20Pen%20Test%20HackFest%202021.pdf&#34;&gt;https://github.com/bluesentinelsec/OffensiveGoLang/blob/master/Offensive%20GoLang%202.0%20-%20SANS%20Pen%20Test%20HackFest%202021.pdf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/zimnyaatishina&#34;&gt;@zimnyaatishina&lt;/a&gt; - &lt;a href=&#34;https://tishina.in/execution/golang-winmaldev-basics&#34;&gt;https://tishina.in/execution/golang-winmaldev-basics&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>alin-io/pkgstore</title>
    <updated>2023-11-13T01:30:23Z</updated>
    <id>tag:github.com,2023-11-13:/alin-io/pkgstore</id>
    <link href="https://github.com/alin-io/pkgstore" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Package Proxy is an All in One server that handles Packages for NPM, PyPi, Docker/Containers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UVyOgq8.png&#34; alt=&#34;Alin.io Package Store UI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://Alin.io&#34;&gt;Alin.io&lt;/a&gt; pkgstore is a simple NPM and Pypi registry server, which also acts as a proxy to the generic public registries. It is built for easy maintainability and performance.&lt;/p&gt; &#xA;&lt;p&gt;pkgstore is built with an extendable structure that allows adding more storage backends or databases to keep the package metadata information. Currently, by default, the storage backend is an AWS S3 bucket or Minio Bucket if you have a self-hosted environment.&lt;/p&gt; &#xA;&lt;p&gt;The database is a simple SQLite file, which is configurable from the environment variable of &lt;code&gt;DATABASE_URL&lt;/code&gt;, and it acts as a database type selector based on the given database URL prefix, like if you have a &lt;code&gt;postgresql://...&lt;/code&gt; then the database instance will act with a PostgreSQL driver. Otherwise, it will fall back to SQLite. You can see how it&#39;s done in &lt;a href=&#34;https://github.com/alin-io/pkgstore/raw/79af6bbff49be70c394277473655b7fd5618bced/docker-compose.yaml#L10-L10&#34;&gt;&lt;code&gt;docker-compose.yaml&lt;/code&gt; file&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/aY365Pa.png&#34; alt=&#34;Alin.io Package Store UI&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Running Locally with Go&lt;/h2&gt; &#xA;&lt;p&gt;This is a standard Golang Gin project and all the dependencies are inside &lt;code&gt;go.mod&lt;/code&gt; and &lt;code&gt;go.sum&lt;/code&gt; files. So you can run it with the following steps:&lt;/p&gt; &#xA;&lt;h4&gt;1. Install Go Dependencies&lt;/h4&gt; &#xA;&lt;p&gt;Command below is going to download Go dependencies and put them inside &lt;code&gt;vendor&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go mod download&#xA;go mod vendor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2. Build the UI Project&lt;/h4&gt; &#xA;&lt;p&gt;We have a React.js based UI inside &lt;code&gt;ui&lt;/code&gt; folder to list the available packages and their versions. You can build the UI project with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ui&#xA;npm install&#xA;npm run build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will build the &lt;code&gt;Vite React TypeScript&lt;/code&gt; project and will copy all the bundles to the &lt;code&gt;cmd/server/ui&lt;/code&gt; folder, which will then get bundled with the Go binary. So that at the end, we should have a single binary with the UI inside it.&lt;/p&gt; &#xA;&lt;h4&gt;3. Run the Project&lt;/h4&gt; &#xA;&lt;p&gt;Finally, after having the UI built and Go dependencies installed, we can run the project with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go run ./cmd/server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;OR, we can just build the final binary and run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build -o pkgstore ./cmd/server&#xA;&#xA;./pkgstore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running with Docker&lt;/h2&gt; &#xA;&lt;p&gt;We have a &lt;code&gt;docker-compose.yaml&lt;/code&gt; file that you can use to run the project with Docker. It will run the following services:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pkgstore&lt;/code&gt;: The main pkgstore service&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;minio&lt;/code&gt;: A self-hosted S3 compatible storage service&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;postgres&lt;/code&gt;: A PostgreSQL database service&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; for Docker-Compose based configuration we are using PostgreSQL database, which makes it easier to run the project with Docker. But you can change the database URL to any other database type, like MySQL, SQLite, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose build&#xA;docker-compose up&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>