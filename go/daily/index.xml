<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Go Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-30T01:35:59Z</updated>
  <subtitle>Daily Trending of Go in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Mob2003/rakshasa</title>
    <updated>2023-03-30T01:35:59Z</updated>
    <id>tag:github.com,2023-03-30:/Mob2003/rakshasa</id>
    <link href="https://github.com/Mob2003/rakshasa" rel="alternate"></link>
    <summary type="html">&lt;p&gt;基于go编写的跨平台、稳定、隐秘的多级代理内网穿透工具&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rakshasa&lt;/h1&gt; &#xA;&lt;p&gt;rakshasa是一个使用Go语言编写的强大多级代理工具，专为实现&lt;strong&gt;多级代理&lt;/strong&gt;，&lt;strong&gt;内网穿透&lt;/strong&gt;而设计。它可以在节点群里面任意两个节点之间转发TCP请求和响应，同时支持&lt;strong&gt;socks5代理&lt;/strong&gt;，&lt;strong&gt;http代理&lt;/strong&gt;，并且可以&lt;strong&gt;引入外部http、socks5代理池，自动切换请求IP&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;p&gt;节点之间使用内置证书的TLS加密TCP通讯，再叠加一层自定义秘钥的AES加密，可以在所有Go支持的平台使用。可以在你所有的的Windows和Linux服务器上搭建节点并组成节点群网络。&lt;/p&gt; &#xA;&lt;h2&gt;更多使用方法和截图&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mob2003/rakshasa/main/readme/rakshasa%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1.md&#34;&gt;点击查看更多介绍&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mob2003/rakshasa/main/readme/rakshasa%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F--win10%2BProxifier%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B.md&#34;&gt;内网穿透--win10+Proxifier使用案例&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;编译与使用&lt;/h2&gt; &#xA;&lt;p&gt;首先生成证书：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd gencert&#xA;go run main.go&#xA;cd ../&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;也可以使用其他工具生成证书，将 server.crt 和 server.key 放到 cert 目录下。然后再编译rakshasa&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在 Windows 下使用cmd跨平台编译 Linux 示例：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd gencert&#xA;go run main.go&#xA;cd ../&#xA;set GOOS=linux&#xA;go build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;使用图示&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/128351726/226882870-f4f3cbc0-61df-486c-afc0-511d87586402.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;使用方法&lt;/h2&gt; &#xA;&lt;h3&gt;启动一个带CLI节点&lt;/h3&gt; &#xA;&lt;p&gt;不带任何参数即可启动：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;d:\&amp;gt;rakshasa.exe&#xA;start on port: 8883&#xA;rakshasa&amp;gt;&#xA;rakshasa&amp;gt;help&#xA;&#xA;Commands:&#xA;  bind              进入bind功能&#xA;  clear             clear the screen&#xA;  config            配置管理&#xA;  connect           进入connect功能&#xA;  exit              exit the program&#xA;  help              display help&#xA;  httpproxy         进入httpProxy功能&#xA;  new               与一个或者多个节点连接，使用方法 new ip:端口 多个地址以,间隔 如1080 127.0.0.1:1081,127.0.0.1:1082&#xA;  ping              ping 节点&#xA;  print             列出所有节点&#xA;  remoteshell       远程shell&#xA;  remotesocks5      进入remotesocks5功能&#xA;  shellcode         执行shellcode&#xA;  socks5            进入socks5功能&#xA;&#xA;&#xA;rakshasa&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;请查阅&lt;a href=&#34;https://raw.githubusercontent.com/Mob2003/rakshasa/main/readme/cli.md&#34;&gt;CLI使用说明&lt;/a&gt;了解详细信息&lt;/p&gt; &#xA;&lt;h2&gt;其他启动参数说明&lt;/h2&gt; &#xA;&lt;h3&gt;-nocli&lt;/h3&gt; &#xA;&lt;p&gt;在无法后台执行的情况下，启动一个不带 CLI 的节点:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nohup /root/rakshasa -nocli &amp;gt; /root/rakshasa.log 2&amp;gt;&amp;amp;1 &amp;amp;&#xA;#Linux下配合nohup后台执行&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-p 端口&lt;/h3&gt; &#xA;&lt;p&gt;以指定端口启动:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -p 8883&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-d ip:port,ip:port...&lt;/h3&gt; &#xA;&lt;p&gt;连接下一层代理或更多层代理，多个地址以逗号隔开，生效在最后一个 ip:port：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -d 192.168.1.1:8883,192.168.1.2:8883,192.168.1.3:8883 -socks5 1080&#xA;#从本地1080端口启动一个socks5代理，流量通过三层转发ip最后在192.168.1.3请求目标数据&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-socks5 用户名:密码@ip:端口&lt;/h3&gt; &#xA;&lt;p&gt;本地开启SOCKS5代理穿透到远程节点，可以不带-d：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -socks5 1080 &#xA;#不使用-d参数，则表示直接在本机启动一个socks5代理&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-remotesocks5 端口&lt;/h3&gt; &#xA;&lt;p&gt;远程开启SOCKS5代理流量出口到本地：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -remotesocks5 1081  -d 192.168.1.2:1080,192.168.1.3:1080&#xA;#方向从右往左(加上本机是3个节点)，在192.168.1.3这台机器开启一个socks5端口1081，流量穿透到本地节点出去&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-connect ip:port,remote_ip:remote_port&lt;/h3&gt; &#xA;&lt;p&gt;本地监听并转发到指定 IP 端口，使用场景为本机连接 teamserver，隐藏本机 IP：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -connect 127.0.0.1:50050,192,168,1,2:50050 -d 192.168.1.3:1080,192.168.1.4:1080 &#xA;#本机cs连接127.0.0.1:50050实际上通过1.3,1.4节点后，再连接到192.168.1.2:50050 teamserver，teamserver看到你的ip是最后一个节点的ip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-bind ip:port,remote_ip:remote_port&lt;/h3&gt; &#xA;&lt;p&gt;反向代理模式，必须配合-d使用：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -bind 192.168.1.2:50050,0,0,0.0:50050 -d 192.168.1.3:1080,192.168.1.4:1080&#xA;#与上面相反，在最右端节点监听端口50050，流量到本机节点后，最终发往192.168.1.2，最终上线ip为本机ip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-http_proxy 用户名:密码@ip:端口&lt;/h3&gt; &#xA;&lt;p&gt;启动一个http代理，可以不使用-d，建议配合-http_proxy_pool使用代理池，自动切换代理ip：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -http_proxy 8080 -http_proxy_pool out.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-password 密钥&lt;/h3&gt; &#xA;&lt;p&gt;各节点除了证书校验之外，还额外支持密钥连接，建议使用并定期更换密钥，以避免二进制泄露后被别人连上&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rakshasa -password 123456&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;-f yaml文件 &lt;a href=&#34;https://raw.githubusercontent.com/Mob2003/rakshasa/main/readme/config.md&#34;&gt;详细说明&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;指定配置文件启动。&lt;/p&gt; &#xA;&lt;h3&gt;-help&lt;/h3&gt; &#xA;&lt;p&gt;更多启动参数使用帮助&lt;/p&gt; &#xA;&lt;h2&gt;关于开源&lt;/h2&gt; &#xA;&lt;p&gt;本作品使用MPL 2.0许可证，您可以下载、修改和使用本代码。然而，您必须明确表示，任何此类担保、支持、赔偿或责任义务均由您单独提供，与本作者无关。本人不承担您在使用或修改本程序所造成的任何后果或责任。&lt;/p&gt; &#xA;&lt;p&gt;在遵循MPL 2.0许可证的基础上，您可以自由地对rakshasa进行修改和扩展，以满足您的特定需求。同时，您可以将改进和新功能贡献给社区，让更多人受益。但请注意，确保在分享和发布修改后的代码时遵守许可证要求，并尊重原作者的版权。&lt;/p&gt; &#xA;&lt;h2&gt;联系方式&lt;/h2&gt; &#xA;&lt;p&gt;联系我加入微信群聊&lt;/p&gt; &#xA;&lt;p&gt;QQ: 2252233695&lt;/p&gt; &#xA;&lt;p&gt;WeChat/微信: Mob20045&lt;/p&gt; &#xA;&lt;h2&gt;知识星球&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/128351726/226802981-64c09047-a78c-4e7f-b48d-7bfa5439ec5f.jpg&#34; alt=&#34;5d5003546e6618b7c40dc8946963ec7&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>securego/gosec</title>
    <updated>2023-03-30T01:35:59Z</updated>
    <id>tag:github.com,2023-03-30:/securego/gosec</id>
    <link href="https://github.com/securego/gosec" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Golang security checker&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gosec - Golang Security Checker&lt;/h1&gt; &#xA;&lt;p&gt;Inspects source code for security problems by scanning the Go AST.&lt;/p&gt; &#xA;&lt;img src=&#34;https://securego.io/img/gosec.png&#34; width=&#34;320&#34;&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;). You may not use this file except in compliance with the License. You may obtain a copy of the License &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project status&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bestpractices.coreinfrastructure.org/projects/3218&#34;&gt;&lt;img src=&#34;https://bestpractices.coreinfrastructure.org/projects/3218/badge&#34; alt=&#34;CII Best Practices&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/securego/gosec/actions?query=workflows%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/securego/gosec/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/securego/gosec&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/securego/gosec/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/securego/gosec&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/securego/gosec&#34; alt=&#34;GoReport&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/securego/gosec/v2&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/securego/gosec/v2&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://securego.io/&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/docs/badge/?version=latest&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/securego/gosec/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/securego/gosec/total.svg?sanitize=true&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/securego/gosec/tags&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/securego/gosec.svg?sanitize=true&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://securego.slack.com&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Slack-4A154B?style=for-the-badge&amp;amp;logo=slack&amp;amp;logoColor=white&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;h3&gt;CI Installation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# binary will be $(go env GOPATH)/bin/gosec&#xA;curl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s -- -b $(go env GOPATH)/bin vX.Y.Z&#xA;&#xA;# or install it into ./bin/&#xA;curl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s vX.Y.Z&#xA;&#xA;# In alpine linux (as it does not come with curl by default)&#xA;wget -O - -q https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s vX.Y.Z&#xA;&#xA;# If you want to use the checksums provided on the &#34;Releases&#34; page&#xA;# then you will have to download a tar.gz file for your operating system instead of a binary file&#xA;wget https://github.com/securego/gosec/releases/download/vX.Y.Z/gosec_vX.Y.Z_OS.tar.gz&#xA;&#xA;# The file will be in the current folder where you run the command&#xA;# and you can check the checksum like this&#xA;echo &#34;&amp;lt;check sum from the check sum file&amp;gt;  gosec_vX.Y.Z_OS.tar.gz&#34; | sha256sum -c -&#xA;&#xA;gosec --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GitHub Action&lt;/h3&gt; &#xA;&lt;p&gt;You can run &lt;code&gt;gosec&lt;/code&gt; as a GitHub action as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: Run Gosec&#xA;on:&#xA;  push:&#xA;    branches:&#xA;      - master&#xA;  pull_request:&#xA;    branches:&#xA;      - master&#xA;jobs:&#xA;  tests:&#xA;    runs-on: ubuntu-latest&#xA;    env:&#xA;      GO111MODULE: on&#xA;    steps:&#xA;      - name: Checkout Source&#xA;        uses: actions/checkout@v2&#xA;      - name: Run Gosec Security Scanner&#xA;        uses: securego/gosec@master&#xA;        with:&#xA;          args: ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Integrating with code scanning&lt;/h3&gt; &#xA;&lt;p&gt;You can &lt;a href=&#34;https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/integrating-with-code-scanning&#34;&gt;integrate third-party code analysis tools&lt;/a&gt; with GitHub code scanning by uploading data as SARIF files.&lt;/p&gt; &#xA;&lt;p&gt;The workflow shows an example of running the &lt;code&gt;gosec&lt;/code&gt; as a step in a GitHub action workflow which outputs the &lt;code&gt;results.sarif&lt;/code&gt; file. The workflow then uploads the &lt;code&gt;results.sarif&lt;/code&gt; file to GitHub using the &lt;code&gt;upload-sarif&lt;/code&gt; action.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: &#34;Security Scan&#34;&#xA;&#xA;# Run workflow each time code is pushed to your repository and on a schedule.&#xA;# The scheduled workflow runs every at 00:00 on Sunday UTC time.&#xA;on:&#xA;  push:&#xA;  schedule:&#xA;  - cron: &#39;0 0 * * 0&#39;&#xA;&#xA;jobs:&#xA;  tests:&#xA;    runs-on: ubuntu-latest&#xA;    env:&#xA;      GO111MODULE: on&#xA;    steps:&#xA;      - name: Checkout Source&#xA;        uses: actions/checkout@v2&#xA;      - name: Run Gosec Security Scanner&#xA;        uses: securego/gosec@master&#xA;        with:&#xA;          # we let the report trigger content trigger a failure using the GitHub Security features.&#xA;          args: &#39;-no-fail -fmt sarif -out results.sarif ./...&#39;&#xA;      - name: Upload SARIF file&#xA;        uses: github/codeql-action/upload-sarif@v1&#xA;        with:&#xA;          # Path to SARIF file relative to the root of the repository&#xA;          sarif_file: results.sarif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Local Installation&lt;/h3&gt; &#xA;&lt;h4&gt;Go 1.16+&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install github.com/securego/gosec/v2/cmd/gosec@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Go version &amp;lt; 1.16&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get -u github.com/securego/gosec/v2/cmd/gosec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Gosec can be configured to only run a subset of rules, to exclude certain file paths, and produce reports in different formats. By default all rules will be run against the supplied input files. To recursively scan from the current directory you can supply &lt;code&gt;./...&lt;/code&gt; as the input argument.&lt;/p&gt; &#xA;&lt;h3&gt;Available rules&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;G101: Look for hard coded credentials&lt;/li&gt; &#xA; &lt;li&gt;G102: Bind to all interfaces&lt;/li&gt; &#xA; &lt;li&gt;G103: Audit the use of unsafe block&lt;/li&gt; &#xA; &lt;li&gt;G104: Audit errors not checked&lt;/li&gt; &#xA; &lt;li&gt;G106: Audit the use of ssh.InsecureIgnoreHostKey&lt;/li&gt; &#xA; &lt;li&gt;G107: Url provided to HTTP request as taint input&lt;/li&gt; &#xA; &lt;li&gt;G108: Profiling endpoint automatically exposed on /debug/pprof&lt;/li&gt; &#xA; &lt;li&gt;G109: Potential Integer overflow made by strconv.Atoi result conversion to int16/32&lt;/li&gt; &#xA; &lt;li&gt;G110: Potential DoS vulnerability via decompression bomb&lt;/li&gt; &#xA; &lt;li&gt;G111: Potential directory traversal&lt;/li&gt; &#xA; &lt;li&gt;G112: Potential slowloris attack&lt;/li&gt; &#xA; &lt;li&gt;G113: Usage of Rat.SetString in math/big with an overflow (CVE-2022-23772)&lt;/li&gt; &#xA; &lt;li&gt;G114: Use of net/http serve function that has no support for setting timeouts&lt;/li&gt; &#xA; &lt;li&gt;G201: SQL query construction using format string&lt;/li&gt; &#xA; &lt;li&gt;G202: SQL query construction using string concatenation&lt;/li&gt; &#xA; &lt;li&gt;G203: Use of unescaped data in HTML templates&lt;/li&gt; &#xA; &lt;li&gt;G204: Audit use of command execution&lt;/li&gt; &#xA; &lt;li&gt;G301: Poor file permissions used when creating a directory&lt;/li&gt; &#xA; &lt;li&gt;G302: Poor file permissions used with chmod&lt;/li&gt; &#xA; &lt;li&gt;G303: Creating tempfile using a predictable path&lt;/li&gt; &#xA; &lt;li&gt;G304: File path provided as taint input&lt;/li&gt; &#xA; &lt;li&gt;G305: File traversal when extracting zip/tar archive&lt;/li&gt; &#xA; &lt;li&gt;G306: Poor file permissions used when writing to a new file&lt;/li&gt; &#xA; &lt;li&gt;G401: Detect the usage of DES, RC4, MD5 or SHA1&lt;/li&gt; &#xA; &lt;li&gt;G402: Look for bad TLS connection settings&lt;/li&gt; &#xA; &lt;li&gt;G403: Ensure minimum RSA key length of 2048 bits&lt;/li&gt; &#xA; &lt;li&gt;G404: Insecure random number source (rand)&lt;/li&gt; &#xA; &lt;li&gt;G501: Import blocklist: crypto/md5&lt;/li&gt; &#xA; &lt;li&gt;G502: Import blocklist: crypto/des&lt;/li&gt; &#xA; &lt;li&gt;G503: Import blocklist: crypto/rc4&lt;/li&gt; &#xA; &lt;li&gt;G504: Import blocklist: net/http/cgi&lt;/li&gt; &#xA; &lt;li&gt;G505: Import blocklist: crypto/sha1&lt;/li&gt; &#xA; &lt;li&gt;G601: Implicit memory aliasing of items from a range statement&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Retired rules&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;G105: Audit the use of math/big.Int.Exp - &lt;a href=&#34;https://github.com/golang/go/issues/15184&#34;&gt;CVE is fixed&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;G307: Deferring a method which returns an error - causing more inconvenience than fixing a security issue, despite the details from this &lt;a href=&#34;https://www.joeshaw.org/dont-defer-close-on-writable-files/&#34;&gt;blog post&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Selecting rules&lt;/h3&gt; &#xA;&lt;p&gt;By default, gosec will run all rules against the supplied file paths. It is however possible to select a subset of rules to run via the &lt;code&gt;-include=&lt;/code&gt; flag, or to specify a set of rules to explicitly exclude using the &lt;code&gt;-exclude=&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Run a specific set of rules&#xA;$ gosec -include=G101,G203,G401 ./...&#xA;&#xA;# Run everything except for rule G303&#xA;$ gosec -exclude=G303 ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CWE Mapping&lt;/h3&gt; &#xA;&lt;p&gt;Every issue detected by &lt;code&gt;gosec&lt;/code&gt; is mapped to a &lt;a href=&#34;http://cwe.mitre.org/data/index.html&#34;&gt;CWE (Common Weakness Enumeration)&lt;/a&gt; which describes in more generic terms the vulnerability. The exact mapping can be found &lt;a href=&#34;https://github.com/securego/gosec/raw/master/issue/issue.go#L50&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;A number of global settings can be provided in a configuration file as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{&#xA;    &#34;global&#34;: {&#xA;        &#34;nosec&#34;: &#34;enabled&#34;,&#xA;        &#34;audit&#34;: &#34;enabled&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nosec&lt;/code&gt;: this setting will overwrite all &lt;code&gt;#nosec&lt;/code&gt; directives defined throughout the code base&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;audit&lt;/code&gt;: runs in audit mode which enables addition checks that for normal code analysis might be too nosy&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Run with a global configuration file&#xA;$ gosec -conf config.json .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also some rules accept configuration. For instance on rule &lt;code&gt;G104&lt;/code&gt;, it is possible to define packages along with a list of functions which will be skipped when auditing the not checked errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{&#xA;    &#34;G104&#34;: {&#xA;        &#34;ioutil&#34;: [&#34;WriteFile&#34;]&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also configure the hard-coded credentials rule &lt;code&gt;G101&lt;/code&gt; with additional patterns, or adjust the entropy threshold:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{&#xA;    &#34;G101&#34;: {&#xA;        &#34;pattern&#34;: &#34;(?i)passwd|pass|password|pwd|secret|private_key|token&#34;,&#xA;         &#34;ignore_entropy&#34;: false,&#xA;         &#34;entropy_threshold&#34;: &#34;80.0&#34;,&#xA;         &#34;per_char_threshold&#34;: &#34;3.0&#34;,&#xA;         &#34;truncate&#34;: &#34;32&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;gosec will fetch automatically the dependencies of the code which is being analyzed when go module is turned on (e.g.&lt;code&gt;GO111MODULE=on&lt;/code&gt;). If this is not the case, the dependencies need to be explicitly downloaded by running the &lt;code&gt;go get -d&lt;/code&gt; command before the scan.&lt;/p&gt; &#xA;&lt;h3&gt;Excluding test files and folders&lt;/h3&gt; &#xA;&lt;p&gt;gosec will ignore test files across all packages and any dependencies in your vendor directory.&lt;/p&gt; &#xA;&lt;p&gt;The scanning of test files can be enabled with the following flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gosec -tests ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also additional folders can be excluded as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; gosec -exclude-dir=rules -exclude-dir=cmd ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Excluding generated files&lt;/h3&gt; &#xA;&lt;p&gt;gosec can ignore generated go files with default generated code comment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Code generated by some generator DO NOT EDIT.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gosec -exclude-generated ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Annotating code&lt;/h3&gt; &#xA;&lt;p&gt;As with all automated detection tools, there will be cases of false positives. In cases where gosec reports a failure that has been manually verified as being safe, it is possible to annotate the code with a comment that starts with &lt;code&gt;#nosec&lt;/code&gt;. The &lt;code&gt;#nosec&lt;/code&gt; comment should have the format &lt;code&gt;#nosec [RuleList] [-- Justification]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The annotation causes gosec to stop processing any further nodes within the AST so can apply to a whole block or more granularly to a single expression.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#xA;import &#34;md5&#34; //#nosec&#xA;&#xA;&#xA;func main(){&#xA;&#xA;    /* #nosec */&#xA;    if x &amp;gt; y {&#xA;        h := md5.New() // this will also be ignored&#xA;    }&#xA;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When a specific false positive has been identified and verified as safe, you may wish to suppress only that single rule (or a specific set of rules) within a section of code, while continuing to scan for other problems. To do this, you can list the rule(s) to be suppressed within the &lt;code&gt;#nosec&lt;/code&gt; annotation, e.g: &lt;code&gt;/* #nosec G401 */&lt;/code&gt; or &lt;code&gt;//#nosec G201 G202 G203&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You could put the description or justification text for the annotation. The justification should be after the rule(s) to suppress and start with two or more dashes, e.g: &lt;code&gt;//#nosec G101 G102 -- This is a false positive&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;In some cases you may also want to revisit places where &lt;code&gt;#nosec&lt;/code&gt; annotations have been used. To run the scanner and ignore any &lt;code&gt;#nosec&lt;/code&gt; annotations you can do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gosec -nosec=true ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tracking suppressions&lt;/h3&gt; &#xA;&lt;p&gt;As described above, we could suppress violations externally (using &lt;code&gt;-include&lt;/code&gt;/ &lt;code&gt;-exclude&lt;/code&gt;) or inline (using &lt;code&gt;#nosec&lt;/code&gt; annotations) in gosec. This suppression inflammation can be used to generate corresponding signals for auditing purposes.&lt;/p&gt; &#xA;&lt;p&gt;We could track suppressions by the &lt;code&gt;-track-suppressions&lt;/code&gt; flag as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gosec -track-suppressions -exclude=G101 -fmt=sarif -out=results.sarif ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For external suppressions, gosec records suppression info where &lt;code&gt;kind&lt;/code&gt; is &lt;code&gt;external&lt;/code&gt; and &lt;code&gt;justification&lt;/code&gt; is a certain sentence &#34;Globally suppressed&#34;.&lt;/li&gt; &#xA; &lt;li&gt;For inline suppressions, gosec records suppression info where &lt;code&gt;kind&lt;/code&gt; is &lt;code&gt;inSource&lt;/code&gt; and &lt;code&gt;justification&lt;/code&gt; is the text after two or more dashes in the comment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Only SARIF and JSON formats support tracking suppressions.&lt;/p&gt; &#xA;&lt;h3&gt;Build tags&lt;/h3&gt; &#xA;&lt;p&gt;gosec is able to pass your &lt;a href=&#34;https://golang.org/pkg/go/build/&#34;&gt;Go build tags&lt;/a&gt; to the analyzer. They can be provided as a comma separated list as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gosec -tags debug,ignore ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Output formats&lt;/h3&gt; &#xA;&lt;p&gt;gosec currently supports &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;yaml&lt;/code&gt;, &lt;code&gt;csv&lt;/code&gt;, &lt;code&gt;sonarqube&lt;/code&gt;, &lt;code&gt;JUnit XML&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; and &lt;code&gt;golint&lt;/code&gt; output formats. By default results will be reported to stdout, but can also be written to an output file. The output format is controlled by the &lt;code&gt;-fmt&lt;/code&gt; flag, and the output file is controlled by the &lt;code&gt;-out&lt;/code&gt; flag as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Write output in json format to results.json&#xA;$ gosec -fmt=json -out=results.json *.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Results will be reported to stdout as well as to the provided output file by &lt;code&gt;-stdout&lt;/code&gt; flag. The &lt;code&gt;-verbose&lt;/code&gt; flag overrides the output format when stdout the results while saving them in the output file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Write output in json format to results.json as well as stdout&#xA;$ gosec -fmt=json -out=results.json -stdout *.go&#xA;&#xA;# Overrides the output format to &#39;text&#39; when stdout the results, while writing it to results.json&#xA;$ gosec -fmt=json -out=results.json -stdout -verbose=text *.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; gosec generates the &lt;a href=&#34;https://docs.sonarqube.org/latest/analysis/generic-issue/&#34;&gt;generic issue import format&lt;/a&gt; for SonarQube, and a report has to be imported into SonarQube using &lt;code&gt;sonar.externalIssuesReportPaths=path/to/gosec-report.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;p&gt;You can build the binary with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Note on Sarif Types Generation&lt;/h3&gt; &#xA;&lt;p&gt;Install the tool with :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get -u github.com/a-h/generate/cmd/schema-generate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then generate the types with :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;schema-generate -i sarif-schema-2.1.0.json -o mypath/types.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most of the MarshallJSON/UnmarshalJSON are removed except the one for PropertyBag which is handy to inline the additional properties. The rest can be removed. The URI,ID, UUID, GUID were renamed so it fits the Golang convention defined &lt;a href=&#34;https://github.com/golang/lint/raw/master/lint.go#L700&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;You can run all unit tests using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Release&lt;/h3&gt; &#xA;&lt;p&gt;You can create a release by tagging the version as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git tag v1.0.0 -m &#34;Release version v1.0.0&#34;&#xA;git push origin v1.0.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The GitHub &lt;a href=&#34;https://raw.githubusercontent.com/securego/gosec/master/.github/workflows/release.yml&#34;&gt;release workflow&lt;/a&gt; triggers immediately after the tag is pushed upstream. This flow will release the binaries using the &lt;a href=&#34;https://goreleaser.com/actions/&#34;&gt;goreleaser&lt;/a&gt; action and then it will build and publish the docker image into Docker Hub.&lt;/p&gt; &#xA;&lt;p&gt;The released artifacts are signed using &lt;a href=&#34;https://docs.sigstore.dev/&#34;&gt;cosign&lt;/a&gt;. You can use the public key from &lt;a href=&#34;https://raw.githubusercontent.com/securego/gosec/master/cosign.pub&#34;&gt;cosign.pub&lt;/a&gt; file to verify the signature of docker image and binaries files.&lt;/p&gt; &#xA;&lt;p&gt;The docker image signature can be verified with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cosign verify --key cosign.pub securego/gosec:&amp;lt;TAG&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The binary files signature can be verified with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cosign verify-blob --key cosign.pub --signature gosec_&amp;lt;VERSION&amp;gt;_darwin_amd64.tar.gz.sig  gosec_&amp;lt;VERSION&amp;gt;_darwin_amd64.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Docker image&lt;/h3&gt; &#xA;&lt;p&gt;You can also build locally the docker image by using the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make image&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run the &lt;code&gt;gosec&lt;/code&gt; tool in a container against your local Go project. You only have to mount the project into a volume as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm -it -w /&amp;lt;PROJECT&amp;gt;/ -v &amp;lt;YOUR PROJECT PATH&amp;gt;/&amp;lt;PROJECT&amp;gt;:/&amp;lt;PROJECT&amp;gt; securego/gosec /&amp;lt;PROJECT&amp;gt;/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the current working directory needs to be set with &lt;code&gt;-w&lt;/code&gt; option in order to get successfully resolved the dependencies from go module file&lt;/p&gt; &#xA;&lt;h3&gt;Generate TLS rule&lt;/h3&gt; &#xA;&lt;p&gt;The configuration of TLS rule can be generated from &lt;a href=&#34;https://statics.tls.security.mozilla.org/server-side-tls-conf.json&#34;&gt;Mozilla&#39;s TLS ciphers recommendation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First you need to install the generator tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get github.com/securego/gosec/v2/cmd/tlsconfig/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can invoke now the &lt;code&gt;go generate&lt;/code&gt; in the root of the project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go generate ./...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate the &lt;code&gt;rules/tls_config.go&lt;/code&gt; file which will contain the current ciphers recommendation from Mozilla.&lt;/p&gt; &#xA;&lt;h2&gt;Who is using gosec?&lt;/h2&gt; &#xA;&lt;p&gt;This is a &lt;a href=&#34;https://raw.githubusercontent.com/securego/gosec/master/USERS.md&#34;&gt;list&lt;/a&gt; with some of the gosec&#39;s users.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;Support this project by becoming a sponsor. Your logo will show up here with a link to your website&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mercedes-benz&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://avatars.githubusercontent.com/u/34240465?s=80&amp;amp;v=4&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>szpnygo/VecTextSearch</title>
    <updated>2023-03-30T01:35:59Z</updated>
    <id>tag:github.com,2023-03-30:/szpnygo/VecTextSearch</id>
    <link href="https://github.com/szpnygo/VecTextSearch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;一个99%由ChatGPT开发的项目。A project that is 99% developed by ChatGPT.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;VecTextSearch&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/szpnygo/VecTextSearch&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/tag/szpnygo/VecTextSearch?label=version&#34; alt=&#34;version&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/issues/szpnygo/VecTextSearch&#34; alt=&#34;GitHub issues&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/forks/szpnygo/VecTextSearch&#34; alt=&#34;GitHub forks&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/szpnygo/VecTextSearch&#34; alt=&#34;GitHub stars&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/szpnygo/VecTextSearch&#34; alt=&#34;GitHub license&#34;&gt; &lt;img src=&#34;https://img.shields.io/docker/pulls/neosu/vec-text-search&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;VecTextSearch是一个使用OpenAI语言模型生成文本向量并在Weaviate数据库中进行高效搜索的项目。它允许用户将文本数据存储在Weaviate数据库中，并根据文本相似性快速搜索和检索相关文本。项目使用Golang编写，并提供一个简单的REST API供客户端调用&lt;/p&gt; &#xA;&lt;p&gt;简体中文 | &lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/README_en.md&#34;&gt;English&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;项目介绍&lt;/h2&gt; &#xA;&lt;p&gt;VecTextSearch 是一个使用 OpenAI 语言模型生成文本向量并在 Weaviate 数据库中进行高效搜索的项目。它允许用户将文本数据存储在 Weaviate 数据库中，并根据文本相似性快速搜索和检索相关文本。项目使用 Golang 编写，并提供一个简单的 REST API 供客户端调用。&lt;/p&gt; &#xA;&lt;h2&gt;聊天记录&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/history/chat1.md&#34;&gt;聊天记录1&lt;/a&gt; - 创建项目&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/history/chat2.md&#34;&gt;聊天记录2&lt;/a&gt; - 修改Dockerfile和Makefile&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/history/chat3.md&#34;&gt;聊天记录3&lt;/a&gt; - 简化向量搜索的返回结果，修改数据结构&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/history/chat4.md&#34;&gt;聊天记录4&lt;/a&gt; - 重构项目结构&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/history/chat5.md&#34;&gt;聊天记录5&lt;/a&gt; - 把ChatGPT的聊天对话直接下载为Markdown文件&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/history/chat6.md&#34;&gt;聊天记录6&lt;/a&gt; - 添加跨域支持，修复make run命令的错误&lt;/p&gt; &#xA;&lt;h2&gt;效果&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/images/postman.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;项目背景&lt;/h2&gt; &#xA;&lt;p&gt;在许多实际应用中，需要基于文本相似性进行快速搜索。例如，给定一篇文章，可以找到与其内容相似的其他文章。传统的基于关键词的搜索方法可能无法准确捕捉到文本之间的相似性。VecTextSearch 利用 OpenAI 的强大语言模型将文本转换为向量表示，然后使用 Weaviate 数据库进行高效的相似向量搜索。&lt;/p&gt; &#xA;&lt;h2&gt;用处与使用场景&lt;/h2&gt; &#xA;&lt;p&gt;VecTextSearch 可以应用于以下场景：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;为文章、博客、论文等寻找相关内容。&lt;/li&gt; &#xA; &lt;li&gt;实现智能问答系统，根据用户提问快速匹配到相关问题及答案。&lt;/li&gt; &#xA; &lt;li&gt;构建推荐系统，根据用户的阅读历史为其推荐相似文章。&lt;/li&gt; &#xA; &lt;li&gt;检测重复或抄袭的内容。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TODO 列表&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;开发演示应用程序&lt;/strong&gt;：创建一个用于直观展示 VecTextSearch 功能和用例的演示应用程序。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;添加数据管理接口&lt;/strong&gt;：为项目提供数据管理接口，方便用户管理存储在 Weaviate 数据库中的文本数据。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;开发用户友好的前端界面&lt;/strong&gt;：简化 VecTextSearch 的使用，为用户提供更好的体验。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;提供详细文档&lt;/strong&gt;：编写包括 API 参考、使用示例和教程在内的详细文档。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;提供更多配置选项&lt;/strong&gt;：允许用户根据需求调整 VecTextSearch 的性能和功能。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;添加单元测试和集成测试&lt;/strong&gt;：确保代码质量和稳定性。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;关注 OpenAI 语言模型的更新&lt;/strong&gt;：持续关注 OpenAI 语言模型的更新和改进，及时将最新技术应用于 VecTextSearch。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;开发插件或扩展系统&lt;/strong&gt;：允许用户根据需求自定义 VecTextSearch 的功能。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;接口介绍&lt;/h2&gt; &#xA;&lt;p&gt;VecTextSearch 提供了两个 REST API 接口：&lt;/p&gt; &#xA;&lt;h3&gt;添加文本&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;URL: /add-text&lt;/li&gt; &#xA; &lt;li&gt;Method: POST&lt;/li&gt; &#xA; &lt;li&gt;Content-Type: application/json&lt;/li&gt; &#xA; &lt;li&gt;Request Payload:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;name&#34;: &#34;文章名称&#34;,&#xA;  &#34;content&#34;: &#34;文章内容&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Response: 成功添加文本后，将返回一个包含文本 ID 的 JSON 对象。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: &#34;文章唯一标识符&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;搜索相似文本&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;URL: /search-similar-texts&lt;/li&gt; &#xA; &lt;li&gt;Method: POST&lt;/li&gt; &#xA; &lt;li&gt;Content-Type: application/json&lt;/li&gt; &#xA; &lt;li&gt;Request Payload:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;content&#34;: &#34;查询内容&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Response: 搜索成功后，将返回一个包含相似文本信息的 JSON 对象。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;data&#34;: [&#xA;    {&#xA;      &#34;id&#34;: &#34;文章唯一标识符&#34;,&#xA;      &#34;name&#34;: &#34;文章名称&#34;,&#xA;      &#34;content&#34;: &#34;文章内容&#34;,&#xA;      &#34;distance&#34;: &#34;与查询内容的距离&#34;,&#xA;      &#34;certainty&#34;: &#34;与查询内容的相似度&#34;&#xA;    },&#xA;    ...&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Makefile 功能说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;make init&lt;/code&gt;：创建 &lt;code&gt;.env&lt;/code&gt; 文件模板，用于配置环境变量。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make build&lt;/code&gt;：构建 Docker 镜像。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make push&lt;/code&gt;：将 Docker 镜像推送到 Docker Hub。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make run&lt;/code&gt;：在本地运行应用程序。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;启动Weaviate向量数据库&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \&#xA;  --name weaviate \&#xA;  -p 8888:8080 \&#xA;  --restart on-failure:0 \&#xA;  -e QUERY_DEFAULTS_LIMIT=25 \&#xA;  -e AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED=true \&#xA;  -e PERSISTENCE_DATA_PATH=&#39;/var/lib/weaviate&#39; \&#xA;  -e DEFAULT_VECTORIZER_MODULE=&#39;none&#39; \&#xA;  -e ENABLE_MODULES=&#39;&#39; \&#xA;  -e AUTOSCHEMA_ENABLED=true \&#xA;  -e CLUSTER_HOSTNAME=&#39;node1&#39; \&#xA;  semitechnologies/weaviate:1.18.1 \&#xA;  --host 0.0.0.0 \&#xA;  --port 8080 \&#xA;  --scheme http&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ChatGPT 转 Markdown Chrome 插件&lt;/h2&gt; &#xA;&lt;p&gt;ChatGPT 转 Markdown 是一个由 ChatGPT 开发的 Chrome 插件，旨在帮助用户轻松地将 ChatGPT 与 OpenAI 的对话记录下载为 Markdown 文件。生成的 Markdown 文件将包含整个对话内容，并在用户和助手之间进行明确区分。这款插件方便用户整理和查看聊天记录，提高工作效率。&lt;/p&gt; &#xA;&lt;p&gt;主要功能：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;在 ChatGPT 对话页面添加一个 &#34;下载 Markdown&#34; 按钮&lt;/li&gt; &#xA; &lt;li&gt;将整个对话记录转换为 Markdown 格式&lt;/li&gt; &#xA; &lt;li&gt;自动生成以 &#34;Neo&#34;（用户）和 &#34;ChatGPT&#34;（助手）为标题的聊天记录段落&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;详细说明和使用方法，请参考&lt;a href=&#34;https://raw.githubusercontent.com/szpnygo/VecTextSearch/main/history/extension/&#34;&gt;ChatGPT转Markdown插件&lt;/a&gt;文件。&lt;/p&gt; &#xA;&lt;h2&gt;开发与贡献&lt;/h2&gt; &#xA;&lt;p&gt;如果您想为 VecTextSearch 做出贡献或者对项目进行二次开发，您可以按照以下步骤操作：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;克隆本仓库到本地：&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/szpnygo/VecTextSearch.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;进入项目目录并安装相关依赖：&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd VecTextSearch&#xA;go get -u&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;在 config.yml 文件中填写正确的 OpenAI API 密钥。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;运行项目：&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go run main.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果您在使用 VecTextSearch 时遇到问题或者有新的想法和建议，欢迎提交 Issue 或 Pull Request。我们非常感谢您的贡献和支持！&lt;/p&gt; &#xA;&lt;h2&gt;许可证&lt;/h2&gt; &#xA;&lt;p&gt;VecTextSearch 采用 MIT 许可证。有关详细信息，请参阅 LICENSE 文件。&lt;/p&gt; &#xA;&lt;h2&gt;联系我们&lt;/h2&gt; &#xA;&lt;p&gt;如果您在使用 VecTextSearch 过程中遇到任何问题，请随时与我们联系。您可以通过以下方式联系我们：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;在 GitHub 仓库中提交 Issue&lt;/li&gt; &#xA; &lt;li&gt;发送电子邮件至：&lt;a href=&#34;mailto:st2udio@gmail.com&#34;&gt;st2udio@gmail.com&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>