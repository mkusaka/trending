<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-10T01:33:52Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>splitgraph/seafowl-gcsfuse</title>
    <updated>2023-06-10T01:33:52Z</updated>
    <id>tag:github.com,2023-06-10:/splitgraph/seafowl-gcsfuse</id>
    <link href="https://github.com/splitgraph/seafowl-gcsfuse" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scale to zero Seafowl hosting with Cloud Run&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;Scale to zero Seafowl via gcsfuse&lt;/h3&gt; &#xA;&lt;p&gt;Because &lt;a href=&#34;https://seafowl.io/&#34;&gt;Seafowl&lt;/a&gt; was architected with the cloud in mind it&#39;s a good candidate for serverless/&#39;scale to zero&#39; hosting e.g. Cloud Run and similar.&lt;/p&gt; &#xA;&lt;p&gt;Database objects can be stored in &lt;a href=&#34;https://seafowl.io/docs/reference/seafowl-toml-configuration#type--s3&#34;&gt;S3 buckets&lt;/a&gt;, which avoids depending on a persistent volume. Meanwhile Seafowl&#39;s catalog can be &lt;a href=&#34;https://seafowl.io/docs/reference/seafowl-toml-configuration#type--sqlite&#34;&gt;backed by SQLite&lt;/a&gt;, also good for the scale to zero story because it avoids the usual persistent Postgres process.&lt;/p&gt; &#xA;&lt;p&gt;Platforms like Lambda and Cloud Run will forward incoming HTTP requests to the waiting Seafowl service, which is the ideal time for it to fetch the up-to-date SQLite catalog so the query can be handled with fresh data.&lt;/p&gt; &#xA;&lt;p&gt;By adding &lt;a href=&#34;https://github.com/GoogleCloudPlatform/gcsfuse&#34;&gt;gcsfuse&lt;/a&gt; to the Seafowl container, the SQLite file is mounted from the bucket into the Seafowl container. While there is a performance penalty in doing so, the catalog is only metadata, not the raw database objects, so the penalty (at least observed so far) is negligible. Plus, so long as traffic is within the same region, GCP doesn&#39;t charge for bucket &amp;lt;-&amp;gt; Cloud Run traffic, an additional bonus for hosting costs.&lt;/p&gt; &#xA;&lt;h3&gt;How to use&lt;/h3&gt; &#xA;&lt;p&gt;Please check out &lt;a href=&#34;https://www.splitgraph.com/blog/deploying-serverless-seafowl&#34;&gt;blog post&lt;/a&gt; for the step by step details on how to set this up.&lt;/p&gt; &#xA;&lt;p&gt;In the end you&#39;ll have a bucket like this:&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/splitgraph/seafowl-gcsfuse/assets/182515/e9c1a8d2-8c5c-4bf8-a217-f78e56ad1300&#34; width=&#34;500&#34;&gt; &#xA;&lt;p&gt;and some endpoint similar to&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;https://seafowl-gcsfuse-YourEndpointHere.a.run.app/q&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;you can query from a browser, or your backend.&lt;/p&gt; &#xA;&lt;h3&gt;Steps&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Build the Docker image (or if you want, use the prebuilt image &lt;a href=&#34;https://hub.docker.com/r/splitgraph/seafowl-gcsfuse&#34;&gt;splitgraph/seafowl-gcsfuse&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Make it avaialble to Cloud Run (e.g. push to &lt;code&gt;hub.docker.com&lt;/code&gt; or your own repo)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.splitgraph.com/blog/deploying-serverless-seafowl&#34;&gt;Deploy&lt;/a&gt; a new Cloud Run instance using this image, including the secrets&lt;/li&gt; &#xA; &lt;li&gt;Test the endpoint using e.g. curl &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -i -H &#34;Content-Type: application/json&#34; \&#xA;-X POST &#34;https://your-endpoint-goes-here.a.run.app/q&#34; -d@- &amp;lt;&amp;lt;EOF&#xA;{&#34;query&#34;: &#34;&#xA;SELECT now()&#xA;&#34;}&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;What&#39;s in the repo&lt;/h3&gt; &#xA;&lt;p&gt;This repo provides a &lt;a href=&#34;https://raw.githubusercontent.com/splitgraph/seafowl-gcsfuse/master/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; which runs the &lt;a href=&#34;https://raw.githubusercontent.com/splitgraph/seafowl-gcsfuse/master/gcsfuse_run.sh&#34;&gt;gcsfuse_run.sh&lt;/a&gt; file at init time.&lt;/p&gt; &#xA;&lt;p&gt;If you want to try separate endpoints for readonly and read/write, two example config files (&lt;a href=&#34;https://raw.githubusercontent.com/splitgraph/seafowl-gcsfuse/master/configs/seafowl-ro.toml&#34;&gt;read-only&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/splitgraph/seafowl-gcsfuse/master/configs/seafowl.toml&#34;&gt;write-enabled&lt;/a&gt;) are provided. You could upload them as &lt;a href=&#34;https://cloud.google.com/secret-manager&#34;&gt;secrets&lt;/a&gt; which lets them be mounted into your Cloud Run instance&#39;s filesystem, similarly to FUSE. Or if you prefer to mount these configs some other way, or use env vars to avoid depending on Secret Manager, that&#39;s possible too.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>truecharts/containers</title>
    <updated>2023-06-10T01:33:52Z</updated>
    <id>tag:github.com,2023-06-10:/truecharts/containers</id>
    <link href="https://github.com/truecharts/containers" rel="alternate"></link>
    <summary type="html">&lt;p&gt;TrueCharts container repository&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Container Images&lt;/h1&gt; &#xA;&lt;p&gt;Images are hosted on Github Container Registry &lt;a href=&#34;https://github.com/orgs/truecharts/packages?ecosystem=container&amp;amp;visibility=public&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Mirror&lt;/h2&gt; &#xA;&lt;p&gt;We host a dedicated mirror repostiory, these containers are directly fetched from official and/or trusted sources.&lt;/p&gt; &#xA;&lt;h3&gt;Purpose&lt;/h3&gt; &#xA;&lt;p&gt;We host our own mirror for a multitude of reasons, which includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting around Docker Hub rate-limiting&lt;/li&gt; &#xA; &lt;li&gt;Preventing upstream maintainers removing tags from breaking our Apps&lt;/li&gt; &#xA; &lt;li&gt;Generating usage metrics&lt;/li&gt; &#xA; &lt;li&gt;Applying patches&lt;/li&gt; &#xA; &lt;li&gt;Improving code uniformity&lt;/li&gt; &#xA; &lt;li&gt;Allowing multi-registry failover&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>tarsisazevedo/ufam-db-tp3</title>
    <updated>2023-06-10T01:33:52Z</updated>
    <id>tag:github.com,2023-06-10:/tarsisazevedo/ufam-db-tp3</id>
    <link href="https://github.com/tarsisazevedo/ufam-db-tp3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;terceiro trabalho da turma 2023.1 de BD da UFAM&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ufam-db-tp3&lt;/h1&gt; &#xA;&lt;p&gt;Repositorio base para o Trabalho 3 de Banco de Dados da Graduação em Ciencia da Computação na UFAM &lt;a href=&#34;https://docs.google.com/document/d/17Uobq1brb6TbbCr64DWCEWG9J-LAGpgXuOC3BVpczx4/edit#&#34;&gt;Link do trabalho&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Copiando esse repositorio&lt;/h2&gt; &#xA;&lt;p&gt;Você deve ter uma conta no github, criar é gratis, e ele é essencial para a vida e carreira de você.&lt;/p&gt; &#xA;&lt;p&gt;Para fazer isso siga esses passos:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/118348/229365938-48d261c8-b569-463c-bc00-462eb218b423.mp4&#34;&gt;https://user-images.githubusercontent.com/118348/229365938-48d261c8-b569-463c-bc00-462eb218b423.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Para entender melhor &lt;a href=&#34;https://www.alura.com.br/artigos/o-que-e-git-github&#34;&gt;git e github&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Configurando&lt;/h2&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;Instalando o &lt;a href=&#34;https://www.docker.com/products/docker-desktop/&#34;&gt;docker desktop (Windows, Linux e Mac)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Instalando na linha de comando&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04-pt&#34;&gt;Docker&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Python e Virtualenv&lt;/h3&gt; &#xA;&lt;p&gt;Você deve configurar uma virtualenv do python para não instalar as bibliotecas no seu python do sistema.&lt;/p&gt; &#xA;&lt;p&gt;Se seu python é 3.3+&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python -m venv venv&#xA;source venv/bin/activate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Agora você pode instalar os pacotes do python:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Rodando o docker&lt;/h2&gt; &#xA;&lt;p&gt;Primeiro, você deve configurar seu dockerfile:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Definir qual distro linux vai usar&lt;/li&gt; &#xA; &lt;li&gt;Instalar Python3.8+ e Pip&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Agora você pode construir sua imagem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build . -t tp3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Depois que terminar, você pode rodar seu docker assim:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -p 5433:5432 -v $(pwd)/datadir/:/app/datadir tp3 tp3 &amp;lt;comando para subir o postgres&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;No jupyter notebook, você pode acessar o postgres na &lt;strong&gt;porta 5433&lt;/strong&gt;\&lt;/p&gt; &#xA;&lt;p&gt;O trabalho pede para testar varios formatos de sistema de arquivo. Para fazer isso, você deve montar tal um diretorio na sua maquina com o sistema de arquivo e passar ele para o docker.&lt;/p&gt; &#xA;&lt;p&gt;Exemplo: Vou testar o &lt;strong&gt;ext3&lt;/strong&gt;, depois de montar a pasta, farei o seguinte:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -p 5433:5432 -v $(pwd)/datadir_ext3/:/app/datadir &amp;lt;comando para subir o postgres&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>