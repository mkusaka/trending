<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-07T01:34:22Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OWASP/API-Security</title>
    <updated>2023-06-07T01:34:22Z</updated>
    <id>tag:github.com,2023-06-07:/OWASP/API-Security</id>
    <link href="https://github.com/OWASP/API-Security" rel="alternate"></link>
    <summary type="html">&lt;p&gt;OWASP API Security Project&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OWASP API Security Top 10&lt;/h1&gt; &#xA;&lt;p&gt;This project is designed to address the ever-increasing number of organizations that are deploying potentially sensitive APIs as part of their software offerings. These APIs are used for internal tasks and to interface with third parties. Unfortunately, many APIs do not undergo the rigorous security testing that would help make them secure from an attack.&lt;/p&gt; &#xA;&lt;p&gt;The OWASP API Security Project seeks to provide value to software developers and security assessors by underscoring the potential risks in insecure APIs, and illustrating how these risks may be mitigated. In order to facilitate this goal, the OWASP API Security Project will create and maintain a Top 10 API Security Risks document, as well as a documentation portal for best practices when creating or assessing APIs.&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;While working as developers or information security consultants, many people have encountered APIs as part of a project. While there are some resources to help create and evaluate these projects (such as the OWASP REST Security Cheat Sheet), there has not be a comprehensive security project designed to assist builders, breakers, and defenders in the community.&lt;/p&gt; &#xA;&lt;p&gt;This project aims to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create the OWASP Top Ten API Security Risks document, which can easily underscore the most common risks in the area.&lt;/li&gt; &#xA; &lt;li&gt;Create a documentation portal for developers to build APIs in a secure manner.&lt;/li&gt; &#xA; &lt;li&gt;Work closely with the security community to maintain living documents that evolve with security trends.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Project Leaders&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.owasp.org/index.php/User:ErezYalon&#34;&gt;Erez Yalon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.owasp.org/index.php/User:Inon&#34;&gt;Inon Shkedy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:paulo.silva@owasp.org&#34;&gt;Paulo Silva&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;The OWASP API Security Project documents are free to use!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The OWASP API Security Project is licensed under the &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 license&lt;/a&gt;, so you can copy, distribute, and transmit the work. You can also adapt it, and use it commercially, as long as you attribute the work. If you alter, transform, or build upon this work, you may distribute the resulting work only under the same or similar license to this one.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NordicPlayground/nrf-docker</title>
    <updated>2023-06-07T01:34:22Z</updated>
    <id>tag:github.com,2023-06-07:/NordicPlayground/nrf-docker</id>
    <link href="https://github.com/NordicPlayground/nrf-docker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dockerfile that contains all dependencies needed to build nRF Connect SDK applications.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Docker image for building nRF Connect SDK applications&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/NordicPlayground/nrf-docker/workflows/Publish%20Docker/badge.svg?branch=saga&#34; alt=&#34;Publish Docker&#34;&gt; (&lt;em&gt;the &lt;a href=&#34;https://hub.docker.com/r/nordicplayground/nrfconnect-sdk&#34;&gt;Docker image&lt;/a&gt; is build against &lt;a href=&#34;https://github.com/nrfconnect/sdk-nrf&#34;&gt;nRF Connect SDK&lt;/a&gt; &lt;code&gt;main&lt;/code&gt;,&lt;code&gt;v2.4-branch&lt;/code&gt;,&lt;code&gt;v2.3-branch&lt;/code&gt;,&lt;code&gt;v2.2-branch&lt;/code&gt;,&lt;code&gt;v2.1-branch&lt;/code&gt;,&lt;code&gt;v2.0-branch&lt;/code&gt;,&lt;code&gt;v1.9-branch&lt;/code&gt;,&lt;code&gt;v1.8-branch&lt;/code&gt;, &lt;code&gt;v1.7-branch&lt;/code&gt;, &lt;code&gt;v1.6-branch&lt;/code&gt;, and &lt;code&gt;v1.5-branch&lt;/code&gt; every night.&lt;/em&gt;)&lt;/p&gt; &#xA;&lt;p&gt;This project defines a Docker image that contains all dependencies to run &lt;code&gt;west&lt;/code&gt; commands with the nRF Connect SDK. Bind mount the project folder you&#39;d like to build, and the output will end up in the same folder (nested in build/zephyr subdir of the app).&lt;/p&gt; &#xA;&lt;p&gt;The aim is to provide a Docker image that can compile application and samples in a &lt;a href=&#34;https://github.com/nrfconnect/sdk-nrf&#34;&gt;nRF Connect SDK&lt;/a&gt; release branch, not to exactly replicate the software configuration used when the release was made.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è Read more about this aproach &lt;a href=&#34;https://devzone.nordicsemi.com/nordic/nrf-connect-sdk-guides/b/getting-started/posts/build-ncs-application-firmware-images-using-docker&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NordicPlayground/nrf-docker/saga/diagram.png&#34; alt=&#34;Docker + Zephyr -&gt; merged.hex&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;code&gt;docker&lt;/code&gt; on your operating system. On Windows you might want to use the &lt;a href=&#34;https://docs.docker.com/docker-for-windows/wsl-tech-preview/&#34;&gt;WSL subsystem&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;You can either build the image from this repository or use a pre-built one from Dockerhub.&lt;/p&gt; &#xA;&lt;h3&gt;Build image locally&lt;/h3&gt; &#xA;&lt;p&gt;Clone the repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/NordicPlayground/nrf-docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build the image (this is only needed once):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd nrf-docker&#xA;docker build -t nrfconnect-sdk --build-arg sdk_nrf_revision=v2.4-branch .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üçè &lt;em&gt;Note:&lt;/em&gt; To build for a Mac with the M1 architecture, you need to specify the &lt;code&gt;arm64&lt;/code&gt; architecture when building: &lt;code&gt;--build-arg arch=arm64&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è The &lt;code&gt;sdk_nrf_revision&lt;/code&gt; build argument can be used to specify what version of the nRF Connect SDK that will be used when looking up dependencies with pip for the SDK and it&#39;s west dependency repositories. The value can be a git &lt;em&gt;tag&lt;/em&gt;, &lt;em&gt;branch&lt;/em&gt; or &lt;em&gt;sha&lt;/em&gt; from the &lt;a href=&#34;https://github.com/nrfconnect/sdk-nrf&#34;&gt;nRF Connect SDK repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Use pre-built image from Dockerhub&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è This is a convenient way to quickly build your firmware but using images from untrusted third-parties poses the risk of exposing your source code. There is no guarantee (e.g. cryptographic signature) about what this image contains. When publishing the image this project only ensures through automation that it can be used to build nRF Connect SDK examples. The entire image creation and publication is automated (build on GitHub Actions, and served by Dockerhub), which means there are multiple systems that can be compromised, during and after publication. No human is involved in verifying the image. In addition Docker images are not deterministic. At build time, dependencies are fetched from third-party sources and installed. These dependencies could also contain malicious code. If you are using this image you must be aware that you are using software from many untrusted sources with all the consequences that brings.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üçè &lt;em&gt;Note:&lt;/em&gt; The prebuilt images are not available for &lt;code&gt;arm64&lt;/code&gt; architecture (Apple M1), because GitHub Actions don&#39;t have hosted runners with Apple M1 yet.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To use the pre-built image &lt;a href=&#34;https://hub.docker.com/r/nordicplayground/nrfconnect-sdk&#34;&gt;&lt;code&gt;nordicplayground/nrfconnect-sdk:main&lt;/code&gt;&lt;/a&gt;; add &lt;code&gt;nordicplayground/&lt;/code&gt; before the image name and &lt;code&gt;:tag&lt;/code&gt; after. Replace &lt;code&gt;tag&lt;/code&gt; with one of the &lt;a href=&#34;https://hub.docker.com/r/nordicplayground/nrfconnect-sdk/tags&#34;&gt;available tags&lt;/a&gt; on the Dockerhub image. The only difference between the tags are which Python dependencies are pre-installed in the image based on the different &lt;code&gt;requirements.txt&lt;/code&gt; files from the nRF Connect SDK repository&#39;s west dependencies.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm -v ${PWD}:/workdir/project nordicplayground/nrfconnect-sdk:main ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The rest of the documentation will use the local name &lt;code&gt;nrfconnect-sdk&lt;/code&gt;, but any of them can use &lt;code&gt;nordicplayground/nrfconnect-sdk:main&lt;/code&gt; (or a different tag) instead.&lt;/p&gt; &#xA;&lt;h3&gt;Build the firmware&lt;/h3&gt; &#xA;&lt;p&gt;To demonstrate, we&#39;ll build the &lt;em&gt;asset_tracker_v2&lt;/em&gt; application from sdk-nrf:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm \&#xA;    -v ${PWD}:/workdir/project \&#xA;    -w /workdir/nrf/applications/asset_tracker_v2 \&#xA;    nrfconnect-sdk \&#xA;    west build -p always -b nrf9160dk_nrf9160_ns --build-dir /workdir/project/build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The firmware file will be located here: &lt;code&gt;nrf/applications/asset_tracker_v2/build/zephyr/merged.hex&lt;/code&gt;. Because it&#39;s inside the folder that is bind mounted when running the image, it is also available outside of the Docker image.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è The &lt;code&gt;-p always&lt;/code&gt; build argument is to do a pristine build. It is similar to cleaning the build folder and is used because it is less error-prone to a previous build with different configuration. To speed up subsequent build with the same configuration you can remove this argument to avoid re-building code that haven&#39;t been modified since the previous build.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To build a stand-alone project, replace &lt;code&gt;-w /workdir/nrf/applications/asset_tracker_v2&lt;/code&gt; with the name of the applications folder inside the docker container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# run from the build-with-nrf-connect-sdk&#xA;docker run --rm -v ${PWD}:/workdir/project \&#xA;    nrfconnect-sdk \&#xA;    west build -p always -b nrf9160dk_nrf9160_ns&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Full example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# build docker image&#xA;git clone https://github.com/NordicPlayground/nrf-docker&#xA;cd nrf-docker&#xA;docker build -t nrfconnect-sdk --build-arg sdk_nrf_revision=v2.4-branch .&#xA;cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build a Zephyr sample using the hosted image&lt;/h3&gt; &#xA;&lt;p&gt;This builds the &lt;code&gt;hci_uart&lt;/code&gt; sample and stores the &lt;code&gt;hci_uart.hex&lt;/code&gt; file in the current directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm nordicplayground/nrfconnect-sdk:main \&#xA;    -v ${PWD}:/workdir/project \&#xA;    west build zephyr/samples/bluetooth/hci_uart -p always -b nrf9160dk_nrf52840 --build-dir /workdir/project/build&#xA;ls -la build/zephyr &amp;amp;&amp;amp; cp build/zephyr/zephyr.hex ./hci_uart.hex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;nRF5280 DK example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Init and build in Docker&#xA;docker run --rm nordicplayground/nrfconnect-sdk:main \&#xA;  -v ${PWD}:/workdir/project \&#xA;  west build zephyr/samples/bluetooth/peripheral_ht -p always -b nrf52840dk_nrf52840 --build-dir /workdir/project/build&#xA;&#xA;# Access build files&#xA;cp build/zephyr/zephyr.hex peripheral_ht.hex&#xA;ls -la ./peripheral_ht.hex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Flashing&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è Docker for Mac OS and Windows does not have support for USB yet, so this will only work on Linux computers.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# assumes asset_tracker_v2 built already (see above)&#xA;docker run --rm \&#xA;    -w /workdir/nrf/applications/asset_tracker_v2 \&#xA;    --device=/dev/ttyACM0 --privileged \&#xA;    nrfconnect-sdk \&#xA;    west flash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ClangFormat&lt;/h2&gt; &#xA;&lt;p&gt;The image comes with &lt;a href=&#34;https://clang.llvm.org/docs/ClangFormat.html&#34;&gt;ClangFormat&lt;/a&gt; and the &lt;a href=&#34;https://github.com/nrfconnect/sdk-nrf/raw/main/.clang-format&#34;&gt;nRF Connect SDK formatting rules&lt;/a&gt; so you can run for example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --name nrfconnect-sdk -d nordicplayground/nrfconnect-sdk tail -f /dev/null&#xA;find ./src -type f -iname \*.h -o -iname \*.c \&#xA;    | xargs -I@ /bin/bash -c &#34;\&#xA;        tmpfile=\$(mktemp /tmp/clang-formatted.XXXXXX) &amp;amp;&amp;amp; \&#xA;        docker exec -i nrfconnect-sdk clang-format &amp;lt; @ &amp;gt; \$tmpfile &amp;amp;&amp;amp; \&#xA;        cmp --silent @ \$tmpfile || (mv \$tmpfile @ &amp;amp;&amp;amp; echo @ formatted.)&#34;&#xA;docker kill nrfconnect-sdk&#xA;docker rm nrfconnect-sdk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to format your sources.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è Instead of having &lt;code&gt;clang-format&lt;/code&gt; overwrite the source code file itself, the above command passes the source code file on stdin to clang-format and then overwrites it outside of the container. Otherwise the overwritten file will be owner by the root user (because the Docker daemon is run as root).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Interactive usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -it --name nrfconnect-sdk -v ${PWD}:/workdir/project \&#xA;    nrfconnect-sdk /bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è On Linux add &lt;code&gt;--device=/dev/ttyACM0 --privileged&lt;/code&gt; to be able to flash from the Docker container.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Then, inside the container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd nrf/applications/asset_tracker_v2&#xA;west build -p always -b nrf9160dk_nrf9160_ns&#xA;west flash # only works on linux - use nrf desktop tools on Windows/Mac OS&#xA;west build&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Meanwhile, inside or outside of the container, you may modify the code and repeat the build/flash cycle.&lt;/p&gt; &#xA;&lt;p&gt;Later after closing the container you may re-open it by name to continue where you left off:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker start -i nrfconnect-sdk&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>