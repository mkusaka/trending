<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-24T01:28:55Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>onosaito/WordPress</title>
    <updated>2023-08-24T01:28:55Z</updated>
    <id>tag:github.com,2023-08-24:/onosaito/WordPress</id>
    <link href="https://github.com/onosaito/WordPress" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;App Wordpress&lt;/h1&gt; &#xA;&lt;p&gt;Wordpress is a relatively simple sample application that only requires compute to run its containerized binary and a MySQL database. The Wordpress application can be deployed on top of the Crossplane Sample Stacks for GCP, AWS, and Azure -- or any stack that provides the neccesary service catalog.&lt;/p&gt; &#xA;&lt;p&gt;Applications allow you to define your application and its managed service dependencies as a single installable unit. Applications are portable in that they create claims for infrastructure that are satisfied by different managed service implementations depending on what stacks are installed in your environment.&lt;/p&gt; &#xA;&lt;p&gt;The Wordpress application can be deployed on top of stacks that provide the default resource classes capable of satisfying the required infrastructure claims for things like a MySQL database and a Kubernetes Cluster. All of the following stacks provide the neccesary default resource classes in their service catalog: &lt;a href=&#34;https://github.com/crossplane/stack-gcp-sample&#34;&gt;GCP Sample Stack&lt;/a&gt;, &lt;a href=&#34;https://github.com/crossplane/stack-aws-sample&#34;&gt;AWS Sample Stack&lt;/a&gt;, and &lt;a href=&#34;https://github.com/crossplane/stack-azure-sample&#34;&gt;Azure Sample Stack&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can even make your own stacks and the Wordpress application will deploy successfully on top as long as the stack provides the neccesary default resource classes. Checkout the &lt;a href=&#34;https://crossplane.github.io/docs&#34;&gt;Crossplane docs&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/crossplane/app-wordpress/tree/master/helm-chart/templates&#34;&gt;templates&lt;/a&gt; used in this application show how templating engines like &lt;code&gt;helm&lt;/code&gt; and &lt;code&gt;kustomize&lt;/code&gt; can be used to build your own application and this repo can be used a starting point for building your own application.&lt;/p&gt; &#xA;&lt;p&gt;Checkout the &lt;a href=&#34;https://raw.githubusercontent.com/onosaito/WordPress/master/docs/quickstart.md&#34;&gt;Wordpress Quick Start&lt;/a&gt; to rapidly get started in your environment.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install with the following command after replacing &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; with the correct one, like &lt;code&gt;0.1.0&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl crossplane package install -n default &#39;crossplane/app-wordpress:&amp;lt;version&amp;gt;&#39; wordpress&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Here is an example CR that you can use to deploy Wordpress to a fresh new cluster:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: wordpress.apps.crossplane.io/v1alpha1&#xA;kind: WordpressInstance&#xA;metadata:&#xA;  name: testme&#xA;spec:&#xA;# You can use UseExistingTarget as well to schedule to a KubernetesTarget in the&#xA;# same namespace randomly.&#xA;  provisionPolicy: ProvisionNewCluster&#xA;&#xA;#  This is the default value.&#xA;# image: wordpress:4.6.1-apache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Test Locally&lt;/h2&gt; &#xA;&lt;h3&gt;Minikube&lt;/h3&gt; &#xA;&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt; and then run the following command to copy the image into your minikube node&#39;s image registry:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Do not forget to specify &amp;lt;version&amp;gt;&#xA;docker save &#34;crossplane/app-wordpress:&amp;lt;version&amp;gt;&#34; | (eval &#34;$(minikube docker-env --shell bash)&#34; &amp;amp;&amp;amp; docker load)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After running this, you can use the &lt;a href=&#34;https://raw.githubusercontent.com/onosaito/WordPress/master/#installation&#34;&gt;installation&lt;/a&gt; command and the image loaded into minikube node will be picked up.&lt;/p&gt; &#xA;&lt;h2&gt;Release&lt;/h2&gt; &#xA;&lt;p&gt;To create and publish a release, use the upbound Jenkins jobs. You&#39;ll want to have your release version handy.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;A note about the multibranch pipelines we use.&lt;/strong&gt; We&#39;re using multibranch pipeline jobs in Jenkins, which means that Jenkins creates a new job for each branch that it detects. This means that each time a new branch is created, such as from the create branch job, you may need to trigger a new scan of the repository. It also means you may need to run the job once and have it fail before you can enter in parameters for the job.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;First, run the &lt;a href=&#34;https://jenkinsci.upbound.io/job/crossplaneio/job/app-wordpress/job/branch-create/&#34;&gt;job to cut a new branch&lt;/a&gt;, if needed. The branch should be named &lt;code&gt;release-MAJOR.MINOR&lt;/code&gt;. For example: &lt;code&gt;release-0.0&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If needed, edit the package version in the release branch, so that the stack version matches the version that will be released. Look for the stack&#39;s metadata block.&lt;/li&gt; &#xA; &lt;li&gt;Run the &lt;a href=&#34;https://jenkinsci.upbound.io/job/crossplaneio/job/app-wordpress/job/tag/&#34;&gt;job to tag the exact release&lt;/a&gt; we want. For example: &lt;code&gt;v0.0.1&lt;/code&gt;. If you use the one on the release branch we created, that&#39;s the simplest.&lt;/li&gt; &#xA; &lt;li&gt;Run the &lt;a href=&#34;https://jenkinsci.upbound.io/job/crossplaneio/job/app-wordpress/job/publish/&#34;&gt;job to publish the release&lt;/a&gt;. It&#39;s easiest if you use the branch created earlier.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>