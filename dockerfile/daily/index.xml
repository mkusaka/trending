<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-17T01:32:16Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Next-DAO/atomicals-electrumx-docker</title>
    <updated>2023-11-17T01:32:16Z</updated>
    <id>tag:github.com,2023-11-17:/Next-DAO/atomicals-electrumx-docker</id>
    <link href="https://github.com/Next-DAO/atomicals-electrumx-docker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Atomicals ElectrumX Docker&lt;/h1&gt; &#xA;&lt;p&gt;Aim to provide a simple and easy way to run &lt;a href=&#34;https://github.com/atomicals/atomicals-electrumx&#34;&gt;atomicals-electrumx&lt;/a&gt; server. Inspired by &lt;a href=&#34;https://github.com/lukechilds/docker-electrumx&#34;&gt;https://github.com/lukechilds/docker-electrumx&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Bitcoin Full Node&lt;/li&gt; &#xA; &lt;li&gt;At least &lt;strong&gt;100G&lt;/strong&gt; left in your storage.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;1. Update your Bitcoin Full Node RPC settings, &lt;em&gt;SKIP&lt;/em&gt; if you already set.&lt;/h3&gt; &#xA;&lt;p&gt;Add this to your bitcoin.conf, and restart your bitcoin full node.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;assuming your lan ip is &lt;code&gt;192.168.50.2&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;txindex=1&#xA;rpcauth=electrumx:c7ed296134ebe0035d9ff786dfa102b5$9d40e8e36bcdba1e3ca0a79178c3864c3deaa9e6fd484ff683e7770690a97097&#xA;&#xA;rpcbind=0.0.0.0&#xA;rpcallowip=127.0.0.1&#xA;rpcallowip=172.0.0.0/8&#xA;rpcallowip=192.168.50.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;txindex=1&lt;/code&gt; is required for ElectrumX to work. You need wait for full node to reindex.&lt;/li&gt; &#xA; &lt;li&gt;You can also download script from &lt;a href=&#34;https://github.com/bitcoin/bitcoin/raw/master/share/rpcauth/rpcauth.py&#34;&gt;https://github.com/bitcoin/bitcoin/blob/master/share/rpcauth/rpcauth.py&lt;/a&gt;. And generate one by yourself.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;2. Clone this repo and Run the server:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/lucky2077/atomicals-electrumx-docker.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd atomicals-electrumx-docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create an &lt;code&gt;.env&lt;/code&gt; file with content below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;DAEMON_URL=electrumx:electrumx@192.168.50.2:8332&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run the ElectrumX server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose pull &amp;amp;&amp;amp; docker-compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use &lt;code&gt;docker-compose logs -f&lt;/code&gt; to check the logs.&lt;/li&gt; &#xA; &lt;li&gt;use &lt;code&gt;docker-compose down&lt;/code&gt; to stop the server.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You should stop here until the server is fully synced.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;data&lt;/code&gt; directory will be more than &lt;strong&gt;90G&lt;/strong&gt; after sync.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>realtime-sanitizer/radsan</title>
    <updated>2023-11-17T01:32:16Z</updated>
    <id>tag:github.com,2023-11-17:/realtime-sanitizer/radsan</id>
    <link href="https://github.com/realtime-sanitizer/radsan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Central hub for RealtimeSanitizer and its associated tooling&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Realtime Sanitizer&lt;/h1&gt; &#xA;&lt;p&gt;RealtimeSanitizer (a.k.a. RADSan) is a real-time safety testing tool for C and C++ projects. RADSan can be used to detect &lt;em&gt;real-time violations&lt;/em&gt;, i.e. calls to methods that are not safe for use in functions with deterministic runtime requirements.&lt;/p&gt; &#xA;&lt;p&gt;RADSan is a customised version of &lt;code&gt;clang&lt;/code&gt; and, like other popular sanitizers, a lightweight dynamic library that can detect real-time unsafe system calls. Calls to functions such as &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt; and &lt;code&gt;pthread_mutex_lock&lt;/code&gt; (along with anything else RADSan believes may have a nondeterministic execution time) will cause RADSan to error, but only if they are called within a real-time context, as defined by the user. Real-time contexts are defined by the user simply by marking functions with the &lt;code&gt;[[clang::realtime]]&lt;/code&gt; attribute.&lt;/p&gt; &#xA;&lt;h1&gt;Table Of Contents&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#getting-radsan&#34;&gt;Getting RADSan&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#cmake&#34;&gt;CMake&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#configuration&#34;&gt;Configuration&lt;/a&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#error-modes&#34;&gt;Error Modes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#disabling-radsan&#34;&gt;Disabling RADSan&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#choice-of-symbolizer&#34;&gt;Choice of symbolizer&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#how-it-works&#34;&gt;How it works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#building-from-source&#34;&gt;Building from source&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/realtime-sanitizer/radsan/main/#contact&#34;&gt;Contact&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Using RealtimeSanitizer requires only two actions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;mark a real-time function with the &lt;code&gt;[[clang::realtime]]&lt;/code&gt; attribute:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;[[clang::realtime]] void process (processing_data const &amp;amp; data)&#xA;{&#xA;    auto x = std::vector&amp;lt;float&amp;gt; (16); // oops!&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;add &lt;code&gt;-fsanitize=realtime&lt;/code&gt; to your compile and link flags:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;clang -fsanitize=realtime main.cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At run-time, RADSan presents detected real-time violations with a helpful stack trace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./a.out&#xA;Real-time violation: intercepted call to real-time unsafe function `malloc` in real-time context! Stack trace:&#xA;    #0 0x5644f383d78a in radsan::printStackTrace() /llvm-project/compiler-rt/lib/radsan/radsan_stack.cpp:36:5&#xA;    #1 0x5644f383d630 in radsan::Context::printDiagnostics(char const*) /llvm-project/compiler-rt/lib/radsan/radsan_context.cpp:37:3&#xA;    #2 0x5644f383d5d5 in radsan::Context::exitIfRealtime(char const*) /llvm-project/compiler-rt/lib/radsan/radsan_context.cpp:24:5&#xA;    #3 0x5644f383e067 in exitIfRealtime /llvm-project/compiler-rt/lib/radsan/radsan_interceptors.cpp:29:29&#xA;    #4 0x5644f383e067 in malloc /llvm-project/compiler-rt/lib/radsan/radsan_interceptors.cpp:221:3&#xA;    #5 0x7f7a072b798b in operator new(unsigned long) (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae98b) (BuildId: e37fe1a879783838de78cbc8c80621fa685d58a2)&#xA;    #6 0x5644f3861d7f in std::__new_allocator&amp;lt;float&amp;gt;::allocate(unsigned long, void const*) (/root/test/a.out+0x2ad7f)&#xA;    #7 0x5644f3861d10 in std::allocator_traits&amp;lt;std::allocator&amp;lt;float&amp;gt;&amp;gt;::allocate(std::allocator&amp;lt;float&amp;gt;&amp;amp;, unsigned long) (/root/test/a.out+0x2ad10)&#xA;    #8 0x5644f3861ccf in std::_Vector_base&amp;lt;float, std::allocator&amp;lt;float&amp;gt;&amp;gt;::_M_allocate(unsigned long) (/root/test/a.out+0x2accf)&#xA;    #9 0x5644f3861c20 in std::_Vector_base&amp;lt;float, std::allocator&amp;lt;float&amp;gt;&amp;gt;::_M_create_storage(unsigned long) (/root/test/a.out+0x2ac20)&#xA;    #10 0x5644f38619b1 in std::_Vector_base&amp;lt;float, std::allocator&amp;lt;float&amp;gt;&amp;gt;::_Vector_base(unsigned long, std::allocator&amp;lt;float&amp;gt; const&amp;amp;) (/root/test/a.out+0x2a9b1)&#xA;    #11 0x5644f3861838 in std::vector&amp;lt;float, std::allocator&amp;lt;float&amp;gt;&amp;gt;::vector(unsigned long, std::allocator&amp;lt;float&amp;gt; const&amp;amp;) (/root/test/a.out+0x2a838)&#xA;    #12 0x5644f3861767 in process(processing_data const&amp;amp;) (/root/test/a.out+0x2a767)&#xA;    #13 0x5644f38617d0 in main (/root/test/a.out+0x2a7d0)&#xA;    #14 0x7f7a06eefd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: a43bfc8428df6623cd498c9c0caeb91aec9be4f9)&#xA;    #15 0x7f7a06eefe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: a43bfc8428df6623cd498c9c0caeb91aec9be4f9)&#xA;    #16 0x5644f383d4a4 in _start (/root/test/a.out+0x64a4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Getting RADSan&lt;/h1&gt; &#xA;&lt;h2&gt;Docker&lt;/h2&gt; &#xA;&lt;p&gt;The fastest way to try RealtimeSanitizer is to pull the &lt;a href=&#34;https://hub.docker.com/repository/docker/realtimesanitizer/radsan-clang/&#34;&gt;pre-built docker image&lt;/a&gt;, which has &lt;code&gt;clang&lt;/code&gt; (and other &lt;code&gt;llvm&lt;/code&gt; tooling) with RADSan readily installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull realtimesanitizer/radsan-clang&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can quickly experiment in your own repository using a shared-volume:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -v $(pwd):/my_repo -it realtimesanitizer/radsan-clang /bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which mounts the host&#39;s current working directory at path &lt;code&gt;/my_repo&lt;/code&gt; in the container. Alternatively, you may prefer to use the RADSan Docker image as a parent image for your own development or CI environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM realtimesanitizer/radsan-clang:latest&#xA;RUN apt-get update &amp;amp;&amp;amp; apt-get install -y git cmake vim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Linux &amp;amp; macOS&lt;/h2&gt; &#xA;&lt;p&gt;Pre-built binaries for Linux and macOS are not yet available for download. Please see the &#34;Building from source&#34; section below for instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Windows&lt;/h2&gt; &#xA;&lt;p&gt;Apologies, RealtimeSanitizer does not yet support Windows. We very much welcome contributions, so please contact us (details at the bottom of this README) if you&#39;re interested.&lt;/p&gt; &#xA;&lt;h1&gt;CMake&lt;/h1&gt; &#xA;&lt;p&gt;RADSan-enabled clang is installed to &lt;code&gt;/usr/local&lt;/code&gt; in the RADSan Docker image, and CMake will automatically detect it. However, if you&#39;ve built RADSan from source, you&#39;ll need to instruct CMake to use it by either:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;setting the &lt;code&gt;CC&lt;/code&gt; and &lt;code&gt;CXX&lt;/code&gt; environment variables,&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;CC=/path/to/built/clang CXX=/path/to/built/clang++ cmake ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;passing the &lt;code&gt;CMAKE_C_COMPILER&lt;/code&gt; and &lt;code&gt;CMAKE_CXX_COMPILER&lt;/code&gt; options to cmake&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cmake -DCMAKE_CXX_COMPILER=/path/to/built/clang++ ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;or using &lt;code&gt;set(CMAKE_CXX_COMPILER ...)&lt;/code&gt; in your CMake project file.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;set(CMAKE_CXX_COMPILER /path/to/built/clang++)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Adding the compiler flag &lt;code&gt;-fsanitize=realtime&lt;/code&gt; can be done however works best for your project. Individual targets can be configured with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;target_compile_options(MyTarget PUBLIC -fsanitize=realtime)&#xA;target_link_options(MyTarget PUBLIC -fsanitize=realtime)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or add the following to configure all targets in the project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_compile_options(-fsanitize=realtime)&#xA;add_link_options(-fsanitize=realtime)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Configuration&lt;/h1&gt; &#xA;&lt;h2&gt;Error modes&lt;/h2&gt; &#xA;&lt;p&gt;RADSan&#39;s behaviour during real-time violations can be configured using the &lt;code&gt;RADSAN_ERROR_MODE&lt;/code&gt; environment variable. RADSan recognises any of the following values for &lt;code&gt;RADSAN_ERROR_MODE&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;exit&lt;/code&gt; (RADSan will immediately exit with a failure code on the first violation),&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;continue&lt;/code&gt; (RADSan will print errors and continue), or&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;interactive&lt;/code&gt; (RADSan will wait for your instruction at the command line):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;gt; RADSAN_ERROR_MODE=interactive ./my_executable&#xA;&#xA;Real-time violation: intercepted call to real-time unsafe function `malloc` in real-time context! Stack trace:&#xA;    #0 0x5644f383d78a in radsan::printStackTrace() /llvm-project/compiler-rt/lib/radsan/radsan_stack.cpp:36:5&#xA;    #1 0x5644f383d630 in radsan::Context::printDiagnostics(char const*) /llvm-project/compiler-rt/lib/radsan/radsan_context.cpp:37:3&#xA;    ... (etc)&#xA;&#xA;Continue? (Y/n):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default configuration is &lt;code&gt;RADSAN_ERROR_MODE=exit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Disabling RADSan&lt;/h2&gt; &#xA;&lt;p&gt;You might find a case where you disagree with RADSan&#39;s assessment of real-time safety. Consider the case of locking and unlocking a mutex; these operations can block if the mutex is contested, and common advice is to avoid them in real-time contexts. However, it can be argued that their use is safe under certain special constraints, like if the mutex is never contested (you might be re-using multi-threaded code in a single-threaded context), or if it&#39;s only contested at times when a user is expecting a glitch anyway (if, say, an audio device is disconnected). RADSan always assumes the worst, and this may not be true for your particular use case. You can turn off RADSan&#39;s error detection temporarily by wrapping code in &lt;code&gt;radsan_off()&lt;/code&gt; and &lt;code&gt;radsan_on()&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;radsan.h&#34; // (found in llvm-project/compiler-rt/lib/radsan)&#xA;&#xA;[[clang::realtime]] float process (float x)&#xA;{&#xA;    auto const y = 2.0f * x;&#xA;&#xA;    radsan_off();&#xA;    i_know_this_method_is_realtime_safe_but_radsan_complains_about_it();&#xA;    radsan_on();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Choice of symbolizer&lt;/h2&gt; &#xA;&lt;p&gt;By default, RADSan uses the installed &lt;code&gt;llvm-symbolizer&lt;/code&gt; to symbolise the stack trace. If you prefer a different symboliser, you can configure RADSan to use it by setting the envionment variable &lt;code&gt;RADSAN_SYMBOLIZER_PATH&lt;/code&gt; at run-time.&lt;/p&gt; &#xA;&lt;h1&gt;How it works&lt;/h1&gt; &#xA;&lt;p&gt;Radsan contains a submodule with a fork of the &lt;code&gt;llvm-project&lt;/code&gt;. This fork contains 2 main areas of new functionality:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Changes to the clang compiler front end that:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;check for &lt;code&gt;-fsanitize=realtime&lt;/code&gt; as a compiler flag,&lt;/li&gt; &#xA;   &lt;li&gt;look for functions marked with the &lt;code&gt;[[clang::runtime]]&lt;/code&gt; function attribute,&lt;/li&gt; &#xA;   &lt;li&gt;insert calls to &lt;code&gt;radsan_realtime_enter()&lt;/code&gt; &amp;amp; &lt;code&gt;radsan_realtime_exit()&lt;/code&gt; at the start and end of each of these realtime functions, which are used by the radsan library (described below), to keep track of whether we are inside a realtime context or not.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;radsan&lt;/code&gt; library&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;This library links to your application at run time and contains 2 main functional areas:&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;radsan::Context&lt;/code&gt;: which is used to maintain whether we are in a &#34;real-time&#34; context and handle any errors&lt;/li&gt; &#xA;     &lt;li&gt;The &lt;code&gt;INTERCEPTOR&lt;/code&gt;s, which are used to intercept calls to the system library at runtime. It uses interceptors from llvm&#39;s &lt;code&gt;compiler-rt&lt;/code&gt; library and contains an interceptor for each function we want to intercept. They all follow the same pattern: check if we&#39;re in a real-time context, if not, then call the &#34;real&#34; function, if it is, then handle the error&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;INTERCEPTOR(void *, malloc, SIZE_T size) {&#xA;  radsan::expectNotRealtime(&#34;malloc&#34;);&#xA;  return REAL(malloc)(size);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Building from source&lt;/h1&gt; &#xA;&lt;h2&gt;Clang with RealtimeSanitizer&lt;/h2&gt; &#xA;&lt;p&gt;Building RADSan-enabled clang is performed entirely within the fork of the llvm-project submodule. The llvm-project is a CMake project, and takes a bit of time to build. To minimise this build time, we recommend using the &lt;code&gt;ninja&lt;/code&gt; build system, and configuring with the following CMake settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd llvm-project&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake -G Ninja \&#xA;   -DCMAKE_BUILD_TYPE=Release \&#xA;   -DBUILD_SHARED_LIBS=ON \&#xA;   -DLLVM_ENABLE_PROJECTS=&#34;clang;compiler-rt&#34; \&#xA;   -DLLVM_TARGETS_TO_BUILD=Native \&#xA;   ../llvm&#xA;ninja -j8 clang compiler-rt llvm-symbolizer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If built successfully, &lt;code&gt;clang&lt;/code&gt; should have appeared inside the &lt;code&gt;bin/&lt;/code&gt; folder, and the radsan dynamic library should be in &lt;code&gt;lib/&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; find bin | grep clang&#xA;bin/clang&#xA;bin/clang-tblgen&#xA;bin/clang-cl&#xA;bin/clang++&#xA;bin/clang-cpp&#xA;bin/clang-18&#xA;&amp;gt; find lib | grep radsan&#xA;lib/clang/18/lib/darwin/libclang_rt.radsan_osx_dynamic.dylib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;RADSan Docker image&lt;/h2&gt; &#xA;&lt;p&gt;Building the Docker image locally is straightforward:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build -t radsan -f docker/Dockerfile .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Contact&lt;/h1&gt; &#xA;&lt;p&gt;RealtimeSanitizer was developed by David Trevelyan and Ali Barker. We welcome contributions to make this tool more helpful to a wider group of developers. For all comments, suggestions and queries, please contact us by:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;joining the &lt;a href=&#34;https://discord.gg/DZqjbmSZzZ&#34;&gt;Discord server&lt;/a&gt;, or&lt;/li&gt; &#xA; &lt;li&gt;sending an email to &lt;a href=&#34;mailto:realtime.sanitizer@gmail.com&#34;&gt;realtime.sanitizer@gmail.com&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>