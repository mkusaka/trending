<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-04T01:31:12Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>PrivateBin/docker-nginx-fpm-alpine</title>
    <updated>2025-07-04T01:31:12Z</updated>
    <id>tag:github.com,2025-07-04:/PrivateBin/docker-nginx-fpm-alpine</id>
    <link href="https://github.com/PrivateBin/docker-nginx-fpm-alpine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PrivateBin docker image based on Nginx, php-fpm &amp; Alpine Linux stack&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PrivateBin on Nginx, php-fpm &amp;amp; Alpine&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;PrivateBin&lt;/strong&gt; is a minimalist, open source online &lt;a href=&#34;https://en.wikipedia.org/wiki/Pastebin&#34;&gt;pastebin&lt;/a&gt; where the server has zero knowledge of pasted data. Data is encrypted and decrypted in the browser using 256bit AES in &lt;a href=&#34;https://en.wikipedia.org/wiki/Galois/Counter_Mode&#34;&gt;Galois Counter mode&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This repository contains the Dockerfile and resources needed to create a Docker image with a pre-installed PrivateBin instance in a secure default configuration. The images are based on the docker hub Alpine image, extended with the GD module required to generate discussion avatars and the Nginx webserver to serve static JavaScript libraries, CSS &amp;amp; the logos. All logs of php-fpm and Nginx (access &amp;amp; errors) are forwarded to docker logs.&lt;/p&gt; &#xA;&lt;h2&gt;Image variants&lt;/h2&gt; &#xA;&lt;p&gt;This is the all-in-one image (&lt;a href=&#34;https://hub.docker.com/r/privatebin/nginx-fpm-alpine/&#34;&gt;Docker Hub&lt;/a&gt; / &lt;a href=&#34;https://github.com/orgs/PrivateBin/packages/container/package/nginx-fpm-alpine&#34;&gt;GitHub&lt;/a&gt;) that can be used with any storage backend supported by PrivateBin - file based storage, databases, Google Cloud or S3 Storage. We also offer dedicated images for each backend:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/privatebin/fs&#34;&gt;Image for file based storage (Docker Hub&lt;/a&gt; / &lt;a href=&#34;https://github.com/orgs/PrivateBin/packages/container/package/fs&#34;&gt;GitHub&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/privatebin/pdo&#34;&gt;Image for PostgreSQL, MariaDB &amp;amp; MySQL (Docker Hub&lt;/a&gt; / &lt;a href=&#34;https://github.com/orgs/PrivateBin/packages/container/package/pdo&#34;&gt;GitHub&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/privatebin/gcs&#34;&gt;Image for Google Cloud Storage (Docker Hub&lt;/a&gt; / &lt;a href=&#34;https://github.com/orgs/PrivateBin/packages/container/package/gcs&#34;&gt;GitHub&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/privatebin/s3&#34;&gt;Image for S3 Storage (Docker Hub&lt;/a&gt; / &lt;a href=&#34;https://github.com/orgs/PrivateBin/packages/container/package/s3&#34;&gt;GitHub&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Image tags&lt;/h2&gt; &#xA;&lt;p&gt;All images contain a release version of PrivateBin and are offered with the following tags:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;latest&lt;/code&gt; is an alias of the latest pushed image, usually the same as &lt;code&gt;nightly&lt;/code&gt;, but excluding &lt;code&gt;edge&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nightly&lt;/code&gt; is the latest released PrivateBin version on an upgraded Alpine release image, including the latest changes from the docker image repository&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;edge&lt;/code&gt; is the latest released PrivateBin version on an upgraded Alpine edge image&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stable&lt;/code&gt; contains the latest PrivateBin release on the latest tagged release of the &lt;a href=&#34;https://github.com/PrivateBin/docker-nginx-fpm-alpine&#34;&gt;docker image git repository&lt;/a&gt; - gets updated when important security fixes are released for Alpine or upon new Alpine releases&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;1.5.1&lt;/code&gt; contains PrivateBin version 1.5.1 on the latest tagged release of the &lt;a href=&#34;https://github.com/PrivateBin/docker-nginx-fpm-alpine&#34;&gt;docker image git repository&lt;/a&gt; - gets updated when important security fixes are released for Alpine or upon new Alpine releases, same as stable&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;1.5.1-...&lt;/code&gt; are provided for selecting specific, immutable images&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you update your images automatically via pulls, the &lt;code&gt;stable&lt;/code&gt;, &lt;code&gt;nightly&lt;/code&gt; or &lt;code&gt;latest&lt;/code&gt; are recommended. If you prefer to have control and reproducability or use a form of orchestration, the numeric tags are probably preferable. The &lt;code&gt;edge&lt;/code&gt; tag offers a preview of software in future Alpine releases and serves as an early warning system to detect image build issues in these.&lt;/p&gt; &#xA;&lt;h2&gt;Image registries&lt;/h2&gt; &#xA;&lt;p&gt;These images are hosted on the Docker Hub and the GitHub container registries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/u/privatebin&#34;&gt;Images on Docker Hub&lt;/a&gt;, which are prefixed &lt;code&gt;privatebin&lt;/code&gt; or &lt;code&gt;docker.io/privatebin&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/orgs/PrivateBin/packages&#34;&gt;Images on GitHub&lt;/a&gt;, which are prefixed &lt;code&gt;ghcr.io/privatebin&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Running the image&lt;/h2&gt; &#xA;&lt;p&gt;Assuming you have docker successfully installed and internet access, you can fetch and run the image from the docker hub like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker run -d --restart=&#34;always&#34; --read-only -p 8080:8080 -v $PWD/privatebin-data:/srv/data privatebin/nginx-fpm-alpine&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The parameters in detail:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-v $PWD/privatebin-data:/srv/data&lt;/code&gt; - replace &lt;code&gt;$PWD/privatebin-data&lt;/code&gt; with the path to the folder on your system, where the pastes and other service data should be persisted. This guarantees that your pastes aren&#39;t lost after you stop and restart the image or when you replace it. May be skipped if you just want to test the image or use database or Google Cloud Storage backend.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-p 8080:8080&lt;/code&gt; - The Nginx webserver inside the container listens on port 8080, this parameter exposes it on your system on port 8080. Be sure to use a reverse proxy for HTTPS termination in front of it in production environments.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--read-only&lt;/code&gt; - This image supports running in read-only mode. Using this reduces the attack surface slightly, since an exploit in one of the images services can&#39;t overwrite arbitrary files in the container. Only /tmp, /var/tmp, /var/run &amp;amp; /srv/data may be written into.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-d&lt;/code&gt; - launches the container in the background. You can use &lt;code&gt;docker ps&lt;/code&gt; and &lt;code&gt;docker logs&lt;/code&gt; to check if the container is alive and well.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--restart=&#34;always&#34;&lt;/code&gt; - restart the container if it crashes, mainly useful for production setups&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that the volume mounted must be owned by UID 65534 / GID 82. If you run the container in a docker instance with &#34;userns-remap&#34; you need to add your subuid/subgid range to these numbers.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Custom configuration&lt;/h3&gt; &#xA;&lt;p&gt;In case you want to use a customized &lt;a href=&#34;https://github.com/PrivateBin/PrivateBin/raw/master/cfg/conf.sample.php&#34;&gt;conf.php&lt;/a&gt; file, for example one that has file uploads enabled or that uses a different template, add the file as a second volume:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker run -d --restart=&#34;always&#34; --read-only -p 8080:8080 -v $PWD/conf.php:/srv/cfg/conf.php:ro -v $PWD/privatebin-data:/srv/data privatebin/nginx-fpm-alpine&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The &lt;code&gt;Filesystem&lt;/code&gt; data storage is supported out of the box. The image includes PDO modules for MySQL and PostgreSQL, required for the &lt;code&gt;Database&lt;/code&gt; one, but you still need to keep the /srv/data persisted for the server salt and the traffic limiter when using a release before 1.4.0.&lt;/p&gt; &#xA;&lt;h4&gt;Environment variables&lt;/h4&gt; &#xA;&lt;p&gt;The following variables are passed down to the PHP application to support various scenarios. This allows certain settings to be changed via the environment instead of a configuration file. Most of these variables relate to the storage backends:&lt;/p&gt; &#xA;&lt;h5&gt;Amazon Web Services variables used by the S3 backend&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_ACCESS_KEY_ID&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_CONTAINER_AUTHORIZATION_TOKEN&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_CONTAINER_CREDENTIALS_FULL_URI&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_CONTAINER_CREDENTIALS_RELATIVE_URI&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_DEFAULT_REGION&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_PROFILE&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_ROLE_ARN&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_ROLE_SESSION_NAME&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_SECRET_ACCESS_KEY&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_SESSION_TOKEN&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_STS_REGIONAL_ENDPOINTS&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_WEB_IDENTITY_TOKEN_FILE&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWS_SHARED_CREDENTIALS_FILE&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Google Cloud variables used by the GCS backend&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;GCLOUD_PROJECT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GOOGLE_APPLICATION_CREDENTIALS&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GOOGLE_CLOUD_PROJECT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PRIVATEBIN_GCS_BUCKET&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Custom backend settings&lt;/h5&gt; &#xA;&lt;p&gt;The following variables are not used by default, but can be &lt;a href=&#34;https://github.com/PrivateBin/docker-nginx-fpm-alpine/issues/196#issuecomment-2163331528&#34;&gt;enabled in your custom configuration file&lt;/a&gt;, to keep sensitive information out of it:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;STORAGE_HOST&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;STORAGE_LOGIN&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;STORAGE_PASSWORD&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;STORAGE_CONTAINER&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Configuration folder&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CONFIG_PATH&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Timezone settings&lt;/h5&gt; &#xA;&lt;p&gt;The image supports the following two environment variables to adjust the timezone. This is especially useful to ensure the logs show the correct local time.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;TZ&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PHP_TZ&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: The application internally handles expiration of pastes based on a UNIX timestamp that is calculated based on the timezone set during its creation. Changing the PHP_TZ will affect this and leads to earlier (if the timezone is increased) or later (if it is decreased) expiration than expected.&lt;/p&gt; &#xA;&lt;h3&gt;Adjusting nginx or php-fpm settings&lt;/h3&gt; &#xA;&lt;p&gt;You can attach your own &lt;code&gt;php.ini&lt;/code&gt; or nginx configuration files to the folders &lt;code&gt;/etc/php/conf.d/&lt;/code&gt; and &lt;code&gt;/etc/nginx/http.d/&lt;/code&gt; respectively. This, for example, would let you adjust the maximum size that these two services accept for file uploads, if you need more than the default 10 MiB.&lt;/p&gt; &#xA;&lt;h3&gt;Kubernetes deployment&lt;/h3&gt; &#xA;&lt;p&gt;Below is an example deployment for Kubernetes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---&#xA;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: privatebin-deployment&#xA;  labels:&#xA;    app: privatebin&#xA;spec:&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: privatebin&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: privatebin&#xA;    spec:&#xA;      securityContext:&#xA;        runAsUser: 65534&#xA;        runAsGroup: 82&#xA;        fsGroup: 82&#xA;      containers:&#xA;      - name: privatebin&#xA;        image: privatebin/nginx-fpm-alpine:stable&#xA;        ports:&#xA;        - containerPort: 8080&#xA;        env:&#xA;        - name: TZ&#xA;          value: Antarctica/South_Pole&#xA;        - name: PHP_TZ&#xA;          value: Antarctica/South_Pole&#xA;        securityContext:&#xA;          readOnlyRootFilesystem: true&#xA;          privileged: false&#xA;          allowPrivilegeEscalation: false&#xA;        livenessProbe:&#xA;          httpGet:&#xA;            path: /&#xA;            port: 8080&#xA;        readinessProbe:&#xA;          httpGet:&#xA;            path: /&#xA;            port: 8080&#xA;        volumeMounts:&#xA;        - mountPath: /srv/data&#xA;          name: privatebin-data&#xA;          readOnly: False&#xA;        - mountPath: /run&#xA;          name: run&#xA;          readOnly: False&#xA;        - mountPath: /tmp&#xA;          name: tmp&#xA;          readOnly: False&#xA;        - mountPath: /var/lib/nginx/tmp&#xA;          name: nginx-cache&#xA;          readOnly: False&#xA;  volumes:&#xA;    - name: run&#xA;      emptyDir:&#xA;        medium: &#34;Memory&#34;&#xA;    - name: tmp&#xA;      emptyDir:&#xA;        medium: &#34;Memory&#34;&#xA;    - name: nginx-cache&#xA;      emptyDir: {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the volume &lt;code&gt;privatebin-data&lt;/code&gt; has to be a shared, persisted volume across all nodes, i.e. on an NFS share. As of PrivateBin 1.4.0 it is no longer required, when using a database or Google Cloud Storage.&lt;/p&gt; &#xA;&lt;h2&gt;Running administrative scripts&lt;/h2&gt; &#xA;&lt;p&gt;The image includes two administrative scripts, which you can use to migrate from one storage backend to another, delete pastes by ID, removing empty directories when using the Filesystem backend, to purge all expired pastes and display statistics. These can be executed within the running image or by running the commands as alternative entrypoints with the same volumes attached as in the running service image. The former option is recommended.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# assuming you named your container &#34;privatebin&#34; using the option: --name privatebin&#xA;&#xA;$ docker exec -t privatebin administration --help&#xA;Usage:&#xA;  administration [--delete &amp;lt;paste id&amp;gt; | --empty-dirs | --help | --purge | --statistics]&#xA;&#xA;Options:&#xA;  -d, --delete      deletes the requested paste ID&#xA;  -e, --empty-dirs  removes empty directories (only if Filesystem storage is&#xA;                    configured)&#xA;  -h, --help        displays this help message&#xA;  -p, --purge       purge all expired pastes&#xA;  -s, --statistics  reads all stored pastes and comments and reports statistics&#xA;&#xA;$ docker exec -t privatebin migrate --help&#xA;migrate - Copy data between PrivateBin backends&#xA;&#xA;Usage:&#xA;  migrate [--delete-after] [--delete-during] [-f] [-n] [-v] srcconfdir&#xA;          [&amp;lt;dstconfdir&amp;gt;]&#xA;  migrate [-h|--help]&#xA;&#xA;Options:&#xA;  --delete-after   delete data from source after all pastes and comments have&#xA;                   successfully been copied to the destination&#xA;  --delete-during  delete data from source after the current paste and its&#xA;                   comments have successfully been copied to the destination&#xA;  -f               forcefully overwrite data which already exists at the&#xA;                   destination&#xA;  -h, --help       displays this help message&#xA;  -n               dry run, do not copy data&#xA;  -v               be verbose&#xA;  &amp;lt;srcconfdir&amp;gt;     use storage backend configuration from conf.php found in&#xA;                   this directory as source&#xA;  &amp;lt;dstconfdir&amp;gt;     optionally, use storage backend configuration from conf.php&#xA;                   found in this directory as destination; defaults to:&#xA;                   /srv/bin/../cfg/conf.php&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that in order to migrate between different storage backends, you will need to use the all-in-one image called &lt;code&gt;privatebin/nginx-fpm-alpine&lt;/code&gt;, as it includes all the necessary drivers and libraries for the supported backends. When using the variant images, you will only be able to migrate between two backends of the same storage type - for example, two filesystem paths or two database backends.&lt;/p&gt; &#xA;&lt;h2&gt;Rolling your own image&lt;/h2&gt; &#xA;&lt;p&gt;To reproduce the image, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ docker build -t privatebin/nginx-fpm-alpine .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Behind the scenes&lt;/h3&gt; &#xA;&lt;p&gt;The two processes, Nginx and php-fpm, are started by s6.&lt;/p&gt; &#xA;&lt;p&gt;Nginx is required to serve static files and caches them, too. Requests to the index.php (which is the only PHP file exposed in the document root at /var/www) are passed to php-fpm via a socket at /run/php-fpm.sock. All other PHP files and the data are stored under /srv.&lt;/p&gt; &#xA;&lt;p&gt;The Nginx setup supports only HTTP, so make sure that you run a reverse proxy in front of this for HTTPS offloading and reducing the attack surface on your TLS stack. The Nginx in this image is set up to deflate/gzip text content.&lt;/p&gt; &#xA;&lt;p&gt;During the build of the image, the PrivateBin release archive is downloaded from Github. All the downloaded Alpine packages and the PrivateBin archive are validated using cryptographic signatures to ensure they have not been tempered with, before deploying them in the image.&lt;/p&gt;</summary>
  </entry>
</feed>