<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-06T01:32:44Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ledermann/docker-rails-base</title>
    <updated>2023-02-06T01:32:44Z</updated>
    <id>tag:github.com,2023-02-06:/ledermann/docker-rails-base</id>
    <link href="https://github.com/ledermann/docker-rails-base" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Optimized Docker base images for Rails applications&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ledermann/docker-rails-base/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/ledermann/docker-rails-base/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Build images&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;DockerRailsBase&lt;/h1&gt; &#xA;&lt;p&gt;Building Docker images usually takes a long time. This repo contains base images with preinstalled dependencies for &lt;a href=&#34;https://rubyonrails.org/&#34;&gt;Ruby on Rails&lt;/a&gt;, so building a production image will be &lt;strong&gt;2-3 times faster&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What?&lt;/h2&gt; &#xA;&lt;p&gt;When using the official Ruby image, building a Docker image for a typical Rails application requires lots of time for installing dependencies - mainly OS packages, Ruby gems, Ruby gems with native extensions (Nokogiri etc.) and Node modules. This is required every time the app needs to be deployed to production.&lt;/p&gt; &#xA;&lt;p&gt;I was looking for a way to reduce this time, so I created base images that contain most of the dependencies used in my applications.&lt;/p&gt; &#xA;&lt;p&gt;And while I&#39;m at it, I also moved as much as possible from the app-specific Dockerfile into the base image by using &lt;a href=&#34;https://docs.docker.com/engine/reference/builder/#onbuild&#34;&gt;ONBUILD&lt;/a&gt; triggers. This makes the Dockerfile in my apps small and simple.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;I compared building times using a typical Rails application. This is the result on my local machine:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Based on official Ruby image: &lt;strong&gt;4:50 min&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Based on DockerRailsBase: &lt;strong&gt;1:57 min&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As you can see, using DockerRailsBase is more than &lt;strong&gt;2 times faster&lt;/strong&gt; compared to the official Ruby image. It saves nearly &lt;strong&gt;3min&lt;/strong&gt; on every build.&lt;/p&gt; &#xA;&lt;p&gt;Note: Before I started timing, the base image was not available on my machine, so it was downloaded first, which took some time. If the base image is already available, the building time is only 1:18min (&lt;strong&gt;3 times faster&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;p&gt;This repo is based on the following assumptions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Your Docker host is compatible with &lt;a href=&#34;https://wiki.alpinelinux.org/wiki/Release_Notes_for_Alpine_3.17.0&#34;&gt;Alpine Linux 3.17&lt;/a&gt;, which requires Docker 20.10.0 or later&lt;/li&gt; &#xA; &lt;li&gt;Your app is compatible with &lt;a href=&#34;https://github.com/docker-library/ruby/raw/master/3.1/alpine3.17/Dockerfile&#34;&gt;Ruby 3.1 for Alpine Linux&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Your app uses Ruby on Rails 6.0, 6.1 or 7.0&lt;/li&gt; &#xA; &lt;li&gt;Your app uses PostgreSQL, SQLite or MySQL/MariaDB&lt;/li&gt; &#xA; &lt;li&gt;Your app installs Node modules with &lt;a href=&#34;https://yarnpkg.com/&#34;&gt;Yarn&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Your app bundles JavaScript with &lt;code&gt;rails assets:precompile&lt;/code&gt;. This works with &lt;a href=&#34;https://github.com/ElMassimo/vite_ruby&#34;&gt;Vite Ruby&lt;/a&gt;, &lt;a href=&#34;https://github.com/rails/webpacker&#34;&gt;Webpacker&lt;/a&gt;, &lt;a href=&#34;https://github.com/rails/sprockets-rails&#34;&gt;Asset pipeline (Sprockets)&lt;/a&gt; and others.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If your project differs from this, I suggest to fork this project and create your own base image.&lt;/p&gt; &#xA;&lt;h2&gt;How?&lt;/h2&gt; &#xA;&lt;p&gt;It uses &lt;a href=&#34;https://docs.docker.com/develop/develop-images/multistage-build/&#34;&gt;multi-stage building&lt;/a&gt; to build a very small production image. There are two Dockerfiles in this repo, one for the first stage (called &lt;code&gt;Builder&lt;/code&gt;) and one for the resulting stage (called &lt;code&gt;Final&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Builder stage&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Builder&lt;/code&gt; stage installs Ruby gems and Node modules. It also includes Git, Node.js and some build tools - all we need to compile assets.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Based on &lt;a href=&#34;https://github.com/docker-library/ruby/raw/master/3.2/alpine3.17/Dockerfile&#34;&gt;ruby:3.2.0-alpine&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Adds packages needed for installing gems and compiling assets: Git, Node.js, Yarn, PostgreSQL client and build tools&lt;/li&gt; &#xA; &lt;li&gt;Adds some default Ruby gems (Rails 7.0 etc., see &lt;a href=&#34;https://raw.githubusercontent.com/ledermann/docker-rails-base/main/Builder/Gemfile&#34;&gt;Gemfile&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Adds some default Node modules (Turbo, Stimulus, TailwindCSS etc., see &lt;a href=&#34;https://raw.githubusercontent.com/ledermann/docker-rails-base/main/Builder/package.json&#34;&gt;package.json&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Via ONBUILD triggers it installs missing gems and Node modules, then compiles the assets&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/ledermann/docker-rails-base/main/Builder/Dockerfile&#34;&gt;Builder/Dockerfile&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Final stage&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Final&lt;/code&gt; stage builds the production image, which includes just the bare minimum.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Based on &lt;a href=&#34;https://github.com/docker-library/ruby/raw/master/3.2/alpine3.17/Dockerfile&#34;&gt;ruby:3.2.0-alpine&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Adds packages needed for production: postgresql-client, tzdata, file&lt;/li&gt; &#xA; &lt;li&gt;Via ONBUILD triggers it mainly copies the app and gems from the &lt;code&gt;Builder&lt;/code&gt; stage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/ledermann/docker-rails-base/main/Final/Dockerfile&#34;&gt;Final/Dockerfile&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Staying up-to-date&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://dependabot.com/&#34;&gt;Dependabot&lt;/a&gt;, every updated Ruby gem or Node module results in an updated image.&lt;/p&gt; &#xA;&lt;h3&gt;How to use for your Rails application&lt;/h3&gt; &#xA;&lt;h4&gt;Building the Docker image&lt;/h4&gt; &#xA;&lt;p&gt;Add this &lt;code&gt;Dockerfile&lt;/code&gt; to your application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM ledermann/rails-base-builder:3.2.0-alpine AS Builder&#xA;FROM ledermann/rails-base-final:3.2.0-alpine&#xA;USER app&#xA;CMD [&#34;bundle&#34;, &#34;exec&#34;, &#34;puma&#34;, &#34;-C&#34;, &#34;config/puma.rb&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Yes, this is the complete &lt;code&gt;Dockerfile&lt;/code&gt; of your Rails app. It&#39;s so simple because the work is done by ONBUILD triggers.&lt;/p&gt; &#xA;&lt;p&gt;Now build the image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Building the Docker image with BuildKit&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/develop/develop-images/build_enhancements/&#34;&gt;BuildKit&lt;/a&gt; requires a little &lt;a href=&#34;https://github.com/moby/buildkit/issues/816&#34;&gt;workaround&lt;/a&gt; to trigger the ONBUILD statements. Add a &lt;code&gt;COPY&lt;/code&gt; statement to the &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM ledermann/rails-base-builder:3.2.0-alpine AS Builder&#xA;FROM ledermann/rails-base-final:3.2.0-alpine&#xA;&#xA;# Workaround to trigger Builder&#39;s ONBUILDs to finish:&#xA;COPY --from=Builder /etc/alpine-release /tmp/dummy&#xA;&#xA;USER app&#xA;CMD [&#34;bundle&#34;, &#34;exec&#34;, &#34;puma&#34;, &#34;-C&#34;, &#34;config/puma.rb&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can build the image with BuildKit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker buildx build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use private npm/Yarn packages by mounting the config file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker buildx build --secret id=npmrc,src=$HOME/.npmrc .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker buildx build --secret id=yarnrc,src=$HOME/.yarnrc.yml .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a similar way you can provide a configuration file for Bundler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker buildx build --secret id=bundleconfig,src=$HOME/.bundle/config .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Continuous integration (CI)&lt;/h4&gt; &#xA;&lt;p&gt;Example to build the application&#39;s image with GitHub Actions and push it to the GitHub Container Registry:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:&#xA;  runs-on: ubuntu-latest&#xA;&#xA;  steps:&#xA;    - uses: actions/checkout@v2&#xA;      with:&#xA;        fetch-depth: 0&#xA;&#xA;    - name: Fetch tag annotations&#xA;      # https://github.com/actions/checkout/issues/290&#xA;      run: git fetch --tags --force&#xA;&#xA;    - name: Login to GitHub Container Registry&#xA;      uses: docker/login-action@v1&#xA;      with:&#xA;        registry: ghcr.io&#xA;        username: ${{ github.repository_owner }}&#xA;        password: ${{ secrets.GITHUB_TOKEN }}&#xA;&#xA;    - name: Build the image&#xA;      run: |&#xA;        export COMMIT_TIME=$(git show -s --format=%cI ${GITHUB_SHA})&#xA;        export COMMIT_SHA=${GITHUB_SHA}&#xA;        export COMMIT_VERSION=$(git describe)&#xA;        docker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA --build-arg COMMIT_VERSION -t ghcr.io/user/repo:latest .&#xA;&#xA;    - name: Push the image&#xA;      run: docker push ghcr.io/user/repo:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Available Docker images&lt;/h2&gt; &#xA;&lt;p&gt;Both Docker images (&lt;code&gt;Builder&lt;/code&gt; and &lt;code&gt;Final&lt;/code&gt;) are regularly published at DockerHub and tagged with the current Ruby version:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/ledermann/rails-base-builder/tags&#34;&gt;https://hub.docker.com/r/ledermann/rails-base-builder/tags&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/ledermann/rails-base-final/tags&#34;&gt;https://hub.docker.com/r/ledermann/rails-base-final/tags&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Beware: The published images are &lt;strong&gt;not&lt;/strong&gt; immutable. When a dependency (e.g. Ruby gem) is updated, the images will be republished using the &lt;strong&gt;same&lt;/strong&gt; tag.&lt;/p&gt; &#xA;&lt;p&gt;When a new Ruby version comes out, a new tag is introduced and the images will be published using this tag and the former images will not be updated anymore. Here is a list of the tags that have been used in this repo so far:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Ruby version&lt;/th&gt; &#xA;   &lt;th&gt;Tag&lt;/th&gt; &#xA;   &lt;th&gt;First published&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.2.0&lt;/td&gt; &#xA;   &lt;td&gt;3.2.0-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2023-01-13&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.1.3&lt;/td&gt; &#xA;   &lt;td&gt;3.1.3-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2022-11-26&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.1.2&lt;/td&gt; &#xA;   &lt;td&gt;3.1.2-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2022-04-13&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.1.1&lt;/td&gt; &#xA;   &lt;td&gt;3.1.1-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2022-02-19&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.1.0&lt;/td&gt; &#xA;   &lt;td&gt;3.1.0-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2022-01-08&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.0.3&lt;/td&gt; &#xA;   &lt;td&gt;3.0.3-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2021-11-24&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.0.2&lt;/td&gt; &#xA;   &lt;td&gt;3.0.2-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2021-07-08&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.0.1&lt;/td&gt; &#xA;   &lt;td&gt;3.0.1-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2021-04-06&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.0.0&lt;/td&gt; &#xA;   &lt;td&gt;3.0.0-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2021-02-15&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2.7.2&lt;/td&gt; &#xA;   &lt;td&gt;2.7.2-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2020-10-10&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2.7.1&lt;/td&gt; &#xA;   &lt;td&gt;2.7.1-alpine&lt;/td&gt; &#xA;   &lt;td&gt;2020-05-20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2.6.6&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;2020-04-01&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2.6.5&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;2020-01-24&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The latest Docker images are also tagged as &lt;code&gt;latest&lt;/code&gt;. However, it is not recommended to use this tag in your Rails application, because updating an app to a new Ruby version usually requires some extra work.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Why not simply use layer caching?&lt;/h3&gt; &#xA;&lt;p&gt;Docker supports layer caching, so for building images it performs just the needed steps: If there is a layer from a former build and nothing has changed, it will be used. But for dependencies, this means: If a single Ruby gem in the application was updated or added, the step with &lt;code&gt;bundle install&lt;/code&gt; is run again, so &lt;strong&gt;all&lt;/strong&gt; gems will be installed again.&lt;/p&gt; &#xA;&lt;p&gt;Using a prebuilt image improves installing dependencies a lot, because only the different/updated dependencies will be installed - all existing ones will be reused.&lt;/p&gt; &#xA;&lt;h3&gt;What if my app requires slightly different dependencies?&lt;/h3&gt; &#xA;&lt;p&gt;This doesn&#39;t matter:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A missing Alpine package can be installed with &lt;code&gt;apk add&lt;/code&gt; inside your app&#39;s Dockerfile.&lt;/li&gt; &#xA; &lt;li&gt;A missing Node module (or version) will be installed with &lt;code&gt;rails assets:precompile&lt;/code&gt; via the ONBUILD trigger.&lt;/li&gt; &#xA; &lt;li&gt;A missing Ruby gem (or version) will be installed with &lt;code&gt;bundle install&lt;/code&gt; via the ONBUILD trigger.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;There are gems included that my app doesn&#39;t need. Will they bloat the resulting image?&lt;/h3&gt; &#xA;&lt;p&gt;No. In the build stage there is a &lt;code&gt;bundle clean --force&lt;/code&gt;, which uninstalls all gems not referenced in the app&#39;s Gemfile.&lt;/p&gt;</summary>
  </entry>
</feed>