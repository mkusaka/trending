<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-17T01:39:04Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SalesLoft/docker-ruby-jemalloc</title>
    <updated>2022-07-17T01:39:04Z</updated>
    <id>tag:github.com,2022-07-17:/SalesLoft/docker-ruby-jemalloc</id>
    <link href="https://github.com/SalesLoft/docker-ruby-jemalloc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ruby jemalloc base image for Salesloft&lt;/h1&gt; &#xA;&lt;p&gt;Custom Docker image containing a Ruby build with jemalloc. Primarily used as a base image for Melody.&lt;/p&gt; &#xA;&lt;p&gt;Note: You should not build and push this repository from a laptop. GitHub Actions will build and push using the included Docker workflow.&lt;/p&gt; &#xA;&lt;h2&gt;Building multiple architectures&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker build --platform linux/amd64 -t salesloft/ruby-jemalloc:2.5.5-buster-slim-linux-amd64 .&#xA;docker push salesloft/ruby-jemalloc:2.5.5-buster-slim-linux-amd64&#xA;&#xA;docker build --platform linux/arm64 -t salesloft/ruby-jemalloc:2.5.5-buster-slim-linux-arm64 .&#xA;docker push salesloft/ruby-jemalloc:2.5.5-buster-slim-linux-arm64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Creating the manifest and pushing to Docker Hub&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker manifest create salesloft/ruby-jemalloc:2.5.5-buster-slim \&#xA;    --amend salesloft/ruby-jemalloc:2.5.5-buster-slim-linux-amd64 \&#xA;    --amend salesloft/ruby-jemalloc:2.5.5-buster-slim-linux-arm64&#xA;docker manifest push salesloft/ruby-jemalloc:2.5.5-buster-slim&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>Hubok/MultiModeBridge</title>
    <updated>2022-07-17T01:39:04Z</updated>
    <id>tag:github.com,2022-07-17:/Hubok/MultiModeBridge</id>
    <link href="https://github.com/Hubok/MultiModeBridge" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MultiModeBridge&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://lax1.w3fur.radio/container_map.png&#34; alt=&#34;Chart of Docker containers&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NicolasPereira/nodejs-api-tcc</title>
    <updated>2022-07-17T01:39:04Z</updated>
    <id>tag:github.com,2022-07-17:/NicolasPereira/nodejs-api-tcc</id>
    <link href="https://github.com/NicolasPereira/nodejs-api-tcc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;API feita em NodeJS para cadastrar e gerenciar lista de compras&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NodeJS API&lt;/h1&gt; &#xA;&lt;p&gt;API feita em NodeJS para cadastrar e gerenciar lista de compras no fluxo de um trabalho de conclusão de curso!&lt;/p&gt; &#xA;&lt;p&gt;Arquitetura Macro do Projeto: &lt;img src=&#34;https://raw.githubusercontent.com/NicolasPereira/nodejs-api-tcc/main/docs/macro.jpg&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;O Projeto de Conclusão de Curso tem como ideia facilitar a criação de lista de compras através do reconhecimento de imagem, dessa forma o usuário scanneia sua compra e armazenamos todos os itens de sua compra, na sua próxima compra o usuário deve apenas scannear os produtos que restaram, deste modo a aplicação deve gerar a lista de compras baseada nos itens da última compra e nos itens que o usuário já possui.&lt;/p&gt; &#xA;&lt;p&gt;Está API tem a responsabilidade de se comunicar com a aplicação mobile, realizar a validação de regra de negócio e persistir os dados no banco de dados.&lt;/p&gt; &#xA;&lt;h2&gt;Tecnologias&lt;/h2&gt; &#xA;&lt;p&gt;1 - NodeJS 2 - Express 3 - Prisma (ORM) 4 - PostgreeSQL 5 - Docker&lt;/p&gt; &#xA;&lt;h2&gt;Como Rodar o projeto&lt;/h2&gt; &#xA;&lt;p&gt;1 - Clone este repositório&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone git@github.com:NicolasPereira/nodejs-api-tcc.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;2 - Build a imagem&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker-compose build image -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;3 - O serviço estara rodando na porta &lt;code&gt;3000&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;4 - Para parar a aplicação&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker-compose down&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;5 - Para iniciar a aplicação após a imagem já estar buildada&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker-compose up&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>