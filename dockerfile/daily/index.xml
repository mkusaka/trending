<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dockerfile Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-01T01:32:49Z</updated>
  <subtitle>Daily Trending of Dockerfile in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Mrzyang/doprax_ss</title>
    <updated>2023-01-01T01:32:49Z</updated>
    <id>tag:github.com,2023-01-01:/Mrzyang/doprax_ss</id>
    <link href="https://github.com/Mrzyang/doprax_ss" rel="alternate"></link>
    <summary type="html">&lt;p&gt;build ss with v2ray-plugin server on dorpax docker container&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ss with v2ray-plugin on Doprax&lt;/h1&gt; &#xA;&lt;p&gt;you should use the client supporting ss with v2ray-plugin, like Matsuri on Android, shadowsocket on ios and so on. Clash is advised because Matsuri can not often be connected when visiting youtube and some other websites.&lt;/p&gt; &#xA;&lt;p&gt;the ss configuration on Matsuri is like the following imageï¼š&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Mrzyang/doprax_ss/raw/master/Matsuri_configuration.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;then you can get the ss link by Matsuri and import to clash.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mebaysan/DockerElKitabi</title>
    <updated>2023-01-01T01:32:49Z</updated>
    <id>tag:github.com,2023-01-01:/mebaysan/DockerElKitabi</id>
    <link href="https://github.com/mebaysan/DockerElKitabi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Docker Ã–ÄŸrenirken AldÄ±ÄŸÄ±m Notlar&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#&amp;nbsp;Ä°Ã§indekiler&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#giri%C5%9F&#34;&gt;GiriÅŸ&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#neden-docker&#34;&gt;Neden Docker&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#sanalla%C5%9Ft%C4%B1rma&#34;&gt;SanallaÅŸtÄ±rma&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-linux&#34;&gt;Container (Linux)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-engine&#34;&gt;Docker Engine&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#image-ve-container-docker&#34;&gt;Image ve Container (Docker)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#image-registry&#34;&gt;Image Registry&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#kurulum-yapmadan-docker-kullanmak&#34;&gt;Kurulum Yapmadan Docker Kullanmak&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-101&#34;&gt;Container 101&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-cli&#34;&gt;Docker CLI&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-temelleri-1&#34;&gt;Container Temelleri-1&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-temelleri-2&#34;&gt;Container Temelleri-2&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-temelleri-3&#34;&gt;Container Temelleri-3&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-katmanl%C4%B1-dosya-sistemi-yap%C4%B1s%C4%B1&#34;&gt;Docker KatmanlÄ± Dosya Sistemi YapÄ±sÄ±&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-container-ya%C5%9Fam-s%C3%BCresi-lifecycle&#34;&gt;Docker Container YaÅŸam SÃ¼resi (Lifecycle)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-volume-container-d%C4%B1%C5%9F%C4%B1-veri-saklama&#34;&gt;Docker Volume-Container DÄ±ÅŸÄ± Veri Saklama&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-bo%C5%9F-dolu-volume-davran%C4%B1%C5%9Flar%C4%B1&#34;&gt;Docker BoÅŸ-Dolu Volume DavranÄ±ÅŸlarÄ±&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#bind-mounts&#34;&gt;Bind Mounts&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-102&#34;&gt;Container 102&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-network-driver&#34;&gt;Docker Network Driver&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-network-objeleri-1&#34;&gt;Docker Network Objeleri-1&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-network-objeleri-2-port-publish&#34;&gt;Docker Network Objeleri-2-Port Publish&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-network-objeleri-3&#34;&gt;Docker Network Objeleri-3&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#logging-uygulama-g%C3%BCnl%C3%BCkleri&#34;&gt;Logging Uygulama GÃ¼nlÃ¼kleri&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-stats-ve-top&#34;&gt;Docker Stats ve Top&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-cpu-ve-memory-limitleri&#34;&gt;Container Cpu ve Memory Limitleri&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#environment-variables-ortam-de%C4%9Fi%C5%9Fkenleri&#34;&gt;Environment Variables (Ortam DeÄŸiÅŸkenleri)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#image-ve-registry&#34;&gt;Image ve Registry&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#image-i%CC%87simlendirme-ve-tag-yap%C4%B1s%C4%B1&#34;&gt;Image Ä°simlendirme ve Tag YapÄ±sÄ±&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#image-olu%C5%9Fturma&#34;&gt;Image oluÅŸturma&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#dockerfile-1&#34;&gt;Dockerfile-1&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#dockerfile-parametreleri&#34;&gt;Dockerfile Parametreleri&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#dockerfile-2&#34;&gt;Dockerfile-2&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#dockerfile-3&#34;&gt;Dockerfile-3&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#dockerfile-4&#34;&gt;Dockerfile-4&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#linux-shell-trickleri&#34;&gt;Linux Shell Trickleri&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#dockerfile-5&#34;&gt;Dockerfile-5&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#add-ve-copy-fark%C4%B1&#34;&gt;ADD ve COPY FarkÄ±&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#entrypoint-ve-cmd-fark%C4%B1&#34;&gt;ENTRYPOINT ve CMD FarkÄ±&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#exec-form-ve-shell-form-fark%C4%B1&#34;&gt;Exec Form ve Shell Form FarkÄ±&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#multi-stage-build&#34;&gt;Multi-stage Build&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#arg&#34;&gt;ARG&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-commit&#34;&gt;Docker Commit&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-save-load&#34;&gt;Docker Save-Load&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#registry&#34;&gt;Registry&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#compose-ve-swarm&#34;&gt;Compose ve Swarm&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-compose&#34;&gt;Docker Compose&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-compose-cli&#34;&gt;Docker Compose CLI&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-compose-yaml-dosyas%C4%B1&#34;&gt;Docker Compose Yaml DosyasÄ±&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-compose-build&#34;&gt;Docker Compose Build&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#container-orchestration&#34;&gt;Container Orchestration&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-swarm&#34;&gt;Docker Swarm&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#swarm-manager-ve-worker-node&#34;&gt;Swarm Manager ve Worker Node&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#manager-node&#34;&gt;Manager Node&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#worker-node&#34;&gt;Worker Node&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-swarm-init&#34;&gt;Docker Swarm init&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#swarm-service&#34;&gt;Swarm Service&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#overlay-network&#34;&gt;Overlay Network&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-secret&#34;&gt;Docker Secret&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/#docker-stack&#34;&gt;Docker Stack&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;GiriÅŸ&lt;/h1&gt; &#xA;&lt;p&gt;Docker Ã¶ÄŸrenirken aldÄ±ÄŸÄ±m notlar.&lt;/p&gt; &#xA;&lt;p&gt;Genellikle Ã–zgÃ¼r Ã–ztÃ¼rk&#39;Ã¼n &lt;a href=&#34;https://www.udemy.com/course/adan-zye-docker/&#34;&gt;Docker eÄŸitimi&lt;/a&gt;ni izlerken not aldÄ±m.&lt;/p&gt; &#xA;&lt;p&gt;Elimin altÄ±nda TÃ¼rkÃ§e kaynak olmasÄ± iÃ§in &lt;a href=&#34;https://www.amazon.com.tr/Docker-Konteyner-Uygulamalar%C4%B1-Deniz-Parlak/dp/6058060761/ref=sxts_sxwds-bia-wc-rsf-lq2a1_0?__mk_tr_TR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;amp;cv_ct_cx=docker&amp;amp;dchild=1&amp;amp;keywords=docker&amp;amp;pd_rd_i=6058060761&amp;amp;pd_rd_r=adeb9eba-433e-4a3e-86e0-e81304013581&amp;amp;pd_rd_w=yeCbD&amp;amp;pd_rd_wg=E8mQH&amp;amp;pf_rd_p=1afd11f1-1dc6-4ec0-a331-2a221d78fd95&amp;amp;pf_rd_r=ZQNNXBF5BV4D5Z92G71P&amp;amp;psc=1&amp;amp;qid=1610552031&amp;amp;sr=1-1-569cd1f4-72a6-4f1d-b3c5-cf7f1ae39fbb&#34;&gt;Docker ve Konteyner UygulamalarÄ±&lt;/a&gt; kitabÄ±nÄ± almÄ±ÅŸtÄ±m ve bazen buradan faydalandÄ±m.&lt;/p&gt; &#xA;&lt;p&gt;*Metinlerin bir bÃ¶lÃ¼mÃ¼nÃ¼ Ã–zgÃ¼r Hoca&#39;nÄ±n sunumundan aldÄ±m.&lt;/p&gt; &#xA;&lt;p&gt;*NaÃ§izane; &lt;a href=&#34;https://www.udemy.com/course/adan-zye-docker/&#34;&gt;eÄŸitimi&lt;/a&gt; ÅŸiddetle Ã¶nerebilirim&lt;/p&gt; &#xA;&lt;h2&gt;Neden Docker&lt;/h2&gt; &#xA;&lt;p&gt;Yeni nesil IT sistemleri Docker Ã¼zerinde koÅŸuyor. En Ã§ok kullanÄ±lmak istenen platformlar listesinde Ã¼st sÄ±ralarda yer alÄ±yor. Ä°ÅŸ ilanlarÄ±nda aranan bir Ã¶zellik &lt;span&gt;ğŸ˜œ&lt;/span&gt;&lt;/p&gt; &#xA;&lt;h2&gt;SanallaÅŸtÄ±rma&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Temelde bir fiziksel makina Ã¼zerinde birden fazla sanal makina kurup, kaynak daÄŸÄ±tÄ±mÄ±nÄ± ve ortak kaynak kullanÄ±mÄ±nÄ± saÄŸlayan sisteme verilen isimdir.&lt;/li&gt; &#xA; &lt;li&gt;Bu sayede fiziksel sunuculardaki atÄ±l kapasiteyi minimuma indirebiliriz. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Kaynak israfÄ± Ã¶nlenir&lt;/li&gt; &#xA;   &lt;li&gt;Her uygulama izole edilmiÅŸtir, bu sayede bir uygulamada Ã§Ä±kan sorun diÄŸer uygulamalarÄ± etkilemeyecektir&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Container (Linux)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SanallaÅŸtÄ±rma her ne kadar kaynak israfÄ±nÄ± minimuma indirse de yine de kaynak israfÄ± mevcuttur. Bu sebeple container&#39;lar hayatÄ±mÄ±za girdi.&lt;/li&gt; &#xA; &lt;li&gt;Linux containerlar sayesinde uygulamalar izole bir ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±labildi fakat bu kolay bir iÅŸlem deÄŸildi.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Namespaces&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Linux Ã§ekirdeÄŸinde bulunan yapÄ± taÅŸlarÄ±ndandÄ±r. Prensibi Ã§ekirdek kaynaklarrÄ±nÄ±n bÃ¶lÃ¼mlere ayrÄ±lmasÄ±dÄ±r. Container izolasyonunun saÄŸlanmasÄ±ndaki birincil yapÄ±dÄ±r.&lt;/li&gt; &#xA;   &lt;li&gt;BazÄ± namespaces&#39;ler &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Net: AÄŸ arayÃ¼zlerini yÃ¶netir&lt;/li&gt; &#xA;     &lt;li&gt;PID: SÃ¼reÃ§lerin izolasyonunu saÄŸlar&lt;/li&gt; &#xA;     &lt;li&gt;Mnt: Dosya sistemindeki mount noktalarÄ±nÄ± yÃ¶netir&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cgroups&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Linux Ã§ekirdeÄŸinin kullandÄ±ÄŸÄ± temel bileÅŸenlerdendir. DonanÄ±m kaynaklarÄ±nÄ±n sÄ±nÄ±rlandÄ±rÄ±lmasÄ±, kÄ±sÄ±tlama ve limit Ã¶zelliklerinin saÄŸlanmasÄ± iÃ§in kullanÄ±lÄ±r&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Container&#39;lar; host makinede izole olarak Ã§alÄ±ÅŸan, kullanÄ±cÄ± tarafÄ±ndan her ÅŸekilde mÃ¼dahale edilebilen &lt;strong&gt;sanal birimdir&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;AynÄ± sistem Ã¼zerinde Ã§alÄ±ÅŸÄ±rlar, o sistemin Ã§ekirdeÄŸini kullanÄ±rlar fakat birbirlerinden tamamen izole durumdalardÄ±r.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker Engine&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker engine; client-server mimarisinde bir uygulamadÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Docker platformunun kalbidir&lt;/li&gt; &#xA; &lt;li&gt;Docker Daemon, Docker Client, REST API bileÅŸenlerinden (temel) oluÅŸur&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Docker Daemon&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;REST API isteklerini karÅŸÄ±lar&lt;/li&gt; &#xA;   &lt;li&gt;Docker objelerini Ã¼retmemizi ve yÃ¶netmemizi saÄŸlar (Container, image, volume vb bileÅŸenler)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rest API&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;DiÄŸer uygulamalar rest api sayesinde docker daemon ile konuÅŸur&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Docker CLI (Client)&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Rest API&#39;nin en Ã¶nemli kullanÄ±cÄ±sÄ± Docker CLI&#39;dÄ±r&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Bir docker engine kurduÄŸumuzda o makinede hem docker server (daemon) hem de docker client (docker cli) kurulmuÅŸ olur&lt;/li&gt; &#xA; &lt;li&gt;Ä°stersek bu client (docker cli) uygulamasÄ±nÄ± localimize kurarak, cloudda kurduÄŸumuz bir server (docker daemon)&#39;Ä± yÃ¶netebiliriz. Yani bu 2 uygulama birbirinden farklÄ±dÄ±r.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/static/giris/giris-1.png&#34; alt=&#34;docker-components&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Image ve Container (Docker)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker image&#39;lerde kernel&#39;e gerek yoktur&lt;/li&gt; &#xA; &lt;li&gt;Image&#39;ler birer ÅŸablondur&lt;/li&gt; &#xA; &lt;li&gt;Bir image&#39;i bir yerde depolayabilirsem, docker engine sayesinde bu image&#39;i Ã§alÄ±ÅŸtÄ±rabilirim&lt;/li&gt; &#xA; &lt;li&gt;Container&#39;lar sayesinde image&#39;leri depolayabiliriz&lt;/li&gt; &#xA; &lt;li&gt;Container dediÄŸimiz ÅŸey aslÄ±nda bir nevi image&#39;lerin Ã§alÄ±ÅŸÄ±r halidir. Container image ÅŸablonunun Ã§alÄ±ÅŸan kopyasÄ±dÄ±r olarak dÃ¼ÅŸÃ¼nebiliriz&lt;/li&gt; &#xA; &lt;li&gt;Bu sayede her sistemde her seferinde aynÄ± sonucu alÄ±rÄ±z. Bir yerde Ã§alÄ±ÅŸan container her yerde Ã§alÄ±ÅŸÄ±r&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Image Registry&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Container Registry, Container Image Registry, Docker Registry olarak da bilinir&lt;/li&gt; &#xA; &lt;li&gt;Docker imajlarÄ±nÄ± depolayÄ±p daÄŸÄ±tabildiÄŸimiz bir alt yapÄ± servisidir&lt;/li&gt; &#xA; &lt;li&gt;En bilineni Docker Engine&#39;Ä±n default olarak baktÄ±ÄŸÄ± yer olan &lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;&#39;dÄ±r&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Kurulum Yapmadan Docker Kullanmak&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://labs.play-with-docker.com/&#34;&gt;Play With Docker&lt;/a&gt; hizmeti sayesinde cloud ortamÄ±nda Docker denemeleri yapabiliriz&lt;/li&gt; &#xA; &lt;li&gt;Tek kÃ¶tÃ¼ yanÄ± bir oturumda en fazla 4 saat kullanmamÄ±za izin vermesidir&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Container 101&lt;/h1&gt; &#xA;&lt;h2&gt;Docker CLI&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker Daemon&#39;u yÃ¶netmemizi saÄŸlar&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker version&lt;/code&gt; -&amp;gt; Docker kurulumu ile ilgili temel bilgilere eriÅŸiriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker info&lt;/code&gt; -&amp;gt; Docker ile ilgili temel bilgilere eriÅŸiriz (kaÃ§ container Ã§alÄ±ÅŸÄ±yor, drivers vb.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker&lt;/code&gt; -&amp;gt; Docker CLI&#39;da kullanabileceÄŸimiz komutlarÄ± listeler &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Options&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Docker Daemon&#39;a baÄŸlanÄ±rken kullanacaÄŸÄ±mÄ±z parametreler gÃ¶zÃ¼kÃ¼r&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Management Commands&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;YÃ¶netebileceÄŸimiz bileÅŸenlerin listesi&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Commands&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;YÃ¶netmek istediÄŸimiz bileÅŸen iÃ§in Ã§alÄ±ÅŸtÄ±rmak istediÄŸimiz komut&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker image --help&lt;/code&gt; -&amp;gt; image bileÅŸeni ile kullanabileceÄŸimiz komutlarÄ± listeler&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Container Temelleri-1&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container --help&lt;/code&gt; -&amp;gt; container bileÅŸeni ile kullanabileceÄŸim komutlar&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run&lt;/code&gt; -&amp;gt; parametre olarak verdiÄŸimiz isimde bir container varsa baÅŸlatÄ±r yoksa Ã¶nce oluÅŸturur sonra baÅŸlatÄ±r&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run --name ilkcontainer ozgurozturknet/app1&lt;/code&gt; -&amp;gt; &lt;strong&gt;ilkcontainer&lt;/strong&gt; adÄ±nda bir container oluÅŸturdu ve docker hub&#39;da ozgurozturknet altÄ±ndaki varsayÄ±lan (app1) uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rdÄ±&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container ls -a&lt;/code&gt; -&amp;gt;&amp;nbsp;sistemdeki tÃ¼m container&#39;larÄ± listeler. -a olmasaydÄ± sadece Ã§alÄ±ÅŸan container&#39;larÄ± listelerdi&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Container iÃ§erisindeki varsayÄ±lan olarak Ã§alÄ±ÅŸmasÄ± iÃ§in ayarlanan uygulama durduÄŸunda container&#39;da kapatÄ±lÄ±r&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Container Temelleri-2&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run &amp;lt;IMAGE&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -p 80:80 ozgurozturknet/adanzyedocker&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;80:80 portunda Ã§alÄ±ÅŸan bir web servisi Ã§alÄ±ÅŸtÄ±rÄ±r (hazÄ±r imaj)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container ls&lt;/code&gt; komutu ile bu container&#39;Ä± gÃ¶rebiliriz. Ã‡Ã¼nkÃ¼ bu Ã§alÄ±ÅŸÄ±p kapanan bir uygulama deÄŸildir&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container logs &amp;lt;ContainerID&amp;gt;&lt;/code&gt; -&amp;gt; ID&#39;si verilen container&#39;a ait loglarÄ± gÃ¶sterir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container stop &amp;lt;ContainerID&amp;gt;&lt;/code&gt; -&amp;gt; ID&#39;si verilen container&#39;Ä± durdurur&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container start &amp;lt;ContainerID&amp;gt;&lt;/code&gt; -&amp;gt; ID&#39;si verilen container&#39;Ä± baÅŸlatÄ±r&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d -p 80:80 ozgurozturknet/adanzyedocker&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;-d&lt;/strong&gt; detach&#39;ten gelmektedir. Container direkt arka planda Ã§alÄ±ÅŸmaya baÅŸlar (terminalimize baÄŸlamaz)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container rm &amp;lt;ContainerID&amp;gt;&lt;/code&gt; -&amp;gt; ID&#39;si verilen container&#39;Ä± siler &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;illa tam id vermek zorunda deÄŸiliz id&#39;nin ilk harflerini versek de olur&lt;/li&gt; &#xA;   &lt;li&gt;Ã‡alÄ±ÅŸan bir container silinemez bunu Ã¶ncelikle durdurmamÄ±z gerekir ya da &lt;strong&gt;-f&lt;/strong&gt; parametresi kullanÄ±larak &lt;strong&gt;force&lt;/strong&gt; ederek sileriz&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container prune&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;sistemdeki Ã§alÄ±ÅŸmayan tÃ¼m container&#39;larÄ± siler&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Container Temelleri-3&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run --name websunucu -p 80:80 -d ozgurozturknet/adanzyedocker&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;websunucu adÄ±nda bir container&#39;Ä± adanzyedocker imajÄ±ndan oluÅŸturdu ve arka planda Ã§alÄ±ÅŸtÄ±rdÄ± (127.0.0.1&#39;e giderek gÃ¶rebilirsiniz)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container exec -it &amp;lt;ContainerName&amp;gt; &amp;lt;command&amp;gt;&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;it&lt;/code&gt; -&amp;gt; interaktif olarak container&#39;a baÄŸlan demek&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker container exec -it websunucu sh&lt;/code&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;websunucu container&#39;Ä±na baÄŸlan ve sh komutunu Ã§alÄ±ÅŸtÄ±r (shelle baÄŸlanÄ±r)&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;ctrl + p q&lt;/code&gt; kombinasyonu ile Container&#39;Ä± kapatmadan arka plana alabiliriz&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker cp basitapp:/app .&lt;/code&gt; -&amp;gt; &lt;strong&gt;container&#39;Ä±n kapanmÄ±ÅŸ olmasÄ± Ã¶nemli deÄŸil yeter ki silinmemiÅŸ olsun.&lt;/strong&gt; basitapp adÄ±ndaki container&#39;Ä±n app klasÃ¶rÃ¼nÃ¼ host makinadaki bu dizine kopyala dedik.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker KatmanlÄ± Dosya Sistemi YapÄ±sÄ±&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker depolama alt yapÄ±sÄ±nda &lt;strong&gt;union file system&lt;/strong&gt; adÄ± verilen bir yapÄ± kullanÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Docker imajlarÄ± mevcut bir base imaj Ã¼zerine inÅŸa edilir&lt;/li&gt; &#xA; &lt;li&gt;Bu imaj Ã¼zerine yapÄ±lan her deÄŸiÅŸiklik birer katman olarak eklenir ve bu katmanlar birer dosya olarak saklanÄ±r&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker Container YaÅŸam SÃ¼resi (Lifecycle)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TÃ¼m ayarlamalar image oluÅŸturma aÅŸamasÄ±nda yapÄ±landÄ±rÄ±lÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Tek bir uygulama Ã§alÄ±ÅŸtÄ±rmasÄ± iÃ§in dizayn edilir&lt;/li&gt; &#xA; &lt;li&gt;Bir sorun olursa saniyeler iÃ§erisinde yeni bir kopya oluÅŸturulabilir&lt;/li&gt; &#xA; &lt;li&gt;Sorun container&#39;a baÄŸlanÄ±larak Ã§Ã¶zÃ¼lmez&lt;/li&gt; &#xA; &lt;li&gt;Container iÃ§erisinde Ã§alÄ±ÅŸan ana uygulama durduÄŸu zaman container&#39;da durdurulur&lt;/li&gt; &#xA; &lt;li&gt;Container&#39;da bir sorun ile karÅŸÄ±laÅŸÄ±lÄ±rsa bu container&#39;a baÄŸlanÄ±larak deÄŸil yeni bir container oluÅŸturularak Ã§Ã¶zÃ¼lÃ¼r&lt;/li&gt; &#xA; &lt;li&gt;Container&#39;lar yeniden oluÅŸturulduÄŸunda container iÃ§erisindeki veriler sÄ±fÄ±rlanÄ±r, bunlarÄ± container dÄ±ÅŸÄ±nda tutmamÄ±z gerekir&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker Volume-Container DÄ±ÅŸÄ± Veri Saklama&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ne demiÅŸtik? Docker lifecycle sonlandÄ±ÄŸÄ±nda container iÃ§erisindeki her ÅŸey sÄ±fÄ±rlanÄ±r, yani yazdÄ±ÄŸÄ±mÄ±z dosyalar vb hiÃ§ olmamÄ±ÅŸ gibi ilk hale dÃ¶ner&lt;/li&gt; &#xA; &lt;li&gt;Volume&#39;ler Container&#39;lar dÄ±ÅŸÄ±nda veri saklamak istediÄŸimiz zaman Ã§ok kullanÄ±ÅŸlÄ±dÄ±r&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker volume create &amp;lt;VolumeName&amp;gt;&lt;/code&gt; -&amp;gt; parametre olarak verilen isimde bir volume oluÅŸturur &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker volume create ilkvolume&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker volume inspect &amp;lt;VolumeName&amp;gt;&lt;/code&gt; -&amp;gt; volume detaylarÄ±nÄ± verir &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker volume inspect ilkvolume&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -it -v ilkvolume:/uygulama alpine sh&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;alpine imajÄ±ndan bir container oluÅŸturuyorum&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;-it&lt;/strong&gt; ile container&#39;a interaktif olarak baÄŸlanÄ±p &lt;strong&gt;sh&lt;/strong&gt; komutunu Ã§alÄ±ÅŸtÄ±rÄ±yorum&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;-v&lt;/strong&gt; ile ilkvolume adÄ±ndaki volume&#39;u container iÃ§erisindeki /uygulama adÄ±ndaki klasÃ¶re baÄŸlÄ±yorum &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;-v &amp;lt;VolumeName&amp;gt;:&amp;lt;ContainerÄ°Ã§indekiKlasÃ¶r&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Ã–rneÄŸimiz gereÄŸi aÅŸaÄŸÄ±daki iÅŸlemleri gerÃ§ekleÅŸtiriyoruz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;cd uygulama&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;touch test&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;echo &#34;naber nasÄ±lsÄ±n?&#34; &amp;gt; test&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;exit&lt;/code&gt; ile conteiner&#39;dan Ã§Ä±ktÄ±k ve container&#39;Ä± siliyoruz (volume&#39;u test edeceÄŸiz bakalÄ±m yeni bir container ile oluÅŸturduÄŸumuz test dosyasÄ±na ulaÅŸabilecek miyiz)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker volume ls&lt;/code&gt; -&amp;gt; komutu ile volume&#39;leri listeleriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run --name mydebiancontainer -it -v ilkvolume:/uygulama debian sh&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;debian imajÄ±ndan mydebiancontainer adÄ±nda container oluÅŸtur, /uygulama klasÃ¶rÃ¼ne ilkvolume volume&#39;unu baÄŸla ve sh ile container&#39;a baÄŸlan&lt;/li&gt; &#xA;   &lt;li&gt;burdan aynÄ± ÅŸekilde klasÃ¶re gidip cat ile dosya iÃ§erisine bakarsak yazdÄ±ÄŸÄ±mÄ±z verinin orda bulunduÄŸunu gÃ¶rebiliriz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker BoÅŸ-Dolu Volume DavranÄ±ÅŸlarÄ±&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Container iÃ§erisinde volume adÄ±nda bir klasÃ¶r yoksa, o isimde bir klasÃ¶r oluÅŸturulur ve iÃ§erisine mount edilir. Peki volume&#39;leri bir klasÃ¶r iÃ§erisine mount etmek istersek?&lt;/li&gt; &#xA; &lt;li&gt;EÄŸer volume imaj iÃ§inde bulunan mevcut klasÃ¶re mount edilirse: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;KlasÃ¶r boÅŸsa o anda volume iÃ§inde hangi dosyalar varsa bu klasÃ¶rde de o dosyalarÄ± gÃ¶rÃ¼rÃ¼z&lt;/li&gt; &#xA;   &lt;li&gt;KlasÃ¶rde dosya varsa ve volume boÅŸsa klasÃ¶rdeki &lt;strong&gt;dosyalar volume&#39;e kopyalanÄ±r&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;KlasÃ¶rde dosya var ya da yok fakat volume boÅŸ deÄŸilse, klasÃ¶rÃ¼n iÃ§inde volume&#39;de ne varsa onu gÃ¶rÃ¼rÃ¼z&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Bind Mounts&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Host makinada (kendi local makinamÄ±z) bulunan bir klasÃ¶rÃ¼ veya dosyayÄ± Container iÃ§erisinde map etmeye &lt;strong&gt;Bind Moun&lt;/strong&gt; denir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d -p 80:80 --name mynginx nginx&lt;/code&gt; -&amp;gt; basit bir web sunucu oluÅŸturduk&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container exec -it mynginx sh&lt;/code&gt; -&amp;gt; container&#39;a baÄŸlanÄ±yoruz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd /usr/share/nginx/html&lt;/code&gt; -&amp;gt; bize default olarak serve edilen dosya&lt;/li&gt; &#xA; &lt;li&gt;Åimdi bu container&#39;Ä± siliyoruz ve aÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rÄ±yoruz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d -p 80:80 -v /Users/mebaysan/Desktop/mydockertest:/usr/share/nginx/html nginx&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;-d ile container&#39;Ä±n arka planda Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlÄ±yoruz&lt;/li&gt; &#xA;   &lt;li&gt;-p ile port set ediyoruz&lt;/li&gt; &#xA;   &lt;li&gt;-v ile aynÄ± Volume baÄŸlar gibi local makinamÄ±zdaki klasÃ¶r path&#39;ini veriyoruz ve dedik ki; container iÃ§erisindeki /usr/share/nginx/html klasÃ¶rÃ¼ localimdeki ilgili path&#39;ten Ã§eksin&lt;/li&gt; &#xA;   &lt;li&gt;nginx -&amp;gt; imaj adÄ±&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;UnutmamalÄ±yÄ±z ki bu yÃ¶ntem development aÅŸamasÄ±nda kullanÄ±lÄ±r, kesinlikle production ortamÄ±nda kullanmamalÄ±yÄ±z!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Container 102&lt;/h1&gt; &#xA;&lt;h2&gt;Docker Network Driver&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ek protokol vb getirmeden aÄŸ iÅŸlemlerini gerÃ§ekleÅŸtirebiliriz&lt;/li&gt; &#xA; &lt;li&gt;Container sistemlerinin iletiÅŸim altyapÄ±sÄ±nÄ± network driver&#39;larÄ± ile saÄŸlÄ±yoruz&lt;/li&gt; &#xA; &lt;li&gt;Temel 5 driver vardÄ±r &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Bridge &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;VarsayÄ±lan driver&#39;dÄ±r&lt;/li&gt; &#xA;     &lt;li&gt;Network objesi oluÅŸturulurken Ã¶zellikle baÅŸka bir driver belirtilmezse bridge driver ile oluÅŸturulur&lt;/li&gt; &#xA;     &lt;li&gt;Her Docker kurulu host Ã¼stÃ¼nde bridge driver ile oluÅŸturulmuÅŸ &#34;Bridge&#34; adÄ±nda network bulunur ve container oluÅŸturulduÄŸunda farklÄ± bir driver belirtilmediÄŸi sÃ¼rece default olarak buna baÄŸlanÄ±lÄ±r&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Host &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Her sistemde host driver ile oluÅŸturulmuÅŸ &#34;Host&#34; adÄ±nda bir driver vardÄ±r&lt;/li&gt; &#xA;     &lt;li&gt;Bu network&#39;e baÄŸlÄ± container&#39;da network izolasyonu olmaz. O host Ã¼zerinde Ã§alÄ±ÅŸan bir process&#39;miÅŸcesine host&#39;un aÄŸ kaynaklarÄ±nÄ± kullanÄ±r&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Macvlan &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Bu driver ile oluÅŸturulan network objeleri ile container&#39;lar fiziksel aÄŸlara kendi mac adreslerine sahip birer fiziksel aÄŸ adaptÃ¶rÃ¼ne sahipmiÅŸcesine baÄŸlanabilir&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;None &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Container&#39;a hiÃ§ bir ÅŸekilde aÄŸ baÄŸlantÄ±sÄ± olmasÄ±n istersek None driver kullanÄ±lÄ±r&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Overlay &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;AyrÄ± hostlar Ã¼zerindeki container&#39;larÄ±n aynÄ± aÄŸda Ã§alÄ±ÅŸÄ±yormuÅŸ gibi Ã§alÄ±ÅŸmasÄ± istendiÄŸi zaman Overlay network&#39;ler kullanÄ±lÄ±r&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker Network Objeleri-1&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network ls&lt;/code&gt; -&amp;gt; sistemdeki kurulu network objeleri listeler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network inspect bridge&lt;/code&gt; -&amp;gt; bridge NAME&#39;ine sahip objenin Ã¶zelliklerini listeler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run --net &amp;lt;NetworkObject&amp;gt; &amp;lt;CONTAINER&amp;gt;&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;--net&lt;/code&gt; ile network objesini vererek ilgili network&#39;e baÄŸlanabiliriz&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container run --net none &amp;lt;CONTAINER&amp;gt;&lt;/code&gt; -&amp;gt; container&#39;a aÄŸ baÄŸlantÄ±sÄ± olmaz (none)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker Network Objeleri-2-Port Publish&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ayni bridge Ã¼zerindeki container&#39;lar birbirleriyle iletiÅŸim kurabilirler Fakat biz dÄ±ÅŸ dÃ¼nyadan container iÃ§erisindeki servislere eriÅŸmek istersek &lt;strong&gt;port publish&lt;/strong&gt; denilen iÅŸlem sayesinde eriÅŸebiliriz.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ã–rnek olarak&lt;/strong&gt; container iÃ§erisindeki servis 80 portundan dinliyor. Biz &lt;code&gt;-p&lt;/code&gt; ya da &lt;code&gt;--publish&lt;/code&gt; parametresi ile bu portu belirleriz ve bu sayede host makineye 80 portundan gelen istekleri container&#39;Ä±n 80 portuna iletiriz.&lt;/li&gt; &#xA; &lt;li&gt;Bu iÅŸleme &lt;strong&gt;port publish&lt;/strong&gt; denir. Notasyon ÅŸu ÅŸekildedir &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;-p &amp;lt;HostPort&amp;gt;:&amp;lt;ContainerPort&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;-p 80:80&lt;/code&gt; -&amp;gt; Ã¶rnek&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;-p 8080:80 -p 8043:443&lt;/code&gt; -&amp;gt; birden fazla port publish yapabiliriz&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Default olarak TCP portlarÄ± aÃ§Ä±lÄ±r. EÄŸer istersek UDP portlarÄ± aÃ§abiliriz&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;-p 80:80/udp&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker Network Objeleri-3&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Container&#39;lar arasÄ± network izolasyonu saÄŸlamak istersek ayrÄ± bridge&#39;ler oluÅŸturarak bunu saÄŸlayabiliriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Default bridge network iÃ§erisinde dns Ã§Ã¶zÃ¼mlemesi yok&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;VarsayÄ±lan dÄ±ÅŸÄ±nda ip aralÄ±klarÄ± tanÄ±mlayabiliriz&lt;/li&gt; &#xA; &lt;li&gt;KullanÄ±cÄ± tanÄ±mlÄ± bridge network&#39;e baÄŸlÄ± container&#39;lar birbirleriyle isimler Ã¼zerinden haberleÅŸebilirler. Dns Ã§Ã¶zÃ¼mlemesi saÄŸlar&lt;/li&gt; &#xA; &lt;li&gt;Container&#39;lar Ã§alÄ±ÅŸÄ±r durumdayken de kullanÄ±cÄ± tanÄ±mlÄ± bridge network&#39;lere baÄŸlanÄ±p, baÄŸlantÄ±yÄ± kesebilirler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d --name websunucu ozgurozturknet/adanzyedocker &lt;/code&gt; -&amp;gt; websunucu adÄ±nda bir container oluÅŸturuyorum&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -it -d --name database1 ozgurozturknet/adanzyedocker sh&lt;/code&gt; -&amp;gt; database1 adÄ±nda bir container oluÅŸturup iÃ§ine giriyorum. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;ping websunucu1&lt;/code&gt; ile ilk container&#39;a eriÅŸmeye Ã§alÄ±ÅŸÄ±yorum&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;/usr/src/myapp # ping websunucu&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;ping: websunucu: Name does not resolve&lt;/code&gt; -&amp;gt; o container&#39;a direkt container adÄ± ile eriÅŸemiyorum; Ã§Ã¼nkÃ¼ default bridge network&#39;de dns Ã§Ã¶zÃ¼mlemesi yok&lt;/li&gt; &#xA;     &lt;li&gt;Fakat IP adresi Ã¼zerinden eriÅŸebiliriz yani aralarÄ±nda baÄŸlantÄ± var&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Åimdi container&#39;larÄ± siliyoruz ve kendi bridge&#39;mizi oluÅŸturup container&#39;larÄ± yeniden oluÅŸturacaÄŸÄ±z&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network create mybridge&lt;/code&gt; -&amp;gt; mybridge adÄ±nda bir bridge network oluÅŸturduk. Opsiyon girmediÄŸimiz iÃ§in default olarak bridge oluÅŸturdu &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker network create --driver=host myhost&lt;/code&gt; -&amp;gt; host network&#39;u oluÅŸturur&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker network ls&lt;/code&gt; -&amp;gt; network driver&#39;lar listelenir&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network inspect mybridge&lt;/code&gt; -&amp;gt; network driver&#39;Ä±mÄ±zÄ± inceliyoruz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d --name websunucu --net mybridge ozgurozturknet/adanzyedocker&lt;/code&gt; -&amp;gt; websunucu adÄ±nda bir container oluÅŸturduk ve mybridge driver&#39;Ä±na baÄŸladÄ±k&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d --name database --net mybridge ozgurozturknet/adanzyedocker&lt;/code&gt; -&amp;gt; database adÄ±nda bir container oluÅŸturduk ve mybridge driver&#39;a baÄŸladÄ±k&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network inspect mybridge&lt;/code&gt; -&amp;gt; mybridge adÄ±ndaki driver&#39;a bakÄ±yoruz ve baÄŸlÄ± olan container&#39;larÄ± gÃ¶rÃ¼yoruz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container exec -it websunucu sh&lt;/code&gt; -&amp;gt; websunucu container&#39;Ä±na baÄŸlanÄ±yoruz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;ping database&lt;/code&gt; -&amp;gt; database adÄ±ndaki container&#39;Ä± pingliyoruz ve bu sefer baÅŸarÄ±lÄ± oluyoruz. Ã‡Ã¼nkÃ¼ kendimiz bir bridge oluÅŸturduk ve bunun Ã¼zerinde container&#39;larÄ± iletiÅŸime geÃ§iriyoruz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network create --driver=bridge --subnet=10.10.0.0/16 --ip-range=10.10.10.0/24 --gateway=10.10.10.10 mybridge2&lt;/code&gt; -&amp;gt; istersek oluÅŸturduÄŸumuz bridge&#39;in aÄŸ Ã¶zelliklerini belirleyebiliriz&lt;/li&gt; &#xA; &lt;li&gt;KullanÄ±cÄ± tanÄ±mlÄ± bridge&#39;lerin en Ã¶nemli Ã¶zelliklerinden birisi de container&#39;lar Ã§alÄ±ÅŸÄ±rken bu bridge&#39;lere baÄŸlanabilirler&lt;/li&gt; &#xA; &lt;li&gt;Notasyon ÅŸu ÅŸekildedir: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker network connect &amp;lt;BridgeName&amp;gt; &amp;lt;ContainerName&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker network connect mybridge2 database&lt;/code&gt; -&amp;gt; yukarda oluÅŸturduÄŸumuz database container&#39;Ä±nÄ± mybridge2 adÄ±ndaki network&#39;e baÄŸlÄ±yoruz. UnutmayalÄ±m ÅŸu an hala Ã§alÄ±ÅŸan bir container!&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker attach database&lt;/code&gt; -&amp;gt; Ã§alÄ±ÅŸan bir container olan database&#39;e baÄŸlanÄ±yoruz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;ifconfig&lt;/code&gt; -&amp;gt; yazdÄ±ÄŸÄ±mÄ±zda gÃ¶receÄŸiz ki &lt;strong&gt;eth1&lt;/strong&gt; (mybridge2) gelmiÅŸ&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network disconnect mybridge2 database&lt;/code&gt; -&amp;gt; database container&#39;Ä± mybridge2&#39;den dÃ¼ÅŸÃ¼rÃ¼yoruz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network rm mybridge2&lt;/code&gt; -&amp;gt; driver&#39;Ä± sildik (baÄŸlÄ± bir container olmamasÄ± gerek)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Logging Uygulama GÃ¼nlÃ¼kleri&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker araÃ§larÄ±nÄ± kullanarak loglara eriÅŸebiliriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d --name mycont1 ozgurozturknet/app1&lt;/code&gt; -&amp;gt; arka planda mycont1 adÄ±nda bir container oluÅŸtur&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker logs mycont1&lt;/code&gt; -&amp;gt; mycont1 adÄ±ndaki container&#39;a ait loglar&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d --name mycont2 -p 80:80 nginx&lt;/code&gt; -&amp;gt; container oluÅŸturup 127.0.0.1 adresine gidip 3-5 kere refresh yapÄ±yorum &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker logs mycont2&lt;/code&gt; -&amp;gt; container&#39;a ait loglar&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Docker Stats ve Top&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Container; tek bir uygulamanÄ±n ya da servisin paketlenmiÅŸ halidir, sÃ¼rekli olarak container iÃ§erisine girmeyiz.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker top &amp;lt;ContainerName&amp;gt;&lt;/code&gt; -&amp;gt; ilgili container iÃ§erisinde Ã§alÄ±ÅŸan process&#39;leri listeler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker stats &amp;lt;ContainerName&amp;gt;&lt;/code&gt; -&amp;gt; ilgili container&#39;Ä±n ne kadar kaynak kullandÄ±ÄŸÄ±nÄ± gÃ¶sterir &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker stats&lt;/code&gt; -&amp;gt; tÃ¼m container&#39;larÄ±n kaynak kullanÄ±mÄ±nÄ± gÃ¶sterir&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Container Cpu ve Memory Limitleri&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;EÄŸer container oluÅŸtururken limitler koymazsak her container; sistem kaynaklarÄ±nÄ± sÄ±nÄ±rsÄ±z olarak kullanÄ±r&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -dit --name mycont alpine&lt;/code&gt; -&amp;gt; bir container oluÅŸturuyorum &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker attach mycont&lt;/code&gt; -&amp;gt; komutu ile container&#39;a baÄŸlanabilirim&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ctrl + p q&lt;/code&gt; kombinasyonu ile arka plana atabilirim (Ã§alÄ±ÅŸmaya devam eder)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -d --memory=100m alpine&lt;/code&gt; -&amp;gt; max 100mb kullanabilecek bir container oluÅŸturdu&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -dit --name mytest --memory=100m alpine&lt;/code&gt; -&amp;gt; mytest adÄ±nda bir container oluÅŸturuldu, max 100m kullanabilecek &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;m&lt;/code&gt; -&amp;gt; megabyte&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;g&lt;/code&gt; -&amp;gt; gigabyte&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;k&lt;/code&gt; -&amp;gt; kilobyte&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt; -&amp;gt; byte&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -dit --memory=100m --memory-swap=200m alpine&lt;/code&gt; -&amp;gt; eÄŸer memory limiti aÅŸÄ±lsa bile swap olarak 200m daha kullanabilecek&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -dit --cpus=&#34;1.5&#34; alpine&lt;/code&gt; -&amp;gt; oluÅŸturduÄŸumuz container sistem iÃ§erisinde ne kadar core varsa onun sadece 1.5 tanesini kullanabilecek&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -dit --cpus=&#34;1.5&#34; --cpuset-cpus=&#34;0,3&#34; alpine&lt;/code&gt; -&amp;gt; sadece cpu 0 ve cpu 3&#39;Ã¼ kullanabil dedik&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Environment Variables (Ortam DeÄŸiÅŸkenleri)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ä°ÅŸletim sistemi bazÄ±nda tanÄ±mlanan ve her yerden Ã§aÄŸrÄ±labilen deÄŸiÅŸkenlerdir&lt;/li&gt; &#xA; &lt;li&gt;Linux sistemlerde: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;printenv&lt;/code&gt; ile tÃ¼m ortam deÄŸiÅŸkenlerini gÃ¶sterir&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;echo $&amp;lt;EnvName&amp;gt;&lt;/code&gt; -&amp;gt; ilgili deÄŸiÅŸkenin deÄŸerini verir&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;export &amp;lt;EnvName&amp;gt;=&amp;lt;EnvValue&amp;gt;&lt;/code&gt; -&amp;gt; deÄŸiÅŸken tanÄ±mlamamÄ±zÄ± saÄŸlar&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -it --env VAR1=deneme1 --env VAR2=deneme2 alpine sh&lt;/code&gt; -&amp;gt; container&#39;a 2 adet environment tanÄ±mladÄ±k. &lt;strong&gt;Environment&#39;ler bÃ¼yÃ¼k kÃ¼Ã§Ã¼k harf duyarlÄ±dÄ±r&lt;/strong&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Container iÃ§erisinde &lt;code&gt;printenv&lt;/code&gt; kullanÄ±rsak (alpine linux olduÄŸundan) tanÄ±mladÄ±ÄŸÄ±mÄ±z deÄŸiÅŸkenleri gÃ¶rebiliriz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run -it --env HOME alpine sh&lt;/code&gt; -&amp;gt; eÄŸer environment&#39;e deÄŸer atamazsak sistem Ã¼zerinde o environment&#39;i arar ve onun deÄŸerini atayÄ±p container&#39;a gÃ¶nderir&lt;/li&gt; &#xA; &lt;li&gt;EÄŸer istersek bir dosya iÃ§erisinde tÃ¼m ortam deÄŸiÅŸkenlerini tanÄ±mlayÄ±p tek komut ile de bunu gÃ¶nderebiliriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;touch env.list&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;echo &#34;VAR1=deneme1&#34; &amp;gt;&amp;gt; env.list&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;echo &#34;VAR2=deneme1&#34; &amp;gt;&amp;gt; env.list&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;echo &#34;VAR3=deneme1&#34; &amp;gt;&amp;gt; env.list&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;DeÄŸiÅŸkenleri dosya iÃ§erisine ekledim&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container run -it --env-file ./env.list alpine sh&lt;/code&gt; -&amp;gt; &lt;strong&gt;--env-file&lt;/strong&gt; parametresi sayesinde liste olarak environment&#39;leri gÃ¶nderdik&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Image ve Registry&lt;/h1&gt; &#xA;&lt;h2&gt;Image Ä°simlendirme ve Tag YapÄ±sÄ±&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker imajÄ±na verilen isim aynÄ± zamanda o imajÄ±n nerede depolandÄ±ÄŸÄ±nÄ± da belirtir&lt;/li&gt; &#xA; &lt;li&gt;Docker imaj adÄ± ile container oluÅŸturabildiÄŸimiz gibi imaj ID&#39;sini de kullanarak imajlardan container oluÅŸturabiliriz&lt;/li&gt; &#xA; &lt;li&gt;Docker imaj yapÄ±sÄ±: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;&amp;lt;RegistryURL&amp;gt;/&amp;lt;repository&amp;gt;:&amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker.io/mebaysan/test:latest&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;strong&gt;docker.io&lt;/strong&gt; olmasÄ±nÄ±n sebebi varsayÄ±lan olarak docker hub registry&#39;den imaj Ã§ekilmesidir. EÄŸer istersek farklÄ± registry&#39;leri belirtebiliriz: &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;code&gt;docker image pull gcr.io/google-containers/busybox&lt;/code&gt; -&amp;gt; Ã¶rnek olarak google image registry&#39;den busy box adÄ±ndaki imajÄ± Ã§ektik&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Tag&#39;ler sayesinde tek repository iÃ§inde birden fazla versiyon tutabiliriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker image pull &amp;lt;ImageName&amp;gt;&lt;/code&gt; -&amp;gt; komutu sayesinde local sistemimize bir imajÄ± Ã§ekeriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Tag belirtmediÄŸimiz mÃ¼ddetÃ§e default olarak &lt;code&gt;latest&lt;/code&gt; tag&#39;Ä± kullanÄ±lÄ±r&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker tag ubuntu mebaysan/deneme&lt;/code&gt; -&amp;gt; Ã§ektiÄŸimiz ubuntu imajÄ±nÄ± localde yeniden adlandÄ±rdÄ±k (Ã¶ncesinde pull edilmeli tabii). ArtÄ±k aynÄ± imaja mebaysan/deneme diyerek eriÅŸebiliriz.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Image oluÅŸturma&lt;/h2&gt; &#xA;&lt;h3&gt;Dockerfile-1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker imajÄ± oluÅŸturmak istersek Ã¶ncelikle Dockerfile adÄ±nda bir dosya oluÅŸturmamÄ±z gerekir&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Dockerfile Parametreleri&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Daha detaylÄ± bilgi iÃ§in &lt;a href=&#34;https://github.com/ozgurozturknet/AdanZyeDocker/raw/master/kisim5/bolum47/Dockerfile%20Talimatlari%20Aciklamasi.txt&#34;&gt;buraya&lt;/a&gt; Ã–zgÃ¼r hocanÄ±n repository&#39;sine bakÄ±nÄ±z. Bu parametreleri ve aÃ§Ä±klamalarÄ±nÄ± onun reposundan aldÄ±m.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;FROM&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;OluÅŸturulacak imajÄ±n hangi imajdan oluÅŸturulacaÄŸÄ±nÄ± belirten talimat. Dockerfile iÃ§erisinde geÃ§mesi mecburi tek talimat budur. Mutlaka olmalÄ±dÄ±r.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: FROM ubuntu:18.04&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;LABEL&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ä°maj metadataâ€™sÄ±na key=value ÅŸeklinde deÄŸer Ã§iftleri eklemek iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin team=development ÅŸeklinde bir etiket eklenerek bu imajÄ±n development ekibinin kullanmasÄ± iÃ§in yaratÄ±ldÄ±ÄŸÄ± belirtilebilir.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: LABEL version:1.0.8&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;RUN&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ä°maj oluÅŸturulurken shellâ€™de bir komut Ã§alÄ±ÅŸtÄ±rmak istersek bu talimat kullanÄ±lÄ±r. Ã–rneÄŸin apt-get install xxx ile xxx isimli uygulamanÄ±n bu imaja yÃ¼klenmesi saÄŸlanabilir.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: RUN apt-get update&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;cd xxx komutuyla ile istediÄŸimiz klasÃ¶re geÃ§mek yerine bu talimat kullanÄ±larak istediÄŸimiz klasÃ¶re geÃ§er ve oradan Ã§alÄ±ÅŸmaya devam ederiz.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: WORKDIR /usr/src/app&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;USER&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;gireceÄŸimiz komutlarÄ± hangi kullanÄ±cÄ± ile Ã§alÄ±ÅŸtÄ±rmasÄ±nÄ± istiyorsak bu talimat ile onu seÃ§ebiliriz.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: USER poweruser&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;COPY&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ä°maj iÃ§ine dosya veya klasÃ¶r kopyalamak iÃ§in kullanÄ±rÄ±z&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: COPY /source /user/src/app&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ADD&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;COPY ile aynÄ± iÅŸi yapar yani dosya ya da klasÃ¶r kopyalarsÄ±nÄ±z. Fakat ADD bunun yanÄ±nda dosya kaynaÄŸÄ±nÄ±n bir url olmasÄ±na da izin verir. AyrÄ±ca ADD ile kaynak olarak bir .tar dosyasÄ± belirtilirse bu dosya imaja .tar olarak sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ haliyle deÄŸil de aÃ§Ä±larak kopyalanÄ±r.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: ADD &lt;a href=&#34;https://wordpress.org/latest.tar.gz&#34;&gt;https://wordpress.org/latest.tar.gz&lt;/a&gt; /temp&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ENV&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Imaj iÃ§inde environment variable tanÄ±mlamak iÃ§in kullanÄ±lÄ±r&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: ENV TEMP_FOLDER=&#34;/temp&#34;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ARG&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;ARG ile de variable tanÄ±mlarsÄ±nÄ±z. Fakat bu variable sadece imaj oluÅŸturulurken yani build aÅŸamasÄ±nda kullanÄ±lÄ±r. ImajÄ±n oluÅŸturulmuÅŸ halinde bu variable bulunmaz. ENV ile imaj oluÅŸturulduktan sonra da imaj iÃ§inde olmasÄ±nÄ± istediÄŸiniz variable tanÄ±mlarsÄ±nÄ±z, ARG ile sadece oluÅŸtururken kullanmanÄ±z gereken variable tanÄ±mlarsÄ±nÄ±z.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: ARG VERSION:1.0&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VOLUME&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Imaj iÃ§erisinde volume tanÄ±mlanamÄ±zÄ± saÄŸlayan talimat. EÄŸer bu volume host sistemde varsa container bunu kullanÄ±r. Yoksa yeni volume oluÅŸturur.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: VOLUME /myvol&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;EXPOSE&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Bu imajdan oluÅŸturulacak containerlarÄ±n hangi portlar Ã¼stÃ¼nden eriÅŸilebileceÄŸini yani hangi portlarÄ±n yayÄ±nlanacaÄŸÄ±nÄ± bu talimatla belirtirsiniz.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: EXPOSE 80/tcp&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Bu talimat ile bir containerÄ±n Ã§alÄ±ÅŸtÄ±rÄ±labilir bir uygulama gibi ayarlanabilmesini saÄŸlarsÄ±nÄ±z.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: ENTRYPOINT [&#34;/usr/sbin/apache2ctl&#34;, &#34;-D&#34;, &#34;FOREGROUND&#34;]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;CMD&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Bu imajdan container yaratÄ±ldÄ±ÄŸÄ± zaman varsayÄ±lan olarak Ã§alÄ±ÅŸtÄ±rmasÄ±nÄ± istediÄŸiniz komutu bu talimat ile belirlersiniz.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: CMD java merhaba&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;HEALTHCHECK&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Bu talimat ile Docker&#39;a bir konteynerin hala Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol etmesini sÃ¶ylebiliriz. Docker varsayÄ±lan olarak container iÃ§erisinde Ã§alÄ±ÅŸan ilk processi izler ve o Ã§alÄ±ÅŸtÄ±ÄŸÄ± sÃ¼rece container Ã§alÄ±ÅŸmaya devam eder. Fakat process Ã§alÄ±ÅŸsa bile onun dÃ¼zgÃ¼n iÅŸlem yapÄ±p yapmadÄ±ÄŸÄ±na bakmaz. HEALTHCHECK ile buna bakabilme imkanÄ±na kavuÅŸuruz.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: HEALTHCHECK --interval=5m --timeout=3s CMD curl -f &lt;a href=&#34;http://localhost/&#34;&gt;http://localhost/&lt;/a&gt; || exit 1&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SHELL&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Dockerfile&#39;Ä±n komutlarÄ± iÅŸleyeceÄŸi shell&#39;in hangisi olduÄŸunu belirtiriz. Linux iÃ§in varsayÄ±lan shell [&#34;/bin/sh&#34;, &#34;-c&#34;],Windows iÃ§in [&#34;cmd&#34;, &#34;/S&#34;, &#34;/C&#34;]. BunlarÄ± SHELL talimatÄ± ile deÄŸiÅŸtirebiliriz.&lt;/li&gt; &#xA;   &lt;li&gt;Ã–r: SHELL [&#34;powershell&#34;, &#34;-command&#34;]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Dockerfile-2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AÅŸaÄŸÄ±daki Ã¶rnek senaryo iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/Dockerfile-2/Dockerfile&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz. Comment line&#39;lar ile desteklenmeye Ã§alÄ±ÅŸÄ±ldÄ±. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ubuntu 18.04 yÃ¼klÃ¼ bir sistem kur&lt;/li&gt; &#xA;   &lt;li&gt;Ä°ÅŸletim sistemini gÃ¼ncelle&lt;/li&gt; &#xA;   &lt;li&gt;Python kur&lt;/li&gt; &#xA;   &lt;li&gt;UygulamayÄ± sisteme kopyala&lt;/li&gt; &#xA;   &lt;li&gt;Sistem baÅŸladÄ±ÄŸÄ±nda uygulamanÄ±n baÅŸlamasÄ±nÄ± ayarla&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker image build -t &amp;lt;ImageTag&amp;gt; -f &amp;lt;DockerFileName&amp;gt; .&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker image build -t mebaysan/ilkimaj .&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ilkimaj adÄ±nda bir imaj oluÅŸturur&lt;/li&gt; &#xA;     &lt;li&gt;&lt;strong&gt;.&lt;/strong&gt; -&amp;gt; build context&#39;i belirtiyoruz, eÄŸer Dockerfile iÃ§inde COPY vb bir komut varsa bunlar iÃ§in gerekli dosyalarÄ± sen bu Ã§alÄ±ÅŸtÄ±ÄŸÄ±n klasÃ¶r iÃ§erisinde ara&lt;/li&gt; &#xA;     &lt;li&gt;Dockerfile&#39;Ä±n olduÄŸu dizinde bir adet Dockerfile olduÄŸundan ekstra -f parametresini girmeme gerek yok&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker image ls&lt;/code&gt; komutu ile sistemimizdeki mevcut imajlarÄ± gÃ¶rebiliriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker container run mebaysan/ilkimaj&lt;/code&gt; komutu ile oluÅŸturduÄŸumuz imajdan bir container oluÅŸturduk ve ekran Ã§Ä±ktÄ±snÄ± gÃ¶rdÃ¼k&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker image history &amp;lt;ImageTag&amp;gt;&lt;/code&gt; komutu ile imajÄ±n geÃ§miÅŸini gÃ¶rebiliriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker image history mebaysan/ilkimaj&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Dockerfile-3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Localde oluÅŸturduÄŸumuz bir Docker imajÄ±nÄ± hub&#39;a gÃ¶ndermek iÃ§in Ã¶ncelikle CLI&#39;da login olmamÄ±z gerekir &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker login&lt;/code&gt; -&amp;gt; komutu ile login olabiliriz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker image push &amp;lt;Image&amp;gt;&lt;/code&gt; komutu ile localdeki istediÄŸimiz image&#39;i hub&#39;a pushlayabiliriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker image push mebaysan/ilkimaj&lt;/code&gt; -&amp;gt; ilgili imajÄ± pushlar&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Dockerfile-4&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bir flask uygulamasÄ±nÄ± container&#39;da Ã§alÄ±ÅŸtÄ±rÄ±yoruz. Daha detaylÄ± bilgi iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/Dockerfile-4/pythonapp/&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;O klasÃ¶rdeki Docker imajÄ± oluÅŸturmak iÃ§in: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker image build -t mebaysan/basitflaskimaj .&lt;/code&gt; komutunu kullanÄ±yorum&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;OluÅŸturduÄŸum imajdan bir container oluÅŸturmak iÃ§in: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker container run --rm -p 80:5000 mebaysan/basitflaskimaj&lt;/code&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;code&gt;--rm&lt;/code&gt; -&amp;gt; container kapanÄ±nca otomatik olarak sil (bir daha silmekle uÄŸraÅŸmayalÄ±m)&lt;/li&gt; &#xA;       &lt;li&gt;&lt;code&gt;-p&lt;/code&gt; -&amp;gt; bu makinaya 80 portundan gelen istekleri container&#39;Ä±n 5000 portuna yÃ¶nlendir. Flask uygulamasÄ± 5000 portundan ayaÄŸa kalktÄ±ÄŸÄ± iÃ§in&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Linux Shell Trickleri&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;echo&lt;/code&gt; komutu sayesinde bir deÄŸeri Ã§Ä±ktÄ± olarak verir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; sayesinde bir komutun Ã§Ä±ktÄ±sÄ±nÄ± yÃ¶nlendiririz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;echo &#34;deneme&#34; &amp;gt; deneme.txt&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; komutun sonuna eklersek komutu arka plana atar, arkada Ã§alÄ±ÅŸÄ±r&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;|&lt;/code&gt; 1. komutun Ã§Ä±ktÄ±sÄ±nÄ± 2. komuta iletmeye saÄŸlar&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cat dosya | grep &#34;naber&#34;&lt;/code&gt; dosya iÃ§eriÄŸini okur Ã§Ä±ktÄ±yÄ± grep&#39;e yollar, iÃ§erisinde naber geÃ§enleri filtreler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ls ; date&lt;/code&gt; -&amp;gt; &lt;strong&gt;;&lt;/strong&gt; sayesinde aynÄ± anda birden fazla komut Ã§alÄ±ÅŸtÄ±rmamÄ±zÄ± saÄŸlar&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; -&amp;gt; VE&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;||&lt;/code&gt; -&amp;gt; VEYA&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Dockerfile-5&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Healthcheck konusunu gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z dosyaya &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/Dockerfile-5/Dockerfile&#34;&gt;buradan&lt;/a&gt; bakabilirsiniz&lt;/li&gt; &#xA; &lt;li&gt;Ä°maj oluÅŸturmak iÃ§in: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker image build -t mebaysan/basichealthcheck .&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Bu imajdan container oluÅŸturmak iÃ§in: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container run -d --name mycont -p 80:80 mebaysan/basichealthcheck&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;ENV Ã¶rneÄŸi ile container oluÅŸturmak iÃ§in: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container run -d --name mycont --env KULLANICI=&#34;BAYSAN&#34; --env HOSTNAME=&#34;MyHOST&#34; -p 80:80 mebaysan/basichealthcheck&lt;/code&gt; -&amp;gt; ortam deÄŸiÅŸkenleri set ederek container oluÅŸturuyoruz, detaylÄ± aÃ§Ä±klama &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/Dockerfile-5/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; iÃ§erisindedir&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;ADD ve COPY FarkÄ±&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;COPY -&amp;gt; belirttiÄŸimiz dosya veya klasÃ¶rÃ¼ belirttiÄŸimiz PATH&#39;e atar&lt;/li&gt; &#xA; &lt;li&gt;ADD -&amp;gt; COPY ile aynÄ± iÅŸlevi yapar fakat dosya kaynaÄŸÄ±nÄ±n bir url olmasÄ±na izin verir. AynÄ± zamanda kaynak dosya bir .tar dosyasÄ± ise bunu hedef klasÃ¶re decompress olarak atar&lt;/li&gt; &#xA; &lt;li&gt;Detaylar iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/ADD-COPY-FARKI/Dockerfile&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz&lt;/li&gt; &#xA; &lt;li&gt;OluÅŸturduÄŸumuz Dockerfile ile imaj oluÅŸturup aÅŸaÄŸÄ±daki komut ile container oluÅŸturuyoruz ve ADD sonucunu gÃ¶rÃ¼yoruz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container run -it mebaysan/wpadd sh&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;ENTRYPOINT ve CMD FarkÄ±&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CMD iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/ENTRYPOINT-CMD-FARKI/cmd/Dockerfile&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz&lt;/li&gt; &#xA; &lt;li&gt;ENTRYPOINT iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/ENTRYPOINT-CMD-FARKI/entrypoint/Dockerfile&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz&lt;/li&gt; &#xA; &lt;li&gt;CMD runtime&#39;da deÄŸiÅŸebilirken ENTRYPOINT runtime&#39;da deÄŸiÅŸtirilemez&lt;/li&gt; &#xA; &lt;li&gt;Her image&#39;de en az 1 adet CMD veya ENTRYPOINT olmalÄ±dÄ±r&lt;/li&gt; &#xA; &lt;li&gt;EÄŸer hem CMD hem de ENTRYPOINT varsa, CMD&#39;de yazÄ±lanlarÄ± ENTRYPOINT&#39;e parametre olarak geÃ§er&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Exec Form ve Shell Form FarkÄ±&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Exec Form =&amp;gt;&amp;nbsp;&lt;code&gt;CMD [&#34;python&#34;, &#34;app.py&#34;]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Shell Form =&amp;gt;&amp;nbsp;&lt;code&gt;CMD python app.py&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;EÄŸer komut Shell formunda girilirse bu imajdan container oluÅŸturulduÄŸu zaman bu komutu varsayÄ±lan shell&#39;i Ã§alÄ±ÅŸtÄ±rarak onun iÃ§erisinde Ã§alÄ±ÅŸtÄ±rÄ±r. Bu nedenle container&#39;da Ã§alÄ±ÅŸan 1. process (pid 1) bu shell process olur&lt;/li&gt; &#xA; &lt;li&gt;EÄŸer komut Exec formunda girildiyse herhangi bir shell Ã§alÄ±ÅŸtÄ±rÄ±lmaz ve komut direk process olarak Ã§alÄ±ÅŸÄ±r. Container&#39;Ä±n pid 1&#39;i o process olur&lt;/li&gt; &#xA; &lt;li&gt;Exec formunda Ã§alÄ±ÅŸtÄ±rÄ±lan komutlar herhangi bir shell processi Ã§alÄ±ÅŸmadÄ±ÄŸÄ± iÃ§in Environment Variable gibi bazÄ± deÄŸerlere eriÅŸemezler.&lt;/li&gt; &#xA; &lt;li&gt;EÄŸer ENTRYPOINT ve CMD birlikte kullanÄ±lacaksa Exec form kullanÄ±lmalÄ±dÄ±r. Shell formda CMD&#39;deki komutlar ENTRPOINT&#39;e parametre olarak aktarÄ±lmaz&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Multi-stage Build&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ä°maj oluÅŸtururken, oluÅŸturma aÅŸamalarÄ±nÄ± kademelere bÃ¶lmemize ve ilk kademede yarattÄ±ÄŸÄ±mÄ±z imaj iÃ§erisindeki dosyalarÄ± bir sonraki kademede oluÅŸturacaÄŸÄ±mÄ±z imaja kopyalayabilmemize imkan saÄŸlar. Bu sayede son imajÄ±mÄ±zÄ±n boyutunun kÃ¼Ã§Ã¼lmesi saÄŸlanÄ±r. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ã–r: Bir Go uygulamasÄ± yazdÄ±k ve bunu derleyip sunucuya gÃ¶ndereceÄŸiz, imaj oluÅŸtururken Ã¶nce kodu derler Ã§alÄ±ÅŸan bir halini hazÄ±rlarÄ±z. SonrasÄ±nda bu Ã§alÄ±ÅŸan derlenmiÅŸ dosyayÄ± 2. aÅŸamada nihai imaja koyar ve imajÄ± oluÅŸtururuz. Bu sayede gereksiz yere kaynak kodlarÄ±nÄ± veya go derleyicisini imaj iÃ§erisinde tutmamÄ±za gerek kalmaz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Ã–rnekler iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/MultiStageBuild/Dockerfile&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;ARG&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ä°maj oluÅŸtururken kullanbildiÄŸimiz bir diÄŸer parametre ise ARG&#39;dÄ±r. Sadece build aÅŸamasÄ±nda kullanÄ±labilir ve sonrasÄ±nda container ayaÄŸa kalktÄ±ÄŸÄ±nda eriÅŸilemez.&lt;/li&gt; &#xA; &lt;li&gt;Ã–rnek iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/ARG/Dockerfile&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz.&lt;/li&gt; &#xA; &lt;li&gt;Ã–rnek bir Build Arg gÃ¶nderimi &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker image build -t mytest2 --build-arg VERSION=3.8.1 .&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Docker Commit&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dockerfile olmadan da docker imaj oluÅŸturabiliriz&lt;/li&gt; &#xA; &lt;li&gt;DoÄŸru kullanÄ±m Dockerfile olsa da tek yÃ¶ntem bu deÄŸildir&lt;/li&gt; &#xA; &lt;li&gt;Ã–ncelikle localimizde bir container oluÅŸturur ve iÃ§erisinde gerekli kurulumlarÄ± vs yaparÄ±z&lt;/li&gt; &#xA; &lt;li&gt;ArdÄ±ndan &lt;code&gt;docker commit &amp;lt;LocalContainerName&amp;gt; &amp;lt;NewImageTag&amp;gt;&lt;/code&gt; komutu ile o container&#39;dan bir imaj oluÅŸturmuÅŸ oluruz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ã–r: &lt;code&gt;docker commit localcont1 mebaysan/prodcont1:latest&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker commit -c &#39;CMD [&#34;command 1&#34;, &#34;command 2&#34;]&#39; &amp;lt;LocalContainerName&amp;gt; &amp;lt;NewImageTag&amp;gt;&lt;/code&gt; -&amp;gt; -c parametresi ile CMD, EXPOSE vb. komutlarÄ± bu imaja ekleyebiliriz&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Docker Save-Load&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Save komutu sayesinde localde oluÅŸturduÄŸumuz bir imajÄ± &lt;code&gt;.tar&lt;/code&gt; dosyasÄ± olarak kayÄ±t edebiliriz, ve internet eriÅŸimi olmasa bile (hub&#39;dan Ã§ekemiyor demektir) sunucuya atabiliriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker save &amp;lt;LocalImage&amp;gt; -o &amp;lt;filename&amp;gt;.tar&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker save mebaysan/test -o mebaysantestimaj.tar&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Load komutu ile &lt;code&gt;.tar&lt;/code&gt; olarak gelen docker dosyasÄ±nÄ± sisteme imaj olarak yÃ¼kleyebiliriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker load -i &amp;lt;TarFile&amp;gt;&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker load -i mebaysantestimaj.tar&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Registry&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Kendi aÄŸÄ±mÄ±zda Ã¼cretsiz olarak bir docker deposu oluÅŸturabiliriz&lt;/li&gt; &#xA; &lt;li&gt;Bunun iÃ§in yine Docker Hub Ã¼zerinden &lt;span&gt;ğŸ˜Š&lt;/span&gt; &lt;a href=&#34;https://hub.docker.com/_/registry&#34;&gt;registry&lt;/a&gt; imajÄ±nÄ± kullanacaÄŸÄ±z &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Bu imaj sayesinde bir container Ã§alÄ±ÅŸtÄ±racaÄŸÄ±z. Ä°Ã§erisinde docker hub&#39;a benzer bir yazÄ±lÄ±m Ã§alÄ±ÅŸtÄ±rÄ±yor. 5000 portundan ayaÄŸa kalkÄ±yor.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker pull registry&lt;/code&gt; imajÄ± locale Ã§ekiyoruz&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container run -d -p 5000:5000 --restart always --name registry registry&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;restart parametresi container down olduÄŸunda ne yapÄ±lacaÄŸÄ±nÄ± alÄ±r &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;code&gt;always&lt;/code&gt; -&amp;gt; down olunca ne olursa olsun restart at&lt;/li&gt; &#xA;       &lt;li&gt;&lt;code&gt;no&lt;/code&gt; -&amp;gt; down olunca bir ÅŸey yapma&lt;/li&gt; &#xA;       &lt;li&gt;&lt;code&gt;on-failure&lt;/code&gt; -&amp;gt; sadece hata olur da kapanÄ±rsa yeniden baÅŸlat fakat biz elimizle manuel kapatÄ±rsak yeniden baÅŸlatma&lt;/li&gt; &#xA;       &lt;li&gt;&lt;code&gt;unless-stopped&lt;/code&gt; -&amp;gt; manuel olarak stop edersek baÅŸlatmaz fakat geri kalan her durumda baÅŸlatÄ±r&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;5000 portunu 5000 portuna publish ettik&lt;/li&gt; &#xA;     &lt;li&gt;registy adÄ±ndaki container&#39;Ä± registry imajÄ±ndan oluÅŸturduk&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;http://127.0.0.1:5000/&lt;/code&gt; altÄ±nda Ã§alÄ±ÅŸmaya baÅŸlar&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;http://127.0.0.1:5000/v2/_catalog&lt;/code&gt; altÄ±nda kayÄ±tlÄ± repolarÄ± gÃ¶sterir,&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;localcont1&lt;/code&gt; adÄ±nda bir imaj oluÅŸturduÄŸumuzu varsayalÄ±m &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker push localhost:5000/localcont1&lt;/code&gt; -&amp;gt; localdeki imajÄ± registry&#39;e kayÄ±t etti&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker pull localhost:5000/localcont1&lt;/code&gt; bu adrese eriÅŸebilen makinalar; komutu ile local registry&#39;deki imajÄ± Ã§ekebilir&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Compose ve Swarm&lt;/h1&gt; &#xA;&lt;h2&gt;Docker Compose&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compsoe, Ã§oklu Docker uygulamalarÄ±nÄ± oluÅŸturmak ve Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lan bir araÃ§tÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Compose ile uygulamanÄ±n hizmetlerini yapÄ±landÄ±rmak iÃ§in bir YAML dosyasÄ± kullanÄ±lÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Daha sonra tek bir komut ile tÃ¼m hizmetleri yapÄ±landÄ±rmaya baÅŸlar ve sistemi baÅŸlatÄ±rÄ±z&lt;/li&gt; &#xA; &lt;li&gt;Compose production iÃ§in Ã§ok uygun bir araÃ§ deÄŸildir. Development aÅŸamasÄ± iÃ§in idealdir&lt;/li&gt; &#xA; &lt;li&gt;Compose, Docker Engine ile birlikte gelen bir araÃ§ deÄŸildir. Bunu ayrÄ±ca sisteme kurmamÄ±z gerekir. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Mac ve Windows sistemlerde Docker Desktop kurduÄŸumuzdan bu uygulama ile birlikte kurulu olarak Compose gelmektedir&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; dosyasÄ± iÃ§erisinde gerekli konfigÃ¼rasyonlar tutulur&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose up -d&lt;/code&gt; ile .yml dosyasÄ± kullanÄ±larak sistem ayaÄŸa kaldÄ±rÄ±lÄ±r&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker compose down&lt;/code&gt; ile sistem kapatÄ±lÄ±r&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Docker Compose CLI&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;docker-compose komutlarÄ±nÄ± kullanmak iÃ§in yml dosyasÄ± ile aynÄ± dizinde olmamÄ±z Ã¶nemlidir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose up&lt;/code&gt; -&amp;gt; &lt;strong&gt;aynÄ± dizindeki&lt;/strong&gt; docker-compose.yml dosyasÄ±nÄ± kullanarak sistemi baÅŸlatÄ±r &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker-compose up -d&lt;/code&gt; -&amp;gt; arka planda (detach) Ã§alÄ±ÅŸtÄ±rÄ±r&lt;/li&gt; &#xA;   &lt;li&gt;docker objelerini isimlendirirken; sistemdeki diÄŸer objeler ile Ã§akÄ±ÅŸmasÄ±n diye docker-compose.yml dosyasÄ±nÄ±n bulunduÄŸu klasÃ¶r adÄ±yla baÅŸlayan isimlendirme yapar -&amp;gt;&amp;nbsp;&lt;code&gt;klasorAdi_objeAdi&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose down&lt;/code&gt; -&amp;gt; tÃ¼m servisleri (docker objeleri) kapatÄ±r ve siler &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;her ÅŸeyi siler fakat volume&#39;leri silmez&lt;/strong&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose config&lt;/code&gt; ile docker-config.yml dosyasÄ±nÄ± gÃ¶sterir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose images&lt;/code&gt; -&amp;gt; servislerin hangi imajlarla oluÅŸtuÄŸunu gÃ¶sterir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose logs&lt;/code&gt; -&amp;gt; tÃ¼m servislerin loglarÄ±nÄ± listeler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose exec&lt;/code&gt; -&amp;gt; compose ile oluÅŸturduÄŸumuz servisin iÃ§inde komut Ã§alÄ±ÅŸtÄ±rÄ±r &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker-compose exec &amp;lt;ServiceName&amp;gt; &amp;lt;Command&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Docker Compose Yaml DosyasÄ±&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Detaylar iÃ§in &lt;a href=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/uygulamalar/Compose/intro/docker-compose.yml&#34;&gt;buraya&lt;/a&gt; bakabilirsiniz&lt;/li&gt; &#xA; &lt;li&gt;Ä°lgili dizinde &lt;code&gt;docker-compose up -d&lt;/code&gt; komutu sayesinde bu config dosyasÄ±ndan sistemi ayaÄŸa kaldÄ±rÄ±yorum. &lt;code&gt;http://127.0.0.1/&lt;/code&gt; adresine gittiÄŸimizde baÅŸarÄ±lÄ± bir ÅŸekilde wordpress kurulumunu gÃ¶rmÃ¼ÅŸ olacaÄŸÄ±z&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Docker Compose Build&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ä°stersek &lt;strong&gt;imajÄ±mÄ±zÄ±&lt;/strong&gt; compose ayaÄŸa kalkarken oluÅŸacak ÅŸekilde ayarlayabiliriz&lt;/li&gt; &#xA; &lt;li&gt;Bunun iÃ§in docker-compose.yml dosyasÄ± ile aynÄ± dizinde bir Dockerfile oluÅŸturmamÄ±z gerekir. Dockerfile iÃ§erisinde istediÄŸimiz imajÄ± hazÄ±rlarÄ±z.&lt;/li&gt; &#xA; &lt;li&gt;Compose file iÃ§inde ise servisi hazÄ±rlarken image yerine &lt;code&gt;build&lt;/code&gt; key&#39;ini kullanÄ±rÄ±z ve build olacak Dockerfile&#39;Ä± aynÄ± dizinde olduÄŸundan &lt;code&gt;.&lt;/code&gt; ile belirtiriz &lt;img src=&#34;https://raw.githubusercontent.com/mebaysan/DockerElKitabi/main/static/compose/Screen%20Shot%202021-01-17%20at%2012.17.21.png&#34; alt=&#34;compose-build&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Daha detaylÄ± bilgi iÃ§in &lt;a href=&#34;https://github.com/ozgurozturknet/AdanZyeDocker/tree/master/kisim6/bolum68&#34;&gt;buraya&lt;/a&gt; bakabiliriz&lt;/li&gt; &#xA; &lt;li&gt;Kod iÃ§erisinde gÃ¼ncelleme yaptÄ±ÄŸÄ±mÄ±zda ise Ã¶nce imajÄ± gÃ¼ncellememiz gerekir. Bunun iÃ§in de &lt;code&gt;docker-compose build&lt;/code&gt; komutunu kullanÄ±r Ã¶nce build aldÄ±ÄŸÄ±mÄ±z imajÄ± gÃ¼ncelleriz. SonrasÄ±nda &lt;code&gt;docker-compose up&lt;/code&gt; ile servisleri ayaÄŸa kaldÄ±rÄ±rÄ±z&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Container Orchestration&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Container Orchestration, containerlarÄ±n daÄŸÄ±tÄ±mÄ±nÄ±, yÃ¶netimini, Ã¶lÃ§eklendirilmesini ve aÄŸ oluÅŸturulmasÄ±nÄ± otomatikleÅŸtirme iÅŸlemine denir&lt;/li&gt; &#xA; &lt;li&gt;YÃ¼zlerce container&#39;Ä± bir arada yÃ¶netmek iÃ§in kullanÄ±lan yazÄ±lÄ±mlardÄ±r&lt;/li&gt; &#xA; &lt;li&gt;En bilinen araÃ§lar: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Swarm&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Docker engine ile gelen bir araÃ§tÄ±r. Docker tarafÄ±ndan geliÅŸtirilmiÅŸtir&lt;/li&gt; &#xA;     &lt;li&gt;Bir Docker ana bilgisayar havuzunu tek bir sanal ana bilgisayara dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Neredeyse sektÃ¶r standardÄ± haline gelmiÅŸtir&lt;/li&gt; &#xA;     &lt;li&gt;Container uygulamalarÄ±nÄ±n daÄŸÄ±tÄ±mÄ±nÄ±, Ã¶lÃ§eklendirilmesini ve yÃ¶netimini otomatikleÅŸtirmek iÃ§in oluÅŸturulmuÅŸ aÃ§Ä±k kaynaklÄ± bir sistemdir&lt;/li&gt; &#xA;     &lt;li&gt;Kolay yÃ¶netim ve keÅŸif iÃ§in uygulamayÄ± oluÅŸturan container&#39;larÄ± mantÄ±ksal birimler halinde gruplandÄ±rÄ±r&lt;/li&gt; &#xA;     &lt;li&gt;Google&#39;da 15 yÄ±ldan fazla sÃ¼reye sahip olan container deneyiminin aÃ§Ä±k kaynak topluluk dÃ¼nyasÄ± Ã¼yelerinin tecrÃ¼belerine eklenerek oluÅŸturulmuÅŸtur&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Docker Swarm&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker Engine&#39;e gÃ¶mÃ¼lÃ¼ bir container orchestration Ã§Ã¶zÃ¼mÃ¼dÃ¼r&lt;/li&gt; &#xA; &lt;li&gt;Bir docker ana bilgisayar havuzunu tek bir sanal ana bilgisayara dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r&lt;/li&gt; &#xA; &lt;li&gt;Hostlar arasÄ±nda ÅŸu portlar aÃ§Ä±k olmalÄ±dÄ±r &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;TCP port 2377 -&amp;gt; Cluster yÃ¶netimi&lt;/li&gt; &#xA;   &lt;li&gt;TCP ve UDP port 7946 -&amp;gt; Nodelar arasÄ± iletiÅŸim&lt;/li&gt; &#xA;   &lt;li&gt;UDP port 4789 -&amp;gt; Overlay network&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Swarm Manager ve Worker Node&lt;/h3&gt; &#xA;&lt;h4&gt;Manager Node&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bir adet manager tarafÄ±ndan diÄŸer hostlar yÃ¶netilir&lt;/li&gt; &#xA; &lt;li&gt;docker swarm init komutunu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda Ã¼zerinde bulunduÄŸumuz host sistemi engine moddan swarm mode geÃ§irir&lt;/li&gt; &#xA; &lt;li&gt;Swarm birden fazla manager node destekler ve bu sayede yÃ¼ksek eriÅŸilebilirlik saÄŸlar. Bir managerda sorun olursa diÄŸer manager devreye girer ve iÅŸ yÃ¼rÃ¼meye devam eder&lt;/li&gt; &#xA; &lt;li&gt;Manager nodelardan yalnÄ±zca 1 tanesi lider olarak seÃ§ilidir ve tÃ¼m yÃ¶netim lider tarafÄ±ndan yapÄ±lÄ±r. DiÄŸer manager nodelar pasif durumdadÄ±r. Pasif manager nodelardan birine bir komut verip iÅŸ yapmasÄ±nÄ± istersek bu sadece proxy gÃ¶revi gÃ¶rÃ¼r ve komutu lider node&#39;a iletir&lt;/li&gt; &#xA; &lt;li&gt;Birden fazla manager olan ortamlarda bir adet lider seÃ§ilmelidir. Swarm bunu otomatik halleder ve bunun iÃ§in Raft Consensus algoritmasÄ±nÄ± kullanÄ±r. Raft algoritmasÄ±; lider seÃ§imi iÃ§in kurallarÄ± belirlemeye yarar. Mesela ortamda 5 manager olan durumda bir ÅŸekilde lider olan nodea eriÅŸilemezse belirli bir zaman sonra kalan 4 node kendi aralarÄ±nda oylama yaparak lider belirler. ArtÄ±k swarm-cluster&#39;Ä±n yÃ¶netimi bu lider tarafÄ±ndan yapÄ±lÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Raft algoritmasÄ± yalnÄ±zca (n-1)/2 sayÄ±da nodeun devre dÄ±ÅŸÄ± kalmasÄ±nÄ± tolere edebilir. (5 node iÃ§in max 2 hata tolere) Aksi halde yÃ¶netim altyapÄ±sÄ± Ã§alÄ±ÅŸmayacaktÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Raft algoritmasÄ±nÄ±n dÃ¼zgÃ¼n Ã§alÄ±ÅŸabilmesi iÃ§in ve lider seÃ§iminin sorunsuz olmasÄ± iÃ§in ortamÄ±n her zaman tek sayÄ±da manager nodela kurulmuÅŸ olmasÄ± gerekir. 7&#39;den fazla manager olduÄŸu durumlarda ortamda daha fazla sorun Ã§Ä±kmasÄ± muhtemeldir.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Worker Node&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swarm cluster kurulur, ve cluster&#39;a worker node olarak dahil ol deriz&lt;/li&gt; &#xA; &lt;li&gt;Manager node&#39;dan sertifika Ã§ekerler ve emir beklerler&lt;/li&gt; &#xA; &lt;li&gt;Ä°stediÄŸimiz sayede worker node ekleyebiliriz&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Docker Swarm init&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bu bÃ¶lÃ¼m iÃ§in &lt;a href=&#34;https://labs.play-with-docker.com/&#34;&gt;labs.play-with-docker.com&lt;/a&gt; adresine gidiyorum ve 5 adet instance oluÅŸturuyorum&lt;/li&gt; &#xA; &lt;li&gt;Bir hostu swarm moda alacaÄŸÄ±z &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker swarm init --advertise-addr 192.168.0.8&lt;/code&gt; bu hostun swarm modunu aktif ediyoruz (192.168.0.8 play with docker tarafÄ±ndan kullandÄ±ÄŸÄ±mÄ±z hosta verilen IP) &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;advertise-addr -&amp;gt; host Ã¼zerindeki kullanmak istediÄŸimiz network kartÄ±na ait adres&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker swarm join-token manager&lt;/code&gt; -&amp;gt; bir nodeu cluster&#39;a manager olarak eklemek iÃ§in gerekli olan komutu ve tokeni verecek &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;manager olarak eklemek istediÄŸimiz node&#39;a (hosta,makinaya,cihaza) gidip ilgili komutu yapÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda cluster&#39;a manager olarak eklenecek&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker swarm join-token worker&lt;/code&gt; -&amp;gt; bir node&#39;u cluster&#39;a worker olarak eklemek iÃ§in gerekli olan komutu ve tokeni verecek &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;aynÄ± ÅŸekilde worker olarak eklemek istediÄŸimiz node&#39;da Ã§alÄ±ÅŸtÄ±rÄ±p nodeu worker olarak cluster&#39;a ekleyeceÄŸiz&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;swarm mode&#39;u aktif ettiÄŸimiz node&#39;a gidip &lt;code&gt;docker node ls&lt;/code&gt; komutu ile cluster hakkÄ±nda bilgi sahibi olabiliriz&lt;/li&gt; &#xA; &lt;li&gt;swarm manager olan node&#39;a gidip &lt;code&gt;docker service create --name test --replicas=5 -p 8080:80 nginx&lt;/code&gt; komutu ile &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;adÄ± test olan (--name)&lt;/li&gt; &#xA;   &lt;li&gt;8080 portu 80 portuna publish edilmiÅŸ (-p)&lt;/li&gt; &#xA;   &lt;li&gt;nginx imajÄ±ndan&lt;/li&gt; &#xA;   &lt;li&gt;5 adet container oluÅŸtur (--replicas=5)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service ps &amp;lt;ServiceName&amp;gt;&lt;/code&gt; -&amp;gt; adÄ± verilen service hakkÄ±nda bilgi getirir&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Swarm Service&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swarm service&#39;lerinde 2 mod vardÄ±r. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Replicated&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Aksini belirtmediÄŸimiz sÃ¼rece bu modda servis oluÅŸturulur&lt;/li&gt; &#xA;     &lt;li&gt;OluÅŸturmak istediÄŸimiz servisin kaÃ§ replica iÃ§ereceÄŸini belirtiriz&lt;/li&gt; &#xA;     &lt;li&gt;Swarm uygun nodelarda o sayÄ±da replica oluÅŸturur&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Global&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Servisin kaÃ§ replica iÃ§ereceÄŸini belirtmeyiz. Swarm altÄ±ndaki her node Ã¼zerinde 1 replica oluÅŸturur-&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service create --name test nginx&lt;/code&gt; -&amp;gt; nginx imajÄ±ndan test adÄ±nda servis oluÅŸtur &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;replika sayÄ±sÄ±nÄ± belirtmediÄŸimiz iÃ§in 1 adet oluÅŸturdu&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service ls&lt;/code&gt; -&amp;gt; service listesini gÃ¶rebiliriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service ps test&lt;/code&gt; -&amp;gt; test adÄ±ndaki servisi altÄ±ndaki tasklara ait detaylarÄ± gÃ¶rebiliriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service logs test&lt;/code&gt; -&amp;gt; test servisi altÄ±ndaki tÃ¼m container&#39;lara ait loglarÄ± gÃ¶sterir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service inspect test&lt;/code&gt;&amp;nbsp;-&amp;gt;&amp;nbsp;test servisine ait detaylar&lt;/li&gt; &#xA; &lt;li&gt;Swarm servislerinin en Ã¶nemli Ã¶zelliklerinden biri servislere hÄ±zlÄ±ca yeni replikalar oluÅŸturabiliriz &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker service scale test=3&lt;/code&gt; ile test servisimize yeni 2 replika daha (zaten 1 replika ile oluÅŸturmuÅŸtuk) ekliyor. AynÄ± ÅŸekilde azaltabiliriz de&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service rm test&lt;/code&gt; -&amp;gt; test adÄ±ndaki servisi sileriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service create --name myglb --mode=global nginx&lt;/code&gt; -&amp;gt; servisi global modda oluÅŸturur (her node Ã¼zerinde 1 replika)&lt;/li&gt; &#xA; &lt;li&gt;Update iÅŸlemi &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;update yapÄ±nca servisteki containerlardan birini siler yerine yeni gÃ¼ncellenmiÅŸ container&#39;Ä± koyar ve sÄ±radaki eski container&#39;a geÃ§er, siler yerine gÃ¼ncellenmiÅŸi koyar ve diÄŸerine geÃ§er ...&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker service create --name websrv --network over-net -p 8080:5000 --replicas=10 mebaysan/basitflaskimaj&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;adÄ± websrv olan&lt;/li&gt; &#xA;     &lt;li&gt;over-net adÄ±nda oluÅŸturulmuÅŸ network driver&#39;a baÄŸlÄ±&lt;/li&gt; &#xA;     &lt;li&gt;8080:5000 port publish yapÄ±lmÄ±ÅŸ olan&lt;/li&gt; &#xA;     &lt;li&gt;10 adet replikaya sahip bir servis oluÅŸtur (play with docker platformu Ã¼zerinde over-net adÄ±nda bir overlay network oluÅŸturdum &amp;amp; 3 manager 2 workerlÄ± bir cluster oluÅŸturmuÅŸtum)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;--update-delay&lt;/code&gt; -&amp;gt; bu parametre, gÃ¼ncellemeler arasÄ±nda ne kadar bekleyeceÄŸini belirtmemizi saÄŸlar (bir containeri sil gyerien gÃ¼ncellenmiÅŸi koy parametre kadar bekle diÄŸerine geÃ§ gibi)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;--update-parallelism&lt;/code&gt; -&amp;gt; bu parametre sayesinde aynÄ± kanda kaÃ§ container&#39;Ä±n gÃ¼ncelleneceÄŸini sÃ¶yleriz (aynÄ± anda 2 container sil gÃ¼ncelle 5 sn bekle diÄŸer ikisine geÃ§ gibi)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker service update --detach --update-delay 5s --update-parallelism 2 --image mebaysan/basitflaskimaj websrv&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;arkaplanda (detach)&lt;/li&gt; &#xA;     &lt;li&gt;5 saniyede bir (update-delay)&lt;/li&gt; &#xA;     &lt;li&gt;aynÄ± anda 2 container olacak ÅŸekilde&lt;/li&gt; &#xA;     &lt;li&gt;mebaysan/basitflaskimaj adÄ±ndaki imajdan&lt;/li&gt; &#xA;     &lt;li&gt;websrv adÄ±ndaki servisi gÃ¼ncelle&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service rollback --detach websrv&lt;/code&gt; -&amp;gt; arkaplanda websrv adÄ±ndaki servisi bir Ã¶nceki haline getir&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Overlay Network&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Overlay network aslÄ±nda bir network driver&#39;dÄ±r&lt;/li&gt; &#xA; &lt;li&gt;FarklÄ± merkezlerde bulunan nodelar sanki aynÄ± merkezdeymiÅŸ gibi haberleÅŸebilir&lt;/li&gt; &#xA; &lt;li&gt;Bir swarm cluster oluÅŸturulduÄŸu zaman ingress adÄ±nda bir overlay network de otomatik olarak oluÅŸturulur. Aksini belirtmediÄŸimiz sÃ¼rece oluÅŸturduÄŸumuz servisler bu overlay network&#39;e baÄŸlanÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Ä°stersek user defined overlay networkler de oluÅŸturabiliriz&lt;/li&gt; &#xA; &lt;li&gt;Overlay networklerin temel yÃ¶netim katmanÄ±nÄ±n haberleÅŸme altyapÄ±sÄ± encryptedir. Fakat buraya baÄŸladÄ±ÄŸÄ±mÄ±z containerlarÄ±n birbirleriyle iletiÅŸimi varsayÄ±lan olarak encrypted deÄŸildir. Overlay network oluÅŸtururken &lt;code&gt;--opt encrypted&lt;/code&gt; parametresini kullanarak bu trafiÄŸin de encrypted olmasÄ±nÄ± saÄŸlayabiliriz. Bu opt encrypted overlay netowrk trafiÄŸini biraz yavaÅŸlatacaktÄ±r.&lt;/li&gt; &#xA; &lt;li&gt;AynÄ± overlay network&#39;e baÄŸlÄ± servislerin containerlarÄ± birbirleriyle herhangi bir port kÄ±sÄ±tlamasÄ± olmaksÄ±zÄ±n haberleÅŸebilirler ve sanki aynÄ± aÄŸdaymÄ±ÅŸ gibi Ã§alÄ±ÅŸÄ±rlar.&lt;/li&gt; &#xA; &lt;li&gt;Swarm altÄ±nda yaratÄ±lan servisler aynÄ± overlay network Ã¼zerinde birbirlerine servis isimleriyle ulaÅŸabilir. Docker burada hem dns Ã§Ã¶zÃ¼mlemesi hizmeti hem de load balancing hizmeti saÄŸlar&lt;/li&gt; &#xA; &lt;li&gt;Overlay network Ã¼zerinde port publsh de yapabiliriz. Swarm overlat networklerde ingress routing mesh destekler. Port publish edip Docker host Ã¼zerinden o porta eriÅŸirsek Docker o host Ã¼stÃ¼nde o portun publish olduÄŸu bir container bulunmasa bile bulunan bir host&#39;a trafiÄŸi yÃ¶nlendirecek ve cevap verecektir&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker network create -d overlay over-net&lt;/code&gt; -&amp;gt; adÄ± over-net olan overlay bir network oluÅŸtur&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Docker Secret&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Conteinar&#39;larda plain text olarak tutmamÄ±zÄ±n gÃ¼venlik zafiyeti oluÅŸturabileceÄŸi username ve password gibi verileri secret objeleri ÅŸeklinde encrypted olarak transfer edebiliriz&lt;/li&gt; &#xA; &lt;li&gt;Docker Swarm, aynÄ± volume ve container&#39;lar gibi birer Docker objesidir&lt;/li&gt; &#xA; &lt;li&gt;Swarm altÄ±nda bir isim ve deÄŸer ÅŸeklinde secretler oluÅŸturabiliriz. Bu objeler Swarm cluster&#39;Ä±n raft deposunda encrypted olarak saklanÄ±yor. Bu secretleri istediÄŸimiz servislere baÄŸlayabiliyoruz. Secret, Swarm manager&#39;dan servisin Ã§alÄ±ÅŸacaÄŸÄ± container&#39;a transfer ediliyor (encrypted). BaÄŸlandÄ±ÄŸÄ± service container&#39;larÄ±nÄ±n /run/secrets klasÃ¶rÃ¼nde eriÅŸilebilecek ÅŸekilde map ediliyor. O container bu path iÃ§indeki objeye eriÅŸiyor ve kullanÄ±yor&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker swarm init&lt;/code&gt; diyerek swarm cluster oluÅŸturuyoruz&lt;/li&gt; &#xA; &lt;li&gt;Secret oluÅŸturmanÄ±n iki yolu vardÄ±r. Birincisi metin dosyalarÄ±ndan oluÅŸturmaktÄ±r &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;username.txt ve password.txt dosyalarÄ±mÄ±n olduÄŸu dizine gidiyorum. &lt;code&gt;docker secret create &amp;lt;SecretName&amp;gt; &amp;lt;FilePath&amp;gt;&lt;/code&gt; komutu ile secret oluÅŸturuyoruz &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker secret create username ./username.txt&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;docker secret create password ./password.txt&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker secret ls&lt;/code&gt; ile Secret&#39;leri listeleriz&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker secret rm &amp;lt;SecretName&amp;gt;&lt;/code&gt; ile Secret sileriz&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker secret inspect &amp;lt;SecretName&amp;gt;&lt;/code&gt; ile Secret inceleyebiliriz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Ä°kinci yÃ¶ntem ise terminalden oluÅŸturmaktÄ±r &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;echo &#34;&amp;lt;SECRET&amp;gt;&#34; | docker create &amp;lt;SecretName&amp;gt; -&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;echo &#34;Bu bir secrettir&#34; | docker secret create deneme -&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker service create -d --name secrettest --secret username --secret password mebaysan/basitflaskimaj&lt;/code&gt; -&amp;gt; bir servis oluÅŸturduk ve iÃ§erisine cluster&#39;daki secretlarÄ± gÃ¶nderdik&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker exec -it 0c sh&lt;/code&gt; -&amp;gt; oluÅŸturduÄŸumuz container&#39;a baÄŸlandÄ±k&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd /run/secrets&lt;/code&gt; -&amp;gt; secretlarÄ±n tutulduÄŸu dizine gidiyoruz ve orada oluÅŸturduÄŸumuz secret isimleriyle dosyalar gÃ¶rÃ¼yoruz. BunlarÄ±n deÄŸerleri de secretlarÄ±n deÄŸerleridir&lt;/li&gt; &#xA; &lt;li&gt;Secret&#39;i gÃ¼ncellemek istersek service&#39;i gÃ¼ncellememiz gerekir&lt;/li&gt; &#xA; &lt;li&gt;Ã–nce cluster&#39;da yeni bir secret oluÅŸturuyoruz (varsayalÄ±m ki username2 adÄ±nda olsun) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker service update --secret-rm username --secret-add username2 secrettest&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;--secret-rm username&lt;/code&gt; secrettest servisindeki username adlÄ± secreti sil&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;--secret-add username2&lt;/code&gt; ilgili servisteki username secret&#39;in yeni deÄŸerini cluster&#39;daki username2 secretinin deÄŸeri olarak gÃ¼ncelle&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Docker Stack&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker Compose&#39;daki gibi bir iÅŸleme benzer. Stack de bunu swarm ortamÄ±nda yapmamÄ±zÄ± saÄŸlar.&lt;/li&gt; &#xA; &lt;li&gt;docker-compose.yml dosyasÄ± kullanÄ±r&lt;/li&gt; &#xA; &lt;li&gt;Docker Compose dosyasÄ± ile arasÄ±nda bazÄ± farklar var &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Docker Engine ile tanÄ±mlÄ± komutlar Compose ile kullanÄ±labilirken Stack iÃ§in kullanÄ±lamaz&lt;/li&gt; &#xA;   &lt;li&gt;Stack iÃ§in uygun olan komutlar Compose ile kullanÄ±lamaz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Ä°lgili dosyanÄ±n bulunduÄŸu dizine gidiyorum&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker stack ls&lt;/code&gt; -&amp;gt; oluÅŸturduÄŸumuz stckleri listeler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker stack ps&lt;/code&gt; -&amp;gt; stack altÄ±ndaki tasklarÄ± gÃ¶rebiliriz&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker stack rm &amp;lt;StackName&amp;gt;&lt;/code&gt; -&amp;gt; ilgili stack i siler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker stack services &amp;lt;StackName&amp;gt;&lt;/code&gt; -&amp;gt; ilgili stack altÄ±ndaki servisleri listeler&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker stack deploy -c ./docker-compose.yml ilkstack&lt;/code&gt; -&amp;gt; docker-compose.yml&#39;dan bir stack oluÅŸturur ve ayaÄŸa kaldÄ±rÄ±r. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;ilkstack adÄ±ndaki stack&#39;i bu dizindeki docker-compose.yml dosyasÄ±ndan oluÅŸturur&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;stacklerde docker-compose.yml pathini belirtmemiz gerekir&lt;/strong&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>hiifeng/V2ray-for-Doprax</title>
    <updated>2023-01-01T01:32:49Z</updated>
    <id>tag:github.com,2023-01-01:/hiifeng/V2ray-for-Doprax</id>
    <link href="https://github.com/hiifeng/V2ray-for-Doprax" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The tool can install v2ray on the Doprax, including VMess and VLess protocols, it will automatically switch IP, you need to fork this projects, read readme.md and run it. Create By ifeng.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;V2ray for Doprax&lt;/h1&gt; &#xA;&lt;p&gt;Create By ifeng&lt;br&gt; Web Site: &lt;a href=&#34;https://www.hicairo.com&#34;&gt;https://www.hicairo.com&lt;/a&gt; &lt;br&gt; Telegram: &lt;a href=&#34;https://t.me/HiaiFeng&#34;&gt;https://t.me/HiaiFeng&lt;/a&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;ç®€ä»‹ï¼š&lt;/h1&gt; &#xA;&lt;p&gt;æœ¬é¡¹ç›®ç”¨äºåœ¨ Doprax.com å…è´¹æœåŠ¡ä¸Šéƒ¨ç½² V2ray ï¼Œé‡‡ç”¨çš„æ–¹æ¡ˆä¸º Nginx + WebSocket + VMess/VLess + TLSã€‚é€Ÿåº¦ä¸ Replit ç›¸æ¯”è¾ƒæ…¢ï¼Œä½†æ˜¯å®˜æ–¹å®£ä¼ ä¸é™æµé‡ï¼ŒæœåŠ¡å¯åŠ¨åæ°¸ä¸åœæœºã€‚&lt;/p&gt; &#xA;&lt;h1&gt;æ³¨æ„äº‹é¡¹ï¼š&lt;/h1&gt; &#xA;&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;&#xA;&lt;li&gt;&lt;b&gt;è¯·å‹¿æ»¥ç”¨ï¼Œè´¦å·å°ç¦é£é™©è‡ªè´Ÿã€‚&lt;/b&gt;&lt;/li&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;&#xA;&lt;li&gt;&lt;b&gt;éƒ¨ç½²å®Œæˆå¦‚å‘ç°ä¸èƒ½ä¸Šç½‘ï¼Œè¯·æ£€æŸ¥åŸŸåæ˜¯å¦è¢«å¢™ï¼Œå¯ä½¿ç”¨ Cloudflare CDN è§£å†³ã€‚&lt;/b&gt;&lt;/li&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;h1&gt;éƒ¨ç½²ï¼š&lt;/h1&gt; &#xA;&lt;p&gt;1ã€ç™»å½•è‡ªå·±çš„ GitHub è´¦å·å Fork è¯¥é¡¹ç›®ã€‚&lt;/p&gt; &#xA;&lt;p&gt;2ã€æ³¨å†Œ &lt;a href=&#34;https://www.doprax.com/signup/&#34;&gt;Doprax.com&lt;/a&gt; è´¦å·ç™»å½•å Import è¯¥é¡¹ç›®ã€‚&lt;/p&gt; &#xA;&lt;p&gt;è¯¦ç»†ä½¿ç”¨æ–¹æ¡ˆè¯·å‚è€ƒï¼šhttps://www.hicairo.com/post/55.html&lt;/p&gt; &#xA;&lt;h1&gt;ä½¿ç”¨æ–¹æ³•ï¼š&lt;/h1&gt; &#xA;&lt;p&gt;1ã€æœåŠ¡å™¨ç«¯é…ç½®&lt;/p&gt; &#xA;&lt;p&gt;è¯·ä½¿ç”¨ &lt;a href=&#34;https://www.v2fly.org/awesome/tools.html&#34;&gt;ç¬¬ä¸‰æ–¹å·¥å…·&lt;/a&gt; ç”Ÿæˆä¸€ä¸ªæ–°çš„ UUID ã€‚åœ¨ Doprax.com ç™»å½•åä¾æ¬¡ç‚¹å‡»å·¦ä¾§èœå•ä¸­çš„ Main ,çª—å£å³ä¾§çš„ Edit source code ï¼Œé€‰æ‹© Dockerfile æ–‡ä»¶ï¼Œç¼–è¾‘ UUID åŠä¼ªè£…åœ°å€ä¿¡æ¯ä¿å­˜åé‡å¯æœåŠ¡ã€‚&lt;/p&gt; &#xA;&lt;img src=&#34;https://www.hicairo.com/zb_users/upload/2022/12/202212291672276227538571.webp&#34;&gt; &#xA;&lt;pre class=&#34;notranslate&#34;&gt;&lt;code&gt;# ç”¨æ–°ç”Ÿæˆçš„ UUID æ›¿æ¢ de04add9-5c68-8bab-950c-08cd5320df18&#xA;ENV UUID de04add9-5c68-8bab-950c-08cd5320df18&#xA;# VMESS_WSPATH / VLESS_WSPATH ä¸¤ä¸ªå¸¸é‡åˆ†åˆ«å®šä¹‰äº† Vmess/VLess çš„ä¼ªè£…è·¯å¾„ï¼Œ&#xA;# è¯·åˆ†åˆ«ä¿®æ”¹å†…å®¹ä¸­çš„vmessæˆ–vlessã€‚æ³¨æ„ï¼šä¼ªè£…è·¯å¾„å‰æ— éœ€åŠ   /&#xA;ENV VMESS_WSPATH vmess&#xA;ENV VLESS_WSPATH vless&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;2ã€å®¢æˆ·ç«¯é…ç½®&lt;/p&gt; &#xA;&lt;p&gt;èŠ‚ç‚¹å®¢æˆ·ç«¯é…ç½®éœ€è¦æ‰‹åŠ¨è¿›è¡Œï¼Œä¸‹é¢ä»¥ V2rayN ä¸ºä¾‹ã€‚ &lt;/p&gt;&#xA;&lt;p&gt;ä¸‹å›¾ä¸º VMess é…ç½®ç¤ºæ„å›¾ï¼Œè¯·ä¿®æ”¹æ ‡ç¤ºå†…å®¹ï¼Œå…¶ä»–è®¾ç½®äºå›¾ç‰‡ä¸­æ˜¾ç¤ºä¸€è‡´ã€‚(æ³¨æ„ï¼šæ­¤å¤„è¯·åœ¨ä¼ªè£…è·¯å¾„å‰åŠ  / )&lt;/p&gt; &#xA;&lt;img src=&#34;https://www.hicairo.com/zb_users/upload/2022/12/202212291672276258394161.webp&#34;&gt; &#xA;&lt;p&gt;ä¸‹å›¾ä¸º VMess é…ç½®ç¤ºæ„å›¾ï¼Œè¯·ä¿®æ”¹æ ‡ç¤ºå†…å®¹ï¼Œå…¶ä»–è®¾ç½®äºå›¾ç‰‡ä¸­æ˜¾ç¤ºä¸€è‡´ã€‚(æ³¨æ„ï¼šæ­¤å¤„è¯·åœ¨ä¼ªè£…è·¯å¾„å‰åŠ  / )&lt;/p&gt; &#xA;&lt;img src=&#34;https://www.hicairo.com/zb_users/upload/2022/12/202212291672276274474231.webp&#34;&gt; &#xA;&lt;h1&gt;åé¦ˆä¸äº¤æµï¼š&lt;/h1&gt; &#xA;&lt;p&gt;åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ°é—®é¢˜ï¼Œè¯·ä½¿ç”¨Telegramä¸æˆ‘è”ç³»ã€‚ï¼ˆ &lt;a href=&#34;https://t.me/HiaiFeng&#34;&gt;https://t.me/HiaiFeng&lt;/a&gt; ï¼‰&lt;/p&gt;</summary>
  </entry>
</feed>