<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-20T01:39:43Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>PHP-FFMpeg/PHP-FFMpeg</title>
    <updated>2023-04-20T01:39:43Z</updated>
    <id>tag:github.com,2023-04-20:/PHP-FFMpeg/PHP-FFMpeg</id>
    <link href="https://github.com/PHP-FFMpeg/PHP-FFMpeg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An object oriented PHP driver for FFMpeg binary&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PHP-FFMPEG&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/PHP-FFMpeg/PHP-FFMpeg&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/PHP-FFMpeg/PHP-FFMpeg.svg?style=flat-square&#34; alt=&#34;Latest Version on Packagist&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/PHP-FFMpeg/PHP-FFMpeg/master/LICENSE.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square&#34; alt=&#34;Software License&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/PHP-FFMpeg/PHP-FFMpeg/workflows/run-tests/badge.svg?sanitize=true&#34; alt=&#34;run-tests&#34;&gt; &lt;a href=&#34;https://packagist.org/packages/PHP-FFMpeg/PHP-FFMpeg&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dt/PHP-FFMpeg/PHP-FFMpeg.svg?style=flat-square&#34; alt=&#34;Total Downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An Object-Oriented library to convert video/audio files with FFmpeg / AVConv.&lt;/p&gt; &#xA;&lt;h2&gt;Your attention please&lt;/h2&gt; &#xA;&lt;h3&gt;How this library works:&lt;/h3&gt; &#xA;&lt;p&gt;This library requires a working &lt;a href=&#34;https://ffmpeg.org/download.html&#34;&gt;FFMpeg install&lt;/a&gt;. You will need both FFMpeg and FFProbe binaries to use it. Be sure that these binaries can be located with system PATH to get the benefit of the binary detection, otherwise you should have to explicitly give the binaries path on load.&lt;/p&gt; &#xA;&lt;h3&gt;Known issues:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using rotate and resize will produce a corrupted output when using &lt;a href=&#34;http://libav.org/&#34;&gt;libav&lt;/a&gt; 0.8. The bug is fixed in version 9. This bug does not appear in latest ffmpeg version.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;This library requires PHP 8.0 or higher. For older versions of PHP, check out the &lt;a href=&#34;https://github.com/PHP-FFMpeg/PHP-FFMpeg/tree/0.x&#34;&gt;0.x-branch&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The recommended way to install PHP-FFMpeg is through &lt;a href=&#34;https://getcomposer.org&#34;&gt;Composer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ composer require php-ffmpeg/php-ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&#xA;require &#39;vendor/autoload.php&#39;;&#xA;&#xA;$ffmpeg = FFMpeg\FFMpeg::create();&#xA;$video = $ffmpeg-&amp;gt;open(&#39;video.mpg&#39;);&#xA;$video&#xA;    -&amp;gt;filters()&#xA;    -&amp;gt;resize(new FFMpeg\Coordinate\Dimension(320, 240))&#xA;    -&amp;gt;synchronize();&#xA;$video&#xA;    -&amp;gt;frame(FFMpeg\Coordinate\TimeCode::fromSeconds(10))&#xA;    -&amp;gt;save(&#39;frame.jpg&#39;);&#xA;$video&#xA;    -&amp;gt;save(new FFMpeg\Format\Video\X264(), &#39;export-x264.mp4&#39;)&#xA;    -&amp;gt;save(new FFMpeg\Format\Video\WMV(), &#39;export-wmv.wmv&#39;)&#xA;    -&amp;gt;save(new FFMpeg\Format\Video\WebM(), &#39;export-webm.webm&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;This documentation is an introduction to discover the API. It&#39;s recommended to browse the source code as it is self-documented.&lt;/p&gt; &#xA;&lt;h3&gt;FFMpeg&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FFMpeg\FFMpeg&lt;/code&gt; is the main object to use to manipulate medias. To build it, use the static &lt;code&gt;FFMpeg\FFMpeg::create&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffmpeg = FFMpeg\FFMpeg::create();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;FFMpeg will autodetect ffmpeg and ffprobe binaries. If you want to give binary paths explicitly, you can pass an array as configuration. A &lt;code&gt;Psr\Logger\LoggerInterface&lt;/code&gt; can also be passed to log binary executions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffmpeg = FFMpeg\FFMpeg::create(array(&#xA;    &#39;ffmpeg.binaries&#39;  =&amp;gt; &#39;/opt/local/ffmpeg/bin/ffmpeg&#39;,&#xA;    &#39;ffprobe.binaries&#39; =&amp;gt; &#39;/opt/local/ffmpeg/bin/ffprobe&#39;,&#xA;    &#39;timeout&#39;          =&amp;gt; 3600, // The timeout for the underlying process&#xA;    &#39;ffmpeg.threads&#39;   =&amp;gt; 12,   // The number of threads that FFMpeg should use&#xA;), $logger);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may pass a &lt;code&gt;temporary_directory&lt;/code&gt; key to specify a path for temporary files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffmpeg = FFMpeg\FFMpeg::create(array(&#xA;    &#39;temporary_directory&#39; =&amp;gt; &#39;/var/ffmpeg-tmp&#39;&#xA;), $logger);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manipulate media&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FFMpeg\FFMpeg&lt;/code&gt; creates media based on URIs. URIs could be either a pointer to a local filesystem resource, an HTTP resource or any resource supported by FFmpeg.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: To list all supported resource type of your FFmpeg build, use the &lt;code&gt;-protocols&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ffmpeg -protocols&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To open a resource, use the &lt;code&gt;FFMpeg\FFMpeg::open&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffmpeg-&amp;gt;open(&#39;video.mpeg&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Two types of media can be resolved: &lt;code&gt;FFMpeg\Media\Audio&lt;/code&gt; and &lt;code&gt;FFMpeg\Media\Video&lt;/code&gt;. A third type, &lt;code&gt;FFMpeg\Media\Frame&lt;/code&gt;, is available through videos.&lt;/p&gt; &#xA;&lt;h3&gt;Video&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FFMpeg\Media\Video&lt;/code&gt; can be transcoded, ie: change codec, isolate audio or video. Frames can be extracted.&lt;/p&gt; &#xA;&lt;h5&gt;Transcoding&lt;/h5&gt; &#xA;&lt;p&gt;You can transcode videos using the &lt;code&gt;FFMpeg\Media\Video:save&lt;/code&gt; method. You will pass a &lt;code&gt;FFMpeg\Format\FormatInterface&lt;/code&gt; for that.&lt;/p&gt; &#xA;&lt;p&gt;Please note that audio and video bitrate are set on the format. You can disable the &lt;code&gt;-b:v&lt;/code&gt; option by setting the kilo bitrate to 0.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$format = new FFMpeg\Format\Video\X264();&#xA;$format-&amp;gt;on(&#39;progress&#39;, function ($video, $format, $percentage) {&#xA;    echo &#34;$percentage % transcoded&#34;;&#xA;});&#xA;&#xA;$format&#xA;    -&amp;gt;setKiloBitrate(1000)&#xA;    -&amp;gt;setAudioChannels(2)&#xA;    -&amp;gt;setAudioKiloBitrate(256);&#xA;&#xA;$video-&amp;gt;save($format, &#39;video.avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Transcoding progress can be monitored in realtime, see Format documentation below for more information.&lt;/p&gt; &#xA;&lt;h5&gt;Extracting image&lt;/h5&gt; &#xA;&lt;p&gt;You can extract a frame at any timecode using the &lt;code&gt;FFMpeg\Media\Video::frame&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;This code returns a &lt;code&gt;FFMpeg\Media\Frame&lt;/code&gt; instance corresponding to the second 42. You can pass any &lt;code&gt;FFMpeg\Coordinate\TimeCode&lt;/code&gt; as argument, see dedicated documentation below for more information.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$frame = $video-&amp;gt;frame(FFMpeg\Coordinate\TimeCode::fromSeconds(42));&#xA;$frame-&amp;gt;save(&#39;image.jpg&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to extract multiple images from the video, you can use the following filter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video&#xA;    -&amp;gt;filters()&#xA;    -&amp;gt;extractMultipleFrames(FFMpeg\Filters\Video\ExtractMultipleFramesFilter::FRAMERATE_EVERY_10SEC, &#39;/path/to/destination/folder/&#39;)&#xA;    -&amp;gt;synchronize();&#xA;&#xA;$video&#xA;    -&amp;gt;save(new FFMpeg\Format\Video\X264(), &#39;/path/to/new/file&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, this will save the frames as &lt;code&gt;jpg&lt;/code&gt; images.&lt;/p&gt; &#xA;&lt;p&gt;You are able to override this using &lt;code&gt;setFrameFileType&lt;/code&gt; to save the frames in another format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$frameFileType = &#39;jpg&#39;; // either &#39;jpg&#39;, &#39;jpeg&#39; or &#39;png&#39;&#xA;$filter = new ExtractMultipleFramesFilter($frameRate, $destinationFolder);&#xA;$filter-&amp;gt;setFrameFileType($frameFileType);&#xA;&#xA;$video-&amp;gt;addFilter($filter);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Clip&lt;/h5&gt; &#xA;&lt;p&gt;Cuts the video at a desired point. Use input seeking method. It is faster option than use filter clip.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$clip = $video-&amp;gt;clip(FFMpeg\Coordinate\TimeCode::fromSeconds(30), FFMpeg\Coordinate\TimeCode::fromSeconds(15));&#xA;$clip-&amp;gt;save(new FFMpeg\Format\Video\X264(), &#39;video.avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The clip filter takes two parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$start&lt;/code&gt;, an instance of &lt;code&gt;FFMpeg\Coordinate\TimeCode&lt;/code&gt;, specifies the start point of the clip&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$duration&lt;/code&gt;, optional, an instance of &lt;code&gt;FFMpeg\Coordinate\TimeCode&lt;/code&gt;, specifies the duration of the clip&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;On clip you can apply same filters as on video. For example resizing filter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$clip = $video-&amp;gt;clip(FFMpeg\Coordinate\TimeCode::fromSeconds(30), FFMpeg\Coordinate\TimeCode::fromSeconds(15));&#xA;$clip-&amp;gt;filters()-&amp;gt;resize(new FFMpeg\Coordinate\Dimension(320, 240), FFMpeg\Filters\Video\ResizeFilter::RESIZEMODE_INSET, true);&#xA;$clip-&amp;gt;save(new FFMpeg\Format\Video\X264(), &#39;video.avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Generate a waveform&lt;/h5&gt; &#xA;&lt;p&gt;You can generate a waveform of an audio file using the &lt;code&gt;FFMpeg\Media\Audio::waveform&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;This code returns a &lt;code&gt;FFMpeg\Media\Waveform&lt;/code&gt; instance. You can optionally pass dimensions as the first two arguments and an array of hex string colors for ffmpeg to use for the waveform, see dedicated documentation below for more information.&lt;/p&gt; &#xA;&lt;p&gt;The output file MUST use the PNG extension.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$waveform = $audio-&amp;gt;waveform(640, 120, array(&#39;#00FF00&#39;));&#xA;$waveform-&amp;gt;save(&#39;waveform.png&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to get a waveform from a video, convert it in an audio file first.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Open your video file&#xA;$video = $ffmpeg-&amp;gt;open( &#39;video.mp4&#39; );&#xA;&#xA;// Set an audio format&#xA;$audio_format = new FFMpeg\Format\Audio\Mp3();&#xA;&#xA;// Extract the audio into a new file as mp3&#xA;$video-&amp;gt;save($audio_format, &#39;audio.mp3&#39;);&#xA;&#xA;// Set the audio file&#xA;$audio = $ffmpeg-&amp;gt;open( &#39;audio.mp3&#39; );&#xA;&#xA;// Create the waveform&#xA;$waveform = $audio-&amp;gt;waveform();&#xA;$waveform-&amp;gt;save( &#39;waveform.png&#39; );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Filters&lt;/h5&gt; &#xA;&lt;p&gt;You can apply filters on &lt;code&gt;FFMpeg\Media\Video&lt;/code&gt; with the &lt;code&gt;FFMpeg\Media\Video::addFilter&lt;/code&gt; method. Video accepts Audio and Video filters.&lt;/p&gt; &#xA;&lt;p&gt;You can build your own filters and some are bundled in PHP-FFMpeg - they are accessible through the &lt;code&gt;FFMpeg\Media\Video::filters&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;Filters are chainable&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video&#xA;    -&amp;gt;filters()&#xA;    -&amp;gt;resize($dimension, $mode, $useStandards)&#xA;    -&amp;gt;framerate($framerate, $gop)&#xA;    -&amp;gt;synchronize();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Rotate&lt;/h6&gt; &#xA;&lt;p&gt;Rotates a video to a given angle.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;filters()-&amp;gt;rotate($angle);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;$angle&lt;/code&gt; parameter must be one of the following constants :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Filters\Video\RotateFilter::ROTATE_90&lt;/code&gt;: 90° clockwise&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Filters\Video\RotateFilter::ROTATE_180&lt;/code&gt;: 180°&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Filters\Video\RotateFilter::ROTATE_270&lt;/code&gt;: 90° counterclockwise&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h6&gt;Resize&lt;/h6&gt; &#xA;&lt;p&gt;Resizes a video to a given size.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;filters()-&amp;gt;resize($dimension, $mode, $useStandards);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resize filter takes three parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$dimension&lt;/code&gt;, an instance of &lt;code&gt;FFMpeg\Coordinate\Dimension&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$mode&lt;/code&gt;, one of the constants &lt;code&gt;FFMpeg\Filters\Video\ResizeFilter::RESIZEMODE_*&lt;/code&gt; constants&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$useStandards&lt;/code&gt;, a boolean to force the use of the nearest aspect ratio standard.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want a video in a non-standard ratio, you can use the padding filter to resize your video in the desired size, and wrap it into black bars.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;filters()-&amp;gt;pad($dimension);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The pad filter takes one parameter:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$dimension&lt;/code&gt;, an instance of &lt;code&gt;FFMpeg\Coordinate\Dimension&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Don&#39;t forget to save it afterwards.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;save(new FFMpeg\Format\Video\X264(), $new_file);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Watermark&lt;/h6&gt; &#xA;&lt;p&gt;Watermark a video with a given image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video&#xA;    -&amp;gt;filters()&#xA;    -&amp;gt;watermark($watermarkPath, array(&#xA;        &#39;position&#39; =&amp;gt; &#39;relative&#39;,&#xA;        &#39;bottom&#39; =&amp;gt; 50,&#xA;        &#39;right&#39; =&amp;gt; 50,&#xA;    ));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The watermark filter takes two parameters:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;$watermarkPath&lt;/code&gt;, the path to your watermark file. &lt;code&gt;$coordinates&lt;/code&gt;, an array defining how you want your watermark positioned. You can use relative positioning as demonstrated above or absolute as such:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video&#xA;    -&amp;gt;filters()&#xA;    -&amp;gt;watermark($watermarkPath, array(&#xA;        &#39;position&#39; =&amp;gt; &#39;absolute&#39;,&#xA;        &#39;x&#39; =&amp;gt; 1180,&#xA;        &#39;y&#39; =&amp;gt; 620,&#xA;    ));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Framerate&lt;/h6&gt; &#xA;&lt;p&gt;Changes the frame rate of the video.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;filters()-&amp;gt;framerate($framerate, $gop);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The framerate filter takes two parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$framerate&lt;/code&gt;, an instance of &lt;code&gt;FFMpeg\Coordinate\FrameRate&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$gop&lt;/code&gt;, a &lt;a href=&#34;https://wikipedia.org/wiki/Group_of_pictures&#34;&gt;GOP&lt;/a&gt; value (integer)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h6&gt;Synchronize&lt;/h6&gt; &#xA;&lt;p&gt;Synchronizes audio and video.&lt;/p&gt; &#xA;&lt;p&gt;Some containers may use a delay that results in desynchronized outputs. This filter solves this issue.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;filters()-&amp;gt;synchronize();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Clip&lt;/h6&gt; &#xA;&lt;p&gt;Cuts the video at a desired point.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;filters()-&amp;gt;clip(FFMpeg\Coordinate\TimeCode::fromSeconds(30), FFMpeg\Coordinate\TimeCode::fromSeconds(15));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The clip filter takes two parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$start&lt;/code&gt;, an instance of &lt;code&gt;FFMpeg\Coordinate\TimeCode&lt;/code&gt;, specifies the start point of the clip&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$duration&lt;/code&gt;, optional, an instance of &lt;code&gt;FFMpeg\Coordinate\TimeCode&lt;/code&gt;, specifies the duration of the clip&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h6&gt;Crop&lt;/h6&gt; &#xA;&lt;p&gt;Crops the video based on a width and height(a &lt;code&gt;Point&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video-&amp;gt;filters()-&amp;gt;crop(new FFMpeg\Coordinate\Point(&#34;t*100&#34;, 0, true), new FFMpeg\Coordinate\Dimension(200, 600));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It takes two parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$point&lt;/code&gt;, an instance of &lt;code&gt;FFMpeg\Coordinate\Point&lt;/code&gt;, specifies the point to crop&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$dimension&lt;/code&gt;, an instance of &lt;code&gt;FFMpeg\Coordinate\Dimension&lt;/code&gt;, specifies the dimension of the output video&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Audio&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FFMpeg\Media\Audio&lt;/code&gt; can be transcoded too, ie: change codec, isolate audio or video. Frames can be extracted.&lt;/p&gt; &#xA;&lt;h5&gt;Transcoding&lt;/h5&gt; &#xA;&lt;p&gt;You can transcode audios using the &lt;code&gt;FFMpeg\Media\Audio:save&lt;/code&gt; method. You will pass a &lt;code&gt;FFMpeg\Format\FormatInterface&lt;/code&gt; for that.&lt;/p&gt; &#xA;&lt;p&gt;Please note that audio kilobitrate is set on the audio format.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffmpeg = FFMpeg\FFMpeg::create();&#xA;$audio = $ffmpeg-&amp;gt;open(&#39;track.mp3&#39;);&#xA;&#xA;$format = new FFMpeg\Format\Audio\Flac();&#xA;$format-&amp;gt;on(&#39;progress&#39;, function ($audio, $format, $percentage) {&#xA;    echo &#34;$percentage % transcoded&#34;;&#xA;});&#xA;&#xA;$format&#xA;    -&amp;gt;setAudioChannels(2)&#xA;    -&amp;gt;setAudioKiloBitrate(256);&#xA;&#xA;$audio-&amp;gt;save($format, &#39;track.flac&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Transcoding progress can be monitored in realtime, see Format documentation below for more information.&lt;/p&gt; &#xA;&lt;h5&gt;Filters&lt;/h5&gt; &#xA;&lt;p&gt;You can apply filters on &lt;code&gt;FFMpeg\Media\Audio&lt;/code&gt; with the &lt;code&gt;FFMpeg\Media\Audio::addFilter&lt;/code&gt; method. It only accepts audio filters.&lt;/p&gt; &#xA;&lt;p&gt;You can build your own filters and some are bundled in PHP-FFMpeg - they are accessible through the &lt;code&gt;FFMpeg\Media\Audio::filters&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;h5&gt;Clipping&lt;/h5&gt; &#xA;&lt;p&gt;Cuts the audio at a desired point.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$audio-&amp;gt;filters()-&amp;gt;clip(FFMpeg\Coordinate\TimeCode::fromSeconds(30), FFMpeg\Coordinate\TimeCode::fromSeconds(15));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Metadata&lt;/h6&gt; &#xA;&lt;p&gt;Add metadata to audio files. Just pass an array of key=value pairs of all metadata you would like to add. If no arguments are passed into the filter all metadata will be removed from input file. Currently supported data is title, artist, album, artist, composer, track, year, description, artwork&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$audio-&amp;gt;filters()-&amp;gt;addMetadata([&#34;title&#34; =&amp;gt; &#34;Some Title&#34;, &#34;track&#34; =&amp;gt; 1]);&#xA;&#xA;//remove all metadata and video streams from audio file&#xA;$audio-&amp;gt;filters()-&amp;gt;addMetadata();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add artwork to the audio file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$audio-&amp;gt;filters()-&amp;gt;addMetadata([&#34;artwork&#34; =&amp;gt; &#34;/path/to/image/file.jpg&#34;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: at present ffmpeg (version 3.2.2) only supports artwork output for .mp3 files&lt;/p&gt; &#xA;&lt;h6&gt;Resample&lt;/h6&gt; &#xA;&lt;p&gt;Resamples an audio file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$audio-&amp;gt;filters()-&amp;gt;resample($rate);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resample filter takes two parameters :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$rate&lt;/code&gt;, a valid audio sample rate value (integer)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Frame&lt;/h4&gt; &#xA;&lt;p&gt;A frame is an image at a timecode of a video; see documentation above about frame extraction.&lt;/p&gt; &#xA;&lt;p&gt;You can save frames using the &lt;code&gt;FFMpeg\Media\Frame::save&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$frame-&amp;gt;save(&#39;target.jpg&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method has a second optional boolean parameter. Set it to true to get accurate images; it takes more time to execute.&lt;/p&gt; &#xA;&lt;h4&gt;Gif&lt;/h4&gt; &#xA;&lt;p&gt;A gif is an animated image extracted from a sequence of the video.&lt;/p&gt; &#xA;&lt;p&gt;You can save gif files using the &lt;code&gt;FFMpeg\Media\Gif::save&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$video = $ffmpeg-&amp;gt;open( &#39;/path/to/video&#39; );&#xA;$video&#xA;    -&amp;gt;gif(FFMpeg\Coordinate\TimeCode::fromSeconds(2), new FFMpeg\Coordinate\Dimension(640, 480), 3)&#xA;    -&amp;gt;save($new_file);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method has a third optional boolean parameter, which is the duration of the animation. If you don&#39;t set it, you will get a fixed gif image.&lt;/p&gt; &#xA;&lt;h4&gt;Concatenation&lt;/h4&gt; &#xA;&lt;p&gt;This feature allows you to generate one audio or video file, based on multiple sources.&lt;/p&gt; &#xA;&lt;p&gt;There are two ways to concatenate videos, depending on the codecs of the sources. If your sources have all been encoded with the same codec, you will want to use the &lt;code&gt;FFMpeg\Media\Concatenate::saveFromSameCodecs&lt;/code&gt; which has way better performances. If your sources have been encoded with different codecs, you will want to use the &lt;code&gt;FFMpeg\Media\Concatenate::saveFromDifferentCodecs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The first function will use the initial codec as the one for the generated file. With the second function, you will be able to choose which codec you want for the generated file.&lt;/p&gt; &#xA;&lt;p&gt;You also need to pay attention to the fact that, when using the saveFromDifferentCodecs method, your files MUST have video and audio streams.&lt;/p&gt; &#xA;&lt;p&gt;In both cases, you will have to provide an array of files.&lt;/p&gt; &#xA;&lt;p&gt;To concatenate videos encoded with the same codec, do as follow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// In order to instantiate the video object, you HAVE TO pass a path to a valid video file.&#xA;// We recommend that you put there the path of any of the video you want to use in this concatenation.&#xA;$video = $ffmpeg-&amp;gt;open( &#39;/path/to/video&#39; );&#xA;$video&#xA;    -&amp;gt;concat(array(&#39;/path/to/video1&#39;, &#39;/path/to/video2&#39;))&#xA;    -&amp;gt;saveFromSameCodecs(&#39;/path/to/new_file&#39;, TRUE);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The boolean parameter of the save function allows you to use the copy parameter which accelerates drastically the generation of the encoded file.&lt;/p&gt; &#xA;&lt;p&gt;To concatenate videos encoded with the different codec, do as follow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// In order to instantiate the video object, you HAVE TO pass a path to a valid video file.&#xA;// We recommend that you put there the path of any of the video you want to use in this concatenation.&#xA;$video = $ffmpeg-&amp;gt;open( &#39;/path/to/video&#39; );&#xA;&#xA;$format = new FFMpeg\Format\Video\X264();&#xA;$format-&amp;gt;setAudioCodec(&#34;libmp3lame&#34;);&#xA;&#xA;$video&#xA;    -&amp;gt;concat(array(&#39;/path/to/video1&#39;, &#39;/path/to/video2&#39;))&#xA;    -&amp;gt;saveFromDifferentCodecs($format, &#39;/path/to/new_file&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More details about concatenation in FFMPEG can be found &lt;a href=&#34;https://trac.ffmpeg.org/wiki/Concatenate&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;https://ffmpeg.org/ffmpeg-formats.html#concat-1&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://ffmpeg.org/ffmpeg.html#Stream-copy&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;AdvancedMedia&lt;/h3&gt; &#xA;&lt;p&gt;AdvancedMedia may have multiple inputs and multiple outputs.&lt;/p&gt; &#xA;&lt;p&gt;This class has been developed primarily to use with &lt;code&gt;-filter_complex&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;So, its &lt;code&gt;filters()&lt;/code&gt; method accepts only filters that can be used inside &lt;code&gt;-filter_complex&lt;/code&gt; command. AdvancedMedia already contains some built-in filters.&lt;/p&gt; &#xA;&lt;h4&gt;Base usage&lt;/h4&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$advancedMedia = $ffmpeg-&amp;gt;openAdvanced(array(&#39;video_1.mp4&#39;, &#39;video_2.mp4&#39;));&#xA;$advancedMedia-&amp;gt;filters()&#xA;    -&amp;gt;custom(&#39;[0:v][1:v]&#39;, &#39;hstack&#39;, &#39;[v]&#39;);&#xA;$advancedMedia&#xA;    -&amp;gt;map(array(&#39;0:a&#39;, &#39;[v]&#39;), new X264(&#39;aac&#39;, &#39;libx264&#39;), &#39;output.mp4&#39;)&#xA;    -&amp;gt;save();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code takes 2 input videos, stacks they horizontally in 1 output video and adds to this new video the audio from the first video. (It is impossible with simple filtergraph that has only 1 input and only 1 output).&lt;/p&gt; &#xA;&lt;h4&gt;Complicated example&lt;/h4&gt; &#xA;&lt;p&gt;A more difficult example of possibilities of the AdvancedMedia. Consider all input videos already have the same resolution and duration. (&#34;xstack&#34; filter has been added in the 4.1 version of the ffmpeg).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$inputs = array(&#xA;    &#39;video_1.mp4&#39;,&#xA;    &#39;video_2.mp4&#39;,&#xA;    &#39;video_3.mp4&#39;,&#xA;    &#39;video_4.mp4&#39;,&#xA;);&#xA;&#xA;$advancedMedia = $ffmpeg-&amp;gt;openAdvanced($inputs);&#xA;$advancedMedia-&amp;gt;filters()&#xA;    -&amp;gt;custom(&#39;[0:v]&#39;, &#39;negate&#39;, &#39;[v0negate]&#39;)&#xA;    -&amp;gt;custom(&#39;[1:v]&#39;, &#39;edgedetect&#39;, &#39;[v1edgedetect]&#39;)&#xA;    -&amp;gt;custom(&#39;[2:v]&#39;, &#39;hflip&#39;, &#39;[v2hflip]&#39;)&#xA;    -&amp;gt;custom(&#39;[3:v]&#39;, &#39;vflip&#39;, &#39;[v3vflip]&#39;)&#xA;    -&amp;gt;xStack(&#39;[v0negate][v1edgedetect][v2hflip][v3vflip]&#39;, XStackFilter::LAYOUT_2X2, 4, &#39;[resultv]&#39;);&#xA;$advancedMedia&#xA;    -&amp;gt;map(array(&#39;0:a&#39;), new Mp3(), &#39;video_1.mp3&#39;)&#xA;    -&amp;gt;map(array(&#39;1:a&#39;), new Flac(), &#39;video_2.flac&#39;)&#xA;    -&amp;gt;map(array(&#39;2:a&#39;), new Wav(), &#39;video_3.wav&#39;)&#xA;    -&amp;gt;map(array(&#39;3:a&#39;), new Aac(), &#39;video_4.aac&#39;)&#xA;    -&amp;gt;map(array(&#39;[resultv]&#39;), new X264(&#39;aac&#39;, &#39;libx264&#39;), &#39;output.mp4&#39;)&#xA;    -&amp;gt;save();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code takes 4 input videos, then the negates the first video, stores result in &lt;code&gt;[v0negate]&lt;/code&gt; stream, detects edges in the second video, stores result in &lt;code&gt;[v1edgedetect]&lt;/code&gt; stream, horizontally flips the third video, stores result in &lt;code&gt;[v2hflip]&lt;/code&gt; stream, vertically flips the fourth video, stores result in &lt;code&gt;[v3vflip]&lt;/code&gt; stream, then takes this 4 generated streams ans combine them in one 2x2 collage video. Then saves audios from the original videos into the 4 different formats and saves the generated collage video into the separate file.&lt;/p&gt; &#xA;&lt;p&gt;As you can see, you can take multiple input sources, perform the complicated processing for them and produce multiple output files in the same time, in the one ffmpeg command.&lt;/p&gt; &#xA;&lt;h4&gt;Just give me a map!&lt;/h4&gt; &#xA;&lt;p&gt;You do not have to use &lt;code&gt;-filter_complex&lt;/code&gt;. You can use only &lt;code&gt;-map&lt;/code&gt; options. For example, just extract the audio from the video:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$advancedMedia = $ffmpeg-&amp;gt;openAdvanced(array(&#39;video.mp4&#39;));&#xA;$advancedMedia&#xA;    -&amp;gt;map(array(&#39;0:a&#39;), new Mp3(), &#39;output.mp3&#39;)&#xA;    -&amp;gt;save();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Customisation&lt;/h4&gt; &#xA;&lt;p&gt;If you need you can extra customize the result ffmpeg command of the AdvancedMedia:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$advancedMedia = $ffmpeg-&amp;gt;openAdvanced($inputs);&#xA;$advancedMedia&#xA;    -&amp;gt;setInitialParameters(array(&#39;the&#39;, &#39;params&#39;, &#39;that&#39;, &#39;will&#39;, &#39;be&#39;, &#39;added&#39;, &#39;before&#39;, &#39;-i&#39;, &#39;part&#39;, &#39;of&#39;, &#39;the&#39;, &#39;command&#39;))&#xA;    -&amp;gt;setAdditionalParameters(array(&#39;the&#39;, &#39;params&#39;, &#39;that&#39;, &#39;will&#39;, &#39;be&#39;, &#39;added&#39;, &#39;at&#39;, &#39;the&#39;, &#39;end&#39;, &#39;of&#39;, &#39;the&#39;, &#39;command&#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Formats&lt;/h4&gt; &#xA;&lt;p&gt;A format implements &lt;code&gt;FFMpeg\Format\FormatInterface&lt;/code&gt;. To save to a video file, use &lt;code&gt;FFMpeg\Format\VideoInterface&lt;/code&gt;, and &lt;code&gt;FFMpeg\Format\AudioInterface&lt;/code&gt; for audio files.&lt;/p&gt; &#xA;&lt;p&gt;A format can also extend &lt;code&gt;FFMpeg\Format\ProgressableInterface&lt;/code&gt; to get realtime information about the transcoding.&lt;/p&gt; &#xA;&lt;p&gt;Predefined formats already provide progress information as events.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$format = new FFMpeg\Format\Video\X264();&#xA;$format-&amp;gt;on(&#39;progress&#39;, function ($video, $format, $percentage) {&#xA;    echo &#34;$percentage % transcoded&#34;;&#xA;});&#xA;&#xA;$video-&amp;gt;save($format, &#39;video.avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The callback provided for the event can be any callable.&lt;/p&gt; &#xA;&lt;h5&gt;Add additional parameters&lt;/h5&gt; &#xA;&lt;p&gt;You can add additional parameters to your encoding requests based on your video format.&lt;/p&gt; &#xA;&lt;p&gt;The argument of the setAdditionalParameters method is an array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$format = new FFMpeg\Format\Video\X264();&#xA;$format-&amp;gt;setAdditionalParameters(array(&#39;foo&#39;, &#39;bar&#39;));&#xA;$video-&amp;gt;save($format, &#39;video.avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Add initial parameters&lt;/h5&gt; &#xA;&lt;p&gt;You can also add initial parameters to your encoding requests based on your video format. This can be expecially handy in overriding a default input codec in FFMpeg.&lt;/p&gt; &#xA;&lt;p&gt;The argument of the setInitialParameters method is an array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$format = new FFMpeg\Format\Video\X264();&#xA;$format-&amp;gt;setInitialParameters(array(&#39;-acodec&#39;, &#39;libopus&#39;));&#xA;$video-&amp;gt;save($format, &#39;video.avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Create your own format&lt;/h5&gt; &#xA;&lt;p&gt;The easiest way to create a format is to extend the abstract &lt;code&gt;FFMpeg\Format\Video\DefaultVideo&lt;/code&gt; and &lt;code&gt;FFMpeg\Format\Audio\DefaultAudio&lt;/code&gt;. and implement the following methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class CustomWMVFormat extends FFMpeg\Format\Video\DefaultVideo&#xA;{&#xA;    public function __construct($audioCodec = &#39;wmav2&#39;, $videoCodec = &#39;wmv2&#39;)&#xA;    {&#xA;        $this&#xA;            -&amp;gt;setAudioCodec($audioCodec)&#xA;            -&amp;gt;setVideoCodec($videoCodec);&#xA;    }&#xA;&#xA;    public function supportBFrames()&#xA;    {&#xA;        return false;&#xA;    }&#xA;&#xA;    public function getAvailableAudioCodecs()&#xA;    {&#xA;        return array(&#39;wmav2&#39;);&#xA;    }&#xA;&#xA;    public function getAvailableVideoCodecs()&#xA;    {&#xA;        return array(&#39;wmv2&#39;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Coordinates&lt;/h4&gt; &#xA;&lt;p&gt;FFMpeg uses many units for time and space coordinates.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Coordinate\AspectRatio&lt;/code&gt; represents an aspect ratio.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Coordinate\Dimension&lt;/code&gt; represent a dimension.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Coordinate\FrameRate&lt;/code&gt; represent a framerate.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Coordinate\Point&lt;/code&gt; represent a point. (Supports dynamic points since v0.10.0)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FFMpeg\Coordinate\TimeCode&lt;/code&gt; represent a timecode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;FFProbe&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FFMpeg\FFProbe&lt;/code&gt; is used internally by &lt;code&gt;FFMpeg\FFMpeg&lt;/code&gt; to probe medias. You can also use it to extract media metadata.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffprobe = FFMpeg\FFProbe::create();&#xA;$ffprobe&#xA;    -&amp;gt;streams(&#39;/path/to/video/mp4&#39;) // extracts streams informations&#xA;    -&amp;gt;videos()                      // filters video streams&#xA;    -&amp;gt;first()                       // returns the first video stream&#xA;    -&amp;gt;get(&#39;codec_name&#39;);            // returns the codec_name property&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffprobe = FFMpeg\FFProbe::create();&#xA;$ffprobe&#xA;    -&amp;gt;format(&#39;/path/to/video/mp4&#39;) // extracts file informations&#xA;    -&amp;gt;get(&#39;duration&#39;);             // returns the duration property&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Validating media files&lt;/h3&gt; &#xA;&lt;p&gt;(since 0.10.0) You can validate media files using PHP-FFMpeg&#39;s FFProbe wrapper.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$ffprobe = FFMpeg\FFProbe::create();&#xA;$ffprobe-&amp;gt;isValid(&#39;/path/to/file/to/check&#39;); // returns bool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Music: &#34;Favorite Secrets&#34; by Waylon Thornton From the Free Music Archive &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-sa/3.0/us/&#34;&gt;CC BY NC SA&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Music: &#34;Siesta&#34; by Jahzzar From the Free Music Archive &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/3.0/&#34;&gt;CC BY SA&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>