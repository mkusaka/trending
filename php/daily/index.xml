<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-20T01:46:14Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cerbero90/json-parser</title>
    <updated>2023-06-20T01:46:14Z</updated>
    <id>tag:github.com,2023-06-20:/cerbero90/json-parser</id>
    <link href="https://github.com/cerbero90/json-parser" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üß© Zero-dependencies pull parser to read large JSON from any source in a memory-efficient way.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;üß© JSON Parser&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitter.com/cerbero90&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=author&amp;amp;message=cerbero90&amp;amp;color=50ABF1&amp;amp;logo=twitter&amp;amp;style=flat-square&#34; alt=&#34;Author&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.php.net&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/php-v/cerbero/json-parser?color=%234F5B93&amp;amp;logo=php&amp;amp;style=flat-square&#34; alt=&#34;PHP Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/cerbero90/json-parser/actions?query=workflow%3Abuild&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/cerbero90/json-parser/build.yml?branch=master&amp;amp;style=flat-square&amp;amp;logo=github&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://scrutinizer-ci.com/g/cerbero90/json-parser/code-structure&#34;&gt;&lt;img src=&#34;https://img.shields.io/scrutinizer/coverage/g/cerbero90/json-parser.svg?style=flat-square&amp;amp;logo=scrutinizer&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://scrutinizer-ci.com/g/cerbero90/json-parser&#34;&gt;&lt;img src=&#34;https://img.shields.io/scrutinizer/g/cerbero90/json-parser.svg?style=flat-square&amp;amp;logo=scrutinizer&#34; alt=&#34;Quality Score&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://phpstan.org/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/level-max-success?style=flat-square&amp;amp;logo=data:image/png;base64,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&#34; alt=&#34;PHPStan Level&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/cerbero/json-parser&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/cerbero/json-parser.svg?label=version&amp;amp;style=flat-square&#34; alt=&#34;Latest Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/LICENSE.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square&#34; alt=&#34;Software License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.php-fig.org/psr/psr-7/&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=compliance&amp;amp;message=PSR-7&amp;amp;color=blue&amp;amp;style=flat-square&#34; alt=&#34;PSR-7&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.php-fig.org/psr/psr-12/&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=compliance&amp;amp;message=PSR-12&amp;amp;color=blue&amp;amp;style=flat-square&#34; alt=&#34;PSR-12&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/cerbero/json-parser&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dt/cerbero/json-parser.svg?style=flat-square&#34; alt=&#34;Total Downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Zero-dependencies pull parser to read large JSON from any source in a memory-efficient way.&lt;/p&gt; &#xA;&lt;h2&gt;üì¶ Install&lt;/h2&gt; &#xA;&lt;p&gt;Via Composer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer require cerbero/json-parser&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üîÆ Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-basics&#34;&gt;üë£ Basics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-sources&#34;&gt;üíß Sources&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-pointers&#34;&gt;üéØ Pointers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-lazy-pointers&#34;&gt;üêº Lazy pointers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#%EF%B8%8F-decoders&#34;&gt;‚öôÔ∏è Decoders&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-errors-handling&#34;&gt;üí¢ Errors handling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-progress&#34;&gt;‚è≥ Progress&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-settings&#34;&gt;üõ† Settings&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;üë£ Basics&lt;/h3&gt; &#xA;&lt;p&gt;JSON Parser provides a minimal API to read large JSON from any source:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// a source is anything that can provide a JSON, in this case an endpoint&#xA;$source = &#39;https://randomuser.me/api/1.4?seed=json-parser&amp;amp;results=5&#39;;&#xA;&#xA;foreach (new JsonParser($source) as $key =&amp;gt; $value) {&#xA;    // instead of loading the whole JSON, we keep in memory only one key and value at a time&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Depending on our code style, we can instantiate the parser in 3 different ways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\JsonParser;&#xA;use function Cerbero\JsonParser\parseJson;&#xA;&#xA;&#xA;// classic object instantiation&#xA;new JsonParser($source);&#xA;&#xA;// static instantiation&#xA;JsonParser::parse($source);&#xA;&#xA;// namespaced function&#xA;parseJson($source);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we don&#39;t want to use &lt;code&gt;foreach()&lt;/code&gt; to loop through each key and value, we can chain the &lt;code&gt;traverse()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;JsonParser::parse($source)-&amp;gt;traverse(function (mixed $value, string|int $key, JsonParser $parser) {&#xA;    // lazily load one key and value at a time, we can also access the parser if needed&#xA;});&#xA;&#xA;// no foreach needed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è Please note the parameters order of the callback: the value is passed before the key.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;üíß Sources&lt;/h3&gt; &#xA;&lt;p&gt;A JSON source is any data point that provides a JSON. A wide range of sources are supported by default:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;strings&lt;/strong&gt;, e.g. &lt;code&gt;{&#34;foo&#34;:&#34;bar&#34;}&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;iterables&lt;/strong&gt;, i.e. arrays or instances of &lt;code&gt;Traversable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;file paths&lt;/strong&gt;, e.g. &lt;code&gt;/path/to/large.json&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;resources&lt;/strong&gt;, e.g. streams&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;API endpoint URLs&lt;/strong&gt;, e.g. &lt;code&gt;https://endpoint.json&lt;/code&gt; or any instance of &lt;code&gt;Psr\Http\Message\UriInterface&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;PSR-7 requests&lt;/strong&gt;, i.e. any instance of &lt;code&gt;Psr\Http\Message\RequestInterface&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;PSR-7 messages&lt;/strong&gt;, i.e. any instance of &lt;code&gt;Psr\Http\Message\MessageInterface&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;PSR-7 streams&lt;/strong&gt;, i.e. any instance of &lt;code&gt;Psr\Http\Message\StreamInterface&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Laravel HTTP client requests&lt;/strong&gt;, i.e. any instance of &lt;code&gt;Illuminate\Http\Client\Request&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Laravel HTTP client responses&lt;/strong&gt;, i.e. any instance of &lt;code&gt;Illuminate\Http\Client\Response&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;user-defined sources&lt;/strong&gt;, i.e. any instance of &lt;code&gt;Cerbero\JsonParser\Sources\Source&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the source we need to parse is not supported by default, we can implement our own custom source.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;b&gt;Click here to see how to implement a custom source.&lt;/b&gt;&lt;/summary&gt; &#xA; &lt;p&gt;To implement a custom source, we need to extend &lt;code&gt;Source&lt;/code&gt; and implement 3 methods:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\Sources\Source;&#xA;use Traversable;&#xA;&#xA;class CustomSource extends Source&#xA;{&#xA;    public function getIterator(): Traversable&#xA;    {&#xA;        // return a Traversable holding the JSON source, e.g. a Generator yielding chunks of JSON&#xA;    }&#xA;&#xA;    public function matches(): bool&#xA;    {&#xA;        // return TRUE if this class can handle the JSON source&#xA;    }&#xA;&#xA;    protected function calculateSize(): ?int&#xA;    {&#xA;        // return the size of the JSON in bytes or NULL if it can&#39;t be calculated&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The parent class &lt;code&gt;Source&lt;/code&gt; gives us access to 2 properties:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;$source&lt;/code&gt;: the JSON source we pass to the parser, i.e.: &lt;code&gt;new JsonParser($source)&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;$config&lt;/code&gt;: the configuration we set by chaining methods like &lt;code&gt;$parser-&amp;gt;pointer(&#39;/foo&#39;)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;The method &lt;code&gt;getIterator()&lt;/code&gt; defines the logic to read the JSON source in a memory-efficient way. It feeds the parser with small pieces of JSON. Please refer to the &lt;a href=&#34;https://github.com/cerbero90/json-parser/tree/master/src/Sources&#34;&gt;already existing sources&lt;/a&gt; to see some implementations.&lt;/p&gt; &#xA; &lt;p&gt;The method &lt;code&gt;matches()&lt;/code&gt; determines whether the JSON source passed to the parser can be handled by our custom implementation. In other words, we are telling the parser if it should use our class for the JSON to parse.&lt;/p&gt; &#xA; &lt;p&gt;Finally, &lt;code&gt;calculateSize()&lt;/code&gt; computes the whole size of the JSON source. It&#39;s used to track the &lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-progress&#34;&gt;parsing progress&lt;/a&gt;, however it&#39;s not always possible to know the size of a JSON source. In this case, or if we don&#39;t need to track the progress, we can return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;Now that we have implemented our custom source, we can pass it to the parser:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse(new CustomSource($source));&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // process one key and value of $source at a time&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you find yourself implementing the same custom source in different projects, feel free to send a PR and we will consider to support your custom source by default. Thank you in advance for any contribution!&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;üéØ Pointers&lt;/h3&gt; &#xA;&lt;p&gt;A JSON pointer is a &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc6901&#34;&gt;standard&lt;/a&gt; used to point to nodes within a JSON. This package leverages JSON pointers to extract only some sub-trees from large JSONs.&lt;/p&gt; &#xA;&lt;p&gt;Consider &lt;a href=&#34;https://randomuser.me/api/1.4?seed=json-parser&amp;amp;results=5&#34;&gt;this JSON&lt;/a&gt; for example. To extract only the first gender and avoid parsing the rest of the JSON, we can set the &lt;code&gt;/results/0/gender&lt;/code&gt; pointer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;pointer(&#39;/results/0/gender&#39;);&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st and only iteration: $key === &#39;gender&#39;, $value === &#39;female&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JSON Parser takes advantage of the &lt;code&gt;-&lt;/code&gt; wildcard to point to any array index, so we can extract all the genders with the &lt;code&gt;/results/-/gender&lt;/code&gt; pointer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;pointer(&#39;/results/-/gender&#39;);&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;gender&#39;, $value === &#39;female&#39;&#xA;    // 2nd iteration: $key === &#39;gender&#39;, $value === &#39;female&#39;&#xA;    // 3rd iteration: $key === &#39;gender&#39;, $value === &#39;male&#39;&#xA;    // and so on for all the objects in the array...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to extract more sub-trees, we can set multiple pointers. Let&#39;s extract all genders and countries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;pointers([&#39;/results/-/gender&#39;, &#39;/results/-/location/country&#39;]);&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;gender&#39;, $value === &#39;female&#39;&#xA;    // 2nd iteration: $key === &#39;country&#39;, $value === &#39;Germany&#39;&#xA;    // 3rd iteration: $key === &#39;gender&#39;, $value === &#39;female&#39;&#xA;    // 4th iteration: $key === &#39;country&#39;, $value === &#39;Mexico&#39;&#xA;    // and so on for all the objects in the array...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è Intersecting pointers like &lt;code&gt;/foo&lt;/code&gt; and &lt;code&gt;/foo/bar&lt;/code&gt; is not allowed but intersecting wildcards like &lt;code&gt;foo/-/bar&lt;/code&gt; and &lt;code&gt;foo/0/bar&lt;/code&gt; is possible.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can also specify a callback to execute when JSON pointers are found. This is handy when we have different pointers and we need to run custom logic for each of them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;pointers([&#xA;    &#39;/results/-/gender&#39; =&amp;gt; fn (string $gender, string $key) =&amp;gt; new Gender($gender),&#xA;    &#39;/results/-/location/country&#39; =&amp;gt; fn (string $country, string $key) =&amp;gt; new Country($country),&#xA;]);&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;gender&#39;, $value instanceof Gender&#xA;    // 2nd iteration: $key === &#39;country&#39;, $value instanceof Country&#xA;    // and so on for all the objects in the array...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è Please note the parameters order of the callbacks: the value is passed before the key.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The same can also be achieved by chaining the method &lt;code&gt;pointer()&lt;/code&gt; multiple times:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)&#xA;    -&amp;gt;pointer(&#39;/results/-/gender&#39;, fn (string $gender, string $key) =&amp;gt; new Gender($gender))&#xA;    -&amp;gt;pointer(&#39;/results/-/location/country&#39;, fn (string $country, string $key) =&amp;gt; new Country($country));&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;gender&#39;, $value instanceof Gender&#xA;    // 2nd iteration: $key === &#39;country&#39;, $value instanceof Country&#xA;    // and so on for all the objects in the array...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pointer callbacks can also be used to customize a key. We can achieve that by updating the key &lt;strong&gt;reference&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;pointer(&#39;/results/-/name/first&#39;, function (string $name, string &amp;amp;$key) {&#xA;    $key = &#39;first_name&#39;;&#xA;});&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;first_name&#39;, $value === &#39;Sara&#39;&#xA;    // 2nd iteration: $key === &#39;first_name&#39;, $value === &#39;Andrea&#39;&#xA;    // and so on for all the objects in the array...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the callbacks are enough to handle the pointers and we don&#39;t need to run any common logic for all pointers, we can avoid to manually call &lt;code&gt;foreach()&lt;/code&gt; by chaining the method &lt;code&gt;traverse()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;JsonParser::parse($source)&#xA;    -&amp;gt;pointer(&#39;/-/gender&#39;, $this-&amp;gt;handleGender(...))&#xA;    -&amp;gt;pointer(&#39;/-/location/country&#39;, $this-&amp;gt;handleCountry(...))&#xA;    -&amp;gt;traverse();&#xA;&#xA;// no foreach needed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise if some common logic for all pointers is needed but we prefer methods chaining to manual loops, we can pass a callback to the &lt;code&gt;traverse()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;JsonParser::parse($source)&#xA;    -&amp;gt;pointer(&#39;/results/-/gender&#39;, fn (string $gender, string $key) =&amp;gt; new Gender($gender))&#xA;    -&amp;gt;pointer(&#39;/results/-/location/country&#39;, fn (string $country, string $key) =&amp;gt; new Country($country))&#xA;    -&amp;gt;traverse(function (Gender|Country $value, string $key, JsonParser $parser) {&#xA;        // 1st iteration: $key === &#39;gender&#39;, $value instanceof Gender&#xA;        // 2nd iteration: $key === &#39;country&#39;, $value instanceof Country&#xA;        // and so on for all the objects in the array...&#xA;    });&#xA;&#xA;// no foreach needed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è Please note the parameters order of the callbacks: the value is passed before the key.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Sometimes the sub-trees extracted by pointers are small enough to be kept entirely in memory. In such cases, we can chain &lt;code&gt;toArray()&lt;/code&gt; to eager load the extracted sub-trees into an array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// [&#39;gender&#39; =&amp;gt; &#39;female&#39;, &#39;country&#39; =&amp;gt; &#39;Germany&#39;]&#xA;$array = JsonParser::parse($source)-&amp;gt;pointers([&#39;/results/0/gender&#39;, &#39;/results/0/location/country&#39;])-&amp;gt;toArray();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üêº Lazy pointers&lt;/h3&gt; &#xA;&lt;p&gt;JSON Parser only keeps one key and one value in memory at a time. However, if the value is a large array or object, it may be inefficient to keep it all in memory.&lt;/p&gt; &#xA;&lt;p&gt;To solve this problem, we can use lazy pointers. These pointers recursively keep in memory only one key and one value at a time for any nested array or object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;lazyPointer(&#39;/results/0/name&#39;);&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;name&#39;, $value instanceof Parser&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lazy pointers return a lightweight instance of &lt;code&gt;Cerbero\JsonParser\Tokens\Parser&lt;/code&gt; instead of the actual large value. To lazy load nested keys and values, we can then loop through the parser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;lazyPointer(&#39;/results/0/name&#39;);&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;name&#39;, $value instanceof Parser&#xA;    foreach ($value as $nestedKey =&amp;gt; $nestedValue) {&#xA;        // 1st iteration: $nestedKey === &#39;title&#39;, $nestedValue === &#39;Mrs&#39;&#xA;        // 2nd iteration: $nestedKey === &#39;first&#39;, $nestedValue === &#39;Sara&#39;&#xA;        // 3rd iteration: $nestedKey === &#39;last&#39;, $nestedValue === &#39;Meder&#39;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As mentioned above, lazy pointers are recursive. This means that no nested objects or arrays will ever be kept in memory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;lazyPointer(&#39;/results/0/location&#39;);&#xA;&#xA;foreach ($json as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;location&#39;, $value instanceof Parser&#xA;    foreach ($value as $nestedKey =&amp;gt; $nestedValue) {&#xA;        // 1st iteration: $nestedKey === &#39;street&#39;, $nestedValue instanceof Parser&#xA;        // 2nd iteration: $nestedKey === &#39;city&#39;, $nestedValue === &#39;Sontra&#39;&#xA;        // ...&#xA;        // 6th iteration: $nestedKey === &#39;coordinates&#39;, $nestedValue instanceof Parser&#xA;        // 7th iteration: $nestedKey === &#39;timezone&#39;, $nestedValue instanceof Parser&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To lazily parse the entire JSON, we can simply chain the &lt;code&gt;lazy()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;foreach (JsonParser::parse($source)-&amp;gt;lazy() as $key =&amp;gt; $value) {&#xA;    // 1st iteration: $key === &#39;results&#39;, $value instanceof Parser&#xA;    // 2nd iteration: $key === &#39;info&#39;, $value instanceof Parser&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lazy pointers also have all the other functionalities of normal pointers: they accept callbacks, can be set one by one or all together, can be eager loaded into an array and can be mixed with normal pointers as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// set custom callback to run only when names are found&#xA;$json = JsonParser::parse($source)-&amp;gt;lazyPointer(&#39;/results/-/name&#39;, fn (Parser $name) =&amp;gt; $this-&amp;gt;handleName($name));&#xA;&#xA;// set multiple lazy pointers one by one&#xA;$json = JsonParser::parse($source)&#xA;    -&amp;gt;lazyPointer(&#39;/results/-/name&#39;, fn (Parser $name) =&amp;gt; $this-&amp;gt;handleName($name))&#xA;    -&amp;gt;lazyPointer(&#39;/results/-/location&#39;, fn (Parser $location) =&amp;gt; $this-&amp;gt;handleLocation($location));&#xA;&#xA;// set multiple lazy pointers all together&#xA;$json = JsonParser::parse($source)-&amp;gt;lazyPointers([&#xA;    &#39;/results/-/name&#39; =&amp;gt; fn (Parser $name) =&amp;gt; $this-&amp;gt;handleName($name)),&#xA;    &#39;/results/-/location&#39; =&amp;gt; fn (Parser $location) =&amp;gt; $this-&amp;gt;handleLocation($location)),&#xA;]);&#xA;&#xA;// eager load lazy pointers into an array&#xA;// [&#39;name&#39; =&amp;gt; [&#39;title&#39; =&amp;gt; &#39;Mrs&#39;, &#39;first&#39; =&amp;gt; &#39;Sara&#39;, &#39;last&#39; =&amp;gt; &#39;Meder&#39;], &#39;street&#39; =&amp;gt; [&#39;number&#39; =&amp;gt; 46, &#39;name&#39; =&amp;gt; &#39;R√∂merstra√üe&#39;]]&#xA;$array = JsonParser::parse($source)-&amp;gt;lazyPointers([&#39;/results/0/name&#39;, &#39;/results/0/location/street&#39;])-&amp;gt;toArray();&#xA;&#xA;// mix pointers and lazy pointers&#xA;$json = JsonParser::parse($source)&#xA;    -&amp;gt;pointer(&#39;/results/-/gender&#39;, fn (string $gender) =&amp;gt; $this-&amp;gt;handleGender($gender))&#xA;    -&amp;gt;lazyPointer(&#39;/results/-/name&#39;, fn (Parser $name) =&amp;gt; $this-&amp;gt;handleName($name));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;‚öôÔ∏è Decoders&lt;/h3&gt; &#xA;&lt;p&gt;By default JSON Parser uses the built-in PHP function &lt;code&gt;json_decode()&lt;/code&gt; to decode one key and value at a time.&lt;/p&gt; &#xA;&lt;p&gt;Normally it decodes values to associative arrays but, if we prefer to decode values to objects, we can set a custom decoder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\Decoders\JsonDecoder;&#xA;&#xA;JsonParser::parse($source)-&amp;gt;decoder(new JsonDecoder(decodesToArray: false));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/crazyxman/simdjson_php#simdjson_php&#34;&gt;simdjson extension&lt;/a&gt; offers a decoder &lt;a href=&#34;https://github.com/crazyxman/simdjson_php/tree/master/benchmark#run-phpbench-benchmark&#34;&gt;faster&lt;/a&gt; than &lt;code&gt;json_decode()&lt;/code&gt; that can be installed via &lt;code&gt;pecl install simdjson&lt;/code&gt; if your server satisfies the &lt;a href=&#34;https://github.com/crazyxman/simdjson_php#requirement&#34;&gt;requirements&lt;/a&gt;. JSON Parser leverages the simdjson decoder by default if the extension is loaded.&lt;/p&gt; &#xA;&lt;p&gt;If we need a decoder that is not supported by default, we can implement our custom one.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;b&gt;Click here to see how to implement a custom decoder.&lt;/b&gt;&lt;/summary&gt; &#xA; &lt;p&gt;To create a custom decoder, we need to implement the &lt;code&gt;Decoder&lt;/code&gt; interface and implement 1 method:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\Decoders\Decoder;&#xA;use Cerbero\JsonParser\Decoders\DecodedValue;&#xA;&#xA;class CustomDecoder implements Decoder&#xA;{&#xA;    public function decode(string $json): DecodedValue&#xA;    {&#xA;        // return an instance of DecodedValue both in case of success or failure&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The method &lt;code&gt;decode()&lt;/code&gt; defines the logic to decode the given JSON value and it needs to return an instance of &lt;code&gt;DecodedValue&lt;/code&gt; both in case of success or failure.&lt;/p&gt; &#xA; &lt;p&gt;To make custom decoder implementations even easier, JSON Parser provides an &lt;a href=&#34;https://github.com/cerbero90/json-parser/tree/master/src/Decoders/AbstractDecoder.php&#34;&gt;abstract decoder&lt;/a&gt; that hydrates &lt;code&gt;DecodedValue&lt;/code&gt; for us so that we just need to define how a JSON value should be decoded:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\Decoders\AbstractDecoder;&#xA;&#xA;class CustomDecoder extends AbstractDecoder&#xA;{&#xA;    protected function decodeJson(string $json): mixed&#xA;    {&#xA;        // decode the given JSON or throw an exception on failure&#xA;        return json_decode($json, flags: JSON_THROW_ON_ERROR);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;‚ö†Ô∏è Please make sure to throw an exception in &lt;code&gt;decodeJson()&lt;/code&gt; if the decoding process fails.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;Now that we have implemented our custom decoder, we can set it like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;JsonParser::parse($source)-&amp;gt;decoder(new CustomDecoder());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To see some implementation examples, please refer to the &lt;a href=&#34;https://github.com/cerbero90/json-parser/tree/master/src/Decoders&#34;&gt;already existing decoders&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;If you find yourself implementing the same custom decoder in different projects, feel free to send a PR and we will consider to support your custom decoder by default. Thank you in advance for any contribution!&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;üí¢ Errors handling&lt;/h3&gt; &#xA;&lt;p&gt;Not all JSONs are valid, some may present syntax errors due to an incorrect structure (e.g. &lt;code&gt;[}&lt;/code&gt;) or decoding errors when values can&#39;t be decoded properly (e.g. &lt;code&gt;[1a]&lt;/code&gt;). JSON Parser allows us to intervene and define the logic to run when these issues occur:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\Decoders\DecodedValue;&#xA;use Cerbero\JsonParser\Exceptions\SyntaxException;&#xA;&#xA;$json = JsonParser::parse($source)&#xA;    -&amp;gt;onSyntaxError(fn (SyntaxException $e) =&amp;gt; $this-&amp;gt;handleSyntaxError($e))&#xA;    -&amp;gt;onDecodingError(fn (DecodedValue $decoded) =&amp;gt; $this-&amp;gt;handleDecodingError($decoded));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can even replace invalid values with placeholders to avoid that the entire JSON parsing fails because of them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// instead of failing, replace invalid values with NULL&#xA;$json = JsonParser::parse($source)-&amp;gt;patchDecodingError();&#xA;&#xA;// instead of failing, replace invalid values with &#39;&amp;lt;invalid&amp;gt;&#39;&#xA;$json = JsonParser::parse($source)-&amp;gt;patchDecodingError(&#39;&amp;lt;invalid&amp;gt;&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced decoding errors patching, we can pass a closure that has access to the &lt;code&gt;DecodedValue&lt;/code&gt; instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\Decoders\DecodedValue;&#xA;&#xA;$patches = [&#39;1a&#39; =&amp;gt; 1, &#39;2b&#39; =&amp;gt; 2];&#xA;$json = JsonParser::parse($source)&#xA;    -&amp;gt;patchDecodingError(fn (DecodedValue $decoded) =&amp;gt; $patches[$decoded-&amp;gt;json] ?? null);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any exception thrown by this package implements the &lt;code&gt;JsonParserException&lt;/code&gt; interface. This makes it easy to handle all exceptions in a single catch block:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Cerbero\JsonParser\Exceptions\JsonParserException;&#xA;&#xA;try {&#xA;    JsonParser::parse($source)-&amp;gt;traverse();&#xA;} catch (JsonParserException) {&#xA;    // handle any exception thrown by JSON Parser&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For reference, here is a comprehensive table of all the exceptions thrown by this package:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;Cerbero\JsonParser\Exceptions\&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;thrown when&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DecodingException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a value in the JSON can&#39;t be decoded&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;GuzzleRequiredException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Guzzle is not installed and the JSON source is an endpoint&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;IntersectingPointersException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;two JSON pointers intersect&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;InvalidPointerException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a JSON pointer syntax is not valid&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SyntaxException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;the JSON structure is not valid&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UnsupportedSourceException&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a JSON source is not supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;‚è≥ Progress&lt;/h3&gt; &#xA;&lt;p&gt;When processing large JSONs, it can be helpful to track the parsing progress. JSON Parser provides convenient methods for accessing all the progress details:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = new JsonParser($source);&#xA;&#xA;$json-&amp;gt;progress(); // &amp;lt;Cerbero\JsonParser\ValueObjects\Progress&amp;gt;&#xA;$json-&amp;gt;progress()-&amp;gt;current(); // the already parsed bytes e.g. 86759341&#xA;$json-&amp;gt;progress()-&amp;gt;total(); // the total bytes to parse e.g. 182332642&#xA;$json-&amp;gt;progress()-&amp;gt;fraction(); // the completed fraction e.g. 0.47583&#xA;$json-&amp;gt;progress()-&amp;gt;percentage(); // the completed percentage e.g. 47.583&#xA;$json-&amp;gt;progress()-&amp;gt;format(); // the formatted progress e.g. 47.5%&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The total size of a JSON is calculated differently depending on the &lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/#-sources&#34;&gt;source&lt;/a&gt;. In some cases, it may not be possible to determine the size of a JSON and only the current progress is known:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json-&amp;gt;progress()-&amp;gt;current(); // 86759341&#xA;$json-&amp;gt;progress()-&amp;gt;total(); // null&#xA;$json-&amp;gt;progress()-&amp;gt;fraction(); // null&#xA;$json-&amp;gt;progress()-&amp;gt;percentage(); // null&#xA;$json-&amp;gt;progress()-&amp;gt;format(); // null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üõ† Settings&lt;/h3&gt; &#xA;&lt;p&gt;JSON Parser also provides other settings to fine-tune the parsing process. For example we can set the number of bytes to read when parsing JSON strings or streams:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$json = JsonParser::parse($source)-&amp;gt;bytes(1024 * 16); // read JSON chunks of 16KB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üìÜ Change log&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; for more information on what has changed recently.&lt;/p&gt; &#xA;&lt;h2&gt;üß™ Testing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üíû Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/CODE_OF_CONDUCT.md&#34;&gt;CODE_OF_CONDUCT&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;üßØ Security&lt;/h2&gt; &#xA;&lt;p&gt;If you discover any security related issues, please email &lt;a href=&#34;mailto:andrea.marco.sartori@gmail.com&#34;&gt;andrea.marco.sartori@gmail.com&lt;/a&gt; instead of using the issue tracker.&lt;/p&gt; &#xA;&lt;h2&gt;üèÖ Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/cerbero90&#34;&gt;Andrea Marco Sartori&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/contributors&#34;&gt;All Contributors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;‚öñÔ∏è License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT). Please see &lt;a href=&#34;https://raw.githubusercontent.com/cerbero90/json-parser/develop/LICENSE.md&#34;&gt;License File&lt;/a&gt; for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dingo/api</title>
    <updated>2023-06-20T01:46:14Z</updated>
    <id>tag:github.com,2023-06-20:/dingo/api</id>
    <link href="https://github.com/dingo/api" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A RESTful API package for the Laravel and Lumen frameworks.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Move repositories notice&lt;/h1&gt; &#xA;&lt;p&gt;Unfortunately this package cannot be maintained at this location anymore due to broken CI integrations, and travis-ci likely can&#39;t be used much longer either due to their change to paid plans. This project is still being actively maintained, we ask you to please switch to the following repository: &lt;a href=&#34;https://github.com/api-ecosystem-for-laravel/dingo-api&#34;&gt;https://github.com/api-ecosystem-for-laravel/dingo-api&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/829059/9216039/82be51cc-40f6-11e5-88f5-f0cbd07bcc39.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Dingo API package is meant to provide you, the developer, with a set of tools to help you easily and quickly build your own API. While the goal of this package is to remain as flexible as possible it still won&#39;t cover all situations and solve all problems.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/dingo/api&#34;&gt;&lt;img src=&#34;https://img.shields.io/travis/dingo/api/master.svg?style=flat-square&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/dingo/api/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/l/dingo/api.svg?style=flat-square&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/dingo/api&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/vpre/dingo/api.svg?style=flat-square&#34; alt=&#34;Development Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/dingo/api&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dm/dingo/api.svg?style=flat-square&#34; alt=&#34;Monthly Installs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://styleci.io/repos/18673522&#34;&gt;&lt;img src=&#34;https://styleci.io/repos/18673522/shield&#34; alt=&#34;StyleCI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;This package provides tools for the following, and more:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Content Negotiation&lt;/li&gt; &#xA; &lt;li&gt;Multiple Authentication Adapters&lt;/li&gt; &#xA; &lt;li&gt;API Versioning&lt;/li&gt; &#xA; &lt;li&gt;Rate Limiting&lt;/li&gt; &#xA; &lt;li&gt;Response Transformers and Formatters&lt;/li&gt; &#xA; &lt;li&gt;Error and Exception Handling&lt;/li&gt; &#xA; &lt;li&gt;Internal Requests&lt;/li&gt; &#xA; &lt;li&gt;API Blueprint Documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to our extensive &lt;a href=&#34;https://github.com/dingo/api/wiki&#34;&gt;Wiki documentation&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;API Boilerplate&lt;/h2&gt; &#xA;&lt;p&gt;If you are looking to start a new project from scratch, consider using the &lt;a href=&#34;https://github.com/specialtactics/laravel-api-boilerplate&#34;&gt;Laravel API Boilerplate&lt;/a&gt;, which builds on top of the dingo-api package, and adds a lot of great features.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;For answers you may not find in the Wiki, avoid posting issues. Feel free to ask for support on the dedicated &lt;a href=&#34;https://larachat.slack.com/messages/api/&#34;&gt;Slack&lt;/a&gt; room. Make sure to mention &lt;strong&gt;specialtactics&lt;/strong&gt; so he is notified.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This package is licensed under the &lt;a href=&#34;http://opensource.org/licenses/BSD-3-Clause&#34;&gt;BSD 3-Clause license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>