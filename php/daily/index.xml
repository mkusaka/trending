<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-09T01:36:35Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>doctrine/deprecations</title>
    <updated>2022-12-09T01:36:35Z</updated>
    <id>tag:github.com,2022-12-09:/doctrine/deprecations</id>
    <link href="https://github.com/doctrine/deprecations" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Thin library around different deprecation strategies&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Doctrine Deprecations&lt;/h1&gt; &#xA;&lt;p&gt;A small (side-effect free by default) layer on top of &lt;code&gt;trigger_error(E_USER_DEPRECATED)&lt;/code&gt; or PSR-3 logging.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;no side-effects by default, making it a perfect fit for libraries that don&#39;t know how the error handler works they operate under&lt;/li&gt; &#xA; &lt;li&gt;options to avoid having to rely on error handlers global state by using PSR-3 logging&lt;/li&gt; &#xA; &lt;li&gt;deduplicate deprecation messages to avoid excessive triggering and reduce overhead&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We recommend to collect Deprecations using a PSR logger instead of relying on the global error handler.&lt;/p&gt; &#xA;&lt;h2&gt;Usage from consumer perspective:&lt;/h2&gt; &#xA;&lt;p&gt;Enable Doctrine deprecations to be sent to a PSR3 logger:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::enableWithPsrLogger($logger);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable Doctrine deprecations to be sent as &lt;code&gt;@trigger_error($message, E_USER_DEPRECATED)&lt;/code&gt; messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::enableWithTriggerError();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you only want to enable deprecation tracking, without logging or calling &lt;code&gt;trigger_error&lt;/code&gt; then call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::enableTrackingDeprecations();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tracking is enabled with all three modes and provides access to all triggered deprecations and their individual count:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$deprecations = \Doctrine\Deprecations\Deprecation::getTriggeredDeprecations();&#xA;&#xA;foreach ($deprecations as $identifier =&amp;gt; $count) {&#xA;    echo $identifier . &#34; was triggered &#34; . $count . &#34; times\n&#34;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Suppressing Specific Deprecations&lt;/h3&gt; &#xA;&lt;p&gt;Disable triggering about specific deprecations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::ignoreDeprecations(&#34;https://link/to/deprecations-description-identifier&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Disable all deprecations from a package&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::ignorePackage(&#34;doctrine/orm&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Other Operations&lt;/h3&gt; &#xA;&lt;p&gt;When used within PHPUnit or other tools that could collect multiple instances of the same deprecations the deduplication can be disabled:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::withoutDeduplication();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Disable deprecation tracking again:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::disable();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage from a library/producer perspective:&lt;/h2&gt; &#xA;&lt;p&gt;When you want to unconditionally trigger a deprecation even when called from the library itself then the &lt;code&gt;trigger&lt;/code&gt; method is the way to go:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::trigger(&#xA;    &#34;doctrine/orm&#34;,&#xA;    &#34;https://link/to/deprecations-description&#34;,&#xA;    &#34;message&#34;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If variable arguments are provided at the end, they are used with &lt;code&gt;sprintf&lt;/code&gt; on the message.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::trigger(&#xA;    &#34;doctrine/orm&#34;,&#xA;    &#34;https://github.com/doctrine/orm/issue/1234&#34;,&#xA;    &#34;message %s %d&#34;,&#xA;    &#34;foo&#34;,&#xA;    1234&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you want to trigger a deprecation only when it is called by a function outside of the current package, but not trigger when the package itself is the cause, then use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;\Doctrine\Deprecations\Deprecation::triggerIfCalledFromOutside(&#xA;    &#34;doctrine/orm&#34;,&#xA;    &#34;https://link/to/deprecations-description&#34;,&#xA;    &#34;message&#34;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Based on the issue link each deprecation message is only triggered once per request.&lt;/p&gt; &#xA;&lt;p&gt;A limited stacktrace is included in the deprecation message to find the offending location.&lt;/p&gt; &#xA;&lt;p&gt;Note: A producer/library should never call &lt;code&gt;Deprecation::enableWith&lt;/code&gt; methods and leave the decision how to handle deprecations to application and frameworks.&lt;/p&gt; &#xA;&lt;h2&gt;Usage in PHPUnit tests&lt;/h2&gt; &#xA;&lt;p&gt;There is a &lt;code&gt;VerifyDeprecations&lt;/code&gt; trait that you can use to make assertions on the occurrence of deprecations within a test.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Doctrine\Deprecations\PHPUnit\VerifyDeprecations;&#xA;&#xA;class MyTest extends TestCase&#xA;{&#xA;    use VerifyDeprecations;&#xA;&#xA;    public function testSomethingDeprecation()&#xA;    {&#xA;        $this-&amp;gt;expectDeprecationWithIdentifier(&#39;https://github.com/doctrine/orm/issue/1234&#39;);&#xA;&#xA;        triggerTheCodeWithDeprecation();&#xA;    }&#xA;&#xA;    public function testSomethingDeprecationFixed()&#xA;    {&#xA;        $this-&amp;gt;expectNoDeprecationWithIdentifier(&#39;https://github.com/doctrine/orm/issue/1234&#39;);&#xA;&#xA;        triggerTheCodeWithoutDeprecation();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is a deprecation identifier?&lt;/h2&gt; &#xA;&lt;p&gt;An identifier for deprecations is just a link to any resource, most often a Github Issue or Pull Request explaining the deprecation and potentially its alternative.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>paratestphp/paratest</title>
    <updated>2022-12-09T01:36:35Z</updated>
    <id>tag:github.com,2022-12-09:/paratestphp/paratest</id>
    <link href="https://github.com/paratestphp/paratest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ’» Parallel testing for PHPUnit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ParaTest&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/brianium/paratest&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/brianium/paratest.svg?sanitize=true&#34; alt=&#34;Latest Stable Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/brianium/paratest&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dt/brianium/paratest.svg?sanitize=true&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/paratestphp/paratest/actions&#34;&gt;&lt;img src=&#34;https://github.com/paratestphp/paratest/workflows/Integrate/badge.svg?branch=6.x&#34; alt=&#34;Integrate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/paratestphp/paratest?branch=6.x&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/paratestphp/paratest/coverage.svg?branch=6.x&#34; alt=&#34;Code Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://shepherd.dev/github/paratestphp/paratest&#34;&gt;&lt;img src=&#34;https://shepherd.dev/github/paratestphp/paratest/coverage.svg?sanitize=true&#34; alt=&#34;Type Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dashboard.stryker-mutator.io/reports/github.com/paratestphp/paratest/6.x&#34;&gt;&lt;img src=&#34;https://badge.stryker-mutator.io/github.com/paratestphp/paratest/6.x&#34; alt=&#34;Infection MSI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The objective of ParaTest is to support parallel testing in PHPUnit. Provided you have well-written PHPUnit tests, you can drop &lt;code&gt;paratest&lt;/code&gt; in your project and start using it with no additional bootstrap or configurations!&lt;/p&gt; &#xA;&lt;p&gt;Benefits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Zero configuration. After the installation, run with &lt;code&gt;vendor/bin/paratest&lt;/code&gt;. That&#39;s it!&lt;/li&gt; &#xA; &lt;li&gt;Code Coverage report combining. Run your tests in N parallel processes and all the code coverage output will be combined into one report.&lt;/li&gt; &#xA; &lt;li&gt;Flexible. Isolate test files in separate processes or take advantage of &lt;code&gt;WrapperRunner&lt;/code&gt; for even faster runs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;To install with composer run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;composer require --dev brianium/paratest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Versions&lt;/h1&gt; &#xA;&lt;p&gt;Only the latest version of PHPUnit is supported, and thus only the latest version of ParaTest is actively maintained.&lt;/p&gt; &#xA;&lt;p&gt;This is because of the following reasons:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;To reduce bugs, code duplication and incompatibilities with PHPUnit, from version 5 ParaTest heavily relies on PHPUnit &lt;code&gt;@internal&lt;/code&gt; classes&lt;/li&gt; &#xA; &lt;li&gt;The fast pace both PHP and PHPUnit have taken recently adds too much maintenance burden, which we can only afford for the latest versions to stay up-to-date&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;After installation, the binary can be found at &lt;code&gt;vendor/bin/paratest&lt;/code&gt;. Run it with &lt;code&gt;--help&lt;/code&gt; option to see a complete list of the available options.&lt;/p&gt; &#xA;&lt;h2&gt;Optimizing Speed&lt;/h2&gt; &#xA;&lt;p&gt;To get the most out of ParaTest, you have to adjust the parameters carefully.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Use the WrapperRunner if possible&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;The default Runner for PHPUnit spawns a new process for each testcase (or method in functional mode). This provides the highest compatibility but comes with the cost of many spawned processes and a bootstrapping for each process. Especially when you have a slow bootstrapping in your tests (like a database setup) you should try the &lt;code&gt;WrapperRunner&lt;/code&gt; with &lt;code&gt;--runner WrapperRunner&lt;/code&gt;. It spawns one &#34;worker&#34;-process for each parallel process (&lt;code&gt;-p&lt;/code&gt;), executes the bootstrapping once and reuses these processes for each test executed. That way the overhead of process spawning and bootstrapping is reduced to the minimum.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Adjust the number of processes with &lt;code&gt;-p&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;To allow full usage of your cpu cores, you should have at least one process per core. More processes allow better resource usage but keep in mind that each process has its own costs for spawning. The default is auto, which means the number of logical CPU cores is set as the number of processes. You might try something like logical &lt;code&gt;CPU cores * 2&lt;/code&gt; (e.g. if you have 8 logical cores, you might try &lt;code&gt;16&lt;/code&gt;), but keep in mind that each process generates a little bit of overhead as well.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Choose between per-testcase- and per-testmethod-parallelization with &lt;code&gt;-f&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Given you have few testcases (classes) with many long running methods, you should use the &lt;code&gt;-f&lt;/code&gt; option to enable the &lt;code&gt;functional mode&lt;/code&gt; and allow different methods of the same class to be executed in parallel. Keep in mind that the default is per-testcase-parallelization to address inter-testmethod dependencies. Note that in most projects, using &lt;code&gt;-f&lt;/code&gt; is &lt;strong&gt;slower&lt;/strong&gt; since each test &lt;strong&gt;method&lt;/strong&gt; will need to be bootstrapped separately.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Tune batch max size &lt;code&gt;--max-batch-size&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Batch size will affect the max amount of atomic tests which will be used for a single test method. One atomic test will be either one test method from test class if no data provider available for method or will be only one item from dataset for method. Increase this value to reduce per-process overhead and in most cases it will also reduce parallel efficiency. Decrease this value to increase per-process overhead and in most cases it will also increase parallel efficiency. If the amount of all tests is less than the max batch size then everything will be processed in one process thread so ParaTest is completely useless in that case. The best way to find the most effective batch size is to test with different batch size values and select best. Max batch size = 0 means that grouping in batches will not be used and one batch will equal all method tests (one or all from data provider). Max batch size = 1 means that each batch will contain only one test from the data provider or one method if the data provider is not used. Bigger max batch size can significantly increase phpunit command line length so the process can fail. Decrease max batch size to reduce command line length. Windows has a limit around 32k, Linux - 2048k, Mac OS X - 256k.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Test token&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;TEST_TOKEN&lt;/code&gt; environment variable is guaranteed to have a value that is different from every other currently running test. This is useful to e.g. use a different database for each test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (getenv(&#39;TEST_TOKEN&#39;) !== false) {  // Using ParaTest&#xA;    $dbname = &#39;testdb_&#39; . getenv(&#39;TEST_TOKEN&#39;);&#xA;} else {&#xA;    $dbname = &#39;testdb&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;UNIQUE_TEST_TOKEN&lt;/code&gt; environment variable is also available and guaranteed to have a value that is unique both per run and per process.&lt;/p&gt; &#xA;&lt;h2&gt;Code coverage&lt;/h2&gt; &#xA;&lt;p&gt;Beginning from PHPUnit 9.3.4, it is strongly advised to set a coverage cache directory, see &lt;a href=&#34;https://github.com/sebastianbergmann/phpunit/raw/9.3.4/ChangeLog-9.3.md#934---2020-08-10&#34;&gt;PHPUnit Changelog @ 9.3.4&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The cache is always warmed up by ParaTest before executing the test suite.&lt;/p&gt; &#xA;&lt;h3&gt;PCOV&lt;/h3&gt; &#xA;&lt;p&gt;If you have installed &lt;code&gt;pcov&lt;/code&gt; but need to enable it only while running tests, you have to pass thru the needed PHP binary option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;php -d pcov.enabled=1 vendor/bin/paratest --passthru-php=&#34;&#39;-d&#39; &#39;pcov.enabled=1&#39;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;xDebug&lt;/h3&gt; &#xA;&lt;p&gt;If you have &lt;code&gt;xDebug&lt;/code&gt; installed, activating it by the environment variable is enough to have it running even in the subprocesses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XDEBUG_MODE=coverage vendor/bin/paratest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PHPDBG&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;PHPDBG&lt;/code&gt; is automatically detected and used in the subprocesses if it&#39;s the running binary of the main process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;phpdbg vendor/bin/paratest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Initial setup for all tests&lt;/h2&gt; &#xA;&lt;p&gt;Because ParaTest runs multiple processes in parallel, each with their own instance of the PHP interpreter, techniques used to perform an initialization step exactly once for each test work different from PHPUnit. The following pattern will not work as expected - run the initialization exactly once - and instead run the initialization once per process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;private static bool $initialized = false;&#xA;&#xA;public function setUp(): void&#xA;{&#xA;    if (! self::$initialized) {&#xA;         self::initialize();&#xA;         self::$initialized = true;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is because static variables persist during the execution of a single process. In parallel testing each process has a separate instance of &lt;code&gt;$initialized&lt;/code&gt;. You can use the following pattern to ensure your initialization runs exactly once for the entire test invocation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;static bool $initialized = false;&#xA;&#xA;public function setUp(): void&#xA;{&#xA;    if (! self::$initialized) {&#xA;        // We utilize the filesystem as shared mutable state to coordinate between processes&#xA;        touch(&#39;/tmp/test-initialization-lock-file&#39;);&#xA;        $lockFile = fopen(&#39;/tmp/test-initialization-lock-file&#39;, &#39;r&#39;);&#xA;&#xA;        // Attempt to get an exclusive lock - first process wins&#xA;        if (flock($lockFile, LOCK_EX | LOCK_NB)) {&#xA;            // Since we are the single process that has an exclusive lock, we run the initialization&#xA;            self::initialize();&#xA;        } else {&#xA;            // If no exclusive lock is available, block until the first process is done with initialization&#xA;            flock($lockFile, LOCK_SH);&#xA;        }&#xA;&#xA;        self::$initialized = true;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;If you run into problems with &lt;code&gt;paratest&lt;/code&gt;, try to get more information about the issue by enabling debug output via &lt;code&gt;--verbose --debug&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When a sub-process fails, the originating command is given in the output and can then be copy-pasted in the terminal to be run and debugged. All internal commands run with &lt;code&gt;--printer [...]\NullPhpunitPrinter&lt;/code&gt; which silence the original PHPUnit output: during a debugging run remove that option to restore the output and see what PHPUnit is doing.&lt;/p&gt; &#xA;&lt;h2&gt;Windows&lt;/h2&gt; &#xA;&lt;p&gt;Windows users be sure to use the appropriate batch files.&lt;/p&gt; &#xA;&lt;p&gt;An example being:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;vendor\bin\paratest.bat ...&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;ParaTest assumes &lt;a href=&#34;https://github.com/php-fig/fig-standards/raw/master/accepted/PSR-0.md&#34;&gt;PSR-0&lt;/a&gt; for loading tests.&lt;/p&gt; &#xA;&lt;p&gt;For convenience, ParaTest for Windows uses 79 columns mode to prevent blank lines in the standard 80x25 windows console.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Constants, static methods, static variables and everything exposed by test classes consumed by other test classes (including Reflection) are not supported. This is due to a limitation of the current implementation of &lt;code&gt;WrapperRunner&lt;/code&gt; and how PHPUnit searches for classes. The fix is to put shared code into classes which are not tests &lt;em&gt;themselves&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Integration with PHPStorm&lt;/h2&gt; &#xA;&lt;p&gt;ParaTest provides a dedicated binary to work with PHPStorm; follow these steps to have ParaTest working within it:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Be sure you have PHPUnit already configured in PHPStorm: &lt;a href=&#34;https://www.jetbrains.com/help/phpstorm/using-phpunit-framework.html#php_test_frameworks_phpunit_integrate&#34;&gt;https://www.jetbrains.com/help/phpstorm/using-phpunit-framework.html#php_test_frameworks_phpunit_integrate&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Go to &lt;code&gt;Run&lt;/code&gt; -&amp;gt; &lt;code&gt;Edit configurations...&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Select &lt;code&gt;Add new Configuration&lt;/code&gt;, select the &lt;code&gt;PHPUnit&lt;/code&gt; type and name it &lt;code&gt;ParaTest&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;In the &lt;code&gt;Command Line&lt;/code&gt; -&amp;gt; &lt;code&gt;Interpreter options&lt;/code&gt; add &lt;code&gt;./vendor/bin/paratest_for_phpstorm&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Any additional ParaTest options you want to pass to ParaTest should go within the &lt;code&gt;Test runner&lt;/code&gt; -&amp;gt; &lt;code&gt;Test runner options&lt;/code&gt; section&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You should now have a &lt;code&gt;ParaTest&lt;/code&gt; run within your configurations list. It should natively work with the &lt;code&gt;Rerun failed tests&lt;/code&gt; and &lt;code&gt;Toggle auto-test&lt;/code&gt; buttons of the &lt;code&gt;Run&lt;/code&gt; overlay.&lt;/p&gt; &#xA;&lt;h3&gt;Run with Coverage&lt;/h3&gt; &#xA;&lt;p&gt;Coverage with one of the &lt;a href=&#34;https://raw.githubusercontent.com/paratestphp/paratest/6.x/#code-coverage&#34;&gt;available coverage engines&lt;/a&gt; must already be &lt;a href=&#34;https://www.jetbrains.com/help/phpstorm/code-coverage.html&#34;&gt;configured in PHPStorm&lt;/a&gt; and working when running tests sequentially in order for the helper binary to correctly handle code coverage&lt;/p&gt; &#xA;&lt;h1&gt;For Contributors: testing ParaTest itself&lt;/h1&gt; &#xA;&lt;p&gt;Before creating a Pull Request be sure to run all the necessary checks with &lt;code&gt;make&lt;/code&gt; command.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>symfony/yaml</title>
    <updated>2022-12-09T01:36:35Z</updated>
    <id>tag:github.com,2022-12-09:/symfony/yaml</id>
    <link href="https://github.com/symfony/yaml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Yaml component loads and dumps YAML files.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Yaml Component&lt;/h1&gt; &#xA;&lt;p&gt;The Yaml component loads and dumps YAML files.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://symfony.com/doc/current/components/yaml.html&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://symfony.com/doc/current/contributing/index.html&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/symfony/symfony/issues&#34;&gt;Report issues&lt;/a&gt; and &lt;a href=&#34;https://github.com/symfony/symfony/pulls&#34;&gt;send Pull Requests&lt;/a&gt; in the &lt;a href=&#34;https://github.com/symfony/symfony&#34;&gt;main Symfony repository&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>