<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-17T01:33:40Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wechatpay-apiv3/wechatpay-php</title>
    <updated>2023-08-17T01:33:40Z</updated>
    <id>tag:github.com,2023-08-17:/wechatpay-apiv3/wechatpay-php</id>
    <link href="https://github.com/wechatpay-apiv3/wechatpay-php" rel="alternate"></link>
    <summary type="html">&lt;p&gt;微信支付 APIv3 的官方 PHP Library，同时也支持 APIv2&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;微信支付 WeChatPay OpenAPI SDK&lt;/h1&gt; &#xA;&lt;p&gt;[A]Sync Chainable WeChatPay v2&amp;amp;v3&#39;s OpenAPI SDK for PHP&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-php/actions&#34;&gt;&lt;img src=&#34;https://github.com/wechatpay-apiv3/wechatpay-php/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub actions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/wechatpay/wechatpay&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/stars/wechatpay/wechatpay&#34; alt=&#34;Packagist Stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/wechatpay/wechatpay&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dm/wechatpay/wechatpay&#34; alt=&#34;Packagist Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/wechatpay/wechatpay&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/wechatpay/wechatpay&#34; alt=&#34;Packagist Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/wechatpay/wechatpay&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/php-v/wechatpay/wechatpay&#34; alt=&#34;Packagist PHP Version Support&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/wechatpay/wechatpay&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/l/wechatpay/wechatpay&#34; alt=&#34;Packagist License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;概览&lt;/h2&gt; &#xA;&lt;p&gt;基于 &lt;a href=&#34;http://docs.guzzlephp.org/&#34;&gt;Guzzle HTTP Client&lt;/a&gt; 的微信支付 PHP 开发库。&lt;/p&gt; &#xA;&lt;h3&gt;功能介绍&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;微信支付 APIv2 和 APIv3 的 Guzzle HTTP 客户端，支持 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82&#34;&gt;同步&lt;/a&gt; 或 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82&#34;&gt;异步&lt;/a&gt; 发送请求，并自动进行请求签名和应答验签&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/#%E9%93%BE%E5%BC%8F-uri-template&#34;&gt;链式实现的 URI Template&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/#%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E5%8A%A0%E8%A7%A3%E5%AF%86&#34;&gt;敏感信息加解密&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/#%E5%9B%9E%E8%B0%83%E9%80%9A%E7%9F%A5&#34;&gt;回调通知&lt;/a&gt;的验签和解密&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;项目状态&lt;/h2&gt; &#xA;&lt;p&gt;当前版本为 &lt;code&gt;1.4.8&lt;/code&gt; 测试版本。 项目版本遵循 &lt;a href=&#34;https://semver.org/lang/zh-CN/&#34;&gt;语义化版本号&lt;/a&gt;。 如果你使用的版本 &lt;code&gt;&amp;lt;=v1.3.2&lt;/code&gt;，升级前请参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/UPGRADING.md&#34;&gt;升级指南&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;环境要求&lt;/h2&gt; &#xA;&lt;p&gt;项目支持的环境如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Guzzle 7.0，PHP &amp;gt;= 7.2.5&lt;/li&gt; &#xA; &lt;li&gt;Guzzle 6.5，PHP &amp;gt;= 7.1.2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;我们推荐使用目前处于 &lt;a href=&#34;https://www.php.net/supported-versions.php&#34;&gt;Active Support&lt;/a&gt; 阶段的 PHP 8 和 Guzzle 7。&lt;/p&gt; &#xA;&lt;h2&gt;安装&lt;/h2&gt; &#xA;&lt;p&gt;推荐使用 PHP 包管理工具 &lt;a href=&#34;https://getcomposer.org/&#34;&gt;Composer&lt;/a&gt; 安装 SDK：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;composer require wechatpay/wechatpay&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;开始&lt;/h2&gt; &#xA;&lt;p&gt;ℹ️ 以下是 &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay-1.shtml&#34;&gt;微信支付 API v3&lt;/a&gt; 的指引。如果你是 API v2 的使用者，请看 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/README_APIv2.md&#34;&gt;README_APIv2&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;概念&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;商户 API 证书&lt;/strong&gt;，是用来证实商户身份的。证书中包含商户号、证书序列号、证书有效期等信息，由证书授权机构（Certificate Authority ，简称 CA）签发，以防证书被伪造或篡改。详情见 &lt;a href=&#34;https://kf.qq.com/faq/161222NneAJf161222U7fARv.html&#34;&gt;什么是商户API证书？如何获取商户API证书？&lt;/a&gt; 。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;商户 API 私钥&lt;/strong&gt;。你申请商户 API 证书时，会生成商户私钥，并保存在本地证书文件夹的文件 apiclient_key.pem 中。为了证明 API 请求是由你发送的，你应使用商户 API 私钥对请求进行签名。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;⚠&lt;/span&gt; 不要把私钥文件暴露在公共场合，如上传到 Github，写在 App 代码中等。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;微信支付平台证书&lt;/strong&gt;。微信支付平台证书是指：由微信支付负责申请，包含微信支付平台标识、公钥信息的证书。你需使用微信支付平台证书中的公钥验证 API 应答和回调通知的签名。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;ℹ️ 你需要先手工 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/#%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0%E8%AF%81%E4%B9%A6&#34;&gt;下载平台证书&lt;/a&gt; 才能使用 SDK 发起请求。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;证书序列号&lt;/strong&gt;。每个证书都有一个由 CA 颁发的唯一编号，即证书序列号。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;示例程序：微信支付平台证书下载&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;require_once(&#39;vendor/autoload.php&#39;);&#xA;&#xA;use WeChatPay\Builder;&#xA;use WeChatPay\Crypto\Rsa;&#xA;use WeChatPay\Util\PemUtil;&#xA;&#xA;// 设置参数&#xA;&#xA;// 商户号&#xA;$merchantId = &#39;190000****&#39;;&#xA;&#xA;// 从本地文件中加载「商户API私钥」，「商户API私钥」会用来生成请求的签名&#xA;$merchantPrivateKeyFilePath = &#39;file:///path/to/merchant/apiclient_key.pem&#39;;&#xA;$merchantPrivateKeyInstance = Rsa::from($merchantPrivateKeyFilePath, Rsa::KEY_TYPE_PRIVATE);&#xA;&#xA;// 「商户API证书」的「证书序列号」&#xA;$merchantCertificateSerial = &#39;3775B6A45ACD588826D15E583A95F5DD********&#39;;&#xA;&#xA;// 从本地文件中加载「微信支付平台证书」，用来验证微信支付应答的签名&#xA;$platformCertificateFilePath = &#39;file:///path/to/wechatpay/cert.pem&#39;;&#xA;$platformPublicKeyInstance = Rsa::from($platformCertificateFilePath, Rsa::KEY_TYPE_PUBLIC);&#xA;&#xA;// 从「微信支付平台证书」中获取「证书序列号」&#xA;$platformCertificateSerial = PemUtil::parseCertificateSerialNo($platformCertificateFilePath);&#xA;&#xA;// 构造一个 APIv3 客户端实例&#xA;$instance = Builder::factory([&#xA;    &#39;mchid&#39;      =&amp;gt; $merchantId,&#xA;    &#39;serial&#39;     =&amp;gt; $merchantCertificateSerial,&#xA;    &#39;privateKey&#39; =&amp;gt; $merchantPrivateKeyInstance,&#xA;    &#39;certs&#39;      =&amp;gt; [&#xA;        $platformCertificateSerial =&amp;gt; $platformPublicKeyInstance,&#xA;    ],&#xA;]);&#xA;&#xA;// 发送请求&#xA;$resp = $instance-&amp;gt;chain(&#39;v3/certificates&#39;)-&amp;gt;get(&#xA;    [&#39;debug&#39; =&amp;gt; true] // 调试模式，https://docs.guzzlephp.org/en/stable/request-options.html#debug&#xA;);&#xA;echo $resp-&amp;gt;getBody(), PHP_EOL;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;文档&lt;/h2&gt; &#xA;&lt;h3&gt;同步请求&lt;/h3&gt; &#xA;&lt;p&gt;使用客户端提供的 &lt;code&gt;get&lt;/code&gt;、&lt;code&gt;put&lt;/code&gt;、&lt;code&gt;post&lt;/code&gt;、&lt;code&gt;patch&lt;/code&gt; 或 &lt;code&gt;delete&lt;/code&gt; 方法发送同步请求。以 &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_1.shtml&#34;&gt;Native支付下单&lt;/a&gt; 为例。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;try {&#xA;    $resp = $instance&#xA;    -&amp;gt;chain(&#39;v3/pay/transactions/native&#39;)&#xA;    -&amp;gt;post([&#39;json&#39; =&amp;gt; [&#xA;        &#39;mchid&#39;        =&amp;gt; &#39;1900006XXX&#39;,&#xA;        &#39;out_trade_no&#39; =&amp;gt; &#39;native12177525012014070332333&#39;,&#xA;        &#39;appid&#39;        =&amp;gt; &#39;wxdace645e0bc2cXXX&#39;,&#xA;        &#39;description&#39;  =&amp;gt; &#39;Image形象店-深圳腾大-QQ公仔&#39;,&#xA;        &#39;notify_url&#39;   =&amp;gt; &#39;https://weixin.qq.com/&#39;,&#xA;        &#39;amount&#39;       =&amp;gt; [&#xA;            &#39;total&#39;    =&amp;gt; 1,&#xA;            &#39;currency&#39; =&amp;gt; &#39;CNY&#39;&#xA;        ],&#xA;    ]]);&#xA;&#xA;    echo $resp-&amp;gt;getStatusCode(), PHP_EOL;&#xA;    echo $resp-&amp;gt;getBody(), PHP_EOL;&#xA;} catch (\Exception $e) {&#xA;    // 进行错误处理&#xA;    echo $e-&amp;gt;getMessage(), PHP_EOL;&#xA;    if ($e instanceof \GuzzleHttp\Exception\RequestException &amp;amp;&amp;amp; $e-&amp;gt;hasResponse()) {&#xA;        $r = $e-&amp;gt;getResponse();&#xA;        echo $r-&amp;gt;getStatusCode() . &#39; &#39; . $r-&amp;gt;getReasonPhrase(), PHP_EOL;&#xA;        echo $r-&amp;gt;getBody(), PHP_EOL, PHP_EOL, PHP_EOL;&#xA;    }&#xA;    echo $e-&amp;gt;getTraceAsString(), PHP_EOL;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;请求成功后，你会获得一个 &lt;code&gt;GuzzleHttp\Psr7\Response&lt;/code&gt; 的应答对象。 阅读 Guzzle 文档 &lt;a href=&#34;https://docs.guzzlephp.org/en/stable/quickstart.html#using-responses&#34;&gt;Using Response&lt;/a&gt; 进一步了解如何访问应答内的信息。&lt;/p&gt; &#xA;&lt;h3&gt;异步请求&lt;/h3&gt; &#xA;&lt;p&gt;使用客户端提供的 &lt;code&gt;getAsync&lt;/code&gt;、&lt;code&gt;putAsync&lt;/code&gt;、&lt;code&gt;postAsync&lt;/code&gt;、&lt;code&gt;patchAsync&lt;/code&gt; 或 &lt;code&gt;deleteAsync&lt;/code&gt; 方法发送异步请求。以 &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_9.shtml&#34;&gt;退款&lt;/a&gt; 为例。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$promise = $instance&#xA;-&amp;gt;chain(&#39;v3/refund/domestic/refunds&#39;)&#xA;-&amp;gt;postAsync([&#xA;    &#39;json&#39; =&amp;gt; [&#xA;        &#39;transaction_id&#39; =&amp;gt; &#39;1217752501201407033233368018&#39;,&#xA;        &#39;out_refund_no&#39;  =&amp;gt; &#39;1217752501201407033233368018&#39;,&#xA;        &#39;amount&#39;         =&amp;gt; [&#xA;            &#39;refund&#39;   =&amp;gt; 888,&#xA;            &#39;total&#39;    =&amp;gt; 888,&#xA;            &#39;currency&#39; =&amp;gt; &#39;CNY&#39;,&#xA;        ],&#xA;    ],&#xA;])&#xA;-&amp;gt;then(static function($response) {&#xA;    // 正常逻辑回调处理&#xA;    echo $response-&amp;gt;getBody(), PHP_EOL;&#xA;    return $response;&#xA;})&#xA;-&amp;gt;otherwise(static function($e) {&#xA;    // 异常错误处理&#xA;    echo $e-&amp;gt;getMessage(), PHP_EOL;&#xA;    if ($e instanceof \GuzzleHttp\Exception\RequestException &amp;amp;&amp;amp; $e-&amp;gt;hasResponse()) {&#xA;        $r = $e-&amp;gt;getResponse();&#xA;        echo $r-&amp;gt;getStatusCode() . &#39; &#39; . $r-&amp;gt;getReasonPhrase(), PHP_EOL;&#xA;        echo $r-&amp;gt;getBody(), PHP_EOL, PHP_EOL, PHP_EOL;&#xA;    }&#xA;    echo $e-&amp;gt;getTraceAsString(), PHP_EOL;&#xA;});&#xA;// 同步等待&#xA;$promise-&amp;gt;wait();&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;[get|post|put|patch|delete]Async&lt;/code&gt; 返回的是 &lt;a href=&#34;https://github.com/guzzle/promises&#34;&gt;Guzzle Promises&lt;/a&gt;。你可以做两件事：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;成功时使用 &lt;code&gt;then()&lt;/code&gt; 处理得到的 &lt;code&gt;Psr\Http\Message\ResponseInterface&lt;/code&gt;，（可选地）将它传给下一个 &lt;code&gt;then()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;失败时使用 &lt;code&gt;otherwise()&lt;/code&gt; 处理异常&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;最后使用 &lt;code&gt;wait()&lt;/code&gt; 等待请求执行完成。&lt;/p&gt; &#xA;&lt;h3&gt;同步还是异步&lt;/h3&gt; &#xA;&lt;p&gt;对于大部分开发者，我们建议使用同步的模式，因为它更加易于理解。&lt;/p&gt; &#xA;&lt;p&gt;如果你是具有异步编程基础的开发者，在某些连续调用 API 的场景，将多个操作通过 &lt;code&gt;then()&lt;/code&gt; 流式串联起来会是一种优雅的实现方式。例如， &lt;a href=&#34;https://developers.weixin.qq.com/community/pay/article/doc/000ec4521086b85fb81d6472a51013&#34;&gt;以函数链的形式流式下载交易帐单&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;链式 URI Template&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc6570.html&#34;&gt;URI Template&lt;/a&gt; 是表达 URI 中变量的一种方式。微信支付 API 使用这种方式表示 URL Path 中的单号或者 ID。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# 使用微信支付订单号查询订单&#xA;GET /v3/pay/transactions/id/{transaction_id}&#xA;&#xA;# 使用商户订单号查询订单&#xA;GET /v3/pay/transactions/out-trade-no/{out_trade_no}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;使用 &lt;a href=&#34;https://en.wikipedia.org/wiki/Method_chaining&#34;&gt;链式&lt;/a&gt; URI Template，你能像书写代码一样流畅地书写 URL，轻松地输入路径并传递 URL 参数。配置接口描述包后还能开启 &lt;a href=&#34;https://github.com/TheNorthMemory/wechatpay-openapi&#34;&gt;IDE提示&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;链式串联的基本单元是 URI Path 中的 &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc3986.html#section-3.3&#34;&gt;segments&lt;/a&gt;，&lt;code&gt;segments&lt;/code&gt; 之间以 &lt;code&gt;-&amp;gt;&lt;/code&gt; 连接。连接的规则如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;普通 segment &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;直接书写。例如 &lt;code&gt;v3-&amp;gt;pay-&amp;gt;transactions-&amp;gt;native&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;使用 &lt;code&gt;chain()&lt;/code&gt;。例如 &lt;code&gt;chain(&#39;v3/pay/transactions/native&#39;)&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;包含连字号(-)的 segment &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;使用驼峰 camelCase 风格书写。例如 &lt;code&gt;merchant-service&lt;/code&gt; 可写成 &lt;code&gt;merchantService&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;使用 &lt;code&gt;{&#39;foo-bar&#39;}&lt;/code&gt; 方式书写。例如 &lt;code&gt;{&#39;merchant-service&#39;}&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Path 变量。URL 中的 Path 变量应使用这种写法，避免自行组装或者使用 &lt;code&gt;chain()&lt;/code&gt;，导致大小写处理错误 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;推荐使用&lt;/strong&gt; &lt;code&gt;_variable_name_&lt;/code&gt; 方式书写，支持 IDE 提示。例如 &lt;code&gt;v3-&amp;gt;pay-&amp;gt;transactions-&amp;gt;id-&amp;gt;_transaction_id_&lt;/code&gt;。&lt;/li&gt; &#xA;   &lt;li&gt;使用 &lt;code&gt;{&#39;{variable_name}&#39;}&lt;/code&gt; 方式书写。例如 &lt;code&gt;v3-&amp;gt;pay-&amp;gt;transactions-&amp;gt;id-&amp;gt;{&#39;{transaction_id}&#39;}&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;请求的 &lt;code&gt;HTTP METHOD&lt;/code&gt; 作为链式最后的执行方法。例如 &lt;code&gt;v3-&amp;gt;pay-&amp;gt;transactions-&amp;gt;native-&amp;gt;post([ ... ])&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Path 变量的值，以同名参数传入执行方法&lt;/li&gt; &#xA; &lt;li&gt;Query 参数，以名为 &lt;code&gt;query&lt;/code&gt; 的参数传入执行方法&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;以&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_2.shtml&#34;&gt;查询订单&lt;/a&gt; &lt;code&gt;GET&lt;/code&gt; 方法为例：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$promise = $instance&#xA;-&amp;gt;v3-&amp;gt;pay-&amp;gt;transactions-&amp;gt;id-&amp;gt;_transaction_id_&#xA;-&amp;gt;getAsync([&#xA;    // Query 参数&#xA;    &#39;query&#39; =&amp;gt; [&#39;mchid&#39; =&amp;gt; &#39;1230000109&#39;],&#xA;    // 变量名 =&amp;gt; 变量值&#xA;    &#39;transaction_id&#39; =&amp;gt; &#39;1217752501201407033233368018&#39;,&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;以 &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_3.shtml&#34;&gt;关闭订单&lt;/a&gt; &lt;code&gt;POST&lt;/code&gt; 方法为例：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$promise = $instance&#xA;-&amp;gt;v3-&amp;gt;pay-&amp;gt;transactions-&amp;gt;outTradeNo-&amp;gt;_out_trade_no_-&amp;gt;close&#xA;-&amp;gt;postAsync([&#xA;    // 请求消息&#xA;    &#39;json&#39; =&amp;gt; [&#39;mchid&#39; =&amp;gt; &#39;1230000109&#39;],&#xA;    // 变量名 =&amp;gt; 变量值&#xA;    &#39;out_trade_no&#39; =&amp;gt; &#39;1217752501201407033233368018&#39;,&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;更多例子&lt;/h2&gt; &#xA;&lt;h3&gt;视频文件上传&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter2_1_2.shtml&#34;&gt;官方开发文档地址&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 参考上述指引说明，并引入 `MediaUtil` 正常初始化，无额外条件&#xA;use WeChatPay\Util\MediaUtil;&#xA;// 实例化一个媒体文件流，注意文件后缀名需符合接口要求&#xA;$media = new MediaUtil(&#39;/your/file/path/video.mp4&#39;);&#xA;&#xA;$resp = $instance-&#xA;&amp;gt;chain(&#39;v3/merchant/media/video_upload&#39;)&#xA;-&amp;gt;post([&#xA;    &#39;body&#39;    =&amp;gt; $media-&amp;gt;getStream(),&#xA;    &#39;headers&#39; =&amp;gt; [&#xA;        &#39;content-type&#39; =&amp;gt; $media-&amp;gt;getContentType(),&#xA;    ]&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;营销图片上传&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter9_0_1.shtml&#34;&gt;官方开发文档地址&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use WeChatPay\Util\MediaUtil;&#xA;$media = new MediaUtil(&#39;/your/file/path/image.jpg&#39;);&#xA;$resp = $instance&#xA;-&amp;gt;v3-&amp;gt;marketing-&amp;gt;favor-&amp;gt;media-&amp;gt;imageUpload&#xA;-&amp;gt;post([&#xA;    &#39;body&#39;    =&amp;gt; $media-&amp;gt;getStream(),&#xA;    &#39;headers&#39; =&amp;gt; [&#xA;        &#39;Content-Type&#39; =&amp;gt; $media-&amp;gt;getContentType(),&#xA;    ]&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;敏感信息加/解密&lt;/h2&gt; &#xA;&lt;p&gt;为了保证通信过程中敏感信息字段（如用户的住址、银行卡号、手机号码等）的机密性，&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;微信支付要求加密上送的敏感信息&lt;/li&gt; &#xA; &lt;li&gt;微信支付会加密下行的敏感信息&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;下面以 &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3_partner/apis/chapter11_1_1.shtml&#34;&gt;特约商户进件&lt;/a&gt; 为例，演示如何进行 &lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/qian-ming-zhi-nan-1/min-gan-xin-xi-jia-mi&#34;&gt;敏感信息加解密&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use WeChatPay\Crypto\Rsa;&#xA;// 做一个匿名方法，供后续方便使用，$platformPublicKeyInstance 见初始化章节&#xA;$encryptor = static function(string $msg) use ($platformPublicKeyInstance): string {&#xA;    return Rsa::encrypt($msg, $platformPublicKeyInstance);&#xA;};&#xA;&#xA;$resp = $instance&#xA;-&amp;gt;chain(&#39;v3/applyment4sub/applyment/&#39;)&#xA;-&amp;gt;post([&#xA;    &#39;json&#39; =&amp;gt; [&#xA;        &#39;business_code&#39; =&amp;gt; &#39;APL_98761234&#39;,&#xA;        &#39;contact_info&#39;  =&amp;gt; [&#xA;            &#39;contact_name&#39;      =&amp;gt; $encryptor(&#39;张三&#39;),&#xA;            &#39;contact_id_number&#39; =&amp;gt; $encryptor(&#39;110102YYMMDD888X&#39;),&#xA;            &#39;mobile_phone&#39;      =&amp;gt; $encryptor(&#39;13000000000&#39;),&#xA;            &#39;contact_email&#39;     =&amp;gt; $encryptor(&#39;abc123@example.com&#39;),&#xA;        ],&#xA;        //...&#xA;    ],&#xA;    &#39;headers&#39; =&amp;gt; [&#xA;        // $platformCertificateSerial 见初始化章节&#xA;        &#39;Wechatpay-Serial&#39; =&amp;gt; $platformCertificateSerial,&#xA;    ],&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;签名&lt;/h2&gt; &#xA;&lt;p&gt;你可以使用 &lt;code&gt;Rsa::sign()&lt;/code&gt; 计算调起支付时所需参数签名。以 &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml&#34;&gt;JSAPI支付&lt;/a&gt; 为例。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use WeChatPay\Formatter;&#xA;use WeChatPay\Crypto\Rsa;&#xA;&#xA;$merchantPrivateKeyFilePath = &#39;file:///path/to/merchant/apiclient_key.pem&#39;;&#xA;$merchantPrivateKeyInstance = Rsa::from($merchantPrivateKeyFilePath);&#xA;&#xA;$params = [&#xA;    &#39;appId&#39;     =&amp;gt; &#39;wx8888888888888888&#39;,&#xA;    &#39;timeStamp&#39; =&amp;gt; (string)Formatter::timestamp(),&#xA;    &#39;nonceStr&#39;  =&amp;gt; Formatter::nonce(),&#xA;    &#39;package&#39;   =&amp;gt; &#39;prepay_id=wx201410272009395522657a690389285100&#39;,&#xA;];&#xA;$params += [&#39;paySign&#39; =&amp;gt; Rsa::sign(&#xA;    Formatter::joinedByLineFeed(...array_values($params)),&#xA;    $merchantPrivateKeyInstance&#xA;), &#39;signType&#39; =&amp;gt; &#39;RSA&#39;];&#xA;&#xA;echo json_encode($params);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;回调通知&lt;/h2&gt; &#xA;&lt;p&gt;回调通知受限于开发者/商户所使用的&lt;code&gt;WebServer&lt;/code&gt;有很大差异，这里只给出开发指导步骤，供参考实现。&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;从请求头部&lt;code&gt;Headers&lt;/code&gt;，拿到&lt;code&gt;Wechatpay-Signature&lt;/code&gt;、&lt;code&gt;Wechatpay-Nonce&lt;/code&gt;、&lt;code&gt;Wechatpay-Timestamp&lt;/code&gt;、&lt;code&gt;Wechatpay-Serial&lt;/code&gt;及&lt;code&gt;Request-ID&lt;/code&gt;，商户侧&lt;code&gt;Web&lt;/code&gt;解决方案可能有差异，请求头可能大小写不敏感，请根据自身应用来定；&lt;/li&gt; &#xA; &lt;li&gt;获取请求&lt;code&gt;body&lt;/code&gt;体的&lt;code&gt;JSON&lt;/code&gt;纯文本；&lt;/li&gt; &#xA; &lt;li&gt;检查通知消息头标记的&lt;code&gt;Wechatpay-Timestamp&lt;/code&gt;偏移量是否在5分钟之内；&lt;/li&gt; &#xA; &lt;li&gt;调用&lt;code&gt;SDK&lt;/code&gt;内置方法，&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml&#34;&gt;构造验签名串&lt;/a&gt;然后经&lt;code&gt;Rsa::verfify&lt;/code&gt;验签；&lt;/li&gt; &#xA; &lt;li&gt;消息体需要解密的，调用&lt;code&gt;SDK&lt;/code&gt;内置方法解密；&lt;/li&gt; &#xA; &lt;li&gt;如遇到问题，请拿&lt;code&gt;Request-ID&lt;/code&gt;点击&lt;a href=&#34;https://support.pay.weixin.qq.com/online-service?utm_source=github&amp;amp;utm_medium=wechatpay-php&amp;amp;utm_content=apiv3&#34;&gt;这里&lt;/a&gt;，联系官方在线技术支持；&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;样例代码如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use WeChatPay\Crypto\Rsa;&#xA;use WeChatPay\Crypto\AesGcm;&#xA;use WeChatPay\Formatter;&#xA;&#xA;$inWechatpaySignature = &#39;&#39;;// 请根据实际情况获取&#xA;$inWechatpayTimestamp = &#39;&#39;;// 请根据实际情况获取&#xA;$inWechatpaySerial = &#39;&#39;;// 请根据实际情况获取&#xA;$inWechatpayNonce = &#39;&#39;;// 请根据实际情况获取&#xA;$inBody = &#39;&#39;;// 请根据实际情况获取，例如: file_get_contents(&#39;php://input&#39;);&#xA;&#xA;$apiv3Key = &#39;&#39;;// 在商户平台上设置的APIv3密钥&#xA;&#xA;// 根据通知的平台证书序列号，查询本地平台证书文件，&#xA;// 假定为 `/path/to/wechatpay/inWechatpaySerial.pem`&#xA;$platformPublicKeyInstance = Rsa::from(&#39;file:///path/to/wechatpay/inWechatpaySerial.pem&#39;, Rsa::KEY_TYPE_PUBLIC);&#xA;&#xA;// 检查通知时间偏移量，允许5分钟之内的偏移&#xA;$timeOffsetStatus = 300 &amp;gt;= abs(Formatter::timestamp() - (int)$inWechatpayTimestamp);&#xA;$verifiedStatus = Rsa::verify(&#xA;    // 构造验签名串&#xA;    Formatter::joinedByLineFeed($inWechatpayTimestamp, $inWechatpayNonce, $inBody),&#xA;    $inWechatpaySignature,&#xA;    $platformPublicKeyInstance&#xA;);&#xA;if ($timeOffsetStatus &amp;amp;&amp;amp; $verifiedStatus) {&#xA;    // 转换通知的JSON文本消息为PHP Array数组&#xA;    $inBodyArray = (array)json_decode($inBody, true);&#xA;    // 使用PHP7的数据解构语法，从Array中解构并赋值变量&#xA;    [&#39;resource&#39; =&amp;gt; [&#xA;        &#39;ciphertext&#39;      =&amp;gt; $ciphertext,&#xA;        &#39;nonce&#39;           =&amp;gt; $nonce,&#xA;        &#39;associated_data&#39; =&amp;gt; $aad&#xA;    ]] = $inBodyArray;&#xA;    // 加密文本消息解密&#xA;    $inBodyResource = AesGcm::decrypt($ciphertext, $apiv3Key, $nonce, $aad);&#xA;    // 把解密后的文本转换为PHP Array数组&#xA;    $inBodyResourceArray = (array)json_decode($inBodyResource, true);&#xA;    // print_r($inBodyResourceArray);// 打印解密后的结果&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;异常处理&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt; 默认已提供基础中间件&lt;code&gt;\GuzzleHttp\Middleware::httpErrors&lt;/code&gt;来处理异常，文档可见&lt;a href=&#34;https://docs.guzzlephp.org/en/stable/quickstart.html#exceptions&#34;&gt;这里&lt;/a&gt;。 本SDK自&lt;code&gt;v1.1&lt;/code&gt;对异常处理做了微调，各场景抛送出的异常如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;HTTP&lt;/code&gt;网络错误，如网络连接超时、DNS解析失败等，送出&lt;code&gt;\GuzzleHttp\Exception\RequestException&lt;/code&gt;；&lt;/li&gt; &#xA; &lt;li&gt;服务器端返回了 &lt;code&gt;5xx HTTP&lt;/code&gt; 状态码，送出&lt;code&gt;\GuzzleHttp\Exception\ServerException&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;服务器端返回了 &lt;code&gt;4xx HTTP&lt;/code&gt; 状态码，送出&lt;code&gt;\GuzzleHttp\Exception\ClientException&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;服务器端返回了 &lt;code&gt;30x HTTP&lt;/code&gt; 状态码，如超出SDK客户端重定向设置阈值，送出&lt;code&gt;\GuzzleHttp\Exception\TooManyRedirectsException&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;服务器端返回了 &lt;code&gt;20x HTTP&lt;/code&gt; 状态码，如SDK客户端逻辑处理失败，例如应答签名验证失败，送出&lt;code&gt;\GuzzleHttp\Exception\RequestException&lt;/code&gt;；&lt;/li&gt; &#xA; &lt;li&gt;请求签名准备阶段，&lt;code&gt;HTTP&lt;/code&gt;请求未发生之前，如PHP环境异常、商户私钥异常等，送出&lt;code&gt;\UnexpectedValueException&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;初始化时，如把&lt;code&gt;商户证书序列号&lt;/code&gt;配置成&lt;code&gt;平台证书序列号&lt;/code&gt;，送出&lt;code&gt;\InvalidArgumentException&lt;/code&gt;;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;以上示例代码，均含有&lt;code&gt;catch&lt;/code&gt;及&lt;code&gt;otherwise&lt;/code&gt;错误处理场景示例，测试用例也覆盖了&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/tests/ClientDecoratorTest.php&#34;&gt;5xx/4xx/20x异常&lt;/a&gt;，开发者可参考这些代码逻辑进行错误处理。&lt;/p&gt; &#xA;&lt;h2&gt;定制&lt;/h2&gt; &#xA;&lt;p&gt;当默认的本地签名和验签方式不适合你的系统时，你可以通过实现&lt;code&gt;signer&lt;/code&gt;或者&lt;code&gt;verifier&lt;/code&gt;中间件来定制签名和验签，比如，你的系统把商户私钥集中存储，业务系统需通过远程调用进行签名。 以下示例用来演示如何替换SDK内置中间件，来实现远程&lt;code&gt;请求签名&lt;/code&gt;及&lt;code&gt;结果验签&lt;/code&gt;，供商户参考实现。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use GuzzleHttp\Client;&#xA;use GuzzleHttp\Middleware;&#xA;use GuzzleHttp\Exception\RequestException;&#xA;use Psr\Http\Message\RequestInterface;&#xA;use Psr\Http\Message\ResponseInterface;&#xA;&#xA;// 假设集中管理服务器接入点为内网`http://192.168.169.170:8080/`地址，并提供两个URI供签名及验签&#xA;// - `/wechatpay-merchant-request-signature` 为请求签名&#xA;// - `/wechatpay-response-merchant-validation` 为响应验签&#xA;$client = new Client([&#39;base_uri&#39; =&amp;gt; &#39;http://192.168.169.170:8080/&#39;]);&#xA;&#xA;// 请求参数签名，返回字符串形如`\WeChatPay\Formatter::authorization`返回的字符串&#xA;$remoteSigner = function (RequestInterface $request) use ($client, $merchantId): string {&#xA;    return (string)$client-&amp;gt;post(&#39;/wechatpay-merchant-request-signature&#39;, [&#39;json&#39; =&amp;gt; [&#xA;        &#39;mchid&#39; =&amp;gt; $merchantId,&#xA;        &#39;verb&#39;  =&amp;gt; $request-&amp;gt;getMethod(),&#xA;        &#39;uri&#39;   =&amp;gt; $request-&amp;gt;getRequestTarget(),&#xA;        &#39;body&#39;  =&amp;gt; (string)$request-&amp;gt;getBody(),&#xA;    ]])-&amp;gt;getBody();&#xA;};&#xA;&#xA;// 返回结果验签，返回可以是4xx,5xx，与远程验签应用约定返回字符串&#39;OK&#39;为验签通过&#xA;$remoteVerifier = function (ResponseInterface $response) use ($client, $merchantId): string {&#xA;    [$nonce]     = $response-&amp;gt;getHeader(&#39;Wechatpay-Nonce&#39;);&#xA;    [$serial]    = $response-&amp;gt;getHeader(&#39;Wechatpay-Serial&#39;);&#xA;    [$signature] = $response-&amp;gt;getHeader(&#39;Wechatpay-Signature&#39;);&#xA;    [$timestamp] = $response-&amp;gt;getHeader(&#39;Wechatpay-Timestamp&#39;);&#xA;    return (string)$client-&amp;gt;post(&#39;/wechatpay-response-merchant-validation&#39;, [&#39;json&#39; =&amp;gt; [&#xA;        &#39;mchid&#39;     =&amp;gt; $merchantId,&#xA;        &#39;nonce&#39;     =&amp;gt; $nonce,&#xA;        &#39;serial&#39;    =&amp;gt; $serial,&#xA;        &#39;signature&#39; =&amp;gt; $signature,&#xA;        &#39;timestamp&#39; =&amp;gt; $timestamp,&#xA;        &#39;body&#39;      =&amp;gt; (string)$response-&amp;gt;getBody(),&#xA;    ]])-&amp;gt;getBody();&#xA;};&#xA;&#xA;$stack = $instance-&amp;gt;getDriver()-&amp;gt;select()-&amp;gt;getConfig(&#39;handler&#39;);&#xA;// 卸载SDK内置签名中间件&#xA;$stack-&amp;gt;remove(&#39;signer&#39;);&#xA;// 注册内网远程请求签名中间件&#xA;$stack-&amp;gt;before(&#39;prepare_body&#39;, Middleware::mapRequest(&#xA;    static function (RequestInterface $request) use ($remoteSigner): RequestInterface {&#xA;        return $request-&amp;gt;withHeader(&#39;Authorization&#39;, $remoteSigner($request));&#xA;    }&#xA;), &#39;signer&#39;);&#xA;// 卸载SDK内置验签中间件&#xA;$stack-&amp;gt;remove(&#39;verifier&#39;);&#xA;// 注册内网远程请求验签中间件&#xA;$stack-&amp;gt;before(&#39;http_errors&#39;, static function (callable $handler) use ($remoteVerifier): callable {&#xA;    return static function (RequestInterface $request, array $options = []) use ($remoteVerifier, $handler) {&#xA;        return $handler($request, $options)-&amp;gt;then(&#xA;            static function(ResponseInterface $response) use ($remoteVerifier, $request): ResponseInterface {&#xA;                $verified = &#39;&#39;;&#xA;                try {&#xA;                    $verified = $remoteVerifier($response);&#xA;                } catch (\Throwable $exception) {}&#xA;                if ($verified === &#39;OK&#39;) { //远程验签约定，返回字符串`OK`作为验签通过&#xA;                    throw new RequestException(&#39;签名验签失败&#39;, $request, $response, $exception ?? null);&#xA;                }&#xA;                return $response;&#xA;            }&#xA;        );&#xA;    };&#xA;}, &#39;verifier&#39;);&#xA;&#xA;// 链式/同步/异步请求APIv3即可，例如:&#xA;$instance-&amp;gt;v3-&amp;gt;certificates-&amp;gt;getAsync()-&amp;gt;then(static function($res) { return $res-&amp;gt;getBody(); })-&amp;gt;wait();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;常见问题&lt;/h2&gt; &#xA;&lt;h3&gt;如何下载平台证书？&lt;/h3&gt; &#xA;&lt;p&gt;使用内置的&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/bin/README.md&#34;&gt;微信支付平台证书下载器&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer exec CertificateDownloader.php -- -k ${apiV3key} -m ${mchId} -f ${mchPrivateKeyFilePath} -s ${mchSerialNo} -o ${outputFilePath}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;微信支付平台证书下载后，下载器会用获得的&lt;code&gt;平台证书&lt;/code&gt;对返回的消息进行验签。下载器同时开启了 &lt;code&gt;Guzzle&lt;/code&gt; 的 &lt;code&gt;debug =&amp;gt; true&lt;/code&gt; 参数，方便查询请求/响应消息的基础调试信息。&lt;/p&gt; &#xA;&lt;p&gt;ℹ️ &lt;a href=&#34;https://kf.qq.com/faq/180830E36vyQ180830AZFZvu.html&#34;&gt;什么是APIv3密钥？如何设置？&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;证书和回调解密需要的AesGcm解密在哪里？&lt;/h3&gt; &#xA;&lt;p&gt;请参考&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/src/Crypto/AesGcm.php&#34;&gt;AesGcm.php&lt;/a&gt;，例如内置的&lt;code&gt;平台证书&lt;/code&gt;下载工具解密代码如下:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;AesGcm::decrypt($cert-&amp;gt;ciphertext, $apiv3Key, $cert-&amp;gt;nonce, $cert-&amp;gt;associated_data);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;配合swoole使用时，上传文件接口报错&lt;/h3&gt; &#xA;&lt;p&gt;建议升级至swoole 4.6+，swoole在 4.6.0 中增加了native-curl(&lt;a href=&#34;https://github.com/swoole/swoole-src/pull/3863&#34;&gt;swoole/swoole-src#3863&lt;/a&gt;)支持，我们测试能正常使用了。 更详细的信息，请参考&lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-guzzle-middleware/issues/36&#34;&gt;#36&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;如何加载公/私钥和证书&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;v1.2&lt;/code&gt;提供了统一的加载函数 &lt;code&gt;Rsa::from($thing, $type)&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Rsa::from($thing, $type)&lt;/code&gt; 支持从文件/字符串加载公/私钥和证书，使用方法可参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/tests/Crypto/RsaTest.php&#34;&gt;RsaTest.php&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Rsa::fromPkcs1&lt;/code&gt;是个语法糖，支持加载 &lt;code&gt;PKCS#1&lt;/code&gt; 格式的公/私钥，入参是 &lt;code&gt;base64&lt;/code&gt; 字符串&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Rsa::fromPkcs8&lt;/code&gt;是个语法糖，支持加载 &lt;code&gt;PKCS#8&lt;/code&gt; 格式的私钥，入参是 &lt;code&gt;base64&lt;/code&gt; 字符串&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Rsa::fromSpki&lt;/code&gt;是个语法糖，支持加载 &lt;code&gt;SPKI&lt;/code&gt; 格式的公钥，入参是 &lt;code&gt;base64&lt;/code&gt; 字符串&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Rsa::pkcs1ToSpki&lt;/code&gt;是个 &lt;code&gt;RSA公钥&lt;/code&gt; 格式转换函数，入参是 &lt;code&gt;base64&lt;/code&gt; 字符串&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;如何计算商家券发券 API 的签名&lt;/h3&gt; &#xA;&lt;p&gt;使用 &lt;code&gt;Hash::sign()&lt;/code&gt;计算 APIv2 的签名，示例请参考 APIv2 文档的 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/README_APIv2.md#%E6%95%B0%E6%8D%AE%E7%AD%BE%E5%90%8D&#34;&gt;数据签名&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;为什么 URL 上的变量 OpenID，请求时被替换成小写了？&lt;/h3&gt; &#xA;&lt;p&gt;本 SDK 把 URL 中的大写视为包含连字号的 segment。请求时， &lt;code&gt;camelCase&lt;/code&gt; 会替换为 &lt;code&gt;camel-case&lt;/code&gt;。相关 issue 可参考 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-php/issues/56&#34;&gt;#56&lt;/a&gt;、 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-php/issues/69&#34;&gt;#69&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;为了避免大小写错乱，URL 中存在变量时的正确做法是：使用 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/#%E9%93%BE%E5%BC%8F-uri-template&#34;&gt;链式 URI Template&lt;/a&gt; 的 Path 变量。比如：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;推荐写法&lt;/strong&gt; &lt;code&gt;-&amp;gt;v3-&amp;gt;marketing-&amp;gt;favor-&amp;gt;users-&amp;gt;_openid_-&amp;gt;coupons-&amp;gt;post([&#39;openid&#39; =&amp;gt; &#39;AbcdEF12345&#39;])&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&amp;gt;v3-&amp;gt;marketing-&amp;gt;favor-&amp;gt;users-&amp;gt;{&#39;{openid}&#39;}-&amp;gt;coupons-&amp;gt;post([&#39;openid&#39; =&amp;gt; &#39;AbcdEF12345&#39;])&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&amp;gt;chain(&#39;{+myurl}&#39;)-&amp;gt;post([&#39;myurl&#39; =&amp;gt; &#39;v3/marketing/favor/users/AbcdEF12345/coupons&#39;])&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&amp;gt;{&#39;{+myurl}&#39;}-&amp;gt;post([&#39;myurl&#39; =&amp;gt; &#39;v3/marketing/favor/users/AbcdEF12345/coupons&#39;])&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;联系我们&lt;/h2&gt; &#xA;&lt;p&gt;如果你发现了&lt;strong&gt;BUG&lt;/strong&gt;或者有任何疑问、建议，请通过issue进行反馈。&lt;/p&gt; &#xA;&lt;p&gt;也欢迎访问我们的&lt;a href=&#34;https://developers.weixin.qq.com/community/pay&#34;&gt;开发者社区&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;链接&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.guzzlephp.org/en/stable/overview.html#requirements&#34;&gt;GuzzleHttp官方版本支持&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.php.net/supported-versions.php&#34;&gt;PHP官方版本支持&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/CHANGELOG.md&#34;&gt;变更历史&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/UPGRADING.md&#34;&gt;升级指南&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a name=&#34;note-rfc3986&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc3986.html#section-3.3&#34;&gt;RFC3986&lt;/a&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;section-3.3 &lt;code&gt;segments&lt;/code&gt;: A path consists of a sequence of path segments separated by a slash (&#34;/&#34;) character.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a name=&#34;note-rfc6570&#34;&gt;&lt;/a&gt;&lt;a&gt; &lt;/a&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc6570.html&#34;&gt;RFC6570&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.php.net/manual/zh/openssl.certparams.php&#34;&gt;PHP密钥/证书参数 相关说明&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-php/main/LICENSE&#34;&gt;Apache-2.0 License&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Behat/Behat</title>
    <updated>2023-08-17T01:33:40Z</updated>
    <id>tag:github.com,2023-08-17:/Behat/Behat</id>
    <link href="https://github.com/Behat/Behat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;BDD in PHP&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/Behat/logo/raw/master/logo.png&#34; alt=&#34;Behat&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Behat is a BDD framework for PHP to help you test business expectations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/Behat/Behat&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Behat/Behat.svg?sanitize=true&#34; alt=&#34;Gitter chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/behat/behat&#34;&gt;&lt;img src=&#34;https://poser.pugx.org/behat/behat/license.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Behat/Behat/actions?query=workflow%3ABuild&#34;&gt;&lt;img src=&#34;https://github.com/Behat/Behat/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installing Behat&lt;/h2&gt; &#xA;&lt;p&gt;The easiest way to install Behat is by using &lt;a href=&#34;https://getcomposer.org&#34;&gt;Composer&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$&amp;gt; composer require --dev behat/behat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that you&#39;ll be able to run Behat via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$&amp;gt; vendor/bin/behat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing Development Version&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository and install dependencies via &lt;a href=&#34;https://getcomposer.org&#34;&gt;Composer&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$&amp;gt; composer install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that you will be able to run development version of Behat via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$&amp;gt; bin/behat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Before contributing to Behat, please take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/Behat/Behat/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h2&gt;Versioning&lt;/h2&gt; &#xA;&lt;p&gt;Starting from &lt;code&gt;v3.0.0&lt;/code&gt;, Behat is following &lt;a href=&#34;http://semver.org/spec/v2.0.0.html&#34;&gt;Semantic Versioning v2.0.0&lt;/a&gt;. This basically means that if all you do is implement interfaces (like &lt;a href=&#34;https://github.com/Behat/Behat/raw/v3.1.0/src/Behat/Behat/Context/ContextClass/ClassResolver.php#L15-L22&#34;&gt;this one&lt;/a&gt;) and use service constants (like &lt;a href=&#34;https://github.com/Behat/Behat/raw/v3.1.0/src/Behat/Behat/Context/ServiceContainer/ContextExtension.php#L46&#34;&gt;this one&lt;/a&gt;), you would not have any backwards compatibility issues with Behat up until &lt;code&gt;v4.0.0&lt;/code&gt; (or later major) is released. Exception could be an extremely rare case where BC break is introduced as a measure to fix a serious issue.&lt;/p&gt; &#xA;&lt;p&gt;You can read detailed guidance on what BC means in &lt;a href=&#34;http://symfony.com/doc/current/contributing/code/bc.html&#34;&gt;Symfony BC guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Useful Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The main website is at &lt;a href=&#34;http://behat.org&#34;&gt;http://behat.org&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The documentation is at &lt;a href=&#34;http://docs.behat.org/en/latest/&#34;&gt;http://docs.behat.org/en/latest/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Official Google Group is at &lt;a href=&#34;http://groups.google.com/group/behat&#34;&gt;http://groups.google.com/group/behat&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;IRC channel on &lt;a href=&#34;http://freenode.net/&#34;&gt;#freenode&lt;/a&gt; is &lt;code&gt;#behat&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Behat/Behat/master/CONTRIBUTING.md&#34;&gt;Note on Patches/Pull Requests&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Konstantin Kudryashov &lt;a href=&#34;http://github.com/everzet&#34;&gt;everzet&lt;/a&gt; [lead developer]&lt;/li&gt; &#xA; &lt;li&gt;Other &lt;a href=&#34;https://github.com/Behat/Behat/graphs/contributors&#34;&gt;awesome developers&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>