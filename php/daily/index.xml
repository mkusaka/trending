<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-10T01:34:55Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>phpspec/prophecy</title>
    <updated>2022-12-10T01:34:55Z</updated>
    <id>tag:github.com,2022-12-10:/phpspec/prophecy</id>
    <link href="https://github.com/phpspec/prophecy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Highly opinionated mocking framework for PHP 5.3+&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Prophecy&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/phpspec/prophecy&#34;&gt;&lt;img src=&#34;https://poser.pugx.org/phpspec/prophecy/version.svg?sanitize=true&#34; alt=&#34;Stable release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/phpspec/prophecy&#34;&gt;&lt;img src=&#34;https://travis-ci.org/phpspec/prophecy.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Prophecy is a highly opinionated yet very powerful and flexible PHP object mocking framework. Though initially it was created to fulfil phpspec2 needs, it is flexible enough to be used inside any testing framework out there with minimal effort.&lt;/p&gt; &#xA;&lt;h2&gt;A simple example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;class UserTest extends PHPUnit\Framework\TestCase&#xA;{&#xA;    private $prophet;&#xA;&#xA;    public function testPasswordHashing()&#xA;    {&#xA;        $hasher = $this-&amp;gt;prophet-&amp;gt;prophesize(&#39;App\Security\Hasher&#39;);&#xA;        $user   = new App\Entity\User($hasher-&amp;gt;reveal());&#xA;&#xA;        $hasher-&amp;gt;generateHash($user, &#39;qwerty&#39;)-&amp;gt;willReturn(&#39;hashed_pass&#39;);&#xA;&#xA;        $user-&amp;gt;setPassword(&#39;qwerty&#39;);&#xA;&#xA;        $this-&amp;gt;assertEquals(&#39;hashed_pass&#39;, $user-&amp;gt;getPassword());&#xA;    }&#xA;&#xA;    protected function setUp()&#xA;    {&#xA;        $this-&amp;gt;prophet = new \Prophecy\Prophet;&#xA;    }&#xA;&#xA;    protected function tearDown()&#xA;    {&#xA;        $this-&amp;gt;prophet-&amp;gt;checkPredictions();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;Prophecy requires PHP 7.2.0 or greater.&lt;/p&gt; &#xA;&lt;h3&gt;Setup through composer&lt;/h3&gt; &#xA;&lt;p&gt;First, add Prophecy to the list of dependencies inside your &lt;code&gt;composer.json&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;require-dev&#34;: {&#xA;        &#34;phpspec/prophecy&#34;: &#34;~1.0&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then simply install it with composer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$&amp;gt; composer install --prefer-dist&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can read more about Composer on its &lt;a href=&#34;http://getcomposer.org&#34;&gt;official webpage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to use it&lt;/h2&gt; &#xA;&lt;p&gt;First of all, in Prophecy every word has a logical meaning, even the name of the library itself (Prophecy). When you start feeling that, you&#39;ll become very fluid with this tool.&lt;/p&gt; &#xA;&lt;p&gt;For example, Prophecy has been named that way because it concentrates on describing the future behavior of objects with very limited knowledge about them. But as with any other prophecy, those object prophecies can&#39;t create themselves - there should be a Prophet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$prophet = new Prophecy\Prophet;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Prophet creates prophecies by &lt;em&gt;prophesizing&lt;/em&gt; them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$prophecy = $prophet-&amp;gt;prophesize();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result of the &lt;code&gt;prophesize()&lt;/code&gt; method call is a new object of class &lt;code&gt;ObjectProphecy&lt;/code&gt;. Yes, that&#39;s your specific object prophecy, which describes how your object would behave in the near future. But first, you need to specify which object you&#39;re talking about, right?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$prophecy-&amp;gt;willExtend(&#39;stdClass&#39;);&#xA;$prophecy-&amp;gt;willImplement(&#39;SessionHandlerInterface&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are 2 interesting calls - &lt;code&gt;willExtend&lt;/code&gt; and &lt;code&gt;willImplement&lt;/code&gt;. The first one tells object prophecy that our object should extend a specific class. The second one says that it should implement some interface. Obviously, objects in PHP can implement multiple interfaces, but extend only one parent class.&lt;/p&gt; &#xA;&lt;h3&gt;Dummies&lt;/h3&gt; &#xA;&lt;p&gt;Ok, now we have our object prophecy. What can we do with it? First of all, we can get our object &lt;em&gt;dummy&lt;/em&gt; by revealing its prophecy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$dummy = $prophecy-&amp;gt;reveal();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;$dummy&lt;/code&gt; variable now holds a special dummy object. Dummy objects are objects that extend and/or implement preset classes/interfaces by overriding all their public methods. The key point about dummies is that they do not hold any logic - they just do nothing. Any method of the dummy will always return &lt;code&gt;null&lt;/code&gt; and the dummy will never throw any exceptions. Dummy is your friend if you don&#39;t care about the actual behavior of this double and just need a token object to satisfy a method typehint.&lt;/p&gt; &#xA;&lt;p&gt;You need to understand one thing - a dummy is not a prophecy. Your object prophecy is still assigned to &lt;code&gt;$prophecy&lt;/code&gt; variable and in order to manipulate with your expectations, you should work with it. &lt;code&gt;$dummy&lt;/code&gt; is a dummy - a simple php object that tries to fulfil your prophecy.&lt;/p&gt; &#xA;&lt;h3&gt;Stubs&lt;/h3&gt; &#xA;&lt;p&gt;Ok, now we know how to create basic prophecies and reveal dummies from them. That&#39;s awesome if we don&#39;t care about our &lt;em&gt;doubles&lt;/em&gt; (objects that reflect originals) interactions. If we do, we need to use &lt;em&gt;stubs&lt;/em&gt; or &lt;em&gt;mocks&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A stub is an object double, which doesn&#39;t have any expectations about the object behavior, but when put in specific environment, behaves in specific way. Ok, I know, it&#39;s cryptic, but bear with me for a minute. Simply put, a stub is a dummy, which depending on the called method signature does different things (has logic). To create stubs in Prophecy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$prophecy-&amp;gt;read(&#39;123&#39;)-&amp;gt;willReturn(&#39;value&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Oh wow. We&#39;ve just made an arbitrary call on the object prophecy? Yes, we did. And this call returned us a new object instance of class &lt;code&gt;MethodProphecy&lt;/code&gt;. Yep, that&#39;s a specific method with arguments prophecy. Method prophecies give you the ability to create method promises or predictions. We&#39;ll talk about method predictions later in the &lt;em&gt;Mocks&lt;/em&gt; section.&lt;/p&gt; &#xA;&lt;h4&gt;Promises&lt;/h4&gt; &#xA;&lt;p&gt;Promises are logical blocks, that represent your fictional methods in prophecy terms and they are handled by the &lt;code&gt;MethodProphecy::will(PromiseInterface $promise)&lt;/code&gt; method. As a matter of fact, the call that we made earlier (&lt;code&gt;willReturn(&#39;value&#39;)&lt;/code&gt;) is a simple shortcut to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$prophecy-&amp;gt;read(&#39;123&#39;)-&amp;gt;will(new Prophecy\Promise\ReturnPromise(array(&#39;value&#39;)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This promise will cause any call to our double&#39;s &lt;code&gt;read()&lt;/code&gt; method with exactly one argument - &lt;code&gt;&#39;123&#39;&lt;/code&gt; to always return &lt;code&gt;&#39;value&#39;&lt;/code&gt;. But that&#39;s only for this promise, there&#39;s plenty others you can use:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ReturnPromise&lt;/code&gt; or &lt;code&gt;-&amp;gt;willReturn(1)&lt;/code&gt; - returns a value from a method call&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ReturnArgumentPromise&lt;/code&gt; or &lt;code&gt;-&amp;gt;willReturnArgument($index)&lt;/code&gt; - returns the nth method argument from call&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ThrowPromise&lt;/code&gt; or &lt;code&gt;-&amp;gt;willThrow($exception)&lt;/code&gt; - causes the method to throw specific exception&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CallbackPromise&lt;/code&gt; or &lt;code&gt;-&amp;gt;will($callback)&lt;/code&gt; - gives you a quick way to define your own custom logic&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Keep in mind, that you can always add even more promises by implementing &lt;code&gt;Prophecy\Promise\PromiseInterface&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Method prophecies idempotency&lt;/h4&gt; &#xA;&lt;p&gt;Prophecy enforces same method prophecies and, as a consequence, same promises and predictions for the same method calls with the same arguments. This means:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$methodProphecy1 = $prophecy-&amp;gt;read(&#39;123&#39;);&#xA;$methodProphecy2 = $prophecy-&amp;gt;read(&#39;123&#39;);&#xA;$methodProphecy3 = $prophecy-&amp;gt;read(&#39;321&#39;);&#xA;&#xA;$methodProphecy1 === $methodProphecy2;&#xA;$methodProphecy1 !== $methodProphecy3;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s interesting, right? Now you might ask me how would you define more complex behaviors where some method call changes behavior of others. In PHPUnit or Mockery you do that by predicting how many times your method will be called. In Prophecy, you&#39;ll use promises for that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$user-&amp;gt;getName()-&amp;gt;willReturn(null);&#xA;&#xA;// For PHP 5.4&#xA;$user-&amp;gt;setName(&#39;everzet&#39;)-&amp;gt;will(function () {&#xA;    $this-&amp;gt;getName()-&amp;gt;willReturn(&#39;everzet&#39;);&#xA;});&#xA;&#xA;// For PHP 5.3&#xA;$user-&amp;gt;setName(&#39;everzet&#39;)-&amp;gt;will(function ($args, $user) {&#xA;    $user-&amp;gt;getName()-&amp;gt;willReturn(&#39;everzet&#39;);&#xA;});&#xA;&#xA;// Or&#xA;$user-&amp;gt;setName(&#39;everzet&#39;)-&amp;gt;will(function ($args) use ($user) {&#xA;    $user-&amp;gt;getName()-&amp;gt;willReturn(&#39;everzet&#39;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And now it doesn&#39;t matter how many times or in which order your methods are called. What matters is their behaviors and how well you faked it.&lt;/p&gt; &#xA;&lt;p&gt;Note: If the method is called several times, you can use the following syntax to return different values for each call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$prophecy-&amp;gt;read(&#39;123&#39;)-&amp;gt;willReturn(1, 2, 3);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This feature is actually not recommended for most cases. Relying on the order of calls for the same arguments tends to make test fragile, as adding one more call can break everything.&lt;/p&gt; &#xA;&lt;h4&gt;Arguments wildcarding&lt;/h4&gt; &#xA;&lt;p&gt;The previous example is awesome (at least I hope it is for you), but that&#39;s not optimal enough. We hardcoded &lt;code&gt;&#39;everzet&#39;&lt;/code&gt; in our expectation. Isn&#39;t there a better way? In fact there is, but it involves understanding what this &lt;code&gt;&#39;everzet&#39;&lt;/code&gt; actually is.&lt;/p&gt; &#xA;&lt;p&gt;You see, even if method arguments used during method prophecy creation look like simple method arguments, in reality they are not. They are argument token wildcards. As a matter of fact, &lt;code&gt;-&amp;gt;setName(&#39;everzet&#39;)&lt;/code&gt; looks like a simple call just because Prophecy automatically transforms it under the hood into:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$user-&amp;gt;setName(new Prophecy\Argument\Token\ExactValueToken(&#39;everzet&#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Those argument tokens are simple PHP classes, that implement &lt;code&gt;Prophecy\Argument\Token\TokenInterface&lt;/code&gt; and tell Prophecy how to compare real arguments with your expectations. And yes, those classnames are damn big. That&#39;s why there&#39;s a shortcut class &lt;code&gt;Prophecy\Argument&lt;/code&gt;, which you can use to create tokens like that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Prophecy\Argument;&#xA;&#xA;$user-&amp;gt;setName(Argument::exact(&#39;everzet&#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ExactValueToken&lt;/code&gt; is not very useful in our case as it forced us to hardcode the username. That&#39;s why Prophecy comes bundled with a bunch of other tokens:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IdenticalValueToken&lt;/code&gt; or &lt;code&gt;Argument::is($value)&lt;/code&gt; - checks that the argument is identical to a specific value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ExactValueToken&lt;/code&gt; or &lt;code&gt;Argument::exact($value)&lt;/code&gt; - checks that the argument matches a specific value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeToken&lt;/code&gt; or &lt;code&gt;Argument::type($typeOrClass)&lt;/code&gt; - checks that the argument matches a specific type or classname&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ObjectStateToken&lt;/code&gt; or &lt;code&gt;Argument::which($method, $value)&lt;/code&gt; - checks that the argument method returns a specific value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CallbackToken&lt;/code&gt; or &lt;code&gt;Argument::that(callback)&lt;/code&gt; - checks that the argument matches a custom callback&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AnyValueToken&lt;/code&gt; or &lt;code&gt;Argument::any()&lt;/code&gt; - matches any argument&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AnyValuesToken&lt;/code&gt; or &lt;code&gt;Argument::cetera()&lt;/code&gt; - matches any arguments to the rest of the signature&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;StringContainsToken&lt;/code&gt; or &lt;code&gt;Argument::containingString($value)&lt;/code&gt; - checks that the argument contains a specific string value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;InArrayToken&lt;/code&gt; or &lt;code&gt;Argument::in($array)&lt;/code&gt; - checks if value is in array&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NotInArrayToken&lt;/code&gt; or &lt;code&gt;Argument::notIn($array)&lt;/code&gt; - checks if value is not in array&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And you can add even more by implementing &lt;code&gt;TokenInterface&lt;/code&gt; with your own custom classes.&lt;/p&gt; &#xA;&lt;p&gt;So, let&#39;s refactor our initial &lt;code&gt;{set,get}Name()&lt;/code&gt; logic with argument tokens:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Prophecy\Argument;&#xA;&#xA;$user-&amp;gt;getName()-&amp;gt;willReturn(null);&#xA;&#xA;// For PHP 5.4&#xA;$user-&amp;gt;setName(Argument::type(&#39;string&#39;))-&amp;gt;will(function ($args) {&#xA;    $this-&amp;gt;getName()-&amp;gt;willReturn($args[0]);&#xA;});&#xA;&#xA;// For PHP 5.3&#xA;$user-&amp;gt;setName(Argument::type(&#39;string&#39;))-&amp;gt;will(function ($args, $user) {&#xA;    $user-&amp;gt;getName()-&amp;gt;willReturn($args[0]);&#xA;});&#xA;&#xA;// Or&#xA;$user-&amp;gt;setName(Argument::type(&#39;string&#39;))-&amp;gt;will(function ($args) use ($user) {&#xA;    $user-&amp;gt;getName()-&amp;gt;willReturn($args[0]);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it. Now our &lt;code&gt;{set,get}Name()&lt;/code&gt; prophecy will work with any string argument provided to it. We&#39;ve just described how our stub object should behave, even though the original object could have no behavior whatsoever.&lt;/p&gt; &#xA;&lt;p&gt;One last bit about arguments now. You might ask, what happens in case of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Prophecy\Argument;&#xA;&#xA;$user-&amp;gt;getName()-&amp;gt;willReturn(null);&#xA;&#xA;// For PHP 5.4&#xA;$user-&amp;gt;setName(Argument::type(&#39;string&#39;))-&amp;gt;will(function ($args) {&#xA;    $this-&amp;gt;getName()-&amp;gt;willReturn($args[0]);&#xA;});&#xA;&#xA;// For PHP 5.3&#xA;$user-&amp;gt;setName(Argument::type(&#39;string&#39;))-&amp;gt;will(function ($args, $user) {&#xA;    $user-&amp;gt;getName()-&amp;gt;willReturn($args[0]);&#xA;});&#xA;&#xA;// Or&#xA;$user-&amp;gt;setName(Argument::type(&#39;string&#39;))-&amp;gt;will(function ($args) use ($user) {&#xA;    $user-&amp;gt;getName()-&amp;gt;willReturn($args[0]);&#xA;});&#xA;&#xA;$user-&amp;gt;setName(Argument::any())-&amp;gt;will(function () {&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nothing. Your stub will continue behaving the way it did before. That&#39;s because of how arguments wildcarding works. Every argument token type has a different score level, which wildcard then uses to calculate the final arguments match score and use the method prophecy promise that has the highest score. In this case, &lt;code&gt;Argument::type()&lt;/code&gt; in case of success scores &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;Argument::any()&lt;/code&gt; scores &lt;code&gt;3&lt;/code&gt;. So the type token wins, as does the first &lt;code&gt;setName()&lt;/code&gt; method prophecy and its promise. The simple rule of thumb - more precise token always wins.&lt;/p&gt; &#xA;&lt;h4&gt;Getting stub objects&lt;/h4&gt; &#xA;&lt;p&gt;Ok, now we know how to define our prophecy method promises, let&#39;s get our stub from it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$stub = $prophecy-&amp;gt;reveal();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you might see, the only difference between how we get dummies and stubs is that with stubs we describe every object conversation instead of just agreeing with &lt;code&gt;null&lt;/code&gt; returns (object being &lt;em&gt;dummy&lt;/em&gt;). As a matter of fact, after you define your first promise (method call), Prophecy will force you to define all the communications - it throws the &lt;code&gt;UnexpectedCallException&lt;/code&gt; for any call you didn&#39;t describe with object prophecy before calling it on a stub.&lt;/p&gt; &#xA;&lt;h3&gt;Mocks&lt;/h3&gt; &#xA;&lt;p&gt;Now we know how to define doubles without behavior (dummies) and doubles with behavior, but no expectations (stubs). What&#39;s left is doubles for which we have some expectations. These are called mocks and in Prophecy they look almost exactly the same as stubs, except that they define &lt;em&gt;predictions&lt;/em&gt; instead of &lt;em&gt;promises&lt;/em&gt; on method prophecies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$entityManager-&amp;gt;flush()-&amp;gt;shouldBeCalled();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Predictions&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;shouldBeCalled()&lt;/code&gt; method here assigns &lt;code&gt;CallPrediction&lt;/code&gt; to our method prophecy. Predictions are a delayed behavior check for your prophecies. You see, during the entire lifetime of your doubles, Prophecy records every single call you&#39;re making against it inside your code. After that, Prophecy can use this collected information to check if it matches defined predictions. You can assign predictions to method prophecies using the &lt;code&gt;MethodProphecy::should(PredictionInterface $prediction)&lt;/code&gt; method. As a matter of fact, the &lt;code&gt;shouldBeCalled()&lt;/code&gt; method we used earlier is just a shortcut to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$entityManager-&amp;gt;flush()-&amp;gt;should(new Prophecy\Prediction\CallPrediction());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It checks if your method of interest (that matches both the method name and the arguments wildcard) was called 1 or more times. If the prediction failed then it throws an exception. When does this check happen? Whenever you call &lt;code&gt;checkPredictions()&lt;/code&gt; on the main Prophet object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$prophet-&amp;gt;checkPredictions();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In PHPUnit, you would want to put this call into the &lt;code&gt;tearDown()&lt;/code&gt; method. If no predictions are defined, it would do nothing. So it won&#39;t harm to call it after every test.&lt;/p&gt; &#xA;&lt;p&gt;There are plenty more predictions you can play with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CallPrediction&lt;/code&gt; or &lt;code&gt;shouldBeCalled()&lt;/code&gt; - checks that the method has been called 1 or more times&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NoCallsPrediction&lt;/code&gt; or &lt;code&gt;shouldNotBeCalled()&lt;/code&gt; - checks that the method has not been called&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CallTimesPrediction&lt;/code&gt; or &lt;code&gt;shouldBeCalledTimes($count)&lt;/code&gt; - checks that the method has been called &lt;code&gt;$count&lt;/code&gt; times&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CallbackPrediction&lt;/code&gt; or &lt;code&gt;should($callback)&lt;/code&gt; - checks the method against your own custom callback&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Of course, you can always create your own custom prediction any time by implementing &lt;code&gt;PredictionInterface&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Spies&lt;/h3&gt; &#xA;&lt;p&gt;The last bit of awesomeness in Prophecy is out-of-the-box spies support. As I said in the previous section, Prophecy records every call made during the double&#39;s entire lifetime. This means you don&#39;t need to record predictions in order to check them. You can also do it manually by using the &lt;code&gt;MethodProphecy::shouldHave(PredictionInterface $prediction)&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$em = $prophet-&amp;gt;prophesize(&#39;Doctrine\ORM\EntityManager&#39;);&#xA;&#xA;$controller-&amp;gt;createUser($em-&amp;gt;reveal());&#xA;&#xA;$em-&amp;gt;flush()-&amp;gt;shouldHaveBeenCalled();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Such manipulation with doubles is called spying. And with Prophecy it just works.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Can I call the original methods on a prophesized class?&lt;/h3&gt; &#xA;&lt;p&gt;Prophecy does not support calling the original methods on a phrophesized class. If you find yourself needing to mock some methods of a class while calling the original version of other methods, it&#39;s likely a sign that your class violates the &lt;a href=&#34;https://en.wikipedia.org/wiki/Single-responsibility_principle&#34;&gt;single-responsibility principle&lt;/a&gt; and should be refactored.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Cacti/cacti</title>
    <updated>2022-12-10T01:34:55Z</updated>
    <id>tag:github.com,2022-12-10:/Cacti/cacti</id>
    <link href="https://github.com/Cacti/cacti" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cacti ™&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cacti ™&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/Cacti/cacti&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Cacti/cacti.svg?branch=develop&#34; alt=&#34;Build Status - Develop&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://opensource.box.com/badges&#34;&gt;&lt;img src=&#34;http://opensource.box.com/badges/active.svg?sanitize=true&#34; alt=&#34;Project Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://translate.cacti.net&#34; title=&#34;Translation Status&#34;&gt;&lt;img src=&#34;https://translate.cacti.net/widgets/cacti/-/core/svg-badge.svg?sanitize=true&#34; alt=&#34;Translation Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://isitmaintained.com/project/cacti/cacti&#34; title=&#34;Average time to resolve an issue&#34;&gt;&lt;img src=&#34;http://isitmaintained.com/badge/resolution/cacti/cacti.svg?sanitize=true&#34; alt=&#34;Average time to resolve an issue&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://isitmaintained.com/project/cacti/cacti&#34; title=&#34;Percentage of issues still open&#34;&gt;&lt;img src=&#34;http://isitmaintained.com/badge/open/cacti/cacti.svg?sanitize=true&#34; alt=&#34;Percentage of open issues&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Welcome to the Cacti GitHub Site!&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;We currently have two functioning versions of Cacti on this site, and several Cacti plugins supported by The Cacti Group. Our current long lived version of Cacti in the &lt;code&gt;1.2.x&lt;/code&gt; branch. The current release version of this branch is Cacti 1.2.22. Sometime in December 2022, we will release Cacti 1.2.23.&lt;/p&gt; &#xA;&lt;p&gt;This pending maintenance release has several bugs fixes, and significantly more welcomed feature enhancements. You can review the CHANGELOG for the &lt;code&gt;1.2.x&lt;/code&gt; branch for more information on that.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, we have the &lt;code&gt;develop&lt;/code&gt; branch. This is now an active Development Branch. In this branch, we as a team have re-grouped and are introducing several new features. We hope to be able to deliver a Christmas present for Cacti enthusiasts, which will be a Cacti 1.3.0-beta release. If you want to get involved earlier, you can simply download the development release and knock yourselves out. The 1.3.0 release will include everything in the pending 1.2.23 release, as well as several additional features from our roadmap.&lt;/p&gt; &#xA;&lt;p&gt;System requirements vary from Cacti point release to point release. The matrix below documents the minimum tool levels for each version. With our source distribution, all the vendor included packages are pre-packeged and tested by the Cacti group, so there is no reason to use package management tools to install those dependencies.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Dependency&lt;/th&gt; &#xA;   &lt;th&gt;Cacti 1.2.x&lt;/th&gt; &#xA;   &lt;th&gt;Cacti 1.3.x&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MariaDB&lt;/td&gt; &#xA;   &lt;td&gt;5.5+&lt;/td&gt; &#xA;   &lt;td&gt;10.2.x+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MySQL&lt;/td&gt; &#xA;   &lt;td&gt;5.5+&lt;/td&gt; &#xA;   &lt;td&gt;5.7+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;PHP&lt;/td&gt; &#xA;   &lt;td&gt;5.4+&lt;/td&gt; &#xA;   &lt;td&gt;8.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;RRDtool&lt;/td&gt; &#xA;   &lt;td&gt;1.4+&lt;/td&gt; &#xA;   &lt;td&gt;1.8+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Net-SNMP&lt;/td&gt; &#xA;   &lt;td&gt;5.5+&lt;/td&gt; &#xA;   &lt;td&gt;5.8+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For Cacti 1.2.x, it is reasonable to run with RHEL/CentOS 7 or equivalent. However, for Cacti 1.3.x, it would be better to run on RHEL/CentOS/Rocky 8 or equivalent as this OS version makes PHP8.0 available via a DNF Stream.&lt;/p&gt; &#xA;&lt;p&gt;However, if you wish to run Cacti 1.3.x on the RHEL/CentOS 7 distribution you can do so if you use the REMI distributions of PHP. You will also in this case have to build RRDtool 1.8+ from source, which is strait forward.&lt;/p&gt; &#xA;&lt;p&gt;In the sections below, you can find some important first steps before installing either the Cacti 1.2.x version of the pending Cacti 1.3.x version. Good luck and enjoy Cacti.&lt;/p&gt; &#xA;&lt;h1&gt;Running Cacti from the &lt;code&gt;develop&lt;/code&gt; Branch&lt;/h1&gt; &#xA;&lt;h2&gt;IMPORTANT&lt;/h2&gt; &#xA;&lt;p&gt;When using source or by downloading the code directly from the repository, it is important to note that periodically, you may have to return the database upgrade cli script to bring in new columns. You can use the --forcever=1.2.22 option to assume you are upgrading from an earlier cacti version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;php -q upgrade_database.php --forcever=1.2.22&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you experience SQL errors in your Cacti log, please open a case in our Cacti issue tracker here.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrading from Pre-Cacti 1.x Releases&lt;/h2&gt; &#xA;&lt;p&gt;When Cacti was first developed nearly 20 years ago, MySQL was not as mature as it is now. When The Cacti Group went about engineering Cacti 1.x, a decision was made to force users to use the InnoDB storage engine for many of the Tables. This was done as the InnoDB storage engine provides a better user experience when your web site has several concurrent logins. Though a little slower, it also provides greater resiliency for the developers.&lt;/p&gt; &#xA;&lt;p&gt;With that said, there are several changes that you MUST perform to MySQL/MariaDB before you upgrade, and a service restart is required. Depending on your release of MariaDB or MySQL, the following settings will either be required, or already enabled as default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[mysqld]&#xA;&#xA;# required for multiple language support&#xA;character-set-server = utf8mb4&#xA;collation-server = utf8mb4_unicode_ci&#xA;&#xA;# Memory tunables - Cacti provides recommendations at upgrade time&#xA;max_heap_table_size = XXX&#xA;max_allowed_packet = 500M&#xA;tmp_table_size = XXX&#xA;join_buffer_size = XXX&#xA;sort_buffer_size = XXX&#xA;&#xA;# important for compatibility&#xA;sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER&#xA;&#xA;# innodb settings - Cacti provides recommendations at upgrade time&#xA;innodb_buffer_pool_instances = XXX&#xA;innodb_flush_log_at_trx_commit = 2&#xA;innodb_buffer_pool_size = XXX&#xA;innodb_sort_buffer_size = XXX&#xA;innodb_doublewrite = ON&#xA;&#xA;# required&#xA;innodb_file_per_table = ON&#xA;innodb_file_format = Barracuda&#xA;innodb_large_prefix = 1&#xA;&#xA;# not all version support&#xA;innodb_flush_log_at_timeout = 3&#xA;&#xA;# for SSD&#39;s/NVMe&#xA;innodb_read_io_threads = 32&#xA;innodb_write_io_threads = 16&#xA;innodb_io_capacity = 10000&#xA;innodb_io_capacity_max = 20000&#xA;innodb_flush_method = O_DIRECT&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;em&gt;required&lt;/em&gt; settings are very important. Otherwise, you will encounter issues upgrading. The settings with XXX, Cacti will provide a recommendation at upgrade time. It is not out of the ordinary to have to restart MySQL/MariaDB during the upgrade to tune these settings. Please make special note of this before you begin your upgrade.&lt;/p&gt; &#xA;&lt;p&gt;Before you upgrade, you should make these required changes, then restart MySQL/MariaDB. After that, you can save yourself some time and potential errors by running the following scripts (assuming you are using bash):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;for table in `mysql -e &#34;SELECT TABLE_NAME FROM information_schema.TABLES WHERE table_schema=&#39;cacti&#39; AND engine!=&#39;MEMORY&#39;&#34; cacti | grep -v TABLE_NAME`;&#xA;do&#xA;   echo &#34;Converting $table&#34;;&#xA;   mysql -e &#34;ALTER TABLE $table ENGINE=InnoDB ROW_FORMAT=Dynamic CHARSET=utf8mb4&#34; cacti;&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will convert any tables that are either InnoDB or MyISAM to Barracuda file format, dynamic row format and utf8mb4. Note, that if you have been using MySQL or MariaDB without innodb_file_per_table set to on, you might be better in backing up your database, resetting InnoDB by removing your ib* files in the /var/lib/mysql directory, and after which restoring your database and MySQL/MariaDB tables and permissions. Before you take such a step, you should always practice on a test server until you feel comfortable with the change.&lt;/p&gt; &#xA;&lt;p&gt;Good luck, and enjoy Cacti!&lt;/p&gt; &#xA;&lt;h2&gt;Running Database Upgrade Script&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo -u cacti php -q cli/upgrade_database.php --forcever=`cat include/cacti_version`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Updating Cacti Version in Database&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;update version set cacti = &#39;1.1.38&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; Change the above version to the correct version or risk the installer upgrading from a previous version.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;About Cacti&lt;/h1&gt; &#xA;&lt;p&gt;Cacti is a complete network graphing solution designed to harness the power of RRDtool&#39;s data storage and graphing functionality providing the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Remote and local data collectors&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Device discovery&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automation of device and graph creation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Graph and device templating&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Custom data collection methods&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;User, group and domain access controls&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of this is wrapped in an intuitive, easy to use interface that makes sense for both LAN-sized installations and complex networks with thousands of devices.&lt;/p&gt; &#xA;&lt;p&gt;Developed in the early 2000s by Ian Berry as a high school project, it has been used by thousands of companies and enthusiasts to monitor and manage their Enterprise Networks and Data Centers.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Cacti should be able to run on any Linux, UNIX, or Windows based operating system with the following requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;PHP 7.4+&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MySQL 5.6+&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RRDtool 1.3+, 1.5+ recommended&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NET-SNMP 5.5+&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Web Server with PHP support&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;PHP Must also be compiled as a standalone cgi or cli binary. This is required for data gathering via cron.&lt;/p&gt; &#xA;&lt;h3&gt;php-snmp&lt;/h3&gt; &#xA;&lt;p&gt;We mark the php-snmp module as optional. So long as you are not using ipv6 devices, or using snmpv3 engine IDs or contexts, then using php-snmp should be safe. Otherwise, you should consider uninstalling the php-snmp module as it will create problems. We are aware of the problem with php-snmp and looking to get involved in the php project to resolve these issues.&lt;/p&gt; &#xA;&lt;h3&gt;RRDtool&lt;/h3&gt; &#xA;&lt;p&gt;RRDtool is available in multiple versions and a majority of them are supported by Cacti. Please remember to confirm your Cacti settings for the RRDtool version if you having problem rendering graphs.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation is available with the Cacti releases and also available for viewing on the &lt;a href=&#34;https://github.com/Cacti/documentation/raw/develop/README.md&#34;&gt;Documentation Repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Check out the main &lt;a href=&#34;http://www.cacti.net&#34;&gt;Cacti&lt;/a&gt; web site for downloads, change logs, release notes and more!&lt;/p&gt; &#xA;&lt;h3&gt;Community forums&lt;/h3&gt; &#xA;&lt;p&gt;Given the large scope of Cacti, the forums tend to generate a respectable amount of traffic. Doing your part in answering basic questions goes a long way since we cannot be everywhere at once. Contribute to the Cacti community by participating on the &lt;a href=&#34;http://forums.cacti.net&#34;&gt;Cacti Community Forums&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;GitHub Documentation&lt;/h3&gt; &#xA;&lt;p&gt;Get involved in creating and editing Cacti Documentation! Fork, change and submit a pull request to help improve the documentation on &lt;a href=&#34;https://github.com/cacti/documentation&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;GitHub Development&lt;/h3&gt; &#xA;&lt;p&gt;Get involved in development of Cacti! Join the developers and community on &lt;a href=&#34;https://github.com/cacti&#34;&gt;GitHub&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Functionality&lt;/h2&gt; &#xA;&lt;h3&gt;Data Sources&lt;/h3&gt; &#xA;&lt;p&gt;Cacti handles the gathering of data through the concept of data sources. Data sources utilize input methods to gather data from devices, hosts, databases, scripts, etc... The possibilities are endless as to the nature of the data you are able to collect. Data sources are the direct link to the underlying RRD files; how data is stored within RRD files and how data is retrieved from RRD files.&lt;/p&gt; &#xA;&lt;h3&gt;Graphs&lt;/h3&gt; &#xA;&lt;p&gt;Graphs, the heart and soul of Cacti, are created by RRDtool using the defined data sources definition.&lt;/p&gt; &#xA;&lt;h3&gt;Templating&lt;/h3&gt; &#xA;&lt;p&gt;Bringing it all together, Cacti uses and extensive template system that allows for the creation and consumption of portable templates. Graph, data source, and RRA templates allow for the easy creation of graphs and data sources out of the box. Along with the Cacti community support, templates have become the standard way to support graphing any number of devices in use in today computing and networking environments.&lt;/p&gt; &#xA;&lt;h3&gt;Data Collection (The Poller)&lt;/h3&gt; &#xA;&lt;p&gt;Local and remote data collection support with the ability to set collection intervals. Check out &lt;em&gt;&lt;strong&gt;Data Source Profile&lt;/strong&gt;&lt;/em&gt; with in Cacti for more information. Data Source Profiles can be applied to graphs at creation time or at the data template level.&lt;/p&gt; &#xA;&lt;p&gt;Remote data collection has been made easy through replication of resources to remote data collectors. Even when connectivity to the main Cacti installation is lost from remote data collector, it will store collected data until connectivity is restored. Remote data collection only requires MySQL and HTTP/HTTPS access back to the main Cacti installation location.&lt;/p&gt; &#xA;&lt;h3&gt;Network Discovery and Automation&lt;/h3&gt; &#xA;&lt;p&gt;Cacti provides administrators a series of network automation functionality in order to reduce the time and effort it takes to setup and manage devices.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Multiple definable network discovery rules&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automation templates that specify how devices are configured&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Plugin Framework&lt;/h3&gt; &#xA;&lt;p&gt;Cacti is more than a network monitoring system, it is an operations framework that allows the extension and augmentation of Cacti functionality. The Cacti Group continues to maintain an assortment of plugins. If you are looking to add features to Cacti, there is quite a bit of reference material to choose from on GitHub.&lt;/p&gt; &#xA;&lt;h3&gt;Dynamic Graph Viewing Experience&lt;/h3&gt; &#xA;&lt;p&gt;Cacti allows for many runtime augmentations while viewing graphs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Dynamically loaded tree and graph view&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Searching by string, graph and template types&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Viewing augmentation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Simple time span adjustments&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Convenient sliding time window buttons&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Single click realtime graph option&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Easy graph export to csv&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RRA view with just a click&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;User, Groups and Permissions&lt;/h3&gt; &#xA;&lt;p&gt;Support for per user and per group permissions at a per realm (area of Cacti), per graph, per graph tree, per device, etc... The permission model in Cacti is role based access control (RBAC) to allow for flexible assignment of permissions. Support for enforcement of password complexity, password age and changing of expired passwords.&lt;/p&gt; &#xA;&lt;h2&gt;RRDtool Graph Options&lt;/h2&gt; &#xA;&lt;p&gt;Cacti supports most RRDtool graphing abilities including:&lt;/p&gt; &#xA;&lt;h3&gt;Graph Options&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Full right axis&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Shift&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Dash and dash offset&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Alt y-grid&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No grid fit&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Units length&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Tab width&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Dynamic labels&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rules legend&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Legend position&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Graph Items&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;VDEFs&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stacked lines&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;User definable line widths&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Text alignment&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Copyright (c) 2004-2022 - The Cacti Group, Inc.&lt;/p&gt;</summary>
  </entry>
</feed>