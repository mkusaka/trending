<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-11T01:36:02Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>square/pjson</title>
    <updated>2022-11-11T01:36:02Z</updated>
    <id>tag:github.com,2022-11-11:/square/pjson</id>
    <link href="https://github.com/square/pjson" rel="alternate"></link>
    <summary type="html">&lt;p&gt;JSON &lt;=&gt; PHP8+ objects serialization / deserialization library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;A &lt;strong&gt;simple&lt;/strong&gt; library for JSON to PHP Objects conversions&lt;/p&gt; &#xA;&lt;p&gt;Often times, we interact with an API, or data source that returns JSON. PHP only offers the possibility to deserialize that json into an array or objects of type &lt;code&gt;stdClass&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library helps deserializing JSON into actual objects of custom defined classes. It does so by using PHP8&#39;s attributes on class properties.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Simple serialization of a class&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Square\Pjson\Json;&#xA;use Square\Pjson\JsonSerialize;&#xA;&#xA;class Schedule&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    protected int $start;&#xA;&#xA;    #[Json]&#xA;    protected int $end;&#xA;&#xA;    public function __construct(int $start, int $end)&#xA;    {&#xA;        $this-&amp;gt;start = $start;&#xA;        $this-&amp;gt;end = $end;&#xA;    }&#xA;}&#xA;&#xA;(new Schedule(1, 2))-&amp;gt;toJson();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Would yield the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;start&#34;: 1,&#xA;    &#34;end&#34;: 2&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then the reverse can be achieved via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Schedule::fromJsonString(&#39;{&#34;start&#34;:1,&#34;end&#34;:2}&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which would return an instance of class &lt;code&gt;Schedule&lt;/code&gt; with the properties set according to the JSON.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Names&lt;/h3&gt; &#xA;&lt;p&gt;The previous example can be made to use custom names in JSON instead of just the property name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Square\Pjson\Json;&#xA;use Square\Pjson\JsonSerialize;&#xA;&#xA;class Schedule&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json(&#39;begin&#39;)]&#xA;    protected int $start;&#xA;&#xA;    #[Json(&#39;stop&#39;)]&#xA;    protected int $end;&#xA;&#xA;    public function __construct(int $start, int $end)&#xA;    {&#xA;        $this-&amp;gt;start = $start;&#xA;        $this-&amp;gt;end = $end;&#xA;    }&#xA;}&#xA;&#xA;(new Schedule(1, 2))-&amp;gt;toJson();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would yield&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;begin&#34;: 1,&#xA;    &#34;stop&#34;: 2&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And deserializing with those new property names works just as before:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;dump(Schedule::fromJsonString(&#39;{&#34;begin&#34;:1,&#34;stop&#34;:2}&#39;));&#xA;&#xA;// ^ Schedule^ {#345&#xA;//   #start: 1&#xA;//   #end: 2&#xA;// }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Private / Protected&lt;/h3&gt; &#xA;&lt;p&gt;The visibility of a property does not matter. A private or protected property can be serialized / unserialized as well (see previous examples).&lt;/p&gt; &#xA;&lt;h3&gt;Property Path&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes the json format isn&#39;t exactly the PHP version we want to use. Say for example that the JSON we received for the previous schedule examples were to look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;data&#34;: {&#xA;        &#34;start&#34;: 1,&#xA;        &#34;end&#34;: 2&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By declaring our class json attributes as follows, we can still read those properties direclty into our class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Schedule&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json([&#39;data&#39;, &#39;start&#39;])]&#xA;    protected int $start;&#xA;&#xA;    #[Json([&#39;data&#39;, &#39;end&#39;])]&#xA;    protected int $end;&#xA;&#xA;    public function __construct(int $start, int $end)&#xA;    {&#xA;        $this-&amp;gt;start = $start;&#xA;        $this-&amp;gt;end = $end;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recursive serialize / deserialize&lt;/h3&gt; &#xA;&lt;p&gt;If we are working with a json structure that&#39;s a bit more complex, we will want to have properties be classes that can also be properly deserialized into.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;saturday&#34;: {&#xA;        &#34;start&#34;: 0,&#xA;        &#34;end&#34;: 2&#xA;    },&#xA;    &#34;sunday&#34;: {&#xA;        &#34;start&#34;: 0,&#xA;        &#34;end&#34;: 7&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following 2 PHP classes could work well with this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Schedule&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    protected int $start;&#xA;&#xA;    #[Json]&#xA;    protected int $end;&#xA;}&#xA;&#xA;class Weekend&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json(&#39;saturday&#39;)]&#xA;    protected Schedule $sat;&#xA;    #[Json(&#39;sunday&#39;)]&#xA;    protected Schedule $sun;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Arrays&lt;/h3&gt; &#xA;&lt;p&gt;When working with an array of items where each item should be of a given class, we need to tell pjson about the target type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;days&#34;: [&#xA;        {&#xA;            &#34;start&#34;: 0,&#xA;            &#34;end&#34;: 2&#xA;        },&#xA;        {&#xA;            &#34;start&#34;: 0,&#xA;            &#34;end&#34;: 2&#xA;        },&#xA;        {&#xA;            &#34;start&#34;: 0,&#xA;            &#34;end&#34;: 2&#xA;        },&#xA;        {&#xA;            &#34;start&#34;: 0,&#xA;            &#34;end&#34;: 7&#xA;        }&#xA;    ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With Schedule still defined as before, we&#39;d define a week like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Week&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json(type: Schedule::class)]&#xA;    protected array $days;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would also work with a map if the json were like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;days&#34;: {&#xA;        &#34;monday&#34;: {&#xA;            &#34;start&#34;: 0,&#xA;            &#34;end&#34;: 2&#xA;        },&#xA;        &#34;wednesday&#34;: {&#xA;            &#34;start&#34;: 0,&#xA;            &#34;end&#34;: 2&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the resulting PHP object would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Week^ {#353&#xA;  #days: array:2 [&#xA;    &#34;monday&#34; =&amp;gt; Schedule^ {#344&#xA;      #start: 0&#xA;      #end: 2&#xA;    }&#xA;    &#34;wednesday&#34; =&amp;gt; Schedule^ {#343&#xA;      #start: 0&#xA;      #end: 2&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Polymorphic deserialization&lt;/h3&gt; &#xA;&lt;p&gt;Say you have 2 classes that extend a base class. You might receive those as part of a collection and don&#39;t know ahead of time if you&#39;ll be dealing with one or the other. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;abstract class CatalogObject&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    protected $id;&#xA;&#xA;    #[Json]&#xA;    protected string $type;&#xA;}&#xA;&#xA;class CatalogCategory extends CatalogObject&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json(&#39;parent_category_id&#39;)]&#xA;    protected string $parentCategoryId;&#xA;}&#xA;&#xA;class CatalogItem extends CatalogObject&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    protected string $name;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can implement the &lt;code&gt;fromJsonData(array $array) : static&lt;/code&gt; on &lt;code&gt;CatalogObject&lt;/code&gt; to discriminate based on the received data and return the correct serialization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;abstract class CatalogObject&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    protected $id;&#xA;&#xA;    #[Json]&#xA;    protected string $type;&#xA;&#xA;    public static function fromJsonData($jd): static&#xA;    {&#xA;        $t = $jd[&#39;type&#39;];&#xA;&#xA;        return match ($t) {&#xA;            &#39;category&#39; =&amp;gt; CatalogCategory::fromJsonData($jd),&#xA;            &#39;item&#39; =&amp;gt; CatalogItem::fromJsonData($jd),&#xA;        };&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;WARNING:&lt;/strong&gt; Make sure that each of the subclasses directly &lt;code&gt;use JsonSerialize&lt;/code&gt;. Otherwise when they call &lt;code&gt;::fromJsonData&lt;/code&gt;, they would call the parent on &lt;code&gt;CatalogObject&lt;/code&gt; leading to infinite recursion.&lt;/p&gt; &#xA;&lt;p&gt;With this in place, we can do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$jsonCat = &#39;{&#34;type&#34;: &#34;category&#34;, &#34;id&#34;: &#34;123&#34;, &#34;parent_category_id&#34;: &#34;456&#34;}&#39;;&#xA;$c = CatalogObject::fromJsonString($jsonCat);&#xA;$this-&amp;gt;assertEquals(CatalogCategory::class, get_class($c));&#xA;&#xA;$jsonItem = &#39;{&#34;type&#34;: &#34;item&#34;, &#34;id&#34;: &#34;123&#34;, &#34;name&#34;: &#34;Sandals&#34;}&#39;;&#xA;$c = CatalogObject::fromJsonString($jsonItem);&#xA;$this-&amp;gt;assertEquals(CatalogItem::class, get_class($c));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lists&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re dealing with a list of things to deserialize, you can call &lt;code&gt;MyClass::listFromJsonString($json)&lt;/code&gt; or &lt;code&gt;MyClass::listfromJsonData($array)&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Schedule::listFromJsonString(&#39;[&#xA;    {&#xA;        &#34;schedule_start&#34;: 1,&#xA;        &#34;schedule_end&#34;: 2&#xA;    },&#xA;    {&#xA;        &#34;schedule_start&#34;: 11,&#xA;        &#34;schedule_end&#34;: 22&#xA;    },&#xA;    {&#xA;        &#34;schedule_start&#34;: 111,&#xA;        &#34;schedule_end&#34;: 222&#xA;    }&#xA;]&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;yields the same as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;[&#xA;    new Schedule(1, 2),&#xA;    new Schedule(11, 22),&#xA;    new Schedule(111, 222),&#xA;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Initial path&lt;/h3&gt; &#xA;&lt;p&gt;Somteimes the JSON you care about will be nested under a property but you don&#39;t want / need to model the outer layer. For this you can pass a &lt;code&gt;$path&lt;/code&gt; to the deserializing methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Schedule::fromJsonString(&#39;{&#xA;    &#34;data&#34;: {&#xA;        &#34;schedule_start&#34;: 1,&#xA;        &#34;schedule_end&#34;: 2&#xA;    }&#xA;}&#39;, path: &#39;data&#39;);&#xA;&#xA;Schedule::fromJsonString(&#39;{&#xA;    &#34;data&#34;: {&#xA;        &#34;main&#34;: {&#xA;            &#34;schedule_start&#34;: 1,&#xA;            &#34;schedule_end&#34;: 2&#xA;        }&#xA;    }&#xA;}&#39;, path: [&#39;data&#39;, &#39;main&#39;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enums&lt;/h3&gt; &#xA;&lt;p&gt;Backed enums are supported out of the box in PHP 8.1&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Widget&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    public Status $status;&#xA;}&#xA;&#xA;enum Status : string&#xA;{&#xA;    case ON = &#39;ON&#39;;&#xA;    case OFF = &#39;OFF&#39;;&#xA;}&#xA;$w = new Widget;&#xA;$w-&amp;gt;status = Status::ON;&#xA;&#xA;$w-&amp;gt;toJson(); // {&#34;status&#34;: &#34;ON&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And regular enums can be supported via the &lt;code&gt;JsonSerialize&lt;/code&gt; trait or the &lt;code&gt;JsonDataSerializable&lt;/code&gt; interface&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Widget&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    public Size $size;&#xA;}&#xA;&#xA;enum Size&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    case BIG;&#xA;    case SMALL;&#xA;&#xA;    public static function fromJsonData($d, array|string $path = []): static&#xA;    {&#xA;        return match ($d) {&#xA;            &#39;BIG&#39; =&amp;gt; self::BIG,&#xA;            &#39;SMALL&#39; =&amp;gt; self::SMALL,&#xA;            &#39;big&#39; =&amp;gt; self::BIG,&#xA;            &#39;small&#39; =&amp;gt; self::SMALL,&#xA;        };&#xA;    }&#xA;&#xA;    public function toJsonData()&#xA;    {&#xA;        return strtolower($this-&amp;gt;name);&#xA;    }&#xA;}&#xA;&#xA;$w = new Widget;&#xA;$w-&amp;gt;size = Size::BIG;&#xA;&#xA;$w-&amp;gt;toJson(); // {&#34;status&#34;: &#34;big&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scalar &amp;lt;=&amp;gt; Class&lt;/h3&gt; &#xA;&lt;p&gt;In some cases, you might want a scalar value to become a PHP object once deserialized and vice-versa. For example, a &lt;code&gt;BigInt&lt;/code&gt; class could hold an int as a string and represent it as a string when serialized to JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Stats&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    public BigInt $count;&#xA;}&#xA;&#xA;class BigInt implements JsonDataSerializable&#xA;{&#xA;    public function __construct(&#xA;        protected string $value,&#xA;    ) {&#xA;    }&#xA;&#xA;    public static function fromJsonData($jd, array|string $path = []) : static&#xA;    {&#xA;        return new BigInt($jd);&#xA;    }&#xA;&#xA;    public function toJsonData()&#xA;    {&#xA;        return $this-&amp;gt;value;&#xA;    }&#xA;}&#xA;&#xA;$stats = new Stats;&#xA;$stats-&amp;gt;count = new BigInt(&#34;123456789876543234567898765432345678976543234567876543212345678765432&#34;);&#xA;$stats-&amp;gt;toJson(); // {&#34;count&#34;:&#34;123456789876543234567898765432345678976543234567876543212345678765432&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use with PHPStan&lt;/h2&gt; &#xA;&lt;p&gt;Using this library, you may have properties that don&#39;t appear to be read from or written to anywhere in your code, but are purely used for JSON serialization. PHPStan will complain about these issues, but you can help PHPStan understand that this is expected behavior by adding this library&#39;s extension in your &lt;code&gt;phpstan.neon&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-neon&#34;&gt;includes:&#xA;  - vendor/square/pjson/extension.neon&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Laravel Integration&lt;/h2&gt; &#xA;&lt;h3&gt;via castable&lt;/h3&gt; &#xA;&lt;p&gt;If you wish to cast Eloquent model attributes to classes via Pjson, you might do so with the provided casting utilities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Illuminate\Contracts\Database\Eloquent\Castable;&#xA;use Square\Pjson\Json;&#xA;use Square\Pjson\JsonSerialize;&#xA;use Square\Pjson\Integrations\Laravel\JsonCastable;&#xA;&#xA;class Schedule implements Castable // implement the laravel interface&#xA;{&#xA;    use JsonSerialize;&#xA;    use JsonCastable; // use the provided Pjson trait&#xA;&#xA;    #[Json]&#xA;    protected int $start;&#xA;&#xA;    #[Json]&#xA;    protected int $end;&#xA;&#xA;    public function __construct(int $start, int $end)&#xA;    {&#xA;        $this-&amp;gt;start = $start;&#xA;        $this-&amp;gt;end = $end;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in your Eloquent model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$casts = [&#xA;    &#39;schedule&#39; =&amp;gt; Schedule::class,&#xA;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;via cast arguments&lt;/h3&gt; &#xA;&lt;p&gt;Alternatively, you can simply use Laravel&#39;s cast arguments. In this case the &lt;code&gt;Schedule&lt;/code&gt; class stays the way it used to be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Square\Pjson\Json;&#xA;use Square\Pjson\JsonSerialize;&#xA;&#xA;class Schedule&#xA;{&#xA;    use JsonSerialize;&#xA;&#xA;    #[Json]&#xA;    protected int $start;&#xA;&#xA;    #[Json]&#xA;    protected int $end;&#xA;&#xA;    public function __construct(int $start, int $end)&#xA;    {&#xA;        $this-&amp;gt;start = $start;&#xA;        $this-&amp;gt;end = $end;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you provide the class target of the cast like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$casts = [&#xA;    &#39;schedule&#39; =&amp;gt; JsonCaster::class.&#39;:&#39;.Schedule::class,&#xA;];&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>composer-unused/composer-unused</title>
    <updated>2022-11-11T01:36:02Z</updated>
    <id>tag:github.com,2022-11-11:/composer-unused/composer-unused</id>
    <link href="https://github.com/composer-unused/composer-unused" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Show unused composer dependencies by scanning your code&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/composer-unused/composer-unused/main/art/logo.png&#34; width=&#34;450&#34; alt=&#34;composer-unused logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;composer-unused&lt;/h1&gt; &#xA;&lt;p&gt;A Composer tool to show unused Composer dependencies by scanning your code.&lt;/p&gt; &#xA;&lt;p&gt;Created by &lt;a href=&#34;https://twitter.com/icanhazstring&#34;&gt;Andreas Frömer&lt;/a&gt; and &lt;a href=&#34;https://github.com/composer-unused/composer-unused/graphs/contributors&#34;&gt;contributors&lt;/a&gt;, logo by &lt;a href=&#34;https://twitter.com/caneco&#34;&gt;Caneco&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/composer-unused/composer-unused&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/composer-unused/composer-unused/validate-code?label=build&amp;amp;style=flat-square&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/composer-unused/composer-unused&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/composer-unused/composer-unused/validate-phar?label=build-phar&amp;amp;style=flat-square&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/composer-unused/composer-unused/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/tag-date/composer-unused/composer-unused.svg?label=version&amp;amp;style=flat-square&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ If you want to use this tool as composer-plugin head over to &lt;a href=&#34;https://github.com/composer-unused/composer-unused-plugin&#34;&gt;composer-unused-plugin&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;When working in a big repository, you sometimes lose track of your required Composer packages. There may be so many packages you can&#39;t be sure if they are actually used or not.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, the &lt;code&gt;composer why&lt;/code&gt; command only gives you the information about why a package is installed in dependency to another package.&lt;/p&gt; &#xA;&lt;p&gt;How do we check whether the provided &lt;em&gt;symbols&lt;/em&gt; of a package are used in our code?&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;composer unused&lt;/code&gt; to the rescue!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/composer-unused/composer-unused/main/art/example.gif&#34; alt=&#34;example&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;⚠️ This tool heavily depends on certain versions of its dependencies. A &lt;strong&gt;local installation of this tool is not recommended&lt;/strong&gt; as it might not work as intended or can&#39;t be installed correctly. We do recommened you download the &lt;code&gt;.phar&lt;/code&gt; archive or use &lt;strong&gt;PHIVE&lt;/strong&gt; to install it locally.&lt;/p&gt; &#xA;&lt;h3&gt;PHAR (PHP Archive) (recommended)&lt;/h3&gt; &#xA;&lt;p&gt;Install via &lt;code&gt;phive&lt;/code&gt; or grab the latest &lt;code&gt;composer-unused.phar&lt;/code&gt; from the latest release:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;phive install composer-unused&#xA;curl -OL https://github.com/composer-unused/composer-unused/releases/latest/download/composer-unused.phar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Local&lt;/h3&gt; &#xA;&lt;p&gt;You can also install &lt;code&gt;composer-unused&lt;/code&gt; as a local &lt;strong&gt;development&lt;/strong&gt; dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;composer require --dev icanhazstring/composer-unused&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Depending on the kind of your installation the command might differ.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: Packages must be installed via &lt;code&gt;composer install&lt;/code&gt; or &lt;code&gt;composer update&lt;/code&gt; prior to running &lt;code&gt;composer-unused&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;PHAR&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;phar&lt;/code&gt; archive can be run directly in you project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;php composer-unused.phar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Local&lt;/h3&gt; &#xA;&lt;p&gt;Having &lt;code&gt;composer-unused&lt;/code&gt; as a local dependency you can run it using the shipped binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vendor/bin/composer-unused&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exclude folders and packages&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes you don&#39;t want to scan a certain directory or ignore a Composer package while scanning. In these cases, you can provide the &lt;code&gt;--excludeDir&lt;/code&gt; or the &lt;code&gt;--excludePackage&lt;/code&gt; option. These options accept multiple values as shown next:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;php composer-unused.phar --excludeDir=config --excludePackage=symfony/console&#xA;php composer-unused.phar \&#xA;    --excludeDir=bin \&#xA;    --excludeDir=config \&#xA;    --excludePackage=symfony/assets \&#xA;    --excludePackage=symfony/console&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Make sure the package is named exactly as in your &lt;code&gt;composer.json&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can configure composer-unused by placing a &lt;code&gt;composer-unused.php&lt;/code&gt; beside the projects &lt;code&gt;composer.json&lt;/code&gt; This configuration can look something like this: &lt;a href=&#34;https://raw.githubusercontent.com/composer-unused/composer-unused/main/composer-unused.php&#34;&gt;composer-unused.php&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Ignore dependencies by name&lt;/h4&gt; &#xA;&lt;p&gt;To ignore dependencies by their name, add the following line to your configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$config-&amp;gt;addNamedFilter(NamedFilter::fromString(&#39;dependency/name&#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Ignore dependencies by pattern&lt;/h4&gt; &#xA;&lt;p&gt;To ignore dependencies by pattern, add the following line to your configuration&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$config-&amp;gt;addPatternFilter(PatternFilter::fromString(&#39;/dependency\/name/&#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can ignore multiple dependencies by a single organization using &lt;code&gt;PatternFilter&lt;/code&gt; e.g. &lt;code&gt;/symfony\/.*/&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Additional files to be parsed&lt;/h4&gt; &#xA;&lt;p&gt;Per default, &lt;code&gt;composer-unused&lt;/code&gt; is using the &lt;code&gt;composer.json&lt;/code&gt; autoload directive to determine where to look for files to parse. Sometimes dependencies don&#39;t have their composer.json correctly set up, or files get loaded in another way. Using this, you can define additional files on a per-dependency basis.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$config-&amp;gt;setAdditionalFilesFor(&#39;dependency/name&#39;, [&amp;lt;list-of-file-paths&amp;gt;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;Please have a look at &lt;a href=&#34;https://raw.githubusercontent.com/composer-unused/composer-unused/main/CHANGELOG.md&#34;&gt;&lt;code&gt;CHANGELOG.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please have a look at &lt;a href=&#34;https://raw.githubusercontent.com/composer-unused/composer-unused/main/CONTRIBUTING.md&#34;&gt;&lt;code&gt;CONTRIBUTING.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Please have a look at &lt;a href=&#34;https://raw.githubusercontent.com/composer-unused/composer-unused/main/CODE_OF_CONDUCT.md&#34;&gt;&lt;code&gt;CODE_OF_CONDUCT.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This package is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/composer-unused/composer-unused/main/LICENSE&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>