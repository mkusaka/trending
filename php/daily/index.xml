<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-14T01:37:55Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pusher/pusher-http-php</title>
    <updated>2022-12-14T01:37:55Z</updated>
    <id>tag:github.com,2022-12-14:/pusher/pusher-http-php</id>
    <link href="https://github.com/pusher/pusher-http-php" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PHP library for interacting with the Pusher Channels HTTP API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pusher Channels HTTP PHP Library&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pusher/pusher-http-php/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/pusher/pusher-http-php/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/pusher/pusher-php-server&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/pusher/pusher-php-server&#34; alt=&#34;Packagist Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/pusher/pusher-php-server&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/l/pusher/pusher-php-server&#34; alt=&#34;Packagist License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/pusher/pusher-php-server&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dm/pusher/pusher-php-server&#34; alt=&#34;Packagist Downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;PHP library for interacting with the Pusher Channels HTTP API.&lt;/p&gt; &#xA;&lt;p&gt;Register at &lt;a href=&#34;https://pusher.com&#34;&gt;https://pusher.com&lt;/a&gt; and use the application credentials within your app as shown below.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can get the Pusher Channels PHP library via a composer package called &lt;code&gt;pusher-php-server&lt;/code&gt;. See &lt;a href=&#34;https://packagist.org/packages/pusher/pusher-php-server&#34;&gt;https://packagist.org/packages/pusher/pusher-php-server&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ composer require pusher/pusher-php-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or add to &lt;code&gt;composer.json&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&#34;require&#34;: {&#xA;    &#34;pusher/pusher-php-server&#34;: &#34;^7.2&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then run &lt;code&gt;composer update&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Supported platforms&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PHP - supports PHP versions 7.3, 7.4, 8.0, and 8.1.&lt;/li&gt; &#xA; &lt;li&gt;Laravel - version 8.29 and above has built-in support for Pusher Channels as a &lt;a href=&#34;https://laravel.com/docs/master/broadcasting&#34;&gt;Broadcasting backend&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Other PHP frameworks - supported provided you are using a supported version of PHP.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Pusher Channels constructor&lt;/h2&gt; &#xA;&lt;p&gt;Use the credentials from your Pusher Channels application to create a new &lt;code&gt;Pusher\Pusher&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$app_id = &#39;YOUR_APP_ID&#39;;&#xA;$app_key = &#39;YOUR_APP_KEY&#39;;&#xA;$app_secret = &#39;YOUR_APP_SECRET&#39;;&#xA;$app_cluster = &#39;YOUR_APP_CLUSTER&#39;;&#xA;&#xA;$pusher = new Pusher\Pusher($app_key, $app_secret, $app_id, [&#39;cluster&#39; =&amp;gt; $app_cluster]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The fourth parameter is an &lt;code&gt;$options&lt;/code&gt; array. The additional options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;scheme&lt;/code&gt; - e.g. http or https&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;host&lt;/code&gt; - the host e.g. api.pusherapp.com. No trailing forward slash&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt; - the http port&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;path&lt;/code&gt; - a prefix to append to all request paths. This is only useful if you are running the library against an endpoint you control yourself (e.g. a proxy that routes based on the path prefix).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; - the HTTP timeout&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;useTLS&lt;/code&gt; - quick option to use scheme of https and port 443.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster&lt;/code&gt; - specify the cluster where the application is running from.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;encryption_master_key&lt;/code&gt; - a 32 char long key. This key, along with the channel name, are used to derive per-channel encryption keys. Per-channel keys are used encrypt event data on encrypted channels.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, by default calls will be made over HTTPS. To use plain HTTP you can set useTLS to false:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$options = [&#xA;  &#39;cluster&#39; =&amp;gt; $app_cluster,&#xA;  &#39;useTLS&#39; =&amp;gt; false&#xA;];&#xA;$pusher = new Pusher\Pusher($app_key, $app_secret, $app_id, $options);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Logging configuration&lt;/h2&gt; &#xA;&lt;p&gt;The recommended approach of logging is to use a &lt;a href=&#34;https://github.com/php-fig/fig-standards/raw/master/accepted/PSR-3-logger-interface.md&#34;&gt;PSR-3&lt;/a&gt; compliant logger implementing &lt;code&gt;Psr\Log\LoggerInterface&lt;/code&gt;. The &lt;code&gt;Pusher&lt;/code&gt; object implements &lt;code&gt;Psr\Log\LoggerAwareInterface&lt;/code&gt;, meaning you call &lt;code&gt;setLogger(LoggerInterface $logger)&lt;/code&gt; to set the logger instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// where $logger implements `LoggerInterface`&#xA;&#xA;$pusher-&amp;gt;setLogger($logger);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Guzzle client&lt;/h2&gt; &#xA;&lt;p&gt;This library uses Guzzle internally to make HTTP calls. You can pass your own Guzzle instance to the Pusher constructor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$custom_client = new GuzzleHttp\Client();&#xA;&#xA;$pusher = new Pusher\Pusher(&#xA;    $app_key,&#xA;    $app_secret,&#xA;    $app_id,&#xA;    [],&#xA;    $custom_client&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows you to pass in your own middleware, see the tests for an &lt;a href=&#34;https://raw.githubusercontent.com/pusher/pusher-http-php/master/tests/acceptance/middlewareTest.php&#34;&gt;example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Publishing/Triggering events&lt;/h2&gt; &#xA;&lt;p&gt;To trigger an event on one or more channels use the &lt;code&gt;trigger&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;h3&gt;A single channel&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;trigger(&#39;my-channel&#39;, &#39;my_event&#39;, &#39;hello world&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple channels&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;trigger([ &#39;channel-1&#39;, &#39;channel-2&#39; ], &#39;my_event&#39;, &#39;hello world&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Batches&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s also possible to send multiple events with a single API call (max 10 events per call on multi-tenant clusters):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$batch = [];&#xA;$batch[] = [&#39;channel&#39; =&amp;gt; &#39;my-channel&#39;, &#39;name&#39; =&amp;gt; &#39;my_event&#39;, &#39;data&#39; =&amp;gt; [&#39;hello&#39; =&amp;gt; &#39;world&#39;]];&#xA;$batch[] = [&#39;channel&#39; =&amp;gt; &#39;my-channel&#39;, &#39;name&#39; =&amp;gt; &#39;my_event&#39;, &#39;data&#39; =&amp;gt; [&#39;myname&#39; =&amp;gt; &#39;bob&#39;]];&#xA;$pusher-&amp;gt;triggerBatch($batch);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Asynchronous interface&lt;/h3&gt; &#xA;&lt;p&gt;Both &lt;code&gt;trigger&lt;/code&gt; and &lt;code&gt;triggerBatch&lt;/code&gt; have asynchronous counterparts in &lt;code&gt;triggerAsync&lt;/code&gt; and &lt;code&gt;triggerBatchAsync&lt;/code&gt;. These functions return &lt;a href=&#34;https://github.com/guzzle/promises&#34;&gt;Guzzle promises&lt;/a&gt; which can be chained with &lt;code&gt;-&amp;gt;then&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$promise = $pusher-&amp;gt;triggerAsync([&#39;channel-1&#39;, &#39;channel-2&#39;], &#39;my_event&#39;, &#39;hello world&#39;);&#xA;&#xA;$promise-&amp;gt;then(function($result) {&#xA;  // do something with $result&#xA;  return $result;&#xA;});&#xA;&#xA;$final_result = $promise-&amp;gt;wait();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Arrays&lt;/h3&gt; &#xA;&lt;p&gt;Arrays are automatically converted to JSON format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$array[&#39;name&#39;] = &#39;joe&#39;;&#xA;$array[&#39;message_count&#39;] = 23;&#xA;&#xA;$pusher-&amp;gt;trigger(&#39;my_channel&#39;, &#39;my_event&#39;, $array);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of this will be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&#34;{&#39;name&#39;: &#39;joe&#39;, &#39;message_count&#39;: 23}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Socket id&lt;/h3&gt; &#xA;&lt;p&gt;In order to avoid duplicates you can optionally &lt;a href=&#34;https://pusher.com/docs/channels/server_api/excluding-event-recipients&#34;&gt;specify the sender&#39;s socket id&lt;/a&gt; while triggering an event:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;trigger(&#39;my-channel&#39;, &#39;event&#39;, &#39;data&#39;, [&#39;socket_id&#39; =&amp;gt; $socket_id]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$batch = [];&#xA;$batch[] = [&#39;channel&#39; =&amp;gt; &#39;my-channel&#39;, &#39;name&#39; =&amp;gt; &#39;my_event&#39;, &#39;data&#39; =&amp;gt; [&#39;hello&#39; =&amp;gt; &#39;world&#39;], [&#39;socket_id&#39; =&amp;gt; $socket_id]];&#xA;$batch[] = [&#39;channel&#39; =&amp;gt; &#39;my-channel&#39;, &#39;name&#39; =&amp;gt; &#39;my_event&#39;, &#39;data&#39; =&amp;gt; [&#39;myname&#39; =&amp;gt; &#39;bob&#39;], [&#39;socket_id&#39; =&amp;gt; $socket_id]];&#xA;$pusher-&amp;gt;triggerBatch($batch);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fetch channel info on publish [&lt;a href=&#34;https://pusher.com/docs/lab#experimental-program&#34;&gt;EXPERIMENTAL&lt;/a&gt;]&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to request for attributes about the channels that were published to with the &lt;a href=&#34;https://pusher.com/docs/channels/library_auth_reference/rest-api#request&#34;&gt;&lt;code&gt;info&lt;/code&gt; param&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$result = $pusher-&amp;gt;trigger(&#39;my-channel&#39;, &#39;my_event&#39;, &#39;hello world&#39;, [&#39;info&#39; =&amp;gt; &#39;subscription_count&#39;]);&#xA;$subscription_count = $result-&amp;gt;channels[&#39;my-channel&#39;]-&amp;gt;subscription_count;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$batch = [];&#xA;$batch[] = [&#39;channel&#39; =&amp;gt; &#39;my-channel&#39;, &#39;name&#39; =&amp;gt; &#39;my_event&#39;, &#39;data&#39; =&amp;gt; [&#39;hello&#39; =&amp;gt; &#39;world&#39;], &#39;info&#39; =&amp;gt; &#39;subscription_count&#39;];&#xA;$batch[] = [&#39;channel&#39; =&amp;gt; &#39;presence-my-channel&#39;, &#39;name&#39; =&amp;gt; &#39;my_event&#39;, &#39;data&#39; =&amp;gt; [&#39;myname&#39; =&amp;gt; &#39;bob&#39;], &#39;info&#39; =&amp;gt; &#39;user_count,subscription_count&#39;];&#xA;$result = $pusher-&amp;gt;triggerBatch($batch);&#xA;&#xA;foreach ($result-&amp;gt;batch as $i =&amp;gt; $attributes) {&#xA;  echo &#34;channel: {$batch[$i][&#39;channel&#39;]}, name: {$batch[$i][&#39;name&#39;]}&#34;;&#xA;  if (isset($attributes-&amp;gt;subscription_count)) {&#xA;    echo &#34;, subscription_count: {$attributes-&amp;gt;subscription_count}&#34;;&#xA;  }&#xA;  if (isset($attributes-&amp;gt;user_count)) {&#xA;    echo &#34;, user_count: {$attributes-&amp;gt;user_count}&#34;;&#xA;  }&#xA;  echo PHP_EOL;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JSON format&lt;/h3&gt; &#xA;&lt;p&gt;If your data is already encoded in JSON format, you can avoid a second encoding step by setting the sixth argument true, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;trigger(&#39;my-channel&#39;, &#39;event&#39;, &#39;data&#39;, [], true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Authenticating users&lt;/h2&gt; &#xA;&lt;p&gt;To authenticate users on Pusher Channels on your application, you can use the &lt;code&gt;authenticateUser&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;authenticateUser(&#39;socket_id&#39;, &#39;user-id&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see &lt;a href=&#34;https://pusher.com/docs/channels/server_api/authenticating-users/&#34;&gt;authenticating users&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Authorizing Private channels&lt;/h2&gt; &#xA;&lt;p&gt;To authorize your users to access private channels on Pusher, you can use the &lt;code&gt;authorizeChannel&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;authorizeChannel(&#39;private-my-channel&#39;,&#39;socket_id&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see &lt;a href=&#34;https://pusher.com/docs/channels/server_api/authorizing-users/&#34;&gt;authorizing users&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Authorizing Presence channels&lt;/h2&gt; &#xA;&lt;p&gt;Using presence channels is similar to private channels, but you can specify extra data to identify that particular user:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;authorizePresenceChannel(&#39;presence-my-channel&#39;,&#39;socket_id&#39;, &#39;user_id&#39;, &#39;user_info&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see &lt;a href=&#34;https://pusher.com/docs/channels/server_api/authorizing-users/&#34;&gt;authorizing users&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Webhooks&lt;/h2&gt; &#xA;&lt;p&gt;This library provides a way of verifying that webhooks you receive from Pusher are actually genuine webhooks from Pusher. It also provides a structure for storing them. A helper method called &lt;code&gt;webhook&lt;/code&gt; enables this. Pass in the headers and body of the request, and it&#39;ll return a Webhook object with your verified events. If the library was unable to validate the signature, an exception is thrown instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$webhook = $pusher-&amp;gt;webhook($request_headers, $request_body);&#xA;$number_of_events = count($webhook-&amp;gt;get_events());&#xA;$time_received = $webhook-&amp;gt;get_time_ms();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;End to end encryption&lt;/h2&gt; &#xA;&lt;p&gt;This library supports end to end encryption of your private channels. This means that only you and your connected clients will be able to read your messages. Pusher cannot decrypt them. You can enable this feature by following these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;You should first set up Private channels. This involves &lt;a href=&#34;https://pusher.com/docs/authorizing_users&#34;&gt;creating an authorization endpoint on your server&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Next, generate your 32 byte master encryption key, base64 encode it and store it securely. This is secret and you should never share this with anyone. Not even Pusher.&lt;/p&gt; &lt;p&gt;To generate an appropriate key from a good random source, you can use the &lt;code&gt;openssl&lt;/code&gt; command:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl rand -base64 32&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Specify your master encryption key when creating your Pusher client:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher = new Pusher\Pusher(&#xA;    $app_key,&#xA;    $app_secret,&#xA;    $app_id,&#xA;    [&#xA;        &#39;cluster&#39; =&amp;gt; $app_cluster,&#xA;        &#39;encryption_master_key_base64&#39; =&amp;gt; &#34;&amp;lt;your base64 encoded master key&amp;gt;&#34;&#xA;    ]&#xA; );&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Channels where you wish to use end to end encryption should be prefixed with &lt;code&gt;private-encrypted-&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Subscribe to these channels in your client, and you&#39;re done! You can verify it is working by checking out the debug console on the &lt;a href=&#34;https://raw.githubusercontent.com/pusher/pusher-http-php/master/dashboard&#34;&gt;https://dashboard.pusher.com/&lt;/a&gt; and seeing the scrambled ciphertext.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important note: This will &lt;strong&gt;not&lt;/strong&gt; encrypt messages on channels that are not prefixed by &lt;code&gt;private-encrypted-&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Limitation&lt;/strong&gt;: you cannot trigger a single event on a mixture of unencrypted and encrypted channels in a call to &lt;code&gt;trigger&lt;/code&gt;, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$data[&#39;name&#39;] = &#39;joe&#39;;&#xA;$data[&#39;message_count&#39;] = 23;&#xA;&#xA;$pusher-&amp;gt;trigger([&#39;channel-1&#39;, &#39;private-encrypted-channel-2&#39;], &#39;test_event&#39;, $data);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rationale: the methods in this library map directly to individual Channels HTTP API requests. If we allowed triggering a single event on multiple channels (some encrypted, some unencrypted), then it would require two API requests: one where the event is encrypted to the encrypted channels, and one where the event is unencrypted for unencrypted channels.&lt;/p&gt; &#xA;&lt;h3&gt;Presence example&lt;/h3&gt; &#xA;&lt;p&gt;First set the channel authorization endpoint in your JS app when creating the Pusher object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var pusher = new Pusher(&#34;app_key&#34;,&#xA;  // ...&#xA;  channelAuthorization: {&#xA;    endpoint: &#34;/presenceAuth.php&#34;,&#xA;  },&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, create the following in presenceAuth.php:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;header(&#39;Content-Type: application/json&#39;);&#xA;&#xA;if (isset($_SESSION[&#39;user_id&#39;])) {&#xA;  $stmt = $pdo-&amp;gt;prepare(&#34;SELECT * FROM `users` WHERE id = :id&#34;);&#xA;  $stmt-&amp;gt;bindValue(&#39;:id&#39;, $_SESSION[&#39;user_id&#39;], PDO::PARAM_INT);&#xA;  $stmt-&amp;gt;execute();&#xA;  $user = $stmt-&amp;gt;fetch();&#xA;} else {&#xA;  die(json_encode(&#39;no-one is logged in&#39;));&#xA;}&#xA;&#xA;$pusher = new Pusher\Pusher($key, $secret, $app_id);&#xA;$presence_data = [&#39;name&#39; =&amp;gt; $user[&#39;name&#39;]];&#xA;&#xA;echo $pusher-&amp;gt;authorizePresenceChannel($_POST[&#39;channel_name&#39;], $_POST[&#39;socket_id&#39;], $user[&#39;id&#39;], $presence_data);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: this assumes that you store your users in a table called &lt;code&gt;users&lt;/code&gt; and that those users have a &lt;code&gt;name&lt;/code&gt; column. It also assumes that you have a login mechanism that stores the &lt;code&gt;user_id&lt;/code&gt; of the logged in user in the session.&lt;/p&gt; &#xA;&lt;h2&gt;Application State Queries&lt;/h2&gt; &#xA;&lt;h3&gt;Get information about a channel&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;getChannelInfo($name);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible to get information about a channel from the Channels HTTP API.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$info = $pusher-&amp;gt;getChannelInfo(&#39;channel-name&#39;);&#xA;$channel_occupied = $info-&amp;gt;occupied;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;a href=&#34;https://pusher.com/docs/presence_channels&#34;&gt;presence channels&lt;/a&gt; you can also query the number of distinct users currently subscribed to this channel (a single user may be subscribed many times, but will only count as one):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$info = $pusher-&amp;gt;getChannelInfo(&#39;presence-channel-name&#39;, [&#39;info&#39; =&amp;gt; &#39;user_count&#39;]);&#xA;$user_count = $info-&amp;gt;user_count;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have enabled the ability to query the &lt;code&gt;subscription_count&lt;/code&gt; (the number of connections currently subscribed to this channel) then you can query this value as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$info = $pusher-&amp;gt;getChannelInfo(&#39;presence-channel-name&#39;, [&#39;info&#39; =&amp;gt; &#39;subscription_count&#39;]);&#xA;$subscription_count = $info-&amp;gt;subscription_count;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get a list of application channels&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;getChannels();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible to get a list of channels for an application from the Channels HTTP API.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$result = $pusher-&amp;gt;getChannels();&#xA;$channel_count = count($result-&amp;gt;channels); // $channels is an Array&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get a filtered list of application channels&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;getChannels([&#39;filter_by_prefix&#39; =&amp;gt; &#39;some_filter&#39;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible to get a list of channels based on their name prefix. To do this you need to supply an &lt;code&gt;$options&lt;/code&gt; parameter to the call. In the following example the call will return a list of all channels with a &lt;code&gt;presence-&lt;/code&gt; prefix. This is idea for fetching a list of all presence channels.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$results = $pusher-&amp;gt;getChannels([&#39;filter_by_prefix&#39; =&amp;gt; &#39;presence-&#39;]);&#xA;$channel_count = count($result-&amp;gt;channels); // $channels is an Array&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be achieved using the generic &lt;code&gt;pusher-&amp;gt;get&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;get(&#39;/channels&#39;, [&#39;filter_by_prefix&#39; =&amp;gt; &#39;presence-&#39;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get a list of application channels with subscription counts&lt;/h3&gt; &#xA;&lt;p&gt;The HTTP API returning the channel list does not support returning the subscription count along with each channel. Instead, you can fetch this data by iterating over each channel and making another request. Be warned: this approach consumes (number of channels + 1) messages!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;$subscription_counts = [];&#xA;foreach ($pusher-&amp;gt;getChannels()-&amp;gt;channels as $channel =&amp;gt; $v) {&#xA;  $subscription_counts[$channel] =&#xA;    $pusher-&amp;gt;getChannelInfo(&#xA;      $channel, [&#39;info&#39; =&amp;gt; &#39;subscription_count&#39;]&#xA;    )-&amp;gt;subscription_count;&#xA;}&#xA;var_dump($subscription_counts);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get user information from a presence channel&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$results = $pusher-&amp;gt;getPresenceUsers(&#39;presence-channel-name&#39;);&#xA;$users_count = count($results-&amp;gt;users); // $users is an Array&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be achieved using the generic &lt;code&gt;pusher-&amp;gt;get&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$response = $pusher-&amp;gt;get(&#39;/channels/presence-channel-name/users&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;$response&lt;/code&gt; is in the format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Array (&#xA;&#x9;[body] =&amp;gt; {&#34;users&#34;:[{&#34;id&#34;:&#34;a_user_id&#34;}]}&#xA;&#x9;[status] =&amp;gt; 200&#xA;&#x9;[result] =&amp;gt; Array (&#xA;&#x9;&#x9;[users] =&amp;gt; Array (&#xA;&#x9;&#x9;&#x9;[0] =&amp;gt; Array (&#xA;&#x9;&#x9;&#x9;&#x9;[id] =&amp;gt; a_user_id&#xA;&#x9;&#x9;&#x9;),&#xA;&#x9;&#x9;&#x9;/* Additional users */&#xA;&#x9;&#x9;)&#xA;&#x9;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generic get function&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pusher-&amp;gt;get($path, $params);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Used to make &lt;code&gt;GET&lt;/code&gt; queries against the Channels HTTP API. Handles authentication.&lt;/p&gt; &#xA;&lt;p&gt;Response is an associative array with a &lt;code&gt;result&lt;/code&gt; index. The contents of this index is dependent on the HTTP method that was called. However, a &lt;code&gt;status&lt;/code&gt; property to allow the HTTP status code is always present and a &lt;code&gt;result&lt;/code&gt; property will be set if the status code indicates a successful call to the API.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$response = $pusher-&amp;gt;get(&#39;/channels&#39;);&#xA;$http_status_code = $response[&#39;status&#39;];&#xA;$result = $response[&#39;result&#39;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running the tests&lt;/h2&gt; &#xA;&lt;p&gt;Requires &lt;a href=&#34;https://github.com/sebastianbergmann/phpunit&#34;&gt;phpunit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run &lt;code&gt;composer install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Go to the &lt;code&gt;tests&lt;/code&gt; directory&lt;/li&gt; &#xA; &lt;li&gt;Rename &lt;code&gt;config.example.php&lt;/code&gt; and replace the values with valid Channels credentials &lt;strong&gt;or&lt;/strong&gt; create environment variables.&lt;/li&gt; &#xA; &lt;li&gt;Some tests require a client to be connected to the app you defined in the config; you can do this by opening &lt;a href=&#34;https://dashboard.pusher.com/apps/&#34;&gt;https://dashboard.pusher.com/apps/&lt;/a&gt;&amp;lt;YOUR_TEST_APP_ID&amp;gt;/getting_started in the browser&lt;/li&gt; &#xA; &lt;li&gt;From the root directory of the project, execute &lt;code&gt;composer exec phpunit&lt;/code&gt; to run all the tests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright 2014, Pusher. Licensed under the MIT license: &lt;a href=&#34;https://www.opensource.org/licenses/mit-license.php&#34;&gt;https://www.opensource.org/licenses/mit-license.php&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2010, Squeeks. Licensed under the MIT license: &lt;a href=&#34;https://www.opensource.org/licenses/mit-license.php&#34;&gt;https://www.opensource.org/licenses/mit-license.php&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>phpstan/phpstan</title>
    <updated>2022-12-14T01:37:55Z</updated>
    <id>tag:github.com,2022-12-14:/phpstan/phpstan</id>
    <link href="https://github.com/phpstan/phpstan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PHP Static Analysis Tool - discover bugs in your code without running it!&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;PHPStan - PHP Static Analysis Tool&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://i.imgur.com/WaRKPlC.png&#34; alt=&#34;PHPStan&#34; width=&#34;300&#34; height=&#34;300&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/phpstan/phpstan/actions&#34;&gt;&lt;img src=&#34;https://github.com/phpstan/phpstan/workflows/Tests/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/phpstan/phpstan&#34;&gt;&lt;img src=&#34;https://poser.pugx.org/phpstan/phpstan/v/stable&#34; alt=&#34;Latest Stable Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/phpstan/phpstan/stats&#34;&gt;&lt;img src=&#34;https://poser.pugx.org/phpstan/phpstan/downloads&#34; alt=&#34;Total Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://choosealicense.com/licenses/mit/&#34;&gt;&lt;img src=&#34;https://poser.pugx.org/phpstan/phpstan/license&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://phpstan.org/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/PHPStan-enabled-brightgreen.svg?style=flat&#34; alt=&#34;PHPStan Enabled&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;PHPStan focuses on finding errors in your code without actually running it. It catches whole classes of bugs even before you write tests for the code. It moves PHP closer to compiled languages in the sense that the correctness of each line of the code can be checked before you run the actual line.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://phpstan.org/&#34;&gt;Read more about PHPStan ¬ª&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://phpstan.org/try&#34;&gt;Try out PHPStan on the on-line playground! ¬ª&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://coders.thecodingmachine.com/phpstan&#34;&gt;&lt;img src=&#34;https://i.imgur.com/kQhNOTP.png&#34; alt=&#34;TheCodingMachine&#34; width=&#34;247&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://packagist.com/?utm_source=phpstan&amp;amp;utm_medium=readme&amp;amp;utm_campaign=sponsorlogo&#34;&gt;&lt;img src=&#34;https://i.imgur.com/B2T63Do.png&#34; alt=&#34;Private Packagist&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://careers.tuigroup.com/jobs/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/uw5rAlR.png&#34; alt=&#34;Musement&#34; width=&#34;247&#34; height=&#34;49&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://blackfire.io/docs/introduction?utm_source=phpstan&amp;amp;utm_medium=github_readme&amp;amp;utm_campaign=logo&#34;&gt;&lt;img src=&#34;https://i.imgur.com/zR8rsqk.png&#34; alt=&#34;Blackfire.io&#34; width=&#34;254&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://www.iodigital.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/fJlw1n9.png&#34; alt=&#34;iO&#34; width=&#34;254&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://jobs.ticketswap.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/lhzcutK.png&#34; alt=&#34;TicketSwap&#34; width=&#34;269&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://www.startupjobs.cz/startup/shipmonk&#34;&gt;&lt;img src=&#34;https://i.imgur.com/bAC47za.jpg&#34; alt=&#34;ShipMonk&#34; width=&#34;290&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://togetter.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/x9n5cj3.png&#34; alt=&#34;Togetter&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://join.rightcapital.com/?utm_source=phpstan&amp;amp;utm_medium=github&amp;amp;utm_campaign=sponsorship&#34;&gt;&lt;img src=&#34;https://i.imgur.com/1AhB5tW.png&#34; alt=&#34;RightCapital&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://www.contentkingapp.com/?ref=php-developer&amp;amp;utm_source=phpstan&amp;amp;utm_medium=referral&amp;amp;utm_campaign=sponsorship&#34;&gt;&lt;img src=&#34;https://i.imgur.com/HHhbPGN.png&#34; alt=&#34;ContentKing&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://zol.fr?utm_source=phpstan&#34;&gt;&lt;img src=&#34;https://i.imgur.com/dzDgd4s.png&#34; alt=&#34;ZOL&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://www.psyonix.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/p8svxQZ.png&#34; alt=&#34;Psyonix&#34; width=&#34;254&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://www.shopware.com/en/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/L4X5w9s.png&#34; alt=&#34;Shopware&#34; width=&#34;284&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://craftcms.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/xJWThke.png&#34; alt=&#34;Craft CMS&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://www.worksome.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/TQKSwOl.png&#34; alt=&#34;Worksome&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://www.crisp.nl/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/jRJyPve.png&#34; alt=&#34;Crisp.nl&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://inviqa.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/G99rj45.png&#34; alt=&#34;Inviqa&#34; width=&#34;254&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://www.cdn77.com/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/Oo3wA3m.png&#34; alt=&#34;CDN77&#34; width=&#34;283&#34; height=&#34;64&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sponsors/ondrejmirtes&#34;&gt;&lt;strong&gt;You can now sponsor my open-source work on PHPStan through GitHub Sponsors.&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Does GitHub already have your üí≥? Do you use PHPStan to find üêõ before they reach production? &lt;a href=&#34;https://github.com/sponsors/ondrejmirtes&#34;&gt;Send a couple of üí∏ a month my way too.&lt;/a&gt; Thank you!&lt;/p&gt; &#xA;&lt;p&gt;One-time donations &lt;a href=&#34;https://paypal.me/phpstan&#34;&gt;through PayPal&lt;/a&gt; are also accepted. To request an invoice, &lt;a href=&#34;mailto:ondrej@mirtes.cz&#34;&gt;contact me&lt;/a&gt; through e-mail.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;All the documentation lives on the &lt;a href=&#34;https://phpstan.org/&#34;&gt;phpstan.org website&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://phpstan.org/user-guide/getting-started&#34;&gt;Getting Started &amp;amp; User Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://phpstan.org/config-reference&#34;&gt;Config Reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://phpstan.org/writing-php-code/phpdocs-basics&#34;&gt;PHPDocs Basics&lt;/a&gt; &amp;amp;&amp;nbsp;&lt;a href=&#34;https://phpstan.org/writing-php-code/phpdoc-types&#34;&gt;PHPDoc Types&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://phpstan.org/user-guide/extension-library&#34;&gt;Extension Library&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://phpstan.org/developing-extensions/extension-types&#34;&gt;Developing Extensions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://apiref.phpstan.org/&#34;&gt;API Reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;PHPStan Pro&lt;/h2&gt; &#xA;&lt;p&gt;PHPStan Pro is a paid add-on on top of open-source PHPStan Static Analysis Tool with these premium features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Web UI for browsing found errors, you can click and open your editor of choice on the offending line.&lt;/li&gt; &#xA; &lt;li&gt;Continuous analysis (watch mode): scans changed files in the background, refreshes the UI automatically.&lt;/li&gt; &#xA; &lt;li&gt;Interactive fixer: lets you choose the right fix for found errors &lt;span&gt;üòä&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Try it on PHPStan 0.12.45 or later by running it with the &lt;code&gt;--pro&lt;/code&gt; option. You can create an account either by following the on-screen instructions, or by visiting &lt;a href=&#34;https://account.phpstan.com/&#34;&gt;account.phpstan.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After 30-day free trial period it costs 7 EUR for individuals monthly, 70 EUR for teams (up to 25 members). By paying for PHPStan Pro, you&#39;re supporting the development of open-source PHPStan.&lt;/p&gt; &#xA;&lt;p&gt;You can read more about it on &lt;a href=&#34;https://phpstan.org/blog/introducing-phpstan-pro&#34;&gt;PHPStan&#39;s website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;This project adheres to a &lt;a href=&#34;https://github.com/phpstan/phpstan/raw/master/CODE_OF_CONDUCT.md&#34;&gt;Contributor Code of Conduct&lt;/a&gt;. By participating in this project and its community, you are expected to uphold this code.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Any contributions are welcome. PHPStan&#39;s source code open to pull requests lives at &lt;a href=&#34;https://github.com/phpstan/phpstan-src&#34;&gt;&lt;code&gt;phpstan/phpstan-src&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>