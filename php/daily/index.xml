<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-17T01:43:53Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>laravel/tinker</title>
    <updated>2023-02-17T01:43:53Z</updated>
    <id>tag:github.com,2023-02-17:/laravel/tinker</id>
    <link href="https://github.com/laravel/tinker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Powerful REPL for the Laravel framework.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/laravel/tinker/2.x/art/logo.svg?sanitize=true&#34; alt=&#34;Logo Laravel Tinker&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/laravel/tinker/actions&#34;&gt;&lt;img src=&#34;https://github.com/laravel/tinker/workflows/tests/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/laravel/tinker&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dt/laravel/tinker&#34; alt=&#34;Total Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/laravel/tinker&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/laravel/tinker&#34; alt=&#34;Latest Stable Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/laravel/tinker&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/l/laravel/tinker&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Laravel Tinker is a powerful REPL for the Laravel framework.&lt;/p&gt; &#xA;&lt;h2&gt;Official Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation for Tinker can be found on the &lt;a href=&#34;https://laravel.com/docs/artisan#tinker&#34;&gt;Laravel website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Thank you for considering contributing to Tinker! The contribution guide can be found in the &lt;a href=&#34;https://laravel.com/docs/contributions&#34;&gt;Laravel documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;In order to ensure that the Laravel community is welcoming to all, please review and abide by the &lt;a href=&#34;https://laravel.com/docs/contributions#code-of-conduct&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Security Vulnerabilities&lt;/h2&gt; &#xA;&lt;p&gt;Please review &lt;a href=&#34;https://github.com/laravel/tinker/security/policy&#34;&gt;our security policy&lt;/a&gt; on how to report security vulnerabilities.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Laravel Tinker is open-sourced software licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/laravel/tinker/2.x/LICENSE.md&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>PHP-Open-Source-Saver/jwt-auth</title>
    <updated>2023-02-17T01:43:53Z</updated>
    <id>tag:github.com,2023-02-17:/PHP-Open-Source-Saver/jwt-auth</id>
    <link href="https://github.com/PHP-Open-Source-Saver/jwt-auth" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üîê JSON Web Token Authentication for Laravel &amp; Lumen&lt;/p&gt;&lt;hr&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PHP-Open-Source-Saver/jwt-auth/main/README.pr-ar.md&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/lang-ar-blue&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tymondesigns/jwt-auth/wiki&#34;&gt;This repository is a fork from original tymonsdesigns/jwt-auth&lt;/a&gt;, we decided to fork and work independent because the original one was not being updated for long time and keep doing support for the application.&lt;/p&gt; &#xA;&lt;h2&gt;Migrating from &lt;a href=&#34;https://github.com/tymondesigns/jwt-auth&#34;&gt;&lt;code&gt;tymondesigns/jwt-auth&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This uses different namespace, then &lt;code&gt;tymondesigns/jwt-auth&lt;/code&gt;, but overall, provides the same API, that makes migration to this repository pretty easy:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;composer remove tymon/jwt-auth&lt;/code&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;&lt;strong&gt;Info&lt;/strong&gt; An error will appear because the package is still in use, ignore it.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt;Replace all the occurrences of &lt;code&gt;Tymon\JWTAuth&lt;/code&gt; with &lt;code&gt;PHPOpenSourceSaver\JWTAuth&lt;/code&gt;. &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: You can use &lt;em&gt;Find and Replace&lt;/em&gt; feature of your IDE. Try it with &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;R&lt;/kbd&gt;&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;composer require php-open-source-saver/jwt-auth&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Notes&lt;/h3&gt; &#xA;&lt;p&gt;Due to new features, added in our library, there are some incompatibilities. &lt;em&gt;This won&#39;t hurt you in most cases&lt;/em&gt;, unless you have &lt;a href=&#34;https://laravel.com/docs/8.x/packages#opting-out-of-package-discovery&#34;&gt;implicitly disabled autodiscovery&lt;/a&gt; for original Tymon&#39;s package.&lt;/p&gt; &#xA;&lt;p&gt;Current compatability breaks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PHP-Open-Source-Saver/jwt-auth/main/src/JWTGuard.php&#34;&gt;&lt;code&gt;JWTGuard&lt;/code&gt;&lt;/a&gt; have new required constructor parameter &lt;a href=&#34;https://raw.githubusercontent.com/PHP-Open-Source-Saver/jwt-auth/main/src/Providers/AbstractServiceProvider.php#L97&#34;&gt;&lt;code&gt;$eventDispatcher&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Full documentation is available at &lt;a href=&#34;https://laravel-jwt-auth.readthedocs.io/&#34;&gt;laravel-jwt-auth.readthedocs.io&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;If you want to disclose a security related issue, please follow our &lt;a href=&#34;https://github.com/PHP-Open-Source-Saver/jwt-auth/security/policy&#34;&gt;security policy&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>protonemedia/laravel-ffmpeg</title>
    <updated>2023-02-17T01:43:53Z</updated>
    <id>tag:github.com,2023-02-17:/protonemedia/laravel-ffmpeg</id>
    <link href="https://github.com/protonemedia/laravel-ffmpeg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This package provides an integration with FFmpeg for Laravel. Laravel&#39;s Filesystem handles the storage of the files.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Laravel FFMpeg&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/pbmedia/laravel-ffmpeg&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/pbmedia/laravel-ffmpeg.svg?style=flat-square&#34; alt=&#34;Latest Version on Packagist&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/LICENSE.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square&#34; alt=&#34;Software License&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/protonemedia/laravel-ffmpeg/workflows/run-tests/badge.svg?sanitize=true&#34; alt=&#34;run-tests&#34;&gt; &lt;a href=&#34;https://packagist.org/packages/pbmedia/laravel-ffmpeg&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dt/pbmedia/laravel-ffmpeg.svg?style=flat-square&#34; alt=&#34;Total Downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package provides an integration with FFmpeg for Laravel 9 and 10. &lt;a href=&#34;http://laravel.com/docs/9.x/filesystem&#34;&gt;Laravel&#39;s Filesystem&lt;/a&gt; handles the storage of the files.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsor this package!&lt;/h2&gt; &#xA;&lt;p&gt;‚ù§Ô∏è We proudly support the community by developing Laravel packages and giving them away for free. If this package saves you time or if you&#39;re relying on it professionally, please consider &lt;a href=&#34;https://github.com/sponsors/pascalbaljet&#34;&gt;sponsoring the maintenance and development&lt;/a&gt;. Keeping track of issues and pull requests takes time, but we&#39;re happy to help!&lt;/p&gt; &#xA;&lt;h2&gt;Laravel Splade&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Did you hear about Laravel Splade? ü§©&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s the &lt;em&gt;magic&lt;/em&gt; of Inertia.js with the &lt;em&gt;simplicity&lt;/em&gt; of Blade. &lt;a href=&#34;https://github.com/protonemedia/laravel-splade&#34;&gt;Splade&lt;/a&gt; provides a super easy way to build Single Page Applications using Blade templates. Besides that magic SPA-feeling, it comes with more than ten components to sparkle your app and make it interactive, all without ever leaving Blade.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Super easy wrapper around &lt;a href=&#34;https://github.com/PHP-FFMpeg/PHP-FFMpeg&#34;&gt;PHP-FFMpeg&lt;/a&gt;, including support for filters and other advanced features.&lt;/li&gt; &#xA; &lt;li&gt;Integration with &lt;a href=&#34;http://laravel.com/docs/9.x/filesystem&#34;&gt;Laravel&#39;s Filesystem&lt;/a&gt;, &lt;a href=&#34;https://laravel.com/docs/9.x/configuration&#34;&gt;configuration system&lt;/a&gt; and &lt;a href=&#34;https://laravel.com/docs/9.x/errors&#34;&gt;logging handling&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Compatible with Laravel 9 and 10, support for &lt;a href=&#34;https://laravel.com/docs/9.x/packages#package-discovery&#34;&gt;Package Discovery&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for HLS.&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for encrypted HLS (AES-128) and rotating keys (optional).&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for concatenation, multiple inputs/outputs, image sequences (timelapse), complex filters (and mapping), frame/thumbnail exports.&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for watermarks (positioning and manipulation).&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for creating a mosaic/sprite/tile from a video.&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for generating &lt;em&gt;VTT Preview Thumbnail&lt;/em&gt; files.&lt;/li&gt; &#xA; &lt;li&gt;Requires PHP 8.1 or 8.2.&lt;/li&gt; &#xA; &lt;li&gt;Tested with FFmpeg 4.4 and 5.0.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Verify you have the latest version of FFmpeg installed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can install the package via composer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer require pbmedia/laravel-ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the Service Provider and Facade to your &lt;code&gt;app.php&lt;/code&gt; config file if you&#39;re not using Package Discovery.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// config/app.php&#xA;&#xA;&#39;providers&#39; =&amp;gt; [&#xA;    ...&#xA;    ProtoneMedia\LaravelFFMpeg\Support\ServiceProvider::class,&#xA;    ...&#xA;];&#xA;&#xA;&#39;aliases&#39; =&amp;gt; [&#xA;    ...&#xA;    &#39;FFMpeg&#39; =&amp;gt; ProtoneMedia\LaravelFFMpeg\Support\FFMpeg::class&#xA;    ...&#xA;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Publish the config file using the artisan CLI tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;php artisan vendor:publish --provider=&#34;ProtoneMedia\LaravelFFMpeg\Support\ServiceProvider&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrading to v8&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;set_command_and_error_output_on_exception&lt;/code&gt; configuration key now defaults to &lt;code&gt;true&lt;/code&gt;, making exceptions more informative. Read more at the &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/#handling-exceptions&#34;&gt;Handling exceptions&lt;/a&gt; section.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;enable_logging&lt;/code&gt; configuration key has been replaced by &lt;code&gt;log_channel&lt;/code&gt; to choose the log channel used when writing messages to the logs. If you still want to disable logging entirely, you may set the new configuration key to &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;em&gt;segment length&lt;/em&gt; and &lt;em&gt;keyframe interval&lt;/em&gt; of &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/#HLS&#34;&gt;HLS exports&lt;/a&gt; should be &lt;code&gt;2&lt;/code&gt; or more; less is not supported anymore.&lt;/li&gt; &#xA; &lt;li&gt;As Laravel 9 has migrated from &lt;a href=&#34;https://laravel.com/docs/9.x/upgrade#flysystem-3&#34;&gt;Flysystem 1.x to 3.x&lt;/a&gt;, this version is not compatible with Laravel 8 or earlier.&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re using the &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/#watermark-manipulation&#34;&gt;Watermark manipulation&lt;/a&gt; feature, make sure you upgrade &lt;a href=&#34;https://github.com/spatie/image&#34;&gt;&lt;code&gt;spatie/image&lt;/code&gt;&lt;/a&gt; to v2.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Upgrading to v7&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The namespace has changed to &lt;code&gt;ProtoneMedia\LaravelFFMpeg&lt;/code&gt;, the facade has been renamed to &lt;code&gt;ProtoneMedia\LaravelFFMpeg\Support\FFMpeg&lt;/code&gt;, and the Service Provider has been renamed to &lt;code&gt;ProtoneMedia\LaravelFFMpeg\Support\ServiceProvider&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Chaining exports are still supported, but you have to reapply filters for each export.&lt;/li&gt; &#xA; &lt;li&gt;HLS playlists now include bitrate, framerate and resolution data. The segments also use a new naming pattern (&lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/#using-custom-segment-patterns&#34;&gt;read more&lt;/a&gt;). Please verify your exports still work in your player.&lt;/li&gt; &#xA; &lt;li&gt;HLS export is now executed as &lt;em&gt;one&lt;/em&gt; job instead of exporting each format/stream separately. This uses FFMpeg&#39;s &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter_complex&lt;/code&gt; features. It might be sufficient to replace all calls to &lt;code&gt;addFilter&lt;/code&gt; with &lt;code&gt;addLegacyFilter&lt;/code&gt;, but some filters should be migrated manually. Please read the &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/#hls&#34;&gt;documentation on HLS&lt;/a&gt; to find out more about adding filters.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Convert an audio or video file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::fromDisk(&#39;songs&#39;)&#xA;    -&amp;gt;open(&#39;yesterday.mp3&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;toDisk(&#39;converted_songs&#39;)&#xA;    -&amp;gt;inFormat(new \FFMpeg\Format\Audio\Aac)&#xA;    -&amp;gt;save(&#39;yesterday.aac&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of the &lt;code&gt;fromDisk()&lt;/code&gt; method you can also use the &lt;code&gt;fromFilesystem()&lt;/code&gt; method, where &lt;code&gt;$filesystem&lt;/code&gt; is an instance of &lt;code&gt;Illuminate\Contracts\Filesystem\Filesystem&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$media = FFMpeg::fromFilesystem($filesystem)-&amp;gt;open(&#39;yesterday.mp3&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Progress monitoring&lt;/h3&gt; &#xA;&lt;p&gt;You can monitor the transcoding progress. Use the &lt;code&gt;onProgress&lt;/code&gt; method to provide a callback, which gives you the completed percentage. In previous versions of this package you had to pass the callback to the format object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;onProgress(function ($percentage) {&#xA;        echo &#34;{$percentage}% transcoded&#34;;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The callback may also expose &lt;code&gt;$remaining&lt;/code&gt; (in seconds) and &lt;code&gt;$rate&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;onProgress(function ($percentage, $remaining, $rate) {&#xA;        echo &#34;{$remaining} seconds left at rate: {$rate}&#34;;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Opening uploaded files&lt;/h3&gt; &#xA;&lt;p&gt;You can open uploaded files directly from the &lt;code&gt;Request&lt;/code&gt; instance. It&#39;s probably better to first save the uploaded file in case the request aborts, but if you want to, you can open a &lt;code&gt;UploadedFile&lt;/code&gt; instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class UploadVideoController&#xA;{&#xA;    public function __invoke(Request $request)&#xA;    {&#xA;        FFMpeg::open($request-&amp;gt;file(&#39;video&#39;));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Open files from the web&lt;/h3&gt; &#xA;&lt;p&gt;You can open files from the web by using the &lt;code&gt;openUrl&lt;/code&gt; method. You can specify custom HTTP headers with the optional second parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::openUrl(&#39;https://videocoursebuilder.com/lesson-1.mp4&#39;);&#xA;&#xA;FFMpeg::openUrl(&#39;https://videocoursebuilder.com/lesson-2.mp4&#39;, [&#xA;    &#39;Authorization&#39; =&amp;gt; &#39;Basic YWRtaW46MTIzNA==&#39;,&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handling exceptions&lt;/h3&gt; &#xA;&lt;p&gt;When the encoding fails, a &lt;code&gt;ProtoneMedia\LaravelFFMpeg\Exporters\EncodingException&lt;/code&gt; shall be thrown, which extends the underlying &lt;code&gt;FFMpeg\Exception\RuntimeException&lt;/code&gt; class. This class has two methods that can help you identify the problem. Using the &lt;code&gt;getCommand&lt;/code&gt; method, you can get the executed command with all parameters. The &lt;code&gt;getErrorOutput&lt;/code&gt; method gives you a full output log.&lt;/p&gt; &#xA;&lt;p&gt;In previous versions of this package, the message of the exception was always &lt;em&gt;Encoding failed&lt;/em&gt;. You can downgrade to this message by updating the &lt;code&gt;set_command_and_error_output_on_exception&lt;/code&gt; configuration key to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;try {&#xA;    FFMpeg::open(&#39;yesterday.mp3&#39;)&#xA;        -&amp;gt;export()&#xA;        -&amp;gt;inFormat(new Aac)&#xA;        -&amp;gt;save(&#39;yesterday.aac&#39;);&#xA;} catch (EncodingException $exception) {&#xA;    $command = $exception-&amp;gt;getCommand();&#xA;    $errorLog = $exception-&amp;gt;getErrorOutput();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Filters&lt;/h3&gt; &#xA;&lt;p&gt;You can add filters through a &lt;code&gt;Closure&lt;/code&gt; or by using PHP-FFMpeg&#39;s Filter objects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use FFMpeg\Filters\Video\VideoFilters;&#xA;&#xA;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addFilter(function (VideoFilters $filters) {&#xA;        $filters-&amp;gt;resize(new \FFMpeg\Coordinate\Dimension(640, 480));&#xA;    })&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;toDisk(&#39;converted_videos&#39;)&#xA;    -&amp;gt;inFormat(new \FFMpeg\Format\Video\X264)&#xA;    -&amp;gt;save(&#39;small_steve.mkv&#39;);&#xA;&#xA;// or&#xA;&#xA;$start = \FFMpeg\Coordinate\TimeCode::fromSeconds(5)&#xA;$clipFilter = new \FFMpeg\Filters\Video\ClipFilter($start);&#xA;&#xA;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addFilter($clipFilter)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;toDisk(&#39;converted_videos&#39;)&#xA;    -&amp;gt;inFormat(new \FFMpeg\Format\Video\X264)&#xA;    -&amp;gt;save(&#39;short_steve.mkv&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also call the &lt;code&gt;addFilter&lt;/code&gt; method &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;export&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use FFMpeg\Filters\Video\VideoFilters;&#xA;&#xA;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;toDisk(&#39;converted_videos&#39;)&#xA;    -&amp;gt;inFormat(new \FFMpeg\Format\Video\X264)&#xA;    -&amp;gt;addFilter(function (VideoFilters $filters) {&#xA;        $filters-&amp;gt;resize(new \FFMpeg\Coordinate\Dimension(640, 480));&#xA;    })&#xA;    -&amp;gt;save(&#39;small_steve.mkv&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Resizing&lt;/h4&gt; &#xA;&lt;p&gt;Since resizing is a common operation, we&#39;ve added a dedicated method for it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;inFormat(new \FFMpeg\Format\Video\X264)&#xA;    -&amp;gt;resize(640, 480)&#xA;    -&amp;gt;save(&#39;steve_howe_resized.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first argument is the width, and the second argument the height. The optional third argument is the mode. You can choose between &lt;code&gt;fit&lt;/code&gt; (default), &lt;code&gt;inset&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt;. The optional fourth argument is a boolean whether or not to force the use of standards ratios. You can find about these modes in the &lt;code&gt;FFMpeg\Filters\Video\ResizeFilter&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;h3&gt;Custom filters&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes you don&#39;t want to use the built-in filters. You can apply your own filter by providing a set of options. This can be an array or multiple strings as arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addFilter([&#39;-itsoffset&#39;, 1]);&#xA;&#xA;// or&#xA;&#xA;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addFilter(&#39;-itsoffset&#39;, 1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Watermark filter&lt;/h3&gt; &#xA;&lt;p&gt;You can easily add a watermark using the &lt;code&gt;addWatermark&lt;/code&gt; method. With the &lt;code&gt;WatermarkFactory&lt;/code&gt;, you can open your watermark file from a specific disk, just like opening an audio or video file. When you discard the &lt;code&gt;fromDisk&lt;/code&gt; method, it uses the default disk specified in the &lt;code&gt;filesystems.php&lt;/code&gt; configuration file.&lt;/p&gt; &#xA;&lt;p&gt;After opening your watermark file, you can position it with the &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, and &lt;code&gt;left&lt;/code&gt; methods. The first parameter of these methods is the offset, which is optional and can be negative.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use ProtoneMedia\LaravelFFMpeg\Filters\WatermarkFactory;&#xA;&#xA;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addWatermark(function(WatermarkFactory $watermark) {&#xA;        $watermark-&amp;gt;fromDisk(&#39;local&#39;)&#xA;            -&amp;gt;open(&#39;logo.png&#39;)&#xA;            -&amp;gt;right(25)&#xA;            -&amp;gt;bottom(25);&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of using the position methods, you can also use the &lt;code&gt;horizontalAlignment&lt;/code&gt; and &lt;code&gt;verticalAlignment&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;p&gt;For horizontal alignment, you can use the &lt;code&gt;WatermarkFactory::LEFT&lt;/code&gt;, &lt;code&gt;WatermarkFactory::CENTER&lt;/code&gt; and &lt;code&gt;WatermarkFactory::RIGHT&lt;/code&gt; constants. For vertical alignment, you can use the &lt;code&gt;WatermarkFactory::TOP&lt;/code&gt;, &lt;code&gt;WatermarkFactory::CENTER&lt;/code&gt; and &lt;code&gt;WatermarkFactory::BOTTOM&lt;/code&gt; constants. Both methods take an optional second parameter, which is the offset.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addWatermark(function(WatermarkFactory $watermark) {&#xA;        $watermark-&amp;gt;open(&#39;logo.png&#39;)&#xA;            -&amp;gt;horizontalAlignment(WatermarkFactory::LEFT, 25)&#xA;            -&amp;gt;verticalAlignment(WatermarkFactory::TOP, 25);&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;WatermarkFactory&lt;/code&gt; also supports opening files from the web with the &lt;code&gt;openUrl&lt;/code&gt; method. It supports custom HTTP headers as well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addWatermark(function(WatermarkFactory $watermark) {&#xA;        $watermark-&amp;gt;openUrl(&#39;https://videocoursebuilder.com/logo.png&#39;);&#xA;&#xA;        // or&#xA;&#xA;        $watermark-&amp;gt;openUrl(&#39;https://videocoursebuilder.com/logo.png&#39;, [&#xA;            &#39;Authorization&#39; =&amp;gt; &#39;Basic YWRtaW46MTIzNA==&#39;,&#xA;        ]);&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want more control over the GET request, you can pass in an optional third parameter, which gives you the Curl resource.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$watermark-&amp;gt;openUrl(&#39;https://videocoursebuilder.com/logo.png&#39;, [&#xA;    &#39;Authorization&#39; =&amp;gt; &#39;Basic YWRtaW46MTIzNA==&#39;,&#xA;], function($curl) {&#xA;    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 0);&#xA;    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Watermark manipulation&lt;/h4&gt; &#xA;&lt;p&gt;This package can manipulate watermarks by using &lt;a href=&#34;https://github.com/spatie/image&#34;&gt;Spatie&#39;s Image package&lt;/a&gt;. To get started, install the package with Composer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer require spatie/image&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can chain one more manipulation methods on the &lt;code&gt;WatermarkFactory&lt;/code&gt; instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;addWatermark(function(WatermarkFactory $watermark) {&#xA;        $watermark-&amp;gt;open(&#39;logo.png&#39;)&#xA;            -&amp;gt;right(25)&#xA;            -&amp;gt;bottom(25)&#xA;            -&amp;gt;width(100)&#xA;            -&amp;gt;height(100)&#xA;            -&amp;gt;greyscale();&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://spatie.be/docs/image/v1/introduction&#34;&gt;the documentation&lt;/a&gt; for all available methods.&lt;/p&gt; &#xA;&lt;h3&gt;Export without transcoding&lt;/h3&gt; &#xA;&lt;p&gt;This package comes with a &lt;code&gt;ProtoneMedia\LaravelFFMpeg\FFMpeg\CopyFormat&lt;/code&gt; class that allows you to export a file without transcoding the streams. You might want to use this to use another container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use ProtoneMedia\LaravelFFMpeg\FFMpeg\CopyFormat;&#xA;&#xA;FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;inFormat(new CopyFormat)&#xA;    -&amp;gt;save(&#39;video.mkv&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chain multiple convertions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// The &#39;fromDisk()&#39; method is not required, the file will now&#xA;// be opened from the default &#39;disk&#39;, as specified in&#xA;// the config file.&#xA;&#xA;FFMpeg::open(&#39;my_movie.mov&#39;)&#xA;&#xA;    // export to FTP, converted in WMV&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;toDisk(&#39;ftp&#39;)&#xA;    -&amp;gt;inFormat(new \FFMpeg\Format\Video\WMV)&#xA;    -&amp;gt;save(&#39;my_movie.wmv&#39;)&#xA;&#xA;    // export to Amazon S3, converted in X264&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;toDisk(&#39;s3&#39;)&#xA;    -&amp;gt;inFormat(new \FFMpeg\Format\Video\X264)&#xA;    -&amp;gt;save(&#39;my_movie.mkv&#39;);&#xA;&#xA;    // you could even discard the &#39;toDisk()&#39; method,&#xA;    // now the converted file will be saved to&#xA;    // the same disk as the source!&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;inFormat(new FFMpeg\Format\Video\WebM)&#xA;    -&amp;gt;save(&#39;my_movie.webm&#39;)&#xA;&#xA;    // optionally you could set the visibility&#xA;    // of the exported file&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;inFormat(new FFMpeg\Format\Video\WebM)&#xA;    -&amp;gt;withVisibility(&#39;public&#39;)&#xA;    -&amp;gt;save(&#39;my_movie.webm&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Export a frame from a video&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;getFrameFromSeconds(10)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;toDisk(&#39;thumnails&#39;)&#xA;    -&amp;gt;save(&#39;FrameAt10sec.png&#39;);&#xA;&#xA;// Instead of the &#39;getFrameFromSeconds()&#39; method, you could&#xA;// also use the &#39;getFrameFromString()&#39; or the&#xA;// &#39;getFrameFromTimecode()&#39; methods:&#xA;&#xA;$media = FFMpeg::open(&#39;steve_howe.mp4&#39;);&#xA;$frame = $media-&amp;gt;getFrameFromString(&#39;00:00:13.37&#39;);&#xA;&#xA;// or&#xA;&#xA;$timecode = new FFMpeg\Coordinate\TimeCode(...);&#xA;$frame = $media-&amp;gt;getFrameFromTimecode($timecode);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also get the raw contents of the frame instead of saving it to the filesystem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$contents = FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;getFrameFromSeconds(2)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;getFrameContents();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Export multiple frames at once&lt;/h3&gt; &#xA;&lt;p&gt;There is a &lt;code&gt;TileFilter&lt;/code&gt; that powers the &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/#creates-tiles-of-frames&#34;&gt;Tile-feature&lt;/a&gt;. To make exporting multiple frames faster and simpler, we leveraged this feature to add some helper methods. For example, you may use the &lt;code&gt;exportFramesByInterval&lt;/code&gt; method to export frames by a fixed interval. Alternatively, you may pass the number of frames you want to export to the &lt;code&gt;exportFramesByAmount&lt;/code&gt; method, which will then calculate the interval based on the duration of the video.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;exportFramesByInterval(2)&#xA;    -&amp;gt;save(&#39;thumb_%05d.jpg&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both methods accept an optional second and third argument to specify to width and height of the frames. Instead of passing both the width and height, you may also pass just one of them. FFmpeg will respect the aspect ratio of the source.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;exportFramesByAmount(10, 320, 180)&#xA;    -&amp;gt;save(&#39;thumb_%05d.png&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both methods accept an optional fourth argument to specify the quality of the image when you&#39;re exporting to a lossy format like JPEG. The range for JPEG is &lt;code&gt;2-31&lt;/code&gt;, with &lt;code&gt;2&lt;/code&gt; being the best quality and &lt;code&gt;31&lt;/code&gt; being the worst.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;exportFramesByInterval(2, 640, 360, 5)&#xA;    -&amp;gt;save(&#39;thumb_%05d.jpg&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creates tiles of frames&lt;/h3&gt; &#xA;&lt;p&gt;You can create tiles from a video. You may call the &lt;code&gt;exportTile&lt;/code&gt; method to specify how your tiles should be generated. In the example below, each generated image consists of a 3x5 grid (thus containing 15 frames) and each frame is 160x90 pixels. A frame will be taken every 5 seconds from the video. Instead of passing both the width and height, you may also pass just one of them. FFmpeg will respect the aspect ratio of the source.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use ProtoneMedia\LaravelFFMpeg\Filters\TileFactory;&#xA;&#xA;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportTile(function (TileFactory $factory) {&#xA;        $factory-&amp;gt;interval(5)&#xA;            -&amp;gt;scale(160, 90)&#xA;            -&amp;gt;grid(3, 5);&#xA;    })&#xA;    -&amp;gt;save(&#39;tile_%05d.jpg&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of passing both the width and height, you may also pass just one of them like &lt;code&gt;scale(160)&lt;/code&gt; or &lt;code&gt;scale(null, 90)&lt;/code&gt;. The aspect ratio will be respected. The &lt;code&gt;TileFactory&lt;/code&gt; has &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;padding&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt; methods as well. There&#39;s also a &lt;code&gt;quality&lt;/code&gt; method to specify the quality when exporting to a lossy format like JPEG. The range for JPEG is &lt;code&gt;2-31&lt;/code&gt;, with &lt;code&gt;2&lt;/code&gt; being the best quality and &lt;code&gt;31&lt;/code&gt; being the worst.&lt;/p&gt; &#xA;&lt;p&gt;This package can also generate a WebVTT file to add &lt;em&gt;Preview Thumbnails&lt;/em&gt; to your video player. This is supported out-of-the-box by &lt;a href=&#34;https://support.jwplayer.com/articles/how-to-add-preview-thumbnails&#34;&gt;JW player&lt;/a&gt; and there are community-driven plugins for Video.js available as well. You may call the &lt;code&gt;generateVTT&lt;/code&gt; method on the &lt;code&gt;TileFactory&lt;/code&gt; with the desired filename:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportTile(function (TileFactory $factory) {&#xA;        $factory-&amp;gt;interval(10)&#xA;            -&amp;gt;scale(320, 180)&#xA;            -&amp;gt;grid(5, 5)&#xA;            -&amp;gt;generateVTT(&#39;thumbnails.vtt&#39;);&#xA;    })&#xA;    -&amp;gt;save(&#39;tile_%05d.jpg&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple exports using loops&lt;/h3&gt; &#xA;&lt;p&gt;Chaining multiple conversions works because the &lt;code&gt;save&lt;/code&gt; method of the &lt;code&gt;MediaExporter&lt;/code&gt; returns a fresh instance of the &lt;code&gt;MediaOpener&lt;/code&gt;. You can use this to loop through items, for example, to exports multiple frames from one video:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$mediaOpener = FFMpeg::open(&#39;video.mp4&#39;);&#xA;&#xA;foreach ([5, 15, 25] as $key =&amp;gt; $seconds) {&#xA;    $mediaOpener = $mediaOpener-&amp;gt;getFrameFromSeconds($seconds)&#xA;        -&amp;gt;export()&#xA;        -&amp;gt;save(&#34;thumb_{$key}.png&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;MediaOpener&lt;/code&gt; comes with an &lt;code&gt;each&lt;/code&gt; method as well. The example above could be refactored like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;video.mp4&#39;)-&amp;gt;each([5, 15, 25], function ($ffmpeg, $seconds, $key) {&#xA;    $ffmpeg-&amp;gt;getFrameFromSeconds($seconds)-&amp;gt;export()-&amp;gt;save(&#34;thumb_{$key}.png&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Create a timelapse&lt;/h3&gt; &#xA;&lt;p&gt;You can create a timelapse from a sequence of images by using the &lt;code&gt;asTimelapseWithFramerate&lt;/code&gt; method on the exporter&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;feature_%04d.png&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;asTimelapseWithFramerate(1)&#xA;    -&amp;gt;inFormat(new X264)&#xA;    -&amp;gt;save(&#39;timelapse.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple inputs&lt;/h3&gt; &#xA;&lt;p&gt;You can open multiple inputs, even from different disks. This uses FFMpeg&#39;s &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter_complex&lt;/code&gt; features. You can open multiple files by chaining the &lt;code&gt;open&lt;/code&gt; method of by using an array. You can mix inputs from different disks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;video1.mp4&#39;)-&amp;gt;open(&#39;video2.mp4&#39;);&#xA;&#xA;FFMpeg::open([&#39;video1.mp4&#39;, &#39;video2.mp4&#39;]);&#xA;&#xA;FFMpeg::fromDisk(&#39;uploads&#39;)&#xA;    -&amp;gt;open(&#39;video1.mp4&#39;)&#xA;    -&amp;gt;fromDisk(&#39;archive&#39;)&#xA;    -&amp;gt;open(&#39;video2.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you open multiple inputs, you have to add mappings so FFMpeg knows how to route them. This package provides a &lt;code&gt;addFormatOutputMapping&lt;/code&gt; method, which takes three parameters: the format, the output, and the output labels of the &lt;code&gt;-filter_complex&lt;/code&gt; part.&lt;/p&gt; &#xA;&lt;p&gt;The output (2nd argument) should be an instanceof &lt;code&gt;ProtoneMedia\LaravelFFMpeg\Filesystem\Media&lt;/code&gt;. You can instantiate with the &lt;code&gt;make&lt;/code&gt; method, call it with the name of the disk and the path (see example).&lt;/p&gt; &#xA;&lt;p&gt;Check out this example, which maps separate video and audio inputs into one output.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::fromDisk(&#39;local&#39;)&#xA;    -&amp;gt;open([&#39;video.mp4&#39;, &#39;audio.m4a&#39;])&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;addFormatOutputMapping(new X264, Media::make(&#39;local&#39;, &#39;new_video.mp4&#39;), [&#39;0:v&#39;, &#39;1:a&#39;])&#xA;    -&amp;gt;save();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an example &lt;a href=&#34;https://github.com/PHP-FFMpeg/PHP-FFMpeg#base-usage&#34;&gt;from the underlying library&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// This code takes 2 input videos, stacks they horizontally in 1 output video and&#xA;// adds to this new video the audio from the first video. (It is impossible&#xA;// with a simple filter graph that has only 1 input and only 1 output).&#xA;&#xA;FFMpeg::fromDisk(&#39;local&#39;)&#xA;    -&amp;gt;open([&#39;video.mp4&#39;, &#39;video2.mp4&#39;])&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;addFilter(&#39;[0:v][1:v]&#39;, &#39;hstack&#39;, &#39;[v]&#39;)  // $in, $parameters, $out&#xA;    -&amp;gt;addFormatOutputMapping(new X264, Media::make(&#39;local&#39;, &#39;stacked_video.mp4&#39;), [&#39;0:a&#39;, &#39;[v]&#39;])&#xA;    -&amp;gt;save();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like single inputs, you can also pass a callback to the &lt;code&gt;addFilter&lt;/code&gt; method. This will give you an instance of &lt;code&gt;\FFMpeg\Filters\AdvancedMedia\ComplexFilters&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use FFMpeg\Filters\AdvancedMedia\ComplexFilters;&#xA;&#xA;FFMpeg::open([&#39;video.mp4&#39;, &#39;video2.mp4&#39;])&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;addFilter(function(ComplexFilters $filters) {&#xA;        // $filters-&amp;gt;watermark(...);&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Opening files from the web works similarly. You can pass an array of URLs to the &lt;code&gt;openUrl&lt;/code&gt; method, optionally with custom HTTP headers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::openUrl([&#xA;    &#39;https://videocoursebuilder.com/lesson-3.mp4&#39;,&#xA;    &#39;https://videocoursebuilder.com/lesson-4.mp4&#39;,&#xA;]);&#xA;&#xA;FFMpeg::openUrl([&#xA;    &#39;https://videocoursebuilder.com/lesson-3.mp4&#39;,&#xA;    &#39;https://videocoursebuilder.com/lesson-4.mp4&#39;,&#xA;], [&#xA;    &#39;Authorization&#39; =&amp;gt; &#39;Basic YWRtaW46MTIzNA==&#39;,&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use another set of HTTP headers for each URL, you can chain the &lt;code&gt;openUrl&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::openUrl(&#39;https://videocoursebuilder.com/lesson-5.mp4&#39;, [&#xA;    &#39;Authorization&#39; =&amp;gt; &#39;Basic YWRtaW46MTIzNA==&#39;,&#xA;])-&amp;gt;openUrl(&#39;https://videocoursebuilder.com/lesson-6.mp4&#39;, [&#xA;    &#39;Authorization&#39; =&amp;gt; &#39;Basic bmltZGE6NDMyMQ==&#39;,&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Concat files without transcoding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::fromDisk(&#39;local&#39;)&#xA;    -&amp;gt;open([&#39;video.mp4&#39;, &#39;video2.mp4&#39;])&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;concatWithoutTranscoding()&#xA;    -&amp;gt;save(&#39;concat.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Concat files with transcoding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::fromDisk(&#39;local&#39;)&#xA;    -&amp;gt;open([&#39;video.mp4&#39;, &#39;video2.mp4&#39;])&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;inFormat(new X264)&#xA;    -&amp;gt;concatWithTranscoding($hasVideo = true, $hasAudio = true)&#xA;    -&amp;gt;save(&#39;concat.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Determinate duration&lt;/h3&gt; &#xA;&lt;p&gt;With the &lt;code&gt;Media&lt;/code&gt; class you can determinate the duration of a file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$media = FFMpeg::open(&#39;wwdc_2006.mp4&#39;);&#xA;&#xA;$durationInSeconds = $media-&amp;gt;getDurationInSeconds(); // returns an int&#xA;$durationInMiliseconds = $media-&amp;gt;getDurationInMiliseconds(); // returns a float&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handling remote disks&lt;/h3&gt; &#xA;&lt;p&gt;When opening or saving files from or to a remote disk, temporary files will be created on your server. After you&#39;re done exporting or processing these files, you could clean them up by calling the &lt;code&gt;cleanupTemporaryFiles()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::cleanupTemporaryFiles();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the root of the temporary directories is evaluated by PHP&#39;s &lt;code&gt;sys_get_temp_dir()&lt;/code&gt; method, but you can modify it by setting the &lt;code&gt;temporary_files_root&lt;/code&gt; configuration key to a custom path.&lt;/p&gt; &#xA;&lt;h2&gt;HLS&lt;/h2&gt; &#xA;&lt;p&gt;You can create a M3U8 playlist to do &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Live_Streaming&#34;&gt;HLS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$lowBitrate = (new X264)-&amp;gt;setKiloBitrate(250);&#xA;$midBitrate = (new X264)-&amp;gt;setKiloBitrate(500);&#xA;$highBitrate = (new X264)-&amp;gt;setKiloBitrate(1000);&#xA;&#xA;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportForHLS()&#xA;    -&amp;gt;setSegmentLength(10) // optional&#xA;    -&amp;gt;setKeyFrameInterval(48) // optional&#xA;    -&amp;gt;addFormat($lowBitrate)&#xA;    -&amp;gt;addFormat($midBitrate)&#xA;    -&amp;gt;addFormat($highBitrate)&#xA;    -&amp;gt;save(&#39;adaptive_steve.m3u8&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;addFormat&lt;/code&gt; method of the HLS exporter takes an optional second parameter which can be a callback method. This allows you to add different filters per format. First, check out the &lt;em&gt;Multiple inputs&lt;/em&gt; section to understand how complex filters are handled.&lt;/p&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;addFilter&lt;/code&gt; method to add a complex filter (see &lt;code&gt;$lowBitrate&lt;/code&gt; example). Since the &lt;code&gt;scale&lt;/code&gt; filter is used a lot, there is a helper method (see &lt;code&gt;$midBitrate&lt;/code&gt; example). You can also use a callable to get access to the &lt;code&gt;ComplexFilters&lt;/code&gt; instance. The package provides the &lt;code&gt;$in&lt;/code&gt; and &lt;code&gt;$out&lt;/code&gt; arguments so you don&#39;t have to worry about it (see &lt;code&gt;$highBitrate&lt;/code&gt; example).&lt;/p&gt; &#xA;&lt;p&gt;HLS export is built using FFMpeg&#39;s &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter_complex&lt;/code&gt; features. This is a breaking change from earlier versions (1.x - 6.x) which performed a single export for each format. If you&#39;re upgrading, replace the &lt;code&gt;addFilter&lt;/code&gt; calls with &lt;code&gt;addLegacyFilter&lt;/code&gt; calls and verify the result (see &lt;code&gt;$superBitrate&lt;/code&gt; example). Not all filters will work this way and some need to be upgraded manually.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$lowBitrate = (new X264)-&amp;gt;setKiloBitrate(250);&#xA;$midBitrate = (new X264)-&amp;gt;setKiloBitrate(500);&#xA;$highBitrate = (new X264)-&amp;gt;setKiloBitrate(1000);&#xA;$superBitrate = (new X264)-&amp;gt;setKiloBitrate(1500);&#xA;&#xA;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportForHLS()&#xA;    -&amp;gt;addFormat($lowBitrate, function($media) {&#xA;        $media-&amp;gt;addFilter(&#39;scale=640:480&#39;);&#xA;    })&#xA;    -&amp;gt;addFormat($midBitrate, function($media) {&#xA;        $media-&amp;gt;scale(960, 720);&#xA;    })&#xA;    -&amp;gt;addFormat($highBitrate, function ($media) {&#xA;        $media-&amp;gt;addFilter(function ($filters, $in, $out) {&#xA;            $filters-&amp;gt;custom($in, &#39;scale=1920:1200&#39;, $out); // $in, $parameters, $out&#xA;        });&#xA;    })&#xA;    -&amp;gt;addFormat($superBitrate, function($media) {&#xA;        $media-&amp;gt;addLegacyFilter(function ($filters) {&#xA;            $filters-&amp;gt;resize(new \FFMpeg\Coordinate\Dimension(2560, 1920));&#xA;        });&#xA;    })&#xA;    -&amp;gt;save(&#39;adaptive_steve.m3u8&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using custom segment patterns&lt;/h3&gt; &#xA;&lt;p&gt;You can use a custom pattern to name the segments and playlists. The &lt;code&gt;useSegmentFilenameGenerator&lt;/code&gt; gives you 5 arguments. The first, second and third argument provide information about the basename of the export, the format of the current iteration and the key of the current iteration. The fourth argument is a callback you should call with your &lt;em&gt;segments&lt;/em&gt; pattern. The fifth argument is a callback you should call with your &lt;em&gt;playlist&lt;/em&gt; pattern. Note that this is not the name of the primary playlist, but the name of the playlist of each format.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::fromDisk(&#39;videos&#39;)&#xA;    -&amp;gt;open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportForHLS()&#xA;    -&amp;gt;useSegmentFilenameGenerator(function ($name, $format, $key, callable $segments, callable $playlist) {&#xA;        $segments(&#34;{$name}-{$format-&amp;gt;getKiloBitrate()}-{$key}-%03d.ts&#34;);&#xA;        $playlist(&#34;{$name}-{$format-&amp;gt;getKiloBitrate()}-{$key}.m3u8&#34;);&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encrypted HLS&lt;/h3&gt; &#xA;&lt;p&gt;You can encrypt each HLS segment using AES-128 encryption. To do this, call the &lt;code&gt;withEncryptionKey&lt;/code&gt; method on the HLS exporter with a key. We provide a &lt;code&gt;generateEncryptionKey&lt;/code&gt; helper method on the &lt;code&gt;HLSExporter&lt;/code&gt; class to generate a key. Make sure you store the key well, as the exported result is worthless without the key. By default, the filename of the key is &lt;code&gt;secret.key&lt;/code&gt;, but you can change that with the optional second parameter of the &lt;code&gt;withEncryptionKey&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use ProtoneMedia\LaravelFFMpeg\Exporters\HLSExporter;&#xA;&#xA;$encryptionKey = HLSExporter::generateEncryptionKey();&#xA;&#xA;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportForHLS()&#xA;    -&amp;gt;withEncryptionKey($encryptionKey)&#xA;    -&amp;gt;addFormat($lowBitrate)&#xA;    -&amp;gt;addFormat($midBitrate)&#xA;    -&amp;gt;addFormat($highBitrate)&#xA;    -&amp;gt;save(&#39;adaptive_steve.m3u8&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To secure your HLS export even further, you can rotate the key on each exported segment. By doing so, it will generate multiple keys that you&#39;ll need to store. Use the &lt;code&gt;withRotatingEncryptionKey&lt;/code&gt; method to enable this feature and provide a callback that implements the storage of the keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportForHLS()&#xA;    -&amp;gt;withRotatingEncryptionKey(function ($filename, $contents) {&#xA;        $videoId = 1;&#xA;&#xA;        // use this callback to store the encryption keys&#xA;&#xA;        Storage::disk(&#39;secrets&#39;)-&amp;gt;put($videoId . &#39;/&#39; . $filename, $contents);&#xA;&#xA;        // or...&#xA;&#xA;        DB::table(&#39;hls_secrets&#39;)-&amp;gt;insert([&#xA;            &#39;video_id&#39; =&amp;gt; $videoId,&#xA;            &#39;filename&#39; =&amp;gt; $filename,&#xA;            &#39;contents&#39; =&amp;gt; $contents,&#xA;        ]);&#xA;    })&#xA;    -&amp;gt;addFormat($lowBitrate)&#xA;    -&amp;gt;addFormat($midBitrate)&#xA;    -&amp;gt;addFormat($highBitrate)&#xA;    -&amp;gt;save(&#39;adaptive_steve.m3u8&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;withRotatingEncryptionKey&lt;/code&gt; method has an optional second argument to set the number of segments that use the same key. This defaults to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;steve_howe.mp4&#39;)&#xA;    -&amp;gt;exportForHLS()&#xA;    -&amp;gt;withRotatingEncryptionKey($callable, 10);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some filesystems, especially on cheap and slow VPSs, are not fast enough to handle the rotating key. This may lead to encoding exceptions, like &lt;code&gt;No key URI specified in key info file&lt;/code&gt;. One possible solution is to use a different storage for the keys, which you can specify using the &lt;code&gt;temporary_files_encrypted_hls&lt;/code&gt; configuration key. On UNIX-based systems, you may use a &lt;code&gt;tmpfs&lt;/code&gt; filesystem to increase read/write speeds:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// config/laravel-ffmpeg.php&#xA;&#xA;return [&#xA;&#xA;    &#39;temporary_files_encrypted_hls&#39; =&amp;gt; &#39;/dev/shm&#39;&#xA;&#xA;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Protecting your HLS encryption keys&lt;/h3&gt; &#xA;&lt;p&gt;To make working with encrypted HLS even better, we&#39;ve added a &lt;code&gt;DynamicHLSPlaylist&lt;/code&gt; class that modifies playlists on-the-fly and specifically for your application. This way, you can add your authentication and authorization logic. As we&#39;re using a plain Laravel controller, you can use features like &lt;a href=&#34;https://laravel.com/docs/master/authorization#gates&#34;&gt;Gates&lt;/a&gt; and &lt;a href=&#34;https://laravel.com/docs/master/middleware#introduction&#34;&gt;Middleware&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In this example, we&#39;ve saved the HLS export to the &lt;code&gt;public&lt;/code&gt; disk, and we&#39;ve stored the encryption keys to the &lt;code&gt;secrets&lt;/code&gt; disk, which isn&#39;t publicly available. As the browser can&#39;t access the encryption keys, it won&#39;t play the video. Each playlist has paths to the encryption keys, and we need to modify those paths to point to an accessible endpoint.&lt;/p&gt; &#xA;&lt;p&gt;This implementation consists of two routes. One that responses with an encryption key and one that responses with a modified playlist. The first route (&lt;code&gt;video.key&lt;/code&gt;) is relatively simple, and this is where you should add your additional logic.&lt;/p&gt; &#xA;&lt;p&gt;The second route (&lt;code&gt;video.playlist&lt;/code&gt;) uses the &lt;code&gt;DynamicHLSPlaylist&lt;/code&gt; class. Call the &lt;code&gt;dynamicHLSPlaylist&lt;/code&gt; method on the &lt;code&gt;FFMpeg&lt;/code&gt; facade, and similar to opening media files, you can open a playlist utilizing the &lt;code&gt;fromDisk&lt;/code&gt; and &lt;code&gt;open&lt;/code&gt; methods. Then you must provide three callbacks. Each of them gives you a relative path and expects a full path in return. As the &lt;code&gt;DynamicHLSPlaylist&lt;/code&gt; class implements the &lt;code&gt;Illuminate\Contracts\Support\Responsable&lt;/code&gt; interface, you can return the instance.&lt;/p&gt; &#xA;&lt;p&gt;The first callback (KeyUrlResolver) gives you the relative path to an encryption key. The second callback (MediaUrlResolver) gives you the relative path to a media segment (.ts files). The third callback (PlaylistUrlResolver) gives you the relative path to a playlist.&lt;/p&gt; &#xA;&lt;p&gt;Now instead of using &lt;code&gt;Storage::disk(&#39;public&#39;)-&amp;gt;url(&#39;adaptive_steve.m3u8&#39;)&lt;/code&gt; to get the full url to your primary playlist, you can use &lt;code&gt;route(&#39;video.playlist&#39;, [&#39;playlist&#39; =&amp;gt; &#39;adaptive_steve.m3u8&#39;])&lt;/code&gt;. The &lt;code&gt;DynamicHLSPlaylist&lt;/code&gt; class takes care of all the paths and urls.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Route::get(&#39;/video/secret/{key}&#39;, function ($key) {&#xA;    return Storage::disk(&#39;secrets&#39;)-&amp;gt;download($key);&#xA;})-&amp;gt;name(&#39;video.key&#39;);&#xA;&#xA;Route::get(&#39;/video/{playlist}&#39;, function ($playlist) {&#xA;    return FFMpeg::dynamicHLSPlaylist()&#xA;        -&amp;gt;fromDisk(&#39;public&#39;)&#xA;        -&amp;gt;open($playlist)&#xA;        -&amp;gt;setKeyUrlResolver(function ($key) {&#xA;            return route(&#39;video.key&#39;, [&#39;key&#39; =&amp;gt; $key]);&#xA;        })&#xA;        -&amp;gt;setMediaUrlResolver(function ($mediaFilename) {&#xA;            return Storage::disk(&#39;public&#39;)-&amp;gt;url($mediaFilename);&#xA;        })&#xA;        -&amp;gt;setPlaylistUrlResolver(function ($playlistFilename) {&#xA;            return route(&#39;video.playlist&#39;, [&#39;playlist&#39; =&amp;gt; $playlistFilename]);&#xA;        });&#xA;})-&amp;gt;name(&#39;video.playlist&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Live Coding Session&lt;/h3&gt; &#xA;&lt;p&gt;Here you can find a Live Coding Session about HLS encryption:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=WlbzWoAcez4&#34;&gt;https://www.youtube.com/watch?v=WlbzWoAcez4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Process Output&lt;/h2&gt; &#xA;&lt;p&gt;You can get the raw process output by calling the &lt;code&gt;getProcessOutput&lt;/code&gt; method. Though the use-case is limited, you can use it to analyze a file (for example, with the &lt;code&gt;volumedetect&lt;/code&gt; filter). It returns a &lt;code&gt;ProtoneMedia\LaravelFFMpeg\Support\ProcessOutput&lt;/code&gt; class that has three methods: &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt;. Each method returns an array with the corresponding lines.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$processOutput = FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;addFilter([&#39;-filter:a&#39;, &#39;volumedetect&#39;, &#39;-f&#39;, &#39;null&#39;])&#xA;    -&amp;gt;getProcessOutput();&#xA;&#xA;$processOutput-&amp;gt;all();&#xA;$processOutput-&amp;gt;errors();&#xA;$processOutput-&amp;gt;out();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advanced&lt;/h2&gt; &#xA;&lt;p&gt;The Media object you get when you &#39;open&#39; a file, actually holds the Media object that belongs to the &lt;a href=&#34;https://github.com/PHP-FFMpeg/PHP-FFMpeg&#34;&gt;underlying driver&lt;/a&gt;. It handles dynamic method calls as you can see &lt;a href=&#34;https://github.com/pascalbaljetmedia/laravel-ffmpeg/raw/master/src/Media.php#L114-L117&#34;&gt;here&lt;/a&gt;. This way all methods of the underlying driver are still available to you.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// This gives you an instance of ProtoneMedia\LaravelFFMpeg\MediaOpener&#xA;$media = FFMpeg::fromDisk(&#39;videos&#39;)-&amp;gt;open(&#39;video.mp4&#39;);&#xA;&#xA;// The &#39;getStreams&#39; method will be called on the underlying Media object since&#xA;// it doesn&#39;t exists on this object.&#xA;$codec = $media-&amp;gt;getStreams()-&amp;gt;first()-&amp;gt;get(&#39;codec_name&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want direct access to the underlying object, call the object as a function (invoke):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// This gives you an instance of ProtoneMedia\LaravelFFMpeg\MediaOpener&#xA;$media = FFMpeg::fromDisk(&#39;videos&#39;)-&amp;gt;open(&#39;video.mp4&#39;);&#xA;&#xA;// This gives you an instance of FFMpeg\Media\MediaTypeInterface&#xA;$baseMedia = $media();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Experimental&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/#progress-monitoring&#34;&gt;progress listener&lt;/a&gt; exposes the transcoded percentage, but the underlying package also has an internal &lt;code&gt;AbstractProgressListener&lt;/code&gt; that exposes the current pass and the current time. Though the use-case is limited, you might want to get access to this listener instance. You can do this by decorating the format with the &lt;code&gt;ProgressListenerDecorator&lt;/code&gt;. This feature is highly experimental, so be sure the test this thoroughly before using it in production.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use FFMpeg\Format\ProgressListener\AbstractProgressListener;&#xA;use ProtoneMedia\LaravelFFMpeg\FFMpeg\ProgressListenerDecorator;&#xA;&#xA;$format = new \FFMpeg\Format\Video\X264;&#xA;$decoratedFormat = ProgressListenerDecorator::decorate($format);&#xA;&#xA;FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;inFormat($decoratedFormat)&#xA;    -&amp;gt;onProgress(function () use ($decoratedFormat) {&#xA;        $listeners = $decoratedFormat-&amp;gt;getListeners();  // array of listeners&#xA;&#xA;        $listener = $listeners[0];  // instance of AbstractProgressListener&#xA;&#xA;        $listener-&amp;gt;getCurrentPass();&#xA;        $listener-&amp;gt;getTotalPass();&#xA;        $listener-&amp;gt;getCurrentTime();&#xA;    })&#xA;    -&amp;gt;save(&#39;new_video.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since we can&#39;t get rid of some of the underlying options, you can interact with the final FFmpeg command by adding a callback to the exporter. You can add one or more callbacks by using the &lt;code&gt;beforeSaving&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;FFMpeg::open(&#39;video.mp4&#39;)&#xA;    -&amp;gt;export()&#xA;    -&amp;gt;inFormat(new X264)&#xA;    -&amp;gt;beforeSaving(function ($commands) {&#xA;        $commands[] = &#39;-hello&#39;;&#xA;&#xA;        return $commands;&#xA;    })&#xA;    -&amp;gt;save(&#39;concat.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: this does not work with concatenation and frame exports&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example app&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a blog post that will help you get started with this package:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://protone.media/en/blog/how-to-use-ffmpeg-in-your-laravel-projects&#34;&gt;https://protone.media/en/blog/how-to-use-ffmpeg-in-your-laravel-projects&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Using Video.js to play HLS in any browser&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a 20-minute overview how to get started with Video.js. It covers including Video.js from a CDN, importing it as an ES6 module with Laravel Mix (Webpack) and building a reusable Vue.js component.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=nA1Jy8BPjys&#34;&gt;https://www.youtube.com/watch?v=nA1Jy8BPjys&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Wiki&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-ffmpeg/wiki/Custom-filters&#34;&gt;Custom filters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-ffmpeg/wiki/FFmpeg-failed-to-execute-command&#34;&gt;FFmpeg failed to execute command&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-ffmpeg/wiki/Get-the-dimensions-of-a-Video-file&#34;&gt;Get the dimensions of a Video file&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-ffmpeg/wiki/Monitoring-the-transcoding-progress&#34;&gt;Monitoring the transcoding progress&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-ffmpeg/wiki/Unable-to-load-FFProbe&#34;&gt;Unable to load FFProbe&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; for more information about what has changed recently.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ composer test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Other Laravel packages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-analytics-event-tracking&#34;&gt;&lt;code&gt;Laravel Analytics Event Tracking&lt;/code&gt;&lt;/a&gt;: Laravel package to easily send events to Google Analytics.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-blade-on-demand&#34;&gt;&lt;code&gt;Laravel Blade On Demand&lt;/code&gt;&lt;/a&gt;: Laravel package to compile Blade templates in memory.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-cross-eloquent-search&#34;&gt;&lt;code&gt;Laravel Cross Eloquent Search&lt;/code&gt;&lt;/a&gt;: Laravel package to search through multiple Eloquent models.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-eloquent-scope-as-select&#34;&gt;&lt;code&gt;Laravel Eloquent Scope as Select&lt;/code&gt;&lt;/a&gt;: Stop duplicating your Eloquent query scopes and constraints in PHP. This package lets you re-use your query scopes and constraints by adding them as a subquery.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-eloquent-where-not&#34;&gt;&lt;code&gt;Laravel Eloquent Where Not&lt;/code&gt;&lt;/a&gt;: This Laravel package allows you to flip/invert an Eloquent scope, or really any query constraint.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-form-components&#34;&gt;&lt;code&gt;Laravel Form Components&lt;/code&gt;&lt;/a&gt;: Blade components to rapidly build forms with Tailwind CSS Custom Forms and Bootstrap 4. Supports validation, model binding, default values, translations, includes default vendor styling and fully customizable!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-mixins&#34;&gt;&lt;code&gt;Laravel Mixins&lt;/code&gt;&lt;/a&gt;: A collection of Laravel goodies.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-paddle&#34;&gt;&lt;code&gt;Laravel Paddle&lt;/code&gt;&lt;/a&gt;: Paddle.com API integration for Laravel with support for webhooks/events.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-verify-new-email&#34;&gt;&lt;code&gt;Laravel Verify New Email&lt;/code&gt;&lt;/a&gt;: This package adds support for verifying new email addresses: when a user updates its email address, it won&#39;t replace the old one until the new one is verified.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protonemedia/laravel-webdav&#34;&gt;&lt;code&gt;Laravel WebDAV&lt;/code&gt;&lt;/a&gt;: WebDAV driver for Laravel&#39;s Filesystem.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;If you discover any security-related issues, please email &lt;a href=&#34;mailto:code@protone.media&#34;&gt;code@protone.media&lt;/a&gt; instead of using the issue tracker. Please do not email any questions, open an issue if you have a question.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pascalbaljet&#34;&gt;Pascal Baljet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/contributors&#34;&gt;All Contributors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT). Please see &lt;a href=&#34;https://raw.githubusercontent.com/protonemedia/laravel-ffmpeg/main/LICENSE.md&#34;&gt;License File&lt;/a&gt; for more information.&lt;/p&gt;</summary>
  </entry>
</feed>