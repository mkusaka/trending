<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-05T01:32:06Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Sammyjo20/laravel-haystack</title>
    <updated>2022-08-05T01:32:06Z</updated>
    <id>tag:github.com,2022-08-05:/Sammyjo20/laravel-haystack</id>
    <link href="https://github.com/Sammyjo20/laravel-haystack" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üë©‚Äçüåæ Beautifully simple but powerful database-driven job chains.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/29132017/181642184-e95e6214-2ff0-4a32-985e-938432b7b3f5.jpeg&#34; width=&#34;250&#34;&gt; &#xA; &lt;h1&gt;Laravel Haystack&lt;/h1&gt; &#xA; &lt;p&gt;Beautifully simple but powerful database-driven job chains.&lt;/p&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/sammyjo20/laravel-haystack/actions/workflows/tests.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Laravel Haystack is a package that allows you to have a job chain stored in the database. Since all of the jobs in the chain are in the database, memory usage is low and you can delay jobs for a long time or have long running jobs without risking using all your memory. Laravel Haystack supports every queue connection/worker out of the box. (Database, Redis/Horizon, SQS).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;addJob(new ProcessPodcast)&#xA;   -&amp;gt;addJob(new PublishPodcast)&#xA;   -&amp;gt;then(function () {&#xA;      // Haystack completed&#xA;   })&#xA;   -&amp;gt;catch(function () {&#xA;      // Haystack failed&#xA;   })&#xA;   -&amp;gt;finally(function () {&#xA;      // Always run either on success or fail.&#xA;   })&#xA;   -&amp;gt;paused(function () {&#xA;      // Run if the haystack is paused&#xA;   })&#xA;   -&amp;gt;withMiddleware([&#xA;      // Middleware to apply on every job&#xA;   ])&#xA;   -&amp;gt;withDelay(60) // Add a delay to every job&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;But doesn&#39;t Laravel already have job chains?&lt;/h3&gt; &#xA;&lt;p&gt;That&#39;s right! Let&#39;s just be clear that we&#39;re not talking about &lt;strong&gt;Batched Jobs&lt;/strong&gt;. Laravel does have job chains but they have some considerations.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;They consume quite a lot of memory/data since the chain is stored inside the job. This is especially true if you are storing thousands of jobs.&lt;/li&gt; &#xA; &lt;li&gt;They are volatile, meaning if you lose one job in the chain - you lose the whole chain.&lt;/li&gt; &#xA; &lt;li&gt;They do not provide the &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt; callable methods that batched jobs do.&lt;/li&gt; &#xA; &lt;li&gt;Long delays with memory based or SQS queue is not possible as you could lose the jobs due to expiry or if the server shuts down.&lt;/li&gt; &#xA; &lt;li&gt;You can&#39;t share data between jobs as there is no &#34;state&#34; across the chain&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Laravel Haystack aims to solve this by storing the job chain in the database and queuing one job at a time. When the job is completed, Laravel Haystack listens out for the &#34;job completed&#34; event and queues the next job in the chain from the database.&lt;/p&gt; &#xA;&lt;h3&gt;Laravel Haystack Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Low memory consumption as one job is processed at a time and the chain is stored in the database&lt;/li&gt; &#xA; &lt;li&gt;You can delay/release jobs for as long as you want since it will use the scheduler to restart a chain. Even if your queue driver is SQS!&lt;/li&gt; &#xA; &lt;li&gt;It provides callback methods like &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Global middleware that can be applied to every single job in the chain&lt;/li&gt; &#xA; &lt;li&gt;Delay that can be added to every job in the chain&lt;/li&gt; &#xA; &lt;li&gt;You can store and retrieve data/state that is accessible to every job in the chain.&lt;/li&gt; &#xA; &lt;li&gt;You can store the model for later processing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Use Cases&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you need to make hundreds or thousands of API calls in a row, can be combined with Spatie&#39;s Job Rate Limiter to keep track of delays and pause jobs when a rate limit is hit.&lt;/li&gt; &#xA; &lt;li&gt;If you need to queue thousands of jobs in a chain at a time.&lt;/li&gt; &#xA; &lt;li&gt;If you need to batch import rows of data - each row can be a haystack job (bale) and processed one at a time. While keeping important job information stored in the database.&lt;/li&gt; &#xA; &lt;li&gt;If you need &#34;release&#34; times longer than 15 minutes if you are using Amazon SQS&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the package via composer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer require sammyjo20/laravel-haystack&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Requires Laravel 8+ and PHP 8.1&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Then publish and run the migrations with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;php artisan vendor:publish --tag=&#34;haystack-migrations&#34;&#xA;php artisan migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can publish the config file with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;php artisan vendor:publish --tag=&#34;haystack-config&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Configuring Jobs&lt;/h3&gt; &#xA;&lt;p&gt;To prepare your jobs for Laravel Haystack, you must add the &lt;strong&gt;StackableJob&lt;/strong&gt; interface and &lt;strong&gt;Stackable&lt;/strong&gt; trait to your jobs. This provides the properties and methods Haystack requires.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class ProcessPodcast implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building Haystacks&lt;/h3&gt; &#xA;&lt;p&gt;Let‚Äôs create our first Haystack. To get started, import the Haystack model and then call the ‚Äúbuild‚Äù static function on it. This will provide you with the &lt;strong&gt;HaystackBuilder&lt;/strong&gt; class which can be used to define your haystack. You can then use the ‚ÄúaddJob‚Äù method to add jobs to the Haystack. Make sure all the jobs have the &lt;strong&gt;StackableJob&lt;/strong&gt; interface and &lt;strong&gt;Stackable&lt;/strong&gt; trait.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;use Sammyjo20\LaravelHaystack\Models\Haystack;&#xA;&#xA;Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;addJob(new PublishPodcast)&#xA;   -&amp;gt;addJob(new TweetAboutPodcast);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dispatching Haystacks&lt;/h3&gt; &#xA;&lt;p&gt;Once you have created your Haystack, you can dispatch it using the &lt;code&gt;dispatch&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;use Sammyjo20\LaravelHaystack\Models\Haystack;&#xA;&#xA;Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;addJob(new PublishPodcast)&#xA;   -&amp;gt;addJob(new TweetAboutPodcast)&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating Haystacks For Later&lt;/h3&gt; &#xA;&lt;p&gt;Use the create method to create the model and store it somewhere for later processing. You can start the Haystack at any time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;use Sammyjo20\LaravelHaystack\Models\Haystack;&#xA;&#xA;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;addJob(new PublishPodcast)&#xA;   -&amp;gt;addJob(new TweetAboutPodcast)&#xA;   -&amp;gt;create();&#xA;&#xA;// Do other things...&#xA;&#xA;$haystack-&amp;gt;start(); // Initiate haystack&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Callback Events&lt;/h2&gt; &#xA;&lt;p&gt;Laravel Haystack provides you with three really simple callback events that will be serialized and used at certain points in time.&lt;/p&gt; &#xA;&lt;h3&gt;Then&lt;/h3&gt; &#xA;&lt;p&gt;The ‚Äúthen‚Äù event is triggered when the haystack has completed successfully.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;then(function () {&#xA;       // Do something... &#xA;   })&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Catch&lt;/h3&gt; &#xA;&lt;p&gt;The ‚Äúcatch‚Äù event is triggered when the haystack has failed. You will still have the failed job to see what the error was, but this is useful if you need to perform any cleanup.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;catch(function () {&#xA;       // Do something... &#xA;   })&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Finally&lt;/h3&gt; &#xA;&lt;p&gt;The ‚Äúfinally ‚Äúevent is always triggered at the end of a haystack, if it was successful or if it failed. This is very useful if you want to have loading states in your application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;finally(function () {&#xA;       // Do something... &#xA;   })&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Paused&lt;/h3&gt; &#xA;&lt;p&gt;The &#34;paused&#34; event is triggered if the Haystack has been paused using the &lt;code&gt;pauseHaystack&lt;/code&gt; method or a job has been released using the &lt;code&gt;longRelease&lt;/code&gt; method. This is useful if you need to update the database to mark an import as paused, especially if the pause is for a long time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;paused(function () {&#xA;       // Do something... &#xA;   })&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invokable classes&lt;/h3&gt; &#xA;&lt;p&gt;Each of these methods support invokable classes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RecordPodcast)&#xA;   -&amp;gt;then(new Then)&#xA;   -&amp;gt;catch(new Catch)&#xA;   -&amp;gt;finally(new Finally)&#xA;   -&amp;gt;paused(new Paused)&#xA;   -&amp;gt;dispatch();&#xA;&#xA;// Example Invokable class&#xA;&#xA;class Then {&#xA;   public function __invoke()&#xA;   {&#xA;       // Do something...&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuring&lt;/h2&gt; &#xA;&lt;p&gt;You can configure a global delay, connection and queue that will apply to all jobs in the haystack. You can also provide a per-job configuration if you choose to too.&lt;/p&gt; &#xA;&lt;h3&gt;Delay&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;withDelay&lt;/code&gt; method to apply a global delay to every job.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;withDelay(60)&#xA;   -&amp;gt;addJob(new RecordPodcast) &#xA;   -&amp;gt;addJob(new ProcessPodcast)&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Connection&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;onConnection&lt;/code&gt; method to use a given connection for every job.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;onConnection(&#39;redis&#39;)&#xA;   -&amp;gt;addJob(new RecordPodcast) &#xA;   -&amp;gt;addJob(new ProcessPodcast)&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Queue&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;onQueue&lt;/code&gt; method to use a given queue for every job.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;onQueue(&#39;podcasts&#39;)&#xA;   -&amp;gt;addJob(new RecordPodcast) &#xA;   -&amp;gt;addJob(new ProcessPodcast)&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom Delay, Connection, Queue Per Job&lt;/h3&gt; &#xA;&lt;p&gt;You can also choose to use a different delay, connection or queue for every job!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;onQueue(&#39;podcasts&#39;)&#xA;   -&amp;gt;addJob(new RecordPodcast, delay: 60, queue: &#39;low&#39;, connection: &#39;redis&#39;) &#xA;   -&amp;gt;addJob(new ProcessPodcast, delay: 120, queue: &#39;high&#39;, connection: &#39;sqs&#39;)&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you have already configured the job with delay, connection or queue, it will use that configuration.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Global Middleware&lt;/h2&gt; &#xA;&lt;p&gt;You can also provide middleware that will be applied to every job in the haystack. This is perfect if you don‚Äôt want to manually add the middleware to every job, or if the middleware can‚Äôt belong to the job on its own. This is extremely useful if you want to apply an API rate limiter to your requests. Just use the &lt;code&gt;withMiddleware&lt;/code&gt; method. It will accept either an array, a closure that returns an array or an invokable class that returns an array.&lt;/p&gt; &#xA;&lt;h3&gt;Array&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;onQueue(&#39;podcasts&#39;)&#xA;   -&amp;gt;addJob(new RecordPodcast) &#xA;   -&amp;gt;addJob(new ProcessPodcast)&#xA;   -&amp;gt;withMiddleware([&#xA;       (new RateLimited)-&amp;gt;allows(30)-&amp;gt;everyMinute(),&#xA;       new OtherMiddleware,&#xA;   ])&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Closure&lt;/h3&gt; &#xA;&lt;p&gt;You must return an array in the closure for it to work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;onQueue(&#39;podcasts&#39;)&#xA;   -&amp;gt;addJob(new RecordPodcast) &#xA;   -&amp;gt;addJob(new ProcessPodcast)&#xA;   -&amp;gt;withMiddleware(function () {&#xA;        return [&#xA;           (new RateLimited)-&amp;gt;allows(30)-&amp;gt;everyMinute(),&#xA;           new OtherMiddleware,&#xA;        ];&#xA;   })&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invokable class&lt;/h3&gt; &#xA;&lt;p&gt;You must return an array inside your invokable class for it to work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$haystack = Haystack::build()&#xA;   -&amp;gt;onQueue(&#39;podcasts&#39;)&#xA;   -&amp;gt;addJob(new RecordPodcast) &#xA;   -&amp;gt;addJob(new ProcessPodcast)&#xA;   -&amp;gt;withMiddleware(new PodcastMiddleware)&#xA;   -&amp;gt;dispatch();&#xA;&#xA;// Invokable class...&#xA;&#xA;class PodcastMiddleware {&#xA;    public function __invoke()&#xA;    {&#xA;&#x9;&#x9;return [&#xA;&#x9;        (new RateLimited)-&amp;gt;allows(30)-&amp;gt;everyMinute(),&#xA;&#x9;&#x9;    new OtherMiddleware,&#xA;&#x9;&#x9;];&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Appending Jobs&lt;/h2&gt; &#xA;&lt;p&gt;You can append to the haystack inside of your job. If you choose to do this, the appended job will go at the end of the chain. Just use the &lt;code&gt;appendToHaystack&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class ProcessPodcast implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function handle()&#xA;    {&#xA;        // Your application code...&#xA;&#xA;        $this-&amp;gt;appendToHaystack(new DifferentJob);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Long Delays &amp;amp; Pausing Haystack&lt;/h2&gt; &#xA;&lt;p&gt;Haystack fully supports the existing &lt;code&gt;release&lt;/code&gt; and &lt;code&gt;delay&lt;/code&gt; methods in Laravel, however occasionally you may want to pause the haystack for an extended period of time, or release a job until the next day when an API rate limit is lifted. This can also be used as a longer delay if you are using Amazon SQS which only has a delay of 15 minutes.&lt;/p&gt; &#xA;&lt;p&gt;Laravel Haystack can provide this by storing the resume date in the database and using the Scheduler to dispatch the haystack when it is ready. When Laravel Haystack is paused, no job is left in your queue.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning: Since Laravel Haystack stores a copy of the job in the database before it is dispatched, it cannot keep track of job attempts or back-off. This means that a job can be released using the &#34;longRelease&#34; as many times as you like. &lt;a href=&#34;https://github.com/Sammyjo20/laravel-haystack/issues/9&#34;&gt;This is something that is being looked into.&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Setting Up&lt;/h3&gt; &#xA;&lt;p&gt;Before you configure long releases or pauses, you must make sure your scheduler is running and the following line is added to your Console/Kernel.php file. If you can, provide the &lt;code&gt;onOneServer&lt;/code&gt; method as well which will prevent any accidental duplicate-resumes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;// Add to Console/Kernel.php&#xA;&#xA;$schedule-&amp;gt;command(&#39;haystacks:resume&#39;)-&amp;gt;everyMinute();&#xA;&#xA;// One server if you are running the scheduler on multiple servers&#xA;&#xA;$schedule-&amp;gt;command(&#39;haystacks:resume&#39;)-&amp;gt;everyMinute()-&amp;gt;onOneServer();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Long Releasing&lt;/h3&gt; &#xA;&lt;p&gt;If you would like to release the current job back onto the queue, just use the &lt;code&gt;longRelease&lt;/code&gt; method inside your job‚Äôs handle method. You can provide an integer for seconds or a Carbon datetime instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class ProcessPodcast implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function handle()&#xA;    {&#xA;        // Your application code...&#xA;&#xA;        $this-&amp;gt;longRelease(300); // Release for 5 minutes&#xA;&#xA;        // Or use Carbon&#xA;&#xA;        $this-&amp;gt;longRelease(now()-&amp;gt;addDays(2)); // Release for 2 days.&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pausing the next job&lt;/h3&gt; &#xA;&lt;p&gt;If you want to process the current job but pause the Haystack for the next job, use the &lt;code&gt;pauseHaystack&lt;/code&gt; method. If you have disabled automatic processing, you can provide a delay to the &lt;code&gt;nextJob&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class ProcessPodcast implements ShouldQueue, StackableJo&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function handle()&#xA;    {&#xA;        // Your application code...&#xA;&#xA;        $this-&amp;gt;pauseHaystack(now()-&amp;gt;addHours(4)); // Pause the haystack for 4 hours.&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Shared Job Data&lt;/h2&gt; &#xA;&lt;p&gt;Laravel Haystack has the ability for your jobs to store and retrieve state/data between jobs. This is really useful if you need to store data in the first job and then in the second job, process the data and in the final job, email the processed data. You are able to create a process pipeline since each job is processed in sequential order. This is really exciting because with traditional chained jobs, you cannot share data between jobs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RetrieveDataFromApi)&#xA;   -&amp;gt;addJob(new ProcessDataFromApi)&#xA;   -&amp;gt;addJob(new StoreDataFromApi)&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Storing data inside of jobs&lt;/h3&gt; &#xA;&lt;p&gt;Inside your job, you can use the &lt;code&gt;setHaystackData()&lt;/code&gt; method to store some data. This method accepts a key, value and optional Eloquent cast.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class RetrieveDataFromApi implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function handle()&#xA;    {&#xA;        // Your application code...&#xA;        &#xA;        $this-&amp;gt;setHaystackData(&#39;username&#39;, &#39;Sammyjo20&#39;);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Casting data&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;setHaystackData&lt;/code&gt; method supports any data type. It supports fully casting your data into any of Eloquent&#39;s existing casts, or even your custom casts. Just provide a third argument to specify the cast.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class RetrieveDataFromApi implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function handle()&#xA;    {&#xA;        // Your application code...&#xA;        &#xA;        // Array Data, provide third argument to specify cast.&#xA;        &#xA;        $this-&amp;gt;setHaystackData(&#39;data&#39;, [&#39;username&#39; =&amp;gt; &#39;Sammyjo20&#39;], &#39;array&#39;);&#xA;        &#xA;        // Carbon dates...&#xA;        &#xA;        $this-&amp;gt;setHaystackData(&#39;currentDate&#39;, now(), &#39;immutable_datetime&#39;);&#xA;        &#xA;        // Supports custom casts&#xA;        &#xA;        $this-&amp;gt;setHaystackData(&#39;customData&#39;, $object, CustomCast::class);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving data inside of jobs&lt;/h3&gt; &#xA;&lt;p&gt;From one job you can set the data, but that data will be available to every job in the haystack there after. Just use the &lt;code&gt;getHaystackData&lt;/code&gt; method to get data by key or use the &lt;code&gt;allHaystackData&lt;/code&gt; to get a collection containing the haystack data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class RetrieveDataFromApi implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function handle()&#xA;    {&#xA;        // Get data by key&#xA;        &#xA;        $username = $this-&amp;gt;getHaystackData(&#39;username&#39;); // Sammyjo20&#xA;        &#xA;        // Get all data&#xA;        &#xA;        $allData = $this-&amp;gt;allHaystackData(); // Collection: [&#39;username&#39; =&amp;gt; &#39;Sammyjo20&#39;]&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting The Data After Processing&lt;/h3&gt; &#xA;&lt;p&gt;Laravel Haystack will conveniently pass a collection into your then/catch/finally closures with all the of the data that you stored inside the Haystack. You can then use this data however you wish.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RetrieveDataFromApi)&#xA;   -&amp;gt;addJob(new ProcessDataFromApi)&#xA;   -&amp;gt;addJob(new StoreDataFromApi)&#xA;   -&amp;gt;then(function ($data) {&#xA;        // $data: [&#39;username&#39; =&amp;gt; &#39;Sammyjo20&#39;, &#39;other-key&#39; =&amp;gt; &#39;value&#39;, &#39;collection&#39; =&amp;gt; new Collection],&#xA;   })&#xA;   -&amp;gt;catch(function ($data) {&#xA;        // $data: [&#39;username&#39; =&amp;gt; &#39;Sammyjo20&#39;, &#39;other-key&#39; =&amp;gt; &#39;value&#39;, &#39;collection&#39; =&amp;gt; new Collection],&#xA;   })&#xA;   -&amp;gt;finally(function ($data) {&#xA;        // $data: [&#39;username&#39; =&amp;gt; &#39;Sammyjo20&#39;, &#39;other-key&#39; =&amp;gt; &#39;value&#39;, &#39;collection&#39; =&amp;gt; new Collection],&#xA;   })&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you would like to disable this functionality, you can provide the &lt;code&gt;dontReturnData&lt;/code&gt; method to the Haystack builder. If this method is provided, Haystack won&#39;t run the query that retrieves all the data at the end of a Haystack.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;$haystack = Haystack::build()&#xA;   -&amp;gt;addJob(new RetrieveDataFromApi)&#xA;   -&amp;gt;addJob(new ProcessDataFromApi)&#xA;   -&amp;gt;addJob(new StoreDataFromApi)&#xA;   -&amp;gt;dontReturnData()&#xA;   -&amp;gt;then(function ($data) {&#xA;        // $data: null&#xA;   })&#xA;   -&amp;gt;dispatch();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you would like to disable this feature entirely, you can set the &lt;code&gt;return_all_haystack_data_when_finished&lt;/code&gt; config variable to false.&lt;/p&gt; &#xA;&lt;h2&gt;Manual Processing&lt;/h2&gt; &#xA;&lt;p&gt;By default, Laravel Haystack will use events to automatically process the next job in the haystack. If you would like to disable this functionality, you will need to make sure to disable the &lt;code&gt;automatic_processing&lt;/code&gt; in your config/haystack.php file. After that, you will need to make sure your jobs tell Haystack when to process the next job.&lt;/p&gt; &#xA;&lt;h3&gt;Using nextJob()&lt;/h3&gt; &#xA;&lt;p&gt;Since Haystack is no longer listening to your jobs, you will need to tell it when to dispatch the next job. You can do this by using the &lt;code&gt;nextJob&lt;/code&gt; method. Laravel Haystack will automatically stop when it gets to the end of the haystack.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class ProcessPodcast implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function handle()&#xA;    {&#xA;        // Your application code...&#xA;&#xA;        $this-&amp;gt;nextJob();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manually Failing Haystacks&lt;/h3&gt; &#xA;&lt;p&gt;Since Haystack is no longer listening out for failed jobs, you will need to call the &lt;code&gt;failHaystack&lt;/code&gt; method in your job, preferably in the &lt;code&gt;failed&lt;/code&gt; method. If you do not provide this, Haystack won‚Äôt call your ‚Äúcatch‚Äù and ‚Äúfinally‚Äù methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA; &#xA;namespace App\Jobs;&#xA; &#xA;use Sammyjo20\LaravelHaystack\Contracts\StackableJob;&#xA;use Sammyjo20\LaravelHaystack\Concerns\Stackable;&#xA; &#xA;class ProcessPodcast implements ShouldQueue, StackableJob&#xA;{&#xA;    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Stackable&#xA;&#xA;    public function failed($exception)&#xA;    {&#xA;        $this-&amp;gt;failHaystack();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Cleaning Up Stale And Finished Haystacks&lt;/h2&gt; &#xA;&lt;p&gt;Laravel Haystack will attempt to clean up every job on successful/failed haystacks, however there may be a situation, especially if you have not enabled the automatic processing. If you have disabled the option to automatically delete haystacks when they are finished they may build up quickly.&lt;/p&gt; &#xA;&lt;p&gt;You can prevent this by running the following prune command every day in your scheduler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;// Add to Console/Kernel.php&#xA;&#xA;use Sammyjo20\LaravelHaystack\Models\Haystack;&#xA;&#xA;$schedule-&amp;gt;command(&#39;model:prune&#39;, [&#xA;    &#39;--model&#39; =&amp;gt; [Haystack::class],&#xA;])-&amp;gt;daily();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support Haystack&#39;s Development&lt;/h2&gt; &#xA;&lt;p&gt;While I never expect anything, if you would like to support my work, you can donate to my Ko-Fi page by simply buying me a coffee or two! &lt;a href=&#34;https://ko-fi.com/sammyjo20&#34;&gt;https://ko-fi.com/sammyjo20&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Thank you for using Laravel Haystack ‚ù§Ô∏è&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>spatie/data-transfer-object</title>
    <updated>2022-08-05T01:32:06Z</updated>
    <id>tag:github.com,2022-08-05:/spatie/data-transfer-object</id>
    <link href="https://github.com/spatie/data-transfer-object" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Data transfer objects with batteries included&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://supportukrainenow.org&#34;&gt;&lt;img src=&#34;https://github-ads.s3.eu-central-1.amazonaws.com/support-ukraine.svg?t=1&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Data transfer objects with batteries included&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/spatie/data-transfer-object&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/v/spatie/data-transfer-object.svg?style=flat-square&#34; alt=&#34;Latest Version on Packagist&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/spatie/data-transfer-object/workflows/Test/badge.svg?sanitize=true&#34; alt=&#34;Test&#34;&gt; &lt;a href=&#34;https://packagist.org/packages/spatie/data-transfer-object&#34;&gt;&lt;img src=&#34;https://img.shields.io/packagist/dt/spatie/data-transfer-object.svg?style=flat-square&#34; alt=&#34;Total Downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the package via composer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer require spatie/data-transfer-object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Note&lt;/strong&gt;: v3 of this package only supports &lt;code&gt;php:^8.0&lt;/code&gt;. If you&#39;re looking for the older version, check out &lt;a href=&#34;https://github.com/spatie/data-transfer-object/tree/v2&#34;&gt;v2&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Support us&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://spatie.be/github-ad-click/data-transfer-object&#34;&gt;&lt;img src=&#34;https://github-ads.s3.eu-central-1.amazonaws.com/data-transfer-object.jpg?t=1&#34; width=&#34;419px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We invest a lot of resources into creating &lt;a href=&#34;https://spatie.be/open-source&#34;&gt;best in class open source packages&lt;/a&gt;. You can support us by &lt;a href=&#34;https://spatie.be/open-source/support-us&#34;&gt;buying one of our paid products&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We highly appreciate you sending us a postcard from your hometown, mentioning which of our package(s) you are using. You&#39;ll find our address on &lt;a href=&#34;https://spatie.be/about-us&#34;&gt;our contact page&lt;/a&gt;. We publish all received postcards on &lt;a href=&#34;https://spatie.be/open-source/postcards&#34;&gt;our virtual postcard wall&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The goal of this package is to make constructing objects from arrays of (serialized) data as easy as possible. Here&#39;s what a DTO looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Spatie\DataTransferObject\Attributes\MapFrom;&#xA;use Spatie\DataTransferObject\DataTransferObject;&#xA;&#xA;class MyDTO extends DataTransferObject&#xA;{&#xA;    public OtherDTO $otherDTO;&#xA;    &#xA;    public OtherDTOCollection $collection;&#xA;    &#xA;    #[CastWith(ComplexObjectCaster::class)]&#xA;    public ComplexObject $complexObject;&#xA;    &#xA;    public ComplexObjectWithCast $complexObjectWithCast;&#xA;    &#xA;    #[NumberBetween(1, 100)]&#xA;    public int $a;&#xA;    &#xA;    #[MapFrom(&#39;address.city&#39;)]&#xA;    public string $city;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could construct this DTO like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$dto = new MyDTO(&#xA;    a: 5,&#xA;    collection: [&#xA;        [&#39;id&#39; =&amp;gt; 1],&#xA;        [&#39;id&#39; =&amp;gt; 2],&#xA;        [&#39;id&#39; =&amp;gt; 3],&#xA;    ],&#xA;    complexObject: [&#xA;        &#39;name&#39; =&amp;gt; &#39;test&#39;,&#xA;    ],&#xA;    complexObjectWithCast: [&#xA;        &#39;name&#39; =&amp;gt; &#39;test&#39;,&#xA;    ],&#xA;    otherDTO: [&#39;id&#39; =&amp;gt; 5],&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s discuss all possibilities one by one.&lt;/p&gt; &#xA;&lt;h2&gt;Named arguments&lt;/h2&gt; &#xA;&lt;p&gt;Constructing a DTO can be done with named arguments. It&#39;s also possible to still use the old array notation. This example is equivalent to the one above.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$dto = new MyDTO([&#xA;    &#39;a&#39; =&amp;gt; 5,&#xA;    &#39;collection&#39; =&amp;gt; [&#xA;        [&#39;id&#39; =&amp;gt; 1],&#xA;        [&#39;id&#39; =&amp;gt; 2],&#xA;        [&#39;id&#39; =&amp;gt; 3],&#xA;    ],&#xA;    &#39;complexObject&#39; =&amp;gt; [&#xA;        &#39;name&#39; =&amp;gt; &#39;test&#39;,&#xA;    ],&#xA;    &#39;complexObjectWithCast&#39; =&amp;gt; [&#xA;        &#39;name&#39; =&amp;gt; &#39;test&#39;,&#xA;    ],&#xA;    &#39;otherDTO&#39; =&amp;gt; [&#39;id&#39; =&amp;gt; 5],&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Value casts&lt;/h2&gt; &#xA;&lt;p&gt;If a DTO has a property that is another DTO or a DTO collection, the package will take care of automatically casting arrays of data to those DTOs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$dto = new MyDTO(&#xA;    collection: [ // This will become an object of class OtherDTOCollection&#xA;        [&#39;id&#39; =&amp;gt; 1],&#xA;        [&#39;id&#39; =&amp;gt; 2], // Each item will be an instance of OtherDTO&#xA;        [&#39;id&#39; =&amp;gt; 3],&#xA;    ],&#xA;    otherDTO: [&#39;id&#39; =&amp;gt; 5], // This data will be cast to OtherDTO&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom casters&lt;/h3&gt; &#xA;&lt;p&gt;You can build your own caster classes, which will take whatever input they are given, and will cast that input to the desired result.&lt;/p&gt; &#xA;&lt;p&gt;Take a look at the &lt;code&gt;ComplexObject&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class ComplexObject&#xA;{&#xA;    public string $name;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And its caster &lt;code&gt;ComplexObjectCaster&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Spatie\DataTransferObject\Caster;&#xA;&#xA;class ComplexObjectCaster implements Caster&#xA;{&#xA;    /**&#xA;     * @param array|mixed $value&#xA;     *&#xA;     * @return mixed&#xA;     */&#xA;    public function cast(mixed $value): ComplexObject&#xA;    {&#xA;        return new ComplexObject(&#xA;            name: $value[&#39;name&#39;]&#xA;        );&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Class-specific casters&lt;/h3&gt; &#xA;&lt;p&gt;Instead of specifying which caster should be used for each property, you can also define that caster on the target class itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class MyDTO extends DataTransferObject&#xA;{&#xA;    public ComplexObjectWithCast $complexObjectWithCast;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#[CastWith(ComplexObjectWithCastCaster::class)]&#xA;class ComplexObjectWithCast&#xA;{&#xA;    public string $name;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Default casters&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s possible to define default casters on a DTO class itself. These casters will be used whenever a property with a given type is encountered within the DTO class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#[&#xA;    DefaultCast(DateTimeImmutable::class, DateTimeImmutableCaster::class),&#xA;    DefaultCast(MyEnum::class, EnumCaster::class),&#xA;]&#xA;abstract class BaseDataTransferObject extends DataTransferObject&#xA;{&#xA;    public MyEnum $status; // EnumCaster will be used&#xA;    &#xA;    public DateTimeImmutable $date; // DateTimeImmutableCaster will be used&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using custom caster arguments&lt;/h3&gt; &#xA;&lt;p&gt;Any caster can be passed custom arguments, the built-in &lt;a href=&#34;https://github.com/spatie/data-transfer-object/raw/master/src/Casters/ArrayCaster.php&#34;&gt;&lt;code&gt;ArrayCaster&lt;/code&gt; implementation&lt;/a&gt; is a good example of how this may be used.&lt;/p&gt; &#xA;&lt;p&gt;Using named arguments when passing input to your caster will help make your code more clear, but they are not required.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    /** @var \Spatie\DataTransferObject\Tests\Foo[] */&#xA;    #[CastWith(ArrayCaster::class, itemType: Foo::class)]&#xA;    public array $collectionWithNamedArguments;&#xA;    &#xA;    /** @var \Spatie\DataTransferObject\Tests\Foo[] */&#xA;    #[CastWith(ArrayCaster::class, Foo::class)]&#xA;    public array $collectionWithoutNamedArguments;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the first argument passed to the caster constructor is always the array with type(s) of the value being casted. All other arguments will be the ones passed as extra arguments in the &lt;code&gt;CastWith&lt;/code&gt; attribute.&lt;/p&gt; &#xA;&lt;h2&gt;Validation&lt;/h2&gt; &#xA;&lt;p&gt;This package doesn&#39;t offer any specific validation functionality, but it does give you a way to build your own validation attributes. For example, &lt;code&gt;NumberBetween&lt;/code&gt; is a user-implemented validation attribute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class MyDTO extends DataTransferObject&#xA;{&#xA;    #[NumberBetween(1, 100)]&#xA;    public int $a;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It works like this under the hood:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#[Attribute(Attribute::TARGET_PROPERTY | Attribute::IS_REPEATABLE)]&#xA;class NumberBetween implements Validator&#xA;{&#xA;    public function __construct(&#xA;        private int $min,&#xA;        private int $max&#xA;    ) {&#xA;    }&#xA;&#xA;    public function validate(mixed $value): ValidationResult&#xA;    {&#xA;        if ($value &amp;lt; $this-&amp;gt;min) {&#xA;            return ValidationResult::invalid(&#34;Value should be greater than or equal to {$this-&amp;gt;min}&#34;);&#xA;        }&#xA;&#xA;        if ($value &amp;gt; $this-&amp;gt;max) {&#xA;            return ValidationResult::invalid(&#34;Value should be less than or equal to {$this-&amp;gt;max}&#34;);&#xA;        }&#xA;&#xA;        return ValidationResult::valid();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Mapping&lt;/h2&gt; &#xA;&lt;p&gt;You can map a DTO property from a source property with a different name using the &lt;code&gt;#[MapFrom]&lt;/code&gt; attribute.&lt;/p&gt; &#xA;&lt;p&gt;It works with a &#34;dot&#34; notation property name or an index.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class PostDTO extends DataTransferObject&#xA;{&#xA;    #[MapFrom(&#39;postTitle&#39;)]&#xA;    public string $title;&#xA;    &#xA;    #[MapFrom(&#39;user.name&#39;)]&#xA;    public string $author;&#xA;}&#xA;&#xA;$dto = new PostDTO([&#xA;    &#39;postTitle&#39; =&amp;gt; &#39;Hello world&#39;,&#xA;    &#39;user&#39; =&amp;gt; [&#xA;        &#39;name&#39; =&amp;gt; &#39;John Doe&#39;&#xA;    ]&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class UserDTO extends DataTransferObject&#xA;{&#xA;&#xA;    #[MapFrom(0)]&#xA;    public string $firstName;&#xA;    &#xA;    #[MapFrom(1)]&#xA;    public string $lastName;&#xA;}&#xA;&#xA;$dto = new UserDTO([&#39;John&#39;, &#39;Doe&#39;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes you also want to map them during the transformation to Array. A typical usecase would be transformation from camel case to snake case. For that you can use the &lt;code&gt;#[MapTo]&lt;/code&gt; attribute.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class UserDTO extends DataTransferObject&#xA;{&#xA;&#xA;    #[MapFrom(0)]&#xA;    #[MapTo(&#39;first_name&#39;)]&#xA;    public string $firstName;&#xA;    &#xA;    #[MapFrom(1)]&#xA;    #[MapTo(&#39;last_name&#39;)]&#xA;    public string $lastName;&#xA;}&#xA;&#xA;$dto = new UserDTO([&#39;John&#39;, &#39;Doe&#39;]);&#xA;$dto-&amp;gt;toArray() // [&#39;first_name&#39; =&amp;gt; &#39;John&#39;, &#39;last_name&#39;=&amp;gt; &#39;Doe&#39;];&#xA;$dto-&amp;gt;only(&#39;first_name&#39;)-&amp;gt;toArray() // [&#39;first_name&#39; =&amp;gt; &#39;John&#39;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strict DTOs&lt;/h2&gt; &#xA;&lt;p&gt;The previous version of this package added the &lt;code&gt;FlexibleDataTransferObject&lt;/code&gt; class which allowed you to ignore properties that didn&#39;t exist on the DTO. This behaviour has been changed, all DTOs are flexible now by default, but you can make them strict by using the &lt;code&gt;#[Strict]&lt;/code&gt; attribute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class NonStrictDto extends DataTransferObject&#xA;{&#xA;    public string $name;&#xA;}&#xA;&#xA;// This works&#xA;new NonStrictDto(&#xA;    name: &#39;name&#39;,&#xA;    unknown: &#39;unknown&#39;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use \Spatie\DataTransferObject\Attributes\Strict;&#xA;&#xA;#[Strict]&#xA;class StrictDto extends DataTransferObject&#xA;{&#xA;    public string $name;&#xA;}&#xA;&#xA;// This throws a \Spatie\DataTransferObject\Exceptions\UnknownProperties exception&#xA;new StrictDto(&#xA;    name: &#39;name&#39;,&#xA;    unknown: &#39;unknown&#39;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Helper functions&lt;/h2&gt; &#xA;&lt;p&gt;There are also some helper functions provided for working with multiple properties at once.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$postData-&amp;gt;all();&#xA;&#xA;$postData&#xA;    -&amp;gt;only(&#39;title&#39;, &#39;body&#39;)&#xA;    -&amp;gt;toArray();&#xA;    &#xA;$postData&#xA;    -&amp;gt;except(&#39;author&#39;)&#xA;    -&amp;gt;toArray();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;all()&lt;/code&gt; will simply return all properties, while &lt;code&gt;toArray()&lt;/code&gt; will cast nested DTOs to arrays as well.&lt;/p&gt; &#xA;&lt;p&gt;You can chain the &lt;code&gt;except()&lt;/code&gt; and &lt;code&gt;only()&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$postData&#xA;    -&amp;gt;except(&#39;title&#39;)&#xA;    -&amp;gt;except(&#39;body&#39;)&#xA;    -&amp;gt;toArray();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s important to note that &lt;code&gt;except()&lt;/code&gt; and &lt;code&gt;only()&lt;/code&gt; are immutable, they won&#39;t change the original data transfer object.&lt;/p&gt; &#xA;&lt;h2&gt;Immutable DTOs and cloning&lt;/h2&gt; &#xA;&lt;p&gt;This package doesn&#39;t force immutable objects since PHP doesn&#39;t support them, but you&#39;re always encouraged to keep your DTOs immutable. To help you, there&#39;s a &lt;code&gt;clone&lt;/code&gt; method on every DTO which accepts data to override:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$clone = $original-&amp;gt;clone(other: [&#39;name&#39; =&amp;gt; &#39;a&#39;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that no data in &lt;code&gt;$original&lt;/code&gt; is changed.&lt;/p&gt; &#xA;&lt;h2&gt;Collections of DTOs&lt;/h2&gt; &#xA;&lt;p&gt;This version removes the &lt;code&gt;DataTransferObjectCollection&lt;/code&gt; class. Instead you can use simple casters and your own collection classes.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of casting a collection of DTOs to an array of DTOs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Bar extends DataTransferObject&#xA;{&#xA;    /** @var \Spatie\DataTransferObject\Tests\Foo[] */&#xA;    #[CastWith(FooArrayCaster::class)]&#xA;    public array $collectionOfFoo;&#xA;}&#xA;&#xA;class Foo extends DataTransferObject&#xA;{&#xA;    public string $name;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class FooArrayCaster implements Caster&#xA;{&#xA;    public function cast(mixed $value): array&#xA;    {&#xA;        if (! is_array($value)) {&#xA;            throw new Exception(&#34;Can only cast arrays to Foo&#34;);&#xA;        }&#xA;&#xA;        return array_map(&#xA;            fn (array $data) =&amp;gt; new Foo(...$data),&#xA;            $value&#xA;        );&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want the redundant typehint, or want extended collection functionality; you could create your own collection classes using any collection implementation. In this example, we use Laravel&#39;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Bar extends DataTransferObject&#xA;{&#xA;    #[CastWith(FooCollectionCaster::class)]&#xA;    public CollectionOfFoo $collectionOfFoo;&#xA;}&#xA;&#xA;class Foo extends DataTransferObject&#xA;{&#xA;    public string $name;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Illuminate\Support\Collection;&#xA;&#xA;class CollectionOfFoo extends Collection&#xA;{&#xA;    // Add the correct return type here for static analyzers to know which type of array this is &#xA;    public function offsetGet($key): Foo&#xA;    {&#xA;        return parent::offsetGet($key);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class FooCollectionCaster implements Caster&#xA;{&#xA;    public function cast(mixed $value): CollectionOfFoo&#xA;    {&#xA;        return new CollectionOfFoo(array_map(&#xA;            fn (array $data) =&amp;gt; new Foo(...$data),&#xA;            $value&#xA;        ));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Simple arrays of DTOs&lt;/h2&gt; &#xA;&lt;p&gt;For a simple array of DTOs, or an object that implements PHP&#39;s built-in &lt;code&gt;ArrayAccess&lt;/code&gt;, consider using the &lt;code&gt;ArrayCaster&lt;/code&gt; which requires an item type to be provided:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Bar extends DataTransferObject&#xA;{&#xA;    /** @var \Spatie\DataTransferObject\Tests\Foo[] */&#xA;    #[CastWith(ArrayCaster::class, itemType: Foo::class)]&#xA;    public array $collectionOfFoo;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Changelog&lt;/h3&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/spatie/data-transfer-object/main/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; for more information on what has changed recently.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/spatie/.github/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h3&gt;Security&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;ve found a bug regarding security please mail &lt;a href=&#34;mailto:security@spatie.be&#34;&gt;security@spatie.be&lt;/a&gt; instead of using the issue tracker.&lt;/p&gt; &#xA;&lt;h2&gt;Postcardware&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;re free to use this package, but if it makes it to your production environment we highly appreciate you sending us a postcard from your hometown, mentioning which of our package(s) you are using.&lt;/p&gt; &#xA;&lt;p&gt;Our address is: Spatie, Kruikstraat 22, 2018 Antwerp, Belgium.&lt;/p&gt; &#xA;&lt;p&gt;We publish all received postcards &lt;a href=&#34;https://spatie.be/en/opensource/postcards&#34;&gt;on our company website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;External tools&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://json2dto.atymic.dev&#34;&gt;json2dto&lt;/a&gt;: a GUI to convert JSON objects to DTO classes (with nesting support). Also provides a &lt;a href=&#34;https://github.com/atymic/json2dto#cli-tool&#34;&gt;CLI tool&lt;/a&gt; for local usage.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anteris-dev/data-transfer-object-factory&#34;&gt;Data Transfer Object Factory&lt;/a&gt;: Intelligently generates a DTO instance using the correct content for your properties based on its name and type.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/brendt&#34;&gt;Brent Roose&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spatie/contributors&#34;&gt;All Contributors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Our &lt;code&gt;Arr&lt;/code&gt; class contains functions copied from Laravels &lt;code&gt;Arr&lt;/code&gt; helper.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT). Please see &lt;a href=&#34;https://raw.githubusercontent.com/spatie/data-transfer-object/main/LICENSE.md&#34;&gt;License File&lt;/a&gt; for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>orchidsoftware/platform</title>
    <updated>2022-08-05T01:32:06Z</updated>
    <id>tag:github.com,2022-08-05:/orchidsoftware/platform</id>
    <link href="https://github.com/orchidsoftware/platform" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Orchid is a @laravel package that allows for rapid application development of back-office applications, admin/user panels, and dashboards.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://orchid.software/&#34;&gt;&lt;img src=&#34;https://orchid.software/img/logo-laravel-style.svg?sanitize=true&#34; alt=&#34;Laravel Orchid&#34; height=&#34;48&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h4 align=&#34;center&#34;&gt;For the full documentation, visit &lt;a href=&#34;http://orchid.software&#34;&gt;orchid.software&lt;/a&gt;.&lt;/h4&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/orchidsoftware/platform/actions&#34;&gt;&lt;img src=&#34;https://github.com/orchidsoftware/platform/workflows/Tests/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/orchidsoftware/platform&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/orchidsoftware/platform/branch/master/graph/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packagist.org/packages/orchid/platform&#34;&gt;&lt;img alt=&#34;Packagist&#34; src=&#34;https://img.shields.io/packagist/dt/orchid/platform.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/orchid&#34;&gt;&lt;img src=&#34;https://img.shields.io/opencollective/all/orchid&#34; alt=&#34;Open Collective backers and sponsors&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Orchid is a free &lt;a href=&#34;https://laravel.com&#34;&gt;Laravel&lt;/a&gt; package that abstracts standard business logic and allows code-driven rapid application development of back-office applications, admin/user panels, and dashboards.&lt;/p&gt; &#xA;&lt;h3&gt;Live Demo&lt;/h3&gt; &#xA;&lt;a href=&#34;https://demo.orchid.software/login&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/orchidsoftware/platform/master/.github/IMAGES/promo-full.png&#34; alt=&#34;Laravel Orchid Platform&#34; align=&#34;center&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;Curious but not (yet) in the mood to read the documentation? Click &lt;a href=&#34;https://demo.orchid.software/login&#34;&gt;here&lt;/a&gt;, to experience a live demo of Orchid.&lt;/p&gt; &#xA;&lt;h3&gt;Interesting Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Rapid Application Development&lt;/strong&gt; - Focus on PHP development and don&#39;t lose time with HTML, CSS, or JavaScript. Build application logic, not admin panels. Try our &lt;a href=&#34;https://orchid.software/en/docs/quickstart/&#34;&gt;quick start guide&lt;/a&gt; and kick-start your application&#39;s development.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Form Builder&lt;/strong&gt; - Prevent reinventing the wheel or forms. Orchid supports already &lt;a href=&#34;https://orchid.software/en/docs/field/&#34;&gt;40+ form elements&lt;/a&gt; &#34;out of the box&#34; and allows you to build all kinds of forms quickly.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Fast Loading Times&lt;/strong&gt; - Enjoy a SPA like performance! Transitions can be made without reloading a page and require no additional code. Thanks to the &lt;a href=&#34;https://hotwire.dev/&#34;&gt;Hotwire&lt;/a&gt; project, Orchid makes this a satisfying experience for you and your users.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Access Permissions &amp;amp; Roles&lt;/strong&gt; - Take advantage of &lt;a href=&#34;https://orchid.software/en/docs/access/&#34;&gt;granular access permissions&lt;/a&gt;, based on a user‚Äôs identity and corresponding role membership.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Filtering &amp;amp; Sorting&lt;/strong&gt; - Offer your users the ability to filter and sort data quickly! Orchid uses an &lt;a href=&#34;https://orchid.software/en/docs/quickstart-sort-filter-table/&#34;&gt;Eloquent based filtering/sorting approach&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Fast Full-Text Search&lt;/strong&gt; - Take advantage of the integrated &lt;a href=&#34;https://orchid.software/en/docs/global-search/&#34;&gt;Laravel Scout based full-text search&lt;/a&gt;, which allows searching through all available content, and displaying search results almost instantly.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Multiple Notifications Types&lt;/strong&gt; - Orchid offers &lt;a href=&#34;https://orchid.software/en/docs/alert/&#34;&gt;various types of notifications&lt;/a&gt; and allows your application to keep your users informed appropriately.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h3&gt;Documentation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üåç &lt;a href=&#34;https://orchid.software/en/docs&#34;&gt;Documentation &amp;amp; Quick Start Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üá∑üá∫ –ß—Ç–æ–±—ã –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ–º, –ø–æ—Å–µ—Ç–∏—Ç–µ —Å–∞–π—Ç &lt;a href=&#34;https://orchid.software/ru/docs&#34;&gt;orchid.software&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Blog&lt;/h3&gt; &#xA;&lt;p&gt;Orchid&#39;s &lt;a href=&#34;https://blog.orchid.software/&#34;&gt;blog&lt;/a&gt; informs about news and announcements around Laravel Orchid, including related projects.&lt;/p&gt; &#xA;&lt;h2&gt;Feedback/Support&lt;/h2&gt; &#xA;&lt;p&gt;We are continually trying to actively include feedback from the community in the development of Orchid. You help us a lot if you give us well structured and detailed feedback.&lt;/p&gt; &#xA;&lt;h3&gt;GitHub&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create &lt;a href=&#34;https://github.com/orchidsoftware/platform/issues&#34;&gt;issues&lt;/a&gt; to ask questions or report problems.&lt;/li&gt; &#xA; &lt;li&gt;Participate in &lt;a href=&#34;https://github.com/orchidsoftware/platform/discussions&#34;&gt;disccussions&lt;/a&gt; around Orchid and share your ideas/opinions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Telegram User Groups&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://t.me/orchid_community&#34;&gt;Global Community&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://t.me/orchid_russian_community&#34;&gt;Russian Community&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://t.me/esLaravelOrchid&#34;&gt;Spanish Community&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Discord&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/NxXhSHa5tq&#34;&gt;Discord&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Release Strategy&lt;/h3&gt; &#xA;&lt;p&gt;We like to keep things as modern as possible and have a &#34;&lt;a href=&#34;https://en.wikipedia.org/wiki/Release_early,_release_often&#34;&gt;release early, release often&lt;/a&gt;&#34; approach to major releases. This means we won&#39;t wait an arbitrary number of months to accumulate significant changes and release the next major version. By releasing major versions often, new features will be out earlier, and upgrading between versions will be much easier.&lt;/p&gt; &#xA;&lt;h3&gt;Changelog&lt;/h3&gt; &#xA;&lt;p&gt;We actively and continuously maintain a &lt;a href=&#34;https://raw.githubusercontent.com/orchidsoftware/platform/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt; that informs about Orchid&#39;s history of improvements, bug fixes, and changes.&lt;/p&gt; &#xA;&lt;h2&gt;Support Orchid&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to our backers üôè, Orchid is free for private and commercial purposes. üéâ&lt;/p&gt; &#xA;&lt;p&gt;Voluntary donations are allowing us to spend more time improving Orchid for everyone! üëç&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opencollective.com/orchid#backers&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/orchid/sponsors.svg?width=838&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/orchid#backers&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/orchid/backers.svg?width=838&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Orchid is covered by the MIT license. Check &lt;a href=&#34;https://raw.githubusercontent.com/orchidsoftware/platform/master/LICENSE&#34;&gt;our license&lt;/a&gt; for further information.&lt;/p&gt;</summary>
  </entry>
</feed>