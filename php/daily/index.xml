<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PHP Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-02T01:37:24Z</updated>
  <subtitle>Daily Trending of PHP in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>laravel-workflow/laravel-workflow</title>
    <updated>2022-12-02T01:37:24Z</updated>
    <id>tag:github.com,2022-12-02:/laravel-workflow/laravel-workflow</id>
    <link href="https://github.com/laravel-workflow/laravel-workflow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Durable workflow engine that allows users to write long running persistent distributed workflows (orchestrations) in PHP powered by Laravel Queues. Inspired by Temporal and Azure Durable Functions.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Laravel Workflow &lt;a href=&#34;https://github.com/laravel-workflow/laravel-workflow/actions/workflows/php.yml&#34;&gt;&lt;img src=&#34;https://github.com/laravel-workflow/laravel-workflow/actions/workflows/php.yml/badge.svg?sanitize=true&#34; alt=&#34;PHP Composer&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/laravel-workflow/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/laravel-workflow/community.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Durable workflow engine that allows users to write long running persistent distributed workflows (orchestrations) in PHP powered by &lt;a href=&#34;https://laravel.com/docs/9.x/queues&#34;&gt;Laravel Queues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;This library is installable via &lt;a href=&#34;https://getcomposer.org&#34;&gt;Composer&lt;/a&gt;. You must also publish the migrations for the &lt;code&gt;workflows&lt;/code&gt; table.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;composer require laravel-workflow/laravel-workflow&#xA;&#xA;php artisan vendor:publish --provider=&#34;Workflow\Providers\WorkflowServiceProvider&#34; --tag=&#34;migrations&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;You can use any queue driver that Laravel supports but this is heavily tested against Redis. Your cache driver must support locks. (Read: &lt;a href=&#34;https://laravel.com/docs/9.x/queues#unique-jobs&#34;&gt;Laravel Queues&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;1. Create a workflow.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Workflow\ActivityStub;&#xA;use Workflow\Workflow;&#xA;&#xA;class MyWorkflow extends Workflow&#xA;{&#xA;    public function execute()&#xA;    {&#xA;        $result = yield ActivityStub::make(MyActivity::class);&#xA;        return $result;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;2. Create an activity.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Workflow\Activity;&#xA;&#xA;class MyActivity extends Activity&#xA;{&#xA;    public function execute()&#xA;    {&#xA;        return &#39;activity&#39;;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;3. Run the workflow.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Workflow\WorkflowStub;&#xA;&#xA;$workflow = WorkflowStub::make(MyWorkflow::class);&#xA;$workflow-&amp;gt;start();&#xA;while ($workflow-&amp;gt;running());&#xA;$workflow-&amp;gt;output();&#xA;=&amp;gt; &#39;activity&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Signals&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;code&gt;WorkflowStub::await()&lt;/code&gt; along with signal methods allows a workflow to wait for an external event.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Workflow\ActivityStub;&#xA;use Workflow\SignalMethod;&#xA;use Workflow\Workflow;&#xA;use Workflow\WorkflowStub;&#xA;&#xA;&#xA;class MyWorkflow extends Workflow&#xA;{&#xA;    private bool $isReady = false;&#xA;&#xA;    #[SignalMethod]&#xA;    public function ready()&#xA;    {&#xA;        $this-&amp;gt;isReady = true;&#xA;    }&#xA;&#xA;    public function execute()&#xA;    {&#xA;        $result = yield ActivityStub::make(MyActivity::class);&#xA;&#xA;        yield WorkflowStub::await(fn () =&amp;gt; $this-&amp;gt;isReady);&#xA;&#xA;        $otherResult = yield ActivityStub::make(MyOtherActivity::class);&#xA;&#xA;        return $result . $otherResult;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The workflow will reach the call to &lt;code&gt;WorkflowStub::await()&lt;/code&gt; and then hibernate until some external code signals the workflow like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$workflow-&amp;gt;ready();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Timers&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;code&gt;WorkflowStub::timer($seconds)&lt;/code&gt; allows a workflow to wait for a fixed amount of time in seconds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Workflow\ActivityStub;&#xA;use Workflow\Workflow;&#xA;use Workflow\WorkflowStub;&#xA;&#xA;class MyWorkflow extends Workflow&#xA;{&#xA;    public function execute()&#xA;    {&#xA;        $result = yield ActivityStub::make(MyActivity::class);&#xA;&#xA;        yield WorkflowStub::timer(300);&#xA;&#xA;        $otherResult = yield ActivityStub::make(MyOtherActivity::class);&#xA;&#xA;        return $result . $otherResult;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The workflow will reach the call to &lt;code&gt;WorkflowStub::timer()&lt;/code&gt; and then hibernate for 5 minutes. After that time has passed, it will continue execution.&lt;/p&gt; &#xA;&lt;h2&gt;Signal + Timer&lt;/h2&gt; &#xA;&lt;p&gt;In most cases you don&#39;t want to wait forever for a signal.&lt;/p&gt; &#xA;&lt;p&gt;Instead, you want to wait for some amount of time and then give up. It&#39;s possible to combine a signal with a timer yourself to achieve this but a convenience method exists to do this for you, &lt;code&gt;WorkflowStub::awaitWithTimeout()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Workflow\WorkflowStub;&#xA;&#xA;$result = yield WorkflowStub::awaitWithTimeout(300, fn () =&amp;gt; $this-&amp;gt;isReady);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will wait like the previous signal example but it will timeout after 5 minutes. If a timeout occurs, the result will be &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Failed Workflows&lt;/h2&gt; &#xA;&lt;p&gt;If a workflow fails or crashes at any point then it can be resumed from that point. Any activities that were successfully completed during the previous execution of the workflow will not be run again.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Workflow\WorkflowStub;&#xA;&#xA;$workflow = WorkflowStub::load(1);&#xA;$workflow-&amp;gt;resume();&#xA;while ($workflow-&amp;gt;running());&#xA;$workflow-&amp;gt;output();&#xA;=&amp;gt; &#39;activity&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Retries&lt;/h2&gt; &#xA;&lt;p&gt;A workflow will only fail when the retries on the failing activity have been exhausted.&lt;/p&gt; &#xA;&lt;p&gt;The default activity retry policy is to retry activities forever with an exponential backoff that decays to 2 minutes. If your activity fails because of a transient error (something that fixes itself) then it will keep retrying and eventually recover automatically. However, if your activity fails because of a permanent error then you will have to fix it manually via a code deploy and restart your queue workers. The activity will then retry again using the new code and complete successfully.&lt;/p&gt; &#xA;&lt;p&gt;Workflows and activities are based on &lt;a href=&#34;https://laravel.com/docs/9.x/queues&#34;&gt;Laravel Queues&lt;/a&gt; so you can use any options you normally would.&lt;/p&gt; &#xA;&lt;h2&gt;Workflow Constraints&lt;/h2&gt; &#xA;&lt;p&gt;Workflows and activities have a key difference. Workflows cannot have any side effects other than running activities and they must be deterministic. The following list only applies to workflows, not activities.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No IO.&lt;/li&gt; &#xA; &lt;li&gt;No mutable global variables.&lt;/li&gt; &#xA; &lt;li&gt;No non-deterministic functions like non-seeded &lt;code&gt;rand()&lt;/code&gt; or &lt;code&gt;Str::uuid()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;No &lt;code&gt;Carbon::now()&lt;/code&gt;, use &lt;code&gt;WorkflowStub::now()&lt;/code&gt; to get the current time.&lt;/li&gt; &#xA; &lt;li&gt;No &lt;code&gt;sleep()&lt;/code&gt;, use &lt;code&gt;yield WorkflowStub::timer()&lt;/code&gt; to wait.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of these types of operations should be done in activities.&lt;/p&gt; &#xA;&lt;h2&gt;Activity Constraints&lt;/h2&gt; &#xA;&lt;p&gt;Activities have none of the above constraints. However, because activities are retryable they should still be idempotent. If your activity creates a charge for a customer then retrying it should not create a duplicate charge.&lt;/p&gt; &#xA;&lt;p&gt;Many external APIs support passing an &lt;code&gt;Idempotency-Key&lt;/code&gt;. See &lt;a href=&#34;https://stripe.com/docs/api/idempotent_requests&#34;&gt;Stripe&lt;/a&gt; for an example.&lt;/p&gt; &#xA;&lt;p&gt;Many operations are naturally idempotent. If you encode a video twice, while it may be a waste of time, you still have the same video. If you delete the same file twice, the second deletion does nothing.&lt;/p&gt; &#xA;&lt;p&gt;Some operations are not idempotent but duplication may be tolerable. If you are unsure if an email was actually sent, sending a duplicate email might be preferable to risking that no email was sent at all.&lt;/p&gt; &#xA;&lt;h2&gt;Constraints Summary&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Workflows&lt;/th&gt; &#xA;   &lt;th&gt;Activities&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;❌ IO&lt;/td&gt; &#xA;   &lt;td&gt;✔️ IO&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;❌ mutable global variables&lt;/td&gt; &#xA;   &lt;td&gt;✔️ mutable global variables&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;❌ non-deterministic functions&lt;/td&gt; &#xA;   &lt;td&gt;✔️ non-deterministic functions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;❌ &lt;code&gt;Carbon::now()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✔️ &lt;code&gt;Carbon::now()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;❌ &lt;code&gt;sleep()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✔️ &lt;code&gt;sleep()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;❌ non-idempotent&lt;/td&gt; &#xA;   &lt;td&gt;❌ non-idempotent&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Monitoring&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/laravel-workflow/waterline&#34;&gt;Waterline&lt;/a&gt; is a separate UI that works nicely alongside Horizon. Think of Waterline as being to workflows what Horizon is to queues.&lt;/p&gt; &#xA;&lt;h3&gt;Dashboard View&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1130888/202866614-4adad485-60d1-403c-976f-d3063e928287.png&#34; alt=&#34;waterline_dashboard&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Workflow View&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1130888/202866616-98a214d3-a916-4ae1-952e-ca8267ddf4a7.png&#34; alt=&#34;workflow&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Refer to &lt;a href=&#34;https://github.com/laravel-workflow/waterline&#34;&gt;https://github.com/laravel-workflow/waterline&lt;/a&gt; for installation and configuration instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Supporters&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/laravel-workflow/laravel-workflow/stargazers&#34;&gt;&lt;img src=&#34;https://reporoster.com/stars/dark/laravel-workflow/laravel-workflow&#34; alt=&#34;Stargazers repo roster for @laravel-workflow/laravel-workflow&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>