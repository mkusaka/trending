<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dart Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-01-26T01:42:32Z</updated>
  <subtitle>Weekly Trending of Dart in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fluttercommunity/flutter_workmanager</title>
    <updated>2025-01-26T01:42:32Z</updated>
    <id>tag:github.com,2025-01-26:/fluttercommunity/flutter_workmanager</id>
    <link href="https://github.com/fluttercommunity/flutter_workmanager" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Flutter plugin which allows you to execute code in the background on Android and iOS.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Flutter Workmanager&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://pub.dartlang.org/packages/workmanager&#34;&gt;&lt;img src=&#34;https://img.shields.io/pub/v/workmanager.svg?sanitize=true&#34; alt=&#34;pub package&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cirrus-ci.com/github/vrtdev/flutter_workmanager/&#34;&gt;&lt;img src=&#34;https://img.shields.io/cirrus/github/vrtdev/flutter_workmanager/master&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Flutter WorkManager is a wrapper around &lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/workmanager&#34;&gt;Android&#39;s WorkManager&lt;/a&gt;, &lt;a href=&#34;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623125-application&#34;&gt;iOS&#39; performFetchWithCompletionHandler&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/documentation/backgroundtasks/bgapprefreshtask&#34;&gt;iOS BGAppRefreshTask&lt;/a&gt;, effectively enabling headless execution of Dart code in the background.&lt;/p&gt; &#xA;&lt;p&gt;For iOS users, please watch this video on a general introduction to background processing: &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2020/10063&#34;&gt;https://developer.apple.com/videos/play/wwdc2020/10063&lt;/a&gt;. All of the constraints discussed in the video also apply to this plugin.&lt;/p&gt; &#xA;&lt;p&gt;This is especially useful to run periodic tasks, such as fetching remote data on a regular basis.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This plugin was featured in this &lt;a href=&#34;https://medium.com/vrt-digital-studio/flutter-workmanager-81e0cfbd6f6e&#34;&gt;Medium blogpost&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Platform Setup&lt;/h1&gt; &#xA;&lt;p&gt;In order for background work to be scheduled correctly you should follow the Android and iOS setup first.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fluttercommunity/flutter_workmanager/raw/master/ANDROID_SETUP.md&#34;&gt;Android Setup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fluttercommunity/flutter_workmanager/raw/master/IOS_SETUP.md&#34;&gt;iOS Setup&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to use the package?&lt;/h1&gt; &#xA;&lt;p&gt;See sample folder for a complete working example.&lt;br&gt; Before registering any task, the WorkManager plugin must be initialized.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;@pragma(&#39;vm:entry-point&#39;) // Mandatory if the App is obfuscated or using Flutter 3.1+&#xA;void callbackDispatcher() {&#xA;  Workmanager().executeTask((task, inputData) {&#xA;    print(&#34;Native called background task: $task&#34;); //simpleTask will be emitted here.&#xA;    return Future.value(true);&#xA;  });&#xA;}&#xA;&#xA;void main() {&#xA;  Workmanager().initialize(&#xA;    callbackDispatcher, // The top level function, aka callbackDispatcher&#xA;    isInDebugMode: true // If enabled it will post a notification whenever the task is running. Handy for debugging tasks&#xA;  );&#xA;  Workmanager().registerOneOffTask(&#34;task-identifier&#34;, &#34;simpleTask&#34;);&#xA;  runApp(MyApp());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;callbackDispatcher&lt;/code&gt; needs to be either a static function or a top level function to be accessible as a Flutter entry point.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The workmanager runs on a separate isolate from the main flutter isolate. Ensure to initialize all dependencies inside the &lt;code&gt;Workmanager().executeTask&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Debugging tips&lt;/h5&gt; &#xA;&lt;p&gt;Wrap the code inside your &lt;code&gt;Workmanager().executeTask&lt;/code&gt; in a &lt;code&gt;try and catch&lt;/code&gt; in order to catch any exceptions thrown.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;@pragma(&#39;vm:entry-point&#39;)&#xA;void callbackDispatcher() {&#xA;  Workmanager().executeTask((task, inputData) async {&#xA;&#xA;    int? totalExecutions;&#xA;    final _sharedPreference = await SharedPreferences.getInstance(); //Initialize dependency&#xA;&#xA;    try { //add code execution&#xA;      totalExecutions = _sharedPreference.getInt(&#34;totalExecutions&#34;);&#xA;      _sharedPreference.setInt(&#34;totalExecutions&#34;, totalExecutions == null ? 1 : totalExecutions+1);&#xA;    } catch(err) {&#xA;      Logger().e(err.toString()); // Logger flutter package, prints error on the debug console&#xA;      throw Exception(err);&#xA;    }&#xA;&#xA;    return Future.value(true);&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Android tasks are identified using their &lt;code&gt;taskName&lt;/code&gt;. iOS tasks are identified using their &lt;code&gt;taskIdentifier&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, there is an exception for iOS background fetch: &lt;code&gt;Workmanager.iOSBackgroundTask&lt;/code&gt;, a constant for iOS background fetch task.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Work Result&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;code&gt;Workmanager().executeTask(...&lt;/code&gt; block supports 3 possible outcomes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;Future.value(true)&lt;/code&gt;: The task is successful.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Future.value(false)&lt;/code&gt;: The task did not complete successfully and needs to be retried. On Android, the retry is done automatically. On iOS (when using BGTaskScheduler), the retry needs to be scheduled manually.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Future.error(...)&lt;/code&gt;: The task failed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;On Android, the &lt;code&gt;BackoffPolicy&lt;/code&gt; will configure how &lt;code&gt;WorkManager&lt;/code&gt; is going to retry the task.&lt;/p&gt; &#xA;&lt;p&gt;Refer to the example app for a successful, retrying and a failed task.&lt;/p&gt; &#xA;&lt;h1&gt;iOS specific setup and note&lt;/h1&gt; &#xA;&lt;p&gt;Initialize Workmanager only once. Background app refresh can only be tested on a real device, it cannot be tested on a simulator.&lt;/p&gt; &#xA;&lt;h3&gt;Migrate to 0.6.x&lt;/h3&gt; &#xA;&lt;p&gt;Version 0.6.x of this plugin has some breaking changes for iOS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Workmanager.registerOneOffTask was previously using iOS &lt;strong&gt;BGProcessingTask&lt;/strong&gt;, now it will be an immediate run task which will continue in the background if user leaves the App. Since the previous solution meant the one off task will only run if the device is idle and as often experienced only when device is charging, in practice it means somewhere at night, or not at all during that day, because &lt;strong&gt;BGProcessingTask&lt;/strong&gt; is meant for long running tasks. The new solution makes it more in line with Android except it does not support &lt;strong&gt;initialDelay&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you need the old behavior you can use the new iOS only method &lt;code&gt;Workmanager.registerProcessingTask&lt;/code&gt;: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Replace &lt;code&gt;Workmanager().registerOneOffTask&lt;/code&gt; with &lt;code&gt;Workmanager().registerProcessingTask&lt;/code&gt; in your App&lt;/li&gt; &#xA;   &lt;li&gt;Replace &lt;code&gt;WorkmanagerPlugin.registerTask&lt;/code&gt; with &lt;code&gt;WorkmanagerPlugin.registerBGProcessingTask&lt;/code&gt; in &lt;code&gt;AppDelegate.swift&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Workmanager.registerOneOffTask does not support &lt;strong&gt;initialDelay&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Workmanager.registerOneOffTask now supports &lt;strong&gt;inputData&lt;/strong&gt; which was always returning null in the previous solution&lt;/li&gt; &#xA; &lt;li&gt;Workmanager.registerOneOffTask now does NOT require &lt;code&gt;WorkmanagerPlugin.registerTask&lt;/code&gt; call in &lt;code&gt;AppDelegate.swift&lt;/code&gt; hence remove the call&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;One off tasks&lt;/h3&gt; &#xA;&lt;p&gt;iOS supports &lt;strong&gt;One off tasks&lt;/strong&gt; only on iOS 13+ with a few basic constraints:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;registerOneOffTask&lt;/code&gt; starts immediately. It might run for only 30 seconds due to iOS restrictions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().registerOneOffTask(&#xA;  &#34;task-identifier&#34;,&#xA;  simpleTaskKey, // Ignored on iOS&#xA;  initialDelay: Duration(minutes: 30), // Ignored on iOS&#xA;  inputData: ... // fully supported&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Periodic tasks&lt;/h3&gt; &#xA;&lt;p&gt;iOS supports two types of &lt;strong&gt;Periodic tasks&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;On iOS 12 and lower you can use deprecated Background Fetch API, see &lt;a href=&#34;https://raw.githubusercontent.com/fluttercommunity/flutter_workmanager/main/IOS_SETUP.md&#34;&gt;iOS Setup&lt;/a&gt;, even though the API is deprecated by iOS it still works on iOS 13+ as of writing this article&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;registerPeriodicTask&lt;/code&gt; is only supported on iOS 13+, it might run for only 30 seconds due to iOS restrictions, but doesn&#39;t start immediately, rather iOS will schedule it as per user&#39;s App usage pattern.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ On iOS 13+, adding a &lt;code&gt;BGTaskSchedulerPermittedIdentifiers&lt;/code&gt; key to the Info.plist for new &lt;code&gt;BGTaskScheduler&lt;/code&gt; API disables the &lt;code&gt;performFetchWithCompletionHandler&lt;/code&gt; and &lt;code&gt;setMinimumBackgroundFetchInterval&lt;/code&gt; methods, which means you cannot use both old Background Fetch and new &lt;code&gt;registerPeriodicTask&lt;/code&gt; at the same time, you have to choose one based on your minimum iOS target version. For details see &lt;a href=&#34;https://developer.apple.com/documentation/uikit/app_and_environment/scenes/preparing_your_ui_to_run_in_the_background/using_background_tasks_to_update_your_app&#34;&gt;Apple Docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To use &lt;code&gt;registerPeriodicTask&lt;/code&gt; first register the task in &lt;code&gt;Info.plist&lt;/code&gt; and &lt;code&gt;AppDelegate.swift&lt;/code&gt; &lt;a href=&#34;https://raw.githubusercontent.com/fluttercommunity/flutter_workmanager/main/IOS_SETUP.md&#34;&gt;iOS Setup&lt;/a&gt;. Unlike Android, for iOS you have to set the frequency in &lt;code&gt;AppDelegate.swift&lt;/code&gt;. The frequency is not guaranteed rather iOS will schedule it as per user&#39;s App usage pattern, iOS might take a few days to learn usage pattern. In reality frequency just means do not repeat the task before x seconds/minutes. If frequency is not provided it will default to 15 minutes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Register a periodic task with 20 minutes frequency. The frequency is in seconds.&#xA;WorkmanagerPlugin.registerPeriodicTask(withIdentifier: &#34;be.tramckrijte.workmanagerExample.iOSBackgroundAppRefresh&#34;, frequency: NSNumber(value: 20 * 60))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then schedule the task from your App&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;const iOSBackgroundAppRefresh = &#34;be.tramckrijte.workmanagerExample.iOSBackgroundAppRefresh&#34;;&#xA;Workmanager().registerPeriodicTask(&#xA;  iOSBackgroundAppRefresh,&#xA;  iOSBackgroundAppRefresh,&#xA;  initialDelay: Duration(seconds: 10),&#xA;  frequency: Duration(hours: 1), // Ignored on iOS, rather set in AppDelegate.swift&#xA;  inputData: ... // Not supported&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see &lt;a href=&#34;https://developer.apple.com/documentation/backgroundtasks/bgapprefreshtask&#34;&gt;BGAppRefreshTask&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Processing tasks&lt;/h3&gt; &#xA;&lt;p&gt;iOS supports &lt;strong&gt;Processing tasks&lt;/strong&gt; only on iOS 13+ which can run for more than 30 seconds.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;registerProcessingTask&lt;/code&gt; is a long running one off background task, currently only for iOS. It can be run for more than 30 seconds but doesn&#39;t start immediately, rather iOS might schedule it when device is idle and charging. Processing tasks are for long processes like data processing and app maintenance. Processing tasks can run for minutes, but the system can interrupt these. iOS might terminate any running background processing tasks when the user starts using the device. For more information see &lt;a href=&#34;https://developer.apple.com/documentation/backgroundtasks/bgprocessingtask&#34;&gt;BGProcessingTask&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;const iOSBackgroundProcessingTask = &#34;be.tramckrijte.workmanagerExample.iOSBackgroundProcessingTask&#34;;&#xA;Workmanager().registerProcessingTask(&#xA;  iOSBackgroundProcessingTask,&#xA;  iOSBackgroundProcessingTask,&#xA;  initialDelay: Duration(minutes: 2),&#xA;  constraints: Constraints(&#xA;    // Connected or metered mark the task as requiring internet&#xA;    networkType: NetworkType.connected,&#xA;    // Require external power&#xA;    requiresCharging: true,&#xA;  ),&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Background App Refresh permission&lt;/h3&gt; &#xA;&lt;p&gt;On iOS user can disable &lt;code&gt;Background App Refresh&lt;/code&gt; permission anytime, hence background tasks can only run if user has granted the permission.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;permision_handler&lt;/code&gt; to check for the permission:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final status = await Permission.backgroundRefresh.status;&#xA;if (status != PermissionStatus.granted) {&#xA;  _showNoPermission(context, status);&#xA;  return;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see the &lt;a href=&#34;https://developer.apple.com/documentation/backgroundtasks&#34;&gt;BGTaskScheduler documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Print scheduled tasks&lt;/h3&gt; &#xA;&lt;p&gt;On iOS you can print scheduled tasks using &lt;code&gt;Workmanager.printScheduledTasks&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;It prints task details to console. To be used during development/debugging. Currently only supported on iOS and only on iOS 13+.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;if (Platform.isIOS) {&#xA;  Workmanager().printScheduledTasks();&#xA;  // Prints: [BGTaskScheduler] Task Identifier: iOSBackgroundAppRefresh earliestBeginDate: 2023.10.10 PM 11:10:12&#xA;  // Or:     [BGTaskScheduler] There are no scheduled tasks&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Customisation (Android)&lt;/h1&gt; &#xA;&lt;p&gt;Not every &lt;code&gt;Android WorkManager&lt;/code&gt; feature is ported.&lt;/p&gt; &#xA;&lt;p&gt;Two kinds of background tasks can be registered :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;One off task&lt;/strong&gt; : runs only once&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Periodic tasks&lt;/strong&gt; : runs indefinitely on a regular basis&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// One off task registration&#xA;Workmanager().registerOneOffTask(&#xA;    &#34;oneoff-task-identifier&#34;, &#xA;    &#34;simpleTask&#34;&#xA;);&#xA;&#xA;// Periodic task registration&#xA;Workmanager().registerPeriodicTask(&#xA;    &#34;periodic-task-identifier&#34;, &#xA;    &#34;simplePeriodicTask&#34;, &#xA;    // When no frequency is provided the default 15 minutes is set.&#xA;    // Minimum frequency is 15 min. Android will automatically change your frequency to 15 min if you have configured a lower frequency.&#xA;    frequency: Duration(hours: 1),&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each task must have an &lt;strong&gt;unique name&lt;/strong&gt;;&lt;br&gt; This allows cancellation of a started task.&lt;br&gt; The second parameter is the &lt;code&gt;String&lt;/code&gt; that will be sent to your &lt;code&gt;callbackDispatcher&lt;/code&gt; function, indicating the task&#39;s &lt;em&gt;type&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Tagging&lt;/h2&gt; &#xA;&lt;p&gt;You can set the optional &lt;code&gt;tag&lt;/code&gt; property.&lt;br&gt; Handy for cancellation by &lt;code&gt;tag&lt;/code&gt;.&lt;br&gt; This is different from the unique name in that you can group multiple tasks under one tag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().registerOneOffTask(&#34;1&#34;, &#34;simpleTask&#34;, tag: &#34;tag&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Existing Work Policy&lt;/h2&gt; &#xA;&lt;p&gt;Indicates the desired behaviour when the same task is scheduled more than once.&lt;br&gt; The default is &lt;code&gt;KEEP&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().registerOneOffTask(&#34;1&#34;, &#34;simpleTask&#34;, existingWorkPolicy: ExistingWorkPolicy.append);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Initial Delay&lt;/h2&gt; &#xA;&lt;p&gt;Indicates how along a task should waitbefore its first run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().registerOneOffTask(&#34;1&#34;, &#34;simpleTask&#34;, initialDelay: Duration(seconds: 10));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Constraints&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Constraints are mapped at best effort to each platform. Android&#39;s WorkManager supports most of the specific constraints, whereas iOS tasks are limited.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NetworkType Constrains the type of network required for your work to run. For example, Connected. The &lt;code&gt;NetworkType&lt;/code&gt; lists various network conditions. &lt;code&gt;.connected&lt;/code&gt; &amp;amp; &lt;code&gt;.metered&lt;/code&gt; will be mapped to &lt;a href=&#34;https://developer.apple.com/documentation/backgroundtasks/bgprocessingtaskrequest/3142242-requiresnetworkconnectivity&#34;&gt;&lt;code&gt;requiresNetworkConnectivity&lt;/code&gt;&lt;/a&gt; on iOS.&lt;/li&gt; &#xA; &lt;li&gt;RequiresBatteryNotLow (Android only) When set to true, your work will not run if the device is in low battery mode. &lt;strong&gt;Enabling the battery saving mode on the android device prevents the job from running&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;RequiresCharging When set to true, your work will only run when the device is charging.&lt;/li&gt; &#xA; &lt;li&gt;RequiresDeviceIdle (Android only) When set to true, this requires the user’s device to be idle before the work will run. This can be useful for running batched operations that might otherwise have a - negative performance impact on other apps running actively on the user’s device.&lt;/li&gt; &#xA; &lt;li&gt;RequiresStorageNotLow (Android only) When set to true, your work will not run if the user’s storage space on the device is too low.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().registerOneOffTask(&#xA;    &#34;1&#34;,&#xA;    &#34;simpleTask&#34;,&#xA;    constraints: Constraints(&#xA;        networkType: NetworkType.connected,&#xA;        requiresBatteryNotLow: true,&#xA;        requiresCharging: true,&#xA;        requiresDeviceIdle: true,&#xA;        requiresStorageNotLow: true&#xA;    )&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;InputData&lt;/h3&gt; &#xA;&lt;p&gt;Add some input data for your task. Valid value types are: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; and their &lt;code&gt;list&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt; Workmanager().registerOneOffTask(&#xA;    &#34;1&#34;,&#xA;    &#34;simpleTask&#34;,&#xA;    inputData: {&#xA;    &#39;int&#39;: 1,&#xA;    &#39;bool&#39;: true,&#xA;    &#39;double&#39;: 1.0,&#xA;    &#39;string&#39;: &#39;string&#39;,&#xA;    &#39;array&#39;: [1, 2, 3],&#xA;    },&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;BackoffPolicy&lt;/h2&gt; &#xA;&lt;p&gt;Indicates the waiting strategy upon task failure.&lt;br&gt; The default is &lt;code&gt;BackoffPolicy.exponential&lt;/code&gt;.&lt;br&gt; You can also specify the delay.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().registerOneOffTask(&#34;1&#34;, &#34;simpleTask&#34;, backoffPolicy: BackoffPolicy.exponential, backoffPolicyDelay: Duration(seconds: 10));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Cancellation&lt;/h2&gt; &#xA;&lt;p&gt;A task can be cancelled in different ways :&lt;/p&gt; &#xA;&lt;h3&gt;By Tag&lt;/h3&gt; &#xA;&lt;p&gt;Cancels the task that was previously registered using this &lt;strong&gt;Tag&lt;/strong&gt;, if any.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().cancelByTag(&#34;tag&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;By Unique Name&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().cancelByUniqueName(&#34;&amp;lt;MyTask&amp;gt;&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;All&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Workmanager().cancelAll();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Building project&lt;/h1&gt; &#xA;&lt;p&gt;Project was migrated to &lt;a href=&#34;https://pub.dev/packages/melos&#34;&gt;Melos&lt;/a&gt; so build steps has changed.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install melos&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;dart pub global activate melos&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;In project root bootstrap&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;melos bootstrap&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Get packages&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;melos run get&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you should be able to run example project&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd example&#xA;flutter run&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>