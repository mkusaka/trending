<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dart Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-09-01T01:30:11Z</updated>
  <subtitle>Daily Trending of Dart in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>superlistapp/super_sliver_list</title>
    <updated>2024-09-01T01:30:11Z</updated>
    <id>tag:github.com,2024-09-01:/superlistapp/super_sliver_list</id>
    <link href="https://github.com/superlistapp/super_sliver_list" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Drop-in replacement for SliverList and ListView that can handle large amount of items with variable extents and reliably jump / animate to any item.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SliverList and ListView - Supercharged&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;See the &lt;a href=&#34;https://superlistapp.github.io/super_sliver_list/#/&#34;&gt;live example&lt;/a&gt; of &lt;code&gt;SuperSliverList&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;SuperSliverList&lt;/code&gt; and &lt;code&gt;SuperListView&lt;/code&gt; are drop in replacement widgets for &lt;code&gt;SliverList&lt;/code&gt; and &lt;code&gt;ListView&lt;/code&gt; with greatly improved performance and additional features:&lt;/p&gt; &#xA;&lt;h4&gt;Fast scrolling with large amount of items with variable extents&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SliverList&lt;/code&gt; performance degrades heavily when quickly scrolling through a large amount of items with different extents, requiring workarounds such as using &lt;code&gt;FixedExtentSliverList&lt;/code&gt; or prototype items. &lt;code&gt;SuperSliverList&lt;/code&gt; uses different layout algorithm and can handle virtually unlimited number of items with variable extents without any slow-downs.&lt;/p&gt; &#xA;&lt;h4&gt;Ability to jump or animate to specific item&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SliverList&lt;/code&gt; does not provide any way to jump or animate a particular index. There is a &lt;a href=&#34;https://pub.dev/packages/scrollable_positioned_list&#34;&gt;scrollable_positioned_list&lt;/a&gt; package that provides this functionality, but it comes at a cost, as it requires custom scroll view, does not seem to work properly with Scrollbars, can&#39;t be used with with other slivers (such as sticky headers) and ultimately is backed by a &lt;code&gt;SliverList&lt;/code&gt; so it has the same performance issues as mentioned above.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;SuperSliverList&lt;/code&gt; provides a way to reliably jump and animate to a specific item, even if the item is outside of the viewport and has not been built or laid out yet.&lt;/p&gt; &#xA;&lt;h4&gt;Smooth and predictable scrollbar behavior&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SliverList&lt;/code&gt; is quite prone to scrollbar erraticaly jumping around when scrolling through a list of items with different extents. With &lt;code&gt;SuperSliverList&lt;/code&gt; the scrollbar should behave more predictably. See the &lt;a href=&#34;https://raw.githubusercontent.com/superlistapp/super_sliver_list/main/#advanced&#34;&gt;Advanced&lt;/a&gt; section for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;SuperListView&lt;/code&gt; is a drop-in replacement for &lt;code&gt;ListView&lt;/code&gt;, and as such you can use it same way you&#39;d use &lt;code&gt;ListView&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;SuperListView.builder(&#xA;  itemCount: 1000,&#xA;  itemBuilder: (context, index) {&#xA;    return ListTile(title: Text(&#39;Item $index&#39;));&#xA;  },&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;SuperSliverList&lt;/code&gt; is a drop-in replacement for &lt;code&gt;SliverList&lt;/code&gt; and should work with any &lt;code&gt;CustomScrollView&lt;/code&gt; configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;CustomScrollView(&#xA;  slivers: &amp;lt;Widget&amp;gt;[&#xA;    SliverPadding(&#xA;      padding: const EdgeInsets.all(20.0),&#xA;      sliver: SuperSliverList(&#xA;        delegate: SliverChildListDelegate(&#xA;          &amp;lt;Widget&amp;gt;[&#xA;            const Text(&#34;I&#39;m dedicating every day to you&#34;),&#xA;            const Text(&#39;Domestic life was never quite my style&#39;),&#xA;            const Text(&#39;When you smile, you knock me out, I fall apart&#39;),&#xA;            const Text(&#39;And I thought I was so smart&#39;),&#xA;          ],&#xA;        ),&#xA;      ),&#xA;    ),&#xA;  ],&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Jumping and animating to specific item&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ListController&lt;/code&gt; can be provided to &lt;code&gt;SuperSliverList&lt;/code&gt;/&lt;code&gt;SuperListView&lt;/code&gt; and used to jump or animate to specific item:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class _MyState extends State&amp;lt;MyWidget&amp;gt; {&#xA;  final _listController = ListController();&#xA;  final _scrollController = ScrollController();&#xA;&#xA;  @override&#xA;  Widget build(BuildContext context) {&#xA;    return SuperListView.builder(&#xA;      listController: _listController,&#xA;      controller: _scrollController,&#xA;      itemCount: 1000,&#xA;      itemBuilder: (context, index) {&#xA;        return ListTile(title: Text(&#39;Item $index&#39;));&#xA;      },&#xA;    );&#xA;  }&#xA;&#xA;  void jumpToItem(int index) {&#xA;    _listController.jumpToItem(&#xA;      index: index,&#xA;      scrollController: _scrollController,&#xA;      alignment: 0.5,&#xA;    );&#xA;  }&#xA;&#xA;  void animateToItem(int index) {&#xA;    _listController.animateToItem(&#xA;      index: index,&#xA;      scrollController: _scrollController,&#xA;      alignment: 0.5,&#xA;      // You can provide duration and curve depending on the estimated&#xA;      // distance between currentPosition and the target item position.&#xA;      duration: (estimatedDistance) =&amp;gt; Duration(milliseconds: 250),&#xA;      curve: (estimatedDistance) =&amp;gt; Curves.easeInOut,&#xA;    );&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advanced&lt;/h2&gt; &#xA;&lt;p&gt;Very roughtly speaking &lt;code&gt;SuperSliverList&lt;/code&gt; works by estimating the extent of items that are outside of viewport and when these items are scrolled into the viewport cache area the scroll position is transparently adjusted to account of the difference between estimated and actual extents. On small lists this difference may result in scrollbar movement not being perfectly aligned with list movement. &lt;code&gt;SuperSliverList&lt;/code&gt; provides two ways to rectify this:&lt;/p&gt; &#xA;&lt;h3&gt;Improve extent estimation&lt;/h3&gt; &#xA;&lt;p&gt;You can register custom callback that will be used to estimate extent of estimated items. This can be useful if you have an idea, atleast approximately, how large the extent of each item is.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;SuperSliverList(&#xA;    delegate: /*...*/,&#xA;    estimateExtent: (index) =&amp;gt; 100.0, // Provide your own extent estimation&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Precalculate extents for items&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;SuperSliverList&lt;/code&gt; can, if needed, asynchronously precalculate extents for items. To enfore this, subclass &lt;code&gt;ExtentPrecalculationPolicy&lt;/code&gt; and provide it to &lt;code&gt;SuperSliverList&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;In this example the extents are eagerly precalculated for lists with less than 100 items:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class MyPrecalculationPolicy extends ExtentPrecalculationPolicy {&#xA;  @override&#xA;  bool shouldPrecaculateExtents(ExtentPrecalculationContext context)  {&#xA;    return context.numberOfItems &amp;lt; 100;&#xA;  }&#xA;}&#xA;&#xA;return SuperSliverList(&#xA;    delegate: /*...*/,&#xA;    extentPrecalculationPolicy: myPolicy,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The threshold is arbitrary, but in general there are diminishing returns for precalculating extents for large lists, as the extent estimation error for each item has much smaller impact on the scrollbar position if there are many items.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/superlistapp/super_sliver_list/main/example&#34;&gt;example&lt;/a&gt; folder for a complete sample app using &lt;code&gt;SuperSliverList&lt;/code&gt;. You can also see the &lt;a href=&#34;https://superlistapp.github.io/super_sliver_list/&#34;&gt;example deployed live&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dart-lang/mockito</title>
    <updated>2024-09-01T01:30:11Z</updated>
    <id>tag:github.com,2024-09-01:/dart-lang/mockito</id>
    <link href="https://github.com/dart-lang/mockito" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mockito-inspired mock library for Dart&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/dart-lang/mockito/actions/workflows/test-package.yml&#34;&gt;&lt;img src=&#34;https://github.com/dart-lang/mockito/actions/workflows/test-package.yml/badge.svg?sanitize=true&#34; alt=&#34;Dart CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pub.dev/packages/mockito&#34;&gt;&lt;img src=&#34;https://img.shields.io/pub/v/mockito.svg?sanitize=true&#34; alt=&#34;Pub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pub.dev/packages/mockito/publisher&#34;&gt;&lt;img src=&#34;https://img.shields.io/pub/publisher/mockito.svg?sanitize=true&#34; alt=&#34;package publisher&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Mock library for Dart inspired by &lt;a href=&#34;https://github.com/mockito/mockito&#34;&gt;Mockito&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Let&#39;s create mocks&lt;/h2&gt; &#xA;&lt;p&gt;Mockito 5.0.0 supports Dart&#39;s new &lt;strong&gt;null safety&lt;/strong&gt; language feature in Dart 2.12, primarily with code generation.&lt;/p&gt; &#xA;&lt;p&gt;To use Mockito&#39;s generated mock classes, add a &lt;code&gt;build_runner&lt;/code&gt; dependency in your package&#39;s &lt;code&gt;pubspec.yaml&lt;/code&gt; file, under &lt;code&gt;dev_dependencies&lt;/code&gt;; something like &lt;code&gt;build_runner: ^1.11.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For alternatives to the code generation API, see the &lt;a href=&#34;https://github.com/dart-lang/mockito/raw/master/NULL_SAFETY_README.md&#34;&gt;NULL_SAFETY_README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s start with a Dart library, &lt;code&gt;cat.dart&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:mockito/annotations.dart&#39;;&#xA;import &#39;package:mockito/mockito.dart&#39;;&#xA;&#xA;// Annotation which generates the cat.mocks.dart library and the MockCat class.&#xA;@GenerateNiceMocks([MockSpec&amp;lt;Cat&amp;gt;()])&#xA;import &#39;cat.mocks.dart&#39;;&#xA;&#xA;// Real class&#xA;class Cat {&#xA;  String sound() =&amp;gt; &#34;Meow&#34;;&#xA;  bool eatFood(String food, {bool? hungry}) =&amp;gt; true;&#xA;  Future&amp;lt;void&amp;gt; chew() async =&amp;gt; print(&#34;Chewing...&#34;);&#xA;  int walk(List&amp;lt;String&amp;gt; places) =&amp;gt; 7;&#xA;  void sleep() {}&#xA;  void hunt(String place, String prey) {}&#xA;  int lives = 9;&#xA;}&#xA;&#xA;void main() {&#xA;  // Create mock object.&#xA;  var cat = MockCat();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By annotating the import of a &lt;code&gt;.mocks.dart&lt;/code&gt; library with &lt;code&gt;@GenerateNiceMocks&lt;/code&gt;, you are directing Mockito&#39;s code generation to write a mock class for each &#34;real&#34; class listed, in a new library.&lt;/p&gt; &#xA;&lt;p&gt;The next step is to run &lt;code&gt;build_runner&lt;/code&gt; in order to generate this new library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;flutter pub run build_runner build&#xA;# OR&#xA;dart run build_runner build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;build_runner&lt;/code&gt; will generate a file with a name based on the file containing the &lt;code&gt;@GenerateNiceMocks&lt;/code&gt; annotation. In the above &lt;code&gt;cat.dart&lt;/code&gt; example, we import the generated library as &lt;code&gt;cat.mocks.dart&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: by default only annotations in files under &lt;code&gt;test/&lt;/code&gt; are processed, if you want to add Mockito annotations in other places, you will need to add a &lt;code&gt;build.yaml&lt;/code&gt; file to your project, see &lt;a href=&#34;https://stackoverflow.com/questions/68275811/is-there-a-way-to-let-mockito-generate-mocks-for-integration-tests-in-a-flutter&#34;&gt;this SO answer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The generated mock class, &lt;code&gt;MockCat&lt;/code&gt;, extends Mockito&#39;s Mock class and implements the Cat class, giving us a class which supports stubbing and verifying.&lt;/p&gt; &#xA;&lt;h2&gt;Let&#39;s verify some behavior!&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Interact with the mock object.&#xA;cat.sound();&#xA;// Verify the interaction.&#xA;verify(cat.sound());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once created, the mock instance will remember all interactions. Then you can selectively &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verify.html&#34;&gt;&lt;code&gt;verify&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verifyInOrder.html&#34;&gt;&lt;code&gt;verifyInOrder&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verifyNever.html&#34;&gt;&lt;code&gt;verifyNever&lt;/code&gt;&lt;/a&gt;) the interactions you are interested in.&lt;/p&gt; &#xA;&lt;h2&gt;How about some stubbing?&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Stub a mock method before interacting.&#xA;when(cat.sound()).thenReturn(&#34;Purr&#34;);&#xA;expect(cat.sound(), &#34;Purr&#34;);&#xA;&#xA;// You can call it again.&#xA;expect(cat.sound(), &#34;Purr&#34;);&#xA;&#xA;// Let&#39;s change the stub.&#xA;when(cat.sound()).thenReturn(&#34;Meow&#34;);&#xA;expect(cat.sound(), &#34;Meow&#34;);&#xA;&#xA;// You can stub getters.&#xA;when(cat.lives).thenReturn(9);&#xA;expect(cat.lives, 9);&#xA;&#xA;// You can stub a method to throw.&#xA;when(cat.lives).thenThrow(RangeError(&#39;Boo&#39;));&#xA;expect(() =&amp;gt; cat.lives, throwsRangeError);&#xA;&#xA;// We can calculate a response at call time.&#xA;var responses = [&#34;Purr&#34;, &#34;Meow&#34;];&#xA;when(cat.sound()).thenAnswer((_) =&amp;gt; responses.removeAt(0));&#xA;expect(cat.sound(), &#34;Purr&#34;);&#xA;expect(cat.sound(), &#34;Meow&#34;);&#xA;&#xA;// We can stub a method with multiple calls that happened in a particular order.&#xA;when(cat.sound()).thenReturnInOrder([&#34;Purr&#34;, &#34;Meow&#34;]);&#xA;expect(cat.sound(), &#34;Purr&#34;);&#xA;expect(cat.sound(), &#34;Meow&#34;);&#xA;expect(() =&amp;gt; cat.sound(), throwsA(isA&amp;lt;StateError&amp;gt;()));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/when.html&#34;&gt;&lt;code&gt;when&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/PostExpectation/thenReturn.html&#34;&gt;&lt;code&gt;thenReturn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/PostExpectation/thenAnswer.html&#34;&gt;&lt;code&gt;thenAnswer&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/PostExpectation/thenThrow.html&#34;&gt;&lt;code&gt;thenThrow&lt;/code&gt;&lt;/a&gt; APIs provide a stubbing mechanism to override this behavior. Once stubbed, the method will always return stubbed value regardless of how many times it is called. If a method invocation matches multiple stubs, the one which was declared last will be used. It is worth noting that stubbing and verifying only works on methods of a mocked class; in this case, an instance of &lt;code&gt;MockCat&lt;/code&gt; must be used, not an instance of &lt;code&gt;Cat&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;A quick word on async stubbing&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/PostExpectation/thenReturn.html&#34;&gt;&lt;code&gt;thenReturn&lt;/code&gt;&lt;/a&gt; to return a &lt;code&gt;Future&lt;/code&gt; or &lt;code&gt;Stream&lt;/code&gt; will throw an &lt;code&gt;ArgumentError&lt;/code&gt;.&lt;/strong&gt; This is because it can lead to unexpected behaviors. For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the method is stubbed in a different zone than the zone that consumes the &lt;code&gt;Future&lt;/code&gt;, unexpected behavior could occur.&lt;/li&gt; &#xA; &lt;li&gt;If the method is stubbed to return a failed &lt;code&gt;Future&lt;/code&gt; or &lt;code&gt;Stream&lt;/code&gt; and it doesn&#39;t get consumed in the same run loop, it might get consumed by the global exception handler instead of an exception handler the consumer applies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Instead, use &lt;code&gt;thenAnswer&lt;/code&gt; to stub methods that return a &lt;code&gt;Future&lt;/code&gt; or &lt;code&gt;Stream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// BAD&#xA;when(mock.methodThatReturnsAFuture())&#xA;    .thenReturn(Future.value(&#39;Stub&#39;));&#xA;when(mock.methodThatReturnsAStream())&#xA;    .thenReturn(Stream.fromIterable([&#39;Stub&#39;]));&#xA;&#xA;// GOOD&#xA;when(mock.methodThatReturnsAFuture())&#xA;    .thenAnswer((_) async =&amp;gt; &#39;Stub&#39;);&#xA;when(mock.methodThatReturnsAStream())&#xA;    .thenAnswer((_) =&amp;gt; Stream.fromIterable([&#39;Stub&#39;]));&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If, for some reason, you desire the behavior of &lt;code&gt;thenReturn&lt;/code&gt;, you can return a pre-defined instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Use the above method unless you&#39;re sure you want to create the Future ahead&#xA;// of time.&#xA;final future = Future.value(&#39;Stub&#39;);&#xA;when(mock.methodThatReturnsAFuture()).thenAnswer((_) =&amp;gt; future);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Argument matchers&lt;/h2&gt; &#xA;&lt;p&gt;Mockito provides the concept of the &#34;argument matcher&#34; (using the class ArgMatcher) to capture arguments and to track how named arguments are passed. In most cases, both plain arguments and argument matchers can be passed into mock methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// You can use `any`&#xA;when(cat.eatFood(any)).thenReturn(false);&#xA;&#xA;// ... or plain arguments themselves&#xA;when(cat.eatFood(&#34;fish&#34;)).thenReturn(true);&#xA;&#xA;// ... including collections&#xA;when(cat.walk([&#34;roof&#34;,&#34;tree&#34;])).thenReturn(2);&#xA;&#xA;// ... or matchers&#xA;when(cat.eatFood(argThat(startsWith(&#34;dry&#34;)))).thenReturn(false);&#xA;&#xA;// ... or mix arguments with matchers&#xA;when(cat.eatFood(argThat(startsWith(&#34;dry&#34;)), hungry: true)).thenReturn(true);&#xA;expect(cat.eatFood(&#34;fish&#34;), isTrue);&#xA;expect(cat.walk([&#34;roof&#34;,&#34;tree&#34;]), equals(2));&#xA;expect(cat.eatFood(&#34;dry food&#34;), isFalse);&#xA;expect(cat.eatFood(&#34;dry food&#34;, hungry: true), isTrue);&#xA;&#xA;// You can also verify using an argument matcher.&#xA;verify(cat.eatFood(&#34;fish&#34;));&#xA;verify(cat.walk([&#34;roof&#34;,&#34;tree&#34;]));&#xA;verify(cat.eatFood(argThat(contains(&#34;food&#34;))));&#xA;&#xA;// You can verify setters.&#xA;cat.lives = 9;&#xA;verify(cat.lives=9);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If an argument other than an ArgMatcher (like &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/any.html&#34;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/anyNamed.html&#34;&gt;&lt;code&gt;anyNamed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/argThat.html&#34;&gt;&lt;code&gt;argThat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/captureThat.html&#34;&gt;&lt;code&gt;captureThat&lt;/code&gt;&lt;/a&gt;, etc.) is passed to a mock method, then the &lt;a href=&#34;https://pub.dev/documentation/matcher/latest/matcher/equals.html&#34;&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/a&gt; matcher is used for argument matching. If you need more strict matching, consider using &lt;code&gt;argThat(identical(arg))&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, note that &lt;code&gt;null&lt;/code&gt; cannot be used as an argument adjacent to ArgMatcher arguments, nor as an un-wrapped value passed as a named argument. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;verify(cat.hunt(&#34;backyard&#34;, null)); // OK: no arg matchers.&#xA;verify(cat.hunt(argThat(contains(&#34;yard&#34;)), null)); // BAD: adjacent null.&#xA;verify(cat.hunt(argThat(contains(&#34;yard&#34;)), argThat(isNull))); // OK: wrapped in an arg matcher.&#xA;verify(cat.eatFood(&#34;Milk&#34;, hungry: null)); // BAD: null as a named argument.&#xA;verify(cat.eatFood(&#34;Milk&#34;, hungry: argThat(isNull))); // BAD: null as a named argument.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Named arguments&lt;/h2&gt; &#xA;&lt;p&gt;Mockito currently has an awkward nuisance to its syntax: named arguments and argument matchers require more specification than you might think: you must declare the name of the argument in the argument matcher. This is because we can&#39;t rely on the position of a named argument, and the language doesn&#39;t provide a mechanism to answer &#34;Is this element being used as a named element?&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// GOOD: argument matchers include their names.&#xA;when(cat.eatFood(any, hungry: anyNamed(&#39;hungry&#39;))).thenReturn(true);&#xA;when(cat.eatFood(any, hungry: argThat(isNotNull, named: &#39;hungry&#39;))).thenReturn(false);&#xA;when(cat.eatFood(any, hungry: captureAnyNamed(&#39;hungry&#39;))).thenReturn(false);&#xA;when(cat.eatFood(any, hungry: captureThat(isNotNull, named: &#39;hungry&#39;))).thenReturn(true);&#xA;&#xA;// BAD: argument matchers do not include their names.&#xA;when(cat.eatFood(any, hungry: any)).thenReturn(true);&#xA;when(cat.eatFood(any, hungry: argThat(isNotNull))).thenReturn(false);&#xA;when(cat.eatFood(any, hungry: captureAny)).thenReturn(false);&#xA;when(cat.eatFood(any, hungry: captureThat(isNotNull))).thenReturn(true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Verifying exact number of invocations / at least x / never&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verify.html&#34;&gt;&lt;code&gt;verify&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verifyNever.html&#34;&gt;&lt;code&gt;verifyNever&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;cat.sound();&#xA;cat.sound();&#xA;&#xA;// Exact number of invocations&#xA;verify(cat.sound()).called(2);&#xA;&#xA;// Or using matcher&#xA;verify(cat.sound()).called(greaterThan(1));&#xA;&#xA;// Or never called&#xA;verifyNever(cat.eatFood(any));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Verification in order&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verifyInOrder.html&#34;&gt;&lt;code&gt;verifyInOrder&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;cat.eatFood(&#34;Milk&#34;);&#xA;cat.sound();&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;verifyInOrder([&#xA;  cat.eatFood(&#34;Milk&#34;),&#xA;  cat.sound(),&#xA;  cat.eatFood(&#34;Fish&#34;)&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Verification in order is flexible - you don&#39;t have to verify all interactions one-by-one but only those that you are interested in testing in order.&lt;/p&gt; &#xA;&lt;h2&gt;Making sure interaction(s) never happened on mock&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verifyZeroInteractions.html&#34;&gt;&lt;code&gt;verifyZeroInteractions&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;verifyZeroInteractions(cat);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Finding redundant invocations&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verifyNoMoreInteractions.html&#34;&gt;&lt;code&gt;verifyNoMoreInteractions&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;cat.sound();&#xA;verify(cat.sound());&#xA;verifyNoMoreInteractions(cat);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Capturing arguments for further assertions&lt;/h2&gt; &#xA;&lt;p&gt;Use the &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/captureAny.html&#34;&gt;&lt;code&gt;captureAny&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/captureThat.html&#34;&gt;&lt;code&gt;captureThat&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/captureAnyNamed.html&#34;&gt;&lt;code&gt;captureAnyNamed&lt;/code&gt;&lt;/a&gt; argument matchers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Simple capture&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;expect(verify(cat.eatFood(captureAny)).captured.single, &#34;Fish&#34;);&#xA;&#xA;// Capture multiple calls&#xA;cat.eatFood(&#34;Milk&#34;);&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;expect(verify(cat.eatFood(captureAny)).captured, [&#34;Milk&#34;, &#34;Fish&#34;]);&#xA;&#xA;// Conditional capture&#xA;cat.eatFood(&#34;Milk&#34;);&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;expect(verify(cat.eatFood(captureThat(startsWith(&#34;F&#34;)))).captured, [&#34;Fish&#34;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Waiting for an interaction&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/untilCalled.html&#34;&gt;&lt;code&gt;untilCalled&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Waiting for a call.&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;await untilCalled(cat.chew()); // Completes when cat.chew() is called.&#xA;&#xA;// Waiting for a call that has already happened.&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;await untilCalled(cat.eatFood(any)); // Completes immediately.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Nice mocks vs classic mocks&lt;/h2&gt; &#xA;&lt;p&gt;Mockito provides two APIs for generating mocks, the &lt;code&gt;@GenerateNiceMocks&lt;/code&gt; annotation and the &lt;code&gt;@GenerateMocks&lt;/code&gt; annotation. &lt;strong&gt;The recommended API is &lt;code&gt;@GenerateNiceMocks&lt;/code&gt;.&lt;/strong&gt; The difference between these two APIs is in the behavior of a generated mock class when a method is called and no stub could be found. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;void main() {&#xA;  var cat = MockCat();&#xA;  cat.sound();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Cat.sound&lt;/code&gt; method returns a non-nullable String, but no stub has been made with &lt;code&gt;when(cat.sound())&lt;/code&gt;, so what should the code do? What is the &#34;missing stub&#34; behavior?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &#34;missing stub&#34; behavior of a mock class generated with &lt;code&gt;@GenerateMocks&lt;/code&gt; is to throw an exception.&lt;/li&gt; &#xA; &lt;li&gt;The &#34;missing stub&#34; behavior of a mock class generated with &lt;code&gt;@GenerateNiceMocks&lt;/code&gt; is to return a &#34;simple&#34; legal value (for example, a non-&lt;code&gt;null&lt;/code&gt; value for a non-nullable return type). The value should not be used in any way; it is returned solely to avoid a runtime type exception.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Mocking a Function type&lt;/h2&gt; &#xA;&lt;p&gt;To create mocks for Function objects, write an &lt;code&gt;abstract class&lt;/code&gt; with a method for each function type signature that needs to be mocked. The methods can be torn off and individually stubbed and verified.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;@GenerateMocks([Cat, Callbacks])&#xA;import &#39;cat_test.mocks.dart&#39;&#xA;&#xA;abstract class Callbacks {&#xA;  Cat findCat(String name);&#xA;}&#xA;&#xA;void main() {&#xA;  var mockCat = MockCat();&#xA;  var findCatCallback = MockCallbacks().findCat;&#xA;  when(findCatCallback(&#39;Pete&#39;)).thenReturn(mockCat);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Writing a fake&lt;/h2&gt; &#xA;&lt;p&gt;You can also write a simple fake class that implements a real class, by extending &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/Fake-class.html&#34;&gt;Fake&lt;/a&gt;. Fake allows your subclass to satisfy the implementation of your real class, without overriding the methods that aren&#39;t used in your test; the Fake class implements the default behavior of throwing &lt;a href=&#34;https://api.dartlang.org/stable/dart-core/UnimplementedError-class.html&#34;&gt;UnimplementedError&lt;/a&gt; (which you can override in your fake class):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Fake class&#xA;class FakeCat extends Fake implements Cat {&#xA;  @override&#xA;  bool eatFood(String food, {bool? hungry}) {&#xA;    print(&#39;Fake eat $food&#39;);&#xA;    return true;&#xA;  }&#xA;}&#xA;&#xA;void main() {&#xA;  // Create a new fake Cat at runtime.&#xA;  var cat = FakeCat();&#xA;&#xA;  cat.eatFood(&#34;Milk&#34;); // Prints &#39;Fake eat Milk&#39;.&#xA;  cat.sleep(); // Throws.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resetting mocks&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/reset.html&#34;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Clearing collected interactions:&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;clearInteractions(cat);&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;verify(cat.eatFood(&#34;Fish&#34;)).called(1);&#xA;&#xA;// Resetting stubs and collected interactions:&#xA;when(cat.eatFood(&#34;Fish&#34;)).thenReturn(true);&#xA;cat.eatFood(&#34;Fish&#34;);&#xA;reset(cat);&#xA;when(cat.eatFood(any)).thenReturn(false);&#xA;expect(cat.eatFood(&#34;Fish&#34;), false);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/logInvocations.html&#34;&gt;&lt;code&gt;logInvocations&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/throwOnMissingStub.html&#34;&gt;&lt;code&gt;throwOnMissingStub&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Print all collected invocations of any mock methods of a list of mock objects:&#xA;logInvocations([catOne, catTwo]);&#xA;&#xA;// Throw every time that a mock method is called without a stub being matched:&#xA;throwOnMissingStub(cat);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Best Practices&lt;/h2&gt; &#xA;&lt;p&gt;Testing with real objects is preferred over testing with mocks - if you can construct a real instance for your tests, you should! If there are no calls to &lt;a href=&#34;https://pub.dev/documentation/mockito/latest/mockito/verify.html&#34;&gt;&lt;code&gt;verify&lt;/code&gt;&lt;/a&gt; in your test, it is a strong signal that you may not need mocks at all, though it&#39;s also OK to use a &lt;code&gt;Mock&lt;/code&gt; like a stub. Data models never need to be mocked if they can be constructed with stubbed data. When it&#39;s not possible to use the real object, a tested implementation of a fake is the next best thing; it&#39;s more likely to behave similarly to the real class than responses stubbed out in tests. Finally an object which &lt;code&gt;extends Fake&lt;/code&gt; using manually overridden methods is preferred over an object which &lt;code&gt;extends Mock&lt;/code&gt; used as either a stub or a mock.&lt;/p&gt; &#xA;&lt;p&gt;A class which &lt;code&gt;extends Mock&lt;/code&gt; should &lt;em&gt;never&lt;/em&gt; stub out its own responses with &lt;code&gt;when&lt;/code&gt; in its constructor or anywhere else. Stubbed responses should be defined in the tests where they are used. For responses controlled outside of the test use &lt;code&gt;@override&lt;/code&gt; methods for either the entire interface, or with &lt;code&gt;extends Fake&lt;/code&gt; to skip some parts of the interface.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, a class which &lt;code&gt;extends Mock&lt;/code&gt; should &lt;em&gt;never&lt;/em&gt; have any implementation. It should not define any &lt;code&gt;@override&lt;/code&gt; methods, and it should not mixin any implementations. Actual member definitions can&#39;t be stubbed by tests and can&#39;t be tracked and verified by Mockito. A mix of test defined stubbed responses and mock defined overrides will lead to confusion. It is OK to define &lt;em&gt;static&lt;/em&gt; utilities on a class which &lt;code&gt;extends Mock&lt;/code&gt; if it helps with code structure.&lt;/p&gt; &#xA;&lt;h2&gt;Frequently asked questions&lt;/h2&gt; &#xA;&lt;p&gt;Read more information about this package in the &lt;a href=&#34;https://github.com/dart-lang/mockito/raw/master/FAQ.md&#34;&gt;FAQ&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>