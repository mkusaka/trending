<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dart Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-29T01:28:56Z</updated>
  <subtitle>Daily Trending of Dart in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rodydavis/signals.dart</title>
    <updated>2023-11-29T01:28:56Z</updated>
    <id>tag:github.com,2023-11-29:/rodydavis/signals.dart</id>
    <link href="https://github.com/rodydavis/signals.dart" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Complete port of @preact/signals-core to Dart and extensions for common operations&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/rodydavis/signals.dart/actions/workflows/tests.yml&#34;&gt;&lt;img src=&#34;https://github.com/rodydavis/signals.dart/actions/workflows/tests.yml/badge.svg?sanitize=true&#34; alt=&#34;Tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/rodydavis/signals.dart/actions/workflows/website.yml&#34;&gt;&lt;img src=&#34;https://github.com/rodydavis/signals.dart/actions/workflows/website.yml/badge.svg?sanitize=true&#34; alt=&#34;Website&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Signals.dart&lt;/h1&gt; &#xA;&lt;p&gt;Complete dart port of &lt;a href=&#34;https://preactjs.com/blog/introducing-signals/&#34;&gt;Preact signals&lt;/a&gt; and takes full advantage of &lt;a href=&#34;https://preactjs.com/blog/signal-boosting/&#34;&gt;signal boosting&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Documentation Site: &lt;a href=&#34;https://rodydavis.github.io/signals.dart/&#34;&gt;https://rodydavis.github.io/signals.dart/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Package&lt;/th&gt; &#xA;   &lt;th&gt;Pub&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rodydavis/signals.dart/main/packages/signals&#34;&gt;&lt;code&gt;signals&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://pub.dev/packages/signals&#34;&gt;&lt;img src=&#34;https://img.shields.io/pub/v/signals.svg?sanitize=true&#34; alt=&#34;signals&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rodydavis/signals.dart/main/packages/signals_devtools_extension&#34;&gt;&lt;code&gt;signals_devtools_extension&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Guide / API&lt;/h2&gt; &#xA;&lt;p&gt;The signals library exposes four functions which are the building blocks to model any business logic you can think of.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;signal(initialValue)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;signal&lt;/code&gt; function creates a new signal. A signal is a container for a value that can change over time. You can read a signal&#39;s value or subscribe to value updates by accessing its &lt;code&gt;.value&lt;/code&gt; property.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;final counter = signal(0);&#xA;&#xA;// Read value from signal, logs: 0&#xA;print(counter.value);&#xA;&#xA;// Write to a signal&#xA;counter.value = 1;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Writing to a signal is done by setting its &lt;code&gt;.value&lt;/code&gt; property. Changing a signal&#39;s value synchronously updates every &lt;a href=&#34;https://raw.githubusercontent.com/rodydavis/signals.dart/main/#computedfn&#34;&gt;computed&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/rodydavis/signals.dart/main/#effectfn&#34;&gt;effect&lt;/a&gt; that depends on that signal, ensuring your app state is always consistent.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;signal.peek()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;In the rare instance that you have an effect that should write to another signal based on the previous value, but you &lt;em&gt;don&#39;t&lt;/em&gt; want the effect to be subscribed to that signal, you can read a signals&#39;s previous value via &lt;code&gt;signal.peek()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final counter = signal(0);&#xA;final effectCount = signal(0);&#xA;&#xA;effect(() {&#xA;&#x9;print(counter.value);&#xA;&#xA;&#x9;// Whenever this effect is triggered, increase `effectCount`.&#xA;&#x9;// But we don&#39;t want this signal to react to `effectCount`&#xA;&#x9;effectCount.value = effectCount.peek() + 1;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you should only use &lt;code&gt;signal.peek()&lt;/code&gt; if you really need it. Reading a signal&#39;s value via &lt;code&gt;signal.value&lt;/code&gt; is the preferred way in most scenarios.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;untracked(fn)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In case when you&#39;re receiving a callback that can read some signals, but you don&#39;t want to subscribe to them, you can use &lt;code&gt;untracked&lt;/code&gt; to prevent any subscriptions from happening.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final counter = signal(0);&#xA;final effectCount = signal(0);&#xA;final fn = () =&amp;gt; effectCount.value + 1;&#xA;&#xA;effect(() {&#xA;&#x9;print(counter.value);&#xA;&#xA;&#x9;// Whenever this effect is triggered, run `fn` that gives new value&#xA;&#x9;effectCount.value = untracked(fn);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;computed(fn)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Data is often derived from other pieces of existing data. The &lt;code&gt;computed&lt;/code&gt; function lets you combine the values of multiple signals into a new signal that can be reacted to, or even used by additional computeds. When the signals accessed from within a computed callback change, the computed callback is re-executed and its new return value becomes the computed signal&#39;s value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;final name = signal(&#34;Jane&#34;);&#xA;final surname = signal(&#34;Doe&#34;);&#xA;&#xA;final fullName = computed(() =&amp;gt; name.value + &#34; &#34; + surname.value);&#xA;&#xA;// Logs: &#34;Jane Doe&#34;&#xA;print(fullName.value);&#xA;&#xA;// Updates flow through computed, but only if someone&#xA;// subscribes to it. More on that later.&#xA;name.value = &#34;John&#34;;&#xA;// Logs: &#34;John Doe&#34;&#xA;print(fullName.value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any signal that is accessed inside the &lt;code&gt;computed&lt;/code&gt;&#39;s callback function will be automatically subscribed to and tracked as a dependency of the computed signal.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;effect(fn)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;effect&lt;/code&gt; function is the last piece that makes everything reactive. When you access a signal inside an &lt;code&gt;effect&lt;/code&gt;&#39;s callback function, that signal and every dependency of said signal will be activated and subscribed to. In that regard it is very similar to &lt;a href=&#34;https://raw.githubusercontent.com/rodydavis/signals.dart/main/#computedfn&#34;&gt;&lt;code&gt;computed(fn)&lt;/code&gt;&lt;/a&gt;. By default all updates are lazy, so nothing will update until you access a signal inside &lt;code&gt;effect&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;final name = signal(&#34;Jane&#34;);&#xA;final surname = signal(&#34;Doe&#34;);&#xA;final fullName = computed(() =&amp;gt; name.value + &#34; &#34; + surname.value);&#xA;&#xA;// Logs: &#34;Jane Doe&#34;&#xA;effect(() =&amp;gt; print(fullName.value));&#xA;&#xA;// Updating one of its dependencies will automatically trigger&#xA;// the effect above, and will print &#34;John Doe&#34; to the console.&#xA;name.value = &#34;John&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can destroy an effect and unsubscribe from all signals it was subscribed to, by calling the returned function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;final name = signal(&#34;Jane&#34;);&#xA;final surname = signal(&#34;Doe&#34;);&#xA;final fullName = computed(() =&amp;gt; name.value + &#34; &#34; + surname.value);&#xA;&#xA;// Logs: &#34;Jane Doe&#34;&#xA;final dispose = effect(() =&amp;gt; print(fullName.value));&#xA;&#xA;// Destroy effect and subscriptions&#xA;dispose();&#xA;&#xA;// Update does nothing, because no one is subscribed anymore.&#xA;// Even the computed `fullName` signal won&#39;t change, because it knows&#xA;// that no one listens to it.&#xA;surname.value = &#34;Doe 2&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Warning Cycles&lt;/h4&gt; &#xA;&lt;p&gt;Mutating a signal inside an effect will cause an infinite loop, because the effect will be triggered again. To prevent this, you can use &lt;a href=&#34;https://raw.githubusercontent.com/rodydavis/signals.dart/main/#untrackedfn&#34;&gt;&lt;code&gt;untracked(fn)&lt;/code&gt;&lt;/a&gt; to read a signal without subscribing to it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;dart:async&#39;;&#xA;&#xA;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;Future&amp;lt;void&amp;gt; main() async {&#xA;  final completer = Completer&amp;lt;void&amp;gt;();&#xA;  final age = signal(0);&#xA;&#xA;  effect(() {&#xA;    print(&#39;You are ${age.value} years old&#39;);&#xA;    age.value++; // &amp;lt;-- This will throw a cycle error&#xA;  });&#xA;&#xA;  await completer.future;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;batch(fn)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;batch&lt;/code&gt; function allows you to combine multiple signal writes into one single update that is triggered at the end when the callback completes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;final name = signal(&#34;Jane&#34;);&#xA;final surname = signal(&#34;Doe&#34;);&#xA;final fullName = computed(() =&amp;gt; name.value + &#34; &#34; + surname.value);&#xA;&#xA;// Logs: &#34;Jane Doe&#34;&#xA;effect(() =&amp;gt; print(fullName.value));&#xA;&#xA;// Combines both signal writes into one update. Once the callback&#xA;// returns the `effect` will trigger and we&#39;ll log &#34;Foo Bar&#34;&#xA;batch(() {&#xA;&#x9;name.value = &#34;Foo&#34;;&#xA;&#x9;surname.value = &#34;Bar&#34;;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you access a signal that you wrote to earlier inside the callback, or access a computed signal that was invalidated by another signal, we&#39;ll only update the necessary dependencies to get the current value for the signal you read from. All other invalidated signals will update at the end of the callback function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;final counter = signal(0);&#xA;final _double = computed(() =&amp;gt; counter.value * 2);&#xA;final _triple = computed(() =&amp;gt; counter.value * 3);&#xA;&#xA;effect(() =&amp;gt; print(_double.value, _triple.value));&#xA;&#xA;batch(() {&#xA;&#x9;counter.value = 1;&#xA;&#x9;// Logs: 2, despite being inside batch, but `triple`&#xA;&#x9;// will only update once the callback is complete&#xA;&#x9;print(_double.value);&#xA;});&#xA;// Now we reached the end of the batch and call the effect&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Batches can be nested and updates will be flushed when the outermost batch call completes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:signals/signals.dart&#39;;&#xA;&#xA;final counter = signal(0);&#xA;effect(() =&amp;gt; print(counter.value));&#xA;&#xA;batch(() {&#xA;&#x9;batch(() {&#xA;&#x9;&#x9;// Signal is invalidated, but update is not flushed because&#xA;&#x9;&#x9;// we&#39;re still inside another batch&#xA;&#x9;&#x9;counter.value = 1;&#xA;&#x9;});&#xA;&#xA;&#x9;// Still not updated...&#xA;});&#xA;// Now the callback completed and we&#39;ll trigger the effect.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>