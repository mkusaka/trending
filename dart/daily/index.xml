<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dart Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-02T01:39:13Z</updated>
  <subtitle>Daily Trending of Dart in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>liangxianzhe/creator</title>
    <updated>2022-08-02T01:39:13Z</updated>
    <id>tag:github.com,2022-08-02:/liangxianzhe/creator</id>
    <link href="https://github.com/liangxianzhe/creator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A state management library that enables concise, fluid, readable and testable business logic code.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img height=&#34;80&#34; src=&#34;https://github.com/terryl1900/creator/raw/master/resource/logo.png?raw=true&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://pub.dev/packages/creator&#34;&gt;&lt;img src=&#34;https://img.shields.io/pub/v/creator.svg?sanitize=true&#34; alt=&#34;Pub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/terryl1900/creator/actions&#34;&gt;&lt;img src=&#34;https://github.com/terryl1900/creator/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/terryl1900/creator&#34;&gt; &lt;img src=&#34;https://codecov.io/gh/terryl1900/creator/branch/master/graph/badge.svg?token=C9L8AALWP4&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Creator is a state management library that enables &lt;strong&gt;concise, fluid, readable, and testable&lt;/strong&gt; business logic code.&lt;/p&gt; &#xA;&lt;p&gt;Read and update state with compile time safety:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Creator creates a stream of data.&#xA;final counter = Creator.value(0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Widget build(BuildContext context) {&#xA;  return Column(&#xA;    children: [&#xA;      // Watcher will rebuild whenever counter changes.&#xA;      Watcher((context, ref, _) =&amp;gt; Text(&#39;${ref.watch(counter)}&#39;)),&#xA;      TextButton(&#xA;        // Update state is easy.&#xA;        onPressed: () =&amp;gt; context.ref.update&amp;lt;int&amp;gt;(counter, (count) =&amp;gt; count + 1),&#xA;        child: const Text(&#39;+1&#39;),&#xA;      ),&#xA;    ],&#xA;  );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Write clean and testable business logic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// repo.dart&#xA;&#xA;// Pretend calling a backend service to get fahrenheit temperature.&#xA;Future&amp;lt;int&amp;gt; getFahrenheit(String city) async {&#xA;  await Future.delayed(const Duration(milliseconds: 100));&#xA;  return 60 + city.hashCode % 20;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// logic.dart&#xA;&#xA;// Simple creators bind to UI.&#xA;final cityCreator = Creator.value(&#39;London&#39;);&#xA;final unitCreator = Creator.value(&#39;Fahrenheit&#39;);&#xA;&#xA;// Write fluid code with methods like map, where, etc.&#xA;final fahrenheitCreator = cityCreator.asyncMap(getFahrenheit);&#xA;&#xA;// Combine creators for business logic. &#xA;final temperatureCreator = Emitter&amp;lt;String&amp;gt;((ref, emit) async {&#xA;  final f = await ref.watch(fahrenheitCreator);&#xA;  final unit = ref.watch(unitCreator);&#xA;  emit(unit == &#39;Fahrenheit&#39; ? &#39;$f F&#39; : &#39;${f2c(f)} C&#39;);&#xA;});&#xA;&#xA;// Fahrenheit to celsius converter.&#xA;int f2c(int f) =&amp;gt; ((f - 32) * 5 / 9).round();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// main.dart&#xA;&#xA;Widget build(BuildContext context) {&#xA;  return Watcher((context, ref, _) =&amp;gt; &#xA;      Text(ref.watch(temperatureCreator.asyncData).data ?? &#39;loading&#39;));&#xA;}&#xA;... context.ref.set(cityCreator, &#39;Pairs&#39;);  // triggers backend call&#xA;... context.ref.set(unitCreator, &#39;Celsius&#39;);  // doesn&#39;t trigger backend call&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Getting started:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dart pub add creator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Table of content:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#why-creator&#34;&gt;Why Creator?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#concept&#34;&gt;Concept&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#creator&#34;&gt;Creator&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#emitter&#34;&gt;Emitter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#creatorgraph&#34;&gt;CreatorGraph&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#watcher&#34;&gt;Watcher&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#listen-to-change&#34;&gt;Listen to change&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#name&#34;&gt;Name&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#keep-alive&#34;&gt;Keep alive&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#creator-group&#34;&gt;Creator group&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#extension-method&#34;&gt;Extension method&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#creator-equality&#34;&gt;Creator equality&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#service-locator&#34;&gt;Service locator&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#error-handling&#34;&gt;Error handling&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#testing&#34;&gt;Testing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#example&#34;&gt;Example&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#counter&#34;&gt;Counter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#decremental-counter&#34;&gt;Decremental counter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#weather&#34;&gt;Weather&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#news&#34;&gt;News&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#best-practice&#34;&gt;Best practice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#read-source-code&#34;&gt;Read source code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#faq&#34;&gt;FAQ&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#is-it-production-ready&#34;&gt;Is it production ready?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#is-it-bad-to-define-creator-as-global-variable&#34;&gt;Is it bad to define creator as global variable?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#how-to-watch-a-property-while-still-accessing-the-whole-object&#34;&gt;How to watch a property while still accessing the whole object?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#how-does-creators-life-cycle-work&#34;&gt;How does creator&#39;s life cycle work?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#whats-the-difference-between-contextref-vs-ref-in-creatorref--&#34;&gt;What&#39;s the difference between &lt;code&gt;context.ref&lt;/code&gt; vs &lt;code&gt;ref&lt;/code&gt; in &lt;code&gt;Creator((ref) =&amp;gt; ...)&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#whats-the-difference-between-creatorfuturet-vs-emittert&#34;&gt;What&#39;s the difference between &lt;code&gt;Creator&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; vs &lt;code&gt;Emitter&amp;lt;T&amp;gt;&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#what-do-i-need-to-know-if-im-a-riverpod-user&#34;&gt;What do I need to know if I&#39;m a riverpod user?&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liangxianzhe/creator/master/#thats-it&#34;&gt;That&#39;s it&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Why Creator?&lt;/h1&gt; &#xA;&lt;p&gt;When we built our Flutter app, we started with &lt;a href=&#34;https://github.com/felangel/bloc&#34;&gt;flutter_bloc&lt;/a&gt;. Later we switched to &lt;a href=&#34;https://github.com/rrousselGit/riverpod&#34;&gt;riverpod&lt;/a&gt;. However, we encountered several issues related to its async providers and realized we wanted a different mechanism.&lt;/p&gt; &#xA;&lt;p&gt;So we built Creator. It is heavily inspired by &lt;code&gt;riverpod&lt;/code&gt;, but with a simpler data model, better async support, and a much simpler implementation.&lt;/p&gt; &#xA;&lt;p&gt;The benefit of using Creator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enables concise, fluid, readable, and testable business logic. Sync or async.&lt;/li&gt; &#xA; &lt;li&gt;No need to worry when to &#34;provide&#34; creators.&lt;/li&gt; &#xA; &lt;li&gt;Concept is extremely simple and easy to learn.&lt;/li&gt; &#xA; &lt;li&gt;No magic. Build this library yourself with &lt;a href=&#34;https://medium.com/@terryl1900/create-a-flutter-state-management-library-with-100-lines-of-code-e80bd865f4bd&#34;&gt;100 lines of code&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Concept&lt;/h1&gt; &#xA;&lt;p&gt;Creator&#39;s concept is extremely simple. There are only two types of creators:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Creator&lt;/code&gt; which creates a stream of &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Emitter&lt;/code&gt; which creates a stream of &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here stream is in its logical term, not the Stream class.&lt;/p&gt; &#xA;&lt;p&gt;Both &lt;code&gt;Creator&lt;/code&gt; and &lt;code&gt;Emitter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Can depend on other creators, and update its state when others&#39; state changes.&lt;/li&gt; &#xA; &lt;li&gt;Are loaded lazily and disposed automatically.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Dependencies form a graph, for example, this is the graph for the weather example above:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/terryl1900/creator/raw/master/resource/weather.png?raw=true&#34; alt=&#34;weather&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The library simply maintains the graph with an adjacency list and propagates state changes along the edges.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;Creator&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Creator&lt;/code&gt; takes a function you write to create a state. The function takes a &lt;code&gt;Ref&lt;/code&gt;, which provides API to interact with the internal graph.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final number = Creator.value(42);  // Same as Creator((ref) =&amp;gt; 42)&#xA;final double = Creator((ref) =&amp;gt; ref.watch(number) * 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calling watch adds an edge &lt;code&gt;number&lt;/code&gt; -&amp;gt; &lt;code&gt;double&lt;/code&gt; to the graph, so &lt;code&gt;double&lt;/code&gt;&#39;s create function will rerun whenever &lt;code&gt;number&lt;/code&gt;&#39;s state changes.&lt;/p&gt; &#xA;&lt;p&gt;The nice part is that creator comes with methods like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc. They are similar to those methods in Iterable or Stream. So &lt;code&gt;double&lt;/code&gt; can simply be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final double = number.map((n) =&amp;gt; n * 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also &lt;code&gt;read&lt;/code&gt; a creator when &lt;code&gt;watch&lt;/code&gt; doesn&#39;t make sense, for example, inside a touch event handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;TextButton(&#xA;  onPressed: () =&amp;gt; print(context.ref.read(number)),&#xA;  child: const Text(&#39;Print&#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To update the creator&#39;s state, use either &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;... ref.set(number, 42);  // No-op if value is the same&#xA;... ref.update&amp;lt;int&amp;gt;(number, (n) =&amp;gt; n + 10);  // Same as read then set&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note creator determines state change using &lt;code&gt;T.==&lt;/code&gt;, so it should work with immutable data.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If &lt;code&gt;T&lt;/code&gt; is a class, use const constructor and override &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;. Or use package like &lt;code&gt;equatable&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If &lt;code&gt;T&lt;/code&gt; is a list, create a new list rather than update the existing one.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Creator&#39;s dependency can be dynamic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final C = Creator((ref) {&#xA;  final value = ref.watch(A);&#xA;  return value &amp;gt;= 0 ? value : ref.watch(B);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, &lt;code&gt;A&lt;/code&gt; -&amp;gt; &lt;code&gt;C&lt;/code&gt; always exists, &lt;code&gt;B&lt;/code&gt; -&amp;gt; &lt;code&gt;C&lt;/code&gt; may or may not exist. The library will update the graph properly as dependency changes.&lt;/p&gt; &#xA;&lt;h2&gt;Emitter&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Emitter&lt;/code&gt; works very similar to &lt;code&gt;Creator&lt;/code&gt;, but it creates &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. The main difference is &lt;code&gt;Creator&lt;/code&gt; has valid data to begin with, while &lt;code&gt;Emitter&lt;/code&gt; might need to wait for some async work before it yields the first data.&lt;/p&gt; &#xA;&lt;p&gt;In practice, &lt;code&gt;Emitter&lt;/code&gt; is very useful to deal with data from backend services, which is async by nature.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final stockCreator = Creator.value(&#39;TSLA&#39;);&#xA;final priceCreator = Emitter&amp;lt;int&amp;gt;((ref, emit) async {&#xA;  final stock = ref.watch(stockCreator);&#xA;  final price = await fetchStockPrice(stock);&#xA;  emit(price);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Emitter&lt;/code&gt; takes a &lt;code&gt;FutureOr&amp;lt;void&amp;gt; Function(Ref ref, void Function(T) emit)&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; allows getting data from the graph, and &lt;code&gt;emit&lt;/code&gt; allows pushing data back to the graph. You can &lt;code&gt;emit&lt;/code&gt; multiple times.&lt;/p&gt; &#xA;&lt;p&gt;Existing &lt;code&gt;Stream&lt;/code&gt; can be converted to Emitter easily with &lt;code&gt;Emitter.stream&lt;/code&gt;. It works both sync or async:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final authCreator = Emitter.stream(&#xA;    (ref) =&amp;gt; FirebaseAuth.instance.authStateChanges());&#xA;&#xA;final userCreator = Emitter.stream((ref) async {&#xA;  final authId = await ref.watch(&#xA;      authCreator.where((auth) =&amp;gt; auth != null).map((auth) =&amp;gt; auth!.uid));&#xA;  return FirebaseFirestore.instance.collection(&#39;users&#39;).doc(authId).snapshots();&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example also shows the extension method &lt;code&gt;where&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;. With them, userCreator will only recreate when auth id changes, and ignore changes on other auth properties.&lt;/p&gt; &#xA;&lt;p&gt;In some sense, you can think &lt;code&gt;Emitter&lt;/code&gt; as a different version of &lt;code&gt;Stream&lt;/code&gt;, which makes combining streams super easy.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Emitter&lt;/code&gt; generates &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;, so it can be hooked to Flutter&#39;s &lt;code&gt;FutureBuilder&lt;/code&gt; for UI. Or you can use &lt;code&gt;Emitter.asyncData&lt;/code&gt;, which is a creator of &lt;code&gt;AsyncData&amp;lt;T&amp;gt;&lt;/code&gt;. AsyncData is similar to AsyncSnapshot for future/stream:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;enum AsyncDataStatus { waiting, active }&#xA;&#xA;class AsyncData&amp;lt;T&amp;gt; {&#xA;  const AsyncData._(this.status, this.data);&#xA;  const AsyncData.waiting() : this._(AsyncDataStatus.waiting, null);&#xA;  const AsyncData.withData(T data) : this._(AsyncDataStatus.active, data);&#xA;&#xA;  final AsyncDataStatus status;&#xA;  final T? data;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With it building widget with &lt;code&gt;Emitter&lt;/code&gt; is easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Watcher((context, ref, _) {&#xA;  final user = ref.watch(userCreator.asyncData).data;&#xA;  return user != null ? Text(user!.name) : const CircularProgressIndicator();&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;CreatorGraph&lt;/h2&gt; &#xA;&lt;p&gt;To make creators work, wrap your app in a &lt;code&gt;CreatorGraph&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;void main() {&#xA;  runApp(CreatorGraph(child: const MyApp()));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CreatorGraph is a InheritedWidget. It holds a &lt;code&gt;Ref&lt;/code&gt; object (which holds the graph) and exposes it through &lt;code&gt;context.ref&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;CreatorGraph uses &lt;code&gt;DefaultCreatorObserver&lt;/code&gt; by default, which prints logs when creator state changes. It can be replaced with your own log collection observer.&lt;/p&gt; &#xA;&lt;h2&gt;Watcher&lt;/h2&gt; &#xA;&lt;p&gt;Watcher is a simple StatefulWidget which holds a &lt;code&gt;Creator&amp;lt;Widget&amp;gt;&lt;/code&gt; internally and calls &lt;code&gt;setState&lt;/code&gt; when its dependency changes.&lt;/p&gt; &#xA;&lt;p&gt;It takes builder function &lt;code&gt;Widget Function(BuildContext context, Ref ref, Widget child)&lt;/code&gt;. You can use &lt;code&gt;ref&lt;/code&gt; to watch creators to populate the widget. &lt;code&gt;child&lt;/code&gt; can be used optionally if the subtree should not rebuild when dependency changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Watcher((context, ref, child) {&#xA;  final color = ref.watch(userFavoriteColor);&#xA;  return Container(color: color, child: child);&#xA;}, child: ExpensiveAnimation());  // this child is passed into the builder above&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Listen to change&lt;/h2&gt; &#xA;&lt;p&gt;Watching a creator will get its latest state. What if you also want previous state? Simply call &lt;code&gt;watch(someCreator.change)&lt;/code&gt; to get a &lt;code&gt;Change&amp;lt;T&amp;gt;&lt;/code&gt;, which is an object with two properties &lt;code&gt;T? before&lt;/code&gt; and &lt;code&gt;T after&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For your convenience, &lt;code&gt;Watcher&lt;/code&gt; can also take a listener. It can be used to achieve side effects or run background tasks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// If builder is null, child widget is directly returned. You can set both&#xA;// builder and listener. They are independent of each other.&#xA;Watcher(null, listener: (ref) {&#xA;  final change = ref.watch(number.change);&#xA;  print(&#39;Number changed from ${change.before} to ${change.after}&#39;);&#xA;}, child: SomeChildWidget());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Name&lt;/h2&gt; &#xA;&lt;p&gt;Creators can have names for logging purpose. Setting name is recommended for any serious app.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final numberCreator = Creator.value(0, name: &#39;number&#39;);&#xA;final doubleCreator = numberCreator.map((n) =&amp;gt; n * 2, name: &#39;double&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Keep alive&lt;/h2&gt; &#xA;&lt;p&gt;By default, creators are disposed when losing all its watchers. This can be overridden with &lt;code&gt;keepAlive&lt;/code&gt; parameter. It is useful if the creator maintains a connection to backend (e.g. listen to firestore realtime updates).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final userCreator = Emitter.stream((ref) {&#xA;  return FirebaseFirestore.instance.collection(&#39;users&#39;).doc(&#39;123&#39;).snapshots();&#xA;}, keepAlive: true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Creator group&lt;/h2&gt; &#xA;&lt;p&gt;Creator group can generate creators with external parameter. For example, in Instagram app, there might be multiple profile pages on navigation stack, thus we need multiple instance of &lt;code&gt;profileCreator&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Instagram has four tabs: instagram, reels, video, tagged&#xA;final tabCreator = Creator.arg1&amp;lt;Tab, String&amp;gt;((ref, userId) =&amp;gt; &#39;instagram&#39;);&#xA;final profileCreator = Emitter.arg1&amp;lt;Profile, String&amp;gt;((ref, userId, emit) async {&#xA;  final tab = ref.watch(tabCreator(userId));&#xA;  emit(await fetchProfileData(userId, tab));  // Call backend&#xA;});&#xA;&#xA;// Now switching tab in user A&#39;s profile page will not affect user B.&#xA;... ref.watch(profileCreator(&#39;userA&#39;));&#xA;... ref.set(tabCreator(&#39;userA&#39;), &#39;reels&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Creators comes with factory methods &lt;code&gt;arg1&lt;/code&gt; &lt;code&gt;arg2&lt;/code&gt; &lt;code&gt;arg3&lt;/code&gt; which take in 1-3 arguments.&lt;/p&gt; &#xA;&lt;h2&gt;Extension method&lt;/h2&gt; &#xA;&lt;p&gt;Our favorite part of the library is that you can use methods like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt; on creators (full list &lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator_core/lib/src/extension.dart&#34;&gt;here&lt;/a&gt;). They are similar to those methods in Iterable or Stream.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final numberCreator = Creator.value(0);&#xA;final oddCreator = numberCreator.where((n) =&amp;gt; n.isOdd);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;Creator&lt;/code&gt; needs to have valid state at the beginning, while &lt;code&gt;where((n) =&amp;gt; n.isOdd)&lt;/code&gt; cannot guarantee that. This is why &lt;code&gt;where&lt;/code&gt; returns an &lt;code&gt;Emitter&lt;/code&gt; rather than a &lt;code&gt;Creator&lt;/code&gt;. Here is the implementation of the &lt;code&gt;where&lt;/code&gt; method. It is quite simple and you can write similar extensions if you want:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;extension CreatorExtension&amp;lt;T&amp;gt; on Creator&amp;lt;T&amp;gt; {&#xA;  Emitter&amp;lt;T&amp;gt; where(bool Function(T) test) {&#xA;    return Emitter((ref, emit) {&#xA;      final value = ref.watch(this);&#xA;      if (test(value)) {&#xA;        emit(value);&#xA;      }&#xA;    });&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use extension methods in two ways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Define oddCreator explicitly as a stable variable.&#xA;final oddCreator = numberCreator.where((n) =&amp;gt; n.isOdd);&#xA;final someCreator = Creator((ref) {&#xA;  return &#39;this is odd: ${ref.watch(oddCreator)}&#39;);&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Create &#34;oddCreator&#34; anonymously on the fly.&#xA;final someCreator = Creator((ref) {&#xA;  return &#39;this is odd: ${ref.watch(numberCreator.where((n) =&amp;gt; n.isOdd))}&#39;);&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you use the &#34;on the fly&#34; approach, please read next section about creator equality.&lt;/p&gt; &#xA;&lt;h2&gt;Creator equality&lt;/h2&gt; &#xA;&lt;p&gt;The graph checks whether two creators are equal using &lt;code&gt;==&lt;/code&gt;. This means creator should be defined in global variables, static variables or any other ways which can keep variable stable during its life cycle.&lt;/p&gt; &#xA;&lt;p&gt;What happens if creators are defined in local variables on the fly?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final text = Creator((ref) {&#xA;  final double = Creator((ref) =&amp;gt; ref.watch(number) * 2);&#xA;  return &#39;double: ${ref.watch(double)}&#39;;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here &lt;code&gt;double&lt;/code&gt; is a local variable, it has different instances whenever &lt;code&gt;text&lt;/code&gt; is recreated. The internal graph could change from &lt;code&gt;number -&amp;gt; double_A -&amp;gt; text&lt;/code&gt; to &lt;code&gt;number -&amp;gt; double_B -&amp;gt; text&lt;/code&gt; as the number changes. &lt;code&gt;text&lt;/code&gt; still generates correct data, but there is an extra cost to swap the node in the graph. Because the change is localized to only one node, the cost can be ignored as long as the create function is simple.&lt;/p&gt; &#xA;&lt;p&gt;If needed, an optional &lt;code&gt;List&amp;lt;Object?&amp;gt; args&lt;/code&gt; can be set to ask the library to find an existing creator with the same &lt;code&gt;args&lt;/code&gt; in the graph. Now when number changes, the graph won&#39;t change:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final text = Creator((ref) {&#xA;  // args need to be globally unique. [&#39;text&#39;, &#39;double&#39;] is likely unique.&#xA;  final double = Creator((ref) =&amp;gt; ref.watch(number) * 2, args: [&#39;text&#39;, &#39;double&#39;]);&#xA;  return &#39;double: ${ref.watch(double)}&#39;;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same applies to using extension methods on the fly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final text = Creator((ref) {&#xA;  return &#39;double: ${ref.watch(number.map((n) =&amp;gt; n * 2, args: [&#39;text&#39;, &#39;double&#39;]))}&#39;;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Internally, args powers these features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Creator group. &lt;code&gt;profileCreator(&#39;userA&#39;)&lt;/code&gt; is a creator with args &lt;code&gt;[profileCreator, &#39;userA&#39;]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Async data. &lt;code&gt;userCreator.asyncData&lt;/code&gt; is a creator with args &lt;code&gt;[userCreator, &#39;asyncData&#39;]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Change. &lt;code&gt;number.change&lt;/code&gt; is a creator with args &lt;code&gt;[number, &#39;change&#39;]&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Service locator&lt;/h2&gt; &#xA;&lt;p&gt;State management libraries are commonly used as service locators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class UserRepo {&#xA;  void changeName(User user, String name) {...}&#xA;}&#xA;final userRepo = Creator.value(UserRepo(), keepAlive: true);&#xA;&#xA;... context.ref.read(userRepo).changeName(user, name);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If needed, &lt;code&gt;ref&lt;/code&gt; can be passed to UserRepo &lt;code&gt;Creator((ref) =&amp;gt; UserRepo(ref))&lt;/code&gt;. This allows UserRepo &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; other creators. Do not &lt;code&gt;watch&lt;/code&gt; though, because it might recreate UserRepo.&lt;/p&gt; &#xA;&lt;h2&gt;Error handling&lt;/h2&gt; &#xA;&lt;p&gt;The library will:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For &lt;code&gt;Creator&lt;/code&gt;, store exception happened during create and throw it when watch.&lt;/li&gt; &#xA; &lt;li&gt;For &lt;code&gt;Emitter&lt;/code&gt;, naturally use Future.error, so error is returned when watch.&lt;/li&gt; &#xA; &lt;li&gt;In either case, error is treated as a state change.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This means that errors can be handled in the most natural way, at the place makes the most sense. Use the weather app above as an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// Here we don&#39;t handle error, meaning it returns Future.error if network error&#xA;// occurs. Alternately we can catch network error and return some default value,&#xA;// add retry logic, convert network error to our own error class, etc.&#xA;final fahrenheitCreator = cityCreator.mapAsync(getFahrenheit);&#xA;&#xA;// Here we choose to handle the error in widget.&#xA;Widget build(BuildContext context) {&#xA;  return Watcher((context, ref, _) {&#xA;    try {&#xA;      return Text(ref.watch(temperatureCreator.asyncData).data ?? &#39;loading&#39;);&#xA;    } catch (error) {&#xA;      return TextButton(&#39;Something went wrong, click to retry&#39;, &#xA;          onPressed: () =&amp;gt; ref.recreate(fahrenheitCreator));&#xA;    }&#xA;  };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Testing creator is quite easy by combining &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;. Use the weather app above as an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;// No setUp, no tearDown, no mocks. Writing tests becomes fun.&#xA;&#xA;test(&#39;temperature creator change unit&#39;, () async {&#xA;  final ref = Ref();&#xA;  expect(await ref.watch(temperatureCreator), &#34;60 F&#34;);&#xA;  ref.set(unitCreator, &#39;Celsius&#39;);&#xA;  await Future.delayed(const Duration()); // allow emitter to propagate&#xA;  expect(await ref.watch(temperatureCreator), &#34;16 C&#34;);&#xA;});&#xA;&#xA;test(&#39;temperature creator change fahrenheit value&#39;, () async {&#xA;  final ref = Ref();&#xA;  expect(await ref.watch(temperatureCreator), &#34;60 F&#34;);&#xA;  ref.set(fahrenheitCreator, Future.value(90));&#xA;  await Future.delayed(const Duration()); // allow emitter to propagate&#xA;  expect(await ref.watch(temperatureCreator), &#34;90 F&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Example&lt;/h1&gt; &#xA;&lt;p&gt;Source code &lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator/example/lib&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Counter&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dartpad.dev/?id=911a1919b2b7125cc1f8c69e3c07caf9&#34;&gt;DartPad&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A counter app shows basic Creator/Watcher usage.&lt;/p&gt; &#xA;&lt;h2&gt;Decremental counter&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dartpad.dev/?id=1a4c338fdf8ef7c4af8f80ddff88f4ec&#34;&gt;DartPad&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A counter app shows how to hide state and expose state mutate APIs.&lt;/p&gt; &#xA;&lt;h2&gt;Weather&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dartpad.dev/?id=344ee052cab2700bd084a78ac6362897&#34;&gt;DartPad&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simple weather app shows splitting backend/logic/ui code and writing logic with Creator and Emitter.&lt;/p&gt; &#xA;&lt;h2&gt;News&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dartpad.dev/?id=a6d82a6bb955fa4f42ff50b6c6d90d34&#34;&gt;DartPad&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simple news app with infinite list of news. It shows combining creators for loading indicator and fetching data with pagination.&lt;/p&gt; &#xA;&lt;h2&gt;Graph&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dartpad.dev/?id=77a60e33349a20c6623d163146378c5d&#34;&gt;DartPad&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simple app shows how the creator library builds the internal graph dynamically.&lt;/p&gt; &#xA;&lt;h1&gt;Best practice&lt;/h1&gt; &#xA;&lt;p&gt;Creator is quite flexible and doesn&#39;t force a particular style. Best practices also depend on the project and personal preference. Here we just list a few things we follow:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Split code into repo files (backend service call), logic files (creator), and UI files (widget).&lt;/li&gt; &#xA; &lt;li&gt;Define creator in global variables.&lt;/li&gt; &#xA; &lt;li&gt;Keep creator small for testability. Put derived state in derived creators (using &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, etc).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Read source code&lt;/h1&gt; &#xA;&lt;p&gt;Creator&#39;s implementation is surprisingly simple. In fact, the &lt;strong&gt;core logic&lt;/strong&gt; is less than 500 lines of code.&lt;/p&gt; &#xA;&lt;p&gt;You can optionally read this &lt;a href=&#34;https://medium.com/@terryl1900/create-a-flutter-state-management-library-with-100-lines-of-code-e80bd865f4bd&#34;&gt;article&lt;/a&gt; first, which describes how we built the first version with 100 lines of code.&lt;/p&gt; &#xA;&lt;p&gt;Read creator_core library in this order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator_core/lib/src/graph.dart&#34;&gt;graph.dart&lt;/a&gt;&lt;/strong&gt;: a simple implementation of a bi-directed graph using adjacency list. It can automatically delete nodes which become zero out-degree.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator_core/lib/src/creator.dart&#34;&gt;creator.dart&lt;/a&gt;&lt;/strong&gt;: the CreatorBase class and its two sub classes, Creator and Emitter. Their main job is to recreate state when asked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator_core/lib/src/ref.dart&#34;&gt;ref.dart&lt;/a&gt;&lt;/strong&gt;: manages the graph and provides &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; methods to user.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator_core/lib/src/extension.dart&#34;&gt;extension.dart&lt;/a&gt;: implement extension methods &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Read creator library in this order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator/lib/src/creator_graph.dart&#34;&gt;creator_graph.dart&lt;/a&gt;: A simple InheritedWidget which expose &lt;code&gt;Ref&lt;/code&gt; through context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/packages/creator/lib/src/watcher.dart&#34;&gt;watcher.dart&lt;/a&gt;: A stateful widget which holds a &lt;code&gt;Creator&amp;lt;Widget&amp;gt;&lt;/code&gt; internally.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;h2&gt;Is it production ready?&lt;/h2&gt; &#xA;&lt;p&gt;Well, we have been using it in production for our own app (&lt;a href=&#34;https://chooly.app&#34;&gt;Chooly&lt;/a&gt;). However, since it is new to the community, the API might change as we take feedback. So the suggestion for now: read the source code and make your own call.&lt;/p&gt; &#xA;&lt;h2&gt;Is it bad to define creator as global variable?&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s not. Creator itself doesn&#39;t hold states. States are held in Ref (in CreatorGraph). Defining a creator is more like defining a function or a class.&lt;/p&gt; &#xA;&lt;h2&gt;How to watch a property while still accessing the whole object?&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;final someCreator = Creator((ref) {&#xA;  ref.watch(userCreator.map((user) =&amp;gt; user.email));&#xA;  final user = ref.read(userCreator);&#xA;  return &#39;${user.name}\&#39;s email is changed&#39;;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How does creator&#39;s life cycle work?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is added to the graph when firstly being watched.&lt;/li&gt; &#xA; &lt;li&gt;It can be removed from the graph manually by &lt;code&gt;Ref.dispose&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If it has watchers, it is automatically removed from the graph when losing all its watchers, unless keepAlive property is set.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What&#39;s the difference between &lt;code&gt;context.ref&lt;/code&gt; vs &lt;code&gt;ref&lt;/code&gt; in &lt;code&gt;Creator((ref) =&amp;gt; ...)&lt;/code&gt;?&lt;/h2&gt; &#xA;&lt;p&gt;They both point to the same internal graph, the only difference is that the first ref&#39;s &lt;code&gt;_owner&lt;/code&gt; field is null, while the second ref&#39;s &lt;code&gt;_owner&lt;/code&gt; field is the creator itself. This means:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is the same to &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; any creators with either ref. The operation is passed to the internal graph.&lt;/li&gt; &#xA; &lt;li&gt;If &lt;code&gt;ref._owner&lt;/code&gt; is null, &lt;code&gt;ref.watch(foo)&lt;/code&gt; will simply add &lt;code&gt;foo&lt;/code&gt; to the graph.&lt;/li&gt; &#xA; &lt;li&gt;If &lt;code&gt;ref._owner&lt;/code&gt; is not null, &lt;code&gt;ref.watch(foo)&lt;/code&gt; will also add an edge &lt;code&gt;foo -&amp;gt; ref._owner&lt;/code&gt; to the graph.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What&#39;s the difference between &lt;code&gt;Creator&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; vs &lt;code&gt;Emitter&amp;lt;T&amp;gt;&lt;/code&gt;?&lt;/h2&gt; &#xA;&lt;p&gt;They are both extended from &lt;code&gt;CreatorBase&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whose state is &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;. However, there are two important differences, which make &lt;code&gt;Emitter&amp;lt;T&amp;gt;&lt;/code&gt; better for async tasks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Emitter&amp;lt;T&amp;gt;&lt;/code&gt; stores &lt;code&gt;T&lt;/code&gt; in addition to &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;, so that we can log change of &lt;code&gt;T&lt;/code&gt; or populate &lt;code&gt;AsyncData&amp;lt;T&amp;gt;&lt;/code&gt; properly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Emitter&amp;lt;T&amp;gt;&lt;/code&gt; notify its watcher when &lt;code&gt;T&lt;/code&gt; is emitted, so its watchers can start their work immediately. &lt;code&gt;Creator&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; notify its watchers when the future is started, so its watchers are still blocked until the future is finished.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What do I need to know if I&#39;m a riverpod user?&lt;/h2&gt; &#xA;&lt;p&gt;Check &lt;a href=&#34;https://github.com/terryl1900/creator/raw/master/doc/faq_for_riverpod_user.md&#34;&gt;FAQ for riverpod user&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;That&#39;s it&lt;/h1&gt; &#xA;&lt;p&gt;Hope you enjoyed reading this doc and will enjoy using Creator. Feedback and contribution are welcome!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Let us know your experience using Creator (github issue or &lt;a href=&#34;mailto:terry@chooly.app&#34;&gt;terry@chooly.app&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Upvote this &lt;a href=&#34;https://github.com/dart-lang/dart-pad/issues/2288&#34;&gt;issue&lt;/a&gt; so we can build DartPad example easier.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>