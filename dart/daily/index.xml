<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Dart Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-11T01:34:08Z</updated>
  <subtitle>Daily Trending of Dart in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mjansen4857/pathplanner</title>
    <updated>2023-01-11T01:34:08Z</updated>
    <id>tag:github.com,2023-01-11:/mjansen4857/pathplanner</id>
    <link href="https://github.com/mjansen4857/pathplanner" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple yet powerful motion profile generator for FRC robots&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/mjansen4857/pathplanner/actions/workflows/pathplanner-ci.yaml&#34;&gt;&lt;img src=&#34;https://github.com/mjansen4857/pathplanner/actions/workflows/pathplanner-ci.yaml/badge.svg?sanitize=true&#34; alt=&#34;PathPlanner&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mjansen4857/pathplanner/actions/workflows/pplib-ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/mjansen4857/pathplanner/actions/workflows/pplib-ci.yml/badge.svg?sanitize=true&#34; alt=&#34;PathPlannerLib&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;PathPlanner&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/en-us/p/frc-pathplanner/9nqbkb5dw909?cid=storebadge&amp;amp;ocid=badge&amp;amp;rtc=1&amp;amp;activetab=pivot:overviewtab&#34;&gt;&lt;img src=&#34;https://mjansen4857.com/badges/windows.svg?sanitize=true&#34; height=&#34;50&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://apps.apple.com/us/app/frc-pathplanner/id1593046876&#34;&gt;&lt;img src=&#34;https://mjansen4857.com/badges/mac.svg?sanitize=true&#34; height=&#34;51&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Download from one of the above app stores to receive auto-updates. Manual installs can be found &lt;a href=&#34;https://github.com/mjansen4857/pathplanner/releases&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9343077/211618068-8b4b0edb-d5b2-4247-94ee-119742d4507a.png&#34; alt=&#34;PathPlanner&#34;&gt; PathPlanner is a motion profile generator for FRC robots created by team 3015. The main features of PathPlanner include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each path is made with BÃ©zier curves, allowing fine tuning of the exact path shape.&lt;/li&gt; &#xA; &lt;li&gt;Holonomic mode supports decoupling the robot&#39;s rotation from its direction of travel.&lt;/li&gt; &#xA; &lt;li&gt;Real-time path preview&lt;/li&gt; &#xA; &lt;li&gt;Allows placing &#34;event markers&#34; along the path which can be used to trigger other code while path following.&lt;/li&gt; &#xA; &lt;li&gt;Split a path into a &#34;path group&#34; to follow each part of a path seperately.&lt;/li&gt; &#xA; &lt;li&gt;Auto path saving and file management&lt;/li&gt; &#xA; &lt;li&gt;Robot-side vendor library for path generation and custom path following commands/controllers&lt;/li&gt; &#xA; &lt;li&gt;Full autonomous command generation with PathPlannerLib AutoBuilder&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage and Documentation&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://github.com/mjansen4857/pathplanner/wiki&#34;&gt;Check the Wiki&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make sure you &lt;a href=&#34;https://github.com/mjansen4857/pathplanner/wiki/PathPlannerLib:-Installing&#34;&gt;install PathPlannerLib&lt;/a&gt; to generate your paths. Paths can be pre-generated as CSV or WPILib JSON files, but the vendor library is much easier to use and supports all of the features of the GUI.&lt;/p&gt; &#xA;&lt;h2&gt;How to build manually:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://flutter.dev/docs/get-started/install&#34;&gt;Install Flutter&lt;/a&gt; (this project currently uses v3.3.9)&lt;/li&gt; &#xA; &lt;li&gt;Open the project in a terminal and run the following command: &lt;code&gt;flutter build &amp;lt;PLATFORM&amp;gt;&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Valid platforms are: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;windows&lt;/li&gt; &#xA;     &lt;li&gt;macos&lt;/li&gt; &#xA;     &lt;li&gt;linux&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The built app will be located here: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Windows: &lt;code&gt;&amp;lt;PROJECT DIR&amp;gt;/build/windows/runner/Release&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;maxOS: &lt;code&gt;&amp;lt;PROJECT DIR&amp;gt;/build/macos/Build/Products/Release&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Linux: &lt;code&gt;&amp;lt;PROJECT DIR&amp;gt;/build/linux/x64/release/bundle&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;OR &lt;code&gt;flutter run&lt;/code&gt; to run in debug mode&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Zira-Games/state-machine-animation</title>
    <updated>2023-01-11T01:34:08Z</updated>
    <id>tag:github.com,2023-01-11:/Zira-Games/state-machine-animation</id>
    <link href="https://github.com/Zira-Games/state-machine-animation" rel="alternate"></link>
    <summary type="html">&lt;p&gt;State-machine driven animation controller and evaluation library based on streams.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;State-machine driven animation controller and evaluation library based on streams for flutter.&lt;/p&gt; &#xA;&lt;p&gt;It provides reactive and entity based animation definitions, which can be in variety of states, transitions, and all possible blended states in between, through keyframe evaluation &amp;amp; interpolation.&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;p&gt;State-machine animation exists to solve the problem of exponentially rising code complexity that quickly becomes impossible to handle when you&#39;re using dozens of separate animation controllers for a single element and trying to keep them in sync according to their relations.&lt;/p&gt; &#xA;&lt;p&gt;While the current best practice is to let dedicated animation runtimes like rive (flare) to take over when complexity reaches that level, you would lose among many flutter specific features, fine-grained access to how your animations should behave depending on your application state when that happens.&lt;/p&gt; &#xA;&lt;p&gt;The library aims to provide;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the simplest possible surface API that you can achieve almost most behaviours with readability, clarity and maintainability with the exact right mix of declarative and imperative programming approaches.&lt;/li&gt; &#xA; &lt;li&gt;the simplest possible implementation that can let its users easily understand its codebase, fork the repository, and adapt it based on their unique requirements.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Therefor, delay the need for animation runtimes until you need features like animation rigging and meshing that requires a dedicated user interfaces to implement, and limit their use to only those features.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Keyframe evaluation &amp;amp; interpolation,&lt;/li&gt; &#xA; &lt;li&gt;Duration and Curve evaluation that can be provided with default values and functional evaluation for variety of hierarchical levels of the animation definition,&lt;/li&gt; &#xA; &lt;li&gt;Animation model containers that handles multiple animations properties for a specific entity.&lt;/li&gt; &#xA; &lt;li&gt;Reactive approach to ensuring continuity that can handle transitions being layered overed each other, with concurrency options different transition reaction types to changing app state.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Right now, the surface-level API is written to work well with the stream based state management techniques like BLOC.&lt;/p&gt; &#xA;&lt;p&gt;The library works with &lt;code&gt;BehaviorSubject&lt;/code&gt; instances (streams that can have current values) to handle its state at all levels. So familiarity with the stream concept and their manipulation would be helpful.&lt;/p&gt; &#xA;&lt;p&gt;This said, everyone is encouraged to clone the repo and shift around some classes to use different patterns, such as using the more performant and synchronous &lt;code&gt;ValueNotifier&lt;/code&gt; instances flutter animation classes uses, or using a more declarative approach for state machine instances instead of object inheritance.&lt;/p&gt; &#xA;&lt;h5&gt;A basic state machine representation&lt;/h5&gt; &#xA;&lt;img alt=&#34;an example state machine configuration&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 1.png&#34;&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;It thinks in 3 different levels of streams.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An entity state stream which is the input for the state machine. Its value need to include all the information that the animation should react to.&lt;/li&gt; &#xA; &lt;li&gt;A State-machine output stream which represents the animation controller state.&lt;/li&gt; &#xA; &lt;li&gt;An animation property or an animation model stream which evaluates the controller state that your app can use to render the animating object.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A sample usage of all three is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;void main() {&#xA;&#xA;  // A simple extension of the TickerProvider, that gives implementers the responsibility of managing a ticker&#39;s disposal along with its creation. &#xA;  final AppTickerManager tickerManager = AppTickerManager();&#xA;  &#xA;  // The entity state stream of the object that should be animated. &#xA;  // In this case, the AppState can be in one of three Position values.&#xA;  final BehaviorSubject&amp;lt;AppState&amp;gt; stateSubject = BehaviorSubject&amp;lt;AppState&amp;gt;.seeded(AppState(Position.center));&#xA;&#xA;  // The State Machine Controller instance which tells the state-machine stream how to react to the changes in the entity state stream.&#xA;  // This class represents the meat and bones of our animation definition.&#xA;  final ExampleAFSM stateMachine = ExampleAFSM(stateSubject, tickerManager);&#xA;&#xA;  // The final animation stream that evaluates the state-machine controller stream. &#xA;  // In this case it&#39;s a single double property that we provide its value for the each keyframe of its state machine.&#xA;  final animation = DoubleAnimationProperty&amp;lt;AppState&amp;gt;(&#xA;    keyEvaluator: (key, sourceState) {&#xA;      if( key == &#34;LEFT&#34; ){&#xA;        return -100;&#xA;      } else if( key == &#34;CENTER&#34; ){&#xA;        return 0;&#xA;      } else if( key == &#34;RIGHT&#34; ){&#xA;        return 100;&#xA;      }&#xA;    }&#xA;  ).getAnimation(stateMachine.output);&#xA;&#xA;  // The stream subscription that we use to expose the values of the animation. &#xA;  animation.listen((animationProperty) { &#xA;    print(&#34;${animationProperty.time}: ${animationProperty.value}&#34;);&#xA;  });&#xA;&#xA;  // We change the the value of the input stream to center to right, so the state-machine can react and transition to some other state. &#xA;  stateSubject.add(AppState(Position.left));&#xA;  &#xA;}&#xA;&#xA;/**&#xA;  Source state implementation&#xA; */&#xA;enum Position {&#xA;  left,&#xA;  center,&#xA;  right;&#xA;}&#xA;&#xA;class AppState extends Equatable {&#xA;&#xA;  final Position position;&#xA;&#xA;  const AppState(this.position);&#xA;&#xA;  @override&#xA;  List&amp;lt;Object?&amp;gt; get props =&amp;gt; [position];&#xA;&#xA;}&#xA;&#xA;/**&#xA;  State machine definition.&#xA;  Implementing this abstract class means implementing the following 3 hook methods which gets called when the input state changes&#xA; */&#xA;&#xA;class ExampleSM extends AnimationStateMachine&amp;lt;AppState&amp;gt; {&#xA;&#xA;  ExampleAFSM(super.input, super.tickerManager);&#xA;&#xA;  // A readiness hook that returns bool. &#xA;  // If your source state has certain values that the state-machine shouldn&#39;t try to react to and evaluate, make sure to change the implementation accordingly from the following.&#xA;  @override&#xA;  bool isReady(state) =&amp;gt; true;&#xA;&#xA;  // The configuration of your state machine based on the source state. &#xA;  // It should provide the starting point for a state-machine that is ready, and the durations for how long it takes to transition from one state to another.&#xA;  @override&#xA;  AnimationStateMachineConfig&amp;lt;AppState&amp;gt; getConfig(state) =&amp;gt; const AnimationStateMachineConfig(&#xA;    nodes: [&#34;LEFT&#34;, &#34;CENTER&#34;, &#34;RIGHT&#34;],&#xA;    initialState: Idle(&#34;CENTER&#34;),&#xA;    defaultDuration: 1000&#xA;  );&#xA;&#xA;  // The the most important hook where you define how your state machine should react to changes in the source state.&#xA;  // You can jump or transition to any state, which can be nodes or specific points in a transition between two nodes.&#xA;  @override&#xA;  void reactToStateChanges(state, previous) {&#xA;    transitionTo(Idle(state.position.name.toUpperCase()));&#xA;  }&#xA;&#xA;}&#xA;&#xA;// A Basic ticker manager implementation. If you have a game loop, it should be probably the one to implement this interface.&#xA;class AppTickerManager implements TickerManager {&#xA;&#xA;  final List&amp;lt;Ticker&amp;gt; _tickers = &amp;lt;Ticker&amp;gt;[];&#xA;&#xA;  @override&#xA;  Ticker createTicker(TickerCallback onTick) {&#xA;    final ticker = Ticker(onTick);&#xA;    _tickers.add(ticker);&#xA;    return ticker;&#xA;  }&#xA;&#xA;  @override&#xA;  void disposeTicker(Ticker ticker){&#xA;    ticker.dispose();&#xA;    _tickers.remove(ticker);&#xA;  }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;AnimationStateMachine&lt;/code&gt; Usage&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;AnimationStateMachine&lt;/code&gt; is an abstract class that is used through extending it.&lt;/p&gt; &#xA;&lt;p&gt;It is responsible for the handling the behaviour of the state machine according to the source state.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The readiness check for the source state,&lt;/li&gt; &#xA; &lt;li&gt;the animation nodes,&lt;/li&gt; &#xA; &lt;li&gt;transition durations between the nodes,&lt;/li&gt; &#xA; &lt;li&gt;how the state machine should react to changing nodes,&lt;/li&gt; &#xA; &lt;li&gt;and optionally the default keyframe overrides within a transition,&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;should be configured through the relevant hooks through this instance. One notable exception is the curve of a transition, which is determined in the animation instance unlike the native flutter animation controllers.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;isReady&lt;/code&gt; hook:&lt;/h4&gt; &#xA;&lt;h4&gt;&lt;code&gt;getConfig&lt;/code&gt; hook:&lt;/h4&gt; &#xA;&lt;h4&gt;&lt;code&gt;reactToStateChanges&lt;/code&gt; hook:&lt;/h4&gt; &#xA;&lt;p&gt;[Explanation] Use cases are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Jump to an &lt;code&gt;Idle&lt;/code&gt; State&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  @override&#xA;  void reactToStateChanges(SampleSource state, SampleSource? previous) {&#xA;    jumpTo(const Idle(&#34;NODE_1&#34;));&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img alt=&#34;jump to representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 2a.png&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Default Transition to an Idle State&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  @override&#xA;  void reactToStateChanges(SampleSource state, SampleSource? previous) {&#xA;    transitionTo(const Idle(&#34;NODE_2&#34;));&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img alt=&#34;transition to Idle representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 2b.png&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Jump to a default &lt;code&gt;InTransition&lt;/code&gt; State&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  @override&#xA;  void reactToStateChanges(SampleSource state, SampleSource? previous) {&#xA;    jumpTo(InTransition.fromEdges(const Idle(&#34;NODE_1&#34;), const Idle(&#34;NODE_2&#34;), 0.5, playState: PlayState.paused));&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img alt=&#34;transition to InTransition paused representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 2c.png&#34;&gt; &#xA;&lt;img alt=&#34;transition to InTransition playing representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 2d.png&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Execute a named Transition (With Custom Keyframes) to an &lt;code&gt;Idle&lt;/code&gt; State&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  @override&#xA;  void reactToStateChanges(SampleSource state, SampleSource? previous) {&#xA;    execute(Transition.declared(&#xA;      identifier: &#34;AN_AWESOME_TRANSITION&#34;,&#xA;      from: const Idle(&#34;NODE_1&#34;),&#xA;      to: const Idle(&#34;NODE_2&#34;),&#xA;      defaultInternalKeyframes: const [&#xA;        AnimationKeyframe(Idle(&#34;KEYFRAME_1&#34;), 0.25),&#xA;        AnimationKeyframe(Idle(&#34;KEYFRAME_2&#34;), 0.50),&#xA;        AnimationKeyframe(Idle(&#34;KEYFRAME_3&#34;), 0.75)&#xA;      ]&#xA;    ));&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Named &lt;code&gt;SelfTransition&lt;/code&gt; (With Custom Keyframes)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  @override&#xA;  void reactToStateChanges(SampleSource state, SampleSource? previous) {&#xA;    executeSelfTransition(SelfTransition(&#34;LOOPING&#34;, [AnimationKeyframe(Idle(&#34;MID-POINT&#34;), 0.5)]));&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Jump to a named &lt;code&gt;InTransition&lt;/code&gt; State&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  @override&#xA;  void reactToStateChanges(SampleSource state, SampleSource? previous) {&#xA;    jumpTo(&#xA;      InTransition(&#xA;        Transition.declared(&#xA;          identifier: &#34;AN_AWESOME_TRANSITION&#34;,&#xA;          from: const Idle(&#34;NODE_1&#34;),&#xA;          to: const Idle(&#34;NODE_2&#34;),&#xA;          defaultInternalKeyframes: const [&#xA;            AnimationKeyframe(Idle(&#34;KEYFRAME_1&#34;), 0.25),&#xA;            AnimationKeyframe(Idle(&#34;KEYFRAME_2&#34;), 0.50),&#xA;            AnimationKeyframe(Idle(&#34;KEYFRAME_3&#34;), 0.75)&#xA;          ]&#xA;        ), // named transition&#xA;        0.4, // progress&#xA;        playState: PlayState.paused&#xA;      )&#xA;    );&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Concurrency behaviours when you transition into a state when there is already an ongoing transition.&lt;/h4&gt; &#xA;&lt;p&gt;When calling &lt;code&gt;transitionTo&lt;/code&gt; method within the reactToStateChanges hook of an &lt;code&gt;AnimationStateMachine&lt;/code&gt; instance, you have the option of providing a &lt;code&gt;TransitionConcurrencyBehavior&lt;/code&gt; value. This will change the way the state machine will react to the transition attempt when there is already an ongoing transaction.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  @override&#xA;  void reactToStateChanges(SampleSource state, SampleSource? previous) {&#xA;    transitionTo(const Idle(&#34;NODE_1&#34;), behavior: TransitionConcurrencyBehavior.sequence);&#xA;    transitionTo(const Idle(&#34;NODE_2&#34;), behavior: TransitionConcurrencyBehavior.sequence);&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img alt=&#34;concurrency replace representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 3a.png&#34;&gt; &#xA;&lt;img alt=&#34;concurrency ignore representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 3b.png&#34;&gt; &#xA;&lt;img alt=&#34;concurrency combine representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 3c.png&#34;&gt; &#xA;&lt;img alt=&#34;concurrency sequence representation&#34; src=&#34;https://raw.githubusercontent.com/Zira-Games/state-machine-animation/master/.github/images/State Machine 3d.png&#34;&gt; &#xA;&lt;h3&gt;Animation Property Usage&lt;/h3&gt; &#xA;&lt;p&gt;When a state machine is meant to govern a single property, you should use &lt;code&gt;AnimationProperty&amp;lt;T, S&amp;gt;&lt;/code&gt; class or one of its extensions as a shortcut.&lt;/p&gt; &#xA;&lt;p&gt;Animation properties instances are responsible for evaluating the state machine into a resulting value through keyframes and interpolation, along with determining the curve a transition is going to be interpreted with for that property.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;DoubleAnimationProperty&lt;/code&gt; usage&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  final animation = DoubleAnimationProperty&amp;lt;AppState&amp;gt;(&#xA;    keyEvaluator: (key, sourceState) {&#xA;      if( key == &#34;NODE_1&#34; ){&#xA;        return -100;&#xA;      } else if( key == &#34;NODE_2&#34; ){&#xA;        return 0;&#xA;      } else if( key == &#34;NODE_3&#34; ){&#xA;        return 100;&#xA;      }&#xA;    }&#xA;  ).getAnimation(stateMachine.output);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Custom &lt;code&gt;AnimationProperty&lt;/code&gt; usage&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  final animation = AnimationProperty&amp;lt;double, AppState&amp;gt;(&#xA;    // initialValue: ..., // to provide the default value of a property it couldn&#39;t be evaluated.&#xA;    // evaluateKeyframes: ..., // to override the default keyframes of a transition&#xA;    // tween: ..., // the tween instance to be used during interpolation&#xA;    // defaultCurve: .. //&#xA;    // evaluateCurve: .. //&#xA;    keyEvaluator: (key, sourceState) {&#xA;      if( key == &#34;NODE_1&#34; ){&#xA;        return -100;&#xA;      } else if( key == &#34;NODE_2&#34; ){&#xA;        return 0;&#xA;      }&#xA;    }&#xA;  ).getAnimation(stateMachine.output);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To receive an animation stream, the &lt;code&gt;getAnimation&lt;/code&gt; method of an animation property definition should be called with a state machine stream.&lt;/p&gt; &#xA;&lt;p&gt;Returned stream of the type &lt;code&gt;AnimationPropertyState&amp;lt;T&amp;gt;&lt;/code&gt; will contain the following information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;value&lt;/li&gt; &#xA; &lt;li&gt;direction&lt;/li&gt; &#xA; &lt;li&gt;velocity&lt;/li&gt; &#xA; &lt;li&gt;time&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Current existing extensions of &lt;code&gt;AnimationProperty&lt;/code&gt; class is as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;IntegerAnimationProperty&lt;/li&gt; &#xA; &lt;li&gt;DoubleAnimationProperty&lt;/li&gt; &#xA; &lt;li&gt;ModdedDoubleAnimationProperty&lt;/li&gt; &#xA; &lt;li&gt;SizeAnimationProperty&lt;/li&gt; &#xA; &lt;li&gt;ColorAnimationProperty&lt;/li&gt; &#xA; &lt;li&gt;BoolAnimationProperty&lt;/li&gt; &#xA; &lt;li&gt;StringAnimationProperty&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Animation Container Usage&lt;/h3&gt; &#xA;&lt;p&gt;When a state machine is meant to govern an element represented by multiple properties, which is the case for most complex animations, you should use &lt;code&gt;AnimationContainer&lt;/code&gt; and &lt;code&gt;AnimationModel&lt;/code&gt; classes.&lt;/p&gt; &#xA;&lt;p&gt;Animation containers are convenience classes that holds multiple animation properties and the common behaviour between them.&lt;/p&gt; &#xA;&lt;p&gt;They are responsible for serialising the animation properties and the source state into the &lt;code&gt;AnimationModel&lt;/code&gt; class they are related to.&lt;/p&gt; &#xA;&lt;p&gt;They provide an output stream of the AnimationModel.&lt;/p&gt; &#xA;&lt;p&gt;Animation models are simple, data classes that implement a copyWith method, that lets the container know how to map the animation properties to its fields.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;AnimationContainer&lt;/code&gt; and &lt;code&gt;AnimationModel&lt;/code&gt; usage&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;&#xA;class AwesomeObjectAnimation extends AnimationContainer&amp;lt;AwesomeSourceState, AwesomeObject&amp;gt; {&#xA;&#xA;  AwesomeObjectAnimation(AwesomeObjectStateMachine stateMachine) : super(&#xA;    stateMachine: stateMachine,&#xA;    initial: AwesomeObject.empty(),&#xA;    defaultCurve: Curves.easeInOutQuad,&#xA;    staticPropertySerializer: (state) =&amp;gt; {&#xA;      &#34;name&#34;: state.name // example of a non-animated, static property within the animation model class.&#xA;    },&#xA;    properties: [&#xA;      DoubleAnimationProperty(&#xA;        name: &#34;x&#34;,&#xA;        keyEvaluator: (key, sourceState) {&#xA;          if ( key == &#34;NODE_1&#34; ) {&#xA;            return 0;&#xA;          } else if ( key == &#34;NODE_2&#34; ) {&#xA;            return 100;&#xA;          }&#xA;        }&#xA;      ),&#xA;      DoubleAnimationProperty(&#xA;        name: &#34;y&#34;,&#xA;        evaluateCurve: (transition) =&amp;gt; transition.from == const Idle(&#34;NODE_2&#34;) &amp;amp;&amp;amp; transition.to == const Idle(&#34;NODE_1&#34;) // An example of overriding curve for a property of a specific transition&#xA;          ? Curves.bounceOut &#xA;          : Curves.easeInOutQuad,&#xA;        keyEvaluator: (key, sourceState) {&#xA;          if ( key == &#34;NODE_1&#34; ) {&#xA;            return 0;&#xA;          } else if ( key == &#34;NODE_2&#34; ) {&#xA;            return 100;&#xA;          }&#xA;        }&#xA;      ),&#xA;      DoubleAnimationProperty(&#xA;        name: &#34;scale&#34;,&#xA;        keyEvaluator: (key, sourceState) {&#xA;          if ( key == &#34;NODE_1&#34; ) {&#xA;            return 1;&#xA;          } else if ( key == &#34;NODE_2&#34; ) {&#xA;            return 2;&#xA;          }&#xA;        }&#xA;      ),&#xA;      DoubleAnimationProperty&amp;lt;RegularCardState&amp;gt;(&#xA;        name: &#34;opacity&#34;,&#xA;        evaluateKeyframes: (transition, sourceState) =&amp;gt; const [&#xA;          AnimationKeyframe(Idle(&#34;NODE_1&#34;), 0), &#xA;          AnimationKeyframe(Idle(&#34;KEYFRAME_1&#34;), 0.2),&#xA;          AnimationKeyframe(Idle(&#34;KEYFRAME_2&#34;), 0.4), &#xA;          AnimationKeyframe(Idle(&#34;NODE_2&#34;), 1)&#xA;        ],&#xA;        keyEvaluator: (key, sourceState){&#xA;          if ( key == &#34;NODE_1&#34; ) {&#xA;            return 0.5;&#xA;          } else if ( key == &#34;KEYFRAME_1&#34; ) {&#xA;            return 0.6;&#xA;          } else if ( key == &#34;KEYFRAME_2&#34; ) {&#xA;            return 0.7;&#xA;          } else if ( key == &#34;NODE_2&#34; ) {&#xA;            return 1;&#xA;          }&#xA;        }&#xA;      )&#xA;    ]&#xA;  );&#xA;}&#xA;&#xA;class AwesomeObject extends AnimationModel {&#xA;&#xA;  final double name;&#xA;  final double x;&#xA;  final double y;&#xA;  final double scale;&#xA;  final double opacity;&#xA;&#xA;  AwesomeObject(&#xA;    this.name,&#xA;    this.x,&#xA;    this.y,&#xA;    this.scale,&#xA;    this.opacity,&#xA;  );&#xA;&#xA;  AwesomeObject.empty() :&#xA;    name = &#34;&#34;,&#xA;    x = 0,&#xA;    y = 0,&#xA;    scale = 1,&#xA;    opacity = 1;&#xA;&#xA;  @override List&amp;lt;Object?&amp;gt; get props =&amp;gt; [name, x, y, scale, opacity];&#xA;&#xA;  @override&#xA;  AwesomeObject copyWith(Map&amp;lt;String, dynamic&amp;gt; valueMap) =&amp;gt; AwesomeObject(&#xA;    valueMap[&#34;name&#34;] ?? name,&#xA;    valueMap[&#34;x&#34;] ?? x,&#xA;    valueMap[&#34;y&#34;] ?? y,&#xA;    valueMap[&#34;scale&#34;] ?? scale,&#xA;    valueMap[&#34;opacity&#34;] ?? opacity&#xA;  );&#xA;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rendering the Animation with BehaviorSubjectBuilder&lt;/h3&gt; &#xA;&lt;p&gt;BehaviorSubjectBuilder is a simple extension of the StreamBuilder widget that exists for convenience.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class ExampleWidget extends StatelessWidget {&#xA;  const ExampleWidget({Key? key}) : super(key: key);&#xA;&#xA;  @override&#xA;  Widget build(BuildContext context) {&#xA;    return BehaviorSubjectBuilder(&#xA;      subject: context.read&amp;lt;AwesomeObjectAnimation&amp;gt;(),&#xA;      subjectBuilder: (context, awesomeObject) =&amp;gt; Container(&#xA;       /*.... */ &#xA;      )&#xA;    );&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Subscribing Callbacks to Animation Events&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;  // ...&#xA;  final ExampleAFSM stateMachine = ExampleAFSM(stateSubject, tickerManager); &#xA;  //...&#xA;  stateMachine.output.firstWhere((state) =&amp;gt; state?.state.fromKey == &#34;NODE_2&#34;).then((value){&#xA;    print(&#34;ON NODE_2&#34;);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>