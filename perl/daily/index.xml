<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-17T01:44:04Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dkogan/vnlog</title>
    <updated>2023-01-17T01:44:04Z</updated>
    <id>tag:github.com,2023-01-17:/dkogan/vnlog</id>
    <link href="https://github.com/dkogan/vnlog" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Process labelled tabular ASCII data using normal UNIX tools&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;Talk&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I just gave a talk about this at [[https://www.socallinuxexpo.org/scale/17x][SCaLE 17x]]. Here are the [[https://www.youtube.com/watch?v=Qvb_uNkFGNQ&amp;amp;t=12830s][video of the talk]] and the [[https://github.com/dkogan/talk-feedgnuplot-vnlog/blob/master/feedgnuplot-vnlog.org][&#34;slides&#34;]].&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Summary&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Vnlog (&#34;vanilla-log&#34;) is a toolkit for manipulating tabular ASCII data with labelled fields using normal UNIX tools. If you regularly use =awk= and =sort= and =uniq= and others, these tools will make you infinitely more powerful. The vnlog tools /extend/, rather than replace the standard tooling, so minimal effort is required to learn and use these tools.&lt;/p&gt; &#xA;&lt;p&gt;Everything assumes a trivially simple log format:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A whitespace-separated table of ASCII human-readable text&lt;/li&gt; &#xA; &lt;li&gt;A =#= character starts a comment that runs to the end of the line (like in many scripting languages)&lt;/li&gt; &#xA; &lt;li&gt;The first line that begins with a single =#= (not =##= or =#!=) is a /legend/, naming each column. This is required, and the field names that appear here are referenced by all the tools.&lt;/li&gt; &#xA; &lt;li&gt;Empty fields reported as =-=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This describes 99% of the format, with some extra details [[#format-details][below]]. Example:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE #!/usr/bin/whatever&lt;/p&gt; &#xA;&lt;h1&gt;a b c&lt;/h1&gt; &#xA;&lt;p&gt;1 2 3&lt;/p&gt; &#xA;&lt;h2&gt;comment&lt;/h2&gt; &#xA;&lt;p&gt;4 5 6 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Such data can be processed directly with almost any existing tool, and /this/ toolkit allows the user to manipulate this data in a nicer way by relying on standard UNIX tools. The core philosophy is to avoid creating new knowledge as much as possible. Consequently, the vnlog toolkit relies /heavily/ on existing (and familiar!) tools and workflows. As such, the toolkit is small, light, and has a /very/ friendly learning curve.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Synopsis&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I have [[https://raw.githubusercontent.com/dkogan/vnlog/master/dji-tsla.tar.gz][two sets of historical stock data]], from the start of 2018 until now (2018/11):&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; dji.vnl head -n 4 #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Open High Low Close AdjClose Volume : 2018-11-15 25061.48 25354.56 24787.79 25289.27 25289.27 383292840 : 2018-11-14 25388.08 25501.29 24935.82 25080.50 25080.50 384240000 : 2018-11-13 25321.21 25511.03 25193.78 25286.49 25286.49 339690000&lt;/p&gt; &#xA;&lt;p&gt;And&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; tsla.vnl head -n 4 #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Open High Low Close AdjClose Volume : 2018-11-15 342.33 348.58 339.04 348.44 348.44 4486339 : 2018-11-14 342.70 347.11 337.15 344.00 344.00 5036300 : 2018-11-13 333.16 344.70 332.20 338.73 338.73 5448600&lt;/p&gt; &#xA;&lt;p&gt;I can pull out the closing prices:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; dji.vnl vnl-filter -p Close | head -n4 #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Close : 25289.27 : 25080.50 : 25286.49&lt;/p&gt; &#xA;&lt;p&gt;=vnl-filter= is primarily a wrapper around =awk= or =perl=, allowing the user to reference columns by name. I can then plot the closing prices:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results file link :exports both &amp;lt; dji.vnl vnl-filter -p Close | feedgnuplot --lines --unset grid #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:guide-1.svg]]&lt;/p&gt; &#xA;&lt;p&gt;Here I kept /only/ the closing price column, so the x-axis is just the row index. The data was in reverse chronological order, so this plot is also in reverse chronological order. Let&#39;s fix that:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results file link :exports both &amp;lt; dji.vnl vnl-sort -k Date | vnl-filter -p Close | feedgnuplot --lines --unset grid #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:guide-2.svg]]&lt;/p&gt; &#xA;&lt;p&gt;The =vnl-sort= tool (and most of the other =vnl-xxx= tools) are wrappers around the core tools already available on the system (such as =sort=, in this case). With the primary difference being reading/writing vnlog, and referring to columns by name.&lt;/p&gt; &#xA;&lt;p&gt;We now have the data in the correct order, but it&#39;d be nice to see the actual dates on the x-axis. While we&#39;re at it, let&#39;s label the axes too:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; dji.vnl vnl-filter -p Date,Close | head -n4 #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Close : 2018-11-15 25289.27 : 2018-11-14 25080.50 : 2018-11-13 25286.49&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results file link :exports both &amp;lt; dji.vnl vnl-sort -k Date | vnl-filter -p Date,Close | feedgnuplot --lines --unset grid --timefmt %Y-%m-%d --domain &lt;br&gt; --xlabel &#39;Date&#39; --ylabel &#39;Price ($)&#39; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:guide-3.svg]]&lt;/p&gt; &#xA;&lt;p&gt;What was the highest value of the Dow-Jones index, and when did it happen?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; dji.vnl vnl-sort -rgk Close | head -n2 | vnl-align #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Open High Low Close AdjClose Volume : 2018-10-03 26833.47 26951.81 26789.08 26828.39 26828.39 280130000&lt;/p&gt; &#xA;&lt;p&gt;Alrighty. Looks like the high was in October. Let&#39;s zoom in on that month:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results file link :exports both &amp;lt; dji.vnl vnl-sort -k Date | vnl-filter &#39;Date ~ /2018-10/&#39; -p Date,Close | feedgnuplot --lines --unset grid --timefmt %Y-%m-%d --domain &lt;br&gt; --xlabel &#39;Date&#39; --ylabel &#39;Price ($)&#39; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:guide-4.svg]]&lt;/p&gt; &#xA;&lt;p&gt;OK. Is this thing volatile? What was the largest single-day gain?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; dji.vnl vnl-filter -p &#39;.,d=diff(Close)&#39; | head -n4 | vnl-align #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Open High Low Close AdjClose Volume d&lt;br&gt; : 2018-11-15 25061.48 25354.56 24787.79 25289.27 25289.27 383292840 -&lt;br&gt; : 2018-11-14 25388.08 25501.29 24935.82 25080.50 25080.50 384240000 -208.77 : 2018-11-13 25321.21 25511.03 25193.78 25286.49 25286.49 339690000 205.99&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; dji.vnl vnl-filter -p &#39;.,d=diff(Close)&#39; | vnl-sort -rgk d | head -n2 | vnl-align #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Open High Low Close AdjClose Volume d&lt;br&gt; : 2018-02-02 26061.79 26061.79 25490.66 25520.96 25520.96 522880000 1175.21&lt;/p&gt; &#xA;&lt;p&gt;Whoa. So the best single-gain day was 2018-02-02: the dow gained 1175.21 points between closing on Feb 1 and Feb 2. But it actually lost ground that day! What if I looked at the difference between the opening and closing in a single day?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both &amp;lt; dji.vnl vnl-filter -p &#39;.,d=Close-Open&#39; | vnl-sort -rgk d | head -n2 | vnl-align #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Open High Low Close AdjClose Volume d&lt;br&gt; : 2018-02-06 24085.17 24946.23 23778.74 24912.77 24912.77 823940000 827.6&lt;/p&gt; &#xA;&lt;p&gt;I guess by that metric 2018-02-06 was better. Let&#39;s join the Dow-jones index data and the TSLA data, and let&#39;s look at them together:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both vnl-join --vnl-autosuffix dji.vnl tsla.vnl -j Date | head -n4 | vnl-align #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Date Open_dji High_dji Low_dji Close_dji AdjClose_dji Volume_dji Open_tsla High_tsla Low_tsla Close_tsla AdjClose_tsla Volume_tsla : 2018-11-15 25061.48 25354.56 24787.79 25289.27 25289.27 383292840 342.33 348.58 339.04 348.44 348.44 4486339&lt;br&gt; : 2018-11-14 25388.08 25501.29 24935.82 25080.50 25080.50 384240000 342.70 347.11 337.15 344.00 344.00 5036300&lt;br&gt; : 2018-11-13 25321.21 25511.03 25193.78 25286.49 25286.49 339690000 333.16 344.70 332.20 338.73 338.73 5448600&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results output :exports both vnl-join --vnl-autosuffix dji.vnl tsla.vnl -j Date | vnl-filter -p &#39;^Close&#39; | head -n4 | vnl-align #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : # Close_dji Close_tsla : 25289.27 348.44&lt;br&gt; : 25080.50 344.00&lt;br&gt; : 25286.49 338.73&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results file link :exports both vnl-join --vnl-autosuffix dji.vnl tsla.vnl -j Date | vnl-filter -p &#39;^Close&#39; | feedgnuplot --domain --points --unset grid &lt;br&gt; --xlabel &#39;DJI price ($)&#39; --ylabel &#39;TSLA price ($)&#39; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:guide-5.svg]]&lt;/p&gt; &#xA;&lt;p&gt;Huh. Apparently there&#39;s no obvious, strong correlation between TSLA and Dow-Jones closing prices. And we saw that with just a few shell commands, without dropping down into a dedicated analysis system.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Build and installation vnlog is a part of Debian/buster and Ubuntu/cosmic (18.10) and later. On those boxes you can simply&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ sudo apt install vnlog libvnlog-dev libvnlog-perl python3-vnlog #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;to get the binary tools, the C API, the perl and python3 interfaces respectively.&lt;/p&gt; &#xA;&lt;p&gt;** Install on non-Debian boxes Most of this is written in an interpreted language, so there&#39;s nothing to build or install, and you can run the tools directly from the source tree:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ git clone &lt;a href=&#34;https://github.com/dkogan/vnlog.git&#34;&gt;https://github.com/dkogan/vnlog.git&lt;/a&gt; $ cd vnlog $ ./vnl-filter ..... #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;The python and perl libraries can be run from the tree by setting the =PYTHONPATH= and =PERL5LIB= environment variables respectively. For the C library, you should =make=, and then point your =CFLAGS= and =LDLIBS= and =LD_LIBRARY_PATH= to the local tree.&lt;/p&gt; &#xA;&lt;p&gt;If you do want to install to some arbitrary location to simplify the paths, do this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ make $ PREFIX=/usr/local make install #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;This will install /all/ the components into =/usr/local=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Description Vnlog data is nicely readable by both humans and machines. Any time your application invokes =printf()= for either diagnostics or logging, consider writing out vnlog-formatted data. You retain human readability, but gain the power all the =vnl-...= tools provide.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Vnlog tools are designed to be very simple and light. There&#39;s an ever-growing list of other tools that do vaguely the same thing. Some of these:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/BurntSushi/xsv&#34;&gt;https://github.com/BurntSushi/xsv&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://csvkit.readthedocs.io/&#34;&gt;https://csvkit.readthedocs.io/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/johnkerl/miller&#34;&gt;https://github.com/johnkerl/miller&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eBay/tsv-utils-dlang&#34;&gt;https://github.com/eBay/tsv-utils-dlang&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/datamash/&#34;&gt;https://www.gnu.org/software/datamash/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stedolan.github.io/jq/&#34;&gt;https://stedolan.github.io/jq/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/benbernard/RecordStream&#34;&gt;https://github.com/benbernard/RecordStream&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dinedal/textql&#34;&gt;https://github.com/dinedal/textql&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.visidata.org/&#34;&gt;https://www.visidata.org/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://harelba.github.io/q/&#34;&gt;http://harelba.github.io/q/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/BatchLabs/charlatan&#34;&gt;https://github.com/BatchLabs/charlatan&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dbohdan/sqawk&#34;&gt;https://github.com/dbohdan/sqawk&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Many of these provide facilities to run various analyses, and others focus on data types that aren&#39;t just a table (json for instance). Vnlog by contrast doesn&#39;t analyze anything, and targets the most trivial possible data format. This makes it very easy to run any analysis you like in any tool you like. The main envisioned use case is one-liners, and the tools are geared for that purpose. The above mentioned tools are much more powerful than vnlog, so they could be a better fit for some use cases. I claim that&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;90% of the time you want to do simple things, and vnlog is a great fit for the task&lt;/li&gt; &#xA; &lt;li&gt;If you really do need to do something complex, you shouldn&#39;t be in the shell writing oneliners anymore, and a fully-fledged analysis system (numpy, etc) is more appropriate&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the spirit of doing as little as possible, the provided tools are wrappers around tools you already have and are familiar with. The provided tools are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=vnl-filter= is a tool to select a subset of the rows/columns in a vnlog and/or to manipulate the contents. This is an =awk= wrapper where the fields can be referenced by name instead of index. 20-second tutorial:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results none :exports code vnl-filter -p col1,col2,colx=col3+col4 &#39;col5 &amp;gt; 10&#39; --has col6 #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;will read the input, and produce a vnlog with 3 columns: =col1= and =col2= from the input, and a column =colx= that&#39;s the sum of =col3= and =col4= in the input. Only those rows for which /both/ =col5 &amp;gt; 10= is true /and/ that have a non-null value for =col6= will be output. A null entry is signified by a single =-= character.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results none :exports code vnl-filter --eval &#39;{s += x} END {print s}&#39; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;will evaluate the given awk program on the input, but the column names work as you would hope they do: if the input has a column named =x=, this would produce the sum of all values in this column.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=vnl-sort=, =vnl-uniq=, =vnl-join=, =vnl-tail=, =vnl-ts= are wrappers around the corresponding commandline tools. These work exactly as you would expect also: the columns can be referenced by name, and the legend comment is handled properly. These are wrappers, so all the commandline options those tools have &#34;just work&#34; (except options that don&#39;t make sense in the context of vnlog). As an example, =vnl-tail -f= will follow a log: data will be read by =vnl-tail= as it is written into the log (just like =tail -f=, but handling the legend properly). And you already know how to use these tools without even reading the manpages! Note: I use the Linux kernel and the tools from GNU Coreutils exclusively, but this all has been successfully tested on FreeBSD and OSX also. Please let me know if something doesn&#39;t work.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=vnl-align= aligns vnlog columns for easy interpretation by humans. The meaning is unaffected&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=Vnlog::Parser= is a simple perl library to read a vnlog&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=vnlog= is a simple python library to read a vnlog. Both python2 and python3 are supported&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=libvnlog= is a C library to simplify writing a vnlog. Clearly all you /really/ need is =printf()=, but this is useful if we have lots of columns, many containing null values in any given row, and/or if we have parallel threads writing to a log. In my usage I have hundreds of columns of sparse data, so this is handy&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=vnl-make-matrix= converts a one-point-per-line vnlog to a matrix of data. I.e.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ cat dat.vnl&lt;/p&gt; &#xA;&lt;h1&gt;i j x&lt;/h1&gt; &#xA;&lt;p&gt;0 0 1 0 1 2 0 2 3 1 0 4 1 1 5 1 2 6 2 0 7 2 1 8 2 2 9 3 0 10 3 1 11 3 2 12&lt;/p&gt; &#xA;&lt;p&gt;$ &amp;lt; dat.vnl vnl-filter -p i,x | vnl-make-matrix --outdir /tmp Writing to &#39;/tmp/x.matrix&#39;&lt;/p&gt; &#xA;&lt;p&gt;$ cat /tmp/x.matrix 1 2 3 4 5 6 7 8 9 10 11 12 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;All the tools have manpages that contain more detail. And more tools will probably be added with time.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Format details The high-level description of the vnlog format from [[#Summary][above]] is sufficient to read/write &#34;normal&#34; vnlog data, but there are a few corner cases that should be mentioned. To reiterate, the format description from above describes vnlog as:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A whitespace-separated table of ASCII human-readable text&lt;/li&gt; &#xA; &lt;li&gt;A =#= character starts a comment that runs to the end of the line (like in many scripting languages)&lt;/li&gt; &#xA; &lt;li&gt;The first line that begins with a single =#= (not =##= or =#!=) is a /legend/, naming each column. This is required, and the field names that appear here are referenced by all the tools.&lt;/li&gt; &#xA; &lt;li&gt;Empty fields reported as =-=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For a few years now I&#39;ve been using these tools myself, and supporting others as they were passing vnlog data around. In the process I&#39;ve encountered some slightly-weird data, and patched the tools to accept it. So today the included vnlog tools are /very/ permissive, and accept any vnlog data that can possibly be accepted. Other vnlog tools may not be quite as permissive, and may not be able to interpret &#34;weird&#34; data. Points of note, describing the included vnlog tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Leading and trailing whitespace is ignored. Everywhere. So this data file will be read properly, with the =x= column containing 1 and 3:&lt;/p&gt; &lt;p&gt;#+begin_example&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;x y&lt;/h1&gt; &#xA;&lt;p&gt;1 2 3 4 #+end_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Empty (or whitespace-only) lines anywhere are ignored, and treated as a comment&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;An initial =#= comment without field names is treated as a comment, and we continue looking for the legend in the following lines. So this data file will be read properly:&lt;/p&gt; &lt;p&gt;#+begin_example&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;comment&lt;/h2&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;x y&lt;/h1&gt; &#xA;&lt;p&gt;1 2 3 4 #+end_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Trailing comments are supported, like in most scripting languages. So this data file will be read properly:&lt;/p&gt; &lt;p&gt;#+begin_example&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;x y&lt;/h1&gt; &#xA;&lt;p&gt;1 2 # comment 3 4 #+end_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Field names are /very/ permissive: anything that isn&#39;t whitespace is supported. So this data file will be read properly:&lt;/p&gt; &lt;p&gt;#+begin_example&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;x y # 1+ -&lt;/h1&gt; &#xA;&lt;p&gt;1 2 3 4 5 11 12 13 14 15 #+end_example&lt;/p&gt; &#xA;&lt;p&gt;We can pull out the =#= and =1+= and =-= columns:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src sh vnl-filter -p &#39;#,1+,-&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And we can even operate on them, if we use whitespace to indicate field boundaries:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src sh vnl-filter -p &#39;x=1+ + 5&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Note that this implies that trailing comments in a legend line are /not/ supported: the extra =#= characters will be used for field names. Field names containing =,= or === are currently not accepted by =vnl-filter=, but /are/ accepted by the other tools (=vnl-sort= and such). I&#39;ll make =vnl-filter= able to work with those field names too, eventually, but as a user, the simplest thing to do is to not pass around data with such field names.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Duplicated labels are supported whenever possible. So&lt;/p&gt; &lt;p&gt;#+begin_example&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;x y z z&lt;/h1&gt; &#xA;&lt;p&gt;1 2 3 4 11 12 13 14 #+end_example&lt;/p&gt; &#xA;&lt;p&gt;will work just fine, unless we&#39;re operating on =z=. With this data, both of these commands work:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src sh vnl-filter -p x vnl-filter -p z #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Picking =z= selects both of the =z= columns. But neither of these commands can work with the non-unique =z= column:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src sh vnl-filter -p s=z+1 vnl-sort -k z #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Workflows and recipes ** Storing disjoint data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A common use case is a complex application that produces several semi-related subsets of data at once. Example: a moving vehicle is reporting both its own position and the observed positions of other vehicles; at any given time any number of other vehicles may be observed. Two equivalent workflows are possible:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a single unified vnlog stream for /all/ the data&lt;/li&gt; &#xA; &lt;li&gt;several discrete vnlog streams for each data subset&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both are valid approaches&lt;/p&gt; &#xA;&lt;p&gt;*** One unified vnlog stream Here the application produces a /single/ vnlog that contains /all/ the columns, from /all/ the data subsets. In any given row, many of the columns will be empty (i.e. contain only =-= ). For instance, a row describing a vehicle own position will not have data about any observations, and vice versa. It is inefficient to store all the extra =-= but it makes many things much nicer, so it&#39;s often worth it. =vnl-filter= can be used to pull out the different subsets. Sample =joint.vnl=:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt; &#xA;&lt;h1&gt;time x_self x_observation&lt;/h1&gt; &#xA;&lt;p&gt;1 10 - 2 20 - 2 - 100 3 30 - 3 - 200 3 - 300 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Here we have 3 instances in time. We have no observations at =time= 1, one observation at =time= 2, and two observations at =time= 3. We can use =vnl-filter= to pull out the data we want:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ &amp;lt; joint.vnl vnl-filter -p time,self&lt;/p&gt; &#xA;&lt;h1&gt;time x_self&lt;/h1&gt; &#xA;&lt;p&gt;1 10 2 20 2 - 3 30 3 - 3 - #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;If we only care about our own positions, the =+= modifier in picked columns in =vnl-filter= is very useful here:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ &amp;lt; joint.vnl vnl-filter -p time,+self&lt;/p&gt; &#xA;&lt;h1&gt;time x_self&lt;/h1&gt; &#xA;&lt;p&gt;1 10 2 20 3 30&lt;/p&gt; &#xA;&lt;p&gt;$ &amp;lt; joint.vnl vnl-filter -p time,+observation&lt;/p&gt; &#xA;&lt;h1&gt;time x_observation&lt;/h1&gt; &#xA;&lt;p&gt;2 100 3 200 3 300 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Note that the default is =--skipempty=, so if we&#39;re /only/ looking at =x_self= for instance, then we don&#39;t even need to =+= modifier:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example $ &amp;lt; joint.vnl vnl-filter -p self&lt;/p&gt; &#xA;&lt;h1&gt;x_self&lt;/h1&gt; &#xA;&lt;p&gt;10 20 30 #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Also, note that the =vnlog= C interface works very nicely to produce these datafiles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can define lots and lots of columns, but only fill some of them before calling =vnlog_emit_record()=. The rest will be set to =-=.&lt;/li&gt; &#xA; &lt;li&gt;You can create multiple contexts for each type of data, and you can populate them with data independently. And when calling =vnlog_emit_record_ctx()=, you&#39;ll get a record with data for just that context.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Several discrete vnlog streams&lt;/p&gt; &#xA;&lt;p&gt;Conversely, the application can produce /separate/ vnlog streams for /each/ subset of data. Depending on what is desired, exactly, =vnl-join= can be used to re-join them:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ cat self.vnl&lt;/p&gt; &#xA;&lt;h1&gt;time x_self&lt;/h1&gt; &#xA;&lt;p&gt;1 10 2 20 3 30&lt;/p&gt; &#xA;&lt;p&gt;$ cat observations.vnl&lt;/p&gt; &#xA;&lt;h1&gt;time x_observation&lt;/h1&gt; &#xA;&lt;p&gt;2 100 3 200 3 300&lt;/p&gt; &#xA;&lt;p&gt;$ vnl-join -j time -a- self.vnl observations.vnl&lt;/p&gt; &#xA;&lt;h1&gt;time x_self x_observation&lt;/h1&gt; &#xA;&lt;p&gt;1 10 - 2 20 100 3 30 200 3 30 300 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** Data statistics&lt;/p&gt; &#xA;&lt;p&gt;A common need is to compute basic statistics from your data. Many of the alternative toolkits listed above provide built-in facilities to do this, but vnlog does not: it&#39;s meant to be unixy, where each tool has very limited scope. Thus you can either do this with =awk= like you would normally, or you can use other standalone tools to perform the needed computations. For instance, I can generate some data:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ seq 2 100 | awk &#39;BEGIN {print &#34;# x&#34;} {print log($1)}&#39; &amp;gt; /tmp/log.vnl #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Then I can compute the mean with =awk=:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ &amp;lt; /tmp/log.vnl vnl-filter --eval &#39;{sum += x} END {print sum/NR}&#39; 3.67414 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Or I can compute the mean (and other stuff) with a separate standalone tool:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ &amp;lt; /tmp/log.vnl ministat x &#xA; &lt;stdin&gt;&#xA;   +----------------------------------------------------------------------------+ | xx | | x xxxxxxx | | xx xxxxxxxxxxxx| | x x xxxxxxxxxxxxxxxxxxxxxxx| |x x x x x x x x x xx xx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx| | |____&#xA;  &lt;em&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;A____M&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;| | +----------------------------------------------------------------------------+ N Min Max Median Avg Stddev x 99 0.693147 4.60517 3.93183 3.6741353 0.85656382 #+END_EXAMPLE&#xA; &lt;/stdin&gt;&lt;/p&gt; &#xA;&lt;p&gt;=ministat= is not a part of the vnlog toolkit, but the vnlog format is generic so it works just fine.&lt;/p&gt; &#xA;&lt;p&gt;** Powershell-style filtering of common shell commands&lt;/p&gt; &#xA;&lt;p&gt;Everything about vnlog is generic and simple, so it&#39;s easy to use it to process data that wasn&#39;t originally meant to be used this way. For instance filtering the output of =ls -l= to report only file names and sizes, skipping directories, and sorting by file sizes:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ ls -l&lt;/p&gt; &#xA;&lt;p&gt;total 320 -rw-r--r-- 1 dima dima 5044 Aug 25 15:04 Changes -rw-r--r-- 1 dima dima 12749 Aug 25 15:04 Makefile -rw-r--r-- 1 dima dima 69789 Aug 25 15:04 README.org -rw-r--r-- 1 dima dima 33781 Aug 25 15:04 README.template.org -rw-r--r-- 1 dima dima 5359 Aug 25 15:04 b64_cencode.c drwxr-xr-x 4 dima dima 4096 Aug 25 15:04 completions drwxr-xr-x 3 dima dima 4096 Aug 25 15:04 lib drwxr-xr-x 3 dima dima 4096 Aug 25 15:04 packaging drwxr-xr-x 2 dima dima 4096 Aug 25 15:04 test -rwxr-xr-x 1 dima dima 5008 Aug 25 15:04 vnl-align -rwxr-xr-x 1 dima dima 56637 Aug 25 15:04 vnl-filter -rwxr-xr-x 1 dima dima 5678 Aug 25 15:04 vnl-gen-header -rwxr-xr-x 1 dima dima 29815 Aug 25 15:04 vnl-join -rwxr-xr-x 1 dima dima 3631 Aug 25 15:04 vnl-make-matrix -rwxr-xr-x 1 dima dima 8372 Aug 25 15:04 vnl-sort -rwxr-xr-x 1 dima dima 5822 Aug 25 15:04 vnl-tail -rwxr-xr-x 1 dima dima 4439 Aug 25 15:04 vnl-ts -rw-r--r-- 1 dima dima 559 Aug 25 15:04 vnlog-base64.h -rw-r--r-- 1 dima dima 8169 Aug 25 15:04 vnlog.c -rw-r--r-- 1 dima dima 12677 Aug 25 15:04 vnlog.h&lt;/p&gt; &#xA;&lt;p&gt;$ (echo &#39;# permissions num_links user group size month day time name&#39;; ls -l | tail -n +2) | vnl-filter &#39;permissions !~ &#34;^d&#34;&#39; -p name,size | vnl-sort -gk size | vnl-align&lt;/p&gt; &#xA;&lt;h1&gt;name size&lt;/h1&gt; &#xA;&lt;p&gt;vnlog-base64.h 559 vnl-make-matrix 3631 vnl-ts 4439 vnl-align 5008 Changes 5044 b64_cencode.c 5359 vnl-gen-header 5678 vnl-tail 5822 vnlog.c 8169 vnl-sort 8372 vnlog.h 12677 Makefile 12749 vnl-join 29815 README.template.org 33781 vnl-filter 56637 README.org 69789 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;With a bit of shell manipulation, these tools can be applied to a whole lot of different data streams that know nothing of vnlog.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C interface ** Basic usage For most uses, vnlog files are simple enough to be generated with plain prints. But then each print statement has to know which numeric column we&#39;re populating, which becomes effortful with many columns. In my usage it&#39;s common to have a large parallelized C program that&#39;s writing logs with hundreds of columns where any one record would contain only a subset of the columns. In such a case, it&#39;s helpful to have a library that can output the log files. This is available. Basic usage looks like this:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In a shell:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh :results none :exports code vnl-gen-header &#39;int w&#39; &#39;uint8_t x&#39; &#39;char* y&#39; &#39;double z&#39; &#39;void* binary&#39; &amp;gt; vnlog_fields_generated.h #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;In a C program test.c:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC C #include &#34;vnlog_fields_generated.h&#34;&lt;/p&gt; &#xA;&lt;p&gt;int main() { vnlog_emit_legend();&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vnlog_set_field_value__w(-10);&#xA;vnlog_set_field_value__x(40);&#xA;vnlog_set_field_value__y(&#34;asdf&#34;);&#xA;vnlog_emit_record();&#xA;&#xA;vnlog_set_field_value__z(0.3);&#xA;vnlog_set_field_value__x(50);&#xA;vnlog_set_field_value__w(-20);&#xA;vnlog_set_field_value__binary(&#34;\x01\x02\x03&#34;, 3);&#xA;vnlog_emit_record();&#xA;&#xA;vnlog_set_field_value__w(-30);&#xA;vnlog_set_field_value__x(10);&#xA;vnlog_set_field_value__y(&#34;whoa&#34;);&#xA;vnlog_set_field_value__z(0.5);&#xA;vnlog_emit_record();&#xA;&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;} #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Then we build and run, and we get&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE $ cc -o test test.c -lvnlog&lt;/p&gt; &#xA;&lt;p&gt;$ ./test&lt;/p&gt; &#xA;&lt;h1&gt;w x y z binary&lt;/h1&gt; &#xA;&lt;p&gt;-10 40 asdf - - -20 50 - 0.2999999999999999889 AQID -30 10 whoa 0.5 - #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;The binary field in base64-encoded. This is a rarely-used feature, but sometimes you really need to log binary data for later processing, and this makes it possible.&lt;/p&gt; &#xA;&lt;p&gt;So you&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Generate the header to define your columns&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Call =vnlog_emit_legend()=&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Call =vnlog_set_field_value__...()= for each field you want to set in that row.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Call =vnlog_emit_record()= to write the row and to reset all fields for the next row. Any fields unset with a =vnlog_set_field_value__...()= call are written as null: =-=&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This is enough for 99% of the use cases. Things get a bit more complex if we have have threading or if we have multiple vnlog ouput streams in the same program. For both of these we use vnlog /contexts/.&lt;/p&gt; &#xA;&lt;p&gt;** Contexts&lt;/p&gt; &#xA;&lt;p&gt;To support independent writing into the same vnlog (possibly by multiple threads; this is reentrant), each log-writer should create a context, and use it when talking to vnlog. The context functions will make sure that the fields in each context are independent and that the output records won&#39;t clobber each other:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC C void child_writer( // the parent context also writes to this vnlog. Pass NULL to // use the global one struct vnlog_context_t* ctx_parent ) { struct vnlog_context_t ctx; vnlog_init_child_ctx(&amp;amp;ctx, ctx_parent);&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;while(records)&#xA;{&#xA;    vnlog_set_field_value_ctx__xxx(&amp;amp;ctx, ...);&#xA;    vnlog_set_field_value_ctx__yyy(&amp;amp;ctx, ...);&#xA;    vnlog_set_field_value_ctx__zzz(&amp;amp;ctx, ...);&#xA;    vnlog_emit_record_ctx(&amp;amp;ctx);&#xA;}&#xA;&#xA;vnlog_free_ctx(&amp;amp;ctx); // required only if we have any binary fields&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;} #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;If we want to have multiple independent vnlog writers to /different/ streams (with different columns and legends), we do this instead:&lt;/p&gt; &#xA;&lt;p&gt;=file1.c=: #+BEGIN_SRC C #include &#34;vnlog_fields_generated1.h&#34;&lt;/p&gt; &#xA;&lt;p&gt;void f(void) { // Write some data out to the default context and default output (STDOUT) vnlog_emit_legend(); ... vnlog_set_field_value__xxx(...); vnlog_set_field_value__yyy(...); ... vnlog_emit_record(); } #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;=file2.c=: #+BEGIN_SRC C #include &#34;vnlog_fields_generated2.h&#34;&lt;/p&gt; &#xA;&lt;p&gt;void g(void) { // Make a new session context, send output to a different file, write // out legend, and send out the data struct vnlog_context_t ctx; vnlog_init_session_ctx(&amp;amp;ctx); FILE* fp = fopen(...); vnlog_set_output_FILE(&amp;amp;ctx, fp); vnlog_emit_legend_ctx(&amp;amp;ctx); ... vnlog_set_field_value__a(...); vnlog_set_field_value__b(...); ... vnlog_free_ctx(&amp;amp;ctx); // required only if we have any binary fields vnlog_emit_record(); } #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Note that it&#39;s the user&#39;s responsibility to make sure the new sessions go to a different =FILE= by invoking =vnlog_set_output_FILE()=. Furthermore, note that the included =vnlog_fields_....h= file defines the fields we&#39;re writing to; and if we have multiple different vnlog field definitions in the same program (as in this example), then the different writers /must/ live in different source files. The compiler will barf if you try to =#include= two different =vnlog_fields_....h= files in the same source.&lt;/p&gt; &#xA;&lt;p&gt;** Remaining APIs&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=vnlog_printf(...)= and =vnlog_printf_ctx(ctx, ...)= write to a pipe like =printf()= does. This exists primarily for comments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=vnlog_clear_fields_ctx(ctx, do_free_binary)= clears out the data in a context and makes it ready to be used for the next record. It is rare for the user to have to call this manually. The most common case is handled automatically (clearing out a context after emitting a record). One area where this is useful is when making a copy of a context:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_SRC C struct vnlog_context_t ctx1; // .... do stuff with ctx1 ... add data to it ...&lt;/p&gt; &#xA;&lt;p&gt;struct vnlog_context_t ctx2 = ctx1; // ctx1 and ctx2 now both have the same data, and the same pointers to // binary data. I need to get rid of the pointer references in ctx1&lt;/p&gt; &#xA;&lt;p&gt;vnlog_clear_fields_ctx(&amp;amp;ctx1, false); #+END_SRC&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=vnlog_free_ctx(ctx)= frees memory for an vnlog context. Do this before throwing the context away. Currently this is only needed for context that have binary fields, but this should be called for all contexts anyway, in case this changes in a later revision&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Base64 interface The C interface supports writing base64-encoded binary data using Chris Venter&#39;s libb64. The base64-encoder used here was slightly modified: the output appears all on one line, making is suitable to appear in a vnlog field. If we&#39;re writing a vnlog with =printf()= directly without using the =vnlog.h= interface described above, we allow this modified base64 encoder to be invoked by itself. Usage:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC C void* binary_buffer = ...; int binary_buffer_len = ...;&lt;/p&gt; &#xA;&lt;p&gt;char base64_buffer[vnlog_base64_dstlen_to_encode(binary_buffer_len)]; vnlog_base64_encode( base64_buffer, sizeof(base64_buffer), binary_buffer, binary_buffer_len ); #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Clearly the above example allocates the base64 buffer on the stack, so it&#39;s only suitable for small-ish data chunks. But if you have lots and lots of data, probably writing it as base64 into a vnlog isn&#39;t the best thing to do.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Python interface Reading vnlog data into a python program is simple. The =vnlog= Python module provides three different ways to do that:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;slurp the whole thing into a numpy array using the =slurp()= function. Basic usage:&lt;/p&gt; &lt;p&gt;#+begin_src python import vnlog log_numpy_array,list_keys,dict_key_index = &lt;br&gt; vnlog.slurp(filename_or_fileobject) #+end_src&lt;/p&gt; &lt;p&gt;This parses out the legend, and then calls =numpy.loadtxt()=. Null data values (=-=) are not supported&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Iterate through the records: =vnlog= class, used as an iterator. Basic usage:&lt;/p&gt; &lt;p&gt;#+begin_src python import vnlog for d in vnlog.vnlog(filename_or_fileobject): print(d[&#39;time&#39;],d[&#39;height&#39;]) #+end_src&lt;/p&gt; &lt;p&gt;Null data values are represented as =None=&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Parse incoming lines individually: =vnlog= class, using the =parse()= method. Basic usage:&lt;/p&gt; &lt;p&gt;#+begin_src python import vnlog parser = vnlog.vnlog() for l in file: parser.parse(l) d = parser.values_dict() if not d: continue print(d[&#39;time&#39;],d[&#39;height&#39;]) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Most of the time you&#39;d use options 1 or 2 above. Option 3 is the most general, but also the most verbose&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;numpy interface If we need to read data into numpy specifically, nicer tools are available than the generic =vnlog= Python module. The built-in =numpy.loadtxt= =numpy.savetxt= functions work well (with the caveat that =numpy.loadtxt()= should be followed by =numpysane.atleast_dims(..., -2)= to make sure that a data array of shape =(Nrows,Ncols)= is returned even if =Nrows==1=. For example to write to standard output a vnlog with fields =a=, =b= and =c=:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_SRC python numpy.savetxt(sys.stdout, array, fmt=&#34;%g&#34;, header=&#34;a b c&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Note that numpy automatically adds the =#= to the header. To read a vnlog from a file on disk, do something like&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC python array = numpysane.atleast_dims(numpy.loadtxt(&#39;data.vnl&#39;), -2) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;These functions know that =#= lines are comments, but don&#39;t interpret anything as field headers. That&#39;s easy to do, so I&#39;m not providing any helper libraries. I might do that at some point, but in the meantime, patches are welcome.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compatibility&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I use GNU/Linux-based systems exclusively, but everything has been tested functional on FreeBSD and OSX in addition to Debian, Ubuntu and CentOS. I can imagine there&#39;s something I missed when testing on non-Linux systems, so please let me know if you find any issues.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Caveats and bugs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These tools are meant to be simple, so some things are hard requirements. A big one is that columns are whitespace-separated. There is /no/ mechanism for escaping or quoting whitespace into a single field. I think supporting something like that is more trouble than it&#39;s worth.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Manpages ** vnl-filter #+BEGIN_EXAMPLE NAME vnl-filter - filters vnlogs to select particular rows, fields&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SYNOPSIS $ cat run.vnl&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; # time x   y   z   temperature&#xA; 3      1   2.3 4.8 30&#xA; 4      1.1 2.2 4.7 31&#xA; 6      1   2.0 4.0 35&#xA; 7      1   1.6 3.1 42&#xA;&#xA;&#xA; $ &amp;lt;run.vnl vnl-filter -p x,y,z | vnl-align&#xA;&#xA; # x  y   z&#xA; 1   2.3 4.8&#xA; 1.1 2.2 4.7&#xA; 1   2.0 4.0&#xA; 1   1.6 3.1&#xA;&#xA;&#xA; $ &amp;lt;run.vnl vnl-filter -p i=NR,time,&#39;dist=sqrt(x*x + y*y + z*z)&#39; | vnl-align&#xA;&#xA; # i time   dist&#xA; 1   3    5.41572&#xA; 2   4    5.30471&#xA; 3   6    4.58258&#xA; 4   7    3.62905&#xA;&#xA;&#xA; $ &amp;lt;run.vnl vnl-filter &#39;temperature &amp;gt;= 35&#39; | vnl-align&#xA;&#xA; # time x  y   z  temperature&#xA; 6      1 2.0 4.0 35&#xA; 7      1 1.6 3.1 42&#xA;&#xA;&#xA;&#xA; $ &amp;lt;run.vnl vnl-filter --eval &#39;{s += temperature} END { print &#34;mean temp: &#34; s/NR}&#39;&#xA;&#xA; mean temp: 34.5&#xA;&#xA;&#xA; $ &amp;lt;run.vnl vnl-filter -p x,y | feedgnuplot --terminal &#39;dumb 80,30&#39; --unset grid --domain --lines --exit&#xA;&#xA;   2.3 +---------------------------------------------------------------------+&#xA;       |           +          +          ***************         +           |&#xA;       |                                                **************       |&#xA;       |                                                              *******|&#xA;   2.2 |-+                                                       ************|&#xA;       |                                                 ********            |&#xA;       |                                         ********                    |&#xA;   2.1 |-+                              *********                          +-|&#xA;       |                        ********                                     |&#xA;       |                ********                                             |&#xA;       |            ****                                                     |&#xA;     2 |-+         *                                                       +-|&#xA;       |           *                                                         |&#xA;       |           *                                                         |&#xA;       |           *                                                         |&#xA;   1.9 |-+         *                                                       +-|&#xA;       |           *                                                         |&#xA;       |           *                                                         |&#xA;       |           *                                                         |&#xA;   1.8 |-+         *                                                       +-|&#xA;       |           *                                                         |&#xA;       |           *                                                         |&#xA;   1.7 |-+         *                                                       +-|&#xA;       |           *                                                         |&#xA;       |           *                                                         |&#xA;       |           *          +           +           +          +           |&#xA;   1.6 +---------------------------------------------------------------------+&#xA;      0.98         1         1.02        1.04        1.06       1.08        1.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION This tool is largely a frontend for awk to operate on vnlog files. Vnlog is both an input and an output. This tool makes it very simple to select specific rows and columns for output and to manipulate the data in various ways.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This is a UNIX-style tool, so the input/output of this tool is strictly&#xA;STDIN/STDOUT. Furthermore, in its usual form this tool is a filter, so&#xA;the format of the output is *exactly* the same as the format of the&#xA;input. The exception to this is when using &#34;--eval&#34;, in which the output&#xA;is dependent on whatever expression we&#39;re evaluating.&#xA;&#xA;This tool is convenient to process both stored data or live data; in the&#xA;latter case, it&#39;s very useful to pipe the streaming output to&#xA;&#34;feedgnuplot --stream&#34; to get a realtime visualization of the incoming&#xA;data.&#xA;&#xA;This tool reads enough of the input file to get a legend, at which point&#xA;it constructs an awk program to do the main work, and execs to awk (it&#39;s&#xA;possible to use perl as well, but this isn&#39;t as fast).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Input/output data format The input/output data is vnlog: a plain-text table of values. Any lines beginning with &#34;#&#34; are treated as comments, and are passed through. The first line that begins with &#34;#&#34; but not &#34;##&#34; or &#34;#!&#34; is a &lt;em&gt;legend&lt;/em&gt; line. After the &#34;#&#34;, follow whitespace-separated field names. Each subsequent line is whitespace-separated values matching this legend. For instance, this is a valid vnlog file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; #!/usr/bin/something&#xA; ## more comments&#xA; # x y z&#xA; -0.016107 0.004362 0.005369&#xA; -0.017449 0.006711 0.006711&#xA; -0.018456 0.014093 0.006711&#xA; -0.017449 0.018791 0.006376&#xA;&#xA;&#34;vnl-filter&#34; uses this format for both the input and the output. The&#xA;comments are preserved, but the legend is updated to reflect the fields&#xA;in the output file.&#xA;&#xA;A string &#34;-&#34; is used to indicate an undefined value, so this is also a&#xA;valid vnlog file:&#xA;&#xA; # x y z&#xA; 1 2 3&#xA; 4 - 6&#xA; - - 7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Filtering To select specific &lt;em&gt;columns&lt;/em&gt;, pass their names to the &#34;-p&#34; option (short for &#34;--print&#34; or &#34;--pick&#34;, which are synonyms). In its simplest form, to grab only columns &#34;x&#34; and &#34;y&#34;, do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; vnl-filter -p x,y&#xA;&#xA;See the detailed description of &#34;-p&#34; below for more detail.&#xA;&#xA;To select specific *rows*, we use *matches* expressions. Anything on the&#xA;&#34;vnl-filter&#34; commandline and not attached to any &#34;--xxx&#34; option is such&#xA;an expression. For instance&#xA;&#xA; vnl-filter &#39;size &amp;gt; 10&#39;&#xA;&#xA;would select only those rows whose &#34;size&#34; column contains a value &amp;gt; 10.&#xA;See the detailed description of matches expressions below for more&#xA;detail.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Context lines &#34;vnl-filter&#34; supports the context output options (&#34;-A&#34;, &#34;-B&#34; and &#34;-C&#34;) exactly like the &#34;grep&#34; tool. I.e to print out all rows whose &#34;size&#34; column contains a value &amp;gt; 10 &lt;em&gt;but also&lt;/em&gt; include the 3 rows immediately before &lt;em&gt;and&lt;/em&gt; after such matching rows, do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; vnl-filter -C3 &#39;size &amp;gt; 10&#39;&#xA;&#xA;&#34;-B&#34; reports the rows *before* matching ones and &#34;-A&#34; the rows *after*&#xA;matching ones. &#34;-C&#34; reports both. Note that this applies *only* to&#xA;*matches* expressions: records skipped because they fail &#34;--has&#34; or&#xA;&#34;--skipempty&#34; are *not* included in contextual output.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Backend choice By default, the parsing of arguments and the legend happens in perl, which then constructs a simple awk script, and invokes &#34;mawk&#34; to actually read the data and to process it. This is done because awk is lighter weight and runs faster, which is important because our data sets could be quite large. We default to &#34;mawk&#34; specifically, since this is a simpler implementation than &#34;gawk&#34;, and runs much faster. If for whatever reason we want to do everything with perl, this can be requested with the &#34;--perl&#34; option.&lt;/p&gt; &#xA;&lt;p&gt;Special functions For convenience we support several special functions in any expression passed on to awk or perl (named expressions, matches expressions, &#34;--eval&#34; strings). These generally maintain some internal state, and vnl-filter makes sure that this state is consistent. Note that these are evaluated &lt;em&gt;after&lt;/em&gt; &#34;--skipcomments&#34; and &#34;--has&#34;. So any record skipped because of a &#34;--has&#34; expression, for instance, will &lt;em&gt;not&lt;/em&gt; be considered in &#34;prev()&#34;, &#34;diff()&#34; and so on.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   rel(x) returns value of &#34;x&#34; relative to the first value of &#34;x&#34;. For&#xA;    instance we might want to see the time or position relative to the&#xA;    start, not relative to some absolute beginning. Example:&#xA;&#xA;     $ cat tst.vnl&#xA;&#xA;     # time x&#xA;     100    200&#xA;     101    212&#xA;     102    209&#xA;&#xA;&#xA;     $ &amp;lt;tst.vnl vnl-filter -p &#39;t=rel(time),x=rel(x)&#xA;&#xA;     # t x&#xA;     0 0&#xA;     1 12&#xA;     2 9&#xA;&#xA;*   diff(x) returns the difference between the current value of &#34;x&#34; and&#xA;    the previous value of &#34;x&#34;. The first row will always be &#34;-&#34;.&#xA;    Example:&#xA;&#xA;     $ &amp;lt;tst.vnl vnl-filter -p x,&#39;d1=diff(x),d2=diff(diff(x))&#39; | vnl-align&#xA;&#xA;     # x d1 d2&#xA;       1  -  -&#xA;       8  7  7&#xA;      27 19 12&#xA;      64 37 18&#xA;     125 61 24&#xA;&#xA;*   sum(x) returns the cumulative sum of &#34;x&#34;. As diff(x) can be thought&#xA;    of as a derivative, sum(x) can be thought of as an integral. So&#xA;    &#34;diff(sum(x))&#34; would return the same value as &#34;x&#34; (except for the&#xA;    first row; &#34;diff()&#34; always returns &#34;-&#34; for the first row).&#xA;&#xA;    Example:&#xA;&#xA;     $ &amp;lt;tst.vnl vnl-filter -p &#39;x,s=sum(x),ds=diff(sum(x))&#39; | vnl-align&#xA;&#xA;     # x  s   ds&#xA;       1   1   -&#xA;       8   9   8&#xA;      27  36  27&#xA;      64 100  64&#xA;     125 225 125&#xA;&#xA;*   prev(x) returns the previous value of &#34;x&#34;. One could construct&#xA;    &#34;sum()&#34; and &#34;rel()&#34; using this, if they weren&#39;t already available.&#xA;&#xA;*   latestdefined(x) returns the most recent value of &#34;x&#34; that isn&#39;t&#xA;    &#34;-&#34;. If &#34;x&#34; isn&#39;t &#34;-&#34;, this simply returns &#34;x&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ARGUMENTS Matches expressions Anything on the commandline not attached to any &#34;--xxx&#34; option is a &lt;em&gt;matches&lt;/em&gt; expression. These are used to select particular records (rows) in a data file. For each row, we evaluate all the expressions. If &lt;em&gt;all&lt;/em&gt; the expressions evaluate to true, that row is output. This expression is passed directly to the awk (or perl) backend.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Example: to select all rows that have valid data in column &#34;a&#34; *or*&#xA;column &#34;b&#34; *or* column &#34;c&#34; you can&#xA;&#xA; vnl-filter &#39;a != &#34;-&#34; || b != &#34;-&#34; || c != &#34;-&#34;&#39;&#xA;&#xA;or&#xA;&#xA; vnl-filter --perl &#39;defined a || defined b || defined c&#39;&#xA;&#xA;As with the named expressions given to &#34;-p&#34; (described above), these are&#xA;passed directly to awk, so anything that can be done with awk is&#xA;supported here.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;-p|--print|--pick expr These option provide the mechanism to select specific columns for output. For instance to pull out columns called &#34;lat&#34;, &#34;lon&#34;, and any column whose name contains the string &#34;feature_&#34;, do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; vnl-filter -p lat,lon,&#39;feature_.*&#39;&#xA;&#xA;or, equivalently&#xA;&#xA; vnl-filter --print lat --print lon --print &#39;feature_.*&#39;&#xA;&#xA;We look for exact column name matches first, and if none are found, we&#xA;try a regex. If there was no column called exactly &#34;feature_&#34;, then the&#xA;above would be equivalent to&#xA;&#xA; vnl-filter -p lat,lon,feature_&#xA;&#xA;This mechanism is much more powerful than just selecting columns. First&#xA;off, we can rename chosen fields:&#xA;&#xA; vnl-filter -p w=feature_width&#xA;&#xA;would pick the &#34;feature_width&#34; field, but the resulting column in the&#xA;output would be named &#34;w&#34;. When renaming a column in this way regexen&#xA;are *not* supported, and exact field names must be given. But the string&#xA;to the right of the &#34;=&#34; is passed on directly to awk (after replacing&#xA;field names with column indices), so any awk expression can be used&#xA;here. For instance to compute the length of a vector in separate columns&#xA;&#34;x&#34;, &#34;y&#34;, and &#34;z&#34; you can do:&#xA;&#xA; vnl-filter -p &#39;l=sqrt(x*x + y*y + z*z)&#39;&#xA;&#xA;A single column called &#34;l&#34; would be produced.&#xA;&#xA;We can also *exclude* columns by preceding their name with &#34;!&#34;. This&#xA;works like you expect. Rules:&#xA;&#xA;*   The pick/exclude directives are processed in order given to produce&#xA;    the output picked-column list&#xA;&#xA;*   If the first &#34;-p&#34; item is an exclusion, we implicitly pick *all* the&#xA;    columns prior to processing the &#34;-p&#34;.&#xA;&#xA;*   The exclusion expressions match the *output* column names, not the&#xA;    *input* names.&#xA;&#xA;*   We match the exact column names first. If that fails, we match as a&#xA;    regex&#xA;&#xA;Example. To grab all the columns *except* the temperature(s) do this:&#xA;&#xA; vnl-filter -p !temperature&#xA;&#xA;To grab all the columns that describe *something* about a robot (columns&#xA;whose names have the string &#34;robot_&#34; in them), but *not* its temperature&#xA;(i.e. *not* &#34;robot_temperature&#34;), do this:&#xA;&#xA; vnl-filter -p robot_,!temperature&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;--has a,b,c,... Used to select records (rows) that have a non-empty value in a particular field (column). A &lt;em&gt;null&lt;/em&gt; value in a column is designated with a single &#34;-&#34;. If we want to select only records that have a value in the &#34;x&#34; column, we pass &#34;--has x&#34;. To select records that have data for &lt;em&gt;all&lt;/em&gt; of a given set of columns, the &#34;--has&#34; option can be repeated, or these multiple columns can be given in a whitespace-less comma-separated list. For instance if we want only records that have data in &lt;em&gt;both&lt;/em&gt; columns &#34;x&#34; &lt;em&gt;and&lt;/em&gt; &#34;y&#34; we can pass in &#34;--has x,y&#34; or &#34;--has x --has y&#34;. If we want to combine multiple columns in an &lt;em&gt;or&lt;/em&gt; (select rows that have data in &lt;em&gt;any&lt;/em&gt; of a given set of columns), use a matches expression, as documented below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;If we want to select a column *and* pick only rows that have a value in&#xA;this column, a shorthand syntax exists:&#xA;&#xA; vnl-filter --has col -p col&#xA;&#xA;is equivalent to&#xA;&#xA; vnl-filter -p +col&#xA;&#xA;Note that just like the column specifications in &#34;-p&#34; the columns given&#xA;to &#34;--has&#34; must match exactly *or* as a regex. In either case, a unique&#xA;matching column must be found.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;-l|list-columns Instead of doing any processing, parse the input to get the available columns, print those out, and exit&lt;/p&gt; &#xA;&lt;p&gt;-A N|--after-context N Output N lines following each &lt;em&gt;matches&lt;/em&gt; expression, even those lines that do not themselves match. This works just like the &#34;grep&#34; options of the same name. See &#34;Context lines&#34;&lt;/p&gt; &#xA;&lt;p&gt;-B N|--before-context N Output N lines preceding each &lt;em&gt;matches&lt;/em&gt; expression, even those lines that do not themselves match. This works just like the &#34;grep&#34; options of the same name. See &#34;Context lines&#34;&lt;/p&gt; &#xA;&lt;p&gt;-C N|--context N Output N lines preceding and following each &lt;em&gt;matches&lt;/em&gt; expression, even those lines that do not themselves match. This works just like the &#34;grep&#34; options of the same name. See &#34;Context lines&#34;&lt;/p&gt; &#xA;&lt;p&gt;--eval expr Instead of printing out all matching records and picked columns, just run the given chunk of awk (or perl). In this mode of operation, &#34;vnl-filter&#34; acts just like a glorified awk, that allows fields to be accessed by name instead of by number, as it would be in raw awk.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Since the expression may print *anything* or nothing at all, the output&#xA;in this mode is not necessarily itself a valid vnlog stream. And no&#xA;column-selecting arguments should be given, since they make no sense in&#xA;this mode.&#xA;&#xA;In awk the expr is a full set of pattern/action statements. So to print&#xA;the sum of columns &#34;a&#34; and &#34;b&#34; in each row, and at the end, print the&#xA;sum of all values in the &#34;a&#34; column&#xA;&#xA; vnl-filter --eval &#39;{print a+b; suma += a} END {print suma}&#39;&#xA;&#xA;In perl the arbitrary expression fits in like this:&#xA;&#xA; sub evalexpr&#xA; {&#xA;   eval expression;     # evaluate the arbitrary expression&#xA; }&#xA; while(&amp;lt;&amp;gt;) # read each line&#xA; {&#xA;   chomp;&#xA;   next unless matches; # skip non-matching lines&#xA;   evalexpr();&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;--function|--sub Evaluates the given expression as a function that can be used in other expressions. This is most useful when you want to print something that can&#39;t trivially be written as a simple expression. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; $ cat tst.vnl&#xA; # s&#xA; 1-2&#xA; 3-4&#xA; 5-6&#xA;&#xA; $ &amp;lt; tst.vnl&#xA;   vnl-filter --function &#39;before(x) { sub(&#34;-.*&#34;,&#34;&#34;,x); return x }&#39; \&#xA;              --function &#39;after(x)  { sub(&#34;.*-&#34;,&#34;&#34;,x); return x }&#39; \&#xA;              -p &#39;b=before(s),a=after(s)&#39;&#xA; # b a&#xA; 1 2&#xA; 3 4&#xA; 5 6&#xA;&#xA;See the CAVEATS section below if you&#39;re doing something&#xA;sufficiently-complicated where you need this.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;--function-abs|--sub-abs Convenience option to add an absolute-value &#34;abs()&#34; function. This is only useful for awk programs (the default, no &#34;--perl&#34; given) since perl already provides &#34;abs()&#34; by default.&lt;/p&gt; &#xA;&lt;p&gt;--begin|--BEGIN Evaluates the given expression in the BEGIN {} block of the generated awk (or perl) program.&lt;/p&gt; &#xA;&lt;p&gt;--end|--END Evaluates the given expression in the END {} block of the generated awk (or perl) program.&lt;/p&gt; &#xA;&lt;p&gt;--[no]skipempty Do [not] skip records where all fields are blank. By default we &lt;em&gt;do&lt;/em&gt; skip all empty records; to include them, pass &#34;--noskipempty&#34;&lt;/p&gt; &#xA;&lt;p&gt;--skipcomments Don&#39;t output non-legend comments&lt;/p&gt; &#xA;&lt;p&gt;--perl By default all procesing is performed by &#34;mawk&#34;, but if for whatever reason we want perl instead, pass &#34;--perl&#34;. Both modes work, but &#34;mawk&#34; is noticeably faster. &#34;--perl&#34; could be useful because it is more powerful, which could be important since a number of things pass commandline strings directly to the underlying language (named expressions, matches expressions, &#34;--eval&#34; strings). Note that while variables in perl use sigils, column references should &lt;em&gt;not&lt;/em&gt; use sigils. To print the sum of all values in column &#34;a&#34; you&#39;d do this in awk&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; vnl-filter --eval &#39;{suma += a} END {print suma}&#39;&#xA;&#xA;and this in perl&#xA;&#xA; vnl-filter --perl --eval &#39;{$suma += a} END {say $suma}&#39;&#xA;&#xA;The perl strings are evaluated without &#34;use strict&#34; or &#34;use warnings&#34; so&#xA;I didn&#39;t have to declare $suma in the example.&#xA;&#xA;With &#34;--perl&#34;, empty strings (&#34;-&#34; in the vnlog file) are converted to&#xA;&#34;undef&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;--dumpexprs Used for debugging. This spits out all the final awk (or perl) program we run for the given commandline options and given input. This is the final program, with the column references resolved to numeric indices, so one can figure out what went wrong.&lt;/p&gt; &#xA;&lt;p&gt;--unbuffered Flushes each line after each print. This makes sure each line is output as soon as it is available, which is crucial for realtime output and streaming plots.&lt;/p&gt; &#xA;&lt;p&gt;--stream Synonym for &#34;--unbuffered&#34;&lt;/p&gt; &#xA;&lt;p&gt;CAVEATS This tool is very lax in its input validation (on purpose). As a result, columns with names like %CPU and &#34;TIME+&#34; do work (i.e. you can more or less feed in output from &#34;top -b&#34;). The downside is that shooting yourself in the foot is possible. This tradeoff is currently tuned to be very permissive, which works well for my use cases. I&#39;d be interested in hearing other people&#39;s experiences. Potential pitfalls/unexpected behaviors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   All column names are replaced in all eval strings without regard to&#xA;    context. The earlier example that reports the sum of values in a&#xA;    column: &#34;vnl-filter --eval &#39;{suma += a} END {print suma}&#39;&#34; will work&#xA;    fine if we *do* have a column named &#34;a&#34; and do *not* have a column&#xA;    named &#34;suma&#34;. But will not do the right thing if any of those are&#xA;    violated. For instance, if a column &#34;a&#34; doesn&#39;t exist, then &#34;awk&#34;&#xA;    would see &#34;suma += a&#34; instead of something like &#34;suma += $5&#34;. &#34;a&#34;&#xA;    would be an uninitialized variable, which evaluates to 0, so the&#xA;    full &#34;vnl-filter&#34; command would not fail, but would print 0 instead.&#xA;    It&#39;s the user&#39;s responsibility to make sure we&#39;re talking about the&#xA;    right columns. The focus here was one-liners so hopefully nobody has&#xA;    so many columns, they can&#39;t keep track of all of them in their head.&#xA;    I don&#39;t see any way to resolve this without seriously impacting the&#xA;    scope of the tool, so I&#39;m leaving this alone.&#xA;&#xA;*   It is natural to use vnlog as a database. You can run queries with&#xA;    something like&#xA;&#xA;     vnl-filter &#39;key == 5&#39;&#xA;&#xA;    This works. But unlike a real database this is clearly a linear&#xA;    lookup. With large data files, this would be significantly slower&#xA;    than the logarithmic searches provided by a real database. The&#xA;    meaning of &#34;large&#34; and &#34;significant&#34; varies, and you should test it.&#xA;    In my experience vnlog &#34;databases&#34; scale surprisingly well. But at&#xA;    some point, importing your data to something like sqlite is well&#xA;    worth it.&#xA;&#xA;*   When substituting column names I match *either* a word-nonword&#xA;    transition (&#34;\b&#34;) *or* a whitespace-nonword transition. The word&#xA;    boundaries is what would be used 99% of the time. But the keys may&#xA;    have special characters in them, which don&#39;t work with &#34;\b&#34;. This&#xA;    means that whitespace becomes important: &#34;1+%CPU&#34; will not be parsed&#xA;    as expected, which is correct since &#34;+%CPU&#34; is also a valid field&#xA;    name. But &#34;1+ %CPU&#34; will be parsed correctly, so if you have weird&#xA;    field names, put the whitespace into your expressions. It&#39;ll make&#xA;    them more readable anyway.&#xA;&#xA;*   Strings passed to &#34;-p&#34; are split on &#34;,&#34; *except* if the &#34;,&#34; is&#xA;    inside balanced &#34;()&#34;. This makes it possible to say things like&#xA;    &#34;vnl-filter --function &#39;f(a,b) { ... }&#39; -p &#39;c=f(a,b)&#39;&#34;. This is&#xA;    probably the right behavior, although some questionable looking&#xA;    field names become potentially impossible: &#34;f(a&#34; and &#34;b)&#34; *could*&#xA;    otherwise be legal field names, but you&#39;re probably asking for&#xA;    trouble if you do that.&#xA;&#xA;*   Currently there&#39;re two modes: a pick/print mode and an &#34;--eval&#34;&#xA;    mode. Then there&#39;s also &#34;--function&#34;, which adds bits of &#34;--eval&#34; to&#xA;    the pick/print mode, but it feels maybe insufficient. I don&#39;t yet&#xA;    have strong feelings about what this should become. Comments welcome&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-align #+BEGIN_EXAMPLE NAME vnl-align - aligns vnlog columns for easy interpretation by humans&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ cat tst.vnl&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; # w x y z&#xA; -10 40 asdf -&#xA; -20 50 - 0.300000&#xA; -30 10 whoa 0.500000&#xA;&#xA;&#xA; $ vnl-align tst.vnl&#xA;&#xA; # w  x   y      z&#xA; -10 40 asdf -&#xA; -20 50 -    0.300000&#xA; -30 10 whoa 0.500000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION The basic usage is&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; vnl-align logfile&#xA;&#xA;The arguments are assumed to be the vnlog files. If no arguments are&#xA;given, the input comes from STDIN.&#xA;&#xA;This is very similar to &#34;column -t&#34;, but handles &#34;#&#34; lines properly:&#xA;&#xA;1. The first &#34;#&#34; line is the legend. For the purposes of alignment, the&#xA;leading &#34;#&#34; character and the first column label are treated as one&#xA;column&#xA;&#xA;2. All other &#34;#&#34; lines are output verbatim.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-sort #+BEGIN_EXAMPLE NAME vnl-sort - sorts an vnlog file, preserving the legend&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ cat a.vnl # a b AA 11 bb 12 CC 13 dd 14 dd 123&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Sort lexically by a:&#xA; $ &amp;lt;a.vnl vnl-sort -k a&#xA; # a b&#xA; AA 11&#xA; CC 13&#xA; bb 12&#xA; dd 123&#xA; dd 14&#xA;&#xA; Sort lexically by a, ignoring case:&#xA; $ &amp;lt;a.vnl vnl-sort -k a --ignore-case&#xA; # a b&#xA; AA 11&#xA; bb 12&#xA; CC 13&#xA; dd 123&#xA; dd 14&#xA;&#xA; Sort lexically by a, then numerically by b:&#xA; $ &amp;lt;a.vnl vnl-sort -k a -k b.n&#xA; # a b&#xA; AA 11&#xA; CC 13&#xA; bb 12&#xA; dd 14&#xA; dd 123&#xA;&#xA; Sort lexically by a, then numerically by b in reverse:&#xA; $ &amp;lt;a.vnl vnl-sort -k a -k b.nr&#xA; # a b&#xA; AA 11&#xA; CC 13&#xA; bb 12&#xA; dd 123&#xA; dd 14&#xA;&#xA;&#xA; Sort by month and then day:&#xA; $ cat dat.vnl&#xA; # month day&#xA; March 5&#xA; Jan 2&#xA; Feb 1&#xA; March 30&#xA; Jan 21&#xA;&#xA; $ &amp;lt;dat.vnl vnl-sort -k month.M -k day.n&#xA; # month day&#xA; Jan 2&#xA; Jan 21&#xA; Feb 1&#xA; March 5&#xA; March 30&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION Usage: vnl-sort [options] logfile logfile logfile ... &amp;lt; logfile&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This tool sorts given vnlog files in various ways. &#34;vnl-sort&#34; is a&#xA;wrapper around the GNU coreutils &#34;sort&#34; tool. Since this is a wrapper,&#xA;most commandline options and behaviors of the &#34;sort&#34; tool are present;&#xA;consult the sort(1) manpage for detail. The differences from GNU&#xA;coreutils &#34;sort&#34; are&#xA;&#xA;*   The input and output to this tool are vnlog files, complete with a&#xA;    legend&#xA;&#xA;*   The columns are referenced by name, not index. So instead of saying&#xA;&#xA;      sort -k1&#xA;&#xA;    to sort by the first column, you say&#xA;&#xA;      sort -k time&#xA;&#xA;    to sort by column &#34;time&#34;.&#xA;&#xA;*   The fancy &#34;KEYDEF&#34; spec from &#34;sort&#34; is only partially supported. I&#xA;    only allow us to sort by full *fields*, so the start/stop positions&#xA;    don&#39;t make sense. I *do* support the &#34;OPTS&#34; to change the type of&#xA;    sorting in a given particular column. For instance, to sort by month&#xA;    and then by day, do this (see example above):&#xA;&#xA;      vnl-sort -k month.M -k day.n&#xA;&#xA;*   &#34;--files0-from&#34; is not supported due to lack of time. If somebody&#xA;    really needs it, talk to me.&#xA;&#xA;*   &#34;--output&#34; is not supported due to an uninteresting technical&#xA;    limitation. The output always goes to standard out.&#xA;&#xA;*   &#34;--field-separator&#34; is not supported because vnlog assumes&#xA;    whitespace-separated fields&#xA;&#xA;*   &#34;--zero-terminated&#34; is not supported because vnlog assumes&#xA;    newline-separated records&#xA;&#xA;*   By default we call the &#34;sort&#34; tool to do the actual work. If the&#xA;    underlying tool has a different name or lives in an odd path, this&#xA;    can be specified by passing &#34;--vnl-tool TOOL&#34;&#xA;&#xA;Past that, everything &#34;sort&#34; does is supported, so see that man page for&#xA;detailed documentation. Note that all non-legend comments are stripped&#xA;out, since it&#39;s not obvious where they should end up.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;COMPATIBILITY I use GNU/Linux-based systems exclusively, but everything has been tested functional on FreeBSD and OSX in addition to Debian, Ubuntu and CentOS. I can imagine there&#39;s something I missed when testing on non-Linux systems, so please let me know if you find any issues.&lt;/p&gt; &#xA;&lt;p&gt;SEE ALSO sort(1)&lt;/p&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-join #+BEGIN_EXAMPLE NAME vnl-join - joins two log files on a particular field&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ cat a.vnl # a b AA 11 bb 12 CC 13 dd 14 dd 123&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; $ cat b.vnl&#xA; # a c&#xA; aa 1&#xA; cc 3&#xA; bb 4&#xA; ee 5&#xA; - 23&#xA;&#xA; Try to join unsorted data on field &#39;a&#39;:&#xA; $ vnl-join -j a a.vnl b.vnl&#xA; # a b c&#xA; join: /dev/fd/5:3: is not sorted: CC 13&#xA; join: /dev/fd/6:3: is not sorted: bb 4&#xA;&#xA; Sort the data, and join on &#39;a&#39;:&#xA; $ vnl-join --vnl-sort - -j a a.vnl b.vnl | vnl-align&#xA; # a  b c&#xA; bb  12 4&#xA;&#xA; Sort the data, and join on &#39;a&#39;, ignoring case:&#xA; $ vnl-join -i --vnl-sort - -j a a.vnl b.vnl | vnl-align&#xA; # a b c&#xA; AA 11 1&#xA; bb 12 4&#xA; CC 13 3&#xA;&#xA; Sort the data, and join on &#39;a&#39;. Also print the unmatched lines from both files:&#xA; $ vnl-join -a1 -a2 --vnl-sort - -j a a.vnl b.vnl | vnl-align&#xA; # a  b   c&#xA; -   -   23&#xA; AA   11 -&#xA; CC   13 -&#xA; aa  -    1&#xA; bb   12  4&#xA; cc  -    3&#xA; dd  123 -&#xA; dd   14 -&#xA; ee  -    5&#xA;&#xA; Sort the data, and join on &#39;a&#39;. Print the unmatched lines from both files,&#xA; Output ONLY column &#39;c&#39; from the 2nd input:&#xA; $ vnl-join -a1 -a2 -o 2.c --vnl-sort - -j a a.vnl b.vnl | vnl-align&#xA; # c&#xA; 23&#xA; -&#xA; -&#xA;  1&#xA;  4&#xA;  3&#xA; -&#xA; -&#xA;  5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION Usage: vnl-join [join options] [--vnl-sort -|[sdfgiMhnRrV]+] [ --vnl-[pre|suf]fix[1|2] xxx | --vnl-[pre|suf]fix xxx,yyy,zzz | --vnl-autoprefix | --vnl-autosuffix ] logfile1 logfile2&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This tool joins two vnlog files on a given field. &#34;vnl-join&#34; is a&#xA;wrapper around the GNU coreutils &#34;join&#34; tool. Since this is a wrapper,&#xA;most commandline options and behaviors of the &#34;join&#34; tool are present;&#xA;consult the join(1) manpage for detail. The differences from GNU&#xA;coreutils &#34;join&#34; are&#xA;&#xA;*   The input and output to this tool are vnlog files, complete with a&#xA;    legend&#xA;&#xA;*   The columns are referenced by name, not index. So instead of saying&#xA;&#xA;      join -j1&#xA;&#xA;    to join on the first column, you say&#xA;&#xA;      join -j time&#xA;&#xA;    to join on column &#34;time&#34;.&#xA;&#xA;*   -1 and -2 are supported, but *must* refer to the same field. Since&#xA;    vnlog knows the identify of each field, it makes no sense for -1 and&#xA;    -2 to be different. So pass &#34;-j&#34; instead, it makes more sense in&#xA;    this context.&#xA;&#xA;*   &#34;-a-&#34; is available as a shorthand for &#34;-a1 -a2&#34;: this is a full&#xA;    outer join, printing unmatched records from both of the inputs.&#xA;    Similarly, &#34;-v-&#34; is available as a shorthand for &#34;-v1 -v2&#34;: this&#xA;    will output *only* the unique records in both of the inputs.&#xA;&#xA;*   &#34;vnl-join&#34;-specific options are available to adjust the field-naming&#xA;    in the output:&#xA;&#xA;      --vnl-prefix1&#xA;      --vnl-suffix1&#xA;      --vnl-prefix2&#xA;      --vnl-suffix2&#xA;      --vnl-prefix&#xA;      --vnl-suffix&#xA;      --vnl-autoprefix&#xA;      --vnl-autosuffix&#xA;&#xA;    See &#34;Field names in the output&#34; below for details.&#xA;&#xA;*   A &#34;vnl-join&#34;-specific option &#34;--vnl-sort&#34; is available to sort the&#xA;    input and/or output. See below for details.&#xA;&#xA;*   By default we call the &#34;join&#34; tool to do the actual work. If the&#xA;    underlying tool has a different name or lives in an odd path, this&#xA;    can be specified by passing &#34;--vnl-tool TOOL&#34;&#xA;&#xA;*   If no &#34;-o&#34; is given, we output the join field, the remaining fields&#xA;    in logfile1, the remaining fields in logfile2, .... This is what &#34;-o&#xA;    auto&#34; does, except we also handle empty vnlogs correctly.&#xA;&#xA;*   &#34;-e&#34; is not supported because vnlog uses &#34;-&#34; to represent undefined&#xA;    fields.&#xA;&#xA;*   &#34;--header&#34; is not supported because vnlog assumes a specific header&#xA;    structure, and &#34;vnl-join&#34; makes sure that this header is handled&#xA;    properly&#xA;&#xA;*   &#34;-t&#34; is not supported because vnlog assumes whitespace-separated&#xA;    fields&#xA;&#xA;*   &#34;--zero-terminated&#34; is not supported because vnlog assumes&#xA;    newline-separated records&#xA;&#xA;*   Rather than only 2-way joins, this tool supports N-way joins for any&#xA;    N &amp;gt; 2. See below for details.&#xA;&#xA;Past that, everything &#34;join&#34; does is supported, so see that man page for&#xA;detailed documentation. Note that all non-legend comments are stripped&#xA;out, since it&#39;s not obvious where they should end up.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Field names in the output By default, the field names in the output match those in the input. This is what you want most of the time. It is possible, however that a column name adjustment is needed. One common use case for this is if the files being joined have identically-named columns, which would produce duplicate columns in the output. Example: we fixed a bug in a program, and want to compare the results before and after the fix. The program produces an x-y trajectory as a function of time, so both the bugged and the bug-fixed programs produce a vnlog with a legend&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; # time x y&#xA;&#xA;Joining this on &#34;time&#34; will produce a vnlog with a legend&#xA;&#xA; # time x y x y&#xA;&#xA;which is confusing, and *not* what you want. Instead, we invoke&#xA;&#34;vnl-join&#34; as&#xA;&#xA; vnl-join --vnl-suffix1 _buggy --vnl-suffix2 _fixed -j time buggy.vnl fixed.vnl&#xA;&#xA;And in the output we get a legend&#xA;&#xA; # time x_buggy y_buggy x_fixed y_fixed&#xA;&#xA;Much better.&#xA;&#xA;Note that &#34;vnl-join&#34; provides several ways of specifying this. The above&#xA;works *only* for 2-way joins. An alternate syntax is available for N-way&#xA;joins, a comma-separated list. The same could be expressed like this:&#xA;&#xA; vnl-join -a- --vnl-suffix _buggy,_fixed -j time buggy.vnl fixed.vnl&#xA;&#xA;Finally, if passing in structured filenames, &#34;vnl-join&#34; can infer the&#xA;desired syntax from the filenames. The same as above could be expressed&#xA;even simpler:&#xA;&#xA; vnl-join --vnl-autosuffix -j time buggy.vnl fixed.vnl&#xA;&#xA;This works by looking at the set of passed in filenames, and stripping&#xA;out the common leading and trailing strings.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sorting of input and output The GNU coreutils &#34;join&#34; tool expects sorted columns because it can then take only a single pass through the data. If the input isn&#39;t sorted, then we can use normal shell substitutions to sort it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; $ vnl-join -j key &amp;lt;(vnl-sort -s -k key a.vnl) &amp;lt;(vnl-sort -s -k key b.vnl)&#xA;&#xA;For convenience &#34;vnl-join&#34; provides a &#34;--vnl-sort&#34; option. This allows&#xA;the above to be equivalently expressed as&#xA;&#xA; $ vnl-join -j key --vnl-sort - a.vnl b.vnl&#xA;&#xA;The &#34;-&#34; after the &#34;--vnl-sort&#34; indicates that we want to sort the&#xA;*input* only. If we also want to sort the output, pass the short codes&#xA;&#34;sort&#34; accepts instead of the &#34;-&#34;. For instance, to sort the input for&#xA;&#34;join&#34; and to sort the output numerically, in reverse, do this:&#xA;&#xA; $ vnl-join -j key --vnl-sort rg a.vnl b.vnl&#xA;&#xA;The reason this shorthand exists is to work around a quirk of &#34;join&#34;.&#xA;The sort order is *assumed* by &#34;join&#34; to be lexicographical, without any&#xA;way to change this. For &#34;sort&#34;, this is the default sort order, but&#xA;&#34;sort&#34; has many options to change the sort order, options which are&#xA;sorely missing from &#34;join&#34;. A real-world example affected by this is the&#xA;joining of numerical data. If you have &#34;a.vnl&#34;:&#xA;&#xA; # time a&#xA; 8 a&#xA; 9 b&#xA; 10 c&#xA;&#xA;and &#34;b.vnl&#34;:&#xA;&#xA; # time b&#xA; 9  d&#xA; 10 e&#xA;&#xA;Then you cannot use &#34;vnl-join&#34; directly to join the data on time:&#xA;&#xA; $ vnl-join -j time a.vnl b.vnl&#xA; # time a b&#xA; join: /dev/fd/4:3: is not sorted: 10 c&#xA; join: /dev/fd/5:2: is not sorted: 10 e&#xA; 9 b d&#xA; 10 c e&#xA;&#xA;Instead you must re-sort both files lexicographically, *and* then&#xA;(because you almost certainly want to) sort it back into numerical&#xA;order:&#xA;&#xA; $ vnl-join -j time &amp;lt;(vnl-sort -s -k time a.vnl) &amp;lt;(vnl-sort -s -k time b.vnl) |&#xA;   vnl-sort -s -n -k time&#xA; # time a b&#xA; 9 b d&#xA; 10 c e&#xA;&#xA;Yuck. The shorthand described earlier makes the interface part of this&#xA;palatable:&#xA;&#xA; $ vnl-join -j time --vnl-sort n a.vnl b.vnl&#xA; # time a b&#xA; 9 b d&#xA; 10 c e&#xA;&#xA;Note that the input sort is stable: &#34;vnl-join&#34; will invoke &#34;vnl-sort&#xA;-s&#34;. If you want a stable post-sort, you need to ask for it with&#xA;&#34;--vnl-sort s...&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;N-way joins The GNU coreutils &#34;join&#34; tool is inherently designed to join &lt;em&gt;exactly&lt;/em&gt; two files. &#34;vnl-join&#34; extends this capability by chaining together a number of &#34;join&#34; invocations to produce a generic N-way join. This works exactly how you would expect with the following caveats:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   Full outer joins are supported by passing &#34;-a-&#34;, but no other &#34;-a&#34;&#xA;    option is supported. This is possible, but wasn&#39;t obviously worth&#xA;    the trouble.&#xA;&#xA;*   &#34;-v&#34; is not supported. Again, this is possible, but wasn&#39;t obviously&#xA;    worth the trouble.&#xA;&#xA;*   Similarly, &#34;-o&#34; is not supported. This is possible, but wasn&#39;t&#xA;    obviously worth the trouble, especially since the desired behavior&#xA;    can be obtained by post-processing with &#34;vnl-filter&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;BUGS AND CAVEATS The underlying &#34;sort&#34; tool assumes lexicographic ordering, and matches fields purely based on their textual contents. This means that for the purposes of joining, 10, 10.0 and 1.0e1 are all considered different. If needed, you can normalize your keys with something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; vnl-filter -p x=&#39;sprintf(&#34;%f&#34;,x)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;COMPATIBILITY I use GNU/Linux-based systems exclusively, but everything has been tested functional on FreeBSD and OSX in addition to Debian, Ubuntu and CentOS. I can imagine there&#39;s something I missed when testing on non-Linux systems, so please let me know if you find any issues.&lt;/p&gt; &#xA;&lt;p&gt;SEE ALSO join(1)&lt;/p&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-tail #+BEGIN_EXAMPLE NAME vnl-tail - tail a log file, preserving the legend&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ read_temperature | tee temp.vnl # temperature 29.5 30.4 28.3 22.1 ... continually produces data&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ... at the same time, in another terminal&#xA; $ vnl-tail -f temp.vnl&#xA; # temperature&#xA; 28.3&#xA; 22.1&#xA; ... outputs data as it comes in&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION Usage: vnl-tail [options] logfile logfile logfile ... &amp;lt; logfile&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This tool runs &#34;tail&#34; on given vnlog files in various ways. &#34;vnl-tail&#34;&#xA;is a wrapper around the GNU coreutils &#34;tail&#34; tool. Since this is a&#xA;wrapper, most commandline options and behaviors of the &#34;tail&#34; tool are&#xA;present; consult the tail(1) manpage for detail. The differences from&#xA;GNU coreutils &#34;tail&#34; are&#xA;&#xA;*   The input and output to this tool are vnlog files, complete with a&#xA;    legend&#xA;&#xA;*   &#34;-c&#34; is not supported because vnlog really doesn&#39;t want to break up&#xA;    lines&#xA;&#xA;*   &#34;--zero-terminated&#34; is not supported because vnlog assumes&#xA;    newline-separated records&#xA;&#xA;*   By default we call the &#34;tail&#34; tool to do the actual work. If the&#xA;    underlying tool has a different name or lives in an odd path, this&#xA;    can be specified by passing &#34;--vnl-tool TOOL&#34;&#xA;&#xA;Past that, everything &#34;tail&#34; does is supported, so see that man page for&#xA;detailed documentation.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;COMPATIBILITY I use GNU/Linux-based systems exclusively, but everything has been tested functional on FreeBSD and OSX in addition to Debian, Ubuntu and CentOS. I can imagine there&#39;s something I missed when testing on non-Linux systems, so please let me know if you find any issues.&lt;/p&gt; &#xA;&lt;p&gt;SEE ALSO tail(1)&lt;/p&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-ts #+BEGIN_EXAMPLE NAME vnl-ts - add a timestamp to a vnlog stream&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ read_temperature # temperature 29.5 30.4 28.3 22.1 ... continually produces data at 1Hz&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; $ read_temperature | vnl-ts -s %.s&#xA; # time-rel temperature&#xA; 0.013893 30.2&#xA; 1.048695 28.6&#xA; 2.105592 29.3&#xA; 3.162873 22.0&#xA; ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION Usage: vnl-ts [-i | -s] [-m] [--vnl-field t] format &amp;lt; pipe&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This tool runs &#34;ts&#34; on given vnlog streams. &#34;vnl-ts&#34; is a wrapper around&#xA;the &#34;ts&#34; tool from Joey Hess&#39;s moreutils&#xA;&amp;lt;https://joeyh.name/code/moreutils/&amp;gt; toolkit. Since this is a wrapper,&#xA;most commandline options and behaviors of the &#34;ts&#34; tool are present;&#xA;consult the ts(1) manpage for details. The differences from &#34;ts&#34; are&#xA;&#xA;*   The input and output to this tool are vnlog files, complete with a&#xA;    legend&#xA;&#xA;*   The format *must* be passed-in by the user; no default is assumed.&#xA;&#xA;*   The given format *must not* contain whitespace, so that it fits a&#xA;    single vnlog field.&#xA;&#xA;*   &#34;-r&#34; is not supported: it assumes input timestamps with whitespace,&#xA;    which is incompatible with vnlog&#xA;&#xA;*   A &#34;vnl-ts&#34;-specific option &#34;--vnl-field&#34; is available to set the&#xA;    name of the new field. If omitted, a reasonable default will be&#xA;    used.&#xA;&#xA;*   By default we call the &#34;ts&#34; tool to do the actual work. If the&#xA;    underlying tool has a different name or lives in an odd path, this&#xA;    can be specified by passing &#34;--vnl-tool TOOL&#34;&#xA;&#xA;Past that, everything &#34;ts&#34; does is supported, so see that man page for&#xA;detailed documentation.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;COMPATIBILITY By default this calls the tool named &#34;ts&#34;. At least on FreeBSD, it&#39;s called &#34;moreutils-ts&#34;, so on such systems you should invoke &#34;vnl-ts --vnl-tool moreutils-ts ...&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;I use GNU/Linux-based systems exclusively, but everything has been&#xA;tested functional on FreeBSD and OSX in addition to Debian, Ubuntu and&#xA;CentOS. I can imagine there&#39;s something I missed when testing on&#xA;non-Linux systems, so please let me know if you find any issues.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SEE ALSO ts(1)&lt;/p&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-uniq #+BEGIN_EXAMPLE NAME vnl-uniq - uniq a log file, preserving the legend&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ cat colors.vnl # color blue yellow yellow blue yellow orange orange&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; $ &amp;lt; colors.vnl | vnl-sort | vnl-uniq -c&#xA; # count color&#xA;       2 blue&#xA;       2 orange&#xA;       3 yellow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION Usage: vnl-uniq [options] &amp;lt; logfile&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This tool runs &#34;uniq&#34; on a given vnlog dataset. &#34;vnl-uniq&#34; is a wrapper&#xA;around the GNU coreutils &#34;uniq&#34; tool. Since this is a wrapper, most&#xA;commandline options and behaviors of the &#34;uniq&#34; tool are present;&#xA;consult the uniq(1) manpage for detail. The differences from GNU&#xA;coreutils &#34;uniq&#34; are&#xA;&#xA;*   The input and output to this tool are vnlog files, complete with a&#xA;    legend&#xA;&#xA;*   &#34;--zero-terminated&#34; is not supported because vnlog assumes&#xA;    newline-separated records&#xA;&#xA;*   Only *one* input is supported (a file on the cmdline or data on&#xA;    standard input), and the output *always* goes to standard output.&#xA;    Specifying the output as a file on the commandline is not supported.&#xA;&#xA;*   &#34;--vnl-count NAME&#34; can be given to name the &#34;count&#34; column. &#34;-c&#34; is&#xA;    still supported to add the default new column named &#34;count&#34;, but if&#xA;    another name is wanted, &#34;--vnl-count&#34; does that. &#34;--vnl-count&#34;&#xA;    implies &#34;-c&#34;&#xA;&#xA;*   In addition to the normal behavior of skipping fields at the start,&#xA;    &#34;-f&#34; and &#34;--skip-fields&#34; can take a negative argument to skip the&#xA;    *all but the last* N fields. For instance, to use only the one last&#xA;    field, pass &#34;-f -1&#34; or &#34;--skip-fields=-1&#34;.&#xA;&#xA;*   By default we call the &#34;uniq&#34; tool to do the actual work. If the&#xA;    underlying tool has a different name or lives in an odd path, this&#xA;    can be specified by passing &#34;--vnl-tool TOOL&#34;&#xA;&#xA;Past that, everything &#34;uniq&#34; does is supported, so see that man page for&#xA;detailed documentation.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;COMPATIBILITY I use GNU/Linux-based systems exclusively, but everything has been tested functional on FreeBSD and OSX in addition to Debian, Ubuntu and CentOS. I can imagine there&#39;s something I missed when testing on non-Linux systems, so please let me know if you find any issues.&lt;/p&gt; &#xA;&lt;p&gt;SEE ALSO uniq(1)&lt;/p&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-gen-header #+BEGIN_EXAMPLE NAME vnl-gen-header - create definition for vnlog output from C&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ vnl-gen-header &#39;int w&#39; &#39;uint8_t x&#39; &#39;char* y&#39; &#39;double z&#39; &amp;gt; vnlog_fields_generated.h&lt;/p&gt; &#xA;&lt;p&gt;DESCRIPTION We provide a simple C library to produce vnlog output. The fields this library outputs must be known at compile time, and are specified in a header created by this tool. Please see the vnlog documentation for instructions on how to use the library&lt;/p&gt; &#xA;&lt;p&gt;ARGUMENTS This tool needs to be given a list of field definitions. First we look at the commandline, and if the definitions are not available there, we look on STDIN. Each definition is a string &#34;type name&#34; (one def per argument on the commandline or per line on STDIN). If reading from STDIN, we ignore blank lines, and treat any line starting with &#34;#&#34; as a comment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Each def represents a single output field. Each such field spec in a&#xA;C-style variable declaration with a type followed by a name. Note that&#xA;these field specs contain whitespace, so each one must be quoted before&#xA;being passed to the shell.&#xA;&#xA;The types can be basic scalars, possibly with set widths (&#34;char&#34;,&#xA;&#34;double&#34;, &#34;int&#34;, &#34;uint32_t&#34;, &#34;unsigned int&#34;, ...), a NULL-terminated&#xA;string (&#34;char*&#34;) or a generic chunk of binary data (&#34;void*&#34;).&#xA;&#xA;The names must consist entirely of letters, numbers or &#34;_&#34;, like&#xA;variables in C.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** vnl-make-matrix #+BEGIN_EXAMPLE NAME vnl-make-matrix - create a matrix from a one-point-per-record vnlog&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS $ cat /tmp/dat.vnl # i j x 0 0 1 0 1 2 0 2 3 1 0 4 1 1 5 1 2 6 2 0 7 2 1 8 2 2 9 3 0 10 3 1 11 3 2 12&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; $ &amp;lt;/tmp/dat.vnl vnl-filter -p i,x | vnl-make-matrix --outdir /tmp --prefix test_&#xA; Writing to &#39;/tmp/test_x.matrix&#39;&#xA;&#xA; $ cat /tmp/test_x.matrix&#xA; 1 2 3&#xA; 4 5 6&#xA; 7 8 9&#xA; 10 11 12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION Vnlog represents each &#34;data item&#34; as a line of text. This is very often what one wants, but at times it isn&#39;t. One example of this is matrix data: we want each line to contain a whole row of a matrix. This script exists for convenience, to bridge this gap.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The input is an vnlog, coming in on STDIN and/or in files given on the&#xA;commandline. This vnlog must have at least two fields: the&#xA;least-significant (slowest-changing) index of each point (must be the&#xA;*first* field), and as many value fields as desired. These points must&#xA;be written out in order, and it is assumed that all entries in the&#xA;matrix are specified. The output is a set of (non-vnlog) matrix files in&#xA;the directory given in the &#34;--outdir&#34; argument. These files are named&#xA;&#34;PREFIX_XXX.matrix&#34; where &#34;PREFIX&#34; comes from --prefix (or empty) and&#xA;&#34;XXX&#34; is the field name. These matrices can be loaded into any analysis&#xA;tool (numpy for instance), or plotted directly with gnuplot:&#xA;&#xA; set size ratio -1&#xA; plot &#34;/tmp/test_x.matrix&#34; matrix with image&#xA; pause -1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Repository&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dkogan/vnlog/&#34;&gt;https://github.com/dkogan/vnlog/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Authors&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Dima Kogan (=&lt;a href=&#34;mailto:dima@secretsauce.net&#34;&gt;dima@secretsauce.net&lt;/a&gt;=) wrote this toolkit for his work at the Jet Propulsion Laboratory, and is delighted to have been able to release it publically&lt;/p&gt; &#xA;&lt;p&gt;Chris Venter (=&lt;a href=&#34;mailto:chris.venter@gmail.com&#34;&gt;chris.venter@gmail.com&lt;/a&gt;=) wrote the base64 encoder&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License and copyright&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2016-2017 California Institute of Technology&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2017-2018 Dima Kogan (=&lt;a href=&#34;mailto:dima@secretsauce.net&#34;&gt;dima@secretsauce.net&lt;/a&gt;=)&lt;/p&gt; &#xA;&lt;p&gt;=b64_cencode.c= comes from =cencode.c= in the =libb64= project. It is written by Chris Venter (=&lt;a href=&#34;mailto:chris.venter@gmail.com&#34;&gt;chris.venter@gmail.com&lt;/a&gt;=) who placed it in the public domain. The full text of the license is in that file.&lt;/p&gt;</summary>
  </entry>
</feed>