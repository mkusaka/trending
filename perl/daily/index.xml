<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-01T01:40:53Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>brk3/o2sms</title>
    <updated>2023-10-01T01:40:53Z</updated>
    <id>tag:github.com,2023-10-01:/brk3/o2sms</id>
    <link href="https://github.com/brk3/o2sms" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unmodified Git mirror from SVN of macker&#39;s o2sms&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>bradhaywood/DBIx-Moo</title>
    <updated>2023-10-01T01:40:53Z</updated>
    <id>tag:github.com,2023-10-01:/bradhaywood/DBIx-Moo</id>
    <link href="https://github.com/bradhaywood/DBIx-Moo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimalistic ORM built on Moo&lt;/p&gt;&lt;hr&gt;&lt;p&gt;NAME DBIx::Moo - Minimalistic ORM built on Moo&lt;/p&gt; &#xA;&lt;p&gt;DESCRIPTION DBIx::Moo is a minimal ORM built on Moo. Instead of multiple files (one for each table), it uses just the one. Your schema is built using Moo. This is just a test module and shouldn&#39;t really be used for any thing. I built it in an attempt to get used to OOP frameworks like Moose and Moo. This is my first one.&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS Create your Schema module&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    package MySchema;&#xA;&#xA;    use Moo;&#xA;    extends &#39;DBIx::Moo::Core&#39;;&#xA;&#xA;    has &#39;users&#39; =&amp;gt; (&#xA;        is  =&amp;gt; &#39;rw&#39;,&#xA;        isa =&amp;gt; sub {&#xA;            die &#34;columns expects HashRef\n&#34;&#xA;                if ref(shift) ne &#39;HASH&#39;;&#xA;        },&#xA;        default =&amp;gt; sub {&#xA;            {&#xA;                table       =&amp;gt; 1,&#xA;                columns     =&amp;gt; [qw/ id name status /],&#xA;                primary_key =&amp;gt; &#39;id&#39;,&#xA;            }&#xA;        }&#xA;    );&#xA;&#xA;    has &#39;_config&#39; =&amp;gt; (&#xA;        is =&amp;gt; &#39;ro&#39;,&#xA;        isa =&amp;gt; sub {&#xA;            die &#34;_config expects ArrayRef&#34;&#xA;                if ref(shift) ne &#39;ARRAY&#39;;&#xA;        },&#xA;        default =&amp;gt; sub {&#xA;            [&#xA;                &#39;dbi:Pg:dbname=my_db&#39;,&#xA;                &#39;myuser&#39;,&#xA;                &#39;mypass&#39;,&#xA;            ]&#xA;        },&#xA;    );&#xA;&#xA;Now you can reuse this Schema whenever you want&#xA;&#xA;    use MySchema;&#xA;&#xA;    my $schema = Schema-&amp;gt;new-&amp;gt;connect();&#xA;    my $users  = $schema-&amp;gt;table(&#39;users&#39;);&#xA;&#xA;    # get a single row using primary key&#xA;    say $users-&amp;gt;find(10)-&amp;gt;{name};&#xA;&#xA;    # get all active users&#xA;    my @users = $users-&amp;gt;search({ status =&amp;gt; &#39;active&#39; })-&amp;gt;all;&#xA;    for my $user (@users) {&#xA;        say $user-&amp;gt;{name};&#xA;        say $user-&amp;gt;{status};&#xA;    }&#xA;&#xA;    # you can also use search to save as an array (similar as calling -&amp;gt;all)&#xA;    my @users = $users-&amp;gt;search({ status =&amp;gt; &#39;active&#39; });&#xA;&#xA;    # or save it as a scalar&#xA;    my $users_rs = $users-&amp;gt;search({ status =&amp;gt; &#39;active&#39; });&#xA;&#xA;    # count the rows&#xA;    say $users_rs-&amp;gt;count;&#xA;&#xA;    # get the first row object&#xA;    say $users_rs-&amp;gt;first;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;METHODS connect Initialises a connection to DBI using DBIx::Connector.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $schema = MySchema-&amp;gt;new-&amp;gt;connect;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;table If the table exists in the config, it will set it as the currently active table for that instance and return a DBIx::Moo::ResultSet object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $users = $schema-&amp;gt;table(&#39;users&#39;);&#xA;&#xA;You can even chain this onto the initial &#34;connect&#34; method&#xA;&#xA;    my $users = $schema-&amp;gt;new-&amp;gt;connect-&amp;gt;table(&#39;users&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;search Returns a DBIx::Moo::ResultSet based on your search query. If it&#39;s expecting a scalar you&#39;ll get an object, if it&#39;s expecting an array, you&#39;ll get the results&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $users = $users-&amp;gt;search({ status =&amp;gt; &#39;active&#39; });&#xA;    my @users = $users-&amp;gt;search({ status =&amp;gt; &#39;active&#39; });&#xA;    for my $user (@users) { say $user-&amp;gt;{name} }&#xA;&#xA;The first hashref are the items you want to search for, the optional&#xA;second hashref are extra search options, like &#34;order_by&#34; and &#34;rows&#34;. For&#xA;more information on the search syntax, please check out&#xA;SQL::Abstract::More as it uses this.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;find If you have a primary key set you can use find to search for a particular value. It will search for the value matched against the primary key.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    if (my $user = $users-&amp;gt;find(10)) {&#xA;        say &#34;Found user with ID 10&#34;;&#xA;    }&#xA;&#xA;This will return a DBIx::Moo::Result object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;count Simply returns the number of rows from a DBIx::Moo::ResultSet result&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    say &#34;There are &#34; . $resultset-&amp;gt;count . &#34; rows&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;first Retrieves the first row of a resultset as a HashRef&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    say $resultset-&amp;gt;first-&amp;gt;{name};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;last Same as first, but gets the last row instead&lt;/p&gt; &#xA;&lt;p&gt;method Injects a convenience method into a resultset&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $users = $schema-&amp;gt;table(&#39;users&#39;);&#xA;    $users-&amp;gt;method(&#39;get_me_the_first_three&#39; =&amp;gt; sub {&#xA;        return shift-&amp;gt;search(undef, { rows =&amp;gt; 3, order_by =&amp;gt; [qw/+name/] });&#xA;    });&#xA;&#xA;    my @first_three_users = $users-&amp;gt;get_me_the_first_three;&#xA;    for my $user (@first_three_users) {&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;result Use this on a ResultSet object to get a Result object (for updating). It will only allow you to do this if there is one row found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $result = $resultset-&amp;gt;search({ name =&amp;gt; &#39;Foobie&#39; })-&amp;gt;result;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;update Updates a row with the specified parameters. Must be called from a DBIx::Moo::Result object. Will return a DBIx::Moo::Result object&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $row = $resultset-&amp;gt;search({ name =&amp;gt; &#39;Foobie&#39; })-&amp;gt;result;&#xA;    $row-&amp;gt;update({ name =&amp;gt; &#39;Bar&#39; });&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>