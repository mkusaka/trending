<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-21T01:35:37Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pawjy/perl-promised-command</title>
    <updated>2022-10-21T01:35:37Z</updated>
    <id>tag:github.com,2022-10-21:/pawjy/perl-promised-command</id>
    <link href="https://github.com/pawjy/perl-promised-command" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;Promised::Command - Run a command&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;p&gt;use Promised::Command;&lt;/p&gt; &#xA;&lt;p&gt;$cmd = Promised::Command-&amp;gt;new ([&#39;ls&#39;, &#39;-a&#39;, &#39;/&#39;]); $cmd-&amp;gt;run-&amp;gt;then (sub { return $cmd-&amp;gt;wait; })-&amp;gt;then (sub { my $result = $_[0]; if ($result-&amp;gt;exit_code == 0) { warn &#34;done&#34;; } else { warn &#34;failed&#34;; } });&lt;/p&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;The C&lt;a href=&#34;Promised::Command&#34;&gt;Promised::Command&lt;/a&gt; class provides a L&#xA; &lt;promise&gt;&#xA;  -returning command execution interface.&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 METHODS&lt;/p&gt; &#xA;&lt;p&gt;Following methods are available:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd = Promised::Command-&amp;gt;new ($args)&lt;/p&gt; &#xA;&lt;p&gt;Create a new command object. The argument must be an array reference containing a command (zeroth item) and zero or more arguments (first or later items).&lt;/p&gt; &#xA;&lt;p&gt;=item $promise = $cmd-&amp;gt;run&lt;/p&gt; &#xA;&lt;p&gt;Start the execution of the command. It returns a L&#xA; &lt;promise&gt;&#xA;  , which is resolved with a result object when the execution is started.&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method cannot be invoked multiple times.&lt;/p&gt; &#xA;&lt;p&gt;=item $promise = $cmd-&amp;gt;wait&lt;/p&gt; &#xA;&lt;p&gt;Return a L&#xA; &lt;promise&gt;&#xA;  , which is resolved with a result object once the execution of the command has finished.&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method can be invoked before the C&#xA; &lt;run&gt;&#xA;  &#39;s promise is resolved, but it must be invoked after the C&#xA;  &lt;run&gt;&#xA;    method is invoked. This method always returns the same promise.&#xA;  &lt;/run&gt;&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;The promise is resolved with a result object whose C&amp;lt;is_success&amp;gt; method returns true even when the exit code of the command is non-zero. Note also that failure to execute the command (e.g. command-not-found error) is also result in resolving the promise with a successful result object whose exit code is non-zero.&lt;/p&gt; &#xA;&lt;p&gt;If the command has terminated by an uncaught signal, the promise is rejected with a result object whose C&amp;lt;is_error&amp;gt; method returns true.&lt;/p&gt; &#xA;&lt;p&gt;=item $boolean = $cmd-&amp;gt;create_process_group&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;create_process_group ($boolean)&lt;/p&gt; &#xA;&lt;p&gt;Get or set whether a new process group should be created for the command (by C&#xA; &lt;setpgrp&gt;&#xA;  ) or not.&#xA; &lt;/setpgrp&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked. If this method is not invoked, the same process group as the main process is used.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;wd ($string)&lt;/p&gt; &#xA;&lt;p&gt;=item $string = $cmd-&amp;gt;wd&lt;/p&gt; &#xA;&lt;p&gt;Get or set the current working directory for the command as a (system-dependent byte) string.&lt;/p&gt; &#xA;&lt;p&gt;This method must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked. If this method is not invoked, the current directory is left unchanged (i.e. same as that of the main process).&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $hashref = $cmd-&amp;gt;envs&lt;/p&gt; &#xA;&lt;p&gt;Return the environment variables for the command as a reference to the hash of environment name/value byte string pairs.&lt;/p&gt; &#xA;&lt;p&gt;If a value is specified in the hash, an environment variable is set. Otherwise, if an C&#xA; &lt;undef&gt;&#xA;   value is explicitly specified in the hash, the environment variable, if any, is unset. Otherwise, any environment variable of the main process is left unchanged. This method must be invoked before the C&#xA;  &lt;run&gt;&#xA;    method is invoked.&#xA;  &lt;/run&gt;&#xA; &lt;/undef&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $stream = $cmd-&amp;gt;get_stdin_stream&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;stdin (SCALARREF)&lt;/p&gt; &#xA;&lt;p&gt;Specify how the standard input is handled.&lt;/p&gt; &#xA;&lt;p&gt;If the C&amp;lt;get_stdin_stream&amp;gt; is invoked, a L&#xA; &lt;writablestream&gt;&#xA;   object that is a writable stream of the input is returned. Any written value (i.e. the argument too the C&#xA;  &lt;write&gt;&#xA;    method of the writer) must be an L&#xA;   &lt;arraybufferview&gt;&#xA;     (such as L&#xA;    &lt;dataview&gt;&#xA;      and L&#xA;     &lt;a href=&#34;TypedArray::Uint8Array&#34;&gt;TypedArray::Uint8Array&lt;/a&gt;). If the stream is aborted, the input is closed as soon as possible (which means not all data might be written, though it does not affect the execution of the child process).&#xA;    &lt;/dataview&gt;&#xA;   &lt;/arraybufferview&gt;&#xA;  &lt;/write&gt;&#xA; &lt;/writablestream&gt;&lt;/p&gt; &#xA;&lt;p&gt;If a scalar reference is specified to the C&#xA; &lt;stdin&gt;&#xA;   method, the referenced scalar value is written as the input. The referenced value must be a byte string.&#xA; &lt;/stdin&gt;&lt;/p&gt; &#xA;&lt;p&gt;Only one of these methods must be invoked at most once. These methods must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;If these methods are not invoked, the input&#39;s handling is left unchanged (i.e. same as the standard input of the main process).&lt;/p&gt; &#xA;&lt;p&gt;=item $stream = $cmd-&amp;gt;get_stdout_stream&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;stdout (SCALARREF)&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;stdout (CODE)&lt;/p&gt; &#xA;&lt;p&gt;=item $stream = $cmd-&amp;gt;get_stderr_stream&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;stderr (SCALARREF)&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;stderr (CODE)&lt;/p&gt; &#xA;&lt;p&gt;Specify how the standard output or the standard error output is handled.&lt;/p&gt; &#xA;&lt;p&gt;If the C&amp;lt;get_stdout_stream&amp;gt; or C&amp;lt;get_stderr_stream&amp;gt; method is invoked, a L&#xA; &lt;readablestream&gt;&#xA;   object that is a readable byte stream of the output is returned. If the stream is canceled, any remaining data are silently discarded (which does not affect the child process).&#xA; &lt;/readablestream&gt;&lt;/p&gt; &#xA;&lt;p&gt;If a scalar reference is specified to the C&#xA; &lt;stdout&gt;&#xA;   or C&#xA;  &lt;stderr&gt;&#xA;    method, the output is set to the referenced scalar value.&#xA;  &lt;/stderr&gt;&#xA; &lt;/stdout&gt;&lt;/p&gt; &#xA;&lt;p&gt;If a code reference is specified to the C&#xA; &lt;stdout&gt;&#xA;   or C&#xA;  &lt;stderr&gt;&#xA;    method, the code is invoked with a chunk as the argument whenever the chunk is available, and with an C&#xA;   &lt;undef&gt;&#xA;     as the argument when the end of the output is reached.&#xA;   &lt;/undef&gt;&#xA;  &lt;/stderr&gt;&#xA; &lt;/stdout&gt;&lt;/p&gt; &#xA;&lt;p&gt;Only one of these methods must be invoked at most once for each of standard output and standard error output. These methods must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;If these methods are not invoked, the output&#39;s handling is left unchanged (i.e. same as the standard output or the standard error output of the main process).&lt;/p&gt; &#xA;&lt;p&gt;=item $pid = $cmd-&amp;gt;pid&lt;/p&gt; &#xA;&lt;p&gt;Return the process ID of the child process (i.e. the command&#39;s process).&lt;/p&gt; &#xA;&lt;p&gt;This method can be invoked after the C&#xA; &lt;run&gt;&#xA;   promise is resolved. Note that there can no longer be the process with the ID or can be a different process with the ID if the command has finished.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $boolean = $cmd-&amp;gt;running&lt;/p&gt; &#xA;&lt;p&gt;Return whether the command is running or not.&lt;/p&gt; &#xA;&lt;p&gt;Note that returning a true value does not mean the command is actually in active; it might be finished but not C&#xA; &lt;waitpid&gt;&#xA;  ed by this process yet.&#xA; &lt;/waitpid&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $promise = $cmd-&amp;gt;send_signal ($signal)&lt;/p&gt; &#xA;&lt;p&gt;Send a signal to the command&#39;s process, if running.&lt;/p&gt; &#xA;&lt;p&gt;The argument must be a string or integer representing the signal, such as C&#xA; &lt;int&gt;&#xA;   or C&amp;lt;2&amp;gt;, or zero to not send any signal. See C&amp;lt;perldoc -f kill&amp;gt;.&#xA; &lt;/int&gt;&lt;/p&gt; &#xA;&lt;p&gt;The method returns a L&#xA; &lt;promise&gt;&#xA;  , which is resolved with a result object whose C&#xA;  &lt;killed&gt;&#xA;    method returns the number of processed to which the signal is sent. If the command&#39;s process is no longer running, the signal is sent to no process.&#xA;  &lt;/killed&gt;&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $value = $cmd-&amp;gt;propagate_signal&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;propagate_signal ($value)&lt;/p&gt; &#xA;&lt;p&gt;Get or set whether signals to this (main) process should be propagated to the child (command) process or not.&lt;/p&gt; &#xA;&lt;p&gt;The value can be a non-reference value or an array reference of signal names or an array reference of a pair of signal names. A non-reference value is equivalent to C&amp;lt;[&#39;INT&#39;, &#39;QUIT&#39;, &#39;TERM&#39;]&amp;gt;. A pair of signal names represents that when the first signal is received by the main process, the second signal should be sent to the child process instead. The value represents the types of the signals to propagate. Signals specified by this method caught by the main process result in terminating the main process after the propagation.&lt;/p&gt; &#xA;&lt;p&gt;This method must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked. If this method is not invoked, no signal is propagated.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;If signals are to be propagated, any other signal handling should be done through L&lt;a href=&#34;Promised::Command::Signals&#34;&gt;Promised::Command::Signals&lt;/a&gt; to avoid confliction of signal handlers.&lt;/p&gt; &#xA;&lt;p&gt;=item $signal = $cmd-&amp;gt;signal_before_destruction&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;signal_before_destruction ($signal)&lt;/p&gt; &#xA;&lt;p&gt;Get or set the signal (e.g. C&#xA; &lt;kill&gt;&#xA;   or C&#xA;  &lt;term&gt;&#xA;   ) which should be sent to the command (child) process if it is still running when the command object is destroyed (i.e. the I&amp;lt;$cmd&amp;gt; object is destroyed without its C&#xA;   &lt;wait&gt;&#xA;     method invoked). This feature is useful when the command object can be discarded by unexpected shutdown of the application (e.g. Perl runtime error) but still need to ensure that child process should be terminated.&#xA;   &lt;/wait&gt;&#xA;  &lt;/term&gt;&#xA; &lt;/kill&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked. If this method is not invoked, no signal is sent.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $seconds = $cmd-&amp;gt;timeout&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;timeout ($seconds)&lt;/p&gt; &#xA;&lt;p&gt;Get or set the timeout from the execution of the command in seconds. If a positive number is specified, the signal specified by the C&amp;lt;timeout_signal&amp;gt; method is sent to the command&#39;s process, if any. Otherwise no timeout is set.&lt;/p&gt; &#xA;&lt;p&gt;This method must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $signal = $cmd-&amp;gt;timeout_signal&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;timeout_signal ($signal)&lt;/p&gt; &#xA;&lt;p&gt;Get or set the signal (e.g. C&#xA; &lt;kill&gt;&#xA;   or C&#xA;  &lt;term&gt;&#xA;   ) which should be sent when the C&#xA;   &lt;timeout&gt;&#xA;     seconds has elapsed before the command returns. It is set to C&#xA;    &lt;term&gt;&#xA;      unless explicitly specified.&#xA;    &lt;/term&gt;&#xA;   &lt;/timeout&gt;&#xA;  &lt;/term&gt;&#xA; &lt;/kill&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $cmd-&amp;gt;abort_signal ($asignal)&lt;/p&gt; &#xA;&lt;p&gt;Set the abort signal (L&#xA; &lt;abortsignal&gt;&#xA;   object from the L&#xA;  &lt;a href=&#34;https://github.com/wakaba/perl-promise&#34;&gt;https://github.com/wakaba/perl-promise&lt;/a&gt; respository; the value returned by the C&amp;lt;&amp;lt; $abort_controller-&amp;gt;signal &amp;gt;&amp;gt; method) which can be used to send a signal to terminate the process.&#xA; &lt;/abortsignal&gt;&lt;/p&gt; &#xA;&lt;p&gt;The signal sent when aborted is specified by the C&amp;lt;timeout_signal&amp;gt; method.&lt;/p&gt; &#xA;&lt;p&gt;This method must be invoked before the C&#xA; &lt;run&gt;&#xA;   method is invoked.&#xA; &lt;/run&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head1 RESULT OBJECT&lt;/p&gt; &#xA;&lt;p&gt;Promises are resolved with a result object, which has following methods:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $boolean = $result-&amp;gt;is_success&lt;/p&gt; &#xA;&lt;p&gt;=item $boolean = $result-&amp;gt;is_error&lt;/p&gt; &#xA;&lt;p&gt;Whether the operation has succeded or in error. Note that C&amp;lt;&amp;lt; !!$result-&amp;gt;is_success == !!!$result-&amp;gt;is_error &amp;gt;&amp;gt; is always true.&lt;/p&gt; &#xA;&lt;p&gt;=item $string = &#39;&#39; . $result&lt;/p&gt; &#xA;&lt;p&gt;Return a short message of the result for the developer.&lt;/p&gt; &#xA;&lt;p&gt;=item $int = $result-&amp;gt;exit_code&lt;/p&gt; &#xA;&lt;p&gt;Return the exit code of the command, if applicable, or C&amp;lt;-1&amp;gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;=item $int = $result-&amp;gt;signal&lt;/p&gt; &#xA;&lt;p&gt;Return the signal which terminates the command, if applicable.&lt;/p&gt; &#xA;&lt;p&gt;=item $boolean = $result-&amp;gt;core_dump&lt;/p&gt; &#xA;&lt;p&gt;Return whether there is a core dump or not, if applicable.&lt;/p&gt; &#xA;&lt;p&gt;=item $int = $result-&amp;gt;killed&lt;/p&gt; &#xA;&lt;p&gt;Return the number of process to which the signal is sent. Used by C&amp;lt;send_signal&amp;gt;&#39;s promise.&lt;/p&gt; &#xA;&lt;p&gt;=item $string = $result-&amp;gt;message&lt;/p&gt; &#xA;&lt;p&gt;Return a short error message for the developer, if available.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head1 ENVIRONMENT VARIABLE&lt;/p&gt; &#xA;&lt;p&gt;If the environment variable C&amp;lt;PROMISED_COMMAND_DEBUG&amp;gt; is set to a true value, debug messages are printed to the standard error output.&lt;/p&gt; &#xA;&lt;p&gt;=head1 SEE ALSO&lt;/p&gt; &#xA;&lt;p&gt;There are related modules: L&lt;a href=&#34;Promised::Command::Signals&#34;&gt;Promised::Command::Signals&lt;/a&gt;, L&lt;a href=&#34;Promised::Command::Docker&#34;&gt;Promised::Command::Docker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=head1 DEPENDENCY&lt;/p&gt; &#xA;&lt;p&gt;The module requires Perl 5.10 or later.&lt;/p&gt; &#xA;&lt;p&gt;The module requires L&#xA; &lt;promise&gt; &#xA;  &lt;a href=&#34;https://github.com/wakaba/perl-promise&#34;&gt;https://github.com/wakaba/perl-promise&lt;/a&gt; and L&#xA;  &lt;a href=&#34;AnyEvent::Util&#34;&gt;AnyEvent::Util&lt;/a&gt;.&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;Methods C&amp;lt;get_stdin_stream&amp;gt;, C&amp;lt;get_stdout_stream&amp;gt;, and C&amp;lt;get_stderr_stream&amp;gt; require the L&#xA; &lt;readablestream&gt;&#xA;   module from the perl-streams repository &#xA;  &lt;a href=&#34;https://github.com/manakai/perl-streams&#34;&gt;https://github.com/manakai/perl-streams&lt;/a&gt;.&#xA; &lt;/readablestream&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=head1 HISTORY&lt;/p&gt; &#xA;&lt;p&gt;This repository was located at &lt;a href=&#34;https://github.com/wakaba/perl-promised-command&#34;&gt;https://github.com/wakaba/perl-promised-command&lt;/a&gt; until 2 February, 2022.&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2015-2022 Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>FlashKorten/txt2cwp</title>
    <updated>2022-10-21T01:35:37Z</updated>
    <id>tag:github.com,2022-10-21:/FlashKorten/txt2cwp</id>
    <link href="https://github.com/FlashKorten/txt2cwp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;utility to create LaTeX-Crosswordpuzzles without ANY hassle&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;txt2cwp&lt;/h1&gt; &#xA;&lt;p&gt;Create a simple textfile containing only a filled out crossword form. Filled blocks in the puzzle are set by the character &#39;&lt;code&gt;_&lt;/code&gt;&#39; (underscore). You don&#39;t have to set up the dimension of the puzzle - just put the same number of letters into each line.&lt;/p&gt; &#xA;&lt;p&gt;If you look at the example in &#39;cwp.txt&#39; you will find its content to be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;counter&#xA;hex_rsa&#xA;amt_and&#xA;r_esc__&#xA;_friend&#xA;vim__or&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is very easy to fill such a puzzle if you start with something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;counter&#xA;..x....&#xA;..t....&#xA;..e....&#xA;..r....&#xA;..m....&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and fill in the missing letters in replace (overwrite) mode in your editor.&lt;/p&gt; &#xA;&lt;p&gt;Then you can parse the source file through txt2cwp:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;txt2cwp cwp.txt&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This generates cwp.tex, a frameset for your puzzle in which only the clues are missing. You have to insert the clues into the tex file at the appropriate positions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;\Clue{1}{counter}{}%&#xA;\Clue{7}{hex}{}%&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will become something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;\Clue{1}{counter}{Something increasing each time around}%&#xA;\Clue{7}{hex}{Regular polygon with the most vertices to tile a plane with}%&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since the solution to each clue is given as second parameter to \Clue, this should be very easy, in fact, dare I say, comfortable!&lt;/p&gt; &#xA;&lt;p&gt;After all the clues are added compile the tex file using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pdflatex cwp.tex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and you are done...&lt;/p&gt; &#xA;&lt;p&gt;Enjoy!&lt;/p&gt;</summary>
  </entry>
</feed>