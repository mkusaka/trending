<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-19T01:45:11Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>percona/percona-toolkit</title>
    <updated>2022-08-19T01:45:11Z</updated>
    <id>tag:github.com,2022-08-19:/percona/percona-toolkit</id>
    <link href="https://github.com/percona/percona-toolkit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Percona Toolkit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Percona Toolkit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cla-assistant.percona.com/percona/percona-toolkit&#34;&gt;&lt;img src=&#34;https://cla-assistant.percona.com/readme/badge/percona/percona-toolkit&#34; alt=&#34;CLA assistant&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Percona Toolkit&lt;/em&gt; is a collection of advanced command-line tools used by &lt;a href=&#34;http://www.percona.com/&#34;&gt;Percona&lt;/a&gt; support staff to perform a variety of MySQL and system tasks that are too difficult or complex to perform manually.&lt;/p&gt; &#xA;&lt;p&gt;These tools are ideal alternatives to private or &#34;one-off&#34; scripts because they are professionally developed, formally tested, and fully documented. They are also fully self-contained, so installation is quick and easy and no libraries are installed.&lt;/p&gt; &#xA;&lt;p&gt;Percona Toolkit is developed and supported by Percona Inc. For more information and other free, open-source software developed by Percona, visit &lt;a href=&#34;http://www.percona.com/software/&#34;&gt;http://www.percona.com/software/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;To install all tools, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl Makefile.PL&#xA;make&#xA;make test&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You probably need to be root to &lt;code&gt;make install&lt;/code&gt;. On most systems, the tools are installed in /usr/local/bin. See the INSTALL file for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Run &lt;code&gt;man percona-toolkit&lt;/code&gt; to see a list of installed tools, then &lt;code&gt;man tool&lt;/code&gt; to read the embedded documentation for a specific tool. You can also read the documentation online at &lt;a href=&#34;http://www.percona.com/software/percona-toolkit/&#34;&gt;http://www.percona.com/software/percona-toolkit/&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jlapeyre/PDL-DSP-Fir</title>
    <updated>2022-08-19T01:45:11Z</updated>
    <id>tag:github.com,2022-08-19:/jlapeyre/PDL-DSP-Fir</id>
    <link href="https://github.com/jlapeyre/PDL-DSP-Fir" rel="alternate"></link>
    <summary type="html">&lt;p&gt;fir filters for PDL&lt;/p&gt;&lt;hr&gt;&lt;p&gt;=head1 OVERVIEW&lt;/p&gt; &#xA;&lt;p&gt;Two modules for PDL providing some fir filtering.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt; &#xA;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;PDL::DSP::Fir - Finite impulse response filter kernels.&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;p&gt;use PDL; use PDL::DSP::Fir qw( firwin );&lt;/p&gt; &#xA;&lt;h1&gt;return a 10 sample lowpass filter kernel&lt;/h1&gt; &#xA;&lt;h1&gt;with a cutoff at 90% of the Nyquist frequency.&lt;/h1&gt; &#xA;&lt;p&gt;$kernel = firwin( N =&amp;gt; 10, fc =&amp;gt; 0.9 );&lt;/p&gt; &#xA;&lt;h1&gt;Equivalent way of calling.&lt;/h1&gt; &#xA;&lt;p&gt;$kernel = firwin( { N =&amp;gt; 10, fc =&amp;gt; 0.9 } );&lt;/p&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;This module provides routines to create one-dimensional finite impulse response (FIR) filter kernels. This distribution inlcudes a simple interface for filtering in L&lt;a href=&#34;PDL::DSP::Fir::Simple&#34;&gt;PDL::DSP::Fir::Simple&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The routine L returns a filter kernel constructed from windowed sinc functions. Available filters are lowpass, highpass, bandpass, and bandreject. The window functions are in the module L&lt;a href=&#34;PDL::DSP::Windows&#34;&gt;PDL::DSP::Windows&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Below, the word B&#xA; &lt;order&gt;&#xA;   refers to the number of elements in the filter kernel.&#xA; &lt;/order&gt;&lt;/p&gt; &#xA;&lt;p&gt;No functions are exported be default.&lt;/p&gt; &#xA;&lt;p&gt;=head1 FUNCTIONS&lt;/p&gt; &#xA;&lt;p&gt;=head2 firwin&lt;/p&gt; &#xA;&lt;p&gt;=head3 Usage&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;$kern = firwin({OPTIONS}); $kern = firwin(OPTIONS);&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Returns a filter kernel (a finite impulse response function) to be convolved with data.&lt;/p&gt; &#xA;&lt;p&gt;The kernel is built from windowed sinc functions. With the option C&amp;lt;type =E&#xA; &lt;gt&gt;&#xA;   &#39;window&#39;&amp;gt; no sinc is used, rather the kernel is just the window. The options may be passed as a list of key-value pairs, or as an anonymous hash.&#xA; &lt;/gt&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head3 OPTIONS&lt;/p&gt; &#xA;&lt;p&gt;=over&lt;/p&gt; &#xA;&lt;p&gt;=item N&lt;/p&gt; &#xA;&lt;p&gt;order of filter. This is the number of elements in the returned kernel pdl.&lt;/p&gt; &#xA;&lt;p&gt;=item type&lt;/p&gt; &#xA;&lt;p&gt;Filter type. One of C&#xA; &lt;lowpass&gt;&#xA;  , C&#xA;  &lt;highpass&gt;&#xA;   , C&#xA;   &lt;bandpass&gt;&#xA;    , C&#xA;    &lt;bandstop&gt;&#xA;     , C&#xA;     &lt;window&gt;&#xA;      . Aliases for C&#xA;      &lt;bandstop&gt;&#xA;        are C&#xA;       &lt;bandreject&gt;&#xA;         and C&#xA;        &lt;notch&gt;&#xA;         . Default is C&#xA;         &lt;lowpass&gt;&#xA;          . For C&#xA;          &lt;bandpass&gt;&#xA;            and C&#xA;           &lt;bandstop&gt;&#xA;             the number of samples L must be odd. If B&#xA;            &lt;type&gt;&#xA;              is C&#xA;             &lt;window&gt;&#xA;              , then the kernel returned is just the window function.&#xA;             &lt;/window&gt;&#xA;            &lt;/type&gt;&#xA;           &lt;/bandstop&gt;&#xA;          &lt;/bandpass&gt;&#xA;         &lt;/lowpass&gt;&#xA;        &lt;/notch&gt;&#xA;       &lt;/bandreject&gt;&#xA;      &lt;/bandstop&gt;&#xA;     &lt;/window&gt;&#xA;    &lt;/bandstop&gt;&#xA;   &lt;/bandpass&gt;&#xA;  &lt;/highpass&gt;&#xA; &lt;/lowpass&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item fc&lt;/p&gt; &#xA;&lt;p&gt;Cutoff frequency for low- and highpass filters as a fraction of the Nyquist frequency. Must be a number between C&amp;lt;0&amp;gt; and C&amp;lt;1&amp;gt;. No default value.&lt;/p&gt; &#xA;&lt;p&gt;=item fclo, fchi&lt;/p&gt; &#xA;&lt;p&gt;Lower and upper cutoff frequencies for bandpass and bandstop filters. No default values.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;All other options to L are passed to the function L&lt;a href=&#34;PDL::DSP::Windows/window&#34;&gt;PDL::DSP::Windows/window&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=cut =pod&lt;/p&gt; &#xA;&lt;p&gt;The following three functions are called by the C&#xA; &lt;firwin&gt;&#xA;  , but may also be useful by themselves, for instance, to construct more complicated filters.&#xA; &lt;/firwin&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head2 ir_sinc&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;$sinc = ir_sinc($f_cut, $N);&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Return an C&amp;lt;$N&amp;gt; point sinc function representing a lowpass filter with cutoff frequency C&amp;lt;$f_cut&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;C&amp;lt;$f_cut&amp;gt; must be between 0 and 1, with 1 being Nyquist freq. The output pdl is the function C&amp;lt;sin( $f_cut * $x ) / $x&amp;gt; where $x is pdl of C&amp;lt;$N&amp;gt; uniformly spaced values ranging from C&amp;lt; - PI * ($N-1)/2&amp;gt; through C&amp;lt;PI * ($N-1)/2&amp;gt;. For what it&#39;s worth, a bit of efficiency is gained by computing the index at which C&amp;lt;$x&amp;gt; is zero, rather than searching for it.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 spectral_inverse&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;$fir_inv = spectral_inverse($fir);&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Return output kernel whose spectrum is the inverse of the spectrum of the input kernel.&lt;/p&gt; &#xA;&lt;p&gt;The number of samples in the input kernel must be odd. Input C&amp;lt;$fir&amp;gt; and output C&amp;lt;$fir_inv&amp;gt; are real-space fir filter kernels. The spectrum of the output kernel is the additive inverse with respect to 1 of the spectrum of the input kernel.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 spectral_reverse&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;$fir_rev = spectral_reverse($fir);&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Return output kernel whose spectrum is the reverse of the spectrum of the input kernel.&lt;/p&gt; &#xA;&lt;p&gt;That is, the spectrum is mirrored about the center frequency.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;John Lapeyre, C&amp;lt;&amp;lt; &#xA; &lt;jlapeyre at cpan.org&gt;&#xA;   &amp;gt;&amp;gt;&#xA; &lt;/jlapeyre&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 ACKNOWLEDGEMENTS&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE AND COPYRIGHT&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2012 John Lapeyre.&lt;/p&gt; &#xA;&lt;p&gt;This program is free software; you can redistribute it and/or modify it under the terms of either: the GNU General Public License as published by the Free Software Foundation; or the Artistic License.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://dev.perl.org/licenses/&#34;&gt;http://dev.perl.org/licenses/&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;PDL::DSP::Simple - Simple interface to windowed sinc filters.&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   use PDL::LiteF;&#xA;   use PDL::DSP::Fir::Simple;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;At present, this module provides one filtering routine. The main purpose is to provide an easy-to-use lowpass filter that only requires the user to provide the data and the cutoff frequency. However, the routines take options to give the user more control over the filtering. The module implements the filters via convolution with a kernel representing a finite impulse response function, either directly or with fft. The filter kernel is constructed from windowed sinc functions. Available filters are lowpass, highpass, bandpass, and bandreject. All window functions in L&lt;a href=&#34;PDL::DSP::Windows&#34;&gt;PDL::DSP::Windows&lt;/a&gt; are available.&lt;/p&gt; &#xA;&lt;p&gt;See L&lt;a href=&#34;PDL::DSP::Iir/moving_average&#34;&gt;PDL::DSP::Iir/moving_average&lt;/a&gt; for a moving average filter.&lt;/p&gt; &#xA;&lt;p&gt;Some of this functionality is already available in the PDL core. The modules L&lt;a href=&#34;PDL::Audio&#34;&gt;PDL::Audio&lt;/a&gt; and L&lt;a href=&#34;PDL::Stats:TS&#34;&gt;PDL::Stats:TS&lt;/a&gt; (time series) also have filtering functions.&lt;/p&gt; &#xA;&lt;p&gt;Below, the word B&#xA; &lt;order&gt;&#xA;   refers to the number of elements in the filter kernel. The default value is equal to the number of elements in the data to be filtered.&#xA; &lt;/order&gt;&lt;/p&gt; &#xA;&lt;p&gt;No functions are exported by default.&lt;/p&gt; &#xA;&lt;p&gt;=head1 FUNCTIONS&lt;/p&gt; &#xA;&lt;p&gt;=head2 filter&lt;/p&gt; &#xA;&lt;p&gt;$xf = filter($x, {OPTIONS});&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   or&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;$xf = filter($x, $kern);&lt;/p&gt; &#xA;&lt;p&gt;=head3 Examples&lt;/p&gt; &#xA;&lt;p&gt;=for example&lt;/p&gt; &#xA;&lt;p&gt;Apply lowpass filter to signal $x with a cutoff frequency of 90% of the Nyquist frequency (i.e. 45% of the sample frequency).&lt;/p&gt; &#xA;&lt;p&gt;$xf = filter($x, { fc =&amp;gt; 0.9 });&lt;/p&gt; &#xA;&lt;p&gt;Apply a highpass filter rather than the default lowpass filter&lt;/p&gt; &#xA;&lt;p&gt;$xf = filter($x, {fc =&amp;gt; 0.9 , type =&amp;gt; &#39;highpass&#39; });&lt;/p&gt; &#xA;&lt;p&gt;Apply a lowpass filter of order 20 with a blackman window, rather than the default hamming window.&lt;/p&gt; &#xA;&lt;p&gt;$xf = filter($x, {fc =&amp;gt; 0.9 , window =&amp;gt; &#39;blackman&#39; , N =&amp;gt; 20 });&lt;/p&gt; &#xA;&lt;p&gt;Apply a 10 point moving average. Note that this moving averaging is implemented via convolution. This is a relatively inefficient implementation.&lt;/p&gt; &#xA;&lt;p&gt;$xf = filter($x, {window =&amp;gt; &#39;rectangular&#39;, type =&amp;gt; &#39;window&#39;, N =&amp;gt; 10 });&lt;/p&gt; &#xA;&lt;p&gt;Return the kernel used in the convolution.&lt;/p&gt; &#xA;&lt;p&gt;($xf, $kern) = filter($x, { fc =&amp;gt; 0.9 });&lt;/p&gt; &#xA;&lt;p&gt;Apply a lowpass filter of order 20 with a tukey window with parameter I&#xA; &lt;alpha&gt;&#xA;   = 0.5.&#xA; &lt;/alpha&gt;&lt;/p&gt; &#xA;&lt;p&gt;$xf = filter($x, {fc =&amp;gt; 0.9 , window =&amp;gt; { name =&amp;gt; &#39;tukey&#39;, params =&amp;gt; 0.5 } , N =&amp;gt; 20 });&lt;/p&gt; &#xA;&lt;p&gt;=head3 OPTIONS&lt;/p&gt; &#xA;&lt;p&gt;=over&lt;/p&gt; &#xA;&lt;p&gt;=item N&lt;/p&gt; &#xA;&lt;p&gt;Order of filter. I.e. the number of points in the filter kernel. If this option is not given, or is undefined, or false, or less than zero, then the order of the filter is equal to the number of points in the data C&amp;lt;$x&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=item kern&lt;/p&gt; &#xA;&lt;p&gt;A kernel to use for convolution rather than calculating a kernel from other parameters.&lt;/p&gt; &#xA;&lt;p&gt;=item boundary&lt;/p&gt; &#xA;&lt;p&gt;Boundary condition passed to C&#xA; &lt;convolvend&gt;&#xA;  . Must be one of &#39;extend&#39;, &#39;truncate&#39;, &#39;periodic&#39;. See L&#xA;  &lt;a href=&#34;PDL::ImageND&#34;&gt;PDL::ImageND&lt;/a&gt;.&#xA; &lt;/convolvend&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;All other options to C&#xA; &lt;filter&gt;&#xA;   are passed to the function L&#xA;  &lt;a href=&#34;PDL::DSP::Fir/firwin&#34;&gt;PDL::DSP::Fir/firwin&lt;/a&gt; which creates the filter kernel. L&#xA;  &lt;a href=&#34;PDL::DSP::Fir/firwin&#34;&gt;PDL::DSP::Fir/firwin&lt;/a&gt; in turn passes options to L&#xA;  &lt;a href=&#34;PDL::DSP::Windows:window&#34;&gt;PDL::DSP::Windows:window&lt;/a&gt;. The option C&#xA;  &lt;window&gt;&#xA;    is either a string giving the name of the window function, or an anonymous hash of options to pass to L&#xA;   &lt;a href=&#34;PDL::DSP::Windows:window&#34;&gt;PDL::DSP::Windows:window&lt;/a&gt;. For example C&amp;lt;&amp;lt; { name =&amp;gt; &#39;window_name&#39;, ... } &amp;gt;&amp;gt;.&#xA;  &lt;/window&gt;&#xA; &lt;/filter&gt;&lt;/p&gt; &#xA;&lt;p&gt;If the second argument is not a hash of options then it is interpreted as a kernel C&amp;lt;$kern&amp;gt; to be convolved with the C&amp;lt;$data&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;If called in a list context, the filtered data and kernel ($dataf,$kern) are returned.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 testdata&lt;/p&gt; &#xA;&lt;p&gt;$x = testdata($Npts, $freqs, $amps)&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;$x = testdata(1000, [5,100], [1, .1] );&lt;/p&gt; &#xA;&lt;p&gt;Generate a signal by summing sine functions of differing frequencies. The signal has $Npts elements. $freqs is an array of frequencies, and $amps an array of amplitudes for each frequency. The frequencies should be between 0 and 1, with 1 representing the nyquist frequency.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;John Lapeyre, C&amp;lt;&amp;lt; &#xA; &lt;jlapeyre at cpan.org&gt;&#xA;   &amp;gt;&amp;gt;&#xA; &lt;/jlapeyre&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE AND COPYRIGHT&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2012 John Lapeyre.&lt;/p&gt; &#xA;&lt;p&gt;This program is free software; you can redistribute it and/or modify it under the terms of either: the GNU General Public License as published by the Free Software Foundation; or the Artistic License.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://dev.perl.org/licenses/&#34;&gt;http://dev.perl.org/licenses/&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>karupanerura/p5-Net-DNS-Hosts</title>
    <updated>2022-08-19T01:45:11Z</updated>
    <id>tag:github.com,2022-08-19:/karupanerura/p5-Net-DNS-Hosts</id>
    <link href="https://github.com/karupanerura/p5-Net-DNS-Hosts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;override request&#39;s host like /etc/hosts&lt;/p&gt;&lt;hr&gt;&lt;p&gt;package Net::DNS::Hosts; use 5.008_001; use strict; use warnings; use utf8;&lt;/p&gt; &#xA;&lt;p&gt;our $VERSION = &#39;0.01&#39;;&lt;/p&gt; &#xA;&lt;p&gt;use Socket ();&lt;/p&gt; &#xA;&lt;p&gt;sub import { my $class = shift; $class-&amp;gt;set_super_inet_aton( *Socket::inet_aton{CODE} ); $class-&amp;gt;disable_override; { no warnings &#39;redefine&#39;; *Socket::inet_aton = sub { $class-&amp;gt;inet_aton-&amp;gt;(@_); }; } }&lt;/p&gt; &#xA;&lt;p&gt;my $SUPER_inet_aton; sub set_super_inet_aton { $SUPER_inet_aton = $_[1] }; sub super_inet_aton { $SUPER_inet_aton };&lt;/p&gt; &#xA;&lt;p&gt;my $inet_aton; sub set_inet_aton { $inet_aton = $_[1] }; sub inet_aton { $inet_aton };&lt;/p&gt; &#xA;&lt;p&gt;my %HOSTS; sub reset_hosts { %HOSTS = () } sub hosts { %HOSTS }&lt;/p&gt; &#xA;&lt;p&gt;sub scope { my $class = shift;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$class-&amp;gt;reset_hosts;&#xA;$class-&amp;gt;register_host(@_);&#xA;$class-&amp;gt;enable_override;&#xA;return Net::DNS::Hosts::Guard-&amp;gt;new(sub {&#xA;    $class-&amp;gt;reset_hosts;&#xA;    $class-&amp;gt;disable_override;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;sub register_host { my $class = shift; my %hosts = @_;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;for my $host (keys %hosts) {&#xA;    $class-&amp;gt;hosts-&amp;gt;{$host} = $class-&amp;gt;super_inet_aton-&amp;gt;($hosts{$host});&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;sub registered_peer_addr { my ($class, $host) = @_;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;return unless exists $class-&amp;gt;hosts-&amp;gt;{$host};&#xA;return $class-&amp;gt;hosts-&amp;gt;{$host};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;sub enable_override { my $class = shift; $class-&amp;gt;set_inet_aton( sub { return $class-&amp;gt;registered_peer_addr(@&lt;em&gt;) || $class-&amp;gt;super_inet_aton-&amp;gt;(@&lt;/em&gt;); } ); }&lt;/p&gt; &#xA;&lt;p&gt;sub disable_override { my $class = shift; $class-&amp;gt;set_inet_aton( sub { return $class-&amp;gt;super_inet_aton-&amp;gt;(@_); } ); }&lt;/p&gt; &#xA;&lt;p&gt;package # for no index Net::DNS::Hosts::Guard; use strict; use warnings; use utf8;&lt;/p&gt; &#xA;&lt;p&gt;sub new { my($class, $code) = @_;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;return bless +{&#xA;    code =&amp;gt; $code&#xA;} =&amp;gt; $class;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;sub fire { shift-&amp;gt;{code}-&amp;gt;(); }&lt;/p&gt; &#xA;&lt;p&gt;sub DESTROY { shift-&amp;gt;fire(); }&lt;/p&gt; &#xA;&lt;p&gt;1; &lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;Net::DNS::Hosts - Perl extention to do something&lt;/p&gt; &#xA;&lt;p&gt;=head1 VERSION&lt;/p&gt; &#xA;&lt;p&gt;This document describes Net::DNS::Hosts version 0.01.&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;use Net::DNS::Hosts;&#xA;use LWP::UserAgent;&#xA;&#xA;my $scope = Net::DNS::Hosts-&amp;gt;scope(&#xA;    &#39;www.cpan.org&#39; =&amp;gt; &#39;127.0.0.1&#39;&#xA;);&#xA;&#xA;# override request hosts with peer addr defined above&#xA;my $ua  = LWP::UserAgent-&amp;gt;new;&#xA;my $res = $ua-&amp;gt;get(&#34;http://www.cpan.org/&#34;);&#xA;print $res-&amp;gt;content; # is same as &#34;http://127.0.0.1/&#34; content&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;h1&gt;TODO&lt;/h1&gt; &#xA;&lt;p&gt;=head1 INTERFACE&lt;/p&gt; &#xA;&lt;p&gt;=head2 Functions&lt;/p&gt; &#xA;&lt;p&gt;=head3 C&amp;lt;&amp;lt; hello() &amp;gt;&amp;gt;&lt;/p&gt; &#xA;&lt;h1&gt;TODO&lt;/h1&gt; &#xA;&lt;p&gt;=head1 DEPENDENCIES&lt;/p&gt; &#xA;&lt;p&gt;Perl 5.8.1 or later.&lt;/p&gt; &#xA;&lt;p&gt;=head1 BUGS&lt;/p&gt; &#xA;&lt;p&gt;All complex software has bugs lurking in it, and this module is no exception. If you find a bug please either email me, or add the bug to cpan-RT.&lt;/p&gt; &#xA;&lt;p&gt;=head1 SEE ALSO&lt;/p&gt; &#xA;&lt;p&gt;L&#xA; &lt;perl&gt;&lt;/perl&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;Kenta Sato E&#xA; &lt;lt&gt;&#xA;  &lt;a href=&#34;mailto:karupa@cpan.orgE&#34;&gt;karupa@cpan.orgE&lt;/a&gt;&#xA;  &lt;gt&gt;&lt;/gt&gt;&#xA; &lt;/lt&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE AND COPYRIGHT&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2012, Kenta Sato. All rights reserved.&lt;/p&gt; &#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt;</summary>
  </entry>
</feed>