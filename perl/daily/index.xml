<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-17T01:42:02Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Perl-Oshun/oshun</title>
    <updated>2023-07-17T01:42:02Z</updated>
    <id>tag:github.com,2023-07-17:/Perl-Oshun/oshun</id>
    <link href="https://github.com/Perl-Oshun/oshun" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Declarative data validation for variables and subroutines&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Not So Quick Start&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gist.github.com/thoughtstream/08b7fd48b09c99ae47d6d9f82b913986&#34;&gt;Here&#39;s the full spec&lt;/a&gt;. it&#39;s very long and much of the current discussion is in ... &lt;a href=&#34;https://github.com/Ovid/oshun/discussions&#34;&gt;discussions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Primary change from spec might be to use established &lt;code&gt;my TYPE VARLIST&lt;/code&gt; syntax from &lt;code&gt;perldoc -f my&lt;/code&gt; instead of attributes.&lt;/p&gt; &#xA;&lt;h1&gt;This is Oshun&lt;/h1&gt; &#xA;&lt;p&gt;Oshun is a Nigerian Yoruba river deity. She is a protector, a savior.&lt;/p&gt; &#xA;&lt;p&gt;She will protect your data.&lt;/p&gt; &#xA;&lt;p&gt;In software terms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub fibonacci :returns(UINT) ($nth :of(PositiveInt)) {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: do not worry about that syntax. It&#39;s not real. It&#39;s just a placeholder for whatever will be agreed upon. We&#39;ll get to that later.&lt;/p&gt; &#xA;&lt;p&gt;Oshun is not a module to be installed (though there is code and almost 200K tests). Instead, it&#39;s intended to be a specification like &lt;a href=&#34;https://github.com/Ovid/Cor&#34;&gt;Corinna&lt;/a&gt;, with the goal of seeing if we can get it into the Perl core.&lt;/p&gt; &#xA;&lt;h1&gt;History&lt;/h1&gt; &#xA;&lt;p&gt;In December of 2022, I again wrote about &lt;a href=&#34;https://gist.github.com/Ovid/5ae3752e260219a575ddfdea4c2194f7&#34;&gt;a type system for Perl&lt;/a&gt;. I&#39;ve done this before and the discussion is usually positive, though given that we&#39;re a community, there are those who disagree with the need to have them.&lt;/p&gt; &#xA;&lt;p&gt;Shortly thereafter, Damian Conway and I started talking and he shared a private gist with me. It was an incredibly detailed plan for runtime data checks. (The term &#34;type&#34; is avoided because of the baggage it carries). A few others were quietly invited to the conversation.&lt;/p&gt; &#xA;&lt;p&gt;We spent a few months discussing this and he wrote a prototype, which is the code in this repository. The protoype is &lt;strong&gt;ALPHA&lt;/strong&gt; code and absolutely should not be used in production. Instead, it&#39;s a proof of concept to explore the problem space. It&#39;s also a way to get feedback from the community, which is why this repository is here.&lt;/p&gt; &#xA;&lt;p&gt;After a few months of discussion, &lt;a href=&#34;https://gist.github.com/thoughtstream/08b7fd48b09c99ae47d6d9f82b913986&#34;&gt;Damian rewrote that gist&lt;/a&gt;. It covers the full spec, but it&#39;s long and daunting. I&#39;ll just touch on key points here.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Damian regrets that, for personal reasons, he is not able to continue working on Oshun at this time. He might answer questions, but he does not have much free time available right now.&lt;/p&gt; &#xA;&lt;h1&gt;Why &#34;data checks&#34;?&lt;/h1&gt; &#xA;&lt;p&gt;We&#39;re not using the word &#34;type&#34; because:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Computer scientists have reasonable differences about what they want from a type system&lt;/li&gt; &#xA; &lt;li&gt;Computer programmers have screaming matches&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We&#39;d like to avoid screaming matches.&lt;/p&gt; &#xA;&lt;p&gt;What I want out a &#34;type system&#34; is probably not feasible in Perl and certainly won&#39;t match everyone&#39;s expectations. So we&#39;ve taken a look at what Perl developers currently do. &lt;a href=&#34;https://metacpan.org/pod/Type::Tiny&#34;&gt;Type::Tiny&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Moose&#34;&gt;Moose&lt;/a&gt; (and &lt;code&gt;Moo&lt;/code&gt;) are heavy inspirations for this work. We also looked at &lt;a href=&#34;https://metacpan.org/pod/Dios&#34;&gt;Dios&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Zydeco&#34;&gt;Zydeco&lt;/a&gt;, Raku, and other languages for inspiration, but mostly this matches what Perl is doing today, keeping in mind that popular systems are working within the limitation of Perl. Just as Corinna is better because Sawyer X told me to design something great and not worry about Perl&#39;s current limitations, so are data checks designed to give us what we want without worrying about Perl&#39;s limitations.&lt;/p&gt; &#xA;&lt;h1&gt;What we need to design&lt;/h1&gt; &#xA;&lt;p&gt;There are two aspects of data checks: syntax and semantics. Obviously these are tightly coupled, but we can discuss them separately. If we can get basic agreement on the syntax and core semantics (there will always be edge cases), then we can move forward on writing up the full specification.&lt;/p&gt; &#xA;&lt;h2&gt;Syntax&lt;/h2&gt; &#xA;&lt;p&gt;The syntax is probably the hard part. The initial design was made on the possibly unfounded assumption that P5P would reject any syntax which might impact existing code. This is why we have the &lt;code&gt;:returns&lt;/code&gt; and &lt;code&gt;:of&lt;/code&gt; keywords. &lt;code&gt;perldoc -f my&lt;/code&gt; has the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my VARLIST&#xA;    my TYPE VARLIST&#xA;    my VARLIST : ATTRS&#xA;    my TYPE VARLIST : ATTRS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We very much want that &lt;code&gt;TYPE&lt;/code&gt; syntax. Fortunately, because data checks are lexically scoped and not global, it turns out that we probably &lt;em&gt;can&lt;/em&gt; have the type &lt;code&gt;TYPE&lt;/code&gt; syntax, but we need to be careful.&lt;/p&gt; &#xA;&lt;p&gt;So we have the following syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub fibonacci :returns(UINT) ($nth :of(PositiveInt)) {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But let&#39;s dig in. We&#39;ll consider naming and declaration separately.&lt;/p&gt; &#xA;&lt;h3&gt;Naming&lt;/h3&gt; &#xA;&lt;p&gt;We have two kinds of data check declarations: built-in and user-defined. Built-in checks were defined as all uppercase: &lt;code&gt;INT&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, etc. The reason is this problem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub f_to_c :returns(NUM) ($f :of(NUM)) {...}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;f_to_c(32)&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;f_to_c(-1000)&lt;/code&gt; returns &lt;code&gt;-573.333333333333&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, that doesn&#39;t really make sense, since that&#39;s below absolute zero. So we have user-defined checks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;check Celsius    :isa(NUM[-273.14..inf]);&#xA;check Fahrenheit :isa(NUM[−459.67..inf]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which gives us a much safer, and self-documenting signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub f_to_c :returns(Celsius) ($f :of(Fahrenheit) {...}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, if you discover that your user-defined check is wrong, you can fix it and it will be globally applied. This is a huge win (er, except when your code doesn&#39;t really match the check).&lt;/p&gt; &#xA;&lt;p&gt;UPPER-CASE CHECKS were designed to be a subtle disaffordance to encourage people to write custom checks that more accurately reflect their intent.&lt;/p&gt; &#xA;&lt;p&gt;They also clearly distinguished between built-in and user-defined checks.&lt;/p&gt; &#xA;&lt;p&gt;However, the SHOUTY checks were a touch controversial in some earlier private discussions. You don&#39;t always need a user-defined check. Sometimes it&#39;s just burdensome and if you find a built-in check is wrong, you can later upgrade that to a user-defined check.&lt;/p&gt; &#xA;&lt;p&gt;Another benefit of data checks is that tests are easier. I used to program in Java and I wrote tests using &lt;a href=&#34;https://junit.org/junit5/&#34;&gt;JUnit&lt;/a&gt;. You know what I didn&#39;t test? I didn&#39;t have to test what would happen if the type I passed in was not an expected type. I didn&#39;t have to write tests to verify that the structure I got back was correct. The compiler caught that for me. I could focus on testing the actual functional bits of my code, not the infrastructure. In a sense, Java tests could be more compact &lt;em&gt;and&lt;/em&gt; reliable than Perl tests.&lt;/p&gt; &#xA;&lt;p&gt;But getting back to the shouty checks ...&lt;/p&gt; &#xA;&lt;p&gt;Or we could look at how other languages deal with this. For Java, primitive types are lower-case and include things like &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and so on. These map directly to what the underlying hardware supports. These correspond to the &#34;built-in&#34; checks for Oshun, with the caveat that we focus on types that map naturally to what &lt;em&gt;perl&lt;/em&gt; supports, not what the underlying hardware expects. For example, we have a &lt;code&gt;GLOB&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my    $my_scalar    :of(GLOB) = *STDOUT;&#xA;our   $our_scalar   :of(GLOB) = *STDERR;&#xA;state $state_scalar :of(GLOB) = *STDIN;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Java also has non-primitive types, which are defined by the programmer. These correspond to our user-defined checks. In Java, these are defined using class names. In Oshun, we use &lt;code&gt;check&lt;/code&gt; and the name of a check is an unqualified Perl identifier, which must contain at least one upper-case character and at least one lower-case character.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;# Newly assigned values must never decrease...&#xA;check Monotonic :isa(NUM) ($value, %value) { $value &amp;gt;= $value{old} }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, since SHOUTY checks are controversial, we could use all lower-case for the built-in checks and require user-defined checks to start with an upper-case letter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;# @data must be an array of hashes, where the hash keys must be integers&#xA;# and values must be arrayrefs of Account objects.&#xA;my @data :of(hash[int =&amp;gt; array[obj[Account]]]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Declaration&lt;/h3&gt; &#xA;&lt;p&gt;That brings us to the next contentious issue: how do we declare data checks?&lt;/p&gt; &#xA;&lt;p&gt;We used attributes because they were not likely to conflict with existing code. Further, they correspond to the &lt;a href=&#34;https://ovid.github.io/articles/language-design-consistency.html&#34;&gt;KIM syntax&lt;/a&gt; which Corinna now uses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# KEYWORD IDENTIFIER MODIFIERS                   SETUP&#xA;  sub     f_to_c     :returns(NUM) ($f :of(NUM)) {...}&#xA;&#xA;# KEYWORD IDENTIFIER   MODIFIERS SETUP&#xA;  my      $fahrenheit :of(NUM)   = 32;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Personally, I would like most new Perl features to use KIM. It&#39;s very consistent and avoids the issue of adding a ton of new keywords to the language. &lt;em&gt;More&lt;/em&gt; consistency to Perl is a good thing, but many prefer the quirky nature of our beloved langauge.&lt;/p&gt; &#xA;&lt;p&gt;Responses to the proposed syntax were mixed. Many people prefer a syntax like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my hash[int =&amp;gt; array[obj[Account]]] @data;&#xA;my uint $count = 1;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my @hash hash[int =&amp;gt; array[obj[Account]]];&#xA;my $count uint = 1;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Still others were happy with the KIM syntax, but wanted to use anything other than &lt;code&gt;:of&lt;/code&gt;. &lt;code&gt;:is&lt;/code&gt;, &lt;code&gt;:check&lt;/code&gt;, &lt;code&gt;:contract&lt;/code&gt; were all suggested. I won&#39;t take a position here, other than to say that whatever syntax we should choose should only be cumbersome for things we think we should actively discourage.&lt;/p&gt; &#xA;&lt;h3&gt;Return Values From Subroutines&lt;/h3&gt; &#xA;&lt;p&gt;If we don&#39;t use the &lt;code&gt;:returns(...)&lt;/code&gt; syntax for specifying the checks on values subs/methods return, what then? Looking at &lt;a href=&#34;https://docs.raku.org/language/functions#Return_type_constraints&#34;&gt;how Raku handles this&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub foo(--&amp;gt; Int)      {}; say &amp;amp;foo.returns; # OUTPUT: «(Int)␤»&#xA;sub foo() returns Int {}; say &amp;amp;foo.returns; # OUTPUT: «(Int)␤»&#xA;sub foo() of Int      {}; say &amp;amp;foo.returns; # OUTPUT: «(Int)␤»&#xA;my Int sub foo()      {}; say &amp;amp;foo.returns; # OUTPUT: «(Int)␤» &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I don&#39;t know the design discussions which led Raku to that place, but I don&#39;t think it&#39;s controversial to suggest that Perl is not Raku and we probably don&#39;t want that many different ways of declaring the return check. But if we don&#39;t use &lt;code&gt;:returns(...)&lt;/code&gt;, what then?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub int num (str $name) {...}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What&#39;s the name of that subroutine? I think it&#39;s &lt;code&gt;num&lt;/code&gt;, but it might look like &lt;code&gt;int&lt;/code&gt; to someone else. Who knows? We could do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;int sub num (str $name) {...}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s much clearer, but if &lt;code&gt;&amp;amp;int&lt;/code&gt; is a function in this namespace, I imagine that&#39;s going to create all sorts of parsing problems (not to mention that this will likely confict with existing code). We could do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub num (str $name) returns int {...}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I think that&#39;s the clearest, but it&#39;s also the most verbose. I have no strong preference here, so long as whatever we do it doesn&#39;t conflict with existing code and is easy to use.&lt;/p&gt; &#xA;&lt;h2&gt;Semantics&lt;/h2&gt; &#xA;&lt;p&gt;For a full discussion of the semantics, &lt;a href=&#34;https://gist.github.com/thoughtstream/08b7fd48b09c99ae47d6d9f82b913986&#34;&gt;check Damian&#39;s gist&lt;/a&gt;. Here&#39;s the short version, including the rather controversial final point.&lt;/p&gt; &#xA;&lt;h3&gt;Checks are on the variable, not the data&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $foo :of(INT) = 4;&#xA;$foo = &#39;hello&#39;; # fatal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $foo :of(INT) = 4;&#xA;my $bar = $foo;&#xA;$bar = &#39;hello&#39;; # legal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is because we don&#39;t want checks to have &#34;infectious&#34; side effects that might surprise you. The developer should have full control over the data checks.&lt;/p&gt; &#xA;&lt;h3&gt;No type inference&lt;/h3&gt; &#xA;&lt;p&gt;No surprises. The developer should have full control over the data checks.&lt;/p&gt; &#xA;&lt;p&gt;I can no longer find the article, but I read a long post from a company explaining why they had abandoned their use of type inference.&lt;/p&gt; &#xA;&lt;p&gt;The absolutely loved it, but they spent so much time trying to patch third-party modules that they gave up. They were spending as much time trying to fix other&#39;s code than writing their own.&lt;/p&gt; &#xA;&lt;p&gt;This is a danger of retrofitting a system like &#34;data checks&#34; onto an existing language. Thus, we&#39;re being extremely conservative.&lt;/p&gt; &#xA;&lt;h3&gt;Signature checks&lt;/h3&gt; &#xA;&lt;p&gt;We need to work out the syntax, but the current plan is something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub count_valid :returns(UINT) (@customers :of(OBJ[Customer])) {&#xA;&#x9;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;@customers&lt;/code&gt; variable should maintain the check in the body of the sub, but the return check is applied once and only once on the data returned at the time that it&#39;s returned.&lt;/p&gt; &#xA;&lt;h3&gt;Scalars require valid assignments&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $total :of(NUM); # fatal, because undef fails the check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is per previous discussions. Many languages allow this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;int foo;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But as soon as you assign something to &lt;code&gt;foo&lt;/code&gt;, it&#39;s fatal if it&#39;s not an integer. For Perl, that&#39;s a bit tricky as there&#39;s no difference between uninitialized and undefined. While using that variable prior to assignment is fatal in many languages, that would be more difficult in Perl. Thus, we require a valid assignment.&lt;/p&gt; &#xA;&lt;p&gt;As a workaround, this is bad, but valid:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $total :of(INT|UNDEF);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This restriction doesn&#39;t apply to arrays or hashes because being empty trivially passes the check.&lt;/p&gt; &#xA;&lt;h3&gt;Fatal&lt;/h3&gt; &#xA;&lt;p&gt;By default, a failed check is fatal. We have provisions to downgrade them to warnings or disable them completely.&lt;/p&gt; &#xA;&lt;h3&gt;Internal representation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $foo :of(INT) = &#34;0&#34;;&#xA;Dump($foo);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;0&lt;/code&gt; naturally coerces to an integer, so that&#39;s allowed. However, we don&#39;t plan (for the MVP) to guarantee that Dump shows an &lt;code&gt;IV&lt;/code&gt; instead of a &lt;code&gt;PV&lt;/code&gt;. We&#39;re hoping that can be addressed post-MVP.&lt;/p&gt; &#xA;&lt;h3&gt;User-defined checks&lt;/h3&gt; &#xA;&lt;p&gt;Users should be able to define their own checks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;check LongStr :params($N :of(PosInt)) :isa(STR) ($n) { length $n &amp;gt;= $N }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above would allow this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $name :of(LongStr[10]) = get_name(); # must be at least 10 characters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The body of a check definition should return a true or false value, or die/croak with a more useful message (exceptions would be strongly preferred), but that&#39;s a battle for another day. A &lt;code&gt;Loki&lt;/code&gt; project, perhaps?)&lt;/p&gt; &#xA;&lt;p&gt;A user-defined check is not allowed to change the value of the variable passed in. Otherwise, we could not safely disable checks on demand (coercions are not planned for the MVP, but we have them specced and they use a separate syntax).&lt;/p&gt; &#xA;&lt;p&gt;User-defined checks could be post-MVP, but it&#39;s unclear to me how useful checks would be without them.&lt;/p&gt; &#xA;&lt;h3&gt;Checks are on assignment to the variable&lt;/h3&gt; &#xA;&lt;p&gt;This is probably the most problematic bit.&lt;/p&gt; &#xA;&lt;p&gt;A check applied to a variable is not an invariant on that variable. It&#39;s a prerequisite for assignment to that variable.&lt;/p&gt; &#xA;&lt;p&gt;An invariant on the variable would guarantee that the contents of the variable must always meet a given constraint; a &#34;prerequisite for assignment&#34; only guarantees that each element must be assigned values that meet the constraint at the moment they are assigned.&lt;/p&gt; &#xA;&lt;p&gt;So an array such as &lt;code&gt;my @data :of(HASH[INT])&lt;/code&gt; only requires that each element of &lt;code&gt;@data&lt;/code&gt; must be assigned a hashref whose values are integers. If you were to subsequently modify an element like so (with the caveat that the two lines aren&#39;t exactly equivalent):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;$data[$idx]       = { $key =&amp;gt; &#39;not an integer&#39; }; # fatal&#xA;$data[$idx]{$key} = &#39;not an integer&#34;;             # not fatal !&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second assignment is not modifying &lt;code&gt;@data&lt;/code&gt; directly, only retrieving a value from it and modifying the contents of an entirely different variable through the retrieved reference value.&lt;/p&gt; &#xA;&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; specify that checks are invariants, instead of prerequisites, but that would require that any reference value stored within a checked arrayref or hashref would have to have checks automatically and recursively applied to them as well, which would greatly increase the cost of checking, and might also lead to unexpected action-at-a-distance, when the now-checked references are modified through some other access mechanism.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, we would have to ensure that such auto-subchecked references were appropriately “de-checked” if they are ever removed from the checked container. And how would we manage any conflict if the nested referents happened to have their own (possibly inconsistent) checks?&lt;/p&gt; &#xA;&lt;p&gt;So the checks are simply assertions on direct assignments, rather than invariants over a variable’s entire nested data structure.&lt;/p&gt; &#xA;&lt;p&gt;This is unsatisfying, but we&#39;re playing with the matches we have, not the flamethrower we want.&lt;/p&gt; &#xA;&lt;h1&gt;Coercions&lt;/h1&gt; &#xA;&lt;p&gt;Many people want coercions. We have a plan for them, but they&#39;re not part of the MVP. However, we&#39;re trying to make sure that they can be added later if necessary. Currently, there are some significant limitations to them. First, if we downgrade checks to warnings or disable them, we can&#39;t do that with coercions because the code expects the coerced value. Any user-defined check which is built from a coercion would automatically be upgraded to a coercion.&lt;/p&gt; &#xA;&lt;p&gt;Second, coercions are action at a distance. Thus, if you&#39;re trying to debug why a method failed, you might not realize that the method was passed a UUID instead of a &lt;code&gt;Customer&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re not ruling out coercions, but they introduce new problems we&#39;d rather not have in the MVP&lt;/p&gt; &#xA;&lt;h1&gt;Compile-time checks&lt;/h1&gt; &#xA;&lt;p&gt;We&#39;re not planning on compile-time checks. We&#39;re not ruling them out, but they&#39;re not for the MVP. However, we can envision a future where we have this being a compile-time failure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $foo :of(INT) = &#34;bar&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It would be nice to see this a a compile-time failure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub find_customer :returns(OBJ[Customer]) ($self, $id :of(UUID)) {&#xA;    ...&#xA;}&#xA;&#xA;# in other code:&#xA;my $customer :of(HASH) = $object-&amp;gt;find_customer($UUID);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, due to the extreme late binding in Perl, that&#39;s like to be impossible, so we&#39;re simply not worrying about it.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s only mentioned now because people have asked about this a few times.&lt;/p&gt; &#xA;&lt;h1&gt;About the &lt;code&gt;Data::Checks&lt;/code&gt; module&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;code&gt;Data::Checks&lt;/code&gt; module is a proof-of-concept implementation of the above. However, due to current limitations of Perl, it&#39;s a scary combination of &lt;a href=&#34;https://metacpan.org/pod/PPR&#34;&gt;PPR&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Filter::Simple&#34;&gt;Filter::Simple&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Variable::Magic&#34;&gt;Variable::Magic&lt;/a&gt;, and tied variables. It&#39;s not pretty, but it works. However, Damian&#39;s very clear that this is an unholy abomination (my words, not his, but he was very clear that his code is a proof-of-concept and not something he&#39;d ever release).&lt;/p&gt; &#xA;&lt;p&gt;Amongst other issues that had to be dealt with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Variable::Magic&lt;/code&gt; has significant limitations with array and hashrefs&lt;/li&gt; &#xA; &lt;li&gt;Attributes are not allowed inside subroutine signatures&lt;/li&gt; &#xA; &lt;li&gt;Fast parsing and rewriting of Perl documents is hard&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After he turned it over to me, I fixed a bug and rewrote part of it to make some expectations clearer. In particular, &lt;code&gt;use Data::Checks;&lt;/code&gt; is equivalent to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;use strict;&#xA;use warnings;&#xA;use v5.22;&#xA;use experimental &#39;signatures&#39;;&#xA;use Data::Checks::Parser;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Data::Checks::Parser&lt;/code&gt; module is the core of the module and was originally named &lt;code&gt;Data::Checks&lt;/code&gt; (to be fair &lt;code&gt;Data::Checks::Parser&lt;/code&gt; is a terrible name because it&#39;s rewriting your code, not just parsing it).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ingydotnet/lingy</title>
    <updated>2023-07-17T01:42:02Z</updated>
    <id>tag:github.com,2023-07-17:/ingydotnet/lingy</id>
    <link href="https://github.com/ingydotnet/lingy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lingy&lt;/h1&gt; &#xA;&lt;p&gt;A Clojure Platform for Perl&lt;/p&gt; &#xA;&lt;h1&gt;Synopsis&lt;/h1&gt; &#xA;&lt;p&gt;Run the Lingy REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ lingy&#xA;Lingy 0.1.12 [perl]&#xA;&#xA;user=&amp;gt; (p&amp;lt;TAB&amp;gt;&#xA;pos?     println  prn      pr-str&#xA;user=&amp;gt; (prn &#34;Hello, world!&#34;)&#xA;&#34;Hello, world!&#34;&#xA;nil&#xA;user=&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or a Lingy one-liner:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ lingy -e &#39;(println &#34;Hello, world!&#34;)&#39;&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or run a Lingy program file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;(println &#34;Hello, world!&#34;)&#39; &amp;gt; hello.ly&#xA;$ lingy hello.ly&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or run an example Lingy program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ wget -q https://raw.githubusercontent.com/ingydotnet/lingy/main/eg/99-bottles.ly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cat 99-bottles.ly&#xA;(defn main [number]&#xA;  (let [&#xA;    paragraphs (map paragraph (range number 0 -1)) ]&#xA;    (map println paragraphs)))&#xA;&#xA;(defn paragraph [num]&#xA;  (str&#xA;    (bottles num) &#34; of beer on the wall,\n&#34;&#xA;    (bottles num) &#34; of beer.\n&#34;&#xA;    &#34;Take one down, pass it around.\n&#34;&#xA;    (bottles (dec num)) &#34; of beer on the wall.\n&#34;))&#xA;&#xA;(defn bottles [n]&#xA;  (cond&#xA;    (= n 0) &#34;No more bottles&#34;&#xA;    (= n 1) &#34;1 bottle&#34;&#xA;    :else (str n &#34; bottles&#34;)))&#xA;&#xA;(main (nth *ARGV* 0 99))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ lingy 99-bottles.ly 3&#xA;3 bottles of beer on the wall,&#xA;3 bottles of beer.&#xA;Take one down, pass it around.&#xA;2 bottles of beer on the wall.&#xA;&#xA;2 bottles of beer on the wall,&#xA;2 bottles of beer.&#xA;Take one down, pass it around.&#xA;1 bottle of beer on the wall.&#xA;&#xA;1 bottle of beer on the wall,&#xA;1 bottle of beer.&#xA;Take one down, pass it around.&#xA;No more bottles of beer on the wall.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;Lingy is in ALPHA status.&lt;/p&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;Lingy is an implementation of the Clojure Platform for Perl that is written in Perl and hosted by Perl. Programs and modules written in Lingy have full access to Perl and its CPAN modules.&lt;/p&gt; &#xA;&lt;p&gt;Perl modules can be written in Lingy and distributed on CPAN. (In the future) Lingy code is compiled to a bytecode and should perform on the same order of magnitude as XS modules.&lt;/p&gt; &#xA;&lt;p&gt;Since Lingy will be a complete Clojure implementation, it should be able to run programs written in Clojure and make use of libraries written in Clojure.&lt;/p&gt; &#xA;&lt;p&gt;Clojure is a language that cleanly solves many of the problems of Java including making concurrency simple, and writing functional programs with mostly immutable data types. It is a Lisp dialect that is hosted by Java and compiles to JVM byte code. It has access to any libraries that target the JVM.&lt;/p&gt; &#xA;&lt;p&gt;Much of the Clojure language is written in Clojure (self hosted) and Lingy actually uses the Clojure source code.&lt;/p&gt; &#xA;&lt;p&gt;A variant of Clojure called ClojureScript uses the same Clojure source code but is hosted by JavaScript with full access to NPM modules. Lingy also intends to eventually be ported to and hosted by many other programming languages.&lt;/p&gt; &#xA;&lt;p&gt;Lingy started as a Perl &lt;a href=&#34;https://github.com/ingydotnet/mal/tree/perl.2/impls/perl.2&#34;&gt;implementation&lt;/a&gt; of the &lt;a href=&#34;https://github.com/kanaka/mal&#34;&gt;Make a Lisp&lt;/a&gt; project. This provided a bare-bones Clojure-inspired Lisp interpreter from which Lingy has grown upon.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;The current implementation of Lingy is packaged for installation as a &lt;a href=&#34;https://metacpan.org/pod/Lingy&#34;&gt;Perl module distribution package on CPAN&lt;/a&gt;. This is obvious if you are reading this from CPAN now, but maybe not if you are reading this from the &lt;a href=&#34;https://github.com/ingydotnet/lingy&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to install Lingy is using the &lt;code&gt;cpanm&lt;/code&gt; Perl/CPAN installation tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cpanm Lingy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;cpanm&lt;/code&gt; command is available as a software install on most modern systems, but if you are having trouble finding it see these &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus#INSTALLATION&#34;&gt;simple instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: See &#34;Hacking on Lingy&#34; below if you want to install from source and/or hack on the Lingy source code yourself (and hopefully contribute to the project!).&lt;/p&gt; &#xA;&lt;h1&gt;&lt;code&gt;lingy&lt;/code&gt; CLI Usage&lt;/h1&gt; &#xA;&lt;p&gt;The Lingy language installs a command-line program called &lt;code&gt;lingy&lt;/code&gt;. You can use this command to run Lingy programs, start a Lingy REPL or run Lingy one-liner expressions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;lingy --repl&lt;/code&gt; (or just &lt;code&gt;lingy&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;Starts a Lingy interactive REPL. The REPL has readline support that includes:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Command history&lt;/li&gt; &#xA;   &lt;li&gt;CTL-R searching&lt;/li&gt; &#xA;   &lt;li&gt;Parentheses match highlighting&lt;/li&gt; &#xA;   &lt;li&gt;CTL-C to abort a command w/o leaving REPL&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Use CTL-D to exit the REPL&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;lingy program.ly foo bar&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Run a Lingy program passing in arguments. Arguments are available in Lingy as &lt;code&gt;*ARGV*&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cat program.ly | lingy - foo bar&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Run a Lingy program from STDIN and pass in arguments. The &lt;code&gt;-&lt;/code&gt; means run from STDIN instead of a file. If there are no arguments you can omit the &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;lingy -e &#39;(println &#34;Hello&#34; (nth *ARGV* 0))&#39; world&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Run a Lingy one-liner with arguments.&lt;/p&gt; &lt;p&gt;When used with &lt;code&gt;--repl&lt;/code&gt;, run the &lt;code&gt;-e&lt;/code&gt; code first, then enter the REPL.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;code&gt;lingy&lt;/code&gt; CLI Options&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-e &amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;--eval=&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A Lingy string to evaluate.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;--repl&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Start a Lingy REPL. Can be used with &lt;code&gt;-e&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--ppp&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Print the Lingy compiled AST for a &lt;code&gt;-e&lt;/code&gt; expression.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--xxx&lt;/code&gt;&lt;/p&gt; &lt;p&gt;YAML dump the Lingy compiled AST for a &lt;code&gt;-e&lt;/code&gt; expression.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Lingy REPL Usage&lt;/h1&gt; &#xA;&lt;p&gt;If you run &lt;code&gt;lingy --repl&lt;/code&gt; (or just &lt;code&gt;lingy&lt;/code&gt;) you will start a Lingy interactive REPL. You can run Lingy commands and see the output.&lt;/p&gt; &#xA;&lt;p&gt;The REPL has command line history to save all your commands. It also has readline history search (ctl-r) and tab completion.&lt;/p&gt; &#xA;&lt;p&gt;Note: Input lines that match the previous input line will not be saved in history. That way you can run the same command multiple times in a row and not clutter your history.&lt;/p&gt; &#xA;&lt;h2&gt;Multiline Input&lt;/h2&gt; &#xA;&lt;p&gt;The Lingy REPL will keep prompting you for more lines until you have completed a well formed expression. Usually that means until you have balanced the parentheses.&lt;/p&gt; &#xA;&lt;p&gt;The history (up adn down arrow keys) will bring up the entire multiline form for you to edit.&lt;/p&gt; &#xA;&lt;p&gt;If you want to enter multiple lines as one entry when each line is already well formed, just wrap the entry in a &lt;code&gt;do&lt;/code&gt; expression like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;user=&amp;gt; (do&#xA;  #_=&amp;gt; (prn 1)&#xA;  #_=&amp;gt; (prn 2)&#xA;  #_=&amp;gt; )&#xA;1&#xA;2&#xA;nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also paste multiline examples into the REPL and they will remain editable as multiline.&lt;/p&gt; &#xA;&lt;p&gt;If you want to compress a multiline statement in your history to a single line, add a space to the end of it. Then (after you run it) it will be added to your history as a single line.&lt;/p&gt; &#xA;&lt;h2&gt;Using the Clojure REPL in the Lingy REPL&lt;/h2&gt; &#xA;&lt;p&gt;If you have Clojure installed on your system and you run this command in the Lingy REPL: &lt;code&gt;(clojure-repl-on)&lt;/code&gt;, then every command you enter will be evaluated both by Lingy and Clojure. Run &lt;code&gt;(clojure-repl-off)&lt;/code&gt; to turn it off. Start the Lingy REPL with &lt;code&gt;lingy --clj&lt;/code&gt; to turn it on from the start.&lt;/p&gt; &#xA;&lt;p&gt;Also if you run a command like &lt;code&gt;;;;(source first)&lt;/code&gt; it will only run on Clojure. The command is a comment to Lingy but the REPL will remove the &lt;code&gt;;;;&lt;/code&gt; and pass it to Clojure.&lt;/p&gt; &#xA;&lt;p&gt;Using this feature is a great way to compare how Lingy and Clojure work. Eventually they should be very close to identical but currently Lingy is still a baby.&lt;/p&gt; &#xA;&lt;h1&gt;Lingy / Perl Interoperability&lt;/h1&gt; &#xA;&lt;p&gt;Like Clojure and Java, Lingy and Perl are both ways interoperable.&lt;/p&gt; &#xA;&lt;p&gt;Note: This section currently covers the basics, but more in depth content will be added later.&lt;/p&gt; &#xA;&lt;h2&gt;Using Lingy from Perl Code&lt;/h2&gt; &#xA;&lt;p&gt;The Lingy.pm module lets you easily evaluate Lingy code from inside your Perl code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;use Lingy;&#xA;my $lingy = Lingy-&amp;gt;new;     # Setup the Lingy environment&#xA;my $result = $lingy-&amp;gt;rep(&#34;(+ 1 2 3 4)&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lingy Methods&lt;/h3&gt; &#xA;&lt;p&gt;The Lingy perl module supports the following methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $lingy = Lingy-&amp;gt;new();&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Create a new Lingy object.&lt;/p&gt; &lt;p&gt;This method takes no arguments.&lt;/p&gt; &lt;p&gt;The first time &lt;code&gt;Lingy-&amp;gt;new&lt;/code&gt; is called it initializes the Lingy runtime environment (which is required to process Lingy expressions).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $result_string = $lingy-&amp;gt;rep($lingy_source_code_string);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The &lt;code&gt;rep&lt;/code&gt; method stands for &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Evaluate&lt;/code&gt;, &lt;code&gt;Print&lt;/code&gt; which is the runtime process for running Lingy (or any Lisp) code. This is likely the most common method you will use.&lt;/p&gt; &lt;p&gt;Note: If you call this in a &#34;Loop&#34; you&#39;ve created a &#34;REPL&#34; (Read, Evaluate, Print, Loop).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Lingy also exposes each of the Read, Evaluate and Print methods to give you more control:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $form = $lingy-&amp;gt;read($lingy_source_code_string);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Read a string containing a Lingy source expression and return the Lingy AST object (form). In list context, returns all the form objects read if more than one form is parsed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $result_form = $lingy-&amp;gt;eval($form);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Evaluate a Lingy form object and return the resulting Lingy form object.&lt;/p&gt; &lt;p&gt;Use this in a Perl &lt;code&gt;eval&lt;/code&gt; block to catch any Lingy runtime errors.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $result_string = $lingy-&amp;gt;print($form);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Print a Lingy form object to a text string.&lt;/p&gt; &lt;p&gt;Usually this results in a Lingy expression that you can pass to another &lt;code&gt;$lingy-&amp;gt;read&lt;/code&gt; method call if you want to.&lt;/p&gt; &lt;p&gt;Reading and Printing a Lingy string without Evaluating it in between, often produces the original string (or a semantically equivalent one). That&#39;s because Lisp (Lingy) is &#34;homoiconic&#34;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Using Perl from Lingy Code&lt;/h2&gt; &#xA;&lt;p&gt;Like Clojure, Lingy has a lot of functions/functionality for calling Perl code.&lt;/p&gt; &#xA;&lt;p&gt;This is how Clojure and Lingy are implemented in that as much of the language as possible is written in itself (Lisp) but many functions need to call to the host language to do the work.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(perl &#34;any perl source code string&#34;)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;This is the big hammer. Call Perl&#39;s &lt;code&gt;eval&lt;/code&gt; on any Perl code string and return the result.&lt;/p&gt; &lt;p&gt;The return value likely will not be a Lingy native object. If you save the result in a variable, don&#39;t expect that if will work like a native Lingy object. When the Lingy Printer sees a non-Lingy object it prints it as a YAML dump.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(import YAML.PP.Perl)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Load a Perl module. We are just using &lt;code&gt;YAML::PP::Perl&lt;/code&gt; as an example here. This is like &lt;code&gt;use YAML::PP::Perl;&lt;/code&gt; in Perl.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(def y-pp (YAML.PP.Perl. &#34;boolean&#34; &#34;JSON::PP&#34;))&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Create a new &lt;code&gt;YAML::PP::Perl&lt;/code&gt; object. The &lt;code&gt;.&lt;/code&gt; after the module name is like calling the &lt;code&gt;-&amp;gt;new&lt;/code&gt; in Perl.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(def y-pp (.new YAML.PP.Perl &#34;boolean&#34; &#34;JSON::PP&#34;))&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Call a Perl class method with arguments. This is another way to instantiate an object like the previous example. The &lt;code&gt;.xyz word at the start of an expression is like calling &lt;/code&gt;-&amp;gt;xyz` on the second word, which may be a class or an object.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(println (.dump ypp &#39;(+ 2 2)))&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Call a Perl method with arguments on a Perl instance object.&lt;/p&gt; &lt;p&gt;The example above will print the internal AST form of the Lingy expression &lt;code&gt;(+ 2 2)&lt;/code&gt;. This is a very useful way to debug Lingy.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;WWW&lt;/code&gt;, &lt;code&gt;XXX&lt;/code&gt;, &lt;code&gt;YYY&lt;/code&gt; and &lt;code&gt;ZZZ&lt;/code&gt;&lt;/p&gt; &lt;p&gt;These Lingy functions from the &lt;code&gt;lingy.devel&lt;/code&gt; library, work like the &lt;code&gt;XXX.pm&lt;/code&gt; CPAN module, but from Lingy.&lt;/p&gt; &lt;p&gt;This can we very useful for seeing what Lingy is doing internally.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;(use &#39;lingy.devel) (XXX (perl &#34;\\%INC&#34;))  ; Print a YAML dump of Perl&#39;s %INC value.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Differences from Clojure&lt;/h1&gt; &#xA;&lt;p&gt;Lingy intends to be a proper &#34;Clojure Platform&#34;; a complete port of Clojure to Perl and other languages.&lt;/p&gt; &#xA;&lt;p&gt;That said, differences must exist.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Lingy platform host language is currently just Perl. It is the intent to extend the language set to Python and others soon.&lt;/li&gt; &#xA; &lt;li&gt;Lingy currently only supports a subset of Clojure libraries (most notably clojure.core). It is intended that Lingy will eventually use Clojure&#39;s libraries directly starting with clojure.core. As of this release Lingy can &lt;code&gt;read-string&lt;/code&gt; all of clojure.core and it converts the forms it fully supports into the lingy.core namespace.&lt;/li&gt; &#xA; &lt;li&gt;Lingy tries to map Clojure namespace and Java class symbols/files to Lingy namespace and Perl module/class symbols/files. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The &lt;code&gt;clojure.core&lt;/code&gt; namespace equivalent in Lingy is &lt;code&gt;lingy.core&lt;/code&gt; and maps to a file name called &lt;code&gt;lib/Lingy/core.ly&lt;/code&gt; in the Lingy source code.&lt;/li&gt; &#xA;   &lt;li&gt;The &lt;code&gt;lingy.lang.HashMap&lt;/code&gt; symbol maps to the &lt;code&gt;Lingy::HashMap&lt;/code&gt; module (the &lt;code&gt;lib/Lingy/HashMap.pm&lt;/code&gt; file).&lt;/li&gt; &#xA;   &lt;li&gt;More mapping details to be added here later.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;#?&lt;/code&gt; reader macro uses the &lt;code&gt;:lingy/pl&lt;/code&gt; keyword to conditionally use forms that the Lingy/Perl platform supports.&lt;/li&gt; &#xA; &lt;li&gt;Special global vars (earmuffs) that are unique to Lingy: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;*lingy-version*&lt;/code&gt; Like &lt;code&gt;*clojure-version*&lt;/code&gt; but for Lingy&#39;s version.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*LANG*&lt;/code&gt; Set to &lt;code&gt;&#34;Lingy&#34;&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*HOST*&lt;/code&gt; Set to &lt;code&gt;&#34;perl&#34;&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*clojure-repl*&lt;/code&gt; Boolean (default &lt;code&gt;false&lt;/code&gt;) indicates whether Lingy REPL should also send input to a Clojure REPL.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Lingy error messages currently try to be close to the Clojure ones. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This isn&#39;t always possible or desirable.&lt;/li&gt; &#xA;   &lt;li&gt;Error messages may be completely overhauled to give better info.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Certainly there are other differences and this section will be improved over time.&lt;/p&gt; &#xA;&lt;h1&gt;Hacking on Lingy&lt;/h1&gt; &#xA;&lt;p&gt;If you want to contribute to Lingy, Welcome!&lt;/p&gt; &#xA;&lt;p&gt;If you just want to play with the source while using Lingy, Welcome!&lt;/p&gt; &#xA;&lt;p&gt;Here, we&#39;ll cover how to install Lingy from source and modify the source code. This will include tips on debugging Lingy.&lt;/p&gt; &#xA;&lt;p&gt;This section is a work in progress...&lt;/p&gt; &#xA;&lt;p&gt;Lingy development requires &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt; (almost any versions of these) and a bunch of Perl modules.&lt;/p&gt; &#xA;&lt;p&gt;You probably already have the commands. The best way to install the dependency modules is using the &lt;code&gt;cpanm Lingy&lt;/code&gt; command described above in the &#34;Installation&#34; section. The will install Lingy and all the Perl dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Then you can &lt;code&gt;git clone&lt;/code&gt; the source code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/ingydotnet/lingy.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set up local environment variables for development:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export PATH=$PWD/lingy/perl/bin:$PATH&#xA;export PERL5LIB=$PWD/lingy/perl/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And test your local source code install of Lingy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;which lingy     # Should point at your cloned version&#xA;lingy --execs   # Should list your clone&#xA;lingy -e &#39;(println *lingy-version*)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the &lt;code&gt;export&lt;/code&gt;s above to your shell rc file if you want to.&lt;/p&gt; &#xA;&lt;p&gt;You might need to add these exports if Lingy warns about them. This is more common for people who haven&#39;t used Perl in a while since people who do likely took care of it in the past.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;LC_CTYPE=en_US.UTF-8&#xA;LC_ALL=en_US.UTF-8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging Lingy in the REPL&lt;/h2&gt; &#xA;&lt;p&gt;Running &lt;code&gt;lingy -D&lt;/code&gt; will &lt;code&gt;(use &#39;lingy.devel)&lt;/code&gt; at startup. This provides some dev functions including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(XXX ...)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Throw a YAML dump of the internal Perl structure of the arguments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(WWW ...)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Warn the same thing as above but then return the argument so that the program can continue.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(x-carp-on)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Turn on full stack traces when Perl internally warns or dies. Calling &lt;code&gt;(throw ...)&lt;/code&gt; should also get a full stack trace with this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A bunch of other functions starting with &lt;code&gt;x-&lt;/code&gt;. Tab completion is your friend. :)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;See Also&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=9OcFh-HaCyI&#34;&gt;Video Talk about Lingy and YAMLScript&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://clojure.org/&#34;&gt;Clojure&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/YAMLScript&#34;&gt;YAMLScript&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Test::More::YAMLScript&#34;&gt;Test::More::YAMLScript&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Authors&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ingy döt Net &lt;a href=&#34;mailto:ingy@ingy.net&#34;&gt;ingy@ingy.net&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Copyright and License&lt;/h1&gt; &#xA;&lt;p&gt;Copyright 2023 by Ingy döt Net&lt;/p&gt; &#xA;&lt;p&gt;This is free software, licensed under:&lt;/p&gt; &#xA;&lt;p&gt;The MIT (X11) License&lt;/p&gt;</summary>
  </entry>
</feed>