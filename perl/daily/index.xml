<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-27T01:41:35Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kazeburo/check_memcached_val</title>
    <updated>2023-06-27T01:41:35Z</updated>
    <id>tag:github.com,2023-06-27:/kazeburo/check_memcached_val</id>
    <link href="https://github.com/kazeburo/check_memcached_val" rel="alternate"></link>
    <summary type="html">&lt;p&gt;nagios plugin for checking value in a memcached server&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#!/usr/bin/perl&lt;/p&gt; &#xA;&lt;p&gt;use strict; use warnings; use 5.008005; use File::Temp qw/tempfile/; use File::Spec; use File::Path qw/mkpath/; use File::Copy; use Data::Dumper; use Digest::MD5 qw/md5_hex/; use IO::Socket::INET; use POSIX qw(EINTR EAGAIN EWOULDBLOCK); use Socket qw(IPPROTO_TCP TCP_NODELAY); use Scalar::Util qw/ looks_like_number /; use Pod::Usage qw/pod2usage/; use Getopt::Long; Getopt::Long::Configure (&#34;no_ignore_case&#34;);&lt;/p&gt; &#xA;&lt;p&gt;use constant OUTSIDE =&amp;gt; 0; use constant INSIDE =&amp;gt; 1; use constant OK =&amp;gt; 0; use constant WARNING =&amp;gt; 1; use constant CRITICAL =&amp;gt; 2; use constant UNKNOWN =&amp;gt; 3;&lt;/p&gt; &#xA;&lt;h1&gt;copy from Nagios::Plugin&lt;/h1&gt; &#xA;&lt;p&gt;my $value_n = qr/[-+]?[\d.]+/; my $value_re = qr/$value_n(?:e$value_n)?/;&lt;/p&gt; &#xA;&lt;p&gt;my $host; my $port = 11211; my $warning_arg = 0; my $critical_arg = 0; my $key; my $timeout = 10; my $regex; my $regexi; my $estring; my $rate_multiplier = 1;&lt;/p&gt; &#xA;&lt;p&gt;GetOptions( &#34;h|help&#34; =&amp;gt; \my $help, &#34;H|hostname=s&#34; =&amp;gt; $host, &#34;P|port=i&#34; =&amp;gt; $port, &#34;w|warning=s&#34; =&amp;gt; $warning_arg, &#34;c|critical=s&#34; =&amp;gt; $critical_arg, &#34;k|key=s&#34; =&amp;gt; $key, &#34;t|timeout=i&#34; =&amp;gt; $timeout, &#34;s|string=s&#34; =&amp;gt; $estring, &#34;r|ereg=s&#34; =&amp;gt; $regex, &#34;R|eregi=s&#34; =&amp;gt; $regexi, &#34;invert-search&#34; =&amp;gt; \my $invert_search, &#34;rate&#34; =&amp;gt; \my $rate, &#34;rate-multiplier=i&#34; =&amp;gt; $rate_multiplier ) or pod2usage(-verbose=&amp;gt;1,-exitval=&amp;gt;UNKNOWN); pod2usage(-verbose=&amp;gt;1,-exitval=&amp;gt;CRITICAL) if !$host || !$key; pod2usage(-verbose=&amp;gt;2,-exitval=&amp;gt;OK) if $help;&lt;/p&gt; &#xA;&lt;p&gt;my $warning = parse_range_string($warning_arg); if ( !$warning ) { print &#34;CRITICAL: invalid range definition &#39;$warning_arg&#39;\n&#34;; exit CRITICAL;&lt;br&gt; } my $critical = parse_range_string($critical_arg); if ( !$critical ) { print &#34;CRITICAL: invalid range definition &#39;$critical_arg&#39;\n&#34;; exit CRITICAL;&lt;br&gt; }&lt;/p&gt; &#xA;&lt;p&gt;my $tmpdir = File::Spec-&amp;gt;catdir(File::Spec-&amp;gt;tmpdir(),&#39;check_memcached_val&#39;); my $prevfile = md5_hex(Dumper( [$host,$port,$warning_arg,$critical_arg,$key,$timeout,$estring,$regex,$regexi,$invert_search,$rate] )); if ($rate) { mkpath($tmpdir); }&lt;/p&gt; &#xA;&lt;p&gt;my $client; eval { $client = new_client($host, $port, $timeout); };&lt;/p&gt; &#xA;&lt;p&gt;if ( $@ ) { print &#34;CRITICAL: $@&#34;; exit CRITICAL; }&lt;/p&gt; &#xA;&lt;p&gt;my $write_len = write_all($client, &#34;get $key\r\n&#34;, $timeout); if ( ! defined $write_len ) { print &#34;CRITICAL: Failed to request\n&#34;; exit CRITICAL; } my $buf = &#39;&#39;; while (1) { my $read_len = read_timeout($client, $buf, 1024 - length($buf), length($buf), $timeout) or return; $buf =~ m!(?:END|ERROR)\r\n$!mos and last; }&lt;/p&gt; &#xA;&lt;p&gt;if ( !$buf ) { print &#34;CRITICAL: could not retrieve any data from server\n&#34;; exit CRITICAL; }&lt;/p&gt; &#xA;&lt;p&gt;my $val; if ( $buf =~ m! ^VALUE\x20 $key\x20 (?:[^\x20]+)\x20 (?:[^\x20]+)\r\n (.+)\r\n END\r\n$ !mosx ) { $val = $1; } elsif ( $buf =~ m!ERROR\r\n$!mos ) { # error? print &#34;UNKNOWN: server returns error\n&#34;; exit UNKNOWN; } else { # not found print &#34;CRITICAL: Key:$key is not found on this server\n&#34;; exit CRITICAL; }&lt;/p&gt; &#xA;&lt;h1&gt;string check&lt;/h1&gt; &#xA;&lt;p&gt;if ( defined $estring ) { my $ret = ($val eq $estring); $ret = !$ret if $invert_search; if ( $ret ) { printf &#34;MEMCACHED_VAL MATCH OK: *%s\n&#34;, $val; exit OK; } else { printf &#34;MEMCACHED_VAL MATCH CRITICAL: *%s\n&#34;, $val; exit CRITICAL; } }&lt;/p&gt; &#xA;&lt;h1&gt;regex check&lt;/h1&gt; &#xA;&lt;p&gt;if ( defined $regex ) { my $ret = ($val =~ m!$regex!); $ret = !$ret if $invert_search; if ( $ret ) { printf &#34;MEMCACHED_VAL MATCH OK: *%s\n&#34;, $val; exit OK; } else { printf &#34;MEMCACHED_VAL MATCH CRITICAL: *%s\n&#34;, $val; exit CRITICAL; } }&lt;/p&gt; &#xA;&lt;h1&gt;incase regex check&lt;/h1&gt; &#xA;&lt;p&gt;if ( defined $regexi ) { my $ret = ($val =~ m!$regexi!i); $ret = !$ret if $invert_search; if ( $ret ) { printf &#34;MEMCACHED_VAL MATCH OK: *%s\n&#34;, $val; exit OK; } else { printf &#34;MEMCACHED_VAL MATCH CRITICAL: *%s\n&#34;, $val; exit CRITICAL; } }&lt;/p&gt; &#xA;&lt;h1&gt;number check&lt;/h1&gt; &#xA;&lt;p&gt;if ( ! looks_like_number($val) ) { printf &#34;MEMCACHED_VAL UNKNOWN: Key:%s *%s is not like a number\n&#34;, $key, $val; exit UNKNOWN;&lt;br&gt; }&lt;/p&gt; &#xA;&lt;p&gt;if ( uc($val) eq &#34;0E0&#34; ) { printf &#34;MEMCACHED_VAL MAYBE OK: Key:%s is zero but true - assume okay. *%s\n&#34;, $key, $val; exit OK; }&lt;/p&gt; &#xA;&lt;h1&gt;calc rate&lt;/h1&gt; &#xA;&lt;p&gt;if ( $rate ) { my $path = File::Spec-&amp;gt;catfile($tmpdir, $prevfile); if ( ! -s $path ) { printf &#34;MEMCACHED_VAL MAYBE OK: No previous data to calculate rate - assume okay. Key:%s\n&#34;, $key; atomic_write($path, $val); exit OK; } my $prev_time = [stat $path]-&amp;gt;[9]; #mtime my $elapsed = time - $prev_time; if ( !$elapsed ) { print &#34;MEMCACHED_VAL UNKNOWN: Time duration between plugin calls is invalid. Key:%s\n&#34;, $key; exit UNKNOWN; } open( my $fh, &#39;&amp;lt;&#39;, $path); my $prev = do { local $/; &amp;lt;$fh&amp;gt; }; chomp $prev;chomp $prev; my $rate = ($val - $prev) / $elapsed; atomic_write($path, $val); $val = $rate * $rate_multiplier; }&lt;/p&gt; &#xA;&lt;h1&gt;range check&lt;/h1&gt; &#xA;&lt;p&gt;if ( check_range($critical, $val) ) { printf &#34;MEMCACHED_VAL CRITICAL: Key:%s *%s\n&#34;, $key, $val; exit CRITICAL; }&lt;/p&gt; &#xA;&lt;p&gt;if ( check_range($warning, $val) ) { printf &#34;MEMCACHED_VAL WARNING: Key:%s *%s\n&#34;, $key, $val; exit WARNING; }&lt;/p&gt; &#xA;&lt;p&gt;printf &#34;MEMCACHED_VAL OK: *%s\n&#34;, $val; exit OK;&lt;/p&gt; &#xA;&lt;p&gt;sub new_client { my ($host, $port, $timeout) = @_;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;my $sock = IO::Socket::INET-&amp;gt;new(&#xA;    PeerHost =&amp;gt; $host,&#xA;    PeerPort =&amp;gt; $port,&#xA;    Timeout  =&amp;gt; $timeout, &#xA;    Proto    =&amp;gt; &#39;tcp&#39;,&#xA;) or die &#34;Cannot open client socket: $!\n&#34;;&#xA;&#xA;setsockopt($sock, IPPROTO_TCP, TCP_NODELAY, pack(&#34;l&#34;, 1)) or die;&#xA;$sock-&amp;gt;autoflush(1);&#xA;$sock;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;h1&gt;returns (positive) number of bytes read, or undef if the socket is to be closed&lt;/h1&gt; &#xA;&lt;p&gt;sub read_timeout { my ($sock, $buf, $len, $off, $timeout) = @_; do_io(undef, $sock, $buf, $len, $off, $timeout); }&lt;/p&gt; &#xA;&lt;h1&gt;returns (positive) number of bytes written, or undef if the socket is to be closed&lt;/h1&gt; &#xA;&lt;p&gt;sub write_timeout { my ($sock, $buf, $len, $off, $timeout) = @_; do_io(1, $sock, $buf, $len, $off, $timeout); }&lt;/p&gt; &#xA;&lt;h1&gt;writes all data in buf and returns number of bytes written or undef if failed&lt;/h1&gt; &#xA;&lt;p&gt;sub write_all { my ($sock, $buf, $timeout) = @_; my $off = 0; while (my $len = length($buf) - $off) { my $ret = write_timeout($sock, $buf, $len, $off, $timeout) or return; $off += $ret; } return length $buf; }&lt;/p&gt; &#xA;&lt;h1&gt;returns value returned by $cb, or undef on timeout or network error&lt;/h1&gt; &#xA;&lt;p&gt;sub do_io { my ($is_write, $sock, $buf, $len, $off, $timeout) = @_; my $ret; DO_READWRITE: # try to do the IO if ($is_write) { $ret = syswrite $sock, $buf, $len, $off and return $ret; } else { $ret = sysread $sock, $$buf, $len, $off and return $ret; } unless ((! defined($ret) &amp;amp;&amp;amp; ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK))) { return; } # wait for data DO_SELECT: while (1) { my ($rfd, $wfd); my $efd = &#39;&#39;; vec($efd, fileno($sock), 1) = 1; if ($is_write) { ($rfd, $wfd) = (&#39;&#39;, $efd); } else { ($rfd, $wfd) = ($efd, &#39;&#39;); } my $start_at = time; my $nfound = select($rfd, $wfd, $efd, $timeout); $timeout -= (time - $start_at); last if $nfound; return if $timeout &amp;lt;= 0; } goto DO_READWRITE; }&lt;/p&gt; &#xA;&lt;h1&gt;copy from Nagios::Plugin&lt;/h1&gt; &#xA;&lt;p&gt;sub parse_range_string { my ($string) = @_; my $valid = 0; my %range = ( start =&amp;gt; 0, start_infinity =&amp;gt; 0, end =&amp;gt; 0, end_infinity =&amp;gt; 1, alert_on =&amp;gt; OUTSIDE ); $string =~ s/\s//g; # strip out any whitespace # check for valid range definition unless ( $string =~ /[\d~]/ &amp;amp;&amp;amp; $string =~ m/^@?($value_re|~)?(:($value_re)?)?$/ ) { return; }&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;if ($string =~ s/^\@//) {&#xA;    $range{alert_on} = INSIDE;&#xA;}&#xA;&#xA;if ($string =~ s/^~//) {  # &#39;~:x&#39;&#xA;    $range{start_infinity} = 1;&#xA;}&#xA;if ( $string =~ m/^($value_re)?:/ ) {     # &#39;10:&#39;&#xA;   my $start = $1;&#xA;   if ( defined $start ) {&#xA;       $range{start} = $start + 0;&#xA;       $range{start_infinity} = 0;&#xA;   }&#xA;   $range{end_infinity} = 1;  # overridden below if there&#39;s an end specified&#xA;   $string =~ s/^($value_re)?://;&#xA;   $valid++;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;} if ($string =~ /^($value_re)$/) { # &#39;x:10&#39; or &#39;10&#39; $range{end} = $string + 0; $range{end_infinity} = 0; $valid++; }&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;if ($valid &amp;amp;&amp;amp; ( $range{start_infinity} == 1 &#xA;             || $range{end_infinity} == 1 &#xA;             || $range{start} &amp;lt;= $range{end}&#xA;             )) {&#xA;    return \%range;&#xA;}&#xA;&#xA;return;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;h1&gt;Returns 1 if an alert should be raised, otherwise 0&lt;/h1&gt; &#xA;&lt;p&gt;sub check_range { my ($range, $value) = @_; my $false = 0; my $true = 1; if ($range-&amp;gt;{alert_on} == INSIDE) { $false = 1; $true = 0; } if ($range-&amp;gt;{end_infinity} == 0 &amp;amp;&amp;amp; $range-&amp;gt;{start_infinity} == 0) { if ($range-&amp;gt;{start} &amp;lt;= $value &amp;amp;&amp;amp; $value &amp;lt;= $range-&amp;gt;{end}) { return $false; } else { return $true; } } elsif ($range-&amp;gt;{start_infinity} == 0 &amp;amp;&amp;amp; $range-&amp;gt;{end_infinity} == 1) { if ( $value &amp;gt;= $range-&amp;gt;{start} ) { return $false; } else { return $true; } } elsif ($range-&amp;gt;{start_infinity} == 1 &amp;amp;&amp;amp; $range-&amp;gt;{end_infinity} == 0) { if ($value &amp;lt;= $range-&amp;gt;{end}) { return $false; } else { return $true; } } return $false; }&lt;/p&gt; &#xA;&lt;p&gt;sub atomic_write { my ($writefile, $body) = @_; my ($tmpfh,$tmpfile) = tempfile(UNLINK=&amp;gt;0,TEMPLATE=&amp;gt;$writefile.&#34;.XXXXX&#34;); print $tmpfh $body; close($tmpfh); move( $tmpfile, $writefile); }&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;=encoding utf8&lt;/p&gt; &#xA;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;check_memcached_val.pl - nagios plugin for checking value in a memcached server.&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;p&gt;usage: check_memcached_val.pl -H host -P port -w 0.1 -c 0.2 -t 10 -k getkey&lt;/p&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;check_memcached_val is nagios plugin to retrieve a value from memcached server and check status&lt;/p&gt; &#xA;&lt;p&gt;=head1 ARGUMENTS&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item -h, --help&lt;/p&gt; &#xA;&lt;p&gt;Display help message&lt;/p&gt; &#xA;&lt;p&gt;=item -H, --hostname=STRING&lt;/p&gt; &#xA;&lt;p&gt;Host name or IP Address&lt;/p&gt; &#xA;&lt;p&gt;=item -P, --port=INTEGER&lt;/p&gt; &#xA;&lt;p&gt;Port number (default 11211)&lt;/p&gt; &#xA;&lt;p&gt;=item -k, --key=STRING&lt;/p&gt; &#xA;&lt;p&gt;key name to get&lt;/p&gt; &#xA;&lt;p&gt;=item -s, --string=STRING&lt;/p&gt; &#xA;&lt;p&gt;Return OK state if STRING is an exact match&lt;/p&gt; &#xA;&lt;p&gt;=item -r, --ereg=REGEX&lt;/p&gt; &#xA;&lt;p&gt;Return OK state if extended regular expression REGEX matches&lt;/p&gt; &#xA;&lt;p&gt;=item -R, --eregi=REGEX&lt;/p&gt; &#xA;&lt;p&gt;Return OK state if case-insensitive extended REGEX matches&lt;/p&gt; &#xA;&lt;p&gt;=item --invert-search&lt;/p&gt; &#xA;&lt;p&gt;Invert search result (CRITICAL if found)&lt;/p&gt; &#xA;&lt;p&gt;=item -w, --warning=THRESHOLD&lt;/p&gt; &#xA;&lt;p&gt;Warning threshold range&lt;/p&gt; &#xA;&lt;p&gt;See L&lt;a href=&#34;http://nagiosplug.sourceforge.net/developer-guidelines.html#THRESHOLDFORMAT&#34;&gt;http://nagiosplug.sourceforge.net/developer-guidelines.html#THRESHOLDFORMAT&lt;/a&gt; for THRESHOLD format and examples&lt;/p&gt; &#xA;&lt;p&gt;=item -c, --critical=THRESHOLD&lt;/p&gt; &#xA;&lt;p&gt;Critical threshold range&lt;/p&gt; &#xA;&lt;p&gt;=item -t, --timeout=INTEGER&lt;/p&gt; &#xA;&lt;p&gt;Seconds before connection times out.&lt;/p&gt; &#xA;&lt;p&gt;=item --rate&lt;/p&gt; &#xA;&lt;p&gt;Enable rate calculation. See &#39;Rate Calculation&#39; below&lt;/p&gt; &#xA;&lt;p&gt;=item --rate-multiplier=INTEGER&lt;/p&gt; &#xA;&lt;p&gt;Converts rate per second. For example, set to 60 to convert to per minute&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head1 Rate Calculation&lt;/p&gt; &#xA;&lt;p&gt;check_memcached_val can rate calculation like a check_snmp plugin. check_memcached_val stores previous data in a file and calculate rate per second. This is useful when combination with the memcached incr.&lt;/p&gt; &#xA;&lt;p&gt;On the first run, there will be no prior state - this will return with OK. The state is uniquely determined by the arguments to the plugin, so changing the arguments will create a new state file&lt;/p&gt; &#xA;&lt;p&gt;=head1 INSTALL&lt;/p&gt; &#xA;&lt;p&gt;just copy this script to nagios&#39;s libexec directory.&lt;/p&gt; &#xA;&lt;p&gt;$ curl &lt;a href=&#34;https://raw.github.com/kazeburo/check_memcached_val/master/check_memcached_val.pl&#34;&gt;https://raw.github.com/kazeburo/check_memcached_val/master/check_memcached_val.pl&lt;/a&gt; &amp;gt; check_memcached_val.pl $ chmod +x check_memcached_val.pl $ cp check_memcached_val.pl /path/to/nagios/libexec&lt;/p&gt; &#xA;&lt;p&gt;=head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;Masahiro Nagano E&#xA; &lt;lt&gt;&#xA;  &lt;a href=&#34;mailto:kazeburo@gmail.comE&#34;&gt;kazeburo@gmail.comE&lt;/a&gt;&#xA;  &lt;gt&gt;&lt;/gt&gt;&#xA; &lt;/lt&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE&lt;/p&gt; &#xA;&lt;p&gt;Copyright (C) Masahiro Nagano&lt;/p&gt; &#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt;</summary>
  </entry>
</feed>