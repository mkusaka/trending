<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-24T01:43:46Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xyb3rt/urxvt-perls</title>
    <updated>2023-06-24T01:43:46Z</updated>
    <id>tag:github.com,2023-06-24:/xyb3rt/urxvt-perls</id>
    <link href="https://github.com/xyb3rt/urxvt-perls" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Perl extensions for the rxvt-unicode terminal emulator&lt;/p&gt;&lt;hr&gt;&lt;p&gt;A small collection of perl extensions for the rxvt-unicode terminal emulator.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Simply place the scripts you want to install in /usr/lib/urxvt/perl/ for system-wide availability or in ~/.urxvt/ext/ for user-only availability. You can also put them in a folder of your choice, but then you have to add this line to your .Xdefaults/.Xresources:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;URxvt.perl-lib: /your/folder/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the following sections for information on how to enable the scripts or set script-specific options and keyboard mappings in your .Xdefaults/.Xresources.&lt;/p&gt; &#xA;&lt;h2&gt;keyboard-select&lt;/h2&gt; &#xA;&lt;p&gt;Use keyboard shortcuts to select and copy text.&lt;/p&gt; &#xA;&lt;p&gt;After installing, put the following lines in your .Xdefaults/.Xresources:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;URxvt.perl-ext-common: ...,keyboard-select&#xA;URxvt.keysym.M-Escape: perl:keyboard-select:activate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following line overwrites the default Meta-s binding and allows to activate keyboard-select directly in backward search mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;URxvt.keysym.M-s: perl:keyboard-select:search&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use Meta-Escape to activate selection mode, then use the following keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;h/j/k/l:    Move cursor left/down/up/right (also with arrow keys)&#xA;g/G/0/^/$/H/M/L/f/F/;/,/w/W/b/B/e/E: More vi-like cursor movement keys&#xA;&#39;/&#39;/?:      Start forward/backward search&#xA;n/N:        Repeat last search, N: in reverse direction&#xA;Ctrl-f/b:   Scroll down/up one screen&#xA;Ctrl-d/u:   Scroll down/up half a screen&#xA;v/V/Ctrl-v: Toggle normal/linewise/blockwise selection&#xA;y/Return:   Copy selection to primary buffer, Return: quit afterwards&#xA;Y:          Copy selected lines to primary buffer or cursor line and quit&#xA;q/Escape:   Quit keyboard selection mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;URxvt.keyboard-select.clipboard: If true, copy to clipboard too&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>zaphod42/Coeus</title>
    <updated>2023-06-24T01:43:46Z</updated>
    <id>tag:github.com,2023-06-24:/zaphod42/Coeus</id>
    <link href="https://github.com/zaphod42/Coeus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Master&#39;s Thesis project&lt;/p&gt;&lt;hr&gt;&lt;p&gt;NAME coeus - The Planned Datacenter Language interpreter&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS coeus [options]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Runs the Coeus interpreter. If no input file is specified, reads from&#xA;STDIN.&#xA;&#xA; Options:&#xA;    --input -i      Specify the input file&#xA;    --trace -t      Display the parse trace&#xA;    --backtrace -b  Display backtraces when there is an interpreter error&#xA;    --hook          Load a hook&#xA;    --help -h       Show this help info&#xA;    --man           Show the full man page&#xA;    --target        Specify the run target (default: run)&#xA;&#xA;For a complete explanation of the idea behind the interpreter and the&#xA;language read&#xA;https://github.com/zaphod42/Coeus/raw/master/doc/Masterarbeit.pdf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;OPTIONS --input Specify the input file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--trace Turns on the Parse::RecDescent trace. WARNING: The trace can be&#xA;        very long, even for small files.&#xA;&#xA;--backtrace&#xA;        Turns on the displays a backtrace through the interpreter when&#xA;        an error occurs.&#xA;&#xA;--hook  Register a hook with the interpreter.&#xA;&#xA;        Hooks are called before and after each operation is completed&#xA;        during the interpretation of a program. See&#xA;        Coeus::Interpreter::Hook for more information on hooks.&#xA;&#xA;         PACKAGE_NAME OPT1=VAL,OPT2=VAL,...&#xA;&#xA;        For example to use the Coeus::Visual::DotMapper which has&#xA;        options FILE and NO_SYMTAB you can run:&#xA;&#xA;         coeus --hook &#39;Coeus::Visual::DotMapper FILE=output.dot,NO_SYMTAB=1&#39;&#xA;&#xA;--help  Display the short help message (the SYNOPSIS).&#xA;&#xA;--man   Display the entire man page.&#xA;&#xA;--target&#xA;        Specify the target to run the interpreter to. One of: ast, run.&#xA;&#xA;        The ast target will parse and print the ast to STDOUT. The run&#xA;        target will parse and execute the program.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;LANGUAGE Language Elements A Coeus program consists of a list of declarations, statements, and expressions. Statements do not have any particular value that they evaluate to, whereas expressions also evaluate to a value that can be used for further evaluation. The majority of the language elements are expressions with only a few things for manipulating subscriptions being statements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Expressions themselves are broken down into four types: regular&#xA;expressions, boolean expressions, policy expressions, and behavior&#xA;expressions. For the most part they have the same structure, with the&#xA;main difference between them being what is allowed as part of the&#xA;expression.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Declaring Types type &#xA; &lt;typename&gt;&#xA;   { &#xA;  &lt;capabilityname&gt;&#xA;    # capability declaration &#xA;   &lt;behaviorexpression&gt;&#xA;     -&amp;gt; &#xA;    &lt;capabilityname&gt;&#xA;      # conditional capability # instances have the # capability only when # the expression evaluates # to true }&#xA;    &lt;/capabilityname&gt;&#xA;   &lt;/behaviorexpression&gt;&#xA;  &lt;/capabilityname&gt;&#xA; &lt;/typename&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;A TypeName must always start with an uppercase letter. The condition on&#xA;conditional capabilities can be any boolean expression (see below for an&#xA;explanation of what a boolean expression is). What makes it a behavior&#xA;expression is that no variable references are allowed in the expression&#xA;except for the &#34;_&#34; variable, which is bound to the instance whose&#xA;capabilities are being calculated.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Declaring Landscapes landscape &#xA; &lt;landscapename&gt;&#xA;   { &#xA;  &lt;policyname&gt;&#xA;   ([resilient = &#xA;   &lt;number&gt;&#xA;    ], [comment = &#xA;    &lt;string&gt;&#xA;     ]): &#xA;     &lt;policyexpression&gt;&#xA;       }&#xA;     &lt;/policyexpression&gt;&#xA;    &lt;/string&gt;&#xA;   &lt;/number&gt;&#xA;  &lt;/policyname&gt;&#xA; &lt;/landscapename&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The PolicyName is the name to be given to the policy. The attributes&#xA;resilient and comment are both optional. Comment provides a longer name&#xA;for the policy and is used during error reporting to provide nicer error&#xA;messages. Resilient specifies the minimum number of failures that this&#xA;policy needs to be able to handle. The resiliency of policies is not&#xA;also simple to understand so it is a good idea to understand how it will&#xA;be calculated and check by reading the Coeus::Model::Policy and&#xA;Coeus::Interpreter::PolicyCheck documentation.&#xA;&#xA;A landscape must have one default policy (the one that will be in effect&#xA;when a subscription for the landscape is first made). The default policy&#xA;is marked by prefixing the PolicyName with an asterisk (*).&#xA;&#xA;A PolicyExpression is very similar to a BehaviorExpression except that&#xA;&#34;_&#34; is not bound to anything (except inside queries) and references to&#xA;other policies is allowed (they use the same syntax as variable&#xA;references in standard expressions). For example:&#xA;&#xA; landscape Foo {&#xA;    *start:&#xA;        other &amp;amp;&amp;amp; ?[A]&#xA;    other:&#xA;        ?[Bar | _.baz == 2] &amp;gt;= 2&#xA; }&#xA;&#xA;Creates a landscape &#34;Foo&#34; that will begin with the policy &#34;start&#34;. The&#xA;&#34;start&#34; policy requires that the policy &#34;other&#34; is true as well as there&#xA;being at least one instance of type &#34;A&#34;. The &#34;other&#34; policy requires&#xA;that there are at least two instances of &#34;Bar&#34; that have their parameter&#xA;&#34;baz&#34; set to 2.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Declaring Actions action &#xA; &lt;actionname&gt;&#xA;  ([&#xA;  &lt;parameterlist&gt;&#xA;   ]) { &#xA;   &lt;commands&gt;&#xA;     }&#xA;   &lt;/commands&gt;&#xA;  &lt;/parameterlist&gt;&#xA; &lt;/actionname&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;An action evaluates to the last command evaluated in the body of the&#xA;action. The ParameterList is a comma seperated list of identifiers that&#xA;will be bound to the values passed into the action when it is called.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Statements There are seven statements in Coeus: subscribe, unsubscribe, in, policy, start, stop, and include.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Subscribe and unsubscribe create and destroy subscriptions to&#xA;landscapes. The syntax for subscribe is:&#xA;&#xA; subscribe(&amp;lt;LandscapeName&amp;gt;, &amp;lt;Expression&amp;gt;)&#xA;&#xA;The Expression is evaluated to get the name of the subscription. The&#xA;subscription starts with the default policy of the landscape and a&#xA;configuration with no instances or usages in it. To remove a&#xA;subscription, unsubscribe is used.&#xA;&#xA; unsubscribe(&amp;lt;Expression&amp;gt;)&#xA;&#xA;Just as with subscribe the Expression evaluates to the name of the&#xA;subscription to remove. When a subscription is remove the instances and&#xA;usages are simply de-associated from the subscription, they are not&#xA;decommissioned.&#xA;&#xA;When a change to a subscription needs to be made, then the &#34;in&#34;&#xA;statement is used.&#xA;&#xA; in &amp;lt;Expression&amp;gt; {&#xA;    ...&#xA; }&#xA;&#xA;Expression evaluates to the name of the subscription to work with and&#xA;the block is executed in the context of the subscriptions configuration.&#xA;&#xA;The policy statement changes the current policy of the current&#xA;subscription.&#xA;&#xA; policy[&amp;lt;PolicyName&amp;gt;]&#xA;&#xA;Both start and stop control the lifecycles of instances and usages.&#xA;Start places an instance or usage in the running state, and stop places&#xA;them in the stopped state.&#xA;&#xA; start[&amp;lt;Expression&amp;gt;]&#xA; stop[&amp;lt;Expression&amp;gt;]&#xA;&#xA;The include statement simply includes the text of file into the current&#xA;source code during interpretation, very much like #include in C.&#xA;&#xA; include &amp;lt;String&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Expressions Operators are boolean (&amp;amp;&amp;amp;, ||, not), arithmetic (+, -, *, /), numeric relational (&amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, !=, ==), string relational (lt, gt, eq, ne), assignment (:=), and string concatenation (~).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Truth of an expression is based on the same criteria as truth in Perl.&#xA;In Perl 0, &#34;&#34;, &#34;0&#34;, &#34; &#34;, and undefined are all false and everything else&#xA;is true.&#xA;&#xA;Additionally there are constructors:&#xA;&#xA; ![&amp;lt;Type&amp;gt;]&#xA; ![&amp;lt;Type&amp;gt;:&amp;lt;identifier&amp;gt;]&#xA; ![&amp;lt;var&amp;gt; &amp;lt;- &amp;lt;Type&amp;gt;]&#xA; ![&amp;lt;var&amp;gt; &amp;lt;- &amp;lt;Type&amp;gt;:&amp;lt;identifier&amp;gt;]&#xA; ![&amp;lt;var&amp;gt; -&amp;gt; &amp;lt;capability&amp;gt; &amp;lt;var&amp;gt;]&#xA;&#xA;The first form commissions a new instance of type Type. The second can&#xA;be understood as &#34;commission if needed&#34;. If there is not an instance of&#xA;type Type with the given identifier then it will be created, otherwise&#xA;it will simply be returned. If the wanted instance is in the system, but&#xA;not yet in the subscription in which the command is executed then the&#xA;instance will be brought into the subscription&#39;s configuration. This&#xA;allows for sharing the same instance between subscriptions.&#xA;&#xA;The third and fourth forms commission or commission if needed,&#xA;respectively, an instance and install it on the instance held in var.&#xA;The fifth form commissions a usage relationship.&#xA;&#xA;In the third and fifth forms if the vars hold more than one instance&#xA;then the commission will be performed for each instance, or each pair of&#xA;instances, in the vars. The fourth form will error in this case since it&#xA;would mean attempting to install the same instance in multiple places.&#xA;&#xA;Decommissioning is accomplished by:&#xA;&#xA; X[ &amp;lt;expression&amp;gt; ]&#xA;&#xA;It evaluates the expression and then removes the instance(s) or usage(s)&#xA;from the configuration.&#xA;&#xA;Decommissioning instances when currently inside a subscription will&#xA;simply remove the association between the instance and the subscription.&#xA;If, on the other hand, the instance is removed outside the context of a&#xA;subscription, then the instance will be completely removed from the&#xA;system (meaning removing it from all subscriptions it may be in).&#xA;&#xA;Decommissioning a usage will always completely remove it!&#xA;&#xA;NOTE: Decommissioning things can have unexpected consequences. Variables&#xA;may be unbound!&#xA;&#xA;All expressions can have a &#34;topic block&#34; added to them as well. The&#xA;topic block is a block of expressions that have the variable &#34;_&#34; bound&#xA;to the value of the expression that comes before the block. If the&#xA;expression that is before the block evaluates to a list (such as in the&#xA;case of queries), the block is applied repeatedly to each element of the&#xA;list.&#xA;&#xA; &amp;lt;Expression&amp;gt; {&#xA;    ...&#xA; }&#xA;&#xA;Queries are used to find instances and uses within the current&#xA;configuration (either the system&#39;s or a subscription&#39;s).&#xA;&#xA; ?[ &amp;lt;query&amp;gt; ]&#xA;&#xA;The queries can have several forms&#xA;&#xA; &amp;lt;TypePattern&amp;gt;                # finds all instances &#xA;                              # of a given type pattern&#xA;&#xA; &amp;lt;TypePattern&amp;gt; : &amp;lt;identifier&amp;gt; # finds the instance of &#xA;                              # type pattern with the &#xA;                              # given identifier&#xA;&#xA; &amp;lt;Expression&amp;gt; &amp;lt;- &amp;lt;TypePattern&amp;gt; # finds instances installed &#xA;                               # on Expression of a given &#xA;                               # type pattern&#xA;&#xA; &amp;lt;Expression&amp;gt; &amp;lt;- &amp;lt;TypePattern&amp;gt; : &amp;lt;identifier&amp;gt; # finds the &#xA;                               # instance installed on &#xA;                               # Expression of a given type &#xA;                               # pattern and identifier&#xA;&#xA; &amp;lt;InstancePattern&amp;gt; -&amp;gt; &amp;lt;CapabilityPattern&amp;gt; &amp;lt;InstancePattern&amp;gt; &#xA;                               # finds use relationships&#xA;&#xA;The TypePatterns can be either a TypeName, variable reference, or &#34;?&#34;.&#xA;The TypeName searches for instances of the given TypeName, a variable&#xA;reference searchs for the instances held in the variable, and &#34;?&#34; finds&#xA;all instances.&#xA;&#xA;The InstancePatterns in the usage query form can be either Expressions&#xA;or &#34;?&#34;. Expressions are handled the same as variable references in the&#xA;TypePatterns, and &#34;?&#34; is exactly the same as the &#34;?&#34; in the&#xA;TypePatterns. The CapabilityPattern can be either a capability name, in&#xA;which case only usages for the given capability will be returned, or &#34;?&#34;&#xA;in which case all usages that match the InstancePatterns will be&#xA;returned.&#xA;&#xA;In addition to the simple querying possible with these patterns, the&#xA;four instance query forms can have a filter specified as:&#xA;&#xA; &amp;lt;Query&amp;gt; | &amp;lt;Expression&amp;gt;&#xA;&#xA;In which case for each instance found by Query, Expression will be&#xA;evaluated with &#34;_&#34; set to the instance. When the expression returns true&#xA;then the instance will be included in the final result, otherwise it&#xA;will not.&#xA;&#xA;Action invocations look like function calls in most languages:&#xA;&#xA;    &amp;lt;ActionName&amp;gt;(arg, arg, ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Predicates There are two predicates available for looking at an instance: running?, and can?.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;running?(&amp;lt;Instance&amp;gt;)&#34; returns true if the given instance is currently&#xA;in the running state.&#xA;&#xA;&#34;can?(&amp;lt;Capability&amp;gt;)&#34; returns true if the instance held in &#34;_&#34; has the&#xA;given Capability.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;BUGS AND TODO * The parser does not provide good error messages when something is wrong.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*       Specifying parameters for plugin modules interferes with&#xA;        specifying file paths.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;AUTHOR Andrew Parker &lt;a href=&#34;mailto:aparker42@gmail.com&#34;&gt;aparker42@gmail.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>