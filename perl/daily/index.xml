<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-07T01:41:38Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hamishcoleman/thinkpad-ec</title>
    <updated>2023-08-07T01:41:38Z</updated>
    <id>tag:github.com,2023-08-07:/hamishcoleman/thinkpad-ec</id>
    <link href="https://github.com/hamishcoleman/thinkpad-ec" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Infrastructure for examining and patching Thinkpad embedded controller firmware&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;COMPATIBILTY WARNING:&lt;/h2&gt; &#xA;&lt;p&gt;As the result of CVE-2019-6171, newer Lenovo firmware update files have added a digital signature. If you upgrade to locked version you will not be able to patch your EC without downgrading it.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;laptop&lt;/th&gt; &#xA;   &lt;th&gt;last modifiable&lt;/th&gt; &#xA;   &lt;th&gt;first protected version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;t430&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.81 (G1ETC1WW) EC 1.13 (G1HT35WW)&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.82 (G1ETC2WW) EC 1.14 (G1HT36WW)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;t430s&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.75 (G7ETB5WW) EC 1.16 (G7HT39WW)&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.76 (G7ETB6WW) EC 1.16 (G7HT40WW)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;t530, t530i&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.76 (G4ETB6WW) EC 1.13 (G4HT39WW)&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.77 (G4ETB7WW) EC 1.14 (G4HT40WW)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;w530&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.75 (G5ETB5WW) EC 1.13 (G4HT39WW)&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.76 (G5ETB6WW) EC 1.14 (G4HT40WW)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;x230&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.75 (G2ETB5WW) EC 1.14 (G2HT35WW)&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.77 (G2ETB7WW) EC 1.15 (G2HT36WW)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;x230t&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.73 (GCETB3WW) EC 1.14 (GCHT25WW)&lt;/td&gt; &#xA;   &lt;td&gt;BIOS 2.75 (GCETB5WW) EC 1.15 (GCHT26WW)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Basically, any BIOS update package where the changelog mentions CVE-2019-6171 will have this lockdown.&lt;/p&gt; &#xA;&lt;p&gt;Lenovo is tracking their response to this CVE at: &lt;a href=&#34;https://support.lenovo.com/gb/en/solutions/len-27764&#34;&gt;https://support.lenovo.com/gb/en/solutions/len-27764&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you upgraded your BIOS to the locked version:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ensure that downgrading is possible in BIOS settings (Security/UEFI BIOS Update Option/Secure Rollback Prevention -&amp;gt; Disable)&lt;/li&gt; &#xA; &lt;li&gt;Downgrade it to the latest supported version. EC will be automatically downgraded as well&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Intro&lt;/h2&gt; &#xA;&lt;p&gt;The main purpose of this software is to patch the EC on xx30 series thinkpads to make the classic 7-row keyboards work. There are also patches included (but disabled by default) to disable the authentic battery validation check.&lt;/p&gt; &#xA;&lt;p&gt;With the patches included here, you can install the classic keyboard hardware on many xx30 series laptops and make almost every key work properly. The only keys that are not working are Fn+F3 (Battery) and Fn+F12 (Hibernate).&lt;/p&gt; &#xA;&lt;p&gt;The xx30 keyboards do not have a Caps Lock Indicator and the motherboard has no hardware support for a Caps Lock Indicator, so the replacement classic keyboard will never turn on the Indicator on any laptop.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;A full writeup of the hardware modifications needed can be found at: &lt;a href=&#34;http://www.thinkwiki.org/wiki/Install_Classic_Keyboard_on_xx30_Series_ThinkPads&#34;&gt;http://www.thinkwiki.org/wiki/Install_Classic_Keyboard_on_xx30_Series_ThinkPads&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;More information for hacking on this can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/hamishcoleman/thinkpad-ec/master/docs/HACKING.txt&#34;&gt;HACKING doc&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A video presenting how these thinkpad laptops were hacked is online: &lt;a href=&#34;https://www.youtube.com/watch?v=Fzmm87oVQ6c&#34;&gt;https://www.youtube.com/watch?v=Fzmm87oVQ6c&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Reverse engineering details for the L430, L530, B580, V480, V480c, V580, V580c and E330 models can be found in the &lt;a href=&#34;https://github.com/leecher1337/thinkpad-Lx30-ec&#34;&gt;thinkpad-Lx30-ec project&lt;/a&gt;. Patches for patching the genuine battery check on these have been contributed from that project. (These all have an Nuvotron EC, with a different architecture to the original &#34;classic&#34; thinkpad models).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Step-by-step instructions:&lt;/h2&gt; &#xA;&lt;p&gt;This software expects to be run under Linux (real Linux, not Microsoft Windows Linux subsystem). For best results, ensure you have updated your BIOS to a recent version before starting. If there is too large a difference between the BIOS and EC versions then the flash process will not complete.&lt;/p&gt; &#xA;&lt;p&gt;A little more detail about the BIOS versions: It is not so much a question about upgrading to a recent BIOS version, but more of ensuring you are using a compatible EC firmware version. For safety, ensure that the EC version you are running is the same as the EC version used by the patched image you build. The version used to build the patch is shown at the end of the build process and during the pre-flash warning message.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure you have installed the minimum required packages On Debian, this can be done with:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sudo apt-get update&#xA;sudo apt-get install make git&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;On Fedora, you could install it with dnf:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sudo dnf install git mtools openssl-devel&#xA;sudo dnf group install &#34;C Development Tools and Libraries&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;On OpenSUSE, try:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sudo zypper in git mtools libressl-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone a copy of this repo on to your computer:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;cd ~/&#xA;git clone https://github.com/hamishcoleman/thinkpad-ec&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Change to the directory created by the clone:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;cd ~/thinkpad-ec&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the prerequisite packages On Debian, this can be done with:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sudo make build-deps&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Show the list of laptops and USB image file names:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;make list_laptops&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Choose your laptop model name from the list shown. E.G. &#34;patched.x230.img&#34; for a x230 laptop.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Optionally, the configuration can be changed from the defaults at this point. Read the &lt;a href=&#34;https://raw.githubusercontent.com/hamishcoleman/thinkpad-ec/master/docs/CONFIG.md&#34;&gt;CONFIG doc&lt;/a&gt; for details of the available config options.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Using the name chosen in the previous step, make the fully patched image for this laptop (this will download the original file from Lenovo and patch it):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;make patched.x230.img&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Insert your USB stick and determine what device name it has. (Note: chose a USB stick with nothing important on it, it will be erased in the next step) This command should help you find the right device:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;lsblk -d -o NAME,SIZE,LABEL&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note: Do not mount the USB stick. If your desktop environment automatically mounts devices for you, you will need to unmount the stick. You may find that using the &#34;Eject&#34; option does not work as it may turn the power off to the stick, which will stop the next step from working.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Write the bootable patched image onto the USB stick device (replace the &#34;sdx&#34; in this command with the correct name for your usb stick)&lt;/p&gt; &lt;p&gt;WARNING: if you do not have the right device name, you might overwrite your hard drive!&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sudo dd if=patched.x230.img of=/dev/sdx bs=4M status=progress conv=fsync&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Your USB stick is now ready to boot and install the patched firmware.&lt;/p&gt; &#xA;&lt;h2&gt;Notes:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can also create a bootable CDROM image for burning to a disk by asking for a &#34;.iso&#34; file instead of the &#34;.img&#34; in step 6 above. Then you can use your normal CDROM burning tools to put this image on a blank cd and boot it up, skipping steps 7 and 8.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The configuration is applied during the building of the patched image. If you wish to change the configuration, the patched image will need to be rebuilt.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Booting the stick and flashing the firmware:&lt;/h2&gt; &#xA;&lt;p&gt;While flashing the firmware is as simple as booting the USB stick created above, there are a couple of steps that can help the process. This is more a list of issues that the community has discovered as the patch was applied in different circumstances than a hard and fast set of requirements.&lt;/p&gt; &#xA;&lt;p&gt;The flashing process takes place in two distinct steps (these are outlined below, but explained in more detail in &lt;a href=&#34;https://raw.githubusercontent.com/hamishcoleman/thinkpad-ec/master/docs/firmware_flashing.txt&#34;&gt;firmware_flashing doc&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Booting the USB stick:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;First shows a page with information about the patch, including which laptop type it was built for.&lt;/li&gt; &#xA;   &lt;li&gt;Then it hands the new EC update to the BIOS, &#34;staging&#34; it for a future flashing into the EC hardware&lt;/li&gt; &#xA;   &lt;li&gt;Finally it reboots the system.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Under the BIOS control, during a bootup:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;During the boot, the BIOS notices that it has a new EC update staged&lt;/li&gt; &#xA;   &lt;li&gt;It then checks if it is safe to flash this update to the EC.&lt;/li&gt; &#xA;   &lt;li&gt;If everything is safe, it will show a screen saying &#34;Flashing EC&#34;&lt;/li&gt; &#xA;   &lt;li&gt;The system will bootup normally with the new EC code running.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you don&#39;t see this second screen with the &#34;Flashing EC&#34; message, your EC has not been flashed, and you should continue reading below to see what steps you can take to ensure the EC is properly flashed with the patched firmware. In this cases everything might look like it was successful but after the reboot the keys are not remapped.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;For best results, ensure you have the power charger plugged in during the flashing process.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Some chargers seem to have issues with actually performing the flashing procedure after the flash process reboots. So, if you have - or can borrow - other chargers, try that.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The firmware flash process generally requires you to have a charged battery plugged in to the laptop before it will complete.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It may be possible to bypass the requirement for a charged battery if you unplug the battery completely.&lt;/li&gt; &#xA;   &lt;li&gt;Alternatively, it might be simply looking for any battery /and/ the power charger plugged in.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Yes, this is contradictory, but it is worth trying both options.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;An ultrabay battery is not considered by the update mechanism to be a suitable source of power - when trying different battery options, ensure you are trying batteries in the main battery slot.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure your BIOS has been configured to boot from &#34;Legacy&#34; and not &#34;UEFI&#34; before trying to boot.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you do normally use UEFI boot, there has been at least one case where the EC does not get flashed until the BIOS is switched back into UEFI mode - after which the EC was automatically flashed on the next reboot.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>pfischer/AI-ExpertSystem-Advanced</title>
    <updated>2023-08-07T01:41:38Z</updated>
    <id>tag:github.com,2023-08-07:/pfischer/AI-ExpertSystem-Advanced</id>
    <link href="https://github.com/pfischer/AI-ExpertSystem-Advanced" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Perl Expert system with backward, forward and mixed algorithms&lt;/p&gt;&lt;hr&gt;&lt;p&gt;NAME AI::ExpertSystem::Advanced - Expert System with backward, forward and mixed algorithms&lt;/p&gt; &#xA;&lt;p&gt;DESCRIPTION Inspired in AI::ExpertSystem::Simple but with additional features:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   Uses backward, forward and mixed algorithms.&#xA;&#xA;*   Offers different views, so user can interact with the expert system&#xA;    via a terminal or with a friendly user interface.&#xA;&#xA;*   The knowledge database can be stored in any format such as YAML, XML&#xA;    or databases. You just need to choose what driver to use and you are&#xA;    done.&#xA;&#xA;*   Uses certainty factors.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SYNOPSIS An example of the mixed algorithm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    use AI::ExpertSystem::Advanced;&#xA;    use AI::ExpertSystem::Advanced::KnowledgeDB::Factory;&#xA;&#xA;    my $yaml_kdb = AI::ExpertSystem::Advanced::KnowledgeDB::Factory-&amp;gt;new(&#39;yaml&#39;,&#xA;        {&#xA;            filename =&amp;gt; &#39;examples/knowledge_db_one.yaml&#39;&#xA;        });&#xA;&#xA;    my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;            viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;            knowledge_db =&amp;gt; $yaml_kdb,&#xA;            initial_facts =&amp;gt; [&#39;I&#39;],&#xA;            verbose =&amp;gt; 1);&#xA;    $ai-&amp;gt;mixed();&#xA;    $ai-&amp;gt;summary();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Attributes initial_facts A list/set of initial facts the algorithms start using.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    During the forward algorithm the task is to find a list of goals&#xA;    caused by these initial facts (the only data we have in that&#xA;    moment).&#xA;&#xA;    Lets imagine your knowledge database is about symptoms and diseases.&#xA;    You need to find what diseases are caused by the symptoms of a&#xA;    patient, these first symptons are the initial facts.&#xA;&#xA;    Initial facts as also asked and inference facts can be negative or&#xA;    positive. By default the initial facts are positive.&#xA;&#xA;    Keep in mind that the data contained in this array can be the IDs or&#xA;    the name of the fact.&#xA;&#xA;    This array will be converted to initial_facts_dict. And all the data&#xA;    (ids or or names) will be made of only IDs.&#xA;&#xA;        my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;                viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;                knowledge_db =&amp;gt; $yaml_kdb,&#xA;                initial_facts =&amp;gt; [&#39;I&#39;, [&#39;F&#39;, &#39;-&#39;], [&#39;G&#39;, &#39;+&#39;]);&#xA;&#xA;    As you can see if you want to provide the sign of a fact, just&#xA;    *encapsulate* it in an array, the first item should be the fact and&#xA;    the second one the sign.&#xA;&#xA;initial_facts_dict&#xA;    This dictionary (see AI::ExpertSystem::Advanced::Dictionary has the&#xA;    sasme data of initial_facts but with the additional feature(s) of&#xA;    proviing iterators and a quick way to find elements.&#xA;&#xA;goals_to_check&#xA;        my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;                viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;                knowledge_db =&amp;gt; $yaml_kdb,&#xA;                goals_to_check =&amp;gt; [&#39;J&#39;]);&#xA;&#xA;    When doing the backward() algorithm it&#39;s required to have at least&#xA;    one goal (aka hypothesis).&#xA;&#xA;    This could be pretty similar to initial_facts, with the difference&#xA;    that the initial facts are used more with the causes of the rules&#xA;    and this one with the goals (usually one in a well defined knowledge&#xA;    database).&#xA;&#xA;    The same rule of initial_facts apply here, you can provide the sign&#xA;    of the facts and you can provide the id or the name of them.&#xA;&#xA;    From our example of symptoms and diseases lets imagine we have the&#xA;    hypothesis that a patient has flu, we don&#39;t know the symptoms it&#xA;    has, we want the expert system to keep asking us for them to make&#xA;    sure that our hypothesis is correct (or incorrect in case there&#39;s&#xA;    not enough information).&#xA;&#xA;goals_to_check_dict&#xA;    Very similar to goals_to_check (and indeed of initial_facts_dict).&#xA;    We want to make the job easier.&#xA;&#xA;    It will be a dictionary made of the data of goals_to_check.&#xA;&#xA;inference_facts&#xA;    Inference facts are basically the core of an expert system. These&#xA;    are facts that are found and copied when a set of facts (initial,&#xA;    inference or asked) match with the causes of a goal.&#xA;&#xA;    inference_facts is a AI::ExpertSystem::Advanced::Dictionary, it will&#xA;    store the name of the fact, the rule that caused these facts to be&#xA;    copied to this dictionary, the sign and the algorithm that triggered&#xA;    it.&#xA;&#xA;knowledge_db&#xA;    The object reference of the knowledge database&#xA;    AI::ExpertSystem::Advanced is using.&#xA;&#xA;asked_facts&#xA;    During the backward() algorithm there will be cases when there&#39;s no&#xA;    clarity if a fact exists. In these cases the backward() will be&#xA;    asking the user (via automation or real questions) if a fact exists.&#xA;&#xA;    Going back to the initial_facts example of symptoms and diseases.&#xA;    Imagine the algorithm is checking a rule, some of the facts of the&#xA;    rule make a match with the ones of initial_facts or inference_facts&#xA;    but some wont, for these *unsure* facts the backward() will ask the&#xA;    user if a symptom (a fact) exists. All these asked facts will be&#xA;    stored here.&#xA;&#xA;visited_rules&#xA;    Keeps a record of all the rules the algorithms have visited and also&#xA;    the number of causes each rule has.&#xA;&#xA;verbose&#xA;        my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;                viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;                knowledge_db =&amp;gt; $yaml_kdb,&#xA;                initial_facts =&amp;gt; [&#39;I&#39;],&#xA;                verbose =&amp;gt; 1);&#xA;&#xA;    By default this is turned off. If you want to know what happens&#xA;    behind the scenes turn this on.&#xA;&#xA;    Everything that needs to be debugged will be passed to the debug()&#xA;    method of your viewer.&#xA;&#xA;viewer&#xA;    Is the object AI::ExpertSystem::Advanced will be using for printing&#xA;    what is happening and for interacting with the user (such as asking&#xA;    the asked_facts).&#xA;&#xA;    This is practical if you want to use a viewer object that is not&#xA;    provided by AI::ExpertSystem::Advanced::Viewer::Factory.&#xA;&#xA;viewer_class&#xA;    Is the the class name of the viewer.&#xA;&#xA;    You can decide to use the viewers&#xA;    AI::ExpertSystem::Advanced::Viewer::Factory offers, in this case you&#xA;    can pass the object or only the name of your favorite viewer.&#xA;&#xA;found_factor&#xA;    In your knowledge database you can give different *weights* to the&#xA;    facts of each rule (eg to define what facts have more *priority*).&#xA;    During the mixed() algorithm it will be checking what causes are&#xA;    found in the inference_facts and in the asked_facts dictionaries,&#xA;    then the total number of matches (or total number of certainity&#xA;    factors of each rule) will be compared versus the value of this&#xA;    factor, if it&#39;s higher or equal then the rule will be triggered.&#xA;&#xA;    You can read the documentation of the mixed() algorithm to know the&#xA;    two ways this factor can be used.&#xA;&#xA;shot_rules&#xA;    All the rules that are shot are stored here. This is a hash, the key&#xA;    of each item is the rule id while its value is the precision time&#xA;    when the rule was shot.&#xA;&#xA;    The precision time is useful for knowing when a rule was shot and&#xA;    based on that you can know what steps it followed so you can compare&#xA;    (or reproduce) them.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Constants * FACT_SIGN_NEGATIVE Used when a fact is negative, aka, a fact doesn&#39;t happen.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* FACT_SIGN_POSITIVE&#xA;    Used for those facts that happen.&#xA;&#xA;* FACT_SIGN_UNSURE&#xA;    Used when there&#39;s no straight answer of a fact, eg, we don&#39;t know if&#xA;    an answer will change the result.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Methods shoot($rule, $algorithm) Shoots the given rule. It will do the following verifications:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   Each of the facts (causes) will be compared against the&#xA;    initial_facts_dict, inference_facts and asked_facts (in this order).&#xA;&#xA;*   If any initial, inference or asked fact matches with a cause but&#xA;    it&#39;s negative then all of its goals (usually only one by rule) will&#xA;    be copied to the inference_facts with a negative sign, otherwise a&#xA;    positive sign will be used.&#xA;&#xA;*   Will add the rule to the shot_rules hash.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is_rule_shot($rule) Verifies if the given $rule has been shot.&lt;/p&gt; &#xA;&lt;p&gt;get_goals_by_rule($rule) Will ask the knowledge_db for the goals of the given $rule.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;A AI::ExpertSystem::Advanced::Dictionary will be returned.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;get_causes_by_rule($rule) Will ask the knowledge_db for the causes of the given $rule.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;A AI::ExpertSystem::Advanced::Dictionary will be returned.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is_fact_negative($dict_name, $fact) Will check if the given $fact of the given dictionary ($dict_name) is negative.&lt;/p&gt; &#xA;&lt;p&gt;copy_to_inference_facts($facts, $sign, $algorithm, $rule) Copies the given $facts (a dictionary, usually goal(s) of a rule) to the inference_facts dictionary. All the given goals will be copied with the given $sign.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Additionally it will add the given $algorithm and $rule to the inference&#xA;facts. So later we can know how we got to a certain inference fact.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;compare_causes_with_facts($rule) Compares the causes of the given $rule with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   Initial facts&#xA;&#xA;*   Inference facts&#xA;&#xA;*   Asked facts&#xA;&#xA;It will be couting the matches of all of the above dictionaries, so for&#xA;example if we have four causes, two make match with initial facts, other&#xA;with inference and the remaining one with the asked facts, then it will&#xA;evaluate to true since we have a match of the four causes.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;get_causes_match_factor($rule) Similar to compare_causes_with_facts() but with the difference that it will count the &#34;match factor&#34; of each matched cause and return the total of this weight.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The match factor is used by the mixed() algorithm and is useful to know&#xA;if a certain rule should be shoot or not even if not all of the causes&#xA;exist in our facts.&#xA;&#xA;The *match factor* is calculated in two ways:&#xA;&#xA;*   Will do a sum of the weight for each matched cause. Please note that&#xA;    if only one cause of a rule has a specified weight then the&#xA;    remaining causes will default to the total weight minus 1 and then&#xA;    divided with the total number of causes (matched or not) that don&#39;t&#xA;    have a weight.&#xA;&#xA;*   If no weight is found with all the causes of the given rule, then&#xA;    the total number of matches will be divided by the total number of&#xA;    causes.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is_goal_in_our_facts($goal) Checks if the given $goal is in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1   The initial facts&#xA;&#xA;2   The inference facts&#xA;&#xA;3   The asked facts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;remove_last_ivisited_rule() Removes the last visited rule and return its number.&lt;/p&gt; &#xA;&lt;p&gt;visit_rule($rule, $total_causes) Adds the given $rule to the end of the visited_rules.&lt;/p&gt; &#xA;&lt;p&gt;copy_to_goals_to_check($rule, $facts) Copies a list of facts (usually a list of causes of a rule) to goals_to_check_dict.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The rule ID of the goals that are being copied is also stored in the&#xA;hahs.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ask_about($fact) Uses viewer to ask the user for the existence of the given $fact.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The valid answers are:&#xA;&#xA;+ or FACT_SIGN_POSITIVE&#xA;    In case user knows of it.&#xA;&#xA;- or FACT_SIGN_NEGATIVE&#xA;    In case user doesn&#39;t knows of it.&#xA;&#xA;~ or FACT_SIGN_UNSURE&#xA;    In case user doesn&#39;t have any clue about the given fact.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;get_rule_by_goal($goal) Looks in the knowledge_db for the rule that has the given goal. If a rule is found its number is returned, otherwise undef.&lt;/p&gt; &#xA;&lt;p&gt;forward() use AI::ExpertSystem::Advanced; use AI::ExpertSystem::Advanced::KnowledgeDB::Factory;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $yaml_kdb = AI::ExpertSystem::Advanced::KnowledgeDB::Factory-&amp;gt;new(&#39;yaml&#39;,&#xA;            {&#xA;                filename =&amp;gt; &#39;examples/knowledge_db_one.yaml&#39;&#xA;            });&#xA;&#xA;    my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;            viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;            knowledge_db =&amp;gt; $yaml_kdb,&#xA;            initial_facts =&amp;gt; [&#39;F&#39;, &#39;J&#39;]);&#xA;    $ai-&amp;gt;forward();&#xA;    $ai-&amp;gt;summary();&#xA;&#xA;The forward chaining algorithm is one of the main methods used in Expert&#xA;Systems. It starts with a set of variables (known as initial facts) and&#xA;reads the available rules.&#xA;&#xA;It will be reading rule by rule and for each one it will compare its&#xA;causes with the initial, inference and asked facts. If all of these&#xA;causes are in the facts then the rule will be shoot and all of its goals&#xA;will be copied/converted to inference facts and will restart reading&#xA;from the first rule.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;backward() use AI::ExpertSystem::Advanced; use AI::ExpertSystem::Advanced::KnowledgeDB::Factory;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $yaml_kdb = AI::ExpertSystem::Advanced::KnowledgeDB::Factory-&amp;gt;new(&#39;yaml&#39;,&#xA;        {&#xA;            filename =&amp;gt; &#39;examples/knowledge_db_one.yaml&#39;&#xA;            });&#xA;&#xA;    my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;            viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;            knowledge_db =&amp;gt; $yaml_kdb,&#xA;            goals_to_check =&amp;gt; [&#39;J&#39;]);&#xA;    $ai-&amp;gt;backward();&#xA;    $ai-&amp;gt;summary();&#xA;&#xA;The backward algorithm starts with a set of *assumed* goals (facts). It&#xA;will start reading goal by goal. For each goal it will check if it&#xA;exists in the initial, inference and asked facts (see&#xA;is_goal_in_our_facts()) for more information).&#xA;&#xA;*   If the goal exist then it will be removed from the dictionary, it&#xA;    will also verify if there are more visited rules to shoot.&#xA;&#xA;    If there are still more visited rules to shoot then it will check&#xA;    from what rule the goal comes from, if it was copied from a rule&#xA;    then this data will exist. With this information then it will see&#xA;    how many of the causes of this given rule are still in the&#xA;    goals_to_check_dict.&#xA;&#xA;    In case there are still causes of this rule in goals_to_check_dict&#xA;    then the amount of causes pending will be reduced by one. Otherwise&#xA;    (if the amount is 0) then the rule of this last removed goal will be&#xA;    shoot.&#xA;&#xA;*   If the goal doesn&#39;t exist in the mentioned facts then the goal will&#xA;    be searched in the goals of every rule.&#xA;&#xA;    In case it finds the rule that has the goal, this rule will be&#xA;    marked (added) to the list of visited rules (visited_rules) and also&#xA;    all of its causes will be added to the top of the&#xA;    goals_to_check_dict and it will start reading again all the goals.&#xA;&#xA;    If there&#39;s the case where the goal doesn&#39;t exist as a goal in the&#xA;    rules then it will ask the user (via ask_about()) for the existence&#xA;    of it. If user is not sure about it then the algorithm ends.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;mixed() As its name says, it&#39;s a mix of forward() and backward() algorithms, it requires to have at least one initial fact.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The first thing it does is to run the forward() algorithm (hence the&#xA;need of at least one initial fact). If the algorithm fails then the&#xA;mixed algorithm also ends unsuccessfully.&#xA;&#xA;Once the first *run* of forward() algorithm happens it starts looking&#xA;for any positive inference fact, if only one is found then this ends the&#xA;algorithm with the assumption it knows what&#39;s happening.&#xA;&#xA;In case no positive inference fact is found then it will start reading&#xA;the rules and creating a list of intuitive facts.&#xA;&#xA;For each rule it will get a *certainty factor* of its causes versus the&#xA;initial, inference and asked facts. In case the certainity factor is&#xA;greater or equal than found_factor then all of its goals will be copied&#xA;to the intuitive facts (eg, read it as: it assumes the goals have&#xA;something to do with our first initial facts).&#xA;&#xA;Once all the rules are read then it verifies if there are intuitive&#xA;facts, if no facts are found then it ends with the intuition, otherwise&#xA;it will run the backward() algorithm for each one of these facts (eg,&#xA;each fact will be converted to a goal). After each *run* of the&#xA;backward() algorithm it will verify for any positive inference fact, if&#xA;just one is found then the algorithm ends.&#xA;&#xA;At the end (if there are still no positive inference facts) it will run&#xA;the forward() algorithm and restart (by looking again for any positive&#xA;inference fact).&#xA;&#xA;A good example to understand how this algorithm is useful is: imagine&#xA;you are a doctor and know some of the symptoms of a patient. Probably&#xA;with the first symptoms you have you can get to a positive conclusion&#xA;(eg that a patient has *X* disease). However in case there&#39;s still no&#xA;clue, then a set of questions (done by the call of backward()) of&#xA;symptons related to the initial symptoms will be asked to the user. For&#xA;example, we know that that the patient has a headache but that doesn&#39;t&#xA;give us any positive answer, what if the patient has flu or another&#xA;disease? Then a set of these *related* symptons will be asked to the&#xA;user.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;summary($return) The main purpose of any expert system is the ability to explain: what is happening, how it got to a result, what assumption(s) it required to make, the fatcs that were excluded and the ones that were used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This method will use the viewer (or return the result) in YAML format of&#xA;all the rules that were shot. It will explain how it got to each one of&#xA;the causes so a better explanation can be done by the viewer.&#xA;&#xA;If $return is defined (eg, it got any parameter) then the result wont be&#xA;passed to the viewer, instead it will be returned as a string.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SEE ALSO Take a look AI::ExpertSystem::Simple too.&lt;/p&gt; &#xA;&lt;p&gt;AUTHOR Pablo Fischer (&lt;a href=&#34;mailto:pablo@pablo.com.mx&#34;&gt;pablo@pablo.com.mx&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;COPYRIGHT Copyright (C) 2010 by Pablo Fischer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This library is free software; you can redistribute it and/or modify it&#xA;under the same terms as Perl itself.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>