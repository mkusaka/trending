<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-13T01:40:53Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fniessen/git-leuven</title>
    <updated>2023-04-13T01:40:53Z</updated>
    <id>tag:github.com,2023-04-13:/fniessen/git-leuven</id>
    <link href="https://github.com/fniessen/git-leuven" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Git configuration, aliases and extra commands&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Awesome Git aliases and extra commands #+AUTHOR: Fabrice Niessen #+EMAIL: (concat &#34;fniessen&#34; at-sign &#34;pirilampo.org&#34;) #+DESCRIPTION: Pretty format for `git log&#39; and different helpful command aliases #+KEYWORDS: git, log, pretty format, alias #+LANGUAGE: en #+OPTIONS: H:4 num:nil toc:nil&lt;/p&gt; &#xA;&lt;p&gt;#+SETUPFILE: ~/org/theme-readtheorg.setup&lt;/p&gt; &#xA;&lt;p&gt;#+EXPORT_EXCLUDE_TAGS: noexport #+PROPERTY: header-args :tangle .gitconfig :eval no&lt;/p&gt; &#xA;&lt;p&gt;#+name: current-time #+begin_src emacs-lisp :eval yes :results value silent :tangle no :exports none (format-time-string &#34;%Y%m%d.%H%M&#34;) #+end_src&lt;/p&gt; &#xA;&lt;h1&gt;- &lt;a href=&#34;http://doc.bazaar.canonical.com/beta/en/user-reference/tags-help.html&#34;&gt;http://doc.bazaar.canonical.com/beta/en/user-reference/tags-help.html&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;- &lt;a href=&#34;https://manned.org/bzr/307858cd&#34;&gt;https://manned.org/bzr/307858cd&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;- &lt;a href=&#34;https://documentation.help/Bazaar-help/revisionspec-help.html&#34;&gt;https://documentation.help/Bazaar-help/revisionspec-help.html&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;- &lt;a href=&#34;https://www.mercurial-scm.org/wiki/GitConcepts#Command_equivalence_table&#34;&gt;https://www.mercurial-scm.org/wiki/GitConcepts#Command_equivalence_table&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Table of Contents :TOC_1_gh:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#foreword][Foreword]]&lt;/li&gt; &#xA; &lt;li&gt;[[#overview][Overview]]&lt;/li&gt; &#xA; &lt;li&gt;[[#global-options][Global options]]&lt;/li&gt; &#xA; &lt;li&gt;[[#------------------------------------------------------------------------------][------------------------------------------------------------------------------]]&lt;/li&gt; &#xA; &lt;li&gt;[[#aliases][Aliases]]&lt;/li&gt; &#xA; &lt;li&gt;[[#repository][Repository]]&lt;/li&gt; &#xA; &lt;li&gt;[[#instructions][Instructions]]&lt;/li&gt; &#xA; &lt;li&gt;[[#source-files][Source Files]]&lt;/li&gt; &#xA; &lt;li&gt;[[#commits][Commits]]&lt;/li&gt; &#xA; &lt;li&gt;[[#branches][Branches]]&lt;/li&gt; &#xA; &lt;li&gt;[[#tags][Tags]]&lt;/li&gt; &#xA; &lt;li&gt;[[#compare-revisions-commits-branches-or-tags][Compare Revisions (commits, branches or tags)]]&lt;/li&gt; &#xA; &lt;li&gt;[[#releases][?Releases]]&lt;/li&gt; &#xA; &lt;li&gt;[[#graph][?Graph]]&lt;/li&gt; &#xA; &lt;li&gt;[[#contributors][?Contributors]]&lt;/li&gt; &#xA; &lt;li&gt;[[#pull-requests][Pull requests]]&lt;/li&gt; &#xA; &lt;li&gt;[[#pipelines][Pipelines]]&lt;/li&gt; &#xA; &lt;li&gt;[[#deployments-to-different-environments][Deployments (to different environments)]]&lt;/li&gt; &#xA; &lt;li&gt;[[#issues][Issues]]&lt;/li&gt; &#xA; &lt;li&gt;[[#wiki][Wiki]]&lt;/li&gt; &#xA; &lt;li&gt;[[#downloads][Downloads]]&lt;/li&gt; &#xA; &lt;li&gt;[[#settings][Settings]]&lt;/li&gt; &#xA; &lt;li&gt;[[#-------------------------------------------------------------------------------1][------------------------------------------------------------------------------]]&lt;/li&gt; &#xA; &lt;li&gt;[[#run-on-all-repositories][Run on All repositories]]&lt;/li&gt; &#xA; &lt;li&gt;[[#sort-out][Sort out]]&lt;/li&gt; &#xA; &lt;li&gt;[[#download-repository][Download repository]]&lt;/li&gt; &#xA; &lt;li&gt;[[#what-if][What if]]&lt;/li&gt; &#xA; &lt;li&gt;[[#if-you-made-a-mistake][If you made a mistake]]&lt;/li&gt; &#xA; &lt;li&gt;[[#if-you-get-errors][If you get errors...]]&lt;/li&gt; &#xA; &lt;li&gt;[[#github-tasks][GitHub tasks]]&lt;/li&gt; &#xA; &lt;li&gt;[[#references][References]]&lt;/li&gt; &#xA; &lt;li&gt;[[#git-clients][Git clients]]&lt;/li&gt; &#xA; &lt;li&gt;[[#contributing][Contributing]]&lt;/li&gt; &#xA; &lt;li&gt;[[#license][License]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Foreword&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;This is Git. It tracks collaborative work on projects through a beautiful distributed graph theory model.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Cool. How do we use it?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No idea. Just memorize these Shell commands and type them to sync up. If you get errors, save your work elsewhere, delete the project, and download a fresh copy.&lt;/p&gt; &lt;p&gt;If that doesn&#39;t fix it, =git.txt= contains the phone number of a friend of mine who understands &lt;del&gt;git&lt;/del&gt;. Just wait through a few minutes of /&#39;It&#39;s really pretty simple, just think of branches as...&#39;/ and eventually you&#39;ll learn the commands that will fix everything.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;From [[https://xkcd.com/1597/][xkcd]].&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Overview&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following configures interesting global settings for Git. These are stored in the =.gitconfig= file located in the user home directory.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Preferences&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Customizing Git.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :noweb yes&lt;/p&gt; &#xA;&lt;h1&gt;.gitconfig, Time-stamp: &amp;lt;&amp;lt;current-time()&amp;gt;&amp;gt;&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** User&lt;/p&gt; &#xA;&lt;p&gt;Setting your user name and e-mail address is important because Git stores the committer and author of a change in every commit.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [checkout] preserveTimestamps = true&lt;/p&gt; &#xA;&lt;p&gt;[user] # Tell Git about yourself. Override this in the file .gitconfig_local. name = John Doe email = &lt;a href=&#34;mailto:john.doe@example.com&#34;&gt;john.doe@example.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;[github] user = jdoe #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You should &#34;override&#34; the above with your personal details in the file =.gitconfig_local=.&lt;/p&gt; &#xA;&lt;p&gt;** Auto-Prune&lt;/p&gt; &#xA;&lt;p&gt;On &lt;em&gt;fetch&lt;/em&gt; / pull, automatically remove local branches that no longer exist on the remote:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [fetch] prune = true #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Default Branch Name&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;del&gt;master&lt;/del&gt; as the name for the initial branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [init] defaultBranch = master #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This default branch name is subject to change. To configure the initial branch name to use in all of your new repositories, which will suppress this warning, call:&lt;/p&gt; &#xA;&lt;p&gt;Names commonly chosen instead of &lt;del&gt;master&lt;/del&gt; are &lt;del&gt;main&lt;/del&gt;, &lt;del&gt;trunk&lt;/del&gt; and &lt;del&gt;development&lt;/del&gt;. The just-created branch can be renamed via:&lt;/p&gt; &#xA;&lt;p&gt;: git branch -m NAME&lt;/p&gt; &#xA;&lt;p&gt;** External Merge Tool&lt;/p&gt; &#xA;&lt;p&gt;How to resolve merge conflicts in Git? Try &lt;del&gt;git mergetool&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [merge] conflictstyle = diff3 #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For small changes, &lt;del&gt;git diff&lt;/del&gt; and &lt;del&gt;vc-diff&lt;/del&gt; are perfect.&lt;/li&gt; &#xA; &lt;li&gt;For medium changes, &lt;del&gt;magit&lt;/del&gt; is perfect.&lt;/li&gt; &#xA; &lt;li&gt;For large changes, [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD) is perfect.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Firstly, here is what the parameters (used below) mean:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;$LOCAL&lt;/del&gt; is the file in the &lt;em&gt;current branch&lt;/em&gt; (e.g. &lt;del&gt;master&lt;/del&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;$REMOTE&lt;/del&gt; is the file in the &lt;em&gt;branch being merged&lt;/em&gt; (e.g. &lt;del&gt;BRANCH_NAME&lt;/del&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;$MERGED&lt;/del&gt; is the &lt;em&gt;partially merged file&lt;/em&gt; with the merge conflict information in it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;$BASE&lt;/del&gt; is the &lt;em&gt;common ancestor&lt;/em&gt; of &lt;del&gt;$LOCAL&lt;/del&gt; and &lt;del&gt;$REMOTE&lt;/del&gt;, this is to say the file as it was (before both changes) when the branch containing &lt;del&gt;$REMOTE&lt;/del&gt; was originally created.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Emacs as a Git mergetool&lt;/p&gt; &#xA;&lt;p&gt;Ediff or Emerge? Or Magit???&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no [merge] tool = ediff&lt;/p&gt; &#xA;&lt;p&gt;[mergetool &#34;ediff&#34;] cmd = emacsclient -c -a &#34;&#34; --eval &#34;(ediff-merge-files-with-ancestor \&#34;$LOCAL\&#34; \&#34;$REMOTE\&#34; \&#34;$BASE\&#34; nil \&#34;$MERGED\&#34;)&#34; keepBackup = false #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Meld as Git mergetool&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;How do I set up and use Meld as my git mergetool?&lt;/em&gt; See &lt;a href=&#34;https://stackoverflow.com/questions/34119866/setting-up-and-using-meld-as-your-git-difftool-and-mergetool&#34;&gt;https://stackoverflow.com/questions/34119866/setting-up-and-using-meld-as-your-git-difftool-and-mergetool&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;del&gt;auto-merge&lt;/del&gt; in &lt;a href=&#34;https://stackoverflow.com/questions/11133290/git-merging-using-meld&#34;&gt;https://stackoverflow.com/questions/11133290/git-merging-using-meld&lt;/a&gt; (first and second solution).&lt;/p&gt; &#xA;&lt;p&gt;Use [[https://meldmerge.org/][Meld]] as Git &lt;del&gt;mergetool:&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [merge] tool = meld #+end_src&lt;/p&gt; &#xA;&lt;p&gt;I suggest you use either:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no [mergetool &#34;meld&#34;] cmd = meld &#34;$LOCAL&#34; &#34;$MERGED&#34; &#34;$REMOTE&#34; --output &#34;$MERGED&#34; keepBackup = false #+end_src&lt;/p&gt; &#xA;&lt;p&gt;or:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no [mergetool &#34;meld&#34;] cmd = meld &#34;$LOCAL&#34; &#34;$BASE&#34; &#34;$REMOTE&#34; --output &#34;$MERGED&#34; keepBackup = false #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The choice is whether to use &lt;del&gt;$MERGED&lt;/del&gt; or &lt;del&gt;$BASE&lt;/del&gt; in between &lt;del&gt;$LOCAL&lt;/del&gt; and &lt;del&gt;$REMOTE&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Either way, Meld will display 3 panes with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;$LOCAL&lt;/del&gt; in the left pane,&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;$REMOTE&lt;/del&gt; in the right pane and&lt;/li&gt; &#xA; &lt;li&gt;either &lt;del&gt;$MERGED&lt;/del&gt; or &lt;del&gt;$BASE&lt;/del&gt; in the middle pane.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In BOTH cases, &lt;em&gt;the middle pane is the file that you should edit to resolve the merge conflicts&lt;/em&gt;. The difference is just in which starting edit position you&#39;d prefer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;$MERGED&lt;/del&gt; for the file which contains the partially merged file with the merge conflict information or&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;$BASE&lt;/del&gt; for the shared commit ancestor of &lt;del&gt;$LOCAL&lt;/del&gt; and &lt;del&gt;$REMOTE&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_note Since both cmd lines can be useful, I keep them both in my =.gitconfig= file. Most of the time I use the &lt;del&gt;$MERGED&lt;/del&gt; line and the &lt;del&gt;$BASE&lt;/del&gt; line is commented out, but the commenting out can be swapped over if I want to use the &lt;del&gt;$BASE&lt;/del&gt; line instead. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [mergetool &#34;meld&#34;] cmd = meld --diff &#34;$LOCAL&#34; &#34;$MERGED&#34; &#34;$REMOTE&#34; --diff &#34;$BASE&#34; &#34;$LOCAL&#34; --diff &#34;$BASE&#34; &#34;$REMOTE&#34; --output &#34;$MERGED&#34; # cmd = meld --diff &#34;$LOCAL&#34; &#34;$BASE&#34; &#34;$REMOTE&#34; --diff &#34;$BASE&#34; &#34;$LOCAL&#34; --diff &#34;$BASE&#34; &#34;$REMOTE&#34; --output &#34;$MERGED&#34; keepBackup = false #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** External Diff Tool&lt;/p&gt; &#xA;&lt;p&gt;Use [[https://meldmerge.org/][Meld]] as Git &lt;del&gt;difftool:&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [diff] tool = meld&lt;/p&gt; &#xA;&lt;p&gt;[difftool] prompt = false&lt;/p&gt; &#xA;&lt;p&gt;[difftool &#34;meld&#34;] cmd = meld &#34;$LOCAL&#34; &#34;$REMOTE&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** External Editor&lt;/p&gt; &#xA;&lt;p&gt;You may edit your commit messages in your preferred external &lt;em&gt;text editor&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Supported editors include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Atom&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Emacs&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;IntelliJ&lt;/li&gt; &#xA; &lt;li&gt;Notepad++&lt;/li&gt; &#xA; &lt;li&gt;Sublime&lt;/li&gt; &#xA; &lt;li&gt;VS Code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf [core] # editor = notepad++.exe -multiInst -notabbar -nosession -noPlugin editor = emacsclient #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Delete &#34;.orig&#34; files&lt;/p&gt; &#xA;&lt;p&gt;Clean the byproducts of the merge conflict process:&lt;/p&gt; &#xA;&lt;p&gt;: find . -name &#34;*.orig&#34; -delete&lt;/p&gt; &#xA;&lt;p&gt;** Pager Support&lt;/p&gt; &#xA;&lt;p&gt;Some Git commands can produce a lot of output, and Git will attempt to use a pager to make those commands more pleasant.&lt;/p&gt; &#xA;&lt;p&gt;To set the pager that should be used, set the application variable &lt;del&gt;pager&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;*** Less&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note When the &lt;del&gt;LESS&lt;/del&gt; environment variable is unset, Git sets it to &lt;del&gt;-FRSX&lt;/del&gt;. If the &lt;del&gt;LESS&lt;/del&gt; environment variable is set, Git does not change it at all.&lt;/p&gt; &#xA;&lt;p&gt;We use &lt;del&gt;-R&lt;/del&gt; in the command itself to be sure to &lt;em&gt;interpret the color codes&lt;/em&gt; when Git is run from /Windows/ Emacs (&lt;del&gt;C-x v l&lt;/del&gt;), with /no/ value for the &lt;del&gt;LESS&lt;/del&gt; /environment variable/. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # git-grep to ignore ^M. pager = tr -d &#39;\r&#39; | less -REX #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Stop viewing non-printable characters (for example, ISO Latin 1 accents in a UTF-8 terminal) in reverse video and hexadecimals: see &lt;del&gt;LESSBINFMT&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Stop viewing &lt;del&gt;^M&lt;/del&gt; symbols in diff:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol whitespace = cr-at-eol #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Diff-so-fancy extension&lt;/p&gt; &#xA;&lt;p&gt;Improve the &lt;del&gt;git diff&lt;/del&gt; output using a tool like:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/so-fancy/diff-so-fancy][diff-so-fancy]] or&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/dandavison/delta][delta]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf pager = diff-so-fancy | LESS= less --tabs=4 -FRX #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;less&lt;/del&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;-F&lt;/del&gt; to exit immediately if the output is less than one screen,&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;-R&lt;/del&gt; for colors to persist, and&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;-X&lt;/del&gt; for not clearing the screen.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_tip The diff-so-fancy ruler was 1 char too long. It turned out I had an option in &lt;del&gt;$LESS&lt;/del&gt; that enabled the status column, and thus added a space at the beginning of every line. I was able to resolve it by clearing the &lt;del&gt;LESS&lt;/del&gt; environment variable in the &lt;del&gt;core.pager&lt;/del&gt; config.&lt;/p&gt; &#xA;&lt;p&gt;Also, the diff-so-fancy ruler was not displayed in Unicode. It turned out I had set &lt;del&gt;LC_CTYPE&lt;/del&gt; to &#34;&#34;. I had to either unset &lt;del&gt;LC_CTYPE&lt;/del&gt; entirely or set it to something with UTF-8 in it.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/so-fancy/diff-so-fancy/issues/364&#34;&gt;https://github.com/so-fancy/diff-so-fancy/issues/364&lt;/a&gt;. #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;** AutoCRLF&lt;/p&gt; &#xA;&lt;p&gt;[[https://help.github.com/en/github/using-git/configuring-git-to-handle-line-endings][GitHub suggests]] that you should make sure to only use LF (&lt;del&gt;\n&lt;/del&gt;) as a newline character in Git-handled repositories.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Checkout Windows-style, commit Unix-style line endings&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Git will convert LF to CRLF when checking out text files onto your file system. When committing text files, CRLF will be converted to LF. &lt;em&gt;For cross-platform projects&lt;/em&gt;, this is the &lt;em&gt;recommended setting on Windows&lt;/em&gt; (&lt;del&gt;core.autocrlf&lt;/del&gt; is set to &lt;del&gt;true&lt;/del&gt;) because it ensures that your repository can be used on other platforms while retaining CRLF in your working tree.&lt;/p&gt; &lt;p&gt;#+begin_src conf :tangle no # Configure Git to ensure line endings in files you checkout are correct # for Windows. For compatibility, line endings are converted to Unix # style when you commit files. autocrlf = true #+end_src&lt;/p&gt; &lt;p&gt;This /turns all LF back into CRLF when writing out into the working tree/.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Checkout as-is, commit Unix-style line endings&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Git will /not perform any conversion when checking out text files/. When committing text files, CRLF will be converted to LF. &lt;em&gt;For cross-platform projects&lt;/em&gt;, this is the &lt;em&gt;recommended setting on Unix&lt;/em&gt; (&lt;del&gt;core.autocrlf&lt;/del&gt; is set to &lt;del&gt;input&lt;/del&gt;) to prevent CRLF from getting written into the repository.&lt;/p&gt; &lt;p&gt;#+begin_src conf :tangle no # Configure Git to ensure line endings in files you checkout are correct # for Linux and macOS. autocrlf = input #+end_src&lt;/p&gt; &lt;p&gt;When you read files back out of the object database and write them into the working tree, they will still have LF to denote the end of line.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Checkout as-is, commit as-is&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Git will not perform any conversions when checking out or committing text files. Choosing this option is &lt;em&gt;not recommended for cross-platform projects&lt;/em&gt; (&lt;del&gt;core.autocrlf&lt;/del&gt; is set to &lt;del&gt;false&lt;/del&gt;).&lt;/p&gt; &lt;p&gt;#+begin_src conf :tangle no autocrlf = false #+end_src&lt;/p&gt; &lt;p&gt;This is the default, but most people are encouraged to change this immediately.&lt;/p&gt; &lt;p&gt;The result of using &lt;del&gt;false&lt;/del&gt; is that Git doesn&#39;t ever mess with line endings on your file. You can check in files with LF or CRLF or CR or some random mix of those three and Git does not care. This can make diffs harder to read and merges more difficult.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Proxy configuration&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no [http] proxy = &lt;a href=&#34;http://proxy-guest.example.com:8080&#34;&gt;http://proxy-guest.example.com:8080&lt;/a&gt; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no [alias] # Proxy. set-proxy = !git config --global http.proxy &lt;a href=&#34;http://proxy-guest.example.com:8080&#34;&gt;http://proxy-guest.example.com:8080&lt;/a&gt; &lt;br&gt; &amp;amp;&amp;amp; git config --global https.proxy &lt;a href=&#34;https://proxy-guest.example.com:8080&#34;&gt;https://proxy-guest.example.com:8080&lt;/a&gt; rmv-proxy = !git config --global --unset http.proxy &lt;br&gt; &amp;amp;&amp;amp; git config --global --unset https.proxy #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;XXX Global options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Core&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [core] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Performance:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Do filesystem operations in parallel to hide latency (default since v2.1). preloadindex = true #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Enable file system caching.&lt;/em&gt; File system data will be read in bulk and cached in memory for certain operations. This provides a significant performance boost.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Enable file system caching. Also, fix UAC issues so you don&#39;t need to run # Git as administrator (default since v2.8). fscache = true #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Clean up reflog?&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [gc] # Minimize the number of files in .git/. auto = 256 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Help&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [help] autocorrect = 1 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Log&lt;/p&gt; &#xA;&lt;p&gt;Get a better date format; for example:&lt;/p&gt; &#xA;&lt;p&gt;: 2021-12-03&lt;/p&gt; &#xA;&lt;p&gt;instead of:&lt;/p&gt; &#xA;&lt;p&gt;: Fri Dec 3 14:26:38 2021 +0100&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [log] date = short #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Print out the ref names (tags or branches) of any commits that are shown.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf decorate = short #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Diff&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [diff] renames = copies renameLimit = 30000 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Using the patience diff algorithm to compare large swathes of repetitive text (hello, xml!) often produces a much more readable diff that will reveal context and therefore hopefully bugs/typos etc.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a quick snippet of a diff to show it helping. Bare LCS-based diff:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src diff :tangle no def thing1 { something += 1 +} + +def somethingelse {&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;something += 1 }&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;def thing2 { something += 2 } #+end_src&lt;/p&gt; &#xA;&lt;p&gt;With &lt;del&gt;patience&lt;/del&gt; becomes:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src diff :tangle no def thing1 { something += 1 }&lt;/p&gt; &#xA;&lt;p&gt;+def somethingelse {&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;something += 1 +}&lt;/li&gt; &#xA; &lt;li&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;def thing2 { something += 2 } #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Same end result but much easier to read.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf algorithm = patience #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Git diff will use &lt;del&gt;(i)ndex&lt;/del&gt;, &lt;del&gt;(w)ork tree&lt;/del&gt;, &lt;del&gt;(c)ommit&lt;/del&gt; and &lt;del&gt;(o)bject&lt;/del&gt; instead of &lt;del&gt;a&lt;/del&gt; / &lt;del&gt;b&lt;/del&gt; / &lt;del&gt;c&lt;/del&gt; / &lt;del&gt;d&lt;/del&gt; as prefixes for patches:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf mnemonicprefix = true #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf noprefix = true #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf colorMoved = dimmed_zebra #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Apply&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [apply] # Don&#39;t detect whitespace errors when applying a patch. whitespace = nowarn #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Status&lt;/p&gt; &#xA;&lt;p&gt;If you are using submodules, it might be useful to turn on the submodule summary.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [status] submoduleSummary = true #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Pull&lt;/p&gt; &#xA;&lt;p&gt;Git pull allows you to integrate with and fetch from another repository or local Git branch.&lt;/p&gt; &#xA;&lt;p&gt;Choose the default behavior of &lt;del&gt;git pull&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Fast-forward if possible (or merge)&lt;/em&gt;&lt;/p&gt; &lt;p&gt;This is the &lt;em&gt;default&lt;/em&gt; behavior of &lt;del&gt;git pull&lt;/del&gt;: fast-forward the current branch to the fetched branch when possible, otherwise create a merge commit.&lt;/p&gt; &lt;p&gt;#+begin_src conf :tangle no [pull] rebase = merges #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Fast-forward only&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Fast-forward to the fetched branch. Fail if that is not possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Rebase&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Rebase the current branch onto the fetched branch.&lt;/p&gt; &lt;p&gt;#+begin_src conf :tangle no [pull] rebase = true #+end_src&lt;/p&gt; &lt;p&gt;If there are no local commits to rebase, this is equivalent to a fast-forward.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;rebase with auto-abort : git rebase foo || git rebase --abort&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://www.gitkraken.com/learn/git/problems/git-pull-rebase&#34;&gt;https://www.gitkraken.com/learn/git/problems/git-pull-rebase&lt;/a&gt;!!!&lt;/p&gt; &#xA;&lt;p&gt;At this point, let us remind you of [[https://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Perils-of-Rebasing][the perils of rebasing]].&lt;/p&gt; &#xA;&lt;p&gt;** Push&lt;/p&gt; &#xA;&lt;p&gt;Push &lt;em&gt;only&lt;/em&gt; the &lt;em&gt;current working branch&lt;/em&gt; (sane pushing -- instead of pushing all branches), with an added safety: only if it is /tracking/ a remote upstream branch with the /same name/.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [push] default = simple #+end_src&lt;/p&gt; &#xA;&lt;p&gt;(&lt;del&gt;simple&lt;/del&gt; is the default in Git 2.x)&lt;/p&gt; &#xA;&lt;p&gt;** Merge&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [merge] stat = true summary = true&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Include summaries of merged commits in newly created merge commit messages.&#xA;log = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Rebase&lt;/p&gt; &#xA;&lt;p&gt;Set &lt;del&gt;rebase.stat = true&lt;/del&gt;, so the &lt;del&gt;diffstat&lt;/del&gt; output is still shown when they pull.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [rebase] stat = true #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Grep&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs/git-grep&#34;&gt;https://git-scm.com/docs/git-grep&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [grep] lineNumber = true&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# # Allow extended regular expressions&#xA;# extendedRegexp = true&#xA;&#xA;fullName = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Color&lt;/p&gt; &#xA;&lt;p&gt;Enable colors in terminal:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [color] ui = auto branch = auto diff = auto status = auto interactive = auto #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Branch&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [color &#34;branch&#34;] current = cyan bold local = green bold remote = red bold upstream = red bold plain = yellow reverse #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Diff&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://git-scm.com/docs/git-config&#34;&gt;http://git-scm.com/docs/git-config&lt;/a&gt; for the &lt;del&gt;slot&lt;/del&gt; list.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [color &#34;diff&#34;] plain = &#34;#888888&#34; meta = 11 frag = magenta bold func = &#34;#cc99cc&#34; old = red bold new = green bold commit = yellow bold whitespace = red reverse #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Diff-so-fancy extension:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [diff-so-fancy] useUnicodeRuler = true&lt;/p&gt; &#xA;&lt;p&gt;[color &#34;diff-highlight&#34;] oldNormal = red bold oldHighlight = red bold 52 newNormal = green bold newHighlight = green bold 22 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Status&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [color &#34;status&#34;] header = normal added = green bold changed = yellow bold untracked = cyan branch = cyan bold nobranch = bold ul blink 12 unmerged = red reverse bold #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;added = modified&lt;/li&gt; &#xA; &lt;li&gt;changed = updated&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Grep&lt;/p&gt; &#xA;&lt;p&gt;The first color given is the foreground; the second is the background.&#34;, e.g &lt;del&gt;match 10 22&lt;/del&gt; -- see &lt;del&gt;man 1 git-config&lt;/del&gt; at &#34;CONFIGURATION FILE&#34; &amp;gt; &#34;Values&#34; &amp;gt; &#34;color&#34;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [color &#34;grep&#34;] context = &#34;#888888&#34; filename = yellow bold function = red linenumber = magenta bold match = green reverse bold matchContext = yellow reverse bold matchSelected = yellow bold blue separator = red bold selected = white #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Format&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [format] pretty = format:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)&amp;lt;%an&amp;gt;%C(reset)&lt;/p&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj&#34;&gt;https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;[custom.formats] ls = &#34;[%C(auto,yellow)%&amp;lt;|(10)%h%C(reset)] [%C(auto,bold blue)%&amp;lt;(15trunc)%cn%C(reset)] %C(auto)%d% C(reset)%s&#34; find = &#34;[%C(yellow)%&amp;lt;|(20)%h%C(reset)] [%C(bold blue)%&amp;lt;(10)%cn%C(reset)] %C(auto)%d %C(reset) %s&#34; graph = &#34;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(yellow)%d%C(reset)%n %C(white)%s%C(reset)%n %C(dim white)- %an &amp;lt;%ae&amp;gt; %C(reset) %C(dim white)(committer: %cn &amp;lt;%ce&amp;gt;)%C(reset)&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;See&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://devhints.io/git-log-format&#34;&gt;https://devhints.io/git-log-format&lt;/a&gt; and&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/pretty-formats&#34;&gt;https://git-scm.com/docs/pretty-formats&lt;/a&gt; (XXX)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Aliases&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Aliases are an easy way to create shortcuts for commonly-typed commands, or to set defaults for commands.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [alias] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you forget your aliases and don&#39;t want to open =.gitconfig= just to check, type &lt;del&gt;git alias&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git alias # Print the list of Git aliases. alias = &#34;!git config -l &lt;br&gt; | grep alias &lt;br&gt; | cut -c 7- &lt;br&gt; | sort &lt;br&gt; | sed &#39;s/=/ = /&#39;&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Repository&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For &lt;em&gt;free private repositories&lt;/em&gt;, see &lt;a href=&#34;https://bitbucket.org/&#34;&gt;https://bitbucket.org/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;** Initialize a new repository&lt;/p&gt; &#xA;&lt;p&gt;Set email addresses for you:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf work-profile = config user.email &#34;&lt;a href=&#34;mailto:john@work.com&#34;&gt;john@work.com&lt;/a&gt;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then, in the working copy:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git init-repository # Create a repository. init-repository = !git init &lt;br&gt; &amp;amp;&amp;amp; (ls -1A | grep -q . || touch .gitignore) &lt;br&gt; &amp;amp;&amp;amp; git add . &lt;br&gt; &amp;amp;&amp;amp; git commit -m &#34;Initial commit&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The command is checking whether the output of &lt;del&gt;ls&lt;/del&gt; command is not empty, and if it is, it will create a =.gitignore= file.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_tip Since Git doesn&#39;t add &lt;em&gt;empty directories&lt;/em&gt;, if you want to keep them in the repository, a sort of conventional hack is to create a file called =.gitkeep= in these directories. (The file could be called anything; Git assigns no special significance to this name.) #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;** Drop the revision history for a project&lt;/p&gt; &#xA;&lt;p&gt;If you accidentally put the wrong tree under version control, simply delete the =.git= directory.&lt;/p&gt; &#xA;&lt;p&gt;: find . -name &#39;.git&#39; -exec rm -rf {} ;&lt;/p&gt; &#xA;&lt;p&gt;** Clone an existing repository&lt;/p&gt; &#xA;&lt;p&gt;Clone an existing repository including all submodules.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf cl = clone --recursive #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For &lt;em&gt;passwordless Git pull&lt;/em&gt; (permanently authenticating with Git repositories),&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;em&gt;use SSH&lt;/em&gt; when cloning, and&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;add&lt;/em&gt; your &lt;em&gt;public key&lt;/em&gt; to the remote server.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;*** I&#39;m having an SSH issue&lt;/p&gt; &#xA;&lt;p&gt;The error (when cloning, pulling or pushing)&lt;/p&gt; &#xA;&lt;p&gt;: SSL certificate problem: Unable to get local issuer certificate&lt;/p&gt; &#xA;&lt;p&gt;occurs when a &lt;em&gt;self-signed certificate cannot be verified&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;For a one-time fix, you can use the &lt;del&gt;env&lt;/del&gt; command to create an environment variable of &lt;del&gt;GIT_SSL_NO_VERIFY=TRUE&lt;/del&gt;:&lt;/p&gt; &lt;p&gt;: env GIT_SSL_NO_VERIFY=TRUE git COMMAND ARGUMENTS&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you don&#39;t want to do this all the time, you can disable Git SSL verification:&lt;/p&gt; &lt;p&gt;#+begin_src conf :tangle no [http] sslVerify = false #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_warning Please be advised disabling SSL verification globally &lt;em&gt;might be considered a security risk&lt;/em&gt; and should be implemented only temporary. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;*** Clone to only the latest commit in the repository&#39;s history&lt;/p&gt; &#xA;&lt;p&gt;The &lt;del&gt;--depth 1&lt;/del&gt; option is useful when you only need the latest version of a repository and don&#39;t need the entire history.&lt;/p&gt; &#xA;&lt;p&gt;This can be the case when:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;you&#39;re cloning a large repository and only need the latest code to work with, or&lt;/li&gt; &#xA; &lt;li&gt;you&#39;re cloning a repository for temporary purposes, such as testing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It makes the clone operation faster and lighter.&lt;/p&gt; &#xA;&lt;p&gt;** Create and add your SSH public key to a repository hosting service&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html&#34;&gt;https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;It is best practice to use Git over SSH (instead of Git over HTTP). In order to use SSH, you will need to:&lt;/p&gt; &#xA;&lt;p&gt;*** Create an SSH key pair on your local computer&lt;/p&gt; &#xA;&lt;p&gt;Generate a new ED25519 (should always be favored) SSH key pair:&lt;/p&gt; &#xA;&lt;p&gt;: ssh-keygen -t ed25519 -C &#34;&lt;a href=&#34;mailto:email@example.com&#34;&gt;email@example.com&lt;/a&gt;&#34;&lt;/p&gt; &#xA;&lt;p&gt;Or, if you want to use RSA:&lt;/p&gt; &#xA;&lt;p&gt;: ssh-keygen -t rsa -b 4096 -C &#34;&lt;a href=&#34;mailto:email@example.com&#34;&gt;email@example.com&lt;/a&gt;&#34;&lt;/p&gt; &#xA;&lt;p&gt;*** Add the key to the repository hosting service&lt;/p&gt; &#xA;&lt;p&gt;*** Testing that everything is set up correctly&lt;/p&gt; &#xA;&lt;p&gt;** Remote repo integrations&lt;/p&gt; &#xA;&lt;p&gt;Fetch URL: &lt;a href=&#34;mailto:git@bitbucket.org-something&#34;&gt;git@bitbucket.org-something&lt;/a&gt;:user/slug&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # origin = !echo &#34;${$(git config --get clone.defaultRemoteName):-origin}&#34; origin = !echo &#34;origin&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf repo-owner = &#34;!f() { &lt;br&gt; git remote show $(git origin) -n &lt;br&gt; | grep &#39;Fetch URL:&#39; &lt;br&gt; | sed -E &#39;s#^.&lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fniessen/git-leuven/master/.*&#34;&gt;/:&lt;/a&gt;/.&lt;/em&gt;$#\1#&#39; &lt;br&gt; | sed &#39;s#.git$##&#39;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf repo-slug = &#34;!f() { &lt;br&gt; git remote show $(git origin) -n &lt;br&gt; | grep &#39;Fetch URL:&#39; &lt;br&gt; | sed -E &#39;s#^.&lt;em&gt;/(.&lt;/em&gt;)$#\1#&#39; &lt;br&gt; | sed &#39;s#.git$##&#39;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;h1&gt;Updating git aliases for different &lt;em&gt;default branch&lt;/em&gt; names (&lt;del&gt;master&lt;/del&gt;, &lt;del&gt;main&lt;/del&gt;, etc.):&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;#+begin_src conf&lt;/h1&gt; &#xA;&lt;h1&gt;## git remote show $(git origin) | grep &#34;HEAD branch&#34; | cut -d&#39; &#39; -f5&lt;/h1&gt; &#xA;&lt;h1&gt;default-branch = !git symbolic-ref refs/remotes/$(git origin)/HEAD | sed &#39;s@^refs/remotes/$(git origin)/@@&#39;&lt;/h1&gt; &#xA;&lt;h1&gt;#+end_src&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;This method can return incorrect results...&lt;/h1&gt; &#xA;&lt;p&gt;: git branch | grep -o -m1 &#34;\b(master|main)\b&#34; See &lt;a href=&#34;https://stackoverflow.com/questions/65703168/how-to-get-the-default-for-the-master-branch-in-git&#34;&gt;https://stackoverflow.com/questions/65703168/how-to-get-the-default-for-the-master-branch-in-git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_tip The &lt;del&gt;sed&lt;/del&gt; strings contain &lt;del&gt;$#&lt;/del&gt;, which will be replaced by the number of arguments to the current script/function (generally 0 for an interactive shell). This is part of the basic Bourne shell syntax, so &lt;em&gt;single quotes&lt;/em&gt; will be needed under any &lt;em&gt;Bourne-like shell&lt;/em&gt; (even pre-POSIX ones) on any OS. Read the standard for more information: &lt;a href=&#34;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html&#34;&gt;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html&lt;/a&gt;. #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;*** Create a new repository in GitHub&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Private&lt;/em&gt; or &lt;em&gt;public&lt;/em&gt; repository?&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no create-repository-gh = &#34;!f() { &lt;br&gt; REPO_OWNER=$1; &lt;br&gt; REPO_SLUG=$2; &lt;br&gt; curl -u &#34;$1&#34; &lt;a href=&#34;https://api.github.com/user/repos&#34;&gt;https://api.github.com/user/repos&lt;/a&gt; -d &#34;{&#34;name&#34;:&#34;$2&#34;}&#34;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Download repository&lt;/p&gt; &#xA;&lt;p&gt;Easily launch a temporary one-off Git server from any local repository, to enable a peer-to-peer Git workflow.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git serve # Fire up a builtin local webserver (for browsing and sharing repository over HTTP). serve = &#34;daemon --verbose --export-all --base-path=.git --reuseaddr --strict-paths .git/&#34; serve = &#34;-c daemon.receivepack=true daemon --base-path=. --export-all --reuseaddr --verbose&#34; #+end_src&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;del&gt;git serve&lt;/del&gt;. &#34;Ready to rumble,&#34; it will report. Git is bad-ass.&lt;/li&gt; &#xA; &lt;li&gt;Find out your IP address. Say it&#39;s 192.168.1.123.&lt;/li&gt; &#xA; &lt;li&gt;Say &#34;hey Jane, I&#39;m not ready/able to push these commits up to origin, but you can fetch my commits into your clone by running git fetch git://192.168.1.123/&#34;&lt;/li&gt; &#xA; &lt;li&gt;Press ctrl+c when you don&#39;t want to serve that repo any longer.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Instructions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Start working with your repository.&lt;/p&gt; &#xA;&lt;p&gt;** Create a README&lt;/p&gt; &#xA;&lt;p&gt;Create a =README.md= file into your repository.&lt;/p&gt; &#xA;&lt;p&gt;: echo &#34;# ${$(git repo-slug):-Repository name}\n\nDescription&#34; &amp;gt;&amp;gt; README.md : git add README.md : git commit -m &#34;Add README.md&#34; : : git push -u $(git origin) master&lt;/p&gt; &#xA;&lt;p&gt;** Create a .gitignore&lt;/p&gt; &#xA;&lt;p&gt;You can also create a =.gitignore= file into your repository.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Source Files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Search for files&lt;/p&gt; &#xA;&lt;p&gt;Search files (by file path) in the current branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git search-for-files PATTERN # List files matching the pattern. search-for-files = !git ls-tree -r --name-only HEAD | grep -i --color=auto&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;search-for-files&#39;.&#xA;find-files = !git search-for-files&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Search files in all branches.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf search-for-files-all = &#34;!f() { &lt;br&gt; for BRANCH in $(git for-each-ref --format=&#34;%(refname)&#34; refs/heads); do &lt;br&gt; printf &#34;\n$(tput bold)$BRANCH:$(tput sgr0)\n&#34;; &lt;br&gt; git ls-tree -r --name-only $BRANCH | nl -bn -w3 | grep --color=auto &#34;$1&#34;; &lt;br&gt; done; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;search-for-files-all&#39;.&#xA;find-files-all = !git search-for-files-all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Search for code&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Code search&lt;/em&gt; looks through all lines of code of all the files (by the &lt;em&gt;file contents&lt;/em&gt;) from the current directory (and its subdirectories).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://confluence.atlassian.com/bitbucketserver/search-for-code-in-bitbucket-server-814204781.html&#34;&gt;https://confluence.atlassian.com/bitbucketserver/search-for-code-in-bitbucket-server-814204781.html&lt;/a&gt; &lt;a href=&#34;https://help.github.com/en/github/searching-for-information-on-github/searching-code&#34;&gt;https://help.github.com/en/github/searching-for-information-on-github/searching-code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Search code for exact matches&lt;/p&gt; &#xA;&lt;p&gt;Find all instances of the specified string in code in the repository (or &lt;em&gt;in the specified path&lt;/em&gt;).&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git search-for-code PATTERN [TREE] # Search repository (or the given tree) for lines matching a given pattern. # `-I&#39; = Don&#39;t match the pattern in binary files. search-for-code = &#34;grep -i -I --line-number --break --heading -C 1&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;search-for-code&#39;.&#xA;ack = !git search-for-code&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Find all instances of the specified string in code files &lt;em&gt;with a certain file extension&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf search-for-code-in-extension = &#34;XXX&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Find files that contain multiple terms, not necessarily on the same line&lt;/p&gt; &#xA;&lt;p&gt;Match any of these patterns, but print matches only from files that have /all/ of them (files must have lines that match each of them):&lt;/p&gt; &#xA;&lt;p&gt;: git grep -i -I --line-number --break --heading -C 1 -e REGEXP -e REGEXP --all-match&lt;/p&gt; &#xA;&lt;p&gt;: git grep -i -I --line-number --break --heading -C 1 -e Compares -e solv --all-match does not work in BitBucket!!!???&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://askubuntu.com/questions/1019678/find-multiple-word-patterns-in-files&#34;&gt;https://askubuntu.com/questions/1019678/find-multiple-word-patterns-in-files&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Pattern in current directory (and its subdirectories)&lt;/p&gt; &#xA;&lt;p&gt;The advantages of &lt;del&gt;git grep&lt;/del&gt; are not only its &lt;em&gt;speed&lt;/em&gt;, and the fact it only searches your project files (i.e. no files in =.git=), but also that is allows you to interface with your repository&#39;s Git database; for example, for searching:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;files registered in the index, rather than the working tree,&lt;/li&gt; &#xA; &lt;li&gt;for your regexp in some files from another branch (XXX does not work? XXX).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_note It doesn&#39;t search files that are not revisioned (untracked, excluded/ignored, etc.). #+end_note&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;: git grep &#34;foo&#34; -- &#39;*.java&#39;&lt;/p&gt; &#xA;&lt;p&gt;More readable output, &lt;em&gt;with grouping&lt;/em&gt; (like Ripgrep, &lt;del&gt;rg&lt;/del&gt;, or &lt;del&gt;ack&lt;/del&gt;):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # In all commits, not in all branches!!! Lots of duplicates!!! grep-all = &#34;!f() { &lt;br&gt; git rev-list --all &lt;br&gt; | xargs git grep $1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Print the name of each &lt;em&gt;file with matches&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git gno PATTERN [TREE] # Show only the names of files that contain matches. gno = &#34;grep -i -I --name-only&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Undo local changes&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/&#34;&gt;https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/&lt;/a&gt; and &lt;a href=&#34;http://gitimmersion.com/lab_14.html&#34;&gt;http://gitimmersion.com/lab_14.html&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;*** Before you staged (in unstaged state)&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Undo&lt;/em&gt; the local changes &lt;em&gt;in the working tree&lt;/em&gt;: roll a file back to its last committed version, removing all the changes detected by Git.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_tip It can also recover &lt;em&gt;deleted files&lt;/em&gt; -- if the deletion has not been committed. #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;If you decide that the changes you have made since the last commit ought to be thrown away, the alias to use is &lt;del&gt;unmodify&lt;/del&gt;;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git unmodify TREE_ISH... # Undo local changes in the working copy at or within TREE_ISH. unmodify = checkout -- undelete = checkout -- #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note The two dashes there (&lt;del&gt;--&lt;/del&gt;, canonically called the &#34;bare double dashes&#34; or the /end of options/ character) ensure that the checkout command know that we are trying to roll back a file and not /change branches/ (the typical usage of the checkout command). #+end_note&lt;/p&gt; &#xA;&lt;p&gt;When you grab a file from a previous time, it sits &lt;em&gt;in your index&lt;/em&gt;, modified.&lt;/p&gt; &#xA;&lt;p&gt;*** Before you committed (in staged state)&lt;/p&gt; &#xA;&lt;p&gt;If you accidentally include a file in the next commit (using &lt;del&gt;git add&lt;/del&gt;), you can use the &lt;del&gt;unstage&lt;/del&gt; alias to tell Git to forget about it (remove it from the staging area).&lt;/p&gt; &#xA;&lt;p&gt;: git add foo.html : (oops - didn&#39;t mean that) : git unstage foo.html : (foo.html left on disk, but excluded from the next commit)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git unstage [FILE...] # Undo a &#39;git add&#39; before the next commit. unstage = reset HEAD -- unadd = reset HEAD -- #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;unstage&lt;/del&gt; is the opposite of &lt;del&gt;git add&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;** Selecting files&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf added = &#34;!git status --porcelain -uno | awk &#39;match($1, /A/) {print $2}&#39;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf modified = !git diff --name-only --diff-filter=M #+end_src&lt;/p&gt; &#xA;&lt;p&gt;List untracked &lt;em&gt;files ignored&lt;/em&gt; by a =.gitignore= statement somewhere. This one is a MUST have:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf ignored = ls-files --others --ignored --exclude-standard #+end_src&lt;/p&gt; &#xA;&lt;p&gt;List untracked files.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # List all untracked files. untracked = ls-files --others --exclude-standard #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # List all tracked files. tracked = ls-files -t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git deleted # List files deleted in the working tree. deleted = ls-files -d #+end_src&lt;/p&gt; &#xA;&lt;p&gt;How to restore a deleted file in a Git repository?&lt;/p&gt; &#xA;&lt;p&gt;: git deleted | xargs git checkout --&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # List staged added, modified or deleted files. staged = &#34;!git status --porcelain -uno | grep -P &#39;^[ADM]&#39; | awk &#39;{ print $2 }&#39;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Tell if a file is being tracked&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf is-tracked1 = &#34;!f() { &lt;br&gt; TRACKED=$(git ls-files $1); &lt;br&gt; if [ -z &#34;$TRACKED&#34; ]; then &lt;br&gt; echo &#39;File NOT tracked (or No such file)&#39;; &lt;br&gt; else &lt;br&gt; echo &#39;File tracked&#39;; &lt;br&gt; fi; &lt;br&gt; }; f&#34; is-tracked2 = &#34;!f() { &lt;br&gt; echo -n $1&#39;: &#39;; &lt;br&gt; if [ -f &#34;$1&#34; ]; then &lt;br&gt; TRACKED=$(git ls-files $1); &lt;br&gt; if [ -z &#34;$TRACKED&#34; ]; then &lt;br&gt; echo &#39;File NOT tracked&#39;; &lt;br&gt; else &lt;br&gt; echo &#39;File tracked&#39;; &lt;br&gt; fi; &lt;br&gt; else &lt;br&gt; echo &#39;No such file!&#39;; &lt;br&gt; fi; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;h1&gt;does not work!?&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note &lt;del&gt;[[&lt;/del&gt; has fewer surprises and is generally safer to use. But it is not portable -- it&#39;s a &lt;em&gt;Bashism&lt;/em&gt;, POSIX doesn&#39;t specify what it does.&lt;/p&gt; &#xA;&lt;p&gt;For example, you can do&lt;/p&gt; &#xA;&lt;p&gt;: [[ -e $b ]]&lt;/p&gt; &#xA;&lt;p&gt;to test whether a file exists.&lt;/p&gt; &#xA;&lt;p&gt;But with &lt;del&gt;[&lt;/del&gt;, you have to quote &lt;del&gt;$b&lt;/del&gt;, because it splits the argument and expands things like &lt;del&gt;&#34;a*&#34;&lt;/del&gt; (where &lt;del&gt;[[&lt;/del&gt; takes it literally).&lt;/p&gt; &#xA;&lt;p&gt;: [ -e &#34;$b&#34; ]&lt;/p&gt; &#xA;&lt;p&gt;That has also to do with how &lt;del&gt;[&lt;/del&gt; can be an external program and receives its argument just normally like every other program (although it can also be a builtin, but then it still has not this special handling). #+end_note&lt;/p&gt; &#xA;&lt;p&gt;** Ignoring files&lt;/p&gt; &#xA;&lt;p&gt;*** Add ignore entry to the repository&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ignore exact filename: filename&lt;/li&gt; &#xA; &lt;li&gt;Ignore everything beneath: folder&lt;/li&gt; &#xA; &lt;li&gt;Ignore all files with this extension: pattern&lt;/li&gt; &#xA; &lt;li&gt;Ignore custom pattern: pattern&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no&lt;/p&gt; &#xA;&lt;h1&gt;Add any directories, files, or patterns you don&#39;t want to be tracked by&lt;/h1&gt; &#xA;&lt;h1&gt;version control&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Quickly add a file or directory to =.gitignore=:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf ignore = &#34;!f() { &lt;br&gt; echo &#34;$1&#34; &amp;gt;&amp;gt; &#34;${GIT_PREFIX}.gitignore&#34;; &lt;br&gt; }; f&#34; # ignore=!([ ! -e .gitignore ] &amp;amp;&amp;amp; touch .gitignore) | echo $1 &amp;gt;&amp;gt;.gitignore&lt;/p&gt; &#xA;&lt;h1&gt;XXX What is GIT_PREFIX?&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Ignore all untracked files by appending them to .gitignore:&#xA;ignore-untracked = &#34;!git status \&#xA;            | grep -P \&#34;^\\t\&#34; \&#xA;            | grep -vF .gitignore \&#xA;            | sed \&#34;s/^\\t//\&#34; \&#xA;            &amp;gt;&amp;gt; \&#34;${GIT_PREFIX}.gitignore\&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note that adding the .gitignore and the file specification will have no effect on files that are already being tracked.&lt;/em&gt; If you&#39;re already tracking these, you&#39;ll have to stop tracking them. (Right-click on the folder or file and select Stop Tracking.) You&#39;ll then see them change from having a green/clean or amber/changed icon to a red/removed icon. On your next commit the files will be removed from the repository and thereafter appear with a blue/ignored icon. Another contributor asked why Ignore was disabled for particular files and I believe it was because he was trying to ignore a file that was already being tracked. You can only ignore a file that has a blue question mark icon.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Fix .gitignore. fix-gitignore = !git rm -r --cached . &lt;br&gt; &amp;amp;&amp;amp; git add . &lt;br&gt; &amp;amp;&amp;amp; git commit -m &#34;Fix .gitignore&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** &lt;del&gt;assume-unchanged&lt;/del&gt; command&lt;/p&gt; &#xA;&lt;p&gt;Ignore/unignore changes to &lt;em&gt;tracked file(s)&lt;/em&gt; without =.gitignore=:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Ignore files only locally. skip = update-index --assume-unchanged unskip = update-index --no-assume-unchanged #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX Have a look at Git lock = skip-worktree&lt;/p&gt; &#xA;&lt;p&gt;It has to be configured for each project member individually.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning As stated in [[http://stackoverflow.com/questions/23097368/git-ignore-vs-exclude-vs-assume-unchanged][git ignore vs. exclude vs. assume-unchanged]], &lt;del&gt;git-update-index --assume-unchanged&lt;/del&gt; was never meant to ignore changes to tracked files (&lt;em&gt;only to spare some stats&lt;/em&gt;). So do not suggest it as a means to achieve that. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;Skip all:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf skip-all = &#34;!git status -s &lt;br&gt; | awk {&#39;print $2&#39;} &lt;br&gt; | xargs git skip&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Unskip all the skipped files:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf unskip-all = &#34;!git skipped &lt;br&gt; | xargs git update-index --no-assume-unchanged&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;List ignored files (&lt;em&gt;marked unchanged&lt;/em&gt;):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf skipped = &#34;!git ls-files -v &lt;br&gt; | grep &#39;^h&#39; &lt;br&gt; | cut -c 3-&#34; skipped2-BAD-MAYBE = !git ls-files -v &lt;br&gt; | grep &#39;^[a-z]&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Clean&lt;/p&gt; &#xA;&lt;p&gt;*** Delete all untracked files&lt;/p&gt; &#xA;&lt;p&gt;To delete all files (and directories) unknown to Git, you can run &lt;del&gt;git clean-tree-unknown&lt;/del&gt;. Only unknown files, not ignored files, are deleted.&lt;/p&gt; &#xA;&lt;p&gt;It won&#39;t remove staged changes, like modified files still uncommitted.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git clean-tree-unknown # Delete (only) untracked files and directories. clean-tree-unknown = clean -d -f # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED. # Files and directories in .gitignore will be preserved.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias to git clean-tree-unknown.&#xA;purge = !git clean-tree-unknown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;WARNING -- BE CAREFUL WITH THIS!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;To check what &lt;del&gt;git clean-tree-unknown&lt;/del&gt; will delete, and be sure it&#39;s what you want, use &lt;del&gt;git clean-tree-unknown-dry-run&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git clean-tree-unknown-dry-run # Show files to delete instead of deleting them. clean-tree-unknown-dry-run = clean -d -n&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias to clean-tree-unknown-dry-run.&#xA;purge-dry-run = !git clean-tree-unknown-dry-run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you want to save your current branch&#39;s state before doing this (just in case), you can do:&lt;/p&gt; &#xA;&lt;p&gt;: git commit -a -m &#34;Saving my work, just in case&#34; : git branch my-saved-work&lt;/p&gt; &#xA;&lt;p&gt;*** Delete all untracked files and also ignored files&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;PLAY WITH FIRE VERSION&lt;/em&gt; which will wipe out all the &lt;em&gt;ignored and untracked&lt;/em&gt; files and directories:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git clean-tree-unknown-ignored # Delete untracked files (and directories), and also ignored files. clean-tree-unknown-ignored = clean -d -f -x # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED, # including those in .gitignore.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias to clean-tree-unknown-ignored.&#xA;purge-all = !git clean-tree-unknown-ignored&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note &lt;del&gt;git clean&lt;/del&gt; will &lt;em&gt;remove any files&lt;/em&gt; from the tracked root directory &lt;em&gt;that are not under Git tracking&lt;/em&gt; (whereas &lt;del&gt;git reset --hard&lt;/del&gt; will /not remove untracked files/). #+end_note&lt;/p&gt; &#xA;&lt;p&gt;To check what &lt;del&gt;git clean-tree-unknown-ignored&lt;/del&gt; will delete, and be sure it&#39;s what you want, use &lt;del&gt;git clean-tree-unknown-ignored-dry-run&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git clean-tree-unknown-ignored-dry-run # Show files to delete instead of deleting them. clean-tree-unknown-ignored-dry-run = clean -d -n -x&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias to clean-tree-unknown-ignored-dry-run.&#xA;purge-all-dry-run = !git clean-tree-unknown-ignored-dry-run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Delete only ignored files&lt;/p&gt; &#xA;&lt;p&gt;Remove (only) ignored files that are still on the repository:&lt;/p&gt; &#xA;&lt;p&gt;: git ignored | xargs rm&lt;/p&gt; &#xA;&lt;p&gt;*** Hg shelve untracked files&lt;/p&gt; &#xA;&lt;p&gt;*** Hg ignore untracked files&lt;/p&gt; &#xA;&lt;p&gt;*** Hg remove untracked files&lt;/p&gt; &#xA;&lt;p&gt;*** Forget all missing files&lt;/p&gt; &#xA;&lt;p&gt;forget = select files that have been deleted &lt;a href=&#34;https://stackoverflow.com/questions/2412239/how-to-do-mercurials-hg-remove-for-all-missing-files&#34;&gt;https://stackoverflow.com/questions/2412239/how-to-do-mercurials-hg-remove-for-all-missing-files&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;remove files which have been deleted &lt;a href=&#34;https://www.commandlinefu.com/commands/view/3502/git-remove-files-which-have-been-deleted&#34;&gt;https://www.commandlinefu.com/commands/view/3502/git-remove-files-which-have-been-deleted&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;stage manually deleted files : git status | grep deleted | sed &#39;s/deleted://g&#39; | sed &#39;s/[#| ]//g&#39; | xargs git rm&lt;/p&gt; &#xA;&lt;p&gt;** Stash (shelve)&lt;/p&gt; &#xA;&lt;p&gt;Temporarily set aside some changes from the current tree.&lt;/p&gt; &#xA;&lt;p&gt;Shelve allows you to temporarily put changes you&#39;ve made &#34;on the shelf&#34;, ie. out of the way, until a later time when you can bring them back from the shelf with the `unshelve&#39; command. The changes are stored alongside your working tree, and so they aren&#39;t propagated along with your branch nor will they survive its deletion.&lt;/p&gt; &#xA;&lt;p&gt;If shelve -list is specified, previously-shelved changes are listed.&lt;/p&gt; &#xA;&lt;p&gt;Shelve is intended to help separate several sets of changes that have been inappropriately mingled. If you just want to get rid of all changes and you don&#39;t need to restore them later, use revert. If you want to shelve all text changes at once, use shelve -all.&lt;/p&gt; &#xA;&lt;p&gt;If filenames are specified, only the changes to those files will be shelved. Other files will be left untouched.&lt;/p&gt; &#xA;&lt;p&gt;If a revision is specified, changes since that revision will be shelved.&lt;/p&gt; &#xA;&lt;p&gt;You can put multiple items on the shelf, and by default, `unshelve&#39; will restore the most recently shelved changes.&lt;/p&gt; &#xA;&lt;p&gt;bzr unshelve [SHELF_ID] Restore shelved changes.&lt;/p&gt; &#xA;&lt;p&gt;--apply Apply changes and remove from the shelf.&lt;/p&gt; &#xA;&lt;p&gt;--delete-only Delete changes without applying them.&lt;/p&gt; &#xA;&lt;p&gt;--dry-run Show changes, but do not apply or remove them.&lt;/p&gt; &#xA;&lt;p&gt;--keep Apply changes but don&#39;t delete them.&lt;/p&gt; &#xA;&lt;p&gt;--preview Instead of unshelving the changes, show the diff that would result from unshelving.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://fossil-scm.org/home/help?cmd=stash&#34;&gt;https://fossil-scm.org/home/help?cmd=stash&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A &lt;em&gt;stash&lt;/em&gt; is nothing but a &lt;em&gt;(temporary) branch&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;git stash&lt;/del&gt; makes a temporary copy of the changes in your &lt;em&gt;index&lt;/em&gt; (staging area) and &lt;em&gt;working tree&lt;/em&gt;, and clears the decks so you can easily work on something else; it reverts your local modifications, allowing you to get rid of some incomplete changes.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_tip Use &lt;del&gt;git stash&lt;/del&gt; if Git refused to merge because it foresees conflicts. #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;If you anticipate that you might have trouble merging the work you want to stash with the work you&#39;re about to do on the clean tree, you can create a new branch with &lt;del&gt;git stash branch NEW_BRANCH_NAME&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Information that is used by default if you don&#39;t provide a message:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example stash@{0}: WIP on BRANCH: SHA_1_OF_HEAD TITLE_LINE_OF_HEAD #+end_example&lt;/p&gt; &#xA;&lt;p&gt;You can operate on the &#34;stash&#34; ref as if it were any other ref.&lt;/p&gt; &#xA;&lt;p&gt;*** Stash push&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;git stash push&lt;/del&gt; also optionally takes a message describing the contents of the stash (much, much more useful):&lt;/p&gt; &#xA;&lt;p&gt;: git stash push -m &#34;Describe what you did here&#34;&lt;/p&gt; &#xA;&lt;p&gt;: stash@{0}: On BRANCH: Describe what you did here&lt;/p&gt; &#xA;&lt;p&gt;This command is useful in saving all changes not ready to be committed and the user wants to have an updated repository.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf stash-push = stash push #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Pop stash off with name like text. stash-pop = &#34;!f() { &lt;br&gt; git stash pop stash@{$(git stash-id $@)}; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Only accepts single word, no quotations.&#xA;stash-id = &#34;!f() { \&#xA;        git stash list \&#xA;            | grep $@ \&#xA;            | head -n 1 \&#xA;            | sed -n &#39;s/stash@{\\(.*\\)}.*/\\1/p&#39;; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # &#34;Add&#34; modified files, deleted files, and new untracked files. stash-all = !git add -A &lt;br&gt; &amp;amp;&amp;amp; git stash #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Hide all files, including untracked files (faster than using --all). hide = stash push --include-untracked #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Take named stash&lt;/p&gt; &#xA;&lt;p&gt;&#34;WIP:&#34;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf snapshot = !git stash push -m &#34;snapshot-$(date +%Y%m%d_%H%M)&#34; &lt;br&gt; &amp;amp;&amp;amp; git stash apply &#34;stash@{0}&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # checkpoint checkpoint = !git stash push -m &#34;$(date +%F--%T)&#34; &lt;br&gt; &amp;amp;&amp;amp; git stash pop --index&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# checkpoint recover&#xA;checkpoint-recover = &#34;!f() { \&#xA;        git fsck \&#xA;            | grep commit \&#xA;            | cut -d&#39; &#39; -f3 \&#xA;            | while read HASH; do \&#xA;                  git rev-parse --verify --no-revs --quiet $HASH^2 2&amp;gt;/dev/null \&#xA;                      &amp;amp;&amp;amp; echo $HASH \&#xA;                      | xargs git rev-list --since=${1:-1day} -1; \&#xA;              done \&#xA;            | xargs -L 1 git log -1 --format=%at:%h \&#xA;            | sort \&#xA;            | cut -f2 -d: \&#xA;            | xargs -L 1 git log -3 --format=&#39;%Cblue%h %Cgreen(%ar) %Creset%s&#39; --graph; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Show a list of all stashes&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf stashes = stash list --date=short #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Show the stash&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git unstash-preview # Instead of unshelving the changes, show the diff that would result from # unshelving. unstash-preview = stash show -p #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git&#34;&gt;https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Show only stash with name like text. stash-show = &#34;!f() { &lt;br&gt; git stash show stash^{/$@} -p; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stash-show = &#34;!f() { \&#xA;        git stash show stash^{/$*} -p; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;One very useful feature one may consider is to list contents of all local stashes:&lt;/p&gt; &#xA;&lt;p&gt;: git stashes | awk -F: &#39;{ print &#34;\n\n\n\n&#34;; &lt;br&gt; : print $0; &lt;br&gt; : print &#34;\n\n&#34;; &lt;br&gt; : system(&#34;git stash show -p &#34; $1); }&#39;&lt;/p&gt; &#xA;&lt;p&gt;Press [Q] to exit each stash.&lt;/p&gt; &#xA;&lt;p&gt;It helped me a lot in the past (cleaning stashes stack).&lt;/p&gt; &#xA;&lt;p&gt;*** Show name-only&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf stash-shno = stash show --name-only #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Apply the stash only, don&#39;t delete it from the stash list&lt;/p&gt; &#xA;&lt;p&gt;When you&#39;re done, with &lt;del&gt;git stash apply&lt;/del&gt; (top stash by default), you&#39;re back where you were. But if that doesn&#39;t work, for whatever reason, you can use any of Git&#39;s other branch merging tools to put things back they way you want them.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git unstash-keep [STASH_ID] # Apply changes but don&#39;t delete them. unstash-keep = stash apply #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git&#34;&gt;https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Find stash with name like text. stash-apply = &#34;!f() { &lt;br&gt; git stash apply stash^{/$@}; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stash-apply = &#34;!f() { \&#xA;        git stash apply stash^{/$*}; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf stash-unapply = !git stash show -p --no-textconv --binary &lt;br&gt; | git apply -R #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Restore shelved changes&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;git unstash&lt;/del&gt; removes the most recent stash or any stash specified and applies changes as a merge. If merge fails, the stash is not removed from the list and must be removed manually.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git unstash [STASH_ID] # Apply changes and remove them from the shelf. unstash = stash pop #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning Be aware that, unlike &lt;del&gt;git stash apply&lt;/del&gt; (though it has its use), &lt;del&gt;git unstash&lt;/del&gt; &lt;em&gt;deletes the applied stash&lt;/em&gt; -- /only/ if the stash is cleanly applied. If there are conflicts, Git will not remove it (but it will still apply it)! #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;*** Drop the stash&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git unstash-delete-only [STASH_ID] # Delete changes without applying them. unstash-delete-only = stash drop #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Clear&lt;/p&gt; &#xA;&lt;p&gt;: git stash clear&lt;/p&gt; &#xA;&lt;p&gt;*** Workflows&lt;/p&gt; &#xA;&lt;p&gt;Alternative to &lt;del&gt;stash&lt;/del&gt; (writing a commit with a default message):&lt;/p&gt; &#xA;&lt;p&gt;XXX See doc of git help stash for workflows...&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Do a regular &lt;del&gt;commit&lt;/del&gt;:&lt;/p&gt; &lt;p&gt;: git add -A &amp;amp;&amp;amp; git commit -m &#39;WIP&#39; # Add all changes (including untracked files).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Do some other work...&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Return to previous work:&lt;/p&gt; &lt;p&gt;: git reset --mixed # Reset the previous commit (but : # keeps all the changes from that : # commit in the working tree). : : git reset --soft # Or this one???&lt;/p&gt; &lt;p&gt;Or, if I merely need to modify the &lt;em&gt;previous&lt;/em&gt; commit:&lt;/p&gt; &lt;p&gt;: git commit -a --amend&lt;/p&gt; &lt;p&gt;The &lt;del&gt;-a&lt;/del&gt; &lt;em&gt;adds any modifications and deletions of existing files&lt;/em&gt; to the commit but ignores brand new files.&lt;/p&gt; &lt;p&gt;The &lt;del&gt;--amend&lt;/del&gt; launches your default commit editor and lets you change the commit message of the &lt;em&gt;most recent&lt;/em&gt; commit.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;*** From git help stash&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   Pulling into a dirty tree&#xA;&#xA;       When you are in the middle of something, you learn that there are&#xA;       upstream changes that are possibly relevant to what you are&#xA;       doing. When your local changes do not conflict with the changes in&#xA;       the upstream, a simple git pull will let you move forward.&#xA;&#xA;       However, there are cases in which your local changes do conflict with&#xA;       the upstream changes, and git pull refuses to overwrite your&#xA;       changes. In such a case, you can stash your changes away, perform&#xA;       a pull, and then unstash, like this:&#xA;&#xA;           $ git pull&#xA;            ...&#xA;           file foobar not up to date, cannot merge.&#xA;           $ git stash&#xA;           $ git pull&#xA;           $ git stash pop&#xA;&#xA;   Interrupted workflow&#xA;&#xA;       When you are in the middle of something, your boss comes in and&#xA;       demands that you fix something immediately. Traditionally, you would&#xA;       make a commit to a temporary branch to store your changes away, and&#xA;       return to your original branch to make the emergency fix, like this:&#xA;&#xA;           # ... hack hack hack ...&#xA;           $ git create-branch my_wip&#xA;           $ git commit -a -m &#34;WIP&#34;&#xA;           $ git checkout master&#xA;           $ edit emergency fix&#xA;           $ git commit -a -m &#34;Fix in a hurry&#34;&#xA;           $ git checkout my_wip&#xA;           $ git reset --soft HEAD~&#xA;           # ... continue hacking ...&#xA;&#xA;       You can use git stash to simplify the above, like this:&#xA;&#xA;           # ... hack hack hack ...&#xA;           $ git stash&#xA;           $ edit emergency fix&#xA;           $ git commit -a -m &#34;Fix in a hurry&#34;&#xA;           $ git stash pop&#xA;           # ... continue hacking ...&#xA;&#xA;   Testing partial commits&#xA;&#xA;       You can use git stash push --keep-index when you want to make two or&#xA;       more commits out of the changes in the work tree, and you want to&#xA;       test each change before committing:&#xA;&#xA;           # ... hack hack hack ...&#xA;           $ git add --patch foo            # add just first part to the index&#xA;           $ git stash push --keep-index    # save all other changes to the stash&#xA;           $ edit/build/test first part&#xA;           $ git commit -m &#39;First part&#39;     # commit fully tested change&#xA;           $ git stash pop                  # prepare to work on all other changes&#xA;           # ... repeat above five steps until one commit remains ...&#xA;           $ edit/build/test remaining parts&#xA;           $ git commit foo -m &#39;Remaining parts&#39;&#xA;&#xA;   Recovering stashes that were cleared/dropped erroneously&#xA;&#xA;       If you mistakenly drop or clear stashes, they cannot be recovered&#xA;       through the normal safety mechanisms. However, you can try the&#xA;       following incantation to get a list of stashes that are still in your&#xA;       repository, but not reachable any more:&#xA;&#xA;           git fsck --unreachable |&#xA;           grep commit | cut -d\  -f3 |&#xA;           xargs git log --merges --no-walk --grep=WIP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Commits&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Create a commit&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Shortcut for commit. ci = commit #+end_src&lt;/p&gt; &#xA;&lt;p&gt;A guide on commit messages: &lt;a href=&#34;https://dev.to/yvonnickfrin/a-guide-on-commit-messages-d8n&#34;&gt;https://dev.to/yvonnickfrin/a-guide-on-commit-messages-d8n&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A useful template for good commit messages (see &lt;a href=&#34;https://medium.com/compass-true-north/writing-good-commit-messages-fc33af9d6321&#34;&gt;https://medium.com/compass-true-north/writing-good-commit-messages-fc33af9d6321&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;p&gt;Implementing a Strong Code-Review Culture &lt;a href=&#34;https://www.youtube.com/watch?v=PJjmw9TRB7s&#34;&gt;https://www.youtube.com/watch?v=PJjmw9TRB7s&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src text :tangle .git_commit_template.txt&lt;/p&gt; &#xA;&lt;h1&gt;|&amp;lt;------ 50-character subject line -------&amp;gt;|&amp;lt;-------------------&amp;gt;|&lt;/h1&gt; &#xA;&lt;h1&gt;If applied, this commit will...&lt;/h1&gt; &#xA;&lt;h1&gt;[Add / Fix / Remove / Update / Refactor / Document] [summary]&lt;/h1&gt; &#xA;&lt;h1&gt;|&amp;lt;----- Optional 72-character wrapped extended description -----&amp;gt;|&lt;/h1&gt; &#xA;&lt;h1&gt;This should answer:&lt;/h1&gt; &#xA;&lt;h1&gt;- Why is this change necessary? (goals, use cases, stories, etc.?)&lt;/h1&gt; &#xA;&lt;h1&gt;- How does this change address the issue? (implementations, algorithms, etc.?)&lt;/h1&gt; &#xA;&lt;h1&gt;- What side effects does this change have?&lt;/h1&gt; &#xA;&lt;h1&gt;Include a link to the ticket, if any.&lt;/h1&gt; &#xA;&lt;h1&gt;Closes #ISSUE_NUMBER&lt;/h1&gt; &#xA;&lt;h1&gt;--- COMMIT END ---&lt;/h1&gt; &#xA;&lt;h1&gt;Emoji can be&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;span&gt;&lt;/span&gt; Add new feature ...&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;span&gt;&lt;/span&gt; Fix bug ...&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;span&gt;&lt;/span&gt; Remove ...&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;span&gt;&lt;/span&gt; Update ...&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;span&gt;&lt;/span&gt; Refactor code ...&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://dev.to/sublimegeek/semantic-commit-messages-with-emojis-3p8h&#34;&gt;https://dev.to/sublimegeek/semantic-commit-messages-with-emojis-3p8h&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://gist.github.com/rxaviers/7360908&#34;&gt;https://gist.github.com/rxaviers/7360908&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://www.webfx.com/tools/emoji-cheat-sheet/&#34;&gt;https://www.webfx.com/tools/emoji-cheat-sheet/&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://gist.github.com/zakkak/7e06725ebd1336bfebebe254de3de825&#34;&gt;https://gist.github.com/zakkak/7e06725ebd1336bfebebe254de3de825&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://help.github.com/en/github/managing-your-work-on-github/closing-issues-using-keywords&#34;&gt;https://help.github.com/en/github/managing-your-work-on-github/closing-issues-using-keywords&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://confluence.atlassian.com/bitbucket/resolve-issues-automatically-when-users-push-code-221451126.html&#34;&gt;https://confluence.atlassian.com/bitbucket/resolve-issues-automatically-when-users-push-code-221451126.html&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://docs.gitlab.com/ee/user/project/issues/managing_issues.html#default-closing-pattern&#34;&gt;https://docs.gitlab.com/ee/user/project/issues/managing_issues.html#default-closing-pattern&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;and you&#39;ll be guided into writing concise commit subjects in the imperative mood -- a good practice. See rule 5 of Chris Beam&#39;s &#34;How to write a commit message&#34; for the inspiration of this tip and more reasoning on the use of the imperative mood.&lt;/p&gt; &#xA;&lt;p&gt;You can automatically &lt;em&gt;close an issue&lt;/em&gt; by using a supported keyword in commit message, such as &lt;del&gt;Closes #10&lt;/del&gt;. (You should always include the &lt;del&gt;#&lt;/del&gt; if you want to ensure that links back to the issue resolve.)&lt;/p&gt; &#xA;&lt;p&gt;For a list of supported keywords, see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.github.com/en/free-pro-team@latest/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword&#34;&gt;https://docs.github.com/en/free-pro-team@latest/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://support.atlassian.com/bitbucket-cloud/docs/resolve-issues-automatically-when-users-push-code/&#34;&gt;https://support.atlassian.com/bitbucket-cloud/docs/resolve-issues-automatically-when-users-push-code/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://gitlab.com/emacs-stuff/git-commit-insert-issue&#34;&gt;https://gitlab.com/emacs-stuff/git-commit-insert-issue&lt;/a&gt; for better Emacs support.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [commit] template = ~/.git_commit_template.txt #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This is a handy table for labels [[https://github.com/angular/angular/blob/master/CONTRIBUTING.md][Angular&#39;s commit standards and guidelines]]:&lt;/p&gt; &#xA;&lt;p&gt;| Label | Description | |----------+--------------------------------------------------------------------------------------------------------| | feat | A new feature | | fix | A bug fix | | style | Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) | | refactor | A code change that neither fixes a bug nor adds a feature | | perf | A code change that improves performance | | test | Adding missing or correcting existing tests | | chore | Changes to the build process or auxiliary tools and libraries such as documentation generation | | doc | Documentation only changes |&lt;/p&gt; &#xA;&lt;p&gt;** Get a commit hash&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf [alias]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Usage: git commit-hash [COMMIT_ISH]&#xA;# Examples:&#xA;#   git commit-hash               find hash of last commit&#xA;#   git commit-hash develop       find hash of last commit in develop&#xA;commit-hash = log -1 --pretty=format:&#39;%h&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Get a commit detail&lt;/p&gt; &#xA;&lt;p&gt;List all the changed files &lt;em&gt;in a commit&lt;/em&gt; (also in a /merge commit/):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git changed-files [COMMIT] # Examples: # git changed-files list files modified in last commit # git changed-files bada55 list files modified in this commit changed-files = show --pretty=&#34;format:&#34; --name-only -m #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Get the diff of a commit&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf download-email-patch = XXX git format-patch $(git current-branch).patch download-plain-diff = &#34;!f() { &lt;br&gt; git diff ${1:-HEAD}~ ${1:-HEAD} &amp;gt; ${1:-HEAD}.diff; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Diff&lt;/p&gt; &#xA;&lt;p&gt;Use a generic rev syntax (rev-parse) to transparently allow complex rev expressions.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf showtool = &#34;!f() { &lt;br&gt; REV=$(git rev-parse &#34;${*:-HEAD}&#34;); &lt;br&gt; git difftool $REV~1 $REV; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This allows doing nice things like:&lt;/p&gt; &#xA;&lt;p&gt;: git showtool :/some nasty bug&lt;/p&gt; &#xA;&lt;p&gt;Diff the last commit for a given file:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf diff-file-last-commit = &#34;!f() { &lt;br&gt; PROJECT_ROOT_DIR=$(git root); &lt;br&gt; echo finding full file path of $1 in $PROJECT_ROOT_DIR; &lt;br&gt; FILEPATH=$(find $PROJECT_ROOT_DIR -type f -name $1); &lt;br&gt; echo full file path $FILEPATH; &lt;br&gt; LAST_MODIFIED_COMMIT_HASH=$(git rev-list -1 HEAD $FILEPATH); &lt;br&gt; echo last commit file modified $LAST_MODIFIED_COMMIT_HASH; &lt;br&gt; git difftool $LAST_MODIFIED_COMMIT_HASH^ $FILEPATH; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Usage (no matter where you are in the repo):&lt;/p&gt; &#xA;&lt;p&gt;: git diff-file-last-commit File.cpp&lt;/p&gt; &#xA;&lt;p&gt;This opens your configured &lt;del&gt;difftool&lt;/del&gt; with the changes to =File.cpp= in the last commit it was touched.&lt;/p&gt; &#xA;&lt;p&gt;*** Performing directory diffs (Comparing folders)&lt;/p&gt; &#xA;&lt;p&gt;The following command makes it similar to the =git-meld.pl= script here: &lt;a href=&#34;https://github.com/wmanley/git-meld&#34;&gt;https://github.com/wmanley/git-meld&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf diffall = difftool -t meld --dir-diff #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Get the references the commit has been pushed to (which branches and tags?)&lt;/p&gt; &#xA;&lt;p&gt;List all the &lt;em&gt;branches and tags&lt;/em&gt; that contain a specific commit.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git where REV # Print only refs which contain the commit. where = for-each-ref --format=&#39;%(refname)&#39; --contains where2 = &#34;!f() { &lt;br&gt; git for-each-ref --format=&#39;%(committerdate:iso) %09 %(authorname) %09 %(refname:short)&#39; --contains $1 &lt;br&gt; | sort -r; &lt;br&gt; }; f&#34; where3 = for-each-ref --format=&#34;%(refname:short)&#34; --points-at HEAD refs/heads #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Filter the list of &lt;em&gt;branches&lt;/em&gt; to only those which have the given &lt;em&gt;commit ID&lt;/em&gt; among their ancestors.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Find branches containing commit. branches-that-contain = branch -a --contains #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This also includes &lt;em&gt;remote tracking branches&lt;/em&gt; in the list, that is &#34;local branches that have a direct relationship to a remote branch&#34;.&lt;/p&gt; &#xA;&lt;p&gt;List all &lt;em&gt;tags&lt;/em&gt; that contain a specific commit ID:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Find tags containing commit. tags-that-contain = &#34;!f() { &lt;br&gt; git tag -l --contains $1 &lt;br&gt; | sort -r; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Check if one commit is an ancestor of another&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src sh :tangle bin/git-is-ancestor :noweb yes #!/usr/bin/env bash&lt;/p&gt; &#xA;&lt;p&gt;#? git-is-ancestor, Time-stamp: 20221102.1443 #? Copyright (C) 2013-2023 Fabrice Niessen #? #? License GPLv3+: GNU GPL version 3 or later &lt;a href=&#34;http://gnu.org/licenses/gpl.html&#34;&gt;http://gnu.org/licenses/gpl.html&lt;/a&gt;. #? This is free software: you are free to change and redistribute it. #? There is NO WARRANTY, to the extent permitted by law.&lt;/p&gt; &#xA;&lt;p&gt;##? Usage: git-is-ancestor [options] COMMIT_1 COMMIT_2 ##? ##? Check if one commit is an ancestor of another. ##? ##? Arguments: ##? COMMIT_1 commit (or tag) 1 ##? COMMIT_2 commit (or tag) 2 ##? ##? Options: ##? -h, --help display this help and exit ##? -V, --version display version information and exit ##? ##? Example: ##? git-is-ancestor 71031cec HEAD determine if current branch contains the commit&lt;/p&gt; &#xA;&lt;h1&gt;Check if docopts command is available.&lt;/h1&gt; &#xA;&lt;p&gt;command -v docopts &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 || { printf &amp;gt;&amp;amp;2 &#39;Error: docopts command not found.\n&#39;; exit 2; }&lt;/p&gt; &#xA;&lt;p&gt;help=$(grep &#34;^##?&#34; &#34;$0&#34; | cut -c 5-) version=$(grep &#34;^#?&#34; &#34;$0&#34; | cut -c 4-) parsed=&#34;$(docopts -h &#34;$help&#34; -V &#34;$version&#34; : &#34;$@&#34;)&#34; eval &#34;$parsed&#34;&lt;/p&gt; &#xA;&lt;p&gt;if $(git merge-base --is-ancestor $COMMIT_1 $COMMIT_2); then printf &#39;%s is an ancestor of %s\n&#39; &#34;$COMMIT_1&#34; &#34;$COMMIT_2&#34; exit 0 elif $(git merge-base --is-ancestor $COMMIT_2 $COMMIT_1); then printf &#39;%s is an ancestor of %s\n&#39; &#34;$COMMIT_2&#34; &#34;$COMMIT_1&#34; exit 0 else printf &#39;%s and %s are not related\n&#39; &#34;$COMMIT_1&#34; &#34;$COMMIT_2&#34; exit 1 fi #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git is-ancestor COMMIT_1 COMMIT_2 # Check if one commit is an ancestor of another. is-ancestor = !$HOME/bin/git-is-ancestor #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Search for commits&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note Just for the record -- searching anything &#34;in a branch&#34; is not possible due to the principle of branches. Branch is only a pointer to a single commit, which is considered to be &#34;the last commit of the branch&#34;, and commits itself do not &#34;belong to a branch&#34; anyhow else.&lt;/p&gt; &#xA;&lt;p&gt;Therefore, Git cannot determine &#34;which branch was which&#34; before merge commits. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;: curl --request GET --header &#34;PRIVATE-TOKEN: YOUR_ACCESS_TOKEN&#34; &lt;a href=&#34;https://gitlab.example.com/api/v4/search?scope=commits&amp;amp;search=bye&#34;&gt;https://gitlab.example.com/api/v4/search?scope=commits&amp;amp;search=bye&lt;/a&gt; : curl --request GET --header &#34;PRIVATE-TOKEN: YOUR_ACCESS_TOKEN&#34; &lt;a href=&#34;https://gitlab.example.com/api/v4/groups/3/search?scope=issues&amp;amp;search=file&#34;&gt;https://gitlab.example.com/api/v4/groups/3/search?scope=issues&amp;amp;search=file&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Search within Commit Messages&lt;/p&gt; &#xA;&lt;p&gt;You can find commits that contain particular words in the commit message. For example, &lt;del&gt;fix typo&lt;/del&gt; matches commits containing the words &lt;del&gt;fix&lt;/del&gt; &lt;em&gt;and&lt;/em&gt; &lt;del&gt;typo&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to find all commits (&lt;em&gt;across all branches&lt;/em&gt;, showing names and status of changed files) where &lt;em&gt;log message&lt;/em&gt; matches a specified pattern (regular expression), use &lt;del&gt;find&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Error with 2 search strings!!! search-for-commits-all-1 = &#34;log -i --all --grep&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You may want to add history to search through the whole repository, by adding &lt;del&gt;rev-list&lt;/del&gt; to your &lt;del&gt;git log&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Only one search string is read! search-for-commits-all-2 = &#34;!f() { &lt;br&gt; git log --grep &#34;$1&#34; -i $(git rev-list --all); &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;h1&gt;#+begin_tip&lt;/h1&gt; &#xA;&lt;h1&gt;If you only add options to one single &lt;del&gt;git&lt;/del&gt; command, there is no benefit to the&lt;/h1&gt; &#xA;&lt;h1&gt;function wrapper. On the contrary, you can&#39;t add other options.&lt;/h1&gt; &#xA;&lt;h1&gt;#+end_tip&lt;/h1&gt; &#xA;&lt;p&gt;To find commits that match &lt;em&gt;either&lt;/em&gt; of patterns (implicit &lt;em&gt;OR&lt;/em&gt; semantic), you can use:&lt;/p&gt; &#xA;&lt;p&gt;: git log --grep=FOO --grep=BAR&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s the alias which simply loops over each argument and calls &lt;del&gt;git log --grep&lt;/del&gt;. Equivalent of calling &lt;del&gt;git log --grep A --grep B --grep C ...&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git search-for-commits-bitbucket-or PATTERN... # Search for commits (Filter by message). search-for-commits-or-bitbucket = &#34;!f() { &lt;br&gt; for l in &#34;$@&#34;; do &lt;br&gt; git log --grep &#34;$l&#34; -i --format=&#34;%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)&amp;lt;%an&amp;gt;%C(reset)&#34; --color=always; &lt;br&gt; printf &#34;\n&#34;; &lt;br&gt; done | sort -r; &lt;br&gt; }; f&#34; # XXX Wrong sorting if all on the same date (wth &#34;testing failure&#34; on PFlow) # XXX Add all, date short... #+end_src&lt;/p&gt; &#xA;&lt;p&gt;: testing failure&lt;/p&gt; &#xA;&lt;p&gt;To find /commit/ that has &lt;em&gt;both&lt;/em&gt; line matching first and line matching second somewhere, use the &lt;em&gt;AND&lt;/em&gt; semantic:&lt;/p&gt; &#xA;&lt;p&gt;: git log --grep=FOO --grep=BAR --all-match&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git search-for-commits-gitlab-and PATTERN... # Search for commits (Filter by message). search-for-commits-and-gitlab = &#34;!f() { &lt;br&gt; CMD=&#34;git log --all-match -i&#34;; &lt;br&gt; for PATTERN in &#34;$@&#34;; do &lt;br&gt; CMD=&#34;$CMD --grep &#39;$PATTERN&#39;&#34;; &lt;br&gt; done; &lt;br&gt; eval $CMD; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;: curl -H &#34;Accept: application/vnd.github.cloak-preview&#34; &lt;br&gt; : &lt;a href=&#34;https://api.github.com/search/commits%5C?q%5C=repo:fniessen/org-html-themes+local+css&#34;&gt;https://api.github.com/search/commits\?q\=repo:fniessen/org-html-themes+local+css&lt;/a&gt; &lt;br&gt; : | jq &#39;.items[] | {commit}&#39;&lt;/p&gt; &#xA;&lt;p&gt;Add &lt;del&gt;--name-status&lt;/del&gt; to show only names and status of &lt;em&gt;changed files&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Show the &lt;em&gt;last commit&lt;/em&gt; whose &lt;em&gt;message matches a regexp&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;: # Show the LATEST commit which has the text &#34;fix: font&#34; in its message. : git log :/&#34;fix: font&#34; : git show :/&#34;fix: font&#34; : : # Show the LATEST merge commit. : git show :/^Merge&lt;/p&gt; &#xA;&lt;p&gt;*** Search by Author&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git search-for-author [PATTERN] # Show the log for an author (or my own user email). search-for-author = &#34;!f() { &lt;br&gt; git log --author=${1-$(git config --get user.email)} -i --no-merges --all; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Search on File Changes&lt;/p&gt; &#xA;&lt;p&gt;**** Search string (added/removed) in code&lt;/p&gt; &#xA;&lt;p&gt;If you want to find all commits where a &lt;em&gt;string&lt;/em&gt; was &lt;em&gt;added or removed&lt;/em&gt; in the /file contents/ (to be more exact: where its &lt;em&gt;number of occurrences changed&lt;/em&gt; in the source file), i.e. search the /commit contents/, use &lt;del&gt;-S&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can dig up commits that have, for example,&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;removed calls to a specific function, or&lt;/li&gt; &#xA; &lt;li&gt;added a certain CSS classname.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_warning If the number of times &#34;foo&#34; appears in the file is the same before and after a commit, it will not match using &lt;del&gt;-S &#34;foo&#34;&lt;/del&gt;. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;In other words, to find the following commit:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src diff :tangle no @@ -4211,9 +4211,10 @@ public class MovesHandler extends EventHandlerBase { */&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; private boolean actionsNotCompleted(final EventHandlerContext context, final String mo_id) {&#xA;     final Object found_mo_id =&#xA;             selectDbValue(context, &#34;activity_log&#34;, &#34;activity_log_id&#34;, &#34;mo_id=&#34; + mo_id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code&gt;               + &#34; AND status NOT IN (&#39;COMPLETED-V&#39;,&#39;REJECTED&#39;,&#39;CANCELLED&#39;)&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code&gt;               + &#34; AND status NOT IN (&#39;COMPLETED-V&#39;,&#39;CLOSED&#39;,&#39;REJECTED&#39;,&#39;CANCELLED&#39;)&#34;);&#xA;   return (found_mo_id != null);&#xA;&lt;/code&gt;&lt;/pre&gt; } #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;you &lt;em&gt;need to search on &#39;CLOSED&#39;&lt;/em&gt;. Searching on &#39;COMPLETED-V&#39; would not bring back that commit!&lt;/p&gt; &#xA;&lt;p&gt;: git log --since=&#34;1 week ago&#34; --all -S &#34;foo&#34;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf whatwhen = log -p -S #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Prettier &lt;del&gt;whatchanged&lt;/del&gt; with full diffs based on text search:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Find commits by source code. search-for-commits-contents = &#34;!f() { &lt;br&gt; git log -S $1; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;h1&gt;XXX Does not work for strings with spaces in them...&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf grep4d = !sh -c &#39;git log -p -S&#39;$1&#39; $2&#39; -&lt;/p&gt; &#xA;&lt;h1&gt;Not the best example, but: git grep4d CLOSED &#39;*.java&#39;&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;del&gt;-S&lt;/del&gt; accepts a string, but can be modified to accept a &lt;em&gt;regexp&lt;/em&gt; with &lt;del&gt;--pickaxe-regex&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;**** Search regexp (added/removed/changed?) in code&lt;/p&gt; &#xA;&lt;p&gt;String contained in added/removed lines from Commit contents (Diff)&lt;/p&gt; &#xA;&lt;p&gt;With the &lt;del&gt;-G&lt;/del&gt; option, the commit is shown in the log if your &lt;em&gt;regexp&lt;/em&gt; search matches any &lt;em&gt;line&lt;/em&gt; that was added, removed, or changed.&lt;/p&gt; &#xA;&lt;p&gt;: git log --since=&#34;1 week ago&#34; --all -G &#34;foo&#34; : git log --since=&#34;1 week ago&#34; --all --full-history -G &#34;foo&#34;&lt;/p&gt; &#xA;&lt;p&gt;** Open a repository in a web browser&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf browse-commits = &#34;!f() { &lt;br&gt; URL=$(git config --get remote.$(git origin).url); &lt;br&gt; xdg-open ${URL/.git}/commits; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For Cygwin:&lt;/p&gt; &#xA;&lt;p&gt;: alias xdg-open=&#39;cygstart&#39;&lt;/p&gt; &#xA;&lt;p&gt;** Push&lt;/p&gt; &#xA;&lt;p&gt;** Undo changes (Oh Shit, Git!?!)&lt;/p&gt; &#xA;&lt;p&gt;See also:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ohshitgit.com/&#34;&gt;https://ohshitgit.com/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://i.pinimg.com/originals/5b/af/1b/5baf1bab9f2285b4d9df6e9a959411e9.png&#34;&gt;https://i.pinimg.com/originals/5b/af/1b/5baf1bab9f2285b4d9df6e9a959411e9.png&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/&#34;&gt;https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://gitimmersion.com/lab_16.html&#34;&gt;http://gitimmersion.com/lab_16.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Undo local changes which were not pushed to remote repository (after you committed)&lt;/p&gt; &#xA;&lt;p&gt;*** Undo changes after they are pushed to remote repository&lt;/p&gt; &#xA;&lt;p&gt;**** Without history modification (preferred way)&lt;/p&gt; &#xA;&lt;p&gt;git revert?&lt;/p&gt; &#xA;&lt;p&gt;**** With history modification (requires coordination with team and force pushes)&lt;/p&gt; &#xA;&lt;p&gt;*** Remove sensitive data from a repository&lt;/p&gt; &#xA;&lt;p&gt;If you commit sensitive data, such as a password or SSH key into a Git repository, you can remove it from the history. To entirely remove unwanted files from a repository&#39;s history you can use:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;either the &lt;del&gt;git filter-branch&lt;/del&gt; command&lt;/li&gt; &#xA; &lt;li&gt;or the BFG Repo-Cleaner open source tool.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** REVERT - Undo mistakes&lt;/p&gt; &#xA;&lt;p&gt;*** Change your last commit&lt;/p&gt; &#xA;&lt;p&gt;This will help when we need to change the most recent commit.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning &lt;del&gt;git commit --amend&lt;/del&gt; is a dangerous operation. Someone might forget that the current commit has already been pushed, and amend it anyway. What will they do then?&lt;/p&gt; &#xA;&lt;p&gt;Try to push the result, see a message about non-fast-forward pushes being not allowed, then go along the &#34;If pushing fails&#34; section (pull, resolve, commit, push), and we&#39;ll have two similar commits in the history. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;#+begin_verse The key to understanding that is that Git does not rewrite history, it creates new history and calls that reality. The commits in this history have different IDs (because the ID is the content plus the ID of its parent, changing just one commit means everything after it must change). If you push this new history (with --force) everyone else will have the old divergent history. All their work will be on top of this divergent history. They have to do the surgery to put their work on your new history.&lt;/p&gt; &#xA;&lt;p&gt;When users do a &#34;git pull&#34;, git doesn&#39;t store that you did a rebase (it would be nice if it did) so it assumes something has gone wrong and refuses to pull. Git gets a human to look at the divergence and decide what to do with it. Unfortunately, most people don&#39;t know what to do with a divergent repository.&lt;/p&gt; &#xA;&lt;p&gt;And yes, this applies to amended commits.&lt;/p&gt; &#xA;&lt;p&gt;This is a common question answered on Stack Overflow. &lt;a href=&#34;https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase&#34;&gt;https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This answer isn&#39;t specifically about rebase, but it illustrates how Git creates new history. &lt;a href=&#34;https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938&#34;&gt;https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938&lt;/a&gt; #+end_verse&lt;/p&gt; &#xA;&lt;p&gt;Modify the &lt;em&gt;last&lt;/em&gt; commit, amending with the same message -- without your editor prompting you for the message you&#39;ve already entered!&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Append your staged changes to the latest commit (keeping the pre-existing # commit message). recommit = commit -v --amend --reuse-message HEAD #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Oh, you made a typo!&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git reword MSG # Change latest commit message to what you type in. reword = commit --amend -m #+end_src&lt;/p&gt; &#xA;&lt;p&gt;or use:&lt;/p&gt; &#xA;&lt;p&gt;: git commit --amend&lt;/p&gt; &#xA;&lt;p&gt;to open your commit editor and reword the message.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git credit AUTHOR_NAME AUTHOR_EMAIL # Credit an author on the latest commit. credit = &#34;!f() { &lt;br&gt; git commit --amend --author=&#34;$1 &amp;lt;$2&amp;gt;&#34; --reuse-message HEAD; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;After discovering these options, I find I am less fearful of making premature commits, since they are easily fixed. (But not after pushing, of course.)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning &lt;em&gt;NEVER AMEND a commit&lt;/em&gt; that you&#39;ve &lt;em&gt;ALREADY PUSHED&lt;/em&gt; to a remote repository. &lt;a href=&#34;https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message&#34;&gt;https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message&lt;/a&gt; #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;Solution for &lt;em&gt;amending older commits&lt;/em&gt;: &lt;a href=&#34;https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit&#34;&gt;https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit&lt;/a&gt; (see 1st and 2nd answers!)&lt;/p&gt; &#xA;&lt;p&gt;My new favorite alias lets you amend to a specific commit, &lt;em&gt;no&lt;/em&gt; need to be the &lt;em&gt;latest&lt;/em&gt; one.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Edit history. recommit2 = &#34;!f() { TARGET=$(git rev-parse &#34;$1&#34;); &lt;br&gt; git commit --fixup=$TARGET ${@:2} &lt;br&gt; &amp;amp;&amp;amp; GIT_EDITOR=true git rebase --interactive --autostash --autosquash $TARGET~; }; f&#34; # See &lt;a href=&#34;https://blog.filippo.io/git-fixup-amending-an-older-commit/&#34;&gt;https://blog.filippo.io/git-fixup-amending-an-older-commit/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Checkout the commit in question, and amend its message.&#xA;reword2 = &#34;!f() { OLD_BRANCH=$(git current-branch); \&#xA;                  git checkout $1; \&#xA;                  git commit --amend; \&#xA;                  git checkout $OLD_BRANCH; }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Undo changes to one (or more) file(s) in a commit -- instead of reverting the entire commit&lt;/p&gt; &#xA;&lt;p&gt;: git show COMMIT_HASH -- PATH/TO/FILE | git apply --reverse&lt;/p&gt; &#xA;&lt;p&gt;*** Throw away a commit&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.vogella.com/tutorials/Git/article.html#resetcommits&#34;&gt;http://www.vogella.com/tutorials/Git/article.html#resetcommits&lt;/a&gt; &lt;a href=&#34;http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified&#34;&gt;http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified&lt;/a&gt; &lt;a href=&#34;http://git-scm.com/2011/07/11/reset.html&#34;&gt;http://git-scm.com/2011/07/11/reset.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;git reset&lt;/del&gt; is a simple way to undo changes that haven&#39;t been shared with anyone else.&lt;/p&gt; &#xA;&lt;p&gt;See  Undo &#39;git add&#39; before commit .&lt;/p&gt; &#xA;&lt;p&gt;**** Soft option -- Do not touch the index file or the working tree at all&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git uncommit # Remove the last commit. uncommit = reset --soft HEAD~1 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you make a commit and really didn&#39;t mean to, use the &lt;del&gt;uncommit&lt;/del&gt; alias to undo it like this:&lt;/p&gt; &#xA;&lt;p&gt;: git uncommit&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;uncommit&lt;/del&gt; &lt;em&gt;undoes the last commit&lt;/em&gt;, and &lt;em&gt;puts the changes&lt;/em&gt; in the commit &lt;em&gt;into your index&lt;/em&gt; -- leaving the content of your working tree exactly as it is. It&#39;s like going back in time to the moment right before you committed.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s really handy if you make a commit and accidently provide the wrong commit message. For example:&lt;/p&gt; &#xA;&lt;p&gt;: git commit -m &#34;Fix bug #11&#34; : (damn - wrong bug number) : git uncommit : git commit -m &#34;Fix bug #1&#34;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note &lt;del&gt;uncommit&lt;/del&gt; here means to do just the reverse of &lt;del&gt;commit&lt;/del&gt;. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;This can be a useful technique in resuming work on an unfinished changeset.&lt;/p&gt; &#xA;&lt;p&gt;**** Mixed option -- Do not touch the working tree (but regenerate the index)&lt;/p&gt; &#xA;&lt;p&gt;Reset the previous commit, but &lt;em&gt;puts&lt;/em&gt; all &lt;em&gt;the changes&lt;/em&gt; from that commit &lt;em&gt;in the working tree&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf uncommit-unstage = reset --mixed HEAD~1 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note &lt;del&gt;--mixed&lt;/del&gt; with paths is deprecated; use &lt;del&gt;git reset -- &#xA;  &lt;paths&gt;&lt;/paths&gt;&lt;/del&gt; instead. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;This is a useful technique if your pull fails to merge the new stuff from upstream: &lt;del&gt;git reset HEAD&lt;/del&gt;1~, pull again, fix the conflicts, then commit your changes again.&lt;/p&gt; &#xA;&lt;p&gt;This can also be a useful technique to slice a single big commit to different small commits to haste review process.&lt;/p&gt; &#xA;&lt;p&gt;**** Hard option -- Regenerate both the index and working tree&lt;/p&gt; &#xA;&lt;p&gt;Remove the last commit, &lt;em&gt;delete changes in your staging area and in your working directory&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Erase any changes since your last commit (reset every file in your working # directory to its committed state). # Destroy the changes from the commit you want to undo. undo = reset --hard HEAD~1 # Delete last commit. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you reset work that you /never committed/, it is gone for good. Too bad! This is quite a dangerous command (&lt;del&gt;git reset --hard&lt;/del&gt; is one of the few Git commands which deletes information with no backout), and must be used with &lt;em&gt;EXTREME CAUTION&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning This command will &lt;em&gt;overwrite all CHANGED tracked files&lt;/em&gt; in the working tree! (/Untracked files/ are out of scope.) #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;#+begin_tip If you have changes in your working tree or staging area, you&#39;ll probably want to stash them before doing the above. #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note See the functionality of the partly overlapping &lt;del&gt;git checkout .&lt;/del&gt; command (note that it will only erase all your unstaged changes: the &lt;em&gt;files in your staging index will be untouched&lt;/em&gt;), by comparing [[https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout][git reset and git checkout]]. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;del&gt;git reset --hard @{u}&lt;/del&gt; to make sure the integration branch is up-to-date before merging.&lt;/p&gt; &#xA;&lt;p&gt;Other scenarios:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Overtime working, did lots of stupid things. You want to run away from what had been done...&lt;/li&gt; &#xA; &lt;li&gt;Recover context before a stale merge.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Revert a commit&lt;/p&gt; &#xA;&lt;p&gt;If you make an unwanted change but it doesn&#39;t make sense to uncommit it (because that code has been pushed to a remote repository say), you can use &lt;del&gt;revert&lt;/del&gt; to effectively reverse the commit in question. For example:&lt;/p&gt; &#xA;&lt;p&gt;: git commit &#34;Fix bug #5&#34; : git push : (hmm - bad fix) : git revert 2a5daf3f&lt;/p&gt; &#xA;&lt;p&gt;This creates a patch that is the opposite of commit &lt;del&gt;2a5daf3f&lt;/del&gt; and commits it to your repository.&lt;/p&gt; &#xA;&lt;p&gt;If you want to revert that commit without committing it (putting the reversion into your index), use:&lt;/p&gt; &#xA;&lt;p&gt;: git revert -n COMMIT&lt;/p&gt; &#xA;&lt;p&gt;*** Squash&lt;/p&gt; &#xA;&lt;p&gt;Combine together a change done in several commits into one commit so that people think you are smart.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git squash N # Bundle the last N commits into a single commit. squash = &#34;!f() { &lt;br&gt; git reset --soft HEAD~$1 &lt;br&gt; &amp;amp;&amp;amp; git commit --edit -m&#34;$(git log --reverse --format=%B HEAD..HEAD@{1})&#34;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/blog/git-squash-commits-merging-bitbucket&#34;&gt;https://bitbucket.org/blog/git-squash-commits-merging-bitbucket&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Revert a faulty merge&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mirrors.edge.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt&#34;&gt;https://mirrors.edge.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** How to undo almost anything with Git&lt;/p&gt; &#xA;&lt;p&gt;Absolutely read &lt;a href=&#34;https://github.com/blog/2019-how-to-undo-almost-anything-with-git&#34;&gt;https://github.com/blog/2019-how-to-undo-almost-anything-with-git&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Branches&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Terminology:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Branch :: A branch is a set of check-ins with the same value for their &#34;branch&#34; property.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Leaf :: A leaf is a check-in with no children in the same branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Closed Leaf :: A closed leaf is any leaf with the closed tag. These leaves are intended to never be extended with descendants and hence are omitted from lists of leaves in the command-line and web interface.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open Leaf :: A open leaf is a leaf that is not closed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fork :: A fork is when a check-in has two or more direct (non-merge) children in the same branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Branch Point :: A branch point occurs when a check-in has two or more direct (non-merge) children in different branches. A branch point is similar to a fork, except that the children are in different branches.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(from &lt;a href=&#34;http://chiselapp.com/user/paulfitz/repository/fossil/doc/trunk/www/branching.wiki&#34;&gt;http://chiselapp.com/user/paulfitz/repository/fossil/doc/trunk/www/branching.wiki&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;** Branching model&lt;/p&gt; &#xA;&lt;p&gt;Consistent &lt;em&gt;naming conventions&lt;/em&gt; (from the [[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow][Gitflow]] Git workflow):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=main= or =master= (used for &lt;em&gt;production releases&lt;/em&gt;)&lt;/p&gt; &lt;p&gt;It should be the most stable branch. Merges commits from develop, release and hotfix branches.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=develop= (used as integration branch for &lt;em&gt;&#34;next release&#34; development&lt;/em&gt;)&lt;/p&gt; &lt;p&gt;It has the newest features and fixes. Merges commits from feature and bugfix branches.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;prefix =feature/MSW-709-add-support-for-webm= (for new &lt;em&gt;features&lt;/em&gt;, such as Jira &lt;em&gt;stories&lt;/em&gt;)&lt;/p&gt; &lt;p&gt;These branches are short lived as they only exist while a specific feature is being developed. Usually does not merge any commits unto it, unless there is another feature derived from it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;prefix =bugfix/= (typically used to fix Release branches, such as Jira &lt;em&gt;bugs&lt;/em&gt;)&lt;/p&gt; &lt;p&gt;Used to fix bugs found that either exist in develop but have not made it into production, or that do exist in production but can wait until the next release. These branches merge into develop.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;prefix =release/2018-12-24= (used for preparing and testing &lt;em&gt;release&lt;/em&gt; tasks)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;prefix =hotfix/fix-123-for-production= (used to &lt;em&gt;urgently fix&lt;/em&gt; bugs on &lt;em&gt;production&lt;/em&gt;, that have high impact)&lt;/p&gt; &lt;p&gt;Used to fix pressing issues that are found in production. Hotfix branches merge directly to the main branch.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Alternatives:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://about.gitlab.com/blog/2014/09/29/gitlab-flow/&#34;&gt;https://about.gitlab.com/blog/2014/09/29/gitlab-flow/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://trunkbaseddevelopment.com/&#34;&gt;https://trunkbaseddevelopment.com/&lt;/a&gt; (and &lt;a href=&#34;https://dev.to/alediaferia/git-tips-for-trunk-based-development-1i1g&#34;&gt;https://dev.to/alediaferia/git-tips-for-trunk-based-development-1i1g&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Create a branch&lt;/p&gt; &#xA;&lt;p&gt;Create a new branch (maximum 40-character name advised), and then switch to it:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf create-branch = checkout -b #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note To create a branch from a specific commit:&lt;/p&gt; &#xA;&lt;p&gt;: git create-branch bugfix 7e09ef09&lt;/p&gt; &#xA;&lt;p&gt;Otherwise you&#39;re in a &#34;detached head&#34; state, which can have odd results. The branch method is at least a little more stable. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note I usually branch off from the commit before the offending commit and stay there until things are resolved (unless I&#39;m able to resolve it myself).&lt;/p&gt; &#xA;&lt;p&gt;Or I branch off the main branch and revert the offending commit until things are resolved, ie. like so&lt;/p&gt; &#xA;&lt;p&gt;: git checkout master : git create-branch sb-master : git revert sha1-of-offending-commit #+end_note&lt;/p&gt; &#xA;&lt;p&gt;** Current branch&lt;/p&gt; &#xA;&lt;p&gt;Name of current branch (not so useful in itself, but used in other aliases):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git current-branch # Show the current branch name (v2.22+). current-branch = branch --show-current #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note In the &#34;detached HEAD&#34; state, that is when &lt;del&gt;HEAD&lt;/del&gt; is not attached to a branch name, there is &lt;em&gt;no branch name&lt;/em&gt;. You can&#39;t get something that doesn&#39;t exist. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git current-branch-without-slash # Show the current branch name (without slash). current-branch-without-slash = &#34;!f() { &lt;br&gt; git current-branch &lt;br&gt; | tr &#39;/&#39; &#39;-&#39;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Publish a branch&lt;/p&gt; &#xA;&lt;p&gt;Push the &lt;del&gt;CURRENT_BRANCH&lt;/del&gt; branch to the =origin= remote and set up tracking:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git publish # Push current branch to remote server. publish = !git push -u $(git origin) $(git current-branch) # (Create a copy of the current branch on the remote &#34;origin&#34;, and set it to # track the upstream branch) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;[[id:a7039f6e-825c-484c-8739-f3e32a9c45fc][Create a pull request]].&lt;/li&gt; &#xA; &lt;li&gt;Your team lead will review the code &amp;amp; merge it to the main branch.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** List branches&lt;/p&gt; &#xA;&lt;p&gt;*** Show all branches&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;List all branches&lt;/em&gt; (both local remote-tracking and local branches), showing SHA-1 and commit subject line for each head, along with the name of the upstream branch (if any).&lt;/p&gt; &#xA;&lt;p&gt;(Sort by Last updated)&lt;/p&gt; &#xA;&lt;p&gt;: git for-each-ref --format=&#34;%(refname:short) %(upstream:track)&#34; refs/heads&lt;/p&gt; &#xA;&lt;p&gt;fco=&#34;!f() { git branch -a -vv --color=always --format=&#39;%(refname)&#39; | sed &#34;s_refs/heads/&lt;strong&gt;&#34; | sed &#34;s_refs/remotes/&lt;/strong&gt;&#34; | fzf --query=&#34;$@&#34; --height=40% --ansi --tac --color=16 --border | awk &#39;{print $1}&#39; | xargs git checkout; }; f&#34; (fuzzy checkout a git branch)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # List local and remote branches. branches = branch -a -vv #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Show info for branches which have been checked out locally... # (Sorted by date; can be useful for spring cleaning) br = for-each-ref &lt;br&gt; --sort=-committerdate refs/heads/ &lt;br&gt; --format=&#39;%(color:green)%(committerdate:short)%(color:reset) %(HEAD) %(color:green bold)%(refname:short)%(color:reset) %(color:red bold)%(upstream:track)%(color:reset) %(color:yellow)%(objectname:short)%(color:reset) %(contents:subject) %(color:bold blue)&amp;lt;%(authorname)&amp;gt;%(color:reset)&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # What branches you have on origin, with info on who is guilty and how long ago. Useful for gitflow and feature branches in general. show-origin = &#34;!sh -c &#39;git fetch; &lt;br&gt; for BRANCH_NAME in $(git branch -r | grep -v HEAD); do &lt;br&gt; echo $(git show -s --format=&#34;%Cred%ci %C(green)%h %C(yellow)%cr %C(magenta)%an %C(blue)&#34; $BRANCH_NAME | head -n 1) \\t$BRANCH_NAME; &lt;br&gt; done | sort -r&#39;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf be = branch --edit-description #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf track = for-each-ref --format=&#39;%(refname:short) &amp;lt;- %(upstream:short)&#39; refs/heads #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Show my branches&lt;/p&gt; &#xA;&lt;p&gt;*** Show active branches&lt;/p&gt; &#xA;&lt;p&gt;List branches that are &lt;em&gt;not merged&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf br-active = &#34;!f() { &lt;br&gt; git branch --no-merged &lt;br&gt; | grep -v &#39;\*&#39;; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Usage: git branches-active&#xA;# Show only branches that are unmerged.&#xA;branches-active = &#34;!f() { \&#xA;        git branch -a -vv --no-merged \&#xA;            | grep -v &#39;\\*&#39;; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Show merged branches&lt;/p&gt; &#xA;&lt;p&gt;List branches whose tips are reachable from the specified commit (&lt;del&gt;HEAD&lt;/del&gt; if not specified).&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf br-merged = &#34;!f() { &lt;br&gt; git branch --merged &lt;br&gt; | grep -v &#39;\*&#39;; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Usage: git branches-merged&#xA;# Show only branches that are merged.&#xA;branches-merged = &#34;!f() { \&#xA;        git branch -a -vv --merged \&#xA;            | grep -v &#39;\\*&#39;; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Show stale branches&lt;/p&gt; &#xA;&lt;p&gt;&#34;Stale branches&#34; are Git branches &lt;em&gt;without commits&lt;/em&gt; for the last few months. This generally indicates old, unmaintained branches for unreleased, incomplete features.&lt;/p&gt; &#xA;&lt;p&gt;For GitHub, such period of inactivity is &lt;em&gt;3 months&lt;/em&gt; (see &lt;a href=&#34;https://help.github.com/articles/viewing-branches-in-your-repository/&#34;&gt;https://help.github.com/articles/viewing-branches-in-your-repository/&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;** Switch branches&lt;/p&gt; &#xA;&lt;p&gt;Checkout [[http://nvie.com/posts/a-successful-git-branching-model/][&lt;em&gt;common branches&lt;/em&gt;]] (useful if you have feature branches):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf master = !git checkout master main = !git checkout main develop = checkout develop #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Update all branches&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf update-all-branches = !sh -c &#34;for BRANCH_NAME in $(git branch -r); do &lt;br&gt; git checkout $BRANCH_NAME; &lt;br&gt; git pull; &lt;br&gt; done&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Close a branch&lt;/p&gt; &#xA;&lt;p&gt;Manage branches that you no longer plan on working with.&lt;/p&gt; &#xA;&lt;p&gt;: git checkout badbranch : git rename-branch badbranch badbranch-CLOSED&lt;/p&gt; &#xA;&lt;p&gt;This renames the branch, and keeps your coworkers happy.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note Such a closed branch is still considered active and will be displayed by default. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;** Delete a branch&lt;/p&gt; &#xA;&lt;p&gt;*** Delete a local branch&lt;/p&gt; &#xA;&lt;p&gt;Delete a &lt;em&gt;local&lt;/em&gt; branch:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Delete a local branch. delete-local-branch = branch -d #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note The &lt;del&gt;-d&lt;/del&gt; (&lt;del&gt;--delete&lt;/del&gt;) option only deletes the branch if it has already been fully merged in its upstream branch.&lt;/p&gt; &#xA;&lt;p&gt;You could also use &lt;del&gt;-D&lt;/del&gt;, which is an alias for &lt;del&gt;--delete --force&lt;/del&gt;, which deletes the branch &#34;irrespective of its merged status.&#34; #+end_note&lt;/p&gt; &#xA;&lt;p&gt;*** Delete the merged branches&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;delete-local-merged-branches&lt;/del&gt; &lt;em&gt;removes&lt;/em&gt; (in bulk) &lt;em&gt;all&lt;/em&gt; the &lt;em&gt;local branches&lt;/em&gt; that have been &lt;em&gt;merged to the current branch&lt;/em&gt; that you are in.&lt;/p&gt; &#xA;&lt;p&gt;XXX &lt;a href=&#34;https://haacked.com/archive/2014/07/28/github-flow-aliases/&#34;&gt;https://haacked.com/archive/2014/07/28/github-flow-aliases/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf bclean = &#34;!f() { &lt;br&gt; DEFAULT=$(git default); &lt;br&gt; git branch --merged ${1-$DEFAULT} &lt;br&gt; | grep -v &#34; ${1-$DEFAULT}$&#34; &lt;br&gt; | xargs git delete-local-branch; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;It deletes every branch that&#39;s been merged into the specified branch except the branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Delete fully merged branches. delete-local-merged-branches = &#34;!f() { &lt;br&gt; git branch --no-color --merged &lt;br&gt; | grep -v &#39;\*&#39; &lt;br&gt; | egrep -v &#34;(master|main|develop)&#34; &lt;br&gt; | xargs -n 1 git delete-local-branch; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# # https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged&#xA;# sweep = &#39;!git branch --merged $([ $1 != &#34;-f&#34; ] &amp;amp;&amp;amp; git rev-parse master) | \&#xA;#           egrep -v &#34;(^\*|^\s*(master|main|develop)$)&#34; | \&#xA;#           xargs git delete-local-branch&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Not &#34;fully merged&#34; means the branch you are about to delete contains commits that are not reachable from any of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;its upstream branch, or&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;HEAD&lt;/del&gt; (current branch). In other words, when you might lose commits.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_tip In the event that you accidentally delete &lt;del&gt;master&lt;/del&gt;, get it back with:&lt;/p&gt; &#xA;&lt;p&gt;: git create-branch master $(git origin)/master #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://haacked.com/archive/2014/07/28/github-flow-aliases/&#34;&gt;http://haacked.com/archive/2014/07/28/github-flow-aliases/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://www.oreilly.com/library/view/git-pocket-guide/9781449327507/ch05.html&#34;&gt;https://www.oreilly.com/library/view/git-pocket-guide/9781449327507/ch05.html&lt;/a&gt; for the distinction between &#34;merged&#34; and &#34;fully merged&#34; branches!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged&#34;&gt;https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/arc90/git-sweep&#34;&gt;https://github.com/arc90/git-sweep&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf # Delete all branches that were safely merged into the main branch. All other are skipped (no worries). # On osx xargs does not have -r argument, so it fail. If you remove -r, it will run at least once, making this not safe operation. cleanup = !git branch --merged=master &lt;br&gt; | grep -Ev &#39;^\* | master$&#39; &lt;br&gt; | xargs -r git delete-local-branch #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Delete a remote branch&lt;/p&gt; &#xA;&lt;p&gt;Delete a &lt;em&gt;remote&lt;/em&gt; branch:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git delete-remote-branch BRANCH_NAME # Delete a remote branch. delete-remote-branch = !git push $(git origin) --delete&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Usage: git unpublish&#xA;# Delete current branch on remote server.&#xA;unpublish = !git delete-remote-branch $(git current-branch)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Delete a branch locally and on the &lt;del&gt;origin&lt;/del&gt; remote&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf delete-branch = &#34;!f() { &lt;br&gt; git delete-local-branch $1 &lt;br&gt; &amp;amp;&amp;amp; git delete-remote-branch $1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Delete all orphaned branches (that no longer exist at remote)&lt;/p&gt; &#xA;&lt;p&gt;Once you delete the branch from the remote, you can &lt;em&gt;remove all orphaned remote-tracking branches that you have locally&lt;/em&gt;, in =.git/refs/remotes/origin=, but are &lt;em&gt;no more present in the remote repository&lt;/em&gt; &lt;del&gt;origin&lt;/del&gt; with:&lt;/p&gt; &#xA;&lt;p&gt;: git remote prune $(git origin)&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;del&gt;--dry-run&lt;/del&gt; flag to only see what branches will be pruned, but not actually prune them:&lt;/p&gt; &#xA;&lt;p&gt;: git remote prune $(git origin) --dry-run&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git prune-all # Prune deleted branches from all remotes. prune-all = !git remote &lt;br&gt; | xargs -n 1 git remote prune # &#39;git remote prune&#39; does not understand &#39;--all&#39;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# There&#39;s no way to tell git remote update to prune orphaned branches?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_tip If you want this to be run automatically every time you fetch/pull:&lt;/p&gt; &#xA;&lt;p&gt;: git config --global fetch.prune true #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;or prune individual remote tracking branches with:&lt;/p&gt; &#xA;&lt;p&gt;: git delete-local-branch BRANCH_NAME&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Remove orphaned branches in your local repository&lt;/em&gt; that &lt;em&gt;no longer exist in the remote&lt;/em&gt; one (by deleting the local ones that show they are &#34;gone&#34; in &lt;del&gt;git branch -vv&lt;/del&gt;):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf prune-local-branches = &#34;!f() { &lt;br&gt; git branch -vv &lt;br&gt; | grep &#39;: gone]&#39; &lt;br&gt; | awk &#39;{print $1}&#39; &lt;br&gt; | xargs git delete-local-branch; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Rename a branch&lt;/p&gt; &#xA;&lt;p&gt;Sometimes we name a branch poorly or maybe we thought the name was &#34;good&#34; but not meaningful to the work we are doing.&lt;/p&gt; &#xA;&lt;p&gt;To rename a branch &lt;em&gt;locally&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If we are on the branch we want to rename, we can just &lt;del&gt;git rename-local-branch NEW_BRANCH_NAME&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If we are on another branch, we have to use &lt;del&gt;git rename-local-branch OLD_BRANCH_NAME NEW_BRANCH_NAME&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf rename-local-branch = branch -m #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX Try : git rename-local-branch &#34;#520-application-fee-refunds&#34; &#34;#509-application-fee-refunds&#34; (see &lt;a href=&#34;https://gist.github.com/lttlrck/9628955&#34;&gt;https://gist.github.com/lttlrck/9628955&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;To rename a branch &lt;em&gt;locally and remotely&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Rename the branch locally,&lt;/li&gt; &#xA; &lt;li&gt;Push the new branch and set local branch to track the new remote, and&lt;/li&gt; &#xA; &lt;li&gt;Delete the old branch.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git rename-branch OLD_BRANCH_NAME NEW_BRANCH_NAME # Rename both a local and remote branch. rename-branch = &#34;!f() { &lt;br&gt; git rename-local-branch $1 $2 &lt;br&gt; &amp;amp;&amp;amp; git push --set-upstream $(git origin) $2 &lt;br&gt; &amp;amp;&amp;amp; git delete-remote-branch $1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** What if&lt;/p&gt; &#xA;&lt;p&gt;... I&#39;m working on the main branch adding a simple feature. After a few minutes I realize it was not so simple and it should have been better to work into a new branch.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master&#34;&gt;http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tags&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Tags give the ability to &lt;em&gt;mark a specific commit&lt;/em&gt; in your repository history as being important.&lt;/p&gt; &#xA;&lt;p&gt;** Create a tag&lt;/p&gt; &#xA;&lt;p&gt;While Git supports annotated and lightweight tags, you can only &lt;em&gt;create&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;lightweight tags&lt;/em&gt; via /GitHub/ interface (for releases), and&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;annotated tags&lt;/em&gt; in /Bitbucket/ and in /GitLab/.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Lightweight tags&lt;/em&gt; are just pointers to specific commits. They &lt;em&gt;don&#39;t include any further information&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Annotated tags&lt;/em&gt; are &lt;em&gt;regular objects&lt;/em&gt; in the repository, which means they have an author, a date, a message, and can be referred because they have their own SHA-1 key.&lt;/p&gt; &#xA;&lt;p&gt;If knowing &lt;em&gt;who&lt;/em&gt; tagged &lt;em&gt;what&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; is relevant for you, then use /annotated tags/. If you &lt;em&gt;just want to tag a specific point in your development&lt;/em&gt;, no matter who and when did that, then /lightweight tags/ are good enough.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note /Annotated tags/ are meant for &lt;em&gt;release&lt;/em&gt; while /lightweight tags/ are meant for private or temporary object labels. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;Create an /annotated tag/:&lt;/p&gt; &#xA;&lt;p&gt;: git tag -a TAG_NAME -m &#39;TAG_MESSAGE&#39;&lt;/p&gt; &#xA;&lt;p&gt;Create a /lightweight tag/ (/no message!/):&lt;/p&gt; &#xA;&lt;p&gt;: git tag TAG_NAME&lt;/p&gt; &#xA;&lt;p&gt;Create a date/time tag with a suffix, e.g: 2021.01.12_15.25_PREVIOUS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf tag-with-date = !sh -c &#39;git tag $(date &#34;+%Y.%m.%d_%H.%M&#34;)_&#34;$0&#34;&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** See the commits for a tag&lt;/p&gt; &#xA;&lt;p&gt;See the list of all the commits for that tag.&lt;/p&gt; &#xA;&lt;p&gt;: git ls TAG_NAME&lt;/p&gt; &#xA;&lt;p&gt;** Push a tag to your repository&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Push TAG_NAME to remote repo. publish-tag = &#34;!sh -c &#39;git push ${2:-$(git origin)} $1&#39; -&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Remove TAG_NAME from remote repo.&#xA;unpublish-tag = &#34;!sh -c &#39;git push ${2:-$(git origin)} :refs/tags/$1&#39; -&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Push all your tags (a regular push won&#39;t push a tag):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf push-tags = push --tags #+end_src&lt;/p&gt; &#xA;&lt;p&gt;: git push --tags # Only tags. : git push --tags $(git origin) master # Code and tags.&lt;/p&gt; &#xA;&lt;p&gt;** List the repository tags&lt;/p&gt; &#xA;&lt;p&gt;List tags using (better) version sorting (not going from =v0.1= to =v0.10=):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # List tags. tags = tag -l --sort=v:refname&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Show a list of tag names and the commits they reference.&#xA;tags-show-ids = show-ref --tags&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;: # Show annotated and lightweight tags. : git show-ref -d --tags &lt;br&gt; : | cut -b 42- &lt;br&gt; : | sort &lt;br&gt; : | sed &#39;s/^{}//&#39; &lt;br&gt; : | uniq -c &lt;br&gt; : | sed &#39;s/2\ refs/tags// a /&#39; &lt;br&gt; : | sed &#39;s/1\ refs/tags//lw /&#39; : # 2. Remove the commit-id. : # 4. Remove ^{} markings. : # 5. Count identical lines. : # 6. 2 identicals = annotated.&lt;/p&gt; &#xA;&lt;p&gt;Show the last tag /in the current branch/:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf last-tag = describe --tags --abbrev=0 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Show the latest tag /in all branches/:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf last-tag-all = !git describe --tags $(git rev-list --tags --max-count=1) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Rename a tag&lt;/p&gt; &#xA;&lt;p&gt;Change the tag name but keep it on the same commit.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git rename-tag OLD_TAG_NAME NEW_TAG_NAME # Rename a tag (locally and remotely). rename-tag = &#34;!f() { &lt;br&gt; git tag $2 $1; &lt;br&gt; git tag -d $1; &lt;br&gt; git push $(git origin) $2; &lt;br&gt; git push $(git origin) :refs/tags/$1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Clear a tag&lt;/p&gt; &#xA;&lt;p&gt;If you have defined a tag and no longer want it defined, use the &lt;del&gt;delete-tag&lt;/del&gt; alias to remove it.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Delete local and remote tags. delete-tag = &#34;!f() { &lt;br&gt; [ -z $1 ] &lt;br&gt; &amp;amp;&amp;amp; echo &#34;No tags given as an argument!&#34; &lt;br&gt; || (git tag -l $1 | &lt;br&gt; xargs -I % echo &#34;git tag -d % &lt;br&gt; &amp;amp;&amp;amp; git push --delete $(git origin) %&#34; | &lt;br&gt; sh); &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;: git tag v2.0-beta-4 : (oops, we&#39;re not releasing a 4th beta) : git delete-tag v2.0-beta-4&lt;/p&gt; &#xA;&lt;p&gt;Delete similar tags:&lt;/p&gt; &#xA;&lt;p&gt;: git delete-tag &#39;v2.0-*&#39;&lt;/p&gt; &#xA;&lt;p&gt;** Remove all tags&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no # Delete all local and remote tags. delete-all-tags = &#34;!f() { &lt;br&gt; for TAG_NAME in $(git tags); do git tag -d $TAG_NAME git push $(git origin) :$TAG_NAME done; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compare Revisions (commits, branches or tags)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;See what&#39;s changed&lt;/em&gt; between two revisions.&lt;/p&gt; &#xA;&lt;p&gt;Easily determine which changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;are on the &#34;compare&#34; side (= merge /source/) but&lt;/li&gt; &#xA; &lt;li&gt;are /not/ on the &#34;base&#34; side (= merge /destination/).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_note Diff using three-dot (&lt;del&gt;...&lt;/del&gt;) notation.&lt;/p&gt; &#xA;&lt;p&gt;When you use three dots (...), &lt;del&gt;git diff&lt;/del&gt; finds the merge-base between the left and right side commit SHA-1s and substitutes that in for the left-side SHA-1. The right-side SHA-1 remains intact. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;You can see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a list of commits,&lt;/li&gt; &#xA; &lt;li&gt;a list of changed files,&lt;/li&gt; &#xA; &lt;li&gt;a diff, and&lt;/li&gt; &#xA; &lt;li&gt;any pull requests merged between the two versions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Commits&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git compare-commits REV_BASE REV_COMPARE compare-commits = &#34;!f() { &lt;br&gt; git log $1...$2; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Files changed&lt;/p&gt; &#xA;&lt;p&gt;List all the changed &lt;em&gt;files between 2 commits&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git compare-changed-files REV_BASE REV_COMPARE # Show changed files between two commits. compare-changed-files = &#34;!f() { &lt;br&gt; git diff --stat $1...$2; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Diff&lt;/p&gt; &#xA;&lt;p&gt;View all diffs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Inline diff (unified, single view)&lt;/p&gt; &lt;p&gt;#+begin_src conf&lt;/p&gt; &lt;h1&gt;Usage: git compare REV_BASE REV_COMPARE&lt;/h1&gt; &lt;h1&gt;= git diff REV_BASE...REV_COMPARE&lt;/h1&gt; &lt;h1&gt;Example: git compare master@{1day} master&lt;/h1&gt; &lt;p&gt;compare = &#34;!f() { &lt;br&gt; git diff $1...$2; &lt;br&gt; }; f&#34;&lt;/p&gt; &lt;h1&gt;&lt;a href=&#34;https://github.com/fniessen/git-leuven/compare/master@%7B1day%7D...master&#34;&gt;https://github.com/fniessen/git-leuven/compare/master@%7B1day%7D...master&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;#+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Side-by-side diff (split view)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Compare files from two different branches&lt;/p&gt; &#xA;&lt;p&gt;: git diff BRANCH_1..BRANCH_2 -- PATH/TO/FILE&lt;/p&gt; &#xA;&lt;p&gt;If either side is &lt;del&gt;HEAD&lt;/del&gt;, it may be omitted (e.g. &lt;del&gt;master..&lt;/del&gt; compares &lt;del&gt;master&lt;/del&gt; to &lt;del&gt;HEAD&lt;/del&gt;).&lt;/p&gt; &#xA;&lt;p&gt;** Merged pull requests&lt;/p&gt; &#xA;&lt;p&gt;** Example comparisons&lt;/p&gt; &#xA;&lt;p&gt;*** Show unmerged commits between two branches&lt;/p&gt; &#xA;&lt;p&gt;The alias &lt;del&gt;missing&lt;/del&gt; (an idea borrowed from Bazaar) shows the unique commits in the current branch and the specified branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git missing [COMMIT_ISH] # Show the missing commits between this and another branch missing = &#34;!f() { &lt;br&gt; printf &#34;$(tput bold)Only in HEAD:$(tput sgr0)\n&#34;; &lt;br&gt; git log &#34;${1:-master}&#34;..; &lt;br&gt; printf &#34;\n&#34;; &lt;br&gt; printf &#34;$(tput bold)Only in other:$(tput sgr0)\n&#34;; &lt;br&gt; git log ..&#34;${1:-master}&#34;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;TODO: Remove hard-coded master&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;How to find all the commits made only on a specific branch?&lt;/em&gt; Assuming that your branch was created off of &lt;del&gt;master&lt;/del&gt;, then /while on the specific branch/ (that is, you have that branch checked out):&lt;/p&gt; &#xA;&lt;p&gt;: git missing $(git ancestor) : git log --no-merges master.. : git log HEAD --not master : git cherry -v master&lt;/p&gt; &#xA;&lt;p&gt;to show commits (that you&#39;ve done since you forked) that haven&#39;t made it to &lt;del&gt;master&lt;/del&gt; yet.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;497034f2 Listener.new now accepts a hash of options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2d0333ff Cache the absolute images path for growl messages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;e4406858 Rename Listener#run to #start #+end_example&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;del&gt;cherry&lt;/del&gt; command is useful to see which commits have been cherry-picked from a development branch to the stable branch, for instance. This command compares changes on the current (=feature=) branch to upstream (=master=) and indicates which are present on both with the &lt;del&gt;-&lt;/del&gt; sign. Changes still missing from upstream are marked with &lt;del&gt;+&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;**** History of a branch: List all commits on only one side of the branches&lt;/p&gt; &#xA;&lt;p&gt;: git log --cherry-pick --left-right --graph master...BRANCH_NAME&lt;/p&gt; &#xA;&lt;p&gt;It is a list of commits reachable from &lt;del&gt;BRANCH_NAME&lt;/del&gt; that are not reachable from &lt;del&gt;master&lt;/del&gt;. This gives you the information you want, but if and only if you have never merged &lt;del&gt;BRANCH_NAME&lt;/del&gt; back to &lt;del&gt;master&lt;/del&gt;, and have never merged &lt;del&gt;master&lt;/del&gt; into &lt;del&gt;BRANCH_NAME&lt;/del&gt; since you created it. If you have merged, then this history of differences will collapse.&lt;/p&gt; &#xA;&lt;p&gt;**** Branch point&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;common ancestor&lt;/em&gt; is the last commit that existed in both branches. Usually this is the branch point, but it could also be a commit that was merged.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Find the point at which a branch forked from another branch ancestor = !zsh -c &#39;diff --old-line-format=&#39;&#39; --new-line-format=&#39;&#39; &lt;br&gt; &amp;lt;(git rev-list --first-parent &#34;${1:-master}&#34;) &lt;br&gt; &amp;lt;(git rev-list --first-parent &#34;${2:-HEAD}&#34;) &lt;br&gt; | head -1&#39; - #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The common ancestor is frequently used with &lt;del&gt;diff&lt;/del&gt; to return all of the changes that your branch introduces, while excluding the changes that you have not merged from the remote branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Since branch point. log-ancestor = !sh -c &#39;git log $(git ancestor)..&#39; diff-ancestor = !sh -c &#39;git diff $(git ancestor)..&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Find the point at which a branch forked from MASTER # Best common ancestor (when it was branched off). ancestor2 = !git merge-base $(git origin)/master $(git current-branch) ancestor3 = !git merge-base --all $(git origin)/master $(git current-branch) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git&#34;&gt;https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** How do I find a list of files committed to a Git branch (since branching)?&lt;/p&gt; &#xA;&lt;p&gt;Show all the changed files in a Git branch &lt;em&gt;since it was forked&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git missing-files [COMMIT_ISH] # Show the changed files between this and (the fork point from) another branch # Examples: # git missing-files list changed files between this and master # git missing-files feature/7 list changed files between this and the &#39;feature/7&#39; branch missing-files = &#34;!f() { &lt;br&gt; git diff --stat ${1:-master}...; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;See the added / copied / deleted / modified / renamed files in a branch:&lt;/p&gt; &#xA;&lt;p&gt;: git diff forked_from_branch...my_forked_branch --name-status --diff-filter=ACDMR&lt;/p&gt; &#xA;&lt;p&gt;Available filters for &lt;del&gt;--diff-filter&lt;/del&gt; are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A :: Added&lt;/li&gt; &#xA; &lt;li&gt;C :: Copied&lt;/li&gt; &#xA; &lt;li&gt;D :: Deleted&lt;/li&gt; &#xA; &lt;li&gt;M :: Modified&lt;/li&gt; &#xA; &lt;li&gt;R :: Renamed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;xGraph&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Graphical history viewers&lt;/p&gt; &#xA;&lt;p&gt;See example at &lt;a href=&#34;https://gitlab.com/procps-ng/procps/-/network/master&#34;&gt;https://gitlab.com/procps-ng/procps/-/network/master&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;[[https://jonas.github.io/tig/][Tig]]&lt;/p&gt; &#xA;&lt;p&gt;To see real &lt;em&gt;timeline&lt;/em&gt; of who is working on what and when:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # 50 most recent commits. # XXX this is a summary? graph = log -50 --branches --tags --remotes --date-order --format=format:&#39;%C(yellow)%h %C(reset) %&amp;lt;(75,trunc)%s &amp;lt;%cn&amp;gt; (%cr) %C(red)%d&#39; --graph&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Show log as a graph&#xA;glog = log --all --graph&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://fossil-scm.org/home/help?cmd=leaves&#34;&gt;https://fossil-scm.org/home/help?cmd=leaves&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf releases = log --no-merges --all --simplify-by-decoration --graph #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf hist = log --graph&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hist-full = log --pretty=format:&#39;%C(green)%cr%C(reset) %C(yellow)%h%Creset %C(yellow)%d%Creset %s %C(bold blue)&amp;lt;%an&amp;gt;%Creset%n&#39; --graph --name-status&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Directed Acyclic Graph:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Draw Git revisions graph with graphviz. graphviz = &#34;!f() { &lt;br&gt; echo &#39;digraph git {&#39; ; &lt;br&gt; git log -25 --pretty=&#39;format: %h -&amp;gt; { %p }&#39; &#34;$@&#34; &lt;br&gt; | sed &#39;s/[0-9a-f][0-9a-f]*/&#34;&amp;amp;&#34;/g&#39; ; &lt;br&gt; echo &#39;}&#39;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Use [[https://graphviz.org/][Graphviz]] for display.&lt;/p&gt; &#xA;&lt;p&gt;This produces output that can be displayed using &lt;del&gt;dotty&lt;/del&gt;, for example:&lt;/p&gt; &#xA;&lt;p&gt;: git graphviz HEAD&lt;del&gt;100..HEAD&lt;/del&gt;60 | dotty /dev/stdin : git graphviz --first-parent master | dotty /dev/stdin&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://tortoisegit.org/docs/tortoisegit/tgit-dug-revgraph.html&#34;&gt;https://tortoisegit.org/docs/tortoisegit/tgit-dug-revgraph.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;xContributors&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Show authors of commits in the repository, /excluding merge commits/.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf contributors-name = shortlog -n -s --no-merges -- contributors-email = shortlog -n -s -e --no-merges -- #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note The &lt;del&gt;--&lt;/del&gt; signals the /end of options/, that the rest of the parameters are limiters. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf whois = &#34;!sh -c &#39;git log -1 --author=&#34;$1&#34; -i --pretty=&#34;format:%an &amp;lt;%ae&amp;gt;\n&#34;&#39; -&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pull requests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A pull request (PR), sometimes called merge request, is a review request. You are asking someone to check the changes on a branch before merging into another branch.&lt;/p&gt; &#xA;&lt;p&gt;XXX See &lt;a href=&#34;https://github.com/github/hub/&#34;&gt;https://github.com/github/hub/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Create a pull request :PROPERTIES: :ID: a7039f6e-825c-484c-8739-f3e32a9c45fc :END:&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll be asked to select a &#34;From&#34; branch and a &#34;To&#34; branch.&lt;/p&gt; &#xA;&lt;p&gt;You need to enter a PR summary. The description is optional.&lt;/p&gt; &#xA;&lt;p&gt;Create a pull request against the default branch:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf pull-request-bb = &#34;!f() { &lt;br&gt; USER_NAME=$1; &lt;br&gt; curl --user $USER_NAME &lt;a href=&#34;https://bitbucket.org/$(git&#34;&gt;https://bitbucket.org/$(git&lt;/a&gt; repo-owner)/$(git repo-slug)/pull-requests/new?source=$(git current-branch)&amp;amp;t=1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no function pr () { if [&#34;$1&#34; == &#34;&#34;] then echo &#34;Please provide the name of the branch to create a pull request against.&#34; else local REPO=$(git remote -v | grep -m 1 &#34;(push)&#34; | sed -e &#34;s/.&lt;em&gt;github.com[:/](.&lt;/em&gt;).git.*/\1/&#34;) local BRANCH=$(git name-rev --name-only HEAD) echo &#34;... creating pull request for branch &#34;$BRANCH&#34; in &#34;$REPO&#34;&#34; open &lt;a href=&#34;https://github.com/$REPO/compare/$1...$BRANCH&#34;&gt;https://github.com/$REPO/compare/$1...$BRANCH&lt;/a&gt; fi } #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Add a comment in GitHub pull request:&lt;/p&gt; &#xA;&lt;p&gt;: curl -s -H &#34;Authorization: token $GITHUB_TOKEN&#34; -X POST -d &#39;{&#34;body&#34;: &#34;$TEXT_PR&#34;}&#39; &#34;&lt;a href=&#34;https://api.github.com/repos/$REPOSITORY_NAME/issues/$GHPRBPULLID/comments%5C&#34;&gt;https://api.github.com/repos/$REPOSITORY_NAME/issues/$GHPRBPULLID/comments\&lt;/a&gt;&#34;&#34;&lt;/p&gt; &#xA;&lt;p&gt;** List pull requests&lt;/p&gt; &#xA;&lt;p&gt;List pull requests in the current repository.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Pull Requests assigned to me&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Pull Requests I&#39;ve created&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Open&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Merged&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Closed&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Git aliases for pull requests and other useful stuff &lt;a href=&#34;https://gist.github.com/metlos/9368527&#34;&gt;https://gist.github.com/metlos/9368527&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For GitHub : git ls-remote $(git origin) &#39;refs/pull/*&#39;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf pr-list = XXX #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** 1. Check out a pull request locally&lt;/p&gt; &#xA;&lt;p&gt;XXX &lt;a href=&#34;https://gitlab.com/help/user/project/merge_requests/index.md#checkout-merge-requests-locally&#34;&gt;https://gitlab.com/help/user/project/merge_requests/index.md#checkout-merge-requests-locally&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sometimes, just reading the code of a pull request might not be enough to verify if it should be merged. Maybe you want to add something, or some tests are failing, and you want to run them locally on your computer.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Check out&lt;/em&gt; the head of a &lt;em&gt;pull request&lt;/em&gt; (given the pull request number) as a &lt;em&gt;local branch&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # For GitHub. pr-checkout-gh = &#34;!f() { &lt;br&gt; git fetch $(git origin) pull/$1/head:pr/$1 &lt;br&gt; &amp;amp;&amp;amp; git checkout pr/$1; &lt;br&gt; }; f&#34; # &lt;a href=&#34;https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally&#34;&gt;https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# For GitLab.&#xA;pr-checkout-gl = &#34;!f() { \&#xA;        git fetch $(git origin) merge-requests/$1/head:pr/$1 \&#xA;            &amp;amp;&amp;amp; git checkout pr/$1; \&#xA;    }; f&#34;&#xA;# https://about.gitlab.com/blog/2016/12/08/git-tips-and-tricks/#add-an-alias-to-checkout-merge-requests-locally&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now you can check out a particular pull request. For example:&lt;/p&gt; &#xA;&lt;p&gt;: git pr-checkout 5&lt;/p&gt; &#xA;&lt;p&gt;will fetch the &lt;em&gt;pull request&lt;/em&gt; #5 into a &lt;em&gt;local&lt;/em&gt; &lt;del&gt;pr/5&lt;/del&gt; &lt;em&gt;branch&lt;/em&gt; and check it out.&lt;/p&gt; &#xA;&lt;p&gt;** 2. Review the changes locally&lt;/p&gt; &#xA;&lt;p&gt;** Push changes to a pull request&lt;/p&gt; &#xA;&lt;p&gt;: #!/bin/bash : TMP_FILE=$(mktemp) : REPO_SLUG=$(git remote -v | grep &#39;^upstream&#39; | head -n 1 | perl -lne &#39;s/github.com:?/?(.&lt;em&gt;)/([^.]&lt;/em&gt;)([.]git| )// or next; print $1,&#34;/&#34;,$2&#39;) : PR_NUMBER=$(git rev-parse --abbrev-ref HEAD | cut -d/ -f 2) : curl -s &lt;a href=&#34;https://api.github.com/repos/$REPO_SLUG/pulls/$PR_NUMBER&#34;&gt;https://api.github.com/repos/$REPO_SLUG/pulls/$PR_NUMBER&lt;/a&gt; &amp;gt; $TMP_FILE : trap &#34;{ rm -f $TMP_FILE; }&#34; EXIT : HEAD_REF=$(cat $TMP_FILE | jq -r &#39;.head.ref&#39;) : HEAD_SLUG=$(cat $TMP_FILE | jq -r &#39;.head.repo.full_name&#39;) : git push -f &lt;a href=&#34;mailto:git@github.com&#34;&gt;git@github.com&lt;/a&gt;:$HEAD_SLUG HEAD:$HEAD_REF&lt;/p&gt; &#xA;&lt;p&gt;For more details on pushing changes to a PR, please see [[https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/allowing-changes-to-a-pull-request-branch-created-from-a-fork][the official article]].&lt;/p&gt; &#xA;&lt;p&gt;** 3. Merge the branch and fix any conflicts that come up&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note We generally don&#39;t like $Revision:$, $Date:$, $Log$, and friends like timestamps, because they&#39;re sources of gratuitous &lt;em&gt;merge conflicts&lt;/em&gt;. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;: git fetch $(git origin) : git checkout &#34;$(git origin)/master&#34; : git merge --no-ff &#34;1-change-encoding-of-read-sql-file&#34;&lt;/p&gt; &#xA;&lt;p&gt;XXX See &lt;a href=&#34;https://gitlab.com/help/user/project/merge_requests/squash_and_merge&#34;&gt;https://gitlab.com/help/user/project/merge_requests/squash_and_merge&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Merge pull request&lt;/p&gt; &#xA;&lt;p&gt;If everything is OK, you can merge the pull request.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # For GitHub. mpr = &#34;!f() { &lt;br&gt; declare OLD_BRANCH=&#34;$(git current-branch)&#34;; &lt;br&gt; declare BRANCH_NAME=&#34;${2:-$OLD_BRANCH}&#34;; &lt;br&gt; if [ $(printf &#34;%s&#34; &#34;$1&#34; | grep &#39;^[0-9]\+$&#39; &amp;gt; /dev/null; printf $?) -eq 0 ]; then &lt;br&gt; git fetch $(git origin) refs/pull/$1/head:pr/$1 &lt;br&gt; &amp;amp;&amp;amp; git checkout -B $BRANCH_NAME &lt;br&gt; &amp;amp;&amp;amp; git rebase $BRANCH_NAME pr/$1 &lt;br&gt; &amp;amp;&amp;amp; git checkout -B $BRANCH_NAME &lt;br&gt; &amp;amp;&amp;amp; git merge --ff-only pr/$1 &lt;br&gt; &amp;amp;&amp;amp; git delete-local-branch pr/$1; &lt;br&gt; fi &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Merge given pull request into the current branch.&#xA;# The commit message will have the same for as if done using the&#xA;# merge button on github.com&#xA;# Example:&#xA;#   git merge-pr $(git origin) 5&#xA;merge-pr = &#34;!sh -c &#39;\&#xA;    USER_AND_REPO=$(git remote show $1 | grep \&#34;Fetch URL\&#34; | sed -E \&#34;s/.*github.com[:\\/]([a-zA-Z_\\-]+)\\/([a-zA-Z_\\-]+)\\.git$/\\1 \\2/\&#34;); \&#xA;    USER=$(echo $USER_AND_REPO | cut -d\&#34; \&#34; -f1); \&#xA;    REPO=$(echo $USER_AND_REPO | cut -d\&#34; \&#34; -f2); \&#xA;    TMP_FILE=$(mktemp); \&#xA;    curl -si https://api.github.com/repos/$USER/$REPO/pulls/$2 &amp;gt; $TMP_FILE; \&#xA;    PULL_AUTHOR=$(cat $TMP_FILE | awk \&#34;{if (/ *\\\&#34;head\\\&#34;/) head=\\\\$1; if (/ *\\\&#34;login\\\&#34;: \\\&#34;/) value=\\\\$2}{if (head &amp;amp;&amp;amp; value) print value; if (head &amp;amp;&amp;amp; value) exit}\&#34; | sed -E \&#34;s/\\\&#34;([^\\\&#34;]+)\\\&#34;.*/\\1/\&#34;); \&#xA;    PULL_REF=$(cat $TMP_FILE | awk \&#34;{if (/ *\\\&#34;head\\\&#34;/) head=\\\\$1; if (/ *\\\&#34;ref\\\&#34;: \\\&#34;/) label=\\\\$2}{if (head &amp;amp;&amp;amp; label) print label; if (head &amp;amp;&amp;amp; label) exit}\&#34; | sed -E \&#34;s/\\\&#34;([^\\\&#34;]+)\\\&#34;.*/\\1/\&#34;); \&#xA;    PULL_TITLE=$(cat $TMP_FILE | grep \&#34;\\\&#34;title\\\&#34;: \&#34; | sed \&#34;s/^ *\\\&#34;title\\\&#34;: \\\&#34;//\&#34; | sed \&#34;s/\\\&#34;,$//\&#34;); \&#xA;    rm $TMP_FILE; \&#xA;    git fetch $1 pull/$2/head; \&#xA;    git merge --no-ff -m \&#34;Merged pull request #$2 from $PULL_AUTHOR/$PULL_REF\n\n$PULL_TITLE\&#34; FETCH_HEAD; \&#xA;    &#39; -&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;This is actually quite useful if you are a maintainer of a project on GitHub.&lt;/p&gt; &#xA;&lt;p&gt;There are two ways you can call it:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;git mpr 123&lt;/del&gt;&lt;/p&gt; &lt;p&gt;This will merge pull request number 123 on top of the current branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;git mpr 123 master&lt;/del&gt;.&lt;/p&gt; &lt;p&gt;This will merge pull request number 123 on top of the branch called master.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you are using GitHub, you can easily merge a pull request using the web interface, but if you want a bit more control over how you are merging the pull requests (for example, I&#39;m using the &lt;del&gt;git merge --ff-only&lt;/del&gt; option, while GitHub will use &lt;del&gt;git merge --no-ff&lt;/del&gt;), or you just want to merge a bunch of pull requests without leaving your terminal -- this function will help you.&lt;/p&gt; &#xA;&lt;p&gt;** 4. Push the result of the merge to the remote&lt;/p&gt; &#xA;&lt;p&gt;: git push $(git origin) &#34;master&#34;&lt;/p&gt; &#xA;&lt;p&gt;** Clean up old branch&lt;/p&gt; &#xA;&lt;p&gt;Delete the &lt;em&gt;from&lt;/em&gt; branch after PR is merged (or ignored -- if it was created b accident or if it&#39;s irrelevant):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf pr-clean = &#34;!f() { &lt;br&gt; git delete-local-branch pr/$1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Show in a web browser&lt;/p&gt; &#xA;&lt;p&gt;Open a pull request page in a web browser.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf pr-show = XXX &#xA; &lt;pr-number&gt;&#xA;   #+end_src&#xA; &lt;/pr-number&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Who?&lt;/p&gt; &#xA;&lt;p&gt;Extra script (called [[https://github.com/mislav/dotfiles/blob/master/bin/git-overwritten][git-overwritten]]) which shows blame information about original authors of lines changed or removed in a given branch:&lt;/p&gt; &#xA;&lt;p&gt;: git overwritten feature $(git origin)/master&lt;/p&gt; &#xA;&lt;p&gt;This is useful when opening pull requests per GitHub Flow; you&#39;ll want your pull request reviewed by colleagues but you might not be sure who to ping. With git-overwritten you&#39;ll get the names of people who wrote the lines you just changed, so you&#39;ll know who to @-mention when opening a pull request.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;So, given a patch (or a branch) together with a &#34;base revision&#34;, you&#39;d get a list of code chunks modified by that patch, then run &#34;annotate&#34; on the base revision, and look for those code chunks, collecting the names of corresponding authors.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Sounds like git-guilt (which I&#39;ve just read about today), might be relevant: &lt;a href=&#34;https://bitbucket.org/tpettersen/git-guilt&#34;&gt;https://bitbucket.org/tpettersen/git-guilt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Find the pull request that introduced a commit&lt;/p&gt; &#xA;&lt;p&gt;Related pull request:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf related-pr-of-commit = &#34;!sh -c &#39;git log --merges --ancestry-path $1..master &lt;br&gt; | tail -n 1 &#39; -&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;: $ git related-pr-of-commit 22689a1 : 1c6b5c4 Merge branch &#39;5-resolve-it&#39; into &#39;master&#39;&lt;/p&gt; &#xA;&lt;p&gt;In this case, the commit comes from pull request 5.&lt;/p&gt; &#xA;&lt;p&gt;** Saved replies&lt;/p&gt; &#xA;&lt;p&gt;GitHub allows to [[https://github.blog/2016-03-29-saved-replies/][save replies]]. You can set them in [[https://github.com/settings/replies][your GitHub settings]]. Here are a couple of commonly used replies:&lt;/p&gt; &#xA;&lt;p&gt;Missing changelog&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src text :tangle no This still lacks a changelog entry. Please see &lt;a href=&#34;https://raw.githubusercontent.com/fniessen/git-leuven/tree/master/changelog&#34;&gt;the changelog folder&lt;/a&gt; for instructions. Hence, I added the &#34;pending changelog&#34; label. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Missing spec PR&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src text :tangle no This still needs a PR to the &lt;a href=&#34;https://github.com/dlang/dlang.org/tree/master/spec&#34;&gt;specification&lt;/a&gt; at &lt;a href=&#34;https://github.com/dlang/dlang.org&#34;&gt;dlang.org&lt;/a&gt;. Hence, I added the label &#34;missing spec PR&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://github.com/dlang/dlang.org/raw/master/CONTRIBUTING.md&#34;&gt;dlang.org CONTRIBUTING guide&lt;/a&gt; for instructions to build dlang.org locally. If you use Windows, don&#39;t worry, you can do your changes &#34;blindly&#34; and preview them at DAutoTest. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Phantom Zone&lt;/p&gt; &#xA;&lt;h2&gt;#+begin_src text :tangle no This PR entered the Phantom Zone&lt;/h2&gt; &#xA;&lt;p&gt;This PR has entered the &lt;a href=&#34;http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org&#34;&gt;Phantom Zone&lt;/a&gt; as it still needs to have the reviewers&#39; concerns addressed and rebased.&lt;/p&gt; &#xA;&lt;h2&gt;Reason for entering the Phantom Zone&lt;/h2&gt; &#xA;&lt;p&gt;This PR is nice, and normally I would revive such a PR if the author was no longer active. I would also revive it if it were an important bug fix or something of higher priority. This PR, however, is just a refactoring, so I&#39;m going to put it in the &lt;a href=&#34;http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org&#34;&gt;Phantom Zone&lt;/a&gt; and close it for now.&lt;/p&gt; &#xA;&lt;h2&gt;How do I get this PR out of the Phantom Zone&lt;/h2&gt; &#xA;&lt;p&gt;Easy: Address the comments -&amp;gt; open a new PR (mention this one + short summary in the description). #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Releases&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can create a release to package software, along with release notes and links to binary files, for other people to use.&lt;/p&gt; &#xA;&lt;p&gt;Releases are based on &lt;em&gt;Git tags&lt;/em&gt;: tags are used to mark &lt;em&gt;release&lt;/em&gt; versions, with the &lt;em&gt;version number&lt;/em&gt; as the &lt;em&gt;tag name&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We recommend naming tags that fit within [[https://semver.org/][semantic versioning]], i.e. having the form &lt;del&gt;v&#xA;  &lt;major&gt;&#xA;   .&#xA;   &lt;minor&gt;&#xA;    .&#xA;    &lt;patch&gt;&lt;/patch&gt;&#xA;   &lt;/minor&gt;&#xA;  &lt;/major&gt;&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Major&lt;/em&gt; release (from &lt;del&gt;v0.8.1&lt;/del&gt; to &lt;del&gt;v1.0.0&lt;/del&gt;) for bug fixes and new features that break backwards compatibility,&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Minor&lt;/em&gt; release (from &lt;del&gt;v0.8.1&lt;/del&gt; to &lt;del&gt;v0.9.0&lt;/del&gt;) for bug fixes and new features that maintain backwards compatibility, and&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Patch&lt;/em&gt; release (from &lt;del&gt;v0.8.1&lt;/del&gt; to &lt;del&gt;v0.8.2&lt;/del&gt;) only for bug fixes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://stackoverflow.com/questions/21639437/git-flow-release-branches-and-tags-with-or-without-v-prefix&#34;&gt;https://stackoverflow.com/questions/21639437/git-flow-release-branches-and-tags-with-or-without-v-prefix&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;#+begin_note It&#39;s common practice to prefix your version names with the letter &lt;del&gt;v&lt;/del&gt;. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;Tag and push changes to the repository:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git release VERSION # Release a new version of your project. release = &#34;!f() { &lt;br&gt; git tag -a v$1 -m &#34;Release version $1&#34; &lt;br&gt; &amp;amp;&amp;amp; git push $(git origin) --tags &lt;br&gt; &amp;amp;&amp;amp; git push $(git origin); &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git manifest # Print a list of version controlled files for the current revision. manifest = ls-files #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipelines&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Testing.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Check if any file in repo has whitespace errors # As described in &lt;a href=&#34;http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git/&#34;&gt;http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git/&lt;/a&gt; check-whitespace = diff-tree --check $(git hash-object -t tree /dev/null) HEAD whitespace-violations = &#34;!git diff --check $(git hash-object -t tree /dev/null)&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Check if any file in repo has windows line endings&#xA;# Currently do not work as alias, works from comand line directly. There is a problem with \r&#xA;check-eol = grep --files-with-matches $&#39;\\r&#39; HEAD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Deployments (to different environments)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf rsync-deploy = #+end_src&lt;/p&gt; &#xA;&lt;p&gt;(see structure of actions in BitBucket)&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://bitbucket.org/blog/wordpress-continuous-deployment&#34;&gt;https://bitbucket.org/blog/wordpress-continuous-deployment&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf&lt;/p&gt; &#xA;&lt;h1&gt;Deploy a branch to review server (&lt;a href=&#34;https://review-feature-1.example.com&#34;&gt;https://review-feature-1.example.com&lt;/a&gt;).&lt;/h1&gt; &#xA;&lt;p&gt;deploy-review =&lt;/p&gt; &#xA;&lt;h1&gt;Deploy master to staging server (&lt;a href=&#34;https://staging.example.com&#34;&gt;https://staging.example.com&lt;/a&gt;).&lt;/h1&gt; &#xA;&lt;p&gt;deploy-staging =&lt;/p&gt; &#xA;&lt;h1&gt;Deploy master to production server (&lt;a href=&#34;https://example.com&#34;&gt;https://example.com&lt;/a&gt;).&lt;/h1&gt; &#xA;&lt;p&gt;deploy-prod =&lt;/p&gt; &#xA;&lt;h1&gt;# Deploy&lt;/h1&gt; &#xA;&lt;h1&gt;staging = !git push heroku-staging $(git current-branch):master -f &amp;amp;&amp;amp; git track &#39;Deployed to staging &#39; # push current branch to staging, can add more comments after&lt;/h1&gt; &#xA;&lt;h1&gt;dev = !git push heroku-dev $(git current-branch):master -f &amp;amp;&amp;amp; git track &#39;Deployed to dev &#39; # push current branch to dev&lt;/h1&gt; &#xA;&lt;h1&gt;deploy = !git push heroku $(git current-branch):master -f &amp;amp;&amp;amp; git track &#39;Deployed to production &#39; # push current branch to production&lt;/h1&gt; &#xA;&lt;h1&gt;shipit = push heroku master&lt;/h1&gt; &#xA;&lt;h1&gt;deploy=&#39;git push production master &amp;amp;&amp;amp; terminal-notifier-notify -title &#34;Deploy&#34; -message &#34;Deploy complete&#34;&#39;&lt;/h1&gt; &#xA;&lt;h1&gt;stage=&#39;git push staging $(git current-branch):master&#39;&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Issues&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Status (and status values that are allowed on a ticket).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Open&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;New&lt;/li&gt; &#xA;   &lt;li&gt;Accepted&lt;/li&gt; &#xA;   &lt;li&gt;Test&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Closed&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Invalid&lt;/li&gt; &#xA;   &lt;li&gt;Closed&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Create Issue&lt;/p&gt; &#xA;&lt;p&gt;Open an issue in the current repository:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enter a summary&lt;/li&gt; &#xA; &lt;li&gt;Write an optional description&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf&lt;/p&gt; &#xA;&lt;h1&gt;title&lt;/h1&gt; &#xA;&lt;h1&gt;description&lt;/h1&gt; &#xA;&lt;h1&gt;assignee&lt;/h1&gt; &#xA;&lt;h1&gt;kind&lt;/h1&gt; &#xA;&lt;h1&gt;priority&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;create-issue = XXX&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Issue template:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src text :tangle .issue_template.txt&lt;/p&gt; &#xA;&lt;h3&gt;Expected behavior&lt;/h3&gt; &#xA;&lt;h3&gt;Actual behavior&lt;/h3&gt; &#xA;&lt;h3&gt;Steps to reproduce the behavior&lt;/h3&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/devspace/awesome-github-templates&#34;&gt;https://github.com/devspace/awesome-github-templates&lt;/a&gt; and &lt;a href=&#34;https://jwong.co.uk/blog/2018/09/01/useful-github-features/#emoji-organising&#34;&gt;https://jwong.co.uk/blog/2018/09/01/useful-github-features/#emoji-organising&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Create Pull Requests&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf create-issue-pull-request = XXX #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Title of pull request:&lt;/p&gt; &#xA;&lt;p&gt;: WIP: Resolve &#34;Title of issue&#34;&lt;/p&gt; &#xA;&lt;p&gt;Once merged:&lt;/p&gt; &#xA;&lt;p&gt;: Resolve &#34;Title of issue&#34;&lt;/p&gt; &#xA;&lt;p&gt;** List All Issues&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://blog.bennycornelissen.nl/post/github-from-your-terminal/&#34;&gt;https://blog.bennycornelissen.nl/post/github-from-your-terminal/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # issues = &#34;!f() { USER_NAME=$1; &lt;br&gt; # curl --user $USER_NAME &lt;br&gt; # &lt;a href=&#34;https://api.bitbucket.org/2.0/repositories/$(git&#34;&gt;https://api.bitbucket.org/2.0/repositories/$(git&lt;/a&gt; repo-owner)/$(git repo-slug)/issues &lt;br&gt; # | jq -C --compact-output &#39;.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]&#39; &lt;br&gt; # | sed -r &#39;s/(....)-(..)-(..)T(..):(..):(..).(............)/\1-\2-\3/g&#39; &lt;br&gt; # | sed &#34;s/new/NEW/&#34; &lt;br&gt; # | sed &#34;s/NEW/$(tput setaf 2) -- NOUVEAU -- $(tput sgr0)/&#34; &lt;br&gt; # | sed &#34;s/NEW/$(tput setaf 3) -NOUV- $(tput sgr0)/&#34; &lt;br&gt; # | sed &#34;s/open/OPEN/&#34; &lt;br&gt; # | sed &#34;s/closed/CLOSED/&#34;; }; f&#34;&lt;/p&gt; &#xA;&lt;h1&gt;--data-urlencode &#39;priority &amp;gt;= &#34;major&#34;&#39;&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no issues = &#34;!f() { &lt;br&gt; USER_NAME=$1; &lt;br&gt; curl --user $USER_NAME &#39;&lt;a href=&#34;https://api.bitbucket.org/2.0/repositories/$(git&#34;&gt;https://api.bitbucket.org/2.0/repositories/$(git&lt;/a&gt; repo-owner)/$(git repo-slug)/issues?pagelen=100&#39; &lt;br&gt; | jq --compact-output &#39;.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]&#39; &lt;br&gt; | sed &#34;s#&#34;open&#34;#$(tput setaf 2)&amp;amp;$(tput sgr0)#&#34; &lt;br&gt; | sed &#34;s#&#34;closed&#34;#$(tput setaf 1)&amp;amp;$(tput sgr0)#&#34;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Set color to red or green, depending on issue state.&lt;/p&gt; &#xA;&lt;p&gt;: # Works! Need to put quotes around the URL! : curl -u $USER_NAME -X GET &#39;&lt;a href=&#34;https://api.bitbucket.org/2.0/repositories/$(git&#34;&gt;https://api.bitbucket.org/2.0/repositories/$(git&lt;/a&gt; repo-owner)/$(git repo-slug)/issues?pagelen=100&#39; &lt;br&gt; : | jq --compact-output &#39;.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]&#39; : # curl -s -S&lt;/p&gt; &#xA;&lt;p&gt;See also [[https://cran.r-project.org/web/packages/jsonlite/vignettes/json-apis.html][Fetching JSON data from Github REST API]].&lt;/p&gt; &#xA;&lt;p&gt;** List Open Issues&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf issues-open = !git issues | grep &#34;open&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** List My Issues (assigned to me)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf issues-assigned-to-me = !git issues | grep &#34;$(git config --get user.name)&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** List Issues I&#39;ve created&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf issues-created-by-me = XXX #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Show Issue&lt;/p&gt; &#xA;&lt;p&gt;Show an existing issue specified by NUMBER.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf show-issue = XXX #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Open Issues in a web browser&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf browse-issues = &#34;!f() { &lt;br&gt; URL=$(git config --get remote.$(git origin).url); &lt;br&gt; xdg-open ${URL/.git}/issues/$1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Jira tickets. issues = &#34;!f() { &lt;br&gt; : git log; &lt;br&gt; echo &#39;Printing issue keys&#39;; &lt;br&gt; git log $@ &lt;br&gt; | egrep -o [A-Z]+-[0-9]+ &lt;br&gt; | sort -u; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Wiki&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf browse-wiki = &#34;!f() { &lt;br&gt; URL=$(git config --get remote.$(git origin).url); &lt;br&gt; xdg-open ${URL/.git}/wiki; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Downloads&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Download repository, tag or branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Put everything in the current repo in a Zip archive. download-repository = &#34;!f() { &lt;br&gt; git archive ${1:-HEAD} --format=zip -o $(basename $(git root))-commit-$(git rev-parse ${1:-HEAD}).zip; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;h1&gt;XXX Test it with tag or branch.&lt;/h1&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Repository settings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** SSH keys&lt;/p&gt; &#xA;&lt;p&gt;List the user&#39;s public SSH keys:&lt;/p&gt; &#xA;&lt;p&gt;: # For GitHub. : curl -O &lt;a href=&#34;https://github.com/fniessen.keys&#34;&gt;https://github.com/fniessen.keys&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;: # For BitBucket. : curl &lt;a href=&#34;https://api.bitbucket.org/2.0/users/fniessen/ssh-keys&#34;&gt;https://api.bitbucket.org/2.0/users/fniessen/ssh-keys&lt;/a&gt; | jq &#39;.values&#39;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &#xA;  &lt;hr&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run on All repositories&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The biggest use I get out of this alias is making sure I have everything committed. Sometimes I&#39;ll work on a project and then forget about it for a little while without committing. When I want to double-check that I&#39;m not forgetting anything, I run &lt;del&gt;git bulk status --short&lt;/del&gt; to quickly scan which repos have uncommitted changes that I need to take care of.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf print-repo-name-then-run = &#34;!f() { &lt;br&gt; echo &#34;=======&#34;; &lt;br&gt; basename $(git rev-parse --show-toplevel); &lt;br&gt; echo &#34;=======&#34;; &lt;br&gt; git &#34;$@&#34;; &lt;br&gt; echo; &lt;br&gt; echo; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Run commands for each repository in the current directory.&#xA;bulk = &#34;!f() { \&#xA;        ls -R -d */.git \&#xA;            | sed s,/.git,, \&#xA;            | xargs -I{} git -C {} print-repo-name-then-run &#34;$@&#34;; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;del&gt;git-repos&lt;/del&gt;: &lt;a href=&#34;http://osiux.com/2015-01-14-sincronizar-repositorios-git-repos.html&#34;&gt;http://osiux.com/2015-01-14-sincronizar-repositorios-git-repos.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;** SHOW - find all &#34;unpushed&#34; commits for all projects in a directory&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory&#34;&gt;https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf bulk-status = &#34;!for DIR in $(find . -name &#34;.git&#34;); do &lt;br&gt; echo &#34;\n*** Repository: $DIR ***&#34; &lt;br&gt; &amp;amp;&amp;amp; git --git-dir=$DIR --work-tree=$DIR/.. status | grep -q &#34;is ahead of&#34;; &lt;br&gt; done&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** git-pull-all-repos and git-push-all-repos&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git pull-all-repos # Pull the changes in all Git repositories of the current directory. pull-all-repos = !$HOME/bin/git-pull-all-repos #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git push-all-repos # Push the changes in all Git repositories of the current directory. push-all-repos = !$HOME/bin/git-push-all-repos #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sort out&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Define:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf exec = &#39;!exec &#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;so that you can do things like &lt;del&gt;git exec make&lt;/del&gt;. This works because Shell aliases are always executed in the top-level directory.&lt;/p&gt; &#xA;&lt;p&gt;Clean up your commits before publishing. Before you push your commits to the repository, it&#39;s good to revise them. You can run the git interactive rebase to squash your commits or modify commit messages. The goal is to publish only clean and relevant commits, no experiments or fixing typos.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Interactive rebase with the given number of latest commits ireb = &#34;!r() { git rebase -i HEAD~$1; }; r&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Start an interactive rebase of all the commits you haven&#39;t pushed # yet. Handy for collapsing a bunch of work-in-progress snapshots into # logical commits before pushing, without having to worry about accidentally # squashing a commit someone else has already referred to. work-in-progress = rebase -i @{u} #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** SHOW - Check the status of your files&lt;/p&gt; &#xA;&lt;p&gt;Give the status in the &lt;em&gt;short format&lt;/em&gt; (preceded by a line showing the /branch name/ and /tracking info/).&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf st = status -s -b #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In the following example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example M README M lisp/mail/rmail.el MM ChangeLog #+end_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=README= is changed and &lt;em&gt;staged for commit&lt;/em&gt; (it&#39;s &lt;em&gt;in the index&lt;/em&gt;),&lt;/li&gt; &#xA; &lt;li&gt;=lisp/mail/rmail.el= is changed but &lt;em&gt;not staged for commit&lt;/em&gt;, and&lt;/li&gt; &#xA; &lt;li&gt;=Changelog= is changed and staged for commit, then &lt;em&gt;changed again&lt;/em&gt; and the new change is &lt;em&gt;not staged for commit&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_note Staging for commit is typically done by &lt;del&gt;git add&lt;/del&gt;. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;** SHOW - View your changes&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Show the diff between the latest commit and the current state d = !&#34;git diff-index --quiet HEAD -- || clear; &lt;br&gt; git --no-pager diff --patch-with-stat&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# `git di $number&#39; shows the diff between the state `$number&#39; commits ago and the current state&#xA;di = &#34;!f() { git diff --patch-with-stat HEAD~$1; }; \&#xA;        git diff-index --quiet HEAD -- || clear; \&#xA;        f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Changes between the working tree and the index (staged for the next commit)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Ignore whitespace when comparing the same lines. This indicates empty # lines added or deleted. diff-ignore-whitespace = diff -w #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Diff line-wise. df = diff&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Diff word-wise.&#xA;dw = diff --color-words&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Configure git-diff to produce the absolutely most minimal diff possible. dw-min = diff -w --word-diff-regex=. --color-words -U0 precommit0 = diff --diff-algorithm=minimal -w #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Changes between the working tree and the latest commit (HEAD)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no diff-all = diff HEAD #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Changes between the index (staged for the next commit) and the latest commit (HEAD)&lt;/p&gt; &#xA;&lt;p&gt;Just before committing the &lt;em&gt;staged&lt;/em&gt; changes (about to be committed), check what your commit changes:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Diff staged line-wise. df-staged = diff --cached&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Diff staged word-wise.&#xA;dw-staged = diff --color-words --cached&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Precommit&lt;/p&gt; &#xA;&lt;p&gt;This is a key part of my workflow. I run this before every commit to make sure I don&#39;t need to use the undo commands.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf precommit = diff --diff-algorithm=minimal -w --cached #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** When was this file first committed&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf first-commit = &#34;!f() { &lt;br&gt; date=$(git log --all --follow --pretty=format:%ci -- $1 | tail -n 1); &lt;br&gt; echo &#34;$date&#34;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX Does not work on renamed files&lt;/p&gt; &#xA;&lt;p&gt;*** When was this file last updated&lt;/p&gt; &#xA;&lt;p&gt;Before using this, please &lt;em&gt;update all local branches&lt;/em&gt;, checking out each branch in succession.&lt;/p&gt; &#xA;&lt;p&gt;See script =git-update-all= at [[https://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches][Can &#34;git pull --all&#34; update all my local branches?]].&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # When was this file last updated, on each local branch. wwflu = &#34;!f() { &lt;br&gt; for BRANCH_NAME in $(git rev-parse --symbolic --branches); do &lt;br&gt; echo -e &#34;$(git log --decorate=no -1 &lt;br&gt; --format=&#34;%at:%C(green)%ad%C(reset) %C(yellow)%h%C(auto)%d%C(reset) %s %C(bold blue)&amp;lt;%an&amp;gt;%C(reset)&#34; &lt;br&gt; --color=always $BRANCH_NAME -- &#34;$1&#34;) On branch $(tput bold)$BRANCH_NAME$(tput sgr0)&#34;; &lt;br&gt; done &lt;br&gt; | sort -r; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;: | cut -f2 -d:; \&lt;/p&gt; &#xA;&lt;p&gt;*** Add only modified changes (and ignore untracked files)&lt;/p&gt; &#xA;&lt;p&gt;Ideally your =.gitignore= should prevent the untracked (and ignored) files from being shown in status, added using &lt;del&gt;git add&lt;/del&gt; etc. So correct your =.gitignore=.&lt;/p&gt; &#xA;&lt;p&gt;You can do &lt;del&gt;git add -u&lt;/del&gt; so that it will &lt;em&gt;stage&lt;/em&gt; the modified and deleted files.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf stage-modified-removed-files = add -u #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can also do &lt;del&gt;git commit -a&lt;/del&gt; to &lt;em&gt;commit&lt;/em&gt; only the modified and deleted files.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf wip = commit -a -m &#34;WIP&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** SHOW - View the commit history&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note The &lt;del&gt;git log&lt;/del&gt; command shows, by default, the &#34;author date&#34; -- not the &#34;committer date&#34;. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git ls # Print a summary of activity. Alias of log. ls = log #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX Check out &lt;a href=&#34;http://marcgg.com/blog/2015/08/04/git-first-parent-log/&#34;&gt;http://marcgg.com/blog/2015/08/04/git-first-parent-log/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;List commits &lt;em&gt;showing changed files&lt;/em&gt; (prettier and more concise version of &lt;del&gt;whatchanged&lt;/del&gt;):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf ll = log --pretty=medium --abbrev-commit --stat #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git last # Return the last commit on the current branch. last = log -1 --stat&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Usage: git lastn [N]&#xA;# Show the last N commits on the current branch.&#xA;lastn = &#34;!f() { \&#xA;        git show --name-only $(git rev-list -${1:-1} HEAD); \&#xA;    }; f&#34;&#xA;&#xA;# lastn2 = &#34;!f() { \&#xA;#         git log -${1:-1} --stat $(git rev-list -${1:-1} HEAD); \&#xA;#     }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;TODO: More information with lastn2 (for file renames), but missing newline after merge commits...&lt;/p&gt; &#xA;&lt;p&gt;*** Show the commit history of a file&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;List of commits&lt;/em&gt; that modified the &lt;em&gt;specified file&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git file-history FILE # Show commit history of a file (like BitBucket). file-history = log # file-history1 = log -- # file-history5 = &#34;!f() { git show -s $(git rev-list --date-order HEAD -- $1); }; f&#34; # file-history6 = !sh -c &#39;git show -s $(git rev-list --date-order HEAD -- $0)&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;That also will &lt;em&gt;print the /right/ merge commits&lt;/em&gt;, &lt;em&gt;like in BitBucket&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;: curl -u USER_NAME &#39;&lt;a href=&#34;https://api.bitbucket.org/2.0/repositories/REPO_OWNER/REPO_SLUG/filehistory/master/PATH/TO/FILE&#34;&gt;https://api.bitbucket.org/2.0/repositories/REPO_OWNER/REPO_SLUG/filehistory/master/PATH/TO/FILE&lt;/a&gt;&#39;&lt;/p&gt; &#xA;&lt;p&gt;This one will &lt;em&gt;follow renames and copies&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git file-history-follow-no-merges FILE # Show commit history of a file (with renames and copies, but without merge commits). file-history-follow-no-merges = log --follow --date-order -C #+end_src&lt;/p&gt; &#xA;&lt;p&gt;... but it &lt;em&gt;DOES NOT print merge commits&lt;/em&gt;!&lt;/p&gt; &#xA;&lt;p&gt;And adding &lt;del&gt;-m&lt;/del&gt; to show merge commits doesn&#39;t quite work -- it will show many, many, many /wrong/ (all?) merge commits.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note Merge commits in particular are very hard cases for &lt;del&gt;git log --follow&lt;/del&gt;, because they have two parents and one parent might have renamed the file. The rename detection and following code inside &lt;del&gt;git log&lt;/del&gt; is a quick hack... #+end_note&lt;/p&gt; &#xA;&lt;p&gt;Add &lt;del&gt;--all&lt;/del&gt; to show commits of /all your branches/, not just from the current branch:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git file-history-all FILE # Show commit history of a file in all branches. file-history-all = log --all # file-history-all1 = log --all -- # file-history-all5 = &#34;!f() { git show -s $(git rev-list --date-order --all HEAD -- $1); }; f&#34; # file-history-all6 = !sh -c &#39;git show -s $(git rev-list --date-order --all HEAD -- $0)&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Find the &lt;em&gt;most recent commit&lt;/em&gt; (chronologically) that modified a file -- looking in /all/ known commits:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git file-last-modified FILE # Show when file was last modified. file-last-modified = log -n 1 --all --date-order #+end_src&lt;/p&gt; &#xA;&lt;p&gt;List commits affecting a specific path and then get all the files modified in each commit:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git related FILE # Generate a list of which files changed together with a file. related = &#34;!f() { &lt;br&gt; git show --name-only $(git rev-list HEAD -- $1); &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;(see &lt;a href=&#34;https://stackoverflow.com/questions/42527378/git-get-the-list-of-files-that-have-been-modified-along-one-specific-file&#34;&gt;https://stackoverflow.com/questions/42527378/git-get-the-list-of-files-that-have-been-modified-along-one-specific-file&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git related-files FILE # Generate a list of which files changed together with a file. related-files = !sh -c &#39;git log --format=format:%H $0 &lt;br&gt; | xargs -L 1 git diff-tree --no-commit-id --name-only -r &lt;br&gt; | sort &lt;br&gt; | uniq -c &lt;br&gt; | sort -b -n -r &lt;br&gt; | less&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Inspect the commits for each edit&lt;/p&gt; &#xA;&lt;p&gt;: git log ... | xargs -n 1 git show&lt;/p&gt; &#xA;&lt;p&gt;** SHOW - Show blame information about original authors of lines changed or removed&lt;/p&gt; &#xA;&lt;p&gt;$ git blame -w # ignores white space $ git blame -M # ignores moving text $ git blame -C # ignores moving text into other files&lt;/p&gt; &#xA;&lt;p&gt;git blame -w README.md The -w option ignores whitespace changes. If a previous author has modified the spacing of a file by switching from tabs to spaces or adding new lines this, unfortunately, obscures the output of git blame by showing these changes.&lt;/p&gt; &#xA;&lt;p&gt;git blame -M README.md The -M option detects moved or copied lines within in the same file. This will report the original author of the lines instead of the last author that moved or copied the lines.&lt;/p&gt; &#xA;&lt;p&gt;git blame -C README.md The -C option detects lines that were moved or copied from other files. This will report the original author of the lines instead of the last author that moved or copied the lines.&lt;/p&gt; &#xA;&lt;p&gt;: git blame -L 1509,1511 lisp/ox-html.el&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf praise = blame -w archeology = blame -w -C -n #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Merge&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Given a merge commit, find the span of commits that exist(ed). # Not so useful in itself, but used by other aliases. # Thanks to Rob Miller for the merge-span-* aliaes. merge-span = &#34;!f() { &lt;br&gt; echo $(git log -1 --merges --pretty=format:%P $2 | cut -d&#39; &#39; -f1)$1$(git log -1 --merges --pretty=format:%P $2 | cut -d&#39; &#39; -f2); &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Find the commits that were introduced by a merge&#xA;merge-span-log = &#34;!f() { \&#xA;        git log $(git merge-span .. $1); \&#xA;    }; f&#34;&#xA;&#xA;# Show the changes that were introduced by a merge&#xA;merge-span-diff = &#34;!f() { \&#xA;        git diff $(git merge-span ... $1); \&#xA;    }; f&#34;&#xA;&#xA;# Show the changes that were introduced by a merge, in your difftool&#xA;merge-span-difftool = &#34;!f() { \&#xA;        git difftool $(git merge-span ... $1); \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** UPDATE - Pull&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Show a list of existing remotes (with URL). r = remote -v #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note &lt;del&gt;git pull&lt;/del&gt; is simply &lt;del&gt;git fetch &amp;amp;&amp;amp; git merge remote&lt;/del&gt;. Its &lt;del&gt;--rebase&lt;/del&gt; option uses &lt;del&gt;rebase&lt;/del&gt; instead of &lt;del&gt;merge&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s exactly why some decide to avoid &lt;del&gt;rebase&lt;/del&gt; (but to &lt;del&gt;pull&lt;/del&gt; instead), because it has bad effects if one merges from another branch and then wants to push. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;About rebase (with visual aid): &lt;a href=&#34;https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395&#34;&gt;https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Show incoming changes&lt;/p&gt; &#xA;&lt;p&gt;The &lt;del&gt;incoming&lt;/del&gt; command returns a list of &lt;em&gt;incoming&lt;/em&gt; commits for the &lt;em&gt;current branch&lt;/em&gt; -- after a &lt;del&gt;git fetch&lt;/del&gt;, to fetch down &lt;em&gt;all the data&lt;/em&gt; it has for the &lt;em&gt;current remote&lt;/em&gt; that you do not --, the next time you do a merge.&lt;/p&gt; &#xA;&lt;p&gt;What was going on, while you were away?&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git incoming # Show new commits found in the remote repository. incoming = !(git remote update -p &lt;br&gt; &amp;amp;&amp;amp; git log ..@{u}) # TODO: git fetch, instead? # TODO: Add optional argument BRANCH_NAME, and delete alias incoming-on-branch&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;incoming&#39;.&#xA;in = !git incoming&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Show log of new commits after you fetched, with stats, excluding merges log-fresh = log --no-merges --stat ORIG_HEAD.. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_tip Starting with Git 1.7.0, &lt;del&gt;@{u}&lt;/del&gt; is shorthand for the &lt;em&gt;current&lt;/em&gt; branch&#39;s &lt;em&gt;upstream&lt;/em&gt; branch; e.g., &lt;del&gt;origin/foo&lt;/del&gt; (or &lt;del&gt;github/foo&lt;/del&gt;, etc., since the remote doesn&#39;t have to be called &lt;del&gt;origin&lt;/del&gt;) if the checked out branch is &lt;del&gt;foo&lt;/del&gt;. #+end_tip&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git incoming-on-branch BRANCH_NAME # Show new commits found in the remote repository. # Example: git incoming-on-branch master incoming-on-branch = !sh -c &#39;git fetch&#39; &lt;br&gt; &amp;amp;&amp;amp; git log ..$(git origin)/$1 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git who-is-changing-branch BRANCH_NAME who-is-changing-branch = !sh -c &#39;git shortlog HEAD..$(git origin)/$0&#39; # TODO: Add fetch? #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Show a &lt;em&gt;single diffstat&lt;/em&gt; (number of added and deleted lines for &lt;em&gt;all changed files&lt;/em&gt;):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf incoming-files = !(git remote update -p &lt;br&gt; &amp;amp;&amp;amp; git diff --stat ...@{u})&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;incoming-files&#39;.&#xA;in-files = !git incoming-files&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning The upstream diff &lt;del&gt;in-what&lt;/del&gt; will show the negative of unpushed (rebased) commits, if any, with the &lt;del&gt;..&lt;/del&gt; notation --- not with the &lt;del&gt;...&lt;/del&gt; notation! #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;Show the changes between the last local commit and the &lt;em&gt;remote&lt;/em&gt; branch:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf incoming-diff = diff @{u} HEAD # diff with upstream branch #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Update with local modifications&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf pull = pull -v #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note &lt;del&gt;git pull&lt;/del&gt; with uncommitted changes can succeed if the newly pulled changes don&#39;t touch the locally changed files, but will fail otherwise. Which makes a lot of sense. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;Git&#39;s fix is to ask you to commit (or stash) before you pull (which is fetch followed by merge).&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # up = &#34;!git stash &amp;amp;&amp;amp; git pull &amp;amp;&amp;amp; git stash pop&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning The above approach is &lt;em&gt;unsafe&lt;/em&gt;: if there&#39;s nothing to stash, the first command will do nothing, and then &lt;del&gt;stash pop&lt;/del&gt; will unstash some random stuff from before. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git pull-autostash # Create a temporary stash before pulling, and apply it after the pull. pull-autostash = ![ -z &#34;$(git status --porcelain -uno)&#34; ] &lt;br&gt; &amp;amp;&amp;amp; git pull &lt;br&gt; || git stash push -m &#34;autostash&#34; &lt;br&gt; &amp;amp;&amp;amp; git pull &lt;br&gt; &amp;amp;&amp;amp; git stash pop #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX What about &lt;del&gt;git stash push --include-untracked&lt;/del&gt; and &lt;del&gt;git stash pop&lt;/del&gt;?&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf up = pull --rebase --autostash up = !git fetch &amp;amp;&amp;amp; git rebase --autostash FETCH_HEAD up= &#34;!git fetch $(git origin) &amp;amp;&amp;amp; git branch -v -a&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;f = !git fetch --all \&#xA;        &amp;amp;&amp;amp; git rebase $(git origin)/master&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://www.praqma.com/stories/git-autostash/&#34;&gt;https://www.praqma.com/stories/git-autostash/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;: git rebase -i --autosquash --autostash&lt;/p&gt; &#xA;&lt;p&gt;Really handy in projects that don&#39;t do merge commits.&lt;/p&gt; &#xA;&lt;p&gt;*** Git up all branches&lt;/p&gt; &#xA;&lt;p&gt;See [[http://aanandprasad.com/git-up/][git-up]] (no longer maintained), which is (roughly) equivalent of executing the following:&lt;/p&gt; &#xA;&lt;p&gt;: git stash : git fetch --all : [foreach branch] : git rebase --rebase-merges &#xA; &lt;branch&gt; &#xA;  &lt;remote&gt;&#xA;   /&#xA;   &lt;branch&gt;&#xA;     : git merge --ff-only &#xA;    &lt;branch&gt;&#xA;      : [end foreach] : git checkout &amp;lt;prev_branch&amp;gt; : git stash pop&#xA;    &lt;/branch&gt;&#xA;   &lt;/branch&gt;&#xA;  &lt;/remote&gt;&#xA; &lt;/branch&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning Use with care: the final stash application after a successful rebase might result in non-trivial conflicts. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;*** Pull&lt;/p&gt; &#xA;&lt;p&gt;Before doing work (in a new branch), &lt;em&gt;ensure that the working tree is&lt;/em&gt; &lt;em&gt;up-to-date&lt;/em&gt; with the &lt;del&gt;origin&lt;/del&gt; (pull and get latest for all submodules):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Get everything new. update = !git pull &amp;amp;&amp;amp; git submodule update --init --recursive get = !git pull --rebase &amp;amp;&amp;amp; git submodule update --init --recursive update = !git pull --rebase --prune $@ &amp;amp;&amp;amp; git submodule update --init --recursive&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Pull in remote changes for the current repository and all its submodules&#xA;p = !&#34;git pull; git submodule foreach git pull $(git origin) master&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;[[https://gist.github.com/gitaarik/8735255][Git Submodules basic explanation]]&lt;/p&gt; &#xA;&lt;p&gt;*** Update all local branches&lt;/p&gt; &#xA;&lt;p&gt;Pull all:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Do a push/pull for just one branch. push-1 = &#34;!git push $(git origin) $(git current-branch)&#34; pull-1 = &#34;!git pull $(git origin) $(git current-branch)&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Pull and push from the current branch.&#xA;sync = &#34;!f() { pull-1 &amp;amp;&amp;amp; push-1; }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf pull-all = !&#34;OLD_BRANCH=$(git current-branch); &lt;br&gt; for BRANCH_NAME in $(git for-each-ref refs/heads --format=&#39;%(refname)&#39;); do &lt;br&gt; git checkout ${BRANCH_NAME#refs/heads/}; &lt;br&gt; git pull --ff-only; &lt;br&gt; done; &lt;br&gt; git checkout $OLD_BRANCH&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches&#34;&gt;http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches&lt;/a&gt; (+ interesting comments about &lt;em&gt;rebase vs merge during a pull&lt;/em&gt;!)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell :tangle bin/git-up-all :shebang #!/usr/bin/env bash REMOTES=&#34;$@&#34;; if [ -z &#34;$REMOTES&#34; ]; then REMOTES=$(git remote); fi REMOTES=$(echo &#34;$REMOTES&#34; | xargs -n 1 echo)&lt;/p&gt; &#xA;&lt;p&gt;CLB=$(git branch -l | awk &#39;/^*/{print $2}&#39;);&lt;/p&gt; &#xA;&lt;p&gt;echo &#34;$REMOTES&#34; | while read REMOTE; do git remote update --prune $REMOTE echo git remote show $REMOTE -n &lt;br&gt; | awk &#39;/merges with remote/ {print $5&#34; &#34;$1}&#39; &lt;br&gt; | while read LINE; do RB=$(echo &#34;$LINE&#34; | cut -f1 -d&#34; &#34;); ARB=&#34;refs/remotes/$REMOTE/$RB&#34;; LB=$(echo &#34;$LINE&#34; | cut -f2 -d&#34; &#34;); ALB=&#34;refs/heads/$LB&#34;; NBEHIND=$(( $(git rev-list --count $ALB..$ARB 2&amp;gt; /dev/null) + 0)); NAHEAD=$(( $(git rev-list --count $ARB..$ALB 2&amp;gt; /dev/null) + 0)); if [ &#34;$NBEHIND&#34; -gt 0 ]; then if [ &#34;$NAHEAD&#34; -gt 0 ]; then echo -e &#34;[$LB \tis $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $REMOTE/$RB.] Not possible to fast-forward, aborting.&#34;; elif [ &#34;$LB&#34; = &#34;$CLB&#34; ]; then echo -e &#34;[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB. Fast-forwarding merge...]&#34;; # git merge --quiet $ARB; git merge --ff-only --verbose $ARB; else echo -e &#34;[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB. Resetting local branch to remote...]&#34;; # git branch -l -f $LB -t $ARB &amp;gt; /dev/null; git branch -l -f $LB -t $ARB; fi else echo -e &#34;$LB \tAlready up to date.&#34;; fi echo done done #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX Is this &lt;del&gt;sync&lt;/del&gt;?&lt;/p&gt; &#xA;&lt;p&gt;*** Get timestamp of last pull&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # For the latest pull (even if there&#39;s nothing new). last-pulled = !stat -c %y $(git root)/.git/FETCH_HEAD &lt;br&gt; | cut -d&#39;.&#39; -f1&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# For the latest pull resulting in changes coming in from the remote master&#xA;# branch (the timestamp won&#39;t change when git pull reports there are no&#xA;# changes).&#xA;last-updated = !stat -c %y $(git root)/.git/refs/heads/$(git current-branch) \&#xA;                    | cut -d&#39;.&#39; -f1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** UPDATE - Merge&lt;/p&gt; &#xA;&lt;p&gt;Merging means to &lt;em&gt;bring the contents of another branch&lt;/em&gt; (possibly from an external repository) &lt;em&gt;into the current branch&lt;/em&gt;. [...] Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together.&lt;/p&gt; &#xA;&lt;p&gt;: Merge branch &#39;BRANCH_NAME&#39; into master&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Will only try to &#34;merge&#34; if your current HEAD commit is in the branch # you&#39;re merging in. This will allow you to merge some commits whilst being # sure you won&#39;t get conflicts. mff = merge --ff-only mff = merge --ff-only @{u}&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Avoid a fast-forward commit.&#xA;mnf = merge --no-ff&#xA;mnf2 = merge --no-ff --log&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Sync branch (merge master into your branch)&lt;/p&gt; &#xA;&lt;p&gt;If a feature branch hasn&#39;t been touched in months, and is behind the main branch, you can sync (merge) the branch with the main branch, to &lt;em&gt;catch your branch up&lt;/em&gt; to all the latest changes on the main branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git sync-branch # Merge remote master into the current branch. sync-branch = !git fetch -p &lt;br&gt; &amp;amp;&amp;amp; git merge $(git origin)/master #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Catch up those random feature branches you haven&#39;t had to touch in months. catchup = !git fetch -p &lt;br&gt; &amp;amp;&amp;amp; git rebase $(git origin)/master #+end_src&lt;/p&gt; &#xA;&lt;p&gt;With &lt;em&gt;all versions&lt;/em&gt; of Git, I recommend using &lt;del&gt;git up&lt;/del&gt; instead of &lt;del&gt;git pull&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf up-tmpname = &#34;!f() { &lt;br&gt; git remote update -p; &lt;br&gt; git merge --ff-only @{u}; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;It is pretty safe: it will abort the merge if it can&#39;t be done using fast-forward. (In other words, if the local branch has diverged from the remote.)&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful&#34;&gt;https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;remote update -p&lt;/del&gt; &lt;em&gt;fetches&lt;/em&gt; all refs from all remotes, instead of just the needed one; &lt;del&gt;merge&lt;/del&gt; then merges the appropriate &lt;em&gt;single branch&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Rebasing non-linear changes (when the fast-forward merge is not possible). upr = &#34;!f() { &lt;br&gt; git remote update -p; &lt;br&gt; git rebase -p @{u}; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;... but read &#34;you&#39;re not using Git as it was intended&#34; on &lt;a href=&#34;https://news.ycombinator.com/item?id=2301765&#34;&gt;https://news.ycombinator.com/item?id=2301765&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;*** Merge current branch into another one&lt;/p&gt; &#xA;&lt;p&gt;Merge strategy:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Merge commit: git merge --no-ff&lt;/li&gt; &#xA; &lt;li&gt;Squash: git merge --squash&lt;/li&gt; &#xA; &lt;li&gt;Fast forward: git merge --ff-only&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf merge-into-master = &#34;!f() { &lt;br&gt; OLD_BRANCH=&#34;$(git symbolic-ref HEAD 2&amp;gt;/dev/null)&#34; || OLD_BRANCH=&#34;(unnamed branch)&#34;; &lt;br&gt; OLD_BRANCH=${OLD_BRANCH##refs/heads/}; &lt;br&gt; git checkout master &lt;br&gt; &amp;amp;&amp;amp; git merge $OLD_BRANCH &lt;br&gt; &amp;amp;&amp;amp; git checkout $OLD_BRANCH; &lt;br&gt; };f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;On projects where we work with a staging or test branch, I regularly merge my work in progress into it so others can test it.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf m = &#34;!f() { &lt;br&gt; local OLD_BRANCH=$(git current-branch); &lt;br&gt; git checkout &#34;$1&#34; &lt;br&gt; &amp;amp;&amp;amp; git pull &lt;br&gt; &amp;amp;&amp;amp; git merge $OLD_BRANCH &lt;br&gt; &amp;amp;&amp;amp; git push &lt;br&gt; &amp;amp;&amp;amp; git checkout $OLD_BRANCH; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you now type &lt;del&gt;git m staging&lt;/del&gt; while on the &lt;del&gt;feature&lt;/del&gt; branch, this will happen:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;First, the function checks out the &lt;del&gt;staging&lt;/del&gt; branch.&lt;/li&gt; &#xA; &lt;li&gt;It then pulls the latest changes to the &lt;del&gt;staging&lt;/del&gt; branch from origin.&lt;/li&gt; &#xA; &lt;li&gt;Then it merges &lt;del&gt;feature&lt;/del&gt; into &lt;del&gt;staging&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Next, it pushes the updated &lt;del&gt;staging&lt;/del&gt; branch back to origin.&lt;/li&gt; &#xA; &lt;li&gt;Finally, it checks out the &lt;del&gt;feature&lt;/del&gt; branch again.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Such a timesaver!&lt;/p&gt; &#xA;&lt;p&gt;*** Undo the merge&lt;/p&gt; &#xA;&lt;p&gt;If you tried a merge which resulted in complex conflicts and want to start over, you can recover with &lt;del&gt;git merge --abort&lt;/del&gt;. It will allow you to &lt;em&gt;undo the merge&lt;/em&gt;, even if it is a fast-forward merge.&lt;/p&gt; &#xA;&lt;p&gt;*** Dry run (do not make changes)&lt;/p&gt; &#xA;&lt;p&gt;Naive (but slow) way:&lt;/p&gt; &#xA;&lt;p&gt;: rm -Rf /tmp/repository : cp -r repository /tmp/ : cd /tmp/repository : git merge ... : # ... If successful, do the real merge.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning It won&#39;t work just cloning to =/tmp=; you need a &lt;em&gt;copy&lt;/em&gt; in order &lt;em&gt;to be sure that uncommitted changes will not conflict&lt;/em&gt;. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;Performing a Git merge with &lt;em&gt;no commit&lt;/em&gt; and &lt;em&gt;no fast-forward&lt;/em&gt; will merge the two code bases together -- it will &lt;em&gt;modify your working copy&lt;/em&gt;. This will allow you to examine, test, and undo the merge if required.&lt;/p&gt; &#xA;&lt;p&gt;: git merge --no-commit --no-ff BRANCH_NAME&lt;/p&gt; &#xA;&lt;p&gt;You can do &lt;del&gt;git merge --abort&lt;/del&gt; after seeing that there are conflicts.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Run merge test (before merge) to check for any conflicts beforehand. merge-test = &#34;!f() { &lt;br&gt; git merge --no-commit --no-ff &#34;$1&#34;; &lt;br&gt; git merge --abort; &lt;br&gt; echo &#34;Merge aborted&#34;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning If your repository is a live Web server, then you could be serving files with conflicts in. That&#39;s why you should &lt;em&gt;never&lt;/em&gt; be &lt;em&gt;handling merges on a live Web server&lt;/em&gt;! Fix up the &lt;del&gt;master&lt;/del&gt; branch (on your development box) and then push it to the real webserver with &lt;del&gt;git pull --ff-only&lt;/del&gt;. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;See if the merge is applicable to the current working tree and/or the index file and &lt;em&gt;detects conflicts&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git merge-dry-run BRANCH_NAME # Check how the merge of BRANCH_NAME into master will go merge-dry-run = &#34;!f() { &lt;br&gt; grep -q &#39;changed in both&#39; &amp;lt;&amp;lt;&amp;lt; $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) &lt;br&gt; &amp;amp;&amp;amp; echo &#39;Merge conflicts!&#39; &lt;br&gt; || echo &#39;This branch can be automatically merged.&#39;; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;h1&gt;DOESN&#39;T work for git fetch &amp;amp; git merge&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Extract the &#34;changed in both&#34; lines as well as the conflicting parts.&#xA;merge-dry-run-conflicts = &#34;!f() { \&#xA;        git merge-tree $(git merge-base $1 $2) $1 $2 \&#xA;            | sed -n &#39;/+&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; .our/,/+&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}&#39; \&#xA;            | cdiff; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Branch/Integration manager&lt;/p&gt; &#xA;&lt;p&gt;Often, during a &lt;em&gt;merge&lt;/em&gt;, you know you want to take a file from one side wholesale; that is, to select the entirety of either our or their file.&lt;/p&gt; &#xA;&lt;p&gt;Pick a file(s) from:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the &lt;em&gt;current branch&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf ours = &#34;!f() { &lt;br&gt; git checkout --ours $@ &lt;br&gt; &amp;amp;&amp;amp; git add $@; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the &lt;em&gt;branch being merged in&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf theirs = &#34;!f() { &lt;br&gt; git checkout --theirs $@ &lt;br&gt; &amp;amp;&amp;amp; git add $@; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning During a &lt;em&gt;rebase&lt;/em&gt;, the commits being merged into the current branch /are/ the commits from your original feature branch. So &lt;del&gt;--ours&lt;/del&gt; and &lt;del&gt;--theirs&lt;/del&gt; will appear to be &lt;em&gt;flipped&lt;/em&gt; around. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note Using &lt;del&gt;git checkout&lt;/del&gt; with &lt;del&gt;--ours&lt;/del&gt; or &lt;del&gt;--theirs&lt;/del&gt; expects at least one argument: the &lt;em&gt;path(s)&lt;/em&gt; of the &lt;em&gt;files / directories&lt;/em&gt; to checkout. If you use &lt;del&gt;git checkout&lt;/del&gt; without any files, then it takes the meaning of /switching branches/. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Best (and safest) way to merge&lt;/em&gt; a Git local branch into =master=:&lt;/p&gt; &#xA;&lt;p&gt;: git checkout master : git pull $(git origin) master # Get the latest changes from the remote. : git merge test : git push $(git origin) master : : git delete-local-branch BRANCH_NAME # Delete local branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_warning &lt;em&gt;Update first the branch (to merge in) of the RIGHT LOCAL CLONE.&lt;/em&gt; -- if you do have many clones on your file system. #+end_warning&lt;/p&gt; &#xA;&lt;p&gt;Best answer I have seen on &lt;del&gt;git merge&lt;/del&gt; &lt;em&gt;strategies&lt;/em&gt;: &lt;a href=&#34;https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies&#34;&gt;https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Show list of files in a conflict state&lt;/p&gt; &#xA;&lt;p&gt;List unmerged files (after a merge failure), having leftover conflict markers:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git conflicts # List files with conflicts. conflicts = diff --name-only --diff-filter=U #+end_src&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;del&gt;git diff --check&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Quickly solve conflicts using an editor.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf edit-unmerged = &#34;!$EDITOR $(git conflicts)&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then, add the conflicted files.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf add-unmerged = &#34;!git add $(git conflicts)&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** BRANCH - Branch&lt;/p&gt; &#xA;&lt;p&gt;*** Feature Branches&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Create a feature branch. feature = &#34;!f() { &lt;br&gt; git create-branch feature/$1 develop; &lt;br&gt; }; f&#34; # XXX or feature-start?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Incorporate a finished feature on develop.&#xA;feature-finish = &#34;!f() { \&#xA;        git checkout develop; \&#xA;        git merge --no-ff feature/$1 \&#xA;            &amp;amp;&amp;amp; git delete-local-branch feature/$1; \&#xA;    }; f&#34;&#xA;&#xA;# XXX Also bug and refactor.&#xA;&#xA;# XXX release-start&#xA;# XXX release-finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://medium.com/gumgum-tech/git-and-git-flow-a-guide-871d46a0ebcb&#34;&gt;https://medium.com/gumgum-tech/git-and-git-flow-a-guide-871d46a0ebcb&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias configuration for our feature branches, like a simple Git flow for feature stories, or hotfix patches, etc.&lt;/p&gt; &#xA;&lt;p&gt;Create a new feature branch:&lt;/p&gt; &#xA;&lt;p&gt;: feature-start = &#39;!OLD_BRANCH=$1; git checkout master; git pull; git create-branch &#34;$OLD_BRANCH&#34; master&#39;&lt;/p&gt; &#xA;&lt;p&gt;Update the feature branch:&lt;/p&gt; &#xA;&lt;p&gt;: feature-pull = &#39;!OLD_BRANCH=$(git current-branch); git checkout master; git pull; git checkout &#34;$OLD_BRANCH&#34;; git rebase master&#39;&lt;/p&gt; &#xA;&lt;p&gt;Share the feature branch:&lt;/p&gt; &#xA;&lt;p&gt;: feature-push = &#39;!OLD_BRANCH=$(git current-branch); git push -u $(git origin) &#34;$OLD_BRANCH&#34;&#39;&lt;/p&gt; &#xA;&lt;p&gt;If your team uses a different feature flow, you may want to skip including these aliases, or you may want to edit these aliases to match your team&#39;s feature flow.&lt;/p&gt; &#xA;&lt;p&gt;*** Git workflows&lt;/p&gt; &#xA;&lt;p&gt;It may be helpful to do a some background reading on workflows with Git. Here is the gitworkflows man page: &lt;a href=&#34;https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html&#34;&gt;https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Other doc on branching models:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html&#34;&gt;http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html&lt;/a&gt; &lt;a href=&#34;http://williamdurand.fr/2012/01/17/my-git-branching-model/&#34;&gt;http://williamdurand.fr/2012/01/17/my-git-branching-model/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** General&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://nuclearsquid.com/writings/git-tricks-tips-workflows/&#34;&gt;http://nuclearsquid.com/writings/git-tricks-tips-workflows/&lt;/a&gt; for more interesting stuff, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When branching off a remote branch, automatically let the local branch track the remote branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When pushing without giving a refspec, push the current branch to its upstream branch. See the git config man page for more possible options.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf # Shortcut for checkout. co = checkout #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Check out the next commit in the commit history -- quite useful for demos to jump across commits:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf next = &#34;!f() { &lt;br&gt; git checkout $(git rev-list --topo-order HEAD..master | tail -1); &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** If you get the error &#34;The following untracked working tree files would be overwritten by checkout&#34;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src text :tangle no error: Your local changes to the following files would be overwritten by checkout: WEB-INF/config/afm-projects.xml.DEV-fni WEB-INF/config/context/logging/logging.xml Please commit your changes or stash them before you switch branches. error: The following untracked working tree files would be overwritten by checkout: WEB-INF/config/afm-projects.xml Please move or remove them before you switch branches. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;One solution is to &lt;em&gt;move the untracked files&lt;/em&gt;, instead of &lt;em&gt;deleting them&lt;/em&gt;. For example:&lt;/p&gt; &#xA;&lt;p&gt;: cd &#34;$(git root)&#34; : git checkout BRANCH_NAME 2&amp;gt;&amp;amp;1 &lt;br&gt; : | while read F; do &lt;br&gt; : [ ! -e &#34;$F&#34; ] || mv -v &#34;$F&#34; &#34;$F.bak&#34;; &lt;br&gt; : done&lt;/p&gt; &#xA;&lt;p&gt;Another is to throw away local changes using a &lt;em&gt;forced checkout&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;: git checkout -f BRANCH_NAME&lt;/p&gt; &#xA;&lt;p&gt;*** Website and page hosting&lt;/p&gt; &#xA;&lt;p&gt;You can easily host websites directly in your repository hosting service. And open HTML files directly from the file browser.&lt;/p&gt; &#xA;&lt;p&gt;For GitHub pages:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell :tangle no echo &#39;setting up gh-pages&#39; echo &#39;-------------------&#39;&lt;/p&gt; &#xA;&lt;p&gt;echo &#39;Tell me your github account username: &#39; read USER_NAME&lt;/p&gt; &#xA;&lt;p&gt;echo &#39;Now, tell me your repository name: &#39; read REPOSITORY&lt;/p&gt; &#xA;&lt;p&gt;git stash &lt;br&gt; &amp;amp;&amp;amp; git create-branch &#39;gh-pages&#39; &lt;br&gt; &amp;amp;&amp;amp; echo &#39;My Page&#39; &amp;gt; index.html &lt;br&gt; &amp;amp;&amp;amp; git add . &lt;br&gt; &amp;amp;&amp;amp; git commit -a -m &#39;Initial commit&#39; &lt;br&gt; &amp;amp;&amp;amp; git remote add $(git origin) &lt;a href=&#34;https://github.com/%22$USER_NAME%22/%22$REPOSITORY%22.git&#34;&gt;https://github.com/&#34;$USER_NAME&#34;/&#34;$REPOSITORY&#34;.git&lt;/a&gt; &lt;br&gt; &amp;amp;&amp;amp; git push -u $(git origin) gh-pages &lt;br&gt; &amp;amp;&amp;amp; echo &#39;Complete&#39; &lt;br&gt; &amp;amp;&amp;amp; echo &#39;-------------------&#39; &lt;br&gt; &amp;amp;&amp;amp; echo &#39;You can find your last changes in the stash!&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For BitBucket: &lt;a href=&#34;https://marketplace.atlassian.com/apps/1212525/pages-for-bitbucket-server?hosting=server&amp;amp;tab=overview&#34;&gt;https://marketplace.atlassian.com/apps/1212525/pages-for-bitbucket-server?hosting=server&amp;amp;tab=overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Recover a branch after its deletion in Git&lt;/p&gt; &#xA;&lt;p&gt;Most of the time unreachable commits are in the reflog. So, the &lt;em&gt;first thing to try is to look at the reflog&lt;/em&gt; using the command &lt;del&gt;git reflog&lt;/del&gt; (which display the reflog for =HEAD=).&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Perhaps something easier if the commit was part of a specific branch still existing is to use the command &lt;del&gt;git reflog name-of-my-branch&lt;/del&gt; to &lt;em&gt;find the SHA-1&lt;/em&gt; for the commit at the tip of your deleted branch -- It works also with a remote, for example if you forced push. Otherwise, use &lt;del&gt;git reflog&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Then, you can just &lt;del&gt;git create-branch BRANCH SHA_1&lt;/del&gt; to recreate the branch from there.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git&#34;&gt;https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Show branches and their commits&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # &#34;show-branch -g=N&#34; can&#39;t be aliased for N easily, so we stop here: sb = show-branch # pg sbt master pu -- if the last line is &#39;master&#39; and not &#39;master~&#39; # or &#39;master~N&#39; then pu is a descendent of master sbt = show-branch --topics sbs = show-branch --sha1-name #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** PUBLISH - Push&lt;/p&gt; &#xA;&lt;p&gt;*** Show outgoing changes: commits that are on the local branch that have not been pushed&lt;/p&gt; &#xA;&lt;p&gt;It is useful to know if you have any &lt;em&gt;local commits&lt;/em&gt; that are not in the remote branch.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note It is a good idea to examine what you are about to push, before actually doing so, because fixing mistakes before pushing is much easier. To do that, use the command &#34;git diff origin/master&#34;. If you want to show your unpushed commits with their commit log messages, use &#34;git show origin/master..&#34; instead. If you only have one local commit you want to push, just &#34;git show&#34; is enough.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It is not clear to me how these two differ. Does &#34;git show origin/master..&#34; output everything that &#34;git diff origin/master&#34; outputs, plus log messages?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Yes, that&#39;s the only real difference between them, when you have no uncommitted changes. (When you do have uncommitted changes, &#34;git diff&#34; will include them, while &#34;git show&#34; will not.) #+end_note&lt;/p&gt; &#xA;&lt;p&gt;The &lt;del&gt;outgoing&lt;/del&gt; command returns a list of &lt;em&gt;unpushed&lt;/em&gt; (outgoing) commits for the &lt;em&gt;current branch&lt;/em&gt;, the next time you do a push.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git outgoing # Show commits not found in the remote branch. outgoing = log @{u}..&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;outgoing&#39;.&#xA;out = !git outgoing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;TODO: Fix missing newline at the end... Hence, wrong count of lines (with shell alias &#34;W&#34;)...&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf outgoing-files = diff --stat @{u}...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;outgoing-files&#39;.&#xA;out-files = !git outgoing-files&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;This causes &lt;del&gt;git log&lt;/del&gt; to show all commits reachable from =HEAD= excluding those reachable from the upstream branch. The &lt;del&gt;@{u}..&lt;/del&gt; argument is equivalent to &lt;del&gt;@{u}..HEAD&lt;/del&gt;, where =HEAD= stands for the last commit in your local branch, but =HEAD= can be omitted for shorthand purposes.&lt;/p&gt; &#xA;&lt;p&gt;If you want to see all &lt;em&gt;unpushed&lt;/em&gt; commits from &lt;em&gt;all branches&lt;/em&gt;, do this:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git outgoing-all # Show commits not found in the destination repository. outgoing-all = log --branches --not --remotes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;outgoing-all&#39;.&#xA;out-all = !git outgoing-all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Show the history difference between a local branch and its remote&lt;/p&gt; &#xA;&lt;p&gt;= git in + git out&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git divergence BRANCH_NAME divergence = &#34;!f() { &lt;br&gt; git log --cherry-pick --left-right --graph $1...$(git origin)/$1; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** PUBLISH - Find out if a change is part of a release&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git sha1-tag COMMIT sha1-tag = &#34;!f() { &lt;br&gt; git name-rev --name-only &#34;$@&#34;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The &lt;del&gt;name-rev&lt;/del&gt; command indicates the &lt;em&gt;position of a commit relative to tags&lt;/em&gt; in the project. For example, &lt;del&gt;v2.3&lt;/del&gt;5~ means that this commit is located 5 commits &lt;em&gt;before&lt;/em&gt; the &lt;del&gt;v2.3&lt;/del&gt; tag -- we can be certain that this change is part of v2.3, then.&lt;/p&gt; &#xA;&lt;p&gt;** Create patches&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf lll = log -u #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Creating a patch&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Make your changes and commit them.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run&lt;/p&gt; &lt;p&gt;: git format-patch COMMIT_ISH&lt;/p&gt; &lt;p&gt;to convert all commits since the referenced commit (not including it) into patch files.&lt;/p&gt; &lt;p&gt;For example:&lt;/p&gt; &lt;p&gt;: git format-patch HEAD~&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;*** Git apply&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Indeed. I cannot apply the patch, git am returns &#34;patch format detection failed.&#34; Can you resubmit it using git format-patch?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You want to use &#39;git apply&#39; on that patch, &#39;git am&#39; is for applying patches produced by &#39;git format-patch&#39; only. In a pinch however, you can relatively easily convert the patch format from &#39;git show to something suitable for &#39;git am&#39;:&lt;/p&gt; &#xA;&lt;p&gt;Replace &#34;commit&#34; with &#34;From&#34;, Replace &#34;Author&#34; with &#34;From&#34; and replace the whitespace at the beginning of the first line of the commit message with &#34;Subject: [PATCH] &#34;.&lt;/p&gt; &#xA;&lt;p&gt;*** Applying the patch&lt;/p&gt; &#xA;&lt;p&gt;: git am *.patch&lt;/p&gt; &#xA;&lt;p&gt;Error while applying a patch&lt;/p&gt; &#xA;&lt;p&gt;: git am--ignore-whitespace 0001-my-awesome-change.patch&lt;/p&gt; &#xA;&lt;p&gt;When &lt;del&gt;git apply&lt;/del&gt; is working normally, you get no output at all:&lt;/p&gt; &#xA;&lt;p&gt;: git apply 0001-my-awesome-change.patch&lt;/p&gt; &#xA;&lt;p&gt;[nothing returned]&lt;/p&gt; &#xA;&lt;p&gt;If you want to see what&#39;s going on behind the scenes, you can use the &lt;del&gt;-v&lt;/del&gt; (verbose) flag:&lt;/p&gt; &#xA;&lt;p&gt;: git apply -v 0001-my-awesome-change.patch&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;del&gt;patch -p1 &amp;lt; filename.patch&lt;/del&gt;. Whereas &lt;del&gt;git-apply&lt;/del&gt; altogether rejects a patch with any errors, &lt;del&gt;patch -p1&lt;/del&gt; works hunk by hunk, applying as many individual changes as it can. It backs up each file as =filename.ext.orig= before modifying it and saves rejected hunks in =filename.ext.rej=. Discard the =.orig= files and manually apply the changes left in the =.rej=. This is an easy strategy for small patches.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Applying Patches&lt;/em&gt; with different line endings error on Cygwin:&lt;/p&gt; &#xA;&lt;p&gt;: patch -t -N -r - -p1 -i 0001-my-awesome-change.patch&lt;/p&gt; &#xA;&lt;p&gt;*** Apply patches from URL&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Apply a patch to files and/or to the index from URL. apply-url = &#34;!f() { &lt;br&gt; curl -s $1 2&amp;gt;nul &lt;br&gt; | git apply ${@:2}; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;: git apply-url &lt;a href=&#34;http://example.org/sample.patch&#34;&gt;http://example.org/sample.patch&lt;/a&gt; args&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Apply a series of patches from an URL. am-url = &#34;!f() { &lt;br&gt; curl -s $1 2&amp;gt;nul &lt;br&gt; | git am ${@:2}; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;: git am-url &lt;a href=&#34;http://example.org/sample.patch&#34;&gt;http://example.org/sample.patch&lt;/a&gt; args&lt;/p&gt; &#xA;&lt;p&gt;*** Apply a patch interactively&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Interactive apply patch. ipatch = &#34;!f() { &lt;br&gt; git apply $1; &lt;br&gt; git add -p; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;: git ipatch mypatchfile&lt;/p&gt; &#xA;&lt;p&gt;*** Shell patch aliases&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell :tangle no&lt;/p&gt; &#xA;&lt;h1&gt;Copy a patch URL to the clipboard, then run one of these commands to download&lt;/h1&gt; &#xA;&lt;h1&gt;the patch and apply it. Hat tip to @chrisjlee for making me reconsider curl.&lt;/h1&gt; &#xA;&lt;h1&gt;Apply&lt;/h1&gt; &#xA;&lt;p&gt;alias cap=&#39;curl $(pbpaste) | git apply -v&#39;&lt;/p&gt; &#xA;&lt;h1&gt;Apply and stage&lt;/h1&gt; &#xA;&lt;p&gt;alias cape=&#39;curl $(pbpaste) | git apply -v --index&#39;&lt;/p&gt; &#xA;&lt;h1&gt;Apply with `patch&#39;&lt;/h1&gt; &#xA;&lt;p&gt;alias capp=&#39;curl $(pbpaste) | patch -p1&#39;&lt;/p&gt; &#xA;&lt;h1&gt;Reverse apply&lt;/h1&gt; &#xA;&lt;p&gt;alias carp=&#39;curl $(pbpaste) | git apply -Rv&#39;&lt;/p&gt; &#xA;&lt;h1&gt;Reverse apply and stage&lt;/h1&gt; &#xA;&lt;p&gt;alias carpe=&#39;curl $(pbpaste) | git apply -Rv --index&#39;&lt;/p&gt; &#xA;&lt;h1&gt;Verify patch&lt;/h1&gt; &#xA;&lt;p&gt;alias cav=&#39;curl $(pbpaste) | git apply -v --check&#39;&lt;/p&gt; &#xA;&lt;h1&gt;Verify patch with `patch&#39;&lt;/h1&gt; &#xA;&lt;p&gt;alias capv=&#39;curl $(pbpaste) | patch -p1 --dry-run&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** PUBLISH - Prepare a release&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/aiidateam/aiida-core/wiki/How-to-make-a-new-release&#34;&gt;https://github.com/aiidateam/aiida-core/wiki/How-to-make-a-new-release&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** ChangeLog&lt;/p&gt; &#xA;&lt;p&gt;Generate the ChangeLog (for your [[https://keepachangelog.com/][CHANGELOG.md]]) with all commit messages since the last tag.&lt;/p&gt; &#xA;&lt;p&gt;A properly formed Git commit subject line should always be able to complete the following sentence:&lt;/p&gt; &#xA;&lt;p&gt;: If applied, this commit will YOUR_SUBJECT_LINE_HERE&lt;/p&gt; &#xA;&lt;p&gt;How to write a good commit message + A changelog generation: &lt;a href=&#34;https://dev.to/gaelthomas/a-beginner-s-guide-to-git-how-to-write-a-good-commit-message-2j49&#34;&gt;https://dev.to/gaelthomas/a-beginner-s-guide-to-git-how-to-write-a-good-commit-message-2j49&lt;/a&gt; &lt;a href=&#34;https://dev.to/chrissiemhrk/git-commit-message-5e21&#34;&gt;https://dev.to/chrissiemhrk/git-commit-message-5e21&lt;/a&gt; &lt;a href=&#34;https://dev.to/helderburato/patterns-for-writing-better-git-commit-messages-4ba0&#34;&gt;https://dev.to/helderburato/patterns-for-writing-better-git-commit-messages-4ba0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git changelog [FIRST_TAG_NAME] [LAST_TAG_NAME] XXX # Detailed list of changes. changelog1 = &#34;!f() { &lt;br&gt; git log --no-merges ${1-$(git last-tag)}..$2; &lt;br&gt; }; f&#34; changelog = !sh -c &#39;git log --no-merges --pretty=format:&#34;* %s&#34; $(git last-tag)...&#39; - changelog-org = !sh -c &#39;git log --no-merges --pretty=format:&#34;- %s&#34; $(git last-tag)...&#39; - #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Savoir quels sont les commits de ma branche courante depuis le dernier tag, afin de savoir ce qu&#39;embarquera la  prochaine release  de mon projet.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # le dernier tag, ainsi que la liste des commits ayant eu lieu depuis sur la # branche courante. unreleased = !git log $(git last-tag)...HEAD &lt;br&gt; &amp;amp;&amp;amp; git last-tag #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX git log --pretty=format:&#34;- %s&#34; 2019.10.10...HEAD displays too many entries on mcpflow repo&lt;/p&gt; &#xA;&lt;p&gt;See also&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/github-changelog-generator/github-changelog-generator&#34;&gt;https://github.com/github-changelog-generator/github-changelog-generator&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/github-changelog-generator/github-changelog-generator/wiki/Alternatives&#34;&gt;https://github.com/github-changelog-generator/github-changelog-generator/wiki/Alternatives&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;**** Today&lt;/p&gt; &#xA;&lt;p&gt;Quickly see what you&#39;ve done today (list commits that aren&#39;t merges, on &lt;em&gt;all branches&lt;/em&gt;):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git today [AUTHOR] today = &#34;!f() { &lt;br&gt; git log &lt;br&gt; --since=midnight &lt;br&gt; --author=&#34;${1-$(git config --get user.name)}&#34; &lt;br&gt; --no-merges &lt;br&gt; --all &lt;br&gt; --pretty=&#39;%C(green)%ad%C(auto) - %s%C(auto)%d&#39; &lt;br&gt; --date=format:&#39;%Y-%m-%d %a %H:%M&#39;; &lt;br&gt; }; f&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Usage: git yesterday [AUTHOR]&#xA;yesterday = &#34;!f() { \&#xA;        git log \&#xA;            --since=&#39;1 day ago midnight&#39; --until=midnight \&#xA;            --author=\&#34;${1-$(git config --get user.name)}\&#34; \&#xA;            --no-merges \&#xA;            --all \&#xA;            --pretty=&#39;%C(green)%ad%C(auto) - %s%C(auto)%d&#39; \&#xA;            --date=format:&#39;%Y-%m-%d %a %H:%M&#39;; \&#xA;    }; f&#34;&#xA;&#xA;# Usage: git this-week [AUTHOR]&#xA;this-week = &#34;!f() { \&#xA;        git log \&#xA;            --since=&#39;1 week ago&#39; \&#xA;            --author=\&#34;${1-$(git config --get user.name)}\&#34; \&#xA;            --no-merges \&#xA;            --all \&#xA;            --pretty=&#39;%C(green)%ad%C(auto) - %s%C(auto)%d&#39; \&#xA;            --date=format:&#39;%Y-%m-%d %a %H:%M&#39;; \&#xA;    }; f&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Show changes for a daily standup meeting:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git standup [AUTHOR] # Summarize changes since 24h, suitable for a daily standup meeting. standup = &#34;!f() { &lt;br&gt; git log &lt;br&gt; --branches &lt;br&gt; --since=$(if [ &#34;$(date +%a)&#34; = &#34;Mon&#34; ]; then &lt;br&gt; echo &#34;friday&#34;; &lt;br&gt; else &lt;br&gt; echo &#34;yesterday&#34;; &lt;br&gt; fi) &lt;br&gt; --author=&#34;${1-$(git config --get user.name)}&#34; &lt;br&gt; --format=format:&#39;%C(green)%ad%C(reset) - %s%C(auto)%d&#39; &lt;br&gt; --date=format:&#39;%Y-%m-%d %a %H:%M&#39;; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;TODO: git standup W donne un dcompte avec une ligne trop peu !&lt;/p&gt; &#xA;&lt;p&gt;*** Release assets&lt;/p&gt; &#xA;&lt;p&gt;Generate =zip= archived source code from the given Git tag.&lt;/p&gt; &#xA;&lt;p&gt;I use this when zipping the current branch with the name of the zip file as the current tag. Useful for uploading to Elasticbeanstalk.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf current-tag = tag --points-at HEAD zip = &#34;!f() { &lt;br&gt; git archive --format=zip -o $(git current-tag).zip HEAD; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf export-branch = &#34;!f() { &lt;br&gt; git format-patch --stdout $1 &amp;gt; ~/$(git current-branch-without-slash).diff; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Save a repo (for example, &lt;del&gt;HEAD&lt;/del&gt; or &lt;del&gt;master&lt;/del&gt; -- or any other branch to archive, if you&#39;ve already checked it out) as a tarball:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf export-zip = archive -o latest.zip export-tgz = archive -o latest.tar.gz -9 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Note that the /output format/ is inferred by the extension of the output file.&lt;/p&gt; &#xA;&lt;p&gt;**** Export a commit&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git export-commit [COMMIT_ISH] # Create an archive of a commit. export-commit = &#34;!f() { &lt;br&gt; git changed-files ${1:-HEAD} &lt;br&gt; | tr &#39;\n&#39; &#39;\0&#39; &lt;br&gt; | xargs -0 zip -9 $(git repo-slug)-commit-$(git current-branch-without-slash)-${1:-$(git commit-hash)}.zip; &lt;br&gt; }; f&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;XXX This does not handle spaces in file names&lt;/p&gt; &#xA;&lt;p&gt;To see the contents of the zipped file (without extraction), use &lt;del&gt;unzip -l FILE&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;**** Generate patch emails&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # View raw commit. email-patch = XXX git format-patch $(git current-branch-without-slash).patch&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Since oldest ancestor...&#xA;plain-diff = !git branch-diff &amp;gt; $(git current-branch-without-slash).diff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Patch = this&lt;/p&gt; &#xA;&lt;p&gt;: From 69936b7cc23c9ae78cec84baa30c599c1ad5990a Mon Sep 17 00:00:00 2001 : From: Brett Viren &lt;a href=&#34;mailto:brett.viren@gmail.com&#34;&gt;brett.viren@gmail.com&lt;/a&gt; : Date: Fri, 2 Oct 2020 10:30:17 -0400 : Subject: [PATCH] Move doc to index.org and generate index.html, README.org : holds short links. : : This is meant to demo serving the refcard via GH pages. The : README.org probably deserves more attention! : : Content modified: : : - Switched to online SETUPFILE. Maybe better to carry a copy of readtheorg? : : - I had problems related to id:&#xA; &lt;hash&gt;&#xA;   and so switch a reference to use : the headline text. : : - Pointed UP and HOME to links related to the refcard. : --- : README.html | 4118 --------------------------------------------------- : README.org | 1673 +-------------------- : index.html | 3308 +++++++++++++++++++++++++++++++++++++++++ : index.org | 1672 +++++++++++++++++++++ : 4 files changed, 4984 insertions(+), 5787 deletions(-) : delete mode 100755 README.html : mode change 100755 =&amp;gt; 100644 README.org : create mode 100644 index.html : create mode 100755 index.org&#xA; &lt;/hash&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;diff.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf patch-for-this = &#34;!git diff -p $(git hash-object -t tree /dev/null)&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** PUBLISH - Tag&lt;/p&gt; &#xA;&lt;p&gt;When tagging releases in a version control system, the tag for a version should be &lt;del&gt;X.Y.Z&lt;/del&gt; (&lt;em&gt;without&lt;/em&gt; prefix &lt;del&gt;v&lt;/del&gt;). The advantages of &lt;del&gt;X.Y.Z&lt;/del&gt; are that gitweb or GitHub can automatically offer a tarball or zip download of the form =packagename-$tag.tar.gz= (and it&#39;s quite established that a tarball should be named =package-X.Y.Z.tar.gz=).&lt;/p&gt; &#xA;&lt;p&gt;** Debugging&lt;/p&gt; &#xA;&lt;p&gt;Sometimes it&#39;s nice to see what is going on under the hood. Try this alias:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf debug = &#34;!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Just insert &lt;del&gt;debug&lt;/del&gt; between &lt;del&gt;git&lt;/del&gt; and whatever would usually follow; for example:&lt;/p&gt; &#xA;&lt;p&gt;: git debug changed&lt;/p&gt; &#xA;&lt;p&gt;** Abbreviations&lt;/p&gt; &#xA;&lt;p&gt;Basic shortcuts.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf cp = cherry-pick -x pick = cherry-pick -s&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.&#xA;cp = cherry-pick&#xA;&#xA;# cherry-pick without making a commit, and when when recording the commit, append a line that says &#34;(cherry picked from commit ...)&#34;&#xA;cp-nx = cherry-pick --no-commit -x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;This command has some useful parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;-e to edit git message&lt;/li&gt; &#xA; &lt;li&gt;-x to add a line &#34;Cherry-picked commit&#34; in the commit message&lt;/li&gt; &#xA; &lt;li&gt;--no-commit or -n to apply the commit changes in the unstaged area (unstead of creating a commit in the branch)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf h = help #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Show the path to root directory of Git repo&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf :tangle no # Get the path cleaned up. root = !pwd -P #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_note This works because Shell aliases are always executed in the top-level directory. #+end_note&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf root = rev-parse --show-toplevel root-relative = rev-parse --show-prefix #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Sync&lt;/p&gt; &#xA;&lt;p&gt;Fetch Git objects from upstream and update local branches.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the local branch is outdated, fast-forward it;&lt;/li&gt; &#xA; &lt;li&gt;If the local branch contains unpushed work, warn about it;&lt;/li&gt; &#xA; &lt;li&gt;If the branch seems merged and its upstream branch was deleted, delete it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf # Pull then push current branch. sync = !git pull &lt;br&gt; &amp;amp;&amp;amp; git push #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf sync = !git update &lt;br&gt; &amp;amp;&amp;amp; git checkout master &lt;br&gt; &amp;amp;&amp;amp; git pull &lt;br&gt; &amp;amp;&amp;amp; git commit @{-1} #+end_src&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s rather basic -- it doesn&#39;t actually rebase my branch that I&#39;m on.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s do a slightly different command: &lt;del&gt;resync&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # git resync -&amp;gt; sync repository and rebase current branch. resync = !sh -c &#39;git checkout master &lt;br&gt; &amp;amp;&amp;amp; git fetch &lt;br&gt; &amp;amp;&amp;amp; git reset --hard $(git origin)/master &lt;br&gt; &amp;amp;&amp;amp; git rebase master&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Cherry-pick style recording&lt;/p&gt; &#xA;&lt;p&gt;Ask interactively which patch hunk to commit, and then do the commit:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Usage: git commit-interactive [FILE...] # Show record of pending changes, letting you choose which patch hunks to commit. commit-interactive = !sh -c &#39;(git add -p -- $@ &amp;amp;&amp;amp; git commit) &lt;br&gt; || git reset&#39; --&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Alias of &#39;commit-interactive&#39;.&#xA;record = !git commit-interactive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;It will not only do &lt;del&gt;git add -p&lt;/del&gt; (with an optional file list), but it will also immediately do the &lt;del&gt;commit&lt;/del&gt;. Upon abandonment of either the &lt;del&gt;add&lt;/del&gt; or the &lt;del&gt;commit&lt;/del&gt;, it will &lt;del&gt;reset&lt;/del&gt; the index.&lt;/p&gt; &#xA;&lt;p&gt;** Dangling&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Dangling blob = Change(s) that made it to the staging area/index but never got committed. One thing that is amazing with Git is that once it gets added to the staging area, you can always get it back because these blobs behave like commits!!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Dangling commit = A commit that isn&#39;t linked to any branch or tag either directly or by any of its ancestors. You can get these back too!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf lost = &#34;!git fsck &lt;br&gt; | awk &#39;/dangling commit/ {print $3}&#39; &lt;br&gt; | git show --format=&#39;SHA-1: %C(yellow)%h%C(reset) %s&#39; --stdin &lt;br&gt; | awk &#39;/SHA-1/ {sub(&#34;SHA-1: &#34;, &#34;&#34;); print}&#39;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src conf # Resurrection of lost commits. zopa = !git log --all --pretty=oneline --abbrev-commit --graph &lt;br&gt; $(git fsck --no-reflogs | grep commit | cut -d\ -f3) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you get errors...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Many situations may cause &#34;errors&#34;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;merge conflicts (two people editing the same part of the same file)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;unmerged changes (another person committed a change before you did, so you need to merge their changes first)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;attempting to recover from a situation such as an accidental merge, and making the situation worse.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://explainxkcd.com/wiki/index.php/1597:_Git&#34;&gt;https://explainxkcd.com/wiki/index.php/1597:_Git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Method 1&lt;/p&gt; &#xA;&lt;p&gt;It is POSSIBLE that a safe way to recover from your problems is as follows:&lt;/p&gt; &#xA;&lt;p&gt;: git stash : git reset --hard HEAD : git pull --ff-only : git stash apply&lt;/p&gt; &#xA;&lt;p&gt;Of course, if any of the commands but the last fails, stop and ask for advice again. If the last one reports merge conflicts, fix them by hand and run &lt;del&gt;git add&lt;/del&gt; on each file after you fixed it. DO NOT use C-x v v after fixing a merge conflict, since that runs both git add and git commit, and you are not ready for the latter until all merge conflicts are dealt with.&lt;/p&gt; &#xA;&lt;p&gt;In any case, do run git status before finally doing git commit. If all succeeds, you can clean up with:&lt;/p&gt; &#xA;&lt;p&gt;: git stash drop&lt;/p&gt; &#xA;&lt;p&gt;** Alternative&lt;/p&gt; &#xA;&lt;p&gt;If your =master= branch is busted, rename it to something else so that it&#39;s out of the way:&lt;/p&gt; &#xA;&lt;p&gt;: git rename-local-branch master master-busted&lt;/p&gt; &#xA;&lt;p&gt;Create a new branch =master= that tracks the origin:&lt;/p&gt; &#xA;&lt;p&gt;: git branch --track master $(git origin)/master&lt;/p&gt; &#xA;&lt;p&gt;Check it out (be careful, this will discard all your local changes):&lt;/p&gt; &#xA;&lt;p&gt;: git checkout -f master&lt;/p&gt; &#xA;&lt;p&gt;Make sure the =master= is up-to-date:&lt;/p&gt; &#xA;&lt;p&gt;: git pull&lt;/p&gt; &#xA;&lt;p&gt;** A GitHub test repository to experiment with conflicts&lt;/p&gt; &#xA;&lt;p&gt;You can experiment with resolving a Git conflict with this repository: &lt;a href=&#34;https://github.com/brianleetest/testGit/raw/master/README.md&#34;&gt;https://github.com/brianleetest/testGit/blob/master/README.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;** GitHub tasks&lt;/p&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://github.com/abo-abo/oremacs/raw/github/etc/org/wiki/git.org&#34;&gt;https://github.com/abo-abo/oremacs/blob/github/etc/org/wiki/git.org&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;** Doc about push failure&lt;/p&gt; &#xA;&lt;p&gt;If a push fails, that does not necessarily indicate a &#34;bad state&#34; -- it simply represents that your history is different than what the remote server has, and that the tip of the branch you are pushing to cannot simply be &#34;fast-forwarded&#34; to your commit.&lt;/p&gt; &#xA;&lt;p&gt;After a failed push, you are in no different state than you were before the push (aside from a possibly puzzled mental state).&lt;/p&gt; &#xA;&lt;p&gt;In your case, since you just want to commit and push in one operation, you likely want to run &lt;del&gt;git pull --rebase&lt;/del&gt;, which would get those changes and then automatically re-commit your work on top of them, as if you had those changes all along. You could then push. So, something like:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell :tangle no&lt;/p&gt; &#xA;&lt;h1&gt;Commit all changes and attempt to push, pulling in changes if necessary and&lt;/h1&gt; &#xA;&lt;h1&gt;re-pushing; on failure, restore to previous state with changes uncomitted.&lt;/h1&gt; &#xA;&lt;p&gt;git commit -am Foo &lt;br&gt; &amp;amp;&amp;amp; { git push &lt;br&gt; || { { git pull --rebase || handle-pull-conflicts; } &lt;br&gt; &amp;amp;&amp;amp; git push; } } &lt;br&gt; || { git reset --soft HEAD^ echo &#39;Commit failed.&#39; } #+end_src&lt;/p&gt; &#xA;&lt;p&gt;But what if rebasing fails? Then you are left resolving a conflict before you can attempt the push operation again. I do not know how you would want to handle this. &lt;del&gt;handle-pull-conflicts&lt;/del&gt; might simply perform a &lt;del&gt;git rebase --abort&lt;/del&gt; and exit with a non-zero status, or it may open a UI/shell to help resolve changes. If you are pushing after every change, this amounts to correcting a single commit, so it might be worth having VC maintain the state here, allow you to correct your commit, and then the vc-next-action would be to run &lt;del&gt;git rebase --continue&lt;/del&gt; after adding the files that conflicted.&lt;/p&gt; &#xA;&lt;p&gt;This will be how the majority of Git users will resolve rejected pushes.&lt;/p&gt; &#xA;&lt;p&gt;Does that make sense?&lt;/p&gt; &#xA;&lt;p&gt;[Aside: &lt;del&gt;git pull&lt;/del&gt; without &lt;del&gt;--rebase&lt;/del&gt; performs a &lt;del&gt;git fetch &amp;amp;&amp;amp; git merge whatever-branch-you-are-tracking&lt;/del&gt;, which has the unfortunate side-effect of creating a merge commit if histories are different; this muddies up history. &lt;del&gt;git pull --rebase&lt;/del&gt; performs &lt;del&gt;git fetch &amp;amp;&amp;amp; git rebase whatever-branch-you-are-tracking&lt;/del&gt;. The difference in the two styles of conflicts here is that, with rebasing, since you are re-committing each and every changeset, you may get multiple conflicts on any number of commits, whereas a merge will give you a single conflict that must be resolved at once. The benefit of rebasing is that it gives you a clean history and does not produce an unnecessary merge conflict which you would then push to origin, akin to leaving a bag of poop on origin&#39;s doorstep.]&lt;/p&gt; &#xA;&lt;p&gt;For other users, it may represent a wholly different problem. For example, if I were to push to GNU ease.js&#39; repo and get that message, that would be a problem, since that means that someone has committed to my repository without my permission. An automatic pull and re-push would be bad in this case, since that makes it look like I&#39;m okay with that.&lt;/p&gt; &#xA;&lt;p&gt;A failed push could also mean that you are tracking the wrong branch, or pushing to the wrong repository. Git allows you to set a &#34;tracking branch&#34;, which can be anything---a local branch, a remote branch, or a branch in an entirely different repository, local or remote. Further, you can override the tracking branch by specifying which remote to push to as part of the &lt;del&gt;push&lt;/del&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;In your case, you&#39;d always want to respect the tracking branch and assume that there are no problems pushing, since you use only one remote, and the tracking branch is always a branch of the same name on origin.&lt;/p&gt; &#xA;&lt;p&gt;A failed push could also mean that someone rudely rewrote history on the remote branch (using &lt;del&gt;git push --force&lt;/del&gt;) and someone needs a talkin&#39; to.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;References&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/tj/git-extras&#34;&gt;https://github.com/tj/git-extras&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://hub.github.com/hub.1.html&#34;&gt;https://hub.github.com/hub.1.html&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh&#34;&gt;http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://girliemac.com/blog/2017/12/26/git-purr/][Git Commands Explained with Cats!]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;- [[file:~/Public/Repositories/emacs/admin/notes/git-workflow][Emacs Git workflow]]&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Git clients&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://jonas.github.io/tig/][Tig]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.gitkraken.com/][GitKraken]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Local configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src conf [include] path = .gitconfig_local #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Issues&lt;/p&gt; &#xA;&lt;p&gt;Report issues and suggest features and improvements on the [[https://github.com/fniessen/git-leuven/issues/new][GitHub issue tracker]].&lt;/p&gt; &#xA;&lt;p&gt;** Patches&lt;/p&gt; &#xA;&lt;p&gt;I love contributions! Patches under any form are always welcome!&lt;/p&gt; &#xA;&lt;p&gt;** Donations&lt;/p&gt; &#xA;&lt;p&gt;If you use the git-leuven project (or any of [[https://github.com/fniessen/][my other projects]]) and feel it is making your life better and easier, you can show your appreciation and help support future development by making today a [[https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;amp;business=VCVAS6KPDQ4JC&amp;amp;lc=BE&amp;amp;item_number=git%2dleuven&amp;amp;currency_code=EUR&amp;amp;bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted][donation]] through PayPal. Thank you!&lt;/p&gt; &#xA;&lt;p&gt;Regardless of the donations, git-leuven will always be free both as in beer and as in speech.&lt;/p&gt; &#xA;&lt;p&gt;** Follow me&lt;/p&gt; &#xA;&lt;p&gt;I have an [[https://twitter.com/f_niessen][f_niessen]] account on Twitter. You should follow it.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Copyright (C) 2013-2022 Fabrice Niessen&lt;/p&gt; &#xA;&lt;p&gt;Author: Fabrice Niessen \ Keywords: git aliases&lt;/p&gt; &#xA;&lt;p&gt;This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;http://opensource.org/licenses/GPL-3.0&#34;&gt; #+html: &lt;img src=&#34;http://img.shields.io/:license-gpl-blue.svg?sanitize=true&#34; alt=&#34;:license-gpl-blue.svg&#34;&gt; #+html: &lt;/a&gt; #+html: &lt;a href=&#34;https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;amp;business=VCVAS6KPDQ4JC&amp;amp;lc=BE&amp;amp;item_number=git%2dleuven&amp;amp;currency_code=EUR&amp;amp;bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted&#34;&gt; #+html: &lt;img src=&#34;https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif&#34; alt=&#34;btn_donate_LG.gif&#34;&gt; #+html: &lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>limitusus/ddns-management</title>
    <updated>2023-04-13T01:40:53Z</updated>
    <id>tag:github.com,2023-04-13:/limitusus/ddns-management</id>
    <link href="https://github.com/limitusus/ddns-management" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DDNS Management&lt;/h1&gt; &#xA;&lt;p&gt;This is just for my private use.&lt;/p&gt; &#xA;&lt;h2&gt;Required Packages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DateTime&lt;/li&gt; &#xA; &lt;li&gt;DBI&lt;/li&gt; &#xA; &lt;li&gt;DBD::mysql&lt;/li&gt; &#xA; &lt;li&gt;Config::Pit&lt;/li&gt; &#xA; &lt;li&gt;Net::DNS&lt;/li&gt; &#xA; &lt;li&gt;(optional) Smart::Comments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;update_ddns&lt;/h2&gt; &#xA;&lt;p&gt;Perl script that updates DDNS database. All configurations are done through Pit (Config::Pit in Perl). This requires MySQL database and a table as &lt;code&gt;ddns_init.sql&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h2&gt;update_dns&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./update_dns $DOMAIN $NAME $DATA&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will update the $NAME.$DOMAIN record with $DATA. For instance, when you update &lt;code&gt;foobar.example.com&lt;/code&gt; with &lt;code&gt;192.168.0.12&lt;/code&gt; the command will be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./update_ddns example.com foobar 192.168.0.12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ddns_client&lt;/h2&gt; &#xA;&lt;p&gt;Shell script that invokes update_dns. It can be configured by &lt;code&gt;envdir&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;$ENVDIR/IP_URL&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The script knows the global IP address through accessing this URL. This &lt;code&gt;IP_URL&lt;/code&gt; returns &lt;code&gt;text/plain&lt;/code&gt; formatted IP address string.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;$ENVDIR/UPDATE_HOST&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Hostname of the DDNS server.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;$ENVDIR/UPDATE_USER&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The login name for SSH command.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;$ENVDIR/SSH_OPTS&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The command-line options for SSH access to the DDNS server. It is inteded to specify SSH private key (&lt;code&gt;-i $KEY&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;$ENVDIR/TARGET_DOMAIN&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The DNS domain of the client. It must be contained in &lt;code&gt;zone&lt;/code&gt; record in DDNS database.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;$ENVDIR/TARGET_NAME&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The DNS name of the client. It will be &lt;code&gt;name&lt;/code&gt; record in the DDNS database.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;$ENVDIR/UPDATE_CMD&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;DDNS update command invoked in the DDNS server. It is intended to launch &lt;code&gt;update_ddns&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;apply_ddns&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./apply_ddns&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;on the named server will send DDNS packet (RFC 2136) and set zone.applied 1 if successed.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Kong/lua-resty-events</title>
    <updated>2023-04-13T01:40:53Z</updated>
    <id>tag:github.com,2023-04-13:/Kong/lua-resty-events</id>
    <link href="https://github.com/Kong/lua-resty-events" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Inter process Pub/Sub pattern for Nginx worker processes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lua-resty-events&lt;/h1&gt; &#xA;&lt;p&gt;Inter process Pub/Sub pattern events propagation for Nginx worker processes&lt;/p&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#name&#34;&gt;Name&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#status&#34;&gt;Status&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#methods&#34;&gt;Methods&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#init_worker&#34;&gt;init_worker&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#run&#34;&gt;run&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#subscribe&#34;&gt;subscribe&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#unsubscribe&#34;&gt;unsubscribe&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#copyright-and-license&#34;&gt;Copyright and License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#see-also&#34;&gt;See Also&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;This library is currently considered experimental.&lt;/p&gt; &#xA;&lt;h1&gt;Synopsis&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;http {&#xA;    lua_package_path &#34;/path/to/lua-resty-events/lib/?/init.lua;;&#34;;&#xA;&#xA;    init_by_lua_block {&#xA;        local opts = {&#xA;            listening = &#34;unix:/tmp/events.sock&#34;,&#xA;        }&#xA;&#xA;        local ev = require(&#34;resty.events&#34;).new(opts)&#xA;        if not ev then&#xA;            ngx.log(ngx.ERR, &#34;failed to new events object&#34;)&#xA;        end&#xA;&#xA;        -- store ev to global&#xA;        _G.ev = ev&#xA;    }&#xA;&#xA;    init_worker_by_lua_block {&#xA;        -- fetch ev from global&#xA;        local ev = _G.ev&#xA;&#xA;        local handler = function(data, event, source, wid)&#xA;            print(&#34;received event; source=&#34;, source,&#xA;                  &#34;, event=&#34;, event,&#xA;                  &#34;, data=&#34;, tostring(data),&#xA;                  &#34;, from process &#34;, wid)&#xA;        end&#xA;&#xA;        local id1 = ev:subscribe(&#34;*&#34;, &#34;*&#34;, handler)&#xA;        local id2 = ev:subscribe(&#34;source&#34;, &#34;*&#34;, handler)&#xA;        local id3 = ev:subscribe(&#34;source&#34;, &#34;event&#34;, handler)&#xA;&#xA;        local ok, err = ev:init_worker()&#xA;        if not ok then&#xA;            ngx.log(ngx.ERR, &#34;failed to init events: &#34;, err)&#xA;        end&#xA;    }&#xA;&#xA;    # create a listening unix domain socket&#xA;    server {&#xA;        listen unix:/tmp/events.sock;&#xA;        location / {&#xA;            content_by_lua_block {&#xA;                -- fetch ev from global&#xA;                local ev = _G.ev&#xA;                ev:run()&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;This module provides a way to send events to the other worker processes in an Nginx server. Communication is through a unix domain socket which is listened by one and only one Nginx worker.&lt;/p&gt; &#xA;&lt;p&gt;The design allows for 3 usecases;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;broadcast an event to all workers processes, see &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;. Example: a healthcheck running in one worker, but informing all workers of a failed upstream node.&lt;/li&gt; &#xA; &lt;li&gt;broadcast an event to the current worker only, see &lt;code&gt;target&lt;/code&gt; parameter of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;coalesce external events to a single action. Example: all workers watch external events indicating an in-memory cache needs to be refreshed. When receiving it they all post it with a unique event hash (all workers generate the same hash), see &lt;code&gt;target&lt;/code&gt; parameter of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;. Now only 1 worker will receive the event &lt;em&gt;only once&lt;/em&gt;, so only one worker will hit the upstream database to refresh the in-memory data.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Methods&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;new&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ev = events.new(opts)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Return a new events object. It should be stored in global scope for &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#run&#34;&gt;run&lt;/a&gt; later.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;opts&lt;/code&gt; parameter is a Lua table with named options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;listening&lt;/code&gt;: the unix domain socket, which must be same as another &lt;code&gt;server&lt;/code&gt; block.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;broker_id&lt;/code&gt;: (optional) the worker id that will start to listen, default &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unique_timeout&lt;/code&gt;: (optional) timeout of unique event data stored (in seconds), default &lt;code&gt;5&lt;/code&gt;. See the &lt;code&gt;target&lt;/code&gt; parameter of the &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt; method.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_queue_len&lt;/code&gt;: (optional) max length of internal events buffer queue, default &lt;code&gt;1024 * 10&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The return value will be the event object or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There is a special parameter &lt;code&gt;testing&lt;/code&gt;, which means the library will not enable unix domain socket listening, and the events will only be propagated in the worker process internally. In the meanwhile, &lt;code&gt;unique_timeout&lt;/code&gt; will be meanless.&lt;/p&gt; &#xA;&lt;p&gt;This feature is very useful for testing, such as &lt;code&gt;resty cli&lt;/code&gt;. The default value for &lt;code&gt;testing&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;init_worker&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = ev:init_worker()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;init_worker_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will initialize the event listener. This should typically be called from the &lt;code&gt;init_worker_by_lua&lt;/code&gt; handler, because it will make sure only one Nginx worker starts to listen on unix domain socket.&lt;/p&gt; &#xA;&lt;p&gt;The return value will be &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; and an error message.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;run&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ev:run()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;content_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Active the event loop only in Nginx broker process, see opts &lt;code&gt;broker_id&lt;/code&gt; of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;. it must be called in &lt;code&gt;content_by_lua*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ev&lt;/code&gt; object must be the same object returned by &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Should not call it if &lt;code&gt;testing&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;publish&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = ev:publish(target, source, event, data)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;all phases except init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will post a new event. &lt;code&gt;target&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;event&lt;/code&gt; are all strings. &lt;code&gt;data&lt;/code&gt; can be anything (including &lt;code&gt;nil&lt;/code&gt;) as long as it is (de)serializable by the LuaJIT string buffer serializer and cJSON (legacy).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;target&lt;/code&gt; parameter could be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;all&#34; : the event will be broadcasted to all workers.&lt;/li&gt; &#xA; &lt;li&gt;&#34;current&#34; : the event will be local to the worker process, it will not be broadcasted to other workers. With this method, the &lt;code&gt;data&lt;/code&gt; element will not be serialized.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;unique hash&lt;/em&gt; : the event will be send to only one worker. Also any follow up events with the same hash value will be ignored (for the &lt;code&gt;unique_timeout&lt;/code&gt; period specified to &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The return value will be &lt;code&gt;true&lt;/code&gt; when the event was successfully published or &lt;code&gt;nil + error&lt;/code&gt; in case of cjson serializition failure or event queue full.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: in case of &#34;all&#34; and &#34;current&#34; the worker process sending the event, will also receive the event! So if the eventsource will also act upon the event, it should not do so from the event posting code, but only when receiving it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;subscribe&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;id = ev:subscribe(source, event, callback)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;all phases except init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will register a callback function to receive events. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;event&lt;/code&gt; are &lt;code&gt;*&lt;/code&gt;, then the callback will be executed on &lt;em&gt;every&lt;/em&gt; event, if &lt;code&gt;source&lt;/code&gt; is provided and &lt;code&gt;event&lt;/code&gt; is &lt;code&gt;*&lt;/code&gt;, then only events with a matching source will be passed. If event name is given, then only when both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;event&lt;/code&gt; match the callback is invoked.&lt;/p&gt; &#xA;&lt;p&gt;The callback should have the following signature;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: callback = function(data, event, source, wid)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The parameters will be the same as the ones provided to &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;, except for the extra value &lt;code&gt;wid&lt;/code&gt; which will be the worker id of the originating worker process, or &lt;code&gt;nil&lt;/code&gt; if it was a local event only. Any return value from &lt;code&gt;callback&lt;/code&gt; will be discarded. &lt;em&gt;Note:&lt;/em&gt; &lt;code&gt;data&lt;/code&gt; may be a reference type of data (eg. a Lua &lt;code&gt;table&lt;/code&gt; type). The same value is passed to all callbacks, &lt;em&gt;so do not change the value in your handler, unless you know what you are doing!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The return value of &lt;code&gt;subscribe&lt;/code&gt; will be a callback id, or it will throw an error if &lt;code&gt;callback&lt;/code&gt; is not a function value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;unsubscribe&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ev:unsubscribe(id)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;all phases except init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will unregister the callback function and prevent it from receiving further events. The parameter &lt;code&gt;id&lt;/code&gt; is the return value of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#subscribe&#34;&gt;subscribe&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2022 Kong Inc.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;See Also&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Kong: &lt;a href=&#34;https://konghq.com/&#34;&gt;https://konghq.com/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>