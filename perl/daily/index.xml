<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-14T01:32:03Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Ensembl/ensembl-genes-metadata</title>
    <updated>2024-03-14T01:32:03Z</updated>
    <id>tag:github.com,2024-03-14:/Ensembl/ensembl-genes-metadata</id>
    <link href="https://github.com/Ensembl/ensembl-genes-metadata" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ensembl-genes-metadata&lt;/h1&gt; &#xA;&lt;h3&gt;The EnsEMBL Genebuild Meta Database System&lt;/h3&gt; &#xA;&lt;p&gt;This repo contains modules and scripts for maintaning the Ensembl genebuild meta database.&lt;/p&gt; &#xA;&lt;p&gt;Currently, this repo contains both Perl and Python modules and/or scripts for adding assembly records to the database&lt;/p&gt; &#xA;&lt;p&gt;To add a new assembly to the database, you need to have the required PERL5LIB for running the genebuild annotation pipeline in your path&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;In addition to the listed python packages (see requirements.txt), you will need to have biopython installed either locally or centrally and set in your path&lt;/p&gt; &#xA;&lt;h3&gt;Perl EnsEMBL repositories you need to have&lt;/h3&gt; &#xA;&lt;p&gt;We recommend that you clone all the repositories into one directory&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Repository name&lt;/th&gt; &#xA;   &lt;th&gt;branch&lt;/th&gt; &#xA;   &lt;th&gt;URL&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl.git&#34;&gt;https://github.com/Ensembl/ensembl.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-hive&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-hive.git&#34;&gt;https://github.com/Ensembl/ensembl-hive.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-compara&lt;/td&gt; &#xA;   &lt;td&gt;release/98&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-compara.git&#34;&gt;https://github.com/Ensembl/ensembl-compara.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-production&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-production.git&#34;&gt;https://github.com/Ensembl/ensembl-production.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-taxonomy&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-taxonomy.git&#34;&gt;https://github.com/Ensembl/ensembl-taxonomy.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-orm&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-orm.git&#34;&gt;https://github.com/Ensembl/ensembl-orm.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-killlist&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-killlist.git&#34;&gt;https://github.com/Ensembl/ensembl-killlist.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-datacheck&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-datacheck.git&#34;&gt;https://github.com/Ensembl/ensembl-datacheck.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-metadata&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-metadata.git&#34;&gt;https://github.com/Ensembl/ensembl-metadata.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-io&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-io.git&#34;&gt;https://github.com/Ensembl/ensembl-io.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For each of these repository, you will need to install their dependencies using the cpanfile provided in their Git repositories&lt;/p&gt; &#xA;&lt;p&gt;You can use the &lt;a href=&#34;https://github.com/Ensembl/ensembl-git-tools&#34;&gt;Ensembl git commands&lt;/a&gt; and run the following command to clone the repositories&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git ensembl --clone genebuild&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Python EnsEMBL repositories you need to have&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Repository name&lt;/th&gt; &#xA;   &lt;th&gt;branch&lt;/th&gt; &#xA;   &lt;th&gt;URL&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ensembl-genes&lt;/td&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Ensembl/ensembl-genes.git&#34;&gt;https://github.com/Ensembl/ensembl-genes.git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Python virtual environment&lt;/h3&gt; &#xA;&lt;p&gt;You will need to create the virtual environment:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;genebuild-metadb&lt;/code&gt; using the requirements.txt file; it needs to be activated for the pipeline to run&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Shell environment&lt;/h3&gt; &#xA;&lt;p&gt;If you are not part of the Ensembl Genebuild team, you will need to set some shell environment variables to avoid having to provide the information to the configuration files. We will assume you are using your home directory&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Variable&lt;/th&gt; &#xA;   &lt;th&gt;Value&lt;/th&gt; &#xA;   &lt;th&gt;Hive configuration parameter&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ENSCODE&lt;/td&gt; &#xA;   &lt;td&gt;$HOME&lt;/td&gt; &#xA;   &lt;td&gt;-enscode_root_dir&lt;/td&gt; &#xA;   &lt;td&gt;Directory path where you cloned all the Perl repositories&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ENSEMBL_SOFTWARE_HOME&lt;/td&gt; &#xA;   &lt;td&gt;$HOME&lt;/td&gt; &#xA;   &lt;td&gt;-software_base_path&lt;/td&gt; &#xA;   &lt;td&gt;Directory where pyenv, plenv and linuxbrew are installed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;LINUXBREW_HOME&lt;/td&gt; &#xA;   &lt;td&gt;$HOME/.linuxbrew&lt;/td&gt; &#xA;   &lt;td&gt;-linuxbrew_home_path&lt;/td&gt; &#xA;   &lt;td&gt;Base directory for your Linuxbrew installation&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;PYTHONPATH&lt;/td&gt; &#xA;   &lt;td&gt;$HOME/ensembl-genes/ensembl_genes_metadata:$HOME/ensembl-genes/ensembl_genes:$HOME/ensembl-hive/wrappers/python3/&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;It needs to be set until the package can be installed properly&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;MySQL&lt;/h3&gt; &#xA;&lt;p&gt;We currently use MySQL databases to store our data. To avoid having to do many changes to the configuration files we recommend having one read-only user and one read-write user. It is also better to use different servers for keeping fail-safe copies of the database.&lt;/p&gt; &#xA;&lt;h2&gt;Running the EnsEMBL Genebuild Meta Database System (Assembly registry pipeline)&lt;/h2&gt; &#xA;&lt;p&gt;There is a main configuration file, &lt;code&gt;Bio::EnsEMBL::Pipeline::PipeConfig::AssemblyRegistrationConf&lt;/code&gt;, which will generate a set of analyses to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;sync genebuild entries between the meta database and the production portal&lt;/li&gt; &#xA; &lt;li&gt;check for new eukaryotic genomes&lt;/li&gt; &#xA; &lt;li&gt;check and update assembly names and refseq accessions&lt;/li&gt; &#xA; &lt;li&gt;backup meta database when new eukaryotic genomes become available&lt;/li&gt; &#xA; &lt;li&gt;register new genomes&lt;/li&gt; &#xA; &lt;li&gt;copy and restore updated database across fail-safe servers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The whole system is explained in more details below&lt;/p&gt; &#xA;&lt;h3&gt;Initialising the pipeline&lt;/h3&gt; &#xA;&lt;p&gt;You will need to activate the genebuild virtual environment&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pyenv activate genebuild-metadb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Filling the main configuration automatically&lt;/h4&gt; &#xA;&lt;p&gt;If you are operating within an environment prepared for Ensembl with the assembly registry you can use the &lt;code&gt;$ENSCODE/ensembl-genes-metadata/src/perl/Bio/EnsEMBL/Pipeline/PipeConfig/AssemblyRegistryConf.pm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You would need to edit &lt;code&gt;$ENSCODE/ensembl-genes-metadata/config/registry.ini&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note: The registry.ini file is the configuration file that contains the genbank accessions and the database connection settings.&lt;/p&gt; &#xA;&lt;p&gt;Then you can run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl $ENSCODE/ensembl-hive/scripts/init_pipeline.pl $ENSCODE/ensembl-genes-metadata/src/perl/Bio/EnsEMBL/Pipeline/PipeConfig/AssemblyRegistryConf.pm -output_path &amp;lt;writable location&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running the Assembly registry pipeline&lt;/h3&gt; &#xA;&lt;p&gt;To start the pipeline you need the URL to your pipeline database which will be provided when running the init_Pipeline.pl script. If you initialised the pipeline automatically, you need to look at the commands displayed on screen at the end of the initialisation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export EHIVE_URL=mysql://readwrite_user:password@host:port/dbname&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now start the pipeline with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl $ENSCODE/ensembl-hive/scripts/beekeeper.pl -url $EHIVE_URL -loop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you only want to run some analyses, you can run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl $ENSCODE/ensembl-hive/scripts/beekeeper.pl -url $EHIVE_URL -loop -analyses_pattern 1..5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Monitoring the pipeline&lt;/h3&gt; &#xA;&lt;h4&gt;GuiHive&lt;/h4&gt; &#xA;&lt;p&gt;To follow the pipeline steps, it is better to use GuiHive, a graphical interface to ensembl-hive, which allows you to change parameters, debug your problems and much more &lt;a href=&#34;https://github.com/Ensembl/guiHive&#34;&gt;https://github.com/Ensembl/guiHive&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;What to do when the main pipeline fails&lt;/h4&gt; &#xA;&lt;p&gt;You should first look at the job tab to know the reason of the failure&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Insufficient memory: you can either use a different resource or add a new one more suited to your needs&lt;/li&gt; &#xA; &lt;li&gt;Error in the code: I&#39;m afraid you will need to do proper debugging&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once you are happy with your fix, you would need to reset the jobs with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl $ENSCODE/ensembl-hive/scripts/beekeeper.pl -url $EHIVE_URL -reset_failed_jobs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and restart the pipeline&lt;/p&gt; &#xA;&lt;h4&gt;How can I debug a job&lt;/h4&gt; &#xA;&lt;p&gt;By default ensembl-hive redirect all output to &lt;code&gt;/dev/null&lt;/code&gt; unless you used some logging parameters.&lt;/p&gt; &#xA;&lt;p&gt;You will need to run the problematic job with runWorker. First you will need to retrieve the job id using GuiHive or the pipeline database. Then you can run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl $ENSCODE/ensembl-hive/scripts/runWorker.pl -url $EHIVE_URL -debug 1 -job_id XX&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using a higher value for &lt;code&gt;-debug&lt;/code&gt; is usually not useful as it is mostly seen as a boolean flag.&lt;/p&gt; &#xA;&lt;h2&gt;The different parts of the EnsEMBL Assembly Registration System&lt;/h2&gt; &#xA;&lt;h3&gt;Sync meta database&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;It will reference the production portal to identify all live databases linked to the current Ensembl release. These databases are then queried to obtain meta information such as the genebuild method, genebuild completion date and genome accession. The retrieved meta data is checked against all pending genebuilds and when a match is found, the pending genebuild status is updated.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;When a database appears to be present both in Rapid and Main sites, the released server is set to Main&lt;/p&gt; &#xA;&lt;h3&gt;Check for new assembly&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;It checks the public archives for any new eukaryotic genome since the last meta database update. If it finds one, an output file containing all new accessions and meta database configuration settings is created.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h3&gt;Refseq and Assembly name check&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;This checks for any changes in the Refseq and assembly name values of existing assemblies.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;All updated assemblies are reported via Slack&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h3&gt;Assembly registration&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;All new assemblies obtained earlier are processed for storage in the database.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;All new assemblies are reported via Slack&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;Depending on whether the new assembly comes from an already existing species or not, there may be need to create and assign or reuse a unique prefix and stable id space range to the assembly record.&lt;/p&gt; &#xA;&lt;h3&gt;Sync meta database&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;When the meta database gets updated, copies are taken and restored across fail-safe servers&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h3&gt;Running the Transcriptomic assessment pipeline&lt;/h3&gt; &#xA;&lt;p&gt;To start the pipeline you need the URL to your pipeline database which will be provided when running the init_Pipeline.pl script. If you initialised the pipeline automatically, you need to look at the command file created in your &lt;code&gt;working_dir&lt;/code&gt; directory to retrieve the information.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export EHIVE_URL=mysql://readwrite_user:password@host:port/dbname&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now start the pipeline with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl $ENSCODE/ensembl-hive/scripts/beekeeper.pl -url $EHIVE_URL -loop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you only want to run some analyses, you can run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl $ENSCODE/ensembl-hive/scripts/beekeeper.pl -url $EHIVE_URL -loop -analyses_pattern 1..5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The different parts of the EnsEMBL Transcriptomic Assessment System&lt;/h2&gt; &#xA;&lt;h3&gt;Fetch candidate assemblies&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;It queries the meta database to retrieve all assemblies with contig_N50 &amp;gt; 100000, having total gap length that is less than 30% of the genome.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;When multiple assemblies exist for one species, it returns a list of one assembly per species.&lt;/p&gt; &#xA;&lt;h3&gt;Transcriptomic data check&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;It queries the ENA for any available transcriptomic data per species.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;It returns a list of species with available data and those without&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;When no data is found at species level, it retries at the genus level&lt;/p&gt; &#xA;&lt;p&gt;This check excludes single ended reads for short reads.&lt;/p&gt; &#xA;&lt;h3&gt;Fetch reads&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;It downloads both short and long read data where available per species&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h3&gt;Prepare assembly for alignment&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;The genomes of all assemblies earlier identified are downloaded and indexed, ready for alignment&lt;/p&gt; &#xA;&lt;p&gt;Genomes are indexed using both Star and Minimap&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h3&gt;Subsampling of reads&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;All fastq files are subsampled randomly to a size of 50000 reads.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h3&gt;Read validation&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;The subsampled read files are validated to ensure they confrom to standard fastq file requirements.&lt;/p&gt; &#xA;&lt;p&gt;Also, the per base sequence quality is tested using Fastqc.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;Reads not meeting the validation criteria or failing the per base sequence quality tests are discarded.&lt;/p&gt; &#xA;&lt;h3&gt;Read alignment&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;The reads that pass the prior validation steps are aligned against their corresponding genomes. Long reads are aligned using Minimap and short reads are aligned using Star.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h3&gt;Read classification&lt;/h3&gt; &#xA;&lt;h4&gt;What it does&lt;/h4&gt; &#xA;&lt;p&gt;Using arbitrary criteria such as percentage mapping quality, per base sequence quality, total read count per sample, the samples are classed as good, weak or unusable.&lt;/p&gt; &#xA;&lt;p&gt;An assembly with five or more good samples gets a green status.&lt;/p&gt; &#xA;&lt;p&gt;An assembly with more than one good or weak sample, with total read count greater than 100000000 gets an amber status.&lt;/p&gt; &#xA;&lt;p&gt;An assembly not meeting either of the above gets a red status.&lt;/p&gt; &#xA;&lt;h4&gt;Notifications&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt; &#xA;&lt;h4&gt;Caveats&lt;/h4&gt; &#xA;&lt;p&gt;None&lt;/p&gt;</summary>
  </entry>
</feed>