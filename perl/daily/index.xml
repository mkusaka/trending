<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-26T01:43:40Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>apache/spamassassin</title>
    <updated>2023-06-26T01:43:40Z</updated>
    <id>tag:github.com,2023-06-26:/apache/spamassassin</id>
    <link href="https://github.com/apache/spamassassin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Read-only mirror of Apache SpamAssassin. Submit patches to https://bz.apache.org/SpamAssassin/. Do not send pull requests&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;Apache SpamAssassin&lt;/h3&gt; &#xA;&lt;h4&gt;GitHub Actions for testing&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://spamassassin.apache.org/&#34; title=&#34;Apache SpamAssassin project&#34;&gt;Apache SpamAssassin project&lt;/a&gt; uses a &lt;a href=&#34;https://svn.apache.org/repos/asf/spamassassin/&#34; title=&#34;subversion repo&#34;&gt;subversion repo&lt;/a&gt; for its development process. A read-only mirror of the repo is maintained on GitHub &lt;a href=&#34;https://github.com/apache/spamassassin&#34; title=&#34;here&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The .github directory containing this README file is not part of the Apache SpamAssassin release package. The files in this directory are intended for use by developers to run tests using GitHub&#39;s Actions facility on GitHub hosted runners.&lt;/p&gt; &#xA;&lt;p&gt;The Apache SpamAssassin Project Management Committe has not made any arrangements to use the resources allocated to the Apache Software Foundation by GitHub to run builds and tests. The actions defined in this directory are available for anyone, including active developers of SpamAssassin, to run in their personal GitHub fork of the repo. However, the inclusion of the files in this repository does not comprise a formal release of the software to the public.&lt;/p&gt; &#xA;&lt;h4&gt;How to use&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fork this repo to your own GitHub repo&lt;/li&gt; &#xA; &lt;li&gt;Usually the default settings for the repo will allow you to run actions. If not, see &lt;a href=&#34;https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository&#34; title=&#34;Managing GitHub Actions&#34;&gt;Managing GitHub Actions&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Click on the &lt;strong&gt;Actions&lt;/strong&gt; tab&lt;/li&gt; &#xA; &lt;li&gt;Click on &lt;strong&gt;SpamAssassin make test&lt;/strong&gt; in the left sidebar&lt;/li&gt; &#xA; &lt;li&gt;Click on the &lt;strong&gt;Run workflow&lt;/strong&gt; dropdown button on the right of the page&lt;/li&gt; &#xA; &lt;li&gt;Edit the four input boxes in the dropdown to select those options that you want to run. Make sure that you follow the syntax of the options as shown, i.e., keep the square braces, use quotes and commas where the dropdown already does.&lt;/li&gt; &#xA; &lt;li&gt;Click the &lt;strong&gt;Run workflow&lt;/strong&gt; button to submit the jobs&lt;/li&gt; &#xA; &lt;li&gt;Click the &lt;strong&gt;Actions&lt;/strong&gt; tab to refresh the screen and show the submitted workflow run, then click the entry for the run you just submitted to see the jobs that are included in it, displayed in the left sidebar.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The workflow run you submit will have one job for every valid combination of values from the first three input boxes.&lt;/p&gt; &#xA;&lt;p&gt;The fourth input box allows you to enter the tests to be run, im the same format as used for TEST_FILES in a make test command line. If left empty, it means run all tests.&lt;/p&gt; &#xA;&lt;p&gt;No matter what is entered in the tests box, the tests that use SQL will only be run in the jobs that have postgres or mysql specified for database. Also, the spamd stress tests and root tests are never run.&lt;/p&gt; &#xA;&lt;p&gt;GitHub has limits on number of jobs you can run simultaneously on the various platforms. Jobs you submit that are over that limit will be queued to be started as other jobs finish.&lt;/p&gt; &#xA;&lt;p&gt;Clicking on a job listed in the left sidebar will open a pane showing the log output of the job. A job that ends with errors will have a red X icon. You can check the log output for details. Some errors will result in the t/log directory contents being zipped up as an artifact you can download. When you are viewing the log pane, click on the &lt;strong&gt;Summary&lt;/strong&gt; icon above the left sidebar, If there are any artifacts to download, there will be a number you can click on under the heading &lt;strong&gt;Artifacts&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Notes&lt;/h4&gt; &#xA;&lt;p&gt;The number of jobs run is the product of the options you specify in the three input boxes. Unless you want to test SpamAssassin on every possible version of perl, which you might if you are the release manager preparing a new release, you will likely want to select only one recent version of perl.&lt;/p&gt; &#xA;&lt;p&gt;The options box for runners only shows the &#34;-latest&#34; names, but you can enter any GitHub hosted runner that they make available, e.g. ubuntu-20.04 or macos-11.&lt;/p&gt; &#xA;&lt;p&gt;Windows is tested using Strawberry Perl, of which the latest release is 5.32. If you have 34 or 36 in the perl versions list, they will not generate jobs on the Windows platform.&lt;/p&gt; &#xA;&lt;p&gt;Jobs run using the database option postgres or mysql will only run the various sql tests. Jobs run using the none option for database will run all the other tests.&lt;/p&gt; &#xA;&lt;p&gt;Some tests, especially some that rely on network access such as t/dnsbl.t, seem to fail occassionally, especially when you are running many jobs simultaneously. After all the jobs of a workflow have completed, you can rerun just those that have failed by clicking on the &lt;strong&gt;Re-run jobs&lt;/strong&gt; button in the overview page for the jobs, and then selecting &lt;strong&gt;Re-run failed jobs&lt;/strong&gt;. Repeat until jobs that seem to be only intermittent failures have successfully passed.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>appsdesh/ChangeTracker</title>
    <updated>2023-06-26T01:43:40Z</updated>
    <id>tag:github.com,2023-06-26:/appsdesh/ChangeTracker</id>
    <link href="https://github.com/appsdesh/ChangeTracker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DB change tracking script&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Created by : Apoorva Deshpande&lt;/h2&gt; &#xA;&lt;p&gt;Contact info : &lt;a href=&#34;http://www.linkedin.com/in/appsdesh&#34;&gt;http://www.linkedin.com/in/appsdesh&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Description : Script to track and maintain database changes.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;db_script_runner is a Perl script to execute SQL scripts for updating the database -h would give you the help menu.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It will try to execute sql scripts from the folder specified by -f option.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Database name, username, password, db host could be provided as command line options.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All of the sql scripts should scrictly enforce following naming convention. sql_\d{1,10}&lt;em&gt;*.sql ( ==&amp;gt; sql&lt;/em&gt;{number}_{text}.sql where number and text are placeholders )&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Where the integer number would help in ensuring the script execution order.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For any changes in the current script one needs to create a new script with the next number in ascending order.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;This scripts maintains the database state in CONFIG_SCRIPTS table, this table keeps track of all those sql scripts which are previously executed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;db_script_runner would execute only those sql scripts which are yet to be executed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;db_script_runner follows the following algorithm a. Check if CONFIG_SRIPTS table exists. i. If NO then create it. b. Check which was the last sql script executed. c. Check in the folder for newer sql script. i. Execute newer script ( Fail on error. Manual intervention needed. ) ii. Make an entry in the CONFIG_SRIPTS table. d. exit&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;eg. db_script_runner is executed for the first time. Folder contains follwing scripts. sql_1_r2-1.sql sql_2_r2-2.sql sql_3_r2-3-prod.sql sql_4_r2-3-1.sql sql_5_r2-4.sql Then db_script_runner would create CONFIG_SCRIPT table in the specified db ( As it is running for the first time ). Since the CONFIG_SCRIPTS table is empty all sql scripts are considered NEW. db_script_runner would execute all scripts one at a time enforcing the sorted ascending order of {number}.&lt;/p&gt; &lt;p&gt;If someone modifies one of the script or adds a new script then it should be stored as sql_6_modified/added.sql The next time when db_script_runner is invoked it will check the db state by looking at CONFIG_SCRIPTS table and identifies sql_6_modified/added.sql as an only candidate for execution.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>