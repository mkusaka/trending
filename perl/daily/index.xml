<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-16T01:50:11Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pawjy/dongry</title>
    <updated>2022-07-16T01:50:11Z</updated>
    <id>tag:github.com,2022-07-16:/pawjy/dongry</id>
    <link href="https://github.com/pawjy/dongry" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dongry, a Perl object-oriented interface for MySQL databases&lt;/p&gt;&lt;hr&gt;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;Dongry::Database - Dongry MySQL database client object&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;p&gt;use Dongry::Database; my $db = Dongry::Database-&amp;gt;new (sources =&amp;gt; {default =&amp;gt; {dsn =&amp;gt; $dsn}, master =&amp;gt; {dsn =&amp;gt; $dsn, writable =&amp;gt; 1}});&lt;/p&gt; &#xA;&lt;p&gt;$db-&amp;gt;execute (&#39;CREATE TABLE table1 (col1 INT, date DATE) ENGINE=InnoDB&#39;); $db-&amp;gt;execute (&#39;INSERT INTO table1 (col1) VALUES (?), (?)&#39;, [10, 2]);&lt;/p&gt; &#xA;&lt;p&gt;my $transaction = $db-&amp;gt;transaction; $db-&amp;gt;insert (&#39;table1&#39;, [{col1 =&amp;gt; 12, date =&amp;gt; &#39;2012-01-02&#39;}]); $db-&amp;gt;update (&#39;table1&#39;, {date =&amp;gt; &#39;2001-10-02&#39;}, where =&amp;gt; {col1 =&amp;gt; {&#39;&amp;lt;&#39;, 5}}); $transaction-&amp;gt;commit;&lt;/p&gt; &#xA;&lt;p&gt;$db-&amp;gt;select (&#39;table1&#39;, {col1 =&amp;gt; $value})-&amp;gt;each_as_row (sub { warn $_-&amp;gt;get (&#39;date&#39;)-&amp;gt;ymd (&#39;/&#39;), &#34;\n&#34;; });&lt;/p&gt; &#xA;&lt;p&gt;my $table = $db-&amp;gt;table (&#39;table1&#39;); # Dongry::Table my $query = $db-&amp;gt;query (...); # Dongry::Query&lt;/p&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;B&#xA; &lt;dongry&gt;&#xA;   is a lightweight Perl interface to MySQL databases. It provides different levels of abstractions for applications to handle database operations in easy, memorable, and safe ways without stealing full control for how and when SQL queries are executed from them.&#xA; &lt;/dongry&gt;&lt;/p&gt; &#xA;&lt;p&gt;The C&lt;a href=&#34;Dongry::Database&#34;&gt;Dongry::Database&lt;/a&gt; module contains the implementation of the database object, which is the most fundamental and important object in Dongry. All of the features in Dongry can be directly or indirectly accessible from the database object, as described in the following sections.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the B&#xA; &lt;deprecated&gt;&#xA;   synchronous processing model, Dongry also supports the asynchronous event-based model by using the L&#xA;  &lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt; module as its backend. Since both modes can be switched or combined easily, you can transit one from the other, or you can partially change the processing mode, in very low cost.&#xA; &lt;/deprecated&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt; &#xA;        &lt;ul&gt; &#xA;         &lt;li&gt; &#xA;          &lt;ul&gt; &#xA;           &lt;li&gt; &#xA;            &lt;ul&gt; &#xA;             &lt;li&gt; &#xA;              &lt;ul&gt; &#xA;               &lt;li&gt; &#xA;                &lt;ul&gt; &#xA;                 &lt;li&gt; &#xA;                  &lt;ul&gt; &#xA;                   &lt;li&gt; &#xA;                    &lt;ul&gt; &#xA;                     &lt;li&gt; &#xA;                      &lt;ul&gt; &#xA;                       &lt;li&gt; &#xA;                        &lt;ul&gt; &#xA;                         &lt;li&gt; &#xA;                          &lt;ul&gt; &#xA;                           &lt;li&gt; &#xA;                            &lt;ul&gt; &#xA;                             &lt;li&gt; &#xA;                              &lt;ul&gt; &#xA;                               &lt;li&gt; &#xA;                                &lt;ul&gt; &#xA;                                 &lt;li&gt; &#xA;                                  &lt;ul&gt; &#xA;                                   &lt;li&gt; &#xA;                                    &lt;ul&gt; &#xA;                                     &lt;li&gt; &#xA;                                      &lt;ul&gt; &#xA;                                       &lt;li&gt; &#xA;                                        &lt;ul&gt; &#xA;                                         &lt;li&gt; &#xA;                                          &lt;ul&gt; &#xA;                                           &lt;li&gt; &#xA;                                            &lt;ul&gt; &#xA;                                             &lt;li&gt;&lt;/li&gt; &#xA;                                            &lt;/ul&gt; &lt;/li&gt; &#xA;                                          &lt;/ul&gt; &lt;/li&gt; &#xA;                                        &lt;/ul&gt; &lt;/li&gt; &#xA;                                      &lt;/ul&gt; &lt;/li&gt; &#xA;                                    &lt;/ul&gt; &lt;/li&gt; &#xA;                                  &lt;/ul&gt; &lt;/li&gt; &#xA;                                &lt;/ul&gt; &lt;/li&gt; &#xA;                              &lt;/ul&gt; &lt;/li&gt; &#xA;                            &lt;/ul&gt; &lt;/li&gt; &#xA;                          &lt;/ul&gt; &lt;/li&gt; &#xA;                        &lt;/ul&gt; &lt;/li&gt; &#xA;                      &lt;/ul&gt; &lt;/li&gt; &#xA;                    &lt;/ul&gt; &lt;/li&gt; &#xA;                  &lt;/ul&gt; &lt;/li&gt; &#xA;                &lt;/ul&gt; &lt;/li&gt; &#xA;              &lt;/ul&gt; &lt;/li&gt; &#xA;            &lt;/ul&gt; &lt;/li&gt; &#xA;          &lt;/ul&gt; &lt;/li&gt; &#xA;        &lt;/ul&gt; &lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;: : : Application : : : +---+------------+ : | D | Query obj. | : | o +------------+-----------+ : | n | Schema-aware ops. | : | g +------------------------+------+ : | r | Structured SQL ops. | : | y +-------------------------------+---+ : | | Bare SQL w/named placeholders | : | +-----------------------------------+---+ | | Bare SQL ops. | | +---------------------------------------+ | | Connection management | +---+---------------+-----------------------+ | DBI | | | DBD::mysql |AnyEvent::MySQL::Client| +-------------------+-----------------------+ | ^ | | v | +-------------------------------------------+ | MySQL Database | +-------------------------------------------+ Fig. Various levels of features in Dongry&lt;/p&gt; &#xA;&lt;p&gt;=head1 METHODS OF DATABASE OBJECT&lt;/p&gt; &#xA;&lt;p&gt;The most important object in Dongry is the database object. The database object is an instance of the C&lt;a href=&#34;Dongry::Database&#34;&gt;Dongry::Database&lt;/a&gt; class. It has following methods:&lt;/p&gt; &#xA;&lt;p&gt;=head2 Instantiation&lt;/p&gt; &#xA;&lt;p&gt;There are two ways to instantiate database objects. One is the C&#xA; &lt;new&gt;&#xA;   constructor method, by which you can always obtain a new instance of the database object. The other is the C&#xA;  &lt;load&gt;&#xA;    method to lookup the database object from the registry by the short name for the object.&#xA;  &lt;/load&gt;&#xA; &lt;/new&gt;&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $db = Dongry::Database-&amp;gt;new (%opts)&lt;/p&gt; &#xA;&lt;p&gt;Create and return a new instance of the L&lt;a href=&#34;Dongry::Database&#34;&gt;Dongry::Database&lt;/a&gt; database object.&lt;/p&gt; &#xA;&lt;p&gt;Options C&#xA; &lt;sources&gt;&#xA;  , C&amp;lt;master_only&amp;gt;, C&#xA;  &lt;onconnect&gt;&#xA;   , C&#xA;   &lt;onerror&gt;&#xA;    , C&#xA;    &lt;schema&gt;&#xA;     , and C&amp;lt;table_name_normalizer&amp;gt; can be specified as key/value pairs. See following subsections for their semantics and acceptable values.&#xA;    &lt;/schema&gt;&#xA;   &lt;/onerror&gt;&#xA;  &lt;/onconnect&gt;&#xA; &lt;/sources&gt;&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;my $db = Dongry::Database-&amp;gt;new (sources =&amp;gt; { default =&amp;gt; {dsn =&amp;gt; ..., username =&amp;gt; ..., password =&amp;gt; ...}, master =&amp;gt; {dsn =&amp;gt; ..., username =&amp;gt; ..., password =&amp;gt; ...}, }, onconnect =&amp;gt; sub { my ($self, %args) = @_; warn $args{source_name}, &#34;: Connected&#34;; });&lt;/p&gt; &#xA;&lt;p&gt;=item $Dongry::Database::Registry-&amp;gt;{$db_name} = {...}&lt;/p&gt; &#xA;&lt;p&gt;=item $reg = Dongry::Database-&amp;gt;create_registry&lt;/p&gt; &#xA;&lt;p&gt;There is the database definition registry, which can be accessed by the hash reference C&amp;lt;$Dongry::Database::Registry&amp;gt;. In addition, an application can create a local registry object by invoking the C&amp;lt;create_registry&amp;gt; class method. Registries are used with the C&#xA; &lt;load&gt;&#xA;   method, as described in the next subsection.&#xA; &lt;/load&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $db = Dongry::Database-&amp;gt;load ($db_name)&lt;/p&gt; &#xA;&lt;p&gt;=item $db = $reg-&amp;gt;load ($db_name)&lt;/p&gt; &#xA;&lt;p&gt;Instead of creating a new instance each time, a named database object instance can be retrieved by the C&#xA; &lt;load&gt;&#xA;   method.&#xA; &lt;/load&gt;&lt;/p&gt; &#xA;&lt;p&gt;Before the first invocation with the database name, the application has to register a short name for the database object with its initialization options, as a key/value pair of C&amp;lt;%$Dongry::Database::Registry&amp;gt; hash (for the global registry) or the C&amp;lt;&amp;lt; %{$reg-&amp;gt;{Registry}} &amp;gt;&amp;gt; hash (for a local registry).&lt;/p&gt; &#xA;&lt;p&gt;The hash key is the short database name and the hash value is the hash reference containing options used to instantiate the database object. Following options allowed for the C&#xA; &lt;new&gt;&#xA;   method is also applicable here: C&#xA;  &lt;sources&gt;&#xA;   , C&amp;lt;master_only&amp;gt;, C&#xA;   &lt;onconnect&gt;&#xA;    , C&#xA;    &lt;onerror&gt;&#xA;     , C&#xA;     &lt;schema&gt;&#xA;      , and C&amp;lt;table_name_normalizer&amp;gt;.&#xA;     &lt;/schema&gt;&#xA;    &lt;/onerror&gt;&#xA;   &lt;/onconnect&gt;&#xA;  &lt;/sources&gt;&#xA; &lt;/new&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alteranatively, some of these values can be specified as code reference which is invoked to get the actual value when an object is initialized, by prefixing C&amp;lt;get_&amp;gt; to the hash key, i.e. C&amp;lt;get_sources&amp;gt;, C&amp;lt;get_onconnect&amp;gt;, C&amp;lt;get_onerror&amp;gt;, C&amp;lt;get_schema&amp;gt;, and C&amp;lt;get_table_name_normalizer&amp;gt;. The code reference will be invoked without any argument. The code reference must return a value that is allowed for the option (e.g. C&amp;lt;get_onconnect&amp;gt; code reference must return an C&#xA; &lt;onconnect&gt;&#xA;   handler code reference).&#xA; &lt;/onconnect&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then, you can use the short database name as the argument to the C&#xA; &lt;load&gt;&#xA;   method to get the instance initialized with the specified options. The instantiation happens only once (per registry). Invocations of the method with the same database name always return the same database object instance. You can control the lifetime of the instances by accessing (e.g. clearing or C&#xA;  &lt;local&gt;&#xA;   izing) the C&amp;lt;$Dongry::Database::Instances&amp;gt; hash reference (for the global registry) or the C&amp;lt;&amp;lt; $reg-&amp;gt;{Instances} &amp;gt;&amp;gt; hash reference (for a local registry).&#xA;  &lt;/local&gt;&#xA; &lt;/load&gt;&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;$Dongry::Database::Registry-&amp;gt;{user} = { sources =&amp;gt; { master =&amp;gt; ..., default =&amp;gt; ..., }, onconnect =&amp;gt; sub { warn &#34;User connected&#34;; }, get_schema =&amp;gt; sub { return My::DatabaseInfo-&amp;gt;schema }, }; $db = Dongry::Database-&amp;gt;load (&#39;user&#39;); $db2 = Dongry::Database-&amp;gt;load (&#39;user&#39;); # same as $db&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head2 Connections&lt;/p&gt; &#xA;&lt;p&gt;A database object can have multiple (physically different) connections to databases. A connection is identified by a short string known as I&lt;data source name&gt;, e.g. C&#xA;  &lt;default&gt;&#xA;    and C&#xA;   &lt;master&gt;&#xA;    .&#xA;   &lt;/master&gt;&#xA;  &lt;/default&gt;&lt;/data&gt;&lt;/p&gt; &#xA;&lt;p&gt;Multiple connections can be used to adopt to different database server deployment strategies, such as:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item A single database server.&lt;/p&gt; &#xA;&lt;p&gt;In this case, the only data source name C&#xA; &lt;master&gt;&#xA;   should be used.&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item A master-slave database server pair.&lt;/p&gt; &#xA;&lt;p&gt;In this case, the data source name C&#xA; &lt;master&gt;&#xA;   should be used for the master server and C&#xA;  &lt;default&gt;&#xA;    for the slave server. Then the C&#xA;   &lt;default&gt;&#xA;     data source name is used for read-only SQL statements and the C&#xA;    &lt;master&gt;&#xA;      for any other, unless explicitly specified.&#xA;    &lt;/master&gt;&#xA;   &lt;/default&gt;&#xA;  &lt;/default&gt;&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item A master-slave database server pair with additional servers for &#34;heavy&#34; queries.&lt;/p&gt; &#xA;&lt;p&gt;In this case, in addition to C&#xA; &lt;master&gt;&#xA;   and C&#xA;  &lt;default&gt;&#xA;    data source names, any application-specific non-false short string, such as C&#xA;   &lt;heavy&gt;&#xA;     or C&#xA;    &lt;batch&gt;&#xA;     , can be used to identify additional servers. Then such additional source names can be specified to SQL executions as options.&#xA;    &lt;/batch&gt;&#xA;   &lt;/heavy&gt;&#xA;  &lt;/default&gt;&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item A complex set of database servers.&lt;/p&gt; &#xA;&lt;p&gt;In this case, any application-specific non-false short string can be used as data source names, but the appropriate data source name must be specified for all SQL executions explicitly.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;Operations in a transaction are always executed with the C&#xA; &lt;master&gt;&#xA;   data source name.&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;It might also be useful to define synchronous and asyncrhonous data source names for transitional applications that are only partially operated in terms of L&#xA; &lt;anyevent&gt;&#xA;  .&#xA; &lt;/anyevent&gt;&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;source ($source_name =&amp;gt; $source_info)&lt;/p&gt; &#xA;&lt;p&gt;=item $source_info = $db-&amp;gt;source ($source_name)&lt;/p&gt; &#xA;&lt;p&gt;=item $db = Dongry::Database-&amp;gt;new (sources =&amp;gt; {$source_name =&amp;gt; $source_info, ...})&lt;/p&gt; &#xA;&lt;p&gt;Get or set data source information for the specified data source name. It is a hash reference containg following key/value pairs:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item dsn =&amp;gt; string (REQUIRED)&lt;/p&gt; &#xA;&lt;p&gt;The &#34;dsn&#34; string used to connect the database. See L&#xA; &lt;dbi&gt;&#xA;   and &#xA;  &lt;a href=&#34;https://metacpan.org/pod/distribution/DBD-mysql/lib/DBD/mysql.pm#connect&#34;&gt;https://metacpan.org/pod/distribution/DBD-mysql/lib/DBD/mysql.pm#connect&lt;/a&gt; for more information.&#xA; &lt;/dbi&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item username =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;The user name used to connect the database. This is optional if the database or the database driver module does not require user name.&lt;/p&gt; &#xA;&lt;p&gt;=item password =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;The password used to connect the database. This is optional if the database or the database driver module does not require password.&lt;/p&gt; &#xA;&lt;p&gt;=item writable =&amp;gt; boolean&lt;/p&gt; &#xA;&lt;p&gt;Whether the database is writable or not. If not writable, the database module refuse to issue write operations as far as possible. Default is false (i.e. not writable).&lt;/p&gt; &#xA;&lt;p&gt;=item anyevent =&amp;gt; boolean&lt;/p&gt; &#xA;&lt;p&gt;Whether the asynchronous mode using L&lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt; should be enabled or not. This option should be set to true (i.e. the asynchronous mode should be used).&lt;/p&gt; &#xA;&lt;p&gt;=item label =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;Informative name of the data source. It is not used to connect to the data source. This value might or might not be useful for debugging. Default is same as C&#xA; &lt;dsn&gt;&#xA;  .&#xA; &lt;/dsn&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item sql_comment =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;Comment string to be embedded at the end of the SQL statements. As described in L&amp;lt;/&#34;INTERPREATAION OF STRINGS&#34;&amp;gt;, non-ASCII characters, as well as utf8-flaged strings, should not be specified. This option might be useful for debugging and loggin purposes.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;Although it is in theory possible to modify the hash reference after it is set to the database object, such modifications might not be reflected to the actual connection, depending on the exact timing of the modification and establishment of the connection. Therefore, you should not try to modify these values once it is set to the database object.&lt;/p&gt; &#xA;&lt;p&gt;TLS or SSL can be used to connect to the server by specifying C&amp;lt;mysql_&lt;em&gt;&amp;gt; options in C&#xA;  &lt;dsn&gt;&#xA;   . However, please note that L&#xA;   &lt;a href=&#34;DBD::mysql&#34;&gt;DBD::mysql&lt;/a&gt;, which is used in the synchronous mode through L&#xA;   &lt;dbi&gt;&#xA;    , might not be compiled with SSL-support enabled, in which case L&#xA;    &lt;a href=&#34;DBD::mysql&#34;&gt;DBD::mysql&lt;/a&gt; silently ignores C&amp;lt;mysql_&#xA;   &lt;/dbi&gt;&#xA;  &lt;/dsn&gt;&lt;/em&gt;&amp;gt; options (!). Once connected, the application can determine whether TLS is used or not by the following code:&lt;/p&gt; &#xA;&lt;p&gt;$tls_enabled = $db-&amp;gt;execute (&#39;SHOW STATUS LIKE &#34;Ssl_cipher&#34;&#39;) -&amp;gt;first-&amp;gt;{Value} ne &#39;&#39;;&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;onconnect ($code)&lt;/p&gt; &#xA;&lt;p&gt;=item $code = $db-&amp;gt;onconnect&lt;/p&gt; &#xA;&lt;p&gt;=item $db = Dongry::Database-&amp;gt;new (onconnect =&amp;gt; $code)&lt;/p&gt; &#xA;&lt;p&gt;Get or set the code reference which is invoked when a new connection is established.&lt;/p&gt; &#xA;&lt;p&gt;Use of the C&#xA; &lt;onconnect&gt;&#xA;   handler is B&#xA;  &lt;deprecated&gt;&#xA;   .&#xA;  &lt;/deprecated&gt;&#xA; &lt;/onconnect&gt;&lt;/p&gt; &#xA;&lt;p&gt;The code reference, when invoked, receives the &#34;self&#34; argument followed by zero or more key/value pairs. The &#34;self&#34; argument is the database object. The key/value pairs would contain:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item source_name =&amp;gt; string (ALWAYS)&lt;/p&gt; &#xA;&lt;p&gt;The name of the data source used to establish the connection.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;The default C&#xA; &lt;onconnect&gt;&#xA;   handler does nothing.&#xA; &lt;/onconnect&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please be aware the C&#xA; &lt;onconnect&gt;&#xA;   handler is not safe place to execute SQL statements in general because it could result in establishing another connection within the C&#xA;  &lt;onconnect&gt;&#xA;    handler. It is, however, safe to execute an SQL statement using the same data source name as given by the C&amp;lt;source_name&amp;gt; option. It might be an interesting use case of this handler to execute some configuration statements (e.g. C&#xA;   &lt;set time_zone&gt;&#xA;     statement) for the connection in the handler.&#xA;   &lt;/set&gt;&#xA;  &lt;/onconnect&gt;&#xA; &lt;/onconnect&gt;&lt;/p&gt; &#xA;&lt;p&gt;Strictly speaking, there might not be a physical connection to the database server when the C&#xA; &lt;onconnect&gt;&#xA;   handler is invoked. In particular, if the C&#xA;  &lt;anyevent&gt;&#xA;    option of the data source is set, the C&#xA;   &lt;onconnect&gt;&#xA;     handler is invoked after the L&#xA;    &lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt; object is instantiated, but the actual connection might not been established at that time. You can assume that the C&#xA;    &lt;onconnect&gt;&#xA;      handler is invoked before any SQL statements or start of transactions are queued to execute with the connection, even when the C&#xA;     &lt;anyevent&gt;&#xA;       option is true.&#xA;     &lt;/anyevent&gt;&#xA;    &lt;/onconnect&gt;&#xA;   &lt;/onconnect&gt;&#xA;  &lt;/anyevent&gt;&#xA; &lt;/onconnect&gt;&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;$Dongry::Database::Registry-&amp;gt;{hoge} = { ... onconnect =&amp;gt; sub { my ($self, %args) = @_; $self-&amp;gt;execute (&#39;set time_zone = &#34;+00:00&#34;&#39;, [], even_if_read_only =&amp;gt; 1, ## This is important! source_name =&amp;gt; $args{source_name}); }, }:&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;onerror ($code)&lt;/p&gt; &#xA;&lt;p&gt;=item $code = $db-&amp;gt;onerror&lt;/p&gt; &#xA;&lt;p&gt;=item $db = Dongry::Database-&amp;gt;new (onerror =&amp;gt; $code)&lt;/p&gt; &#xA;&lt;p&gt;Get or set the code reference which is invoked when an error is detected during various operations, such as connection to databases or execution of queries.&lt;/p&gt; &#xA;&lt;p&gt;Use of the C&#xA; &lt;onerror&gt;&#xA;   handler is B&#xA;  &lt;deprecated&gt;&#xA;   .&#xA;  &lt;/deprecated&gt;&#xA; &lt;/onerror&gt;&lt;/p&gt; &#xA;&lt;p&gt;The code reference, when invoked, receives the &#34;self&#34; argument followed by zero or more key/value pairs. The &#34;self&#34; argument is the database object. The key/value pairs would contain:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item source_name =&amp;gt; string (ALWAYS)&lt;/p&gt; &#xA;&lt;p&gt;The name of the data source for the relevant database connection.&lt;/p&gt; &#xA;&lt;p&gt;=item text =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;A short string describing the situation, if available. This is typically an error message from the underlying L&#xA; &lt;dbi&gt;&#xA;   or database driver modules.&#xA; &lt;/dbi&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item sql =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;The SQL statement being executed, if any.&lt;/p&gt; &#xA;&lt;p&gt;=item file_name =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;=item line =&amp;gt; number&lt;/p&gt; &#xA;&lt;p&gt;The location of the error. These values are only available in asynchronous mode. In synchronous mode, the L&#xA; &lt;carp&gt;&#xA;   module is useful to detect the error location. In asynchronous mode, however, the module only denotes somewhere in the implementation of the event loop.&#xA; &lt;/carp&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;The default C&#xA; &lt;onerror&gt;&#xA;   handler prints the error message to the standard error output.&#xA; &lt;/onerror&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please don&#39;t do anything much more complex than just reporting the error to someone else. In particular, don&#39;t try to execute another SQL statement in the error handler, as it would likely result in another SQL execution error, which would recursively invoke the same error handler.&lt;/p&gt; &#xA;&lt;p&gt;Error handling in synchronous (L&#xA; &lt;dbi&gt;&#xA;   and L&#xA;  &lt;a href=&#34;DBD::mysql&#34;&gt;DBD::mysql&lt;/a&gt;) mode and asynchronous (L&#xA;  &lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt;) mode are different in several ways.&#xA; &lt;/dbi&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the synchronous mode, errors are also handled in synchronously. If the connection or an SQL statement causes an error because of a method invocation, any C&#xA; &lt;onerror&gt;&#xA;   handler is invoked and then an exception is thrown within the method. If you specify an error handler, you can throw an exception (or simply C&#xA;  &lt;die&gt;&#xA;   ) within the handler. Please note that the C&#xA;   &lt;cb&gt;&#xA;     (callback) function given to the method to access the database, if any, is not invoked for the error in synchronous mode. You can continue to use the connection to execute subsequent SQL statements, if desired. (Please note that if the error is fatal and permanent, the subsequent executions would also result in error. In such situation, you might want to invoke the C&#xA;    &lt;disconnect&gt;&#xA;      method explicitly to reestablish the connection.)&#xA;    &lt;/disconnect&gt;&#xA;   &lt;/cb&gt;&#xA;  &lt;/die&gt;&#xA; &lt;/onerror&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode of L&lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt;, as SQL statements are executed asynchronously, errors are also reported asynchronously. If the method to access to the database accepts the C&#xA; &lt;cb&gt;&#xA;   (callback) option, the callback function is invoked even if there is an error, but with the argument describing the error (See the documentation of the C&#xA;  &lt;execute&gt;&#xA;    method for details). Then, the C&#xA;   &lt;onerror&gt;&#xA;     handler of the database object is invoked for the error. No exception is thrown by Dongry. The C&#xA;    &lt;onerror&gt;&#xA;      handler and C&#xA;     &lt;cb&gt;&#xA;       functions should not throw any exception in asynchronous mode. That means that if another statement is enqueued after an errorneous statement, that statement I&#xA;      &lt;is&gt;&#xA;        executed after the error. If it is not desired, the result of the previous statement must be checked before the next statement is enqueued.&#xA;      &lt;/is&gt;&#xA;     &lt;/cb&gt;&#xA;    &lt;/onerror&gt;&#xA;   &lt;/onerror&gt;&#xA;  &lt;/execute&gt;&#xA; &lt;/cb&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;connect ($source_name, %opts)&lt;/p&gt; &#xA;&lt;p&gt;Connect to the data source whose name is specified by the argument, if any, or the C&#xA; &lt;default&gt;&#xA;   data source, otherwise. If there is already a connection established for the specified data source, the method does nothing. After a connection has been established, the C&#xA;  &lt;onconnect&gt;&#xA;    handler is invoked.&#xA;  &lt;/onconnect&gt;&#xA; &lt;/default&gt;&lt;/p&gt; &#xA;&lt;p&gt;You don&#39;t have to invoke this method explicitly in general. This method is automatically invoked at the first time an operation that requires the connection is enforced.&lt;/p&gt; &#xA;&lt;p&gt;Returning from the method does not necessarily mean the physical connection to the database has been established. In particular, if the asynchronous mode is used for the connection, the method only does instantiate the L&lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt; method and the actual connection is established asynchronously.&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode, the returned object is I&#xA; &lt;thenable&gt;&#xA;  .&#xA; &lt;/thenable&gt;&lt;/p&gt; &#xA;&lt;p&gt;The following option is available:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item cb =&amp;gt; code-reference (DEPRECATED)&lt;/p&gt; &#xA;&lt;p&gt;The callback function invoked when the connection has been established (or immediately if the connection is already established).&lt;/p&gt; &#xA;&lt;p&gt;In the synchronous mode, the code reference is synchronously invoked when the connection has been successfully established.&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronos mode, the code reference is asynchronously invoked when the connection has been successfully or erronerously established, except when the C&#xA; &lt;connect&gt;&#xA;   method is invoked within the C&#xA;  &lt;onconnect&gt;&#xA;    handler for the same C&amp;lt;source_name&amp;gt;, in which case the callback is synchronously invoked.&#xA;  &lt;/onconnect&gt;&#xA; &lt;/connect&gt;&lt;/p&gt; &#xA;&lt;p&gt;The code reference receives two arguments: the database object and a return object which contains whether the connection has been successfully established (C&amp;lt;&amp;lt; $&lt;em&gt;[1]-&amp;gt;is_success &amp;gt;&amp;gt;) or not (C&amp;lt;&amp;lt; $&lt;/em&gt;[1]-&amp;gt;is_error &amp;gt;&amp;gt;).&lt;/p&gt; &#xA;&lt;p&gt;The code reference should not throw any exception. See the C&#xA; &lt;onerror&gt;&#xA;   method for rationale.&#xA; &lt;/onerror&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode, the C&#xA; &lt;then&gt;&#xA;   method of the returned object should be used instead of the callback function.&#xA; &lt;/then&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;disconnect ($source_name, %opts)&lt;/p&gt; &#xA;&lt;p&gt;If a data source name is specified, disconnect the connection for the data source. Otherwise, disconnect all the connections hold by the database object. If there is no connection for the data source, the method does nothing.&lt;/p&gt; &#xA;&lt;p&gt;Any B&#xA; &lt;synchronous&gt;&#xA;   connection is disconnected immediately. If there is an uncommitted synchronous transaction, it is rollbacked.&#xA; &lt;/synchronous&gt;&lt;/p&gt; &#xA;&lt;p&gt;Any B&#xA; &lt;asynchronous&gt;&#xA;   connection is disconnected once it becomes free. That is, any ongoing or queued SQL statement or asynchronous transaction is still executed after the C&#xA;  &lt;disconnect&gt;&#xA;    method call.&#xA;  &lt;/disconnect&gt;&#xA; &lt;/asynchronous&gt;&lt;/p&gt; &#xA;&lt;p&gt;The application should explicitly invoke this method to grecefully shutdown the connection to the server. Otherwise some of the ongoing or queued statements might be discarded by the client or by the server.&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode, the returned object is I&#xA; &lt;thenable&gt;&#xA;  .&#xA; &lt;/thenable&gt;&lt;/p&gt; &#xA;&lt;p&gt;The following option is available:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item cb =&amp;gt; code-reference (DEPRECATED)&lt;/p&gt; &#xA;&lt;p&gt;The callback function invoked when the connection has been closed (or immediately if the connection is already closed).&lt;/p&gt; &#xA;&lt;p&gt;In the synchronous mode, the code reference is synchronously invoked when the connection has been closed.&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronos mode, the code reference is asynchronously invoked when the connection has been closed.&lt;/p&gt; &#xA;&lt;p&gt;The code reference receives a arguments: the database object.&lt;/p&gt; &#xA;&lt;p&gt;The code reference should not throw any exception. See the C&#xA; &lt;onerror&gt;&#xA;   method for rationale.&#xA; &lt;/onerror&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode, the C&#xA; &lt;then&gt;&#xA;   method of the returned object should be used instead of the callback function.&#xA; &lt;/then&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;By default SQL executions are automatically committed (i.e. C&#xA; &lt;autocommit&gt;&#xA;   option of the L&#xA;  &lt;dbi&gt;&#xA;    object is set to true). Use of transaction object can override this behavior:&#xA;  &lt;/dbi&gt;&#xA; &lt;/autocommit&gt;&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $transaction = $db-&amp;gt;transaction (when master is in synchronous mode)&lt;/p&gt; &#xA;&lt;p&gt;If the source C&#xA; &lt;master&gt;&#xA;   is in the synchronous mode, the method starts a transaction and returns the synchronous transaction object for the transaction. The synchronous transaction object is a &#34;guard&#34; object; The transaction is effective as long as the object is live.&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once you get a synchronous transaction object, you can invoke SQL operations as usual, through various methods of Dongry. In addition, the C&#xA; &lt;lock&gt;&#xA;   option for C&#xA;  &lt;select&gt; and other retrieval methods becomes available in the transaction. Within a transaction you can only use the C data source. The default data source is C, not C, within a transaction. =item $db-&amp;gt;transaction-&amp;gt;then (sub { $transaction = $_[0] }) (when master is in asynchronous mode) If the source C is in the asynchronous mode, the method returns a promise that is fulfillwed after a transaction is started. The promise is fulfilled with an asynchronous transaction object for the transaction. =back Once you get an B transaction object, you can invoke SQL operations using the methods of the asynchronous transaction object: =over 4 =item $result = $transaction-&amp;gt;execute (...) =item $result = $transaction-&amp;gt;select (...) =item $result = $transaction-&amp;gt;insert (...) =item $result = $transaction-&amp;gt;update (...) =item $result = $transaction-&amp;gt;delete (...) Send an SQL statement. These methods are equivalent to the methods of the Dongry database object but SQL statements are associated with the transaction. The C&amp;lt;source_name&amp;gt; option is not allowed. They are always assumed as C. The C&lt;/select&gt; method supports the C&#xA;  &lt;lock&gt;&#xA;    option.&#xA;  &lt;/lock&gt;&#xA; &lt;/lock&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;After execution of zero or more SQL statements, you have to commit or rollback the transaction to save or discard the modifications, using a method of the synchronous or asynchronous transaction object:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $transaction-&amp;gt;commit (%opts)&lt;/p&gt; &#xA;&lt;p&gt;Commit the transaction. Changes will be persisted by the database.&lt;/p&gt; &#xA;&lt;p&gt;The C&#xA; &lt;cb&gt;&#xA;   option is available. See C&#xA;  &lt;execute&gt;&#xA;    method for more information. The result object for the C&#xA;   &lt;commit&gt;&#xA;     method only contains whether there is an error or not and description for the error, if any.&#xA;   &lt;/commit&gt;&#xA;  &lt;/execute&gt;&#xA; &lt;/cb&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $transaction-&amp;gt;rollback (%opts)&lt;/p&gt; &#xA;&lt;p&gt;Rollback the transaction. Changes will be discarded by the database.&lt;/p&gt; &#xA;&lt;p&gt;The C&#xA; &lt;cb&gt;&#xA;   option is available. See C&#xA;  &lt;execute&gt;&#xA;    method for more information. The result object for the C&#xA;   &lt;rollback&gt;&#xA;     method only contains whether there is an error or not and description for the error, if any.&#xA;   &lt;/rollback&gt;&#xA;  &lt;/execute&gt;&#xA; &lt;/cb&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $string = $transaction-&amp;gt;debug_info&lt;/p&gt; &#xA;&lt;p&gt;Return a string that shortly describes the object. It might or might not be useful for debugging.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;Exactly one of C&#xA; &lt;commit&gt;&#xA;   and C&#xA;  &lt;rollback&gt;&#xA;    methods must be invoked to terminate the transaction. Once one of them are invoked, the synchronous or asynchronous transaction object lost its effect, even if it has not been destroyed by Perl. This is different from usual &#34;guard&#34; objects, including the &#34;force source&#34; object described below.&#xA;  &lt;/rollback&gt;&#xA; &lt;/commit&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you forgot to commit or rollback the changes, they will be discarded when the synchronous or asynchronous transaction object is destroyed by Perl. Don&#39;t rely on this behavior since it is not guaranteed by Perl exactly when an object is destroyed and the rollback statement might not be successfully sent to the server depending on how the event loop and object destruction interact together.&lt;/p&gt; &#xA;&lt;p&gt;After the C&#xA; &lt;commit&gt;&#xA;   or C&#xA;  &lt;rollback&gt;&#xA;    method is invoked on a B&#xA;   &lt;synchronous&gt;&#xA;     transaction object, you can start another synchronous transaction session by calling the C&amp;lt;&amp;lt; $db-&amp;gt;transaction &amp;gt;&amp;gt; method again. A new synchronous transaction cannot be initiated while there is another synchronous transaction.&#xA;   &lt;/synchronous&gt;&#xA;  &lt;/rollback&gt;&#xA; &lt;/commit&gt;&lt;/p&gt; &#xA;&lt;p&gt;During there is an B&#xA; &lt;asynchronous&gt;&#xA;   transaction object, the Dongry database object&#39;s statement methods are also available but they are I&#xA;  &lt;not&gt;&#xA;    associated with the transaction. Such statements are sent to the server after the conclusion of the transaction. Likewise, a new asynchronous transaction can be started even when there is anothor ongoing transaction.&#xA;  &lt;/not&gt;&#xA; &lt;/asynchronous&gt;&lt;/p&gt; &#xA;&lt;p&gt;When you just want to use a particular data source for some operations, you can use the &#34;force source&#34; feature:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $force = $db-&amp;gt;force_source_name ($source_name)&lt;/p&gt; &#xA;&lt;p&gt;Return a &#34;guard&#34; object that forces the use of a data source specified as the argument.&lt;/p&gt; &#xA;&lt;p&gt;While the I&amp;lt;$force&amp;gt; object is in scope (or before the C&#xA; &lt;end&gt;&#xA;   method of the object is invoked), the C&#xA;  &lt;execute&gt;&#xA;    method and the other methods to execute SQL statements act as if the C&amp;lt;source_name&amp;gt; option with the given source name is specified, except that if the C&amp;lt;source_name&amp;gt; is explicitly specified to use another data source for the method, the method would report an error instead.&#xA;  &lt;/execute&gt;&#xA; &lt;/end&gt;&lt;/p&gt; &#xA;&lt;p&gt;It is an error to call this method while there is an active I&amp;lt;$force&amp;gt; object. In other word, you cannot force a data source while another data source is forced. Likewise, you cannot start a transaction when a data source is forced; and you cannot force a data source within a transaction. The transaction automatically forces the C&#xA; &lt;master&gt;&#xA;   data source.&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method is not supported in asynchronous mode.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;The &#34;force&#34; object has following methods:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $force-&amp;gt;end&lt;/p&gt; &#xA;&lt;p&gt;End to force the data source. Although this method is automatically called when the I&amp;lt;$force&amp;gt; object is destroyed by Perl, it is encouraged to call this method explicitly as Perl does not guarantee the exact timing for the destruction of an object.&lt;/p&gt; &#xA;&lt;p&gt;=item $string = $force-&amp;gt;debug_info&lt;/p&gt; &#xA;&lt;p&gt;Return a short string that might or might not be useful for debugging.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;The scope of the forcing object affects the queueing, not the actual execution in asynchronous mode, as for the transaction object.&lt;/p&gt; &#xA;&lt;p&gt;=head2 Bare SQL operations&lt;/p&gt; &#xA;&lt;p&gt;The bare SQL execution API of Dongry, i.e. the C&#xA; &lt;execute&gt;&#xA;   method, executes SQL statements provided by the application as is, with few modifications. It would be useful if you&#39;d like to issue a complex or rarely-used kind of SQL statement and if you really and completely understand what you are doing. For common operations such as insertion and selection, please consider using more abstract APIs described in following sections.&#xA; &lt;/execute&gt;&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $result = $db-&amp;gt;execute ($sql, [$value1, $value2, ...], %opts)&lt;/p&gt; &#xA;&lt;p&gt;=item $result = $db-&amp;gt;execute ($sql, {param1 =&amp;gt; $value1, ...}, %opts)&lt;/p&gt; &#xA;&lt;p&gt;Execute an SQL statement.&lt;/p&gt; &#xA;&lt;p&gt;B&#xA; &lt;sql with anonymous placeholders&gt;&#xA;  : The first argument is the SQL statement to execute, which possibly contains placeholders (C&amp;lt;?&amp;gt;). The second argument is an array reference, which contains values bound to the placeholders. The second argument can be omitted (i.e. can be C&#xA;  &lt;undef&gt;&#xA;   ) if there are no placeholders.&#xA;  &lt;/undef&gt;&#xA; &lt;/sql&gt;&lt;/p&gt; &#xA;&lt;p&gt;B&#xA; &lt;sql with named placeholders&gt;&#xA;  : The first argument is the SQL statement to execute, which possibly contains named placeholders such as C&amp;lt;:params&amp;gt;. The second argument is a hash reference, which contains name-value pairs bound to the placeholders. For more information on the I&#xA;  &lt;named placeholders&gt;&#xA;   , see L&#xA;   &lt;a href=&#34;Dongry::SQL&#34;&gt;Dongry::SQL&lt;/a&gt;.&#xA;  &lt;/named&gt;&#xA; &lt;/sql&gt;&lt;/p&gt; &#xA;&lt;p&gt;In addition, following key/value pairs can be specified as options:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item source_name =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;The name of the data source used to select the database connection. If there is no connection established for the data source, the C&#xA; &lt;connect&gt;&#xA;   method with the source name is automatically invoked and then the SQL statement is executed over that connection.&#xA; &lt;/connect&gt;&lt;/p&gt; &#xA;&lt;p&gt;If this option is not specified, an appropriate data source is determined. In general the C&#xA; &lt;master&gt;&#xA;   data source is chosen. However, if the SQL is known to read-only, i.e. it begins by C&#xA;  &lt;select&gt;, C, or C, the C data source is chosen. Note that transactions and &#34;force source&#34; objects would modify this default. =item must_be_writable =&amp;gt; boolean If this option is set to true, the method would raise an error without executing the SQL statement when the selected data source is I marked as I. If this option is set to true and the C&amp;lt;source_name&amp;gt; option is I specified, the data source is set to C even if the SQL statement is considered as read-only. =item even_if_read_only =&amp;gt; boolean If this option is set to true, the method would not raise an error even when the SQL statement is not considered as read-only but the selected data source is I marked as I. This option would be useful to issue an C statement to set configuration options for the connection, as the method does not consider the C statements as read-only but it should be applied even to a read-only data source. You should not specify both C&amp;lt;must_be_writable&amp;gt; and C&amp;lt;even_if_read_only&amp;gt; options at the same time. =item table_name =&amp;gt; table-name If this option is set to a value, it is used as the value of the result object&#39;s C&amp;lt;table_name&amp;gt; property, if the SQL execution has been succeeded. Otherwise, the result object returned by the C method has the C&amp;lt;table_name&amp;gt; value of C, which means that C&amp;lt;*_as_row&amp;gt; methods on the result object and the C&amp;lt;each_as_row_cb&amp;gt; option of this method cannot be used. =item each_cb =&amp;gt; code-reference =item each_as_row_cb =&amp;gt; code-reference The callback functions that is invoked whenever rows are received from the server. They behave as if the argument of the C or C&amp;lt;each_as_row&amp;gt; method of the result object returned by the C method. In asynchronous mode, as C and C&amp;lt;each_as_row&amp;gt; methods of the return object are not available, these callbacks must be used. In synchronous mode, both those methods and these callbacks are available, but if callbacks are specified, methods are disabled. Anyway, at most one of these callbacks can be specified. The callback is not expected to throw any exception. =item cb =&amp;gt; code-reference (DEPRECATED) The callback function invoked when the SQL has been executed. In the synchronous mode, the code reference is synchronously invoked when the SQL has successfully been executed. In the asynchronous mode, the code reference is asynchronously invoked when the SQL has been executed, successfully or erroneously. The code reference receives two arguments: the database object and the result object that would be returned by the method in synchronous mode. In asynchronous mode, the result object describes the error. The code reference should not throw any exception in asynchronous mode. See the C method for rationale. In the asynchronous mode, the C method of the returned object should be used instead of the callback function. =back The method would return a result object which is I bound to any table. The number of affected rows (or the rows to be fetched) can be retrieved from the C&amp;lt;row_count&amp;gt; method of the result object. If the SQL statement returns rows (e.g. C&lt;/select&gt; or C&#xA;  &lt;show&gt;&#xA;   ), they are accessible from various methods of the result object. The method does not return a value in asynchronous mode.&#xA;  &lt;/show&gt;&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode, the returned object is I&#xA; &lt;thenable&gt;&#xA;  .&#xA; &lt;/thenable&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head2 Structured SQL operations&lt;/p&gt; &#xA;&lt;p&gt;Methods described in this section construct an SQL statement from the given arguments and then execute it. Commonly-used patterns of SQL statements such as C&lt;select&gt; and C are supported by these methods such that an application does not have to concatenate, quote, or otherwise modify bare SQL statements by itself in most cases. =over 4 =item $result = $db-&amp;gt;insert ($table_name, [$values1, $values2, ...], %opts) Insert one or more rows into the table specified by the first argument. The second argument must be an array reference which contains one or more hash references, each of them is a row to be inserted (represented as column name/value pairs). Unspecified columns will be set to their default values by the database. In addition, following options can be specified as key/value pairs: =over 4 =item source_name =&amp;gt; string The name of the data source used to select the database connection. For more information on how data source is selected, see the description for the C method. =item duplicate =&amp;gt; &#34;ignore&#34; / &#34;replace&#34; / arrayref / hashref How &#34;duplicate entry&#34; error is handled by the database. If C is specified, an C statement is issued such that any duplicate insertion will be ignored without errors being reported. Please note that this statement might ignore any other possible error as well. If C is specified, an C statement is issued such that any duplicate rows will be discarded before the insertion. If an array or hash reference is specified, the C clause is appended to the C statement with the values specified in the array or hash. The format of the hash reference is same as the second argument of the C method. An array whose content is equal to a hash can be specified to preserve order of key/value pairs. Note that the order of SQL fragments are significant when they contain column names. If this option is not specified, then a normal C statement is issued such that any duplication would be reported as an SQL execution error through the C handler. =item cb =&amp;gt; code-reference (DEPRECATED) The callback function invoked after the execution of the SQL statement. See the C method for more information. In the asynchronous mode, the C method of the returned object should be used instead of the callback function. =back This method, in the synchronous mode, returns a result object bound to the table specified as the first argument. The number of affected rows can be retrieved from the C&amp;lt;row_count&amp;gt; method of the result object. Althugh inserted rows can be accessible from various methods of the result object, please note that the object only holds the data as received as the argument to the C method. It might not reflect any SQL-level default values, auto-increment values, server-side value normalization, handling of C options, use of bare SQL fragments, and so on. If you really like to know what is inserted (or not inserted) to the database, you have to select the inserted row(s) by yourself. In the case you have explicitly specified the primary key values in the argument, the C method of table row objects obtained from the result object might be useful for this purpose. Example: $db-&amp;gt;insert (&#39;mytable&#39;, [ {id =&amp;gt; 12, name =&amp;gt; &#39;Foo&#39;, date =&amp;gt; 0}, {id =&amp;gt; 13, name =&amp;gt; &#39;Bar&#39;}, {id =&amp;gt; 14, name =&amp;gt; undef, date =&amp;gt; &#39;2012-03-01&#39;}, ]); INSERT INTO mytable (id, name, date) VALUES (&#39;12&#39;, &#39;Foo&#39;, &#39;0&#39;), (&#39;13&#39;, &#39;Bar&#39;, DEFAULT), (&#39;14&#39;, NULL, &#39;2012-03-01&#39;) In the asynchronous mode, the returned object is I. =item $result = $db-&amp;gt;select ($table_name, $where, %opts) Select rows from the table specified as the first argument. Conditions to select rows, i.e. the C clause of the SQL statement, must be specified as the second argument, in that format described in LDongry::SQL. In addition, following options can be specified as key/value pairs: =over 4 =item source_name =&amp;gt; string The name of the data source used to select the database connection. For more information on how data source is selected, see the description for the C method. =item must_be_writable =&amp;gt; boolean If this option is set to true, the method would raise an error without executing the SQL statement if the selected data source is marked as I. For more information on how this option applies, see the description for the C method. =item distinct =&amp;gt; boolean If this options is set to true, the C keyword is put in the statement such that only a row is returned for a duplicate set of rows. =item fields =&amp;gt; fields-struct The columns to retrieve, to be specified just after the C&lt;/select&gt; keyword of the issued SQL statement. The value must be a fields struct, as described in L&lt;a href=&#34;Dongry::SQL&#34;&gt;Dongry::SQL&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;p&gt;[undef, &#39;c1&#39;] # &lt;em&gt;, &lt;code&gt;c1&lt;/code&gt; [{-count =&amp;gt; undef}, &#39;c1&#39;, &#39;c2&#39;] # COUNT(&lt;/em&gt;), &lt;code&gt;c1&lt;/code&gt;, &lt;code&gt;c2&lt;/code&gt; [{-count =&amp;gt; &#39;c1&#39;, as =&amp;gt; &#39;c&#39;, distinct =&amp;gt; 1}] # COUNT(DISTINCT &lt;code&gt;c1&lt;/code&gt;) AS &lt;code&gt;c&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item group =&amp;gt; [column1, column2, ...]&lt;/p&gt; &#xA;&lt;p&gt;The columns to use grouping, i.e. column names for the C&#xA; &lt;group by&gt;&#xA;   clause in the SQL statement. Column names must be specified as an array reference of strings.&#xA; &lt;/group&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item order =&amp;gt; [column1 =&amp;gt; direction, column2 =&amp;gt; direction, ...]&lt;/p&gt; &#xA;&lt;p&gt;The columns and their orders for the sorting, i.e. values for the C&#xA; &lt;order by&gt;&#xA;   clause in the SQL statement. The value must be a order struct, as described in L&#xA;  &lt;a href=&#34;Dongry::SQL&#34;&gt;Dongry::SQL&lt;/a&gt;.&#xA; &lt;/order&gt;&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;p&gt;[col1 =&amp;gt; 1, col2 =&amp;gt; -1] # &lt;code&gt;col1&lt;/code&gt; ASC, &lt;code&gt;col2&lt;/code&gt; DESC [col1 =&amp;gt; &#39;ASC&#39;, col2 =&amp;gt; &#39;DESC&#39;] # &lt;code&gt;col1&lt;/code&gt; ASC, &lt;code&gt;col2&lt;/code&gt; DESC&lt;/p&gt; &#xA;&lt;p&gt;=item offset =&amp;gt; number, limit =&amp;gt; number&lt;/p&gt; &#xA;&lt;p&gt;The offset and the number of rows to retrieve, i.e. values for the C&#xA; &lt;limit&gt;&#xA;   clause in the SQL statement. They must be specified as non-negative integers. If C&#xA;  &lt;offset&gt;&#xA;    is specified but C&#xA;   &lt;limit&gt;&#xA;     is not specified, C&#xA;    &lt;limit&gt;&#xA;      is defaulted to C&amp;lt;1&amp;gt;. Otherwise, the default for C&#xA;     &lt;offset&gt;&#xA;       is zero and the default for C&#xA;      &lt;limit&gt;&#xA;        is inifinity.&#xA;      &lt;/limit&gt;&#xA;     &lt;/offset&gt;&#xA;    &lt;/limit&gt;&#xA;   &lt;/limit&gt;&#xA;  &lt;/offset&gt;&#xA; &lt;/limit&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item lock =&amp;gt; update/share&lt;/p&gt; &#xA;&lt;p&gt;The lock mode for the C&lt;select&gt; operation. If the value is C, C option is included in the C&lt;/select&gt; statement. If the value is C&#xA; &lt;share&gt;&#xA;  , C&#xA;  &lt;lock in share mode&gt;&#xA;    option is included in the C&#xA;   &lt;select&gt; statement. =item each_cb =&amp;gt; code-reference =item each_as_row_cb =&amp;gt; code-reference The callback function invoked whenever rows are received from the server. See the C method for more information. =item cb =&amp;gt; code-reference (DEPRECATED) The callback function invoked after the execution of the SQL statement. See the C method for more information. In the asynchronous mode, the C method of the returned object should be used instead of the callback function. =back This method returns a result object bound to the table specified as the first argument. The number of available rows can be retrieved from the C&amp;lt;row_count&amp;gt; method of the result object. The selected rows can be accessible from one of C, C, and C methods, or their C&amp;lt;_as_row(s)&amp;gt; variants C&amp;lt;all_as_rows&amp;gt;, C&amp;lt;each_as_row&amp;gt;, and C&amp;lt;first_as_row&amp;gt;. Examples: my $result = $db-&amp;gt;select (&#39;table1&#39;, {col1 =&amp;gt; &#39;hoge&#39;, col2 =&amp;gt; 123, date =&amp;gt; {&#39;&amp;lt;=&#39;, &#39;2001-02-02&#39;}}, order =&amp;gt; [date =&amp;gt; -1, col1 =&amp;gt; 1, col2 =&amp;gt; -1]); SELECT * FROM table1 WHERE col1 = &#39;hoge&#39; AND col2 = &#39;123&#39; AND date &amp;lt;= &#39;2001-02-02&#39; ORDER BY date DESC, col1 ASC, col2 DESC; $result-&amp;gt;each (sub { my $values = shift; warn $values-&amp;gt;{date}, &#34;\t&#34;, $values-&amp;gt;{col1}, &#34;\n&#34;; }); my $result = $db-&amp;gt;select (&#39;table1&#39;, {col1 =&amp;gt; &#39;hoge&#39;}, fields =&amp;gt; [{-count =&amp;gt; undef, distinct =&amp;gt; 1, as =&amp;gt; &#39;count&#39;}, &#39;col1&#39;, &#39;col2&#39;], group =&amp;gt; [&#39;col2&#39;]); SELECT COUNT(DISTINCT *) AS count FROM table1 WHERE col1 = &#39;hoge&#39; GROUP BY col2 $result-&amp;gt;all_as_rows-&amp;gt;each (sub { my $row = $_[0]; warn $row-&amp;gt;get (&#39;col1&#39;), &#34;,&#34;, $row-&amp;gt;get (&#39;col2&#39;); warn $row-&amp;gt;get (&#39;count&#39;); }); In the asynchronous mode, the returned object is I. Example: $db-&amp;gt;source (ae =&amp;gt; {dsn =&amp;gt; $dsn, anyevent =&amp;gt; 1}); my $cv = AnyEvent-&amp;gt;condvar; $db-&amp;gt;select (&#39;foo&#39;, {user_id =&amp;gt; $uid}, source_name =&amp;gt; &#39;ae&#39;)-&amp;gt;then (sub { print $[0]-&amp;gt;all-&amp;gt;map (sub { $-&amp;gt;get (&#39;name&#39;) })-&amp;gt;join (&#34;\t&#34;); })-&amp;gt;catch (sub { warn $_[0]; })-&amp;gt;then (sub { $cv-&amp;gt;send; }); $cv-&amp;gt;recv; =item $result = $db-&amp;gt;update ($table_name, $values, where =&amp;gt; $where, %opts) Update rows in the specified table using the SQL C statement. The new values must be specified by the second argument, as hash reference containing key/value pairs representing the column names and their new values. A value can be specified as a scalar value (a text, number, or C value), or a bare SQL fragment object (a return value of the C&amp;lt;bare_sql_fragment&amp;gt; method), which would be inserted to the value portion of the SQL statement. The conditions to specify the updated rows, i.e. the C clause, must be specified as the thrid argument, in the same format as the C&lt;/select&gt; method.&#xA;  &lt;/lock&gt;&#xA; &lt;/share&gt;&lt;/p&gt; &#xA;&lt;p&gt;In addition, following options can be specified as key/value pairs:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item source_name =&amp;gt; string&lt;/p&gt; &#xA;&lt;p&gt;The name of the data source used to select the database connection. For more information on how data source is selected, see the description for the C&#xA; &lt;execute&gt;&#xA;   method.&#xA; &lt;/execute&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item duplicate =&amp;gt; &#34;ignore&#34;&lt;/p&gt; &#xA;&lt;p&gt;Specifies how &#34;duplicate entry&#34; error is handled by the database. If C&#xA; &lt;ignore&gt;&#xA;   is specified, an C&#xA;  &lt;update ignore&gt;&#xA;    statement is issued such that any attempt to generate duplicate rows is ignored without errors being reported. Please note that this statement might ignore any other possible errors as well. If this option is not specified, then a normal C&#xA;   &lt;update&gt;&#xA;     statement is issued such that any duplication would be reported as an SQL execution error through the C&#xA;    &lt;onerror&gt;&#xA;      handler.&#xA;    &lt;/onerror&gt;&#xA;   &lt;/update&gt;&#xA;  &lt;/update&gt;&#xA; &lt;/ignore&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item order =&amp;gt; [column1 =&amp;gt; direction, column2 =&amp;gt; direction, ...]&lt;/p&gt; &#xA;&lt;p&gt;The columns and their orders for the sorting, i.e. values for the C&#xA; &lt;order by&gt;&#xA;   clause in the SQL statement. The value must be a order struct, as described in L&#xA;  &lt;a href=&#34;Dongry::SQL&#34;&gt;Dongry::SQL&lt;/a&gt;.&#xA; &lt;/order&gt;&lt;/p&gt; &#xA;&lt;p&gt;This option would have no effect unless there is also the C&#xA; &lt;limit&gt;&#xA;   option.&#xA; &lt;/limit&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item limit =&amp;gt; number&lt;/p&gt; &#xA;&lt;p&gt;The maximum number of rows to update, i.e. the value for the C&#xA; &lt;limit&gt;&#xA;   clause in the SQL statement. It must be specified as a non-negative integer. If the option is not specified, all the matching rows will be updated. Unlike the C&#xA;  &lt;select&gt; method, the C option is not available for this method. =item cb =&amp;gt; code-reference (DEPRECATED) The callback function invoked after the execution of the SQL statement. See the C method for more information. In the asynchronous mode, the C method of the returned object should be used instead of the callback function. =back This method returns a result object bound to the table specified as the first argument. The number of affected rows can be retrieved from the C&amp;lt;row_count&amp;gt; method of the result object. Methods such as C, C, and C are not available for the result object generated by this method. Example: $db-&amp;gt;update (&#39;table1&#39;, {col1 =&amp;gt; 12, col2 =&amp;gt; $db-&amp;gt;bare_sql_fragment (&#39;col2 + 2&#39;)}, where =&amp;gt; {created =&amp;gt; {&#39;&amp;lt;=&#39;, &#39;2012-01-01 00:00:00&#39;}}); UPDATE table1 SET col1 = 12, col2 = col2 + 2 WHERE created &amp;lt;= &#39;2012-01-01 00:00:00&#39; In the asynchronous mode, the returned object is I. =item $baresql = $db-&amp;gt;bare_sql_fragment ($sql_fragment) Return a bare SQL fragment object for the given SQL statement fragment. In general, values specified for the C or C&lt;/select&gt; methods are interpreted as is, possibly stringified. However, you might sometimes want to specify a SQL expression such as C&amp;lt;columnname + 1&amp;gt; or C&amp;lt;NOW()&amp;gt;.&#xA; &lt;/limit&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can specify such a SQL fragment by wrapping it by the bare SQL fragment object using this method. Bare SQL fragment objects can be specified for the values of C&#xA; &lt;update&gt;&#xA;   method, and the C&#xA;  &lt;duplicate&gt;&#xA;    values option of the C&#xA;   &lt;insert&gt;&#xA;     method.&#xA;   &lt;/insert&gt;&#xA;  &lt;/duplicate&gt;&#xA; &lt;/update&gt;&lt;/p&gt; &#xA;&lt;p&gt;CAUTION! SQL statement fragment is inserted into the SQL statement constructed by those methods as is without any modifications or validations. It means that you have to prevent the fragment from syntax error, SQL injection vulnerability, or any other possible errors.&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;delete ($table_name, $where, %opts)&lt;/p&gt; &#xA;&lt;p&gt;Delete rows in the specified table. The second argument must specify the conditions to select the rows to delete, in the same format as the second argument of the C&lt;select&gt; method. In addition, following options can be specified as key/value pairs: =over 4 =item source_name =&amp;gt; string The name of the data source used to select the database connection. For more information on how data source is selected, see the description for the C method. =item order =&amp;gt; [column1 =&amp;gt; direction, column2 =&amp;gt; direction, ...] The columns and their orders for the sorting, i.e. values for the C clause in the SQL statement. The value must be a order struct, as described in LDongry::SQL. This option would have no effect unless there is also the C option. =item limit =&amp;gt; number The maximum number of rows to delete, i.e. the value for the C clause in the SQL statement. It must be specified as a non-negative integer. If the option is not specified, all the matching rows will be deleted. Unlike the C&lt;/select&gt; method, the C&#xA; &lt;offset&gt;&#xA;   option is not available for this method.&#xA; &lt;/offset&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item cb =&amp;gt; code-reference (DEPRECATED)&lt;/p&gt; &#xA;&lt;p&gt;The callback function invoked after the execution of the SQL statement. See the C&#xA; &lt;execute&gt;&#xA;   method for more information.&#xA; &lt;/execute&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode, the C&#xA; &lt;then&gt;&#xA;   method of the returned object should be used instead of the callback function.&#xA; &lt;/then&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;This method returns a result object bound to the table specified as the first argument. The number of affected rows can be retrieved from the C&amp;lt;row_count&amp;gt; method of the result object. Methods such as C&#xA; &lt;all&gt;&#xA;  , C&#xA;  &lt;each&gt;&#xA;   , and C&#xA;   &lt;first&gt;&#xA;     are not available for the result object generated by this method.&#xA;   &lt;/first&gt;&#xA;  &lt;/each&gt;&#xA; &lt;/all&gt;&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;$db-&amp;gt;delete (&#39;table1&#39;, {created =&amp;gt; {&#39;&amp;lt;=&#39;, &#39;2012-01-01 00:00:00&#39;}});&lt;/p&gt; &#xA;&lt;h1&gt;DELETE FROM &lt;code&gt;table1&lt;/code&gt; WHERE &lt;code&gt;created&lt;/code&gt; &amp;lt;= &#39;2012-01-01 00:00:00&#39;&lt;/h1&gt; &#xA;&lt;p&gt;In the asynchronous mode, the returned object is I&#xA; &lt;thenable&gt;&#xA;  .&#xA; &lt;/thenable&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;set_tz ($tz_offset, source_name =&amp;gt; $source_name, cb =&amp;gt; $cb)&lt;/p&gt; &#xA;&lt;p&gt;Set the time zone for the database connection, using C&#xA; &lt;set time_zone&gt;&#xA;   statement. The time zone offset argument, which is default to UTC, must be in the format understood by the database, i.e. C&amp;lt;+01:00&amp;gt;. The C&amp;lt;source_name&amp;gt; option, defaulted to the C&#xA;  &lt;master&gt;&#xA;   , specifies the data source for which the time zone is set.&#xA;  &lt;/master&gt;&#xA; &lt;/set&gt;&lt;/p&gt; &#xA;&lt;p&gt;The C&#xA; &lt;cb&gt;&#xA;   (callback) function, if specified, is invoked after the execution of the SQL statement. See the C&#xA;  &lt;execute&gt;&#xA;    method for more information. The C&#xA;   &lt;cb&gt;&#xA;     function is B&#xA;    &lt;deprecated&gt;&#xA;     .&#xA;    &lt;/deprecated&gt;&#xA;   &lt;/cb&gt;&#xA;  &lt;/execute&gt;&#xA; &lt;/cb&gt;&lt;/p&gt; &#xA;&lt;p&gt;The default time zone used by the database when this statement is not issued depends on the configuration and the implementation of the database in use.&lt;/p&gt; &#xA;&lt;p&gt;Example. Setting the time zone used in the current connection to the database:&lt;/p&gt; &#xA;&lt;p&gt;$db-&amp;gt;onconnect (sub { my ($self, %args) = @_; $self-&amp;gt;set_tz (&#39;+00:00&#39;, source_name =&amp;gt; $args{source_name}); });&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;uuid_short ($n, source_name =&amp;gt; $source_name)-&amp;gt;then (...)&lt;/p&gt; &#xA;&lt;p&gt;Get the result of the C&amp;lt;UUID_SHORT()&amp;gt; function, repeatedly invoked I&amp;lt;$n&amp;gt; times. This method is equivalent to the C&#xA; &lt;execute&gt;&#xA;   method with SQL statement C&amp;lt;SELECT UUID_SHORT()&amp;gt; where the function is repeated as specified by the argument.&#xA; &lt;/execute&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method does not work in the synchronous mode.&lt;/p&gt; &#xA;&lt;p&gt;In the asynchronous mode, the returned object is I&#xA; &lt;thenable&gt;&#xA;  . It is to be fulfilled with an array reference of the obtained values (i.e. I&amp;lt;$n&amp;gt; UUID short numbers).&#xA; &lt;/thenable&gt;&lt;/p&gt; &#xA;&lt;p&gt;The C&amp;lt;source_name&amp;gt; option, defaulted to the C&#xA; &lt;master&gt;&#xA;  , specifies the data source over which the SQL statement is executed.&#xA; &lt;/master&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head2 Schema-aware operations&lt;/p&gt; &#xA;&lt;p&gt;The following methods provide access to schema-aware APIs. What are schema-aware APIs? Methods mentioned in the previous sections are not schema-aware. That is, no SQL data is handled differently from strings for the purpose of those methods. The schema-aware APIs are built on top of them to offer an abstract layer for convertion of database and Perl data types. For example, if you associated the C&#xA; &lt;created&gt;&#xA;   column (declared as SQL C&#xA;  &lt;timestamp&gt;&#xA;    data type in the database schema) with the C&amp;lt;timestamp_as_DateTime&amp;gt; type handler (defined in L&#xA;   &lt;a href=&#34;Dongry::Type::DateTime&#34;&gt;Dongry::Type::DateTime&lt;/a&gt;), you can use a Perl L&#xA;   &lt;datetime&gt;&#xA;     object to set the value for the column through a schema-aware method, or you can retrieve the column value as a C&#xA;    &lt;datetime&gt;&#xA;      object from a schema-aware method.&#xA;    &lt;/datetime&gt;&#xA;   &lt;/datetime&gt;&#xA;  &lt;/timestamp&gt;&#xA; &lt;/created&gt;&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $db-&amp;gt;schema ($schema)&lt;/p&gt; &#xA;&lt;p&gt;=item $schema = $db-&amp;gt;schema&lt;/p&gt; &#xA;&lt;p&gt;=item $db = Dongry::Database-&amp;gt;new (schema =&amp;gt; $schema)&lt;/p&gt; &#xA;&lt;p&gt;Get or set the schema definition as used by the database object. The schema definition has to be set before any schema-aware operation is actually invoked.&lt;/p&gt; &#xA;&lt;p&gt;Please note that although the I&#xA; &lt;schema&gt;&#xA;   concept of Dongry is modelled after the schema of SQL and database implementations, they have no direct relationship in fact. You can declare a C&#xA;  &lt;int&gt;&#xA;    column in SQL as C&#xA;   &lt;date&gt;&#xA;     in Dongry, even though such a broken mapping would not be useful. If you changed the schema in the database, you might also have to modify the schema definition for Dongry. Although this could be inconvinient for some use cases, it would give an application great control over how they handle data.&#xA;   &lt;/date&gt;&#xA;  &lt;/int&gt;&#xA; &lt;/schema&gt;&lt;/p&gt; &#xA;&lt;p&gt;A I&#xA; &lt;schema&gt;&#xA;   is just a hash reference, where key/value pairs are table names and table schema for them. A I&#xA; &lt;/schema&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&lt;p&gt;=over 4&lt;/p&gt;&#xA;&lt;p&gt;=item type =&amp;gt; type-definition&lt;/p&gt;&#xA;&lt;p&gt;Define the type handler for columns in the table. The value must be a hash reference containing key/value pairs representing column names and its types. A type is a string as described in L&lt;a href=&#34;Dongry::Type&#34;&gt;Dongry::Type&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Types are used to intepret column values in schema-aware operations such as C&#xA; &lt;find&gt;&#xA;   and C&#xA;  &lt;create&gt;&#xA;    methods of the table object.&#xA;  &lt;/create&gt;&#xA; &lt;/find&gt;&lt;/p&gt;&#xA;&lt;p&gt;=item primary_keys =&amp;gt; [$column1, $column2, ...]&lt;/p&gt;&#xA;&lt;p&gt;Define the primary keys for the table. The value must be an array reference containing the column names used as the columns of primary keys for the table.&lt;/p&gt;&#xA;&lt;p&gt;Primary keys are used to identify the row in operations of the table row object, such as C&#xA; &lt;update&gt;&#xA;   and C&#xA;  &lt;delete&gt;&#xA;   .&#xA;  &lt;/delete&gt;&#xA; &lt;/update&gt;&lt;/p&gt;&#xA;&lt;p&gt;The specified columns do not have to be defined as primary keys in the actual database schema in fact. However, there should at least unique keys for the columns, or the operations over the row object would cause unexpected results.&lt;/p&gt;&#xA;&lt;p&gt;=item default =&amp;gt; default-definition&lt;/p&gt;&#xA;&lt;p&gt;Define the default values for columns in the table. The value must be a hash reference whose key/value pairs representing column names and their default values. A default value can be specified as the code reference, in which case the code reference would be invoked each time the default value is necessary. The code reference is invoked without any argument. It is expected to return the default value. In any case, the default value is interpreted as in the data type of the column, as defined by the C&#xA; &lt;type&gt;&#xA;   clause.&#xA; &lt;/type&gt;&lt;/p&gt;&#xA;&lt;p&gt;Default values are used when rows are inserted through a schema-aware method such as the C&#xA; &lt;create&gt;&#xA;   method of the table object.&#xA; &lt;/create&gt;&lt;/p&gt;&#xA;&lt;p&gt;=back&lt;/p&gt;&#xA;&lt;p&gt;Even though all of these keys in the table schema is optional, the table schema it self must be specified in the schema to enable schema-aware APIs for the table.&lt;/p&gt;&#xA;&lt;p&gt;=item $db-&amp;gt;table_name_normalizer ($code)&lt;/p&gt;&#xA;&lt;p&gt;=item $code = $db-&amp;gt;table_name_normalizer&lt;/p&gt;&#xA;&lt;p&gt;=item $db = Dongry::Database-&amp;gt;new (table_name_normalizer =&amp;gt; $code)&lt;/p&gt;&#xA;&lt;p&gt;Get or set the code to normalize table names for the purpose of table schema lookup.&lt;/p&gt;&#xA;&lt;p&gt;Sometimes a number of tables in the database share the same table structure. For example, consider a database where C&amp;lt;hoge_1&amp;gt;, C&amp;lt;hoge_2&amp;gt;, C&amp;lt;hoge_3&amp;gt;, and other tables share the common definition. Rather than repeating the table schema definitions for all tables, you have to register just a table definition by setting the following table name normalizer code:&lt;/p&gt;&#xA;&lt;p&gt;$db-&amp;gt;table_name_normalizer (sub { my $name = shift; $name =~ s/_[0-9]+$/_n/; return $name; }); $db-&amp;gt;schema ({ foo_n =&amp;gt; { ... }, bar_n =&amp;gt; { ... }, });&lt;/p&gt;&#xA;&lt;p&gt;$db-&amp;gt;table (&#39;foo_2&#39;) # -&amp;gt; foo_n $db-&amp;gt;table (&#39;bar_130&#39;) # -&amp;gt; bar_n&lt;/p&gt;&#xA;&lt;p&gt;=item $table = $db-&amp;gt;table ($table_name)&lt;/p&gt;&#xA;&lt;p&gt;Create a table object for the specified table. The table object provides schema-aware APIs for the table. For more information on the table object see documentation for the L&lt;a href=&#34;Dongry::Table&#34;&gt;Dongry::Table&lt;/a&gt; module.&lt;/p&gt;&#xA;&lt;p&gt;=item $query = $db-&amp;gt;query (%opts)&lt;/p&gt;&#xA;&lt;p&gt;Create a query object with the specified options. The query object is an abstraction for a particular schema-aware C&lt;select&gt; operation. If the C&amp;lt;query_class&amp;gt; option is specified, the class is used to instantiate the query object. Otherwise, the LDongry::Query class is used. For more information, including the list of the other available options, see documentation for the LDongry::Query module. =back =head2 Development There is a method to facilitate development of applications: =over 4 =item $string = $db-&amp;gt;debug_info Return a not-so-long string to describe the database object. It might or might not be useful for debugging. =back You might want to dump the SQL statements issued by Dongry for the purpose of development. Though Dongry itself does not have such debugging feature. Perl modules such as LDBIx::ShowSQL, LDevel::KYTProf, and LDBIx::QueryLog for synchronous mode, or LAnyEvent::MySQL::Client::ShowLog for asynchronous mode, would be useful. If the C&amp;lt;SQL_DEBUG&amp;gt; environmental variable has a true value, Dongry loads the LDBIx::ShowSQL or LAnyEvent::MySQL::Client::ShowLog module. If the C&amp;lt;SQL_DEBUG&amp;gt; environmental variable contains substring C&amp;lt;embed_caller&amp;gt;, or if the C&amp;lt;$Dongry::Database::EmbedCallerInSQL&amp;gt; variable has a true value, Dongry embeds the file name and the line number of the method invocations that request SQL executions into the SQL statement, as an SQL comment. =head1 METHODS OF RESULT OBJECT SQL execution methods of the database object, such as C, C&lt;/select&gt;, C&#xA; &lt;insert&gt;&#xA;  , and so on, return the result object.&#xA; &lt;/insert&gt;&lt;/p&gt;&#xA;&lt;p&gt;In the synchronous mode, the object returned by the method itself contains the result of the method.&lt;/p&gt;&#xA;&lt;p&gt;In the asynchronous mode, the object returned by the method does not contain the result, as it is not yet available. If the returned object is referred to as I&#xA; &lt;thenable&gt;&#xA;  , the returned object has the C&#xA;  &lt;then&gt;&#xA;    method. Callback functions registered by the C&#xA;   &lt;then&gt;&#xA;     method will receive the actual result object of the original method as the argument.&#xA;   &lt;/then&gt;&#xA;  &lt;/then&gt;&#xA; &lt;/thenable&gt;&lt;/p&gt;&#xA;&lt;p&gt;The callback function specified by the C&#xA; &lt;cb&gt;&#xA;   option also receives a result object as the second argument in many methods. Such an result object also contains the result of the method.&#xA; &lt;/cb&gt;&lt;/p&gt;&#xA;&lt;p&gt;A result object holds the execution result of the SQL statement, which can be accessible from following methods:&lt;/p&gt;&#xA;&lt;p&gt;=over 4&lt;/p&gt;&#xA;&lt;p&gt;=item $boolean = $result-&amp;gt;is_success&lt;/p&gt;&#xA;&lt;p&gt;=item $boolean = $result-&amp;gt;is_error&lt;/p&gt;&#xA;&lt;p&gt;Return whether the result is success or error.&lt;/p&gt;&#xA;&lt;p&gt;=item $string = $result-&amp;gt;error_text&lt;/p&gt;&#xA;&lt;p&gt;If the result is error, return a short text that describes the error. If no more information is available, or if the result is not error, C&#xA; &lt;undef&gt;&#xA;   is returned.&#xA; &lt;/undef&gt;&lt;/p&gt;&#xA;&lt;p&gt;=item $string = $result-&amp;gt;error_sql&lt;/p&gt;&#xA;&lt;p&gt;If the result is error during the execution of an SQL statement, return the SQL statement that is being executed when the error is reported. If it is not available, or if the result is not error, C&#xA; &lt;undef&gt;&#xA;   is returned.&#xA; &lt;/undef&gt;&lt;/p&gt;&#xA;&lt;p&gt;=item $number = $result-&amp;gt;row_count&lt;/p&gt;&#xA;&lt;p&gt;Return the number of rows affected by the SQL execution (for write operations), or the number of rows found by the SQL execution (for read operations). Please note that the semantics of the number depends on the kind of the executed SQL statement and the database implementation and might not be always useful for the application. For example, the row count for the C&#xA; &lt;insert ignore&gt;&#xA;   statement might not be equal to the number of rows actually inserted into the table.&#xA; &lt;/insert&gt;&lt;/p&gt;&#xA;&lt;p&gt;=item $result-&amp;gt;each ($code)&lt;/p&gt;&#xA;&lt;p&gt;Iterate for each row in the result. The argument must be a code reference. The code is invoked for each row, with an argument which represents the row as a hash reference where key/value pairs represent column names and their values. If there is no row in the result, the code reference will not be invoked at all.&lt;/p&gt;&#xA;&lt;p&gt;This method is not available in asynchronous mode. Use C&amp;lt;each_cb&amp;gt; option instead.&lt;/p&gt;&#xA;&lt;p&gt;=item $list = $result-&amp;gt;all&lt;/p&gt;&#xA;&lt;p&gt;Return a list which contains all the rows in the result. The method returns a list object which contains zero or more hash references representing the rows. The hash reference consists of key/value pairs representing column names and their values.&lt;/p&gt;&#xA;&lt;p&gt;=item $values = $result-&amp;gt;first&lt;/p&gt;&#xA;&lt;p&gt;Return the first row in the result. If there is a row, the method returns the row as a hash reference where key/value pairs represent column names and their values. If there is no row in the result, C&#xA; &lt;undef&gt;&#xA;   is returned.&#xA; &lt;/undef&gt;&lt;/p&gt;&#xA;&lt;p&gt;=item $string = $result-&amp;gt;debug_info&lt;/p&gt;&#xA;&lt;p&gt;Return a short string to describe the result object. It might or might not be useful for debugging.&lt;/p&gt;&#xA;&lt;p&gt;=back&lt;/p&gt;&#xA;&lt;p&gt;The result object is either bound to a table or not bound to any table. If a method receives the table name explicitly as an argument (e.g. the C&lt;select&gt; method of the database object), the result object of the method is bound to that table. Otherwise (e.g. the C method of the database object) the result object is not bound to any table. When the result object is bound to a table, following schema-aware methods can be used: =over 4 =item $name = $result-&amp;gt;table_name Return the name of the table bound to the result object, if any, or C, otherwise. =item $result-&amp;gt;each_as_row ($code) Iterate for rows like the C method does, but gives the table row object for each row to the specified code reference instead of a hash reference. This method is not available in asynchronous mode. Use C&amp;lt;each_as_row_cb&amp;gt; option instead. =item $list = $result-&amp;gt;all_as_rows Return a list of the table rows like the C method does, but puts the table row objects for the rows in the list instead of hash references. =item $row = $result-&amp;gt;first_as_row Return the first table row, if any, like the C method does, but gives the table row object for the first row instead of a hash reference. =back Methods returning table row objects can be called only once for a result object. For example, if the C method is once called, the other methods can no longer be called. In addition, the C method itself become invalid. As described in the section of the C method, row data or table row objects accessible from the result object returned by the C method is based on the argument to the method and might be different from the actual data on the database. A I result object has the following method: =over 4 =item $promise = $result-&amp;gt;then ($onfulfill, $onreject) Register callback functions invoked when the operation of the original method has succeeded or failed, respectively. One of these callback is invoked once the operation result is available, with the result object containing the actual result of the method. This method is actually the C method of a promise object. Both fulfill and reject callbacks can be omitted. The method returns a new promise. The new promise is to be resolved with the returned value of the invoked callback function, or to be rejected by the exception thrown by the callback function. =back A I result object behaves as if it were a L object, except there is no C method. As it has the C method, it can be used as the return value of a promise callback or the argument of the C&amp;lt;&amp;lt; Promise-&amp;gt;resolve &amp;gt;&amp;gt; method to create a promise to be resolved with the actual result object. For more information on promise, see documentation of L https://github.com/wakaba/perl-promise. =head1 COMPATIBILITY Although the synchronous mode of Dongry is built on the top of the L&#39;s standard interface to various kinds of database backends, its full functionality can be used only when the database to be connected is MySQL version 5. The asynchronous mode of Dongry requires LAnyEvent::MySQL::Client, which only supports MySQL client/server protocol as implemented by MySQL version 5. Some of SQL statements generated by Dongry are not supported by other database management systems. Some of features provided by Dongry do not work as intended depending on the database engine in use. Specifically, transaction does not work for tables using the MyISAM engine. =head1 INTERPREATAION OF STRINGS Lower-level interfaces of Dongry, i.e. methods of the database object such as C, C&lt;/select&gt;, C&#xA; &lt;insert&gt;&#xA;  , and so on, leave the interpretation of byte- or character-string (or the utf8 flag) to the underlying layers. The underlying L&#xA;  &lt;dbi&gt;&#xA;    module used in the synchronous mode, in turn, delegates the handling of it to the database driver such as L&#xA;   &lt;a href=&#34;DBD::mysql&#34;&gt;DBD::mysql&lt;/a&gt;. See the documentation for database driver modules for their implementation. The L&#xA;   &lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt; module requires the input being non-utf8 flagged byte string. For portability, you should only use byte strings in queries and values.&#xA;  &lt;/dbi&gt;&#xA; &lt;/insert&gt;&lt;/p&gt;&#xA;&lt;p&gt;Higher-level interfaces of Dongry, namely the schema-aware APIs of the table and table row objects, handles strings as defined by the data type of the column. Unless the type is explicitly specified, you should always specify or receive a byte (or unflagged) string. If a column is expected to contain a character string, the column should be declared as of C&#xA; &lt;text&gt;&#xA;   or C&amp;lt;text_as_ref&amp;gt; such that you can specify or receive a character (or flagged) string. If you write a type handler, be careful for the parser to interpret byte strings and for the serializer to return character strings if the data type is defined as sequence(s) of characters.&#xA; &lt;/text&gt;&lt;/p&gt;&#xA;&lt;p&gt;Dongry does intentionally not support non-ASCII table and column names. How they are interpreted if used is unspecified.&lt;/p&gt;&#xA;&lt;p&gt;Example:&lt;/p&gt;&#xA;&lt;p&gt;my $result = $db-&amp;gt;execute (&#39;SELECT * FROM table1 WHERE name = :name&#39;, {name =&amp;gt; encode &#39;utf-8&#39;, $name}); $name = decode &#39;utf-8&#39;, $result-&amp;gt;first-&amp;gt;{name};&lt;/p&gt;&#xA;&lt;p&gt;$db-&amp;gt;schema ({table1 =&amp;gt; {type =&amp;gt; {name =&amp;gt; &#39;text&#39;}}}); $row = $db-&amp;gt;table (&#39;table1&#39;)-&amp;gt;find ({name =&amp;gt; $flagged_name}); $flagged_name = $row-&amp;gt;get (&#39;name&#39;); $unflagged_name = $row-&amp;gt;get_bare (&#39;name&#39;);&lt;/p&gt;&#xA;&lt;p&gt;=head1 AVAILABILITY&lt;/p&gt;&#xA;&lt;p&gt;The latest version of Dongry is available from the Git repository &lt;a href=&#34;https://github.com/wakaba/dongry&#34;&gt;https://github.com/wakaba/dongry&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;=head1 DEPENDENCY&lt;/p&gt;&#xA;&lt;p&gt;Perl 5.12 or later is required.&lt;/p&gt;&#xA;&lt;p&gt;For the synchronous mode, the modules L&#xA; &lt;dbi&gt;&#xA;   and L&#xA;  &lt;a href=&#34;DBD::mysql&#34;&gt;DBD::mysql&lt;/a&gt; are required.&#xA; &lt;/dbi&gt;&lt;/p&gt;&#xA;&lt;p&gt;For the asynchronous mode, the L&lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt; module in the GitHub repository &lt;a href=&#34;https://github.com/wakaba/perl-anyevent-mysql-client&#34;&gt;https://github.com/wakaba/perl-anyevent-mysql-client&lt;/a&gt; is required.&lt;/p&gt;&#xA;&lt;p&gt;Dongry uses the L&lt;a href=&#34;List::Ish&#34;&gt;List::Ish&lt;/a&gt; module as list object implementation by default, but this can be configured by the C&amp;lt;$Dongry::Database::ListClass&amp;gt; variable. You can use other modules with similar API, such as L&lt;a href=&#34;List::Rubyish&#34;&gt;List::Rubyish&lt;/a&gt; and L&lt;a href=&#34;DBIx::MoCo::List&#34;&gt;DBIx::MoCo::List&lt;/a&gt;, instead. The L&lt;a href=&#34;List::Ish&#34;&gt;List::Ish&lt;/a&gt; module is available at &lt;a href=&#34;https://github.com/wakaba/perl-ooutils/raw/master/lib/List/Ish.pm&#34;&gt;https://github.com/wakaba/perl-ooutils/blob/master/lib/List/Ish.pm&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Additional modules might be used by L&lt;a href=&#34;Dongry::Type&#34;&gt;Dongry::Type&lt;/a&gt; modules, but they are not loaded unless you are explicitly using them. See their documentations for more information.&lt;/p&gt;&#xA;&lt;p&gt;The GitHub repository of Dongry contains submodules. Submodule C&amp;lt;modules/perl-ooutils&amp;gt; contains the L&lt;a href=&#34;List::Ish&#34;&gt;List::Ish&lt;/a&gt; module. Submodule C&amp;lt;modules/perl-json-functions-xs&amp;gt; is required by L&lt;a href=&#34;Dongry::Type::JSON&#34;&gt;Dongry::Type::JSON&lt;/a&gt;. The submodule C&amp;lt;modules/perl-rdb-utils&amp;gt; is used for debugging and testing.&lt;/p&gt;&#xA;&lt;p&gt;=head1 SEE ALSO&lt;/p&gt;&#xA;&lt;p&gt;L&#xA; &lt;dbi&gt;&#xA;  , L&#xA;  &lt;a href=&#34;DBD::mysql&#34;&gt;DBD::mysql&lt;/a&gt;.&#xA; &lt;/dbi&gt;&lt;/p&gt;&#xA;&lt;p&gt;L&lt;a href=&#34;AnyEvent::MySQL::Client&#34;&gt;AnyEvent::MySQL::Client&lt;/a&gt; &lt;a href=&#34;https://github.com/wakaba/perl-anyevent-mysql-client&#34;&gt;https://github.com/wakaba/perl-anyevent-mysql-client&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;MySQL Reference Manuals &lt;a href=&#34;https://dev.mysql.com/doc/&#34;&gt;https://dev.mysql.com/doc/&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;L&lt;a href=&#34;DBIx::ShowSQL&#34;&gt;DBIx::ShowSQL&lt;/a&gt; &lt;a href=&#34;https://github.com/wakaba/perl-rdb-utils/raw/master/lib/DBIx/ShowSQL.pm&#34;&gt;https://github.com/wakaba/perl-rdb-utils/blob/master/lib/DBIx/ShowSQL.pm&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;L&#xA; &lt;promise&gt; &#xA;  &lt;a href=&#34;https://github.com/wakaba/perl-promise&#34;&gt;https://github.com/wakaba/perl-promise&lt;/a&gt;.&#xA; &lt;/promise&gt;&lt;/p&gt;&#xA;&lt;p&gt;=head1 AUTHOR&lt;/p&gt;&#xA;&lt;p&gt;Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;=head1 HISTORY&lt;/p&gt;&#xA;&lt;p&gt;Design and interfaces of various features in Dongry is largely inspired by Perl modules L&#xA; &lt;dbi&gt;&#xA;  , L&#xA;  &lt;a href=&#34;AnyEvent::DBI&#34;&gt;AnyEvent::DBI&lt;/a&gt;, L&#xA;  &lt;a href=&#34;DBIx::MoCo&#34;&gt;DBIx::MoCo&lt;/a&gt;, L&#xA;  &lt;a href=&#34;DBIx::MoCo::Query&#34;&gt;DBIx::MoCo::Query&lt;/a&gt;, L&#xA;  &lt;a href=&#34;DBIx::MoCo::ColumnMethods&#34;&gt;DBIx::MoCo::ColumnMethods&lt;/a&gt;, L&#xA;  &lt;a href=&#34;DBIx::MoCo::TableExtras&#34;&gt;DBIx::MoCo::TableExtras&lt;/a&gt;, L&#xA;  &lt;a href=&#34;SQL::Abstract&#34;&gt;SQL::Abstract&lt;/a&gt;, L&#xA;  &lt;a href=&#34;SQL::NamedPlaceholder&#34;&gt;SQL::NamedPlaceholder&lt;/a&gt;, and L&#xA;  &lt;a href=&#34;List::Rubyish&#34;&gt;List::Rubyish&lt;/a&gt;.&#xA; &lt;/dbi&gt;&lt;/p&gt;&#xA;&lt;p&gt;Thanks to hatz48.&lt;/p&gt;&#xA;&lt;p&gt;This Git repository was located at &lt;a href=&#34;https://github.com/wakaba/dongry&#34;&gt;https://github.com/wakaba/dongry&lt;/a&gt; until 7 March, 2022.&lt;/p&gt;&#xA;&lt;p&gt;=head1 LICENSE&lt;/p&gt;&#xA;&lt;p&gt;Copyright 2011-2022 Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt;&#xA;&lt;p&gt;=cut&lt;/p&gt;&#xA;&lt;table schema&gt;&#xA;  is also a hash reference with following key/value pairs:                                                                                &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>awhatson/pmbris-coro-talk</title>
    <updated>2022-07-16T01:50:11Z</updated>
    <id>tag:github.com,2022-07-16:/awhatson/pmbris-coro-talk</id>
    <link href="https://github.com/awhatson/pmbris-coro-talk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bits and pieces for the &#34;Lightweight Threads in Perl&#34; talk at Brisbane Perl Mongers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;pmbris-coro-talk&lt;/h1&gt; &#xA;&lt;p&gt;Bits and pieces for the &#34;Lightweight Threads in Perl&#34; talk at Brisbane Perl Mongers&lt;/p&gt;</summary>
  </entry>
</feed>