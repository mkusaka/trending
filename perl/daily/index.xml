<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-25T01:41:20Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lingy-lang/lingy</title>
    <updated>2023-07-25T01:41:20Z</updated>
    <id>tag:github.com,2023-07-25:/lingy-lang/lingy</id>
    <link href="https://github.com/lingy-lang/lingy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lingy&lt;/h1&gt; &#xA;&lt;p&gt;A Clojure Platform for Perl&lt;/p&gt; &#xA;&lt;h1&gt;Synopsis&lt;/h1&gt; &#xA;&lt;p&gt;Run the Lingy REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ lingy&#xA;Lingy 0.1.12 [perl]&#xA;&#xA;user=&amp;gt; (p&amp;lt;TAB&amp;gt;&#xA;pos?     println  prn      pr-str&#xA;user=&amp;gt; (prn &#34;Hello, world!&#34;)&#xA;&#34;Hello, world!&#34;&#xA;nil&#xA;user=&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or a Lingy one-liner:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ lingy -e &#39;(println &#34;Hello, world!&#34;)&#39;&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or run a Lingy program file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;(println &#34;Hello, world!&#34;)&#39; &amp;gt; hello.ly&#xA;$ lingy hello.ly&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or run an example Lingy program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ wget -q https://raw.githubusercontent.com/ingydotnet/lingy/main/eg/99-bottles.ly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cat 99-bottles.ly&#xA;(defn main [number]&#xA;  (let [&#xA;    paragraphs (map paragraph (range number 0 -1)) ]&#xA;    (map println paragraphs)))&#xA;&#xA;(defn paragraph [num]&#xA;  (str&#xA;    (bottles num) &#34; of beer on the wall,\n&#34;&#xA;    (bottles num) &#34; of beer.\n&#34;&#xA;    &#34;Take one down, pass it around.\n&#34;&#xA;    (bottles (dec num)) &#34; of beer on the wall.\n&#34;))&#xA;&#xA;(defn bottles [n]&#xA;  (cond&#xA;    (= n 0) &#34;No more bottles&#34;&#xA;    (= n 1) &#34;1 bottle&#34;&#xA;    :else (str n &#34; bottles&#34;)))&#xA;&#xA;(main (nth *ARGV* 0 99))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ lingy 99-bottles.ly 3&#xA;3 bottles of beer on the wall,&#xA;3 bottles of beer.&#xA;Take one down, pass it around.&#xA;2 bottles of beer on the wall.&#xA;&#xA;2 bottles of beer on the wall,&#xA;2 bottles of beer.&#xA;Take one down, pass it around.&#xA;1 bottle of beer on the wall.&#xA;&#xA;1 bottle of beer on the wall,&#xA;1 bottle of beer.&#xA;Take one down, pass it around.&#xA;No more bottles of beer on the wall.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;Lingy is in ALPHA status.&lt;/p&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;Lingy is an implementation of the Clojure Platform for Perl that is written in Perl and hosted by Perl. Programs and modules written in Lingy have full access to Perl and its CPAN modules.&lt;/p&gt; &#xA;&lt;p&gt;Perl modules can be written in Lingy and distributed on CPAN. (In the future) Lingy code is compiled to a bytecode and should perform on the same order of magnitude as XS modules.&lt;/p&gt; &#xA;&lt;p&gt;Since Lingy will be a complete Clojure implementation, it should be able to run programs written in Clojure and make use of libraries written in Clojure.&lt;/p&gt; &#xA;&lt;p&gt;Clojure is a language that cleanly solves many of the problems of Java including making concurrency simple, and writing functional programs with mostly immutable data types. It is a Lisp dialect that is hosted by Java and compiles to JVM byte code. It has access to any libraries that target the JVM.&lt;/p&gt; &#xA;&lt;p&gt;Much of the Clojure language is written in Clojure (self hosted) and Lingy actually uses the Clojure source code.&lt;/p&gt; &#xA;&lt;p&gt;A variant of Clojure called ClojureScript uses the same Clojure source code but is hosted by JavaScript with full access to NPM modules. Lingy also intends to eventually be ported to and hosted by many other programming languages.&lt;/p&gt; &#xA;&lt;p&gt;Lingy started as a Perl &lt;a href=&#34;https://github.com/ingydotnet/mal/tree/perl.2/impls/perl.2&#34;&gt;implementation&lt;/a&gt; of the &lt;a href=&#34;https://github.com/kanaka/mal&#34;&gt;Make a Lisp&lt;/a&gt; project. This provided a bare-bones Clojure-inspired Lisp interpreter from which Lingy has grown upon.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;The current implementation of Lingy is packaged for installation as a &lt;a href=&#34;https://metacpan.org/pod/Lingy&#34;&gt;Perl module distribution package on CPAN&lt;/a&gt;. This is obvious if you are reading this from CPAN now, but maybe not if you are reading this from the &lt;a href=&#34;https://github.com/ingydotnet/lingy&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to install Lingy is using the &lt;code&gt;cpanm&lt;/code&gt; Perl/CPAN installation tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cpanm Lingy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;cpanm&lt;/code&gt; command is available as a software install on most modern systems, but if you are having trouble finding it see these &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus#INSTALLATION&#34;&gt;simple instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: See &#34;Hacking on Lingy&#34; below if you want to install from source and/or hack on the Lingy source code yourself (and hopefully contribute to the project!).&lt;/p&gt; &#xA;&lt;h1&gt;&lt;code&gt;lingy&lt;/code&gt; CLI Usage&lt;/h1&gt; &#xA;&lt;p&gt;The Lingy language installs a command-line program called &lt;code&gt;lingy&lt;/code&gt;. You can use this command to run Lingy programs, start a Lingy REPL or run Lingy one-liner expressions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;lingy --repl&lt;/code&gt; (or just &lt;code&gt;lingy&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;Starts a Lingy interactive REPL. The REPL has readline support that includes:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Command history&lt;/li&gt; &#xA;   &lt;li&gt;CTL-R searching&lt;/li&gt; &#xA;   &lt;li&gt;Parentheses match highlighting&lt;/li&gt; &#xA;   &lt;li&gt;CTL-C to abort a command w/o leaving REPL&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Use CTL-D to exit the REPL&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;lingy program.ly foo bar&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Run a Lingy program passing in arguments. Arguments are available in Lingy as &lt;code&gt;*ARGV*&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cat program.ly | lingy - foo bar&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Run a Lingy program from STDIN and pass in arguments. The &lt;code&gt;-&lt;/code&gt; means run from STDIN instead of a file. If there are no arguments you can omit the &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;lingy -e &#39;(println &#34;Hello&#34; (nth *ARGV* 0))&#39; world&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Run a Lingy one-liner with arguments.&lt;/p&gt; &lt;p&gt;When used with &lt;code&gt;--repl&lt;/code&gt;, run the &lt;code&gt;-e&lt;/code&gt; code first, then enter the REPL.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;code&gt;lingy&lt;/code&gt; CLI Options&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-e &amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;--eval=&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A Lingy string to evaluate.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;--repl&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Start a Lingy REPL. Can be used with &lt;code&gt;-e&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--ppp&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Print the Lingy compiled AST for a &lt;code&gt;-e&lt;/code&gt; expression.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--xxx&lt;/code&gt;&lt;/p&gt; &lt;p&gt;YAML dump the Lingy compiled AST for a &lt;code&gt;-e&lt;/code&gt; expression.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Lingy REPL Usage&lt;/h1&gt; &#xA;&lt;p&gt;If you run &lt;code&gt;lingy --repl&lt;/code&gt; (or just &lt;code&gt;lingy&lt;/code&gt;) you will start a Lingy interactive REPL. You can run Lingy commands and see the output.&lt;/p&gt; &#xA;&lt;p&gt;The REPL has command line history to save all your commands. It also has readline history search (ctl-r) and tab completion.&lt;/p&gt; &#xA;&lt;p&gt;Note: Input lines that match the previous input line will not be saved in history. That way you can run the same command multiple times in a row and not clutter your history.&lt;/p&gt; &#xA;&lt;h2&gt;Multiline Input&lt;/h2&gt; &#xA;&lt;p&gt;The Lingy REPL will keep prompting you for more lines until you have completed a well formed expression. Usually that means until you have balanced the parentheses.&lt;/p&gt; &#xA;&lt;p&gt;The history (up adn down arrow keys) will bring up the entire multiline form for you to edit.&lt;/p&gt; &#xA;&lt;p&gt;If you want to enter multiple lines as one entry when each line is already well formed, just wrap the entry in a &lt;code&gt;do&lt;/code&gt; expression like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;user=&amp;gt; (do&#xA;  #_=&amp;gt; (prn 1)&#xA;  #_=&amp;gt; (prn 2)&#xA;  #_=&amp;gt; )&#xA;1&#xA;2&#xA;nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also paste multiline examples into the REPL and they will remain editable as multiline.&lt;/p&gt; &#xA;&lt;p&gt;If you want to compress a multiline statement in your history to a single line, add a space to the end of it. Then (after you run it) it will be added to your history as a single line.&lt;/p&gt; &#xA;&lt;h2&gt;Using the Clojure REPL in the Lingy REPL&lt;/h2&gt; &#xA;&lt;p&gt;If you have Clojure installed on your system and you run this command in the Lingy REPL: &lt;code&gt;(clojure-repl-on)&lt;/code&gt;, then every command you enter will be evaluated both by Lingy and Clojure. Run &lt;code&gt;(clojure-repl-off)&lt;/code&gt; to turn it off. Start the Lingy REPL with &lt;code&gt;lingy --clj&lt;/code&gt; to turn it on from the start.&lt;/p&gt; &#xA;&lt;p&gt;Also if you run a command like &lt;code&gt;;;;(source first)&lt;/code&gt; it will only run on Clojure. The command is a comment to Lingy but the REPL will remove the &lt;code&gt;;;;&lt;/code&gt; and pass it to Clojure.&lt;/p&gt; &#xA;&lt;p&gt;Using this feature is a great way to compare how Lingy and Clojure work. Eventually they should be very close to identical but currently Lingy is still a baby.&lt;/p&gt; &#xA;&lt;h1&gt;Lingy / Perl Interoperability&lt;/h1&gt; &#xA;&lt;p&gt;Like Clojure and Java, Lingy and Perl are both ways interoperable.&lt;/p&gt; &#xA;&lt;p&gt;Note: This section currently covers the basics, but more in depth content will be added later.&lt;/p&gt; &#xA;&lt;h2&gt;Using Lingy from Perl Code&lt;/h2&gt; &#xA;&lt;p&gt;The Lingy.pm module lets you easily evaluate Lingy code from inside your Perl code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;use Lingy;&#xA;my $lingy = Lingy-&amp;gt;new;     # Setup the Lingy environment&#xA;my $result = $lingy-&amp;gt;rep(&#34;(+ 1 2 3 4)&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lingy Methods&lt;/h3&gt; &#xA;&lt;p&gt;The Lingy perl module supports the following methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $lingy = Lingy-&amp;gt;new();&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Create a new Lingy object.&lt;/p&gt; &lt;p&gt;This method takes no arguments.&lt;/p&gt; &lt;p&gt;The first time &lt;code&gt;Lingy-&amp;gt;new&lt;/code&gt; is called it initializes the Lingy runtime environment (which is required to process Lingy expressions).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $result_string = $lingy-&amp;gt;rep($lingy_source_code_string);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The &lt;code&gt;rep&lt;/code&gt; method stands for &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Evaluate&lt;/code&gt;, &lt;code&gt;Print&lt;/code&gt; which is the runtime process for running Lingy (or any Lisp) code. This is likely the most common method you will use.&lt;/p&gt; &lt;p&gt;Note: If you call this in a &#34;Loop&#34; you&#39;ve created a &#34;REPL&#34; (Read, Evaluate, Print, Loop).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Lingy also exposes each of the Read, Evaluate and Print methods to give you more control:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $form = $lingy-&amp;gt;read($lingy_source_code_string);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Read a string containing a Lingy source expression and return the Lingy AST object (form). In list context, returns all the form objects read if more than one form is parsed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $result_form = $lingy-&amp;gt;eval($form);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Evaluate a Lingy form object and return the resulting Lingy form object.&lt;/p&gt; &lt;p&gt;Use this in a Perl &lt;code&gt;eval&lt;/code&gt; block to catch any Lingy runtime errors.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;my $result_string = $lingy-&amp;gt;print($form);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Print a Lingy form object to a text string.&lt;/p&gt; &lt;p&gt;Usually this results in a Lingy expression that you can pass to another &lt;code&gt;$lingy-&amp;gt;read&lt;/code&gt; method call if you want to.&lt;/p&gt; &lt;p&gt;Reading and Printing a Lingy string without Evaluating it in between, often produces the original string (or a semantically equivalent one). That&#39;s because Lisp (Lingy) is &#34;homoiconic&#34;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Using Perl from Lingy Code&lt;/h2&gt; &#xA;&lt;p&gt;Like Clojure, Lingy has a lot of functions/functionality for calling Perl code.&lt;/p&gt; &#xA;&lt;p&gt;This is how Clojure and Lingy are implemented in that as much of the language as possible is written in itself (Lisp) but many functions need to call to the host language to do the work.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(perl &#34;any perl source code string&#34;)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;This is the big hammer. Call Perl&#39;s &lt;code&gt;eval&lt;/code&gt; on any Perl code string and return the result.&lt;/p&gt; &lt;p&gt;The return value likely will not be a Lingy native object. If you save the result in a variable, don&#39;t expect that if will work like a native Lingy object. When the Lingy Printer sees a non-Lingy object it prints it as a YAML dump.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(import YAML.PP.Perl)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Load a Perl module. We are just using &lt;code&gt;YAML::PP::Perl&lt;/code&gt; as an example here. This is like &lt;code&gt;use YAML::PP::Perl;&lt;/code&gt; in Perl.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(def y-pp (YAML.PP.Perl. &#34;boolean&#34; &#34;JSON::PP&#34;))&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Create a new &lt;code&gt;YAML::PP::Perl&lt;/code&gt; object. The &lt;code&gt;.&lt;/code&gt; after the module name is like calling the &lt;code&gt;-&amp;gt;new&lt;/code&gt; in Perl.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(def y-pp (.new YAML.PP.Perl &#34;boolean&#34; &#34;JSON::PP&#34;))&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Call a Perl class method with arguments. This is another way to instantiate an object like the previous example. The &lt;code&gt;.xyz word at the start of an expression is like calling &lt;/code&gt;-&amp;gt;xyz` on the second word, which may be a class or an object.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(println (.dump ypp &#39;(+ 2 2)))&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Call a Perl method with arguments on a Perl instance object.&lt;/p&gt; &lt;p&gt;The example above will print the internal AST form of the Lingy expression &lt;code&gt;(+ 2 2)&lt;/code&gt;. This is a very useful way to debug Lingy.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;WWW&lt;/code&gt;, &lt;code&gt;XXX&lt;/code&gt;, &lt;code&gt;YYY&lt;/code&gt; and &lt;code&gt;ZZZ&lt;/code&gt;&lt;/p&gt; &lt;p&gt;These Lingy functions from the &lt;code&gt;lingy.devel&lt;/code&gt; library, work like the &lt;code&gt;XXX.pm&lt;/code&gt; CPAN module, but from Lingy.&lt;/p&gt; &lt;p&gt;This can we very useful for seeing what Lingy is doing internally.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;(use &#39;lingy.devel) (XXX (perl &#34;\\%INC&#34;))  ; Print a YAML dump of Perl&#39;s %INC value.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Differences from Clojure&lt;/h1&gt; &#xA;&lt;p&gt;Lingy intends to be a proper &#34;Clojure Platform&#34;; a complete port of Clojure to Perl and other languages.&lt;/p&gt; &#xA;&lt;p&gt;That said, differences must exist.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Lingy platform host language is currently just Perl. It is the intent to extend the language set to Python and others soon.&lt;/li&gt; &#xA; &lt;li&gt;Lingy currently only supports a subset of Clojure libraries (most notably clojure.core). It is intended that Lingy will eventually use Clojure&#39;s libraries directly starting with clojure.core. As of this release Lingy can &lt;code&gt;read-string&lt;/code&gt; all of clojure.core and it converts the forms it fully supports into the lingy.core namespace.&lt;/li&gt; &#xA; &lt;li&gt;Lingy tries to map Clojure namespace and Java class symbols/files to Lingy namespace and Perl module/class symbols/files. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The &lt;code&gt;clojure.core&lt;/code&gt; namespace equivalent in Lingy is &lt;code&gt;lingy.core&lt;/code&gt; and maps to a file name called &lt;code&gt;lib/Lingy/core.ly&lt;/code&gt; in the Lingy source code.&lt;/li&gt; &#xA;   &lt;li&gt;The &lt;code&gt;lingy.lang.HashMap&lt;/code&gt; symbol maps to the &lt;code&gt;Lingy::HashMap&lt;/code&gt; module (the &lt;code&gt;lib/Lingy/HashMap.pm&lt;/code&gt; file).&lt;/li&gt; &#xA;   &lt;li&gt;More mapping details to be added here later.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;#?&lt;/code&gt; reader macro uses the &lt;code&gt;:lingy/pl&lt;/code&gt; keyword to conditionally use forms that the Lingy/Perl platform supports.&lt;/li&gt; &#xA; &lt;li&gt;Special global vars (earmuffs) that are unique to Lingy: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;*lingy-version*&lt;/code&gt; Like &lt;code&gt;*clojure-version*&lt;/code&gt; but for Lingy&#39;s version.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*LANG*&lt;/code&gt; Set to &lt;code&gt;&#34;Lingy&#34;&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*HOST*&lt;/code&gt; Set to &lt;code&gt;&#34;perl&#34;&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*clojure-repl*&lt;/code&gt; Boolean (default &lt;code&gt;false&lt;/code&gt;) indicates whether Lingy REPL should also send input to a Clojure REPL.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Lingy error messages currently try to be close to the Clojure ones. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This isn&#39;t always possible or desirable.&lt;/li&gt; &#xA;   &lt;li&gt;Error messages may be completely overhauled to give better info.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Certainly there are other differences and this section will be improved over time.&lt;/p&gt; &#xA;&lt;h1&gt;Hacking on Lingy&lt;/h1&gt; &#xA;&lt;p&gt;If you want to contribute to Lingy, Welcome!&lt;/p&gt; &#xA;&lt;p&gt;If you just want to play with the source while using Lingy, Welcome!&lt;/p&gt; &#xA;&lt;p&gt;Here, we&#39;ll cover how to install Lingy from source and modify the source code. This will include tips on debugging Lingy.&lt;/p&gt; &#xA;&lt;p&gt;This section is a work in progress...&lt;/p&gt; &#xA;&lt;p&gt;Lingy development requires &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt; (almost any versions of these) and a bunch of Perl modules.&lt;/p&gt; &#xA;&lt;p&gt;You probably already have the commands. The best way to install the dependency modules is using the &lt;code&gt;cpanm Lingy&lt;/code&gt; command described above in the &#34;Installation&#34; section. The will install Lingy and all the Perl dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Then you can &lt;code&gt;git clone&lt;/code&gt; the source code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/ingydotnet/lingy.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set up local environment variables for development:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export PATH=$PWD/lingy/perl/bin:$PATH&#xA;export PERL5LIB=$PWD/lingy/perl/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And test your local source code install of Lingy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;which lingy     # Should point at your cloned version&#xA;lingy --execs   # Should list your clone&#xA;lingy -e &#39;(println *lingy-version*)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the &lt;code&gt;export&lt;/code&gt;s above to your shell rc file if you want to.&lt;/p&gt; &#xA;&lt;p&gt;You might need to add these exports if Lingy warns about them. This is more common for people who haven&#39;t used Perl in a while since people who do likely took care of it in the past.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;LC_CTYPE=en_US.UTF-8&#xA;LC_ALL=en_US.UTF-8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging Lingy in the REPL&lt;/h2&gt; &#xA;&lt;p&gt;Running &lt;code&gt;lingy -D&lt;/code&gt; will &lt;code&gt;(use &#39;lingy.devel)&lt;/code&gt; at startup. This provides some dev functions including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(XXX ...)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Throw a YAML dump of the internal Perl structure of the arguments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(WWW ...)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Warn the same thing as above but then return the argument so that the program can continue.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(x-carp-on)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Turn on full stack traces when Perl internally warns or dies. Calling &lt;code&gt;(throw ...)&lt;/code&gt; should also get a full stack trace with this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A bunch of other functions starting with &lt;code&gt;x-&lt;/code&gt;. Tab completion is your friend. :)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;See Also&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=9OcFh-HaCyI&#34;&gt;Video Talk about Lingy and YAMLScript&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://clojure.org/&#34;&gt;Clojure&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/YAMLScript&#34;&gt;YAMLScript&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Test::More::YAMLScript&#34;&gt;Test::More::YAMLScript&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Authors&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ingy döt Net &lt;a href=&#34;mailto:ingy@ingy.net&#34;&gt;ingy@ingy.net&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Copyright and License&lt;/h1&gt; &#xA;&lt;p&gt;Copyright 2023 by Ingy döt Net&lt;/p&gt; &#xA;&lt;p&gt;This is free software, licensed under:&lt;/p&gt; &#xA;&lt;p&gt;The MIT (X11) License&lt;/p&gt;</summary>
  </entry>
</feed>