<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-03T01:38:54Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>okharch/ppmlib</title>
    <updated>2022-09-03T01:38:54Z</updated>
    <id>tag:github.com,2022-09-03:/okharch/ppmlib</id>
    <link href="https://github.com/okharch/ppmlib" rel="alternate"></link>
    <summary type="html">&lt;p&gt;repository of pure perl modules used in projects but not present by default on provider perl installation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ppmlib&lt;/h1&gt; &#xA;&lt;p&gt;repository of pure perl modules used in projects but not present by default on provider perl installation&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>perlancar/perl-File-Trash-FreeDesktop</title>
    <updated>2022-09-03T01:38:54Z</updated>
    <id>tag:github.com,2022-09-03:/perlancar/perl-File-Trash-FreeDesktop</id>
    <link href="https://github.com/perlancar/perl-File-Trash-FreeDesktop" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>wakaba/perl-anyevent-timer-retry</title>
    <updated>2022-09-03T01:38:54Z</updated>
    <id>tag:github.com,2022-09-03:/wakaba/perl-anyevent-timer-retry</id>
    <link href="https://github.com/wakaba/perl-anyevent-timer-retry" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AnyEvent::Timer::Retry Perl module&lt;/p&gt;&lt;hr&gt;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;AnyEvent::Timer::Retry - Retrying until some condition is satisfied&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;p&gt;use AnyEvent::Timer::Retry; my $timer; $timer = AnyEvent::Timer::Retry-&amp;gt;new (on_retry =&amp;gt; sub { warn sprintf &#34;%dth retry...&#34; $timer-&amp;gt;retry_count; $&lt;em&gt;[0]-&amp;gt;($ok, $appdata); }, on_end =&amp;gt; sub { my ($self, $ok, $appdata) = @&lt;/em&gt;; if ($ok) { warn sprintf &#34;Succeeded after %d tries&#34;, $self-&amp;gt;retry_count; } else { warn sprintf &#34;Failed after %d tries&#34;, $self-&amp;gt;retry_count; } undef $timer; });&lt;/p&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;The C&lt;a href=&#34;AnyEvent::Timer::Retry&#34;&gt;AnyEvent::Timer::Retry&lt;/a&gt; module repeatedly run a code until some condition is satisfied.&lt;/p&gt; &#xA;&lt;p&gt;=head1 METHODS&lt;/p&gt; &#xA;&lt;p&gt;The module runs the specified code by instantiating it with the C&#xA; &lt;new&gt;&#xA;   method. The code specified by the C&amp;lt;on_retry&amp;gt; option to the method is repeatedly invoked until the object is notified as succeeded, or the execution is cancelled. Finally the code specified by the C&amp;lt;on_end&amp;gt; option is invoked.&#xA; &lt;/new&gt;&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $timer = AnyEvent::Timer::Retry-&amp;gt;new (NAME =&amp;gt; VALUE, ...)&lt;/p&gt; &#xA;&lt;p&gt;Run a code with specified arguments. Arguments must be specified as name/value pairs, which include:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item on_retry =&amp;gt; CODE&lt;/p&gt; &#xA;&lt;p&gt;The code reference that is invoked for each try.&lt;/p&gt; &#xA;&lt;p&gt;The code is invoked with the code reference I&amp;lt;$done&amp;gt; as the argument. The code is expected to invoke I&amp;lt;$done&amp;gt; extactly once, directly or indirectly, synchronously or asynchronously, with the following arguments: The first argument must be the boolean value representing whether the retry has succeeded or not. The second argment optionally accept any value, which can be used to pass application-dependent data from the C&amp;lt;on_retry&amp;gt; code to the C&amp;lt;on_end&amp;gt; code.&lt;/p&gt; &#xA;&lt;p&gt;The code is expected not to throw any exception. The I&amp;lt;$done&amp;gt; code will not throw any exception.&lt;/p&gt; &#xA;&lt;p&gt;Note that this code is also invoked for the first try. It is counted as the &#34;zeroth&#34; retry.&lt;/p&gt; &#xA;&lt;p&gt;This option must be specified.&lt;/p&gt; &#xA;&lt;p&gt;=item on_end =&amp;gt; CODE&lt;/p&gt; &#xA;&lt;p&gt;The code reference that is invoked after the result of the last retry is determined.&lt;/p&gt; &#xA;&lt;p&gt;The code is invoked with two arguments: The result of the last retry in boolean; The optional application data set by the C&amp;lt;$done&amp;gt; argument invoked by the C&amp;lt;on_retry&amp;gt; code. The code is expected not to throw any exception.&lt;/p&gt; &#xA;&lt;p&gt;This option must be specified.&lt;/p&gt; &#xA;&lt;p&gt;=item on_info =&amp;gt; CODE&lt;/p&gt; &#xA;&lt;p&gt;The code reference that is invoked when advisory or debug information is available. It is invoked when retry is scheduled, for example.&lt;/p&gt; &#xA;&lt;p&gt;If specified, the code reference is invoked with key/value pairs as arguments. At the time of writing, the only available key is C&#xA; &lt;message&gt;&#xA;  , which is always included in the argument. The value contains the human readable short description of the situation. The code reference is expected not to throw any exception.&#xA; &lt;/message&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unless the code reference is explicitly specified, the C&#xA; &lt;message&gt;&#xA;   value is printed to the standard error output.&#xA; &lt;/message&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item interval =&amp;gt; NUMBER&lt;/p&gt; &#xA;&lt;p&gt;The initial value for the interval between retries, in seconds.&lt;/p&gt; &#xA;&lt;p&gt;=item interval_backoff =&amp;gt; STRING&lt;/p&gt; &#xA;&lt;p&gt;Specify the backoff algorithm used to determine the sequence of intervals for retries. See later section for more information.&lt;/p&gt; &#xA;&lt;p&gt;=item timeout =&amp;gt; NUMBER&lt;/p&gt; &#xA;&lt;p&gt;The global timeout, in seconds. After this period has elapsed since the C&#xA; &lt;new&gt;&#xA;   method is invoked, the ongoing retrying is marked as failed and the entire retrying process is cancelled. Defaulted to 60.&#xA; &lt;/new&gt;&lt;/p&gt; &#xA;&lt;p&gt;Timeout is not set if the value is a negative number.&lt;/p&gt; &#xA;&lt;p&gt;=item retry_timeout =&amp;gt; NUMBER&lt;/p&gt; &#xA;&lt;p&gt;The initial value for the timeout of a retry, in seconds. Once this period has elapsed after the retrying is started, it waits for the next retrying with the appropriate interval. Please note that the retrying operation itself cannot be stopped, but its result is simply discarded. Defaulted to 60.&lt;/p&gt; &#xA;&lt;p&gt;Timeout is not set if the value is a negative number.&lt;/p&gt; &#xA;&lt;p&gt;=item retry_timeout_backoff =&amp;gt; STRING&lt;/p&gt; &#xA;&lt;p&gt;Specify the algorithm to determine the sequence of timeout values for retries. See later section for more information.&lt;/p&gt; &#xA;&lt;p&gt;=item max_retry_count =&amp;gt; NUMBER&lt;/p&gt; &#xA;&lt;p&gt;The maximum number of retries. By default, no maximum value is set.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;In additon, parameters to backoff algorithms can be specified as well, as described in later section.&lt;/p&gt; &#xA;&lt;p&gt;=item $count = $timer-&amp;gt;retry_count&lt;/p&gt; &#xA;&lt;p&gt;The current number of the retries. For the first run of the C&amp;lt;on_retry&amp;gt; code, it returns zero (0). For the first I&#xA; &lt;retry&gt;&#xA;  , it returns one (1).&#xA; &lt;/retry&gt;&lt;/p&gt; &#xA;&lt;p&gt;After the last retry, this method returns the number of the retries run with the object.&lt;/p&gt; &#xA;&lt;p&gt;=item $interval = $timer-&amp;gt;interval&lt;/p&gt; &#xA;&lt;p&gt;Return the I&#xA; &lt;initial&gt;&#xA;   value for the interval between retries, in seconds.&#xA; &lt;/initial&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $interval = $timer-&amp;gt;current_interval&lt;/p&gt; &#xA;&lt;p&gt;Return the interval before the current (or last) retry, in seconds. For the first try, it returns zero.&lt;/p&gt; &#xA;&lt;p&gt;=item $timeout = $timer-&amp;gt;retry_timeout&lt;/p&gt; &#xA;&lt;p&gt;Return the I&#xA; &lt;initial&gt;&#xA;   value for the retry timeout, in seconds.&#xA; &lt;/initial&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $timeout = $timer-&amp;gt;current_retry_timeout&lt;/p&gt; &#xA;&lt;p&gt;Return the retry timeout value for the current (or last) retry, in seconds.&lt;/p&gt; &#xA;&lt;p&gt;=item $time = $timer-&amp;gt;elapsed_time&lt;/p&gt; &#xA;&lt;p&gt;Return the elapsed time from the start of the timer, i.e. the invocation of the C&#xA; &lt;new&gt;&#xA;   method, in seconds.&#xA; &lt;/new&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item undef $timer&lt;/p&gt; &#xA;&lt;p&gt;=item $timer-&amp;gt;cancel&lt;/p&gt; &#xA;&lt;p&gt;Cancel the retrying, as soon as possible. Once the C&#xA; &lt;cancel&gt;&#xA;   method is invoked, or all references to the object is discarded, no more retry will be initiated later. Please note that the currently running retry cannot be stoped, although it is marked as failure.&#xA; &lt;/cancel&gt;&lt;/p&gt; &#xA;&lt;p&gt;After cancelled, the C&amp;lt;on_done&amp;gt; code is invoked with the result argument set to false, with no application data.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head1 BACKOFF ALGORITHMS&lt;/p&gt; &#xA;&lt;p&gt;The intervals between retries are determined by the algorithm specified to the C&amp;lt;interval_backoff&amp;gt; option. Likewise, the way to determine the timeout values of retries are specified by the C&amp;lt;retry_timeout_backoff&amp;gt; option. They are defaulted to C&#xA; &lt;exponential&gt;&#xA;   and C&#xA;  &lt;constant&gt;&#xA;   , respectively.&#xA;  &lt;/constant&gt;&#xA; &lt;/exponential&gt;&lt;/p&gt; &#xA;&lt;p&gt;Following builtin backoff algorithm are defined:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item C&#xA; &lt;constant&gt;&lt;/constant&gt;&lt;/p&gt; &#xA;&lt;p&gt;The value is never changed from their initial values.&lt;/p&gt; &#xA;&lt;p&gt;=item C&#xA; &lt;exponential&gt;&lt;/exponential&gt;&lt;/p&gt; &#xA;&lt;p&gt;The exponential backoff, i.e. the value is increased by multiplying previous value. If the option C&amp;lt;interval_backoff_multiplier&amp;gt; or C&amp;lt;retry_timeout_backoff_multiplier&amp;gt; is specified, it is used as the multiplier for the values. Defaulted to C&amp;lt;1.5&amp;gt;. If the option C&amp;lt;interval_backoff_max&amp;gt; or C&amp;lt;retry_timeout_backoff_max&amp;gt; is specified, and if the calculated value is greater than that value, it is used as the value instead.&lt;/p&gt; &#xA;&lt;p&gt;=item C&#xA; &lt;random&gt;&lt;/random&gt;&lt;/p&gt; &#xA;&lt;p&gt;The value is randomly selected between minimum and maximum values. The initial value is ignored. The minimum value is taken from the option C&amp;lt;interval_backoff_min&amp;gt; or C&amp;lt;retry_timeout_backoff_min&amp;gt;. Likewise, the maximum value is taken from the option C&amp;lt;interval_backoff_max&amp;gt; or C&amp;lt;retry_timeout_backoff_max&amp;gt;. Their defaults are C&amp;lt;1&amp;gt; and C&amp;lt;10&amp;gt;, respectively.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;In addition, you can define other backoff algorithm by adding key-value pair to hash reference C&amp;lt;$AnyEvent::Timer::Retry::BackoffAlgorithms&amp;gt;, where key is the short name of the backoff algorithm and the value is the implementation of the algorithm given as a code reference. The code reference is invoked with two values: The first, I&amp;lt;$type&amp;gt;, represents the type of the value, C&#xA; &lt;interval&gt;&#xA;   or C&amp;lt;retry_timeout&amp;gt;. The second, I&amp;lt;$timer&amp;gt;, is the C&#xA;  &lt;a href=&#34;AnyEvent::Timer::Retry&#34;&gt;AnyEvent::Timer::Retry&lt;/a&gt; object. It can access to the initial value by C&amp;lt;&amp;lt; $timer-&amp;gt;$type &amp;gt;&amp;gt;, the current value by C&amp;lt;&amp;lt; $timer-&amp;gt;{&#34;current_$type&#34;} &amp;gt;&amp;gt; (which could be C&#xA;  &lt;undef&gt;&#xA;    for the first try), the current retry count by C&amp;lt;&amp;lt; $timer-&amp;gt;retry_count &amp;gt;&amp;gt;, an algorithm-specific option by C&amp;lt;&amp;lt; $timer-&amp;gt;{$type . &#39;&#xA;   &lt;em&gt;backoff&lt;/em&gt;&#39; . $name}&#xA;  &lt;/undef&gt;&#xA; &lt;/interval&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;where I&amp;lt;$name&amp;gt; is the algorithm-specific option name. Any other member of C&amp;lt;&amp;lt; $timer &amp;gt;&amp;gt; should not be accessed. The code reference is expected not to throw any exception.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;=head1 DEVELOPMENT&lt;/p&gt; &#xA;&lt;p&gt;Latest version of the module is available from GitHub &lt;a href=&#34;https://github.com/wakaba/perl-anyevent-timer-retry&#34;&gt;https://github.com/wakaba/perl-anyevent-timer-retry&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Test results of the module can be examined at: &lt;a href=&#34;https://travis-ci.org/wakaba/perl-anyevent-timer-retry&#34;&gt;https://travis-ci.org/wakaba/perl-anyevent-timer-retry&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=head1 ACKNOWLEDGEMENTS&lt;/p&gt; &#xA;&lt;p&gt;Design and implementation of this module is influenced by previous works on this area, in particular L&lt;a href=&#34;AnyEvent::Retry&#34;&gt;AnyEvent::Retry&lt;/a&gt; and L&lt;a href=&#34;AnyEvent::RetryTimer&#34;&gt;AnyEvent::RetryTimer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2012 Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt;</summary>
  </entry>
</feed>