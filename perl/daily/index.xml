<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-09T01:49:48Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hadley/ggplot2-book</title>
    <updated>2022-08-09T01:49:48Z</updated>
    <id>tag:github.com,2022-08-09:/hadley/ggplot2-book</id>
    <link href="https://github.com/hadley/ggplot2-book" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ggplot2: elegant graphics for data analysis&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ggplot2 book&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hadley/ggplot2-book/actions&#34;&gt;&lt;img src=&#34;https://github.com/hadley/ggplot2-book/workflows/workflow/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;This is code and text behind the &lt;a href=&#34;http://ggplot2-book.org/&#34;&gt;ggplot2: elegant graphics for data analysis&lt;/a&gt; book. Please help us make it better by &lt;a href=&#34;https://raw.githubusercontent.com/hadley/ggplot2-book/master/contributing.md&#34;&gt;contributing&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Installing dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Install the R packages used by the book with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_deps()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build the book&lt;/h2&gt; &#xA;&lt;p&gt;In RStudio, press Cmd/Ctrl + Shift + B. Or run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;bookdown::render_book(&#34;index.Rmd&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>Tarrasch/zsh-autoenv</title>
    <updated>2022-08-09T01:49:48Z</updated>
    <id>tag:github.com,2022-08-09:/Tarrasch/zsh-autoenv</id>
    <link href="https://github.com/Tarrasch/zsh-autoenv" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Autoenv for zsh&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/Tarrasch/zsh-autoenv&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Tarrasch/zsh-autoenv.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Autoenv for Zsh&lt;/h1&gt; &#xA;&lt;p&gt;zsh-autoenv automatically sources (known/whitelisted) &lt;code&gt;.autoenv.zsh&lt;/code&gt; files, typically used in project root directories.&lt;/p&gt; &#xA;&lt;p&gt;It handles &#34;enter&#34; and leave&#34; events, nesting, and stashing of variables (overwriting and restoring).&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Zsh version 4.3.10 or later.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for enter and leave events, which can use the same file. By default it uses &lt;code&gt;.autoenv.zsh&lt;/code&gt; for entering, and &lt;code&gt;.autoenv_leave.zsh&lt;/code&gt; for leaving.&lt;/li&gt; &#xA; &lt;li&gt;Interactively asks for confirmation / authentication before sourcing an unknown &lt;code&gt;.autoenv.zsh&lt;/code&gt; file, and remembers whitelisted files by their hashed content.&lt;/li&gt; &#xA; &lt;li&gt;Test suite.&lt;/li&gt; &#xA; &lt;li&gt;Written in/for Zsh.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Variable stashing&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;autostash&lt;/code&gt; in your &lt;code&gt;.autoenv.zsh&lt;/code&gt; files to overwrite some variable, e.g. &lt;code&gt;$PATH&lt;/code&gt;. When leaving the directory, it will be automatically restored.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% echo &#39;echo ENTERED; autostash FOO=changed&#39; &amp;gt; project/.autoenv.zsh&#xA;% FOO=orig&#xA;% cd project&#xA;Attempting to load unauthorized env file!&#xA;-rw-rw-r-- 1 user user 36 Mai  6 20:38 /tmp/project/.autoenv.zsh&#xA;&#xA;**********************************************&#xA;&#xA;echo ENTERED; autostash FOO=changed&#xA;&#xA;**********************************************&#xA;&#xA;Would you like to authorize it? (type &#39;yes&#39;) yes&#xA;ENTERED&#xA;project % echo $FOO&#xA;changed&#xA;% cd ..&#xA;% echo $FOO&#xA;orig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also &lt;code&gt;stash&lt;/code&gt;, &lt;code&gt;unstash&lt;/code&gt; and &lt;code&gt;autounstash&lt;/code&gt;, in case you want to have more control.&lt;/p&gt; &#xA;&lt;p&gt;The varstash library has been taken from smartcd, and was optimized for Zsh.&lt;/p&gt; &#xA;&lt;h2&gt;Writing your .autoenv.zsh file&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;autoenv_source_parent()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;zsh-autoenv will stop looking for &lt;code&gt;.autoenv.zsh&lt;/code&gt; files upwards after the first one has been found, but you can use the function &lt;code&gt;autoenv_source_parent&lt;/code&gt; to source the next &lt;code&gt;.autoenv.zsh&lt;/code&gt; file upwards the directory tree from there.&lt;/p&gt; &#xA;&lt;p&gt;The function accepts an optional argument, which allows to stop looking before the file system root is reached:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;autoenv_source_parent ../..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository and source it from your &lt;code&gt;~/.zshrc&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% git clone https://github.com/Tarrasch/zsh-autoenv ~/.dotfiles/lib/zsh-autoenv&#xA;% echo &#39;source ~/.dotfiles/lib/zsh-autoenv/autoenv.zsh&#39; &amp;gt;&amp;gt; ~/.zshrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://github.com/zsh-users/antigen&#34;&gt;antigen&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;antigen-bundle Tarrasch/zsh-autoenv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://github.com/tarjoilija/zgen&#34;&gt;zgen&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;.zshrc&lt;/code&gt; where you are loading your plugins:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;zgen load Tarrasch/zsh-autoenv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://github.com/zplug/zplug&#34;&gt;zplug&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;.zshrc&lt;/code&gt; where you are loading your plugins:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;zplug &#34;Tarrasch/zsh-autoenv&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You can use the following variables to control zsh-autoenv&#39;s behavior. Add them to your &lt;code&gt;~/.zshrc&lt;/code&gt; file, before sourcing/loading zsh-autoenv.&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_FILE_ENTER&lt;/h3&gt; &#xA;&lt;p&gt;Name of the file to look for when entering directories.&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;.autoenv.zsh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_FILE_LEAVE&lt;/h3&gt; &#xA;&lt;p&gt;Name of the file to look for when leaving directories. Requires &lt;code&gt;AUTOENV_HANDLE_LEAVE=1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;.autoenv_leave.zsh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_LOOK_UPWARDS&lt;/h3&gt; &#xA;&lt;p&gt;Look for zsh-autoenv &#34;enter&#34; files in parent dirs?&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_HANDLE_LEAVE&lt;/h3&gt; &#xA;&lt;p&gt;Handle leave events when changing away from a subtree, where an &#34;enter&#34; event was handled?&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_DISABLED&lt;/h3&gt; &#xA;&lt;p&gt;(Temporarily) disable zsh-autoenv. This gets looked at in the chpwd handler.&lt;/p&gt; &#xA;&lt;p&gt;Default: 0&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_DEBUG&lt;/h3&gt; &#xA;&lt;p&gt;Set debug level. If enabled (&amp;gt; 0) it will print information to stderr.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;0: no debug messages&lt;/li&gt; &#xA; &lt;li&gt;1: generic debug logging&lt;/li&gt; &#xA; &lt;li&gt;2: more verbose messages &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;messages about adding/removing files on the internal stack&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;3: everything &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;sets xtrace option (&lt;code&gt;set -x&lt;/code&gt;) while sourcing env files&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;0&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;zsh-autoenv works automatically once installed.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;autoenv-edit&lt;/code&gt; to edit the nearest/current autoenv files. It will use &lt;code&gt;$AUTOENV_EDITOR&lt;/code&gt;, &lt;code&gt;$EDITOR&lt;/code&gt;, or &lt;code&gt;vim&lt;/code&gt; for editing.&lt;/p&gt; &#xA;&lt;h2&gt;Helper functions&lt;/h2&gt; &#xA;&lt;p&gt;The following helper functions are available:&lt;/p&gt; &#xA;&lt;h3&gt;autoenv_append_path&lt;/h3&gt; &#xA;&lt;p&gt;Appends path(s) to &lt;code&gt;$path&lt;/code&gt; (&lt;code&gt;$PATH&lt;/code&gt;), if they are not in there already.&lt;/p&gt; &#xA;&lt;h3&gt;autoenv_prepend_path&lt;/h3&gt; &#xA;&lt;p&gt;Prepends path(s) to &lt;code&gt;$path&lt;/code&gt; (&lt;code&gt;$PATH&lt;/code&gt;), if they are not in there already.&lt;/p&gt; &#xA;&lt;h3&gt;autoenv_remove_path&lt;/h3&gt; &#xA;&lt;p&gt;Removes path(s) from &lt;code&gt;$path&lt;/code&gt; (&lt;code&gt;$PATH&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Returns 0 in case &lt;code&gt;$path&lt;/code&gt; has changed, 1 otherwise.&lt;/p&gt; &#xA;&lt;h2&gt;Recipes&lt;/h2&gt; &#xA;&lt;h3&gt;Automatically activate Python virtualenvs&lt;/h3&gt; &#xA;&lt;p&gt;Given &lt;code&gt;AUTOENV_FILE_ENTER=.autoenv.zsh&lt;/code&gt;, &lt;code&gt;AUTOENV_FILE_LEAVE=.autoenv.zsh&lt;/code&gt; and &lt;code&gt;AUTOENV_HANDLE_LEAVE=1&lt;/code&gt; the following script will activate Python virtualenvs automatically in all subdirectories (&lt;code&gt;.venv&lt;/code&gt; directories get used by &lt;a href=&#34;https://github.com/kennethreitz/pipenv&#34;&gt;pipenv&lt;/a&gt; with &lt;code&gt;PIPENV_VENV_IN_PROJECT=1&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;# Environment file for all projects.&#xA;#  - (de)activates Python virtualenvs (.venv) from pipenv&#xA;&#xA;if [[ $autoenv_event == &#39;enter&#39; ]]; then&#xA;  autoenv_source_parent&#xA;&#xA;  _my_autoenv_venv_chpwd() {&#xA;    if [[ -z &#34;$_ZSH_ACTIVATED_VIRTUALENV&#34; &amp;amp;&amp;amp; -n &#34;$VIRTUAL_ENV&#34; ]]; then&#xA;      return&#xA;    fi&#xA;&#xA;    setopt localoptions extendedglob&#xA;    local -a venv&#xA;    venv=(./(../)#.venv(NY1:A))&#xA;&#xA;    if [[ -n &#34;$_ZSH_ACTIVATED_VIRTUALENV&#34; &amp;amp;&amp;amp; -n &#34;$VIRTUAL_ENV&#34; ]]; then&#xA;      if ! (( $#venv )) || [[ &#34;$_ZSH_ACTIVATED_VIRTUALENV&#34; != &#34;$venv[1]&#34; ]]; then&#xA;        unset _ZSH_ACTIVATED_VIRTUALENV&#xA;        echo &#34;De-activating virtualenv: ${(D)VIRTUAL_ENV}&#34; &amp;gt;&amp;amp;2&#xA;&#xA;        # Simulate &#34;deactivate&#34;, but handle $PATH better (remove VIRTUAL_ENV).&#xA;        if ! autoenv_remove_path $VIRTUAL_ENV/bin; then&#xA;          echo &#34;warning: ${VIRTUAL_ENV}/bin not found in \$PATH&#34; &amp;gt;&amp;amp;2&#xA;        fi&#xA;&#xA;        # NOTE: does not handle PYTHONHOME/_OLD_VIRTUAL_PYTHONHOME&#xA;        unset _OLD_VIRTUAL_PYTHONHOME&#xA;        # NOTE: does not handle PS1/_OLD_VIRTUAL_PS1&#xA;        unset _OLD_VIRTUAL_PS1&#xA;        unset VIRTUAL_ENV&#xA;      fi&#xA;    fi&#xA;&#xA;    if [[ -z &#34;$VIRTUAL_ENV&#34; ]]; then&#xA;      if (( $#venv )); then&#xA;        echo &#34;Activating virtualenv: ${(D)venv}&#34; &amp;gt;&amp;amp;2&#xA;        export VIRTUAL_ENV=$venv[1]&#xA;        autoenv_prepend_path $VIRTUAL_ENV/bin&#xA;        _ZSH_ACTIVATED_VIRTUALENV=&#34;$venv[1]&#34;&#xA;      fi&#xA;    fi&#xA;  }&#xA;  autoload -U add-zsh-hook&#xA;  add-zsh-hook chpwd _my_autoenv_venv_chpwd&#xA;  _my_autoenv_venv_chpwd&#xA;else&#xA;  add-zsh-hook -d chpwd _my_autoenv_venv_chpwd&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;https://github.com/direnv/direnv&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cxreg/smartcd&#34;&gt;https://github.com/cxreg/smartcd&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kennethreitz/autoenv&#34;&gt;https://github.com/kennethreitz/autoenv&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;This started as an optimized version of the bash plugin &lt;a href=&#34;https://github.com/kennethreitz/autoenv&#34;&gt;autoenv&lt;/a&gt; but for Zsh, and grew a lot of functionality on top of it (inspired by &lt;a href=&#34;https://github.com/cxreg/smartcd&#34;&gt;smartcd&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The code was initially based on &lt;a href=&#34;https://github.com/joshuaclayton&#34;&gt;@joshuaclayton&lt;/a&gt;&#39;s dotfiles. In September 2013 &lt;a href=&#34;https://github.com/Tarrasch&#34;&gt;@Tarrasch&lt;/a&gt; packaged it into a nice &lt;a href=&#34;https://github.com/Tarrasch/antigen-hs&#34;&gt;antigen&lt;/a&gt;-compatible unit with integration tests. Since November 2014, &lt;a href=&#34;https://github.com/blueyed&#34;&gt;@blueyed&lt;/a&gt; took over and added many nice features, mainly inspired by &lt;a href=&#34;https://github.com/cxreg/smartcd&#34;&gt;smartcd&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>