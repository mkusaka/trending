<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-06T01:35:57Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>stinb/plugins</title>
    <updated>2022-10-06T01:35:57Z</updated>
    <id>tag:github.com,2022-10-06:/stinb/plugins</id>
    <link href="https://github.com/stinb/plugins" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Understand Plugins and Scripts&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Understand Plugins&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stinb/plugins/main/www.scitools.com&#34;&gt;Understand&lt;/a&gt; is a powerful static analysis tool designed for code maintenance and exploration. It creates an extensive database about your code and how everything is interconnected. The Understand IDE shows you a lot of that information directly, but it also has fully extensible plugin systems for Python and Perl to let you gather and display your teams information in the most meaningful way. Understand supports 4 flavors of plugins: &lt;a href=&#34;https://github.com/stinb/plugins/tree/main/Graph&#34;&gt;Graphs&lt;/a&gt;, &lt;a href=&#34;https://github.com/stinb/plugins/tree/main/IReport&#34;&gt;Interactive Reports&lt;/a&gt;, &lt;a href=&#34;https://github.com/stinb/plugins/tree/main/CodeCheck&#34;&gt;CodeChecks&lt;/a&gt; and &lt;a href=&#34;https://github.com/stinb/plugins/tree/main/Scripts/Python&#34;&gt;Scripts&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Checkout the &lt;a href=&#34;https://scitools.freshdesk.com/en/support/solutions/articles/70000582855&#34;&gt;API tutorials&lt;/a&gt; for more help writing your own plugins. The most up-to-date documentation is accessible from the Help menu in Understand. Select Help-&amp;gt;Python API Documentation. You can also &lt;a href=&#34;https://documentation.scitools.com/html/python/index.html&#34;&gt;access it here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Graph Plugins&lt;/h2&gt; &#xA;&lt;p&gt;With a graph plugin you can leverage the information in the Understand database to create graphs of what is important to you. For example this plugin creates a call tree graph that changes the color based on the complexity of the function. Graphs can be accessed directly in Understand or exported en masse via a script plugin. Check out the &lt;a href=&#34;https://github.com/stinb/plugins/raw/main/Graph/README.md&#34;&gt;README file&lt;/a&gt; in the Graph folder for more details.&lt;br&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/6586272/193095922-cea89e3d-813d-4492-b90a-ef3a42210105.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Interactive Reports&lt;/h2&gt; &#xA;&lt;p&gt;Interactive report plugins, or IReports, let you run queries or gather information on a specified entity in Understand, from Architectures, or from the project as a whole. For example, the below Change Impact IReport let&#39;s you project how much impact changing a function will have, I can see that modifying this function will affect more than 40,000 lines of code.&lt;br&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/6586272/193100232-d82e65a9-dea5-48c1-94fe-0596e66442de.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CodeCheck Plugins&lt;/h2&gt; &#xA;&lt;p&gt;The CodeCheck feature in Understand has hundreds of checks yous can run against your code to validate coding standards and look for issues and vulnerabilities. The Python API makes it easy to &lt;a href=&#34;https://github.com/stinb/plugins/raw/main/CodeCheck/README.md&#34;&gt;write your own checks&lt;/a&gt; as well, like this one we use to enforce our internal parenthesis standard.&lt;br&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/6586272/193142606-7bf859c2-138b-49d5-a0ec-a403a3a6cf7a.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Scripts&lt;/h2&gt; &#xA;&lt;p&gt;You can also query the Understand DB directly with Python and Perl API scripts. You can run these scripts from inside the GUI or from the command line, which lends itself well to batch processes or DevOps integration. We use these scripts heavily as part of our Jenkins CI Pipeline. In this trivial example I list all of the enums in my project from the command line. &lt;img src=&#34;https://user-images.githubusercontent.com/6586272/193142975-512082f8-b9c6-4fc1-b077-b5c5f450f00c.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>manakai/perl-promise</title>
    <updated>2022-10-06T01:35:57Z</updated>
    <id>tag:github.com,2022-10-06:/manakai/perl-promise</id>
    <link href="https://github.com/manakai/perl-promise" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Promise in Perl&lt;/p&gt;&lt;hr&gt;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;Promise - Promise for Perl&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;p&gt;use Promise;&lt;/p&gt; &#xA;&lt;p&gt;$p = Promise-&amp;gt;new (sub { my ($resolve, $reject) = @_; some_async_action (sub { if ($error) { $reject-&amp;gt;($error); } else { $resolve-&amp;gt;($result); } }); }); $p-&amp;gt;then (sub { my $result = shift; ... }, sub { my $error = shift; ... });&lt;/p&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;The C&#xA; &lt;promise&gt;&#xA;   module defines a promise class which exposes methods similar to those of the JavaScript C&#xA;  &lt;promise&gt;&#xA;    class.&#xA;  &lt;/promise&gt;&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;A promise is either to be fulfilled or to be rejected. When the promise is B&#xA; &lt;fulfilled&gt;&#xA;   with a value, any fulfilled callback registered with the promise is invoked with the value. When the promise is B&#xA;  &lt;rejected&gt;&#xA;    with a value, any rejected callback registered with the promise is invoked with the value. Any number of fulfilled and rejected callbacks can be registered. Callbacks can be registered anytime, before or after fulfilling or rejecting of the promise. Each callback is invoked at most once for the promise.&#xA;  &lt;/rejected&gt;&#xA; &lt;/fulfilled&gt;&lt;/p&gt; &#xA;&lt;p&gt;A promise can be B&#xA; &lt;resolved&gt;&#xA;  . When a promise is resolved with another promise, the original promise is fulfilled or rejected once the other promise is fulfilled or rejected, with the same value. When a promise is resolved with a non-promise value, the promise is fulfilled with the value.&#xA; &lt;/resolved&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that fulfilling a promise without value is equivalent to fulfilling a promise with the value of C&#xA; &lt;undef&gt;&#xA;  .&#xA; &lt;/undef&gt;&lt;/p&gt; &#xA;&lt;p&gt;For the purpose of resolution, any Perl object with the C&#xA; &lt;then&gt;&#xA;   method defined is a promise. That is, promise objects implementing other Perl classes can be used in mixture with these L&#xA;  &lt;promise&gt;&#xA;    objects.&#xA;  &lt;/promise&gt;&#xA; &lt;/then&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 METHODS&lt;/p&gt; &#xA;&lt;p&gt;There are following class methods:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $p = Promise-&amp;gt;new (CODE)&lt;/p&gt; &#xA;&lt;p&gt;Create a new promise object. There must be an argument, which must be a code reference. It is expected that the code, when invoked, calls either the first or the second argument to the code synchronously or asynchronously.&lt;/p&gt; &#xA;&lt;p&gt;To resolve the promise created, the first argument (C&amp;lt;$_[0]&amp;gt;), which is a code reference, must be invoked. If an argument is specified to the code, it is used to resolve the promise. Otherwise, C&#xA; &lt;undef&gt;&#xA;   is used to resolve the promise.&#xA; &lt;/undef&gt;&lt;/p&gt; &#xA;&lt;p&gt;To reject the promise created, the second argument (C&amp;lt;$_[1]&amp;gt;), which is a code reference, must be invoked. If an argument is specified to the code, it is used to reject the promise. Otherwise, C&#xA; &lt;undef&gt;&#xA;   is used to reject the promise.&#xA; &lt;/undef&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $p = Promise-&amp;gt;resolve ($x)&lt;/p&gt; &#xA;&lt;p&gt;Return a promise which is resolved with the value specified as the argument. If the argument is a promise, that promise is returned as is. Otherwise, a new promise is created.&lt;/p&gt; &#xA;&lt;p&gt;=item $p = Promise-&amp;gt;reject ($r)&lt;/p&gt; &#xA;&lt;p&gt;Create and return a new promise which is rejected with the value specified as the argument.&lt;/p&gt; &#xA;&lt;p&gt;=item $p = Promise-&amp;gt;all ([$p1, $p2, ...])&lt;/p&gt; &#xA;&lt;p&gt;Create a new promise object, which is to be fulfilled when all of the promises specified in the argument are fulfilled.&lt;/p&gt; &#xA;&lt;p&gt;The argument must be an array reference (or an object which can be evaluated as if it were an array reference).&lt;/p&gt; &#xA;&lt;p&gt;The promise created is to be fulfilled when all of the promises are fulfilled, with an array reference which contains the resolved values of the values included in the array in the argument, in same order.&lt;/p&gt; &#xA;&lt;p&gt;The promise is to be rejected when any of the promises is rejected, with the value of the rejected promise.&lt;/p&gt; &#xA;&lt;p&gt;=item $p = Promise-&amp;gt;race ([$p1, $p2, ...])&lt;/p&gt; &#xA;&lt;p&gt;Create a new promise object, which is to be fulfilled when any of the promises specified in the argument are fulfilled.&lt;/p&gt; &#xA;&lt;p&gt;The argument must be an array reference (or an object which can be evaluated as if it were an array reference).&lt;/p&gt; &#xA;&lt;p&gt;The promise is to be fulfilled or rejected when any of the promises is fulfilled or rejected, with the value of the fulfilled or rejected promise.&lt;/p&gt; &#xA;&lt;p&gt;=item $p = Promise-&amp;gt;from_cv ($cv)&lt;/p&gt; &#xA;&lt;p&gt;Create a promise, which is resolved with the value received by the condvar specified as the argument.&lt;/p&gt; &#xA;&lt;p&gt;The argument is typically an L&lt;a href=&#34;AnyEvent::CondVar&#34;&gt;AnyEvent::CondVar&lt;/a&gt; object, though any object compatible with L&lt;a href=&#34;AnyEvent::CondVar&#34;&gt;AnyEvent::CondVar&lt;/a&gt; API can be used. The argument must be an object with the C&#xA; &lt;cb&gt;&#xA;   method with a code reference argument, which is to be invoked with an object with C&#xA;  &lt;recv&gt;&#xA;    method. If the C&#xA;   &lt;recv&gt;&#xA;     method returns a value (i.e. C&amp;lt;&amp;lt; $cv-&amp;gt;send &amp;gt;&amp;gt; is invoked), the promise is resolved with the value. If the C&#xA;    &lt;recv&gt;&#xA;      method throws (i.e. C&amp;lt;&amp;lt; $cv-&amp;gt;croak &amp;gt;&amp;gt; is invoked), the promise is rejected with the exception.&#xA;    &lt;/recv&gt;&#xA;   &lt;/recv&gt;&#xA;  &lt;/recv&gt;&#xA; &lt;/cb&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;A promise has following methods:&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item $p2 = $p-&amp;gt;then ($onfulfilled, $onrejected)&lt;/p&gt; &#xA;&lt;p&gt;Register callback functions invoked when the promise is fulfilled or rejected. The arguments are the fulfilled and rejected callbacks, in order. The arguments can be omitted (or specify the C&#xA; &lt;undef&gt;&#xA;   value).&#xA; &lt;/undef&gt;&lt;/p&gt; &#xA;&lt;p&gt;The fulfilled callback is invoked when the promise is fulfilled, with the value of the fulfillment as the argument. The default fulfilled callback just returns the argument.&lt;/p&gt; &#xA;&lt;p&gt;The rejected callback is invoked when the promise is rejected, with the value of the rejection as the argument. The default rejection callback just throws the argument.&lt;/p&gt; &#xA;&lt;p&gt;The method returns a new promise. If the fulfilled callback or the rejected callback returns a value, the new promise is resolved with the value. If the fulfilled callback or the rejected callback throws an exception, the new promise is rejected with the exception.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;p&gt;Promise-&amp;gt;resolve (3)-&amp;gt;then (sub { warn shift }); # 3 Promise-&amp;gt;reject (4)-&amp;gt;then (sub { never }, sub { warn shift }); # 4 ...-&amp;gt;then (sub { die 5 }) -&amp;gt;then (undef, sub { $&lt;em&gt;[0] }) -&amp;gt;then (sub { warn shift }); # 5 ...-&amp;gt;then (sub { Promise-&amp;gt;reject (6) }) -&amp;gt;then (undef, sub { warn shift }); # 6 ...-&amp;gt;then (sub { die 7 }) -&amp;gt;then (sub { never }, sub { die $&lt;/em&gt;[0] }) # die with 7 ...-&amp;gt;then (sub { die 8 }) -&amp;gt;then (sub { 10 }) -&amp;gt;then (sub { never }, sub { warn $_[0] }) # 8&lt;/p&gt; &#xA;&lt;p&gt;=item $p2 = $p-&amp;gt;catch ($onrejected)&lt;/p&gt; &#xA;&lt;p&gt;Register a callback function invoked when the promise is rejected. The argument is the rejected callback. This method has same effect as C&amp;lt;&amp;lt; $p2 = $p-&amp;gt;then (undef, $onrejected) &amp;gt;&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=item $p2 = $p-&amp;gt;finally ($onfinally)&lt;/p&gt; &#xA;&lt;p&gt;Register a callback function invoked when the promise is fulfilled or rejected. The argument is the callback.&lt;/p&gt; &#xA;&lt;p&gt;The method returns a new promise. If the callback throws an exception, or the callback returns a promise that is rejected with an exception, the new promise is rejected with the exception. Otherwise, once the return value of the callback is resolved, the new promise is fulfilled with the value of the fulfillment of the original promise, or rejected with the exception of the rejection of the original promise.&lt;/p&gt; &#xA;&lt;p&gt;The callback can be used for e.g. closing any resource opened by preceding callbacks.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;$database-&amp;gt;open-&amp;gt;then (sub { $database-&amp;gt;... # or reject })-&amp;gt;finally (sub { return $database-&amp;gt;close; });&lt;/p&gt; &#xA;&lt;p&gt;=item $cv = $p-&amp;gt;to_cv&lt;/p&gt; &#xA;&lt;p&gt;Create and return an L&lt;a href=&#34;AnyEvent::CondVar&#34;&gt;AnyEvent::CondVar&lt;/a&gt; object. When the promise is fulfilled, the condvar receives the result value (i.e. C&amp;lt;&amp;lt; $cv-&amp;gt;recv&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;returns the value). When the promise is rejected, the condvar is croaked with the thrown value (i.e. C&amp;lt;&amp;lt; $cv-&amp;gt;recv &amp;gt;&amp;gt; croaks with the value). Apparently this method requires L&#xA;   &lt;anyevent&gt;&#xA;    .&#xA;   &lt;/anyevent&gt;&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;=item $p-&amp;gt;manakai_set_handled&lt;/p&gt; &#xA;&lt;p&gt;Mark the promise &#34;handled&#34;, as if the C&#xA; &lt;then&gt;&#xA;   method were invoked, without creating a new promise or enqueueing handlers, supressing &#34;uncaught rejection&#34; warning. (In the ECMAScript specification terms, this method sets the [[PromiseIsHandled]] internal slot to true.)&#xA; &lt;/then&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item $string = $p-&amp;gt;debug_info&lt;/p&gt; &#xA;&lt;p&gt;Return a short character string that might be useful for debugging.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;All methods except for C&amp;lt;from_cv&amp;gt; and C&amp;lt;debug_info&amp;gt; act in similar way to methods with same name in JavaScript C&#xA; &lt;promise&gt;&#xA;   API.&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 ERRORS&lt;/p&gt; &#xA;&lt;p&gt;By default, a simple object, which is to be stringified into a string containing a short description of the error with the location of the error (e.g. C&amp;lt;Something&#39;s wrong at path/to/file.pl line 12345.\n&amp;gt;), is used when the JavaScript C&#xA; &lt;promise&gt;&#xA;   API would use a C&#xA;  &lt;typeerror&gt;&#xA;   . The object is implementing the Perl Error Object Interface Level 1 &#xA;   &lt;a href=&#34;https://github.com/manakai/perl-web-dom/raw/master/lib/Web/DOM/Error.pod#error-object-api&#34;&gt;https://github.com/manakai/perl-web-dom/blob/master/lib/Web/DOM/Error.pod#error-object-api&lt;/a&gt;.&#xA;  &lt;/typeerror&gt;&#xA; &lt;/promise&gt;&lt;/p&gt; &#xA;&lt;p&gt;By setting C&amp;lt;$Promise::CreateTypeError&amp;gt; variable to a code reference, any value can be used as an exception instead of the string. The code or method is invoked with the short description as the first method argument (C&amp;lt;$_[1]&amp;gt;) and is expected to return a value that is to be used as an exception. It is expected not to throw any exception.&lt;/p&gt; &#xA;&lt;p&gt;=head1 EVENT LOOP&lt;/p&gt; &#xA;&lt;p&gt;Fulfilled and rejected callbacks are expected to be invoked by queuing them to some kind of event scheduling mechanism.&lt;/p&gt; &#xA;&lt;p&gt;By default, this is implemented using L&#xA; &lt;anyevent&gt;&#xA;  . By setting C&amp;lt;$Promise::Enqueue&amp;gt; variable to a code reference, any event scheduling mechanism can be used instead. The code or method is invoked with the code reference as the first method argument (C&amp;lt;$_[1]&amp;gt;). It is expected not to throw any exception. It is expected that the code reference is enqueued and to be invoked later.&#xA; &lt;/anyevent&gt;&lt;/p&gt; &#xA;&lt;p&gt;If the L&#xA; &lt;anyevent&gt;&#xA;   default is unchanged and promises are used to write a standalone application, the condvar returned by the C&amp;lt;to_cv&amp;gt; method of the last promise can be used to wait for receiving, which effectively invokes the main loop of the application:&#xA; &lt;/anyevent&gt;&lt;/p&gt; &#xA;&lt;p&gt;use MyPromisedApp; MyPromisedApp-&amp;gt;some_process-&amp;gt;then (sub { ... })-&amp;gt;then (sub { ... })-&amp;gt;to_cv-&amp;gt;recv;&lt;/p&gt; &#xA;&lt;p&gt;=head1 DEPENDENCY&lt;/p&gt; &#xA;&lt;p&gt;The module requires Perl 5.8 or later and L&#xA; &lt;carp&gt;&#xA;   (which is a core module).&#xA; &lt;/carp&gt;&lt;/p&gt; &#xA;&lt;p&gt;By default the module also requires L&#xA; &lt;anyevent&gt;&#xA;  . However they are not required when event loop handlers are replaced as described in previous sections.&#xA; &lt;/anyevent&gt;&lt;/p&gt; &#xA;&lt;p&gt;Otherwise the module has no dependency. The module can be used by simply copying the module file into your Perl execution environment, or by adding the Git repository as a submodule of your Perl application.&lt;/p&gt; &#xA;&lt;p&gt;=head1 SEE ALSO&lt;/p&gt; &#xA;&lt;p&gt;ECMAScript Language Specification &lt;a href=&#34;https://tc39.github.io/ecma262/#sec-promise-objects&#34;&gt;https://tc39.github.io/ecma262/#sec-promise-objects&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are a number of promise-based Perl modules. For convinience, the same Git repository as this module contains L&lt;a href=&#34;Promised::Flow&#34;&gt;Promised::Flow&lt;/a&gt;, which abstracts common promise-based program control flows.&lt;/p&gt; &#xA;&lt;p&gt;L&#xA; &lt;abortcontroller&gt;&#xA;  , L&#xA;  &lt;abortsignal&gt;&#xA;   .&#xA;  &lt;/abortsignal&gt;&#xA; &lt;/abortcontroller&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 HISTORY&lt;/p&gt; &#xA;&lt;p&gt;This repository was originally located at &lt;a href=&#34;https://github.com/wakaba/perl-promise&#34;&gt;https://github.com/wakaba/perl-promise&lt;/a&gt;, which has been transferred to the manaki project on October 7, 2021.&lt;/p&gt; &#xA;&lt;p&gt;=head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2014-2021 Wakaba &lt;a href=&#34;mailto:wakaba@suikawiki.org&#34;&gt;wakaba@suikawiki.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt;</summary>
  </entry>
</feed>