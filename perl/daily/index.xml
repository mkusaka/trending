<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-19T01:52:35Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>binary-com/perl-Mojo-WebSocketProxy</title>
    <updated>2022-07-19T01:52:35Z</updated>
    <id>tag:github.com,2022-07-19:/binary-com/perl-Mojo-WebSocketProxy</id>
    <link href="https://github.com/binary-com/perl-Mojo-WebSocketProxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;perl-Mojo-WebSocketProxy&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/binary-com/perl-Mojo-WebSocketProxy&#34;&gt;&lt;img src=&#34;https://travis-ci.org/binary-com/perl-Mojo-WebSocketProxy.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/binary-com/perl-Mojo-WebSocketProxy&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/binary-com/perl-Mojo-WebSocketProxy/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;INSTALLATION&lt;/h4&gt; &#xA;&lt;p&gt;To install this module, run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl Makefile.PL&#xA;make&#xA;make test&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;NAME&lt;/h4&gt; &#xA;&lt;p&gt;Mojo::WebSocketProxy - WebSocket proxy for JSON-RPC 2.0 server&lt;/p&gt; &#xA;&lt;h4&gt;SYNOPSYS&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt; # lib/your-application.pm&#xA;&#xA; use base &#39;Mojolicious&#39;;&#xA;&#xA; sub startup {&#xA;     my $self = shift;&#xA;     $self-&amp;gt;plugin(&#xA;         &#39;web_socket_proxy&#39; =&amp;gt; {&#xA;             actions =&amp;gt; [&#xA;                 [&#39;json_key&#39;, {some_param =&amp;gt; &#39;some_value&#39;}]&#xA;             ],&#xA;             base_path =&amp;gt; &#39;/api&#39;,&#xA;             url =&amp;gt; &#39;http://rpc-host.com:8080/&#39;,&#xA;         }&#xA;     );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or to manually call RPC server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; # lib/your-application.pm&#xA;&#xA; use base &#39;Mojolicious&#39;;&#xA;&#xA; sub startup {&#xA;     my $self = shift;&#xA;     $self-&amp;gt;plugin(&#xA;         &#39;web_socket_proxy&#39; =&amp;gt; {&#xA;             actions =&amp;gt; [&#xA;                 [&#xA;                     &#39;json_key&#39;,&#xA;                     {&#xA;                         instead_of_forward =&amp;gt; sub {&#xA;                             shift-&amp;gt;call_rpc({&#xA;                                 args =&amp;gt; $args,&#xA;                                 method =&amp;gt; $rpc_method, # it&#39;ll call &#39;http://rpc-host.com:8080/rpc_method&#39;&#xA;                                 rpc_response_cb =&amp;gt; sub {...}&#xA;                             });&#xA;                         }&#xA;                     }&#xA;                 ]&#xA;             ],&#xA;             base_path =&amp;gt; &#39;/api&#39;,&#xA;             url =&amp;gt; &#39;http://rpc-host.com:8080/&#39;,&#xA;         }&#xA;     );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION&lt;/h4&gt; &#xA;&lt;p&gt;Using this module you can forward WebSocket-JSON requests to RPC server.&lt;/p&gt; &#xA;&lt;p&gt;For every message it creates separate hash ref storage, which is available from hooks as $req_storage. Request storage have RPC call parameters in $req_storage-&amp;gt;{call_params}. It copies message args to $req_storage-&amp;gt;{call_params}-&amp;gt;{args}. You can use Mojolicious stash to store data between messages in one connection.&lt;/p&gt; &#xA;&lt;h4&gt;Proxy responses&lt;/h4&gt; &#xA;&lt;p&gt;The plugin sends websocket messages to client with RPC response data. If RPC reponse looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{status =&amp;gt; 1}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It returns simple response like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{$msg_type =&amp;gt; 1, msg_type =&amp;gt; $msg_type}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If RPC returns something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    response_data =&amp;gt; [..],&#xA;    status        =&amp;gt; 1,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Plugin returns common response like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    $msg_type =&amp;gt; $rpc_response,&#xA;    msg_type  =&amp;gt; $msg_type,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can customize ws porxy response using &#39;response&#39; hook.&lt;/p&gt; &#xA;&lt;h4&gt;Sequence Diagram&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://g.gravizo.com/source/ws_proxy?https%3A%2F%2Fraw.githubusercontent.com%2Fbinary-com%2Fperl-Mojo-WebSocketProxy%2Fmaster%2FREADME.md&#34; alt=&#34;Alt text&#34;&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;/summary&gt; ws_proxy @startuml; title Websocket Proxy &#xA; &lt;p&gt;participant Client&lt;/p&gt; &#xA; &lt;p&gt;Client-&amp;gt;Websocket:Initiate connection Client-&amp;gt;Websocket:Send Message&lt;/p&gt; &#xA; &lt;p&gt;note over Websocket: before_forward note over Websocket: instead_of_forward&lt;/p&gt; &#xA; &lt;p&gt;Websocket-&amp;gt;Websocket: instead_of_forward does not forward to rpc and returns response back from ws if its valid one&lt;/p&gt; &#xA; &lt;p&gt;Websocket-&amp;gt;Client: send response (only if instead_of_forward)&lt;/p&gt; &#xA; &lt;p&gt;note over Websocket: before_call&lt;/p&gt; &#xA; &lt;p&gt;Websocket-&amp;gt;RPC: RPC request&lt;/p&gt; &#xA; &lt;p&gt;note over Websocket: after_forward note over Websocket: after_dispatch&lt;/p&gt; &#xA; &lt;p&gt;note over RPC: processing&lt;/p&gt; &#xA; &lt;p&gt;note over Websocket: before_got_rpc_response&lt;/p&gt; &#xA; &lt;p&gt;RPC-&amp;gt;Websocket: RPC response&lt;/p&gt; &#xA; &lt;p&gt;note over Websocket: after_got_rpc_response note over Websocket: success/error note over Websocket: response note over Websocket: before_send_api_response note over Websocket: send&lt;/p&gt; &#xA; &lt;p&gt;Websocket-&amp;gt;Client:send response back&lt;/p&gt; &#xA; &lt;p&gt;note over Websocket: after_send_api_response&lt;/p&gt; &#xA; &lt;p&gt;Client-&amp;gt;Websocket:Close Websocket connection @enduml ws_proxy&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Plugin parameters&lt;/h4&gt; &#xA;&lt;p&gt;The plugin understands the following parameters.&lt;/p&gt; &#xA;&lt;h5&gt;actions&lt;/h5&gt; &#xA;&lt;p&gt;A pointer to array of action details, which contain stash_params, request-response callbacks, other call parameters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$self-&amp;gt;plugin(&#xA;    &#39;web_socket_proxy&#39; =&amp;gt; {&#xA;        actions =&amp;gt; [&#xA;            [&#39;action1_json_key&#39;, {details_key1 =&amp;gt; details_value1}],&#xA;            [&#39;action2_json_key&#39;]&#xA;        ]&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;before_forward&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;before_forward =&amp;gt; [sub { my ($c, $req_storage) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run after request is dispatched and before to start preparing RPC call. It&#39;ll run every hook or until any hook returns some non-empty result. If returns any hash ref then that value will be JSON encoded and send to client, without forward action to RPC. To call RPC every hook should return empty or undefined value. It&#39;s good place to some validation or subscribe actions.&lt;/p&gt; &#xA;&lt;h4&gt;instead_of_forward (global)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;instead_of_forward =&amp;gt; [sub { my ($c, $req_storage) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use this hook if you don&#39;t want dispatcher to call RPC and want to handle request in websocket itself. It&#39;s not good practice to use it as global hook because if if you return response from sub passed then it will return same response for each call. &lt;a href=&#34;https://raw.githubusercontent.com/binary-com/perl-Mojo-WebSocketProxy/master/#instead-of-forward&#34;&gt;Read more&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;before_call (global)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;before_call =&amp;gt; [sub { my ($c, $req_storage) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run just before making rpc call.&lt;/p&gt; &#xA;&lt;h5&gt;after_forward (global)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;after_forward =&amp;gt; [sub { my ($c, $result, $req_storage) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run after every forwarded RPC call done. Or even forward action isn&#39;t running. It can view or modify result value from &#39;before_forward&#39; hook. It&#39;ll run every hook or until any hook returns some non-empty result. If returns any hash ref then that value will be JSON encoded and send to client.&lt;/p&gt; &#xA;&lt;h5&gt;after_dispatch (global)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;after_dispatch =&amp;gt; [sub { my $c = shift; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run at the end of request handling.&lt;/p&gt; &#xA;&lt;h5&gt;before_get_rpc_response (global)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;before_get_rpc_response =&amp;gt; [sub { my ($c, $req_storage) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run when asynchronous RPC call is answered.&lt;/p&gt; &#xA;&lt;h5&gt;after_got_rpc_response (global)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;after_got_rpc_response =&amp;gt; [sub { my ($c, $req_storage) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run after checked that response exists.&lt;/p&gt; &#xA;&lt;h5&gt;before_send_api_response (global)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;before_send_api_response =&amp;gt; [sub { my ($c, $req_storage, $api_response) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run immediately before send API response.&lt;/p&gt; &#xA;&lt;h5&gt;after_sent_api_response (global)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;before_send_api_response =&amp;gt; [sub { my ($c, $req_storage) = @_; ... }, sub {...}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Global hook which will run immediately after sent API response back to client.&lt;/p&gt; &#xA;&lt;h5&gt;base_path&lt;/h5&gt; &#xA;&lt;p&gt;API url for make route.&lt;/p&gt; &#xA;&lt;h5&gt;stream_timeout&lt;/h5&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://metacpan.org/pod/Mojo::IOLoop::Stream#timeout&#34;&gt;&#34;timeout&#34; in Mojo::IOLoop::Stream&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;max_connections&lt;/h5&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://metacpan.org/pod/Mojo::IOLoop#max_connections&#34;&gt;&#34;max_connections&#34; in Mojo::IOLoop&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;max_response_size&lt;/h5&gt; &#xA;&lt;p&gt;Returns error if RPC response size is over value.&lt;/p&gt; &#xA;&lt;h5&gt;opened_connection&lt;/h5&gt; &#xA;&lt;p&gt;Callback for doing something once after connection is opened&lt;/p&gt; &#xA;&lt;h5&gt;finish_connection&lt;/h5&gt; &#xA;&lt;p&gt;Callback for doing something every time when connection is closed.&lt;/p&gt; &#xA;&lt;h5&gt;url&lt;/h5&gt; &#xA;&lt;p&gt;RPC host url - store url string or function to set url dynamically for manually RPC calls. When using forwarded call then url storing in request storage. You can store url in every action options, or make it at before_forward hook.&lt;/p&gt; &#xA;&lt;h4&gt;Actions options&lt;/h4&gt; &#xA;&lt;h5&gt;stash_params&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;stash_params =&amp;gt; [qw/ stash_key1 stash_key2 /]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use this if you want to send specified parameters from Mojolicious $c-&amp;gt;stash to RPC. RPC will receive this as part of call params.&lt;/p&gt; &#xA;&lt;p&gt;You can store RPC response data to Mojolicious stash returning data like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rpc_response =&amp;gt; {&#xA;    stash =&amp;gt; {..} # data to store in Mojolicious stash&#xA;    response_key1 =&amp;gt; response_value1, # response to API client&#xA;    response_key2 =&amp;gt; response_value2&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;success&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;success =&amp;gt; sub { my ($c, $rpc_response) = @_; ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hook which will run if RPC returns success value.&lt;/p&gt; &#xA;&lt;h5&gt;error&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;error =&amp;gt; sub { my ($c, $rpc_response) = @_; ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hook which will run if RPC returns value with error key, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{ result =&amp;gt; { error =&amp;gt; { code =&amp;gt; &#39;some_error&#39; } } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;response&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;response =&amp;gt; sub { my ($c, $rpc_response) = @_; ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hook which will run every time when success or error callbacks is running. It good place to modify API response format.&lt;/p&gt; &#xA;&lt;h4&gt;Instead of forward&lt;/h4&gt; &#xA;&lt;p&gt;This hook is generally used if you don&#39;t want to forward request to RPC and want to handle it within websocket itself, for example like send back server time.&lt;/p&gt; &#xA;&lt;p&gt;Another case where its useful is if you don&#39;t want to send response to rpc url provided in global scope and want to forward to separate RPC service (useful if you have multiple RPC service to handle different type of request)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; instead_of_forward =&amp;gt; sub {&#xA;     shift-&amp;gt;call_rpc({&#xA;         url  =&amp;gt; &#39;some other rpc url&#39;,&#xA;         args =&amp;gt; $args,&#xA;         method =&amp;gt; $rpc_method, # it&#39;ll call &#39;http://rpc-host.com:8080/rpc_method&#39;&#xA;         rpc_response_cb =&amp;gt; sub {...}&#xA;     });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SEE ALSO&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Mojolicious::Plugin::WebSocketProxy&#34;&gt;Mojolicious::Plugin::WebSocketProxy&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Mojo::WebSocketProxy&#34;&gt;Mojo::WebSocketProxy&lt;/a&gt; &lt;a href=&#34;https://metacpan.org/pod/Mojo::WebSocketProxy::CallingEngine&#34;&gt;Mojo::WebSocketProxy::CallingEngine&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Mojo::WebSocketProxy::Dispatcher&#34;&gt;Mojo::WebSocketProxy::Dispatcher&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Mojo::WebSocketProxy::Config&#34;&gt;Mojo::WebSocketProxy::Config&lt;/a&gt; &lt;a href=&#34;https://metacpan.org/pod/Mojo::WebSocketProxy::Parser&#34;&gt;Mojo::WebSocketProxy::Parser&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;COPYRIGHT AND LICENSE&lt;/h4&gt; &#xA;&lt;p&gt;Copyright (C) 2016 binary.com&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>starkandwayne/demo-cf-deployments</title>
    <updated>2022-07-19T01:52:35Z</updated>
    <id>tag:github.com,2022-07-19:/starkandwayne/demo-cf-deployments</id>
    <link href="https://github.com/starkandwayne/demo-cf-deployments" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Demo CF Deployments Rpo&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;cf deployments&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the YAML templates that make up a series of cf BOSH deployments, using the format prescribed by the &lt;a href=&#34;https://github.com/starkandwayne/genesis&#34;&gt;Genesis&lt;/a&gt; utility. These deployments are based off of the &lt;a href=&#34;https://github.com/genesis-community/cf-genesis-kit&#34;&gt;cf-genesis-kit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Environment Naming&lt;/h2&gt; &#xA;&lt;p&gt;Each environment managed by this repository will have its own deployment file, e.g. &lt;code&gt;us-east-prod.yml&lt;/code&gt;. However, in many cases, it can be desirable to share param configurations, or kit configurations across all of the environments, or specific subsets. Genesis supports this by splitting environment names based on hypthens (&lt;code&gt;-&lt;/code&gt;), and finding files with common prefixes to include in the final manifest.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s look at a scenario where there are three environments deployed by genesis: &lt;code&gt;us-west-prod.yml&lt;/code&gt;, &lt;code&gt;us-east-prod.yml&lt;/code&gt;, and &lt;code&gt;us-east-dev.yml&lt;/code&gt;. If there were configurations that should be shared by all environments, they should go in &lt;code&gt;us.yml&lt;/code&gt;. Configurations shared by &lt;code&gt;us-east-dev&lt;/code&gt; and &lt;code&gt;us-east-prod&lt;/code&gt; would go in &lt;code&gt;us-east.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To see what files are currently in play for an environment, you can run &lt;code&gt;genesis &amp;lt;environment-name&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;To create a new environment (called &lt;code&gt;us-east-prod-cf&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis new us-east-prod&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build the full BOSH manifest for an environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis manifest us-east-prod&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... and then deploy it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis deploy us-east-prod&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To rotate credentials for an environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis rotate-secrets us-east-prod&#xA;genesis deploy us-east-prod&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To change the secrets provider for the environments in this repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis secrets-provider --url https://example.com:8200 --insecure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... or clear it to use safe&#39;s currently targeted vault:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis secrets-provider --clear&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the provider for kits is &lt;a href=&#34;https://github.com/genesis-community&#34;&gt;https://github.com/genesis-community&lt;/a&gt;, but you can set this to another provider url via the &lt;code&gt;genesis kit-provider&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis kit-provider https://github.mycorp.com/mygenesiskits&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This requires that url to provide releases in the same manner as github does. You can see the current kit provider by calling it with no argument, or revert back to default with the &lt;code&gt;--clear&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;To update the Concourse Pipeline for this repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis repipe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To check for updates for this kit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis list-kits -u&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To download a new version of the kit, and deploy it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;genesis download cf [version] # omitting version downloads the latest&#xA;&#xA;# update the environment yaml to use the desired kit version,&#xA;# this might be in a different file if using CI to propagate&#xA;# deployment upgrades (perhaps us.yml)&#xA;vi us-east-prod.yml&#xA;&#xA;genesis deploy us-east-prod.yml     # or commit + git push to have&#xA;                                    # CI run through the upgrades&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/starkandwayne/genesis/raw/master/docs/PIPELINES.md&#34;&gt;Deployment Pipeline Documentation&lt;/a&gt; for more information on getting set up with Concourse deployment pipelines.&lt;/p&gt; &#xA;&lt;h2&gt;Helpful Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/genesis-community/cf-genesis-kit&#34;&gt;cf-genesis-kit&lt;/a&gt; - Details on the kit used in this repo, its features, prerequesites, and params.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/starkandwayne/genesis/raw/master/docs/PIPELINES.md&#34;&gt;Deployment Pipeline Documentation&lt;/a&gt; - Docs on all the configuration options for &lt;code&gt;ci.yml&lt;/code&gt;, and how the automated deployment pipelines behave.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Repo Structure&lt;/h2&gt; &#xA;&lt;p&gt;Most of the meat of the deployment repo happens at the base level. Envirionment YAML files, shared YAML files, and the CI configuration YAML file will all be here.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;.genesis/manifests&lt;/code&gt; directory saves redacted copies of the deployment manifests as they are deployed, for posterity, and to keep track of any &lt;code&gt;my-env-name-state.yml&lt;/code&gt; files from &lt;code&gt;bosh create-env&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;.genesis/cached&lt;/code&gt; directory is used by CI to propagate changes for shared YAML files along the pipelines. To aid in CI deploys, the &lt;code&gt;genesis/bin&lt;/code&gt; directory contains an embedded copy of genesis.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.genesis/kits&lt;/code&gt; contains copies of the kits that have been used in this deployment. Once a kit is no longer used in any environment, it can be safely removed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.genesis/config&lt;/code&gt; is used internally by &lt;code&gt;genesis&lt;/code&gt; to understand what is being deployed, and how.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>binary-com/perl-Performance-Probability</title>
    <updated>2022-07-19T01:52:35Z</updated>
    <id>tag:github.com,2022-07-19:/binary-com/perl-Performance-Probability</id>
    <link href="https://github.com/binary-com/perl-Performance-Probability" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;perl-Performance-Probability&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/binary-com/perl-Performance-Probability&#34;&gt;&lt;img src=&#34;https://travis-ci.org/binary-com/perl-Performance-Probability.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/binary-com/perl-Performance-Probability&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/binary-com/perl-Performance-Probability/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The performance probability is a likelihood measure of a client reaching his/her current P&amp;amp;L.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;To install this module, run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    perl Makefile.PL&#xA;    make&#xA;    make test&#xA;    make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Dependencies&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/binary-com/perl-Math-Gauss-XS&#34;&gt;https://github.com/binary-com/perl-Math-Gauss-XS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/binary-com/perl-Math-BivariateCDF&#34;&gt;https://github.com/binary-com/perl-Math-BivariateCDF&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contact&lt;/h1&gt; &#xA;&lt;p&gt;Email: &lt;a href=&#34;mailto:support@binary.com&#34;&gt;support@binary.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>