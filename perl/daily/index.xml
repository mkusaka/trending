<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-10T01:39:04Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>shutter-project/shutter</title>
    <updated>2024-01-10T01:39:04Z</updated>
    <id>tag:github.com,2024-01-10:/shutter-project/shutter</id>
    <link href="https://github.com/shutter-project/shutter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Screenshot tool for Linux&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Shutter Copyright (C) 2008-2013 Mario Kemper &lt;a href=&#34;mailto:mario.kemper@gmail.com&#34;&gt;mario.kemper@gmail.com&lt;/a&gt; Copyright (C) 2020-2021 Google LLC, contributed by Alexey Sokolov &lt;a href=&#34;mailto:sokolov@google.com&#34;&gt;sokolov@google.com&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://shutter-project.org/&#34;&gt;https://shutter-project.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://shutter-project.org/downloads/&#34;&gt;https://shutter-project.org/downloads/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;Via E-Mail : &lt;a href=&#34;https://shutter-project.org/contact/&#34;&gt;https://shutter-project.org/contact/&lt;/a&gt; Via GitHub : &lt;a href=&#34;https://github.com/shutter-project/shutter/issues/new/choose&#34;&gt;https://github.com/shutter-project/shutter/issues/new/choose&lt;/a&gt; Via IRC : ircs://irc.libera.chat:6697/#shutter&lt;/p&gt; &#xA;&lt;h2&gt;Found a bug?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/shutter-project/shutter/issues/new?labels=bug&amp;amp;template=bug_report.md&#34;&gt;https://github.com/shutter-project/shutter/issues/new?labels=bug&amp;amp;template=bug_report.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Shutter Licence&lt;/h2&gt; &#xA;&lt;p&gt;Licence: GPL 3 or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;Shutter is free software; you can redistribute it and/or modify it under the terms of the GNU General Public Licence as published by the Free Software Foundation; either version 3 of the Licence, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;Shutter is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Cursors License&lt;/h2&gt; &#xA;&lt;p&gt;Licence: GPL2 or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;Some cursors (share/shutter/resources/icons/drawing_tool/cursor) are based on/taken from the inkscape project &lt;a href=&#34;http://inkscape.sourceforge.net/&#34;&gt;http://inkscape.sourceforge.net/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Gnome Icons&lt;/h2&gt; &#xA;&lt;p&gt;Licence: GPL2 or (at your option) any later version.&lt;/p&gt; &#xA;&lt;h2&gt;Tango Icons&lt;/h2&gt; &#xA;&lt;p&gt;In the preparation of the 0.8.90 release Novell took care of tracking down all the contributors to get them to relicense their artwork into Public Domain.&lt;/p&gt; &#xA;&lt;p&gt;The COPYING file of the tarball states the following: | The icons in this repository are herefore released into the Public Domain.&lt;/p&gt; &#xA;&lt;p&gt;Additionally the copyright status of the files was tracked in the CVS and the rdf properties of the SVGs adjusted for all files that were put into Public Domain (see rdf:about and rdf:resource). Both fields contain a link to the Creative Commons Public Domain Dediciation[0] as reproduced below: | Public Domain Dedication | | Copyright-Only Dedication (based on United States law) or Public Domain | Certification | | The person or persons who have associated work with this document (the | &#34;Dedicator&#34; or &#34;Certifier&#34;) hereby either (a) certifies that, to the best | of his knowledge, the work of authorship identified is in the public | domain of the country from which the work is published, or (b) | hereby dedicates whatever copyright the dedicators holds in the work | of authorship identified below (the &#34;Work&#34;) to the public domain. A | certifier, moreover, dedicates any copyright interest he may have in | the associated work, and for these purposes, is described as a | &#34;dedicator&#34; below. | | A certifier has taken reasonable steps to verify the copyright | status of this work. Certifier recognizes that his good faith efforts | may not shield him from liability if in fact the work certified is not | in the public domain. | | Dedicator makes this dedication for the benefit of the public at | large and to the detriment of the Dedicator&#39;s heirs and successors. | Dedicator intends this dedication to be an overt act of relinquishment | in perpetuity of all present and future rights under copyright law, | whether vested or contingent, in the Work. Dedicator understands that | such relinquishment of all rights includes the relinquishment of all | rights to enforce (by lawsuit or otherwise) those copyrights in the | Work. | | Dedicator recognizes that, once placed in the public domain, the Work | may be freely reproduced, distributed, transmitted, used, modified, | built upon, or otherwise exploited by anyone for any purpose, commercial | or non-commercial, and in any way, including by methods that have not | yet been invented or conceived. [0] &lt;a href=&#34;http://creativecommons.org/licenses/publicdomain/&#34;&gt;http://creativecommons.org/licenses/publicdomain/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ft/zsh-am</title>
    <updated>2024-01-10T01:39:04Z</updated>
    <id>tag:github.com,2024-01-10:/ft/zsh-am</id>
    <link href="https://github.com/ft/zsh-am" rel="alternate"></link>
    <summary type="html">&lt;p&gt;One-command commit import from zsh-mailinglists&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The Challenge&lt;/p&gt; &lt;p&gt;The goal at which we&#39;d like to end up, is a way to import commits send to zsh&#39;s mailing lists with as little manual labour as possible. The workflow for this kind of endavour - using git&#39;s pre-packaged means - would usually involve the use of &#34;git am&#34;. In your Mail-User-Agent (MUA) you would mark and save the mail message that contain commits you want to import to an `mbox&#39; folder - say &#34;feature-x.mbox&#34; - and run &#34;git am&#34; on that like so:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git am feature-x.mbox #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;With zsh&#39;s development style, that presents two issues:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- Zsh uses a traditional ChangeLog file to linearly track changes.&#xA;- Zsh also uses numbers from ezmlm&#39;s (the mailing list software) X-Seq:&#xA;  header to make it easy to dig up mailing list discussions that belong to&#xA;  the individual change listed in ChangeLog file.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So in the end, the goal is to ideally have &lt;em&gt;one&lt;/em&gt; command that does this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- Look at the saved mbox file, prefix all Subject: headers with the&#xA;  corresponding X-Seq: number (extra sugar: detect if a commit mail was&#xA;  sent to zsh-users instead of zsh-workers and prefix the X-Seq: number&#xA;  with a &#34;users/&#34; string).&#xA;- Commit all messages from the mbox file via &#34;git am&#34; and amend the commits&#xA;  with automatic updates to the ChangeLog file. This should reflect the&#xA;  X-Seq: number, files that were touched by the commit, as well as the&#xA;  title of the commit message (the first line of the commit, that is&#xA;  usually put into the Subject: header of commit mails).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The Workflow&lt;/p&gt; &lt;p&gt;With zsh, all codebase changes (except for trivial ones) go through one of its mailing lists (usually &lt;a href=&#34;mailto:zsh-workers@zsh.org&#34;&gt;zsh-workers@zsh.org&lt;/a&gt;, but sometimes zsh-users, as well). What is more is this: The use of numbers from the X-Seq: header, require developers to amend every commit message. That means that you are doing integration work all the time even with your own changes.&lt;/p&gt; &lt;p&gt;This is a workflow that works pretty well for myself and I think it is simple enough for others to adopt as well. This discusses not only the import of commits from the mailing-lists, but also how to get mails to the mailing-list that are properly formatted to be consumed by the usual git-tools, such as &#34;git am&#34;. That is why this introduction is a little lengthy.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Working on separate branches&lt;/p&gt; &#xA;&lt;p&gt;The branch in which zsh&#39;s development is going forward is &#34;master&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Branches in git are not scary at all. They are cheap to create, have lying around and easy to work with. I know that many people think &#34;Why on earth would I be adding a new branch for this!?&#34;: But let&#39;s assume for the moment, that doing this will help in the end.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s assume, we&#39;ve got the master branch checked out and we&#39;d like to work on &#34;feature-x&#34;. I usually prefix my branches with my initials, so I&#39;d do this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git checkout -b ft/feature-x #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Now I&#39;d work, commit, work, commit, rework... whatever I need to do and git allows me to do. In the end, there will be one or more commits, that implement &#34;feature-x&#34;.&lt;/p&gt; &#xA;&lt;p&gt;** Using git&#39;s mail-related tools&lt;/p&gt; &#xA;&lt;p&gt;Git has a number of tools, that help mailing-list based development. In particular that would be &#34;git format-patch&#34; and &#34;git send-email&#34;. The former generates files, that are properly formatted for consumption by the latter as well as git&#39;s other mail-related tools.&lt;/p&gt; &#xA;&lt;p&gt;*** Commit messages&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Just as a reminder, commit messages with git - by convention - look like&#xA;this:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE The first line should be short and to the point about the change in the commit&lt;/p&gt; &#xA;&lt;p&gt;The second line is to be left &lt;em&gt;EMPTY&lt;/em&gt;!&lt;/p&gt; &#xA;&lt;p&gt;The rest may go into as much detail about the changes as the author sees fit. Information that could be included is: What changed? Why change it in the first place? Why change it in this way and not in another fashion? Maybe parts of mailing list discussions, if they are relevant. #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;*** &#34;git format-patch&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This helper program generates mail messages from a set of commits.&#xA;&#xA;Say we know, we have exactly three commits on our development branch. In&#xA;that case we might call the program like this:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git format-patch -3 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;-3&#34; tells it to create mails for the last three commits.&#xA;&#xA;If you do not quite know how many commits you got, you can also tell&#xA;format-patch to start at the point where you branched off (that would usually&#xA;be the &#34;master&#34; branch) and tell it to stop whereever you are right now:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git format-patch master.. #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;That is all. The result will be a number of &#34;*.patch&#34; files, that you can&#xA;send off to whereever they need to be send to.&#xA;&#xA;If you are preparing larger patch-series, you might want to add a&#xA;cover-mail, too. But that is beyond the scope of this document.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** &#34;git send-email&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This section could be very very short. Because you can just feed the files&#xA;from &#34;format-patch&#34; to &#34;send-email&#34; and be done with it. But there is another&#xA;worthwhile feature we might as well look at.&#xA;&#xA;Mails generated by &#34;format-patch&#34; always contain a line with three dashes,&#xA;followed by a few lines of diff-stat information before the actual diff is&#xA;inserted. This is somewhere in the mail&#39;s body and looks something like&#xA;this:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;#+BEGIN_EXAMPLE&lt;/h2&gt; &#xA;&lt;p&gt;Src/Zle/zle_main.c | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Now, since those &#34;*.patch&#34; files are just plain-text email messages, you&#xA;might be tempted to edit them using your favourite editor. And you can.&#xA;&#xA;The feature I&#39;d like to highlight is, that any text you enter between the&#xA;three-dashes-line and the diffstat will be discarded by &#34;git am&#34; (the tool&#xA;that will ultimately import the commit for us later on). So you can use&#xA;that space to add comments about the commit, that might be of interest for&#xA;other people at the time, but does not deserve to be part of the actual&#xA;commit message.&#xA;&#xA;The actual call to send off the generated mails, looks like this (I told&#xA;you it would have been a short section without that other feature):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git send-email --to=&#39;&lt;a href=&#34;mailto:zsh-workers@zsh.org&#34;&gt;zsh-workers@zsh.org&lt;/a&gt;&#39; --suppress-cc=all *.patch #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;You can configure &#34;send-email&#34; so you have to supply less options, but the&#xA;command line is still pretty short and zsh&#39;s git completion will help you&#xA;construct it with ease.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Receiving the messages&lt;/p&gt; &#xA;&lt;p&gt;Once you can see the messages in your MUA, you can probably mark them in some way and save them to a local folder (preferably &#34;mbox&#34; format, that is what I tested this solution with; although the module I used supports a wide variety of formats).&lt;/p&gt; &#xA;&lt;p&gt;If your MUA cannot do this: My condolences. ;)&lt;/p&gt; &#xA;&lt;p&gt;** Importing the changes from the newly created mbox file&lt;/p&gt; &#xA;&lt;p&gt;This is actually the only section about the solution that is present with this little software package.&lt;/p&gt; &#xA;&lt;p&gt;First lets move to the &#34;master&#34; branch again (you could also do the import in another integration branch and merge that into &#34;master&#34; later, but lets not over-do things):&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git checkout master #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;There are two steps that need to be taken (let&#39;s again assume &#34;feature-x.mbox&#34; as our newly created mbox file). First, amend the Subject: lines of the mails to reflect the X-Seq: number:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % zsh-am-xseq2subject feature-x.mbox #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;This step needs to be taken exactly once.&lt;/p&gt; &#xA;&lt;p&gt;And finally, import the changes and amend ChangeLog along the way appropriately:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % zsh-am-and-changelog feature.mbox #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;And that is it. Unless you get merge conflicts, in which case you need to do some manual labour after all.&lt;/p&gt; &#xA;&lt;p&gt;Obviously, having to enter more than one command is unacceptable, so here&#39;s a short-hand:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % zsh-am feature-x.mbox #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;You can pass as many mbox files as you like to the short-hand command.&lt;/p&gt; &#xA;&lt;p&gt;** Cleaning up&lt;/p&gt; &#xA;&lt;p&gt;One obvious step is to remove the mbox file. That is boring.&lt;/p&gt; &#xA;&lt;p&gt;More interestingly, there&#39;s still our development branch lying around. You can keep it, if you want to. But you can also just remove it, because your changes are now part of &#34;master&#34;, albeit in amended form since the ChangeLog file was changed and the commit title got the X-Seq: number stuck to its front.&lt;/p&gt; &#xA;&lt;p&gt;So for the version control system, the changes are different. And that is finally, why it makes sense to code on separate branches for anything you send through the mailing lists: The changes are different, as far as git is concerned.&lt;/p&gt; &#xA;&lt;p&gt;To remove the development branch just do this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git branch -D ft/feature-x #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Reviewing Branches&lt;/p&gt; &lt;p&gt;The workflow presented earlier uses explicitly created additional branches, because the author believes it helps to separate different changes from each other as well as from on-going development. This section might show reasons why that could indeed be beneficial.&lt;/p&gt; &lt;p&gt;That being said, note that all of this is &lt;em&gt;entirely&lt;/em&gt; &lt;em&gt;optional&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;If you are new to git, you might be surprised to hear that you already &lt;em&gt;have&lt;/em&gt; your own branch already anyway: The &lt;del&gt;master&lt;/del&gt; branch.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** A bird-eye view on a git repository&lt;/p&gt; &#xA;&lt;p&gt;With centralised systems, the initial situation is simpler, simply because the way the network is allowed to look like is a lot more limited. With centralised systems you have got &lt;em&gt;exactly&lt;/em&gt; &lt;em&gt;one&lt;/em&gt; remote system: The central repository.&lt;/p&gt; &#xA;&lt;p&gt;*** Remote systems&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;With distributed systems like git, there could potentially be any number of&#xA;remote systems (in git-lingo, such a system is called a &#34;remote&#34;). And that&#xA;includes none at all. It could also mean 20 or 30 remotes. It does not&#xA;really matter.&#xA;&#xA;When you clone a git repository, git automatically adds one remote for you.&#xA;It calls this default remote ~origin~, because it points to where you got&#xA;the code from in the first place. If you&#39;d like to see a list of remotes,&#xA;that are registered with your repository you can call &#34;git remote show&#34;:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git remote show origin #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;You can add other remotes if you want to. For example, I have a mirror of&#xA;zsh&#39;s git repository set up on github, which I added like this:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git remote add github &lt;a href=&#34;mailto:git@github.com&#34;&gt;git@github.com&lt;/a&gt;:ft/zsh.git #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;In a centralised-like workflow (which is used by most projects I am aware&#xA;of) there is no need for that though. The point is that you could. And in&#xA;more decoupled scenarios it does make sense.&#xA;&#xA;Note, that you can also remove any remote, including ~origin~. There is&#xA;nothing special about it. If you remove it, you cannot get changes from the&#xA;remote repository anymore though. So do not do that. ;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Remote branches&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Since there can be any number of remote systems, git has to have a way to&#xA;keep track of their changes: It keeps exact copies of the remote branches&#xA;in the local repository. You might know that calling &#34;git branch&#34; lists all&#xA;(local) branches in your repository. Its &#34;-a&#34; option will list *all*&#xA;branches, including global ones:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git branch -a&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;master remotes/github/master remotes/origin/#CVSPS.NO.BRANCH remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/dot-zsh-3.1.5-pws-14 remotes/origin/dot-zsh-3.1.5-pws-17 remotes/origin/dot-zsh-3.1.5-pws-19 remotes/origin/master remotes/origin/zsh remotes/origin/zsh-3.1.5-pws-16-patches remotes/origin/zsh-4.0-patches remotes/origin/zsh-4.2-patches #+END_EXAMPLE&lt;/p&gt; &lt;p&gt;That is actually a lot and it might confuse you. So, to make it clear: Most of these were created during the CVS history import. The one that is interesting (since it is the representation of the remote&#39;s &lt;del&gt;master&lt;/del&gt; branch) is &lt;del&gt;remotes/origin/master&lt;/del&gt;. There is also &lt;del&gt;remotes/origin/HEAD&lt;/del&gt; which points to &lt;del&gt;origin/master&lt;/del&gt;: This means that the default branch of the remote repository is &lt;del&gt;master&lt;/del&gt;.&lt;/p&gt; &lt;p&gt;Your local &lt;del&gt;master&lt;/del&gt; is branched off of the remote branch &lt;del&gt;origin/master&lt;/del&gt;. It is as if you had done this manually:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % git checkout -b master origin/master #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;You did not have to do that, because git did it for you when you cloned the&#xA;repository. What you have to realise is this: Your local ~master~ branch is&#xA;*yours*! The remote changes are kept in ~origin/master~.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Connecting local and remote branches&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;How to get changes from a remote branch to a local one then? Or the other&#xA;way round? &#34;Pull! Push!&#34; might be your reaction. Kind of. Let&#39;s take a&#xA;closer look.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Getting remote changes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; The command used to get changes from a remote is actually &#34;git fetch&#34;. It&#xA; gets changes from a remote and updates the branches in its ~remote/*/*~&#xA; namespace accordingly. It does *not* touch your local branches!&#xA;&#xA; &#34;git pull&#34; performs a &#34;git fetch&#34;, but is also does something else: It&#xA; merges, too. You can configure what is merged to where. Per default, stuff&#xA; from ~origin/master~ gets merged to ~master~.&#xA;&#xA; If you do not have new changes in your ~master~ branch, the merge is&#xA; trivial since history remains linear. If you do, the merge will&#xA; commence and also create a merge commit in the end: Your history is not&#xA; linear anymore.&#xA;&#xA; If you want linear history, you can use &#34;git pull --rebase&#34;. &#34;rebase&#34;&#xA; means: Reset ~master~ to ~origin/master~, to the trivial linear merge and&#xA; finally replay all local changes on top of that new master branch.&#xA;&#xA; The thing with merging and rebasing is this: If you made changes to&#xA; ChangeLog, you&#39;ll get a guaranteed merge conflict. That is because of the&#xA; nature of ChangeLog files. Changes are always made at the top, and thus&#xA; will always trigger a conflict if something else changed this top as well&#xA; (as changes in the remote repository would).&#xA;&#xA; This is why I prefer to code on separate branches and only use my local&#xA; ~master~ branch for integration: If something goes wrong, I can always&#xA; just reset my ~master~ branch, pull changes from the remote and re-apply&#xA; the changes from my saved mailbox using \`zsh-am&#39;.&#xA;&#xA; If there are merge conflicts (they will not be in ChangeLog, because&#xA; \`zsh-am&#39; will always produce new entries on top of the current state), I&#xA; can always rebase my coding branch on top of ~master~ and resolve any&#xA; merge conflicts there. Then I resend a new patch series and \`zsh-am&#39; that&#xA; on top of master as soon as the mails return to me.&#xA;&#xA; I believe that workflow to be more robust with the special needs of zsh&#39;s&#xA; development style with X-Seq: numbers and especially ChangeLog entries.&#xA;&#xA; You can do all of this with just your local ~master~ branch. But I think&#xA; it is substantially harder to get everything right in case of conflicts&#xA; doing that.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Getting local changes into a remote&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; The answer is indeed &#34;git push&#34;. There is one caveat though: If the&#xA; remote has new changes, it will not let you push. You would have to fetch,&#xA; and merge or rebase (either explicitly or using &#34;git pull&#34; with or without&#xA; &#34;--rebase&#34;) first and resolve any conflicts locally. This then involves&#xA; all subtleties that were mentioned in the previous section.&#xA;&#xA; After that, you can push to the remote indeed.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Features&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;One command to do all the work at once.&lt;/li&gt; &#xA;   &lt;li&gt;Support for X-Seq: numbers.&lt;/li&gt; &#xA;   &lt;li&gt;Support for mails to zsh-users (they get a &#34;users/&#34; prefix)&lt;/li&gt; &#xA;   &lt;li&gt;Support for amending commits with ChangeLog entries&lt;/li&gt; &#xA;   &lt;li&gt;Support reading mbox files from stdin&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Requirements&lt;/p&gt; &lt;p&gt;The `zsh-am&#39; script requires a POSIX shell as /bin/sh. It also requires an implementation of `mktemp(1)&#39; to be available for the &#34;read mbox file from stdin&#34; feature to work.&lt;/p&gt; &lt;p&gt;The other scripts are written in Perl. Standard modules such as POSIX are assumed to work. The mailbox handling is done by an extension module called Mail::Box which is available from CPAN and is packaged for popular linux distributions as well. For example on debian, the right package to install would be `libmail-box-perl&#39;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Installation&lt;/p&gt; &lt;p&gt;The package consists of four scripts:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;genchangelog: Generates the changelog entries.&lt;/li&gt; &#xA;   &lt;li&gt;zsh-am-xseq2subject: Amends Subject lines with &#34;&#xA;    &lt;number&gt;&#xA;     :&#34; and &#34;users/&#xA;     &lt;number&gt;&#xA;      :&#34; prefixes based on the X-Seq: headers.&#xA;     &lt;/number&gt;&#xA;    &lt;/number&gt;&lt;/li&gt; &#xA;   &lt;li&gt;zsh-am-and-changelog: Calls git-am and amends the ChangeLog along the way.&lt;/li&gt; &#xA;   &lt;li&gt;zsh-am: Calls zsh-am-xseq2subject and zsh-am-and-changelog in succession for any number of mbox files.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The installation works like this:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt; &#xA;&lt;h1&gt;make install&lt;/h1&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;The default installation prefix is &#34;/usr/local&#34;, so the scripts will end up in &#34;/usr/local/bin&#34;. If you&#39;d prefer them to live in &#34;~/bin&#34;, do this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % make install PREFIX=&#34;$HOME&#34; #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Similarly, the package may be uninstalled using:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE&lt;/p&gt; &#xA;&lt;h1&gt;make uninstall&lt;/h1&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;After installing, you have to move to your zsh git clone and call zsh-am with its &#34;-init&#34; option:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % cd ~/src/zsh % zsh-am -init #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;One full example, finally.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE % cd ~/src/zsh % git checkout master % git checkout -b ft/zle-init-hooks&lt;/p&gt; &#xA;&lt;p&gt;[..hack..hack..hack..]&lt;/p&gt; &#xA;&lt;p&gt;% git format-patch master.. % git send-email --to=&#39;&lt;a href=&#34;mailto:zsh-workers@zsh.org&#34;&gt;zsh-workers@zsh.org&lt;/a&gt;&#39; --suppress-cc=all *.patch&lt;/p&gt; &#xA;&lt;p&gt;[..In MUA, mark mails and save them to &#34;~/zle-init-hooks.mbox&#34;..]&lt;/p&gt; &#xA;&lt;p&gt;% git checkout master % zsh-am ~/zle-init-hooks.mbox % gitk --all ;: check if everything in master looks right % git push % rm ~/zle-init-hooks.mbox % git branch -D ft/zle-init-hooks #+END_EXAMPLE&lt;/p&gt;</summary>
  </entry>
</feed>