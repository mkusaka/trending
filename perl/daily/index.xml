<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-15T01:35:39Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>melan/AnyEvent-DBI</title>
    <updated>2023-10-15T01:35:39Z</updated>
    <id>tag:github.com,2023-10-15:/melan/AnyEvent-DBI</id>
    <link href="https://github.com/melan/AnyEvent-DBI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Release history of AnyEvent-DBI&lt;/p&gt;&lt;hr&gt;&lt;p&gt;NAME AnyEvent::DBI - asynchronous DBI access&lt;/p&gt; &#xA;&lt;p&gt;SYNOPSIS use AnyEvent::DBI;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   my $cv = AnyEvent-&amp;gt;condvar;&#xA;&#xA;   my $dbh = new AnyEvent::DBI &#34;DBI:SQLite:dbname=test.db&#34;, &#34;&#34;, &#34;&#34;;&#xA;&#xA;   $dbh-&amp;gt;exec (&#34;select * from test where num=?&#34;, 10, sub {&#xA;      my ($dbh, $rows, $rv) = @_;&#xA;&#xA;      $#_ or die &#34;failure: $@&#34;;&#xA;&#xA;      print &#34;@$_\n&#34;&#xA;         for @$rows;&#xA;&#xA;      $cv-&amp;gt;broadcast;&#xA;   });&#xA;&#xA;   # asynchronously do sth. else here&#xA;&#xA;   $cv-&amp;gt;wait;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DESCRIPTION This module is an AnyEvent user, you need to make sure that you use and run a supported event loop.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This module implements asynchronous DBI access by forking or executing&#xA;separate &#34;DBI-Server&#34; processes and sending them requests.&#xA;&#xA;It means that you can run DBI requests in parallel to other tasks.&#xA;&#xA;The overhead for very simple statements (&#34;select 0&#34;) is somewhere around&#xA;100% to 120% (dual/single core CPU) compared to an explicit&#xA;prepare_cached/execute/fetchrow_arrayref/finish combination.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ERROR HANDLING This module defines a number of functions that accept a callback argument. All callbacks used by this module get their AnyEvent::DBI handle object passed as first argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;If the request was successful, then there will be more arguments,&#xA;otherwise there will only be the $dbh argument and $@ contains an error&#xA;message.&#xA;&#xA;A convinient way to check whether an error occured is to check $#_ - if&#xA;that is true, then the function was successful, otherwise there was an&#xA;error.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;METHODS $dbh = new AnyEvent::DBI $database, $user, $pass, [key =&amp;gt; value]... Returns a database handle for the given database. Each database handle has an associated server process that executes statements in order. If you want to run more than one statement in parallel, you need to create additional database handles.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    The advantage of this approach is that transactions work as state is&#xA;    preserved.&#xA;&#xA;    Example:&#xA;&#xA;       $dbh = new AnyEvent::DBI&#xA;                 &#34;DBI:mysql:test;mysql_read_default_file=/root/.my.cnf&#34;, &#34;&#34;, &#34;&#34;;&#xA;&#xA;    Additional key-value pairs can be used to adjust behaviour:&#xA;&#xA;    on_error =&amp;gt; $callback-&amp;gt;($dbh, $filename, $line, $fatal)&#xA;        When an error occurs, then this callback will be invoked. On&#xA;        entry, $@ is set to the error message. $filename and $line is&#xA;        where the original request was submitted.&#xA;&#xA;        If the fatal argument is true then the database connection is&#xA;        shut down and your database handle became invalid. In addition&#xA;        to invoking the &#34;on_error&#34; callback, all of your queued request&#xA;        callbacks are called without only the $dbh argument.&#xA;&#xA;        If omitted, then &#34;die&#34; will be called on any errors, fatal or&#xA;        not.&#xA;&#xA;    on_connect =&amp;gt; $callback-&amp;gt;($dbh[, $success])&#xA;        If you supply an &#34;on_connect&#34; callback, then this callback will&#xA;        be invoked after the database connect attempt. If the connection&#xA;        succeeds, $success is true, otherwise it is missing and $@&#xA;        contains the $DBI::errstr.&#xA;&#xA;        Regardless of whether &#34;on_connect&#34; is supplied, connect errors&#xA;        will result in &#34;on_error&#34; being called. However, if no&#xA;        &#34;on_connect&#34; callback is supplied, then connection errors are&#xA;        considered fatal. The client will &#34;die&#34; and the &#34;on_error&#34;&#xA;        callback will be called with $fatal true.&#xA;&#xA;        When on_connect is supplied, connect error are not fatal and&#xA;        AnyEvent::DBI will not &#34;die&#34;. You still cannot, however, use the&#xA;        $dbh object you received from &#34;new&#34; to make requests.&#xA;&#xA;    exec_server =&amp;gt; 1&#xA;        If you supply an &#34;exec_server&#34; argument, then the DBI server&#xA;        process will fork and exec another perl interpreter (using $^X)&#xA;        with just the AnyEvent::DBI proxy running. This will provide the&#xA;        cleanest possible proxy for your database server.&#xA;&#xA;        If you do not supply the &#34;exec_server&#34; argument (or supply it&#xA;        with a false value) then the traditional method of starting the&#xA;        server by forking the current process is used. The forked&#xA;        interpreter will try to clean itself up by calling POSIX::close&#xA;        on all file descriptors except STDIN, STDOUT, and STDERR (and&#xA;        the socket it uses to communicate with the cilent, of course).&#xA;&#xA;    timeout =&amp;gt; seconds&#xA;        If you supply a timeout parameter (fractional values are&#xA;        supported), then a timer is started any time the DBI handle&#xA;        expects a response from the server. This includes connection&#xA;        setup as well as requests made to the backend. The timeout spans&#xA;        the duration from the moment the first data is written (or&#xA;        queued to be written) until all expected responses are returned,&#xA;        but is postponed for &#34;timeout&#34; seconds each time more data is&#xA;        returned from the server. If the timer ever goes off then a&#xA;        fatal error is generated. If you have an &#34;on_error&#34; handler&#xA;        installed, then it will be called, otherwise your program will&#xA;        die().&#xA;&#xA;        When altering your databases with timeouts it is wise to use&#xA;        transactions. If you quit due to timeout while performing&#xA;        insert, update or schema-altering commands you can end up not&#xA;        knowing if the action was submitted to the database,&#xA;        complicating recovery.&#xA;&#xA;        Timeout errors are always fatal.&#xA;&#xA;    Any additional key-value pairs will be rolled into a hash reference&#xA;    and passed as the final argument to the &#34;DBI-&amp;gt;connect (...)&#34; call.&#xA;    For example, to supress errors on STDERR and send them instead to an&#xA;    AnyEvent::Handle you could do:&#xA;&#xA;       $dbh = new AnyEvent::DBI&#xA;                  &#34;DBI:mysql:test;mysql_read_default_file=/root/.my.cnf&#34;, &#34;&#34;, &#34;&#34;,&#xA;                  PrintError =&amp;gt; 0,&#xA;                  on_error   =&amp;gt; sub {&#xA;                     $log_handle-&amp;gt;push_write (&#34;DBI Error: $@ at $_[1]:$_[2]\n&#34;);&#xA;                  };&#xA;&#xA;$dbh-&amp;gt;on_error ($cb-&amp;gt;($dbh, $filename, $line, $fatal))&#xA;    Sets (or clears, with &#34;undef&#34;) the &#34;on_error&#34; handler.&#xA;&#xA;$dbh-&amp;gt;timeout ($seconds)&#xA;    Sets (or clears, with &#34;undef&#34;) the database timeout. Useful to&#xA;    extend the timeout when you are about to make a really long query.&#xA;&#xA;$dbh-&amp;gt;exec (&#34;statement&#34;, @args, $cb-&amp;gt;($dbh, \@rows, $rv))&#xA;    Executes the given SQL statement with placeholders replaced by&#xA;    @args. The statement will be prepared and cached on the server side,&#xA;    so using placeholders is extremely important.&#xA;&#xA;    The callback will be called with a weakened AnyEvent::DBI object as&#xA;    the first argument and the result of &#34;fetchall_arrayref&#34; as (or&#xA;    &#34;undef&#34; if the statement wasn&#39;t a select statement) as the second&#xA;    argument.&#xA;&#xA;    Third argument is the return value from the &#34;DBI-&amp;gt;execute&#34; method&#xA;    call.&#xA;&#xA;    If an error occurs and the &#34;on_error&#34; callback returns, then only&#xA;    $dbh will be passed and $@ contains the error message.&#xA;&#xA;$dbh-&amp;gt;attr ($attr_name[, $attr_value], $cb-&amp;gt;($dbh, $new_value))&#xA;    An accessor for the handle attributes, such as &#34;AutoCommit&#34;,&#xA;    &#34;RaiseError&#34;, &#34;PrintError&#34; and so on. If you provide an $attr_value&#xA;    (which might be &#34;undef&#34;), then the given attribute will be set to&#xA;    that value.&#xA;&#xA;    The callback will be passed the database handle and the attribute&#39;s&#xA;    value if successful.&#xA;&#xA;    If an error occurs and the &#34;on_error&#34; callback returns, then only&#xA;    $dbh will be passed and $@ contains the error message.&#xA;&#xA;$dbh-&amp;gt;begin_work ($cb-&amp;gt;($dbh[, $rc]))&#xA;$dbh-&amp;gt;commit ($cb-&amp;gt;($dbh[, $rc]))&#xA;$dbh-&amp;gt;rollback ($cb-&amp;gt;($dbh[, $rc]))&#xA;    The begin_work, commit, and rollback methods expose the equivalent&#xA;    transaction control method of the DBI driver. On success, $rc is&#xA;    true.&#xA;&#xA;    If an error occurs and the &#34;on_error&#34; callback returns, then only&#xA;    $dbh will be passed and $@ contains the error message.&#xA;&#xA;$dbh-&amp;gt;func (&#39;string_which_yields_args_when_evaled&#39;, $func_name,&#xA;$cb-&amp;gt;($dbh, $rc, $dbi_err, $dbi_errstr))&#xA;    This gives access to database driver private methods. Because they&#xA;    are not standard you cannot always depend on the value of $rc or&#xA;    $dbi_err. Check the documentation for your specific driver/function&#xA;    combination to see what it returns.&#xA;&#xA;    Note that the first argument will be eval&#39;ed to produce the argument&#xA;    list to the func() method. This must be done because the&#xA;    serialization protocol between the AnyEvent::DBI server process and&#xA;    your program does not support the passage of closures.&#xA;&#xA;    Here&#39;s an example to extend the query language in SQLite so it&#xA;    supports an intstr() function:&#xA;&#xA;        $cv = AnyEvent-&amp;gt;condvar;&#xA;        $dbh-&amp;gt;func (&#xA;           q{&#xA;              instr =&amp;gt; 2, sub {&#xA;                 my ($string, $search) = @_;&#xA;                 return index $string, $search;&#xA;              },&#xA;           },&#xA;           create_function =&amp;gt; sub {&#xA;              return $cv-&amp;gt;send ($@)&#xA;                 unless $#_;&#xA;              $cv-&amp;gt;send (undef, @_[1,2,3]);&#xA;           }&#xA;        );&#xA;&#xA;        my ($err,$rc,$errcode,$errstr) = $cv-&amp;gt;recv;&#xA;&#xA;        die $err if defined $err;&#xA;        die &#34;EVAL failed: $errstr&#34;&#xA;           if $errcode;&#xA;&#xA;        # otherwise, we can ignore $rc and $errcode for this particular func&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SEE ALSO AnyEvent, DBI, Coro::Mysql.&lt;/p&gt; &#xA;&lt;p&gt;AUTHOR Marc Lehmann &lt;a href=&#34;mailto:schmorp@schmorp.de&#34;&gt;schmorp@schmorp.de&lt;/a&gt; &lt;a href=&#34;http://home.schmorp.de/&#34;&gt;http://home.schmorp.de/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   Adam Rosenstein &amp;lt;adam@redcondor.com&amp;gt;&#xA;   http://www.redcondor.com/&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>