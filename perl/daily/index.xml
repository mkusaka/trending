<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-18T01:35:57Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nilcons/ceh</title>
    <updated>2022-11-18T01:35:57Z</updated>
    <id>tag:github.com,2022-11-18:/nilcons/ceh</id>
    <link href="https://github.com/nilcons/ceh" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A guild for people who like Nix&lt;/p&gt;&lt;hr&gt;&lt;p&gt;[[https://travis-ci.org/nilcons/ceh][https://travis-ci.org/nilcons/ceh.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Power-user environment to share&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Agreements and a repository for a shared GNU/Linux power-user environment.&lt;/li&gt; &#xA; &lt;li&gt;So that it&#39;s easy to work on shared projects (e.g. the haskell header can be =#!/opt/ceh/bin/runhaskell -i /opt/ceh/p/ourproject=, instead of some complicated perl one-liner).&lt;/li&gt; &#xA; &lt;li&gt;So that the packages are available with the same version on our machines (e.g. =emacs=, =tmux=, =firefox=, etc).&lt;/li&gt; &#xA; &lt;li&gt;These agreements are intentionally based on simple unifications instead of abstractions (e.g. =/opt/ceh/home= has to be a symlink for the user&#39;s home directory, no need to =$HOME= or tilde lookups anymore).&lt;/li&gt; &#xA; &lt;li&gt;We use amd64 Nix for package management and if you can decide on the distribution that you use as a base system, we recommend amd64 Debian. But the point is that this should work on any modern amd64 GNU/Linux, we also tested Ubuntu trusty and precise.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Requirements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Modern GNU/Linux distro (ubuntu, debian, etc.).&lt;/li&gt; &#xA; &lt;li&gt;Intel architecture (amd64, no i386/i686 or arm).&lt;/li&gt; &#xA; &lt;li&gt;The machine only has one user who wants to use ceh and nix and she will be the owner of the files in =/opt/ceh= and =/nix=.&lt;/li&gt; &#xA; &lt;li&gt;If the machine is running NixOS already, then =/nix= should exist already of course and Ceh is able to handle that.&lt;/li&gt; &#xA; &lt;li&gt;Root privileges for the installation. Actually only needed for the creation of =/opt/ceh= and =/nix=, not needed for everyday usage or package installation.&lt;/li&gt; &#xA; &lt;li&gt;=/etc/passwd= contains your user, so nix doesn&#39;t have to use any fancy NSS modules.&lt;/li&gt; &#xA; &lt;li&gt;The user uses bash or zsh. This is because he has to source =/opt/ceh/scripts/ceh-profile.sh= which supports these two shells. Patches are welcome for other shells.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Installation instructions : sudo mkdir /opt/ceh /nix : sudo chown $USER. /opt/ceh /nix : chmod 0700 /opt/ceh /nix : cd /opt/ceh : git clone git://github.com/nilcons/ceh.git . : ln -s $HOME home : /opt/ceh/scripts/ceh-init.sh&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Installation instructions for NixOS : sudo mkdir /opt/ceh /nix/var/nix/gcroots/auto/ceh : sudo chown $USER. /opt/ceh /nix/var/nix/gcroots/auto/ceh : chmod 0700 /opt/ceh /nix/var/nix/gcroots/auto/ceh : cd /opt/ceh : git clone git://github.com/nilcons/ceh.git . : ln -s $HOME home : /opt/ceh/scripts/ceh-init.sh&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Everyday usage In the =/opt/ceh/bin= directory there are small wrapper scripts. Those install the required pacakages for the wrapped binaries on first run.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=/opt/ceh/bin= is put into =$PATH= by =/opt/ceh/scripts/ceh-profile.sh=, that you&#39;re supposed to source from your =~/.bashrc=.&lt;/p&gt; &#xA;&lt;p&gt;*** Exclusions: ignoring programs provided by ceh If for any reason you prefer to ignore one of our provided binaries, you can use the =ceh_exclude= script to create a symlink from =/opt/ceh/bin-user/= to the other version of the binary in your =PATH=.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want the exclusion anymore, just delete the symlink.&lt;/p&gt; &#xA;&lt;p&gt;*** Removing packages that got installed on-demand As previously mentioned, the scripts in =/opt/ceh/bin= just install the programs on demand as you run them. Therefore once ran, they take up disk space on your machine. If you tried out something big and would like to get rid of it, then go to =/opt/ceh/installed= and feel free to delete any symlinks there. After deleting the symlinks, run =nix-garbage-collect= to free up the disk space. If you decide to use some deleted software again, it will be redownloaded.&lt;/p&gt; &#xA;&lt;p&gt;If you delete from =/opt/ceh/installed/essential=, then you will have to run =ceh-init.sh=, but Ceh will show a warning message on stderr about that.&lt;/p&gt; &#xA;&lt;p&gt;*** Troubleshooting if something is broken after git pull Sometimes there are changes that are not backward compatible with the previous =ceh-init.sh=. In those cases we do our best to provide warning messages on stderr from scripts, and those messages will ask you to rerun =ceh-init.sh=. That operation is idempotent, feel free to run it you think it can fix up something for you.&lt;/p&gt; &#xA;&lt;p&gt;You can also read the &#34;Upgrade notes&#34; section to know about changes.&lt;/p&gt; &#xA;&lt;p&gt;*** Disable the binary cache, for fun and profit You may just want to see if it&#39;s still possible to build a software from source, instead of using the nix binary cache. Or the nix binary cache is down and you still want to install packages instead of having to wait until it&#39;s back.&lt;/p&gt; &#xA;&lt;p&gt;In both cases, you can just set =$CEH_NO_BIN_CACHE= to 1 and then the wrapper scripts will start building packages instead of using the binary cache.&lt;/p&gt; &#xA;&lt;p&gt;When you do this, you may also want to set =$CEH_BUILD_MAX_JOBS= to the number of your processor cores in the system, because usually building of tools (like compilers, linkers, make, etc.) can be parallelized by nix.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Upgrade notes *** 2018-05-23: Nix 2, no nix-mode.el, no firefox, no vanitygen, no 32-bit, no TWS This is the first Ceh release with Nix 2, if there are issues, please keep us posted!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Nix 2 removed the nix-mode.el emacs bindings, instead you have to use it from Melpa, as you do with all your other emacs modules.&lt;/p&gt; &#xA;&lt;p&gt;We removed Firefox, because it was a constant maintenance burden, and the reasoning from many years ago (easy to use and install java, flash, googletalk plugin) is not strong enough anymore. The Firefox versions shipped by standard desktop distibutions are good enough.&lt;/p&gt; &#xA;&lt;p&gt;Vanitygen is removed from nixpkgs, so we remove it from ceh. :(&lt;/p&gt; &#xA;&lt;p&gt;For the shiny new Nix2 2 gigs of ram is not enough to download ghc-8.2.2 from the binary cache. Therefore we can&#39;t use 32-bit nix anymore. So the base perl and nix package has been changed to 64-bit versions. The bit32 option has also been removed, ceh is now 64-bit only. Rest in peace ia32.&lt;/p&gt; &#xA;&lt;p&gt;TWS is also removed, because Interactive Brokers started to release usable linux desktop installation packages, which includes the correct version of java and just works.&lt;/p&gt; &#xA;&lt;p&gt;*** 2017-07-14: no Haskell anymore We think that for Haskell, stack is a clear winner in the ecosystem.&lt;/p&gt; &#xA;&lt;p&gt;Therefore we may add stack support to ceh in the future, but we have removed our nix based haskell support.&lt;/p&gt; &#xA;&lt;p&gt;*** 2016-04-14: support for multiple outputs As preparation for a baseline upgrade, we had to do a refactoring: in new nixpkgs versions, most of the derivations result in multiple output, not just one. Previously this happened only rarely, so we handled the special cases with the outFilter hack. This hack is gone, and instead we refactored the gclink symlinks a little bit to support multiple derivations.&lt;/p&gt; &#xA;&lt;p&gt;For the end user, the change shouldn&#39;t be notable and everything should continue working as expected.&lt;/p&gt; &#xA;&lt;p&gt;*** 2014-12-20: no more nixops NixOps was not working after the 32-bit -&amp;gt; 64-bit migration, I do not think this is anything to do with the architecture, something has changed in the git repo.&lt;/p&gt; &#xA;&lt;p&gt;Anyways, we know of no users who uses Ceh and nixops together, so it was easier to remove it. Tell us if you need it!&lt;/p&gt; &#xA;&lt;p&gt;*** 2014-12-20: 32-bit -&amp;gt; 64-bit migration I love i686, programs are so fluffy and cute. But unfortunately the world started to ignore that platform and stuff is supported only on amd64 nowadays. E.g. the haskell &#34;community&#34; ignores i686 altogether and unit tests routinely break. The nix binary cache is also only maintained for amd64 and if the glibc is missing for i686, nobody will fix it and you will have to build everything from source.&lt;/p&gt; &#xA;&lt;p&gt;So we decided to move ceh to 64-bit, and live with the memory and disk usage of amd64.&lt;/p&gt; &#xA;&lt;p&gt;This transition should be seamless from the user point of view, but if something goes bad, of course you can always just purge Ceh and reinstall it...&lt;/p&gt; &#xA;&lt;p&gt;Also, if you want to install 32-bit stuff from some packages, you have to use the bit32 flag, instead of the old bit64 flag that we had for 64-bit. For Haskell, you can use the envvar CEH_GHC32 to get a 32-bit GHC and tools.&lt;/p&gt; &#xA;&lt;p&gt;As a last resort, the base perl and nix package is still i686, so you can run =ceh-init.sh= even on a i686 system and write your own wrappers by using the bit32 flag for every package. But we are ready to remove this convenience the first time it causes some problems.&lt;/p&gt; &#xA;&lt;p&gt;Sorry guys, i686 is dead.&lt;/p&gt; &#xA;&lt;p&gt;*** 2014-05-08: refactoring From now on, we don&#39;t use profiles for Ceh&#39;s internal purposes. Instead we use the =/opt/ceh/installed= directory.&lt;/p&gt; &#xA;&lt;p&gt;Profiles essentially give you two features. First, it&#39;s a way to track different states of what is installed and an easy way to roll back and forward between those states. As we have git, we don&#39;t need this. The other feature is that profiles give you a huge symlink farm that mimics a directory tree where only the currently installed packages are seen. We don&#39;t need this feature either, because we have the wrappers in =/opt/ceh/bin= and we can just introduce a constant symlink farm for the manpages in =/opt/ceh/man=.&lt;/p&gt; &#xA;&lt;p&gt;This refactoring will also solve the constant issue around file collissions in profiles and package renames in upstream nixpkgs.&lt;/p&gt; &#xA;&lt;p&gt;You can safely delete =/nix/var/nix/profiles/ceh= and run a =nix-garbage-collect= to get rid of some old stuff that never would be deleted otherwise.&lt;/p&gt; &#xA;&lt;p&gt;*** 2014-03-04: refactoring The new place for the nixpkgs checkout of Ceh is =/opt/ceh/nixpkgs=, you can run =rm -rf /nix/var/ceh_nixpkgs= to remove the old cruft.&lt;/p&gt; &#xA;&lt;p&gt;Also, from now on it&#39;s not necessary (or allowed) to specify derivation hashes when calling =ceh_nixpkgs_install_*= functions. Derivation hashes are always figured out automatically when on-demand installations is needed and only the output hash is consulted for binary consistency.&lt;/p&gt; &#xA;&lt;p&gt;Another change is that we made ceh-init.sh idempotent and it should fix up stuff from any state that is reasonable after a git pull or after deletion of all the profiles in =/nix/var/nix/profiles/ceh=. This means that =ceh-upgrade.sh= is no more and you should always use =ceh-init.sh= if you think Ceh should be reinitialized.&lt;/p&gt; &#xA;&lt;p&gt;*** 2014-01-07: nix channels moved On existing installations, run the following: : nix-channel --remove nixpkgs : nix-channel --add &lt;a href=&#34;http://nixos.org/channels/nixpkgs-unstable&#34;&gt;http://nixos.org/channels/nixpkgs-unstable&lt;/a&gt; : nix-channel --update&lt;/p&gt; &#xA;&lt;p&gt;*** 2014-02-03: xpra upgrade broken Unfortunately the nixpkgs guys changed the name of the xpra packages from python2.7-xpra to xpra. As described in the Troubleshooting section, this is causes a filename collision. This can be fixed: : /opt/ceh/bin/nix-env -p /nix/var/nix/profiles/ceh/bin -e python2.7-xpra : /opt/ceh/bin/xpra&lt;/p&gt; &#xA;&lt;p&gt;*** 2013-08-05: ~/.nix-profile reserved for the user The =/nix/var/nix/profiles/per-user/root/profile= profile (which is symlinked by default from =$HOME/.nix-profile=) is not used for installations anymore. Earlier versions of ceh used to install packages there, but now that profile is reserved for the user.&lt;/p&gt; &#xA;&lt;p&gt;This is good, because if you need some package (e.g. =vim=) quickly from the nixpkgs version that is current the ceh baseline, you can just do: : ceh_nixpkgs_install vim : ~/.nix-profile/bin/vim&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can use the most up-to-date nixpkgs: : nix-channel --add &lt;a href=&#34;http://nixos.org/channels/nixpkgs-unstable&#34;&gt;http://nixos.org/channels/nixpkgs-unstable&lt;/a&gt; : nix-channel --update : nix-env -i vim : ~/.nix-profile/bin/vim&lt;/p&gt; &#xA;&lt;p&gt;No need to create a wrapper in =/opt/ceh= just for a quick test. If you want to get rid of your user profile, simply delete =/nix/var/nix/profiles/per-user/$USER/profile*=. This is from now on is totally separate from ceh&#39;s own nix profiles. Those are located in =/nix/var/nix/profiles/ceh/*=.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re upgrading =ceh= from a version, where the default profile was used for package installations, please delete =/nix/var/nix/profiles/per-user/root/profile*=.&lt;/p&gt; &#xA;&lt;p&gt;*** 2013-08-15: renames nix-init.sh -&amp;gt; ceh-init.sh nix-profile.sh -&amp;gt; ceh-profile.sh nix-purge.sh -&amp;gt; ceh-purge.sh nix-upgrade.sh -&amp;gt; ceh-upgrade.sh&lt;/p&gt; &#xA;&lt;p&gt;And install-world.sh and predict-binary-cache.sh moved to scripts/maintainer.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TODOs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Have an LD_PRELOAD library that hides =/usr/lib/mozilla/plugins= from Firefox&#39;s view.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Design and other info for Ceh hackers, maintainers *** Directory structure =/opt/ceh/bin/=: wrapper scripts, they make sure that the wanted package is already installed into =/nix/store= and symlinked from =/opt/ceh/installed=. After this initialization they just exec the binary from =/nix/store=,&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=/opt/ceh/bin-user/=: gitignored directory for local exclusions, so the end-user has the final say. The =scripts/ceh-profile.sh= script puts this directory in front of the =bin/= directory in PATH,&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/emacs.d/=: contains =nix-mode.el= only, we used to distribute emacs modules via Ceh, but it didn&#39;t work too well, it&#39;s simpler to just use melpa,&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/home=: gitignored symlink to the user&#39;s home, this is extremely useful, because if Ceh is installed, you can simply use =/opt/ceh/home= as a path to point to the user&#39;s home directory without using the tilde expansion of the shell (that doesn&#39;t work in syscalls or on the shebang line),&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/lib/=: the Ceh (mainly written in Perl) internals,&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/p/=: gitignored symlinks to the user&#39;s projects, so every project can have an absolute symlink in =/opt/ceh/p/whatever-project=, like we have =/opt/ceh/home= as an absolute path for the user&#39;s home directory,&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/scripts/=: Ceh end-user scripts (install, purge, profile, upgrade),&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/scripts/maintainer=: Ceh maintainer scripts,&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/nixpkgs=: contains checked out versions of the nixpkgs package collection, used and maintained by =lib/CehInstall.pm=, gitignored,&lt;/p&gt; &#xA;&lt;p&gt;=/nix=: not in Git, but doesn&#39;t store any important data. Deleting all the content and reinstalling Ceh will result in some compilation and downloading, but everything will be recreated eventually,&lt;/p&gt; &#xA;&lt;p&gt;=/nix/store=: contains the installed package roots. Managed by nix commands, like =nix-store=, =nix-env= and =nix-instantiate=,&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/installed/packages=: gitignored directory storing the currently installed packages on a machine. The state is stored as symlinks to =/nix/store= and there are symlinks to here from =/nix/var/nix/gcroots/auto/ceh=. So the purpose of this directory is two-fold: first, it protects the packages that the user use from being garbage collected. Secondly, we can determine with a simple =stat= whether a package is already installed.&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/installed/essential=: nix and perl that is used by Ceh,&lt;/p&gt; &#xA;&lt;p&gt;=/opt/ceh/installed/tools=: the tools used by Ceh itself (e.g. =which=).&lt;/p&gt; &#xA;&lt;p&gt;*** Adding a new package to ceh&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simply create a wrapper script in =/opt/ceh/bin=, use =tmux= as an example,&lt;/li&gt; &#xA; &lt;li&gt;use the autoinit feature to get the initial hash values: : ceh_nixpkgs_install_bin(&#39;newpkg&#39;, AUTOINIT); After running this wrapper once, the AUTOINIT will be replaced with the current nixpkgs version and out hash value.&lt;/li&gt; &#xA; &lt;li&gt;add it to =scripts/maintainer/install-world.sh=,&lt;/li&gt; &#xA; &lt;li&gt;symlink manpages in =/opt/ceh/man= if appropriate,&lt;/li&gt; &#xA; &lt;li&gt;send a github pull request.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Upgrading ceh to a new baseline&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Update CEH_BASELINE_NIXPKGS in =lib/CehBase.pm= with a new hash, that you should get from &lt;a href=&#34;http://hydra.nixos.org/jobset/nixpkgs/trunk&#34;&gt;http://hydra.nixos.org/jobset/nixpkgs/trunk&lt;/a&gt;, by choosing the most recent build that has no pending (gray) packages anymore. Clicking inputs, you can get the git revision you need.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update the used Nix and Perl to the new baseline: : CEH_AUTO_UPGRADE=1 &lt;br&gt; : ENSURE_BASE_PERL=/opt/ceh/installed/essential/perl/MAIN/bin/perl &lt;br&gt; : ENSURE_BASE_NIXPATH=/opt/ceh/installed/essential/nix/MAIN /opt/ceh/lib/ensure_base_installed.pl&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update CEH_BASELINE_NIXPATH in =lib/CehBase.pm= (peek from CehInstall.pl:ensure_base_installed).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update CEH_BASELINE_PERL in =lib/CehBase.pm= (peek from CehInstall.pl:ensure_base_installed).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update all the wrappers to have the new baseline versions. For example to upgrade git: : export CEH_AUTO_UPGRADE=1 : /opt/ceh/bin/gitk&lt;/p&gt; &lt;p&gt;This will update the hash in lib/Packages/Git.pm.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To update all the packages, use scripts/maintainer/install-world.sh. You may also find scripts/maintainer/predict-binary-cache.sh useful in selecting and checking a baseline.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=git grep= the old baseline hash to see that everything has been updated.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;git commit, git push.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Upgrading nix inside ceh-init.sh This should only be done if you have some strong reason for this. E.g. it&#39;s no longer compatible with current glibc on standard linuxes or the communication protocol for nix-daemon changed and therefore Ceh is unusable on NixOS.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Choose a new release from &lt;a href=&#34;http://nixos.org/nix/download.html&#34;&gt;http://nixos.org/nix/download.html&lt;/a&gt;, read release notes, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Look into the install shell script, to figure out the current URL for i686-linux, e.g. for 1.11.2 it was &lt;code&gt;https://nixos.org/releases/nix/nix-1.11.2/nix-1.11.2-i686-linux.tar.bz2&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;tar xvfj nix-x.x.x-i686-linux.tar.bz2&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update =CEH_NIX_DOWNLOAD=, =NIX_TARDIR_NAME= and =CEH_NIX= in =scripts/ceh-init.sh=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Test if =scripts/ceh-init.sh= still works on a clean Debian and on a clean NixOS.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;git commit, git push.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Techtalk #+BEGIN_SRC Title: Nix &amp;amp; ceh: reproducible power-user environment&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Abstract:&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s common for engineers to use multiple GNU/Linux based computers daily, however it&#39;s not easy to achieve the same working environment on each of them.&lt;/p&gt; &#xA;&lt;p&gt;Computers owned by the company may run the company&#39;s linux variant, while computers at home run some common distribution. Some of the running variants are already 64-bit, some are not. Some of them is 2 years old, some of them is fresh.&lt;/p&gt; &#xA;&lt;p&gt;On top of this mixture, it&#39;s hard to imagine to run exactly the same version of GNU Emacs or Mozilla Firefox (with all the hard to install plugins: flash, googletalk, java), without installing a common base operating system.&lt;/p&gt; &#xA;&lt;p&gt;This is the problem that I wanted a solution for, when I looked into the Nix package manager and the Nixpkgs package collection. After a month of exploration I now have a working setup (called ceh), that I run on all of my computers to synchronize (via Git) the choice of software between them.&lt;/p&gt; &#xA;&lt;p&gt;In the techtalk I will present the fundamentals of Nix and show ceh, my setup around Nix. #+END_SRC&lt;/p&gt;</summary>
  </entry>
</feed>