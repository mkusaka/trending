<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-27T01:38:13Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>instriq/security-gate</title>
    <updated>2023-09-27T01:38:13Z</updated>
    <id>tag:github.com,2023-09-27:/instriq/security-gate</id>
    <link href="https://github.com/instriq/security-gate" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple and pratical security gate for Github Security Alerts&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt;&lt;b&gt;Security Gate&lt;/b&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Simple and pratical security gate for Github Security Alerts&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/instriq/security-gate/master/LICENSE.md&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/instriq/security-gate/releases&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/version-0.0.2-blue.svg?sanitize=true&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Summary&lt;/h3&gt; &#xA;&lt;p&gt;This is a project that allows you to use a Security Gate within Github, using Actions and your project&#39;s Security Alerts as an information base. Currently only Dependabot Alerts are supported, soon we will have support for Secrets and Security Advisories Alerts.&lt;/p&gt; &#xA;&lt;p&gt;You can define a vulnerability policy based on impact i.e. the number of vulnerabilities per threat, and automatically block your CI/CD pipeline if these policies are not met. This ensures that your application has greater protection, preventing codes that contain known threats from being deployed in production.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Github Actions&lt;/h3&gt; &#xA;&lt;p&gt;You need to create a token with read access to Security Alerts and configure it within the Secrets resource of your repository, then: In your repository, create a YAML file at: &lt;code&gt;.github/workflows/security-gate.yml&lt;/code&gt; with this content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: Security Gate - Instriq&#xA;&#xA;on:&#xA;  push:&#xA;    branches:&#xA;      - main&#xA;  pull_request:&#xA;    branches:&#xA;      - main&#xA;&#xA;jobs:&#xA;  build:&#xA;    runs-on: ubuntu-latest&#xA;    env:&#xA;      MAX_CRITICAL: 1&#xA;      MAX_HIGH: 2&#xA;      MAX_MEDIUM: 3&#xA;      MAX_LOW: 4&#xA;      GITHUB_TOKEN: ${{ secrets.TOKEN }}&#xA;    steps:&#xA;    - name: Checkout repository&#xA;      uses: actions/checkout@v4&#xA;&#xA;    - name: Pull Docker image from GitHub Container Registry&#xA;      run: docker pull ghcr.io/instriq/security-gate/security-gate:latest&#xA;&#xA;    - name: Verify security alerts from dependabot&#xA;      run: |&#xA;        docker run ghcr.io/instriq/security-gate/security-gate:latest \&#xA;        -t $GITHUB_TOKEN \&#xA;        -r ${{ github.repository }} \&#xA;        --critical $MAX_CRITICAL \&#xA;        --high $MAX_HIGH \&#xA;        --medium $MAX_MEDIUM \&#xA;        --low $MAX_LOW&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;If you want to use local&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Download&#xA;$ git clone https://github.com/instriq/security-gate &amp;amp;&amp;amp; cd security-gate&#xA;    &#xA;# Install libs dependencies&#xA;$ sudo cpanm --installdeps .&#xA;&#xA;# Basic usage&#xA;$ perl security-gate.pl --help&#xA;&#xA;Security Gate v0.0.2&#xA;Core Commands&#xA;==============&#xA;&#x9;Command          Description&#xA;&#x9;-------          -----------&#xA;        -t, --token      GitHub token&#xA;        -r, --repo       GitHub repository&#xA;        -c, --critical   Critical severity limit&#xA;        -h, --high       High severity limit&#xA;        -m, --medium     Medium severity limit&#xA;        -l, --low        Low severity limit &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Docker container&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ docker build -t security-gate .&#xA;$ docker run -ti --rm security-gate -t &amp;lt;GITHUB_TOKEN&amp;gt; -r &amp;lt;organization/repository&amp;gt; --critical 1 --high 2 --medium 3 --low 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Contribution&lt;/h3&gt; &#xA;&lt;p&gt;Your contributions and suggestions are heartily ♥ welcome. &lt;a href=&#34;https://raw.githubusercontent.com/instriq/security-gate/master/.github/CONTRIBUTING.md&#34;&gt;See here the contribution guidelines.&lt;/a&gt; Please, report bugs via &lt;a href=&#34;https://github.com/instriq/security-gate/issues&#34;&gt;issues page&lt;/a&gt; and for security issues, see here the &lt;a href=&#34;https://raw.githubusercontent.com/instriq/security-gate/master/SECURITY.md&#34;&gt;security policy.&lt;/a&gt; (✿ ◕‿◕)&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;This work is licensed under &lt;a href=&#34;https://raw.githubusercontent.com/instriq/security-gate/master/LICENSE.md&#34;&gt;MIT License.&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kazeburo/App-ikachaos</title>
    <updated>2023-09-27T01:38:13Z</updated>
    <id>tag:github.com,2023-09-27:/kazeburo/App-ikachaos</id>
    <link href="https://github.com/kazeburo/App-ikachaos" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tiny tiny monitoring tool&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#!/usr/bin/perl&lt;/p&gt; &#xA;&lt;p&gt;use strict; use warnings; use Getopt::Long qw/:config posix_default no_ignore_case bundling/; use Pod::Usage qw/pod2usage/; use File::Which; use Log::Minimal; use IO::Select; use Proc::Wait3; use LWP::UserAgent; use HTTP::Request::Common;&lt;/p&gt; &#xA;&lt;p&gt;my $check_interval = 5; my $retry_interval = 1; my $notification_interval = 30; my $max_check_attempts = 3; my $command_timeout = 30;&lt;/p&gt; &#xA;&lt;p&gt;GetOptions( &#39;h|help&#39; =&amp;gt; \my $help, &#39;api-url=s&#39; =&amp;gt; \my $api_url, &#39;channel=s@&#39; =&amp;gt; \my @channel, &#39;check-interval=i&#39; =&amp;gt; $check_interval, &#39;retry-interval=i&#39; =&amp;gt; $retry_interval, &#39;notification-interval=i&#39; =&amp;gt; $notification_interval, &#39;max-check-attempts=i&#39; =&amp;gt; $max_check_attempts, &#39;dry-run&#39; =&amp;gt; \my $dry_run, ) or pod2usage(1);&lt;/p&gt; &#xA;&lt;p&gt;pod2usage(-verbose=&amp;gt;2,-exitval=&amp;gt;0) if $help; my @cmd = @ARGV; pod2usage(-verbose=&amp;gt;1,-exitval=&amp;gt;1) unless @cmd;&lt;/p&gt; &#xA;&lt;p&gt;if ( $dry_run ) { my ($result, $exit_code); eval { ($result, $exit_code) = cap_cmd(@cmd, $command_timeout); }; if ($@) { $result = $@; $exit_code = 255; } $result = &#39;-&#39; if ! defined $result; printf &#39;DRY-RUN [%s] %s / %s&#39;.&#34;\n&#34;, code_to_text($exit_code), join(&#34; &#34;, @cmd), $result; exit($exit_code); }&lt;/p&gt; &#xA;&lt;p&gt;pod2usage(-verbose=&amp;gt;1,-exitval=&amp;gt;1) unless $api_url; pod2usage(-verbose=&amp;gt;1,-exitval=&amp;gt;1) unless @channel;&lt;/p&gt; &#xA;&lt;p&gt;my $check_interval_sec = $check_interval * 60; my $retry_interval_sec = $retry_interval * 60; my $notification_interval_sec = $notification_interval * 60;&lt;/p&gt; &#xA;&lt;p&gt;my $stop = 1; local $SIG{TERM} = $SIG{INT} = sub { $stop = 0 }; my $next = time; $next = $next - ( $next % $check_interval_sec) + $check_interval_sec + int(rand($check_interval_sec));; #next + random&lt;/p&gt; &#xA;&lt;p&gt;my @status; my $last_notify = 0;&lt;/p&gt; &#xA;&lt;p&gt;while ( $stop ) { local $Log::Minimal::AUTODUMP = 1; my $current = time(); my $next_interval = $check_interval_sec; if ( @status &amp;amp;&amp;amp; is_error_status($status[0])) { $next_interval = $retry_interval_sec; } while ( $next &amp;lt; $current ) { $next = $next + $next_interval; } while ( $stop ) { last if time() &amp;gt;= $next; select undef, undef, undef, 0.1; ## no critic; } last if !$stop; $next = $next + $next_interval; debugf(&#34;exec command&#34;); my ($result, $exit_code); eval { ($result, $exit_code) = cap_cmd(@cmd, $command_timeout); }; if ($@) { $result = $@; $exit_code = 255; } $result = &#39;-&#39; if ! defined $result; debugf(&#34;command finished code:%s message:%s&#34;,$exit_code,$result);&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;push @status, [$result,$exit_code];&#xA;pop @status if @status &amp;gt; $max_check_attempts;&#xA;&#xA;my @errors = grep { is_error_status($_) } @status;&#xA;if ( @errors == $max_check_attempts ) {&#xA;    # ikachan&#xA;    debugf(&#34;ERROR STATE: %s&#34;, @status);&#xA;    if ( time - $last_notify &amp;gt;= $notification_interval_sec   ) {&#xA;        $last_notify = time;&#xA;        my $message = sprintf &#39;*ikachaos* Alerts: [%s] %s / %s&#39;, code_to_text($exit_code), join(&#34; &#34;, @cmd), $result;&#xA;        my $ua = LWP::UserAgent-&amp;gt;new;&#xA;        for my $channel ( @channel ) {&#xA;            debugf(&#34;SEND NOTIFY to channel:%s message:%s&#34;, $channel, $message);&#xA;            my $res = $ua-&amp;gt;request(POST $api_url,&#xA;              [ &#34;channel&#34;=&amp;gt;$channel,&#34;message&#34;=&amp;gt;$message]);&#xA;            warnf(&#34;failed to sending notify: %s&#34;, $res-&amp;gt;status_line) unless $res-&amp;gt;is_success;&#xA;        }&#xA;    }&#xA;}&#xA;# next..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;sub is_error_status { my $status = shift; $status-&amp;gt;[1] != 0; }&lt;/p&gt; &#xA;&lt;p&gt;sub code_to_text { my $code = shift; if ( $code == 0 ) { return &#34;OK&#34;; } elsif ( $code == 1 ) { return &#34;WARNING&#34;; } elsif ( $code == 2 ) { return &#34;CRITICAL&#34;; } return &#34;UNKNOWN&#34;; }&lt;/p&gt; &#xA;&lt;p&gt;sub cap_cmd { my ($cmdref, $timeout) = @_;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;my $bash = which(&#39;bash&#39;);&#xA;my @cmd = @$cmdref;;&#xA;if ( @cmd == 1 &amp;amp;&amp;amp; $bash ) {&#xA;    @cmd = ($bash,&#39;-c&#39;, $cmd[0]);&#xA;}&#xA;&#xA;local $Log::Minimal::AUTODUMP = 1;&#xA;my $timeout_at = $timeout + time;&#xA;my $s = IO::Select-&amp;gt;new();&#xA;pipe my $logrh, my $logwh&#xA;    or die &#34;Died: failed to create pipe:$!&#34;;&#xA;my $pid = fork;&#xA;if ( ! defined $pid ) {&#xA;    die &#34;Died: fork failed: $!&#34;;&#xA;} &#xA;&#xA;elsif ( $pid == 0 ) {&#xA;    #child&#xA;    close $logrh;&#xA;    open STDOUT, &#39;&amp;gt;&amp;amp;&#39;, $logwh&#xA;        or die &#34;Died: failed to redirect STDOUT&#34;;&#xA;    close $logwh;&#xA;    exec @cmd;&#xA;    exit(255);&#xA;}&#xA;close $logwh;&#xA;my $result;&#xA;$s-&amp;gt;add($logrh);&#xA;my $haserror=0;&#xA;while ( 1 ) {&#xA;    my @ready = $s-&amp;gt;can_read(1);&#xA;    if ( time &amp;gt; $timeout_at ) {&#xA;        $haserror = &#34;exec timeout&#34;;&#xA;        last;&#xA;    }&#xA;    next unless @ready;&#xA;    my $ret = sysread($logrh, my $buf, 65536);&#xA;    if ( ! defined $ret ) {&#xA;        $haserror = &#34;failed to read pipe: $!&#34;;&#xA;        last;&#xA;    }&#xA;    last if $ret == 0;&#xA;    $result .= $buf;&#xA;}&#xA;if ( $haserror ) {&#xA;    kill &#39;TERM&#39;, $pid;&#xA;}&#xA;close $logrh;&#xA;my @wait = wait3(1); #block;&#xA;if ( $haserror ) {&#xA;    return ($haserror, 255);&#xA;}&#xA;my $exit_code = $wait[1];&#xA;$exit_code = $exit_code &amp;gt;&amp;gt; 8;&#xA;return ($result, $exit_code);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;=encoding utf8&lt;/p&gt; &#xA;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;ikachaos.pl - tinytiny monitoring tool&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;p&gt;$ ikachaos.pl -h&lt;/p&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;ikachaos.pl is tinytiny monitoring tool. exec a command and check exit code. If detects error status, send notify via &#xA; &lt;ikachan&gt;&lt;/ikachan&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 ARGUMENTS&lt;/p&gt; &#xA;&lt;p&gt;=over 4&lt;/p&gt; &#xA;&lt;p&gt;=item -h, --help&lt;/p&gt; &#xA;&lt;p&gt;Display help message&lt;/p&gt; &#xA;&lt;p&gt;=item --dry-run&lt;/p&gt; &#xA;&lt;p&gt;Do dry run command and exit&lt;/p&gt; &#xA;&lt;p&gt;=item --api-url: URL&lt;/p&gt; &#xA;&lt;p&gt;API endpoint of ikachan&lt;/p&gt; &#xA;&lt;p&gt;=item --channel: Strings&lt;/p&gt; &#xA;&lt;p&gt;channel names to send notify&lt;/p&gt; &#xA;&lt;p&gt;=item --check-interval: Integer(minute)&lt;/p&gt; &#xA;&lt;p&gt;minute between regularly scheduled checks. default 5min&lt;/p&gt; &#xA;&lt;p&gt;=item --retry-interval: Integer(minute)&lt;/p&gt; &#xA;&lt;p&gt;minute to wait before scheduling a re-check. default 1min&lt;/p&gt; &#xA;&lt;p&gt;=item --notification-interval: Integer(minute)&lt;/p&gt; &#xA;&lt;p&gt;minute to wait before re-sending notify. default 30min&lt;/p&gt; &#xA;&lt;p&gt;=item --max-check-attempts: Integer&lt;/p&gt; &#xA;&lt;p&gt;the number of times that this system retry the host check command&lt;/p&gt; &#xA;&lt;p&gt;=item COMMAND&lt;/p&gt; &#xA;&lt;p&gt;service check command. If exit code isn&#39;t &#34;0&#34;, ikachaos treat it as failed. makes alert level with exit code, for example 0 = OK, 1 = WARNING, 2 = CRITICAL and other = UNKNOWN. This behavior is same as Nagios&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head1 SEE ALSO&lt;/p&gt; &#xA;&lt;ikachan&gt; &#xA; &lt;p&gt;=head1 AUTHOR&lt;/p&gt; &#xA; &lt;p&gt;Masahiro Nagano E&#xA;  &lt;lt&gt;&#xA;   &lt;a href=&#34;mailto:kazeburo@gmail.comE&#34;&gt;kazeburo@gmail.comE&lt;/a&gt;&#xA;   &lt;gt&gt;&lt;/gt&gt;&#xA;  &lt;/lt&gt;&lt;/p&gt; &#xA; &lt;p&gt;=head1 LICENSE&lt;/p&gt; &#xA; &lt;p&gt;Copyright (C) Masahiro Nagano&lt;/p&gt; &#xA; &lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt; &#xA; &lt;p&gt;=cut&lt;/p&gt; &#xA;&lt;/ikachan&gt;</summary>
  </entry>
</feed>