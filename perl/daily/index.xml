<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-03T01:45:03Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>gilbo/baselang</title>
    <updated>2023-07-03T01:45:03Z</updated>
    <id>tag:github.com,2023-07-03:/gilbo/baselang</id>
    <link href="https://github.com/gilbo/baselang" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A collection of demonstration languages in Lua/Terra suitable for learning or for forking when creating a new language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This file provides a getting started guide for developers looking to fork one of the Baselang libraries for use as skeleton code. It provides an overview of the language collection, and some advice on how to effectively develop the languages contained in it.&lt;/p&gt; &#xA;&lt;h1&gt;Collection of Languages&lt;/h1&gt; &#xA;&lt;p&gt;The Baselang collection consists of 4 languages designed to articulate a small space of language designs along two dimensions. In all cases, the languages omit control flow and recursive functions, making them suitable only for expressing straight-line code. Nonetheless, they include a full complement of tests, coverage analysis, interoperability examples and documentation. This tradeoff makes the Baselang languages suitable for quick forking and development into more sophisticated languages--complete with enough infrastructure to grow without collapsing under their own weight.&lt;/p&gt; &#xA;&lt;p&gt;The four languages form a lattice, with Simplang being the least feature rich, and Plexlang the most. The two dimensions of variation are (1) the extension from a unified number type to a richer collection of integers and floating point types, and (2) the addition of a tensor type constructor, along with special tensor expressions.&lt;/p&gt; &#xA;&lt;p&gt;Because these changes to the type system are relatively &lt;em&gt;cross-cutting&lt;/em&gt;, they hopefully give a good example of how to elaborate on the basic architecture. Both features also involve a non-trivial amount of code, so if richer types are needed, you can fork a more sophisticated language to save yourself some development time and trouble.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simplang - completely stripped down language&lt;/li&gt; &#xA; &lt;li&gt;Typelang - language with more sophisticated primitive type system&lt;/li&gt; &#xA; &lt;li&gt;Tenslang - language with more sophisticated tensor type system&lt;/li&gt; &#xA; &lt;li&gt;Plexlang - language with both tensors and rich primitive types&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Forking a language&lt;/h2&gt; &#xA;&lt;p&gt;To fork a language, recursively copy any of the four language sub-directories. Once you&#39;ve done this, you&#39;ll need to do a cross-cutting refactoring of the copied code base. Everywhere that the previous language name occurs needs to be searched for and substituted with your new language name. Here&#39;s a quick guide to helping you make these substitutions.&lt;/p&gt; &#xA;&lt;p&gt;In the following we use &lt;code&gt;Xxxxlang&lt;/code&gt; as a shorthand for &lt;code&gt;Simplang&lt;/code&gt;, &lt;code&gt;Typelang&lt;/code&gt;, &lt;code&gt;Tenslang&lt;/code&gt;, and &lt;code&gt;Plexlang&lt;/code&gt; respectively. We use &lt;code&gt;xxxxl&lt;/code&gt; as shorthand for &lt;code&gt;simpl&lt;/code&gt;, &lt;code&gt;typel&lt;/code&gt;, &lt;code&gt;tensl&lt;/code&gt; and &lt;code&gt;plexl&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;rename files and directories: &lt;code&gt;bin/xxxxl&lt;/code&gt;, &lt;code&gt;release/xxxxlang&lt;/code&gt;, &lt;code&gt;release/xxxxlang/xxxxlang.t&lt;/code&gt;, and &lt;code&gt;release/xxxxlang/xxxxlib.t&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When searching and replacing in files, you&#39;ll have to find and replace occurrences of &lt;code&gt;xxxxl&lt;/code&gt; and &lt;code&gt;xxxxlang&lt;/code&gt;. Less obviously, you may want to find all uses of &lt;code&gt;XL&lt;/code&gt; (&lt;code&gt;SL&lt;/code&gt;, &lt;code&gt;TL&lt;/code&gt;, or &lt;code&gt;PL&lt;/code&gt; respectively) and replace them with your choice of convention for the standard library. You can find these by searching for &lt;code&gt;local XL&lt;/code&gt; or &lt;code&gt;XL.&lt;/code&gt; to reduce false positives&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;search and replace within text files: &lt;code&gt;bin/xxxxl&lt;/code&gt;, &lt;code&gt;runtests&lt;/code&gt;, &lt;code&gt;covanalysis&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All the files in &lt;code&gt;example_c/&lt;/code&gt; except &lt;code&gt;static_call_main.c&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All the files in &lt;code&gt;example/&lt;/code&gt; and &lt;code&gt;tests/&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;everything in the &lt;code&gt;release/&lt;/code&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;search and replace in documentation files: &lt;code&gt;README.md&lt;/code&gt;, &lt;code&gt;example_c.md&lt;/code&gt;, &lt;code&gt;docs/buildhtml&lt;/code&gt;, &lt;code&gt;docs/manual.md&lt;/code&gt;. Note that &lt;code&gt;docs/manual.html&lt;/code&gt; can be regenerated from the markdown file using Pandoc, so editing it manually is not necessary.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Why is this all manual?&lt;/h3&gt; &#xA;&lt;p&gt;It doesn&#39;t hurt to take at least one quick look over everything, though I&#39;m open to someone writing a script to handle this step.&lt;/p&gt; &#xA;&lt;h1&gt;Getting Started (as a Developer)&lt;/h1&gt; &#xA;&lt;p&gt;When you get started working with any of these languages, I recommend you go down the following checklist to get your bearings.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Make sure you can run all the tests and that they&#39;re all passing.&lt;/li&gt; &#xA; &lt;li&gt;Make sure you know how to modify and re-build the documentation.&lt;/li&gt; &#xA; &lt;li&gt;Add a simple, boring feature to the language as your first task&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;To run the tests for a langauge, you simply need to run the script&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./runtests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a good way to check for anything you missed during refactoring.&lt;/p&gt; &#xA;&lt;p&gt;The compilers come with a number of tests already written. However, I recommend that you actively add new tests with each new feature or major change, and actively maintain the existing tests.&lt;/p&gt; &#xA;&lt;p&gt;When writing new tests, you can include &lt;code&gt;tests/test.lua&lt;/code&gt; to get access to a shared set of utility functions for writing tests. You can also add the comment &lt;code&gt;--DISABLE-TEST&lt;/code&gt; as the first line of any test to tell the &lt;code&gt;runtests&lt;/code&gt; script to skip it. This way you can disable tests you want to delay fixing rather than deleting them altogether.&lt;/p&gt; &#xA;&lt;h3&gt;Coverage Testing&lt;/h3&gt; &#xA;&lt;p&gt;While tests are always valuable, they&#39;re especially necessary here since these compilers are written in Lua, an interpreted, dynamically typed language. Without a good set of tests, it&#39;s easy to accumulate lots of unexecuted, unreliable code in the compiler.&lt;/p&gt; &#xA;&lt;p&gt;To help manage this issue, we provide a test coverage analysis system integrated into the compiler. This coverage analysis uses Lua&#39;s &lt;code&gt;debug&lt;/code&gt; facilities, which makes it very simple, if slightly imperfect. To turn on coverage analysis, uncomment the line &lt;code&gt;require &#39;xxxxlang.src.coverage&#39;&lt;/code&gt; near the top of the language file &lt;code&gt;release/xxxxlang/xxxxlang.t&lt;/code&gt;. After uncommenting the line, run the test suite and make sure to recomment the line.&lt;/p&gt; &#xA;&lt;p&gt;Running tests with coverage enabled will generate a &lt;code&gt;coverage_src&lt;/code&gt; directory with copies of all the files from &lt;code&gt;release/xxxxlang/src/&lt;/code&gt;, with line counts prepended to every line. Non-trivial lines that have a 0 count are marked with hashes &lt;code&gt;#####:&lt;/code&gt; to indicate that the line is not currently being covered. Some of these lines won&#39;t be covered for various acceptable reasons. (i.e. they&#39;re lines of terra code or represent sanity check assertions that should be impossible to trigger.)&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re interested in tweaking the coverage analysis, all the important details of collecting the coverage data can be found in &lt;code&gt;release/xxxxlang/src/coverage.t&lt;/code&gt; and all of the details of how the report files are generated can be found in the &lt;code&gt;covanalysis&lt;/code&gt; script. In particular, the &lt;code&gt;covanalysis&lt;/code&gt; script defines a set of line patterns which are ignored as non-executable, regardless of what their line count is.&lt;/p&gt; &#xA;&lt;p&gt;You can find a number of discussions online about the merits and dangers of coverage metrics. While high coverage will not ensure that the test suite is of good quality, it is very useful for ensuring that code is executed at least once. In a dynamic language like Lua, this can help eliminate a range of otherwise trivial bugs.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation and Example Code&lt;/h2&gt; &#xA;&lt;p&gt;Documentation files exist in 3 places. The main source of documentation is &lt;code&gt;docs/manual.md&lt;/code&gt;, which gives a detailed description of the language and its API. Second, there&#39;s a &lt;code&gt;README.md&lt;/code&gt;, which should help a new user get up and running as quickly as possible, along with directing them towards the full manual. This &lt;code&gt;README.md&lt;/code&gt; file will likely be the first documentation a new user encounters, so it&#39;s important for it to remain relatively brief and to the point. Lastly, there are special instructions at &lt;code&gt;example_c/README.md&lt;/code&gt; that provide more detailed information on how the language can be compiled into C code. If you choose to stop supporting this functionality, make sure to remove the &lt;code&gt;example_c&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;The main &lt;code&gt;docs/manual.md&lt;/code&gt; file is also available in HTML format. In order to keep these in sync, we provide a &lt;code&gt;docs/buildhtml&lt;/code&gt; script that constructs the HTML manual automatically from the Markdown document. In order to do so, you need to install the Pandoc utility.&lt;/p&gt; &#xA;&lt;p&gt;Besides the documentation, new users are likely to turn to your example code to get a sense of how to use the langauge. For this reason it&#39;s especially important that you keep your example code (in &lt;code&gt;examples/&lt;/code&gt;) up to date, working, and that you make sure the code is representative of the Language&#39;s intended uses. To help with this, notice that we can create test files like &lt;code&gt;tests/isct_predicates.t&lt;/code&gt; in order to invoke examples as part of our test suite. This is the most reliable way to make sure example code remains up-to-date.&lt;/p&gt; &#xA;&lt;h2&gt;Adding a basic feature to the language&lt;/h2&gt; &#xA;&lt;p&gt;These languages were intentionally left without some obvious, useful features. One benefit of this choice is that there are plenty of small projects new developers can do to learn the code base better. A full list of such projects is provided at the end of this document. We repeat a few of the easier &#34;first-steps&#34; style projects here.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Let expressions&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;There&#39;s a bunch of machinery in the compiler for let expressions, but they&#39;re not exposed as a user-accessible bit of syntax. Expose them, but then also make sure that they&#39;re working correctly by writing appropriate tests. What kind of tests do you need to write?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Control Flow&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Add in basic while-loops and if-then-else statements&lt;/li&gt; &#xA;   &lt;li&gt;Add in for-loops. How should they work?&lt;/li&gt; &#xA;   &lt;li&gt;Add in repeat-while loops&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Type coercions&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Add in the uint32 and int64 types for completeness. How should type coercions work? Should any of the existing coercions be removed?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Deployment and Distribution&lt;/h1&gt; &#xA;&lt;p&gt;The cardinal rule of software distribution is that you should do almost anything in your power to make it easier for more people to reliably, quickly and easily get started using your code. The README files, examples, tests, and scripts included with these languages are all intended to help with this issue.&lt;/p&gt; &#xA;&lt;p&gt;However, the current documentation is largely written assuming some familiarity with Lua/Terra. If you&#39;re developing your language for wide deployment to people who don&#39;t care that much about programming in Lua/Terra, then it might be worth considering how to substantially lower the barrier to getting set up in the first place. For instance, you might want to package the entire language, along with a Lua/Terra environment as a single C-library or pair of C-libraries. As an example, this would be a good idea if you use Lua/Terra to implement a SQL client or database.&lt;/p&gt; &#xA;&lt;h1&gt;Compiler Architecture and Design&lt;/h1&gt; &#xA;&lt;p&gt;Go through some kind of a walk-through here of how things are set up.&lt;/p&gt; &#xA;&lt;h1&gt;Wish List&lt;/h1&gt; &#xA;&lt;p&gt;While I tried to cover most of the major issues with developing and deploying large-ish Lua/Terra DSLs here, there are a few topics that are noticably absent.&lt;/p&gt; &#xA;&lt;p&gt;At the time, my biggest regret is that these example languages do not include much in the way of explicit, carefully considered support for debugging.&lt;/p&gt; &#xA;&lt;h1&gt;Suggested Project List&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;extend the multiple-return-value/assignment feature: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;multi-variable declaration statements would generally be useful. It would also be nice as a way to capture multiple return values from a function call. Design Q: Where should type annotations go? Design Q: Should you be able to capture some return values with an existing variable and some with new variable names? Again, think about balancing simplicity with utility.&lt;/li&gt; &#xA;   &lt;li&gt;consider the following local baselang retpair() return 0,1 end local baselang foo() return retpair() end It doesn&#39;t work right now, because the compiler tries to create a tuple of a tuple to return. Can you fix this problem? Design Q: In what cases should you try to fix this problem? Can you balance simplicity with utility here?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Type coercions &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Add in the uint32 and int64 types for completeness. How should type coercions work? Should any of the existing coercions be removed?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Control Flow &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Add in basic while-loops and if-then-else statements&lt;/li&gt; &#xA;   &lt;li&gt;Add in for-loops. How should they work?&lt;/li&gt; &#xA;   &lt;li&gt;Add in repeat-while loops&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Recursive Functions &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Try adding in only self-recursive (rather than mutually recursive) funtions first. It&#39;s a bit simpler&lt;/li&gt; &#xA;   &lt;li&gt;Can you add mutually recursive functions?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Let expressions &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;There&#39;s a bunch of machinery in the compiler for let expressions, but they&#39;re not exposed as a user-accessible bit of syntax. Expose them, but then also make sure that they&#39;re working correctly by writing appropriate tests. What kind of tests do you need to write?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Coverage &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Turn on the code coverage analysis and see whether or not the tests are covering everything. Probably not. Can you use this information to improve the test suite? Are there any bugs you found?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;New IR &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The AST format has a lot of different node types, some of which are probably unnecessary. Notice that after typechecking, we should have enough local information to flatten out the code such that blocking is unnecessary beyond control flow (if we added that). Specifically, notice that variable scoping/shadowing has been resolved directly into symbol names now. Can you translate to a form that looks a little bit closer to SSA? (It can still be an AST, but try to heavily reduce the number of different AST kinds that are used)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Generic/Polymorphic Functions &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;One approach to polymorphic functions is to simply delay typechecking until the function is used, at which point a variant of the function can be dispatched based on the supplied values. This is relatively simple of a strategy in the current compiler infrastructure, and is recommended heavily.&lt;/li&gt; &#xA;   &lt;li&gt;Another approach is to include explicit polymorphism in the typesystem. This is the more traditional/academic way a programming language might handle things. I recommend against it, but it might be interesting to work through if you want to kill some time. I highly recommend some familiarity with System F or a comparable typesystem if you don&#39;t want to make a total mess of this.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Structured Data &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Add a type for structs of data. How should structs be declared? How should data be accessed from within functions. How should structured data be constructed within a function?&lt;/li&gt; &#xA;   &lt;li&gt;Consider adding full Algebraic Data Types in the ML/Haskell style. Would these be useful to you? Is pattern matching a particularly helpful feature to add?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>