<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-11T01:37:11Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>binary-com/perl-MooseX-Role-Validatable</title>
    <updated>2022-10-11T01:37:11Z</updated>
    <id>tag:github.com,2022-10-11:/binary-com/perl-MooseX-Role-Validatable</id>
    <link href="https://github.com/binary-com/perl-MooseX-Role-Validatable" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/binary-com/perl-MooX-Role-Validatable&#34;&gt;&lt;img src=&#34;https://travis-ci.org/binary-com/perl-MooX-Role-Validatable.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/binary-com/perl-MooX-Role-Validatable&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/binary-com/perl-MooX-Role-Validatable/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;NAME&lt;/h1&gt; &#xA;&lt;p&gt;MooseX::Role::Validatable - Role to add validation to a class&lt;/p&gt; &#xA;&lt;h1&gt;SYNOPSIS&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;package MyClass;&#xA;&#xA;use Moose;&#xA;with &#39;MooseX::Role::Validatable&#39;;&#xA;&#xA;has &#39;attr1&#39; =&amp;gt; (is =&amp;gt; &#39;ro&#39;, lazy_build =&amp;gt; 1);&#xA;&#xA;sub _build_attr1 {&#xA;    my $self = shift;&#xA;&#xA;    # Note initialization errors&#xA;    $self-&amp;gt;add_errors( {&#xA;        message =&amp;gt; &#39;Error: blabla&#39;,&#xA;        message_to_client =&amp;gt; &#39;Something is wrong!&#39;&#xA;    } ) if &#39;blabla&#39;;&#xA;}&#xA;&#xA;sub _validate_some_other_errors { # _validate_*&#xA;    my $self = shift;&#xA;&#xA;    my @errors;&#xA;    push @errors, {&#xA;        message =&amp;gt; &#39;...&#39;,&#xA;        message_to_client =&amp;gt; &#39;...&#39;,&#xA;    };&#xA;&#xA;    return @errors;&#xA;}&#xA;&#xA;## use&#xA;my $ex = MyClass-&amp;gt;new();&#xA;&#xA;if (not $ex-&amp;gt;initialized_correctly) {&#xA;    my @errors = $ex-&amp;gt;all_init_errors();&#xA;    ...;    # We didn&#39;t even start with good data.&#xA;}&#xA;&#xA;if (not $ex-&amp;gt;confirm_validity) { # does not pass those _validate_*&#xA;    my @errors = $ex-&amp;gt;all_errors();&#xA;    ...;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;DESCRIPTION&lt;/h1&gt; &#xA;&lt;p&gt;MooseX::Role::Validatable is a Moo/Moose role which provides a standard way to add validation to a class.&lt;/p&gt; &#xA;&lt;h1&gt;METHODS&lt;/h1&gt; &#xA;&lt;h2&gt;initialized_correctly&lt;/h2&gt; &#xA;&lt;p&gt;no error when init the object (no add_errors is called)&lt;/p&gt; &#xA;&lt;h2&gt;add_errors&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$self-&amp;gt;add_errors(...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;add errors on those lazy attributes or sub BUILD&lt;/p&gt; &#xA;&lt;h2&gt;confirm_validity&lt;/h2&gt; &#xA;&lt;p&gt;run all those &lt;strong&gt;_validate_*&lt;/strong&gt; messages and returns true if no error found.&lt;/p&gt; &#xA;&lt;h2&gt;all_errors&lt;/h2&gt; &#xA;&lt;p&gt;An array of the errors currently noted. combined with &lt;strong&gt;all_init_errors&lt;/strong&gt; and &lt;strong&gt;all_validation_errors&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;all errors including below methods are instance of error_class, default to &lt;a href=&#34;https://metacpan.org/pod/MooseX::Role::Validatable::Error&#34;&gt;MooseX::Role::Validatable::Error&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;all_init_errors&lt;/h2&gt; &#xA;&lt;p&gt;all errors on init&lt;/p&gt; &#xA;&lt;h2&gt;all_validation_errors&lt;/h2&gt; &#xA;&lt;p&gt;all errors on validation&lt;/p&gt; &#xA;&lt;h2&gt;all_errors_by_severity&lt;/h2&gt; &#xA;&lt;p&gt;order by severity&lt;/p&gt; &#xA;&lt;h2&gt;primary_validation_error&lt;/h2&gt; &#xA;&lt;p&gt;the first error of &lt;strong&gt;all_errors_by_severity&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;validation_methods&lt;/h2&gt; &#xA;&lt;p&gt;A list of all validation methods available on this object. This can be auto-generated from all methods which begin with &#34;_validate_&#34; which is especially helpful in devleoping new validations.&lt;/p&gt; &#xA;&lt;p&gt;You may wish to set this list directly on the object, if you create and validate a lot of static objects.&lt;/p&gt; &#xA;&lt;h2&gt;error_class&lt;/h2&gt; &#xA;&lt;p&gt;default to &lt;a href=&#34;https://metacpan.org/pod/MooseX::Role::Validatable::Error&#34;&gt;MooseX::Role::Validatable::Error&lt;/a&gt;, override by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;has &#39;+error_class&#39; =&amp;gt; (is =&amp;gt; &#39;ro&#39;, default =&amp;gt; sub { &#39;My::Validatable::Error&#39; });&#xA;&#xA;# or&#xA;-&amp;gt;new(error_class =&amp;gt; &#39;My::Validatable::Error&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;AUTHOR&lt;/h1&gt; &#xA;&lt;p&gt;Binary.com &lt;a href=&#34;mailto:fayland@binary.com&#34;&gt;fayland@binary.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;COPYRIGHT&lt;/h1&gt; &#xA;&lt;p&gt;Copyright 2014- Binary.com&lt;/p&gt; &#xA;&lt;h1&gt;LICENSE&lt;/h1&gt; &#xA;&lt;p&gt;This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.&lt;/p&gt; &#xA;&lt;h1&gt;SEE ALSO&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>binary-com/perl-Data-Chronicle</title>
    <updated>2022-10-11T01:37:11Z</updated>
    <id>tag:github.com,2022-10-11:/binary-com/perl-Data-Chronicle</id>
    <link href="https://github.com/binary-com/perl-Data-Chronicle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Chronicle storage system&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Chronicle storage system (perl-Data-Chronicle)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/binary-com/perl-Data-Chronicle&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/binary-com/perl-Data-Chronicle.svg?style=svg&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/binary-com/perl-Data-Chronicle&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/binary-com/perl-Data-Chronicle/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains three modules (Reader, Writer, and Subscriber) which can be used to store and retrieve information on an efficient storage with below properties:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Timeliness&lt;/strong&gt; It is assumed that data to be stored are time-based meaning they change over time and the latest version is most important for us.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Efficient&lt;/strong&gt;: The module uses Redis cache to provide efficient data storage and retrieval.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Persistent&lt;/strong&gt;: In addition to caching every incoming data, it is also stored in PostgresSQL for future retrieval.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Transparent&lt;/strong&gt;: This modules hides all the details about caching, database structure and ... from developer. He only needs to call a method to save data and another method to retrieve it. All the underlying complexities are handled by the module.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that you will need to pass &lt;code&gt;cache_writer&lt;/code&gt;, &lt;code&gt;cache_reader&lt;/code&gt; and &lt;code&gt;db_handle&lt;/code&gt; to the &lt;code&gt;Data::Chronicle::Reader/Writer&lt;/code&gt; modules. These three arguments, provide access to your Redis and PostgreSQL which will be used by Chronicle modules.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cache_writer&lt;/code&gt; and &lt;code&gt;cache_reader&lt;/code&gt; should be to be able to get/set given data under given key (both of type string). &lt;code&gt;db_handle&lt;/code&gt; should be capable to store and retrieve data with &lt;code&gt;category&lt;/code&gt;,&lt;code&gt;name&lt;/code&gt; in addition to the timestamp of data insertion. So it should be able to retrieve data for a specific timestamp, category and name. Category, name and data are all string. This can easily be achieved by defining a table in you database containing these columns: &lt;code&gt;timestamp, category, name, value&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are nine important methods this module provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;set&lt;/strong&gt; (in Data::Chronicle::Writer): Given a category, name and value stores the JSONified value in Redis and PostgreSQL database under &#34;category::name&#34; group and also stores current system time as the timestamp for the data (Which can be used for future retrieval if we want to get data as of a specific time). Note that the value MUST be either hash-ref or array-ref.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;mset&lt;/strong&gt; (in Data::Chronicle::Writer): Given multiple categories, names and values atomically performs the set operation on each corresponding category, name, value set.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;get&lt;/strong&gt; (in Data::Chronicle::Reader): Given a category and name returns the latest version of the data according to current Redis cache&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;mget&lt;/strong&gt; (in Data::Chronicle::Reader): Given multiple categories and name atomically performs the get operation on each corresponding category, name set.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;get_for&lt;/strong&gt; (in Data::Chronicle::Reader): Given a category, name and timestamp returns version of data under &#34;category::name&#34; as of the given date (using a DB lookup).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;get_for_period&lt;/strong&gt; (in Data::Chronicle::Reader): Given a category, name, start_timestamp and end_timestamp returns an array-ref containing all data stored between given period for the given &#34;category::name&#34; (using a DB lookup).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;get_history&lt;/strong&gt; (in Data::Chronicle::Reader): Given a category, name, and revision returns version of the data the specified number of revisions in the past. If revision 0 is chosen, the latest version of the data will be returned. If revision 1 is chosen, the previous version of the data will be returned.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;subscribe&lt;/strong&gt; (in Data::Chronicle::Subscriber): Given a category, name, and callback assigns the callback to be called when a new value is set for the specified category and name (if the writer has publish_on_set enabled).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;unsubscribe&lt;/strong&gt; (in Data::Chronicle::Subscriber): Given a category, name, clears the callbacks associated with the specified category and name.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;my $d = get_some_log_data();&#xA;&#xA;my $chronicle_w = Data::Chronicle::Writer-&amp;gt;new( &#xA;    cache_writer =&amp;gt; $writer,&#xA;    db_handle    =&amp;gt; $dbh);&#xA;&#xA;my $chronicle_r = Data::Chronicle::Reader-&amp;gt;new( &#xA;    cache_reader =&amp;gt; $reader, &#xA;    db_handle    =&amp;gt; $dbh);&#xA;&#xA;&#xA;#store data into Chronicle - each time we call `set` it will also store &#xA;#a copy of the data for historical data retrieval&#xA;$chronicle_w-&amp;gt;set(&#34;log_files&#34;, &#34;syslog&#34;, $d);&#xA;&#xA;#retrieve latest data stored for syslog under log_files category&#xA;my $dt = $chronicle_r-&amp;gt;get(&#34;log_files&#34;, &#34;syslog&#34;);&#xA;&#xA;#find historical data for `syslog` at given point in time&#xA;my $some_old_data = $chronicle_r-&amp;gt;get_for(&#34;log_files&#34;, &#34;syslog&#34;, $epoch1);&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>