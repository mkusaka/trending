<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-02T01:39:06Z</updated>
  <subtitle>Daily Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Cyclenerd/google-cloud-compute-machine-types</title>
    <updated>2024-06-02T01:39:06Z</updated>
    <id>tag:github.com,2024-06-02:/Cyclenerd/google-cloud-compute-machine-types</id>
    <link href="https://github.com/Cyclenerd/google-cloud-compute-machine-types" rel="alternate"></link>
    <summary type="html">&lt;p&gt;‚òÅÔ∏è Choose the optimal Google Compute Engine machine type or instance in the many Google Cloud Platform regions&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Google Cloud Compute Comparison&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cyclenerd/google-cloud-compute-machine-types/master/#readme&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Google%20Cloud-%234285F4.svg?logo=google-cloud&amp;amp;logoColor=white&#34; alt=&#34;Badge: Google Cloud&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Cyclenerd/google-cloud-compute-machine-types/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/Cyclenerd/google-cloud-compute-machine-types/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Badge: CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Cyclenerd/google-cloud-compute-machine-types/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/cyclenerd/google-cloud-compute-machine-types&#34; alt=&#34;Badge: GitHub&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This Google Compute Engine machine type comparison &lt;a href=&#34;https://gcloud-compute.com/&#34;&gt;webapp&lt;/a&gt; helps to find the optimal GCE machine type or instance in the many Google Cloud Platform (GCP) regions. A lot of information has been collected from various Google Cloud websites and different sources.&lt;/p&gt; &#xA;&lt;h2&gt;Instance Picker&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gcloud-compute.com/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cyclenerd/google-cloud-compute-machine-types/master/img/grid.png&#34; alt=&#34;Screenshot: gcloud-compute.com - Instance Picker&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Comparison&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gcloud-compute.com/comparison/e2-standard-4/vs/t2a-standard-4.html&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cyclenerd/google-cloud-compute-machine-types/master/img/compare.png&#34; alt=&#34;Screenshot: gcloud-compute.com - Comparison&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üñäÔ∏è Add, edit or change machine type information&lt;/h2&gt; &#xA;&lt;p&gt;The Google Compute Engine API is used to get all machine types in all regions and zones. Additional information is read via SQL files during the build process. Dive into the &lt;a href=&#34;https://raw.githubusercontent.com/Cyclenerd/google-cloud-compute-machine-types/master/build/&#34;&gt;build&lt;/a&gt; folder to see how the data is retrieved, processed, and integrated. Feel free to explore and contribute!&lt;/p&gt; &#xA;&lt;h2&gt;‚ù§Ô∏è Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Have a patch that will benefit this project? Awesome! Follow these steps to have it accepted.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Please read &lt;a href=&#34;https://raw.githubusercontent.com/Cyclenerd/google-cloud-compute-machine-types/master/CONTRIBUTING.md&#34;&gt;how to contribute&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Fork this Git repository and make your changes.&lt;/li&gt; &#xA; &lt;li&gt;Create a Pull Request.&lt;/li&gt; &#xA; &lt;li&gt;Incorporate review feedback to your changes.&lt;/li&gt; &#xA; &lt;li&gt;Accepted!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;üìú License&lt;/h2&gt; &#xA;&lt;p&gt;All files in this repository are under the &lt;a href=&#34;https://raw.githubusercontent.com/Cyclenerd/google-cloud-compute-machine-types/master/LICENSE&#34;&gt;Apache License, Version 2.0&lt;/a&gt; unless noted otherwise.&lt;/p&gt; &#xA;&lt;p&gt;Portions of this webapp are modifications based on work created and shared by &lt;a href=&#34;https://developers.google.com/readme/policies&#34;&gt;Google&lt;/a&gt; and used according to terms described in the &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;Creative Commons 4.0 Attribution License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please note:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No warranty&lt;/li&gt; &#xA; &lt;li&gt;No official Google product&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>qpackers/qifs</title>
    <updated>2024-06-02T01:39:06Z</updated>
    <id>tag:github.com,2024-06-02:/qpackers/qifs</id>
    <link href="https://github.com/qpackers/qifs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;QIF corpus for QPACK encoder and decoder development&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;QIFs&lt;/h1&gt; &#xA;&lt;p&gt;This repository is for storing QIFs used in QPACK development and interop experiments.&lt;/p&gt; &#xA;&lt;h2&gt;Encoder Input&lt;/h2&gt; &#xA;&lt;p&gt;A QPACK encoder uses a QIF file as input. QIF files are stored in &lt;code&gt;qifs/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Encoder Output&lt;/h2&gt; &#xA;&lt;p&gt;A QPACK encoder produces a file whose format is described in &lt;a href=&#34;https://github.com/quicwg/base-drafts/wiki/QPACK-Offline-Interop&#34;&gt;QPACK Offline Interop&lt;/a&gt;. Outputs produced by various encoders are stored in &lt;code&gt;encoded/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;The encoder output server as the decoder input. The idea of the interop is to take a QIF file, encode it using an encoder from one distribution and decode it using a decoder from another distribution.&lt;/p&gt; &#xA;&lt;h2&gt;Converting HARs to QIFs&lt;/h2&gt; &#xA;&lt;p&gt;A HAR is easy to manufacture using any of the major browsers. On the other hand, a HAR is inconvenient for the kind of end-to-end testing that the interop suggests: they are difficult to generate and compare. A HAR can be converted to a QIF format using &lt;code&gt;bin/har2qif.pl&lt;/code&gt; program.&lt;/p&gt; &#xA;&lt;h2&gt;Comparing QIFs&lt;/h2&gt; &#xA;&lt;p&gt;QIFs are text files and can be compared using standard UNIX tools such as &lt;code&gt;diff(1)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Because both input and output QIF files can contain comments and, more importantly, because the decoding process may output header lists in a different order, &lt;code&gt;bin/sort-qif.pl&lt;/code&gt; is provided. Sample use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sh$ encode source.qif &amp;gt; encoded.bin&#xA;sh$ decode encoded.bin &amp;gt; result.qif&#xA;sh$ grep -v ^# source.qif &amp;gt; canonical-input.qif&#xA;sh$ sort-qif.pl --strip-comments result.qif &amp;gt; canonical-output.qif&#xA;sh$ diff canonical-input.qif canonical-output.qif&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>