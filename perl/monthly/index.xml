<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-01T01:53:59Z</updated>
  <subtitle>Monthly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Kong/lua-kong-nginx-module</title>
    <updated>2024-08-01T01:53:59Z</updated>
    <id>tag:github.com,2024-08-01:/Kong/lua-kong-nginx-module</id>
    <link href="https://github.com/Kong/lua-kong-nginx-module" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nginx C module to allow deeper control of Nginx behaviors by Kong Lua code&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Name&lt;/h1&gt; &#xA;&lt;p&gt;lua-kong-nginx-module - Nginx C module that exposes a Lua API to dynamically control Nginx&lt;/p&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#name&#34;&gt;Name&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#directives&#34;&gt;Directives&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#lua_kong_load_var_index&#34;&gt;lua_kong_load_var_index&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#lua_kong_set_static_tag&#34;&gt;lua_kong_set_static_tag&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#lua_kong_error_log_request_id&#34;&gt;lua_kong_error_log_request_id&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#variables&#34;&gt;Variables&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#kong_request_id&#34;&gt;$kong_request_id&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#methods&#34;&gt;Methods&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsdisable_session_reuse&#34;&gt;resty.kong.tls.disable_session_reuse&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsget_full_client_certificate_chain&#34;&gt;resty.kong.tls.get_full_client_certificate_chain&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsset_upstream_cert_and_key&#34;&gt;resty.kong.tls.set_upstream_cert_and_key&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsset_upstream_ssl_trusted_store&#34;&gt;resty.kong.tls.set_upstream_ssl_trusted_store&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsset_upstream_ssl_verify&#34;&gt;resty.kong.tls.set_upstream_ssl_verify&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsset_upstream_ssl_verify_depth&#34;&gt;resty.kong.tls.set_upstream_ssl_verify_depth&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsget_ssl_pointer&#34;&gt;resty.kong.tls.get_ssl_pointer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykonggrpcset_authority&#34;&gt;resty.kong.grpc.set_authority&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtlsdisable_proxy_ssl&#34;&gt;resty.kong.tls.disable_proxy_ssl&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongvarpatch_metatable&#34;&gt;resty.kong.var.patch_metatable&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtagget&#34;&gt;resty.kong.tag.get&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykonglogset_log_level&#34;&gt;resty.kong.log.set_log_level&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykonglogget_log_level&#34;&gt;resty.kong.log.get_log_level&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongpeer_connget_last_peer_connection_cached&#34;&gt;resty.kong.peer_conn.get_last_peer_connection_cached&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;Kong often needs to be able to change Nginx behavior at runtime. Traditionally this has been done using various core patches. This module attempts to unify those approaches and ensure the least amount of modifications made directly to Nginx to support future maintainability.&lt;/p&gt; &#xA;&lt;p&gt;Patches from &lt;a href=&#34;https://github.com/Kong/kong-build-tools/tree/master/openresty-patches/patches&#34;&gt;openresty-patches&lt;/a&gt; are &lt;strong&gt;required&lt;/strong&gt; for this module to compile successfully. You may use the &lt;a href=&#34;https://github.com/Kong/kong-build-tools/tree/master/openresty-build-tools&#34;&gt;openresty-build-tools&lt;/a&gt; script to automatically build an OpenResty binary with required patches as well as this module included.&lt;/p&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;p&gt;This module can be installed just like any ordinary Nginx C module, using the &lt;code&gt;--add-module&lt;/code&gt; configuration option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./configure --prefix=/usr/local/kong-nginx \&#xA;            --add-module=/path/to/lua-kong-nginx-module \&#xA;            ...&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Directives&lt;/h1&gt; &#xA;&lt;h2&gt;lua_kong_load_var_index&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;lua_kong_load_var_index $variable | default;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ensure &lt;em&gt;variable&lt;/em&gt; is indexed. Note that variables defined by &lt;code&gt;set&lt;/code&gt; directive are always indexed by default and does not need to be defined here again.&lt;/p&gt; &#xA;&lt;p&gt;Common variables defined by other modules that are already indexed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$proxy_host&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$proxy_internal_body_length&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$proxy_internal_chunked&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$remote_addr&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$remote_user&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$request&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_referer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_user_agent&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$host&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Specially, use &lt;code&gt;lua_kong_load_var_index default&lt;/code&gt; to index &lt;em&gt;commonly used variables&lt;/em&gt; as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$args&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$is_args&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$bytes_sent&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$content_type&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_authorization&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_connection&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_host&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_kong_debug&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_proxy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_proxy_connection&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_te&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_upgrade&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_forwarded_for&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_forwarded_host&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_forwarded_path&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_forwarded_port&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_forwarded_prefix&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_forwarded_proto&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_kong_request_debug&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_kong_request_debug_token&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http_x_kong_request_debug_log&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$https&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$http2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$realip_remote_addr&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$realip_remote_port&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$remote_port&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$request_length&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$request_method&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$request_time&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$request_uri&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$scheme&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$server_addr&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$server_port&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$ssl_cipher&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$ssl_client_raw_cert&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$ssl_client_verify&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$ssl_protocol&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$ssl_server_name&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$upstream_http_connection&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$upstream_http_trailer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$upstream_http_upgrade&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$upstream_status&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongvarpatch_metatable&#34;&gt;resty.kong.var.patch_metatable&lt;/a&gt; on how to enable indexed variable access.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;lua_kong_set_static_tag&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;lua_kong_set_static_tag value;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;location(http subsystem)&lt;/em&gt; &lt;em&gt;server(stream subsystem)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add a static tag string for Nginx&#39;s &lt;code&gt;location&lt;/code&gt;(http subsystem) or &lt;code&gt;server&lt;/code&gt;(stream subsystem) block, which can be accessed in Lua land by &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#restykongtagget&#34;&gt;&lt;code&gt;resty.kong.tag.get&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Notice: the value of tag is bound with the &lt;code&gt;location&lt;/code&gt;(http subsystem) or &lt;code&gt;server&lt;/code&gt;(stream subsystem) block where it is defined. So if you defined multi tags in different &lt;code&gt;location&lt;/code&gt;(http subsystem) or &lt;code&gt;server&lt;/code&gt;(stream subsystem) block, you will always get the value where your Lua code runs in but not others.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;lua_kong_error_log_request_id&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;lua_kong_error_log_request_id $variable;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;server&lt;/em&gt; &lt;em&gt;location&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Append a Request ID to the standard error log format, load the ID value from &lt;code&gt;$variable&lt;/code&gt;. &lt;code&gt;$variable&lt;/code&gt; must be previously defined.&lt;/p&gt; &#xA;&lt;p&gt;For example, with this configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;lua_kong_error_log_request_id $request_id;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An error log line may look similar to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2023/09/06 11:33:36 [error] 94085#0: *6 [lua] content_by_lua(nginx.conf:27):7: hello world, client: 127.0.0.1, server: , request: &#34;GET /foo HTTP/1.1&#34;, host: &#34;localhost:8080&#34;, request_id: &#34;cd7706e903db672ac5fac333bc8db5ed&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Variables&lt;/h1&gt; &#xA;&lt;h2&gt;$kong_request_id&lt;/h2&gt; &#xA;&lt;p&gt;Unique request identifier generated from 16 pseudo-random bytes, in hexadecimal. This variable is indexed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Methods&lt;/h1&gt; &#xA;&lt;h2&gt;resty.kong.tls.disable_session_reuse&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;succ, err = resty.kong.tls.disable_session_reuse()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;ssl_certificate_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Prevents the TLS session for the current connection from being reused by disabling session ticket and session ID for the current TLS connection.&lt;/p&gt; &#xA;&lt;p&gt;This function returns &lt;code&gt;true&lt;/code&gt; when the call is successful. Otherwise it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tls.get_full_client_certificate_chain&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;pem_chain, err = resty.kong.tls.get_full_client_certificate_chain()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*&lt;/em&gt;, &lt;em&gt;preread_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Returns the PEM encoded downstream client certificate chain with the client certificate at the top and intermediate certificates (if any) at the bottom.&lt;/p&gt; &#xA;&lt;p&gt;If client did not present any certificate or if session was reused, then this function will return &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is functionally similar to &lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_ssl_module.html#var_ssl_client_raw_cert&#34;&gt;$ssl_client_raw_cert&lt;/a&gt; provided by &lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_ssl_module.html&#34;&gt;ngx_http_ssl_module&lt;/a&gt;, with the notable exception that this function also returns any certificate chain client sent during handshake.&lt;/p&gt; &#xA;&lt;p&gt;If the TLS session was reused, (signaled by &lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_ssl_module.html#var_ssl_session_reused&#34;&gt;$ssl_session_reused&lt;/a&gt; returns &#34;r&#34;), then no client certificate information will be available as a full handshake never occurred. In this case caller should use &lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_ssl_module.html#var_ssl_session_id&#34;&gt;$ssl_session_id&lt;/a&gt; to associate this session with one of the previous handshakes to identify the connecting client.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tls.set_upstream_cert_and_key&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = resty.kong.tls.set_upstream_cert_and_key(chain, key)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, balancer_by_lua*&lt;/em&gt;, &lt;em&gt;preread_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Overrides and enables sending client certificate while connecting to the upstream in the current request.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;chain&lt;/code&gt; is the client certificate and intermediate chain (if any) returned by functions such as &lt;a href=&#34;https://github.com/openresty/lua-resty-core/raw/master/lib/ngx/ssl.md#parse_pem_cert&#34;&gt;ngx.ssl.parse_pem_cert&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;key&lt;/code&gt; is the private key corresponding to the client certificate returned by functions such as &lt;a href=&#34;https://github.com/openresty/lua-resty-core/raw/master/lib/ngx/ssl.md#parse_pem_priv_key&#34;&gt;ngx.ssl.parse_pem_priv_key&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On success, this function returns &lt;code&gt;true&lt;/code&gt; and future handshakes with upstream servers will always use the provided client certificate. Otherwise &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.&lt;/p&gt; &#xA;&lt;p&gt;This function can be called multiple times in the same request. Later calls override previous ones.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tls.set_upstream_ssl_trusted_store&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = resty.kong.tls.set_upstream_ssl_trusted_store(store)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, balancer_by_lua*&lt;/em&gt;, &lt;em&gt;preread_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Set upstream ssl verification trusted store of current request. Global setting set by &lt;code&gt;proxy_ssl_trusted_certificate&lt;/code&gt; will be overwritten for the current request.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;store&lt;/code&gt; is a table object that can be created by &lt;a href=&#34;https://github.com/fffonion/lua-resty-openssl#storenew&#34;&gt;resty.openssl.x509.store.new&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On success, this function returns &lt;code&gt;true&lt;/code&gt; and future handshakes with upstream servers will be verified with given store. Otherwise &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.&lt;/p&gt; &#xA;&lt;p&gt;This function can be called multiple times in the same request. Later calls override previous ones.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local x509 = require(&#34;resty.openssl.x509&#34;)&#xA;local crt, err = x509.new([[-----BEGIN CERTIFICATE-----&#xA;...&#xA;-----END CERTIFICATE-----]])&#xA;if err then&#xA;    ngx.log(ngx.ERR, &#34;failed to parse cert: &#34;, err)&#xA;    ngx.exit(500)&#xA;end&#xA;local store = require(&#34;resty.openssl.x509.store&#34;)&#xA;local st, err = store.new()&#xA;if err then&#xA;    ngx.log(ngx.ERR, &#34;failed to create store: &#34;, err)&#xA;    ngx.exit(500)&#xA;end&#xA;local ok, err = st:add(crt)&#xA;if err then&#xA;    ngx.log(ngx.ERR, &#34;failed to add cert to store: &#34;, err)&#xA;    ngx.exit(500)&#xA;end&#xA;-- st:add can be called multiple times, also accept a crl&#xA;-- st:add(another_crt)&#xA;-- st:add(crl)&#xA;-- OR&#xA;-- st:use_default() to load default CA bundle&#xA;local tls = require(&#34;resty.kong.tls&#34;)&#xA;local ok, err = tls.set_upstream_ssl_trusted_store(st.ctx)&#xA;if err then&#xA;    ngx.log(ngx.ERR, &#34;failed to set upstream trusted store: &#34;, err)&#xA;    ngx.exit(500)&#xA;end&#xA;local ok, err = tls.set_upstream_ssl_verify(true)&#xA;if err then&#xA;    ngx.log(ngx.ERR, &#34;failed to set upstream ssl verify: &#34;, err)&#xA;    ngx.exit(500)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tls.set_upstream_ssl_verify&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = resty.kong.tls.set_upstream_ssl_verify(verify)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, balancer_by_lua*&lt;/em&gt;, &lt;em&gt;preread_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Set upstream ssl verification enablement of current request to the given boolean argument &lt;code&gt;verify&lt;/code&gt;. Global setting set by &lt;code&gt;proxy_ssl_verify&lt;/code&gt; will be overwritten.&lt;/p&gt; &#xA;&lt;p&gt;On success, this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.&lt;/p&gt; &#xA;&lt;p&gt;This function can be called multiple times in the same request. Later calls override previous ones.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tls.set_upstream_ssl_verify_depth&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = resty.kong.tls.set_upstream_ssl_verify_depth(depth)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, balancer_by_lua*&lt;/em&gt;, &lt;em&gt;preread_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Set upstream ssl verification depth of current request to the given non-negative integer argument &lt;code&gt;depth&lt;/code&gt;. Global setting set by &lt;code&gt;proxy_ssl_verify_depth&lt;/code&gt; will be overwritten.&lt;/p&gt; &#xA;&lt;p&gt;On success, this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.&lt;/p&gt; &#xA;&lt;p&gt;This function can be called multiple times in the same request. Later calls override previous ones.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tls.get_ssl_pointer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ssl_ptr, err = resty.kong.tls.get_ssl_pointer(sock)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*&lt;/em&gt;, &lt;em&gt;preread_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Retrieves the OpenSSL &lt;code&gt;SSL*&lt;/code&gt; object for the current tcpsock &lt;code&gt;sock&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On success, this function returns the pointer of type &lt;code&gt;SSL&lt;/code&gt;. Otherwise &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.grpc.set_authority&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = resty.kong.grpc.set_authority(new_authority)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, balancer_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Overrides the &lt;code&gt;:authority&lt;/code&gt; pseudo header sent to gRPC upstream by &lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_grpc_module.html&#34;&gt;ngx_http_grpc_module&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function is a capability not possible in Nginx through means of config directive alone. Reason being Nginx auto-generates the &lt;code&gt;:authority&lt;/code&gt; pseudo header without giving us a way to override it at config time. Closest being &lt;code&gt;grpc_set_header Host &#34;foo.example.com&#34;&lt;/code&gt;, but this will cause the gRPC module to use the &lt;code&gt;Host&lt;/code&gt; header and not generate the &lt;code&gt;:authority&lt;/code&gt; pseudo header, causing problems for certain gRPC server.&lt;/p&gt; &#xA;&lt;p&gt;When called, this function accepts a new value to override the &lt;code&gt;:authority&lt;/code&gt; pseudo header that will be generated by the ngx_http_grpc_module for the current request.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;new_authority&lt;/code&gt; parameter &lt;strong&gt;can not&lt;/strong&gt; be an empty string.&lt;/p&gt; &#xA;&lt;p&gt;On success, this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.&lt;/p&gt; &#xA;&lt;p&gt;This function can be called multiple times in the same request. Later calls override previous ones.&lt;/p&gt; &#xA;&lt;p&gt;If called in the &lt;code&gt;balancer_by_lua&lt;/code&gt; context, the request needs to be recreated (see &lt;a href=&#34;https://github.com/openresty/lua-resty-core/raw/master/lib/ngx/balancer.md#recreate_request&#34;&gt;balancer.recreate&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tls.disable_proxy_ssl&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = resty.kong.tls.disable_proxy_ssl()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;preread_by_lua*, balancer_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Disables the TLS handshake to upstream for &lt;a href=&#34;https://nginx.org/en/docs/stream/ngx_stream_proxy_module.html&#34;&gt;ngx_stream_proxy_module&lt;/a&gt;. Effectively this overrides &lt;a href=&#34;https://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_ssl&#34;&gt;proxy_ssl&lt;/a&gt; directive to &lt;code&gt;off&lt;/code&gt; setting for the current stream session.&lt;/p&gt; &#xA;&lt;p&gt;This function has no side effects if the &lt;code&gt;proxy_ssl off;&lt;/code&gt; setting has already been specified inside &lt;code&gt;nginx.conf&lt;/code&gt; or if this function has been previously called from the current session.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.var.patch_metatable&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;resty.kong.var.patch_metatable()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;init_by_lua&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Indexed variable access is a faster way of accessing Nginx variables for OpenResty. This method patches the metatable of &lt;code&gt;ngx.var&lt;/code&gt; to enable index access to variables that supports it. It should be called once in the &lt;code&gt;init&lt;/code&gt; phase which will be effective for all subsequent &lt;code&gt;ngx.var&lt;/code&gt; uses.&lt;/p&gt; &#xA;&lt;p&gt;For variables that does not have indexed access, the slower hash based lookup will be used instead (this is the OpenResty default behavior).&lt;/p&gt; &#xA;&lt;p&gt;To ensure a variable can be accessed using index, you can use the &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#lua_kong_load_var_index&#34;&gt;lua_kong_load_var_index&lt;/a&gt; directive.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.tag.get&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;resty.kong.tag.get()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*, header_filter_by_lua*, body_filter_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Return the tag value which is set by &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#lua_kong_set_static_tag&#34;&gt;&lt;code&gt;lua_kong_set_static_tag&lt;/code&gt;&lt;/a&gt; directive.&lt;/p&gt; &#xA;&lt;p&gt;If there is no tag in &lt;code&gt;location&lt;/code&gt;(http subsystems) or &lt;code&gt;server&lt;/code&gt;(stream subsystems) block, it will return &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.log.set_log_level&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;resty.kong.log.set_log_level(level, timeout)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;any&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Dynamically configures the &lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#error_log&#34;&gt;level&lt;/a&gt; with a timeout for the current worker, and &lt;strong&gt;must&lt;/strong&gt; be one of the &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#nginx-log-level-constants&#34;&gt;Nginx log level constants&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;timeout&lt;/code&gt; specifies a number of seconds after which the log level will be reset to the previous value. If &lt;code&gt;timeout&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the log level will be reset to the default &lt;code&gt;log_level&lt;/code&gt; setting from Nginx configuration immediately.&lt;/p&gt; &#xA;&lt;p&gt;If this method is called again before the timeout, the log level and timeout will be overwritten.&lt;/p&gt; &#xA;&lt;p&gt;If we don’t pass timeout to set_log_level(), it will raise a Lua error. &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.log.get_log_level&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;current_level, timeout, original_level = resty.kong.log.get_log_level()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;any&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Returns the current dynamic log level, remaining timeout (in seconds), and the original log level.&lt;/p&gt; &#xA;&lt;p&gt;If the dynamic log level is not set or not active, the &lt;code&gt;timeout&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#nginx-log-level-constants&#34;&gt;Nginx log level constants&lt;/a&gt; for the possible value of &lt;code&gt;level&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;resty.kong.peer_conn.get_last_peer_connection_cached&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;res = resty.kong.peer_conn.get_last_peer_connection_cached()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;balancer_by_lua&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;subsystems:&lt;/strong&gt; &lt;em&gt;http&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;This function retrieves information about whether the connection used in the previous attempt came from the upstream connection pool when the next_upstream retrying mechanism is in action.&lt;/p&gt; &#xA;&lt;p&gt;The possible results are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;false&lt;/code&gt;: Indicates the connection was not reused from the upstream connection pool, meaning a new connection was created with the upstream in the previous attempt.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;true&lt;/code&gt;: Indicates the connection was reused from the upstream connection pool, meaning no new connection was created with the upstream in the previous attempt.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After applying the &lt;a href=&#34;https://github.com/Kong/kong/raw/3.6.0/build/openresty/patches/ngx_lua-0.10.26_01-dyn_upstream_keepalive.patch&#34;&gt;dynamic upstream keepalive patch&lt;/a&gt;, Nginx&#39;s upstream module attempts to retrieve connections from the upstream connection pool for each retry. If the obtained connection is deemed unusable, Nginx considers that retry invalid and performs a compensatory retry.&lt;/p&gt; &#xA;&lt;p&gt;Since each retry triggers the &lt;code&gt;balancer_by_lua&lt;/code&gt; phase, the number of retries logged in Lua land during this phase may exceed the maximum limit set by &lt;code&gt;set_more_tries&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Using this function in the &lt;code&gt;balancer_by_lua&lt;/code&gt; phase allows for determining if the connection used in the previous retry was taken from the connection pool. If the return value is &lt;code&gt;true&lt;/code&gt;, it indicates that the connection from the pool used in the previous retry was unusable, rendering that retry void.&lt;/p&gt; &#xA;&lt;p&gt;The value returned by this function helps in accurately assessing the actual number of new connections established with the upstream server during the retry process during the &lt;code&gt;balancer_by_lua phase&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;balancer_by_lua_block {&#xA;    local ctx = ngx.ctx&#xA;&#xA;    ctx.tries = ctx.tries or {}&#xA;    local tries = ctx.tries&#xA;&#xA;    -- update the number of tries&#xA;    local try_count = #tries + 1&#xA;&#xA;    -- fetch the last peer connection cached&#xA;    local peer_conn = require(&#34;resty.kong.peer_conn&#34;)&#xA;    local last_peer_connection_cached = peer_conn.get_last_peer_connection_cached()&#xA;    if try_count &amp;gt; 1 then&#xA;        local previous_try = tries[try_count - 1]&#xA;        previous_try.cached = peer_conn.get_last_peer_connection_cached()&#xA;    else&#xA;        tries[try_count].cached = false&#xA;    end&#xA;    &#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2020-2023 Kong Inc.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-kong-nginx-module/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>