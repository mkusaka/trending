<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-04T02:49:32Z</updated>
  <subtitle>Monthly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jimsalterjrs/sanoid</title>
    <updated>2022-06-04T02:49:32Z</updated>
    <id>tag:github.com,2022-06-04:/jimsalterjrs/sanoid</id>
    <link href="https://github.com/jimsalterjrs/sanoid" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Policy-driven snapshot management and replication tools. Using ZFS for underlying next-gen storage. (Btrfs support plans are shelved unless and until btrfs becomes reliable.) Primarily intended for Linux, but BSD use is supported and reasonably frequently tested.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;http://www.openoid.net/wp-content/themes/openoid/images/sanoid_logo.png&#34; alt=&#34;sanoid logo&#34; title=&#34;sanoid logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://openoid.net/gplv3-127x51.png&#34; width=&#34;127&#34; height=&#34;51&#34; align=&#34;right&#34;&gt;Sanoid is a policy-driven snapshot management tool for ZFS filesystems. When combined with the Linux KVM hypervisor, you can use it to make your systems &lt;a href=&#34;http://openoid.net/transcend&#34; target=&#34;_blank&#34;&gt;functionally immortal&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://youtu.be/ZgowLNBsu00&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://www.openoid.net/sanoid_video_launcher.png&#34; alt=&#34;sanoid rollback demo&#34; title=&#34;sanoid rollback demo&#34;&gt;&lt;/a&gt;&lt;br clear=&#34;all&#34;&gt;&lt;sup&gt;(Real time demo: rolling back a full-scale cryptomalware infection in seconds!)&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;More prosaically, you can use Sanoid to create, automatically thin, and monitor snapshots and pool health from a single eminently human-readable TOML config file at /etc/sanoid/sanoid.conf. (Sanoid also requires a &#34;defaults&#34; file located at /etc/sanoid/sanoid.defaults.conf, which is not user-editable.) A typical Sanoid system would have a single cron job but see INSTALL.md fore more details:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* * * * * TZ=UTC /usr/local/bin/sanoid --cron&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Note&lt;/code&gt;: Using UTC as timezone is recommend to prevent problems with daylight saving times&lt;/p&gt; &#xA;&lt;p&gt;And its /etc/sanoid/sanoid.conf might look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[data/home]&#xA;&#x9;use_template = production&#xA;[data/images]&#xA;&#x9;use_template = production&#xA;&#x9;recursive = yes&#xA;&#x9;process_children_only = yes&#xA;[data/images/win7]&#xA;&#x9;hourly = 4&#xA;&#xA;#############################&#xA;# templates below this line #&#xA;#############################&#xA;&#xA;[template_production]&#xA;        frequently = 0&#xA;        hourly = 36&#xA;        daily = 30&#xA;        monthly = 3&#xA;        yearly = 0&#xA;        autosnap = yes&#xA;        autoprune = yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which would be enough to tell sanoid to take and keep 36 hourly snapshots, 30 dailies, 3 monthlies, and no yearlies for all datasets under data/images (but not data/images itself, since process_children_only is set). Except in the case of data/images/win7, which follows the same template (since it&#39;s a child of data/images) but only keeps 4 hourlies for whatever reason.&lt;/p&gt; &#xA;&lt;p&gt;For more full details on sanoid.conf settings see &lt;a href=&#34;https://github.com/jimsalterjrs/sanoid/wiki/Sanoid#options&#34;&gt;Wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Be aware that if you don&#39;t specify some interval options the defaults will be used (from /etc/sanoid/sanoid.defaults.conf)&lt;/p&gt; &#xA;&lt;h5&gt;Sanoid Command Line Options&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;--cron&lt;/p&gt; &lt;p&gt;This will process your sanoid.conf file, create snapshots, then purge expired ones.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--configdir&lt;/p&gt; &lt;p&gt;Specify a location for the config file named sanoid.conf. Defaults to /etc/sanoid&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--cache-dir&lt;/p&gt; &lt;p&gt;Specify a directory to store the zfs snapshot cache. Defaults to /var/cache/sanoid&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--run-dir&lt;/p&gt; &lt;p&gt;Specify a directory for temporary files such as lock files. Defaults to /var/run/sanoid&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--take-snapshots&lt;/p&gt; &lt;p&gt;This will process your sanoid.conf file, create snapshots, but it will NOT purge expired ones. (Note that snapshots taken are atomic in an individual dataset context, &lt;i&gt;not&lt;/i&gt; a global context - snapshots of pool/dataset1 and pool/dataset2 will each be internally consistent and atomic, but one may be a few filesystem transactions &#34;newer&#34; than the other.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--prune-snapshots&lt;/p&gt; &lt;p&gt;This will process your sanoid.conf file, it will NOT create snapshots, but it will purge expired ones.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--force-prune&lt;/p&gt; &lt;p&gt;Purges expired snapshots even if a send/recv is in progress&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--monitor-snapshots&lt;/p&gt; &lt;p&gt;This option is designed to be run by a Nagios monitoring system. It reports on the health of your snapshots.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--monitor-health&lt;/p&gt; &lt;p&gt;This option is designed to be run by a Nagios monitoring system. It reports on the health of the zpool your filesystems are on. It only monitors filesystems that are configured in the sanoid.conf file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--monitor-capacity&lt;/p&gt; &lt;p&gt;This option is designed to be run by a Nagios monitoring system. It reports on the capacity of the zpool your filesystems are on. It only monitors pools that are configured in the sanoid.conf file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--force-update&lt;/p&gt; &lt;p&gt;This clears out sanoid&#39;s zfs snapshot listing cache. This is normally not needed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--version&lt;/p&gt; &lt;p&gt;This prints the version number, and exits.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--quiet&lt;/p&gt; &lt;p&gt;Supress non-error output.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--verbose&lt;/p&gt; &lt;p&gt;This prints additional information during the sanoid run.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--debug&lt;/p&gt; &lt;p&gt;This prints out quite alot of additional information during a sanoid run, and is normally not needed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--readonly&lt;/p&gt; &lt;p&gt;Skip creation/deletion of snapshots (Simulate).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--help&lt;/p&gt; &lt;p&gt;Show help message.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Sanoid script hooks&lt;/h3&gt; &#xA;&lt;p&gt;There are three script types which can optionally be executed at various stages in the lifecycle of a snapshot:&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;pre_snapshot_script&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Will be executed before the snapshot(s) of a single dataset are taken. The following environment variables are passed:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Env vars&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SCRIPT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The type of script being executed, one of &lt;code&gt;pre&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, or &lt;code&gt;prune&lt;/code&gt;. Allows for one script to be used for multiple tasks&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_TARGET&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;DEPRECATED&lt;/strong&gt; The dataset about to be snapshot (only the first dataset will be provided)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_TARGETS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Comma separated list of all datasets to be snapshoted (currently only a single dataset, multiple datasets will be possible later with atomic groups)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SNAPNAME&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;DEPRECATED&lt;/strong&gt; The name of the snapshot that will be taken (only the first name will be provided, does not include the dataset name)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SNAPNAMES&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Comma separated list of all snapshot names that will be taken (does not include the dataset name)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_TYPES&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Comma separated list of all snapshot types to be taken (yearly, monthly, weekly, daily, hourly, frequently)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;If the script returns a non-zero exit code, the snapshot(s) will not be taken unless &lt;code&gt;no_inconsistent_snapshot&lt;/code&gt; is false.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;post_snapshot_script&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Will be executed when:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The pre-snapshot script succeeded or&lt;/li&gt; &#xA; &lt;li&gt;The pre-snapshot script failed and &lt;code&gt;force_post_snapshot_script&lt;/code&gt; is true.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Env vars&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SCRIPT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_TARGET&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;DEPRECATED&lt;/strong&gt; as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_TARGETS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SNAPNAME&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;DEPRECATED&lt;/strong&gt; as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SNAPNAMES&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_TYPES&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_PRE_FAILURE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;This will indicate if the pre-snapshot script failed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;&lt;code&gt;pruning_script&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Will be executed after a snapshot is successfully deleted. The following environment variables will be passed:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Env vars&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SCRIPT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_TARGET&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;SANOID_SNAPNAME&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;as above&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;example&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;sanoid.conf&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;...&#xA;[sanoid-test-0]&#xA;&#x9;use_template = production&#xA;&#x9;recursive = yes&#xA;&#x9;pre_snapshot_script = /tmp/debug.sh&#xA;&#x9;post_snapshot_script = /tmp/debug.sh&#xA;&#x9;pruning_script = /tmp/debug.sh&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;verbose sanoid output&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;...&#xA;executing pre_snapshot_script &#39;/tmp/debug.sh&#39; on dataset &#39;sanoid-test-0&#39;&#xA;taking snapshot sanoid-test-0@autosnap_2020-02-12_14:49:33_yearly&#xA;taking snapshot sanoid-test-0@autosnap_2020-02-12_14:49:33_monthly&#xA;taking snapshot sanoid-test-0@autosnap_2020-02-12_14:49:33_daily&#xA;taking snapshot sanoid-test-0@autosnap_2020-02-12_14:49:33_hourly&#xA;executing post_snapshot_script &#39;/tmp/debug.sh&#39; on dataset &#39;sanoid-test-0&#39;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;pre script env variables&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SANOID_SCRIPT=pre&#xA;SANOID_TARGET=sanoid-test-0/b/bb&#xA;SANOID_TARGETS=sanoid-test-0/b/bb&#xA;SANOID_SNAPNAME=autosnap_2020-02-12_14:49:32_yearly&#xA;SANOID_SNAPNAMES=autosnap_2020-02-12_14:49:32_yearly,autosnap_2020-02-12_14:49:32_monthly,autosnap_2020-02-12_14:49:32_daily,autosnap_2020-02-12_14:49:32_hourly&#xA;SANOID_TYPES=yearly,monthly,daily,hourly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;post script env variables&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SANOID_SCRIPT=post&#xA;SANOID_TARGET=sanoid-test-0/b/bb&#xA;SANOID_TARGETS=sanoid-test-0/b/bb&#xA;SANOID_SNAPNAME=autosnap_2020-02-12_14:49:32_yearly&#xA;SANOID_SNAPNAMES=autosnap_2020-02-12_14:49:32_yearly,autosnap_2020-02-12_14:49:32_monthly,autosnap_2020-02-12_14:49:32_daily,autosnap_2020-02-12_14:49:32_hourly&#xA;SANOID_TYPES=yearly,monthly,daily,hourly&#xA;SANOID_PRE_FAILURE=0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Syncoid&lt;/h1&gt; &#xA;&lt;p&gt;Sanoid also includes a replication tool, syncoid, which facilitates the asynchronous incremental replication of ZFS filesystems. A typical syncoid command might look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;syncoid data/images/vm backup/images/vm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which would replicate the specified ZFS filesystem (aka dataset) from the data pool to the backup pool on the local system, or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;syncoid data/images/vm root@remotehost:backup/images/vm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which would push-replicate the specified ZFS filesystem from the local host to remotehost over an SSH tunnel, or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;syncoid root@remotehost:data/images/vm backup/images/vm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which would pull-replicate the filesystem from the remote host to the local system over an SSH tunnel.&lt;/p&gt; &#xA;&lt;p&gt;Syncoid supports recursive replication (replication of a dataset and all its child datasets) and uses mbuffer buffering, lzop compression, and pv progress bars if the utilities are available on the systems used. If ZFS supports resumeable send/receive streams on both the source and target those will be enabled as default.&lt;/p&gt; &#xA;&lt;p&gt;As of 1.4.18, syncoid also automatically supports and enables resume of interrupted replication when both source and target support this feature.&lt;/p&gt; &#xA;&lt;h5&gt;Syncoid Dataset Properties&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;syncoid:sync&lt;/p&gt; &lt;p&gt;Available values:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;true&lt;/code&gt; (default if unset)&lt;/p&gt; &lt;p&gt;This dataset will be synchronised to all hosts.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;false&lt;/code&gt;&lt;/p&gt; &lt;p&gt;This dataset will not be synchronised to any hosts - it will be skipped. This can be useful for preventing certain datasets from being transferred when recursively handling a tree.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;host1,host2,...&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A comma separated list of hosts. This dataset will only be synchronised by hosts listed in the property.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: this check is performed by the host running &lt;code&gt;syncoid&lt;/code&gt;, thus the local hostname must be present for inclusion during a push operation // the remote hostname must be present for a pull.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: this will also prevent syncoid from handling the dataset if given explicitly on the command line.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: syncing a child of a no-sync dataset will currently result in a critical error.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: empty properties will be handled as if they were unset.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Syncoid Command Line Options&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[source]&lt;/p&gt; &lt;p&gt;This is the source dataset. It can be either local or remote.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[destination]&lt;/p&gt; &lt;p&gt;This is the destination dataset. It can be either local or remote.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--identifier=&lt;/p&gt; &lt;p&gt;Adds the given identifier to the snapshot name after &#34;syncoid_&#34; prefix and before the hostname. This enables the use case of reliable replication to multiple targets from the same host. The following chars are allowed: a-z, A-Z, 0-9, _, -, : and . .&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;-r --recursive&lt;/p&gt; &lt;p&gt;This will also transfer child datasets.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--skip-parent&lt;/p&gt; &lt;p&gt;This will skip the syncing of the parent dataset. Does nothing without &#39;--recursive&#39; option.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--compress &#xA;   &lt;compression type&gt;&lt;/compression&gt;&lt;/p&gt; &lt;p&gt;Currently accepted options: gzip, pigz-fast, pigz-slow, zstd-fast, zstd-slow, lz4, xz, lzo (default) &amp;amp; none. If the selected compression method is unavailable on the source and destination, no compression will be used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--source-bwlimit &amp;lt;limit t|g|m|k&amp;gt;&lt;/p&gt; &lt;p&gt;This is the bandwidth limit in bytes (kbytes, mbytes, etc) per second imposed upon the source. This is mainly used if the target does not have mbuffer installed, but bandwidth limits are desired.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--target-bwlimit &amp;lt;limit t|g|m|k&amp;gt;&lt;/p&gt; &lt;p&gt;This is the bandwidth limit in bytes (kbytes, mbytesm etc) per second imposed upon the target. This is mainly used if the source does not have mbuffer installed, but bandwidth limits are desired.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-command-checks&lt;/p&gt; &lt;p&gt;Does not check the existence of commands before attempting the transfer, providing administrators a way to run the tool with minimal overhead and maximum speed, at risk of potentially failed replication, or other possible edge cases. It assumes all programs are available, and should not be used in most situations. This is an not an officially supported run mode.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-stream&lt;/p&gt; &lt;p&gt;This argument tells syncoid to use -i incrementals, not -I. This updates the target with the newest snapshot from the source, without replicating the intermediate snapshots in between. (If used for an initial synchronization, will do a full replication from newest snapshot and exit immediately, rather than starting with the oldest and then doing an immediate -i to the newest.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-sync-snap&lt;/p&gt; &lt;p&gt;This argument tells syncoid to restrict itself to existing snapshots, instead of creating a semi-ephemeral syncoid snapshot at execution time. Especially useful in multi-target (A-&amp;gt;B, A-&amp;gt;C) replication schemes, where you might otherwise accumulate a large number of foreign syncoid snapshots.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--keep-sync-snap&lt;/p&gt; &lt;p&gt;This argument tells syncoid to skip pruning old snapshots created and used by syncoid for replication if &#39;--no-sync-snap&#39; isn&#39;t specified.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--create-bookmark&lt;/p&gt; &lt;p&gt;This argument tells syncoid to create a zfs bookmark for the newest snapshot after it got replicated successfully. The bookmark name will be equal to the snapshot name. Only works in combination with the --no-sync-snap option. This can be very useful for irregular replication where the last matching snapshot on the source was already deleted but the bookmark remains so a replication is still possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--preserve-recordsize&lt;/p&gt; &lt;p&gt;This argument tells syncoid to set the recordsize on the target before writing any data to it matching the one set on the replication src. This only applies to initial sends.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-clone-rollback&lt;/p&gt; &lt;p&gt;Do not rollback clones on target&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-rollback&lt;/p&gt; &lt;p&gt;Do not rollback anything (clones or snapshots) on target host&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--exclude=REGEX&lt;/p&gt; &lt;p&gt;The given regular expression will be matched against all datasets which would be synced by this run and excludes them. This argument can be specified multiple times.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-resume&lt;/p&gt; &lt;p&gt;This argument tells syncoid to not use resumeable zfs send/receive streams.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--force-delete&lt;/p&gt; &lt;p&gt;Remove target datasets recursively (WARNING: this will also affect child datasets with matching snapshots/bookmarks), if there are no matching snapshots/bookmarks.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-clone-handling&lt;/p&gt; &lt;p&gt;This argument tells syncoid to not recreate clones on the targe on initial sync and doing a normal replication instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--dumpsnaps&lt;/p&gt; &lt;p&gt;This prints a list of snapshots during the run.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--no-privilege-elevation&lt;/p&gt; &lt;p&gt;Bypass the root check and assume syncoid has the necessary permissions (for use with ZFS permission delegation).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--sshport&lt;/p&gt; &lt;p&gt;Allow sync to/from boxes running SSH on non-standard ports.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--sshcipher&lt;/p&gt; &lt;p&gt;Instruct ssh to use a particular cipher set.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--sshoption&lt;/p&gt; &lt;p&gt;Passes option to ssh. This argument can be specified multiple times.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--sshkey&lt;/p&gt; &lt;p&gt;Use specified identity file as per ssh -i.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--quiet&lt;/p&gt; &lt;p&gt;Supress non-error output.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--debug&lt;/p&gt; &lt;p&gt;This prints out quite alot of additional information during a sanoid run, and is normally not needed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--help&lt;/p&gt; &lt;p&gt;Show help message.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--version&lt;/p&gt; &lt;p&gt;Print the version and exit.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;--monitor-version&lt;/p&gt; &lt;p&gt;This doesn&#39;t do anything right now.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that the sync snapshots syncoid creates are not atomic in a global context: sync snapshots of pool/dataset1 and pool/dataset2 will each be internally consistent, but one may be a few filesystem transactions &#34;newer&#34; than the other. (This does not affect the consistency of snapshots already taken in other ways, which syncoid replicates in the overall stream unless --no-stream is specified. So if you want to manually zfs snapshot -R pool@1 before replicating with syncoid, the global atomicity of pool/dataset1@1 and pool/dataset2@1 will still be intact.)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>maxmind/MaxMind-DB</title>
    <updated>2022-06-04T02:49:32Z</updated>
    <id>tag:github.com,2022-06-04:/maxmind/MaxMind-DB</id>
    <link href="https://github.com/maxmind/MaxMind-DB" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Spec and test data for the MaxMind DB file format&lt;/p&gt;&lt;hr&gt;&lt;p&gt;MaxMind DB is a binary file format that stores data indexed by IP address subnets (IPv4 or IPv6).&lt;/p&gt; &#xA;&lt;p&gt;This repository contains the spec for that format.&lt;/p&gt;</summary>
  </entry>
</feed>