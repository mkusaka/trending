<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-15T02:02:20Z</updated>
  <subtitle>Weekly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fxcoudert/gfortran-for-macOS</title>
    <updated>2023-01-15T02:02:20Z</updated>
    <id>tag:github.com,2023-01-15:/fxcoudert/gfortran-for-macOS</id>
    <link href="https://github.com/fxcoudert/gfortran-for-macOS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;GNU Fortran (and GCC) compilers for macOS&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gfortran for macOS&lt;/h1&gt; &#xA;&lt;p&gt;The goal of this repository is to host GNU Fortran packages for macOS. These are simple installers, that will install the GCC compilers (including gfortran) in &lt;code&gt;/usr/local/gfortran&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/fxcoudert/gfortran-for-macOS/releases&#34;&gt;Follow this link to download!&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;How to uninstall?&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo rm -rf /usr/local/gfortran /usr/local/bin/gfortran&#xA;sudo pkgutil --forget com.gnu.gfortran&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;em&gt;If you are interested in how these installers are built, the documentation is &lt;a href=&#34;https://raw.githubusercontent.com/fxcoudert/gfortran-for-macOS/master/build_package.md&#34;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Tarrasch/zsh-autoenv</title>
    <updated>2023-01-15T02:02:20Z</updated>
    <id>tag:github.com,2023-01-15:/Tarrasch/zsh-autoenv</id>
    <link href="https://github.com/Tarrasch/zsh-autoenv" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Autoenv for zsh&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/Tarrasch/zsh-autoenv&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Tarrasch/zsh-autoenv.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Autoenv for Zsh&lt;/h1&gt; &#xA;&lt;p&gt;zsh-autoenv automatically sources (known/whitelisted) &lt;code&gt;.autoenv.zsh&lt;/code&gt; files, typically used in project root directories.&lt;/p&gt; &#xA;&lt;p&gt;It handles &#34;enter&#34; and leave&#34; events, nesting, and stashing of variables (overwriting and restoring).&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Zsh version 4.3.10 or later.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for enter and leave events, which can use the same file. By default it uses &lt;code&gt;.autoenv.zsh&lt;/code&gt; for entering, and &lt;code&gt;.autoenv_leave.zsh&lt;/code&gt; for leaving.&lt;/li&gt; &#xA; &lt;li&gt;Interactively asks for confirmation / authentication before sourcing an unknown &lt;code&gt;.autoenv.zsh&lt;/code&gt; file, and remembers whitelisted files by their hashed content.&lt;/li&gt; &#xA; &lt;li&gt;Test suite.&lt;/li&gt; &#xA; &lt;li&gt;Written in/for Zsh.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Variable stashing&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;autostash&lt;/code&gt; in your &lt;code&gt;.autoenv.zsh&lt;/code&gt; files to overwrite some variable, e.g. &lt;code&gt;$PATH&lt;/code&gt;. When leaving the directory, it will be automatically restored.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% echo &#39;echo ENTERED; autostash FOO=changed&#39; &amp;gt; project/.autoenv.zsh&#xA;% FOO=orig&#xA;% cd project&#xA;Attempting to load unauthorized env file!&#xA;-rw-rw-r-- 1 user user 36 Mai  6 20:38 /tmp/project/.autoenv.zsh&#xA;&#xA;**********************************************&#xA;&#xA;echo ENTERED; autostash FOO=changed&#xA;&#xA;**********************************************&#xA;&#xA;Would you like to authorize it? (type &#39;yes&#39;) yes&#xA;ENTERED&#xA;project % echo $FOO&#xA;changed&#xA;% cd ..&#xA;% echo $FOO&#xA;orig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also &lt;code&gt;stash&lt;/code&gt;, &lt;code&gt;unstash&lt;/code&gt; and &lt;code&gt;autounstash&lt;/code&gt;, in case you want to have more control.&lt;/p&gt; &#xA;&lt;p&gt;The varstash library has been taken from smartcd, and was optimized for Zsh.&lt;/p&gt; &#xA;&lt;h2&gt;Writing your .autoenv.zsh file&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;autoenv_source_parent()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;zsh-autoenv will stop looking for &lt;code&gt;.autoenv.zsh&lt;/code&gt; files upwards after the first one has been found, but you can use the function &lt;code&gt;autoenv_source_parent&lt;/code&gt; to source the next &lt;code&gt;.autoenv.zsh&lt;/code&gt; file upwards the directory tree from there.&lt;/p&gt; &#xA;&lt;p&gt;The function accepts an optional argument, which allows to stop looking before the file system root is reached:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;autoenv_source_parent ../..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository and source it from your &lt;code&gt;~/.zshrc&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% git clone https://github.com/Tarrasch/zsh-autoenv ~/.dotfiles/lib/zsh-autoenv&#xA;% echo &#39;source ~/.dotfiles/lib/zsh-autoenv/autoenv.zsh&#39; &amp;gt;&amp;gt; ~/.zshrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://github.com/zsh-users/antigen&#34;&gt;antigen&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;antigen-bundle Tarrasch/zsh-autoenv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://github.com/tarjoilija/zgen&#34;&gt;zgen&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;.zshrc&lt;/code&gt; where you are loading your plugins:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;zgen load Tarrasch/zsh-autoenv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://github.com/zplug/zplug&#34;&gt;zplug&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;.zshrc&lt;/code&gt; where you are loading your plugins:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;zplug &#34;Tarrasch/zsh-autoenv&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You can use the following variables to control zsh-autoenv&#39;s behavior. Add them to your &lt;code&gt;~/.zshrc&lt;/code&gt; file, before sourcing/loading zsh-autoenv.&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_FILE_ENTER&lt;/h3&gt; &#xA;&lt;p&gt;Name of the file to look for when entering directories.&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;.autoenv.zsh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_FILE_LEAVE&lt;/h3&gt; &#xA;&lt;p&gt;Name of the file to look for when leaving directories. Requires &lt;code&gt;AUTOENV_HANDLE_LEAVE=1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;.autoenv_leave.zsh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_LOOK_UPWARDS&lt;/h3&gt; &#xA;&lt;p&gt;Look for zsh-autoenv &#34;enter&#34; files in parent dirs?&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_HANDLE_LEAVE&lt;/h3&gt; &#xA;&lt;p&gt;Handle leave events when changing away from a subtree, where an &#34;enter&#34; event was handled?&lt;/p&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_DISABLED&lt;/h3&gt; &#xA;&lt;p&gt;(Temporarily) disable zsh-autoenv. This gets looked at in the chpwd handler.&lt;/p&gt; &#xA;&lt;p&gt;Default: 0&lt;/p&gt; &#xA;&lt;h3&gt;AUTOENV_DEBUG&lt;/h3&gt; &#xA;&lt;p&gt;Set debug level. If enabled (&amp;gt; 0) it will print information to stderr.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;0: no debug messages&lt;/li&gt; &#xA; &lt;li&gt;1: generic debug logging&lt;/li&gt; &#xA; &lt;li&gt;2: more verbose messages &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;messages about adding/removing files on the internal stack&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;3: everything &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;sets xtrace option (&lt;code&gt;set -x&lt;/code&gt;) while sourcing env files&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Default: &lt;code&gt;0&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;zsh-autoenv works automatically once installed.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;autoenv-edit&lt;/code&gt; to edit the nearest/current autoenv files. It will use &lt;code&gt;$AUTOENV_EDITOR&lt;/code&gt;, &lt;code&gt;$EDITOR&lt;/code&gt;, or &lt;code&gt;vim&lt;/code&gt; for editing.&lt;/p&gt; &#xA;&lt;h2&gt;Helper functions&lt;/h2&gt; &#xA;&lt;p&gt;The following helper functions are available:&lt;/p&gt; &#xA;&lt;h3&gt;autoenv_append_path&lt;/h3&gt; &#xA;&lt;p&gt;Appends path(s) to &lt;code&gt;$path&lt;/code&gt; (&lt;code&gt;$PATH&lt;/code&gt;), if they are not in there already.&lt;/p&gt; &#xA;&lt;h3&gt;autoenv_prepend_path&lt;/h3&gt; &#xA;&lt;p&gt;Prepends path(s) to &lt;code&gt;$path&lt;/code&gt; (&lt;code&gt;$PATH&lt;/code&gt;), if they are not in there already.&lt;/p&gt; &#xA;&lt;h3&gt;autoenv_remove_path&lt;/h3&gt; &#xA;&lt;p&gt;Removes path(s) from &lt;code&gt;$path&lt;/code&gt; (&lt;code&gt;$PATH&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Returns 0 in case &lt;code&gt;$path&lt;/code&gt; has changed, 1 otherwise.&lt;/p&gt; &#xA;&lt;h2&gt;Recipes&lt;/h2&gt; &#xA;&lt;h3&gt;Automatically activate Python virtualenvs&lt;/h3&gt; &#xA;&lt;p&gt;Given &lt;code&gt;AUTOENV_FILE_ENTER=.autoenv.zsh&lt;/code&gt;, &lt;code&gt;AUTOENV_FILE_LEAVE=.autoenv.zsh&lt;/code&gt; and &lt;code&gt;AUTOENV_HANDLE_LEAVE=1&lt;/code&gt; the following script will activate Python virtualenvs automatically in all subdirectories (&lt;code&gt;.venv&lt;/code&gt; directories get used by &lt;a href=&#34;https://github.com/kennethreitz/pipenv&#34;&gt;pipenv&lt;/a&gt; with &lt;code&gt;PIPENV_VENV_IN_PROJECT=1&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;# Environment file for all projects.&#xA;#  - (de)activates Python virtualenvs (.venv) from pipenv&#xA;&#xA;if [[ $autoenv_event == &#39;enter&#39; ]]; then&#xA;  autoenv_source_parent&#xA;&#xA;  _my_autoenv_venv_chpwd() {&#xA;    if [[ -z &#34;$_ZSH_ACTIVATED_VIRTUALENV&#34; &amp;amp;&amp;amp; -n &#34;$VIRTUAL_ENV&#34; ]]; then&#xA;      return&#xA;    fi&#xA;&#xA;    setopt localoptions extendedglob&#xA;    local -a venv&#xA;    venv=(./(../)#.venv(NY1:A))&#xA;&#xA;    if [[ -n &#34;$_ZSH_ACTIVATED_VIRTUALENV&#34; &amp;amp;&amp;amp; -n &#34;$VIRTUAL_ENV&#34; ]]; then&#xA;      if ! (( $#venv )) || [[ &#34;$_ZSH_ACTIVATED_VIRTUALENV&#34; != &#34;$venv[1]&#34; ]]; then&#xA;        unset _ZSH_ACTIVATED_VIRTUALENV&#xA;        echo &#34;De-activating virtualenv: ${(D)VIRTUAL_ENV}&#34; &amp;gt;&amp;amp;2&#xA;&#xA;        # Simulate &#34;deactivate&#34;, but handle $PATH better (remove VIRTUAL_ENV).&#xA;        if ! autoenv_remove_path $VIRTUAL_ENV/bin; then&#xA;          echo &#34;warning: ${VIRTUAL_ENV}/bin not found in \$PATH&#34; &amp;gt;&amp;amp;2&#xA;        fi&#xA;&#xA;        # NOTE: does not handle PYTHONHOME/_OLD_VIRTUAL_PYTHONHOME&#xA;        unset _OLD_VIRTUAL_PYTHONHOME&#xA;        # NOTE: does not handle PS1/_OLD_VIRTUAL_PS1&#xA;        unset _OLD_VIRTUAL_PS1&#xA;        unset VIRTUAL_ENV&#xA;      fi&#xA;    fi&#xA;&#xA;    if [[ -z &#34;$VIRTUAL_ENV&#34; ]]; then&#xA;      if (( $#venv )); then&#xA;        echo &#34;Activating virtualenv: ${(D)venv}&#34; &amp;gt;&amp;amp;2&#xA;        export VIRTUAL_ENV=$venv[1]&#xA;        autoenv_prepend_path $VIRTUAL_ENV/bin&#xA;        _ZSH_ACTIVATED_VIRTUALENV=&#34;$venv[1]&#34;&#xA;      fi&#xA;    fi&#xA;  }&#xA;  autoload -U add-zsh-hook&#xA;  add-zsh-hook chpwd _my_autoenv_venv_chpwd&#xA;  _my_autoenv_venv_chpwd&#xA;else&#xA;  add-zsh-hook -d chpwd _my_autoenv_venv_chpwd&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;https://github.com/direnv/direnv&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cxreg/smartcd&#34;&gt;https://github.com/cxreg/smartcd&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kennethreitz/autoenv&#34;&gt;https://github.com/kennethreitz/autoenv&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;This started as an optimized version of the bash plugin &lt;a href=&#34;https://github.com/kennethreitz/autoenv&#34;&gt;autoenv&lt;/a&gt; but for Zsh, and grew a lot of functionality on top of it (inspired by &lt;a href=&#34;https://github.com/cxreg/smartcd&#34;&gt;smartcd&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The code was initially based on &lt;a href=&#34;https://github.com/joshuaclayton&#34;&gt;@joshuaclayton&lt;/a&gt;&#39;s dotfiles. In September 2013 &lt;a href=&#34;https://github.com/Tarrasch&#34;&gt;@Tarrasch&lt;/a&gt; packaged it into a nice &lt;a href=&#34;https://github.com/Tarrasch/antigen-hs&#34;&gt;antigen&lt;/a&gt;-compatible unit with integration tests. Since November 2014, &lt;a href=&#34;https://github.com/blueyed&#34;&gt;@blueyed&lt;/a&gt; took over and added many nice features, mainly inspired by &lt;a href=&#34;https://github.com/cxreg/smartcd&#34;&gt;smartcd&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dangerous/deploy-script</title>
    <updated>2023-01-15T02:02:20Z</updated>
    <id>tag:github.com,2023-01-15:/dangerous/deploy-script</id>
    <link href="https://github.com/dangerous/deploy-script" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Easy config file based deployment with git and rsync&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Instructions&lt;/h1&gt; &#xA;&lt;h2&gt;Example config file&lt;/h2&gt; &#xA;&lt;pre&gt;module = example&#xA;path = /usr/local/www&#xA;&#xA;owner = deploy&#xA;group = apache&#xA;&#xA;includes = tmp/cache/index.htmlmod&#xA;excludes = sql /tests tmp/cache/*&#xA;&#xA;ssh_user = deploy&#xA;&#xA;[staging]&#xA;hosts = bulldog dalmatian&#xA;&#xA;[live]&#xA;hosts = poodle labrador&lt;/pre&gt; &#xA;&lt;h2&gt;Explanation&lt;/h2&gt; &#xA;&lt;p&gt;The config file should be stored in /configs. The reason I used a subdirectory is to prevent the shell from autocompleting the name of the config file ... as I would prefer people would be explicit about which module they are deploying.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;module - the name of the module.&lt;/li&gt; &#xA; &lt;li&gt;path - the path on the server where the module resides.&lt;/li&gt; &#xA; &lt;li&gt;owner (optional) - chown the module to owner before deploying&lt;/li&gt; &#xA; &lt;li&gt;group (optional) - chgrp the module to group before deploying&lt;/li&gt; &#xA; &lt;li&gt;includes (optional) - rsync --include&lt;/li&gt; &#xA; &lt;li&gt;excludes (optional) - rsync --exclude&lt;/li&gt; &#xA; &lt;li&gt;ssh_user - the user used to connect to the host&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[environment] sections&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;hosts - a space delimited list of hosts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;deploy (-t TAG | -b BRANCH) -n example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(--tag|-t) TAG - Checkout tag TAG&lt;/li&gt; &#xA; &lt;li&gt;(--branch|-b) BRANCH - Checkout branch BRANCH&lt;/li&gt; &#xA; &lt;li&gt;(--environment|-e) ENVIRONMENT - Use environment ENVIRONMENT (e.g. live, staging)&lt;/li&gt; &#xA; &lt;li&gt;(--dry-run|-d|-n) - Dry-run&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add a repo to the config file so if the module has not been cloned, the script can do it&lt;/li&gt; &#xA; &lt;li&gt;Add a way to have per-environment path&lt;/li&gt; &#xA; &lt;li&gt;Add a way to have per-host users&lt;/li&gt; &#xA; &lt;li&gt;Whether to --delete should be an option&lt;/li&gt; &#xA; &lt;li&gt;Should be able to pass alternative options to rsync&lt;/li&gt; &#xA; &lt;li&gt;have a defaults ini file&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>