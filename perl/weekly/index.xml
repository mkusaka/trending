<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-30T01:49:23Z</updated>
  <subtitle>Weekly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jmacarthur/flatten</title>
    <updated>2022-10-30T01:49:23Z</updated>
    <id>tag:github.com,2022-10-30:/jmacarthur/flatten</id>
    <link href="https://github.com/jmacarthur/flatten" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Perl scripts to unfold 3D OpenSCAD shapes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;flatten&lt;/h1&gt; &#xA;&lt;p&gt;Perl scripts to unfold 3D OpenSCAD shapes.&lt;/p&gt; &#xA;&lt;p&gt;Example usage and self test:&lt;/p&gt; &#xA;&lt;p&gt;./flatten.pl --thickness=3 tests/lifters.csg ./process.pl --kerf=130 tests/lifters.csg-3.svg&lt;/p&gt; &#xA;&lt;p&gt;diff lifters.csg-3.svg lifters.csg-3.svg.correct diff lifters.csg-3-processed.svg lifters.csg-3-processed.svg.correct&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>qt/qtqa</title>
    <updated>2022-10-30T01:49:23Z</updated>
    <id>tag:github.com,2022-10-30:/qt/qtqa</id>
    <link href="https://github.com/qt/qtqa" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Qt QA Scripts&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>jlapeyre/PDL-DSP-Windows</title>
    <updated>2022-10-30T01:49:23Z</updated>
    <id>tag:github.com,2022-10-30:/jlapeyre/PDL-DSP-Windows</id>
    <link href="https://github.com/jlapeyre/PDL-DSP-Windows" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Signal processing window functions for PDL&lt;/p&gt;&lt;hr&gt;&lt;p&gt;=head1 OVERVIEW&lt;/p&gt; &#xA;&lt;p&gt;A module for PDL providing window functions for signal processing. Distributions of this module can be downloaded most easily from CPAN. (Commits tagged with version numbers, may also be downloaded from github.)&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt; &#xA;&lt;p&gt;=head1 NAME&lt;/p&gt; &#xA;&lt;p&gt;PDL::DSP::Windows - Window functions for signal processing&lt;/p&gt; &#xA;&lt;p&gt;=head1 SYNOPSIS&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   use PDL;&#xA;   use PDL::DSP::Windows(&#39;window&#39;);&#xA;   my $samples = window( 10, &#39;tukey&#39;, { params =&amp;gt; .5 });&#xA;&#xA;   use PDL;&#xA;   use PDL::DSP::Windows;&#xA;   my $win = new PDL::DSP::Windows(10, &#39;tukey&#39;, { params =&amp;gt; .5 });&#xA;   print $win-&amp;gt;coherent_gain , &#34;\n&#34;;&#xA;   $win-&amp;gt;plot;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=head1 DESCRIPTION&lt;/p&gt; &#xA;&lt;p&gt;This module provides symmetric and periodic (DFT-symmetric) window functions for use in filtering and spectral analysis. It provides a high-level access subroutine L. This functional interface is sufficient for getting the window samples. For analysis and plotting, etc. an object oriented interface is provided. The functional subroutines must be either explicitly exported, or fully qualified. In this document, the word I&#xA; &lt;function&gt;&#xA;   refers only to the mathematical window functions, while the word I&#xA;  &lt;subroutine&gt;&#xA;    is used to describe code.&#xA;  &lt;/subroutine&gt;&#xA; &lt;/function&gt;&lt;/p&gt; &#xA;&lt;p&gt;Window functions are also known as apodization functions or tapering functions. In this module, each of these functions maps a sequence of C&amp;lt;$N&amp;gt; integers to values called a B&#xA; &lt;samples&gt;&#xA;  . (To confuse matters, the word I&#xA;  &lt;sample&gt;&#xA;    also has other meanings when describing window functions.) The functions are often named for authors of journal articles. Be aware that across the literature and software, some functions referred to by several different names, and some names refer to several different functions. As a result, the choice of window names is somewhat arbitrary.&#xA;  &lt;/sample&gt;&#xA; &lt;/samples&gt;&lt;/p&gt; &#xA;&lt;p&gt;The L window function requires L&lt;a href=&#34;PDL::GSLSF::BESSEL&#34;&gt;PDL::GSLSF::BESSEL&lt;/a&gt;. The L window function requires L&lt;a href=&#34;PDL::LinearAlgebra&#34;&gt;PDL::LinearAlgebra&lt;/a&gt;. But the remaining window functions may be used if these modules are not installed.&lt;/p&gt; &#xA;&lt;p&gt;The most common and easiest usage of this module is indirect, via some higher-level filtering interface, such as L&lt;a href=&#34;PDL::DSP::Fir::Simple&#34;&gt;PDL::DSP::Fir::Simple&lt;/a&gt;. The next easiest usage is to return a pdl of real-space samples with the subroutine L. Finally, for analyzing window functions, object methods, such as L, L, L&amp;lt;/plot_freq&amp;gt; are provided.&lt;/p&gt; &#xA;&lt;p&gt;In the following, first the functional interface (non-object oriented) is described in L&amp;lt;/&#34;FUNCTIONAL INTERFACE&#34;&amp;gt;. Next, the object methods are described in L. Next the low-level subroutines returning samples for each named window are described in L&amp;lt;/&#34;WINDOW FUNCTIONS&#34;&amp;gt;. Finally, some support routines that may be of interest are described in L&amp;lt;/&#34;AUXILIARY SUBROUTINES&#34;&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=head1 FUNCTIONAL INTERFACE&lt;/p&gt; &#xA;&lt;p&gt;=head2 window&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   $win = window({OPTIONS});&#xA;   $win = window($N,{OPTIONS});&#xA;   $win = window($N,$name,{OPTIONS});&#xA;   $win = window($N,$name,$params,{OPTIONS});&#xA;   $win = window($N,$name,$params,$periodic);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Returns an C&amp;lt;$N&amp;gt; point window of type C&amp;lt;$name&amp;gt;. The arguments may be passed positionally in the order C&amp;lt;$N,$name,$params,$periodic&amp;gt;, or they may be passed by name in the hash C&#xA; &lt;options&gt;&#xA;  .&#xA; &lt;/options&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head3 EXAMPLES&lt;/p&gt; &#xA;&lt;h1&gt;Each of the following return a 100 point symmetric hamming window.&lt;/h1&gt; &#xA;&lt;p&gt;$win = window(100); $win = window(100, &#39;hamming&#39;); $win = window(100, { name =&amp;gt; &#39;hamming&#39; ); $win = window({ N=&amp;gt; 100, name =&amp;gt; &#39;hamming&#39; );&lt;/p&gt; &#xA;&lt;h1&gt;Each of the following returns a 100 point symmetric hann window.&lt;/h1&gt; &#xA;&lt;p&gt;$win = window(100, &#39;hann&#39;); $win = window(100, { name =&amp;gt; &#39;hann&#39; );&lt;/p&gt; &#xA;&lt;h1&gt;Returns a 100 point periodic hann window.&lt;/h1&gt; &#xA;&lt;p&gt;$win = window(100, &#39;hann&#39;, { periodic =&amp;gt; 1 } );&lt;/p&gt; &#xA;&lt;h1&gt;Returns a 100 point symmetric Kaiser window with alpha=2.&lt;/h1&gt; &#xA;&lt;p&gt;$win = window(100, &#39;kaiser&#39;, { params =&amp;gt; 2 });&lt;/p&gt; &#xA;&lt;p&gt;=head3 OPTIONS&lt;/p&gt; &#xA;&lt;p&gt;The options follow default PDL::Options rules-- They may be abbreviated, and are case-insensitive.&lt;/p&gt; &#xA;&lt;p&gt;=over&lt;/p&gt; &#xA;&lt;p&gt;=item B&#xA; &lt;name&gt;&lt;/name&gt;&lt;/p&gt; &#xA;&lt;p&gt;(string) name of window function. Default: C&#xA; &lt;hamming&gt;&#xA;  . This selects one of the window functions listed below. Note that the suffix &#39;_per&#39;, for periodic, may be ommitted. It is specified with the option C&amp;lt;&amp;lt; periodic =&amp;gt; 1 &amp;gt;&amp;gt;&#xA; &lt;/hamming&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item B&#xA; &lt;params&gt;&lt;/params&gt;&lt;/p&gt; &#xA;&lt;p&gt;ref to array of parameter or parameters for the window-function subroutine. Only some window-function subroutines take parameters. If the subroutine takes a single parameter, it may be given either as a number, or a list of one number. For example C&amp;lt;3&amp;gt; or C&amp;lt;[3]&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=item B&#xA; &lt;n&gt;&lt;/n&gt;&lt;/p&gt; &#xA;&lt;p&gt;number of points in window function (the same as the order of the filter) No default value.&lt;/p&gt; &#xA;&lt;p&gt;=item B&#xA; &lt;periodic&gt;&lt;/periodic&gt;&lt;/p&gt; &#xA;&lt;p&gt;If value is true, return a periodic rather than a symmetric window function. Default: 0 (that is, false. that is, symmetric.)&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 list_windows&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; list_windows&#xA; list_windows STR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;C&amp;lt;list_windows&amp;gt; prints the names all of the available windows. C&amp;lt;list_windows STR&amp;gt; prints only the names of windows matching the string C&#xA; &lt;str&gt;&#xA;  .&#xA; &lt;/str&gt;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 METHODS&lt;/p&gt; &#xA;&lt;p&gt;=head2 new&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;my $win = new PDL::DSP::Windows(ARGS);&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Create an instance of a Windows object. If C&#xA; &lt;args&gt;&#xA;   are given, the instance is initialized. C&#xA;  &lt;args&gt;&#xA;    are interpreted in exactly the same way as arguments the subroutine L.&#xA;  &lt;/args&gt;&#xA; &lt;/args&gt;&lt;/p&gt; &#xA;&lt;p&gt;=for example&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;my $win1 = new PDL::DSP::Windows(8,&#39;hann&#39;); my $win2 = new PDL::DSP::Windows( { N =&amp;gt; 8, name =&amp;gt; &#39;hann&#39; } );&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 init&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;$win-&amp;gt;init(ARGS);&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Initialize (or reinitialize) a Windows object. ARGS are interpreted in exactly the same way as arguments the subroutine L.&lt;/p&gt; &#xA;&lt;p&gt;=for example&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;my $win = new PDL::DSP::Windows(8,&#39;hann&#39;); $win-&amp;gt;init(10,&#39;hamming&#39;);&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 samples&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;$win-&amp;gt;samples();&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Generate and return a reference to the piddle of $N samples for the window C&amp;lt;$win&amp;gt;. This is the real-space representation of the window.&lt;/p&gt; &#xA;&lt;p&gt;The samples are stored in the object C&amp;lt;$win&amp;gt;, but are regenerated every time C&#xA; &lt;samples&gt;&#xA;   is invoked. See the method L&amp;lt;/get_samples&amp;gt; below.&#xA; &lt;/samples&gt;&lt;/p&gt; &#xA;&lt;p&gt;=for example&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;my $win = new PDL::DSP::Windows(8,&#39;hann&#39;); print $win-&amp;gt;samples(), &#34;\n&#34;;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 modfreqs&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;$win-&amp;gt;modfreqs();&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Generate and return a reference to the piddle of the modulus of the fourier transform of the samples for the window C&amp;lt;$win&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;These values are stored in the object C&amp;lt;$win&amp;gt;, but are regenerated every time C&#xA; &lt;modfreqs&gt;&#xA;   is invoked. See the method L&amp;lt;/get_modfreqs&amp;gt; below.&#xA; &lt;/modfreqs&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head3 options&lt;/p&gt; &#xA;&lt;p&gt;=over&lt;/p&gt; &#xA;&lt;p&gt;=item min_bins =&amp;gt; MIN&lt;/p&gt; &#xA;&lt;p&gt;This sets the minimum number of frequency bins. Default 1000. If necessary, the piddle of window samples are padded with zeros before the fourier transform is performed.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 get&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;my $windata = $win-&amp;gt;get(&#39;samples&#39;);&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Get an attribute (or list of attributes) of the window C&amp;lt;$win&amp;gt;. If attribute C&#xA; &lt;samples&gt;&#xA;   is requested, then the samples are created with the method L&#xA; &lt;/samples&gt; if they don&#39;t exist.&lt;/p&gt; &#xA;&lt;p&gt;=for example&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;my $win = new PDL::DSP::Windows(8,&#39;hann&#39;); print $win-&amp;gt;get(&#39;samples&#39;), &#34;\n&#34;;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 get_samples&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;my $windata = $win-&amp;gt;get_samples&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Return a reference to the pdl of samples for the Window instance C&amp;lt;$win&amp;gt;. The samples will be generated with the method L if and only if they have not yet been generated.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 get_modfreqs&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;my $winfreqs = $win-&amp;gt;get_modfreqs; my $winfreqs = $win-&amp;gt;get_modfreqs({OPTS});&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Return a reference to the pdl of the frequency response (modulus of the DFT) for the Window instance C&amp;lt;$win&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;Options are passed to the method L. The data are created with L if they don&#39;t exist. The data are also created even if they already exist if options are supplied. Otherwise the cached data are returned.&lt;/p&gt; &#xA;&lt;p&gt;=head3 options&lt;/p&gt; &#xA;&lt;p&gt;=over&lt;/p&gt; &#xA;&lt;p&gt;=item min_bins =&amp;gt; MIN&lt;/p&gt; &#xA;&lt;p&gt;This sets the minimum number of frequency bins. See L. Default 1000.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 get_params&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;my $params = $win-&amp;gt;get_params&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Create a new array containing the parameter values for the instance C&amp;lt;$win&amp;gt; and return a reference to the array. Note that not all window types take parameters.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 get_name&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;print $win-&amp;gt;get_name , &#34;\n&#34;;&lt;/p&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Return a name suitable for printing associated with the window $win. This is something like the name used in the documentation for the particular window function. This is static data and does not depend on the instance.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 plot&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$win-&amp;gt;plot;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Plot the samples. Currently, only PDL::Graphics::Gnuplot is supported. The default display type is used.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 plot_freq&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;p&gt;Can be called like this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$win-&amp;gt;plot_freq;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$win-&amp;gt;plot_freq( {ordinate =&amp;gt; ORDINATE });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Plot the frequency response (magnitude of the DFT of the window samples). The response is plotted in dB, and the frequency (by default) as a fraction of the Nyquist frequency. Currently, only PDL::Graphics::Gnuplot is supported. The default display type is used.&lt;/p&gt; &#xA;&lt;p&gt;=head3 options&lt;/p&gt; &#xA;&lt;p&gt;=over&lt;/p&gt; &#xA;&lt;p&gt;=item coord =&amp;gt; COORD&lt;/p&gt; &#xA;&lt;p&gt;This sets the units of frequency of the co-ordinate axis. C&#xA; &lt;coord&gt;&#xA;   must be one of C&#xA;  &lt;nyquist&gt;&#xA;   , for fraction of the nyquist frequency (range C&amp;lt;-1,1&amp;gt;), C&#xA;   &lt;sample&gt;&#xA;    , for fraction of the sampling frequncy (range C&amp;lt;-.5,.5&amp;gt;), or C&#xA;    &lt;bin&gt;&#xA;      for frequency bin number (range C&amp;lt;0,$N-1&amp;gt;). The default value is C&#xA;     &lt;nyquist&gt;&#xA;      .&#xA;     &lt;/nyquist&gt;&#xA;    &lt;/bin&gt;&#xA;   &lt;/sample&gt;&#xA;  &lt;/nyquist&gt;&#xA; &lt;/coord&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item min_bins =&amp;gt; MIN&lt;/p&gt; &#xA;&lt;p&gt;This sets the minimum number of frequency bins. See L&amp;lt;/get_modfreqs&amp;gt;. Default 1000.&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 enbw&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$win-&amp;gt;enbw;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Compute and return the equivalent noise bandwidth of the window.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 coherent_gain&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$win-&amp;gt;coherent_gain;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Compute and return the coherent gain (the dc gain) of the window. This is just the average of the samples.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 process_gain&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$win-&amp;gt;coherent_gain;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Compute and return the processing gain (the dc gain) of the window. This is just the multiplicative inverse of the C&#xA; &lt;enbw&gt;&#xA;  .&#xA; &lt;/enbw&gt;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 scallop_loss&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$win-&amp;gt;scallop_loss;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;BROKEN&lt;/strong&gt;. Compute and return the scalloping loss of the window.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 WINDOW FUNCTIONS&lt;/p&gt; &#xA;&lt;p&gt;These window-function subroutines return a pdl of $N samples. For most windows, there are a symmetric and a periodic version. The symmetric versions are functions of $N points, uniformly spaced, and taking values from x_lo through x_hi. Here, a periodic function of C&amp;lt; $N &amp;gt; points is equivalent to its symmetric counterpart of C&amp;lt;$N+1&amp;gt; points, with the final point omitted. The name of a periodic window-function subroutine is the same as that for the corresponding symmetric function, except it has the suffix C&amp;lt;_per&amp;gt;. The descriptions below describe the symmetric version of each window.&lt;/p&gt; &#xA;&lt;p&gt;The term &#39;Blackman-Harris family&#39; is meant to include the Hamming family and the Blackman family. These are functions of sums of cosines.&lt;/p&gt; &#xA;&lt;p&gt;Unless otherwise noted, the arguments in the cosines of all symmetric window functions are multiples of C&amp;lt;$N&amp;gt; numbers uniformly spaced from C&amp;lt;0&amp;gt; through C&amp;lt;2 pi&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 Symmetric window functions&lt;/p&gt; &#xA;&lt;p&gt;=head2 bartlett($N)&lt;/p&gt; &#xA;&lt;p&gt;The Bartlett window. (Ref 1). Another name for this window is the fejer window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;1 - abs arr,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1. See also L&amp;lt;triangular|/triangular($N)&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 bartlett_hann($N)&lt;/p&gt; &#xA;&lt;p&gt;The Bartlett-Hann window. Another name for this window is the Modified Bartlett-Hann window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;0.62 - 0.48 * abs arr + 0.38* arr1,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1/2 through 1/2, and arr1 are the cos of points ranging from -PI through PI.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman($N)&lt;/p&gt; &#xA;&lt;p&gt;The &#39;classic&#39; Blackman window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.42, a1 = 0.5, a2 = 0.08&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_bnh($N)&lt;/p&gt; &#xA;&lt;p&gt;The Blackman-Harris (bnh) window. An improved version of the 3-term Blackman-Harris window given by Nuttall (Ref 2, p. 89). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.4243801, a1 = 0.4973406, a2 = 0.0782793&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_ex($N)&lt;/p&gt; &#xA;&lt;p&gt;The &#39;exact&#39; Blackman window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.426590713671539, a1 = 0.496560619088564, a2 = 0.0768486672398968&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_gen($N,$alpha)&lt;/p&gt; &#xA;&lt;p&gt;The General classic Blackman window. A single parameter family of the 3-term Blackman window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;my $cx = arr;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(.5 - $alpha) +  ($cx * ((-.5) +  ($cx * ($alpha)))),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where the points in arr are the cos of points ranging from 0 through 2PI.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_gen3($N,$a0,$a1,$a2)&lt;/p&gt; &#xA;&lt;p&gt;The general form of the Blackman family. One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = $a0, a1 = $a1, a2 = $a2&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_gen4($N,$a0,$a1,$a2,$a3)&lt;/p&gt; &#xA;&lt;p&gt;The general 4-term Blackman-Harris window. One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = $a0, a1 = $a1, a2 = $a2, a3 = $a3&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_gen5($N,$a0,$a1,$a2,$a3,$a4)&lt;/p&gt; &#xA;&lt;p&gt;The general 5-term Blackman-Harris window. One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = $a0, a1 = $a1, a2 = $a2, a3 = $a3, a4 = $a4&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_harris($N)&lt;/p&gt; &#xA;&lt;p&gt;The Blackman-Harris window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.422323, a1 = 0.49755, a2 = 0.07922&lt;/p&gt; &#xA;&lt;p&gt;Another name for this window is the Minimum three term (sample) Blackman-Harris window.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_harris4($N)&lt;/p&gt; &#xA;&lt;p&gt;The minimum (sidelobe) four term Blackman-Harris window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.35875, a1 = 0.48829, a2 = 0.14128, a3 = 0.01168&lt;/p&gt; &#xA;&lt;p&gt;Another name for this window is the Blackman-Harris window.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 blackman_nuttall($N)&lt;/p&gt; &#xA;&lt;p&gt;The Blackman-Nuttall window. One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.3635819, a1 = 0.4891775, a2 = 0.1365995, a3 = 0.0106411&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 bohman($N)&lt;/p&gt; &#xA;&lt;p&gt;The Bohman window. (Ref 1). This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;my $x = abs(arr); (1-$x)&lt;em&gt;cos(PI&lt;/em&gt;$x) +(1/PI)&lt;em&gt;sin(PI&lt;/em&gt;$x),&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 cauchy($N,$alpha)&lt;/p&gt; &#xA;&lt;p&gt;The Cauchy window. (Ref 1). Other names for this window are: Abel, Poisson. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;1 / (1 + (arr * $alpha)**2),&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 chebyshev($N,$at)&lt;/p&gt; &#xA;&lt;p&gt;The Chebyshev window. The frequency response of this window has C&amp;lt;$at&amp;gt; dB of attenuation in the stop-band. Another name for this window is the Dolph-Chebyshev window. No periodic version of this window is defined. This routine gives the same result as the routine B&#xA; &lt;chebwin&gt;&#xA;   in Octave 3.6.2.&#xA; &lt;/chebwin&gt;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 cos_alpha($N,$alpha)&lt;/p&gt; &#xA;&lt;p&gt;The Cos_alpha window. (Ref 1). Another name for this window is the Power-of-cosine window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;arr**$alpha ,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr are the sin of points ranging from 0 through PI.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 cosine($N)&lt;/p&gt; &#xA;&lt;p&gt;The Cosine window. Another name for this window is the sine window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;arr,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr are the sin of points ranging from 0 through PI.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 dpss($N,$beta)&lt;/p&gt; &#xA;&lt;p&gt;The Digital Prolate Spheroidal Sequence (DPSS) window. The parameter C&amp;lt;$beta&amp;gt; is the half-width of the mainlobe, measured in frequency bins. This window maximizes the power in the mainlobe for given C&amp;lt;$N&amp;gt; and C&amp;lt;$beta&amp;gt;. Another name for this window is the sleppian window.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 exponential($N)&lt;/p&gt; &#xA;&lt;p&gt;The Exponential window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;2 ** (1 - abs arr) - 1,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 flattop($N)&lt;/p&gt; &#xA;&lt;p&gt;The flat top window. One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.21557895, a1 = 0.41663158, a2 = 0.277263158, a3 = 0.083578947, a4 = 0.006947368&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 gaussian($N,$beta)&lt;/p&gt; &#xA;&lt;p&gt;The Gaussian window. (Ref 1). Another name for this window is the Weierstrass window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;exp (-0.5 * ($beta * arr )**2),&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 hamming($N)&lt;/p&gt; &#xA;&lt;p&gt;The Hamming window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.54, a1 = 0.46&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 hamming_ex($N)&lt;/p&gt; &#xA;&lt;p&gt;The &#39;exact&#39; Hamming window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.53836, a1 = 0.46164&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 hamming_gen($N,$a)&lt;/p&gt; &#xA;&lt;p&gt;The general Hamming window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = $a, a1 = (1-$a)&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 hann($N)&lt;/p&gt; &#xA;&lt;p&gt;The Hann window. (Ref 1). One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.5, a1 = 0.5&lt;/p&gt; &#xA;&lt;p&gt;Another name for this window is the hanning window. See also L&amp;lt;hann_matlab|/hann_matlab($N)&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 hann_matlab($N)&lt;/p&gt; &#xA;&lt;p&gt;The Hann (matlab) window. Equivalent to the Hann window of N+2 points, with the endpoints (which are both zero) removed. No periodic version of this window is defined. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;0.5 - 0.5 * arr,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr are the cosine of points ranging from 2PI/($N+1) through 2PI*$N/($N+1). This routine gives the same result as the routine B&#xA; &lt;hanning&gt;&#xA;   in Matlab. See also L&amp;lt;hann|/hann($N)&amp;gt;.&#xA; &lt;/hanning&gt;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 hann_poisson($N,$alpha)&lt;/p&gt; &#xA;&lt;p&gt;The Hann-Poisson window. (Ref 1). This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;0.5 * (1 + arr1) * exp (-$alpha * abs arr),&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1, and arr1 are the cos of points ranging from -PI through PI.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 kaiser($N,$beta)&lt;/p&gt; &#xA;&lt;p&gt;The Kaiser window. (Ref 1). The parameter C&amp;lt;$beta&amp;gt; is the approximate half-width of the mainlobe, measured in frequency bins. Another name for this window is the Kaiser-Bessel window. This window is defined by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;          barf &#34;kaiser: PDL::GSLSF not installed&#34; unless $HAVE_BESSEL;&#xA;          $beta *= PI;&#xA;          my @n = PDL::GSLSF::BESSEL::gsl_sf_bessel_In ($beta * sqrt(1 - arr **2),0);&#xA;    my @d = PDL::GSLSF::BESSEL::gsl_sf_bessel_In($beta,0);&#xA;    (shift @n)/(shift @d),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 lanczos($N)&lt;/p&gt; &#xA;&lt;p&gt;The Lanczos window. Another name for this window is the sinc window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;my $x = PI * arr; my $res = sin($x)/$x; my $mid; $mid = int($N/2), $res-&amp;gt;slice($mid) .= 1 if $N % 2; $res;,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 nuttall($N)&lt;/p&gt; &#xA;&lt;p&gt;The Nuttall window. One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.3635819, a1 = 0.4891775, a2 = 0.1365995, a3 = 0.0106411&lt;/p&gt; &#xA;&lt;p&gt;See also L&amp;lt;nuttall1|/nuttall1($N)&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 nuttall1($N)&lt;/p&gt; &#xA;&lt;p&gt;The Nuttall (v1) window. A window referred to as the Nuttall window. One of the Blackman-Harris family, with coefficients&lt;/p&gt; &#xA;&lt;p&gt;a0 = 0.355768, a1 = 0.487396, a2 = 0.144232, a3 = 0.012604&lt;/p&gt; &#xA;&lt;p&gt;This routine gives the same result as the routine B&#xA; &lt;nuttallwin&gt;&#xA;   in Octave 3.6.2. See also L&amp;lt;nuttall|/nuttall($N)&amp;gt;.&#xA; &lt;/nuttallwin&gt;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 parzen($N)&lt;/p&gt; &#xA;&lt;p&gt;The Parzen window. (Ref 1). Other names for this window are: Jackson, Valle-Poussin. This function disagrees with the Octave subroutine B&#xA; &lt;parzenwin&gt;&#xA;  , but agrees with Ref. 1. See also L&amp;lt;parzen_octave|/parzen_octave($N)&amp;gt;.&#xA; &lt;/parzenwin&gt;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 parzen_octave($N)&lt;/p&gt; &#xA;&lt;p&gt;The Parzen window. No periodic version of this window is defined. This routine gives the same result as the routine B&#xA; &lt;parzenwin&gt;&#xA;   in Octave 3.6.2. See also L&amp;lt;parzen|/parzen($N)&amp;gt;.&#xA; &lt;/parzenwin&gt;&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 poisson($N,$alpha)&lt;/p&gt; &#xA;&lt;p&gt;The Poisson window. (Ref 1). This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;exp (-$alpha * abs arr),&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 rectangular($N)&lt;/p&gt; &#xA;&lt;p&gt;The Rectangular window. (Ref 1). Other names for this window are: dirichlet, boxcar.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 triangular($N)&lt;/p&gt; &#xA;&lt;p&gt;The Triangular window. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;1 - abs arr,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -$N/($N-1) through $N/($N-1). See also L&amp;lt;bartlett|/bartlett($N)&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 tukey($N,$alpha)&lt;/p&gt; &#xA;&lt;p&gt;The Tukey window. (Ref 1). Another name for this window is the tapered cosine window.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 welch($N)&lt;/p&gt; &#xA;&lt;p&gt;The Welch window. (Ref 1). Other names for this window are: Riez, Bochner, Parzen, parabolic. This window is defined by&lt;/p&gt; &#xA;&lt;p&gt;1 - arr**2,&lt;/p&gt; &#xA;&lt;p&gt;where the points in arr range from -1 through 1.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 AUXILIARY SUBROUTINES&lt;/p&gt; &#xA;&lt;p&gt;These subroutines are used internally, but are also available for export.&lt;/p&gt; &#xA;&lt;p&gt;=head2 cos_mult_to_pow&lt;/p&gt; &#xA;&lt;p&gt;Convert Blackman-Harris coefficients. The BH windows are usually defined via coefficients for cosines of integer multiples of an argument. The same windows may be written instead as terms of powers of cosines of the same argument. These may be computed faster as they replace evaluation of cosines with multiplications. This subroutine is used internally to implement the Blackman-Harris family of windows more efficiently.&lt;/p&gt; &#xA;&lt;p&gt;This subroutine takes between 1 and 7 numeric arguments a0, a1, ...&lt;/p&gt; &#xA;&lt;p&gt;It converts the coefficients of this&lt;/p&gt; &#xA;&lt;p&gt;a0 - a1 cos(arg) + a2 cos( 2 * arg) - a3 cos( 3 * arg) + ...&lt;/p&gt; &#xA;&lt;p&gt;To the cofficients of this&lt;/p&gt; &#xA;&lt;p&gt;c0 + c1 cos(arg) + c2 cos(arg)**2 + c3 cos(arg)**3 + ...&lt;/p&gt; &#xA;&lt;p&gt;=head2 cos_pow_to_mult&lt;/p&gt; &#xA;&lt;p&gt;This function is the inverse of L&amp;lt;/cos_mult_to_pow&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;This subroutine takes between 1 and 7 numeric arguments c0, c1, ...&lt;/p&gt; &#xA;&lt;p&gt;It converts the coefficients of this&lt;/p&gt; &#xA;&lt;p&gt;c0 + c1 cos(arg) + c2 cos(arg)**2 + c3 cos(arg)**3 + ...&lt;/p&gt; &#xA;&lt;p&gt;To the cofficients of this&lt;/p&gt; &#xA;&lt;p&gt;a0 - a1 cos(arg) + a2 cos( 2 * arg) - a3 cos( 3 * arg) + ...&lt;/p&gt; &#xA;&lt;p&gt;=cut =head2 chebpoly&lt;/p&gt; &#xA;&lt;p&gt;=for usage&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;chebpoly($n,$x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=for ref&lt;/p&gt; &#xA;&lt;p&gt;Returns the value of the C&amp;lt;$n&amp;gt;-th order Chebyshev polynomial at point C&amp;lt;$x&amp;gt;. $n and $x may be scalar numbers, pdl&#39;s, or array refs. However, at least one of $n and $x must be a scalar number.&lt;/p&gt; &#xA;&lt;p&gt;All mixtures of pdls and scalars could be handled much more easily as a PP routine. But, at this point PDL::DSP::Windows is pure perl/pdl, requiring no C/Fortran compiler.&lt;/p&gt; &#xA;&lt;p&gt;=cut =head1 REFERENCES&lt;/p&gt; &#xA;&lt;p&gt;=over&lt;/p&gt; &#xA;&lt;p&gt;=item 1&lt;/p&gt; &#xA;&lt;p&gt;Harris, F.J. C&#xA; &lt;on the use of windows for harmonic analysis with discrete fourier transform&gt;&#xA;  , I&#xA;  &lt;proceedings of the ieee&gt;&#xA;   , 1978, vol 66, pp 51-83.&#xA;  &lt;/proceedings&gt;&#xA; &lt;/on&gt;&lt;/p&gt; &#xA;&lt;p&gt;=item 2&lt;/p&gt; &#xA;&lt;p&gt;Nuttall, A.H. C&#xA; &lt;some windows with very good sidelobe behavior&gt;&#xA;  , I&amp;lt;IEEE Transactions on Acoustics, Speech, Signal Processing&amp;gt;, 1981, vol. ASSP-29, pp. 84-91.&#xA; &lt;/some&gt;&lt;/p&gt; &#xA;&lt;p&gt;=back&lt;/p&gt; &#xA;&lt;p&gt;=head1 AUTHOR&lt;/p&gt; &#xA;&lt;p&gt;John Lapeyre, C&amp;lt;&amp;lt; &#xA; &lt;jlapeyre at cpan.org&gt;&#xA;   &amp;gt;&amp;gt;&#xA; &lt;/jlapeyre&gt;&lt;/p&gt; &#xA;&lt;p&gt;=head1 ACKNOWLEDGMENTS&lt;/p&gt; &#xA;&lt;p&gt;For study and comparison, the author used documents or output from: Thomas Cokelaer&#39;s spectral analysis software; Julius O Smith III&#39;s Spectral Audio Signal Processing web pages; Andr√© Carezia&#39;s chebwin.m Octave code; Other code in the Octave signal package.&lt;/p&gt; &#xA;&lt;p&gt;=head1 LICENSE AND COPYRIGHT&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2012 John Lapeyre.&lt;/p&gt; &#xA;&lt;p&gt;This program is free software; you can redistribute it and/or modify it under the terms of either: the GNU General Public License as published by the Free Software Foundation; or the Artistic License.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://dev.perl.org/licenses/&#34;&gt;http://dev.perl.org/licenses/&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;This software is neither licensed nor distributed by The MathWorks, Inc., maker and liscensor of MATLAB.&lt;/p&gt; &#xA;&lt;p&gt;=cut&lt;/p&gt;</summary>
  </entry>
</feed>