<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-13T01:57:12Z</updated>
  <subtitle>Weekly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pfischer/AI-ExpertSystem-Advanced</title>
    <updated>2023-08-13T01:57:12Z</updated>
    <id>tag:github.com,2023-08-13:/pfischer/AI-ExpertSystem-Advanced</id>
    <link href="https://github.com/pfischer/AI-ExpertSystem-Advanced" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Perl Expert system with backward, forward and mixed algorithms&lt;/p&gt;&lt;hr&gt;&lt;p&gt;NAME AI::ExpertSystem::Advanced - Expert System with backward, forward and mixed algorithms&lt;/p&gt; &#xA;&lt;p&gt;DESCRIPTION Inspired in AI::ExpertSystem::Simple but with additional features:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   Uses backward, forward and mixed algorithms.&#xA;&#xA;*   Offers different views, so user can interact with the expert system&#xA;    via a terminal or with a friendly user interface.&#xA;&#xA;*   The knowledge database can be stored in any format such as YAML, XML&#xA;    or databases. You just need to choose what driver to use and you are&#xA;    done.&#xA;&#xA;*   Uses certainty factors.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SYNOPSIS An example of the mixed algorithm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    use AI::ExpertSystem::Advanced;&#xA;    use AI::ExpertSystem::Advanced::KnowledgeDB::Factory;&#xA;&#xA;    my $yaml_kdb = AI::ExpertSystem::Advanced::KnowledgeDB::Factory-&amp;gt;new(&#39;yaml&#39;,&#xA;        {&#xA;            filename =&amp;gt; &#39;examples/knowledge_db_one.yaml&#39;&#xA;        });&#xA;&#xA;    my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;            viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;            knowledge_db =&amp;gt; $yaml_kdb,&#xA;            initial_facts =&amp;gt; [&#39;I&#39;],&#xA;            verbose =&amp;gt; 1);&#xA;    $ai-&amp;gt;mixed();&#xA;    $ai-&amp;gt;summary();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Attributes initial_facts A list/set of initial facts the algorithms start using.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    During the forward algorithm the task is to find a list of goals&#xA;    caused by these initial facts (the only data we have in that&#xA;    moment).&#xA;&#xA;    Lets imagine your knowledge database is about symptoms and diseases.&#xA;    You need to find what diseases are caused by the symptoms of a&#xA;    patient, these first symptons are the initial facts.&#xA;&#xA;    Initial facts as also asked and inference facts can be negative or&#xA;    positive. By default the initial facts are positive.&#xA;&#xA;    Keep in mind that the data contained in this array can be the IDs or&#xA;    the name of the fact.&#xA;&#xA;    This array will be converted to initial_facts_dict. And all the data&#xA;    (ids or or names) will be made of only IDs.&#xA;&#xA;        my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;                viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;                knowledge_db =&amp;gt; $yaml_kdb,&#xA;                initial_facts =&amp;gt; [&#39;I&#39;, [&#39;F&#39;, &#39;-&#39;], [&#39;G&#39;, &#39;+&#39;]);&#xA;&#xA;    As you can see if you want to provide the sign of a fact, just&#xA;    *encapsulate* it in an array, the first item should be the fact and&#xA;    the second one the sign.&#xA;&#xA;initial_facts_dict&#xA;    This dictionary (see AI::ExpertSystem::Advanced::Dictionary has the&#xA;    sasme data of initial_facts but with the additional feature(s) of&#xA;    proviing iterators and a quick way to find elements.&#xA;&#xA;goals_to_check&#xA;        my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;                viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;                knowledge_db =&amp;gt; $yaml_kdb,&#xA;                goals_to_check =&amp;gt; [&#39;J&#39;]);&#xA;&#xA;    When doing the backward() algorithm it&#39;s required to have at least&#xA;    one goal (aka hypothesis).&#xA;&#xA;    This could be pretty similar to initial_facts, with the difference&#xA;    that the initial facts are used more with the causes of the rules&#xA;    and this one with the goals (usually one in a well defined knowledge&#xA;    database).&#xA;&#xA;    The same rule of initial_facts apply here, you can provide the sign&#xA;    of the facts and you can provide the id or the name of them.&#xA;&#xA;    From our example of symptoms and diseases lets imagine we have the&#xA;    hypothesis that a patient has flu, we don&#39;t know the symptoms it&#xA;    has, we want the expert system to keep asking us for them to make&#xA;    sure that our hypothesis is correct (or incorrect in case there&#39;s&#xA;    not enough information).&#xA;&#xA;goals_to_check_dict&#xA;    Very similar to goals_to_check (and indeed of initial_facts_dict).&#xA;    We want to make the job easier.&#xA;&#xA;    It will be a dictionary made of the data of goals_to_check.&#xA;&#xA;inference_facts&#xA;    Inference facts are basically the core of an expert system. These&#xA;    are facts that are found and copied when a set of facts (initial,&#xA;    inference or asked) match with the causes of a goal.&#xA;&#xA;    inference_facts is a AI::ExpertSystem::Advanced::Dictionary, it will&#xA;    store the name of the fact, the rule that caused these facts to be&#xA;    copied to this dictionary, the sign and the algorithm that triggered&#xA;    it.&#xA;&#xA;knowledge_db&#xA;    The object reference of the knowledge database&#xA;    AI::ExpertSystem::Advanced is using.&#xA;&#xA;asked_facts&#xA;    During the backward() algorithm there will be cases when there&#39;s no&#xA;    clarity if a fact exists. In these cases the backward() will be&#xA;    asking the user (via automation or real questions) if a fact exists.&#xA;&#xA;    Going back to the initial_facts example of symptoms and diseases.&#xA;    Imagine the algorithm is checking a rule, some of the facts of the&#xA;    rule make a match with the ones of initial_facts or inference_facts&#xA;    but some wont, for these *unsure* facts the backward() will ask the&#xA;    user if a symptom (a fact) exists. All these asked facts will be&#xA;    stored here.&#xA;&#xA;visited_rules&#xA;    Keeps a record of all the rules the algorithms have visited and also&#xA;    the number of causes each rule has.&#xA;&#xA;verbose&#xA;        my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;                viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;                knowledge_db =&amp;gt; $yaml_kdb,&#xA;                initial_facts =&amp;gt; [&#39;I&#39;],&#xA;                verbose =&amp;gt; 1);&#xA;&#xA;    By default this is turned off. If you want to know what happens&#xA;    behind the scenes turn this on.&#xA;&#xA;    Everything that needs to be debugged will be passed to the debug()&#xA;    method of your viewer.&#xA;&#xA;viewer&#xA;    Is the object AI::ExpertSystem::Advanced will be using for printing&#xA;    what is happening and for interacting with the user (such as asking&#xA;    the asked_facts).&#xA;&#xA;    This is practical if you want to use a viewer object that is not&#xA;    provided by AI::ExpertSystem::Advanced::Viewer::Factory.&#xA;&#xA;viewer_class&#xA;    Is the the class name of the viewer.&#xA;&#xA;    You can decide to use the viewers&#xA;    AI::ExpertSystem::Advanced::Viewer::Factory offers, in this case you&#xA;    can pass the object or only the name of your favorite viewer.&#xA;&#xA;found_factor&#xA;    In your knowledge database you can give different *weights* to the&#xA;    facts of each rule (eg to define what facts have more *priority*).&#xA;    During the mixed() algorithm it will be checking what causes are&#xA;    found in the inference_facts and in the asked_facts dictionaries,&#xA;    then the total number of matches (or total number of certainity&#xA;    factors of each rule) will be compared versus the value of this&#xA;    factor, if it&#39;s higher or equal then the rule will be triggered.&#xA;&#xA;    You can read the documentation of the mixed() algorithm to know the&#xA;    two ways this factor can be used.&#xA;&#xA;shot_rules&#xA;    All the rules that are shot are stored here. This is a hash, the key&#xA;    of each item is the rule id while its value is the precision time&#xA;    when the rule was shot.&#xA;&#xA;    The precision time is useful for knowing when a rule was shot and&#xA;    based on that you can know what steps it followed so you can compare&#xA;    (or reproduce) them.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Constants * FACT_SIGN_NEGATIVE Used when a fact is negative, aka, a fact doesn&#39;t happen.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* FACT_SIGN_POSITIVE&#xA;    Used for those facts that happen.&#xA;&#xA;* FACT_SIGN_UNSURE&#xA;    Used when there&#39;s no straight answer of a fact, eg, we don&#39;t know if&#xA;    an answer will change the result.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Methods shoot($rule, $algorithm) Shoots the given rule. It will do the following verifications:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   Each of the facts (causes) will be compared against the&#xA;    initial_facts_dict, inference_facts and asked_facts (in this order).&#xA;&#xA;*   If any initial, inference or asked fact matches with a cause but&#xA;    it&#39;s negative then all of its goals (usually only one by rule) will&#xA;    be copied to the inference_facts with a negative sign, otherwise a&#xA;    positive sign will be used.&#xA;&#xA;*   Will add the rule to the shot_rules hash.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is_rule_shot($rule) Verifies if the given $rule has been shot.&lt;/p&gt; &#xA;&lt;p&gt;get_goals_by_rule($rule) Will ask the knowledge_db for the goals of the given $rule.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;A AI::ExpertSystem::Advanced::Dictionary will be returned.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;get_causes_by_rule($rule) Will ask the knowledge_db for the causes of the given $rule.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;A AI::ExpertSystem::Advanced::Dictionary will be returned.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is_fact_negative($dict_name, $fact) Will check if the given $fact of the given dictionary ($dict_name) is negative.&lt;/p&gt; &#xA;&lt;p&gt;copy_to_inference_facts($facts, $sign, $algorithm, $rule) Copies the given $facts (a dictionary, usually goal(s) of a rule) to the inference_facts dictionary. All the given goals will be copied with the given $sign.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Additionally it will add the given $algorithm and $rule to the inference&#xA;facts. So later we can know how we got to a certain inference fact.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;compare_causes_with_facts($rule) Compares the causes of the given $rule with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*   Initial facts&#xA;&#xA;*   Inference facts&#xA;&#xA;*   Asked facts&#xA;&#xA;It will be couting the matches of all of the above dictionaries, so for&#xA;example if we have four causes, two make match with initial facts, other&#xA;with inference and the remaining one with the asked facts, then it will&#xA;evaluate to true since we have a match of the four causes.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;get_causes_match_factor($rule) Similar to compare_causes_with_facts() but with the difference that it will count the &#34;match factor&#34; of each matched cause and return the total of this weight.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The match factor is used by the mixed() algorithm and is useful to know&#xA;if a certain rule should be shoot or not even if not all of the causes&#xA;exist in our facts.&#xA;&#xA;The *match factor* is calculated in two ways:&#xA;&#xA;*   Will do a sum of the weight for each matched cause. Please note that&#xA;    if only one cause of a rule has a specified weight then the&#xA;    remaining causes will default to the total weight minus 1 and then&#xA;    divided with the total number of causes (matched or not) that don&#39;t&#xA;    have a weight.&#xA;&#xA;*   If no weight is found with all the causes of the given rule, then&#xA;    the total number of matches will be divided by the total number of&#xA;    causes.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is_goal_in_our_facts($goal) Checks if the given $goal is in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1   The initial facts&#xA;&#xA;2   The inference facts&#xA;&#xA;3   The asked facts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;remove_last_ivisited_rule() Removes the last visited rule and return its number.&lt;/p&gt; &#xA;&lt;p&gt;visit_rule($rule, $total_causes) Adds the given $rule to the end of the visited_rules.&lt;/p&gt; &#xA;&lt;p&gt;copy_to_goals_to_check($rule, $facts) Copies a list of facts (usually a list of causes of a rule) to goals_to_check_dict.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The rule ID of the goals that are being copied is also stored in the&#xA;hahs.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ask_about($fact) Uses viewer to ask the user for the existence of the given $fact.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The valid answers are:&#xA;&#xA;+ or FACT_SIGN_POSITIVE&#xA;    In case user knows of it.&#xA;&#xA;- or FACT_SIGN_NEGATIVE&#xA;    In case user doesn&#39;t knows of it.&#xA;&#xA;~ or FACT_SIGN_UNSURE&#xA;    In case user doesn&#39;t have any clue about the given fact.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;get_rule_by_goal($goal) Looks in the knowledge_db for the rule that has the given goal. If a rule is found its number is returned, otherwise undef.&lt;/p&gt; &#xA;&lt;p&gt;forward() use AI::ExpertSystem::Advanced; use AI::ExpertSystem::Advanced::KnowledgeDB::Factory;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $yaml_kdb = AI::ExpertSystem::Advanced::KnowledgeDB::Factory-&amp;gt;new(&#39;yaml&#39;,&#xA;            {&#xA;                filename =&amp;gt; &#39;examples/knowledge_db_one.yaml&#39;&#xA;            });&#xA;&#xA;    my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;            viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;            knowledge_db =&amp;gt; $yaml_kdb,&#xA;            initial_facts =&amp;gt; [&#39;F&#39;, &#39;J&#39;]);&#xA;    $ai-&amp;gt;forward();&#xA;    $ai-&amp;gt;summary();&#xA;&#xA;The forward chaining algorithm is one of the main methods used in Expert&#xA;Systems. It starts with a set of variables (known as initial facts) and&#xA;reads the available rules.&#xA;&#xA;It will be reading rule by rule and for each one it will compare its&#xA;causes with the initial, inference and asked facts. If all of these&#xA;causes are in the facts then the rule will be shoot and all of its goals&#xA;will be copied/converted to inference facts and will restart reading&#xA;from the first rule.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;backward() use AI::ExpertSystem::Advanced; use AI::ExpertSystem::Advanced::KnowledgeDB::Factory;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    my $yaml_kdb = AI::ExpertSystem::Advanced::KnowledgeDB::Factory-&amp;gt;new(&#39;yaml&#39;,&#xA;        {&#xA;            filename =&amp;gt; &#39;examples/knowledge_db_one.yaml&#39;&#xA;            });&#xA;&#xA;    my $ai = AI::ExpertSystem::Advanced-&amp;gt;new(&#xA;            viewer_class =&amp;gt; &#39;terminal&#39;,&#xA;            knowledge_db =&amp;gt; $yaml_kdb,&#xA;            goals_to_check =&amp;gt; [&#39;J&#39;]);&#xA;    $ai-&amp;gt;backward();&#xA;    $ai-&amp;gt;summary();&#xA;&#xA;The backward algorithm starts with a set of *assumed* goals (facts). It&#xA;will start reading goal by goal. For each goal it will check if it&#xA;exists in the initial, inference and asked facts (see&#xA;is_goal_in_our_facts()) for more information).&#xA;&#xA;*   If the goal exist then it will be removed from the dictionary, it&#xA;    will also verify if there are more visited rules to shoot.&#xA;&#xA;    If there are still more visited rules to shoot then it will check&#xA;    from what rule the goal comes from, if it was copied from a rule&#xA;    then this data will exist. With this information then it will see&#xA;    how many of the causes of this given rule are still in the&#xA;    goals_to_check_dict.&#xA;&#xA;    In case there are still causes of this rule in goals_to_check_dict&#xA;    then the amount of causes pending will be reduced by one. Otherwise&#xA;    (if the amount is 0) then the rule of this last removed goal will be&#xA;    shoot.&#xA;&#xA;*   If the goal doesn&#39;t exist in the mentioned facts then the goal will&#xA;    be searched in the goals of every rule.&#xA;&#xA;    In case it finds the rule that has the goal, this rule will be&#xA;    marked (added) to the list of visited rules (visited_rules) and also&#xA;    all of its causes will be added to the top of the&#xA;    goals_to_check_dict and it will start reading again all the goals.&#xA;&#xA;    If there&#39;s the case where the goal doesn&#39;t exist as a goal in the&#xA;    rules then it will ask the user (via ask_about()) for the existence&#xA;    of it. If user is not sure about it then the algorithm ends.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;mixed() As its name says, it&#39;s a mix of forward() and backward() algorithms, it requires to have at least one initial fact.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The first thing it does is to run the forward() algorithm (hence the&#xA;need of at least one initial fact). If the algorithm fails then the&#xA;mixed algorithm also ends unsuccessfully.&#xA;&#xA;Once the first *run* of forward() algorithm happens it starts looking&#xA;for any positive inference fact, if only one is found then this ends the&#xA;algorithm with the assumption it knows what&#39;s happening.&#xA;&#xA;In case no positive inference fact is found then it will start reading&#xA;the rules and creating a list of intuitive facts.&#xA;&#xA;For each rule it will get a *certainty factor* of its causes versus the&#xA;initial, inference and asked facts. In case the certainity factor is&#xA;greater or equal than found_factor then all of its goals will be copied&#xA;to the intuitive facts (eg, read it as: it assumes the goals have&#xA;something to do with our first initial facts).&#xA;&#xA;Once all the rules are read then it verifies if there are intuitive&#xA;facts, if no facts are found then it ends with the intuition, otherwise&#xA;it will run the backward() algorithm for each one of these facts (eg,&#xA;each fact will be converted to a goal). After each *run* of the&#xA;backward() algorithm it will verify for any positive inference fact, if&#xA;just one is found then the algorithm ends.&#xA;&#xA;At the end (if there are still no positive inference facts) it will run&#xA;the forward() algorithm and restart (by looking again for any positive&#xA;inference fact).&#xA;&#xA;A good example to understand how this algorithm is useful is: imagine&#xA;you are a doctor and know some of the symptoms of a patient. Probably&#xA;with the first symptoms you have you can get to a positive conclusion&#xA;(eg that a patient has *X* disease). However in case there&#39;s still no&#xA;clue, then a set of questions (done by the call of backward()) of&#xA;symptons related to the initial symptoms will be asked to the user. For&#xA;example, we know that that the patient has a headache but that doesn&#39;t&#xA;give us any positive answer, what if the patient has flu or another&#xA;disease? Then a set of these *related* symptons will be asked to the&#xA;user.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;summary($return) The main purpose of any expert system is the ability to explain: what is happening, how it got to a result, what assumption(s) it required to make, the fatcs that were excluded and the ones that were used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This method will use the viewer (or return the result) in YAML format of&#xA;all the rules that were shot. It will explain how it got to each one of&#xA;the causes so a better explanation can be done by the viewer.&#xA;&#xA;If $return is defined (eg, it got any parameter) then the result wont be&#xA;passed to the viewer, instead it will be returned as a string.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SEE ALSO Take a look AI::ExpertSystem::Simple too.&lt;/p&gt; &#xA;&lt;p&gt;AUTHOR Pablo Fischer (&lt;a href=&#34;mailto:pablo@pablo.com.mx&#34;&gt;pablo@pablo.com.mx&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;COPYRIGHT Copyright (C) 2010 by Pablo Fischer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This library is free software; you can redistribute it and/or modify it&#xA;under the same terms as Perl itself.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>vrdabomb5717/Docbox</title>
    <updated>2023-08-13T01:57:12Z</updated>
    <id>tag:github.com,2023-08-13:/vrdabomb5717/Docbox</id>
    <link href="https://github.com/vrdabomb5717/Docbox" rel="alternate"></link>
    <summary type="html">&lt;p&gt;COMS W3157 Homework 1: Documents Analysis&lt;/p&gt;&lt;hr&gt;&lt;p&gt;COMS W3157 Homework 1 Operation: Project Docbox Authors: Varun Ravishankar and Jervis Muindi vr2263 and jjm2190&lt;/p&gt; &#xA;&lt;p&gt;Repository: &lt;a href=&#34;https://bitbucket.org/vrdabomb5717/docbox&#34;&gt;https://bitbucket.org/vrdabomb5717/docbox&lt;/a&gt; CLIC: &lt;a href=&#34;http://web3157.cs.columbia.edu/~jjm2190/public/project/&#34;&gt;http://web3157.cs.columbia.edu/~jjm2190/public/project/&lt;/a&gt; &lt;strong&gt;Files included:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;.project&lt;/em&gt; Nonessential, contains listing of files for editing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Files/&lt;/em&gt; Directory contains files uploaded by users.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Filesearch.pm&lt;/em&gt; Perl module&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Genstat.pm&lt;/em&gt; A module that contains methods to add files, remove files, update files, and generate statistics based upon the user&#39;s database, such as the number of files, the average file size, the top 30 words, change the public status of a file, search the tags/comments/filetype/filename/size, generate the word counts of words in a file, and find out if a file is public.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;HTML.pm&lt;/em&gt; Contains static methods for generating commonly used HTML code specific to DocBox.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Log.pm&lt;/em&gt; Logs messages to the server, like logins, failed logins, errors, and all other important events on the server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Logs/&lt;/em&gt; Folder that contains the log files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Project Desc&lt;/em&gt; Division of responsibilities in project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;PublicDB.pm&lt;/em&gt; Contains static methods for accessing Public file SQLite database; similar in function to Genstat, but specific to the public database.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;TestDB.pl&lt;/em&gt; Test Code to test UserDB module works correctly, by removing, adding, and updating text files, Word docs, PDFs, and RTFs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Test_HTML.pl.cgi&lt;/em&gt; Testing script for HTML::Template.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;ToDoList.txt&lt;/em&gt; List of things still to do. Has not been updated in a while, so it should not be believed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;UserDB.pm&lt;/em&gt; List of methods for accessing and modifying the user registration database, including registering a user, changing password, and changing personal info.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;clip_image002.png&lt;/em&gt; Random image that is apparently our site&#39;s logo.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;css/&lt;/em&gt; Directory that contains the CSS files for the website.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;database schema&lt;/em&gt; Basic schema for the SQL databases we created.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;download.pl.cgi&lt;/em&gt; Downloads the given file to the user&#39;s browser.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;editfile.pl.cgi&lt;/em&gt; Edit file, allowing user to copy, delete, rename, and download.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;email.pl.cgi&lt;/em&gt; Emails user a password reset link.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;filelist.html&lt;/em&gt; HTML page that is displayed to test the file listing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;group.pl.cgi&lt;/em&gt; Groups the user selected file into its own directory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;home.pl.cgi&lt;/em&gt; Lists all files currently owned by the user.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;images/&lt;/em&gt; Contains images used on the website for all operations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;index.html&lt;/em&gt; Main landing page for website.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;login.pl.cgi&lt;/em&gt; Page that is displayed for user to log in on.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;login_failed.html&lt;/em&gt; Page that is displayed when a user fails to authenticate against userpass.db&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;passwords.txt&lt;/em&gt; Test file for storing a user and their password, used on an older revision of the site.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;public.db&lt;/em&gt; Contains a listing of all public files on the server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;public.pl.cgi&lt;/em&gt; Shows all available public files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;register.pl.cgi&lt;/em&gt; Registers new user and adds to the database.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;reset.pl.cgi&lt;/em&gt; Resets the password of a user.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;reset_page.pl.cgi&lt;/em&gt; Gives HTML page to perform password reset.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;search.pl.cgi&lt;/em&gt; Performs a search to which files match given query.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;searchtest.pl&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;stats.pl.cgi&lt;/em&gt; Shows statistics about the users&#39; files and about the website in general, like number of files, users, and average file size.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;temp.tar&lt;/em&gt; Temporary file created to enable directory downloading.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;templates/&lt;/em&gt; Contains HTMl template files used on the website.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;upload.pl.cgi&lt;/em&gt; Uploads current file and saves it in the users&#39; home directory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;upload_page.pl.cgi&lt;/em&gt; Generates HTML to let user upload file to the server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;user.db&lt;/em&gt; Test db that contains a listing of users&#39; files, and the files&#39; properties, as well as word counts for each file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;user.sql&lt;/em&gt; Contains the SQL schema for the .user.db file that is created for each user.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;userpass.db&lt;/em&gt; Database that contains a list of users, their passwords, and users&#39; personal information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;userpass.sql&lt;/em&gt; Database SQL schema file for the userpass.db, which is used to create a new database if we migrate the site.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./Files:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;test/&lt;/em&gt; &lt;em&gt;user/&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;These two directories are separate users, to help test our code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./Files/test:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;.user.db&lt;/em&gt; &lt;em&gt;about_Arithmetic_Operators.help.txt&lt;/em&gt; &lt;em&gt;pub/&lt;/em&gt; &lt;em&gt;t1/&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;This user has their user database, a text file, and two subdirectories.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./Files/test/pub:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;pub3.txt&lt;/em&gt; &lt;em&gt;public-copy.txt&lt;/em&gt; &lt;em&gt;public.txt&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Three text files in this subdirectory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./Files/test/t1:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;hosts&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Another text file, without an extension.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./Files/user:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;.user.db&lt;/em&gt; &lt;em&gt;110.jpg&lt;/em&gt; &lt;em&gt;About Stacks.pdf&lt;/em&gt; &lt;em&gt;Columbia Internet Download Speed FATEST.png&lt;/em&gt; &lt;em&gt;Halo 2.doc&lt;/em&gt; &lt;em&gt;Source Code License.rtf&lt;/em&gt; &lt;em&gt;Untitled.rtf&lt;/em&gt; &lt;em&gt;sample midterm.pdf&lt;/em&gt; &lt;em&gt;test/&lt;/em&gt; &lt;em&gt;testfile.txt&lt;/em&gt; &lt;em&gt;works.txt&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The second user has their database, a jpeg file, 2 PDFs, a PNG, a Word document, 2 RTF files, 2 text files, and a subdirectory called test.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./Files/user/test:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;111.jpg&lt;/em&gt; &lt;em&gt;testfile.txt&lt;/em&gt; &lt;em&gt;works.txt&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;A jpeg and two text files are in this subdirectory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./Logs:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;errors.txt&lt;/em&gt; &lt;em&gt;log.txt&lt;/em&gt; &lt;em&gt;logins.txt&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Log files for the server. log.txt is a log of all events on the server, errors.txt is a log of all errors that occur on the server, and logins.txt is a log of all successful and attempted logins on the server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./css:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;main.css&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;CSS file for the website.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./images:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;copy.png&lt;/em&gt; &lt;em&gt;delete.png&lt;/em&gt; &lt;em&gt;dir.png&lt;/em&gt; &lt;em&gt;download.png&lt;/em&gt; &lt;em&gt;email.png&lt;/em&gt; &lt;em&gt;file.png&lt;/em&gt; &lt;em&gt;public.png&lt;/em&gt; &lt;em&gt;rename.png&lt;/em&gt; &lt;em&gt;stat.png&lt;/em&gt; &lt;em&gt;up.png&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Images that appear during any operation on the website.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;./templates:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;editfile.tmpl&lt;/em&gt; &lt;em&gt;filelist.tmpl&lt;/em&gt; &lt;em&gt;fileop.tmpl&lt;/em&gt; &lt;em&gt;group.tmpl&lt;/em&gt; &lt;em&gt;group_op.tmpl&lt;/em&gt; &lt;em&gt;public.tmpl&lt;/em&gt; &lt;em&gt;reset.tmpl&lt;/em&gt; &lt;em&gt;search.tmpl&lt;/em&gt; &lt;em&gt;stats.tmpl&lt;/em&gt; &lt;em&gt;success.tmpl&lt;/em&gt; &lt;em&gt;upload.tmpl&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Template HTMl pages for all the pages that appear on the website.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Progress and Project Realization&lt;/strong&gt; We made reasonable progress over the past month. About once a week, we would meet up to discuss potential issues and progress, and would make sure that we kept abreast of whatever the other was doing. However, midterms made sure that progress slowed in the middle and only sped up near launch day. We used Mercurial and Bitbucket as source control, which allowed us to keep our code in sync and have a high turnover for code reviews. Our biggest problem was that we did not test the backend code adequately enough, and so we both spent some time debugging the backend until it worked. This meant that, at the time of writing, the UI does not implement some of the features that were written on the backend, since once code is written to update part of the database, it is easy to write functions that will update the rest of the fields separately as well. For example, we do not have a profile page nor UI to update personal info, nor did we have a way to edit the tags and comments fields.&lt;/p&gt; &#xA;&lt;p&gt;Overall, project development was not without hitches, but we worked well together and worked quickly and efficiently towards realizing our goal. One of us, however, would rather shoot himself in the foot than work with Perl for websites ever again.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Security Issues&lt;/strong&gt; Our main security issues are the easiness for spoofing users, since we are not using HTTPS and thus you can just listen in on the server&#39;s private communications and get a user&#39;s private information. Even worse, without HTTPS, we can just send the URL from one browser and spoof the user without even trying. The backend is not encrypted, which means that if the server is compromised, the attacker can get people&#39;s usernames and passwords if they know where to look. The other major issue is the possiblity of SQL injections. Since our backend is so heavily dependent on SQLite databases, SQL injection attacks that modify records or drop tables could have a devastating effect on the site.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bugs and Development Issues&lt;/strong&gt; The biggest bug we had was RTF file searching. Normally, such files can be searched by grep on the backend, but for multiword searches, such tricks don&#39;t work. This is because RTF files are like HTML files in that they can have control words and escape sequences in them, and thus words that are individually marked can screw grep up. Instead, we used a module to get the RTF&#39;s text and then add it to our database, but the first module failed to work properly. We found another module that worked as planned, but CPAN and installing modules on the server caused us to remove this functionality from the site. We also had development issues with getting the server to cooperate when things went wrong, and log errors correctly rather than fail silently with the default error screen.&lt;/p&gt; &#xA;&lt;p&gt;On the backend, we had problems with the speed of adding files and searching large quantities of them. Adding files is simple, but we keep track of the count of each word in a separate table per file, which must be generated whenever a file is added. Getting the strings for a file is easy, but this can generate hundreds of individual words. We must then do 100s of inserts into the database, slowing everything down. This is also done when a file is renamed, since we used filepath as a UNIQUE key and this cannot be changed after is is added to the db. This means that grouping, copying, and renaming is slow.&lt;/p&gt; &#xA;&lt;p&gt;Searching is not as fast as we would like either. We call grep -r to search through all of the user&#39;s files, which can potentially be slow if there are many files. This could have been sped up by using a database meant for searching text, like Apache Lucene. This database would index file contents, and unless the file changed, optimize the contents for quick searches. However, we cannot count on the files being kept constant, especially in file storage situations, and we did not have time to learn how to make a search engine, so this development idea had to fall to the wayside.&lt;/p&gt; &#xA;&lt;p&gt;We had problems separating Perl from HTML and CGI, where we had to find a way to write HTML files so that they could be changed easily, rather than having Perl do it. We also had trouble with the UI; anything more than a basic UI seems to require fudging around with either Perl CGI or using advanced CSS and Javascript, more skills than we possess. This means that the UI looks like it was designed by a 5 year old, and look ugly as sin; however, the UI is functional and works.&lt;/p&gt; &#xA;&lt;p&gt;We had implemented a go up one level directory button but in testing this on CLIC we ran into issue with it displaying properly this specific feature is currently unusuable. However, users can use forward and back buttons of the browsers to get around this issue.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;License&lt;/strong&gt; All source code is licensed under the Simplified BSD license (2-clause BSD). All documentation is licensed under the FreeBSD Documentation License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>perigrin/http-thin-useragent</title>
    <updated>2023-08-13T01:57:12Z</updated>
    <id>tag:github.com,2023-08-13:/perigrin/http-thin-useragent</id>
    <link href="https://github.com/perigrin/http-thin-useragent" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Thin UserAgent Wrapper around HTTP::Thin&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HTTP::Thin::UserAgent&lt;/h1&gt; &#xA;&lt;p&gt;HTTP::Thin::UserAgent -- A Thin Wrapper around HTTP::Thin&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;use HTTP::Thin::UserAgent;&#xA;&#xA;my $data = http( POST &#39;http://api.metacpan.org/v0/release/_search&#39;)-&amp;gt;as_json(&#xA;    {   query  =&amp;gt; { match_all =&amp;gt; {} },&#xA;        size   =&amp;gt; 5000,&#xA;        fields =&amp;gt; [&#39;distribution&#39;],&#xA;        filter =&amp;gt; {&#xA;            and =&amp;gt; [&#xA;                {   term =&amp;gt; {&#xA;                        &#39;release.dependency.module&#39; =&amp;gt; &#39;MooseX::NonMoose&#39;&#xA;                    }&#xA;                },&#xA;                { term =&amp;gt; { &#39;release.maturity&#39; =&amp;gt; &#39;released&#39; } },&#xA;                { term =&amp;gt; { &#39;release.status&#39;   =&amp;gt; &#39;latest&#39; } }&#xA;            ]&#xA;        }&#xA;    }&#xA;)-&amp;gt;decoded_content;&#xA;&#xA;my $results = http(GET &#39;http://www.imdb.com/find?q=Kevin+Bacon&#39;)-&amp;gt;scraper(&#xA;    scraper {&#xA;        process &#39;.findResult&#39;, &#39;results[]&#39; =&amp;gt; scraper {&#xA;            process &#39;.result_text&#39;, text =&amp;gt; &#39;TEXT&#39;;&#xA;            process &#39;.result_text &amp;gt; a&#39;, link =&amp;gt; &#39;@href&#39;;&#xA;        }&#xA;    }&#xA;)-&amp;gt;decoded_content;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>