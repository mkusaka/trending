<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-30T02:02:41Z</updated>
  <subtitle>Weekly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mateu/MooX-Types-MooseLike-Numeric</title>
    <updated>2023-07-30T02:02:41Z</updated>
    <id>tag:github.com,2023-07-30:/mateu/MooX-Types-MooseLike-Numeric</id>
    <link href="https://github.com/mateu/MooX-Types-MooseLike-Numeric" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Numeric types for Moo like those for Moose (MooseX::Types::Common::Numeric)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MooX-Types-MooseLike-Numeric&lt;/h1&gt; &#xA;&lt;p&gt;Numeric types for Moo like those for Moose (MooseX::Types::Common::Numeric)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>interpreters/perlpp</title>
    <updated>2023-07-30T02:02:41Z</updated>
    <id>tag:github.com,2023-07-30:/interpreters/perlpp</id>
    <link href="https://github.com/interpreters/perlpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Perl preprocessor - embed Perl source in any file&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PerlPP: Perl preprocessor&lt;/h1&gt; &#xA;&lt;p&gt;Translates &lt;strong&gt;Text+Perl&lt;/strong&gt; to &lt;strong&gt;Text&lt;/strong&gt;. It can be used for any kind of text templating, e.g. code generation. No external modules are required, just a single file. Requires Perl 5.10.1+.&lt;/p&gt; &#xA;&lt;p&gt;PerlPP runs in two passes: it generates a Perl script from your input, and then it runs the generated script. If you see &lt;code&gt;error at (eval ##)&lt;/code&gt; (for some number &lt;code&gt;##&lt;/code&gt;), it means there was an error in the generated script.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Easy way #1: &lt;code&gt;cpanm Text::PerlPP&lt;/code&gt; (using &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus&#34;&gt;cpanminus&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Easy way #2: copy the &lt;code&gt;perlpp&lt;/code&gt; file from the &lt;a href=&#34;https://github.com/interpreters/perlpp/releases/latest&#34;&gt;latest release&lt;/a&gt; into a directory in your &lt;code&gt;PATH&lt;/code&gt;, and &lt;code&gt;chmod a+x perlpp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For development or more information, see the other &lt;a href=&#34;https://raw.githubusercontent.com/interpreters/perlpp/master/README&#34;&gt;README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: perl perlpp.pl [options] [filename]&#xA;Options:&#xA;&#x9;-o, --output filename&#x9;Output to the file instead of STDOUT.&#xA;&#x9;-D, --define name=value&#x9;Set $D{name}=value in the generated&#xA;&#x9;&#x9;&#x9;&#x9;code.  The hash %D always exists, but&#xA;&#x9;&#x9;&#x9;&#x9;is empty if you haven&#39;t specified any&#xA;&#x9;&#x9;&#x9;&#x9;-D options.&#xA;&#x9;&#x9;&#x9;&#x9;Also substitutes _name_ with _value_&#xA;&#x9;&#x9;&#x9;&#x9;in the output file.&#xA;&#x9;&#x9;&#x9;&#x9;_value_ is optional and defaults to&#xA;&#x9;&#x9;&#x9;&#x9;true.&#xA;&#x9;-e, --eval statement&#x9;Evaluate the statement(s) before any&#xA;&#x9;&#x9;&#x9;&#x9;Perl code of the input files.&#xA;&#x9;-E, --debug&#x9;&#x9;Don&#39;t evaluate Perl code, just write&#xA;&#x9;&#x9;&#x9;&#x9;it to STDERR.&#xA;&#x9;-k, --keep-going&#x9;Don&#39;t stop on errors in an external command&#xA;&#x9;-s, --set name=value&#x9;As -D, but generates into %S and does&#xA;&#x9;&#x9;&#x9;&#x9;not substitute in the text body.&#xA;&#x9;-h, --help&#x9;&#x9;Usage help.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a &lt;strong&gt;-D&lt;/strong&gt; option, the &lt;code&gt;value&lt;/code&gt; must be a valid Perl value, e.g., &lt;code&gt;&#34;foo&#34;&lt;/code&gt; for a string. This may require you to escape quotes in the &lt;strong&gt;-D&lt;/strong&gt; argument, depending on your shell. E.g., if &lt;code&gt;-D foo=&#34;bar&#34;&lt;/code&gt; doesn&#39;t work, try &lt;code&gt;-D &#39;foo=&#34;bar&#34;&#39;&lt;/code&gt; (with single quotes around the whole &lt;code&gt;name=value&lt;/code&gt; part).&lt;/p&gt; &#xA;&lt;h2&gt;Syntax of the input file&lt;/h2&gt; &#xA;&lt;p&gt;The syntax is a bit similar to PHP. Perl code is included between &lt;code&gt;&amp;lt;?&lt;/code&gt; and &lt;code&gt;?&amp;gt;&lt;/code&gt; tags. There are several modes, indicated by the character after the &lt;code&gt;&amp;lt;?&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?&#x9;code mode: Perl code is between the tags.&#xA;&amp;lt;?=&#x9;echo mode: prints a Perl expression.&#xA;&amp;lt;?:&#x9;internal-command mode: executed by PerlPP itself.&#xA;&amp;lt;?/&#x9;code mode, beginning with printing a line break.&#xA;&amp;lt;?#&#x9;comment mode: everything in &amp;lt;?# ... ?&amp;gt; is ignored.&#xA;&amp;lt;?!&#x9;external mode: everything in &amp;lt;?! ... ?&amp;gt; is run as an external command.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code mode is started by &lt;code&gt;&amp;lt;?&lt;/code&gt; followed by any number of whitespaces or line breaks.&lt;/p&gt; &#xA;&lt;p&gt;If there is any non-whitespace character after &lt;code&gt;&amp;lt;?&lt;/code&gt; other than those starting the special modes, then this tag will be ignored (passed as it is). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?x this tag is passed as is ?&amp;gt; because &#34;x&#34; is not a valid mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;produces the result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?x this tag is passed as is ?&amp;gt; because &#34;x&#34; is not a valid mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Generated Script&lt;/h2&gt; &#xA;&lt;p&gt;The generated script:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;is in its own package, named based on the input filename and a unique number&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;use&lt;/code&gt;s &lt;code&gt;5.010001&lt;/code&gt;, &lt;code&gt;strict&lt;/code&gt;, and &lt;code&gt;warnings&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;provides constants &lt;code&gt;true&lt;/code&gt; (=&lt;code&gt;!!1&lt;/code&gt;) and &lt;code&gt;false&lt;/code&gt; (=&lt;code&gt;!!0&lt;/code&gt;) (with &lt;code&gt;use constant&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;declares &lt;code&gt;my %D&lt;/code&gt; and initializes &lt;code&gt;%D&lt;/code&gt; based on any &lt;strong&gt;-D&lt;/strong&gt; options you provide&lt;/li&gt; &#xA; &lt;li&gt;declares &lt;code&gt;my %S&lt;/code&gt; and initializes &lt;code&gt;%S&lt;/code&gt; based on any &lt;strong&gt;-s&lt;/strong&gt; options you provide&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other than that, everything in the script comes from your input file(s). Use the &lt;strong&gt;-E&lt;/strong&gt; option to see the generated script.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Basic loop&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;Hello &amp;lt;? print &#34;world&#34;; ?&amp;gt; (again).&#xA;&amp;lt;?# I don&#39;t appear in the output ?&amp;gt;but I do.&#xA;&amp;lt;? for ( my $i = 0; $i &amp;lt; 5; $i++ ) { ?&amp;gt;&#xA;&#x9;number: &amp;lt;?= $i ?&amp;gt;&#xA;&amp;lt;? } ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Hello world (again).&#xA;but I do.&#xA;&#xA;&#x9;number: 0&#xA;&#xA;&#x9;number: 1&#xA;&#xA;&#x9;number: 2&#xA;&#xA;&#x9;number: 3&#xA;&#xA;&#x9;number: 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Loop with less whitespace&lt;/h3&gt; &#xA;&lt;p&gt;In order to remove empty lines, one might write it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Hello &amp;lt;? print &#34;world&#34;; ?&amp;gt; (again).&#xA;&amp;lt;?  for ( my $i = 0; $i &amp;lt; 5; $i++ ) { ?&amp;gt;number: &amp;lt;?= $i ?&amp;gt;&#xA;&amp;lt;? } ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Hello world (again).&#xA;number: 0&#xA;number: 1&#xA;number: 2&#xA;number: 3&#xA;number: 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Line breaks using &lt;code&gt;&amp;lt;?/&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;foo&amp;lt;? print &#34;bar&#34;;?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;produces the output&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;foobar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Adding the &lt;code&gt;/&lt;/code&gt;, to make&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;foo&amp;lt;?/ print &#34;bar&#34;;?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;produces the output&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;foo&#xA;bar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So &lt;code&gt;&amp;lt;?/ ... ?&amp;gt;&lt;/code&gt; is effectively a shorthand for &lt;code&gt;&amp;lt;? print &#34;\n&#34;; ... ?&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;External commands using &lt;code&gt;&amp;lt;?!&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?! echo Howdy! ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;produces the output&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Howdy!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the command returns an error status, perlpp will as well, unless you specify &lt;strong&gt;-k&lt;/strong&gt;. That way you can use perlpp and external commands in &lt;code&gt;make&lt;/code&gt; and other programs that check exit codes, and not silently lose error information. For example, running &lt;code&gt;perlpp&lt;/code&gt; on the input:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?! false ?&amp;gt; More stuff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will give you an error message (from the &lt;code&gt;false&lt;/code&gt;&#39;s error return), and will not print &lt;code&gt;More stuff&lt;/code&gt;. Running &lt;code&gt;perlpp -k&lt;/code&gt; on that same input will give the error message and will print &lt;code&gt;More stuff&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Internal Commands&lt;/h2&gt; &#xA;&lt;h3&gt;Include&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?:include file.p ?&amp;gt;&#xA;&amp;lt;?:include &#34;long file name.p&#34; ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Includes source code of another PerlPP file into this position. Note that this file can be any PerlPP input, so you can also use this to include plain text files or other literal files. When using the long form, make sure there is whitespace between the trailing &lt;code&gt;&#34;&lt;/code&gt; and the closing tag &lt;code&gt;?&amp;gt;&lt;/code&gt;, as explained below under &#34;Capturing.&#34;&lt;/p&gt; &#xA;&lt;h3&gt;Prefix&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?:prefix foo bar ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replaces word prefixes in the following output. In this case words like &lt;code&gt;fooSomeWord&lt;/code&gt; will become &lt;code&gt;barSomeWord&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Macro&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?:macro some_perl_code; ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will run &lt;code&gt;some_perl_code;&lt;/code&gt; at the time of script generation. Whatever output the perl code produces will be included verbatim in the script output. Within &lt;code&gt;some_perl_code&lt;/code&gt;, the current PerlPP instance is available as &lt;code&gt;$PSelf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This can be used to dynamically select which files you want to include, using the provided &lt;code&gt;Include()&lt;/code&gt; method. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?:macro my $fn=&#34;some_name&#34;; $PSelf-&amp;gt;Include($fn); ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;has the same effect as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?:include some_name ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but &lt;code&gt;$fn&lt;/code&gt; can be determined programmatically. Note that defines set with &lt;strong&gt;-D&lt;/strong&gt; or &lt;strong&gt;-s&lt;/strong&gt; do not take effect until after the script has been generated, which is after the macro code runs. However, those are available as hashes &lt;code&gt;$PSelf-&amp;gt;{Defs}&lt;/code&gt; and &lt;code&gt;$PSelf-&amp;gt;{Sets}&lt;/code&gt; in macro code.&lt;/p&gt; &#xA;&lt;h2&gt;Capturing&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes it is great to get (capture) source text into a Perl string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;?&amp;gt;&#x9;&#x9;start of capturing&#xA;&amp;lt;?&#34;&#x9;&#x9;end of capturing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There must be no whitespace between the &lt;code&gt;&#34;&lt;/code&gt; and the &lt;code&gt;?&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;?&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;? print &#34;?&amp;gt;That&#39;s cool&amp;lt;?&#34; . &#34;?&amp;gt;, really.&amp;lt;?&#34;; ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is the same as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;? print &#39;That\&#39;s cool&#39; . &#39;, really.&#39;; ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Captured strings are properly escaped, and can be sequenced like in this example. Moreover, they can be nested!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?&#xA;&#x9;sub ABC {&#xA;&#x9;&#x9;for my $c ( &#34;a&#34;..&#34;z&#34; ) {&#xA;&#x9;&#x9;&#x9;print $c;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;?&amp;gt;&#xA;&amp;lt;? ABC(); ?&amp;gt;&#xA;&amp;lt;?= uc( &#34;?&amp;gt;alphabet&#xA;&#x9;&amp;lt;? ABC(); ?&amp;gt;&#xA;&amp;lt;?&#34; ); ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Printed characters from the second &lt;code&gt;ABC()&lt;/code&gt; call are attached to the string &lt;code&gt;&#39;alphabet &#39;&lt;/code&gt;, so the result will be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;abcdefghijklmnopqrstuvwxyz&#xA;ALPHABET&#xA;&#x9;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Capturing works in all modes: code, echo, internal-command, or external-command mode.&lt;/p&gt; &#xA;&lt;h2&gt;C Preprocessor Emulation&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;-D&lt;/strong&gt; switch defines elements of &lt;code&gt;%D&lt;/code&gt;. If you do not specify a value, the value &lt;code&gt;true&lt;/code&gt; (a constant in the generated script) will be used. The following commands work mostly analogously to their C preprocessor counterparts.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:define NAME ?&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:undef NAME ?&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:ifdef NAME ?&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:ifndef NAME ?&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:else ?&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:endif ?&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:if NAME CONDITION ?&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;?:elsif NAME CONDITION ?&amp;gt;&lt;/code&gt; (&lt;code&gt;elif&lt;/code&gt; and &lt;code&gt;elseif&lt;/code&gt; are synonyms)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?:ifdef NAME ?&amp;gt;&#xA;&#x9;foo&#xA;&amp;lt;?:endif ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is the same as the more verbose script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;? if(defined($D{NAME})) { ?&amp;gt;&#xA;&#x9;foo&#xA;&amp;lt;? } ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;If and Elsif&lt;/h3&gt; &#xA;&lt;p&gt;Tests with &lt;code&gt;&amp;lt;?:if NAME ... ?&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;?:elsif NAME ... ?&amp;gt;&lt;/code&gt; have two restrictions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If &lt;code&gt;$D{NAME}&lt;/code&gt; does not exist, the test will be &lt;code&gt;false&lt;/code&gt; regardless of the condition &lt;code&gt;...&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;...&lt;/code&gt; must be a valid Perl expression when &lt;code&gt;$D{NAME}&lt;/code&gt; is added to the beginning, with no parentheses around it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;&amp;lt;?:if FOO eq &#34;something&#34; ?&amp;gt;&lt;/code&gt; (note the whitespace before &lt;code&gt;?&amp;gt;&lt;/code&gt;!) will work fine. However, if you want to test &lt;code&gt;(FOO+1)*3&lt;/code&gt;, you will need to use the full Perl code &lt;code&gt;&amp;lt;? if( (FOO+1)*3 == 42 ) { ... } ?&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;?:if ?&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;?:endif?&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Other Features&lt;/h2&gt; &#xA;&lt;h3&gt;Custom Preprocessors&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s possible to create your own pre/post-processors in a &lt;code&gt;&amp;lt;?:macro ?&amp;gt;&lt;/code&gt; block using &lt;code&gt;$PSelf-&amp;gt;AddPreprocessor&lt;/code&gt; and &lt;code&gt;$PSelf-&amp;gt;AddPostprocessor&lt;/code&gt;. This feature is used in &lt;a href=&#34;https://github.com/d-ash/BigBenBox&#34;&gt;BigBenBox&lt;/a&gt; for generating code in the C programming language.&lt;/p&gt; &#xA;&lt;h3&gt;Future&lt;/h3&gt; &#xA;&lt;p&gt;Suggestions are welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Highlighting in your editor&lt;/h2&gt; &#xA;&lt;h3&gt;Vim&lt;/h3&gt; &#xA;&lt;p&gt;To make highlight PerlPP insets in Vim, add this to &lt;em&gt;~/.vimrc&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;autocmd colorscheme * hi PerlPP ctermbg=darkgrey ctermfg=lightgreen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and create corresponding &lt;em&gt;~/.vim/after/syntax/FILETYPE.vim&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;syntax region PerlPP start=&#39;&amp;lt;?&#39; end=&#39;?&amp;gt;&#39; containedin=ALL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;FILETYPE can be determined with &lt;code&gt;:set ft?&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Distributed under the MIT license --- see &lt;a href=&#34;https://raw.githubusercontent.com/interpreters/perlpp/master/LICENSE.txt&#34;&gt;LICENSE.txt&lt;/a&gt; for details. By Andrey Shubin (&lt;a href=&#34;https://github.com/d-ash&#34;&gt;d-ash&lt;/a&gt;) and Chris White (CXW; &lt;a href=&#34;https://github.com/cxw42&#34;&gt;cxw42&lt;/a&gt;); additional contributions by Mohammad S Anwar (MANWAR; &lt;a href=&#34;https://github.com/manwar&#34;&gt;manwar&lt;/a&gt;).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>gleb-roma/google_count</title>
    <updated>2023-07-30T02:02:41Z</updated>
    <id>tag:github.com,2023-07-30:/gleb-roma/google_count</id>
    <link href="https://github.com/gleb-roma/google_count" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Requirements: perl mySQL openvpn HMA files in ../hma&lt;/p&gt; &#xA;&lt;p&gt;To start the scraping, say&lt;/p&gt; &#xA;&lt;p&gt;sudo ./brun.sh&lt;/p&gt; &#xA;&lt;p&gt;or alike. To get data in text format of the form Country\tName_id\t1..52, use&lt;/p&gt; &#xA;&lt;p&gt;./make_panel.pl -l ru &amp;gt;output_file&lt;/p&gt; &#xA;&lt;p&gt;(requires in-text editing).&lt;/p&gt; &#xA;&lt;p&gt;File request.conf should contain configuration variables. NO_PROXY_FREQ equals zero if you do not want to use proxy servers.&lt;/p&gt; &#xA;&lt;p&gt;The lists with people names are taken from ./lists/&lt;/p&gt; &#xA;&lt;p&gt;Parallelization info at ~/Dropbox/Online\ Offline\ Indices\ Gleb/parallel&lt;/p&gt;</summary>
  </entry>
</feed>