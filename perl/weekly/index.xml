<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-28T01:40:53Z</updated>
  <subtitle>Weekly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Kong/lua-resty-events</title>
    <updated>2024-04-28T01:40:53Z</updated>
    <id>tag:github.com,2024-04-28:/Kong/lua-resty-events</id>
    <link href="https://github.com/Kong/lua-resty-events" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Inter process Pub/Sub pattern for Nginx worker processes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lua-resty-events&lt;/h1&gt; &#xA;&lt;p&gt;Inter process Pub/Sub pattern events propagation for Nginx worker processes&lt;/p&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#name&#34;&gt;Name&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#status&#34;&gt;Status&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#methods&#34;&gt;Methods&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#init_worker&#34;&gt;init_worker&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#run&#34;&gt;run&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#subscribe&#34;&gt;subscribe&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#unsubscribe&#34;&gt;unsubscribe&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#copyright-and-license&#34;&gt;Copyright and License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#see-also&#34;&gt;See Also&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;This library is currently considered experimental.&lt;/p&gt; &#xA;&lt;h1&gt;Synopsis&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;http {&#xA;    lua_package_path &#34;/path/to/lua-resty-events/lib/?/init.lua;;&#34;;&#xA;&#xA;    init_by_lua_block {&#xA;        local opts = {&#xA;            listening = &#34;unix:/tmp/events.sock&#34;,&#xA;        }&#xA;&#xA;        local ev = require(&#34;resty.events&#34;).new(opts)&#xA;        if not ev then&#xA;            ngx.log(ngx.ERR, &#34;failed to new events object&#34;)&#xA;        end&#xA;&#xA;        -- store ev to global&#xA;        _G.ev = ev&#xA;    }&#xA;&#xA;    init_worker_by_lua_block {&#xA;        -- fetch ev from global&#xA;        local ev = _G.ev&#xA;&#xA;        local handler = function(data, event, source, wid)&#xA;            print(&#34;received event; source=&#34;, source,&#xA;                  &#34;, event=&#34;, event,&#xA;                  &#34;, data=&#34;, tostring(data),&#xA;                  &#34;, from process &#34;, wid)&#xA;        end&#xA;&#xA;        local id1 = ev:subscribe(&#34;*&#34;, &#34;*&#34;, handler)&#xA;        local id2 = ev:subscribe(&#34;source&#34;, &#34;*&#34;, handler)&#xA;        local id3 = ev:subscribe(&#34;source&#34;, &#34;event&#34;, handler)&#xA;&#xA;        local ok, err = ev:init_worker()&#xA;        if not ok then&#xA;            ngx.log(ngx.ERR, &#34;failed to init events: &#34;, err)&#xA;        end&#xA;    }&#xA;&#xA;    # create a listening unix domain socket&#xA;    server {&#xA;        listen unix:/tmp/events.sock;&#xA;        location / {&#xA;            content_by_lua_block {&#xA;                -- fetch ev from global&#xA;                local ev = _G.ev&#xA;                ev:run()&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;This module provides a way to send events to the other worker processes in an Nginx server. Communication is through a unix domain socket which is listened by one and only one Nginx worker.&lt;/p&gt; &#xA;&lt;p&gt;The design allows for 3 usecases;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;broadcast an event to all workers processes, see &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;. Example: a healthcheck running in one worker, but informing all workers of a failed upstream node.&lt;/li&gt; &#xA; &lt;li&gt;broadcast an event to the current worker only, see &lt;code&gt;target&lt;/code&gt; parameter of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;coalesce external events to a single action. Example: all workers watch external events indicating an in-memory cache needs to be refreshed. When receiving it they all post it with a unique event hash (all workers generate the same hash), see &lt;code&gt;target&lt;/code&gt; parameter of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;. Now only 1 worker will receive the event &lt;em&gt;only once&lt;/em&gt;, so only one worker will hit the upstream database to refresh the in-memory data.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Methods&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;new&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ev = events.new(opts)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Return a new events object. It should be stored in global scope for &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#run&#34;&gt;run&lt;/a&gt; later.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;opts&lt;/code&gt; parameter is a Lua table with named options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;listening&lt;/code&gt;: the unix domain socket, which must be same as another &lt;code&gt;server&lt;/code&gt; block.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;broker_id&lt;/code&gt;: (optional) the worker id that will start to listen, default &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unique_timeout&lt;/code&gt;: (optional) timeout of unique event data stored (in seconds), default &lt;code&gt;5&lt;/code&gt;. See the &lt;code&gt;target&lt;/code&gt; parameter of the &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt; method.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_queue_len&lt;/code&gt;: (optional) max length of internal events buffer queue, default &lt;code&gt;1024 * 10&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_payload_len&lt;/code&gt;: (optional) max length of serialized event data, default &lt;code&gt;1024 * 64&lt;/code&gt;, max &lt;code&gt;1024 * 1024 * 16&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The return value will be the event object or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There is a special parameter &lt;code&gt;testing&lt;/code&gt;, which means the library will not enable unix domain socket listening, and the events will only be propagated in the worker process internally. In the meanwhile, &lt;code&gt;unique_timeout&lt;/code&gt; will be meanless.&lt;/p&gt; &#xA;&lt;p&gt;This feature is very useful for testing, such as &lt;code&gt;resty cli&lt;/code&gt;. The default value for &lt;code&gt;testing&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;init_worker&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = ev:init_worker()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;init_worker_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will initialize the event listener. This should typically be called from the &lt;code&gt;init_worker_by_lua&lt;/code&gt; handler, because it will make sure only one Nginx worker starts to listen on unix domain socket.&lt;/p&gt; &#xA;&lt;p&gt;The return value will be &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; and an error message.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;run&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ev:run()&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;content_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Active the event loop only in Nginx broker process, see opts &lt;code&gt;broker_id&lt;/code&gt; of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;. it must be called in &lt;code&gt;content_by_lua*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ev&lt;/code&gt; object must be the same object returned by &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Should not call it if &lt;code&gt;testing&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;publish&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ok, err = ev:publish(target, source, event, data)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;all phases except init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will post a new event. &lt;code&gt;target&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;event&lt;/code&gt; are all strings. &lt;code&gt;data&lt;/code&gt; can be anything (including &lt;code&gt;nil&lt;/code&gt;) as long as it is (de)serializable by the LuaJIT string buffer serializer and cJSON (legacy).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;target&lt;/code&gt; parameter could be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;all&#34; : the event will be broadcasted to all workers.&lt;/li&gt; &#xA; &lt;li&gt;&#34;current&#34; : the event will be local to the worker process, it will not be broadcasted to other workers. With this method, the &lt;code&gt;data&lt;/code&gt; element will not be serialized.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;unique hash&lt;/em&gt; : the event will be send to only one worker. Also any follow up events with the same hash value will be ignored (for the &lt;code&gt;unique_timeout&lt;/code&gt; period specified to &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#new&#34;&gt;new&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The return value will be &lt;code&gt;true&lt;/code&gt; when the event was successfully published or &lt;code&gt;nil + error&lt;/code&gt; in case of cjson serializition failure or event queue full.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: in case of &#34;all&#34; and &#34;current&#34; the worker process sending the event, will also receive the event! So if the eventsource will also act upon the event, it should not do so from the event posting code, but only when receiving it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: in case of &#34;all&#34; and &#34;&lt;em&gt;unique hash&lt;/em&gt;&#34; the serialized data has a hard-coded limit &lt;code&gt;2^24 - 1&lt;/code&gt; bytes. It means that we can not send any data which is larger than 16MB.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;subscribe&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;id = ev:subscribe(source, event, callback)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;all phases except init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will register a callback function to receive events. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;event&lt;/code&gt; are &lt;code&gt;*&lt;/code&gt;, then the callback will be executed on &lt;em&gt;every&lt;/em&gt; event, if &lt;code&gt;source&lt;/code&gt; is provided and &lt;code&gt;event&lt;/code&gt; is &lt;code&gt;*&lt;/code&gt;, then only events with a matching source will be passed. If event name is given, then only when both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;event&lt;/code&gt; match the callback is invoked.&lt;/p&gt; &#xA;&lt;p&gt;The callback should have the following signature;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: callback = function(data, event, source, wid)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The parameters will be the same as the ones provided to &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#publish&#34;&gt;publish&lt;/a&gt;, except for the extra value &lt;code&gt;wid&lt;/code&gt; which will be the worker id of the originating worker process, or &lt;code&gt;nil&lt;/code&gt; if it was a local event only. Any return value from &lt;code&gt;callback&lt;/code&gt; will be discarded. &lt;em&gt;Note:&lt;/em&gt; &lt;code&gt;data&lt;/code&gt; may be a reference type of data (eg. a Lua &lt;code&gt;table&lt;/code&gt; type). The same value is passed to all callbacks, &lt;em&gt;so do not change the value in your handler, unless you know what you are doing!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The return value of &lt;code&gt;subscribe&lt;/code&gt; will be a callback id, or it will throw an error if &lt;code&gt;callback&lt;/code&gt; is not a function value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;unsubscribe&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;syntax:&lt;/strong&gt; &lt;em&gt;ev:unsubscribe(id)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;context:&lt;/strong&gt; &lt;em&gt;all phases except init_by_lua*&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Will unregister the callback function and prevent it from receiving further events. The parameter &lt;code&gt;id&lt;/code&gt; is the return value of &lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#subscribe&#34;&gt;subscribe&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2022 Kong Inc.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;See Also&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Kong: &lt;a href=&#34;https://konghq.com/&#34;&gt;https://konghq.com/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Kong/lua-resty-events/main/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tipdbmp/misc</title>
    <updated>2024-04-28T01:40:53Z</updated>
    <id>tag:github.com,2024-04-28:/tipdbmp/misc</id>
    <link href="https://github.com/tipdbmp/misc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;misc stuff&lt;/p&gt;&lt;hr&gt;&lt;p&gt;misc modules/templates/snippets&lt;/p&gt; &#xA;&lt;p&gt;http_async: a must have wrapper around AnyEvent::HTTP::http_request&lt;/p&gt; &#xA;&lt;p&gt;SetTheory: the set operations ∪, ∩, -, ^ ∪ : union (elements that are both in A or B) ∩ : intersection (elements incommon) - : difference (elements that are members of A but not members of B) ^ : symmetric difference (only in A or only in B but not both)&lt;/p&gt; &#xA;&lt;p&gt;Module: a module template (yeah it is that difficult in Perl :P)&lt;/p&gt; &#xA;&lt;p&gt;special_literals: those come in handy from time to time&lt;/p&gt;</summary>
  </entry>
</feed>