<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Perl Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-19T02:02:30Z</updated>
  <subtitle>Weekly Trending of Perl in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>takeyuweb/mt-plugin-entrytree</title>
    <updated>2023-03-19T02:02:30Z</updated>
    <id>tag:github.com,2023-03-19:/takeyuweb/mt-plugin-entrytree</id>
    <link href="https://github.com/takeyuweb/mt-plugin-entrytree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ブログ記事が木構造の親子関係を持てるようになり、テンプレートで親、子、兄弟記事を取得したりできるようになります。&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;mt-plugin-entrytree&lt;/h1&gt; &#xA;&lt;p&gt;ブログ記事が木構造の親子関係を持てるようになり、テンプレートで親、子、兄弟記事を取得したりできるようになります。（MT5.1～）&lt;/p&gt; &#xA;&lt;h2&gt;機能&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ブログ記事に親記事IDを追加&lt;/li&gt; &#xA; &lt;li&gt;ブログ記事一覧に親記事、子記事列を追加 一覧画面から直接子記事を作成可能&lt;/li&gt; &#xA; &lt;li&gt;各記事を取得するためのテンプレートタグ（PHPダイナミックパブリッシング未対応）&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;テンプレートタグ（ブロックタグ）&lt;/h2&gt; &#xA;&lt;h3&gt;MTEntryParent&lt;/h3&gt; &#xA;&lt;p&gt;親記事を取得&lt;/p&gt; &#xA;&lt;h3&gt;MTEntryChildren&lt;/h3&gt; &#xA;&lt;p&gt;子記事を取得&lt;/p&gt; &#xA;&lt;h3&gt;MTEntrySiblings&lt;/h3&gt; &#xA;&lt;p&gt;兄弟記事を取得&lt;/p&gt; &#xA;&lt;h3&gt;MTEntryAncestors&lt;/h3&gt; &#xA;&lt;p&gt;祖先記事を取得&lt;/p&gt; &#xA;&lt;h3&gt;MTEntryDescendants&lt;/h3&gt; &#xA;&lt;p&gt;子孫記事を取得&lt;/p&gt; &#xA;&lt;h2&gt;例&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;mt:EntryChildren&amp;gt;&#xA;    &amp;lt;mt:EntriesHeader&amp;gt;&amp;lt;ul&amp;gt;&amp;lt;/mt:EntriesHeader&amp;gt;&#xA;    &amp;lt;li&amp;gt;&amp;lt;$MTEntryTitle$&amp;gt;&amp;lt;/li&amp;gt;&#xA;    &amp;lt;mt:EntriesFooter&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/mt:EntriesFooter&amp;gt;&#xA;&amp;lt;/mt:EntryChildren&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;各テンプレートタグは MTEntries と同じモディファイアを利用できます。（内部的に MTEntries の処理を流用しています）&lt;/p&gt; &#xA;&lt;h2&gt;Contributing to mt-plugin-entrytree&lt;/h2&gt; &#xA;&lt;p&gt;Fork, fix, then send me a pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright(c) 2013 Yuichi Takeuchi, released under the MIT license&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mauke/Scope-OnExit-Wrap</title>
    <updated>2023-03-19T02:02:30Z</updated>
    <id>tag:github.com,2023-03-19:/mauke/Scope-OnExit-Wrap</id>
    <link href="https://github.com/mauke/Scope-OnExit-Wrap" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Scope-OnExit-Wrap&lt;/p&gt; &#xA;&lt;p&gt;Running code on scope exit (with pure Perl fallback)&lt;/p&gt; &#xA;&lt;p&gt;INSTALLATION&lt;/p&gt; &#xA;&lt;p&gt;To install this module, run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perl Makefile.PL&#xA;make&#xA;make test&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SUPPORT AND DOCUMENTATION&lt;/p&gt; &#xA;&lt;p&gt;After installing, you can find documentation for this module with the perldoc command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perldoc Scope::OnExit::Wrap&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also look for information at:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;RT, CPAN&#39;s request tracker&#xA;    http://rt.cpan.org/NoAuth/Bugs.html?Dist=Scope-OnExit-Wrap&#xA;&#xA;AnnoCPAN, Annotated CPAN documentation&#xA;    http://annocpan.org/dist/Scope-OnExit-Wrap&#xA;&#xA;CPAN Ratings&#xA;    http://cpanratings.perl.org/d/Scope-OnExit-Wrap&#xA;&#xA;Search CPAN&#xA;    http://search.cpan.org/dist/Scope-OnExit-Wrap/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;COPYRIGHT AND LICENCE&lt;/p&gt; &#xA;&lt;p&gt;Copyright (C) 2013 Lukas Mai&lt;/p&gt; &#xA;&lt;p&gt;This program is free software; you can redistribute it and/or modify it under the terms of either: the GNU General Public License as published by the Free Software Foundation; or the Artistic License.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://dev.perl.org/licenses/&#34;&gt;http://dev.perl.org/licenses/&lt;/a&gt; for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mfs/husk</title>
    <updated>2023-03-19T02:02:30Z</updated>
    <id>tag:github.com,2023-03-19:/mfs/husk</id>
    <link href="https://github.com/mfs/husk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;iptables firewall compiler&lt;/p&gt;&lt;hr&gt;&lt;p&gt;husk %VERSION% &lt;a href=&#34;http://www.huskfw.info&#34;&gt;http://www.huskfw.info&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;husk is a natural language wrapper around the Linux iptables packet filtering. It is designed to abstract the sometimes confusing syntax of iptables into a format that is easier and friendlier to read and understand.&lt;/p&gt; &#xA;&lt;p&gt;husk can be used on either firewall/router computers (with multiple network interfaces), or standalone systems (with one network interface)&lt;/p&gt; &#xA;&lt;p&gt;Each interface (real or virtual) is called a &#39;zone&#39; in husk. Zones are given a friendly name which is what is used in the rule definitions. This abstracts the Linux device names (eg, eth0, ppp0, bond0 etc) into much more intuitive names such as NET, LAN and DMZ. This has the added benefit of moving interfaces in the future can be done simply by changing the name-to-device mapping.&lt;/p&gt; &#xA;&lt;p&gt;===============================================================================&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;INSTALLATION.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Husk can be installed using standard &#39;make&#39; commands. You must be root to install correctly.&lt;/p&gt; &#xA;&lt;p&gt;Install everything: make all&lt;/p&gt; &#xA;&lt;p&gt;Install only the script: make bin&lt;/p&gt; &#xA;&lt;p&gt;Install only the docs: make docs&lt;/p&gt; &#xA;&lt;p&gt;Install only the configuration examples: make config&lt;/p&gt; &#xA;&lt;p&gt;Uninstallation is also catered for: make uninstall&lt;/p&gt; &#xA;&lt;p&gt;===============================================================================&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SETUP.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First, give your interfaces friendly names in the file &#39;interfaces.conf&#39;. An example file might look like: zone ME is lo zone NET is eth0 zone LAN is eth1 zone DMZ is eth2 I recommend simple 3 letter friendly names for your zones.&lt;/p&gt; &#xA;&lt;p&gt;IMPORTANT NOTE: loopback (&#39;lo&#39;) &lt;em&gt;must&lt;/em&gt; be called the special name &#39;ME&#39;.&lt;/p&gt; &#xA;&lt;p&gt;===============================================================================&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;WRITING RULES.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;===============================================================================&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Common Firewalling husk has built-in &#39;common&#39; firewall rules, prefixed with the keyword &#39;common&#39; NAT: common nat ZONE Apply a Source NAT to traffic going out ZONE, usually &#39;NET&#39; eg: common nat NET SPOOF: common spoof ZONE ADDRESS/PREFIX Prevent address spoofing on the specified ZONE. ADDRESS/PREFIX defines the addresses that are expected to be seen on the given ZONE. You can add multiple &#39;spoof&#39; rules per interface. eg: common spoof LAN 10.0.0.0/24 common spoof LAN 10.0.1.0/24 common spoof DMZ 192.168.100.0/29 BOGON: common bogon ZONE Block bogon traffic on the specified ZONE. Bogon traffic is packets with source addresses that should never be seen outside private networks such as RFC1918 addresses, 127.0.0.0/8 etc. PORTSCAN: common portscan ZONE Attempt to detect, log and drop portscans coming from the given zone. This is only rudimentary, but it&#39;s better than nothing. XMAS: common xmas ZONE Block xmas packets on the specified ZONE. Xmas packets are packets with all flags set, or the packet &#34;is lit up like a Christmas tree&#34; SYN: common syn All packets that the kernel detects as belonging to a &#34;NEW&#34; connection should have the &#34;SYN&#34; flag set. If they don&#39;t, then we DROP them. LOOPBACK: common loopback Create a rule to accept traffic in/out the &#39;lo&#39; interface&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;=============================================================================== 2. define rules ZONE to ZONE Traffic passing between zones is known as cross-zone traffic - eg LAN to NET Defining rules for this cross-zone traffic is done in a &#39;define rules&#39; block: define rules LAN to NET &#xA; &lt;rules go here&gt;&#xA;   end define&#xA; &lt;/rules&gt;&lt;/p&gt; &#xA;&lt;p&gt;There is a special in-built interface called &#39;ANY&#39; which as the name suggests. allows you to write a match calls that ignores one (or both) of the IN and OUT interfaces. For example:&lt;/p&gt; &#xA;&lt;p&gt;Allow the whole world to access Secure POP3 on our mail server. define rules ANY to DMZ accept protocol tcp port pop3s destination address mail.example.com end define&lt;/p&gt; &#xA;&lt;p&gt;This is effectively the same as the FORWARD table, but only NEW connections are passed through here: define rules ANY to ANY accept protocol tcp port 873 # rsync anywhere is fine end define&lt;/p&gt; &#xA;&lt;p&gt;NOTE: &#39;ANY&#39; &lt;em&gt;excludes&lt;/em&gt; the other interface to avoid bounce routing issues. So a match calls for &#39;ANY to LAN&#39; doesn&#39;t include traffic &#39;LAN to LAN&#39;. If you need to allow bounce routing, then add a rule such as: define rules FORWARD accept incoming LAN outgoing LAN accept incoming DMZ outgoing DMZ &#xA; &lt;etc&gt;&#xA;   end define&#xA; &lt;/etc&gt;&lt;/p&gt; &#xA;&lt;p&gt;=============================================================================== 3. define rules &#xA; &lt;user defined&gt;&#xA;   You can create your own user-defined chains (UDC) using &#39;define rules&#39; block. These user-defined chains can then be called from cross-zone blocks. define rules SMB_PORTS &#xA;  &lt;rules go here&gt;&#xA;    end define&#xA;  &lt;/rules&gt;&#xA; &lt;/user&gt;&lt;/p&gt; &#xA;&lt;p&gt;=============================================================================== 4. define rules (INPUT|OUTPUT|FORWARD) To add rules to the standard iptables filter table chains (INPUT, FORWARD and OUTPUT), write a &#39;define rules&#39; UDC block for the appropriate chain: define rules INPUT &#xA; &lt;rules go here&gt;&#xA;   end define&#xA; &lt;/rules&gt;&lt;/p&gt; &#xA;&lt;p&gt;=============================================================================== 5. Rule Keywords Example rules are below. I think this will be the easiest way to explain the keywords and functions of husk. All keywords can be mixed and matched to suit the rule(s) you require.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;accept source address 192.168.100.100&#xA;    Accept anything from source address 192.168.100.100&#xA;&#xA;accept proto tcp port http destination address google.com.au&#xA;    Allow TCP port 80 to whatever &#39;google.com.au&#39; resolves to via DNS.&#xA;&#xA;accept proto tcp ports http,https source range 192.168.0.1 to 192.168.0.10&#xA;    Allow any TCP port 80 and 443 traffic from addresses .1 to .10&#xA;&#xA;accept mac 00:14:22:d8:f9:55&#xA;    Anything from the given MAC Address is allowed.&#xA;&#xA;reject source address 169.254.53.0/24&#xA;    Reject with ICMP unreachable packet any traffic from the given IP&#xA;&#xA;SMB_PORTS destination address 192.168.1.100&#xA;    Jump to the user-defined chain &#34;SMB_PORTS&#34; for traffic to 192.168.1.100&#xA;&#xA;accept all&#xA;    Accept everything.&#xA;&#xA;accept proto icmp type echo-request limit 4/sec burst 8&#xA;    Allow 4 ICMP &#39;echo-request&#39; packets per second, bursting to 8pps&#xA;&#xA;accept proto icmp type echo-reply limit 4/sec burst 12&#xA;    Allow 4 ICMP &#39;echo-reply&#39; packets per second, bursting to 12pps&#xA;&#xA;drop&#xA;    Just drop all packets.&#xA;&#xA;accept in LAN protocol icmp&#xA;    Accept any icmp packets that come in the LAN interface.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;=============================================================================== 6. Port Forwarding (DNAT) If you need to forward incoming traffic from one interface to another using the NAT feature of the kernel, you can use the &#39;map&#39; rule. For example, to NAT port 80 traffic coming in the &#34;NET&#34; interface to an internal server: map in NET destination address protocol tcp port 80 74.132.12.56 to 172.16.1.1&lt;/p&gt; &#xA;&lt;p&gt;You can also translate the ports from one to another by appending to the destination address: map in NET destination address 74.132.12.56:80 to 172.16.1.1:8080&lt;/p&gt; &#xA;&lt;p&gt;=============================================================================== 7. Intercepting / Redirection Using the &#39;trap&#39; or &#39;redirect&#39; keyword, you can silently redirect traffic to the local computer. This is useful for example to intercept all outgoing SMTP traffic to force it through the local SMTP gateway: trap in LAN protocol tcp port 25&lt;/p&gt; &#xA;&lt;p&gt;Redirecting to alternative ports is also possible: redirect incoming NET protocol tcp port 80 to 8080 redirect incoming NET protocol tcp port 2222 to 22&lt;/p&gt; &#xA;&lt;p&gt;=============================================================================== 8. Raw iptables rules Directly writing iptables rules is also supported for putting your own rules in using iptables syntax: iptables -t raw -A OUTPUT -d 10.0.0.0/8 -j NOTRACK&lt;/p&gt; &#xA;&lt;p&gt;=============================================================================== 9. Includes If your ruleset is complicated, you can spread the rules over multiple files then consoldate them all together at compile time by using the &#39;include&#39; keyword: include outbound.rules include inbound.rules&lt;/p&gt; &#xA;&lt;p&gt;Includes can be either relative paths (to the conf dir) or absolute paths. You should be able to nest indefintiely, but be careful not to create loops such as: [rule-one.conf] include rules-two.conf&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[rules-two.conf]&#xA;include rules-one.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is NO PROTECTION against this.&lt;/p&gt; &#xA;&lt;p&gt;===============================================================================&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;COPYRIGHT and LICENSE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;husk is Copyright 2010 Phillip Smith &amp;lt;fukawi2 (at) gmail (dot) com&amp;gt;&lt;/p&gt; &#xA;&lt;p&gt;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>