<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haxe Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-01T02:10:57Z</updated>
  <subtitle>Monthly Trending of Haxe in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>massive-oss/minject</title>
    <updated>2023-09-01T02:10:57Z</updated>
    <id>tag:github.com,2023-09-01:/massive-oss/minject</id>
    <link href="https://github.com/massive-oss/minject" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Haxe port of the ActionScript 3 SwiftSuspenders IOC library with efficient macro enhanced type reflection. Supports AVM1, AVM2, JavaScript, Neko and C++.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;minject is a metadata driven inversion of control (IOC) solution for Haxe. It has been thoroughly tested on JS, AVM1/2, PHP and Neko, but should also work on other platforms.&lt;/p&gt; &#xA;&lt;p&gt;This documentation is a modified version of the original, which can be found &lt;a href=&#34;https://github.com/tschneidereit/SwiftSuspenders/raw/the-past/README.textile&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;minject supports the following features as described in more details later in the documentation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;metadata based annotation of injection points&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;injecting into:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;properties&lt;/li&gt; &#xA;   &lt;li&gt;methods (with support for optional arguments)&lt;/li&gt; &#xA;   &lt;li&gt;constructors (with support for optional arguments)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;named injections, allowing for more specific binding of injections than just by their type. (See &#34;defining injection points&#34;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;@post annotations for invoking methods after all injections have been applied&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;mapping:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;values of nearly any type (enums, abstracts, typedefs, functions)&lt;/li&gt; &#xA;   &lt;li&gt;classes (of which new instances are created for each injection)&lt;/li&gt; &#xA;   &lt;li&gt;singletons (which are created lazily on first injection and then reused for each additional injection of the same rule)&lt;/li&gt; &#xA;   &lt;li&gt;rules (which allows sharing singletons between multiple mapping rules)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;creating child injectors which share their parents&#39; injection mappings but can define additional mappings complementing or replacing the parents&#39; ones&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;querying for the existence of injection rules using Injector#hasMapping&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;direct application of injection rules using Injector#getInstance&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib install minject&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You can find an example of minject usage &lt;a href=&#34;https://github.com/massiveinteractive/minject/raw/master/src/example&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Defining dependencies&lt;/h3&gt; &#xA;&lt;p&gt;minject supports three types of dependency definitions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;value bindings&lt;/em&gt;, which simply map an injection request to be satisfied by injecting the given value&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;class bindings&lt;/em&gt;, which map an injection request to be satisfied by injecting a new instance of the given class&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;singleton bindings&lt;/em&gt;, which map all injection requests for the given class by injecting the same shared instance, which itself gets created on first request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, it&#39;s possible to re-use dependency mappings with &lt;code&gt;mapRule&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For all definition types, it&#39;s possible to specify names, which allows using multiple injection bindings to the same class.&lt;/p&gt; &#xA;&lt;h3&gt;Defining injection points&lt;/h3&gt; &#xA;&lt;p&gt;Dependency bindings can be injected into an object using constructor, setter, property or method injection (or a combination of these). Constructor, Setter, property and method injection require metadata for all injections to be added to the injectee class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and for injecting named dependencies&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject(&#39;NamedDependency&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using basic constructor injections&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject public function new(foo:Bar, beautiful:Flower) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using named dependencies for constructor injection, the metadata has to be placed before the constructor method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject(&#39;NamedDependency&#39;) public function new(foo:Bar) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For methods and constructors accepting multiple parameters, it&#39;s possible to define mixes of named and unnamed dependency bindings. In this case, trailing unnamed dependencies can simply be omitted in the metadata, whereas unnamed dependencies followed by named ones have to be declared as the empty string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject(&#39;&#39;, &#39;NamedDependency&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For methods and constructors, only the mandatory arguments have to have injection mappings. Optional arguments are added in order as long as a mapping is available for them.&lt;/p&gt; &#xA;&lt;p&gt;Injection points apply to inheriting classes just as they do to the class they are defined for. Thus, it&#39;s possible to define injection points for a base class and use them with all derived classes (which in turn might specify additional injection points).&lt;/p&gt; &#xA;&lt;h3&gt;Post construct: Automatically invoking methods on injection completion&lt;/h3&gt; &#xA;&lt;p&gt;Instances of classes that depend on automatic DI are only ready to be used after the DI has completed. Annotating methods in the injectee class with the &lt;code&gt;@post&lt;/code&gt; metadata causes them to be invoked directly after all injections have completed and it is safe to use the instance. Multiple methods can be invoked in a defined order by specifying a priority: &lt;code&gt;@post(2)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Querying for injection mapping existence&lt;/h3&gt; &#xA;&lt;p&gt;minject supports querying for the existence of mapping rules for any request using &lt;code&gt;Injector#hasMapping&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;hasMapping&lt;/code&gt; expects a class or an interface and optionally a name for the mapping and returns &lt;code&gt;true&lt;/code&gt; if a request for this class/name combination can be satisfied. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Directly applying injection mappings&lt;/h3&gt; &#xA;&lt;p&gt;minject supports directly applying injection mappings using &lt;code&gt;Injector#getInstance&lt;/code&gt;. &lt;code&gt;getInstance&lt;/code&gt; expects a class or an interface and optionally a name for the mapping and returns the mapping&#39;s result if one is defined. Otherwise, an exception is thrown.&lt;/p&gt; &#xA;&lt;p&gt;The returned value depends on the mapping defined for the relevant request. E.g., if a singleton mapping has been defined for the request, the shared singleton instance will be returned instead of creating a new instance of the class.&lt;/p&gt; &#xA;&lt;h3&gt;Error handling&lt;/h3&gt; &#xA;&lt;p&gt;If a mapping for a requested injection is not found, an exception string containing the target class and the requested property type is thrown.&lt;/p&gt; &#xA;&lt;h3&gt;Child Injectors&lt;/h3&gt; &#xA;&lt;p&gt;minject supports creating child injectors. These are dependent on their parent injector and automatically inherit all rule mappings the parent has. Additionally, they can have their own rule mappings, complementing or overriding the parent mappings.&lt;/p&gt; &#xA;&lt;p&gt;The main use-case for this feature is as a solution to the so-called &#34;robot legs problem&#34;. When using Dependency Injection, one often wants to create very similar object trees that have only slight differences. A good illustration is a simplified robot, that can be built using identical parts for its legs but needs different parts for the left and the right foot. Using normal Dependency Injection, one would have to subclass the RobotLeg class for each leg only to enable specifying different injections for each foot. The subclasses would then have to implement boilerplate code to apply the injection to the variable the parent expects the foot in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class Robot&#xA;{&#xA;&#x9;@inject public var leftLeg:LeftRobotLeg;&#xA;&#x9;@inject public var rightLeg:RightRobotLeg;&#xA;}&#xA;&#xA;class RobotLeg&#xA;{&#xA;&#x9;var foot:RobotFoot;&#xA;}&#xA;&#xA;class LeftRobotLeg extends RobotLeg&#xA;{&#xA;&#x9;@inject public var foot:LeftRobotFoot;&#xA;}&#xA;&#xA;class RightRobotLeg extends RobotLeg&#xA;{&#xA;&#x9;@inject public var foot:RightRobotFoot;&#xA;}&#xA;&#xA;class RobotConstruction&#xA;{&#xA;&#x9;function buildRobot()&#xA;&#x9;{&#xA;&#x9;&#x9;var injector = new Injector();&#xA;&#x9;&#x9;injector.map(LeftRobotLeg).toClass(LeftRobotLeg);&#xA;&#x9;&#x9;injector.map(RightRobotLeg).toClass(RightRobotLeg);&#xA;&#x9;&#x9;injector.map(LeftRobotFoot).toClass(LeftRobotFoot);&#xA;&#x9;&#x9;injector.map(RightRobotFoot).toClass(RightRobotFoot);&#xA;&#x9;&#x9;var robot = injector.instantiate(Robot);&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using child injectors, the robot can be built with just the RobotLeg class, while still supplying different feet for each leg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;public class Robot&#xA;{&#xA;&#x9;@inject(&#39;leftLeg&#39;) public var leftLeg:RobotLeg;&#xA;&#x9;@inject(&#39;rightLeg&#39;) public var rightLeg:RobotLeg;&#xA;}&#xA;&#xA;public class RobotLeg&#xA;{&#xA;&#x9;var foot:RobotFoot;&#xA;}&#xA;&#xA;public class RobotConstruction&#xA;{&#xA;&#x9;function buildRobot()&#xA;&#x9;{&#xA;&#x9;&#x9;var injector = new Injector();&#xA;&#xA;&#x9;&#x9;// store a reference to the rule&#xA;&#x9;&#x9;var leftLegRule = injector.map(RobotLeg, &#39;leftLeg&#39;).toClass(RobotLeg);&#xA;&#xA;&#x9;&#x9;// create a child injector&#xA;&#x9;&#x9;var leftLegInjector = injector.createChildInjector();&#xA;&#xA;&#x9;&#x9;// create a mapping for the correct foot in the child injector&#xA;&#x9;&#x9;leftLegInjector.map(RobotFoot).toClass(LeftRobotFoot);&#xA;&#xA;&#x9;&#x9;// instruct SwiftSuspenders to use the child injector for all&#xA;&#x9;&#x9;// dependency injections in the left leg object tree&#xA;&#x9;&#x9;leftLegRule.setInjector(leftLegInjector);&#xA;&#xA;&#x9;&#x9;// and the same for the right leg:&#xA;&#x9;&#x9;var rightLegInjector = injector.createChildInjector();&#xA;&#x9;&#x9;rightLegInjector.map(RobotFoot).toClass(RightRobotFoot);&#xA;&#x9;&#x9;rightLegRule.setInjector(rightLegInjector);&#xA;&#xA;&#x9;&#x9;// finally, create the object tree by instantiating the Robot class:&#xA;&#x9;&#x9;var robot = injector.instantiate(Robot);&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The child injectors forward all injection requests they don&#39;t have a mapping for to their parent injector. This enables sharing additional rules between the injectors. For example, the robot feet might have toes that work the same for both feet, so a mapping for these could be added to the main injector instead of adding the mappings to both child injectors.&lt;/p&gt; &#xA;&lt;p&gt;If a mapping from a parent (or other ancestor) injector is used, that doesn&#39;t mean that the child injector isn&#39;t used for subsequent injections anymore. I.e., you can have &#34;holes&#34; in your child injector&#39;s mappings that get filled by an ancestor injector and still define other mappings in your child injector that you want to have applied later on in the object tree that is constructed through DI.&lt;/p&gt; &#xA;&lt;p&gt;Injectors can be nested freely to create configuration trees of arbitrary complexity.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;h4&gt;Field and Setter Injection&lt;/h4&gt; &#xA;&lt;p&gt;Suppose you have a class into which you want to inject dependencies that looks like this (Note that I&#39;ve left out import statements for brevity):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class MyDependentClass&#xA;{&#xA;&#x9;@inject public var firstDepency:MovieClip;&#xA;&#xA;&#x9;@inject(&#39;currentTime&#39;) public var secondDependency:Date;&#xA;&#xA;&#x9;@inject public var thirdDependency(default, set_thirdDependency):Sprite&#xA;&#xA;&#x9;function set_thirdDependency(value:Sprite):Sprite&#xA;&#x9;{&#xA;&#x9;&#x9;return thirdDependency = value;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To inject dependencies into an instance of this class, you would first define dependency mappings and then invoke &lt;code&gt;Injector#injectInto&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;var injector = new Injector();&#xA;injector.map(MovieClip).toValue(new MovieClip());&#xA;&#xA;var currentTime = Date.now();&#xA;injector.map(Date, &#39;currentTime&#39;).toValue(currentTime);&#xA;&#xA;injector.map(Sprite).asSingleton();&#xA;&#xA;var injectee = new MyDependentClass();&#xA;injector.injectInto(injectee);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Method Injection&lt;/h4&gt; &#xA;&lt;p&gt;Suppose you have a class into which you want to inject dependencies that looks like this (Note that I&#39;ve left out import statements for brevity):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class MyDependentClass&#xA;{&#xA;&#x9;var myMovieClip:MovieClip;&#xA;&#x9;var currentTime:Date;&#xA;&#xA;&#x9;@inject public function setFirstDependency(injection:MovieClip):Void&#xA;&#x9;{&#xA;&#x9;&#x9;myMovieClip = injection;&#xA;&#x9;}&#xA;&#xA;&#x9;@inject(&#39;currentTime&#39;)&#xA;&#x9;public function setSecondDependency(injection:Date):Void&#xA;&#x9;{&#xA;&#x9;&#x9;currentTime = injection;&#xA;&#x9;}&#xA;&#xA;&#x9;@inject(&#39;&#39;,&#39;currentTime&#39;)&#xA;&#x9;public function setMultipleDependencies(movieClip:MovieClip, date:Date):Void&#xA;&#x9;{&#xA;&#x9;&#x9;myMovieClip = movieClip;&#xA;&#x9;&#x9;currentTime = date;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To inject dependencies into an instance of this class, you would first define dependency mappings and then invoke &lt;code&gt;Injector#injectInto&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;var injector = new Injector();&#xA;injector.map(MovieClip).toValue(new MovieClip());&#xA;&#xA;var currentTime = Date.now();&#xA;injector.map(Date, &#39;currentTime&#39;).toValue(currentTime);&#xA;&#xA;var injectee = new MyDependentClass();&#xA;injector.injectInto(injectee);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, the defined dependencies are partly redundant, which is waste - but otherwise not harmful.&lt;/p&gt; &#xA;&lt;h4&gt;Constructor Injection&lt;/h4&gt; &#xA;&lt;p&gt;Suppose you have a class into which you want to inject dependencies that looks like this (Note that I&#39;ve left out import statements for brevity):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class MyDependentClass&#xA;{&#xA;&#x9;var myMovieClip:MovieClip;&#xA;&#x9;var currentTime:Date;&#xA;&#xA;&#x9;@inject(&#39;&#39;, &#39;currentTime&#39;) public function new(movieClip:MovieClip, date:Date)&#xA;&#x9;{&#xA;&#x9;&#x9;myMovieClip = movieClip;&#xA;&#x9;&#x9;currentTime = date;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To inject dependencies into an instance of this class, you would first define dependency mappings and then invoke &lt;code&gt;Injector#instantiate&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;var injector = new Injector();&#xA;injector.map(MovieClip).toValue(new MovieClip());&#xA;var currentTime = Date.now();&#xA;injector.map(Date, &#39;currentTime&#39;).toValue(currentTime);&#xA;var injectee = injector.instantiate(MyDependentClass);&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>jegoyalu/jarisplayer</title>
    <updated>2023-09-01T02:10:57Z</updated>
    <id>tag:github.com,2023-09-01:/jegoyalu/jarisplayer</id>
    <link href="https://github.com/jegoyalu/jarisplayer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A flash flv, mp3 or mp4 (h.264) player made on haxe that can be embedded into any website for free or commercial use.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Jaris FLV Player&lt;/h1&gt; &#xA;&lt;p&gt;A flash flv/mp4 player made using haxe and flash develop that can be embedded into any website for free or commercial use. With support for rtmp, youtube, http streaming and many more features. Open for improvements by you!&lt;/p&gt; &#xA;&lt;p&gt;Web Page: &lt;a href=&#34;http://jarisflvplayer.org/&#34;&gt;http://jarisflvplayer.org/&lt;/a&gt; Project Page: &lt;a href=&#34;https://sourceforge.net/projects/jaris/&#34;&gt;https://sourceforge.net/projects/jaris/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Be Free!&lt;/h2&gt; &#xA;&lt;p&gt;Searching for an flv player that could be used freely in all aspects and open source was a hard job. So I just decided to work on a basic player that had the most important features found in others players.&lt;/p&gt; &#xA;&lt;p&gt;Thats the story of how Jaris was born.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Aspect ratio switcher&lt;/li&gt; &#xA; &lt;li&gt;Fullscreen support&lt;/li&gt; &#xA; &lt;li&gt;Http pseudostreaming support&lt;/li&gt; &#xA; &lt;li&gt;Basic RTMP streaming support&lt;/li&gt; &#xA; &lt;li&gt;Poster image&lt;/li&gt; &#xA; &lt;li&gt;Volume control&lt;/li&gt; &#xA; &lt;li&gt;Seek control&lt;/li&gt; &#xA; &lt;li&gt;Display time&lt;/li&gt; &#xA; &lt;li&gt;Use your own logo&lt;/li&gt; &#xA; &lt;li&gt;Add a link to your logo&lt;/li&gt; &#xA; &lt;li&gt;Change position of logo&lt;/li&gt; &#xA; &lt;li&gt;Hide controls on fullscreen&lt;/li&gt; &#xA; &lt;li&gt;Custom control colors&lt;/li&gt; &#xA; &lt;li&gt;Hardware scaling&lt;/li&gt; &#xA; &lt;li&gt;Keyboard shortcuts&lt;/li&gt; &#xA; &lt;li&gt;Mp3 support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Jaris is licensed under GPL and LGPL, meaning that you could use it commercially. What we ask for is that any improvements made to the player should be taken back to jaris flv website so that any one could enjoy the new improvements or features also. In this way everyone could help to maintain an up to date tool that adapts to todays multimedia demands. Using github you can fork the project, work on your changes, and send a pull request.&lt;/p&gt; &#xA;&lt;p&gt;Enjoy a totally free player ;-)&lt;/p&gt; &#xA;&lt;h2&gt;Compiling from source&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;http://haxe.org/&#34;&gt;haxe&lt;/a&gt; change to the directory where jaris sources reside and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  haxe build.xml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JarisFLVPlayer.swf will be generated on the &lt;strong&gt;bin&lt;/strong&gt; directory which you can embed in your web sites as integrate as part of other projects.&lt;/p&gt;</summary>
  </entry>
</feed>