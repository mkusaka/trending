<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haxe Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-09T01:41:03Z</updated>
  <subtitle>Daily Trending of Haxe in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>massive-oss/MassiveUnit</title>
    <updated>2022-06-09T01:41:03Z</updated>
    <id>tag:github.com,2022-06-09:/massive-oss/MassiveUnit</id>
    <link href="https://github.com/massive-oss/MassiveUnit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;munit is a cross-platform unit testing framework for Haxe. Utilises metadata markup for test cases and includes tools for generating, compiling and running test cases from the command line.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;MUnit is a metadata driven unit testing framework for cross-platform Haxe development.&lt;/p&gt; &#xA;&lt;p&gt;It includes tools for creating, updating, compiling and running unit test cases from the command line.&lt;/p&gt; &#xA;&lt;p&gt;MUnit supports Haxe 3+&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To install you must have &lt;a href=&#34;http://www.haxe.org&#34;&gt;Haxe&lt;/a&gt; installed&lt;/p&gt; &#xA;&lt;p&gt;Then just use haxelib to download the latest version&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib install munit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To check that it is all installed and to view the help run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Please note:&lt;/strong&gt; After upgrading you may be required to update the TestMain.hx in existing project before being able to test&lt;/p&gt; &#xA;&lt;p&gt;To install latest build from git:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib git munit https://github.com/massiveinteractive/MassiveUnit.git master src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h3&gt;Cross Platform&lt;/h3&gt; &#xA;&lt;p&gt;MUnit has been designed for cross platform Haxe development. It currently supports js, swf, as3, neko, c++, java, cs, python, php and hl and the tool chain works on Windows, OSX and Linux. To run js tests with NodeJS, add &lt;code&gt;-lib hxnodejs&lt;/code&gt; or &lt;code&gt;-D nodejs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Test Metadata&lt;/h3&gt; &#xA;&lt;p&gt;Test cases use Haxe metadata to simplify creating tests (and avoid needing to extend or implement framework classes).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;@Test&#xA;public function testExample():Void&#xA;{&#xA;&#x9;Assert.isTrue(true);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Asynchronous Tests&lt;/h3&gt; &#xA;&lt;p&gt;Unlike the default haxe unit test classes, MUnit supports asynchronous testing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;@AsyncTest&#xA;public function asyncTestExample(factory:AsyncFactory):Void&#xA;{&#xA;&#x9;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tool Chain&lt;/h3&gt; &#xA;&lt;p&gt;MUnit is way more than just a unit test framework. It includes a command line tool for working with munit projects to streamline your development workflow.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Setup stub test projects in seconds&lt;/li&gt; &#xA; &lt;li&gt;Auto generate test suites based on test classes in a src directory&lt;/li&gt; &#xA; &lt;li&gt;Compile and run multiple targets from an hxml build file&lt;/li&gt; &#xA; &lt;li&gt;Launch and run test applications in the browser or command line (neko)&lt;/li&gt; &#xA; &lt;li&gt;Save out text and junit style test reports to the file system for reporting and ci&lt;/li&gt; &#xA; &lt;li&gt;Auto generate stub test classes (and/or target classes)&lt;/li&gt; &#xA; &lt;li&gt;Integrated code coverage compilation with &lt;a href=&#34;https://github.com/massiveinteractive/MassiveCover&#34;&gt;MCover&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;For detailed user guides refer to the &lt;strong&gt;&lt;a href=&#34;https://github.com/massiveinteractive/MassiveUnit/wiki&#34;&gt;wiki&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The API documentation is available on the &lt;a href=&#34;http://lib.haxe.org/d/munit&#34;&gt;haxelib project page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to contribute&lt;/h2&gt; &#xA;&lt;p&gt;If you find a bug, &lt;a href=&#34;https://github.com/massiveinteractive/MassiveUnit/issues&#34;&gt;report it&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to help, &lt;a href=&#34;https://github.com/massiveinteractive/MassiveUnit/fork_select&#34;&gt;fork it&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To install latest build from git:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib git munit https://github.com/massiveinteractive/MassiveUnit.git src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to make sure it works, make sure to run the bash script (build.sh) and check that the tests all pass on all platforms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit test -coverage&#xA;&#xA;cd ../test&#xA;haxelib run munit test -coverage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;New since 2.0.0&lt;/h2&gt; &#xA;&lt;h3&gt;Haxe 3 Support&lt;/h3&gt; &#xA;&lt;p&gt;Some APIs have changed to ensure compatibility with both Haxe 2.10 and Haxe3.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Support for Haxe 2.09 and Haxe 2.08 have been dropped&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;New since 0.9.5.x&lt;/h2&gt; &#xA;&lt;h3&gt;C++ Target&lt;/h3&gt; &#xA;&lt;p&gt;MUnit now compiles/runs c++ targets&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit test -cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Updates to TestMain to work with MCover 1.4.x&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Note: You may be required to update the TestMain.hx in existing project&#xA;before being able to run `munit test -coverage`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Code Coverage customisation&lt;/h3&gt; &#xA;&lt;p&gt;Munit now supports custom &lt;a href=&#34;https://github.com/massiveinteractive/MassiveCover&#34;&gt;mcover&lt;/a&gt; settings when compiling via &lt;code&gt;munit test -coverage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;re-run &lt;code&gt;haxelib run munit config&lt;/code&gt; in a project to set &lt;code&gt;coverage packages&lt;/code&gt; and &lt;code&gt;coverage ignored classes&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/tynril&#34;&gt;tynril&lt;/a&gt; for adding these options.&lt;/p&gt; &#xA;&lt;h2&gt;New since 2.0.x&lt;/h2&gt; &#xA;&lt;h3&gt;Haxe 3 Support&lt;/h3&gt; &#xA;&lt;p&gt;Munit now supports Haxe 3 RC.&lt;/p&gt; &#xA;&lt;p&gt;There aren&#39;t any new features in this release, however there are several breaking changes to internal APIS and Interfaces to ensure compatibility with both versions of Haxe.&lt;/p&gt; &#xA;&lt;p&gt;To compile tests aginst Haxe 3, you may need to delete any references to js.Dom in the generated TestMain class in your project.&lt;/p&gt; &#xA;&lt;h2&gt;New since 0.9.4.x&lt;/h2&gt; &#xA;&lt;h3&gt;Report Command&lt;/h3&gt; &#xA;&lt;p&gt;Convert munit summary reports into different format(s). As of 0.9.4.0 there is only one supported format (TeamCity)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit report [format] [dest] [-coverage percent]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;The following example generates a teamcity-info.xml report in the project directory (.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit report teamcity . -coverage 85&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: You must run and generated summary reports prior to executing the report command.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;New since 0.9.3.x&lt;/h2&gt; &#xA;&lt;h3&gt;Better CI support&lt;/h3&gt; &#xA;&lt;p&gt;Get error exit code when tests on one or more platforms fail&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit test -result-exit-code&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: haxelib currently doesnt return exit codes &amp;gt; 0 on OSX (see &lt;a href=&#34;http://code.google.com/p/haxe/issues/detail?id=879&#34;&gt;issue&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Workaround for issues with nekotools server HTTP POST via a simple SummaryReportClient&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;var httpClient = new HTTPClient(new SummaryReportClient())&#xA;runner.addResultClient(httpClient);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;New since 0.9.2.x&lt;/h2&gt; &#xA;&lt;p&gt;Rich HTML output for JavaScript and Flash targets (see RichPrintClient)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;var client = new RichPrintClient();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Seamless support for MCover code coverage&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit test -coverage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Commands for generating stub test classes on demand&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit create package.FooTest -for package.Foo  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CI friendly options for munit config command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib run munit config -default&#xA;haxelib run munit config -src path/to/src -hxml path/to/test.hxml&#xA;haxelib run munit config -file path/to/my/custom/config.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Support for assertions inside async tests&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;public function someAsyncTest(factory:AsyncFactory)&#xA;{&#xA;&#x9;Assert.isTrue(false);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Support for custom runner html templates and resources&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Run &#39;munit config&#39; to set template and resources directories&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For full list of recent changes see the &lt;strong&gt;&lt;a href=&#34;https://github.com/massiveinteractive/MassiveUnit/raw/master/CHANGES&#34;&gt;change log&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;This project is brought to you by &lt;a href=&#34;https://github.com/misprintt&#34;&gt;Dominic&lt;/a&gt; and &lt;a href=&#34;https://github.com/mikestead&#34;&gt;Mike&lt;/a&gt; from &lt;a href=&#34;http://massiveinteractive.com&#34;&gt;Massive Interactive&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>massive-oss/minject</title>
    <updated>2022-06-09T01:41:03Z</updated>
    <id>tag:github.com,2022-06-09:/massive-oss/minject</id>
    <link href="https://github.com/massive-oss/minject" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Haxe port of the ActionScript 3 SwiftSuspenders IOC library with efficient macro enhanced type reflection. Supports AVM1, AVM2, JavaScript, Neko and C++.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;minject is a metadata driven inversion of control (IOC) solution for Haxe. It has been thoroughly tested on JS, AVM1/2, PHP and Neko, but should also work on other platforms.&lt;/p&gt; &#xA;&lt;p&gt;This documentation is a modified version of the original, which can be found &lt;a href=&#34;https://github.com/tschneidereit/SwiftSuspenders/raw/the-past/README.textile&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;minject supports the following features as described in more details later in the documentation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;metadata based annotation of injection points&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;injecting into:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;properties&lt;/li&gt; &#xA;   &lt;li&gt;methods (with support for optional arguments)&lt;/li&gt; &#xA;   &lt;li&gt;constructors (with support for optional arguments)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;named injections, allowing for more specific binding of injections than just by their type. (See &#34;defining injection points&#34;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;@post annotations for invoking methods after all injections have been applied&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;mapping:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;values of nearly any type (enums, abstracts, typedefs, functions)&lt;/li&gt; &#xA;   &lt;li&gt;classes (of which new instances are created for each injection)&lt;/li&gt; &#xA;   &lt;li&gt;singletons (which are created lazily on first injection and then reused for each additional injection of the same rule)&lt;/li&gt; &#xA;   &lt;li&gt;rules (which allows sharing singletons between multiple mapping rules)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;creating child injectors which share their parents&#39; injection mappings but can define additional mappings complementing or replacing the parents&#39; ones&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;querying for the existence of injection rules using Injector#hasMapping&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;direct application of injection rules using Injector#getInstance&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;haxelib install minject&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You can find an example of minject usage &lt;a href=&#34;https://github.com/massiveinteractive/minject/raw/master/src/example&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Defining dependencies&lt;/h3&gt; &#xA;&lt;p&gt;minject supports three types of dependency definitions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;value bindings&lt;/em&gt;, which simply map an injection request to be satisfied by injecting the given value&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;class bindings&lt;/em&gt;, which map an injection request to be satisfied by injecting a new instance of the given class&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;singleton bindings&lt;/em&gt;, which map all injection requests for the given class by injecting the same shared instance, which itself gets created on first request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, it&#39;s possible to re-use dependency mappings with &lt;code&gt;mapRule&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For all definition types, it&#39;s possible to specify names, which allows using multiple injection bindings to the same class.&lt;/p&gt; &#xA;&lt;h3&gt;Defining injection points&lt;/h3&gt; &#xA;&lt;p&gt;Dependency bindings can be injected into an object using constructor, setter, property or method injection (or a combination of these). Constructor, Setter, property and method injection require metadata for all injections to be added to the injectee class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and for injecting named dependencies&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject(&#39;NamedDependency&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using basic constructor injections&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject public function new(foo:Bar, beautiful:Flower) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using named dependencies for constructor injection, the metadata has to be placed before the constructor method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject(&#39;NamedDependency&#39;) public function new(foo:Bar) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For methods and constructors accepting multiple parameters, it&#39;s possible to define mixes of named and unnamed dependency bindings. In this case, trailing unnamed dependencies can simply be omitted in the metadata, whereas unnamed dependencies followed by named ones have to be declared as the empty string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inject(&#39;&#39;, &#39;NamedDependency&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For methods and constructors, only the mandatory arguments have to have injection mappings. Optional arguments are added in order as long as a mapping is available for them.&lt;/p&gt; &#xA;&lt;p&gt;Injection points apply to inheriting classes just as they do to the class they are defined for. Thus, it&#39;s possible to define injection points for a base class and use them with all derived classes (which in turn might specify additional injection points).&lt;/p&gt; &#xA;&lt;h3&gt;Post construct: Automatically invoking methods on injection completion&lt;/h3&gt; &#xA;&lt;p&gt;Instances of classes that depend on automatic DI are only ready to be used after the DI has completed. Annotating methods in the injectee class with the &lt;code&gt;@post&lt;/code&gt; metadata causes them to be invoked directly after all injections have completed and it is safe to use the instance. Multiple methods can be invoked in a defined order by specifying a priority: &lt;code&gt;@post(2)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Querying for injection mapping existence&lt;/h3&gt; &#xA;&lt;p&gt;minject supports querying for the existence of mapping rules for any request using &lt;code&gt;Injector#hasMapping&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;hasMapping&lt;/code&gt; expects a class or an interface and optionally a name for the mapping and returns &lt;code&gt;true&lt;/code&gt; if a request for this class/name combination can be satisfied. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Directly applying injection mappings&lt;/h3&gt; &#xA;&lt;p&gt;minject supports directly applying injection mappings using &lt;code&gt;Injector#getInstance&lt;/code&gt;. &lt;code&gt;getInstance&lt;/code&gt; expects a class or an interface and optionally a name for the mapping and returns the mapping&#39;s result if one is defined. Otherwise, an exception is thrown.&lt;/p&gt; &#xA;&lt;p&gt;The returned value depends on the mapping defined for the relevant request. E.g., if a singleton mapping has been defined for the request, the shared singleton instance will be returned instead of creating a new instance of the class.&lt;/p&gt; &#xA;&lt;h3&gt;Error handling&lt;/h3&gt; &#xA;&lt;p&gt;If a mapping for a requested injection is not found, an exception string containing the target class and the requested property type is thrown.&lt;/p&gt; &#xA;&lt;h3&gt;Child Injectors&lt;/h3&gt; &#xA;&lt;p&gt;minject supports creating child injectors. These are dependent on their parent injector and automatically inherit all rule mappings the parent has. Additionally, they can have their own rule mappings, complementing or overriding the parent mappings.&lt;/p&gt; &#xA;&lt;p&gt;The main use-case for this feature is as a solution to the so-called &#34;robot legs problem&#34;. When using Dependency Injection, one often wants to create very similar object trees that have only slight differences. A good illustration is a simplified robot, that can be built using identical parts for its legs but needs different parts for the left and the right foot. Using normal Dependency Injection, one would have to subclass the RobotLeg class for each leg only to enable specifying different injections for each foot. The subclasses would then have to implement boilerplate code to apply the injection to the variable the parent expects the foot in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class Robot&#xA;{&#xA;&#x9;@inject public var leftLeg:LeftRobotLeg;&#xA;&#x9;@inject public var rightLeg:RightRobotLeg;&#xA;}&#xA;&#xA;class RobotLeg&#xA;{&#xA;&#x9;var foot:RobotFoot;&#xA;}&#xA;&#xA;class LeftRobotLeg extends RobotLeg&#xA;{&#xA;&#x9;@inject public var foot:LeftRobotFoot;&#xA;}&#xA;&#xA;class RightRobotLeg extends RobotLeg&#xA;{&#xA;&#x9;@inject public var foot:RightRobotFoot;&#xA;}&#xA;&#xA;class RobotConstruction&#xA;{&#xA;&#x9;function buildRobot()&#xA;&#x9;{&#xA;&#x9;&#x9;var injector = new Injector();&#xA;&#x9;&#x9;injector.map(LeftRobotLeg).toClass(LeftRobotLeg);&#xA;&#x9;&#x9;injector.map(RightRobotLeg).toClass(RightRobotLeg);&#xA;&#x9;&#x9;injector.map(LeftRobotFoot).toClass(LeftRobotFoot);&#xA;&#x9;&#x9;injector.map(RightRobotFoot).toClass(RightRobotFoot);&#xA;&#x9;&#x9;var robot = injector.instantiate(Robot);&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using child injectors, the robot can be built with just the RobotLeg class, while still supplying different feet for each leg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;public class Robot&#xA;{&#xA;&#x9;@inject(&#39;leftLeg&#39;) public var leftLeg:RobotLeg;&#xA;&#x9;@inject(&#39;rightLeg&#39;) public var rightLeg:RobotLeg;&#xA;}&#xA;&#xA;public class RobotLeg&#xA;{&#xA;&#x9;var foot:RobotFoot;&#xA;}&#xA;&#xA;public class RobotConstruction&#xA;{&#xA;&#x9;function buildRobot()&#xA;&#x9;{&#xA;&#x9;&#x9;var injector = new Injector();&#xA;&#xA;&#x9;&#x9;// store a reference to the rule&#xA;&#x9;&#x9;var leftLegRule = injector.map(RobotLeg, &#39;leftLeg&#39;).toClass(RobotLeg);&#xA;&#xA;&#x9;&#x9;// create a child injector&#xA;&#x9;&#x9;var leftLegInjector = injector.createChildInjector();&#xA;&#xA;&#x9;&#x9;// create a mapping for the correct foot in the child injector&#xA;&#x9;&#x9;leftLegInjector.map(RobotFoot).toClass(LeftRobotFoot);&#xA;&#xA;&#x9;&#x9;// instruct SwiftSuspenders to use the child injector for all&#xA;&#x9;&#x9;// dependency injections in the left leg object tree&#xA;&#x9;&#x9;leftLegRule.setInjector(leftLegInjector);&#xA;&#xA;&#x9;&#x9;// and the same for the right leg:&#xA;&#x9;&#x9;var rightLegInjector = injector.createChildInjector();&#xA;&#x9;&#x9;rightLegInjector.map(RobotFoot).toClass(RightRobotFoot);&#xA;&#x9;&#x9;rightLegRule.setInjector(rightLegInjector);&#xA;&#xA;&#x9;&#x9;// finally, create the object tree by instantiating the Robot class:&#xA;&#x9;&#x9;var robot = injector.instantiate(Robot);&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The child injectors forward all injection requests they don&#39;t have a mapping for to their parent injector. This enables sharing additional rules between the injectors. For example, the robot feet might have toes that work the same for both feet, so a mapping for these could be added to the main injector instead of adding the mappings to both child injectors.&lt;/p&gt; &#xA;&lt;p&gt;If a mapping from a parent (or other ancestor) injector is used, that doesn&#39;t mean that the child injector isn&#39;t used for subsequent injections anymore. I.e., you can have &#34;holes&#34; in your child injector&#39;s mappings that get filled by an ancestor injector and still define other mappings in your child injector that you want to have applied later on in the object tree that is constructed through DI.&lt;/p&gt; &#xA;&lt;p&gt;Injectors can be nested freely to create configuration trees of arbitrary complexity.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;h4&gt;Field and Setter Injection&lt;/h4&gt; &#xA;&lt;p&gt;Suppose you have a class into which you want to inject dependencies that looks like this (Note that I&#39;ve left out import statements for brevity):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class MyDependentClass&#xA;{&#xA;&#x9;@inject public var firstDepency:MovieClip;&#xA;&#xA;&#x9;@inject(&#39;currentTime&#39;) public var secondDependency:Date;&#xA;&#xA;&#x9;@inject public var thirdDependency(default, set_thirdDependency):Sprite&#xA;&#xA;&#x9;function set_thirdDependency(value:Sprite):Sprite&#xA;&#x9;{&#xA;&#x9;&#x9;return thirdDependency = value;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To inject dependencies into an instance of this class, you would first define dependency mappings and then invoke &lt;code&gt;Injector#injectInto&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;var injector = new Injector();&#xA;injector.map(MovieClip).toValue(new MovieClip());&#xA;&#xA;var currentTime = Date.now();&#xA;injector.map(Date, &#39;currentTime&#39;).toValue(currentTime);&#xA;&#xA;injector.map(Sprite).asSingleton();&#xA;&#xA;var injectee = new MyDependentClass();&#xA;injector.injectInto(injectee);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Method Injection&lt;/h4&gt; &#xA;&lt;p&gt;Suppose you have a class into which you want to inject dependencies that looks like this (Note that I&#39;ve left out import statements for brevity):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class MyDependentClass&#xA;{&#xA;&#x9;var myMovieClip:MovieClip;&#xA;&#x9;var currentTime:Date;&#xA;&#xA;&#x9;@inject public function setFirstDependency(injection:MovieClip):Void&#xA;&#x9;{&#xA;&#x9;&#x9;myMovieClip = injection;&#xA;&#x9;}&#xA;&#xA;&#x9;@inject(&#39;currentTime&#39;)&#xA;&#x9;public function setSecondDependency(injection:Date):Void&#xA;&#x9;{&#xA;&#x9;&#x9;currentTime = injection;&#xA;&#x9;}&#xA;&#xA;&#x9;@inject(&#39;&#39;,&#39;currentTime&#39;)&#xA;&#x9;public function setMultipleDependencies(movieClip:MovieClip, date:Date):Void&#xA;&#x9;{&#xA;&#x9;&#x9;myMovieClip = movieClip;&#xA;&#x9;&#x9;currentTime = date;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To inject dependencies into an instance of this class, you would first define dependency mappings and then invoke &lt;code&gt;Injector#injectInto&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;var injector = new Injector();&#xA;injector.map(MovieClip).toValue(new MovieClip());&#xA;&#xA;var currentTime = Date.now();&#xA;injector.map(Date, &#39;currentTime&#39;).toValue(currentTime);&#xA;&#xA;var injectee = new MyDependentClass();&#xA;injector.injectInto(injectee);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, the defined dependencies are partly redundant, which is waste - but otherwise not harmful.&lt;/p&gt; &#xA;&lt;h4&gt;Constructor Injection&lt;/h4&gt; &#xA;&lt;p&gt;Suppose you have a class into which you want to inject dependencies that looks like this (Note that I&#39;ve left out import statements for brevity):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class MyDependentClass&#xA;{&#xA;&#x9;var myMovieClip:MovieClip;&#xA;&#x9;var currentTime:Date;&#xA;&#xA;&#x9;@inject(&#39;&#39;, &#39;currentTime&#39;) public function new(movieClip:MovieClip, date:Date)&#xA;&#x9;{&#xA;&#x9;&#x9;myMovieClip = movieClip;&#xA;&#x9;&#x9;currentTime = date;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To inject dependencies into an instance of this class, you would first define dependency mappings and then invoke &lt;code&gt;Injector#instantiate&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;var injector = new Injector();&#xA;injector.map(MovieClip).toValue(new MovieClip());&#xA;var currentTime = Date.now();&#xA;injector.map(Date, &#39;currentTime&#39;).toValue(currentTime);&#xA;var injectee = injector.instantiate(MyDependentClass);&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>