<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haxe Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-01T01:36:21Z</updated>
  <subtitle>Daily Trending of Haxe in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ncannasse/hlos</title>
    <updated>2024-01-01T01:36:21Z</updated>
    <id>tag:github.com,2024-01-01:/ncannasse/hlos</id>
    <link href="https://github.com/ncannasse/hlos" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A toy operating system for HashLink VM&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HL-OS&lt;/h1&gt; &#xA;&lt;p&gt;A toy operating system for HashLink VM&lt;/p&gt; &#xA;&lt;p&gt;This allows you to create a self-contained bootable image binary that includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a very small kernel (&lt;code&gt;kernel.c&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://hashlink.haxe.org&#34;&gt;HashLink VM&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;a minimal libc required to run the HLVM (&lt;code&gt;lib.c&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;including your application code compiled into HL bytecode (&lt;code&gt;App.hx&lt;/code&gt; compiled into &lt;code&gt;out/app.hl&lt;/code&gt; with &lt;a href=&#34;https://haxe.org&#34;&gt;Haxe&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;some extra data files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The boot sequence is the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;BootLoader: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;read the device data&lt;/li&gt; &#xA;   &lt;li&gt;map the kernel code, symbold and VM bytecode into memory&lt;/li&gt; &#xA;   &lt;li&gt;enter into protected mode&lt;/li&gt; &#xA;   &lt;li&gt;call the kernel&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Kernel: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;clear the screen&lt;/li&gt; &#xA;   &lt;li&gt;init the symbols table&lt;/li&gt; &#xA;   &lt;li&gt;load the HLVM bytecode&lt;/li&gt; &#xA;   &lt;li&gt;run it (the HLVM will translate it to machine code first)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Congratulations ! You are now running your Haxe App in Kernel mode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compiling and Running&lt;/h2&gt; &#xA;&lt;p&gt;In order to compile HL-OS, you need GCC/LD/NASM/OBJDUMP toolchain. On Windows and OSX you need a cross compiler version capable of outputing ELF x86 code.&lt;/p&gt; &#xA;&lt;p&gt;This can be downloaded from &lt;a href=&#34;https://github.com/lordmilko/i686-elf-tools/releases&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Look at &lt;code&gt;Makefile&lt;/code&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;In order to run the HLOS image, you can use &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEmu&lt;/a&gt;, then simply &lt;code&gt;make run&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Injecting files&lt;/h3&gt; &#xA;&lt;p&gt;The kernel comes with a mini file system that allows to add and change files contained into the image without having to use any compilation. For this you can simply run &lt;code&gt;haxe --run InjectFile -path out out/kernel.elf app.hl&lt;/code&gt;, this will add or replace the &lt;code&gt;app.hl&lt;/code&gt; found in kernel file by the newest &lt;code&gt;out/app.hl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please note that the kernel is compiled with a fixed amount of reserved data for files. It is defined in &lt;code&gt;kernel_main.s&lt;/code&gt; and can be increased by recompiling the kernel.&lt;/p&gt; &#xA;&lt;h2&gt;Creating a bootable USB&lt;/h2&gt; &#xA;&lt;p&gt;In order to create a bootable standalone USB key, you need first to install the GRUB boot loader on it.&lt;/p&gt; &#xA;&lt;p&gt;On windows, download &lt;a href=&#34;https://ftp.gnu.org/gnu/grub/grub-2.06-for-windows.zip&#34;&gt;Grub 2.06&lt;/a&gt; and run &lt;code&gt;grub-install.exe --force --no-floppy --target=i386-pc --boot-directory=X:\boot //./PHYSICALDRIVE#&lt;/code&gt;. You need to change your drive number and physical drive number with ones that match your system (see &lt;a href=&#34;https://pendrivelinux.com/install-grub2-on-usb-from-windows/&#34;&gt;this tutorial&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Once your GRUB USB is ready, simply use &lt;code&gt;make USB_DRIVE=X: install_usb&lt;/code&gt; to copy the files to it.&lt;/p&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;Testing can be done by booting QEmu directly on the usb key with &lt;code&gt;make run_usb&lt;/code&gt;. This requires to run the command in adminitrator mode.&lt;/p&gt; &#xA;&lt;h2&gt;Assembly progamming&lt;/h2&gt; &#xA;&lt;p&gt;Starting from &lt;a href=&#34;https://github.com/HaxeFoundation/haxe/commit/5ddfcc84f7ee27c9df14f82f27d01ddf51e92df7&#34;&gt;this haxe commit&lt;/a&gt;, you can now emit native assembly directly from Haxe using HLVM.&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;hlos.Asm&lt;/code&gt; class that provides macro helpers. For instance you can do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;var v1 = 111, v2 = 222;&#xA;hlos.Asm.set(Edi, 0xFF); // set cpu register const value&#xA;hlos.Asm.set(Esi, v1); // set cpu register to local variable value&#xA;hlos.Asm.set(v2, Esi); // set local variable to cpu register&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that each HLVM local variable might currently be stored in a CPU register, so if you are doing an operation that changes the value of one Cpu register, you should call &lt;code&gt;hlos.Asm.discard(Eax)&lt;/code&gt; to make sure that the local variable doesn&#39;t get corrupted (&lt;code&gt;Asm.set&lt;/code&gt; does that for you automatically).&lt;/p&gt; &#xA;&lt;h2&gt;Legacy boot loader&lt;/h2&gt; &#xA;&lt;p&gt;The initial boot loader (in &lt;code&gt;tools/boot.asm&lt;/code&gt;) was responsible of loading the kernel and calling it, however it is only working with the 1.44MB Floppy emulator and does not support kernel in the ELF format.&lt;/p&gt;</summary>
  </entry>
</feed>