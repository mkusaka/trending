<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haxe Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-11T01:33:38Z</updated>
  <subtitle>Daily Trending of Haxe in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>RobertBorghese/reflaxe</title>
    <updated>2022-12-11T01:33:38Z</updated>
    <id>tag:github.com,2022-12-11:/RobertBorghese/reflaxe</id>
    <link href="https://github.com/RobertBorghese/reflaxe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haxe framework for creating compilation targets using macros&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Reflaxe - Reflection Compiler for Haxe&lt;/h1&gt; &#xA;&lt;p&gt;A framework for creating Haxe language compilation targets using macros.&lt;/p&gt; &#xA;&lt;p&gt;All you need to worry about is programming the conversion from Haxe&#39;s typed AST to your desired programming language. Reflaxe handles organizing the input AST, reading user configuration, and generating the output file(s), while also providing various configuration options and helper functions for Haxe target developers.&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Topic&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/RobertBorghese/reflaxe#installation&#34;&gt;Installation&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;How to install into your library.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/RobertBorghese/reflaxe/#compiler-code-sample&#34;&gt;Compiler Code Sample&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;How to code the compiler.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/RobertBorghese/reflaxe/#extraparamshxml-sample&#34;&gt;extraParams.hxml Sample&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;How to configure your library.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/RobertBorghese/reflaxe/#compilerhxml-sample&#34;&gt;compile.hxml Sample&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;How to use your library on other Haxe projects.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/RobertBorghese/reflaxe/#basecompiler-functions&#34;&gt;BaseCompiler Functions&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The functions used to configure your compiler&#39;s behavior and code output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/RobertBorghese/reflaxe/#basecompiler-options&#34;&gt;BaseCompiler Options&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Various options passed to Reflaxe for controlling your compiler&#39;s input/output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;#&lt;/th&gt; &#xA;   &lt;th&gt;What to do&lt;/th&gt; &#xA;   &lt;th&gt;What to write&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;Install via haxelib.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;pre&gt;haxelib install reflaxe&lt;/pre&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;Add the lib to your &lt;code&gt;.hxml&lt;/code&gt; file or compile command.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;pre lang=&#34;hxml&#34;&gt;-lib reflaxe&lt;/pre&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;Extend your compiler class from &lt;code&gt;BaseCompiler&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;pre lang=&#34;haxe&#34;&gt;class MyLangCompiler extends reflaxe.BaseCompiler&lt;/pre&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;Compiler Code Sample&lt;/h2&gt; &#xA;&lt;p&gt;Now fill out the abstract functions from &lt;code&gt;BaseCompiler&lt;/code&gt; to define how Haxe AST is converted into a String representation of your target language.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;class MyLangCompiler extends reflaxe.BaseCompiler {&#xA;&#xA;   //---------&#xA;   // call this from your library&#39;s hxml file using --macro&#xA;   public static function Start() {&#xA;      final options = {&#xA;         fileOutputExtension: &#34;.mylang&#34;,&#xA;         outputDirDefineName: &#34;mylang_out&#34;,&#xA;         fileOutputType: FilePerClass&#xA;      };&#xA;&#xA;      //---------&#xA;      // pass an instance of your compiler w/ desired options&#xA;      reflaxe.ReflectCompiler.AddCompiler(new MyLangCompiler(), options);&#xA;   }&#xA;&#xA;   //---------&#xA;   // fill out just these 3 functions and Reflaxe takes care of the rest&#xA;   //---------&#xA;&#xA;   public function compileClass(classType: ClassType, varFields: ClassFieldVars, funcFields: ClassFieldFuncs): Null&amp;lt;String&amp;gt; {&#xA;      // ...&#xA;   }&#xA;&#xA;   public function compileEnum(enumType: EnumType, constructs: Map&amp;lt;String, haxe.macro.EnumField&amp;gt;): Null&amp;lt;String&amp;gt; {&#xA;      // ...&#xA;   }&#xA;&#xA;   public function compileExpression(expr: TypedExpr): Null&amp;lt;String&amp;gt; {&#xA;      // ...&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;extraParams.hxml&lt;/code&gt; Sample&lt;/h2&gt; &#xA;&lt;p&gt;This framework is expected to be used to create Haxe libraries that &#34;add&#34; an output target. These Haxe libraries are then added to other projects and used to compile Haxe code to the target.&lt;/p&gt; &#xA;&lt;p&gt;Your Haxe library using Reflaxe should include an &lt;code&gt;extraParams.hxml&lt;/code&gt; file that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Includes class paths for your target&#39;s unique classes and Haxe standard lib overrides.&lt;/li&gt; &#xA; &lt;li&gt;Defines unique definitions for your target for use in conditional compilation.&lt;/li&gt; &#xA; &lt;li&gt;Runs an initialization macro similar to the &lt;code&gt;MyLangCompiler.Start&lt;/code&gt; function shown above.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hxml&#34;&gt;-cp std&#xA;-cp std/mylang/_std&#xA;&#xA;-D mylang&#xA;&#xA;--macro MyLangCompiler.Start()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;compiler.hxml&lt;/code&gt; Sample&lt;/h2&gt; &#xA;&lt;p&gt;The Haxe project that uses your library must first add it to their &lt;code&gt;.hxml&lt;/code&gt; file. This will cause the Haxe project to use your custom compiler target. All that is left is to define the &#34;outputDirDefineName&#34; define to configure the directory or filename of the output for your compiler target.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hxml&#34;&gt;# your target will be used when your lib is included&#xA;-lib haxe-to-mylang&#xA;&#xA;# set the output directory to &#34;outputDir&#34;&#xA;-D mylang_out=outputDir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;BaseCompiler&lt;/code&gt; Functions&lt;/h2&gt; &#xA;&lt;p&gt;Here is a list of the relevant &lt;code&gt;BaseCompiler&lt;/code&gt; functions and typedefs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;//---------&#xA;// These are the typedefs passed to &#34;compileClass&#34;&#xA;typedef ClassFieldVars = Array&amp;lt;{ isStatic: Bool, read: VarAccess, write: VarAccess, field: ClassField }&amp;gt;;&#xA;typedef ClassFieldFuncs = Array&amp;lt;{ isStatic: Bool, kind: MethodKind, tfunc: TFunc, field: ClassField }&amp;gt;;&#xA;&#xA;//---------&#xA;// BaseCompiler abstract class&#xA;abstract class BaseCompiler {&#xA;   //---------&#xA;   // This function is given data about Haxe classes. It must either return a String of the source code this&#xA;   // class generates, or `null` if the class should be ignored.&#xA;   public abstract function compileClass(classType: ClassType, varFields: ClassFieldVars, funcFields: ClassFieldFuncs): Null&amp;lt;String&amp;gt;;&#xA;   &#xA;   //---------&#xA;   // Similar to &#34;compileClass&#34;, except used for Haxe enums.&#xA;   public abstract function compileEnum(classType: EnumType, constructs: Map&amp;lt;String, EnumField&amp;gt;): Null&amp;lt;String&amp;gt;;&#xA;   &#xA;   //---------&#xA;   // Given the `TypedExpr`, this function should return a String of the generated expression for the output language.&#xA;   // Returning `null` causes the compiler to ignore this expression.&#xA;   public abstract function compileExpression(expr: TypedExpr): Null&amp;lt;String&amp;gt;;&#xA;&#xA;   //---------&#xA;   // Typedef and Abstract compiling functions are also included, but they are ignored by default.&#xA;   // They can be overriden if desired.&#xA;   public function compileTypedef(classType: DefType): Null&amp;lt;String&amp;gt; { return null; }&#xA;   public function compileAbstract(classType: AbstractType): Null&amp;lt;String&amp;gt; { return null; }&#xA;   &#xA;   // ---&#xA;   &#xA;   //---------&#xA;   // Normally this function is unused, however if &#34;Manual&#34; mode is selected for &#34;fileOutputType&#34;, this function is called&#xA;   // and Reflaxe does not generate any output itself. If you wish for more control over how files are generated with&#xA;   // your custom Haxe target, this is the function for you.&#xA;   public function generateFilesManually() {}&#xA;   &#xA;   // ---&#xA;   &#xA;   //---------&#xA;   // These functions are created in Reflaxe and should not be overriden.&#xA;   // They should be used in &#34;compileClass&#34; to compile the expressions from functions and variablesn as opposed to&#xA;   // using &#34;compileExpression&#34; on them directly.&#xA;   public function compileClassVarExpr(expr: TypedExpr): String { ... }&#xA;   public function compileClassFuncExpr(expr: TypedExpr): String { ... }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;BaseCompiler&lt;/code&gt; Options&lt;/h2&gt; &#xA;&lt;p&gt;This is the list of options that can be passed to &lt;code&gt;ReflectCompiler.AddCompiler&lt;/code&gt; to configure how your compiler works.&lt;/p&gt; &#xA;&lt;p&gt;While these all have default values, it is recommended &lt;code&gt;fileOutputExtension&lt;/code&gt;, &lt;code&gt;requireDefine&lt;/code&gt;, and &lt;code&gt;outputDirDefineName&lt;/code&gt; should be defined for your language at the bare minimum.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haxe&#34;&gt;// -------------------------------------------------------&#xA;// How the source code files are outputted.&#xA;// There are four options: &#xA;//  * SingleFile - all output is combined into single file&#xA;//  * FilePerModule - all module output is organized into files&#xA;//  * FilePerClass - each Haxe class is output into its own file&#xA;//  * Manual - nothing is generated and BaseCompiler.generateFilesManually is called&#xA;public var fileOutputType: BaseCompilerFileOutputType = FilePerClass;&#xA;&#xA;// -------------------------------------------------------&#xA;// This string is appended to the filename for each output file.&#xA;public var fileOutputExtension: String = &#34;.hxoutput&#34;;&#xA;&#xA;// -------------------------------------------------------&#xA;// This is the define which must exist for this compiler to function.&#xA;// If &#34;null&#34;, no define is required, but this is not recommended.&#xA;// Typically, the &#34;output directory&#34; define is used here.&#xA;public var requireDefine: Null&amp;lt;String&amp;gt; = null;&#xA;&#xA;// -------------------------------------------------------&#xA;// This is the define that decides where the output is placed.&#xA;// For example, this define will place the output in the &#34;out&#34; directory.&#xA;//&#xA;// -D hxoutput=out&#xA;//&#xA;public var outputDirDefineName: String = &#34;hxoutput&#34;;&#xA;&#xA;// -------------------------------------------------------&#xA;// If &#34;SingleFile&#34; is selected for &#34;fileOutputType&#34;, this is the&#xA;// name of the file generated if a directory is provided to &#34;outputDirDefineName&#34;.&#xA;public var defaultOutputFilename: String = &#34;output&#34;;&#xA;&#xA;// -------------------------------------------------------&#xA;// Whether Haxe&#39;s &#34;Everything is an Expression&#34; is normalized.&#xA;public var normalizeEIE: Bool = true;&#xA;&#xA;// -------------------------------------------------------&#xA;// If &#34;true&#34;, only the module containing the &#34;main&#34; function and &#xA;// any classes it references are compiled.&#xA;// Otherwise, Haxe&#39;s less restrictive dce is used.&#xA;public var smartDCE: Bool = false;&#xA;&#xA;// -------------------------------------------------------&#xA;// If &#34;true&#34;, any old output files that are not generated&#xA;// in the most recent compilation will be deleted.&#xA;// A text file containing all the current output files is&#xA;// saved in the output directory to help keep track. &#xA;//&#xA;// This feature is ignored when &#34;fileOutputType&#34; is SingleFile.&#xA;public var deleteOldOutput: Bool = true;&#xA;&#xA;// -------------------------------------------------------&#xA;// If &#34;true&#34;, an error is thrown if a function without&#xA;// a body is encountered. Typically this occurs when&#xA;// an umimplemented Haxe API function is encountered.&#xA;public var ignoreBodilessFunctions: Bool = false;&#xA;&#xA;// -------------------------------------------------------&#xA;// If &#34;true&#34;, extern classes and fields are not passed to BaseCompiler.&#xA;public var ignoreExterns: Bool = true;&#xA;&#xA;// -------------------------------------------------------&#xA;// If &#34;true&#34;, properties that are not physical properties&#xA;// are not passed to BaseCompiler. (i.e. both their&#xA;// read and write rules are &#34;get&#34;, &#34;set&#34;, or &#34;never&#34;).&#xA;public var ignoreNonPhysicalFields: Bool = true;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>