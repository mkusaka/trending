<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-22T01:33:29Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>HZFE/awesome-interview</title>
    <updated>2022-09-22T01:33:29Z</updated>
    <id>tag:github.com,2022-09-22:/HZFE/awesome-interview</id>
    <link href="https://github.com/HZFE/awesome-interview" rel="alternate"></link>
    <summary type="html">&lt;p&gt;剑指前端 Offer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;剑指前端 Offer&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://febook.hzfe.org/awesome-interview/&#34;&gt;阅读地址 1&lt;/a&gt; &lt;a href=&#34;https://hzfe.github.io/awesome-interview/&#34;&gt;阅读地址 2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;友情链接&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hellodigua/code996&#34;&gt;code996&lt;/a&gt; | 分析工具：统计 Git 项目的 commit 时间分布，推导项目编码强度 &lt;img src=&#34;https://github.com/hellodigua/code996/raw/master/public/preview/1.png&#34; height=&#34;200&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;互动与勘误&lt;/h2&gt; &#xA;&lt;p&gt;本书目前在 &lt;a href=&#34;https://github.com/hzfe/awesome-interview&#34;&gt;GitHub&lt;/a&gt; 中开源了第一版内容的部分题目，旨在接受广大开发者的检验和收集读者反馈后，能将本书打磨得更好。&lt;/p&gt; &#xA;&lt;p&gt;阅读时您可能会发现内容上的错误，可以直接在相关章节末尾的评论区进行留言，留言内容会被自动同步到仓库 Issues 中。您也可以在仓库 &lt;a href=&#34;https://github.com/HZFE/awesome-interview/issues&#34;&gt;Issues&lt;/a&gt; 中直接留下宝贵意见。欢迎读者对内容仓库进行 &lt;a href=&#34;https://github.com/hzfe/awesome-interview&#34;&gt;订阅/Watch&lt;/a&gt; 或加入群聊，我们会持续添加和订正内容。&lt;/p&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/17002181/149885532-6b460199-9a65-4894-aac7-30f22cdbdca1.png&#34; height=&#34;200&#34;&gt; &#xA;&lt;p&gt;添加二维码账号（是个真人）后，回复关键词&#34;&lt;strong&gt;剑指前端&lt;/strong&gt;&#34;，获取入群链接。&lt;/p&gt; &#xA;&lt;h2&gt;适合人群&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;有意冲刺互联网大厂的前端开发者，可参考本书题目和答案提纲，自主深入学习，查漏补缺。&lt;/li&gt; &#xA; &lt;li&gt;短时间内参加面试的前端开发者，可借助本书快速了解面试高频的技术问题和相关解答。&lt;/li&gt; &#xA; &lt;li&gt;前端面试官可参考本书的题型和题目，按岗位需求对候选人进行有梯度的考察。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;CHANGELOG&lt;/h2&gt; &#xA;&lt;h4&gt;2022/7/04&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;新增：本地存储方式及场景&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/5/31&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;修复：平衡二叉树&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/5/05&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;新增：如何对前端代码实施测试&lt;/li&gt; &#xA; &lt;li&gt;优化：浏览器渲染机制&lt;/li&gt; &#xA; &lt;li&gt;优化：浏览器跨域&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/4/09&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;新增：什么是 TypeScript 泛型&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/3/28&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：浏览器事件循环&lt;/li&gt; &#xA; &lt;li&gt;优化：实现节流防抖函数&lt;/li&gt; &#xA; &lt;li&gt;新增：谈谈 React 和 Vue 的区别&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/3/8&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;新增：谈谈微前端&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/3/7&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：垃圾回收机制&lt;/li&gt; &#xA; &lt;li&gt;优化：浏览器渲染机制&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/1/21&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：实现 apply/call/bind&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/1/20&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：HTTP/2 和 HTTP/1.1 的对比&lt;/li&gt; &#xA; &lt;li&gt;优化：前端安全&lt;/li&gt; &#xA; &lt;li&gt;优化：实现一个符合 Promises/A+ 规范的 Promise&lt;/li&gt; &#xA; &lt;li&gt;优化：webpack 工作流程&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/1/19&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;新增：水平垂直居中方案&lt;/li&gt; &#xA; &lt;li&gt;优化：React Fiber 的作用和原理&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/1/18&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;新增：前端路由实现&lt;/li&gt; &#xA; &lt;li&gt;优化：谈谈 CSS 预处理器&lt;/li&gt; &#xA; &lt;li&gt;优化：HOC vs Render Props vs Hooks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2022/1/17&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;新增：React 事件机制原理&lt;/li&gt; &#xA; &lt;li&gt;新增：找到数组中重复的数字&lt;/li&gt; &#xA; &lt;li&gt;新增：实现 apply/call/bind&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/11/10&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：React Hooks 实现原理&lt;/li&gt; &#xA; &lt;li&gt;优化：谈下 webpack loader 的机制&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/11/09&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：浏览器跨域&lt;/li&gt; &#xA; &lt;li&gt;优化：HTTP 缓存机制&lt;/li&gt; &#xA; &lt;li&gt;优化：前端安全&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/11/01&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：浏览器跨域&lt;/li&gt; &#xA; &lt;li&gt;优化：浏览器的重排重绘&lt;/li&gt; &#xA; &lt;li&gt;优化：Vue 的数据绑定机制&lt;/li&gt; &#xA; &lt;li&gt;优化：前端模块化规范&lt;/li&gt; &#xA; &lt;li&gt;优化：Babel 的原理&lt;/li&gt; &#xA; &lt;li&gt;优化：如何定位内存泄露&lt;/li&gt; &#xA; &lt;li&gt;优化：JavaScript 异步编程&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/10/20&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加：webpack 工作流程章节&lt;/li&gt; &#xA; &lt;li&gt;优化：HTTP/2 和 HTTP/1.1 的对比&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/10/16&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化：浏览器事件循环&lt;/li&gt; &#xA; &lt;li&gt;优化：二叉搜索树的第 k 大的节点&lt;/li&gt; &#xA; &lt;li&gt;修复：反转链表&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/10/14&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加 sitemap&lt;/li&gt; &#xA; &lt;li&gt;修复部分 issue 中提的 bug：JavaScript 异步编程&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/10/03&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;更新前言&lt;/li&gt; &#xA; &lt;li&gt;采纳部分 issue 中提的优化点&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/09/30&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;更新 algolia 搜索插件&lt;/li&gt; &#xA; &lt;li&gt;添加机器人账号&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/09/21&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;修复部分 issue 中提的 bug&lt;/li&gt; &#xA; &lt;li&gt;添加群聊二维码&lt;/li&gt; &#xA; &lt;li&gt;更新关于我们&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/09/18&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加 Vue 双向绑定章节&lt;/li&gt; &#xA; &lt;li&gt;添加 algolia 搜索插件&lt;/li&gt; &#xA; &lt;li&gt;修复部分 issue 中提的 bug&lt;/li&gt; &#xA; &lt;li&gt;更新 LICENSE&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/09/15&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;修复 issue 中提的 bug&lt;/li&gt; &#xA; &lt;li&gt;更新 readme&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/09/14&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加 webpack loader 章节&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2021/09/05&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;发布第一版（模拟题 1 - 3）&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Akiq2016&#34;&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/17002181?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/gongpeione&#34;&gt;&lt;img src=&#34;https://avatars3.githubusercontent.com/u/3984824?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/yola-0316&#34;&gt;&lt;img src=&#34;https://avatars.githubusercontent.com/u/4338052?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xiaokk06&#34;&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/12165373?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/NightCatSama&#34;&gt;&lt;img src=&#34;https://avatars0.githubusercontent.com/u/13888962?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xyxiao001&#34;&gt;&lt;img src=&#34;https://avatars3.githubusercontent.com/u/15681693?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/LLawlight&#34;&gt;&lt;img src=&#34;https://avatars0.githubusercontent.com/u/17525377?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/uztg&#34;&gt;&lt;img src=&#34;https://avatars1.githubusercontent.com/u/17242380?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Daryl-L&#34;&gt;&lt;img src=&#34;https://avatars0.githubusercontent.com/u/5457564?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Yiiu&#34;&gt;&lt;img src=&#34;https://avatars3.githubusercontent.com/u/7876498?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/hellodigua&#34;&gt;&lt;img src=&#34;https://avatars1.githubusercontent.com/u/9943164?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/icemirror&#34;&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/14882452?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/yinmazuo&#34;&gt;&lt;img src=&#34;https://avatars1.githubusercontent.com/u/9531951?v=4&amp;amp;s=400&#34; width=&#34;46&#34; height=&#34;46&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kshyam/flask-blog-with-db</title>
    <updated>2022-09-22T01:33:29Z</updated>
    <id>tag:github.com,2022-09-22:/kshyam/flask-blog-with-db</id>
    <link href="https://github.com/kshyam/flask-blog-with-db" rel="alternate"></link>
    <summary type="html">&lt;p&gt;How to create flask app with flask_sqlalchemy&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;How to create flask app with flask_sqlalchemy&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;    clone this example&#xA;    git clone git@github.com:kshyam/flask-blog-with-db.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install flask_sqlalchemy&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    pip install flask_sqlalchemy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;flask --debug run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;OR&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; export FLASK_ENV=development&#xA; flask run&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Open the application&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://127.0.0.1:5000/&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>tc39/proposal-array-from-async</title>
    <updated>2022-09-22T01:33:29Z</updated>
    <id>tag:github.com,2022-09-22:/tc39/proposal-array-from-async</id>
    <link href="https://github.com/tc39/proposal-array-from-async" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Draft specification for a proposed Array.fromAsync method in JavaScript.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Array.fromAsync for JavaScript&lt;/h1&gt; &#xA;&lt;p&gt;ECMAScript Stage-2 Proposal. J.&amp;nbsp;S. Choi, 2021.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://tc39.es/proposal-array-from-async/&#34;&gt;Specification&lt;/a&gt;&lt;/strong&gt; available&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Experimental polyfills&lt;/strong&gt; (do &lt;strong&gt;not&lt;/strong&gt; use in production code yet): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.npmjs.com/package/array-from-async&#34;&gt;array-from-async&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/zloirock/core-js#arrayfromasync&#34;&gt;core-js&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why an Array.fromAsync method&lt;/h2&gt; &#xA;&lt;p&gt;Since its standardization in JavaScript, &lt;strong&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&#34;&gt;Array.from&lt;/a&gt;&lt;/strong&gt; has become one of &lt;code&gt;Array&lt;/code&gt;’s most frequently used built-in methods. However, no similar functionality exists for async iterators.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const arr = [];&#xA;for (const v of iterable) {&#xA;  arr.push(v);&#xA;}&#xA;&#xA;// This does the same thing.&#xA;const arr = Array.from(iterable);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Such functionality would also be useful for &lt;strong&gt;dumping&lt;/strong&gt; the entirety of an &lt;strong&gt;async iterator&lt;/strong&gt; into a &lt;strong&gt;single data structure&lt;/strong&gt;, especially in &lt;strong&gt;unit tests&lt;/strong&gt; or in &lt;strong&gt;command-line&lt;/strong&gt; interfaces. (Several real-world examples are included in a following section.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const arr = [];&#xA;for await (const v of asyncIterable) {&#xA;  arr.push(v);&#xA;}&#xA;&#xA;// We should add something that does the same thing.&#xA;const arr = await ??????????(asyncIterable);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is an &lt;a href=&#34;https://www.npmjs.com/package/it-all&#34;&gt;it-all&lt;/a&gt; NPM library that performs only this task and which gets about 50,000 weekly downloads. This of course does &lt;strong&gt;not&lt;/strong&gt; include any code that uses ad-hoc &lt;code&gt;for await&lt;/code&gt;–&lt;code&gt;of&lt;/code&gt; loops with empty arrays. Further demonstrating the demand for such functionality, several &lt;a href=&#34;https://stackoverflow.com/questions/58668361/how-can-i-convert-an-async-iterator-to-an-array&#34;&gt;Stack Overflow questions&lt;/a&gt; have been asked by various developers, asking how to convert async iterators to arrays.&lt;/p&gt; &#xA;&lt;p&gt;There are several &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-array-from-async/main/#real-world-examples&#34;&gt;real-world examples&lt;/a&gt; listed later in this explainer.&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;(A &lt;a href=&#34;https://tc39.es/proposal-array-from-async/&#34;&gt;formal draft specification&lt;/a&gt; is available.)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Array.fromAsync is to &lt;code&gt;for await&lt;/code&gt;&lt;/strong&gt;&lt;br&gt; as &lt;strong&gt;Array.from is to &lt;code&gt;for&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Similarly to &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&#34;&gt;Array.from&lt;/a&gt;, Array.fromAsync would be a static method of the &lt;code&gt;Array&lt;/code&gt; built-in class, with one required argument and two optional arguments: &lt;code&gt;(items, mapfn, thisArg)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Async-iterable inputs&lt;/h3&gt; &#xA;&lt;p&gt;But, instead of converting a sync iterable to an array, Array.fromAsync can convert an async iterable to a &lt;strong&gt;promise&lt;/strong&gt; that (if everything goes well) will resolve to a new array. Before the promise resolves, it will create an async iterator from the input, lazily iterate over it, and add each yielded value to the new array. (The promise is immediately returned after the Array.fromAsync function call, no matter what.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function * asyncGen (n) {&#xA;  for (let i = 0; i &amp;lt; n; i++)&#xA;    yield i * 2;&#xA;}&#xA;&#xA;// `arr` will be `[0, 2, 4, 6]`.&#xA;const arr = [];&#xA;for await (const v of asyncGen(4)) {&#xA;  arr.push(v);&#xA;}&#xA;&#xA;// This is equivalent.&#xA;const arr = await Array.fromAsync(asyncGen(4));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sync-iterable inputs&lt;/h3&gt; &#xA;&lt;p&gt;If the argument is a sync iterable (and not an async iterable), then the return value is still a promise that will resolve to an array. If the sync iterator yields promises, then each yielded promise is awaited before its value is added to the new array. (Values that are not promises are also awaited to &lt;a href=&#34;https://blog.izs.me/2013/08/designing-apis-for-asynchrony/&#34;&gt;prevent Zalgo&lt;/a&gt;.) All of this matches the behavior of &lt;code&gt;for await&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function * genPromises (n) {&#xA;  for (let i = 0; i &amp;lt; n; i++)&#xA;    yield Promise.resolve(i * 2);&#xA;}&#xA;&#xA;// `arr` will be `[ 0, 2, 4, 6 ]`.&#xA;const arr = [];&#xA;for await (const v of genPromises(4)) {&#xA;  arr.push(v);&#xA;}&#xA;&#xA;// This is equivalent.&#xA;const arr = await Array.fromAsync(genPromises(4));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Like &lt;code&gt;for await&lt;/code&gt;, Array.fromAsync &lt;strong&gt;lazily&lt;/strong&gt; iterates over a sync-but-not-async input. Whenever a developer needs to dump a synchronous input that yields promises into an array, the developer needs to choose carefully between Array.fromAsync and Promise.all, which have complementary control flows:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Parallel awaiting&lt;/th&gt; &#xA;   &lt;th&gt;Sequential awaiting&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Lazy iteration&lt;/th&gt; &#xA;   &lt;td&gt;Impossible&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;await Array.fromAsync(input)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Eager iteration&lt;/th&gt; &#xA;   &lt;td&gt;&lt;code&gt;await Promise.all(Array.from(input))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Useless&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Also like &lt;code&gt;for await&lt;/code&gt;, when given a sync-but-not-async iterable input, then Array.fromAsync will catch &lt;strong&gt;only&lt;/strong&gt; the first rejection that its iteration reaches, and only if that rejection does &lt;strong&gt;not&lt;/strong&gt; occur in a microtask before the iteration reaches and awaits for it. For more information, see &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-array-from-async/main/#errors&#34;&gt;§&amp;nbsp;Errors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// `arr` will be `[ 0, 2, 4, 6 ]`.&#xA;// `genPromises(4)` is lazily iterated,&#xA;// and its four yielded promises are awaited in sequence.&#xA;const arr = await Array.fromAsync(genPromises(4));&#xA;&#xA;// `arr` will also be `[ 0, 2, 4, 6 ]`.&#xA;// However, `genPromises(4)` is eagerly iterated&#xA;// (into an array of four promises),&#xA;// and the four promises are awaited in parallel.&#xA;const arr = await Promise.all(Array.from(genPromises(4)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Non-iterable array-like inputs&lt;/h3&gt; &#xA;&lt;p&gt;Array.fromAsync’s valid inputs are a superset of Array.from’s valid inputs. This includes non-iterable array-likes: objects that have a length property as well as indexed elements (similarly to Array.prototype.values). The return value is still a promise that will resolve to an array. If the array-like object’s elements are promises, then each accessed promise is awaited before its value is added to the new array.&lt;/p&gt; &#xA;&lt;p&gt;One &lt;a href=&#34;https://github.com/tc39/proposal-array-from-async/issues/7#issuecomment-920299880&#34;&gt;TC39 representative’s opinion&lt;/a&gt;: “[Array-likes are] very much not obsolete, and it’s very nice that things aren’t forced to implement the iterator protocol to be transformable into an Array.”&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const arrLike = {&#xA;  length: 4,&#xA;  0: Promise.resolve(0),&#xA;  1: Promise.resolve(2),&#xA;  2: Promise.resolve(4),&#xA;  3: Promise.resolve(6),&#xA;}&#xA;&#xA;// `arr` will be `[ 0, 2, 4, 6 ]`.&#xA;const arr = [];&#xA;for await (const v of Array.from(arrLike)) {&#xA;  arr.push(v);&#xA;}&#xA;&#xA;// This is equivalent.&#xA;const arr = await Array.fromAsync(arrLike);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As it does with sync-but-not-async iterable inputs, Array.fromAsync lazily iterates over the values of array-like inputs, and it awaits each value. The developer must choose between using Array.fromAsync and Promise.all (see &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-array-from-async/main/#sync-iterable-inputs&#34;&gt;§&amp;nbsp;Sync-iterable inputs&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-array-from-async/main/#errors&#34;&gt;§&amp;nbsp;Errors&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Generic factory method&lt;/h3&gt; &#xA;&lt;p&gt;Array.fromAsync is a generic factory method. It does not require that its this receiver be the Array constructor. fromAsync can be transferred to or inherited by any other constructor. In that case, the final result will be the data structure created by that constructor (with no arguments), and with each value yielded by the input being assigned to the data structure’s numeric properties. (Symbol.species is not involved at all.) If the this receiver is not a constructor, then fromAsync creates an array as usual. This matches the behavior of Array.from.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function * asyncGen (n) {&#xA;  for (let i = 0; i &amp;lt; n; i++)&#xA;    yield i * 2;&#xA;}&#xA;function Data (n) {}&#xA;Data.from = Array.from;&#xA;Data.fromAsync = Array.fromAsync;&#xA;&#xA;// d will be a `new Data(0)`, with its `0` property assigned to `0`, its `1`&#xA;// property assigned to `2`, etc.&#xA;const d = new Data(0); let i = 0;&#xA;for await (const v of asyncGen(4)) {&#xA;  d[i] = v;&#xA;}&#xA;&#xA;// This is equivalent.&#xA;const d = await Data.fromAsync(asyncGen(4));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Optional parameters&lt;/h3&gt; &#xA;&lt;p&gt;Array.fromAsync has two optional parameters: &lt;code&gt;mapfn&lt;/code&gt; and &lt;code&gt;thisArg&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;mapfn&lt;/code&gt; is an optional mapping callback, which is called on each value yielded from the input (and awaited if it came from a synchronous input), along with its index integer (starting from 0). Each result of the mapping callback is, in turn, awaited then added to the array.&lt;/p&gt; &#xA;&lt;p&gt;(Without the optional mapping callback, each value yielded from asynchronous inputs is not awaited, and each value yielded from synchronous inputs is awaited only once, before the value is added to the result array. This matches the behavior of &lt;code&gt;for await&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;thisArg&lt;/code&gt; is a &lt;code&gt;this&lt;/code&gt;-binding receiver value for the mapping callback. By default, this is undefined. These optional parameters match the behavior of Array.from. Their exclusion would be surprising to developers who are already used to Array.from.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function * asyncGen (n) {&#xA;  for (let i = 0; i &amp;lt; n; i++)&#xA;    yield i * 2;&#xA;}&#xA;&#xA;// `arr` will be `[ 0, 4, 16, 36 ]`.&#xA;const arr = [];&#xA;for await (const v of asyncGen(4)) {&#xA;  arr.push(await (v ** 2));&#xA;}&#xA;&#xA;// This is equivalent.&#xA;const arr = await Array.fromAsync(asyncGen(4), v =&amp;gt;&#xA;  v ** 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;Like other promise-based APIs, Array.fromAsync will always immediately return a promise. Array.fromAsync will never synchronously throw an error and &lt;a href=&#34;https://blog.izs.me/2013/08/designing-apis-for-asynchrony/&#34;&gt;summon Zalgo&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When Array.fromAsync’s input throws an error while creating its async or sync iterator, then Array.fromAsync’s returned promise will reject with that error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const err = new Error;&#xA;const badIterable = { [Symbol.iterator] () { throw err; } };&#xA;&#xA;// This returns a promise that will reject with `err`.&#xA;Array.fromAsync(badIterable);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When Array.fromAsync’s input is iterable but the input’s iterator throws while iterating, then Array.fromAsync’s returned promise will reject with that error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const err = new Error;&#xA;async function * genErrorAsync () { throw err; }&#xA;&#xA;// This returns a promise that will reject with `err`.&#xA;Array.fromAsync(genErrorAsync());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const err = new Error;&#xA;function * genError () { throw err; }&#xA;&#xA;// This returns a promise that will reject with `err`.&#xA;Array.fromAsync(genError());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When Array.fromAsync’s input is synchronous only (i.e., the input is not an async iterable), and when one of the input’s values is a promise that eventually rejects or has rejected, then iteration stops and Array.fromAsync’s returned promise will reject with the first such error.&lt;/p&gt; &#xA;&lt;p&gt;In this case, Array.fromAsync will catch and handle that first input rejection &lt;strong&gt;only if&lt;/strong&gt; that rejection does &lt;strong&gt;not&lt;/strong&gt; occur in a microtask before the iteration reaches and awaits for it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const err = new Error;&#xA;function * genRejection () {&#xA;  yield Promise.reject(err);&#xA;}&#xA;&#xA;// This returns a promise that will reject with `err`. There is **no**&#xA;// unhandled promise rejection, because the rejection occurs in the same&#xA;// microtask.&#xA;Array.fromAsync(genZeroThenRejection());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like with &lt;code&gt;for await&lt;/code&gt;, Array.fromAsync will &lt;strong&gt;not&lt;/strong&gt; catch any rejections by the input’s promises whenever those rejections occur &lt;strong&gt;before&lt;/strong&gt; the ticks in which Array.fromAsync’s iteration reaches those promises.&lt;/p&gt; &#xA;&lt;p&gt;This is because – like &lt;code&gt;for await&lt;/code&gt; – Array.fromAsync &lt;strong&gt;lazily&lt;/strong&gt; iterates over its input and &lt;strong&gt;sequentially&lt;/strong&gt; awaits each yielded value. Whenever a developer needs to dump a synchronous input that yields promises into an array, the developer needs to choose carefully between Array.fromAsync and Promise.all, which have complementary control flows (see &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-array-from-async/main/#sync-iterable-inputs&#34;&gt;§&amp;nbsp;Sync-iterable inputs&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;For example, when a synchronous input contains two promises, the latter of which will reject before the former promise resolves, then Array.fromAsync will not catch that rejection, because it lazily reaches the rejecting promise only after it already has rejected.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const numOfMillisecondsPerSecond = 1000;&#xA;const slowError = new Error;&#xA;const fastError = new Error;&#xA;&#xA;function waitThenReject (value) {&#xA;  return new Promise((resolve, reject) =&amp;gt; {&#xA;    setTimeout(() =&amp;gt; reject(value), numOfMillisecondsPerSecond);&#xA;  });&#xA;}&#xA;&#xA;function * genRejections () {&#xA;  // Slow promise.&#xA;  yield waitAndReject(slowError);&#xA;  // Fast promise.&#xA;  yield Promise.reject(fastError);&#xA;}&#xA;&#xA;// This returns a promise that will reject with `slowError`. There is **no**&#xA;// unhandled promise rejection: the iteration is lazy and will stop early at the&#xA;// slow promise, so the fast promise will never be created.&#xA;Array.fromAsync(genSlowRejectThenFastReject());&#xA;&#xA;// This returns a promise that will reject with `slowError`. There **is** an&#xA;// unhandled promise rejection with `fastError`: the iteration eagerly creates&#xA;// and dumps both promises into an array, but Array.fromAsync will&#xA;// **sequentially** handle only the slow promise.&#xA;Array.fromAsync([ ...genSlowRejectThenFastReject() ]);&#xA;&#xA;// This returns a promise that will reject with `fastError`. There is **no**&#xA;// unhandled promise rejection: the iteration eagerly creates and dumps both&#xA;// promises into an array, but Promise.all will handle both promises **in&#xA;// parallel**.&#xA;Promise.all([ ...genSlowRejectThenFastReject() ]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When Array.fromAsync’s input has at least one value, and when Array.fromAsync’s mapping callback throws an error when given any of those values, then Array.fromAsync’s returned promise will reject with the first such error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const err = new Error;&#xA;function badCallback () { throw err; }&#xA;&#xA;// This returns a promise that will reject with `err`.&#xA;Array.fromAsync([ 0 ], badCallback);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When Array.fromAsync’s input is null or undefined, or when Array.fromAsync’s mapping callback is neither undefined nor callable, then Array.fromAsync’s returned promise will reject with a TypeError.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// These return promises that will reject with TypeErrors.&#xA;Array.fromAsync(null);&#xA;Array.fromAsync([], 1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Other proposals&lt;/h2&gt; &#xA;&lt;h3&gt;Relationship with iterator-helpers&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/tc39/proposal-iterator-helpers&#34;&gt;iterator-helpers&lt;/a&gt; proposal has toArray, which works with both sync and async iterables. The following pairs of lines are equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Array.from&#xA;&#xA;Array.from(iterable)&#xA;Iterator(iterable).toArray()&#xA;&#xA;Array.from(iterable, mapfn)&#xA;Iterator(iterable).map(mapfn).toArray()&#xA;&#xA;// Array.fromAsync&#xA;&#xA;Array.fromAsync(asyncIterable)&#xA;AsyncIterator(asyncIterable).toArray()&#xA;&#xA;Array.fromAsync(asyncIterable, mapfn)&#xA;AsyncIterator(asyncIterable).map(mapfn).toArray()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;toArray overlaps with both Array.from and Array.fromAsync. This is okay. They can coexist. If we have to choose between having toArray and having fromAsync, then we should choose fromAsync. We already have Array.from. We should match the existing language precedent.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://github.com/tc39/proposal-iterator-helpers/issues/156.&#34;&gt;co-champion of iterable-helpers agrees&lt;/a&gt; that we should have both or that we should prefer Array.fromAsync: “I remembered why it’s better for a buildable structure to consume an iterable than for an iterable to consume a buildable protocol. Sometimes building something one element at a time is the same as building it [more than one] element at a time, but sometimes it could be slow to build that way or produce a structure with equivalent semantics but different performance properties.”&lt;/p&gt; &#xA;&lt;h3&gt;TypedArray.fromAsync, Set.fromAsync, Object.fromEntriesAsync, etc.&lt;/h3&gt; &#xA;&lt;p&gt;The following built-ins also resemble Array.from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;TypedArray.from()&#xA;new Set&#xA;Object.fromEntries()&#xA;new Map&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We are deferring any async versions of these methods to future proposals. See &lt;a href=&#34;https://github.com/tc39/proposal-array-from-async/issues/8&#34;&gt;issue #8&lt;/a&gt; and &lt;a href=&#34;https://github.com/tc39/proposal-setmap-offrom&#34;&gt;proposal-setmap-offrom&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Async spread operator&lt;/h3&gt; &#xA;&lt;p&gt;In the future, standardizing an async spread operator (like &lt;code&gt;[ 0, await ...v ]&lt;/code&gt;) may be useful. This proposal leaves that idea to a &lt;strong&gt;separate&lt;/strong&gt; proposal.&lt;/p&gt; &#xA;&lt;h3&gt;Records and tuples&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-record-tuple&#34;&gt;record/tuple&lt;/a&gt; proposal&lt;/strong&gt; puts forward two new data types with APIs that respectively &lt;strong&gt;resemble&lt;/strong&gt; those of &lt;strong&gt;&lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;&lt;/strong&gt;. The &lt;code&gt;Tuple&lt;/code&gt; constructor, too, would probably need an &lt;code&gt;fromAsync&lt;/code&gt; method. Whether the &lt;code&gt;Record&lt;/code&gt; constructor gets a &lt;code&gt;fromEntriesAsync&lt;/code&gt; method will depend on whether &lt;code&gt;Object.fromEntriesAsync&lt;/code&gt; will also be added in a separate proposal.&lt;/p&gt; &#xA;&lt;h2&gt;Real-world examples&lt;/h2&gt; &#xA;&lt;p&gt;Only minor formatting changes have been made to the status-quo examples.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Status quo &lt;/th&gt;&#xA;   &lt;th&gt;With Array.fromAsync &lt;/th&gt;&#xA;  &lt;/tr&gt;&#xA; &lt;/thead&gt;&#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const all = require(&#39;it-all&#39;);&#xA;&#xA;// Add the default assets to the repo.&#xA;const results = await all(&#xA;  addAll(&#xA;    globSource(initDocsPath, {&#xA;      recursive: true,&#xA;    }),&#xA;    { preload: false },&#xA;  ),&#xA;);&#xA;const dir = results&#xA;  .filter(file =&amp;gt;&#xA;    file.path === &#39;init-docs&#39;)&#xA;  .pop()&#xA;print(&#39;to get started, enter:\n&#39;);&#xA;print(&#xA;  `\tjsipfs cat` +&#xA;  `/ipfs/${dir.cid}/readme\n`,&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;From &lt;a href=&#34;https://github.com/ipfs/js-ipfs/raw/release/v0.54.x/packages/ipfs-core/src/runtime/init-assets-nodejs.js&#34;&gt;ipfs-core/src/runtime/init-assets-nodejs.js&lt;/a&gt;.&lt;/p&gt; &lt;/td&gt;&#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Add the default assets to the repo.&#xA;const results = await Array.fromAsync(&#xA;  addAll(&#xA;    globSource(initDocsPath, {&#xA;      recursive: true,&#xA;    }),&#xA;    { preload: false },&#xA;  ),&#xA;);&#xA;const dir = results&#xA;  .filter(file =&amp;gt;&#xA;    file.path === &#39;init-docs&#39;)&#xA;  .pop()&#xA;print(&#39;to get started, enter:\n&#39;);&#xA;print(&#xA;  `\tjsipfs cat` +&#xA;  `/ipfs/${dir.cid}/readme\n`,&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;&#xA;  &lt;/tr&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const all = require(&#39;it-all&#39;);&#xA;&#xA;const results = await all(&#xA;  node.contentRouting&#xA;    .findProviders(&#39;a cid&#39;),&#xA;);&#xA;expect(results)&#xA;  .to.be.an(&#39;array&#39;)&#xA;  .with.lengthOf(1)&#xA;  .that.deep.equals([result]);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;From &lt;a href=&#34;https://github.com/libp2p/js-libp2p/raw/13cf4761489d59b22924bb8ec2ec6dbe207b280c/test/content-routing/content-routing.node.js&#34;&gt;js-libp2p/test/content-routing/content-routing.node.js&lt;/a&gt;.&lt;/p&gt; &lt;/td&gt;&#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const results = await Array.fromAsync(&#xA;  node.contentRouting&#xA;    .findProviders(&#39;a cid&#39;),&#xA;);&#xA;expect(results)&#xA;  .to.be.an(&#39;array&#39;)&#xA;  .with.lengthOf(1)&#xA;  .that.deep.equals([result]);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;&#xA;  &lt;/tr&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function toArray(items) {&#xA;  const result = [];&#xA;  for await (const item of items) {&#xA;    result.push(item);&#xA;  }&#xA;  return result;&#xA;}&#xA;&#xA;it(&#39;empty-pipeline&#39;, async () =&amp;gt; {&#xA;  const pipeline = new Pipeline();&#xA;  const result = await toArray(&#xA;    pipeline.execute(&#xA;      [ 1, 2, 3, 4, 5 ]));&#xA;  assert.deepStrictEqual(&#xA;    result,&#xA;    [ 1, 2, 3, 4, 5 ],&#xA;  );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;From &lt;a href=&#34;https://github.com/adobe/node-httptransfer/raw/22a32e72df89ce40e77a1dae5575a07654a0851f/test/generator/pipeline.test.js&#34;&gt;node-httptransfer/test/generator/pipeline.test.js&lt;/a&gt;.&lt;/p&gt; &lt;/td&gt;&#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;it(&#39;empty-pipeline&#39;, async () =&amp;gt; {&#xA;  const pipeline = new Pipeline();&#xA;  const result = await Array.fromAsync(&#xA;    pipeline.execute(&#xA;      [ 1, 2, 3, 4, 5 ]));&#xA;  assert.deepStrictEqual(&#xA;    result,&#xA;    [ 1, 2, 3, 4, 5 ],&#xA;  );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;&#xA;  &lt;/tr&gt;&#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt;</summary>
  </entry>
</feed>