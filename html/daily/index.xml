<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-26T01:32:51Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fluent-ffmpeg/node-fluent-ffmpeg</title>
    <updated>2022-11-26T01:32:51Z</updated>
    <id>tag:github.com,2022-11-26:/fluent-ffmpeg/node-fluent-ffmpeg</id>
    <link href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fluent API to FFMPEG (http://www.ffmpeg.org)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fluent ffmpeg-API for node.js &lt;a href=&#34;http://travis-ci.org/fluent-ffmpeg/node-fluent-ffmpeg&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/fluent-ffmpeg/node-fluent-ffmpeg.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.fossa.io/projects/git%2Bgithub.com%2Ffluent-ffmpeg%2Fnode-fluent-ffmpeg?ref=badge_shield&#34;&gt;&lt;img src=&#34;https://app.fossa.io/api/projects/git%2Bgithub.com%2Ffluent-ffmpeg%2Fnode-fluent-ffmpeg.svg?type=shield&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Fluent-ffmpeg is looking for new maintainers&lt;/strong&gt; More details &lt;a href=&#34;https://github.com/fluent-ffmpeg/node-fluent-ffmpeg/wiki/Looking-for-a-new-maintainer&#34;&gt;on the wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This library abstracts the complex command-line usage of ffmpeg into a fluent, easy to use node.js module. In order to be able to use this module, make sure you have &lt;a href=&#34;http://www.ffmpeg.org&#34;&gt;ffmpeg&lt;/a&gt; installed on your system (including all necessary encoding libraries like libmp3lame or libx264).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This is the documentation for fluent-ffmpeg 2.x. You can still access the code and documentation for fluent-ffmpeg 1.7 &lt;a href=&#34;https://github.com/fluent-ffmpeg/node-fluent-ffmpeg/tree/1.x&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Via npm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm install fluent-ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or as a submodule:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git submodule add git://github.com/schaermu/node-fluent-ffmpeg.git vendor/fluent-ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You will find a lot of usage examples (including a real-time streaming example using &lt;a href=&#34;http://www.flowplayer.org&#34;&gt;flowplayer&lt;/a&gt; and &lt;a href=&#34;https://github.com/visionmedia/express&#34;&gt;express&lt;/a&gt;!) in the &lt;code&gt;examples&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;h4&gt;ffmpeg and ffprobe&lt;/h4&gt; &#xA;&lt;p&gt;fluent-ffmpeg requires ffmpeg &amp;gt;= 0.9 to work. It may work with previous versions but several features won&#39;t be available (and the library is not tested with lower versions anylonger).&lt;/p&gt; &#xA;&lt;p&gt;If the &lt;code&gt;FFMPEG_PATH&lt;/code&gt; environment variable is set, fluent-ffmpeg will use it as the full path to the &lt;code&gt;ffmpeg&lt;/code&gt; executable. Otherwise, it will attempt to call &lt;code&gt;ffmpeg&lt;/code&gt; directly (so it should be in your &lt;code&gt;PATH&lt;/code&gt;). You must also have ffprobe installed (it comes with ffmpeg in most distributions). Similarly, fluent-ffmpeg will use the &lt;code&gt;FFPROBE_PATH&lt;/code&gt; environment variable if it is set, otherwise it will attempt to call it in the &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Most features should work when using avconv and avprobe instead of ffmpeg and ffprobe, but they are not officially supported at the moment.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Windows users&lt;/strong&gt;: most probably ffmpeg and ffprobe will &lt;em&gt;not&lt;/em&gt; be in your &lt;code&gt;%PATH&lt;/code&gt;, so you &lt;em&gt;must&lt;/em&gt; set &lt;code&gt;%FFMPEG_PATH&lt;/code&gt; and &lt;code&gt;%FFPROBE_PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Debian/Ubuntu users&lt;/strong&gt;: the official repositories have the ffmpeg/ffprobe executable in the &lt;code&gt;libav-tools&lt;/code&gt; package, and they are actually rebranded avconv/avprobe executables (avconv is a fork of ffmpeg). They should be mostly compatible, but should you encounter any issue, you may want to use the real ffmpeg instead. You can either compile it from source or find a pre-built .deb package at &lt;a href=&#34;https://ffmpeg.org/download.html&#34;&gt;https://ffmpeg.org/download.html&lt;/a&gt; (For Ubuntu, the &lt;code&gt;ppa:mc3man/trusty-media&lt;/code&gt; PPA provides recent builds).&lt;/p&gt; &#xA;&lt;h4&gt;flvtool2 or flvmeta&lt;/h4&gt; &#xA;&lt;p&gt;If you intend to encode FLV videos, you must have either flvtool2 or flvmeta installed and in your &lt;code&gt;PATH&lt;/code&gt; or fluent-ffmpeg won&#39;t be able to produce streamable output files. If you set either the &lt;code&gt;FLVTOOL2_PATH&lt;/code&gt; or &lt;code&gt;FLVMETA_PATH&lt;/code&gt;, fluent-ffmpeg will try to use it instead of searching in the &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Setting binary paths manually&lt;/h4&gt; &#xA;&lt;p&gt;Alternatively, you may set the ffmpeg, ffprobe and flvtool2/flvmeta binary paths manually by using the following API commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ffmpeg.setFfmpegPath(path)&lt;/strong&gt; Argument &lt;code&gt;path&lt;/code&gt; is a string with the full path to the ffmpeg binary.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ffmpeg.setFfprobePath(path)&lt;/strong&gt; Argument &lt;code&gt;path&lt;/code&gt; is a string with the full path to the ffprobe binary.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ffmpeg.setFlvtoolPath(path)&lt;/strong&gt; Argument &lt;code&gt;path&lt;/code&gt; is a string with the full path to the flvtool2 or flvmeta binary.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Creating an FFmpeg command&lt;/h3&gt; &#xA;&lt;p&gt;The fluent-ffmpeg module returns a constructor that you can use to instanciate FFmpeg commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var FfmpegCommand = require(&#39;fluent-ffmpeg&#39;);&#xA;var command = new FfmpegCommand();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use the constructor without the &lt;code&gt;new&lt;/code&gt; operator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var ffmpeg = require(&#39;fluent-ffmpeg&#39;);&#xA;var command = ffmpeg();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may pass an input file name or readable stream, a configuration object, or both to the constructor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var command = ffmpeg(&#39;/path/to/file.avi&#39;);&#xA;var command = ffmpeg(fs.createReadStream(&#39;/path/to/file.avi&#39;));&#xA;var command = ffmpeg({ option: &#34;value&#34;, ... });&#xA;var command = ffmpeg(&#39;/path/to/file.avi&#39;, { option: &#34;value&#34;, ... });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following options are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;source&lt;/code&gt;: input file name or readable stream (ignored if an input file is passed to the constructor)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt;: ffmpeg timeout in seconds (defaults to no timeout)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;preset&lt;/code&gt; or &lt;code&gt;presets&lt;/code&gt;: directory to load module presets from (defaults to the &lt;code&gt;lib/presets&lt;/code&gt; directory in fluent-ffmpeg tree)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;niceness&lt;/code&gt; or &lt;code&gt;priority&lt;/code&gt;: ffmpeg niceness value, between -20 and 20; ignored on Windows platforms (defaults to 0)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;logger&lt;/code&gt;: logger object with &lt;code&gt;debug()&lt;/code&gt;, &lt;code&gt;info()&lt;/code&gt;, &lt;code&gt;warn()&lt;/code&gt; and &lt;code&gt;error()&lt;/code&gt; methods (defaults to no logging)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stdoutLines&lt;/code&gt;: maximum number of lines from ffmpeg stdout/stderr to keep in memory (defaults to 100, use 0 for unlimited storage)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Specifying inputs&lt;/h3&gt; &#xA;&lt;p&gt;You can add any number of inputs to an Ffmpeg command. An input can be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a file name (eg. &lt;code&gt;/path/to/file.avi&lt;/code&gt;);&lt;/li&gt; &#xA; &lt;li&gt;an image pattern (eg. &lt;code&gt;/path/to/frame%03d.png&lt;/code&gt;);&lt;/li&gt; &#xA; &lt;li&gt;a readable stream; only one input stream may be used for a command, but you can use both an input stream and one or several file names.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Note that all fluent-ffmpeg methods are chainable&#xA;ffmpeg(&#39;/path/to/input1.avi&#39;)&#xA;  .input(&#39;/path/to/input2.avi&#39;)&#xA;  .input(fs.createReadStream(&#39;/path/to/input3.avi&#39;));&#xA;&#xA;// Passing an input to the constructor is the same as calling .input()&#xA;ffmpeg()&#xA;  .input(&#39;/path/to/input1.avi&#39;)&#xA;  .input(&#39;/path/to/input2.avi&#39;);&#xA;&#xA;// Most methods have several aliases, here you may use addInput or mergeAdd instead&#xA;ffmpeg()&#xA;  .addInput(&#39;/path/to/frame%02d.png&#39;)&#xA;  .addInput(&#39;/path/to/soundtrack.mp3&#39;);&#xA;&#xA;ffmpeg()&#xA;  .mergeAdd(&#39;/path/to/input1.avi&#39;)&#xA;  .mergeAdd(&#39;/path/to/input2.avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Input options&lt;/h3&gt; &#xA;&lt;p&gt;The following methods enable passing input-related options to ffmpeg. Each of these methods apply on the last input added (including the one passed to the constructor, if any). You must add an input before calling those, or an error will be thrown.&lt;/p&gt; &#xA;&lt;h4&gt;inputFormat(format): specify input format&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;fromFormat()&lt;/code&gt;, &lt;code&gt;withInputFormat()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is only useful for raw inputs, as ffmpeg can determine the input format automatically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg()&#xA;  .input(&#39;/dev/video0&#39;)&#xA;  .inputFormat(&#39;mov&#39;)&#xA;  .input(&#39;/path/to/file.avi&#39;)&#xA;  .inputFormat(&#39;avi&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fluent-ffmpeg checks for format availability before actually running the command, and throws an error when a specified input format is not available.&lt;/p&gt; &#xA;&lt;h4&gt;inputFPS(fps): specify input framerate&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withInputFps()&lt;/code&gt;, &lt;code&gt;withInputFPS()&lt;/code&gt;, &lt;code&gt;withFpsInput()&lt;/code&gt;, &lt;code&gt;withFPSInput()&lt;/code&gt;, &lt;code&gt;inputFps()&lt;/code&gt;, &lt;code&gt;fpsInput()&lt;/code&gt;, &lt;code&gt;FPSInput()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is only valid for raw inputs, as ffmpeg can determine the input framerate automatically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/dev/video0&#39;).inputFPS(29.7);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;native(): read input at native framerate&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;nativeFramerate()&lt;/code&gt;, &lt;code&gt;withNativeFramerate()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).native();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;seekInput(time): set input start time&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Alias&lt;/strong&gt;: &lt;code&gt;setStartTime()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Seeks an input and only start decoding at given time offset. The &lt;code&gt;time&lt;/code&gt; argument may be a number (in seconds) or a timestamp string (with format &lt;code&gt;[[hh:]mm:]ss[.xxx]&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).seekInput(134.5);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).seekInput(&#39;2:14.500&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;loop([duration]): loop over input&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).loop();&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).loop(134.5);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).loop(&#39;2:14.500&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;inputOptions(option...): add custom input options&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;inputOption()&lt;/code&gt;, &lt;code&gt;addInputOption()&lt;/code&gt;, &lt;code&gt;addInputOptions()&lt;/code&gt;, &lt;code&gt;withInputOption()&lt;/code&gt;, &lt;code&gt;withInputOptions()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method allows passing any input-related option to ffmpeg. You can call it with a single argument to pass a single option, optionally with a space-separated parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/* Single option */&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).inputOptions(&#39;-someOption&#39;);&#xA;&#xA;/* Single option with parameter */&#xA;ffmpeg(&#39;/dev/video0&#39;).inputOptions(&#39;-r 24&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also pass multiple options at once by passing an array to the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).inputOptions([&#xA;  &#39;-option1&#39;,&#xA;  &#39;-option2 param2&#39;,&#xA;  &#39;-option3&#39;,&#xA;  &#39;-option4 param4&#39;&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, you may also directly pass command line tokens as separate arguments to the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).inputOptions(&#xA;  &#39;-option1&#39;,&#xA;  &#39;-option2&#39;, &#39;param2&#39;,&#xA;  &#39;-option3&#39;,&#xA;  &#39;-option4&#39;, &#39;param4&#39;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Audio options&lt;/h3&gt; &#xA;&lt;p&gt;The following methods change the audio stream(s) in the produced output.&lt;/p&gt; &#xA;&lt;h4&gt;noAudio(): disable audio altogether&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withNoAudio()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Disables audio in the output and remove any previously set audio option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).noAudio();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;audioCodec(codec): set audio codec&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withAudioCodec()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).audioCodec(&#39;libmp3lame&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fluent-ffmpeg checks for codec availability before actually running the command, and throws an error when a specified audio codec is not available.&lt;/p&gt; &#xA;&lt;h4&gt;audioBitrate(bitrate): set audio bitrate&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withAudioBitrate()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Sets the audio bitrate in kbps. The &lt;code&gt;bitrate&lt;/code&gt; parameter may be a number or a string with an optional &lt;code&gt;k&lt;/code&gt; suffix. This method is used to enforce a constant bitrate; use &lt;code&gt;audioQuality()&lt;/code&gt; to encode using a variable bitrate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).audioBitrate(128);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).audioBitrate(&#39;128&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).audioBitrate(&#39;128k&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;audioChannels(count): set audio channel count&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withAudioChannels()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).audioChannels(2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;audioFrequency(freq): set audio frequency&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withAudioFrequency()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;freq&lt;/code&gt; parameter specifies the audio frequency in Hz.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).audioFrequency(22050);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;audioQuality(quality): set audio quality&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withAudioQuality()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method fixes a quality factor for the audio codec (VBR encoding). The quality scale depends on the actual codec used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .audioCodec(&#39;libmp3lame&#39;)&#xA;  .audioQuality(0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;audioFilters(filter...): add custom audio filters&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;audioFilter()&lt;/code&gt;, &lt;code&gt;withAudioFilter()&lt;/code&gt;, &lt;code&gt;withAudioFilters()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method enables adding custom audio filters. You may add multiple filters at once by passing either several arguments or an array. See the Ffmpeg documentation for available filters and their syntax.&lt;/p&gt; &#xA;&lt;p&gt;Each filter pased to this method can be either a filter string (eg. &lt;code&gt;volume=0.5&lt;/code&gt;) or a filter specification object with the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;filter&lt;/code&gt;: filter name&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt;: optional; either an option string for the filter (eg. &lt;code&gt;n=-50dB:d=5&lt;/code&gt;), an options array for unnamed options (eg. &lt;code&gt;[&#39;-50dB&#39;, 5]&lt;/code&gt;) or an object mapping option names to values (eg. &lt;code&gt;{ n: &#39;-50dB&#39;, d: 5 }&lt;/code&gt;). When &lt;code&gt;options&lt;/code&gt; is not specified, the filter will be added without any options.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .audioFilters(&#39;volume=0.5&#39;)&#xA;  .audioFilters(&#39;silencedetect=n=-50dB:d=5&#39;);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .audioFilters(&#39;volume=0.5&#39;, &#39;silencedetect=n=-50dB:d=5&#39;);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .audioFilters([&#39;volume=0.5&#39;, &#39;silencedetect=n=-50dB:d=5&#39;]);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .audioFilters([&#xA;    {&#xA;      filter: &#39;volume&#39;,&#xA;      options: &#39;0.5&#39;&#xA;    },&#xA;    {&#xA;      filter: &#39;silencedetect&#39;,&#xA;      options: &#39;n=-50dB:d=5&#39;&#xA;    }&#xA;  ]);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .audioFilters(&#xA;    {&#xA;      filter: &#39;volume&#39;,&#xA;      options: [&#39;0.5&#39;]&#xA;    },&#xA;    {&#xA;      filter: &#39;silencedetect&#39;,&#xA;      options: { n: &#39;-50dB&#39;, d: 5 }&#xA;    }&#xA;  ]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Video options&lt;/h3&gt; &#xA;&lt;p&gt;The following methods change the video stream(s) in the produced output.&lt;/p&gt; &#xA;&lt;h4&gt;noVideo(): disable video altogether&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withNoVideo()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method disables video output and removes any previously set video option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).noVideo();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;videoCodec(codec): set video codec&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withVideoCodec()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).videoCodec(&#39;libx264&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fluent-ffmpeg checks for codec availability before actually running the command, and throws an error when a specified video codec is not available.&lt;/p&gt; &#xA;&lt;h4&gt;videoBitrate(bitrate[, constant=false]): set video bitrate&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withVideoBitrate()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Sets the target video bitrate in kbps. The &lt;code&gt;bitrate&lt;/code&gt; argument may be a number or a string with an optional &lt;code&gt;k&lt;/code&gt; suffix. The &lt;code&gt;constant&lt;/code&gt; argument specifies whether a constant bitrate should be enforced (defaults to false).&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind that, depending on the codec used, enforcing a constant bitrate often comes at the cost of quality. The best way to have a constant video bitrate without losing too much quality is to use 2-pass encoding (see Fffmpeg documentation).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).videoBitrate(1000);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).videoBitrate(&#39;1000&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).videoBitrate(&#39;1000k&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).videoBitrate(&#39;1000k&#39;, true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;videoFilters(filter...): add custom video filters&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;videoFilter()&lt;/code&gt;, &lt;code&gt;withVideoFilter()&lt;/code&gt;, &lt;code&gt;withVideoFilters()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method enables adding custom video filters. You may add multiple filters at once by passing either several arguments or an array. See the Ffmpeg documentation for available filters and their syntax.&lt;/p&gt; &#xA;&lt;p&gt;Each filter pased to this method can be either a filter string (eg. &lt;code&gt;fade=in:0:30&lt;/code&gt;) or a filter specification object with the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;filter&lt;/code&gt;: filter name&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt;: optional; either an option string for the filter (eg. &lt;code&gt;in:0:30&lt;/code&gt;), an options array for unnamed options (eg. &lt;code&gt;[&#39;in&#39;, 0, 30]&lt;/code&gt;) or an object mapping option names to values (eg. &lt;code&gt;{ t: &#39;in&#39;, s: 0, n: 30 }&lt;/code&gt;). When &lt;code&gt;options&lt;/code&gt; is not specified, the filter will be added without any options.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .videoFilters(&#39;fade=in:0:30&#39;)&#xA;  .videoFilters(&#39;pad=640:480:0:40:violet&#39;);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .videoFilters(&#39;fade=in:0:30&#39;, &#39;pad=640:480:0:40:violet&#39;);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .videoFilters([&#39;fade=in:0:30&#39;, &#39;pad=640:480:0:40:violet&#39;]);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .videoFilters([&#xA;    {&#xA;      filter: &#39;fade&#39;,&#xA;      options: &#39;in:0:30&#39;&#xA;    },&#xA;    {&#xA;      filter: &#39;pad&#39;,&#xA;      options: &#39;640:480:0:40:violet&#39;&#xA;    }&#xA;  ]);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;    .videoFilters(&#xA;    {&#xA;      filter: &#39;fade&#39;,&#xA;      options: [&#39;in&#39;, 0, 30]&#xA;    },&#xA;    {&#xA;      filter: &#39;filter2&#39;,&#xA;      options: { w: 640, h: 480, x: 0, y: 40, color: &#39;violet&#39; }&#xA;    }&#xA;  );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;fps(fps): set output framerate&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withOutputFps()&lt;/code&gt;, &lt;code&gt;withOutputFPS()&lt;/code&gt;, &lt;code&gt;withFpsOutput()&lt;/code&gt;, &lt;code&gt;withFPSOutput()&lt;/code&gt;, &lt;code&gt;withFps()&lt;/code&gt;, &lt;code&gt;withFPS()&lt;/code&gt;, &lt;code&gt;outputFPS()&lt;/code&gt;, &lt;code&gt;outputFps()&lt;/code&gt;, &lt;code&gt;fpsOutput()&lt;/code&gt;, &lt;code&gt;FPSOutput()&lt;/code&gt;, &lt;code&gt;FPS()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).fps(29.7);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;frames(count): specify frame count&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;takeFrames()&lt;/code&gt;, &lt;code&gt;withFrames()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Set ffmpeg to only encode a certain number of frames.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).frames(240);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Video frame size options&lt;/h3&gt; &#xA;&lt;p&gt;The following methods enable resizing the output video frame size. They all work together to generate the appropriate video filters.&lt;/p&gt; &#xA;&lt;h4&gt;size(size): set output frame size&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;videoSize()&lt;/code&gt;, &lt;code&gt;withSize()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method sets the output frame size. The &lt;code&gt;size&lt;/code&gt; argument may have one of the following formats:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;640x480&lt;/code&gt;: set a fixed output frame size. Unless &lt;code&gt;autopad()&lt;/code&gt; is called, this may result in the video being stretched or squeezed to fit the requested size.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;640x?&lt;/code&gt;: set a fixed width and compute height automatically. If &lt;code&gt;aspect()&lt;/code&gt; is also called, it is used to compute video height; otherwise it is computed so that the input aspect ratio is preserved.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;?x480&lt;/code&gt;: set a fixed height and compute width automatically. If &lt;code&gt;aspect()&lt;/code&gt; is also called, it is used to compute video width; otherwise it is computed so that the input aspect ratio is preserved.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;50%&lt;/code&gt;: rescale both width and height to the given percentage. Aspect ratio is always preserved.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that for compatibility with some codecs, computed dimensions are always rounded down to multiples of 2.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x480&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;).aspect(&#39;4:3&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;50%&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;aspect(aspect): set output frame aspect ratio&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withAspect()&lt;/code&gt;, &lt;code&gt;withAspectRatio()&lt;/code&gt;, &lt;code&gt;setAspect()&lt;/code&gt;, &lt;code&gt;setAspectRatio()&lt;/code&gt;, &lt;code&gt;aspectRatio()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method enforces a specific output aspect ratio. The &lt;code&gt;aspect&lt;/code&gt; argument may either be a number or a &lt;code&gt;X:Y&lt;/code&gt; string.&lt;/p&gt; &#xA;&lt;p&gt;Note that calls to &lt;code&gt;aspect()&lt;/code&gt; are ignored when &lt;code&gt;size()&lt;/code&gt; has been called with a fixed width and height or a percentage, and also when &lt;code&gt;size()&lt;/code&gt; has not been called at all.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;).aspect(&#39;4:3&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;).aspect(1.33333);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;autopad([color=&#39;black&#39;]): enable auto-padding the output video&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;applyAutopadding()&lt;/code&gt;, &lt;code&gt;applyAutoPadding()&lt;/code&gt;, &lt;code&gt;applyAutopad()&lt;/code&gt;, &lt;code&gt;applyAutoPad()&lt;/code&gt;, &lt;code&gt;withAutopadding()&lt;/code&gt;, &lt;code&gt;withAutoPadding()&lt;/code&gt;, &lt;code&gt;withAutopad()&lt;/code&gt;, &lt;code&gt;withAutoPad()&lt;/code&gt;, &lt;code&gt;autoPad()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method enables applying auto-padding to the output video. The &lt;code&gt;color&lt;/code&gt; parameter specifies which color to use for padding, and must be a color code or name supported by ffmpeg (defaults to &#39;black&#39;).&lt;/p&gt; &#xA;&lt;p&gt;The behaviour of this method depends on calls made to other video size methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;when &lt;code&gt;size()&lt;/code&gt; has been called with a percentage or has not been called, it is ignored;&lt;/li&gt; &#xA; &lt;li&gt;when &lt;code&gt;size()&lt;/code&gt; has been called with &lt;code&gt;WxH&lt;/code&gt;, it adds padding so that the input aspect ratio is kept;&lt;/li&gt; &#xA; &lt;li&gt;when &lt;code&gt;size()&lt;/code&gt; has been called with either &lt;code&gt;Wx?&lt;/code&gt; or &lt;code&gt;?xH&lt;/code&gt;, padding is only added if &lt;code&gt;aspect()&lt;/code&gt; was called (otherwise the output dimensions are computed from the input aspect ratio and padding is not needed).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// No size specified, autopad() is ignored&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).autopad();&#xA;&#xA;// Adds padding to keep original aspect ratio.&#xA;// - with a 640x400 input, 40 pixels of padding are added on both sides&#xA;// - with a 600x480 input, 20 pixels of padding are added on top and bottom&#xA;// - with a 320x200 input, video is scaled up to 640x400 and 40px of padding&#xA;//   is added on both sides&#xA;// - with a 320x240 input, video is scaled up to 640x480 and and no padding&#xA;//   is needed&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x480&#39;).autopad();&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x480&#39;).autopad(&#39;white&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x480&#39;).autopad(&#39;#35A5FF&#39;);&#xA;&#xA;// Size computed from input, autopad() is ignored&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;50%&#39;).autopad();&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;).autopad();&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;?x480&#39;).autopad();&#xA;&#xA;// Calling .size(&#39;640x?&#39;).aspect(&#39;4:3&#39;) is similar to calling .size(&#39;640x480&#39;)&#xA;// - with a 640x400 input, 40 pixels of padding are added on both sides&#xA;// - with a 600x480 input, 20 pixels of padding are added on top and bottom&#xA;// - with a 320x200 input, video is scaled up to 640x400 and 40px of padding&#xA;//   is added on both sides&#xA;// - with a 320x240 input, video is scaled up to 640x480 and and no padding&#xA;//   is needed&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;).aspect(&#39;4:3&#39;).autopad();&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;).aspect(&#39;4:3&#39;).autopad(&#39;white&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x?&#39;).aspect(&#39;4:3&#39;).autopad(&#39;#35A5FF&#39;);&#xA;&#xA;// Calling .size(&#39;?x480&#39;).aspect(&#39;4:3&#39;) is similar to calling .size(&#39;640x480&#39;)&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;?x480&#39;).aspect(&#39;4:3&#39;).autopad();&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;?x480&#39;).aspect(&#39;4:3&#39;).autopad(&#39;white&#39;);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;?x480&#39;).aspect(&#39;4:3&#39;).autopad(&#39;#35A5FF&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For compatibility with previous fluent-ffmpeg versions, this method also accepts an additional boolean first argument, which specifies whether to apply auto-padding.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x480&#39;).autopad(true);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).size(&#39;640x480&#39;).autopad(true, &#39;pink&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;keepDAR(): force keeping display aspect ratio&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;keepPixelAspect()&lt;/code&gt;, &lt;code&gt;keepDisplayAspect()&lt;/code&gt;, &lt;code&gt;keepDisplayAspectRatio()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method is useful when converting an input with non-square pixels to an output format that does not support non-square pixels (eg. most image formats). It rescales the input so that the display aspect ratio is the same.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).keepDAR();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying multiple outputs&lt;/h3&gt; &#xA;&lt;h4&gt;output(target[, options]): add an output to the command&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;addOutput()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Adds an output to the command. The &lt;code&gt;target&lt;/code&gt; argument may be an output filename or a writable stream (but at most one output stream may be used with a single command).&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;target&lt;/code&gt; is a stream, an additional &lt;code&gt;options&lt;/code&gt; object may be passed. If it is present, it will be passed ffmpeg output stream &lt;code&gt;pipe()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;Adding an output switches the &#34;current output&#34; of the command, so that any fluent-ffmpeg method that applies to an output is indeed applied to the last output added. For backwards compatibility reasons, you may as well call those methods &lt;em&gt;before&lt;/em&gt; adding the first output (in which case they will apply to the first output when it is added). Methods that apply to an output are all non-input-related methods, except for &lt;code&gt;complexFilter()&lt;/code&gt;, which is global.&lt;/p&gt; &#xA;&lt;p&gt;Also note that when calling &lt;code&gt;output()&lt;/code&gt;, you should not use the &lt;code&gt;save()&lt;/code&gt; or &lt;code&gt;stream()&lt;/code&gt; (formerly &lt;code&gt;saveToFile()&lt;/code&gt; and &lt;code&gt;writeToStream()&lt;/code&gt;) methods, as they already add an output. Use the &lt;code&gt;run()&lt;/code&gt; method to start processing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var stream  = fs.createWriteStream(&#39;outputfile.divx&#39;);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .output(&#39;outputfile.mp4&#39;)&#xA;  .output(stream);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  // You may pass a pipe() options object when using a stream&#xA;  .output(stream, { end:true });&#xA;&#xA;// Output-related methods apply to the last output added&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;&#xA;  .output(&#39;outputfile.mp4&#39;)&#xA;  .audioCodec(&#39;libfaac&#39;)&#xA;  .videoCodec(&#39;libx264&#39;)&#xA;  .size(&#39;320x200&#39;)&#xA;&#xA;  .output(stream)&#xA;  .preset(&#39;divx&#39;)&#xA;  .size(&#39;640x480&#39;);&#xA;&#xA;// Use the run() method to run commands with multiple outputs&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .output(&#39;outputfile.mp4&#39;)&#xA;  .output(stream)&#xA;  .on(&#39;end&#39;, function() {&#xA;    console.log(&#39;Finished processing&#39;);&#xA;  })&#xA;  .run();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Output options&lt;/h3&gt; &#xA;&lt;h4&gt;duration(time): set output duration&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withDuration()&lt;/code&gt;, &lt;code&gt;setDuration()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Forces ffmpeg to stop transcoding after a specific output duration. The &lt;code&gt;time&lt;/code&gt; parameter may be a number (in seconds) or a timestamp string (with format &lt;code&gt;[[hh:]mm:]ss[.xxx]&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).duration(134.5);&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).duration(&#39;2:14.500&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;seek(time): seek output&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;seekOutput()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Seeks streams before encoding them into the output. This is different from calling &lt;code&gt;seekInput()&lt;/code&gt; in that the offset will only apply to one output. This is also slower, as skipped frames will still be decoded (but dropped).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;time&lt;/code&gt; argument may be a number (in seconds) or a timestamp string (with format &lt;code&gt;[[hh:]mm:]ss[.xxx]&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .seekInput(&#39;1:00&#39;)&#xA;&#xA;  .output(&#39;from-1m30s.avi&#39;)&#xA;  .seek(30)&#xA;&#xA;  .output(&#39;from-1m40s.avi&#39;)&#xA;  .seek(&#39;0:40&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;format(format): set output format&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;withOutputFormat()&lt;/code&gt;, &lt;code&gt;toFormat()&lt;/code&gt;, &lt;code&gt;outputFormat()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).format(&#39;flv&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;flvmeta(): update FLV metadata after transcoding&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;updateFlvMetadata()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Calling this method makes fluent-ffmpeg run &lt;code&gt;flvmeta&lt;/code&gt; or &lt;code&gt;flvtool2&lt;/code&gt; on the output file to add FLV metadata and make files streamable. It does not work when outputting to a stream, and is only useful when outputting to FLV format.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).flvmeta().format(&#39;flv&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;outputOptions(option...): add custom output options&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;outputOption()&lt;/code&gt;, &lt;code&gt;addOutputOption()&lt;/code&gt;, &lt;code&gt;addOutputOptions()&lt;/code&gt;, &lt;code&gt;withOutputOption()&lt;/code&gt;, &lt;code&gt;withOutputOptions()&lt;/code&gt;, &lt;code&gt;addOption()&lt;/code&gt;, &lt;code&gt;addOptions()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method allows passing any output-related option to ffmpeg. You can call it with a single argument to pass a single option, optionally with a space-separated parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/* Single option */&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).outputOptions(&#39;-someOption&#39;);&#xA;&#xA;/* Single option with parameter */&#xA;ffmpeg(&#39;/dev/video0&#39;).outputOptions(&#39;-r 24&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also pass multiple options at once by passing an array to the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).outputOptions([&#xA;  &#39;-option1&#39;,&#xA;  &#39;-option2 param2&#39;,&#xA;  &#39;-option3&#39;,&#xA;  &#39;-option4 param4&#39;&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, you may also directly pass command line tokens as separate arguments to the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;).outputOptions(&#xA;  &#39;-option1&#39;,&#xA;  &#39;-option2&#39;, &#39;param2&#39;,&#xA;  &#39;-option3&#39;,&#xA;  &#39;-option4&#39;, &#39;param4&#39;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Miscellaneous options&lt;/h3&gt; &#xA;&lt;h4&gt;preset(preset): use fluent-ffmpeg preset&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;usingPreset()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are two kinds of presets supported by fluent-ffmpeg. The first one is preset modules; to use those, pass the preset name as the &lt;code&gt;preset&lt;/code&gt; argument. Preset modules are loaded from the directory specified by the &lt;code&gt;presets&lt;/code&gt; constructor option (defaults to the &lt;code&gt;lib/presets&lt;/code&gt; fluent-ffmpeg subdirectory).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Uses &amp;lt;path-to-fluent-ffmpeg&amp;gt;/lib/presets/divx.js&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).preset(&#39;divx&#39;);&#xA;&#xA;// Uses /my/presets/foo.js&#xA;ffmpeg(&#39;/path/to/file.avi&#39;, { presets: &#39;/my/presets&#39; }).preset(&#39;foo&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Preset modules must export a &lt;code&gt;load()&lt;/code&gt; function that takes an FfmpegCommand as an argument. fluent-ffmpeg comes with the following preset modules preinstalled:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;divx&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;flashvideo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;podcast&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is the code from the included &lt;code&gt;divx&lt;/code&gt; preset as an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;exports.load = function(ffmpeg) {&#xA;  ffmpeg&#xA;    .format(&#39;avi&#39;)&#xA;    .videoBitrate(&#39;1024k&#39;)&#xA;    .videoCodec(&#39;mpeg4&#39;)&#xA;    .size(&#39;720x?&#39;)&#xA;    .audioBitrate(&#39;128k&#39;)&#xA;    .audioChannels(2)&#xA;    .audioCodec(&#39;libmp3lame&#39;)&#xA;    .outputOptions([&#39;-vtag DIVX&#39;]);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second kind of preset is preset functions. To use those, pass a function which takes an FfmpegCommand as a parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function myPreset(command) {&#xA;  command.format(&#39;avi&#39;).size(&#39;720x?&#39;);&#xA;}&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;).preset(myPreset);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;complexFilter(filters[, map]): set complex filtergraph&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;filterGraph()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;complexFilter()&lt;/code&gt; method enables setting a complex filtergraph for a command. It expects a filter specification (or a filter specification array) and an optional output mapping parameter as arguments.&lt;/p&gt; &#xA;&lt;p&gt;Filter specifications may be either plain ffmpeg filter strings (eg. &lt;code&gt;split=3[a][b][c]&lt;/code&gt;) or objects with the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;filter&lt;/code&gt;: filter name&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt;: optional; either an option string for the filter (eg. &lt;code&gt;in:0:30&lt;/code&gt;), an options array for unnamed options (eg. &lt;code&gt;[&#39;in&#39;, 0, 30]&lt;/code&gt;) or an object mapping option names to values (eg. &lt;code&gt;{ t: &#39;in&#39;, s: 0, n: 30 }&lt;/code&gt;). When &lt;code&gt;options&lt;/code&gt; is not specified, the filter will be added without any options.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;inputs&lt;/code&gt;: optional; input stream specifier(s) for the filter. The value may be either a single stream specifier string or an array of stream specifiers. Each specifier can be optionally enclosed in square brackets. When input streams are not specified, ffmpeg will use the first unused streams of the correct type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;outputs&lt;/code&gt;: optional; output stream specifier(s) for the filter. The value may be either a single stream specifier string or an array of stream specifiers. Each specifier can be optionally enclosed in square brackets.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The output mapping parameter specifies which stream(s) to include in the output from the filtergraph. It may be either a single stream specifier string or an array of stream specifiers. Each specifier can be optionally enclosed in square brackets. When this parameter is not present, ffmpeg will default to saving all unused outputs to the output file.&lt;/p&gt; &#xA;&lt;p&gt;Note that only one complex filtergraph may be set on a given command. Calling &lt;code&gt;complexFilter()&lt;/code&gt; again will override any previously set filtergraph, but you can set as many filters as needed in a single call.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .complexFilter([&#xA;    // Rescale input stream into stream &#39;rescaled&#39;&#xA;    &#39;scale=640:480[rescaled]&#39;,&#xA;&#xA;    // Duplicate rescaled stream 3 times into streams a, b, and c&#xA;    {&#xA;      filter: &#39;split&#39;, options: &#39;3&#39;,&#xA;      inputs: &#39;rescaled&#39;, outputs: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#xA;    },&#xA;&#xA;    // Create stream &#39;red&#39; by removing green and blue channels from stream &#39;a&#39;&#xA;    {&#xA;      filter: &#39;lutrgb&#39;, options: { g: 0, b: 0 },&#xA;      inputs: &#39;a&#39;, outputs: &#39;red&#39;&#xA;    },&#xA;&#xA;    // Create stream &#39;green&#39; by removing red and blue channels from stream &#39;b&#39;&#xA;    {&#xA;      filter: &#39;lutrgb&#39;, options: { r: 0, b: 0 },&#xA;      inputs: &#39;b&#39;, outputs: &#39;green&#39;&#xA;    },&#xA;&#xA;    // Create stream &#39;blue&#39; by removing red and green channels from stream &#39;c&#39;&#xA;    {&#xA;      filter: &#39;lutrgb&#39;, options: { r: 0, g: 0 },&#xA;      inputs: &#39;c&#39;, outputs: &#39;blue&#39;&#xA;    },&#xA;&#xA;    // Pad stream &#39;red&#39; to 3x width, keeping the video on the left,&#xA;    // and name output &#39;padded&#39;&#xA;    {&#xA;      filter: &#39;pad&#39;, options: { w: &#39;iw*3&#39;, h: &#39;ih&#39; },&#xA;      inputs: &#39;red&#39;, outputs: &#39;padded&#39;&#xA;    },&#xA;&#xA;    // Overlay &#39;green&#39; onto &#39;padded&#39;, moving it to the center,&#xA;    // and name output &#39;redgreen&#39;&#xA;    {&#xA;      filter: &#39;overlay&#39;, options: { x: &#39;w&#39;, y: 0 },&#xA;      inputs: [&#39;padded&#39;, &#39;green&#39;], outputs: &#39;redgreen&#39;&#xA;    },&#xA;&#xA;    // Overlay &#39;blue&#39; onto &#39;redgreen&#39;, moving it to the right&#xA;    {&#xA;      filter: &#39;overlay&#39;, options: { x: &#39;2*w&#39;, y: 0 },&#xA;      inputs: [&#39;redgreen&#39;, &#39;blue&#39;], outputs: &#39;output&#39;&#xA;    },&#xA;  ], &#39;output&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting event handlers&lt;/h3&gt; &#xA;&lt;p&gt;Before actually running a command, you may want to set event listeners on it to be notified when it&#39;s done. The following events are available:&lt;/p&gt; &#xA;&lt;h4&gt;&#39;start&#39;: ffmpeg process started&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;start&lt;/code&gt; event is emitted just after ffmpeg has been spawned. It is emitted with the full command line used as an argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .on(&#39;start&#39;, function(commandLine) {&#xA;    console.log(&#39;Spawned Ffmpeg with command: &#39; + commandLine);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&#39;codecData&#39;: input codec data available&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;codecData&lt;/code&gt; event is emitted when ffmpeg outputs codec information about its input streams. It is emitted with an object argument with the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;format&lt;/code&gt;: input format&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;duration&lt;/code&gt;: input duration&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;audio&lt;/code&gt;: audio codec&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;audio_details&lt;/code&gt;: audio encoding details&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;video&lt;/code&gt;: video codec&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;video_details&lt;/code&gt;: video encoding details&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .on(&#39;codecData&#39;, function(data) {&#xA;    console.log(&#39;Input is &#39; + data.audio + &#39; audio &#39; +&#xA;      &#39;with &#39; + data.video + &#39; video&#39;);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&#39;progress&#39;: transcoding progress information&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;progress&lt;/code&gt; event is emitted every time ffmpeg reports progress information. It is emitted with an object argument with the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;frames&lt;/code&gt;: total processed frame count&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;currentFps&lt;/code&gt;: framerate at which FFmpeg is currently processing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;currentKbps&lt;/code&gt;: throughput at which FFmpeg is currently processing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;targetSize&lt;/code&gt;: current size of the target file in kilobytes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timemark&lt;/code&gt;: the timestamp of the current frame in seconds&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;percent&lt;/code&gt;: an estimation of the progress percentage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;percent&lt;/code&gt; can be (very) inaccurate, as the only progress information fluent-ffmpeg gets from ffmpeg is the total number of frames written (and the corresponding duration). To estimate percentage, fluent-ffmpeg has to guess what the total output duration will be, and uses the first input added to the command to do so. In particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;percentage is not available when using an input stream&lt;/li&gt; &#xA; &lt;li&gt;percentage may be wrong when using multiple inputs with different durations and the first one is not the longest&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .on(&#39;progress&#39;, function(progress) {&#xA;    console.log(&#39;Processing: &#39; + progress.percent + &#39;% done&#39;);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&#39;stderr&#39;: FFmpeg output&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;stderr&lt;/code&gt; event is emitted every time FFmpeg outputs a line to &lt;code&gt;stderr&lt;/code&gt;. It is emitted with a string containing the line of stderr (minus trailing new line characters).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .on(&#39;stderr&#39;, function(stderrLine) {&#xA;    console.log(&#39;Stderr output: &#39; + stderrLine);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&#39;error&#39;: transcoding error&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;error&lt;/code&gt; event is emitted when an error occurs when running ffmpeg or when preparing its execution. It is emitted with an error object as an argument. If the error happened during ffmpeg execution, listeners will also receive two additional arguments containing ffmpegs stdout and stderr.&lt;/p&gt; &#xA;&lt;p&gt;If streams are used for input or output, any errors emitted from these streams will be passed through to this event, attached to the &lt;code&gt;error&lt;/code&gt; as &lt;code&gt;inputStreamError&lt;/code&gt; and &lt;code&gt;outputStreamError&lt;/code&gt; for input and output streams respectively.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: you should &lt;em&gt;always&lt;/em&gt; set a handler for the &lt;code&gt;error&lt;/code&gt; event, as node&#39;s default behaviour when an &lt;code&gt;error&lt;/code&gt; event without any listeners is emitted is to output the error to the console and &lt;em&gt;terminate the program&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .on(&#39;error&#39;, function(err, stdout, stderr) {&#xA;    console.log(&#39;Cannot process video: &#39; + err.message);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&#39;end&#39;: processing finished&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;end&lt;/code&gt; event is emitted when processing has finished. Listeners receive ffmpeg standard output and standard error as arguments, except when generating thumbnails (see below), in which case they receive an array of the generated filenames.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .on(&#39;end&#39;, function(stdout, stderr) {&#xA;    console.log(&#39;Transcoding succeeded !&#39;);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;stdout&lt;/code&gt; is empty when the command outputs to a stream. Both &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; are limited by the &lt;code&gt;stdoutLines&lt;/code&gt; option (defaults to 100 lines).&lt;/p&gt; &#xA;&lt;h3&gt;Starting FFmpeg processing&lt;/h3&gt; &#xA;&lt;h4&gt;save(filename): save the output to a file&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;saveToFile()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Starts ffmpeg processing and saves the output to a file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .videoCodec(&#39;libx264&#39;)&#xA;  .audioCodec(&#39;libmp3lame&#39;)&#xA;  .size(&#39;320x240&#39;)&#xA;  .on(&#39;error&#39;, function(err) {&#xA;    console.log(&#39;An error occurred: &#39; + err.message);&#xA;  })&#xA;  .on(&#39;end&#39;, function() {&#xA;    console.log(&#39;Processing finished !&#39;);&#xA;  })&#xA;  .save(&#39;/path/to/output.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: the &lt;code&gt;save()&lt;/code&gt; method is actually syntactic sugar for calling both &lt;code&gt;output()&lt;/code&gt; and &lt;code&gt;run()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;pipe([stream], [options]): pipe the output to a writable stream&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;stream()&lt;/code&gt;, &lt;code&gt;writeToStream()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Starts processing and pipes ffmpeg output to a writable stream. The &lt;code&gt;options&lt;/code&gt; argument, if present, is passed to ffmpeg output stream&#39;s &lt;code&gt;pipe()&lt;/code&gt; method (see nodejs documentation).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var outStream = fs.createWriteStream(&#39;/path/to/output.mp4&#39;);&#xA;&#xA;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .videoCodec(&#39;libx264&#39;)&#xA;  .audioCodec(&#39;libmp3lame&#39;)&#xA;  .size(&#39;320x240&#39;)&#xA;  .on(&#39;error&#39;, function(err) {&#xA;    console.log(&#39;An error occurred: &#39; + err.message);&#xA;  })&#xA;  .on(&#39;end&#39;, function() {&#xA;    console.log(&#39;Processing finished !&#39;);&#xA;  })&#xA;  .pipe(outStream, { end: true });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When no &lt;code&gt;stream&lt;/code&gt; argument is present, the &lt;code&gt;pipe()&lt;/code&gt; method returns a PassThrough stream, which you can pipe to somewhere else (or just listen to events on).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: this is only available with node &amp;gt;= 0.10.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var command = ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .videoCodec(&#39;libx264&#39;)&#xA;  .audioCodec(&#39;libmp3lame&#39;)&#xA;  .size(&#39;320x240&#39;)&#xA;  .on(&#39;error&#39;, function(err) {&#xA;    console.log(&#39;An error occurred: &#39; + err.message);&#xA;  })&#xA;  .on(&#39;end&#39;, function() {&#xA;    console.log(&#39;Processing finished !&#39;);&#xA;  });&#xA;&#xA;var ffstream = command.pipe();&#xA;ffstream.on(&#39;data&#39;, function(chunk) {&#xA;  console.log(&#39;ffmpeg just wrote &#39; + chunk.length + &#39; bytes&#39;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: the &lt;code&gt;stream()&lt;/code&gt; method is actually syntactic sugar for calling both &lt;code&gt;output()&lt;/code&gt; and &lt;code&gt;run()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;run(): start processing&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;exec()&lt;/code&gt;, &lt;code&gt;execute()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method is mainly useful when producing multiple outputs (otherwise the &lt;code&gt;save()&lt;/code&gt; or &lt;code&gt;stream()&lt;/code&gt; methods are more straightforward). It starts processing with the specified outputs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: do not use &lt;code&gt;run()&lt;/code&gt; when calling other processing methods (eg. &lt;code&gt;save()&lt;/code&gt;, &lt;code&gt;pipe()&lt;/code&gt; or &lt;code&gt;screenshots()&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .output(&#39;screenshot.png&#39;)&#xA;  .noAudio()&#xA;  .seek(&#39;3:00&#39;)&#xA;&#xA;  .output(&#39;small.avi&#39;)&#xA;  .audioCodec(&#39;copy&#39;)&#xA;  .size(&#39;320x200&#39;)&#xA;&#xA;  .output(&#39;big.avi&#39;)&#xA;  .audioCodec(&#39;copy&#39;)&#xA;  .size(&#39;640x480&#39;)&#xA;&#xA;  .on(&#39;error&#39;, function(err) {&#xA;    console.log(&#39;An error occurred: &#39; + err.message);&#xA;  })&#xA;  .on(&#39;end&#39;, function() {&#xA;    console.log(&#39;Processing finished !&#39;);&#xA;  })&#xA;  .run();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;mergeToFile(filename, tmpdir): concatenate multiple inputs&lt;/h4&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;mergeToFile&lt;/code&gt; methods on a command to concatenate multiple inputs to a single output file. The &lt;code&gt;mergeToFile&lt;/code&gt; needs a temporary folder as its second argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/part1.avi&#39;)&#xA;  .input(&#39;/path/to/part2.avi&#39;)&#xA;  .input(&#39;/path/to/part2.avi&#39;)&#xA;  .on(&#39;error&#39;, function(err) {&#xA;    console.log(&#39;An error occurred: &#39; + err.message);&#xA;  })&#xA;  .on(&#39;end&#39;, function() {&#xA;    console.log(&#39;Merging finished !&#39;);&#xA;  })&#xA;  .mergeToFile(&#39;/path/to/merged.avi&#39;, &#39;/path/to/tempDir&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;screenshots(options[, dirname]): generate thumbnails&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;code&gt;thumbnail()&lt;/code&gt;, &lt;code&gt;thumbnails()&lt;/code&gt;, &lt;code&gt;screenshot()&lt;/code&gt;, &lt;code&gt;takeScreenshots()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;screenshots&lt;/code&gt; method to extract one or several thumbnails and save them as PNG files. There are a few caveats with this implementation, though:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It will not work on input streams.&lt;/li&gt; &#xA; &lt;li&gt;Progress information reported by the &lt;code&gt;progress&lt;/code&gt; event is not accurate.&lt;/li&gt; &#xA; &lt;li&gt;It doesn&#39;t interract well with filters. In particular, don&#39;t use the &lt;code&gt;size()&lt;/code&gt; method to resize thumbnails, use the &lt;code&gt;size&lt;/code&gt; option instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;options&lt;/code&gt; argument is an object with the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;folder&lt;/code&gt;: output folder for generated image files. Defaults to the current folder.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;filename&lt;/code&gt;: output filename pattern (see below). Defaults to &#34;tn.png&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;count&lt;/code&gt;: specifies how many thumbnails to generate. When using this option, thumbnails are generated at regular intervals in the video (for example, when requesting 3 thumbnails, at 25%, 50% and 75% of the video length). &lt;code&gt;count&lt;/code&gt; is ignored when &lt;code&gt;timemarks&lt;/code&gt; or &lt;code&gt;timestamps&lt;/code&gt; is specified.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timemarks&lt;/code&gt; or &lt;code&gt;timestamps&lt;/code&gt;: specifies an array of timestamps in the video where thumbnails should be taken. Each timestamp may be a number (in seconds), a percentage string (eg. &#34;50%&#34;) or a timestamp string with format &#34;hh:mm:ss.xxx&#34; (where hours, minutes and milliseconds are both optional).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: specifies a target size for thumbnails (with the same format as the &lt;code&gt;.size()&lt;/code&gt; method). &lt;strong&gt;Note:&lt;/strong&gt; you should not use the &lt;code&gt;.size()&lt;/code&gt; method when generating thumbnails.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;filename&lt;/code&gt; option specifies a filename pattern for generated files. It may contain the following format tokens:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#39;%s&#39;: offset in seconds&lt;/li&gt; &#xA; &lt;li&gt;&#39;%w&#39;: screenshot width&lt;/li&gt; &#xA; &lt;li&gt;&#39;%h&#39;: screenshot height&lt;/li&gt; &#xA; &lt;li&gt;&#39;%r&#39;: screenshot resolution (same as &#39;%wx%h&#39;)&lt;/li&gt; &#xA; &lt;li&gt;&#39;%f&#39;: input filename&lt;/li&gt; &#xA; &lt;li&gt;&#39;%b&#39;: input basename (filename w/o extension)&lt;/li&gt; &#xA; &lt;li&gt;&#39;%i&#39;: index of screenshot in timemark array (can be zero-padded by using it like &lt;code&gt;%000i&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If multiple timemarks are passed and no variable format token (&#39;%s&#39; or &#39;%i&#39;) is specified in the filename pattern, &lt;code&gt;_%i&lt;/code&gt; will be added automatically.&lt;/p&gt; &#xA;&lt;p&gt;When generating thumbnails, an additional &lt;code&gt;filenames&lt;/code&gt; event is dispatched with an array of generated filenames as an argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/video.avi&#39;)&#xA;  .on(&#39;filenames&#39;, function(filenames) {&#xA;    console.log(&#39;Will generate &#39; + filenames.join(&#39;, &#39;))&#xA;  })&#xA;  .on(&#39;end&#39;, function() {&#xA;    console.log(&#39;Screenshots taken&#39;);&#xA;  })&#xA;  .screenshots({&#xA;    // Will take screens at 20%, 40%, 60% and 80% of the video&#xA;    count: 4,&#xA;    folder: &#39;/path/to/output&#39;&#xA;  });&#xA;&#xA;ffmpeg(&#39;/path/to/video.avi&#39;)&#xA;  .screenshots({&#xA;    timestamps: [30.5, &#39;50%&#39;, &#39;01:10.123&#39;],&#xA;    filename: &#39;thumbnail-at-%s-seconds.png&#39;,&#xA;    folder: &#39;/path/to/output&#39;,&#xA;    size: &#39;320x240&#39;&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Controlling the FFmpeg process&lt;/h3&gt; &#xA;&lt;h4&gt;kill([signal=&#39;SIGKILL&#39;]): kill any running ffmpeg process&lt;/h4&gt; &#xA;&lt;p&gt;This method sends &lt;code&gt;signal&lt;/code&gt; (defaults to &#39;SIGKILL&#39;) to the ffmpeg process. It only has sense when processing has started. Sending a signal that terminates the process will result in the &lt;code&gt;error&lt;/code&gt; event being emitted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var command = ffmpeg(&#39;/path/to/video.avi&#39;)&#xA;  .videoCodec(&#39;libx264&#39;)&#xA;  .audioCodec(&#39;libmp3lame&#39;)&#xA;  .on(&#39;start&#39;, function() {&#xA;    // Send SIGSTOP to suspend ffmpeg&#xA;    command.kill(&#39;SIGSTOP&#39;);&#xA;&#xA;    doSomething(function() {&#xA;      // Send SIGCONT to resume ffmpeg&#xA;      command.kill(&#39;SIGCONT&#39;);&#xA;    });&#xA;  })&#xA;  .save(&#39;/path/to/output.mp4&#39;);&#xA;&#xA;// Kill ffmpeg after 60 seconds anyway&#xA;setTimeout(function() {&#xA;  command.on(&#39;error&#39;, function() {&#xA;    console.log(&#39;Ffmpeg has been killed&#39;);&#xA;  });&#xA;&#xA;  command.kill();&#xA;}, 60000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;renice([niceness=0]): change ffmpeg process priority&lt;/h4&gt; &#xA;&lt;p&gt;This method alters the niceness (priority) value of any running ffmpeg process (if any) and any process spawned in the future. The &lt;code&gt;niceness&lt;/code&gt; parameter may range from -20 (highest priority) to 20 (lowest priority) and defaults to 0 (which is the default process niceness on most *nix systems).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: this method is ineffective on Windows platforms.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Set startup niceness&#xA;var command = ffmpeg(&#39;/path/to/file.avi&#39;)&#xA;  .renice(5)&#xA;  .save(&#39;/path/to/output.mp4&#39;);&#xA;&#xA;// Command takes too long, raise its priority&#xA;setTimeout(function() {&#xA;  command.renice(-5);&#xA;}, 60000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reading video metadata&lt;/h3&gt; &#xA;&lt;p&gt;You can read metadata from any valid ffmpeg input file with the modules &lt;code&gt;ffprobe&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg.ffprobe(&#39;/path/to/file.avi&#39;, function(err, metadata) {&#xA;    console.dir(metadata);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also call the ffprobe method on an FfmpegCommand to probe one of its input. You may pass a 0-based input number as a first argument to specify which input to read metadata from, otherwise the method will probe the last added input.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;ffmpeg(&#39;/path/to/file1.avi&#39;)&#xA;  .input(&#39;/path/to/file2.avi&#39;)&#xA;  .ffprobe(function(err, data) {&#xA;    console.log(&#39;file2 metadata:&#39;);&#xA;    console.dir(data);&#xA;  });&#xA;&#xA;ffmpeg(&#39;/path/to/file1.avi&#39;)&#xA;  .input(&#39;/path/to/file2.avi&#39;)&#xA;  .ffprobe(0, function(err, data) {&#xA;    console.log(&#39;file1 metadata:&#39;);&#xA;    console.dir(data);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; ffprobe may be called with an input stream, but in this case &lt;em&gt;it will consume data from the stream&lt;/em&gt;, and this data will no longer be available for ffmpeg. Using both ffprobe and a transcoding command on the same input stream will most likely fail unless the stream is a live stream. Only do this if you know what you&#39;re doing.&lt;/p&gt; &#xA;&lt;p&gt;The returned object is the same that is returned by running the following command from your shell (depending on your ffmpeg version you may have to replace &lt;code&gt;-of&lt;/code&gt; with &lt;code&gt;-print_format&lt;/code&gt;) :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ffprobe -of json -show_streams -show_format /path/to/file.avi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will contain information about the container (as a &lt;code&gt;format&lt;/code&gt; key) and an array of streams (as a &lt;code&gt;stream&lt;/code&gt; key). The format object and each stream object also contains metadata tags, depending on the format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  &#34;streams&#34;: [&#xA;    {&#xA;      &#34;index&#34;: 0,&#xA;      &#34;codec_name&#34;: &#34;h264&#34;,&#xA;      &#34;codec_long_name&#34;: &#34;H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&#34;,&#xA;      &#34;profile&#34;: &#34;Constrained Baseline&#34;,&#xA;      &#34;codec_type&#34;: &#34;video&#34;,&#xA;      &#34;codec_time_base&#34;: &#34;1/48&#34;,&#xA;      &#34;codec_tag_string&#34;: &#34;avc1&#34;,&#xA;      &#34;codec_tag&#34;: &#34;0x31637661&#34;,&#xA;      &#34;width&#34;: 320,&#xA;      &#34;height&#34;: 180,&#xA;      &#34;has_b_frames&#34;: 0,&#xA;      &#34;sample_aspect_ratio&#34;: &#34;1:1&#34;,&#xA;      &#34;display_aspect_ratio&#34;: &#34;16:9&#34;,&#xA;      &#34;pix_fmt&#34;: &#34;yuv420p&#34;,&#xA;      &#34;level&#34;: 13,&#xA;      &#34;r_frame_rate&#34;: &#34;24/1&#34;,&#xA;      &#34;avg_frame_rate&#34;: &#34;24/1&#34;,&#xA;      &#34;time_base&#34;: &#34;1/24&#34;,&#xA;      &#34;start_pts&#34;: 0,&#xA;      &#34;start_time&#34;: &#34;0.000000&#34;,&#xA;      &#34;duration_ts&#34;: 14315,&#xA;      &#34;duration&#34;: &#34;596.458333&#34;,&#xA;      &#34;bit_rate&#34;: &#34;702655&#34;,&#xA;      &#34;nb_frames&#34;: &#34;14315&#34;,&#xA;      &#34;disposition&#34;: {&#xA;        &#34;default&#34;: 0,&#xA;        &#34;dub&#34;: 0,&#xA;        &#34;original&#34;: 0,&#xA;        &#34;comment&#34;: 0,&#xA;        &#34;lyrics&#34;: 0,&#xA;        &#34;karaoke&#34;: 0,&#xA;        &#34;forced&#34;: 0,&#xA;        &#34;hearing_impaired&#34;: 0,&#xA;        &#34;visual_impaired&#34;: 0,&#xA;        &#34;clean_effects&#34;: 0,&#xA;        &#34;attached_pic&#34;: 0&#xA;      },&#xA;      &#34;tags&#34;: {&#xA;        &#34;creation_time&#34;: &#34;1970-01-01 00:00:00&#34;,&#xA;        &#34;language&#34;: &#34;und&#34;,&#xA;        &#34;handler_name&#34;: &#34;\fVideoHandler&#34;&#xA;      }&#xA;    },&#xA;    {&#xA;      &#34;index&#34;: 1,&#xA;      &#34;codec_name&#34;: &#34;aac&#34;,&#xA;      &#34;codec_long_name&#34;: &#34;AAC (Advanced Audio Coding)&#34;,&#xA;      &#34;codec_type&#34;: &#34;audio&#34;,&#xA;      &#34;codec_time_base&#34;: &#34;1/48000&#34;,&#xA;      &#34;codec_tag_string&#34;: &#34;mp4a&#34;,&#xA;      &#34;codec_tag&#34;: &#34;0x6134706d&#34;,&#xA;      &#34;sample_fmt&#34;: &#34;fltp&#34;,&#xA;      &#34;sample_rate&#34;: &#34;48000&#34;,&#xA;      &#34;channels&#34;: 2,&#xA;      &#34;bits_per_sample&#34;: 0,&#xA;      &#34;r_frame_rate&#34;: &#34;0/0&#34;,&#xA;      &#34;avg_frame_rate&#34;: &#34;0/0&#34;,&#xA;      &#34;time_base&#34;: &#34;1/48000&#34;,&#xA;      &#34;start_pts&#34;: 0,&#xA;      &#34;start_time&#34;: &#34;0.000000&#34;,&#xA;      &#34;duration_ts&#34;: 28619776,&#xA;      &#34;duration&#34;: &#34;596.245333&#34;,&#xA;      &#34;bit_rate&#34;: &#34;159997&#34;,&#xA;      &#34;nb_frames&#34;: &#34;27949&#34;,&#xA;      &#34;disposition&#34;: {&#xA;        &#34;default&#34;: 0,&#xA;        &#34;dub&#34;: 0,&#xA;        &#34;original&#34;: 0,&#xA;        &#34;comment&#34;: 0,&#xA;        &#34;lyrics&#34;: 0,&#xA;        &#34;karaoke&#34;: 0,&#xA;        &#34;forced&#34;: 0,&#xA;        &#34;hearing_impaired&#34;: 0,&#xA;        &#34;visual_impaired&#34;: 0,&#xA;        &#34;clean_effects&#34;: 0,&#xA;        &#34;attached_pic&#34;: 0&#xA;      },&#xA;      &#34;tags&#34;: {&#xA;        &#34;creation_time&#34;: &#34;1970-01-01 00:00:00&#34;,&#xA;        &#34;language&#34;: &#34;und&#34;,&#xA;        &#34;handler_name&#34;: &#34;\fSoundHandler&#34;&#xA;      }&#xA;    }&#xA;  ],&#xA;  &#34;format&#34;: {&#xA;    &#34;filename&#34;: &#34;http://download.blender.org/peach/bigbuckbunny_movies/BigBuckBunny_320x180.mp4&#34;,&#xA;    &#34;nb_streams&#34;: 2,&#xA;    &#34;format_name&#34;: &#34;mov,mp4,m4a,3gp,3g2,mj2&#34;,&#xA;    &#34;format_long_name&#34;: &#34;QuickTime / MOV&#34;,&#xA;    &#34;start_time&#34;: &#34;0.000000&#34;,&#xA;    &#34;duration&#34;: &#34;596.459000&#34;,&#xA;    &#34;size&#34;: &#34;64657027&#34;,&#xA;    &#34;bit_rate&#34;: &#34;867211&#34;,&#xA;    &#34;tags&#34;: {&#xA;      &#34;major_brand&#34;: &#34;isom&#34;,&#xA;      &#34;minor_version&#34;: &#34;512&#34;,&#xA;      &#34;compatible_brands&#34;: &#34;mp41&#34;,&#xA;      &#34;creation_time&#34;: &#34;1970-01-01 00:00:00&#34;,&#xA;      &#34;title&#34;: &#34;Big Buck Bunny&#34;,&#xA;      &#34;artist&#34;: &#34;Blender Foundation&#34;,&#xA;      &#34;composer&#34;: &#34;Blender Foundation&#34;,&#xA;      &#34;date&#34;: &#34;2008&#34;,&#xA;      &#34;encoder&#34;: &#34;Lavf52.14.0&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Querying ffmpeg capabilities&lt;/h3&gt; &#xA;&lt;p&gt;fluent-ffmpeg enables you to query your installed ffmpeg version for supported formats, codecs, encoders and filters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&#xA;var Ffmpeg = require(&#39;fluent-ffmpeg&#39;);&#xA;&#xA;Ffmpeg.getAvailableFormats(function(err, formats) {&#xA;  console.log(&#39;Available formats:&#39;);&#xA;  console.dir(formats);&#xA;});&#xA;&#xA;Ffmpeg.getAvailableCodecs(function(err, codecs) {&#xA;  console.log(&#39;Available codecs:&#39;);&#xA;  console.dir(codecs);&#xA;});&#xA;&#xA;Ffmpeg.getAvailableEncoders(function(err, encoders) {&#xA;  console.log(&#39;Available encoders:&#39;);&#xA;  console.dir(encoders);&#xA;});&#xA;&#xA;Ffmpeg.getAvailableFilters(function(err, filters) {&#xA;  console.log(&#34;Available filters:&#34;);&#xA;  console.dir(filters);&#xA;});&#xA;&#xA;// Those methods can also be called on commands&#xA;new Ffmpeg({ source: &#39;/path/to/file.avi&#39; })&#xA;  .getAvailableCodecs(...);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These methods pass an object to their callback with keys for each available format, codec or filter.&lt;/p&gt; &#xA;&lt;p&gt;The returned object for formats looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  ...&#xA;  mp4: {&#xA;    description: &#39;MP4 (MPEG-4 Part 14)&#39;,&#xA;    canDemux: false,&#xA;    canMux: true&#xA;  },&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;canDemux&lt;/code&gt; indicates whether ffmpeg is able to extract streams from (demux) this format&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;canMux&lt;/code&gt; indicates whether ffmpeg is able to write streams into (mux) this format&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The returned object for codecs looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  ...&#xA;  mp3: {&#xA;    type: &#39;audio&#39;,&#xA;    description: &#39;MP3 (MPEG audio layer 3)&#39;,&#xA;    canDecode: true,&#xA;    canEncode: true,&#xA;    intraFrameOnly: false,&#xA;    isLossy: true,&#xA;    isLossless: false&#xA;  },&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type&lt;/code&gt; indicates the codec type, either &#34;audio&#34;, &#34;video&#34; or &#34;subtitle&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;canDecode&lt;/code&gt; tells whether ffmpeg is able to decode streams using this codec&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;canEncode&lt;/code&gt; tells whether ffmpeg is able to encode streams using this codec&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Depending on your ffmpeg version (or if you use avconv instead) other keys may be present, for example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;directRendering&lt;/code&gt; tells if codec can render directly in GPU RAM; useless for transcoding purposes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;intraFrameOnly&lt;/code&gt; tells if codec can only work with I-frames&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;isLossy&lt;/code&gt; tells if codec can do lossy encoding/decoding&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;isLossless&lt;/code&gt; tells if codec can do lossless encoding/decoding&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With some ffmpeg/avcodec versions, the description includes encoder/decoder mentions in the form &#34;Foo codec (decoders: libdecodefoo) (encoders: libencodefoo)&#34;. In this case you will want to use those encoders/decoders instead (the codecs object returned by &lt;code&gt;getAvailableCodecs&lt;/code&gt; will also include them).&lt;/p&gt; &#xA;&lt;p&gt;The returned object for encoders looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  ...&#xA;  libmp3lame: {&#xA;    type: &#39;audio&#39;,&#xA;    description: &#39;MP3 (MPEG audio layer 3) (codec mp3)&#39;,&#xA;    frameMT: false,&#xA;    sliceMT: false,&#xA;    experimental: false,&#xA;    drawHorizBand: false,&#xA;    directRendering: false&#xA;  },&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type&lt;/code&gt; indicates the encoder type, either &#34;audio&#34;, &#34;video&#34; or &#34;subtitle&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;experimental&lt;/code&gt; indicates whether the encoder is experimental. When using such a codec, fluent-ffmpeg automatically adds the &#39;-strict experimental&#39; flag.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The returned object for filters looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  ...&#xA;  scale: {&#xA;    description: &#39;Scale the input video to width:height size and/or convert the image format.&#39;,&#xA;    input: &#39;video&#39;,&#xA;    multipleInputs: false,&#xA;    output: &#39;video&#39;,&#xA;    multipleOutputs: false&#xA;  },&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;input&lt;/code&gt; tells the input type this filter operates on, one of &#34;audio&#34;, &#34;video&#34; or &#34;none&#34;. When &#34;none&#34;, the filter likely generates output from nothing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;multipleInputs&lt;/code&gt; tells whether the filter can accept multiple inputs&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;output&lt;/code&gt; tells the output type this filter generates, one of &#34;audio&#34;, &#34;video&#34; or &#34;none&#34;. When &#34;none&#34;, the filter has no output (sink only)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;multipleInputs&lt;/code&gt; tells whether the filter can generate multiple outputs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Cloning an FfmpegCommand&lt;/h3&gt; &#xA;&lt;p&gt;You can create clones of an FfmpegCommand instance by calling the &lt;code&gt;clone()&lt;/code&gt; method. The clone will be an exact copy of the original at the time it has been called (same inputs, same options, same event handlers, etc.). This is mainly useful when you want to apply different processing options on the same input.&lt;/p&gt; &#xA;&lt;p&gt;Setting options, adding inputs or event handlers on a clone will not affect the original command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Create a command to convert source.avi to MP4&#xA;var command = ffmpeg(&#39;/path/to/source.avi&#39;)&#xA;  .audioCodec(&#39;libfaac&#39;)&#xA;  .videoCodec(&#39;libx264&#39;)&#xA;  .format(&#39;mp4&#39;);&#xA;&#xA;// Create a clone to save a small resized version&#xA;command.clone()&#xA;  .size(&#39;320x200&#39;)&#xA;  .save(&#39;/path/to/output-small.mp4&#39;);&#xA;&#xA;// Create a clone to save a medium resized version&#xA;command.clone()&#xA;  .size(&#39;640x400&#39;)&#xA;  .save(&#39;/path/to/output-medium.mp4&#39;);&#xA;&#xA;// Save a converted version with the original size&#xA;command.save(&#39;/path/to/output-original-size.mp4&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions in any form are highly encouraged and welcome! Be it new or improved presets, optimized streaming code or just some cleanup. So start forking!&lt;/p&gt; &#xA;&lt;h3&gt;Code contributions&lt;/h3&gt; &#xA;&lt;p&gt;If you want to add new features or change the API, please submit an issue first to make sure no one else is already working on the same thing and discuss the implementation and API details with maintainers and users by creating an issue. When everything is settled down, you can submit a pull request.&lt;/p&gt; &#xA;&lt;p&gt;When fixing bugs, you can directly submit a pull request.&lt;/p&gt; &#xA;&lt;p&gt;Make sure to add tests for your features and bugfixes and update the documentation (see below) before submitting your code!&lt;/p&gt; &#xA;&lt;h3&gt;Documentation contributions&lt;/h3&gt; &#xA;&lt;p&gt;You can directly submit pull requests for documentation changes. Make sure to regenerate the documentation before submitting (see below).&lt;/p&gt; &#xA;&lt;h3&gt;Updating the documentation&lt;/h3&gt; &#xA;&lt;p&gt;When contributing API changes (new methods for example), be sure to update the README file and JSDoc comments in the code. fluent-ffmpeg comes with a plugin that enables two additional JSDoc tags:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;@aliases&lt;/code&gt;: document method aliases&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**&#xA; * ...&#xA; * @method FfmpegCommand#myMethod&#xA; * @aliases myMethodAlias,myOtherMethodAlias&#xA; */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;@category&lt;/code&gt;: set method category&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**&#xA; * ...&#xA; * @category Audio&#xA; */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can regenerate the JSDoc documentation by running the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make doc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To avoid polluting the commit history, make sure to only commit the regenerated JSDoc once and in a specific commit.&lt;/p&gt; &#xA;&lt;h3&gt;Running tests&lt;/h3&gt; &#xA;&lt;p&gt;To run unit tests, first make sure you installed npm dependencies (run &lt;code&gt;npm install&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to re-generate the test coverage report (filed under test/coverage.html), run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make test-cov&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure your ffmpeg installation is up-to-date to prevent strange assertion errors because of missing codecs/bugfixes.&lt;/p&gt; &#xA;&lt;h2&gt;Main contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/enobrev&#34;&gt;enobrev&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/njoyard&#34;&gt;njoyard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/sadikzzz&#34;&gt;sadikzzz&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/smremde&#34;&gt;smremde&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/spruce&#34;&gt;spruce&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/tagedieb&#34;&gt;tagedieb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/tommadema&#34;&gt;tommadema&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/Weltschmerz&#34;&gt;Weltschmerz&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;(The MIT License)&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2011 Stefan Schaermeli &amp;lt;&lt;a href=&#34;mailto:schaermu@gmail.com&#34;&gt;schaermu@gmail.com&lt;/a&gt;&amp;gt;&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#39;Software&#39;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#39;AS IS&#39;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.fossa.io/projects/git%2Bgithub.com%2Ffluent-ffmpeg%2Fnode-fluent-ffmpeg?ref=badge_large&#34;&gt;&lt;img src=&#34;https://app.fossa.io/api/projects/git%2Bgithub.com%2Ffluent-ffmpeg%2Fnode-fluent-ffmpeg.svg?type=large&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>onlyGuo/nginx-gui</title>
    <updated>2022-11-26T01:32:51Z</updated>
    <id>tag:github.com,2022-11-26:/onlyGuo/nginx-gui</id>
    <link href="https://github.com/onlyGuo/nginx-gui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nginx GUI Manager&lt;/p&gt;&lt;hr&gt;&lt;div style=&#34;text-align: center;color: #884e4e; background-color: gray&#34;&gt; &#xA; &lt;div&gt;&#xA;  现在，它凉了。近两年来没有更新是因为它的确凉了。作者为了生计不得不放弃维护它，现在作者可能正在996,很讽刺...&#xA; &lt;/div&gt; &#xA; &lt;div style=&#34;margin: 20px auto&#34;&gt;&#xA;   Now she is dead. Since it is dead, it has not been updated in the past two years. The author must give up maintenance to maintain the author&#39;s life. Now the author may be doing 996, which is ironic &#xA; &lt;/div&gt; &#xA; &lt;div style=&#34;font-size: 30px&#34;&gt;&#xA;  🙂&#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Nginx GUI 项目恢复开发，已新建2.0的文件夹： &lt;a href=&#34;https://github.com/onlyGuo/nginx-gui-2&#34;&gt;https://github.com/onlyGuo/nginx-gui-2&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;Nginx GUI 2.0 将是一个从头构建的全新本本，将会使用自有的轻量级解库完成对conf文件的操作：&lt;a href=&#34;https://github.com/onlyGuo/nginx-conf-analysis&#34;&gt;https://github.com/onlyGuo/nginx-conf-analysis&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p align=&#34;center&#34;&gt; The nginx GUI makes maintenance easy &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/996icu/996.ICU/raw/master/LICENSE&#34;&gt; &lt;img alt=&#34;996icu&#34; src=&#34;https://img.shields.io/badge/license-NPL%20(The%20996%20Prohibited%20License)-blue.svg?sanitize=true&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/onlyGuo/nginx-gui/raw/master/LICENSE&#34;&gt; &lt;img alt=&#34;code style&#34; src=&#34;https://img.shields.io/github/license/onlyGuo/nginx-gui.svg?style=popout&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;h3&gt;Builder release-1.6&lt;/h3&gt; &#xA;&lt;p&gt;If you want to &lt;a href=&#34;https://github.com/onlyGuo/nginx-gui/releases/tag/1.6&#34;&gt;download&lt;/a&gt; this package, please go to this link: &lt;a href=&#34;https://github.com/onlyGuo/nginx-gui/releases/tag/1.6&#34;&gt;https://github.com/onlyGuo/nginx-gui/releases/tag/1.6&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Docker&lt;/h2&gt; &#xA;&lt;p&gt;感谢&lt;a href=&#34;https://github.com/CrazyLeoJay&#34;&gt;CrazyLeoJay&lt;/a&gt;提供的Docker版本， 分支地址： &lt;a href=&#34;https://github.com/onlyGuo/nginx-gui/tree/gradle-master&#34;&gt;gradle-master&lt;/a&gt; &lt;a href=&#34;https://github.com/CrazyLeoJay/nginx-gui&#34;&gt;CrazyLeoJay/nginx-gui&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Docker Hub&lt;/h2&gt; &#xA;&lt;p&gt;ducker hub &lt;a href=&#34;https://hub.docker.com/r/crazyleojay/nginx_ui&#34;&gt;https://hub.docker.com/r/crazyleojay/nginx_ui&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;拉取镜像：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker pull crazyleojay/nginx_ui&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker run --detach \&#xA;--publish 80:80 --publish 8889:8889 \&#xA;--name nginx_ui \&#xA;--restart always \&#xA;crazyleojay/nginx_ui:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;持久化：&lt;/p&gt; &#xA;&lt;p&gt;配置文件路径：&lt;code&gt;/usr/local/nginx/conf/nginx.conf&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;开发者可以自行配置。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker run --detach \&#xA;--publish 80:80 --publish 8889:8889 \&#xA;--name nginx_ui \&#xA;--restart always \&#xA;--volume /home/nginx.conf:/usr/local/nginx/conf/nginx.conf \&#xA;crazyleojay/nginx_ui:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;China download node&lt;/h3&gt; &#xA;&lt;p&gt;这里提供了国内下载节点， 如果您无法通过以上连接下载release包，可以尝试从下方连接下载(但您需要支付流量费用)：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://disk.321aiyi.com/share/b88e02f8aca04cdd8ce3a1fb02499e79&#34;&gt;Nginx-GUI-For-Linux_X64_v1.6.zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://disk.321aiyi.com/share/6b945535bfc0437bb2b91ff2fa2f97b1&#34;&gt;Nginx-GUI-For-Linux_X86_v1.6.zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://disk.321aiyi.com/share/95075b8f92bb49c297085cba9c1c89a9&#34;&gt;Nginx-GUI-For-Mac_v1.6.zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://disk.321aiyi.com/share/235943a302e140a4b69b005f4874446e&#34;&gt;Nginx-GUI-For-Windows_x64_v1.6.zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/onlyGuo/disk&#34;&gt;国内节点采用的云盘项目开源地址&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;New idea&lt;/h2&gt; &#xA;&lt;p&gt;If you like algorithms, you can implement them &lt;a href=&#34;https://github.com/onlyGuo/nginx-conf-analysis&#34;&gt;here&lt;/a&gt;.&lt;br&gt; In the future, it will be a nginx configuration file management tool library supporting complete modules and files.&lt;/p&gt; &#xA;&lt;h2&gt;Quick start&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the release package.&lt;/li&gt; &#xA; &lt;li&gt;Unzip pachage to your {dir}.&lt;/li&gt; &#xA; &lt;li&gt;Edit the {dir}/conf/conf.properties, set your nginx path.&lt;/li&gt; &#xA; &lt;li&gt;Run {dir}/startup.sh or {dir}/startup.bat&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How to use source code?&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;If your system is Mac os or idea, please copy &#34;conf.properties&#34; to parent directory。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Please eidt &#34;conf.properties&#34;, fill in your nginx path to &#34;conf.properties&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Now, please experience!, the default account and pwssword is &#34;admin&#34;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;AC QQ Group&lt;/h2&gt; &#xA;&lt;p&gt;群号:933481759(已满) 群号:274862188&lt;/p&gt; &#xA;&lt;h2&gt;UI&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/onlyGuo/nginx-gui/master/doc/login.png&#34; alt=&#34;登录&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/onlyGuo/nginx-gui/master/doc/home.png&#34; alt=&#34;主页&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/onlyGuo/nginx-gui/master/doc/lisner.png&#34; alt=&#34;监听&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/onlyGuo/nginx-gui/master/doc/upstream.png&#34; alt=&#34;负载&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/onlyGuo/nginx-gui/master/doc/location.png&#34; alt=&#34;规则&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/onlyGuo/nginx-gui/master/doc/conf.png&#34; alt=&#34;配置&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;LICENCE&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/996icu/996.ICU/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-Anti%20996-blue.svg?sanitize=true&#34; alt=&#34;LICENSE&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jonmircha/youtube-js</title>
    <updated>2022-11-26T01:32:51Z</updated>
    <id>tag:github.com,2022-11-26:/jonmircha/youtube-js</id>
    <link href="https://github.com/jonmircha/youtube-js" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Repositorio de códigos del Curso JavaScript de @jonmircha&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Curso JavaScript&lt;/h1&gt; &#xA;&lt;p&gt;En este repositorio encontrarás los recursos para seguir el &lt;a href=&#34;https://www.youtube.com/playlist?list=PLvq-jIkSeTUZ6QgYYO3MwG9EMqC-KoLXA&#34;&gt;Curso de &lt;em&gt;JavaScript&lt;/em&gt;&lt;/a&gt; de &lt;a href=&#34;https://jonmircha.com/&#34;&gt;Jonathan MirCha&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Recuerda que si quieres mantenerte al tanto de todas las actualizaciones de este curso puedes ingresar al sitio &lt;a href=&#34;https://aprendejavascript.org/&#34;&gt;aprendejavascript.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Este repositorio incluye:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Toda la estructura de archivos y carpetas que usarás en el curso.&lt;/li&gt; &#xA; &lt;li&gt;Todos los códigos y recursos ajenos a &lt;em&gt;JavaScript&lt;/em&gt; para hacer el curso como imágenes, archivos &lt;em&gt;HTML&lt;/em&gt;, &lt;em&gt;CSS&lt;/em&gt;, &lt;em&gt;PHP&lt;/em&gt;, &lt;em&gt;JSON&lt;/em&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;Todo el código &lt;em&gt;JavaScript&lt;/em&gt; de las clases teóricas.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Este repositorio &lt;strong&gt;NO&lt;/strong&gt; incluye:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;El código &lt;em&gt;JavaScript&lt;/em&gt; de los ejercicios prácticos, ¿Porqué no? Por qué ese código lo generarás tú cuando te pongas a hacer los ejercicios propuestos en el curso.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Repositorio &lt;em&gt;PREMIUM&lt;/em&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Adicionalmente a este repositorio por una pequeña aportación puedes acceder a:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Toda la teoría referente a este curso que encuentras en mi &lt;a href=&#34;https://jonmircha.com/blog&#34;&gt;blog&lt;/a&gt; en formato &lt;em&gt;MarkDown&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;El código &lt;em&gt;JavaScript&lt;/em&gt; que da solución a los ejercicios propuestos en el curso.&lt;/li&gt; &#xA; &lt;li&gt;Puedes adquirir el repositorio &lt;em&gt;PREMIUM&lt;/em&gt; &lt;a href=&#34;https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;amp;hosted_button_id=6B6FCUL4SKSJN&#34;&gt;aquí&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Mis Redes Sociales&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;🔔 Suscríbete al canal &lt;a href=&#34;https://youtube.com/jonmircha?sub_confirmation=1&#34;&gt;https://youtube.com/jonmircha?sub_confirmation=1&lt;/a&gt; 🤓&lt;/li&gt; &#xA; &lt;li&gt;👉 Visita mi sitio web &lt;a href=&#34;https://jonmircha.com/&#34;&gt;https://jonmircha.com/&lt;/a&gt; 💻&lt;/li&gt; &#xA; &lt;li&gt;🌮 ¿Me invítas un taco? &lt;a href=&#34;https://www.paypal.me/jonmircha&#34;&gt;https://www.paypal.me/jonmircha&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;📫 Suscríbete a mi lista de correo &lt;a href=&#34;https://tinyletter.com/jonmircha/&#34;&gt;https://tinyletter.com/jonmircha/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>