<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-14T01:29:33Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nevesnunes/ghidra-plays-mario</title>
    <updated>2023-09-14T01:29:33Z</updated>
    <id>tag:github.com,2023-09-14:/nevesnunes/ghidra-plays-mario</id>
    <link href="https://github.com/nevesnunes/ghidra-plays-mario" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Playing NES ROMs with Ghidra&#39;s PCode Emulator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Can Ghidra play Super Mario Bros?&lt;/h1&gt; &#xA;&lt;p&gt;The answer is: &lt;del&gt;very slowly&lt;/del&gt; &lt;strong&gt;YES&lt;/strong&gt;!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/nevesnunes/ghidra-plays-mario/master/imgs/smb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve recorded keyboard inputs that can be replayed to complete the first level. It finishes at in-game time 316, but wall-clock time is &lt;strong&gt;32 minutes&lt;/strong&gt;. Transitions and starting the second level adds another &lt;strong&gt;15 minutes&lt;/strong&gt;. ðŸ˜€&lt;/p&gt; &#xA;&lt;p&gt;Demo (speedup 50x):&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nevesnunes/ghidra-plays-mario/assets/9061071/9b571a39-9672-4dc5-ada2-4a149f60a0dd&#34;&gt;https://github.com/nevesnunes/ghidra-plays-mario/assets/9061071/9b571a39-9672-4dc5-ada2-4a149f60a0dd&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What?&lt;/h2&gt; &#xA;&lt;p&gt;I took an &lt;a href=&#34;https://github.com/binji/smolnes&#34;&gt;existing minimal emulator&lt;/a&gt;, removed all CPU logic, and replaced it with a socket-based protocol for delegating CPU execution to Ghidra&#39;s PCode emulator (server). Everything else is still handled by the modified emulator (client), such as keyboard input and PPU logic.&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;Processor module validation! Sure, Ghidra has &lt;a href=&#34;https://github.com/NationalSecurityAgency/ghidra/raw/master/Ghidra/Extensions/SleighDevTools/pcodetest/&#34;&gt;pcodetest&lt;/a&gt; for this purpose, but it&#39;s hard to tell how much coverage it provides. Apparently, not enough!&lt;/p&gt; &#xA;&lt;p&gt;Just getting the Super Mario Bros title screen to render required fixing bugs in 3 instructions. &lt;a href=&#34;https://github.com/nevesnunes/ghidra/commit/63b08533033f527058a347e5133f9e6184ebad65&#34;&gt;Even more were fixed&lt;/a&gt; while appeasing &lt;a href=&#34;https://github.com/christopherpow/nes-test-roms/raw/master/other/nestest.txt&#34;&gt;nestest.nes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before (some tests fail, until a crash after jumping to an invalid instruction):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/nevesnunes/ghidra-plays-mario/master/imgs/nestest1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;After (all tests pass):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/nevesnunes/ghidra-plays-mario/master/imgs/nestest2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;Tested with Ghidra 10.3.2, on Debian GNU/Linux 12.&lt;/p&gt; &#xA;&lt;p&gt;To reproduce the first level run:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;Ghidra/Processors/6502/data/languages/*.slaspec&lt;/code&gt; from &lt;a href=&#34;https://github.com/nevesnunes/ghidra/tree/fix-6502-ops&#34;&gt;my fork&lt;/a&gt; to your Ghidra installation, then run &lt;code&gt;ant -f build.xml&lt;/code&gt; under &lt;code&gt;data/&lt;/code&gt; to build the updated &lt;code&gt;.sla&lt;/code&gt; files;&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://github.com/kylewlacy/GhidraNes&#34;&gt;GhidraNes&lt;/a&gt; (tested with commit &lt;code&gt;ef27b8d&lt;/code&gt;);&lt;/li&gt; &#xA; &lt;li&gt;Load a Super Mario Bros (World) ROM (sha1 &lt;code&gt;ea343f4e445a9050d4b4fbac2c77d0693b1d0922&lt;/code&gt;), and make sure it&#39;s focused in the listing (a.k.a. disassembly) window (in case you have other files open);&lt;/li&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;./ghidra_scripts/NesEmu.java&lt;/code&gt; to your project&#39;s &lt;code&gt;ghidra_scripts&lt;/code&gt; directory;&lt;/li&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;./inputs/smb.w11full.inputs&lt;/code&gt; to &lt;code&gt;/tmp/smb.inputs&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;On Ghidra&#39;s Window &amp;gt; Script Manager, run &lt;code&gt;NesEmu.java&lt;/code&gt; (starts the server);&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;make &amp;amp;&amp;amp; ./smolnes_emuclt $ROM&lt;/code&gt;, (starts the client, &lt;code&gt;$ROM&lt;/code&gt; is the full path to the same ROM being disassembled in Ghidra);&lt;/li&gt; &#xA; &lt;li&gt;Sit back and enjoy an ~1 FPS demo;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Of course, you can remove &lt;code&gt;/tmp/smb.inputs&lt;/code&gt; and play yourself.&lt;/p&gt; &#xA;&lt;h2&gt;Takeaways&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;As seen in the demo, Ghidra is constantly re-analyzing functions, caused by &lt;a href=&#34;https://github.com/nevesnunes/ghidra-plays-mario/raw/fce8d25afb0a2a37870ddbafffea9880e74f81df/ghidra_scripts/NesEmu.java#L557&#34;&gt;frantic clearing and disassembling of instructions&lt;/a&gt;. Not much room to improve here, since only disassembled instructions can be executed.&lt;/li&gt; &#xA; &lt;li&gt;I&#39;ve run into some desync when recording inputs in the standalone emulator vs replaying them in Ghidra&#39;s emulator. This means that inputs likely end up being set at different instruction lines. Expect diffs in e.g. how many VBlank interrupts happen when comparing both CPU emulators&#39; trace logs... Still, it wasn&#39;t bad enough to break the demo, please let me know if that&#39;s not the case for you.&lt;/li&gt; &#xA; &lt;li&gt;Currently, the protocol is very hardcoded for NES implementation details, and would benefit from a proper &lt;a href=&#34;https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value&#34;&gt;TLV encoding&lt;/a&gt; to handle variable address / data sizes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Profiling&lt;/h2&gt; &#xA;&lt;p&gt;Some flamegraphs were captured with async-profiler: &lt;code&gt;./asprof -e itimer -d 30 -o flamegraph -f /tmp/out.html $GHIDRA_PID&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Surprisingly, stepping through instructions only takes about 15% of CPU time. About 50% is socket I/O (even after some quick optimizations like reusing the same buffer for payloads and buffering socket writes):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/nevesnunes/ghidra-plays-mario/master/flamegraphs/smb_buffered_w.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;deobfuscated.c&lt;/code&gt; from &lt;a href=&#34;https://github.com/binji/smolnes&#34;&gt;smolnes&lt;/a&gt; is under &lt;a href=&#34;https://raw.githubusercontent.com/nevesnunes/ghidra-plays-mario/master/LICENSE.smolnes&#34;&gt;LICENSE.smolnes&lt;/a&gt;, and was modified into files &lt;code&gt;smolnes_emuclt.c&lt;/code&gt; and &lt;code&gt;smolnes_standalone.c&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;Remaining files are under &lt;a href=&#34;https://raw.githubusercontent.com/nevesnunes/ghidra-plays-mario/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt;;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>