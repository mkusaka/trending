<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-17T01:33:37Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>snakemake/snakemake</title>
    <updated>2022-08-17T01:33:37Z</updated>
    <id>tag:github.com,2022-08-17:/snakemake/snakemake</id>
    <link href="https://github.com/snakemake/snakemake" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is the development home of the workflow management system Snakemake. For general information, see&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://gitpod.io/#https://github.com/snakemake/snakemake&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Gitpod-ready--to--code-blue?logo=gitpod&#34; alt=&#34;Gitpod Ready-to-Code&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/snakemake/snakemake/actions?query=branch%3Amain+workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/snakemake/snakemake/workflows/CI/badge.svg?branch=main&#34; alt=&#34;test status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/dashboard?id=snakemake_snakemake&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=snakemake_snakemake&amp;amp;metric=alert_status&#34; alt=&#34;Sonarcloud Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bioconda.github.io/recipes/snakemake/README.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/conda/dn/bioconda/snakemake.svg?label=Bioconda&#34; alt=&#34;Bioconda&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pypi.org/project/snakemake&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/pyversions/snakemake.svg?sanitize=true&#34; alt=&#34;Pypi&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/snakemake/snakemake&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/snakemake/snakemake/Publish%20to%20Docker%20Hub?color=blue&amp;amp;label=docker%20container&#34; alt=&#34;docker container status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stackoverflow.com/questions/tagged/snakemake&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/stack-overflow-orange.svg?sanitize=true&#34; alt=&#34;Stack Overflow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/search?l=&amp;amp;q=%23snakemake%20from%3Ajohanneskoester&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/johanneskoester.svg?style=social&amp;amp;label=Follow&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/NUdMtmr&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/753690260830945390?label=discord%20chat&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/snakemake/snakemake/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/snakemake/snakemake?style=social&#34; alt=&#34;Github stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/snakemake/snakemake/main/CODE_OF_CONDUCT.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Contributor%20Covenant-v2.0%20adopted-ff69b4.svg?sanitize=true&#34; alt=&#34;Contributor Covenant&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Snakemake&lt;/h1&gt; &#xA;&lt;p&gt;The Snakemake workflow management system is a tool to create &lt;strong&gt;reproducible and scalable&lt;/strong&gt; data analyses. Snakemake is highly popular, with on average more than 7 new citations per week in 2021, and almost 400k downloads. Workflows are described via a human readable, Python based language. They can be seamlessly scaled to server, cluster, grid and cloud environments without the need to modify the workflow definition. Finally, Snakemake workflows can entail a description of required software, which will be automatically deployed to any execution environment.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Homepage: &lt;a href=&#34;https://snakemake.github.io&#34;&gt;https://snakemake.github.io&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2012-2022 Johannes Köster &lt;a href=&#34;mailto:johannes.koester@uni-due.com&#34;&gt;johannes.koester@uni-due.com&lt;/a&gt; (see LICENSE)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>WICG/import-maps</title>
    <updated>2022-08-17T01:33:37Z</updated>
    <id>tag:github.com,2022-08-17:/WICG/import-maps</id>
    <link href="https://github.com/WICG/import-maps" rel="alternate"></link>
    <summary type="html">&lt;p&gt;How to control the behavior of JavaScript imports&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Import maps&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Or, how to control the behavior of JavaScript imports&lt;/em&gt;&lt;/p&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#the-basic-idea&#34;&gt;The basic idea&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#background&#34;&gt;Background&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#the-import-map&#34;&gt;The import map&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#specifier-remapping-examples&#34;&gt;Specifier remapping examples&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#bare-specifiers-for-javascript-modules&#34;&gt;Bare specifiers for JavaScript modules&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#packages-via-trailing-slashes&#34;&gt;&#34;Packages&#34; via trailing slashes&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#extension-less-imports&#34;&gt;Extension-less imports&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#general-url-like-specifier-remapping&#34;&gt;General URL-like specifier remapping&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#mapping-away-hashes-in-script-filenames&#34;&gt;Mapping away hashes in script filenames&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#remapping-doesnt-work-for-script&#34;&gt;Remapping doesn&#39;t work for &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#scoping-examples&#34;&gt;Scoping examples&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#multiple-versions-of-the-same-module&#34;&gt;Multiple versions of the same module&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#scope-inheritance&#34;&gt;Scope inheritance&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#import-map-processing&#34;&gt;Import map processing&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#dynamic-import-map-example&#34;&gt;Dynamic import map example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#scope&#34;&gt;Scope&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#interaction-with-speculative-parsingfetching&#34;&gt;Interaction with speculative parsing/fetching&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#base-element&#34;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#feature-detection&#34;&gt;Feature detection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#alternatives-considered&#34;&gt;Alternatives considered&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#the-nodejs-module-resolution-algorithm&#34;&gt;The Node.js module resolution algorithm&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#a-programmable-resolution-hook&#34;&gt;A programmable resolution hook&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#ahead-of-time-rewriting&#34;&gt;Ahead-of-time rewriting&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#service-workers&#34;&gt;Service workers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#a-convention-based-flat-mapping&#34;&gt;A convention-based flat mapping&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#adjacent-concepts&#34;&gt;Adjacent concepts&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#supplying-out-of-band-metadata-for-each-module&#34;&gt;Supplying out-of-band metadata for each module&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#further-work&#34;&gt;Further work&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#multiple-import-map-support&#34;&gt;Multiple import map support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#programmatic-api&#34;&gt;Programmatic API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#importmetaresolve&#34;&gt;&lt;code&gt;import.meta.resolve()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#community-polyfills-and-tooling&#34;&gt;Community polyfills and tooling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#acknowledgments&#34;&gt;Acknowledgments&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;The basic idea&lt;/h2&gt; &#xA;&lt;p&gt;This proposal allows control over what URLs get fetched by JavaScript &lt;code&gt;import&lt;/code&gt; statements and &lt;code&gt;import()&lt;/code&gt; expressions. This allows &#34;bare import specifiers&#34;, such as &lt;code&gt;import moment from &#34;moment&#34;&lt;/code&gt;, to work.&lt;/p&gt; &#xA;&lt;p&gt;The mechanism for doing this is via an &lt;em&gt;import map&lt;/em&gt; which can be used to control the resolution of module specifiers generally. As an introductory example, consider the code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import moment from &#34;moment&#34;;&#xA;import { partition } from &#34;lodash&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Today, this throws, as such bare specifiers &lt;a href=&#34;https://html.spec.whatwg.org/multipage/webappapis.html#resolve-a-module-specifier&#34;&gt;are explicitly reserved&lt;/a&gt;. By supplying the browser with the following import map&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&#xA;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;moment&#34;: &#34;/node_modules/moment/src/moment.js&#34;,&#xA;    &#34;lodash&#34;: &#34;/node_modules/lodash-es/lodash.js&#34;&#xA;  }&#xA;}&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the above would act as if you had written&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import moment from &#34;/node_modules/moment/src/moment.js&#34;;&#xA;import { partition } from &#34;/node_modules/lodash-es/lodash.js&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more on the new &lt;code&gt;&#34;importmap&#34;&lt;/code&gt; value for &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&#39;s &lt;code&gt;type=&#34;&#34;&lt;/code&gt; attribute, see the &lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#installation&#34;&gt;installation section&lt;/a&gt;. For now, we&#39;ll concentrate on the semantics of the mapping, deferring the installation discussion.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Web developers with experience with pre-ES2015 module systems, such as CommonJS (either in Node or bundled using webpack/browserify for the browser), are used to being able to import modules using a simple syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const $ = require(&#34;jquery&#34;);&#xA;const { pluck } = require(&#34;lodash&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Translated into the language of JavaScript&#39;s built-in module system, these would be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import $ from &#34;jquery&#34;;&#xA;import { pluck } from &#34;lodash&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In such systems, these bare import specifiers of &lt;code&gt;&#34;jquery&#34;&lt;/code&gt; or &lt;code&gt;&#34;lodash&#34;&lt;/code&gt; are mapped to full filenames or URLs. In more detail, these specifiers represent &lt;em&gt;packages&lt;/em&gt;, usually distributed on &lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;; by only specifying the name of the package, they are implicitly requesting the main module of that package.&lt;/p&gt; &#xA;&lt;p&gt;The main benefit of this system is that it allows easy coordination across the ecosystem. Anyone can write a module and include an import statement using a package&#39;s well-known name, and let the Node.js runtime or their build-time tooling take care of translating it into an actual file on disk (including figuring out versioning considerations).&lt;/p&gt; &#xA;&lt;p&gt;Today, many web developers are even using JavaScript&#39;s native module syntax, but combining it with bare import specifiers, thus making their code unable to run on the web without per-application, ahead-of-time modification. We&#39;d like to solve that, and bring these benefits to the web.&lt;/p&gt; &#xA;&lt;h2&gt;The import map&lt;/h2&gt; &#xA;&lt;p&gt;We explain the features of the import map via a series of examples.&lt;/p&gt; &#xA;&lt;h3&gt;Specifier remapping examples&lt;/h3&gt; &#xA;&lt;h4&gt;Bare specifiers for JavaScript modules&lt;/h4&gt; &#xA;&lt;p&gt;As mentioned in the introduction,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;moment&#34;: &#34;/node_modules/moment/src/moment.js&#34;,&#xA;    &#34;lodash&#34;: &#34;/node_modules/lodash-es/lodash.js&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;gives bare import specifier support in JavaScript code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import moment from &#34;moment&#34;;&#xA;import(&#34;lodash&#34;).then(_ =&amp;gt; ...);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the right-hand side of the mapping (known as the &#34;address&#34;) must start with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;../&lt;/code&gt;, or &lt;code&gt;./&lt;/code&gt;, or be parseable as an absolute URL, to identify a URL. In the case of relative-URL-like addresses, they are resolved relative to the import map&#39;s base URL, i.e. the base URL of the page for inline import maps, and the URL of the import map resource for external import maps.&lt;/p&gt; &#xA;&lt;p&gt;In particular, &#34;bare&#34; relative URLs like &lt;code&gt;node_modules/moment/src/moment.js&lt;/code&gt; will not work in these positions, for now. This is done as a conservative default, as in the future we may want to allow &lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#multiple-import-map-support&#34;&gt;multiple import maps&lt;/a&gt;, which might change the meaning of the right-hand side in ways that especially affect these bare cases.&lt;/p&gt; &#xA;&lt;h4&gt;&#34;Packages&#34; via trailing slashes&lt;/h4&gt; &#xA;&lt;p&gt;It&#39;s common in the JavaScript ecosystem to have a package (in the sense of &lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;) contain multiple modules, or other files. For such cases, we want to map a prefix in the module specifier space, onto another prefix in the fetchable-URL space.&lt;/p&gt; &#xA;&lt;p&gt;Import maps do this by giving special meaning to specifier keys that end with a trailing slash. Thus, a map like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;moment&#34;: &#34;/node_modules/moment/src/moment.js&#34;,&#xA;    &#34;moment/&#34;: &#34;/node_modules/moment/src/&#34;,&#xA;    &#34;lodash&#34;: &#34;/node_modules/lodash-es/lodash.js&#34;,&#xA;    &#34;lodash/&#34;: &#34;/node_modules/lodash-es/&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would allow not only importing the main modules like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import moment from &#34;moment&#34;;&#xA;import _ from &#34;lodash&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but also non-main modules, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import localeData from &#34;moment/locale/zh-cn.js&#34;;&#xA;import fp from &#34;lodash/fp.js&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Extension-less imports&lt;/h4&gt; &#xA;&lt;p&gt;It is also common in the Node.js ecosystem to import files without including the extension. &lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#the-nodejs-module-resolution-algorithm&#34;&gt;We do not have the luxury&lt;/a&gt; of trying multiple file extensions until we find a good match. However, we can emulate something similar by using an import map. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt; {&#xA;   &#34;imports&#34;: {&#xA;     &#34;lodash&#34;: &#34;/node_modules/lodash-es/lodash.js&#34;,&#xA;     &#34;lodash/&#34;: &#34;/node_modules/lodash-es/&#34;,&#xA;     &#34;lodash/fp&#34;: &#34;/node_modules/lodash-es/fp.js&#34;,&#xA;   }&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would allow not only &lt;code&gt;import fp from &#34;lodash/fp.js&#34;&lt;/code&gt;, but also allow &lt;code&gt;import fp from &#34;lodash/fp&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Although this example shows how it is &lt;em&gt;possible&lt;/em&gt; to allow extension-less imports with import maps, it&#39;s not necessarily &lt;em&gt;desirable&lt;/em&gt;. Doing so bloats the import map, and makes the package&#39;s interface less simple—both for humans and for tooling.&lt;/p&gt; &#xA;&lt;p&gt;This bloat is especially problematic if you need to allow extension-less imports within a package. In that case you will need an import map entry for every file in the package, not just the top-level entry points. For example, to allow &lt;code&gt;import &#34;./fp&#34;&lt;/code&gt; from within the &lt;code&gt;/node_modules/lodash-es/lodash.js&lt;/code&gt; file, you would need an import entry mapping &lt;code&gt;/node_modules/lodash-es/fp&lt;/code&gt; to &lt;code&gt;/node_modules/lodash-es/fp.js&lt;/code&gt;. Now imagine repeating this for every file referenced without an extension.&lt;/p&gt; &#xA;&lt;p&gt;As such, we recommend caution when employing patterns like this in your import maps, or writing modules. It will be simpler for the ecosystem if we don&#39;t rely on import maps to patch up file-extension related mismatches.&lt;/p&gt; &#xA;&lt;h4&gt;General URL-like specifier remapping&lt;/h4&gt; &#xA;&lt;p&gt;As part of allowing general remapping of specifiers, import maps specifically allow remapping of URL-like specifiers, such as &lt;code&gt;&#34;https://example.com/foo.mjs&#34;&lt;/code&gt; or &lt;code&gt;&#34;./bar.mjs&#34;&lt;/code&gt;. A practical use for this is &lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#mapping-away-hashes-in-script-filenames&#34;&gt;mapping away hashes&lt;/a&gt;, but here we demonstrate some basic ones to communicate the concept:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;https://www.unpkg.com/vue/dist/vue.runtime.esm.js&#34;: &#34;/node_modules/vue/dist/vue.runtime.esm.js&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This remapping ensures that any imports of the unpkg.com version of Vue (at least at that URL) instead grab the one from the local server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;/app/helpers.mjs&#34;: &#34;/app/helpers/index.mjs&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This remapping ensures that any URL-like imports that resolve to &lt;code&gt;/app/helpers.mjs&lt;/code&gt;, including e.g. an &lt;code&gt;import &#34;./helpers.mjs&#34;&lt;/code&gt; from files inside &lt;code&gt;/app/&lt;/code&gt;, or an &lt;code&gt;import &#34;../helpers.mjs&#34;&lt;/code&gt; from files inside &lt;code&gt;/app/models&lt;/code&gt;, will instead resolve to &lt;code&gt;/app/helpers/index.mjs&lt;/code&gt;. This is probably not a good idea; instead of creating an indirection which obfuscates your code, you should instead just update your source files to import the correct files. But, it is a useful example for demonstrating the capabilities of import maps.&lt;/p&gt; &#xA;&lt;p&gt;Such remapping can also be done on a prefix-matched basis, by ending the specifier key with a trailing slash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;https://www.unpkg.com/vue/&#34;: &#34;/node_modules/vue/&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This version ensures that import statements for specifiers that start with the substring &lt;code&gt;&#34;https://www.unpkg.com/vue/&#34;&lt;/code&gt; will be mapped to the corresponding URL underneath &lt;code&gt;/node_modules/vue/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In general, the point is that the remapping works the same for URL-like imports as for bare imports. Our previous examples changed the resolution of specifiers like &lt;code&gt;&#34;lodash&#34;&lt;/code&gt;, and thus changed the meaning of &lt;code&gt;import &#34;lodash&#34;&lt;/code&gt;. Here we&#39;re changing the resolution of specifiers like &lt;code&gt;&#34;/app/helpers.mjs&#34;&lt;/code&gt;, and thus changing the meaning of &lt;code&gt;import &#34;/app/helpers.mjs&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that this trailing-slash variant of URL-like specifier mapping only works if the URL-like specifier has a &lt;a href=&#34;https://url.spec.whatwg.org/#special-scheme&#34;&gt;special scheme&lt;/a&gt;: e.g., a mapping of &lt;code&gt;&#34;data:text/&#34;: &#34;/foo&#34;&lt;/code&gt; will not impact the meaning of &lt;code&gt;import &#34;data:text/javascript,console.log(&#39;test&#39;)&#34;&lt;/code&gt;, but instead will only impact &lt;code&gt;import &#34;data:text/&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Mapping away hashes in script filenames&lt;/h4&gt; &#xA;&lt;p&gt;Script files are often given a unique hash in their filename, to improve cachability. See &lt;a href=&#34;https://jakearchibald.com/2016/caching-best-practices/&#34;&gt;this general discussion of the technique&lt;/a&gt;, or &lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching&#34;&gt;this more JavaScript- and webpack-focused discussion&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With module graphs, this technique can be problematic:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Consider a simple module graph, with &lt;code&gt;app.mjs&lt;/code&gt; depending on &lt;code&gt;dep.mjs&lt;/code&gt; which depends on &lt;code&gt;sub-dep.mjs&lt;/code&gt;. Normally, if you upgrade or change &lt;code&gt;sub-dep.mjs&lt;/code&gt;, &lt;code&gt;app.mjs&lt;/code&gt; and &lt;code&gt;dep.mjs&lt;/code&gt; can remain cached, requiring only transferring the new &lt;code&gt;sub-dep.mjs&lt;/code&gt; over the network.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Now consider the same module graph, using hashed filenames for production. There we have our build process generating &lt;code&gt;app-8e0d62a03.mjs&lt;/code&gt;, &lt;code&gt;dep-16f9d819a.mjs&lt;/code&gt;, and &lt;code&gt;sub-dep-7be2aa47f.mjs&lt;/code&gt; from the original three files.&lt;/p&gt; &lt;p&gt;If we upgrade or change &lt;code&gt;sub-dep.mjs&lt;/code&gt;, our build process will re-generate a new filename for the production version, say &lt;code&gt;sub-dep-5f47101dc.mjs&lt;/code&gt;. But this means we need to change the &lt;code&gt;import&lt;/code&gt; statement in the production version of &lt;code&gt;dep.mjs&lt;/code&gt;. That changes its contents, which means the production version of &lt;code&gt;dep.mjs&lt;/code&gt; itself needs a new filename. But then this means we need to update the &lt;code&gt;import&lt;/code&gt; statement in the production version of &lt;code&gt;app.mjs&lt;/code&gt;...&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That is, with module graphs and &lt;code&gt;import&lt;/code&gt; statements containing hashed-filename script files, updates to any part of the graph become viral to all its dependencies, losing all the cachability benefits.&lt;/p&gt; &#xA;&lt;p&gt;Import maps provide a way out of this dillema, by decoupling the module specifiers that appear in &lt;code&gt;import&lt;/code&gt; statements from the URLs on the server. For example, our site could start out with an import map like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;/js/app.mjs&#34;: &#34;/js/app-8e0d62a03.mjs&#34;,&#xA;    &#34;/js/dep.mjs&#34;: &#34;/js/dep-16f9d819a.mjs&#34;,&#xA;    &#34;/js/sub-dep.mjs&#34;: &#34;/js/sub-dep-7be2aa47f.mjs&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and with import statements that are of the form &lt;code&gt;import &#34;./sub-dep.mjs&#34;&lt;/code&gt; instead of &lt;code&gt;import &#34;./sub-dep-7be2aa47f.mjs&#34;&lt;/code&gt;. Now, if we change &lt;code&gt;sub-dep.mjs&lt;/code&gt;, we simply update our import map:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;/js/app.mjs&#34;: &#34;/js/app-8e0d62a03.mjs&#34;,&#xA;    &#34;/js/dep.mjs&#34;: &#34;/js/dep-16f9d819a.mjs&#34;,&#xA;    &#34;/js/sub-dep.mjs&#34;: &#34;/js/sub-dep-5f47101dc.mjs&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and leave the &lt;code&gt;import &#34;./sub-dep.mjs&#34;&lt;/code&gt; statement alone. This means the contents of &lt;code&gt;dep.mjs&lt;/code&gt; don&#39;t change, and so it stays cached; the same for &lt;code&gt;app.mjs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Remapping doesn&#39;t work for &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;An important note about using import maps to change the meaning of import specifiers is that it does not change the meaning of raw URLs, such as those that appear in &lt;code&gt;&amp;lt;script src=&#34;&#34;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;link rel=&#34;modulepreload&#34;&amp;gt;&lt;/code&gt;. That is, given the above example, while&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import &#34;./app.mjs&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would be correctly remapping to its hashed version in import-map-supporting browsers,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&#34;module&#34; src=&#34;./app.mjs&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would not: in all classes of browsers, it would attempt to fetch &lt;code&gt;app.mjs&lt;/code&gt; directly, resulting in a 404. What &lt;em&gt;would&lt;/em&gt; work, in import-map-supporting browsers, would be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&#34;module&#34;&amp;gt;import &#34;./app.mjs&#34;;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scoping examples&lt;/h3&gt; &#xA;&lt;h4&gt;Multiple versions of the same module&lt;/h4&gt; &#xA;&lt;p&gt;It is often the case that you want to use the same import specifier to refer to multiple versions of a single library, depending on who is importing them. This encapsulates the versions of each dependency in use, and avoids &lt;a href=&#34;https://npm.github.io/how-npm-works-docs/theory-and-design/dependency-hell.html&#34;&gt;dependency hell&lt;/a&gt; (&lt;a href=&#34;https://blog.timoxley.com/post/20772365842/node-js-npm-reducing-dependency-overheads&#34;&gt;longer blog post&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;We support this use case in import maps by allowing you to change the meaning of a specifier within a given &lt;em&gt;scope&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;querystringify&#34;: &#34;/node_modules/querystringify/index.js&#34;&#xA;  },&#xA;  &#34;scopes&#34;: {&#xA;    &#34;/node_modules/socksjs-client/&#34;: {&#xA;      &#34;querystringify&#34;: &#34;/node_modules/socksjs-client/querystringify/index.js&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(This is example is one of several &lt;a href=&#34;https://github.com/WICG/import-maps/issues/5#issuecomment-374175653&#34;&gt;in-the-wild examples&lt;/a&gt; of multiple versions per application provided by @zkat. Thanks, @zkat!)&lt;/p&gt; &#xA;&lt;p&gt;With this mapping, inside any modules whose URLs start with &lt;code&gt;/node_modules/socksjs-client/&lt;/code&gt;, the &lt;code&gt;&#34;querystringify&#34;&lt;/code&gt; specifier will refer to &lt;code&gt;/node_modules/socksjs-client/querystringify/index.js&lt;/code&gt;. Whereas otherwise, the top-level mapping will ensure that &lt;code&gt;&#34;querystringify&#34;&lt;/code&gt; refers to &lt;code&gt;/node_modules/querystringify/index.js&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that being in a scope does not change how an address is resolved; the import map&#39;s base URL is still used, instead of e.g. the scope URL prefix.&lt;/p&gt; &#xA;&lt;h4&gt;Scope inheritance&lt;/h4&gt; &#xA;&lt;p&gt;Scopes &#34;inherit&#34; from each other in an intentionally-simple manner, merging but overriding as they go. For example, the following import map:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;a&#34;: &#34;/a-1.mjs&#34;,&#xA;    &#34;b&#34;: &#34;/b-1.mjs&#34;,&#xA;    &#34;c&#34;: &#34;/c-1.mjs&#34;&#xA;  },&#xA;  &#34;scopes&#34;: {&#xA;    &#34;/scope2/&#34;: {&#xA;      &#34;a&#34;: &#34;/a-2.mjs&#34;&#xA;    },&#xA;    &#34;/scope2/scope3/&#34;: {&#xA;      &#34;b&#34;: &#34;/b-3.mjs&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would give the following resolutions:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Specifier&lt;/th&gt; &#xA;   &lt;th&gt;Referrer&lt;/th&gt; &#xA;   &lt;th&gt;Resulting URL&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;a&lt;/td&gt; &#xA;   &lt;td&gt;/scope1/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/a-1.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;b&lt;/td&gt; &#xA;   &lt;td&gt;/scope1/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/b-1.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;c&lt;/td&gt; &#xA;   &lt;td&gt;/scope1/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/c-1.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;a&lt;/td&gt; &#xA;   &lt;td&gt;/scope2/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/a-2.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;b&lt;/td&gt; &#xA;   &lt;td&gt;/scope2/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/b-1.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;c&lt;/td&gt; &#xA;   &lt;td&gt;/scope2/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/c-1.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;a&lt;/td&gt; &#xA;   &lt;td&gt;/scope2/scope3/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/a-2.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;b&lt;/td&gt; &#xA;   &lt;td&gt;/scope2/scope3/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/b-3.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;c&lt;/td&gt; &#xA;   &lt;td&gt;/scope2/scope3/foo.mjs&lt;/td&gt; &#xA;   &lt;td&gt;/c-1.mjs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Import map processing&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;You can install an import map for your application using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element, either inline or with a &lt;code&gt;src=&#34;&#34;&lt;/code&gt; attribute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&#xA;{&#xA;  &#34;imports&#34;: { ... },&#xA;  &#34;scopes&#34;: { ... }&#xA;}&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&#34;importmap&#34; src=&#34;import-map.importmap&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When the &lt;code&gt;src=&#34;&#34;&lt;/code&gt; attribute is used, the resulting HTTP response must have the MIME type &lt;code&gt;application/importmap+json&lt;/code&gt;. (Why not reuse &lt;code&gt;application/json&lt;/code&gt;? Doing so could &lt;a href=&#34;https://github.com/WICG/import-maps/issues/105&#34;&gt;enable CSP bypasses&lt;/a&gt;.) Like module scripts, the request is made with CORS enabled, and the response is always interpreted as UTF-8.&lt;/p&gt; &#xA;&lt;p&gt;Because they affect all imports, any import maps must be present and successfully fetched before any module resolution is done. This means that module graph fetching is blocked on import map fetching.&lt;/p&gt; &#xA;&lt;p&gt;This means that the inline form of import maps is &lt;em&gt;strongly recommended&lt;/em&gt; for best performance. This is similar to the best practice of &lt;a href=&#34;https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery&#34;&gt;inlining critical CSS&lt;/a&gt;; both types of resources block your application from doing important work until they&#39;re processed, so introducing a second network round-trip (or even disk-cache round trip) is a bad idea. If your heart is set on using external import maps, you can attempt to mitigate this round-trip penalty with technologies like HTTP/2 Push or &lt;a href=&#34;https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html&#34;&gt;bundled HTTP exchanges&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As another consequence of how import maps affect all imports, attempting to add a new &lt;code&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&lt;/code&gt; after any module graph fetching has started is an error. The import map will be ignored, and the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element will fire an &lt;code&gt;error&lt;/code&gt; event.&lt;/p&gt; &#xA;&lt;p&gt;For now, only one &lt;code&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&lt;/code&gt; is allowed on the page. We plan to extend this in the future, once we figure out the correct semantics for combining multiple import maps. See discussion in &lt;a href=&#34;https://github.com/WICG/import-maps/issues/14&#34;&gt;#14&lt;/a&gt;, &lt;a href=&#34;https://github.com/WICG/import-maps/issues/137&#34;&gt;#137&lt;/a&gt;, and &lt;a href=&#34;https://github.com/WICG/import-maps/pull/167&#34;&gt;#167&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;What do we do in workers? Probably &lt;code&gt;new Worker(someURL, { type: &#34;module&#34;, importMap: ... })&lt;/code&gt;? Or should you set it from inside the worker? Should dedicated workers use their controlling document&#39;s map, either by default or always? Discuss in &lt;a href=&#34;https://github.com/WICG/import-maps/issues/2&#34;&gt;#2&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Dynamic import map example&lt;/h3&gt; &#xA;&lt;p&gt;The above rules mean that you &lt;em&gt;can&lt;/em&gt; dynamically generate import maps, as long as you do so before performing any imports. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;&#xA;const im = document.createElement(&#39;script&#39;);&#xA;im.type = &#39;importmap&#39;;&#xA;im.textContent = JSON.stringify({&#xA;  imports: {&#xA;    &#39;my-library&#39;: Math.random() &amp;gt; 0.5 ? &#39;/my-awesome-library.mjs&#39; : &#39;/my-rad-library.mjs&#39;&#xA;  }&#xA;});&#xA;document.currentScript.after(im);&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;&amp;lt;script type=&#34;module&#34;&amp;gt;&#xA;import &#39;my-library&#39;; // will fetch the randomly-chosen URL&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A more realistic example might use this capability to assemble the import map based on feature detection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;&#xA;const importMap = {&#xA;  imports: {&#xA;    moment: &#39;/moment.mjs&#39;,&#xA;    lodash: someFeatureDetection() ?&#xA;      &#39;/lodash.mjs&#39; :&#xA;      &#39;/lodash-legacy-browsers.mjs&#39;&#xA;  }&#xA;};&#xA;&#xA;const im = document.createElement(&#39;script&#39;);&#xA;im.type = &#39;importmap&#39;;&#xA;im.textContent = JSON.stringify(importMap);&#xA;document.currentScript.after(im);&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;&amp;lt;script type=&#34;module&#34;&amp;gt;&#xA;import _ from &#34;lodash&#34;; // will fetch the right URL for this browser&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that (like other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; elements) modifying the contents of a &lt;code&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&lt;/code&gt; after it&#39;s already inserted in the document will not work. This is why we wrote the above example by assembling the contents of the import map before creating and inserting the &lt;code&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Scope&lt;/h3&gt; &#xA;&lt;p&gt;Import maps are an application-level thing, somewhat like service workers. (More formally, they would be per-module map, and thus per-realm.) They are not meant to be composed, but instead produced by a human or tool with a holistic view of your web application. For example, it would not make sense for a library to include an import map; libraries can simply reference modules by specifier, and let the application decide what URLs those specifiers map to.&lt;/p&gt; &#xA;&lt;p&gt;This, in addition to general simplicity, is in part what motivates the above restrictions on &lt;code&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Since an application&#39;s import map changes the resolution algorithm for every module in the module map, they are not impacted by whether a module&#39;s source text was originally from a cross-origin URL. If you load a module from a CDN that uses bare import specifiers, you&#39;ll need to know ahead of time what bare import specifiers that module adds to your app, and include them in your application&#39;s import map. (That is, you need to know what all of your application&#39;s transitive dependencies are.) It&#39;s important that control of which URLs are used for each package stay with the application author, so they can holistically manage versioning and sharing of modules.&lt;/p&gt; &#xA;&lt;h3&gt;Interaction with speculative parsing/fetching&lt;/h3&gt; &#xA;&lt;p&gt;Most browsers have a speculative HTML parser which tries to discover resources declared in HTML markup while the HTML parser is waiting for blocking scripts to be fetched and executed. This is not yet specified, although there are ongoing efforts to do so in &lt;a href=&#34;https://github.com/whatwg/html/pull/5959&#34;&gt;whatwg/html#5959&lt;/a&gt;. This section discusses some of the potential interactions to be aware of.&lt;/p&gt; &#xA;&lt;p&gt;First, note that although to our knowledge no browsers do so currently, it would be possible for a speculative parser to fetch &lt;code&gt;https://example.com/foo.mjs&lt;/code&gt; in the following example, while it waits for the blocking script &lt;code&gt;https://example.com/blocking-1.js&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;!-- This file is https://example.com/ --&amp;gt;&#xA;&amp;lt;script src=&#34;blocking-1.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script type=&#34;module&#34;&amp;gt;&#xA;import &#34;./foo.mjs&#34;;&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, a browser could speculatively fetch &lt;code&gt;https://example.com/foo.mjs&lt;/code&gt; and &lt;code&gt;https://example.com/bar.mjs&lt;/code&gt; in the following example, by parsing the import map as part of the speculative parsing process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;!-- This file is https://example.com/ --&amp;gt;&#xA;&amp;lt;script src=&#34;blocking-2.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&#xA;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;foo&#34;: &#34;./foo.mjs&#34;,&#xA;    &#34;https://other.example/bar.mjs&#34;: &#34;./bar.mjs&#34;&#xA;  }&#xA;}&#xA;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script type=&#34;module&#34;&amp;gt;&#xA;import &#34;foo&#34;;&#xA;import &#34;https://other.example/bar.mjs&#34;;&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One interaction to notice here is that browsers which do speculatively parse inline JS modules, but do not support import maps, would probably speculate incorrectly for this example: they might speculatively fetch &lt;code&gt;https://other.example/bar.mjs&lt;/code&gt;, instead of the &lt;code&gt;https://example.com/bar.mjs&lt;/code&gt; it is mapped to.&lt;/p&gt; &#xA;&lt;p&gt;More generally, import map-based speculations can be subject to the same sort of mistakes as other speculations. For example, if the contents of &lt;code&gt;blocking-1.js&lt;/code&gt; were&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const el = document.createElement(&#34;base&#34;);&#xA;el.href = &#34;/subdirectory/&#34;;&#xA;document.currentScript.after(el);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then the speculative fetch of &lt;code&gt;https://example.com/foo.mjs&lt;/code&gt; in the no-import map example would be wasted, as by the time came to perform the actual evaluation of the module, we&#39;d re-compute the relative specifier &lt;code&gt;&#34;./foo.mjs&#34;&lt;/code&gt; and realize that what&#39;s actually requested is &lt;code&gt;https://example.com/subdirectory/foo.mjs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Similarly for the import map case, if the contents of &lt;code&gt;blocking-2.js&lt;/code&gt; were&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.write(`&amp;lt;script type=&#34;importmap&#34;&amp;gt;&#xA;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;foo&#34;: &#34;./other-foo.mjs&#34;,&#xA;    &#34;https://other.example/bar.mjs&#34;: &#34;./other-bar.mjs&#34;&#xA;  }&#xA;}&#xA;&amp;lt;/script&amp;gt;`);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then the speculative fetches of &lt;code&gt;https://example.com/foo.mjs&lt;/code&gt; and &lt;code&gt;https://example.com/bar.mjs&lt;/code&gt; would be wasted, as the newly-written import map would be in effect instead of the one that was seen inline in the HTML.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element&lt;/h3&gt; &#xA;&lt;p&gt;When &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element is present in the document, all URLs and URL-like specifiers in the import map are converted to absolute URLs using the &lt;code&gt;href&lt;/code&gt; from &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;base href=&#34;https://www.unpkg.com/vue/dist/&#34;&amp;gt;&#xA;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&#xA;{&#xA;  &#34;imports&#34;: {&#xA;    &#34;vue&#34;: &#34;./vue.runtime.esm.js&#34;,&#xA;  }&#xA;}&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import(&#34;vue&#34;); // resolves to https://www.unpkg.com/vue/dist/vue.runtime.esm.js&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Feature detection&lt;/h2&gt; &#xA;&lt;p&gt;If the browser supports &lt;a href=&#34;https://html.spec.whatwg.org/multipage/scripting.html#htmlscriptelement&#34;&gt;HTMLScriptElement&lt;/a&gt;&#39;s &lt;a href=&#34;https://html.spec.whatwg.org/multipage/scripting.html#dom-script-supports&#34;&gt;supports(type)&lt;/a&gt; method, &lt;code&gt;HTMLScriptElement.supports(&#39;importmap&#39;)&lt;/code&gt; must return true.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (HTMLScriptElement.supports &amp;amp;&amp;amp; HTMLScriptElement.supports(&#39;importmap&#39;)) {&#xA;  console.log(&#39;Your browser supports import maps.&#39;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Alternatives considered&lt;/h2&gt; &#xA;&lt;h3&gt;The Node.js module resolution algorithm&lt;/h3&gt; &#xA;&lt;p&gt;Unlike in Node.js, in the browser we don&#39;t have the luxury of a reasonably-fast file system that we can crawl looking for modules. Thus, we cannot implement the &lt;a href=&#34;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&#34;&gt;Node module resolution algorithm&lt;/a&gt; directly; it would require performing multiple server round-trips for every &lt;code&gt;import&lt;/code&gt; statement, wasting bandwidth and time as we continue to get 404s. We need to ensure that every &lt;code&gt;import&lt;/code&gt; statement causes only one HTTP request; this necessitates some measure of precomputation.&lt;/p&gt; &#xA;&lt;h3&gt;A programmable resolution hook&lt;/h3&gt; &#xA;&lt;p&gt;Some have suggested customizing the browser&#39;s module resolution algorithm using a JavaScript hook to interpret each module specifier.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, this is fatal to performance; jumping into and back out of JavaScript for every edge of a module graph drastically slows down application startup. (Typical web applications have on the order of thousands of modules, with 3-4× that many import statements.) You can imagine various mitigations, such as restricting the calls to only bare import specifiers or requiring that the hook take batches of specifiers and return batches of URLs, but in the end nothing beats precomputation.&lt;/p&gt; &#xA;&lt;p&gt;Another issue with this is that it&#39;s hard to imagine a useful mapping algorithm a web developer could write, even if they were given this hook. Node.js has one, but it is based on repeatedly crawling the filesystem and checking if files exist; we as discussed above, that&#39;s infeasible on the web. The only situation in which a general algorithm would be feasible is if (a) you never needed per-subgraph customization, i.e. only one version of every module existed in your application; (b) tooling managed to arrange your modules ahead of time in some uniform, predictable fashion, so that e.g. the algorithm becomes &#34;return &lt;code&gt;/js/${specifier}.js&lt;/code&gt;&#34;. But if we&#39;re in this world anyway, a declarative solution would be simpler.&lt;/p&gt; &#xA;&lt;h3&gt;Ahead-of-time rewriting&lt;/h3&gt; &#xA;&lt;p&gt;One solution in use today (e.g. in the &lt;a href=&#34;https://unpkg.com/&#34;&gt;unpkg&lt;/a&gt; CDN via &lt;a href=&#34;https://www.npmjs.com/package/babel-plugin-unpkg&#34;&gt;babel-plugin-unpkg&lt;/a&gt;) is to rewrite all bare import specifiers to their appropriate absolute URLs ahead of time, using build tooling. This could also be done at install time, so that when you install a package using npm, it automatically rewrites the package&#39;s contents to use absolute or relative URLs instead of bare import specifiers.&lt;/p&gt; &#xA;&lt;p&gt;The problem with this approach is that it does not work with dynamic &lt;code&gt;import()&lt;/code&gt;, as it&#39;s impossible to statically analyze the strings passed to that function. You could inject a fixup that, e.g., changes every instance of &lt;code&gt;import(x)&lt;/code&gt; into &lt;code&gt;import(specifierToURL(x, import.meta.url))&lt;/code&gt;, where &lt;code&gt;specifierToURL&lt;/code&gt; is another function generated by the build tool. But in the end this is a fairly leaky abstraction, and the &lt;code&gt;specifierToURL&lt;/code&gt; function largely duplicates the work of this proposal anyway.&lt;/p&gt; &#xA;&lt;h3&gt;Service workers&lt;/h3&gt; &#xA;&lt;p&gt;At first glance, service workers seem like the right place to do this sort of resource translation. We&#39;ve talked in the past about finding some way to pass the specifier along with a service worker&#39;s fetch event, thus allowing it to give back an appropriate &lt;code&gt;Response&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, &lt;em&gt;service workers are not available on first load&lt;/em&gt;. Thus, they can&#39;t really be a part of the critical infrastructure used to load modules. They can only be used as a progressive enhancement on top of fetches that will otherwise generally work.&lt;/p&gt; &#xA;&lt;h3&gt;A convention-based flat mapping&lt;/h3&gt; &#xA;&lt;p&gt;If you have a simple applications with no need for scoped dependency resolution, and have a package installation tool which is comfortable rewriting paths on disk inside the package (unlike current versions of npm), you could get away with a much simpler mapping. For example, if your installation tool created a flat listing of the form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;node_modules_flattened/&#xA;  lodash/&#xA;    index.js&#xA;    core.js&#xA;    fp.js&#xA;  moment/&#xA;    index.js&#xA;  html-to-dom/&#xA;    index.js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then the only information you need is&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A base URL (in our app, &lt;code&gt;/node_modules_flattened/&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;The main module filename used (in our app, &lt;code&gt;index.js&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You could imagine a module import configuration format that only specified these things, or even only some subset (if we baked in assumptions for the others).&lt;/p&gt; &#xA;&lt;p&gt;This idea does not work for more complex applications which need scoped resolution, so we believe the full import map proposal is necessary. But it remains attractive for simple applications, and we wonder if there&#39;s a way to make the proposal also have an easy-mode that does not require listing all modules, but instead relies on conventions and tools to ensure minimal mapping is needed. Discuss in &lt;a href=&#34;https://github.com/WICG/import-maps/issues/7&#34;&gt;#7&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Adjacent concepts&lt;/h2&gt; &#xA;&lt;h3&gt;Supplying out-of-band metadata for each module&lt;/h3&gt; &#xA;&lt;p&gt;Several times now it&#39;s come up that people desire to supply metadata for each module; for example, &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&#34;&gt;integrity metadata&lt;/a&gt;, or fetching options. Although some have proposed doing this with an import statement, &lt;a href=&#34;https://docs.google.com/presentation/d/1qfoLTniLUVJ5YNFrha7BaVumAnW0ZgcCfUU8UbyyuYY/edit#slide=id.p&#34;&gt;careful consideration of the options&lt;/a&gt; leads to preferring an out-of-band manifest file.&lt;/p&gt; &#xA;&lt;p&gt;The import map &lt;em&gt;could&lt;/em&gt; be that manifest file. However, it may not be the best fit, for a few reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;As currently envisioned, most modules in an application would not have entries in the import map. The main use case is for modules you need to refer to by bare specifiers, or modules where you need to do something tricky like polyfilling or virtualizing. If we envisioned every module being in the map, we would not include convenience features like packages-via-trailing-slashes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All proposed metadata so far is applicable to any sort of resource, not just JavaScript modules. A solution should probably work at a more general level.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Further work&lt;/h2&gt; &#xA;&lt;h3&gt;Multiple import map support&lt;/h3&gt; &#xA;&lt;p&gt;It is natural for multiple &lt;code&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&lt;/code&gt;s to appear on a page, just as multiple &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;s of other types can. We would like to enable this in the future.&lt;/p&gt; &#xA;&lt;p&gt;The biggest challenge here is deciding how the multiple import maps compose. That is, given two import maps which both remap the same URL, or two scope definitions which cover the same URL prefix space, what should the affect on the page be? The current leading candidate is &lt;a href=&#34;https://github.com/WICG/import-maps/issues/137&#34;&gt;cascading resolution&lt;/a&gt;, which recasts import maps from being import specifier → URL mappings, to instead be a cascading series of import specifier → import specifier mappings, eventually bottoming out in a &#34;fetchable import specifier&#34; (essentially a URL).&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/WICG/import-maps/milestone/5&#34;&gt;these open issues&lt;/a&gt; for more discussion.&lt;/p&gt; &#xA;&lt;h3&gt;Programmatic API&lt;/h3&gt; &#xA;&lt;p&gt;Some use cases desire a way of reading or manipulating a realm&#39;s import map from script, instead of via inserting declarative &lt;code&gt;&amp;lt;script type=&#34;importmap&#34;&amp;gt;&lt;/code&gt; elements. Consider it an &#34;import map object model&#34;, similar to the CSS object model that allows one to manipulate the page&#39;s usually-declarative CSS rules.&lt;/p&gt; &#xA;&lt;p&gt;The challenges here are around how to reconcile the declarative import maps with any programmatic changes, as well as when in the page&#39;s lifecycle such an API can operate. In general, the simpler designs are less powerful and may meet fewer use cases.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/WICG/import-maps/milestone/8&#34;&gt;these open issues&lt;/a&gt; for more discussion and use cases where a programmatic API could help.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;import.meta.resolve()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The proposed &lt;code&gt;import.meta.resolve(specifier)&lt;/code&gt; function allows module scripts to resolve import specifiers to URLs at any time. See &lt;a href=&#34;https://github.com/whatwg/html/pull/5572&#34;&gt;whatwg/html#5572&lt;/a&gt; for more. This is related to import maps since it allows you to resolve &#34;package-relative&#34; resources, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const url = import.meta.resolve(&#34;somepackage/resource.json&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would give you the appropriately-mapped location of &lt;code&gt;resource.json&lt;/code&gt; within the &lt;code&gt;somepackage/&lt;/code&gt; namespace controlled by the page&#39;s import map.&lt;/p&gt; &#xA;&lt;h2&gt;Community polyfills and tooling&lt;/h2&gt; &#xA;&lt;p&gt;Several members of the community have been working on polyfills and tooling related to import maps. Here are the ones we know about:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/@import-maps/resolve&#34;&gt;@import-maps/resolve&lt;/a&gt; resolves a specifier relative to an import map.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/@jsenv/importmap-node-module&#34;&gt;@jsenv/importmap-node-module&lt;/a&gt; generates an import map from your &lt;code&gt;package.json&lt;/code&gt; and &lt;code&gt;node_modules/&lt;/code&gt; directories.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/@jsenv/importmap-eslint-resolver&#34;&gt;@jsenv/importmap-eslint-resolver&lt;/a&gt; enables import map resolution in &lt;a href=&#34;https://eslint.org/&#34;&gt;ESLint&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/@node-loader/import-maps&#34;&gt;@node-loader/import-maps&lt;/a&gt; is a &lt;a href=&#34;https://nodejs.org/dist/latest/docs/api/esm.html#esm_experimental_loaders&#34;&gt;Node.js loader&lt;/a&gt; for using import maps in Node.js.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/@web/dev-server-import-maps&#34;&gt;@web/dev-server-import-maps&lt;/a&gt; allows using import maps during development and testing with &lt;a href=&#34;https://www.npmjs.com/package/@web/dev-server&#34;&gt;@web/dev-server&lt;/a&gt; and &lt;a href=&#34;https://www.npmjs.com/package/@web/test-runner&#34;&gt;@web/test-runner&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/denoland/deno&#34;&gt;Deno&lt;/a&gt; is a JavaScript/TypeScript runtime with &lt;a href=&#34;https://deno.land/manual/linking_to_external_code/import_maps&#34;&gt;built-in support for import maps&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/guybedford/es-module-shims&#34;&gt;es-module-shims&lt;/a&gt; provides an import maps polyfill for browsers with basic ES modules support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/single-spa/import-map-deployer&#34;&gt;import-map-deployer&lt;/a&gt; is designed for updating import map files from CI&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/import-map-overrides&#34;&gt;import-map-overrides&lt;/a&gt; allows using import maps to improve development flow by pointing to local versions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/importly&#34;&gt;importly&lt;/a&gt; generates an import map from a &lt;code&gt;package.json&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/systemjs/systemjs&#34;&gt;SystemJS&lt;/a&gt; provides a polyfill-like workflow for using import maps in older browsers with the System module format and &lt;code&gt;&amp;lt;script type=&#34;systemjs-importmap&#34;&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/webpack-import-map-plugin&#34;&gt;webpack-import-map-plugin&lt;/a&gt; generates import maps for the output of &lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;, especially useful for the &lt;a href=&#34;https://raw.githubusercontent.com/WICG/import-maps/main/#mapping-away-hashes-in-script-filenames&#34;&gt;hashing use case&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://crates.io/crates/import_map&#34;&gt;import_map&lt;/a&gt; is a Rust crate implementing the specification. Used by Deno.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Feel free to send a pull request with more! Also, you can use &lt;a href=&#34;https://github.com/WICG/import-maps/issues/146&#34;&gt;#146&lt;/a&gt; in the issue tracker for discussion about this space.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;This document originated out of a day-long sprint involving &lt;a href=&#34;https://github.com/domenic&#34;&gt;@domenic&lt;/a&gt;, &lt;a href=&#34;https://github.com/hiroshige-g&#34;&gt;@hiroshige-g&lt;/a&gt;, &lt;a href=&#34;https://github.com/justinfagnani&#34;&gt;@justinfagnani&lt;/a&gt;, &lt;a href=&#34;https://github.com/MylesBorins&#34;&gt;@MylesBorins&lt;/a&gt;, and &lt;a href=&#34;https://github.com/nyaxt&#34;&gt;@nyaxt&lt;/a&gt;. Since then, &lt;a href=&#34;https://github.com/guybedford&#34;&gt;@guybedford&lt;/a&gt; has been instrumental in prototyping and driving forward discussion on this proposal.&lt;/p&gt; &#xA;&lt;p&gt;Thanks also to all of the contributors on the issue tracker for their help in evolving the proposal!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Roll20/roll20-character-sheets</title>
    <updated>2022-08-17T01:33:37Z</updated>
    <id>tag:github.com,2022-08-17:/Roll20/roll20-character-sheets</id>
    <link href="https://github.com/Roll20/roll20-character-sheets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Character sheet templates created by the community for use in Roll20 VTT. Submit a ticket at roll20.net/help if critical hotfixes are to be requested.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://roll20.net&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/Roll20%20Logo.png&#34; alt=&#34;Roll20 logo&#34; title=&#34;Roll20&#34; height=&#34;60&#34;&gt; &lt;/a&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/last-commit/Roll20/roll20-character-sheets/master?color=ff0066&amp;amp;label=last%20updated&#34; alt=&#34;GitHub last commit (branch)&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/contributors/Roll20/roll20-character-sheets?color=ff0066&#34; alt=&#34;GitHub contributors&#34;&gt; &lt;img src=&#34;https://img.shields.io/tokei/lines/github/Roll20/roll20-character-sheets?color=ff0066&amp;amp;label=lines%20of%20code&#34; alt=&#34;Lines of code&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/repo-size/Roll20/roll20-character-sheets?color=ff0066&#34; alt=&#34;GitHub repo size&#34;&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1&gt;Roll20 Character Sheets&lt;/h1&gt; &#xA;&lt;p&gt;Roll20.net is the easy-to-use virtual tabletop that brings pen and paper gaming to the web the right way. Built on a powerful platform of tools, yet elegantly simple, it focuses on enhancing what makes tabletop gaming great: storytelling and camaraderie.&lt;/p&gt; &#xA;&lt;p&gt;This repository is the collection of all the community-contributed character sheets that are available for use on &lt;a href=&#34;https://roll20.net&#34;&gt;Roll20&lt;/a&gt;. These are, mostly, created for free, for use by the community, and represent dozens, if not hundreds of hours of effort on the parts of their creators.&lt;/p&gt; &#xA;&lt;p&gt;This repository consists of over 📜 &lt;strong&gt;800 community contributed sheets&lt;/strong&gt;, from over 🧑 &lt;strong&gt;300 contributors&lt;/strong&gt;, who have written over ⌨️ &lt;strong&gt;400,000 lines of code&lt;/strong&gt;. This is an 🦦 &lt;strong&gt;otter&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Community Conduct&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://help.roll20.net/hc/en-us/articles/360037254334-Community-Code-of-Conduct&#34;&gt;Roll20 Code of Conduct&lt;/a&gt; applies to your participation on this repository.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Following the Roll20 Code of Conduct means &lt;strong&gt;no racism, no sexism, no hate speech, no backseat gaming, no personal attacks, no transphobia, no misgendering, no ableism, no anti-LGBTQIA+ sentiments (and so on) are allowed.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#roll20-character-sheets&#34;&gt;Roll20 Character Sheets&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#community-conduct&#34;&gt;Community Conduct&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#table-of-contents&#34;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#contributing&#34;&gt;Contributing&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#improving-existing-character-sheets&#34;&gt;Improving Existing Character Sheets&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#starting-a-new-character-sheet&#34;&gt;Starting a New Character Sheet&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#submission-guidelines&#34;&gt;Submission Guidelines&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#release-cadence&#34;&gt;Release Cadence&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#internationalization--translations&#34;&gt;Internationalization &amp;amp; Translations&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Roll20/roll20-character-sheets/master/#contact&#34;&gt;Contact&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;There are many ways in which you can contribute to these sheets, and to the health of the space:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Roll20/roll20-character-sheets/issues&#34;&gt;Report issues and bugs&lt;/a&gt; you encounter when using the sheets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Roll20/roll20-character-sheets/pulls&#34;&gt;Review sheet code changes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Review and contribute to the documentation on the &lt;a href=&#34;https://wiki.roll20.net/Building_Character_Sheets&#34;&gt;community wiki&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Write or contribute to a new or existing character sheet!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;If you are interested in contributing code, fixing issues, or adding content, the &lt;a href=&#34;https://wiki.roll20.net/Building_Character_Sheets&#34;&gt;Roll20 Wiki: Building Character Sheets&lt;/a&gt; documentation is a great place to start familiarizing yourself with the space.&lt;/p&gt; &#xA;&lt;h3&gt;Improving Existing Character Sheets&lt;/h3&gt; &#xA;&lt;p&gt;Before you submit work to the repository, please ensure that there is not already a sheet that covers the game you are intending to create a sheet for. If there is already one, fear not! Be bold and suggest some changes.&lt;/p&gt; &#xA;&lt;p&gt;In general, this should look something like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fork the repository.&lt;/li&gt; &#xA; &lt;li&gt;Make your changes to the sheet in question.&lt;/li&gt; &#xA; &lt;li&gt;Make the Pull Request.&lt;/li&gt; &#xA; &lt;li&gt;Invite previous contributors to review your changes.&lt;/li&gt; &#xA; &lt;li&gt;Once everyone is satisfied with the changes, we can merge the changes into the existing sheet.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We have learned from experience that it is better to have a single sheet that is contributed to by a number of people, rather than perpetuating the cycle of a contributing a sheet, losing interest, moving on, and then the next contributor creating an entirely new sheet. This is a collaborative community, please feel empowered to collaborate!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.roll20.net/Github&#34;&gt;Beginner&#39;s Guide to GitHub&lt;/a&gt; - for Roll20 character sheets&lt;/p&gt; &#xA;&lt;h3&gt;Starting a New Character Sheet&lt;/h3&gt; &#xA;&lt;p&gt;If you have a burning desire to start from scratch, and there isn&#39;t already an existing sheet for a game or system, then it&#39;s time to embark upon a voyage of discovery. ⛵ There is plenty of documentation available on the &lt;a href=&#34;https://help.roll20.net/hc/en-us/articles/360037773413&#34;&gt;Roll20 Help Center&lt;/a&gt; and on the &lt;a href=&#34;https://wiki.roll20.net/Building_Character_Sheets&#34;&gt;community wiki&lt;/a&gt;, but here&#39;s a quick primer to get you started.&lt;/p&gt; &#xA;&lt;p&gt;A character sheet, at a minimum requires four files in an appropriately named subfolder of the repo:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&amp;lt;sheetname&amp;gt;.html&lt;/strong&gt; - This HTML file describes the structure and functionality of your character sheet. It might consist of &lt;a href=&#34;https://wiki.roll20.net/Building_Character_Sheets#Text_.26_Numbers&#34;&gt;inputs to store user data&lt;/a&gt;, &lt;a href=&#34;https://wiki.roll20.net/Button#Roll_Button&#34;&gt;buttons to make rolls&lt;/a&gt; to the VTT, &lt;a href=&#34;https://wiki.roll20.net/Repeating_Sections&#34;&gt;repeating sections&lt;/a&gt; to store lists of information (like inventory items), or more advanced elements such as &lt;a href=&#34;https://wiki.roll20.net/Building_Character_Sheets/Roll_Templates&#34;&gt;roll templates&lt;/a&gt; or &lt;a href=&#34;https://wiki.roll20.net/Sheet_Worker_Scripts&#34;&gt;sheet workers&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&amp;lt;sheetname&amp;gt;.css&lt;/strong&gt; - This CSS file is primarily responsible for adding styles to your character sheet. However, CSS can be very versatile and such is used for &lt;a href=&#34;https://wiki.roll20.net/CSS_Wizardry#Tabs&#34;&gt;much&lt;/a&gt;, &lt;a href=&#34;https://wiki.roll20.net/CSS_Wizardry#Custom_Progress_Bar&#34;&gt;much&lt;/a&gt;, &lt;a href=&#34;https://wiki.roll20.net/CSS_Wizardry#Clocks&#34;&gt;much&lt;/a&gt; more.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;preview.(jpg/png/gif)&lt;/strong&gt; - This image file is what users will see as a preview, before selecting your sheet.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;sheet.json&lt;/strong&gt; - This JSON file includes metadata about the sheet, including the filenames for your sheet, your credit as author(s), and much more. It&#39;s integral to your sheet being implemented correctly that this format is followed. Please see &lt;a href=&#34;https://wiki.roll20.net/Sheet.json&#34;&gt;this document&lt;/a&gt; for more information.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Submission Guidelines&lt;/h3&gt; &#xA;&lt;p&gt;All contributions to this repository must meet the minimum requirements outlined in &lt;a href=&#34;https://help.roll20.net/hc/en-us/articles/360037773453&#34;&gt;this article&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Release Cadence&lt;/h3&gt; &#xA;&lt;p&gt;Pull Requests are reviewed &lt;em&gt;at least&lt;/em&gt; weekly by 00:00 UTC on Thursdays, although cadence is often more frequent.&lt;/p&gt; &#xA;&lt;p&gt;Once a Pull Request has been merged, changes should be served on &lt;a href=&#34;https://roll20.net&#34;&gt;Roll20.net&lt;/a&gt; within approximately ten minutes. Contributors are encouraged to open a GitHub issue if their changes haven&#39;t appeared 24 hours after the Pull Request has been merged.&lt;/p&gt; &#xA;&lt;h3&gt;Internationalization &amp;amp; Translations&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;a href=&#34;https://crowdin.com/&#34;&gt;Crowdin&lt;/a&gt; to crowdsource and manage translations for various aspects of our site.&lt;/p&gt; &#xA;&lt;p&gt;Check out the Help Center articles and Community Wiki documentation below to learn about translations and to help us make Roll20 accessible in as many languages as possible!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://roll20.zendesk.com/hc/en-us/articles/360058423993-How-to-Become-a-Translation-Volunteer&#34;&gt;How to Become a Translation Volunteer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://roll20.zendesk.com/hc/en-us/articles/360057432414-How-to-Translate-Content-on-Crowdin&#34;&gt;How to Translate Content on Crowdin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wiki.roll20.net/Character_Sheet_i18n&#34;&gt;Roll20 Community Wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Sheet translations submitted outside of Crowdin will not be accepted and/or will be overwritten by Crowdin.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;All of the code (HTML/CSS) of the sheets in this repository is released under the MIT license (see &lt;a href=&#34;https://github.com/Roll20/roll20-character-sheets/raw/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details). If you contribute a new sheet or help improve an existing sheet, you agree that your contribution is released under the MIT License as well.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;For urgent concerns, problems, or hotfixes, please submit a ticket at &lt;a href=&#34;https://roll20.net/help&#34;&gt;https://roll20.net/help&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>