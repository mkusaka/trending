<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-12T01:31:01Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tc39/proposal-async-context</title>
    <updated>2024-06-12T01:31:01Z</updated>
    <id>tag:github.com,2024-06-12:/tc39/proposal-async-context</id>
    <link href="https://github.com/tc39/proposal-async-context" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Async Context for JavaScript&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Async Context for JavaScript&lt;/h1&gt; &#xA;&lt;p&gt;Status: Stage 2&lt;/p&gt; &#xA;&lt;p&gt;Champions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Andreu Botella (&lt;a href=&#34;https://github.com/andreubotella&#34;&gt;@andreubotella&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Chengzhong Wu (&lt;a href=&#34;https://github.com/legendecas&#34;&gt;@legendecas&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Justin Ridgewell (&lt;a href=&#34;https://github.com/jridgewell&#34;&gt;@jridgewell&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Discuss with the group and join the bi-weekly via &lt;a href=&#34;https://matrix.to/#/#tc39-async-context:matrix.org&#34;&gt;#tc39-async-context&lt;/a&gt; matrix room (&lt;a href=&#34;https://github.com/tc39/how-we-work/raw/main/matrix-guide.md&#34;&gt;Matrix Guide&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h1&gt;Motivation&lt;/h1&gt; &#xA;&lt;p&gt;When writing synchronous JavaScript code, a reasonable expectation from developers is that values are consistently available over the life of the synchronous execution. These values may be passed explicitly (i.e., as parameters to the function or some nested function, or as a closed over variable), or implicitly (extracted from the call stack, e.g., outside the scope as a external object that the function or nested function has access to).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function program() {&#xA;  const value = { key: 123 };&#xA;&#xA;  // Explicitly pass the value to function via parameters.&#xA;  // The value is available for the full execution of the function.&#xA;  explicit(value);&#xA;&#xA;  // Explicitly captured by the closure.&#xA;  // The value is available for as long as the closure exists.&#xA;  const closure = () =&amp;gt; {&#xA;    assert.equal(value.key, 123);&#xA;  };&#xA;&#xA;  // Implicitly propagated via shared reference to an external variable.&#xA;  // The value is available as long as the shared reference is set.&#xA;  // In this case, for as long as the synchronous execution of the&#xA;  // try-finally code.&#xA;  try {&#xA;    shared = value;&#xA;    implicit();&#xA;  } finally {&#xA;    shared = undefined;&#xA;  }&#xA;}&#xA;&#xA;function explicit(value) {&#xA;  assert.equal(value.key, 123);&#xA;}&#xA;&#xA;let shared;&#xA;function implicit() {&#xA;  assert.equal(shared.key, 123);&#xA;}&#xA;&#xA;program();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Async/await syntax improved in ergonomics of writing asynchronous JS. It allows developers to think of asynchronous code in terms of synchronous code. The behavior of the event loop executing the code remains the same as in a promise chain. However, passing code through the event loop loses &lt;em&gt;implicit&lt;/em&gt; information from the call site because we end up replacing the call stack. In the case of async/await syntax, the loss of implicit call site information becomes invisible due to the visual similarity to synchronous code -- the only indicator of a barrier is the &lt;code&gt;await&lt;/code&gt; keyword. As a result, code that &#34;just works&#34; in synchronous JS has unexpected behavior in asynchronous JS while appearing almost exactly the same.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function program() {&#xA;  const value = { key: 123 };&#xA;&#xA;  // Implicitly propagated via shared reference to an external variable.&#xA;  // The value is only available only for the _synchronous execution_ of&#xA;  // the try-finally code.&#xA;  try {&#xA;    shared = value;&#xA;    implicit();&#xA;  } finally {&#xA;    shared = undefined;&#xA;  }&#xA;}&#xA;&#xA;let shared;&#xA;async function implicit() {&#xA;  // The shared reference is still set to the correct value.&#xA;  assert.equal(shared.key, 123);&#xA;&#xA;  await 1;&#xA;&#xA;  // After awaiting, the shared reference has been reset to `undefined`.&#xA;  // We&#39;ve lost access to our original value.&#xA;  assert.throws(() =&amp;gt; {&#xA;    assert.equal(shared.key, 123);&#xA;  });&#xA;}&#xA;&#xA;program();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above problem existed already in promise callback-style code, but the introduction of async/await syntax has aggravated it by making the stack replacement almost undetectable. This problem is not generally solvable with user land code alone. For instance, if the call stack has already been replaced by the time the function is called, that function will never have a chance to capture the shared reference.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function program() {&#xA;  const value = { key: 123 };&#xA;&#xA;  // Implicitly propagated via shared reference to an external variable.&#xA;  // The value is only available only for the _synchronous execution_ of&#xA;  // the try-finally code.&#xA;  try {&#xA;    shared = value;&#xA;    setTimeout(implicit, 0);&#xA;  } finally {&#xA;    shared = undefined;&#xA;  }&#xA;}&#xA;&#xA;let shared;&#xA;function implicit() {&#xA;  // By the time this code is executed, the shared reference has already&#xA;  // been reset. There is no way for `implicit` to solve this because&#xA;  // because the bug is caused (accidentally) by the `program` function.&#xA;  assert.throws(() =&amp;gt; {&#xA;    assert.equal(shared.key, 123);&#xA;  });&#xA;}&#xA;&#xA;program();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Furthermore, the async/await syntax bypasses the userland Promises and makes it impossible for existing tools like &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-async-context/master/#zonesjs&#34;&gt;Zone.js&lt;/a&gt; that &lt;a href=&#34;https://github.com/angular/angular/raw/main/packages/zone.js/STANDARD-APIS.md&#34;&gt;instruments&lt;/a&gt; the &lt;code&gt;Promise&lt;/code&gt; to work with it without transpilation.&lt;/p&gt; &#xA;&lt;p&gt;This proposal introduces a general mechanism by which lost implicit call site information can be captured and used across transitions through the event loop, while allowing the developer to write async code largely as they do in cases without implicit information. The goal is to reduce the mental burden currently required for special handling async code in such cases.&lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;p&gt;This proposal introduces APIs to propagate a value through asynchronous code, such as a promise continuation or async callbacks.&lt;/p&gt; &#xA;&lt;p&gt;Compared to the &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-async-context/master/#prior-arts&#34;&gt;Prior Arts&lt;/a&gt;, this proposal identifies the following features as non-goals:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Async tasks scheduling and interception.&lt;/li&gt; &#xA; &lt;li&gt;Error handling &amp;amp; bubbling through async stacks.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Proposed Solution&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;AsyncContext&lt;/code&gt; is designed as a value store for context propagation across logically-connected sync/async code execution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;namespace AsyncContext {&#xA;  class Variable&amp;lt;T&amp;gt; {&#xA;    constructor(options: AsyncVariableOptions&amp;lt;T&amp;gt;);&#xA;    get name(): string;&#xA;    get(): T | undefined;&#xA;    run&amp;lt;R&amp;gt;(value: T, fn: (...args: any[])=&amp;gt; R, ...args: any[]): R;&#xA;  }&#xA;  interface AsyncVariableOptions&amp;lt;T&amp;gt; {&#xA;    name?: string;&#xA;    defaultValue?: T;&#xA;  }&#xA;&#xA;  class Snapshot {&#xA;    constructor();&#xA;    run&amp;lt;R&amp;gt;(fn: (...args: any[]) =&amp;gt; R, ...args: any[]): R;&#xA;    static wrap&amp;lt;T, R&amp;gt;(fn: (this: T, ...args: any[]) =&amp;gt; R): (this: T, ...args: any[]) =&amp;gt; R;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;AsyncContext.Variable&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Variable&lt;/code&gt; is a container for a value that is associated with the current execution flow. The value is propagated through async execution flows, and can be snapshot and restored with &lt;code&gt;Snapshot&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Variable.prototype.run()&lt;/code&gt; and &lt;code&gt;Variable.prototype.get()&lt;/code&gt; sets and gets the current value of an async execution flow.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const asyncVar = new AsyncContext.Variable();&#xA;&#xA;// Sets the current value to &#39;top&#39;, and executes the `main` function.&#xA;asyncVar.run(&#34;top&#34;, main);&#xA;&#xA;function main() {&#xA;  // AsyncContext.Variable is maintained through other platform queueing.&#xA;  setTimeout(() =&amp;gt; {&#xA;    console.log(asyncVar.get()); // =&amp;gt; &#39;top&#39;&#xA;&#xA;    asyncVar.run(&#34;A&#34;, () =&amp;gt; {&#xA;      console.log(asyncVar.get()); // =&amp;gt; &#39;A&#39;&#xA;&#xA;      setTimeout(() =&amp;gt; {&#xA;        console.log(asyncVar.get()); // =&amp;gt; &#39;A&#39;&#xA;      }, randomTimeout());&#xA;    });&#xA;  }, randomTimeout());&#xA;&#xA;  // AsyncContext.Variable runs can be nested.&#xA;  asyncVar.run(&#34;B&#34;, () =&amp;gt; {&#xA;    console.log(asyncVar.get()); // =&amp;gt; &#39;B&#39;&#xA;&#xA;    setTimeout(() =&amp;gt; {&#xA;      console.log(asyncVar.get()); // =&amp;gt; &#39;B&#39;&#xA;    }, randomTimeout());&#xA;  });&#xA;&#xA;  // AsyncContext.Variable was restored after the previous run.&#xA;  console.log(asyncVar.get()); // =&amp;gt; &#39;top&#39;&#xA;}&#xA;&#xA;function randomTimeout() {&#xA;  return Math.random() * 1000;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: There are controversial thought on the dynamic scoping and &lt;code&gt;Variable&lt;/code&gt;, checkout &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-async-context/master/SCOPING.md&#34;&gt;SCOPING.md&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Hosts are expected to use the infrastructure in this proposal to allow tracking not only asynchronous callstacks, but other ways to schedule jobs on the event loop (such as &lt;code&gt;setTimeout&lt;/code&gt;) to maximize the value of these use cases.&lt;/p&gt; &#xA;&lt;p&gt;A detailed example of use cases can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-async-context/master/USE-CASES.md&#34;&gt;Use cases document&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;AsyncContext.Snapshot&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Snapshot&lt;/code&gt; allows you to opaquely capture the current values of all &lt;code&gt;Variable&lt;/code&gt;s and execute a function at a later time as if those values were still the current values (a snapshot and restore).&lt;/p&gt; &#xA;&lt;p&gt;Note that even with &lt;code&gt;Snapshot&lt;/code&gt;, you can only access the value associated with a &lt;code&gt;Variable&lt;/code&gt; instance if you have access to that instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const asyncVar = new AsyncContext.Variable();&#xA;&#xA;let snapshot&#xA;asyncVar.run(&#34;A&#34;, () =&amp;gt; {&#xA;  // Captures the state of all AsyncContext.Variable&#39;s at this moment.&#xA;  snapshot = new AsyncContext.Snapshot();&#xA;});&#xA;&#xA;asyncVar.run(&#34;B&#34;, () =&amp;gt; {&#xA;  console.log(asyncVar.get()); // =&amp;gt; &#39;B&#39;&#xA;&#xA;  // The snapshot will restore all AsyncContext.Variable to their snapshot&#xA;  // state and invoke the wrapped function. We pass a function which it will&#xA;  // invoke.&#xA;  snapshot.run(() =&amp;gt; {&#xA;    // Despite being lexically nested inside &#39;B&#39;, the snapshot restored us to&#xA;    // to the snapshot &#39;A&#39; state.&#xA;    console.log(asyncVar.get()); // =&amp;gt; &#39;A&#39;&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Snapshot&lt;/code&gt; is useful for implementing APIs that logically &#34;schedule&#34; a callback, so the callback will be called with the context that it logically belongs to, regardless of the context under which it actually runs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let queue = [];&#xA;&#xA;export function enqueueCallback(cb: () =&amp;gt; void) {&#xA;  // Each callback is stored with the context at which it was enqueued.&#xA;  const snapshot = new AsyncContext.Snapshot();&#xA;  queue.push(() =&amp;gt; snapshot.run(cb));&#xA;}&#xA;&#xA;runWhenIdle(() =&amp;gt; {&#xA;  // All callbacks in the queue would be run with the current context if they&#xA;  // hadn&#39;t been wrapped.&#xA;  for (const cb of queue) {&#xA;    cb();&#xA;  }&#xA;  queue = [];&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A detailed explanation of why &lt;code&gt;AsyncContext.Snapshot&lt;/code&gt; is a requirement can be found in &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-async-context/master/SNAPSHOT.md&#34;&gt;SNAPSHOT.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;AsyncContext.Snapshot.wrap&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;AsyncContext.Snapshot.wrap&lt;/code&gt; is a helper which captures the current values of all &lt;code&gt;Variable&lt;/code&gt;s and returns a wrapped function. When invoked, this wrapped function restores the state of all &lt;code&gt;Variable&lt;/code&gt;s and executes the inner function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const asyncVar = new AsyncContext.Variable();&#xA;&#xA;function fn() {&#xA;  return asyncVar.get();&#xA;}&#xA;&#xA;let wrappedFn;&#xA;asyncVar.run(&#34;A&#34;, () =&amp;gt; {&#xA;  // Captures the state of all AsyncContext.Variable&#39;s at this moment, returning&#xA;  // wrapped closure that restores that state.&#xA;  wrappedFn = AsyncContext.Snapshot.wrap(fn)&#xA;});&#xA;&#xA;&#xA;console.log(fn()); // =&amp;gt; undefined&#xA;console.log(wrappedFn()); // =&amp;gt; &#39;A&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can think of this as a more convenient version of &lt;code&gt;Snapshot&lt;/code&gt;, where only a single function needs to be wrapped. It also serves as a convenient way for consumers of libraries that don&#39;t support &lt;code&gt;AsyncContext&lt;/code&gt; to ensure that function is executed in the correct execution context.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// User code that uses a legacy library&#xA;const asyncVar = new AsyncContext.Variable();&#xA;&#xA;function fn() {&#xA;    return asyncVar.get();&#xA;}&#xA;&#xA;asyncVar.run(&#34;A&#34;, () =&amp;gt; {&#xA;    defer(fn); // setTimeout schedules during &#34;A&#34; context.&#xA;})&#xA;asyncVar.run(&#34;B&#34;, () =&amp;gt; {&#xA;    defer(fn); // setTimeout is not called, fn will still see &#34;A&#34; context.&#xA;})&#xA;asyncVar.run(&#34;C&#34;, () =&amp;gt; {&#xA;    const wrapped = AsyncContext.Snapshot.wrap(fn);&#xA;    defer(wrapped); // wrapped callback captures &#34;C&#34; context.&#xA;})&#xA;&#xA;&#xA;// Some legacy library that queues multiple callbacks per macrotick&#xA;// Because the setTimeout is called a single time per queue batch,&#xA;// all callbacks will be invoked with _that_ context regardless of&#xA;// whatever context is active during the call to `defer`.&#xA;const queue = [];&#xA;function defer(callback) {&#xA;    if (queue.length === 0) setTimeout(processQueue, 1);&#xA;    queue.push(callback);&#xA;}&#xA;function processQueue() {&#xA;    for (const cb of queue) {&#xA;        cb();&#xA;    }&#xA;    queue.length = 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;h2&gt;Determine the initiator of a task&lt;/h2&gt; &#xA;&lt;p&gt;Application monitoring tools like OpenTelemetry save their tracing spans in the &lt;code&gt;AsyncContext.Variable&lt;/code&gt; and retrieve the span when they need to determine what started this chain of interaction.&lt;/p&gt; &#xA;&lt;p&gt;These libraries can not intrude the developer APIs for seamless monitoring. The tracing span doesn&#39;t need to be manually passing around by usercodes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// tracer.js&#xA;&#xA;const asyncVar = new AsyncContext.Variable();&#xA;export function run(cb) {&#xA;  // (a)&#xA;  const span = {&#xA;    startTime: Date.now(),&#xA;    traceId: randomUUID(),&#xA;    spanId: randomUUID(),&#xA;  };&#xA;  asyncVar.run(span, cb);&#xA;}&#xA;&#xA;export function end() {&#xA;  // (b)&#xA;  const span = asyncVar.get();&#xA;  span?.endTime = Date.now();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// my-app.js&#xA;import * as tracer from &#34;./tracer.js&#34;;&#xA;&#xA;button.onclick = (e) =&amp;gt; {&#xA;  // (1)&#xA;  tracer.run(() =&amp;gt; {&#xA;    fetch(&#34;https://example.com&#34;).then((res) =&amp;gt; {&#xA;      // (2)&#xA;&#xA;      return processBody(res.body).then((data) =&amp;gt; {&#xA;        // (3)&#xA;&#xA;        const dialog = html`&amp;lt;dialog&amp;gt;&#xA;          Here&#39;s some cool data: ${data} &amp;lt;button&amp;gt;OK, cool&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/dialog&amp;gt;`;&#xA;        dialog.show();&#xA;&#xA;        tracer.end();&#xA;      });&#xA;    });&#xA;  });&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; don&#39;t share same lexical scope with actual code functions, and they are capable of async reentrance thus capable of concurrent multi-tracking.&lt;/p&gt; &#xA;&lt;h2&gt;Transitive task attribution&lt;/h2&gt; &#xA;&lt;p&gt;User tasks can be scheduled with attributions. With &lt;code&gt;AsyncContext.Variable&lt;/code&gt;, task attributions are propagated in the async task flow and sub-tasks can be scheduled with the same priority.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const scheduler = {&#xA;  asyncVar: new AsyncContext.Variable(),&#xA;  postTask(task, options) {&#xA;    // In practice, the task execution may be deferred.&#xA;    // Here we simply run the task immediately.&#xA;    return this.asyncVar.run({ priority: options.priority }, task);&#xA;  },&#xA;  currentTask() {&#xA;    return this.asyncVar.get() ?? { priority: &#34;default&#34; };&#xA;  },&#xA;};&#xA;&#xA;const res = await scheduler.postTask(task, { priority: &#34;background&#34; });&#xA;console.log(res);&#xA;&#xA;async function task() {&#xA;  // Fetch remains background priority by referring to scheduler.currentTask().&#xA;  const resp = await fetch(&#34;/hello&#34;);&#xA;  const text = await resp.text();&#xA;&#xA;  scheduler.currentTask(); // =&amp;gt; { priority: &#39;background&#39; }&#xA;  return doStuffs(text);&#xA;}&#xA;&#xA;async function doStuffs(text) {&#xA;  // Some async calculation...&#xA;  return text;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;User-land queues&lt;/h2&gt; &#xA;&lt;p&gt;User-land queues can be implemented with &lt;code&gt;AsyncContext.Snapshot&lt;/code&gt; to propagate the values of all &lt;code&gt;AsyncContext.Variable&lt;/code&gt;s without access to any of them. This allows the user-land queue to be implemented in a way that is decoupled from consumers of &lt;code&gt;AsyncContext.Variable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// The scheduler doesn&#39;t access to any AsyncContext.Variable.&#xA;const scheduler = {&#xA;  queue: [],&#xA;  postTask(task) {&#xA;    // Each callback is stored with the context at which it was enqueued.&#xA;    const snapshot = new AsyncContext.Snapshot();&#xA;    queue.push(() =&amp;gt; snapshot.run(task));&#xA;  },&#xA;  runWhenIdle() {&#xA;    // All callbacks in the queue would be run with the current context if they&#xA;    // hadn&#39;t been wrapped.&#xA;    for (const cb of this.queue) {&#xA;      cb();&#xA;    }&#xA;    this.queue = [];&#xA;  }&#xA;};&#xA;&#xA;function userAction() {&#xA;  scheduler.postTask(function userTask() {&#xA;    console.log(traceContext.get());&#xA;  });&#xA;}&#xA;&#xA;// Tracing libraries can use AsyncContext.Variable to store tracing contexts.&#xA;const traceContext = new AsyncContext.Variable();&#xA;traceContext.run(&#34;trace-id-a&#34;, userAction);&#xA;traceContext.run(&#34;trace-id-b&#34;, userAction);&#xA;&#xA;scheduler.runWhenIdle();&#xA;// The userTask will be run with the trace context it was enqueued with.&#xA;// =&amp;gt; &#39;trace-id-a&#39;&#xA;// =&amp;gt; &#39;trace-id-b&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;h2&gt;Why take a function in &lt;code&gt;run&lt;/code&gt;?&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Variable.prototype.run&lt;/code&gt; and &lt;code&gt;Snapshot.prototype.run&lt;/code&gt; methods take a function to execute because it ensures async context variables will always contain consistent values in a given execution flow. Any modification must be taken in a sub-graph of an async execution flow, and can not affect their parent or sibling scopes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const asyncVar = new AsyncContext.Variable();&#xA;asyncVar.run(&#34;A&#34;, async () =&amp;gt; {&#xA;  asyncVar.get(); // =&amp;gt; &#39;A&#39;&#xA;&#xA;  // ...arbitrary synchronous codes.&#xA;  // ...or await-ed asynchronous calls.&#xA;&#xA;  // The value can not be modified at this point.&#xA;  asyncVar.get(); // =&amp;gt; &#39;A&#39;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This increases the integrity of async context variables, and makes them easier to reason about where a value of an async variable comes from.&lt;/p&gt; &#xA;&lt;h1&gt;Prior Arts&lt;/h1&gt; &#xA;&lt;h2&gt;zones.js&lt;/h2&gt; &#xA;&lt;p&gt;Zones proposed a &lt;code&gt;Zone&lt;/code&gt; object, which has the following API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Zone {&#xA;  constructor({ name, parent });&#xA;&#xA;  name;&#xA;  get parent();&#xA;&#xA;  fork({ name });&#xA;  run(callback);&#xA;  wrap(callback);&#xA;&#xA;  static get current();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The concept of the &lt;em&gt;current zone&lt;/em&gt;, reified as &lt;code&gt;Zone.current&lt;/code&gt;, is crucial. Both &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;wrap&lt;/code&gt; are designed to manage running the current zone:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;z.run(callback)&lt;/code&gt; will set the current zone to &lt;code&gt;z&lt;/code&gt; for the duration of &lt;code&gt;callback&lt;/code&gt;, resetting it to its previous value afterward. This is how you &#34;enter&#34; a zone.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;z.wrap(callback)&lt;/code&gt; produces a new function that essentially performs &lt;code&gt;z.run(callback)&lt;/code&gt; (passing along arguments and this, of course).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;em&gt;current zone&lt;/em&gt; is the async context that propagates with all our operations. In our above example, sites &lt;code&gt;(1)&lt;/code&gt; through &lt;code&gt;(6)&lt;/code&gt; would all have the same value of &lt;code&gt;Zone.current&lt;/code&gt;. If a developer had done something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const loadZone = Zone.current.fork({ name: &#34;loading zone&#34; });&#xA;window.onload = loadZone.wrap(e =&amp;gt; { ... });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then at all those sites, &lt;code&gt;Zone.current&lt;/code&gt; would be equal to &lt;code&gt;loadZone&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Node.js &lt;code&gt;domain&lt;/code&gt; module&lt;/h2&gt; &#xA;&lt;p&gt;Domain&#39;s global central active domain can be consumed by multiple endpoints and be exchanged in any time with synchronous operation (&lt;code&gt;domain.enter()&lt;/code&gt;). Since it is possible that some third party module changed active domain on the fly and application owner may unaware of such change, this can introduce unexpected implicit behavior and made domain diagnosis hard.&lt;/p&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://nodejs.org/en/docs/guides/domain-postmortem/&#34;&gt;Domain Module Postmortem&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Node.js &lt;code&gt;async_hooks&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This is what the proposal evolved from. &lt;code&gt;async_hooks&lt;/code&gt; in Node.js enabled async resources tracking for APM vendors. On which Node.js also implemented &lt;code&gt;AsyncLocalStorage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Chrome Async Stack Tagging API&lt;/h2&gt; &#xA;&lt;p&gt;Frameworks can schedule tasks with their own userland queues. In such case, the stack trace originated from the framework scheduling logic tells only part of the story.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;Error: Call stack&#xA;  at someTask (example.js)&#xA;  at loop (framework.js)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Chrome &lt;a href=&#34;https://developer.chrome.com/blog/devtools-modern-web-debugging/#linked-stack-traces&#34;&gt;Async Stack Tagging API&lt;/a&gt; introduces a new console method named &lt;code&gt;console.createTask()&lt;/code&gt;. The API signature is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Console {&#xA;  createTask(name: string): Task;&#xA;}&#xA;&#xA;interface Task {&#xA;  run&amp;lt;T&amp;gt;(f: () =&amp;gt; T): T;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;console.createTask()&lt;/code&gt; snapshots the call stack into a &lt;code&gt;Task&lt;/code&gt; record. And each &lt;code&gt;Task.run()&lt;/code&gt; restores the saved call stack and append it to newly generated call stacks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;Error: Call stack&#xA;  at someTask (example.js)&#xA;  at loop (framework.js)          // &amp;lt;- Task.run&#xA;  at async someTask               // &amp;lt;- Async stack appended&#xA;  at schedule (framework.js)      // &amp;lt;- console.createTask&#xA;  at businessLogic (example.js)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>