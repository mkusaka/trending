<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-05T01:33:29Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sqlsec/Hackintosh</title>
    <updated>2022-11-05T01:33:29Z</updated>
    <id>tag:github.com,2022-11-05:/sqlsec/Hackintosh</id>
    <link href="https://github.com/sqlsec/Hackintosh" rel="alternate"></link>
    <summary type="html">&lt;p&gt;国光的黑苹果安装教程：手把手教你配置 OpenCore&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hackintosh&lt;/h1&gt; &#xA;&lt;p&gt;国光的黑苹果安装教程：手把手教你配置 OpenCore&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/25379234/192068277-1c938cb2-0e9d-4b53-8d82-6e3e007b69d5.png&#34; alt=&#34;Snipaste_2022-09-24_07-12-20&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cf-pages/Telegraph-Image</title>
    <updated>2022-11-05T01:33:29Z</updated>
    <id>tag:github.com,2022-11-05:/cf-pages/Telegraph-Image</id>
    <link href="https://github.com/cf-pages/Telegraph-Image" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Free Image Hosting solution, Flickr/imgur alternative. Using Cloudflare Pages and Telegraph.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Telegraph-Image&lt;/h1&gt; &#xA;&lt;p&gt;Free Image Hosting solution, Flickr/imgur alternative. Using Cloudflare Pages and Telegraph.&lt;/p&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;h3&gt;Preparation&lt;/h3&gt; &#xA;&lt;p&gt;你唯一需要提前准备的就是一个Cloudflare账户&lt;/p&gt; &#xA;&lt;h3&gt;Step by Step Instruction&lt;/h3&gt; &#xA;&lt;p&gt;简单3步，即可部署本项目，拥有自己的图床&lt;/p&gt; &#xA;&lt;p&gt;1.下载或是Fork本仓库 &lt;del&gt;(Fork的时候如果能顺手点下旁边的Star就更好了❤)&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;2.打开Cloudflare Dashboard，进入Pages管理页面，选择创建项目，如果在第一步中选择的是fork本仓库，则选择&lt;code&gt;连接到 Git 提供程序&lt;/code&gt;，如果第一步中选择的是下载本仓库则选择&lt;code&gt;直接上传&lt;/code&gt; &lt;img src=&#34;https://telegraph-image.pages.dev/file/8d4ef9b7761a25821d9c2.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;按照页面提示输入项目名称，选择需要连接的git仓库（第一步选择的是fork）或是上传刚刚下载的仓库文件（第一步选择的是下载本仓库），点击&lt;code&gt;部署站点&lt;/code&gt;即可完成部署&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;1.无限图片储存数量，你可以上传不限数量的图片&lt;/p&gt; &#xA;&lt;p&gt;2.无需购买服务器，托管于Cloudflare的网络上，当使用量不超过Cloudflare的免费额度时，完全免费&lt;/p&gt; &#xA;&lt;p&gt;3.无需购买域名，可以使用Cloudflare Pages提供的&lt;code&gt;*.pages.dev&lt;/code&gt;的免费二级域名，同时也支持绑定自定义域名&lt;/p&gt; &#xA;&lt;h3&gt;绑定自定义域名&lt;/h3&gt; &#xA;&lt;p&gt;在pages的自定义域里面，绑定cloudflare中存在的域名，在cloudflare托管的域名，自动会修改dns记录 &lt;img src=&#34;https://telegraph-image.pages.dev/file/29546e3a7465a01281ee2.png&#34; alt=&#34;2&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Limitations&lt;/h3&gt; &#xA;&lt;p&gt;1.由于图片文件实际存储于Telegraph，Telegraph限制上传的图片大小最大为5MB&lt;/p&gt; &#xA;&lt;p&gt;2.由于使用Cloudflare的网络，图片的加载速度在某些地区可能得不到保证&lt;/p&gt; &#xA;&lt;p&gt;3.Cloudflare Function免费版每日限制100,000个请求（即上传或是加载图片的总次数不能超过100,000次）如超过可能需要选择购买Cloudflare Function的付费套餐&lt;/p&gt; &#xA;&lt;h3&gt;感谢&lt;/h3&gt; &#xA;&lt;p&gt;Hostloc @feixiang和@乌拉擦提供的思路和代码&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tc39/proposal-pipeline-operator</title>
    <updated>2022-11-05T01:33:29Z</updated>
    <id>tag:github.com,2022-11-05:/tc39/proposal-pipeline-operator</id>
    <link href="https://github.com/tc39/proposal-pipeline-operator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A proposal for adding a useful pipe operator to JavaScript.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pipe Operator (&lt;code&gt;|&amp;gt;&lt;/code&gt;) for JavaScript&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Stage&lt;/strong&gt;: 2&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Champions&lt;/strong&gt;: J. S. Choi, James DiGioia, Ron Buckton, Tab Atkins-Bittner, [list incomplete] &#xA;  &lt;!-- Alpha order by first name, plz --&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Former champions&lt;/strong&gt;: Daniel Ehrenberg&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;http://tc39.github.io/proposal-pipeline-operator/&#34;&gt;Specification&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/CONTRIBUTING.md&#34;&gt;Contributing guidelines&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md&#34;&gt;Proposal history&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Babel plugin&lt;/strong&gt;: &lt;a href=&#34;https://babeljs.io/blog/2021/07/26/7.15.0#hack-style-pipeline-operator-support-13191httpsgithubcombabelbabelpull13191-13416httpsgithubcombabelbabelpull13416&#34;&gt;Implemented in v7.15&lt;/a&gt;. See &lt;a href=&#34;https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator&#34;&gt;Babel documentation&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(This document presumptively uses &lt;code&gt;%&lt;/code&gt; as the placeholder token for the topic reference. This &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/issues/91&#34;&gt;choice of token is not a final decision&lt;/a&gt;; &lt;code&gt;%&lt;/code&gt; could instead be &lt;code&gt;^&lt;/code&gt;, or many other tokens.)&lt;/p&gt; &#xA;&lt;h2&gt;Why a pipe operator&lt;/h2&gt; &#xA;&lt;p&gt;In the State of JS 2020 survey, the &lt;strong&gt;fourth top answer&lt;/strong&gt; to &lt;a href=&#34;https://2020.stateofjs.com/en-US/opinions/#missing_from_js&#34;&gt;“What do you feel is currently missing from JavaScript?”&lt;/a&gt; was a &lt;strong&gt;pipe operator&lt;/strong&gt;. Why?&lt;/p&gt; &#xA;&lt;p&gt;When we perform &lt;strong&gt;consecutive operations&lt;/strong&gt; (e.g., function calls) on a &lt;strong&gt;value&lt;/strong&gt; in JavaScript, there are currently two fundamental styles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;passing the value as an argument to the operation (&lt;strong&gt;nesting&lt;/strong&gt; the operations if there are multiple operations),&lt;/li&gt; &#xA; &lt;li&gt;or calling the function as a method on the value (&lt;strong&gt;chaining&lt;/strong&gt; more method calls if there are multiple methods).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That is, &lt;code&gt;three(two(one(value)))&lt;/code&gt; versus &lt;code&gt;value.one().two().three()&lt;/code&gt;. However, these styles differ much in readability, fluency, and applicability.&lt;/p&gt; &#xA;&lt;h3&gt;Deep nesting is hard to read&lt;/h3&gt; &#xA;&lt;p&gt;The first style, &lt;strong&gt;nesting&lt;/strong&gt;, is generally applicable – it works for any sequence of operations: function calls, arithmetic, array/object literals, &lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;However, nesting is &lt;strong&gt;difficult to read&lt;/strong&gt; when it becomes deep: the flow of execution moves &lt;strong&gt;right to left&lt;/strong&gt;, rather than the left-to-right reading of normal code. If there are &lt;strong&gt;multiple arguments&lt;/strong&gt; at some levels, reading even bounces &lt;strong&gt;back and forth&lt;/strong&gt;: our eyes must &lt;strong&gt;jump left&lt;/strong&gt; to find a function name, and then they must &lt;strong&gt;jump right&lt;/strong&gt; to find additional arguments. Additionally, &lt;strong&gt;editing&lt;/strong&gt; the code afterwards can be fraught: we must find the correct &lt;strong&gt;place to insert&lt;/strong&gt; new arguments among &lt;strong&gt;many nested parentheses&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;p&gt;Consider this &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js#L295&#34;&gt;real-world code from React&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#xA;  chalk.dim(&#xA;    `$ ${Object.keys(envars)&#xA;      .map(envar =&amp;gt;&#xA;        `${envar}=${envars[envar]}`)&#xA;      .join(&#39; &#39;)&#xA;    }`,&#xA;    &#39;node&#39;,&#xA;    args.join(&#39; &#39;)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This real-world code is made of &lt;strong&gt;deeply nested expressions&lt;/strong&gt;. In order to read its flow of data, a human’s eyes must first:&lt;/p&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt; &lt;p&gt;Find the &lt;strong&gt;initial data&lt;/strong&gt; (the innermost expression, &lt;code&gt;envars&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;And then scan &lt;strong&gt;back and forth&lt;/strong&gt; repeatedly from &lt;strong&gt;inside out&lt;/strong&gt; for each data transformation, each one either an easily missed prefix operator on the left or a suffix operators on the right:&lt;/p&gt; &#xA;   &lt;ol&gt; &#xA;    &lt;li&gt;&lt;code&gt;Object.keys()&lt;/code&gt; (left side),&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;.map()&lt;/code&gt; (right side),&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;.join()&lt;/code&gt; (right side),&lt;/li&gt; &#xA;    &lt;li&gt;A template literal (both sides),&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;chalk.dim()&lt;/code&gt; (left side), then&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;console.log()&lt;/code&gt; (left side).&lt;/li&gt; &#xA;   &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;p&gt;As a result of deeply nesting many expressions (some of which use &lt;strong&gt;prefix&lt;/strong&gt; operators, some of which use &lt;strong&gt;postfix&lt;/strong&gt; operators, and some of which use &lt;strong&gt;circumfix&lt;/strong&gt; operators), we must check &lt;strong&gt;both left and right sides&lt;/strong&gt; to find the &lt;strong&gt;head&lt;/strong&gt; of &lt;strong&gt;each expression&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Method chaining is limited&lt;/h3&gt; &#xA;&lt;p&gt;The second style, &lt;strong&gt;method chaining&lt;/strong&gt;, is &lt;strong&gt;only&lt;/strong&gt; usable if the value has the functions designated as &lt;strong&gt;methods&lt;/strong&gt; for its class. This &lt;strong&gt;limits&lt;/strong&gt; its applicability. But &lt;strong&gt;when&lt;/strong&gt; it applies, thanks to its postfix structure, it is generally more usable and &lt;strong&gt;easier&lt;/strong&gt; to read and write. Code execution flows &lt;strong&gt;left to right&lt;/strong&gt;. Deeply nested expressions are &lt;strong&gt;untangled&lt;/strong&gt;. All arguments for a function call are &lt;strong&gt;grouped&lt;/strong&gt; with the function’s name. And editing the code later to &lt;strong&gt;insert or delete&lt;/strong&gt; more method calls is trivial, since we would just have to put our cursor in one spot, then start typing or deleting one &lt;strong&gt;contiguous&lt;/strong&gt; run of characters.&lt;/p&gt; &#xA;&lt;p&gt;Indeed, the benefits of method chaining are &lt;strong&gt;so attractive&lt;/strong&gt; that some &lt;strong&gt;popular libraries contort&lt;/strong&gt; their code structure specifically to allow &lt;strong&gt;more method chaining&lt;/strong&gt;. The most prominent example is &lt;strong&gt;&lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;&lt;/strong&gt;, which still remains the &lt;strong&gt;most popular JS library&lt;/strong&gt; in the world. jQuery’s core design is a single über-object with dozens of methods on it, all of which return the same object type so that we can &lt;strong&gt;continue chaining&lt;/strong&gt;. There is even a name for this style of programming: &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fluent_interface&#34;&gt;fluent interfaces&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, for all of its fluency, &lt;strong&gt;method chaining&lt;/strong&gt; alone cannot accomodate JavaScript’s &lt;strong&gt;other syntaxes&lt;/strong&gt;: function calls, arithmetic, array/object literals, &lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt;, etc. In this way, method chaining remains &lt;strong&gt;limited&lt;/strong&gt; in its &lt;strong&gt;applicability&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Pipe operators combine both worlds&lt;/h3&gt; &#xA;&lt;p&gt;The pipe operator attempts to marry the &lt;strong&gt;convenience&lt;/strong&gt; and ease of &lt;strong&gt;method chaining&lt;/strong&gt; with the wide &lt;strong&gt;applicability&lt;/strong&gt; of &lt;strong&gt;expression nesting&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The general structure of all the pipe operators is &lt;code&gt;value |&amp;gt;&lt;/code&gt; &lt;var&gt;e1&lt;/var&gt; &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;var&gt;e2&lt;/var&gt; &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;var&gt;e3&lt;/var&gt;, where &lt;var&gt;e1&lt;/var&gt;, &lt;var&gt;e2&lt;/var&gt;, &lt;var&gt;e3&lt;/var&gt; are all expressions that take consecutive values as their parameters. The &lt;code&gt;|&amp;gt;&lt;/code&gt; operator then does some degree of magic to “pipe” &lt;code&gt;value&lt;/code&gt; from the lefthand side into the righthand side.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;Continuing this deeply nested &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world code from React&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#xA;  chalk.dim(&#xA;    `$ ${Object.keys(envars)&#xA;      .map(envar =&amp;gt;&#xA;        `${envar}=${envars[envar]}`)&#xA;      .join(&#39; &#39;)&#xA;    }`,&#xA;    &#39;node&#39;,&#xA;    args.join(&#39; &#39;)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;…we can &lt;strong&gt;untangle&lt;/strong&gt; it as such using a pipe operator and a placeholder token (&lt;code&gt;%&lt;/code&gt;) standing in for the previous operation’s value:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Now, the human reader can &lt;strong&gt;rapidly find&lt;/strong&gt; the &lt;strong&gt;initial data&lt;/strong&gt; (what had been the most innermost expression, &lt;code&gt;envars&lt;/code&gt;), then &lt;strong&gt;linearly&lt;/strong&gt; read, from &lt;strong&gt;left to right&lt;/strong&gt;, each transformation on the data.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Temporary variables are often tedious&lt;/h3&gt; &#xA;&lt;p&gt;One could argue that using &lt;strong&gt;temporary variables&lt;/strong&gt; should be the only way to untangle deeply nested code. Explicitly naming every step’s variable causes something similar to method chaining to happen, with similar benefits to reading and writing code.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;For example, using our previous modified &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world example from React&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;…a version using temporary variables would look like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const envarString = Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;);&#xA;const consoleText = `$ ${envarString}`;&#xA;const coloredConsoleText = chalk.dim(consoleText, &#39;node&#39;, args.join(&#39; &#39;));&#xA;console.log(coloredConsoleText);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;But there are reasons why we encounter deeply nested expressions in each other’s code &lt;strong&gt;all the time in the real world&lt;/strong&gt;, &lt;strong&gt;rather than&lt;/strong&gt; lines of temporary variables. And there are reasons why the &lt;strong&gt;method-chain-based &lt;a href=&#34;https://en.wikipedia.org/wiki/Fluent_interface&#34;&gt;fluent interfaces&lt;/a&gt;&lt;/strong&gt; of jQuery, Mocha, and so on are still &lt;strong&gt;popular&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is often simply too &lt;strong&gt;tedious and wordy&lt;/strong&gt; to &lt;strong&gt;write&lt;/strong&gt; code with a long sequence of temporary, single-use variables. It is arguably even tedious and visually noisy for a human to &lt;strong&gt;read&lt;/strong&gt;, too.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;a href=&#34;https://martinfowler.com/bliki/TwoHardThings.html&#34;&gt;&lt;strong&gt;naming&lt;/strong&gt; is one of the &lt;strong&gt;most difficult tasks&lt;/strong&gt; in programming&lt;/a&gt;, then programmers will &lt;strong&gt;inevitably avoid naming&lt;/strong&gt; variables when they perceive their benefit to be relatively small.&lt;/p&gt; &#xA;&lt;h3&gt;Reusing temporary variables is prone to unexpected mutation&lt;/h3&gt; &#xA;&lt;p&gt;One could argue that using a single &lt;strong&gt;mutable variable&lt;/strong&gt; with a short name would reduce the wordiness of temporary variables, achieving similar results as with the pipe operator.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;For example, our previous modified &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world example from React&lt;/a&gt; could be re-written like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let _;&#xA;_ = Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;);&#xA;_ = `$ ${_}`;&#xA;_ = chalk.dim(_, &#39;node&#39;, args.join(&#39; &#39;));&#xA;_ = console.log(_);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;But code like this is &lt;strong&gt;not common&lt;/strong&gt; in real-world code. One reason for this is that mutable variables can &lt;strong&gt;change unexpectedly&lt;/strong&gt;, causing silent bugs that are hard to find. For example, the variable might be accidentally referenced in a closure. Or it might be mistakenly reassigned within an expression.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example code&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// setup&#xA;function one () { return 1; }&#xA;function double (x) { return x * 2; }&#xA;&#xA;let _;&#xA;_ = one(); // _ is now 1.&#xA;_ = double(_); // _ is now 2.&#xA;_ = Promise.resolve().then(() =&amp;gt;&#xA;  // This does *not* print 2!&#xA;  // It prints 1, because `_` is reassigned downstream.&#xA;  console.log(_));&#xA;&#xA;// _ becomes 1 before the promise callback.&#xA;_ = one(_);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This issue would not happen with the pipe operator. The topic token cannot be reassigned, and code outside of each step cannot change its binding.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let _;&#xA;_ = one()&#xA;  |&amp;gt; double(%)&#xA;  |&amp;gt; Promise.resolve().then(() =&amp;gt;&#xA;    // This prints 2, as intended.&#xA;    console.log(%));&#xA;&#xA;_ = one();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;For this reason, code with mutable variables is also harder to read. To determine what the variable represents at any given point, you must to &lt;strong&gt;search the entire preceding scope&lt;/strong&gt; for places where it is &lt;strong&gt;reassigned&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The topic reference of a pipeline, on the other hand, has a limited lexical scope, and its binding is immutable within its scope. It cannot be accidentally reassigned, and it can be safely used in closures.&lt;/p&gt; &#xA;&lt;p&gt;Although the topic value also changes with each pipeline step, we only scan the previous step of the pipeline to make sense of it, leading to code that is easier to read.&lt;/p&gt; &#xA;&lt;h3&gt;Temporary variables must be declared in statements&lt;/h3&gt; &#xA;&lt;p&gt;Another benefit of the pipe operator over sequences of assignment statements (whether with mutable or with immutable temporary variables) is that they are &lt;strong&gt;expressions&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Pipe expressions are expressions that can be directly returned, assigned to a variable, or used in contexts such as JSX expressions.&lt;/p&gt; &#xA;&lt;p&gt;Using temporary variables, on the other hand, requires sequences of statements.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Examples&lt;/summary&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt;&#xA;    &lt;th&gt;Pipelines&lt;/th&gt; &#xA;    &lt;th&gt;Temporary Variables&lt;/th&gt; &#xA;   &lt;/tr&gt;&#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const envVarFormat = vars =&amp;gt;&#xA;  Object.keys(vars)&#xA;    .map(var =&amp;gt; `${var}=${vars[var]}`)&#xA;    .join(&#39; &#39;)&#xA;    |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const envVarFormat = (vars) =&amp;gt; {&#xA;  let _ = Object.keys(vars);&#xA;    .map(var =&amp;gt; `${var}=${vars[var]}`);&#xA;    .join(&#39; &#39;);&#xA;  return chalk.dim(_, &#39;node&#39;, args.join(&#39; &#39;));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// This example uses JSX.&#xA;return (&#xA;  &amp;lt;ul&amp;gt;&#xA;    {&#xA;      values&#xA;        |&amp;gt; Object.keys(%)&#xA;        |&amp;gt; [...Array.from(new Set(%))]&#xA;        |&amp;gt; %.map(envar =&amp;gt; (&#xA;          &amp;lt;li onClick={&#xA;            () =&amp;gt; doStuff(values)&#xA;          }&amp;gt;{envar}&amp;lt;/li&amp;gt;&#xA;        ))&#xA;    }&#xA;  &amp;lt;/ul&amp;gt;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// This example uses JSX.&#xA;let _ = values;&#xA;_= Object.keys(_);&#xA;_= [...Array.from(new Set(_))];&#xA;_= _.map(envar =&amp;gt; (&#xA;  &amp;lt;li onClick={&#xA;    () =&amp;gt; doStuff(values)&#xA;  }&amp;gt;{envar}&amp;lt;/li&amp;gt;&#xA;));&#xA;return (&#xA;  &amp;lt;ul&amp;gt;{_}&amp;lt;/ul&amp;gt;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Why the Hack pipe operator&lt;/h2&gt; &#xA;&lt;p&gt;There were &lt;strong&gt;two competing proposals&lt;/strong&gt; for the pipe operator: Hack pipes and F# pipes. (Before that, there &lt;strong&gt;was&lt;/strong&gt; a &lt;a href=&#34;https://github.com/js-choi/proposal-smart-pipelines/&#34;&gt;third proposal for a “smart mix” of the first two proposals&lt;/a&gt;, but it has been withdrawn, since its syntax is strictly a superset of one of the proposals’.)&lt;/p&gt; &#xA;&lt;p&gt;The two pipe proposals just differ &lt;strong&gt;slightly&lt;/strong&gt; on what the “magic” is, when we spell our code when using &lt;code&gt;|&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Both&lt;/strong&gt; proposals &lt;strong&gt;reuse&lt;/strong&gt; existing language concepts: Hack pipes are based on the concept of the &lt;strong&gt;expression&lt;/strong&gt;, while F# pipes are based on the concept of the &lt;strong&gt;unary function&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Piping &lt;strong&gt;expressions&lt;/strong&gt; and piping &lt;strong&gt;unary functions&lt;/strong&gt; correspondingly have &lt;strong&gt;small&lt;/strong&gt; and nearly &lt;strong&gt;symmetrical trade-offs&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;This proposal: Hack pipes&lt;/h3&gt; &#xA;&lt;p&gt;In the &lt;strong&gt;Hack language&lt;/strong&gt;’s pipe syntax, the righthand side of the pipe is an &lt;strong&gt;expression&lt;/strong&gt; containing a special &lt;strong&gt;placeholder&lt;/strong&gt;, which is evaluated with the placeholder bound to the result of evaluating the lefthand side&#39;s expression. That is, we write &lt;code&gt;value |&amp;gt; one(%) |&amp;gt; two(%) |&amp;gt; three(%)&lt;/code&gt; to pipe &lt;code&gt;value&lt;/code&gt; through the three functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pro:&lt;/strong&gt; The righthand side can be &lt;strong&gt;any expression&lt;/strong&gt;, and the placeholder can go anywhere any normal variable identifier could go, so we can pipe to any code we want &lt;strong&gt;without any special rules&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; foo(%)&lt;/code&gt; for unary function calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; foo(1, %)&lt;/code&gt; for n-ary function calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; %.foo()&lt;/code&gt; for method calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; % + 1&lt;/code&gt; for arithmetic,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; [%, 0]&lt;/code&gt; for array literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; {foo: %}&lt;/code&gt; for object literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; `${%}`&lt;/code&gt; for template literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; new Foo(%)&lt;/code&gt; for constructing objects,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; await %&lt;/code&gt; for awaiting promises,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; (yield %)&lt;/code&gt; for yielding generator values,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; import(%)&lt;/code&gt; for calling function-like keywords,&lt;/li&gt; &#xA; &lt;li&gt;etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Con:&lt;/strong&gt; Piping through &lt;strong&gt;unary functions&lt;/strong&gt; is &lt;strong&gt;slightly more verbose&lt;/strong&gt; with Hack pipes than with F# pipes. This includes unary functions that were created by &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Currying&#34;&gt;function-currying&lt;/a&gt; libraries&lt;/strong&gt; like &lt;a href=&#34;https://ramdajs.com/&#34;&gt;Ramda&lt;/a&gt;, as well as &lt;a href=&#34;https://github.com/js-choi/proposal-hack-pipes/issues/4#issuecomment-817208635&#34;&gt;unary arrow functions that perform &lt;strong&gt;complex destructuring&lt;/strong&gt; on their arguments&lt;/a&gt;: Hack pipes would be slightly more verbose with an &lt;strong&gt;explicit&lt;/strong&gt; function call suffix &lt;code&gt;(%)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;(Complex destructuring of the topic value will be easier when &lt;a href=&#34;https://github.com/tc39/proposal-do-expressions/&#34;&gt;do expressions&lt;/a&gt; progress, as you will then be able to do variable assignment/destructuring inside of a pipe body.)&lt;/p&gt; &#xA;&lt;h3&gt;Alternative proposal: F# pipes&lt;/h3&gt; &#xA;&lt;p&gt;In the &lt;a href=&#34;https://github.com/valtech-nyc/proposal-fsharp-pipelines&#34;&gt;&lt;strong&gt;F# language&lt;/strong&gt;’s pipe syntax&lt;/a&gt;, the righthand side of the pipe is an expression that must &lt;strong&gt;evaluate into a unary function&lt;/strong&gt;, which is then &lt;strong&gt;tacitly called&lt;/strong&gt; with the lefthand side’s value as its &lt;strong&gt;sole argument&lt;/strong&gt;. That is, we write &lt;code&gt;value |&amp;gt; one |&amp;gt; two |&amp;gt; three&lt;/code&gt; to pipe &lt;code&gt;value&lt;/code&gt; through the three functions. &lt;code&gt;left |&amp;gt; right&lt;/code&gt; becomes &lt;code&gt;right(left)&lt;/code&gt;. This is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Tacit_programming&#34;&gt;tacit programming or point-free style&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;For example, using our previous modified &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world example from React&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;…a version using F# pipes instead of Hack pipes would look like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; x=&amp;gt; `$ ${x}`&#xA;  |&amp;gt; x=&amp;gt; chalk.dim(x, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pro:&lt;/strong&gt; The restriction that the righthand side &lt;strong&gt;must&lt;/strong&gt; resolve to a unary function lets us write very terse pipes &lt;strong&gt;when&lt;/strong&gt; the operation we want to perform is a &lt;strong&gt;unary function call&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; foo&lt;/code&gt; for unary function calls.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This includes unary functions that were created by &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Currying&#34;&gt;function-currying&lt;/a&gt; libraries&lt;/strong&gt; like &lt;a href=&#34;https://ramdajs.com/&#34;&gt;Ramda&lt;/a&gt;, as well as &lt;a href=&#34;https://github.com/js-choi/proposal-hack-pipes/issues/4#issuecomment-817208635&#34;&gt;unary arrow functions that perform &lt;strong&gt;complex destructuring&lt;/strong&gt; on their arguments&lt;/a&gt;: F# pipes would be &lt;strong&gt;slightly less verbose&lt;/strong&gt; with an &lt;strong&gt;implicit&lt;/strong&gt; function call (no &lt;code&gt;(%)&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Con:&lt;/strong&gt; The restriction means that &lt;strong&gt;any operations&lt;/strong&gt; that are performed by &lt;strong&gt;other syntax&lt;/strong&gt; must be made &lt;strong&gt;slightly more verbose&lt;/strong&gt; by &lt;strong&gt;wrapping&lt;/strong&gt; the operation in a unary &lt;strong&gt;arrow function&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; x.foo()&lt;/code&gt; for method calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; x + 1&lt;/code&gt; for arithmetic,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; [x, 0]&lt;/code&gt; for array literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; ({foo: x})&lt;/code&gt; for object literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; `${x}`&lt;/code&gt; for template literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; new Foo(x)&lt;/code&gt; for constructing objects,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; import(x)&lt;/code&gt; for calling function-like keywords,&lt;/li&gt; &#xA; &lt;li&gt;etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Even calling &lt;strong&gt;named functions&lt;/strong&gt; requires &lt;strong&gt;wrapping&lt;/strong&gt; when we need to pass &lt;strong&gt;more than one argument&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; foo(1, x)&lt;/code&gt; for n-ary function calls.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Con:&lt;/strong&gt; The &lt;strong&gt;&lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt; operations are &lt;strong&gt;scoped&lt;/strong&gt; to their &lt;strong&gt;containing function&lt;/strong&gt;, and thus &lt;strong&gt;cannot be handled by unary functions&lt;/strong&gt; alone. If we want to integrate them into a pipe expression, &lt;a href=&#34;https://github.com/valtech-nyc/proposal-fsharp-pipelines/&#34;&gt;&lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; must be handled as &lt;strong&gt;special syntax cases&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; await&lt;/code&gt; for awaiting promises, and&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; yield&lt;/code&gt; for yielding generator values.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Hack pipes favor more common expressions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Both&lt;/strong&gt; Hack pipes and F# pipes respectively impose a small &lt;strong&gt;syntax tax&lt;/strong&gt; on different expressions:&lt;br&gt; &lt;strong&gt;Hack pipes&lt;/strong&gt; slightly tax only &lt;strong&gt;unary function calls&lt;/strong&gt;, and&lt;br&gt; &lt;strong&gt;F# pipes&lt;/strong&gt; slightly tax &lt;strong&gt;all expressions except&lt;/strong&gt; unary function calls.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;strong&gt;both&lt;/strong&gt; proposals, the syntax tax per taxed expression is &lt;strong&gt;small&lt;/strong&gt; (&lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;(%)&lt;/code&gt; and &lt;code&gt;x=&amp;gt;&lt;/code&gt; are &lt;strong&gt;only three characters&lt;/strong&gt;). However, the tax is &lt;strong&gt;multiplied&lt;/strong&gt; by the &lt;strong&gt;prevalence&lt;/strong&gt; of its respectively taxed expressions. It therefore might make sense to impose a tax on whichever expressions are &lt;strong&gt;less common&lt;/strong&gt; and to &lt;strong&gt;optimize&lt;/strong&gt; in favor of whichever expressions are &lt;strong&gt;more common&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unary function calls are in general &lt;strong&gt;less common&lt;/strong&gt; than &lt;strong&gt;all&lt;/strong&gt; expressions &lt;strong&gt;except&lt;/strong&gt; unary functions. In particular, &lt;strong&gt;method&lt;/strong&gt; calling and &lt;strong&gt;n-ary function&lt;/strong&gt; calling will &lt;strong&gt;always&lt;/strong&gt; be &lt;strong&gt;popular&lt;/strong&gt;; in general frequency, &lt;strong&gt;unary&lt;/strong&gt; function calling is equal to or exceeded by those two cases &lt;strong&gt;alone&lt;/strong&gt; – let alone by other ubiquitous syntaxes such as &lt;strong&gt;array literals&lt;/strong&gt;, &lt;strong&gt;object literals&lt;/strong&gt;, and &lt;strong&gt;arithmetic operations&lt;/strong&gt;. This explainer contains several &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#real-world-examples&#34;&gt;real-world examples&lt;/a&gt; of this difference in prevalence.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, several other proposed &lt;strong&gt;new syntaxes&lt;/strong&gt;, such as &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-extensions/&#34;&gt;extension calling&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-do-expressions/&#34;&gt;do expressions&lt;/a&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-record-tuple/&#34;&gt;record/tuple literals&lt;/a&gt;&lt;/strong&gt;, will also likely become &lt;strong&gt;pervasive&lt;/strong&gt; in the &lt;strong&gt;future&lt;/strong&gt;. Likewise, &lt;strong&gt;arithmetic&lt;/strong&gt; operations would also become &lt;strong&gt;even more common&lt;/strong&gt; if TC39 standardizes &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-operator-overloading/&#34;&gt;operator overloading&lt;/a&gt;&lt;/strong&gt;. Untangling these future syntaxes’ expressions would be more fluent with Hack pipes compared to F# pipes.&lt;/p&gt; &#xA;&lt;h3&gt;Hack pipes might be simpler to use&lt;/h3&gt; &#xA;&lt;p&gt;The syntax tax of Hack pipes on unary function calls (i.e., the &lt;code&gt;(%)&lt;/code&gt; to invoke the righthand side’s unary function) is &lt;strong&gt;not a special case&lt;/strong&gt;: it simply is &lt;strong&gt;explicitly writing ordinary code&lt;/strong&gt;, in &lt;strong&gt;the way we normally would&lt;/strong&gt; without a pipe.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, &lt;strong&gt;F# pipes require&lt;/strong&gt; us to &lt;strong&gt;distinguish&lt;/strong&gt; between “code that resolves to an unary function” versus &lt;strong&gt;“any other expression”&lt;/strong&gt; – and to remember to add the arrow-function wrapper around the latter case.&lt;/p&gt; &#xA;&lt;p&gt;For example, with Hack pipes, &lt;code&gt;value |&amp;gt; someFunction + 1&lt;/code&gt; is &lt;strong&gt;invalid syntax&lt;/strong&gt; and will &lt;strong&gt;fail early&lt;/strong&gt;. There is no need to recognize that &lt;code&gt;someFunction + 1&lt;/code&gt; will not evaluate into a unary function. But with F# pipes, &lt;code&gt;value |&amp;gt; someFunction + 1&lt;/code&gt; is &lt;strong&gt;still valid syntax&lt;/strong&gt; – it’ll just &lt;strong&gt;fail late&lt;/strong&gt; at &lt;strong&gt;runtime&lt;/strong&gt;, because &lt;code&gt;someFunction + 1&lt;/code&gt; isn’t callable.&lt;/p&gt; &#xA;&lt;h3&gt;TC39 has rejected F# pipes multiple times&lt;/h3&gt; &#xA;&lt;p&gt;The pipe champion group has presented F# pipes for Stage&amp;nbsp;2 to TC39 &lt;strong&gt;twice&lt;/strong&gt;. It was &lt;strong&gt;unsuccessful&lt;/strong&gt; in advancing to Stage&amp;nbsp;2 both times. Both F# pipes (and &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;partial function application (PFA)&lt;/a&gt;) have run into strong pushback from multiple other TC39 representatives due to various concerns. These have included:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Memory performance concerns (e.g., &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md#2021-07&#34;&gt;especially from browser-engine implementors&lt;/a&gt;),&lt;/li&gt; &#xA; &lt;li&gt;Syntax concerns about &lt;code&gt;await&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Concerns about encouraging ecosystem bifurcation/forking, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This pushback has occurred from &lt;strong&gt;outside&lt;/strong&gt; the pipe champion group. See &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md&#34;&gt;HISTORY.md&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;It is the pipe champion group’s belief that any pipe operator is better than none, in order to &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#why-a-pipe-operator&#34;&gt;easily linearize deeply nested expressions&lt;/a&gt; without resorting to named variables. Many members of the champion group believe that Hack pipes are slightly better than F# pipes, and some members of the champion group believe that F# pipes are slightly better than Hack pipes. But everyone in the champion group agrees that F# pipes have met with far too much resistance to be able to pass TC39 in the foreseeable future.&lt;/p&gt; &#xA;&lt;p&gt;To emphasize, it is likely that an attempt to switch from Hack pipes back to F# pipes will result in TC39 never agreeing to any pipes at all. &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;PFA syntax&lt;/a&gt; is similarly facing an uphill battle in TC39 (see &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md&#34;&gt;HISTORY.md&lt;/a&gt;). Many members of the pipe champion group think this is unfortunate, and they are willing to fight again &lt;strong&gt;later&lt;/strong&gt; for an &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tacit-unary-function-application-syntax&#34;&gt;F#-pipe split mix&lt;/a&gt; and &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;PFA syntax&lt;/a&gt;. But there are quite a few representatives (including &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md#2021-07&#34;&gt;browser-engine implementers&lt;/a&gt;) outside of the Pipe Champion Group who are generally against encouraging &lt;a href=&#34;https://en.wikipedia.org/wiki/Tacit_programming&#34;&gt;tacit programming&lt;/a&gt; (and &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;PFA syntax&lt;/a&gt;), regardless of Hack pipes.&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;(A &lt;a href=&#34;http://tc39.github.io/proposal-pipeline-operator/&#34;&gt;formal draft specification&lt;/a&gt; is available.)&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;topic reference&lt;/strong&gt; &lt;code&gt;%&lt;/code&gt; is a &lt;strong&gt;nullary operator&lt;/strong&gt;. It acts as a placeholder for a &lt;strong&gt;topic value&lt;/strong&gt;, and it is &lt;strong&gt;lexically scoped&lt;/strong&gt; and &lt;strong&gt;immutable&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;code&gt;%&lt;/code&gt; is not a final choice&lt;/summary&gt; &#xA; &lt;p&gt;(The precise &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/issues/91&#34;&gt;&lt;strong&gt;token&lt;/strong&gt; for the topic reference is &lt;strong&gt;not final&lt;/strong&gt;&lt;/a&gt;. &lt;code&gt;%&lt;/code&gt; could instead be &lt;code&gt;^&lt;/code&gt;, or many other tokens. We plan to &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/issues/91&#34;&gt;&lt;strong&gt;bikeshed&lt;/strong&gt; what actual token to use&lt;/a&gt; before advancing to Stage 3. However, &lt;code&gt;%&lt;/code&gt; seems to be the &lt;a href=&#34;https://github.com/js-choi/proposal-hack-pipes/issues/2&#34;&gt;least syntactically problematic&lt;/a&gt;, and it also resembles the placeholders of &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Printf_format_string&#34;&gt;printf format strings&lt;/a&gt;&lt;/strong&gt; and &lt;a href=&#34;https://clojure.org/reference/reader#_dispatch&#34;&gt;&lt;strong&gt;Clojure&lt;/strong&gt;’s &lt;code&gt;#(%)&lt;/code&gt; &lt;strong&gt;function literals&lt;/strong&gt;&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;The &lt;strong&gt;pipe operator&lt;/strong&gt; &lt;code&gt;|&amp;gt;&lt;/code&gt; is an &lt;strong&gt;infix operator&lt;/strong&gt; that forms a &lt;strong&gt;pipe expression&lt;/strong&gt; (also called a &lt;strong&gt;pipeline&lt;/strong&gt;). It evaluates its lefthand side (the &lt;strong&gt;pipe head&lt;/strong&gt; or &lt;strong&gt;pipe input&lt;/strong&gt;), immutably &lt;strong&gt;binds&lt;/strong&gt; the resulting value (the &lt;strong&gt;topic value&lt;/strong&gt;) to the &lt;strong&gt;topic reference&lt;/strong&gt;, then evaluates its righthand side (the &lt;strong&gt;pipe body&lt;/strong&gt;) with that binding. The resulting value of the righthand side becomes the whole pipe expression’s final value (the &lt;strong&gt;pipe output&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The pipe operator’s precedence is the &lt;strong&gt;same&lt;/strong&gt; as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the function arrow &lt;code&gt;=&amp;gt;&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;the assignment operators &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, etc.;&lt;/li&gt; &#xA; &lt;li&gt;the generator operators &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yield *&lt;/code&gt;;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is &lt;strong&gt;tighter&lt;/strong&gt; than only the comma operator &lt;code&gt;,&lt;/code&gt;.&lt;br&gt; It is &lt;strong&gt;looser&lt;/strong&gt; than &lt;strong&gt;all other&lt;/strong&gt; operators.&lt;/p&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;v =&amp;gt; v |&amp;gt; % == null |&amp;gt; foo(%, 0)&lt;/code&gt;&lt;br&gt; would group into &lt;code&gt;v =&amp;gt; (v |&amp;gt; (% == null) |&amp;gt; foo(%, 0))&lt;/code&gt;,&lt;br&gt; which in turn is equivalent to &lt;code&gt;v =&amp;gt; foo(v == null, 0)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A pipe body &lt;strong&gt;must&lt;/strong&gt; use its topic value &lt;strong&gt;at least once&lt;/strong&gt;. For example, &lt;code&gt;value |&amp;gt; foo + 1&lt;/code&gt; is &lt;strong&gt;invalid syntax&lt;/strong&gt;, because its body does not contain a topic reference. This design is because &lt;strong&gt;omission&lt;/strong&gt; of the topic reference from a pipe expression’s body is almost certainly an &lt;strong&gt;accidental&lt;/strong&gt; programmer error.&lt;/p&gt; &#xA;&lt;p&gt;Likewise, a topic reference &lt;strong&gt;must&lt;/strong&gt; be contained in a pipe body. Using a topic reference outside of a pipe body is also &lt;strong&gt;invalid syntax&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To prevent confusing grouping, it is &lt;strong&gt;invalid&lt;/strong&gt; syntax to use &lt;strong&gt;other&lt;/strong&gt; operators that have &lt;strong&gt;similar precedence&lt;/strong&gt; (i.e., the arrow &lt;code&gt;=&amp;gt;&lt;/code&gt;, the ternary conditional operator &lt;code&gt;?&lt;/code&gt; &lt;code&gt;:&lt;/code&gt;, the assignment operators, and the &lt;code&gt;yield&lt;/code&gt; operator) as a &lt;strong&gt;pipe head or body&lt;/strong&gt;. When using &lt;code&gt;|&amp;gt;&lt;/code&gt; with these operators, we must use &lt;strong&gt;parentheses&lt;/strong&gt; to explicitly indicate what grouping is correct. For example, &lt;code&gt;a |&amp;gt; b ? % : c |&amp;gt; %.d&lt;/code&gt; is invalid syntax; it should be corrected to either &lt;code&gt;a |&amp;gt; (b ? % : c) |&amp;gt; %.d&lt;/code&gt; or &lt;code&gt;a |&amp;gt; (b ? % : c |&amp;gt; %.d)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Lastly, topic bindings &lt;strong&gt;inside dynamically compiled&lt;/strong&gt; code (e.g., with &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;new Function&lt;/code&gt;) &lt;strong&gt;cannot&lt;/strong&gt; be used &lt;strong&gt;outside&lt;/strong&gt; of that code. For example, &lt;code&gt;v |&amp;gt; eval(&#39;% + 1&#39;)&lt;/code&gt; will throw a syntax error when the &lt;code&gt;eval&lt;/code&gt; expression is evaluated at runtime.&lt;/p&gt; &#xA;&lt;p&gt;There are &lt;strong&gt;no other special rules&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A natural result of these rules is that, if we need to interpose a &lt;strong&gt;side effect&lt;/strong&gt; in the middle of a chain of pipe expressions, without modifying the data being piped through, then we could use a &lt;strong&gt;comma expression&lt;/strong&gt;, such as with &lt;code&gt;value |&amp;gt; (sideEffect(), %)&lt;/code&gt;. As usual, the comma expression will evaluate to its righthand side &lt;code&gt;%&lt;/code&gt;, essentially passing through the topic value without modifying it. This is especially useful for quick debugging: &lt;code&gt;value |&amp;gt; (console.log(%), %)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Real-world examples&lt;/h2&gt; &#xA;&lt;p&gt;The only changes to the original examples were dedentation and removal of comments.&lt;/p&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/jquery/jquery/raw/2.2-stable/build/tasks/sourcemap.js&#34;&gt;jquery/build/tasks/sourceMap.js&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;var minLoc = Object.keys( grunt.config( &#34;uglify.all.files&#34; ) )[ 0 ];&#xA;&#xA;// With pipes&#xA;var minLoc = grunt.config(&#39;uglify.all.files&#39;) |&amp;gt; Object.keys(%)[0];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/nodejs/node/raw/v16.x/deps/npm/lib/unpublish.js&#34;&gt;node/deps/npm/lib/unpublish.js&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;const json = await npmFetch.json(npa(pkgs[0]).escapedName, opts);&#xA;&#xA;// With pipes&#xA;const json = pkgs[0] |&amp;gt; npa(%).escapedName |&amp;gt; await npmFetch.json(%, opts);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://underscorejs.org/docs/underscore-esm.html&#34;&gt;underscore.js&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return filter(obj, negate(cb(predicate)), context);&#xA;&#xA;// With pipes&#xA;return cb(predicate) |&amp;gt; _.negate(%) |&amp;gt; _.filter(obj, %, context);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/ramda/ramda/raw/v0.27.1/dist/ramda.js&#34;&gt;ramda.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return xf[&#39;@@transducer/result&#39;](obj[methodName](bind(xf[&#39;@@transducer/step&#39;], xf), acc));&#xA;&#xA;// With pipes&#xA;return xf&#xA;  |&amp;gt; bind(%[&#39;@@transducer/step&#39;], %)&#xA;  |&amp;gt; obj[methodName](%, acc)&#xA;  |&amp;gt; xf[&#39;@@transducer/result&#39;](%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/ramda/ramda/raw/v0.27.1/dist/ramda.js&#34;&gt;ramda.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;try {&#xA;  return tryer.apply(this, arguments);&#xA;} catch (e) {&#xA;  return catcher.apply(this, _concat([e], arguments));&#xA;}&#xA;&#xA;// With pipes: Note the visual parallelism between the two clauses.&#xA;try {&#xA;  return arguments&#xA;    |&amp;gt; tryer.apply(this, %);&#xA;} catch (e) {&#xA;  return arguments&#xA;    |&amp;gt; _concat([e], %)&#xA;    |&amp;gt; catcher.apply(this, %);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/expressjs/express/raw/5.0/lib/response.js&#34;&gt;express/lib/response.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return this.set(&#39;Link&#39;, link + Object.keys(links).map(function(rel){&#xA;  return &#39;&amp;lt;&#39; + links[rel] + &#39;&amp;gt;; rel=&#34;&#39; + rel + &#39;&#34;&#39;;&#xA;}).join(&#39;, &#39;));&#xA;&#xA;// With pipes&#xA;return links&#xA;  |&amp;gt; Object.keys(%).map(function (rel) {&#xA;    return &#39;&amp;lt;&#39; + links[rel] + &#39;&amp;gt;; rel=&#34;&#39; + rel + &#39;&#34;&#39;;&#xA;  })&#xA;  |&amp;gt; link + %.join(&#39;, &#39;)&#xA;  |&amp;gt; this.set(&#39;Link&#39;, %);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;react/scripts/jest/jest-cli.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;console.log(&#xA;  chalk.dim(&#xA;    `$ ${Object.keys(envars)&#xA;      .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;      .join(&#39; &#39;)}`,&#xA;    &#39;node&#39;,&#xA;    args.join(&#39; &#39;)&#xA;  )&#xA;);&#xA;&#xA;// With pipes&#xA;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/ramda/ramda/raw/v0.27.1/dist/ramda.js&#34;&gt;ramda.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return _reduce(xf(typeof fn === &#39;function&#39; ? _xwrap(fn) : fn), acc, list);&#xA;&#xA;// With pipes&#xA;return fn&#xA;  |&amp;gt; (typeof % === &#39;function&#39; ? _xwrap(%) : %)&#xA;  |&amp;gt; xf(%)&#xA;  |&amp;gt; _reduce(%, acc, list);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/jquery/jquery/raw/2.2-stable/src/core/init.js&#34;&gt;jquery/src/core/init.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;jQuery.merge( this, jQuery.parseHTML(&#xA;  match[ 1 ],&#xA;  context &amp;amp;&amp;amp; context.nodeType ? context.ownerDocument || context : document,&#xA;  true&#xA;) );&#xA;&#xA;// With pipes&#xA;context&#xA;  |&amp;gt; (% &amp;amp;&amp;amp; %.nodeType ? %.ownerDocument || % : document)&#xA;  |&amp;gt; jQuery.parseHTML(match[1], %, true)&#xA;  |&amp;gt; jQuery.merge(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Relationships with other proposals&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;Function&lt;/code&gt; helpers&lt;/h3&gt; &#xA;&lt;p&gt;Hack pipes can and would coexist with the &lt;a href=&#34;https://github.com/js-choi/proposal-function-helpers&#34;&gt;&lt;code&gt;Function&lt;/code&gt; helpers proposal&lt;/a&gt;, including its &lt;code&gt;pipe&lt;/code&gt; and &lt;code&gt;flow&lt;/code&gt; functions. These simple (and commonly downloaded) convenience functions manipulate unary functions without extra syntax.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tc39-has-rejected-f-pipes-multiple-times&#34;&gt;TC39 has rejected the F# pipe operator twice&lt;/a&gt;. Given this reality, TC39 is considerably more likely to pass &lt;code&gt;pipe&lt;/code&gt; and &lt;code&gt;flow&lt;/code&gt; helper functions than a similar syntactic operator.&lt;/p&gt; &#xA;&lt;p&gt;Standardized &lt;code&gt;pipe&lt;/code&gt; and &lt;code&gt;flow&lt;/code&gt; convenience functions may also obviate some of the need for a F#-pipe infix operator. (They would not preclude standardizing an equivalent operator later. For example, TC39 standardized binary &lt;code&gt;**&lt;/code&gt; even when &lt;code&gt;Math.pow&lt;/code&gt; existed.)&lt;/p&gt; &#xA;&lt;h3&gt;Partial-function-application syntax&lt;/h3&gt; &#xA;&lt;p&gt;Hack pipes can coexist with a syntax for &lt;strong&gt;partial function application&lt;/strong&gt; (PFA). There are two approaches with which they may coexist.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;first approach&lt;/strong&gt; is with an &lt;strong&gt;eagerly&lt;/strong&gt; evaluated PFA syntax, which has &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;already been proposed in proposal-partial-application&lt;/a&gt;. This eager PFA syntax would add an &lt;code&gt;…~(…)&lt;/code&gt; operator. The operator’s right-hand side would be a list of arguments, each of which is an ordinary expression or a &lt;code&gt;?&lt;/code&gt; placeholder. Each consecutive &lt;code&gt;?&lt;/code&gt; placeholder would represent another parameter.&lt;/p&gt; &#xA;&lt;p&gt;Ordinary expressions would be evaluated &lt;strong&gt;before&lt;/strong&gt; the function is created. For example, &lt;code&gt;f~(g(), ?, h(), ?)&lt;/code&gt; would evaluate &lt;code&gt;f&lt;/code&gt;, then &lt;code&gt;g()&lt;/code&gt;, then &lt;code&gt;h()&lt;/code&gt;, and &lt;em&gt;then&lt;/em&gt; it would create a partially applied version of &lt;code&gt;f&lt;/code&gt; with two arguments.&lt;/p&gt; &#xA;&lt;p&gt;An optional number after &lt;code&gt;?&lt;/code&gt; placeholder would override the parameter’s position. For example, &lt;code&gt;f~(?1, ?0)&lt;/code&gt; would have two parameters but would switch them when calling &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;second approach&lt;/strong&gt; is with a &lt;strong&gt;lazily&lt;/strong&gt; evaluated syntax. This could be handled with an &lt;strong&gt;extension to Hack pipes&lt;/strong&gt;, with a syntax further inspired by &lt;a href=&#34;https://clojure.org/reference/reader#_dispatch&#34;&gt;Clojure’s &lt;code&gt;#(^1 ^2)&lt;/code&gt; function literals&lt;/a&gt;. It would do so by &lt;strong&gt;combining&lt;/strong&gt; the Hack pipe &lt;code&gt;|&amp;gt;&lt;/code&gt; with the &lt;strong&gt;arrow function&lt;/strong&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; into a &lt;strong&gt;pipe-function&lt;/strong&gt; operator &lt;code&gt;+&amp;gt;&lt;/code&gt;, which would use the same general rules as &lt;code&gt;|&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;+&amp;gt;&lt;/code&gt; would be a &lt;strong&gt;prefix operator&lt;/strong&gt; that &lt;strong&gt;creates a new function&lt;/strong&gt;, which in turn &lt;strong&gt;binds its argument(s)&lt;/strong&gt; to topic references. &lt;strong&gt;Non-unary functions&lt;/strong&gt; would be created by including topic references with &lt;strong&gt;numbers&lt;/strong&gt; (&lt;code&gt;%0&lt;/code&gt;, &lt;code&gt;%1&lt;/code&gt;, &lt;code&gt;%2&lt;/code&gt;, etc.) or &lt;code&gt;...&lt;/code&gt;. &lt;code&gt;%0&lt;/code&gt; (equivalent to plain &lt;code&gt;%&lt;/code&gt;) would be bound to the &lt;strong&gt;zeroth argument&lt;/strong&gt;, &lt;code&gt;%1&lt;/code&gt; would be bound to the next argument, and so on. &lt;code&gt;%...&lt;/code&gt; would be bound to an array of &lt;strong&gt;rest arguments&lt;/strong&gt;. And just as with &lt;code&gt;|&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&lt;/code&gt; would require its body to contain at least one topic reference in order to be syntactically valid.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Eager PFA&lt;/th&gt; &#xA;   &lt;th&gt;Pipe functions&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(f~(?, 0))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; f(%, 0))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(f~(?, ?, 0))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; f(%0, %1, 0))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(x=&amp;gt; x + 1)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; % + 1)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(x=&amp;gt; x + x)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; % + %)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(x=&amp;gt; f(x, x))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; f(%, %))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;In contrast to the &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;eagerly evaluated PFA syntax&lt;/a&gt;, topic functions would &lt;strong&gt;lazily&lt;/strong&gt; evaluate its arguments, just like how an arrow function would.&lt;/p&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;+&amp;gt; f(g(), %0, h(), %1)&lt;/code&gt; would evaluate &lt;code&gt;f&lt;/code&gt;, and then it would create an arrow function that closes over &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;. The created function would &lt;strong&gt;not&lt;/strong&gt; evaluate &lt;code&gt;g()&lt;/code&gt; or &lt;code&gt;h()&lt;/code&gt; until the every time the created function is called.&lt;/p&gt; &#xA;&lt;p&gt;No matter the approach taken, Hack pipes could coexist with PFA.&lt;/p&gt; &#xA;&lt;h3&gt;Eventual sending / pipelining&lt;/h3&gt; &#xA;&lt;p&gt;Despite sharing the word “pipe” in their name, the pipe operator and the &lt;a href=&#34;https://github.com/tc39/proposal-eventual-send/&#34;&gt;eventual-send proposal&lt;/a&gt;’s remote-object pipelines are orthogonal and independent. They can coexist and even work together.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fileP = E(&#xA;  E(target).openDirectory(dirName)&#xA;).openFile(fileName);&#xA;&#xA;const fileP = target&#xA;|&amp;gt; E(%).openDirectory(dirName)&#xA;|&amp;gt; E(%).openFile(fileName);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Possible future extensions&lt;/h2&gt; &#xA;&lt;h3&gt;Hack-pipe syntax for &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;–&lt;code&gt;of&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Many &lt;strong&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt; statements&lt;/strong&gt; could become pithier if they gained &lt;strong&gt;“pipe syntax”&lt;/strong&gt; that bound the topic reference.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;if () |&amp;gt;&lt;/code&gt; would bind its condition value to &lt;code&gt;%&lt;/code&gt;,&lt;br&gt; &lt;code&gt;catch |&amp;gt;&lt;/code&gt; would bind its caught error to &lt;code&gt;%&lt;/code&gt;,&lt;br&gt; and &lt;code&gt;for (of) |&amp;gt;&lt;/code&gt; would consecutively bind each of its iterator’s values to &lt;code&gt;%&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Status quo&lt;/th&gt; &#xA;   &lt;th&gt;Hack-pipe statement syntax&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;const c = f(); if (c) g(c);&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;if (f()) |&amp;gt; g(%);&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;catch (e) f(e);&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;catch |&amp;gt; f(%);&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;for (const v of f()) g(v);&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;for (f()) |&amp;gt; g(%);&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Optional Hack pipes&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;strong&gt;short-circuiting&lt;/strong&gt; optional-pipe operator &lt;code&gt;|?&amp;gt;&lt;/code&gt; could also be useful, much in the way &lt;code&gt;?.&lt;/code&gt; is useful for optional method calls.&lt;/p&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;value |&amp;gt; (% == null ? % : await foo(%) |&amp;gt; (% == null ? % : % + 1))&lt;/code&gt;&lt;br&gt; would be equivalent to &lt;code&gt;value |?&amp;gt; await foo(%) |?&amp;gt; % + 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Tacit unary function application syntax&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt; for &lt;strong&gt;tacit unary function application&lt;/strong&gt; – that is, the F# pipe operator – has been &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tc39-has-rejected-f-pipes-multiple-times&#34;&gt;rejected twice by TC39&lt;/a&gt;. However, they could still eventually be added to the language in two ways.&lt;/p&gt; &#xA;&lt;p&gt;First, it can be added as a convenience function &lt;code&gt;Function.pipe&lt;/code&gt;. This is what the &lt;a href=&#34;https://github.com/js-choi/proposal-function-helpers&#34;&gt;function-helpers proposal&lt;/a&gt; proposes. &lt;code&gt;Function.pipe&lt;/code&gt; may obviate much of the need for an F#-pipe operator, while still not closing off the possibility of an F#-pipe operator.&lt;/p&gt; &#xA;&lt;p&gt;Secondly, it can be added as &lt;strong&gt;another pipe operator&lt;/strong&gt; &lt;code&gt;|&amp;gt;&amp;gt;&lt;/code&gt; – similarly to how &lt;a href=&#34;https://clojure.org/guides/threading_macros&#34;&gt;Clojure has multiple pipe macros&lt;/a&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;as-&amp;gt;&lt;/code&gt;.&lt;br&gt; For example, &lt;code&gt;value |&amp;gt; % + 1 |&amp;gt;&amp;gt; f |&amp;gt; g(%, 0)&lt;/code&gt;&lt;br&gt; would mean &lt;code&gt;value |&amp;gt; % + 1 |&amp;gt; f(%) |&amp;gt; g(%, 0)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There was an &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tacit-unary-function-application-syntax&#34;&gt;informal proposal for such a &lt;strong&gt;split mix&lt;/strong&gt; of two pipe operators&lt;/a&gt;, which was set aside in favor of single-operator proposals. This split mix might return as a proposal after Hack pipes.&lt;/p&gt;</summary>
  </entry>
</feed>