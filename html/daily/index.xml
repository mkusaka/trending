<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-27T01:36:43Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins</title>
    <updated>2023-06-27T01:36:43Z</updated>
    <id>tag:github.com,2023-06-27:/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins</id>
    <link href="https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DevOps-MasterPiece Project using Git, GitHub, Jenkins, Maven, JUnit, SonarQube, Jfrog Artifactory, Docker, Trivy, AWS S3, Docker Hub, GitHub CLI, EKS, ArgoCD, Prometheus, Grafana, Slack and Hashicorp Vault&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DevOps-MasterPiece&lt;/h1&gt; &#xA;&lt;p&gt;In this project, I created an end-to-end Production like CI-CD pipeline while keeping in mind Securities Best Practices,DevSecOps principles and used all these tools &lt;em&gt;Git, GitHub, Jenkins, Maven, JUnit, SonarQube, Jfrog Artifactory, Docker, Trivy, AWS S3, Docker Hub, GitHub CLI, EKS, ArgoCD, Prometheus, Grafana, Slack and Hashicorp Vault,&lt;/em&gt; to achieve the goal.&lt;/p&gt; &#xA;&lt;h4&gt;I used Jenkins for Continuous Integration and ArgoCD for Continuous Deployment.&lt;/h4&gt; &#xA;&lt;h2&gt;Project Architecture&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/pipeline.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Pipeline flow:&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;When an event (commit) will occur in the application code GitHub repo, the GitHub webhook will push the code to Jenkins and Jenkins will start the build.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Maven will build the code, if the build fails, the whole pipeline will become a failure and Jenkins will notify the user using Slack, If build success then&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Junit will do unit testing, if the application passes test cases then will go to the next step otherwise the whole pipeline will become a failure Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SonarQube scanner will scan the code and will send the report to the SonarQube server, where the report will go through the quality gate and gives the output to the web Dashboard.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In the quality gate, we define conditions or rules like how many bugs or vulnerabilities, or code smells should be present in the code. Also, we have to create a webhook to send the status of quality gate status to Jenkins. If the quality gate status becomes a failure, the whole pipeline will become a failure then Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After the quality gate passes, Artifacts will be sent to Jfrog Artifactory. If artifacts send to the artifactory successfully then will go to the next stage otherwise the whole pipeline will become a failure Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After successful artifacts push to Artifactory, Docker will build the docker image. if the docker build fails when the whole pipeline will become a failure and Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Trivy will scan the docker image, if it finds any Vulnerability then the whole pipeline will become a failure, and the generated report will be sent to s3 for future review and Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After the Trivy scan docker images will be pushed to the docker hub, if the docker fails to push docker images to the docker hub then the pipeline will become a failure and Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After the docker push, Jenkins will clone the Kubernetes manifest repo from the feature branch, if the repo is already present then it will only pull the changes. If Jenkins is unable to clone the repo then the whole pipeline will become a failure and Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After Cloning the repo, Jenkins will update the image tag in the deployment manifest. If Jenkins is unable to update the image tag then the whole pipeline will become a failure and Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After updating the image tag, Jenkins will commit the change and push the code to the feature branch. If Jenkins is unable to push the changes to the feature branch then the whole pipeline will become a failure and Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After pushing changes to the feature branch, Jenkins will create a pull request against the main branch. If Jenkins is unable to create a pull request then the whole pipeline will become a failure and Jenkins will notify the user that your build fails.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After the pull request creation, a senior person from the team will review and merge the pull request.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After merging the feature branch into the main branch, ArgoCD will pull the changes and deploy the application into Kubernetes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;PreRequisites&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;JDK&lt;/li&gt; &#xA; &lt;li&gt;Git&lt;/li&gt; &#xA; &lt;li&gt;Github&lt;/li&gt; &#xA; &lt;li&gt;GitHub CLI&lt;/li&gt; &#xA; &lt;li&gt;Jenkins&lt;/li&gt; &#xA; &lt;li&gt;Sonarqube&lt;/li&gt; &#xA; &lt;li&gt;Jfrog Artifactory&lt;/li&gt; &#xA; &lt;li&gt;Docker&lt;/li&gt; &#xA; &lt;li&gt;Trivy&lt;/li&gt; &#xA; &lt;li&gt;AWS account&lt;/li&gt; &#xA; &lt;li&gt;AWS CLI&lt;/li&gt; &#xA; &lt;li&gt;Docker Hub account&lt;/li&gt; &#xA; &lt;li&gt;Terraform&lt;/li&gt; &#xA; &lt;li&gt;EKS Cluster&lt;/li&gt; &#xA; &lt;li&gt;ArgoCD&lt;/li&gt; &#xA; &lt;li&gt;Helm&lt;/li&gt; &#xA; &lt;li&gt;Prometheus &amp;amp; Grafana&lt;/li&gt; &#xA; &lt;li&gt;Hashicorp Vault&lt;/li&gt; &#xA; &lt;li&gt;Slack&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Server Configuration ( I used )&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;2 t2.medium ( ubuntu) EC2 Instances – 1. one for sonarqube and Hashicorp vault server 2. another for Jfrog Artifactory&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1 t2.large (ubuntu ) EC2 Instance - For Jenkins, Docker, Trivy, AWS CLI, Github CLI, Terraform&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;EKS Cluster with t3.medium nodes&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Want to create this Project on your own then &lt;em&gt;Follow these project steps&lt;/em&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Step: 1 Installation Part&lt;/h2&gt; &#xA;&lt;h3&gt;Stage-01: Install JDK and Create a Java Springboot application&lt;/h3&gt; &#xA;&lt;p&gt;Push all the web application code files into GitHub&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-23%2022-45-05.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Stage-02: Install Jenkins, Docker, Trivy, AWS CLI, Github CLI, Terraform ( t2.large node1 -Jenkins-server)&lt;/h3&gt; &#xA;&lt;h4&gt;Jenkins Installation Prerequisites &lt;a href=&#34;https://www.jenkins.io/doc/book/installing/linux/&#34;&gt;https://www.jenkins.io/doc/book/installing/linux/&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Installation guide is available here &lt;a href=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Jenkins_installation.md&#34;&gt;https://github.com/praveensirvi1212/DevSecOps-project/blob/main/Jenkins_installation.md&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;After installation, install the suggested plugins&lt;/li&gt; &#xA; &lt;li&gt;Open Jenkins Dashboard and install required plugins – SonarQube Scanner, Quality gates, Artifactory, Hashicorp Vault, Slack, Open Blue Ocean&lt;/li&gt; &#xA; &lt;li&gt;go to manage Jenkins &amp;gt; manage plugins &amp;gt; search for plugins &amp;gt; Download now and install after restart &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/jenkins.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Docker Installtion&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install docker using this command&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install docker.io&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;add the current user and Jenkins user into the docker group&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo usermod -aG docker $USER&#xA;sudo usermod -aG docker jenkins&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Trivy Installation&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Insatll trivy using this commands&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install wget apt-transport-https gnupg lsb-release&#xA;wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -&#xA;echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list&#xA;sudo apt-get update&#xA;sudo apt-get install trivy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;AWS CLI installation&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;install aws cli using these commands&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install unzip&#xA;curl &#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip&#34; -o &#34;awscliv2.zip&#34;&#xA;unzip awscliv2.zip&#xA;sudo ./aws/install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install GitHub CLI&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;install GitHub cli using these commands&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;type -p curl &amp;gt;/dev/null || (sudo apt update &amp;amp;&amp;amp; sudo apt install curl -y)&#xA;curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \&#xA;&amp;amp;&amp;amp; sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \&#xA;&amp;amp;&amp;amp; echo &#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main&#34; | sudo tee /etc/apt/sources.list.d/github-cli.list &amp;gt; /dev/null \&#xA;&amp;amp;&amp;amp; sudo apt update \&#xA;&amp;amp;&amp;amp; sudo apt install gh -y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install Terraform&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;install terraform using these commands&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y gnupg software-properties-common&#xA;wget -O- https://apt.releases.hashicorp.com/gpg | \&#xA;gpg --dearmor | \&#xA;sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg&#xA;gpg --no-default-keyring \&#xA;&#x9;--keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg \&#xA;&#x9;--fingerprint&#xA;echo &#34;deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \&#xA;https://apt.releases.hashicorp.com $(lsb_release -cs) main&#34; | \&#xA;sudo tee /etc/apt/sources.list.d/hashicorp.list&#xA;sudo apt update&#xA;sudo apt-get install terraform&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-03 : Install SonarQube and Hashicorp Vault ( t2.medium node2 - SonarQube Server )&lt;/h3&gt; &#xA;&lt;h4&gt;SonarQube installation&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;install docker on the sonarqube server&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt update&#xA;sudo apt install docker.io&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;create a docker container to install SonarQube&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo docker run -d -p 9000:9000 --name sonarqube sonarqube  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install the Hashicorp Vault server&lt;/h4&gt; &#xA;&lt;p&gt;HashiCorp Vault is a&amp;nbsp;secret-management&amp;nbsp;tool specifically designed to control access to sensitive credentials in a low-trust environment.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Installation vault using these commands&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -&#xA;sudo apt-add-repository &#34;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main&#34;&#xA;sudo apt update&#xA;sudo apt install vault -y&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-04: Install Jfrog Artifactory ( t2.medium node3 - Jforg-artifactory server )&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;install the docker&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt update&#xA;sudo apt install docker.io&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;install Jfrog Artifactory&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo docker pull&amp;nbsp;docker.bintray.io/jfrog/artifactory-oss:latest&#xA;sudo mkdir -p /jfrog/artifactory&#xA;sudo chown -R 1030 /jfrog/&#xA;sudo docker run --name artifactory -d -p 8081:8081 -p 8082:8082 \&#xA;&#x9;-v /jfrog/artifactory:/var/opt/jfrog/artifactory \&#xA;&#x9;docker.bintray.io/jfrog/artifactory-oss:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-05 : Install Slack ( on your local system or login in google chrome)&lt;/h3&gt; &#xA;&lt;p&gt;Slack is a workplace communication tool, “a single place for messaging, tools and files.” .&lt;/p&gt; &#xA;&lt;p&gt;Install Slack from the official website of Slack &lt;a href=&#34;https://slack.com/intl/en-in/downloads/linux&#34;&gt;https://slack.com/intl/en-in/downloads/linux&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Stage-06: EKS Cluster Creation using Terraform&lt;/h3&gt; &#xA;&lt;p&gt;To create EKS Cluster using Terraform, I have put the Terraform code here - &lt;a href=&#34;https://github.com/praveensirvi1212/medicure-project/tree/master/eks_module&#34;&gt;https://github.com/praveensirvi1212/medicure-project/tree/master/eks_module&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Suggestion – create eks cluster after successful configuration of jenkins server. When jenkins is able to create pull request in the manifest repo.&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Note: I have installed the terraform in the jenkins server and configured aws cli to create eks cluster. But you can use your local system to create eks cluster . for this, you have to install Terraform and aws cli on your local system.&lt;/h4&gt; &#xA;&lt;p&gt;Run this command after eks cluster creation to update or configure &lt;code&gt;.kube/config&lt;/code&gt; file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;aws eks --region your-region-name update-kubeconfig --name cluster-name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-07: Install ArgoCD in EKS&lt;/h3&gt; &#xA;&lt;p&gt;I am assuming that you have already Kubernetes cluster running&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;use these commands to install argocd&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kubectl create namespace argocd &#xA;kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;edit the argocd-server service to NodePort to access argocd ui&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kubectl -n argocd edit svc argocd-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-08: Install helm ( on the system from where you are creating eks cluster)&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;use these commands to install the helm&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl https://baltocdn.com/helm/signing.asc | gpg --dearmor | sudo tee /usr/share/keyrings/helm.gpg &amp;gt; /dev/null&#xA;sudo apt-get install apt-transport-https --yes&#xA;echo &#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main&#34; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list&#xA;sudo apt-get update&#xA;sudo apt-get install helm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-09: Install Prometheus and Grafana ( from where you have installed helm)&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;use helm to install Prometheus and grafana&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;helm repo add stable https://charts.helm.sh/stable&#xA;helm repo add prometheus-community https://prometheus-community.github.io/helm-charts&#xA;helm search repo prometheus-community&#xA;kubectl create namespace prometheus&#xA;helm install stable prometheus-community/kube-prometheus-stack -n prometheus&#xA;kubectl get pods -n prometheus&#xA;kubectl get svc -n prometheus&#xA;#in order to make Prometheus and grafana available outside the cluster, use LoadBalancer or NodePort instead of ClusterIP.&#xA;#Edit Prometheus Service&#xA;kubectl edit svc stable-kube-prometheus-sta-prometheus -n prometheus&#xA;#Edit Grafana Service&#xA;kubectl edit svc stable-grafana -n prometheus&#xA;kubectl get svc -n prometheus&#xA;&#xA;#Access Grafana UI in the browser using load balancer or nodeport&#xA;&#xA;UserName: admin &#xA;Password: prom-operator&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Done with Installation, Now will we Configure each the tools&lt;/h1&gt; &#xA;&lt;h2&gt;Step: 2 Configure Individual tool&lt;/h2&gt; &#xA;&lt;h3&gt;Stage-01 : Jenkins Configuration&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to Manage Jenkins &amp;gt; configure tools &amp;gt; go to maven&amp;gt; give some name and click on install automatically&lt;/li&gt; &#xA; &lt;li&gt;go to Manage Jenkins &amp;gt; configure tools &amp;gt; go to sonarqube scanner &amp;gt; give some name and click on install automatically&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-02: Hashicorp Vault Configuration&lt;/h3&gt; &#xA;&lt;p&gt;I am assuming that your Vault server is installed and running&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;open the &lt;code&gt; /etc/vault.d/vault.hcl&lt;/code&gt; file with vi or nano&lt;/li&gt; &#xA; &lt;li&gt;replace all the content of this file with this&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;storage &#34;raft&#34; {&#xA;  path    = &#34;/opt/vault/data&#34;&#xA;  node_id = &#34;raft_node_1&#34;&#xA;}&#xA;&#xA;listener &#34;tcp&#34; {&#xA;  address     = &#34;0.0.0.0:8200&#34;&#xA;  tls_disable = 1&#xA;}&#xA;&#xA;api_addr = &#34;http://127.0.0.1:8200&#34;&#xA;cluster_addr = &#34;https://127.0.0.1:8201&#34;&#xA;ui = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo systemctl stop vault&#xA;sudo systemctl start vault&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Commands to run to configure Vault and create AppRole&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export VAULT_ADDR=&#39;http://127.0.0.1:8200&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault operator init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;copy the unseal tokens and initial root token, save it somewhere for later use&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault operator unseal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Paste the first unseal token here&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault operator unseal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Paste the second unseal token here&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault operator unseal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Paste the third unseal token here&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault login &amp;lt;Initial_Root_Token&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;Initial_Root_Token&amp;gt;&lt;/code&gt; is found in the output of &lt;code&gt;vault operator init&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault auth enable approle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault write auth/approle/role/jenkins-role token_num_uses=0 secret_id_num_uses=0 policies=&#34;jenkins&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;This app role will use for jenkins integration&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault read auth/approle/role/jenkins-role/role-id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Copy the role_id and token, and store somewhere&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault write -f auth/approle/role/jenkins-role/secret-id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Copy the secret-id and token, store them somewhere&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Stage-03: SonarQube Server Configuration&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Access the sonarqube ui using the public IP of the server and port 9000&lt;/li&gt; &#xA; &lt;li&gt;default username-password &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt; admin&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h5&gt;Project setup&lt;/h5&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;chose use global setting &lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/sonarqube-.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;create a project manually, give some name to project, project key &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/sonarqubedb.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;click on setup&lt;/li&gt; &#xA; &lt;li&gt;click on other ci&lt;/li&gt; &#xA; &lt;li&gt;give some name to the token and click on generate, save it for a later user&lt;/li&gt; &#xA; &lt;li&gt;click on global&lt;/li&gt; &#xA; &lt;li&gt;select the project type, in this case, I used Maven &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/soanr.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;copy the whole command and save it somewhere&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h5&gt;Create Quality Gate&lt;/h5&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Click on Quality Gates&lt;/li&gt; &#xA; &lt;li&gt;create a new Quality Gate according to your conditions &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/quality%20gate.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;click on Projects &amp;gt; click on all &amp;gt; select your project &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/qualiygate.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;set as default&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h5&gt;Create webhook&lt;/h5&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;click on Administration&lt;/li&gt; &#xA; &lt;li&gt;click on Configuration &amp;gt; click on webhooks&lt;/li&gt; &#xA; &lt;li&gt;create a webhook &amp;gt; Give some name&lt;/li&gt; &#xA; &lt;li&gt;for url use &lt;code&gt;http://jenkins-server-url-with-port/sonarqube-webhook/&lt;/code&gt; &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/webhook.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;in secret leave the blank&lt;/li&gt; &#xA; &lt;li&gt;click on create&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h5&gt;Note: if this webhook does not work fine, then recreate the webhook after integrating the soanrqube with jenkins&lt;/h5&gt; &#xA;&lt;h3&gt;Stage-04: Artifactory Configuration&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;access the UI with public IP and port 8081&lt;/li&gt; &#xA; &lt;li&gt;use username-password as &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;update the password&lt;/li&gt; &#xA; &lt;li&gt;create a Maven repo&lt;/li&gt; &#xA; &lt;li&gt;now go to Administration &amp;gt; User management &amp;gt; Create a new user&lt;/li&gt; &#xA; &lt;li&gt;now go to Repositories &amp;gt; create &amp;gt; locally &amp;gt; give some name like &lt;code&gt;my-local-repo&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-05: S3 Bucket creation to store Trivy report&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;login into aws account&lt;/li&gt; &#xA; &lt;li&gt;search for S3&lt;/li&gt; &#xA; &lt;li&gt;create a bucket with a unique name&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-06: DockerHub account creation&lt;/h3&gt; &#xA;&lt;p&gt;If you already have a dockerhub account then no need to create another&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to dockerhub official website &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/dockerhub.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;click on sign up&lt;/li&gt; &#xA; &lt;li&gt;fill in the details and sing up&lt;/li&gt; &#xA; &lt;li&gt;login into dockerhub&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note: we can create token from dockerhub to integrate jenkins but in this case, I am using docker username and password.&lt;/p&gt; &#xA;&lt;h3&gt;Stage-07: Slack Configuration for jenkins&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://slack.com/intl/en-in&#34;&gt;https://slack.com/intl/en-in&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;sign up with Google&lt;/li&gt; &#xA; &lt;li&gt;create a workspace&lt;/li&gt; &#xA; &lt;li&gt;just give a name&lt;/li&gt; &#xA; &lt;li&gt;you can skip add team member&lt;/li&gt; &#xA; &lt;li&gt;give some name to team working ( channel name like - cicd-pipeline)&lt;/li&gt; &#xA; &lt;li&gt;now go to this site &lt;a href=&#34;https://slack-t8s2905.slack.com/intl/en-in/apps&#34;&gt;https://slack-t8s2905.slack.com/intl/en-in/apps&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;login into your workspace (if need)&lt;/li&gt; &#xA; &lt;li&gt;now click on Get Essential Apps&lt;/li&gt; &#xA; &lt;li&gt;search Jenkins in search bar &amp;gt; click on it&lt;/li&gt; &#xA; &lt;li&gt;click on Add to Slack&lt;/li&gt; &#xA; &lt;li&gt;select channel name &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/slack.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;click on Add Jenkins CI Integration&lt;/li&gt; &#xA; &lt;li&gt;go down to step 3 and copy Integration Token Credential ID and save it somewhere&lt;/li&gt; &#xA; &lt;li&gt;click on Save settings&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-08: Slack Configuration for ArgoCD&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to this site &lt;a href=&#34;https://api.slack.com/apps&#34;&gt;https://api.slack.com/apps&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;click on Create New App&lt;/li&gt; &#xA; &lt;li&gt;select From scratch&lt;/li&gt; &#xA; &lt;li&gt;give some app name&lt;/li&gt; &#xA; &lt;li&gt;pick your workspace&lt;/li&gt; &#xA; &lt;li&gt;click on Create App&lt;/li&gt; &#xA; &lt;li&gt;go to OAuth &amp;amp; Permission&lt;/li&gt; &#xA; &lt;li&gt;go to Scope &amp;gt; Bot Token Scope&lt;/li&gt; &#xA; &lt;li&gt;search in the search bar and select &lt;code&gt;chat:write&lt;/code&gt; ,&lt;code&gt;chat:write.customize&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;now to up to OAuth Token for Your Workspace&lt;/li&gt; &#xA; &lt;li&gt;click on Install to workspace&lt;/li&gt; &#xA; &lt;li&gt;allow your app to access your workspace&lt;/li&gt; &#xA; &lt;li&gt;now copy Bot user OAuth Token and save it somewhere&lt;/li&gt; &#xA; &lt;li&gt;now open slack , you will find your app in Apps&lt;/li&gt; &#xA; &lt;li&gt;now create a channel - click on channels &amp;gt; create channel &amp;gt; give some name to channel &amp;gt; create&lt;/li&gt; &#xA; &lt;li&gt;now in message bar type &lt;code&gt;@your-app-name&lt;/code&gt; and click on send icon &amp;gt; click on add to channel&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Done with Configuration of all tools, Now will we store the credentials into Vault server&lt;/h1&gt; &#xA;&lt;h2&gt;Step: 3 Store the Credentials in the Vault server&lt;/h2&gt; &#xA;&lt;p&gt;run all these commands into the vault server&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;enable secrets path&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault secrets enable -path=secrets kv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;write the secret into secret path&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault write secrets/creds/docker username=abcd password=xyz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;likewise, we can store all the credentials in the vault server. I have stored only the docker credential but you can store all your credential like this.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;create a jenkins policy file with vi or nano &lt;code&gt; jenkins-policy.hcl&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;path &#34;secrets/creds/*&#34; {&#xA; capabilities = [&#34;read&#34;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the policy is created with * means the vault server can read credentials from every path. No need to create policies for each path like &lt;code&gt;secrets/creds/docker&lt;/code&gt; , &lt;code&gt;secrets/creds/slack&lt;/code&gt; etc…&lt;/p&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;run this command to create a policy&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vault policy write jenkins jenkins-policy.hcl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Done with Configuration of all tools, Now will we integrate tools with jenkins&lt;/h1&gt; &#xA;&lt;h2&gt;Step: 4 Integrate all the tools into jenkins for CI&lt;/h2&gt; &#xA;&lt;h3&gt;Stage-01: Hashicorp Vault server integration with Jenkins&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to Jenkins&amp;gt; Manage Jenkins &amp;gt;Manage Credentials &amp;gt; system &amp;gt; Add credentials &amp;gt; Vault App Role Credentials &amp;gt; Paste role-id and secret-id token (we create in Vault - approle) and save and apply. &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/approleVault.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;now to Manage Jenkins &amp;gt; configure system/system&amp;gt; search for vault plugin&lt;/li&gt; &#xA; &lt;li&gt;give the URL of the vault server&lt;/li&gt; &#xA; &lt;li&gt;attach the credentials we created&lt;/li&gt; &#xA; &lt;li&gt;click on Advanced&lt;/li&gt; &#xA; &lt;li&gt;select k/v engine as 1&lt;/li&gt; &#xA; &lt;li&gt;click on skip ssl verification&lt;/li&gt; &#xA; &lt;li&gt;Apply and Save&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-02: SonarQube server integration with Jenkins&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to Manage Jenkins&amp;gt;Manage Credentials &amp;gt; system &amp;gt; Add credentials &amp;gt; secret text file &amp;gt; paste the token we create in sonarqube and save and apply.&lt;/li&gt; &#xA; &lt;li&gt;now to Manage Jenkins &amp;gt; configure system/system&amp;gt; search for SonarQube Server&lt;/li&gt; &#xA; &lt;li&gt;enable the environment variables&lt;/li&gt; &#xA; &lt;li&gt;write the name of Sonaqube server&lt;/li&gt; &#xA; &lt;li&gt;paste the url of SonarQube server&lt;/li&gt; &#xA; &lt;li&gt;select the credential&lt;/li&gt; &#xA; &lt;li&gt;Apply and Save&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-03: Jforg Artifactory integration with Jenkins&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to Manage Jenkins&amp;gt;Manage Credentials &amp;gt; system &amp;gt; Add credentials &amp;gt; username and password &amp;gt; write the username and password we created in jforg artifacotry and save and apply.&lt;/li&gt; &#xA; &lt;li&gt;now to Manage Jenkins &amp;gt; configure system/system&amp;gt; search for Jfrog&lt;/li&gt; &#xA; &lt;li&gt;give instance id as artifactory name&lt;/li&gt; &#xA; &lt;li&gt;Jfrog Platform url - artifactory url like - &lt;a href=&#34;http://localhost:8082&#34;&gt;http://localhost:8082&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;click on Advanced&lt;/li&gt; &#xA; &lt;li&gt;JFrog Artifactory URL - &lt;a href=&#34;http://localhost:8082/artifactory&#34;&gt;http://localhost:8082/artifactory&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;JFrog Distribution URL - &lt;a href=&#34;http://localhost:8082/distribution&#34;&gt;http://localhost:8082/distribution&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Default Deployer Credentials – give username and password of artifactory (not admin user)&lt;/li&gt; &#xA; &lt;li&gt;Apply and save&lt;/li&gt; &#xA; &lt;li&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-04: AWS S3 integration with Jenkins&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;for S3 integration we will configure aws cli in the pipeline itself&lt;/li&gt; &#xA; &lt;li&gt;create credentials for aws cli, use both as the secret text&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-05: DockerHub integration with Jenkins&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to Manage jenkins &amp;gt;Manage Credentials &amp;gt; system &amp;gt; Add credentials &amp;gt; vault Username-Password Credential&lt;/li&gt; &#xA; &lt;li&gt;namespace – leave blank&lt;/li&gt; &#xA; &lt;li&gt;Prefix Path – leave blank&lt;/li&gt; &#xA; &lt;li&gt;Path – secrets/creds/docker&lt;/li&gt; &#xA; &lt;li&gt;Username Key- username&lt;/li&gt; &#xA; &lt;li&gt;Password key – password&lt;/li&gt; &#xA; &lt;li&gt;k/v engine – 1&lt;/li&gt; &#xA; &lt;li&gt;id – give some id like docker-cred&lt;/li&gt; &#xA; &lt;li&gt;Description - give some description&lt;/li&gt; &#xA; &lt;li&gt;click on Test Vault Secrets retrieval &amp;gt; should give output as secrets retrieved successfully otherwise reconfigure the vault server in jenkins&lt;/li&gt; &#xA; &lt;li&gt;Apply and Save&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-05: Slack integration with Jenkins&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to Manage Jenkins&amp;gt;Manage Credentials &amp;gt; system &amp;gt; Add credentials &amp;gt; secret text file &amp;gt; give some name to credentials, paste the token we create in the Slack app and save and apply.&lt;/li&gt; &#xA; &lt;li&gt;now to Manage Jenkins &amp;gt; configure system/system&amp;gt; search for Slack &lt;img src=&#34;https://github.com/praveensirvi1212/DevSecOps-project/raw/main/Images/slcakws.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;workspace – your workspace name ( you create after login into Slack)&lt;/li&gt; &#xA; &lt;li&gt;Credential – attach the slack token&lt;/li&gt; &#xA; &lt;li&gt;Default channel name – write the channel name we created at the time of slack installation like - #cicd-pipeline&lt;/li&gt; &#xA; &lt;li&gt;Apply and save&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-06: GitHub integration with Jenkins ( application code repo )&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to GitHub &amp;gt; go to application code repo &amp;gt; settings&lt;/li&gt; &#xA; &lt;li&gt;go to webhook &amp;gt; Add webhook&lt;/li&gt; &#xA; &lt;li&gt;Payload URL - &lt;a href=&#34;http://jenkins-server-public-ip-with-port/github-webhook/&#34;&gt;http://jenkins-server-public-ip-with-port/github-webhook/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;click on Add Webhook&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Done with the integration of tools with jenkins, Now will we integrate tools with ArgoCD&lt;/h1&gt; &#xA;&lt;h2&gt;Step: 5 Integrate ArgoCD with GitHub and Slack for CD&lt;/h2&gt; &#xA;&lt;h3&gt;Stage-01: ArgoCD integration with Github ( k8s manifest repo)&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;access the argocd UI – node public ip and node port&lt;/li&gt; &#xA; &lt;li&gt;user username as &lt;code&gt;admin&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;for password run this command&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt; kubectl -n argocd get secret argocd-initial-admin-secret -o yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;copy the password and decode it using&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ehco “copied-password” | base64 -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;copy the decoded password and login into argocd&lt;/li&gt; &#xA; &lt;li&gt;go to User Info – update password&lt;/li&gt; &#xA; &lt;li&gt;now go to Application&lt;/li&gt; &#xA; &lt;li&gt;click on New Application&lt;/li&gt; &#xA; &lt;li&gt;give app name&lt;/li&gt; &#xA; &lt;li&gt;chose Project Name as default&lt;/li&gt; &#xA; &lt;li&gt;SYNC Policy – Automatic&lt;/li&gt; &#xA; &lt;li&gt;enable PRUNE RESOURCES and SELF HEAL&lt;/li&gt; &#xA; &lt;li&gt;SOURCE-&lt;/li&gt; &#xA; &lt;li&gt;Repository URL – give your repo URL where you stored the k8s manifest&lt;/li&gt; &#xA; &lt;li&gt;Path – yamls&lt;/li&gt; &#xA; &lt;li&gt;DESTINATION -&lt;/li&gt; &#xA; &lt;li&gt;Cluster Url – chose default&lt;/li&gt; &#xA; &lt;li&gt;namespace- default&lt;/li&gt; &#xA; &lt;li&gt;click on create&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Stage-02: Slack integration with ArgoCD&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;encode your Slack token using this command ( Bot Token )&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &#34;your-slack-token&#34; | base64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;edit &lt;code&gt;argocd-notifications-secret&lt;/code&gt; secret to add slack token&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kubectl -n argocd edit secret argocd-notifications-secret&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;add data field after &lt;code&gt;apiVersion: v1&lt;/code&gt;, Replace &lt;code&gt;xxxx-xxxxx-xx&lt;/code&gt; with your encoded slack token&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;data:&#xA;  slack-token: xxxxx-xxxxxx-xxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;now edit &lt;code&gt;argocd-notifications-cm&lt;/code&gt; configmap&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kubectl -n argocd edit cm argocd-notifications-cm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;add this service for slack after &lt;code&gt;apiVersion: v1&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;data:&#xA;  service.slack: |&#xA;    token: $slack-token&#xA;    username: argocd-bot&#xA;    icon: &#34;&lt;span&gt;🚀&lt;/span&gt;&#34;&#xA;  template.app-sync-succeeded-slack: &#34;message: | \n      Application {{.app.metadata.name}}&#xA;    is now {{.app.status.sync.status}}\n&#34;&#xA;  trigger.on-sync-succeeded: |&#xA;    - when: app.status.sync.status == &#39;Synced&#39;&#xA;      send: [app-sync-succeeded-slack]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;add slack notification annotation in application&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kubectl -n argocd edit application your-app-name-you-created-in-argocd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;add this annotation in metadata section like this&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;  annotations:&#xA;    notifications.argoproj.io/subscribe.on-sync-succeeded.slack: your-slack-channel-name&#xA;  name: argocd-demo&#xA;  namespace: argocd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-03: Prometheus and Grafana Integration&lt;/h3&gt; &#xA;&lt;p&gt;use this docs to import grafana Dashboard into grafana &lt;a href=&#34;https://www.coachdevops.com/2022/05/how-to-setup-monitoring-on-kubernetes.html&#34;&gt;https://www.coachdevops.com/2022/05/how-to-setup-monitoring-on-kubernetes.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;We integrated all the tools with Jenkins, Now Create a declarative jenkins pipeline for each stage.&lt;/h1&gt; &#xA;&lt;h2&gt;Step: 6 Pipeline creation&lt;/h2&gt; &#xA;&lt;h3&gt;General Jenkins declarative Pipeline Syntax&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pipeline {&#xA;    agent any&#xA;    tools {&#xA;        maven &#39;apache-maven-3.0.1&#39; &#xA;    }&#xA;    stages {&#xA;        stage(&#39;Example&#39;) {&#xA;            steps {&#xA;                sh &#39;mvn --version&#39;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-01 : Git Checkout&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage as git checkout&lt;/li&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://opensource.triology.de/jenkins/pipeline-syntax/&#34;&gt;https://opensource.triology.de/jenkins/pipeline-syntax/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;search for checkout: check out version control&lt;/li&gt; &#xA; &lt;li&gt;give your GitHub URL, branch and generate the pipeline syntax&lt;/li&gt; &#xA; &lt;li&gt;paste it into stage steps git check&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;Checkout git&#39;) {&#xA;            steps {&#xA;              git branch: &#39;main&#39;, url:&#39;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins.git&#39;&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-02: Build and Junit test&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage as Build and Junit test&lt;/li&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://opensource.triology.de/jenkins/pipeline-syntax/&#34;&gt;https://opensource.triology.de/jenkins/pipeline-syntax/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;search for sh: shell script&lt;/li&gt; &#xA; &lt;li&gt;give your shell command and generate the pipeline syntax&lt;/li&gt; &#xA; &lt;li&gt;paste it into stage &amp;gt; steps &amp;gt; sh ‘ shell command’&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage (&#39;Build &amp;amp; JUnit Test&#39;) {&#xA;&#x9;steps {&#xA;&#x9;&#x9;sh &#39;mvn install&#39; &#xA;&#x9;}&#xA;&#x9;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-03 : SonarQube Analysis&lt;/h3&gt; &#xA;&lt;p&gt;In this stage, I used withSonarQubeEnv to Prepare the SonarQube Scanner environment and shell command sh&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage SonarQube Analysis&lt;/li&gt; &#xA; &lt;li&gt;paste the command that we created at the time of the sonarqube project creation&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;SonarQube Analysis&#39;){&#xA;            steps{&#xA;                withSonarQubeEnv(&#39;SonarQube-server&#39;) {&#xA;                        sh &#39;&#39;&#39;mvn clean verify sonar:sonar \&#xA;                        -Dsonar.projectKey=gitops-with-argocd \&#xA;                        -Dsonar.projectName=&#39;gitops-with-argocd&#39; \&#xA;                        -Dsonar.host.url=$sonarurl \&#xA;                        -Dsonar.login=$sonarlogin&#39;&#39;&#39;&#xA;                }&#xA;            }&#xA;        }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-04 : Quality gate&lt;/h3&gt; &#xA;&lt;p&gt;This step pauses Pipeline execution and waits for the previously submitted SonarQube analysis to be completed and returns quality gate status. Setting the parameter abortPipeline to true will abort the pipeline if the quality gate status is not green.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage as a Quality gate&lt;/li&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://opensource.triology.de/jenkins/pipeline-syntax/&#34;&gt;https://opensource.triology.de/jenkins/pipeline-syntax/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;search for waitForQualityGate: Wait for SonarQube analysis to be completed and return quality gate status&lt;/li&gt; &#xA; &lt;li&gt;generate pipeline syntax and paste it into steps&lt;/li&gt; &#xA; &lt;li&gt;timeout is optional&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#34;Quality Gate&#34;) {&#xA;            steps {&#xA;              timeout(time: 1, unit: &#39;HOURS&#39;) {&#xA;                waitForQualityGate abortPipeline: true&#xA;              }&#xA;            }&#xA;          }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-05 : Jfrog Artifactory&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We wrap the steps in a script block to execute them as a Groovy script.&lt;/li&gt; &#xA; &lt;li&gt;Inside the try block, we create a reference to the Artifactory server using the Artifactory.newServer method. You need to provide the URL of your Artifactory instance and the credentials ID configured in Jenkins.&lt;/li&gt; &#xA; &lt;li&gt;We define an uploadSpec as a JSON string, specifying the pattern of files to upload and the target repository in Artifactory.&lt;/li&gt; &#xA; &lt;li&gt;We call the server.upload(uploadSpec) method to upload the files to Artifactory based on the specified upload specification.&lt;/li&gt; &#xA; &lt;li&gt;If any exception occurs during the upload process, the catch block will be executed, and an error message will be displayed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;steps {&#xA;                script {&#xA;                    try {&#xA;                        def server = Artifactory.newServer url: &#39;http://13.232.95.58:8082/artifactory&#39;, credentialsId: &#39;jfrog-cred&#39;&#xA;                        def uploadSpec = &#34;&#34;&#34;{&#xA;                            &#34;files&#34;: [&#xA;                                {&#xA;                                    &#34;pattern&#34;: &#34;target/*.jar&#34;,&#xA;                                    &#34;target&#34;: &#34;${TARGET_REPO}/&#34;&#xA;                                }&#xA;                            ]&#xA;                        }&#34;&#34;&#34;&#xA;                        &#xA;                        server.upload(uploadSpec)&#xA;                    } catch (Exception e) {&#xA;                        error(&#34;Failed to deploy artifacts to Artifactory: ${e.message}&#34;)&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-06 : Docker Build&lt;/h3&gt; &#xA;&lt;p&gt;First, write your dockerfile to build docker images. I have posted my dockerfile in the application repo code In this stage, I used the shell command sh to build the docker image&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage Docker Build&lt;/li&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://opensource.triology.de/jenkins/pipeline-syntax/&#34;&gt;https://opensource.triology.de/jenkins/pipeline-syntax/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;search for sh: shell script&lt;/li&gt; &#xA; &lt;li&gt;give your shell command to build image &amp;gt; generate pipeline syntax&lt;/li&gt; &#xA; &lt;li&gt;I used the build-id of jenkins and git commit id for versions of docker images&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sstage(&#39;Docker  Build&#39;) {&#xA;            steps {&#xA;               &#xA;      &#x9;         sh &#39;docker build -t ${IMAGE_REPO}/${NAME}:${VERSION}-${GIT_COMMIT} .&#39;&#xA;                &#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-07: Trivy Image scan&lt;/h3&gt; &#xA;&lt;p&gt;In this stage, I trivy shell command sh to scan the docker image&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage Trivy Image scan&lt;/li&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://opensource.triology.de/jenkins/pipeline-syntax/&#34;&gt;https://opensource.triology.de/jenkins/pipeline-syntax/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;search for sh: shell script&lt;/li&gt; &#xA; &lt;li&gt;give your Trivy shell command to scan the docker image&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Note – There are 3 types of report output formats of trivy ( Table, JSON, Template). I used HTML template for the output report of the trivy scan&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;Image Scan&#39;) {&#xA;            steps {&#xA;      &#x9;        sh &#39; trivy image --format template --template &#34;@/usr/local/share/trivy/templates/html.tpl&#34; -o report.html &#x9;&#x9;${IMAGE_REPO}/${NAME}:${VERSION}-${GIT_COMMIT} &#39;&#xA;            }&#xA;        }&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-08: Upload report generated by trivy to AWS S3&lt;/h3&gt; &#xA;&lt;p&gt;In this stage, I used the shell command sh to Upload Scan report to AWS S3&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage Upload report to AWS S3&lt;/li&gt; &#xA; &lt;li&gt;first create an AWS s3 bucket&lt;/li&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://opensource.triology.de/jenkins/pipeline-syntax/&#34;&gt;https://opensource.triology.de/jenkins/pipeline-syntax/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;search for sh: shell script&lt;/li&gt; &#xA; &lt;li&gt;give your shell command to upload the object to aws s3&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;Upload Scan report to AWS S3&#39;) {&#xA;              steps {&#xA;                  &#xA;                //  sh &#39;aws configure set aws_access_key_id &#34;$AWS_ACCESS_KEY_ID&#34;  &amp;amp;&amp;amp; aws configure set aws_secret_access_key &#34;$AWS_ACCESS_KEY_SECRET&#34;  &amp;amp;&amp;amp; aws configure set region ap-south-1  &amp;amp;&amp;amp; aws configure set output &#34;json&#34;&#39; &#xA;                  sh &#39;aws s3 cp report.html s3://devops-mastepiece/&#39;&#xA;              }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-09: Push Docker images to DockerHub&lt;/h3&gt; &#xA;&lt;p&gt;In this stage, I used the shell command sh to push the docker image to the docker hub. I stored Credentials in Vault and accessed them in jenkins using the Vault key. You can store DockerHub credentials in jenkins and use them as environment variables&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a stage Docker images push&lt;/li&gt; &#xA; &lt;li&gt;go to this site &lt;a href=&#34;https://opensource.triology.de/jenkins/pipeline-syntax/&#34;&gt;https://opensource.triology.de/jenkins/pipeline-syntax/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;search for sh: shell script&lt;/li&gt; &#xA; &lt;li&gt;give your shell command to push docker images to the docker hub&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage (&#39;Docker Build&#39;) {&#xA;           steps {&#xA;               withVault(configuration: [skipSslVerification: true, timeout: 60, vaultCredentialId: &#39;vault-token&#39;, vaultUrl: &#39;http://13.232.53.209:8200&#39;], vaultSecrets: [[path: &#39;secrets/creds/docker&#39;, secretValues: [[vaultKey: &#39;username&#39;], [vaultKey: &#39;password&#39;]]]]) {&#xA;                   &#xA;                   sh &#34;docker login -u ${username} -p ${password} &#34;&#xA;                   sh &#39;docker push ${IMAGE_REPO}/${NAME}:${VERSION}-${GIT_COMMIT}&#39;&#xA;   &#x9;    &#x9;sh &#39;docker rmi  ${IMAGE_REPO}/${NAME}:${VERSION}-${GIT_COMMIT}&#39;&#xA;                   &#xA;                   &#xA;               }&#xA;           }&#xA;       }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage-10: Clone/Pull Repo (k8s manifest repo )&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;in this stage first we check whether the repo already exists or not&lt;/li&gt; &#xA; &lt;li&gt;if exists then pull the changes&lt;/li&gt; &#xA; &lt;li&gt;if not then will clone the repo&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;Clone/Pull Repo&#39;) {&#xA;           steps {&#xA;               script {&#xA;                   if (fileExists(&#39;DevOps_MasterPiece-CD-with-argocd&#39;)) {&#xA;&#xA;                       echo &#39;Cloned repo already exists - Pulling latest changes&#39;&#xA;&#xA;                       dir(&#34;DevOps_MasterPiece-CD-with-argocd&#34;) {&#xA;                         sh &#39;git pull&#39;&#xA;                       }&#xA;&#xA;                   } else {&#xA;                       echo &#39;Repo does not exists - Cloning the repo&#39;&#xA;                       sh &#39;git clone -b feature https://github.com/praveensirvi1212/DevOps_MasterPiece-CD-with-argocd.git&#39;&#xA;                   }&#xA;               }&#xA;           }&#xA;       }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage: 11 Update Manifest&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;used sed command to replace images tag in deployment manifests&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;Update Manifest&#39;) {&#xA;            steps {&#xA;                dir(&#34;DevOps_MasterPiece-CD-with-argocd/yamls&#34;) {&#xA;                    sh &#39;sed -i &#34;s#praveensirvi.*#${IMAGE_REPO}/${NAME}:${VERSION}-${GIT_COMMIT}#g&#34; deployment.yaml&#39;&#xA;                    sh &#39;cat deployment.yaml&#39;&#xA;                }&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage: 12 Commit and Push Changes to the k8s manifest repo&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;set the global username&lt;/li&gt; &#xA; &lt;li&gt;set the remote repo URL&lt;/li&gt; &#xA; &lt;li&gt;checkout the branch to feature&lt;/li&gt; &#xA; &lt;li&gt;stage the changes&lt;/li&gt; &#xA; &lt;li&gt;commit the changes&lt;/li&gt; &#xA; &lt;li&gt;push the changes to the feature branch&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;Commit &amp;amp; Push&#39;) {&#xA;            steps {&#xA;                withCredentials([string(credentialsId: &#39;GITHUB_TOKEN&#39;, variable: &#39;GITHUB_TOKEN&#39;)]) {&#xA;                    dir(&#34;DevOps_MasterPiece-CD-with-argocd/yamls&#34;) {&#xA;                        sh &#34;git config --global user.email &#39;praveen@gmail.com&#39;&#34;&#xA;                        sh &#39;git remote set-url origin https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}&#39;&#xA;                        sh &#39;git checkout feature&#39;&#xA;                        sh &#39;git add deployment.yaml&#39;&#xA;                        sh &#34;git commit -am &#39;Updated image version for Build- ${VERSION}-${GIT_COMMIT}&#39;&#34;&#xA;                        sh &#39;git push origin feature&#39;&#xA;                    }&#xA;                }    &#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage: 13 Create Pull Request&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;The reason to create a pull request is that argocd is sync automatically with Git Hub. GitHub is the only single source of truth for argocd. So if jenkins push the changes to the main branch then argocd will deploy changes directly without reviewing the changes. This should not happen in the Production environment. That’s why we create pull requests against the main branch. So a senior person from the team can review the changes and merge them into the main branch. Then n then only changes should go to the production environment.&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here &lt;code&gt;token.txt&lt;/code&gt; contain the GitHub token, the reason for storing the GitHub token in the text file bcoz &lt;code&gt;gh auth login --with-token&lt;/code&gt; accept only STDIN Input&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stage(&#39;Raise PR&#39;) {&#xA;            steps {&#xA;                withCredentials([string(credentialsId: &#39;GITHUB_TOKEN&#39;, variable: &#39;GITHUB_TOKEN&#39;)]) {&#xA;                    dir(&#34;DevOps_MasterPiece-CD-with-argocd/yamls&#34;) {&#xA;                        sh &#39;&#39;&#39;&#xA;                            set +u&#xA;                            unset GITHUB_TOKEN&#xA;                            gh auth login --with-token &amp;lt; token.txt&#xA;                            &#xA;                        &#39;&#39;&#39;&#xA;                        sh &#39;git branch&#39;&#xA;                        sh &#39;git checkout feature&#39;&#xA;                        sh &#34;gh pr create -t &#39;image tag updated&#39; -b &#39;check and merge it&#39;&#34;&#xA;                    }&#xA;                }    &#xA;            }&#xA;        } &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stage: 14 Post build action&lt;/h3&gt; &#xA;&lt;p&gt;In post build action I used Slack notification. After the build jenkins will send a notification message to Slack whether your build success or failure.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;go to jenkins &amp;gt; your project &amp;gt; pipeline syntax &amp;gt; search for slacksend: send slack message&lt;/li&gt; &#xA; &lt;li&gt;write your channel name and message &amp;gt; generate pipeline syntax.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Note – I used custom messages for my project. I created a function for Slack notification and called the function into Post build.&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;post{&#xA;   always{&#xA;   &#x9;sendSlackNotifcation()&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;sendSlackNotification function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;def sendSlackNotifcation()&#xA;{&#xA;   if ( currentBuild.currentResult == &#34;SUCCESS&#34; ) {&#xA;       buildSummary = &#34;Job_name: ${env.JOB_NAME}\n Build_id: ${env.BUILD_ID} \n Status: *SUCCESS*\n Build_url: ${BUILD_URL}\n Job_url: ${JOB_URL} \n&#34;&#xA;       slackSend( channel: &#34;#devops&#34;, token: &#39;slack-token&#39;, color: &#39;good&#39;, message: &#34;${buildSummary}&#34;)&#xA;   }&#xA;   else {&#xA;       buildSummary = &#34;Job_name: ${env.JOB_NAME}\n Build_id: ${env.BUILD_ID} \n Status: *FAILURE*\n Build_url: ${BUILD_URL}\n Job_url: ${JOB_URL}\n  \n &#34;&#xA;       slackSend( channel: &#34;#devops&#34;, token: &#39;slack-token&#39;, color : &#34;danger&#34;, message: &#34;${buildSummary}&#34;)&#xA;   }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Find the whole pipeline here&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/Jenkinsfile&#34;&gt;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/blob/main/Jenkinsfile&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Step: 7 Project Output&lt;/h2&gt; &#xA;&lt;h1&gt;Final outputs of this Project&lt;/h1&gt; &#xA;&lt;h3&gt;Jenkins Output :&lt;/h3&gt; &#xA;&lt;p&gt;Sorry, I forgot to change the stage name while building the job, but don&#39;t worry I made changes in the Jenkins file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/jenkins.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Sonarqube Output:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/sonarqube.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Quality Gate Status in Jenkins&lt;/h3&gt; &#xA;&lt;p&gt;SonarQube Quality gate status is green and passed.&lt;br&gt; You can apply your custom quality gate like there should be zero ( bug, Vulnerability, code smell ) and if your code has greater than 0 (bugs, vulnerability, code smells). Then your quality gate status will become a failure or red. If your quality gate status becomes a failure, stages after the quality gate will be a failure. &lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/quality-gate.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Trivy report in AWS S3 push by jenkins&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/trivy-report.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Trivy report&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-23%2023-59-22.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Images in DockerHub pushed by jenkins&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/dockerhub.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Image tag updated by jenkins and push changes to feature branch&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-24%2000-06-51.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Pull Request created by jenkins in DevOps_MasterPiece-CD-with-argocd GitHub repo&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/pr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;App in ArgoCD&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/argocd.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Application output deployed in EKS Cluster by ArgoCD&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-22%2023-24-29.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Slack output of jenkins&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-22%2023-24-05.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Slack output of ArgoCD&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-22%2023-58-34.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Prometheus&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-22%2023-20-00.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Grafana&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/praveensirvi1212/DevOps_MasterPiece-CI-with-Jenkins/raw/main/images/Screenshot%20from%202023-06-22%2023-19-50.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>