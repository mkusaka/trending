<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-13T01:31:23Z</updated>
  <subtitle>Daily Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>JackHopkins/factorio-learning-environment</title>
    <updated>2025-03-13T01:31:23Z</updated>
    <id>tag:github.com,2025-03-13:/JackHopkins/factorio-learning-environment</id>
    <link href="https://github.com/JackHopkins/factorio-learning-environment" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A non-saturating, open-ended environment for evaluating LLMs in Factorio&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;Factorio Learning Environment&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://jackhopkins.github.io/factorio-learning-environment/leaderboard&#34;&gt;Leaderboard&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/docs/assets/documents/paper.pdf&#34;&gt;Paper&lt;/a&gt; | &lt;a href=&#34;https://jackhopkins.github.io/factorio-learning-environment/&#34;&gt;Website&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; An open source framework for developing and evaluating LLM agents in the game of &lt;a href=&#34;https://factorio.com/&#34;&gt;Factorio&lt;/a&gt;. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/docs/assets/videos/compressed_527-cropped.webp&#34; width=&#34;485&#34; height=&#34;364&#34; controls&gt; &lt;img src=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/docs/assets/videos/compressed_1897-cropped.webp&#34; width=&#34;485&#34; height=&#34;364&#34; controls&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;em&gt;Claude 3.5 plays Factorio&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why FLE?&lt;/h2&gt; &#xA;&lt;p&gt;We provide two settings:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lab-play&lt;/strong&gt;: 24 structured tasks with fixed resources.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Open-play&lt;/strong&gt; An unbounded task of building the largest possible factory on a procedurally generated map.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Our results demonstrate that models still lack strong spatial reasoning. In lab-play, we find that while LLMs exhibit promising short-horizon skills, they are unable to operate effectively in constrained environments, reflecting limitations in error analysis. In open-play, while LLMs discover automation strategies that improve growth (e.g electric-powered drilling), they fail to achieve complex automation (e.g electronic-circuit manufacturing).&lt;/p&gt; &#xA;&lt;h2&gt;Quick Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#environment-documentation&#34;&gt;Environment&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#agent-documentation&#34;&gt;Agents&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#task-documentation&#34;&gt;Tasks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#tool-documentation&#34;&gt;Tools&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#project-structure&#34;&gt;Project Structure&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#database&#34;&gt;Database&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#benchmarks&#34;&gt;Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#contributing-guidelines&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.factorio.com/&#34;&gt;Factorio&lt;/a&gt; (version 1.1.110)&lt;/li&gt; &#xA; &lt;li&gt;Docker&lt;/li&gt; &#xA; &lt;li&gt;Python 3.10+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Quickstart&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Clone the repository&lt;/strong&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/JackHopkins/factorio-learning-environment.git&#xA;cd env/src&#xA;pip install -e .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Set up Factorio client&lt;/strong&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Purchase Factorio from the &lt;a href=&#34;https://www.factorio.com/&#34;&gt;official website&lt;/a&gt; or on Steam.&lt;/li&gt; &#xA; &lt;li&gt;Downgrade to version 1.1.110: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Steam: Right-click Factorio → Properties → Betas → Select 1.1.110&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Launch FLE Docker server&lt;/strong&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Start Docker daemon&#xA;sudo systemctl start docker&#xA;&#xA;# Build Docker image&#xA;cd cluster/docker&#xA;docker build -t factorio .&#xA;&#xA;# Run a single server&#xA;cd ../local&#xA;docker-compose -f docker-compose-1.yml up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Activate server&lt;/strong&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open Factorio client&lt;/li&gt; &#xA; &lt;li&gt;Navigate to &lt;em&gt;Multiplayer&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Connect to &lt;code&gt;localhost:34197&lt;/code&gt; (default) or your configured address in Docker. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You may disconnect from each server once it has been activated&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Run Eval&lt;/strong&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;First create the .env file. Note that API keys are only required for the respective model providers that will be used to run eval on&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# model providers&#xA;OPENAI_API_KEY=&amp;lt;KEY&amp;gt;&#xA;ANTHROPIC_API_KEY=&amp;lt;KEY&amp;gt;&#xA;TOGETHER_API_KEY=&amp;lt;KEY&amp;gt;&#xA;OPEN_ROUTER_API_KEY=&amp;lt;KEY&amp;gt;&#xA;&#xA;# If using Postgres DB, NOT REQUIRED (See section on Database)&#xA;SKILLS_DB_PORT=&#34;&#34;&#xA;SKILLS_DB_NAME=&#34;&#34;&#xA;SKILLS_DB_USER=&#34;&#34;&#xA;SKILLS_DB_PASSWORD=&#34;&#34;&#xA;&#xA;# AWS credentials if wanting to use Cloudformation, NOT REQUIRED&#xA;AWS_SECRET_ACCESS_KEY=&amp;lt;KEY&amp;gt;&#xA;AWS_ACCESS_KEY_ID=&#34;&#34;&#xA;AWS_DEFAULT_REGION=&#34;&#34;&#xA;CLUSTER_NAME=&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running open and lab play with example run configs:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open Play (one parallel run): &lt;code&gt;python eval/open/independent_runs/run.py --run_config=eval/open/independent_runs/run_config_example_open_play.json&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Tasks (one parallel run of iron-ore task): &lt;code&gt;python eval/open/independent_runs/run.py --run_config=eval/open/independent_runs/run_config_example_lab_play.json&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Environment&lt;/h2&gt; &#xA;&lt;p&gt;FLE is an agent evaluation environment built on the game of Factorio, a popular resource management simulation game.&lt;/p&gt; &#xA;&lt;p&gt;Agents interact with &lt;strong&gt;FLE&lt;/strong&gt; by code synthesis through a &lt;strong&gt;REPL&lt;/strong&gt; (Read-Eval-Print-Loop) pattern:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Observation&lt;/strong&gt;: The agent observes the world through the output streams (stderr/stdout) of their last program.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Action&lt;/strong&gt;: The agent generates a Python program to perform their desired action.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Feedback&lt;/strong&gt;: The environment executes the program, assigns variables, add classes/functions to the namespace, and provides an output stream.&lt;/li&gt; &#xA;&lt;/ol&gt;    &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td class=&#34;python-code&#34;&gt; &lt;b&gt;Action&lt;/b&gt; &lt;pre&gt;&#xA;# 1. Get iron patch and place mining drill&#xA;drill = place_entity(&#xA;    entity=Prototype.MiningDrill,&#xA;    position=nearest(Prototype.IronOre)),&#xA;    direction=Direction.NORTH&#xA;)&#xA;# 2. Add output storage&#xA;chest = place_entity_next_to(&#xA;    entity=Prototype.IronChest,&#xA;    reference_position=drill.drop_position,&#xA;    direction=Direction.SOUTH&#xA;)&#xA;# 3. Verify automation chain and observe entities&#xA;sleep(10) # Sleep for 10 seconds&#xA;assert drill.status == EntityStatus.WORKING&#xA;print(get_entities())&#xA;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td class=&#34;bash-code&#34;&gt; &lt;b&gt;Feedback&lt;/b&gt; &lt;pre&gt;&#xA;&amp;gt;&amp;gt;&amp;gt; [ BurnerMiningDrill(fuel=Inventory({&#39;coal&#39;: 4}), &#xA;&amp;gt;&amp;gt;&amp;gt;                     name=&#39;burner-mining-drill&#39;, &#xA;&amp;gt;&amp;gt;&amp;gt;                     direction=Direction.DOWN, &#xA;&amp;gt;&amp;gt;&amp;gt;                     position=Position(x=-28.0, y=-61.0), &#xA;&amp;gt;&amp;gt;&amp;gt;                     energy=2666.6666666667, &#xA;&amp;gt;&amp;gt;&amp;gt;                     tile_dimensions=TileDimensions(tile_width=2.0, tile_height=2.0), &#xA;&amp;gt;&amp;gt;&amp;gt;                     status=EntityStatus.WORKING, &#xA;&amp;gt;&amp;gt;&amp;gt;                     neighbours=[Entity(name=&#39;iron-chest&#39;, direction=DOWN, position=Position(x=-27.5 y=-59.5)], &#xA;&amp;gt;&amp;gt;&amp;gt;                     drop_position=Position(x=-27.5, y=-59.5), &#xA;&amp;gt;&amp;gt;&amp;gt;                     resources=[Ingredient(name=&#39;iron-ore&#39;, count=30000, type=None)]),&#xA;&amp;gt;&amp;gt;&amp;gt;   Chest(name=&#39;iron-chest&#39;, &#xA;&amp;gt;&amp;gt;&amp;gt;         direction=Direction.UP, &#xA;&amp;gt;&amp;gt;&amp;gt;         position=Position(x=-27.5, y=-59.5), &#xA;&amp;gt;&amp;gt;&amp;gt;         energy=0.0, &#xA;&amp;gt;&amp;gt;&amp;gt;         tile_dimensions=TileDimensions(tile_width=1.0, tile_height=1.0), &#xA;&amp;gt;&amp;gt;&amp;gt;         status=EntityStatus.NORMAL, &#xA;&amp;gt;&amp;gt;&amp;gt;         inventory=Inventory({&#39;iron-ore&#39;: 75}))]&#xA;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt;   &#xA;&lt;p&gt;Agents are provided with the Python standard library, and an API comprising &lt;a href=&#34;https://raw.githubusercontent.com/JackHopkins/factorio-learning-environment/main/#tool-documentation&#34;&gt;tools&lt;/a&gt; that they can use.&lt;/p&gt; &#xA;&lt;p&gt;Tools are functions that perform a game action and return a typed object (e.g an Inventory), which can be stored as a named &lt;strong&gt;variable&lt;/strong&gt; in the Python namespace for later use.&lt;/p&gt; &#xA;&lt;p&gt;The namespace acts as an episodic symbolic memory system, and saved objects represent an observation of the environment at the moment of query.&lt;/p&gt; &#xA;&lt;p&gt;This enables agents to maintain complex state representations and build hierarchical abstractions as the factories scale.&lt;/p&gt; &#xA;&lt;p&gt;Agents observe &lt;strong&gt;stdout&lt;/strong&gt; and &lt;strong&gt;stderr&lt;/strong&gt; - the output streams of their program. Agents may intentionally choose to print relevant objects and computations to the output stream to construct observations.&lt;/p&gt; &#xA;&lt;p&gt;Mistakes in the code or invalid operations raise typed &lt;strong&gt;exceptions&lt;/strong&gt; with detailed context that is written to stderr.&lt;/p&gt; &#xA;&lt;p&gt;This enables agents to reactively debug their programs after execution, and proactively use runtime assertions during execution to self-verify their actions.&lt;/p&gt; &#xA;&lt;p&gt;Agents are able to enhance their internal representation of the game state by defining:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Utility functions for reuse throughout an episode, to encapsulate previously successful logic&lt;/li&gt; &#xA; &lt;li&gt;Classes in the namespace to better organize the data retrieved from the game.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Agents&lt;/h2&gt; &#xA;&lt;p&gt;The Factorio Learning Environment provides a straightforward agent architecture for developing and evaluating AI models that can play Factorio.&lt;/p&gt; &#xA;&lt;p&gt;Agents operate in &lt;em&gt;episodes&lt;/em&gt;, with each step involving observation, planning, and action execution through Python code synthesis. The agent maintains state through a conversation history that includes its actions (&lt;em&gt;assistant&lt;/em&gt;) and the stdout/stderr from the environment (&lt;em&gt;user&lt;/em&gt;). At each step, agents generate Python code policies that are executed in the environment.&lt;/p&gt; &#xA;&lt;h3&gt;Anatomy of an Agent&lt;/h3&gt; &#xA;&lt;p&gt;Agents live in &lt;code&gt;agents&lt;/code&gt;, and implement an abstract base class (AgentABC) that defines the core interface for interacting with the environment.&lt;/p&gt; &#xA;&lt;p&gt;The abstract base class defines two methods that all agents must implement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Generates the next action based on conversation history and environment response (including score / achievements etc).&#xA;step(conversation: Conversation, response: Response) -&amp;gt; Policy:&#xA;&#xA;# Handles cleanup when an episode terminates, i.e for reporting results etc.&#xA;end(conversation: Conversation, completion: CompletionState) -&amp;gt; None:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each agent takes input a task (discussed in the next section) which specifies the goal of the agent.&lt;/p&gt; &#xA;&lt;p&gt;Our default agent is &lt;code&gt;BasicAgent&lt;/code&gt;, which incorporates some basic mechanisms for managing context over long (+1000 step) runs:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Every 32 steps, the all older interactions are summarised into a report in the system message.&lt;/li&gt; &#xA; &lt;li&gt;Conversations are clipped to remain under 200k characters (~87k tokens).&lt;/li&gt; &#xA; &lt;li&gt;We strip out all &lt;em&gt;historical&lt;/em&gt; observations of game entities, as this both fills up the context, and confuses the agent.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We include some basic utilities for calling different LLMs (&lt;code&gt;agents/utils/llm_factory.py&lt;/code&gt;), for formatting the conversation history (&lt;code&gt;agents/utils/formatters/conversation_formatter_abc.py&lt;/code&gt;), and for parsing responses into valid Python (&lt;code&gt;agents/utils/parse_response.py&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Minimal Agent Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ./agents/minimal_agent.py&#xA;&#xA;class MinimalAgent(AgentABC):&#xA;    &#34;&#34;&#34;&#xA;    This is a minimal Agent implementation, which takes the current conversation (including the most recent response)&#xA;    and generates a simple Python code policy to execute the next step.&#xA;    &#xA;    Note: This will blow up context length on longer runs, without some context pruning/management.&#xA;    &#34;&#34;&#34;&#xA;    def __init__(self, model, system_prompt, goal_description, *args, **kwargs):&#xA;        system_prompt += f&#34;\n\n### Goal\n{goal_description}\n\n&#34;&#xA;        super().__init__(model, system_prompt, *args, **kwargs)&#xA;        self.llm_factory = LLMFactory(model)&#xA;    &#xA;    @tenacity.retry(&#xA;       retry=retry_if_exception_type(Exception),&#xA;       wait=wait_exponential(multiplier=1, min=4, max=10)&#xA;    )&#xA;    async def step(self, conversation: Conversation, response: Response) -&amp;gt; Policy:&#xA;        # Generate and return next policy&#xA;        response = await self.llm_factory.acall(&#xA;           messages=self.formatter.to_llm_messages(conversation),&#xA;           n_samples=1,  # We only need one program per iteration&#xA;           temperature=self.generation_params.temperature,&#xA;           max_tokens=self.generation_params.max_tokens,&#xA;           model=self.generation_params.model,&#xA;       )&#xA;        &#xA;       # Parse LLM response into a Policy object&#xA;       policy = parse_response(response)&#xA;       if not policy:&#xA;           raise Exception(&#34;Not a valid Python policy&#34;)&#xA;&#xA;       return policy&#xA;&#xA;    async def end(self, conversation: Conversation, completion: CompletionResult):&#xA;        pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tasks&lt;/h2&gt; &#xA;&lt;p&gt;Each agent is given a &lt;code&gt;task&lt;/code&gt;, which specifies the goal the agent will carry out in FLE. A task consists of a task object defining the core interface of the task category and a json file specifying the parameters of the task.&lt;/p&gt; &#xA;&lt;h3&gt;Anatomy of a Task&lt;/h3&gt; &#xA;&lt;p&gt;Tasks live in &lt;code&gt;eval/tasks&lt;/code&gt;, and implement an abstract base class in &lt;code&gt;eval/tasks/task_abc.py&lt;/code&gt; that defines the core interface for defining the task, setting up the environment and verifying success&lt;/p&gt; &#xA;&lt;p&gt;The abstract base class defines three methods that all tasks must implement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;verify(self, score: float, step: int, instance: FactorioInstance, step_statistics: Dict) -&amp;gt; bool:&#xA;&#34;&#34;&#34; Return true if the task is completed&#34;&#34;&#34;&#xA;&#xA;setup_instance(self, instance):&#xA;&#34;&#34;&#34;Code to provision the initial game state for the task environment&#34;&#34;&#34;&#xA;&#xA;enhance_response_with_task_output(self, response: str, task_response: TaskResponse) -&amp;gt; str:&#xA;&#34;&#34;&#34;Add task specific information to the environment response if needed&#34;&#34;&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We provide two default tasks:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;OpenPlayTask - Task for the open-play setting, where the agent plays the game until a specified number of steps is finished. The verify function will always return False&lt;/li&gt; &#xA; &lt;li&gt;ThroughputTask - Task for requiring the agent to build a factory that achieves a specified throughput in the holdout period. The verify function will return True if the holdout period throughput is above the threshold&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The task jsons specifies the &#34;task_type&#34; and the &#34;config&#34; parameters. &lt;code&gt;task_type&lt;/code&gt; specifies the mapping from the json to the task type (the creation of task objects from the json is done in &lt;code&gt;eval\tasks\task_factory.py&lt;/code&gt;). &lt;code&gt;config&lt;/code&gt; specifies all required attributes to substantiate the respective task object. Each config must at minimum define the &#34;goal_description&#34;, &#34;trajectory_length&#34; and &#34;task_key&#34; parameters. Examples of task json&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Open play task json&#xA;&#xA;{   &#34;task_type&#34;: &#34;default&#34;,&#xA;    &#34;config&#34;: {                         &#xA;        &#34;goal_description&#34;:&#34;- Build the biggest possible factory\n- Maximise automation, efficiency and scale&#34;,&#xA;        &#34;trajectory_length&#34;: 5000,&#xA;        &#34;task_key&#34;: &#34;open_play&#34;&#xA;    }&#xA;}&#xA;# One example of a throughput task json&#xA;{                          &#xA;    &#34;task_type&#34;: &#34;throughput&#34;,&#xA;    &#34;config&#34;:&#xA;        {&#34;goal_description&#34;:&#34;Create an automatic iron gear wheel factory that produces 16 iron gear wheel per 60 ingame seconds&#34;,&#xA;        &#34;throughput_entity&#34;:&#34;iron-gear-wheel&#34;,&#xA;        &#34;quota&#34;:16,&#xA;        &#34;trajectory_length&#34;: 128,&#xA;        &#34;holdout_wait_period&#34;: 60,&#xA;        &#34;pre_holdout_wait_period&#34;: 60,&#xA;        &#34;task_key&#34;: &#34;iron_gear_wheel_throughput_16&#34;}&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example open play task object can be seen below. The throughput task object can be found here &lt;code&gt;eval/tasks/throughput_task.py&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class OpenPlayTask(TaskABC):&#xA;    def __init__(self, trajectory_length, goal_description: str, task_key: str):&#xA;        super().__init__(trajectory_length, starting_inventory = {}, goal_description=goal_description, task_key = task_key)&#xA;        self.starting_game_state = None&#xA;        &#xA;    &#xA;    def verify(self, score: float, instance: FactorioInstance, step_statistics: Dict) -&amp;gt; TaskResponse:&#xA;        return TaskResponse(success = False,&#xA;                            meta = {})&#xA;            &#xA;    def _to_dict(self) -&amp;gt; Dict[str, Any]:&#xA;        return {&#xA;            &#34;goal_description&#34;: self.goal_description,&#xA;            &#34;trajectory_length&#34;: self.trajectory_length,&#xA;            &#34;starting_inventory&#34;: self.starting_inventory,&#xA;            &#34;initial_state&#34;: self.starting_game_state.to_raw() if self.starting_game_state else None,&#xA;        }&#xA;&#xA;    def setup_instance(self, instance):&#xA;        &#34;&#34;&#34;Code to provision the task environment&#34;&#34;&#34;&#xA;        pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running tasks&lt;/h3&gt; &#xA;&lt;p&gt;The entrypoint to run tasks is &lt;code&gt;eval\open\independent_runs\run.py&lt;/code&gt; which reads in a run config json file, runs the tasks specified in parallel and saves each generated program with the environment output and task verification result into the database. The location of the run config json is sent in through the &lt;code&gt;--run_config&lt;/code&gt; inline argument. If no argument is sent, the default run config &lt;code&gt;eval\open\independent_runs\run_config.json&lt;/code&gt; is used.&lt;/p&gt; &#xA;&lt;p&gt;The run config json is a list of dictionaries specifying the task_json location, model and version (optional). One example to run 3 tasks in parallel&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[&#xA;{&#34;task&#34;: &#34;iron_gear_wheel_throughput_16.json&#34;,&#xA;&#34;model&#34;: &#34;gpt-4o-mini-2024-07-18&#34;,&#xA;&#34;version&#34;: 768},&#xA;{&#34;task&#34;: &#34;plastic_bar_throughput_16.json&#34;,&#xA;&#34;model&#34;: &#34;anthropic/claude-3.5-sonnet-open-router&#34;},&#xA;{&#34;task&#34;: &#34;open_play.json&#34;,&#xA;&#34;model&#34;: &#34;gpt-4o-mini-2024-07-18&#34;}&#xA;]&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each task is run until either &lt;code&gt;verify&lt;/code&gt; returns True or the maximum number of steps (&lt;code&gt;trajectory_length&lt;/code&gt;) is reached&lt;/p&gt; &#xA;&lt;h2&gt;Tool Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Agents interact with the game using &lt;em&gt;tools&lt;/em&gt;, which represent a narrow API into the game.&lt;/p&gt; &#xA;&lt;h3&gt;Anatomy of a Tool&lt;/h3&gt; &#xA;&lt;p&gt;Tools live in &lt;code&gt;env/src/tools&lt;/code&gt;, and are either &lt;code&gt;admin&lt;/code&gt; tools (non-agent accessible) or &lt;code&gt;agent&lt;/code&gt; tools (used by the agent).&lt;/p&gt; &#xA;&lt;p&gt;A tool requires 3 files:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;agent.md&lt;/code&gt;: The agent documentation for the tool, including usage patterns, best practices and failure modes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;client.py&lt;/code&gt;: The client-side implementation, which is a Python class that can be invoked by the agent.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server.lua&lt;/code&gt;: The server-side implementation, which handles most of the logic and heavy lifting.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;---&#xA;config:&#xA;  layout: fixed&#xA;  flowchart:&#xA;    defaultRenderer:&#xA;        elk&#xA;---&#xA;flowchart LR&#xA;    A(&#34;fa:fa-comment-dots Agent&#34;)&#xA;    subgraph s1[&#34;Learning Environment&#34;]&#xA;    &#xA;        B(&#34;fa:fa-code Interpreter&#34;)&#xA;        n1(&#34;client.py&#34;)&#xA;    end&#xA;    subgraph s2[&#34;Factorio Server&#34;]&#xA;        E1[&#34;fa:fa-shapes server.lua&#34;]&#xA;        F(&#34;fa:fa-cog Factorio Engine&#34;)&#xA;    end&#xA;&#xA;    A -- Synthesises Python --&amp;gt; B&#xA;    B -- Invokes --&amp;gt; n1 &#xA;    n1 -. Exceptions .-&amp;gt; B&#xA;    n1 -. Objects .-&amp;gt; B&#xA;    n1 --Remote TCP Call--&amp;gt; E1&#xA;    E1 -- Execute --&amp;gt; F&#xA;    &#xA;    F-. Result .-&amp;gt; E1&#xA;    E1 -. TCP Response .-&amp;gt; n1&#xA;    B -. Observation .-&amp;gt; A&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a custom Tool&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a new directory in &lt;code&gt;env/src/tools/agent&lt;/code&gt;, e.g &lt;code&gt;env/src/tools/agent/my_tool&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add a &lt;code&gt;client.py&lt;/code&gt; file, which should contain a class inheriting &lt;code&gt;Tool&lt;/code&gt; and implementing a &lt;code&gt;__call__&lt;/code&gt; function to treat the class as a callable function. The method signature should contain type annotations. This function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;self.execute&lt;/code&gt; to invoke the server-side logic.&lt;/li&gt; &#xA; &lt;li&gt;Add a &lt;code&gt;server.lua&lt;/code&gt; file, containing a function structured like &lt;code&gt;global.actions.my_tool = function(arg1, arg2, ...)&lt;/code&gt;. This file should invoke the &lt;a href=&#34;https://lua-api.factorio.com/1.1.110/&#34;&gt;Factorio API&lt;/a&gt; to perform the desired action, and return a table that will be serialized and sent back to the client.&lt;/li&gt; &#xA; &lt;li&gt;Add an &lt;code&gt;agent.md&lt;/code&gt; file, which should contain a markdown description of the tool. This file will be used by the agent to understand how to use the tool&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Next time you run an eval, the tool will automatically be available to the agent and documented in the agent context.&lt;/p&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;(Optional) Create a test suite in &lt;code&gt;env/tests/actions&lt;/code&gt; for your new tool.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Core Tools&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Tool&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Key Features&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;inspect_inventory&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Checks contents of player or entity inventories&lt;/td&gt; &#xA;   &lt;td&gt;- Supports various inventory types (chests, furnaces, etc.)&lt;br&gt;- Returns Inventory object with count methods&lt;br&gt;- Can query specific items&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;insert_item&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Places items from player inventory into entities&lt;/td&gt; &#xA;   &lt;td&gt;- Works with machines, chests, belts&lt;br&gt;- Validates item compatibility&lt;br&gt;- Returns updated entity&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;extract_item&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Removes items from entity inventories&lt;/td&gt; &#xA;   &lt;td&gt;- Supports all inventory types&lt;br&gt;- Auto-transfers to player inventory&lt;br&gt;- Returns quantity extracted&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;place_entity&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Places entities in the world&lt;/td&gt; &#xA;   &lt;td&gt;- Handles direction and positioning&lt;br&gt;- Validates placement requirements&lt;br&gt;- Returns placed Entity object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;place_entity_next_to&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Places entities relative to others&lt;/td&gt; &#xA;   &lt;td&gt;- Automatic spacing/alignment&lt;br&gt;- Handles entity dimensions&lt;br&gt;- Supports all entity types&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pickup_entity&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Removes entities from the world&lt;/td&gt; &#xA;   &lt;td&gt;- Returns items to inventory&lt;br&gt;- Handles entity groups&lt;br&gt;- Supports all placeable items&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rotate_entity&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Changes entity orientation&lt;/td&gt; &#xA;   &lt;td&gt;- Affects entity behavior (e.g., inserter direction)&lt;br&gt;- Validates rotation rules&lt;br&gt;- Returns updated entity&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;get_entity&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Retrieves entity objects at positions&lt;/td&gt; &#xA;   &lt;td&gt;- Updates stale references&lt;br&gt;- Returns typed Entity objects&lt;br&gt;- Handles all entity types&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;get_entities&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Finds multiple entities in an area&lt;/td&gt; &#xA;   &lt;td&gt;- Supports filtering by type&lt;br&gt;- Returns List[Entity]&lt;br&gt;- Groups connected entities&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;nearest&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Locates closest resources/entities&lt;/td&gt; &#xA;   &lt;td&gt;- Finds ores, water, trees&lt;br&gt;- Returns Position object&lt;br&gt;- 500 tile search radius&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;get_resource_patch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Analyzes resource deposits&lt;/td&gt; &#xA;   &lt;td&gt;- Returns size and boundaries&lt;br&gt;- Supports all resource types&lt;br&gt;- Includes total resource amount&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;harvest_resource&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Gathers resources from the world&lt;/td&gt; &#xA;   &lt;td&gt;- Supports ores, trees, rocks&lt;br&gt;- Auto-collects to inventory&lt;br&gt;- Returns amount harvested&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;connect_entities&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Creates connections between entities&lt;/td&gt; &#xA;   &lt;td&gt;- Handles belts, pipes, power&lt;br&gt;- Automatic pathfinding&lt;br&gt;- Returns connection group&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;get_connection_amount&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Calculates required connection items&lt;/td&gt; &#xA;   &lt;td&gt;- Pre-planning tool&lt;br&gt;- Works with all connection types&lt;br&gt;- Returns item count needed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;set_entity_recipe&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Configures machine crafting recipes&lt;/td&gt; &#xA;   &lt;td&gt;- Works with assemblers/chemical plants&lt;br&gt;- Validates recipe requirements&lt;br&gt;- Returns updated entity&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;get_prototype_recipe&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Retrieves crafting requirements&lt;/td&gt; &#xA;   &lt;td&gt;- Shows ingredients/products&lt;br&gt;- Includes crafting time&lt;br&gt;- Returns Recipe object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;craft_item&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Creates items from components&lt;/td&gt; &#xA;   &lt;td&gt;- Handles recursive crafting&lt;br&gt;- Validates technology requirements&lt;br&gt;- Returns crafted amount&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;set_research&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Initiates technology research&lt;/td&gt; &#xA;   &lt;td&gt;- Validates prerequisites&lt;br&gt;- Returns required ingredients&lt;br&gt;- Handles research queue&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;get_research_progress&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Monitors research status&lt;/td&gt; &#xA;   &lt;td&gt;- Shows remaining requirements&lt;br&gt;- Tracks progress percentage&lt;br&gt;- Returns ingredient list&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;move_to&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Moves player to position&lt;/td&gt; &#xA;   &lt;td&gt;- Pathfinds around obstacles&lt;br&gt;- Can place items while moving&lt;br&gt;- Returns final position&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;nearest_buildable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Finds valid building locations&lt;/td&gt; &#xA;   &lt;td&gt;- Respects entity dimensions&lt;br&gt;- Handles resource requirements&lt;br&gt;- Returns buildable position&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Pauses execution&lt;/td&gt; &#xA;   &lt;td&gt;- Waits for actions to complete&lt;br&gt;- Adapts to game speed&lt;br&gt;- Maximum 15 second duration&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;launch_rocket&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Controls rocket silo launches&lt;/td&gt; &#xA;   &lt;td&gt;- Validates launch requirements&lt;br&gt;- Handles launch sequence&lt;br&gt;- Returns updated silo state&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;print&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Outputs debug information to stdout&lt;/td&gt; &#xA;   &lt;td&gt;- Supports various object types&lt;br&gt;- Useful for monitoring state&lt;br&gt;- Returns formatted string&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Project Structure&lt;/h1&gt; &#xA;&lt;p&gt;Below is an overview of how the project is structured. Some directories also contain more detailed readmes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;factorio-learning-environment/&#xA;├── agents/                            # Factorio Learning Environment&#xA;│     ├── utils/                          # Some utilities for building an agent&#xA;│     ├── agent_abc.py                    # Abstract class to extend&#xA;│     └── basic_agent.py                  # Agent implementation we used for our experiments&#xA;├── env/                            # Factorio Learning Environment&#xA;│     ├── src/                          # Main implementation&#xA;│     │     ├── exceptions/                 # Custom exceptions (WIP)&#xA;│     │     ├── gym/                        # Gym environment wrapper (deprecated but possibly useful)&#xA;│     │     ├── lib/                        # General purpose Lua utilities (e.g serialization etc)&#xA;│     │     ├── models/                     # Core objects used during eval&#xA;│     │     ├── rcon/                       # RCON wrapper for communicating with the game&#xA;│     │     ├── tools/                      # Agent and admin tools&#xA;│     │     │    ├── admin/                     # ~17 Tools for managing state, persistence, scoring etc &#xA;│     │     │    └── agent/                     # ~27 Tools that the agent can use&#xA;│     │     ├── utils/                      # Python utilities&#xA;│     │     ├── entities.py                 # Python object model of the game entities&#xA;│     │     ├── game_types.py               # Technologies, Recipes, Resources&#xA;│     │     ├── instance.py                 # Environment state manager&#xA;│     │     └── namespace.py                # Namespace the agent can read/write variables to. &#xA;│     └── tests/                        # ~350 test cases&#xA;├── cluster/                        # Everything needed to launch Factorio servers&#xA;│     ├── docker/                       # Docker container definition of the Factorio server&#xA;│     │     ├── config/                     # Factorio server configuration files&#xA;│     │     └── mods/                       # Mods (deprecated)&#xA;│     ├── local/                        # Tools for dynamically creating Docker Compose files for clusters&#xA;│     ├── remote/                       # Tools for deploying Factorio clusters onto AWS &#xA;│     └── scenarios/                    # Factorio scenarios for Lab-play and Open-play&#xA;│         ├── default_lab_scenario/&#xA;│         └── open_world/&#xA;├── data/                           # Miscellaneous data&#xA;│     ├── blueprints_to_policies/       # Code to scrape Factorio blueprint sites and create Python policies&#xA;│     ├── icons/                        # Icons for Factorio entities and items&#xA;│     ├── prompts/                      # Prompts (deprecated)&#xA;│     ├── recipes/                      # Factorio recipes in JSONL format&#xA;│     └── scripts/                      # Misc Lua scripts (deprecated)&#xA;├── docs/                           # Website&#xA;│     └── assets/                       # Videos / Images&#xA;└── eval/&#xA;      ├── open/                     # Implementations for running agents in the open game&#xA;      │     ├── beam/                   # Implementation for Beam sampling&#xA;      │     ├── independent_runs/       # Implementation for independent eval runs&#xA;      │     ├── mcts/                   # Implementation for MCTS sampling&#xA;      │     └── plots/                  # Run results and plots&#xA;      └── tasks                     # Implementations for running agents against lab-play tasks&#xA;            ├── task_definitions/       # JSON definition of task&#xA;            ├── task_abc.py             # Abstract task definition&#xA;            └── throughput_task.py      # A basic task checking for a production throughput quota&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Database&lt;/h2&gt; &#xA;&lt;p&gt;To run long trajectories in FLE, we support checkpointing at every agent step using a SQL database. The &lt;code&gt;db_client&lt;/code&gt; implements the interface for saving and loading agent outputs, environment feedbacks, game states and histories of the current trajectory. We support out of the box Postgres and SQLite databases. The easiest way how to set up a FLE-compatible databse is to use SQLite and setup the programs table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# create the db file&#xA;sqlite3 mydatabase.db&#xA;&#xA;# create the programs table&#xA;CREATE TABLE programs (&#xA;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#xA;    code TEXT NOT NULL,&#xA;    value REAL DEFAULT 0.0,&#xA;    visits INTEGER DEFAULT 0,&#xA;    parent_id INTEGER,&#xA;    state_json TEXT,&#xA;    conversation_json TEXT NOT NULL,&#xA;    completion_token_usage INTEGER,&#xA;    prompt_token_usage INTEGER,&#xA;    token_usage INTEGER,&#xA;    response TEXT,&#xA;    holdout_value REAL,&#xA;    raw_reward REAL,&#xA;    version INTEGER DEFAULT 1,&#xA;    version_description TEXT DEFAULT &#39;&#39;,&#xA;    model TEXT DEFAULT &#39;gpt-4o&#39;,&#xA;    meta TEXT,&#xA;    achievements_json TEXT,&#xA;    instance INTEGER DEFAULT -1,&#xA;    depth REAL DEFAULT 0.0,&#xA;    advantage REAL DEFAULT 0.0,&#xA;    ticks INTEGER DEFAULT 0,&#xA;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The SQLite database can then be instantiated to be used for tasks in the &lt;code&gt;create_db_client&lt;/code&gt; function at &lt;code&gt;eval\open\independent_runs\trajectory_runner.py&lt;/code&gt;. We recommend setting up the database_file variable in the .env file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;from eval.open.db_client import SQLliteDBClient&#xA;async def create_db_client() -&amp;gt; SQLliteDBClient:&#xA;    &#34;&#34;&#34;Create database client with connection pool&#34;&#34;&#34;&#xA;    return SQLliteDBClient(&#xA;        max_conversation_length=40,&#xA;        min_connections=2,&#xA;        max_connections=5,&#xA;        # Provide the SQLite database file path&#xA;        database_file=os.getenv(&#34;SQLITE_DB_FILE&#34;) #&#34;mydatabase.db&#34;&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;We measured FLE execution performance across different configurations to measure performance. All benchmarks were run on a Macbook Pro M4 128GB, with 100 iterations per operation on a subset of the existing tools.&lt;/p&gt; &#xA;&lt;h3&gt;Direct API Calls (Factorio Client)&lt;/h3&gt; &#xA;&lt;p&gt;Executing tools against the Factorio server, while a Factorio game client is connected.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Min&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Sec&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity_next_to&lt;/td&gt; &#xA;   &lt;td&gt;2,578.20&lt;/td&gt; &#xA;   &lt;td&gt;42.97&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity&lt;/td&gt; &#xA;   &lt;td&gt;12,057.63&lt;/td&gt; &#xA;   &lt;td&gt;200.96&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;move_to&lt;/td&gt; &#xA;   &lt;td&gt;8,649.89&lt;/td&gt; &#xA;   &lt;td&gt;144.16&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;harvest_resource&lt;/td&gt; &#xA;   &lt;td&gt;16,599.44&lt;/td&gt; &#xA;   &lt;td&gt;276.66&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;craft_item&lt;/td&gt; &#xA;   &lt;td&gt;16,875.14&lt;/td&gt; &#xA;   &lt;td&gt;281.25&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;connect_entities&lt;/td&gt; &#xA;   &lt;td&gt;1,664.70&lt;/td&gt; &#xA;   &lt;td&gt;27.74&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;rotate_entity&lt;/td&gt; &#xA;   &lt;td&gt;12,281.31&lt;/td&gt; &#xA;   &lt;td&gt;204.69&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;insert_item&lt;/td&gt; &#xA;   &lt;td&gt;13,044.42&lt;/td&gt; &#xA;   &lt;td&gt;217.41&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;extract_item&lt;/td&gt; &#xA;   &lt;td&gt;17,167.43&lt;/td&gt; &#xA;   &lt;td&gt;286.12&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;inspect_inventory&lt;/td&gt; &#xA;   &lt;td&gt;17,036.32&lt;/td&gt; &#xA;   &lt;td&gt;283.94&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;get_resource_patch&lt;/td&gt; &#xA;   &lt;td&gt;7,004.49&lt;/td&gt; &#xA;   &lt;td&gt;116.74&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;7,513.29&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;125.22&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Direct API Calls (Headless)&lt;/h3&gt; &#xA;&lt;p&gt;Executing tools against the Factorio server without a game client.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Min&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Sec&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity_next_to&lt;/td&gt; &#xA;   &lt;td&gt;4,856.51&lt;/td&gt; &#xA;   &lt;td&gt;80.94&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity&lt;/td&gt; &#xA;   &lt;td&gt;22,332.72&lt;/td&gt; &#xA;   &lt;td&gt;372.21&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;move_to&lt;/td&gt; &#xA;   &lt;td&gt;16,005.59&lt;/td&gt; &#xA;   &lt;td&gt;266.76&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;harvest_resource&lt;/td&gt; &#xA;   &lt;td&gt;32,727.01&lt;/td&gt; &#xA;   &lt;td&gt;545.45&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;craft_item&lt;/td&gt; &#xA;   &lt;td&gt;36,223.63&lt;/td&gt; &#xA;   &lt;td&gt;603.73&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;connect_entities&lt;/td&gt; &#xA;   &lt;td&gt;2,926.01&lt;/td&gt; &#xA;   &lt;td&gt;48.77&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;rotate_entity&lt;/td&gt; &#xA;   &lt;td&gt;23,467.46&lt;/td&gt; &#xA;   &lt;td&gt;391.12&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;insert_item&lt;/td&gt; &#xA;   &lt;td&gt;25,154.28&lt;/td&gt; &#xA;   &lt;td&gt;419.24&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;extract_item&lt;/td&gt; &#xA;   &lt;td&gt;32,997.26&lt;/td&gt; &#xA;   &lt;td&gt;549.95&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;inspect_inventory&lt;/td&gt; &#xA;   &lt;td&gt;28,401.56&lt;/td&gt; &#xA;   &lt;td&gt;473.36&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;get_resource_patch&lt;/td&gt; &#xA;   &lt;td&gt;8,736.30&lt;/td&gt; &#xA;   &lt;td&gt;145.61&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;13,094.98&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;218.25&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Python Interpreter (Factorio Client)&lt;/h3&gt; &#xA;&lt;p&gt;Executing tools as part of a Python policy string, while a Factorio game client is connected.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Min&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Sec&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity_next_to&lt;/td&gt; &#xA;   &lt;td&gt;4,714.52&lt;/td&gt; &#xA;   &lt;td&gt;78.58&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity&lt;/td&gt; &#xA;   &lt;td&gt;4,774.13&lt;/td&gt; &#xA;   &lt;td&gt;79.57&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;move_to&lt;/td&gt; &#xA;   &lt;td&gt;4,005.77&lt;/td&gt; &#xA;   &lt;td&gt;66.76&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;harvest_resource&lt;/td&gt; &#xA;   &lt;td&gt;3,594.59&lt;/td&gt; &#xA;   &lt;td&gt;59.91&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;craft_item&lt;/td&gt; &#xA;   &lt;td&gt;4,985.02&lt;/td&gt; &#xA;   &lt;td&gt;83.08&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;connect_entities&lt;/td&gt; &#xA;   &lt;td&gt;1,497.11&lt;/td&gt; &#xA;   &lt;td&gt;24.95&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;rotate_entity&lt;/td&gt; &#xA;   &lt;td&gt;4,914.69&lt;/td&gt; &#xA;   &lt;td&gt;81.91&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;insert_item&lt;/td&gt; &#xA;   &lt;td&gt;5,046.99&lt;/td&gt; &#xA;   &lt;td&gt;84.12&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;extract_item&lt;/td&gt; &#xA;   &lt;td&gt;4,743.08&lt;/td&gt; &#xA;   &lt;td&gt;79.05&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;inspect_inventory&lt;/td&gt; &#xA;   &lt;td&gt;4,838.31&lt;/td&gt; &#xA;   &lt;td&gt;80.64&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;get_resource_patch&lt;/td&gt; &#xA;   &lt;td&gt;2,593.11&lt;/td&gt; &#xA;   &lt;td&gt;43.22&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;3,639.10&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;60.65&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Python Interpreter (Headless)&lt;/h3&gt; &#xA;&lt;p&gt;Executing tools as part of a Python policy string, without a game client.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Min&lt;/th&gt; &#xA;   &lt;th&gt;Operations/Sec&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity_next_to&lt;/td&gt; &#xA;   &lt;td&gt;5,069.60&lt;/td&gt; &#xA;   &lt;td&gt;84.49&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;place_entity&lt;/td&gt; &#xA;   &lt;td&gt;5,238.61&lt;/td&gt; &#xA;   &lt;td&gt;87.31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;move_to&lt;/td&gt; &#xA;   &lt;td&gt;4,979.59&lt;/td&gt; &#xA;   &lt;td&gt;82.99&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;harvest_resource&lt;/td&gt; &#xA;   &lt;td&gt;3,247.09&lt;/td&gt; &#xA;   &lt;td&gt;54.12&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;craft_item&lt;/td&gt; &#xA;   &lt;td&gt;5,854.27&lt;/td&gt; &#xA;   &lt;td&gt;97.57&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;connect_entities&lt;/td&gt; &#xA;   &lt;td&gt;2,150.21&lt;/td&gt; &#xA;   &lt;td&gt;35.84&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;rotate_entity&lt;/td&gt; &#xA;   &lt;td&gt;5,370.21&lt;/td&gt; &#xA;   &lt;td&gt;89.50&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;insert_item&lt;/td&gt; &#xA;   &lt;td&gt;5,065.89&lt;/td&gt; &#xA;   &lt;td&gt;84.43&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;extract_item&lt;/td&gt; &#xA;   &lt;td&gt;5,449.07&lt;/td&gt; &#xA;   &lt;td&gt;90.82&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;inspect_inventory&lt;/td&gt; &#xA;   &lt;td&gt;5,638.67&lt;/td&gt; &#xA;   &lt;td&gt;93.98&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;get_resource_patch&lt;/td&gt; &#xA;   &lt;td&gt;2,479.41&lt;/td&gt; &#xA;   &lt;td&gt;41.32&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;4,103.53&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;68.39&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Key Observations&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Headless vs Client Performance&lt;/strong&gt;: The headless server configuration consistently outperforms the client version, with direct API calls showing approximately 74% better throughput (218.25 vs 125.22 ops/sec).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Interpreter Overhead&lt;/strong&gt;: Adding the interpreter layer introduces significant overhead:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Headless: Drops from 218.25 to 68.39 ops/sec (~69% reduction)&lt;/li&gt; &#xA;   &lt;li&gt;Client: Drops from 125.22 to 60.65 ops/sec (~52% reduction)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Operation Variability&lt;/strong&gt;: Some operations show more significant performance variations:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;connect_entities&lt;/code&gt; is consistently the slowest operation across all configurations (because it relies on pathfinding)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;craft_item&lt;/code&gt; and &lt;code&gt;extract_item&lt;/code&gt; tend to be among the fastest operations&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>