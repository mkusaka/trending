<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-28T02:00:36Z</updated>
  <subtitle>Weekly Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>thunlp/WebCPM</title>
    <updated>2023-05-28T02:00:36Z</updated>
    <id>tag:github.com,2023-05-28:/thunlp/WebCPM</id>
    <link href="https://github.com/thunlp/WebCPM" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Official codes for ACL 2023 paper &#34;WebCPM: Interactive Web Search for Chinese Long-form Question Answering&#34;&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;WebCPM&lt;/h1&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;✨ This is the implementation of ACL 2023 paper &lt;a href=&#34;https://arxiv.org/abs/2305.06849&#34;&gt;Interactive Web Search for Chinese Long-form Question Answering&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/assets/paper.png&#34; alt=&#34;paper&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Read this in &lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/README_zh.md&#34;&gt;中文&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Quick links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#quick-links&#34;&gt;Quick links&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#preparation&#34;&gt;Preparation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#prepare-the-data&#34;&gt;Prepare the Data&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#prepare-the-model&#34;&gt;Prepare the model&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#train-webcpm&#34;&gt;Train WebCPM&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#a-brief-introduction-of-pipeline-based-web-search&#34;&gt;A brief Introduction of Pipeline-based Web Search&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#data-preprocessing&#34;&gt;Data Preprocessing&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#training-data-generation-of-interactive-web-search&#34;&gt;Training Data Generation of Interactive Web Search&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#training-data-generation-of-pipeline-based-web-search&#34;&gt;Training Data Generation of Pipeline-based Web Search&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#training&#34;&gt;Training&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#single-task-evaluation&#34;&gt;Single-task Evaluation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#run-webcpm-for-new-questions&#34;&gt;Run WebCPM for New Questions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#interactive-web-search&#34;&gt;Interactive Web Search&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#pipeline-based-web-search&#34;&gt;Pipeline-based Web Search&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#platform-building-for-data-annotation&#34;&gt;Platform Building for Data Annotation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#bugs-or-questions&#34;&gt;Bugs or questions?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#resources-of-tool-learning&#34;&gt;Resources of Tool Learning&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/#citation&#34;&gt;Citation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/assets/platform.png&#34; alt=&#34;platform&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In this work we present WebCPM, a project for interactive Web search using Chinese Pre-trained Models. We develop a web search interface which both humans and collect human web search behaviors. Then we fine-tune PLMs with up to 10B parameters to imitate human behaviors of web search and to generate answers based on the collected facts. We open source the web search interface, dataset, implementation, and model parameters.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;To run our code, please install all the dependency packages by using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Different versions of packages (e.g., &lt;code&gt;pytorch&lt;/code&gt;) may lead to different results from the paper. However, the trend should still hold no matter what versions of packages you use.&lt;/p&gt; &#xA;&lt;h2&gt;Preparation&lt;/h2&gt; &#xA;&lt;h3&gt;Prepare the Data&lt;/h3&gt; &#xA;&lt;p&gt;First download the data from &lt;a href=&#34;https://drive.google.com/drive/folders/1IQBOCwhcMUnkxevv9wVFVLIFT3o8f7HX?usp=sharing&#34;&gt;Google Drive&lt;/a&gt;, and put the files &lt;code&gt;interactive_data&lt;/code&gt; and &lt;code&gt;pipeline_data&lt;/code&gt; to &lt;code&gt;./data&lt;/code&gt;, or run the following commands:&lt;/p&gt; &#xA;&lt;p&gt;The downloaded files contain the following:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;interactive_data/data.json&lt;/code&gt; is the dataset used in the experiments of the paper (&lt;strong&gt;5500&lt;/strong&gt; instances in total). &lt;code&gt;interactive_data/data_zhihu.json&lt;/code&gt; is additional dataset collected alongside this paper (~&lt;strong&gt;900&lt;/strong&gt; instances), with the question sourcing from &lt;a href=&#34;https://www.zhihu.com/people/71-26-1-50&#34;&gt;Zhihu&lt;/a&gt;, you can use this for data augmentation.&lt;/p&gt; &#xA;&lt;p&gt;Please use the following codes to split the above data into train, dev, and test set (setting --add_zhihu will add data_zhihu.json).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd data/interactive_data&#xA;python split.py --add_zhihu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to the interactive web search data, we also provide the dataset needed for training the pipeline-based web search: &lt;code&gt;pipeline_data&lt;/code&gt; (&lt;strong&gt;110k&lt;/strong&gt; instances in total). All the data is created by prompting text-davinci-003 and then manually filtered by human annotators. (&lt;strong&gt;Note&lt;/strong&gt; This part is not included in the paper, and you don&#39;t need to split it into train / dev / test.)&lt;/p&gt; &#xA;&lt;h3&gt;Prepare the model&lt;/h3&gt; &#xA;&lt;p&gt;WebCPM is based on &lt;a href=&#34;https://github.com/OpenBMB/CPM-Live&#34;&gt;CPM-bee&lt;/a&gt; with up to &lt;strong&gt;10 billion&lt;/strong&gt; parameters, which is one of the largest Chinese pre-trained language model in the community. We use an early version of CPM-bee, which is denoted as cpm_10b_webcpm_exp.pt. The latest version of CPM-bee will be open-source soon. &lt;strong&gt;Note the model checkpoint has not been fine-tuned towards any downstream task&lt;/strong&gt;. To access cpm_10b_webcpm_exp.pt, you can download the model parameters at &lt;a href=&#34;https://cloud.tsinghua.edu.cn/d/a02ae00b11434c9c8560/&#34;&gt;Tsinghua Cloud&lt;/a&gt;, or run the following script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd models&#xA;bash download_model_initial_model.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above codes will download the 10B (non-finetuned) model at &lt;code&gt;models&lt;/code&gt;, for the finetuned pipeline model, please refer to &lt;code&gt;download_model_pipeline_finetuned.sh&lt;/code&gt;, or download it manually from &lt;a href=&#34;https://cloud.tsinghua.edu.cn/d/3dc39eccc6c64bb58671/&#34;&gt;Tsinghua Cloud&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Train WebCPM&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/assets/framework.png&#34; alt=&#34;platform&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We provide two versions of WebCPM: (1) interactive web search (the method proposed in the ACL paper) and (2) pipeline-based web search, which is easier to deploy (this method is not reported in the paper). Both versions use different scripts for training data generation and the same codes for model training.&lt;/p&gt; &#xA;&lt;h3&gt;A brief Introduction of Pipeline-based Web Search&lt;/h3&gt; &#xA;&lt;p&gt;The workflow follows four stages: (1) first, generate possible search queries based on the original question; (2) then for each search query, call Bing search and visit top-K web pages; (3) for each web page, extract the important information; (4) based on all the recorded information, generate a coherent and nuanced answer. All these things are trained in a multi-task way, please refer to &lt;code&gt;run_web_browsing/run_pipeline.py&lt;/code&gt;. For details of the interactive web search, please refer to our original paper.&lt;/p&gt; &#xA;&lt;h3&gt;Data Preprocessing&lt;/h3&gt; &#xA;&lt;p&gt;Before you start, run the following codes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PYTHONPATH=/**your-base-path**/webcpm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The training data generation is as follows (we differentiate between interactive web search and pipeline-based method). The following codes will generate &lt;code&gt;train_data&lt;/code&gt;, &lt;code&gt;dev_data&lt;/code&gt;, and &lt;code&gt;test_data&lt;/code&gt; in the corresponding folder, which will be loaded during training.&lt;/p&gt; &#xA;&lt;h4&gt;Training Data Generation of Interactive Web Search&lt;/h4&gt; &#xA;&lt;p&gt;First, construct the data for the synthesis model using the following codes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd dataset_interactive&#xA;python make_data_synthesis_model.py --data_path ../../data/interactive_data  --augment_qa_data --augment_data_path ../../data/pipeline_data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We explain some of the arguments as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;data_path&lt;/code&gt;: The source data path.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;augment_qa_data&lt;/code&gt;: Whether to augment the training data with qa data automatically generated by text-davinci. (To replicate the results in our paper, do not add this argument)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;augment_data_path&lt;/code&gt;: The data path to the augmented training data.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The training data generation of the search model is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python make_data_search_model.py --add_query --add_action --add_abstract --abstract_all_tokens&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We explain some of the arguments as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;data_path&lt;/code&gt;: The source data path.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_query&lt;/code&gt;: If True, will add the query generation data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_abstract&lt;/code&gt;: If True, will add the generate supporting fact extraction data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;abstract_all_tokens&lt;/code&gt;: If True, supporting fact extraction module will generate all the tokens, instead of only the first / last few tokens.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_action&lt;/code&gt;: If True, will add the action prediction data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_synthesis&lt;/code&gt;: If True, will load local data for the synthesis model. &lt;strong&gt;Note You must first run python make_data_synthesis_model.py to obtain the synthesis data then add this argument here&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to train all sub-tasks in a multi-task way, just add all the above arguments; otherwise only add one argument (e.g., &lt;code&gt;--add_query&lt;/code&gt;) for single-task testing.&lt;/p&gt; &#xA;&lt;h4&gt;Training Data Generation of Pipeline-based Web Search&lt;/h4&gt; &#xA;&lt;p&gt;Please run the following codes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd dataset_pipeline&#xA;python make_data.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Training&lt;/h3&gt; &#xA;&lt;p&gt;To train WebCPM, run the following codes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd training&#xA;export PYTHONPATH=/**your-base-path**/webcpm&#xA;export CUDA_VISIBLE_DEVICES=0,1,2,3,4,5,6,7&#xA;GPUS_PER_NODE=$(echo $CUDA_VISIBLE_DEVICES | tr &#39;,&#39; &#39;\n&#39; | wc -l | xargs)&#xA;echo &#34;Number of visible devices: $GPUS_PER_NODE, should be the same as visible devices&#34;&#xA;&#xA;set -ex&#xA;&#xA;MASTER_ADDR=localhost&#xA;MASTER_PORT=3239&#xA;NNODES=1&#xA;NODE_RANK=0&#xA;&#xA;OPTS=&#34;&#34;&#xA;OPTS+=&#34; --model-config config/cpm-bee-10b.json&#34;&#xA;OPTS+=&#34; --dataset ../data/dataset_interactive/train_data&#34;&#xA;OPTS+=&#34; --dataseteval ../data/dataset_interactive/dev_data&#34;&#xA;OPTS+=&#34; --epoch 5&#34;&#xA;OPTS+=&#34; --batch-size 8&#34;&#xA;OPTS+=&#34; --train-iters 100&#34;&#xA;OPTS+=&#34; --save-name webcpm_finetuned&#34;&#xA;OPTS+=&#34; --max-length 2560&#34;&#xA;OPTS+=&#34; --save ../models/&#34;&#xA;OPTS+=&#34; --lr 0.0001&#34;&#xA;OPTS+=&#34; --inspect-iters 100&#34;&#xA;OPTS+=&#34; --warmup-iters 1&#34;&#xA;OPTS+=&#34; --save-epochs 1&#34;&#xA;OPTS+=&#34; --lr-decay-style noam&#34;&#xA;OPTS+=&#34; --weight-decay 0.01&#34;&#xA;OPTS+=&#34; --clip-grad 1.0&#34;&#xA;OPTS+=&#34; --loss-scale 32768&#34;&#xA;OPTS+=&#34; --start-step 0&#34;&#xA;OPTS+=&#34; --load ../models/cpm_10b_webcpm_exp.pt&#34;&#xA;&#xA;CMD=&#34;torchrun --nnodes=${NNODES} --nproc_per_node=${GPUS_PER_NODE} --rdzv_id=1 --rdzv_backend=c10d --rdzv_endpoint=${MASTER_ADDR}:${MASTER_PORT} finetune_cpm_bee.py ${OPTS}&#34;&#xA;&#xA;echo ${CMD}&#xA;$CMD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We explain some of the arguments as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;dataset&lt;/code&gt; and &lt;code&gt;dataseteval&lt;/code&gt;: The path to the processed file. For interactive web search, it is dataset_interactive, while for pipeline-based method, it is dataset_pipeline.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;batch-size&lt;/code&gt;: The batch size of a single GPU, the real batch size will be #GPUs x batch-size per GPU.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max-length&lt;/code&gt;: The maximum sequence length of the data (not the model), those longer training instances will be dropped.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;save-name&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;: The path to save the fine-tuned model and the name of the saved model checkpoint.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;epoch&lt;/code&gt;: The number of training epochs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;load&lt;/code&gt;: The path to the pre-trained model checkpoint (cpmb in this case).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note no matter which module you are training (or the multi-task setting), you can use the above codes. We are training on 8x80G A100, you can change the batch size according to your GPU devices, the performance is not sensitive to the hyper-parameters.&lt;/p&gt; &#xA;&lt;h2&gt;Single-task Evaluation&lt;/h2&gt; &#xA;&lt;p&gt;To evaluate different sub-tasks, you can first run the following codes to get the prediction of your fine-tuned model on the test data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd inference&#xA;python inference.py --test_file ../training/dataset_interactive/test.txt --output_file output/test_predictions.json --ckpt_path **your_finetuned_checkpoint.pt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We explain some of the arguments as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;test_file&lt;/code&gt;: The path to the test file, it should have been generated during data preprocessing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;output_file&lt;/code&gt;: The path you want to write your predictions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ckpt_path&lt;/code&gt;: The path to your fine-tuned model.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After obtaining the predictions on the test file, you can run the following codes for single-task evaluation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python evaluate.py --input_file output/test_predictions.txt --evaluate_action&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We explain some of the arguments as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;input_file&lt;/code&gt;: The path you write your predictions of the test file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;evaluate_action&lt;/code&gt;: Whether you want to evaluate the action prediction task (F1).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;evaluate_query&lt;/code&gt;: Whether you want to evaluate the search query generation task (Rougel-L).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;evaluate_abstract&lt;/code&gt;: Whether you want to evaluate the supporting fact extraction task (Rougel-L).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;abstract_all_tokens&lt;/code&gt;: Which mode do you train your model for supporting fact extraction, if you generate all the tokens, add this argument (Rougel-L).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;evaluate_answer&lt;/code&gt;: Whether you want to evaluate the answer synthesis task (Rougel-L).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beam_size&lt;/code&gt;: Setting beam size to 1 would significantly accelerate inference, but hurt the performance a little bit.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Run WebCPM for New Questions&lt;/h2&gt; &#xA;&lt;p&gt;This is the implementation for the whole pipeline evaluation. You can use the following codes to generate answers for new questions. Note this requires you to first get a Bing search API key from &lt;a href=&#34;https://www.microsoft.com/en-us/bing/apis/bing-web-search-api&#34;&gt;here&lt;/a&gt; and run the following codes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd run_web_browsing&#xA;export PYTHONPATH=/**base-path**/webcpm&#xA;export BING_SEARCH_KEY=&#34;**Your Bing Search API Key**&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interactive Web Search&lt;/h3&gt; &#xA;&lt;p&gt;Coming soon.&lt;/p&gt; &#xA;&lt;h3&gt;Pipeline-based Web Search&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python run_pipeline.py --data_path predictions/test.json --ckpt_path **your-checkpoint**&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We explain some of the arguments as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;data_path&lt;/code&gt;: The path you write your predictions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ckpt_path&lt;/code&gt;: The path to the checkpoint where you have trained using the pipeline-based method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Platform Building for Data Annotation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/assets/annotation.png&#34; alt=&#34;platform&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We open source our web search interface, you can use it for data annotation. Please refer to &lt;a href=&#34;https://raw.githubusercontent.com/thunlp/WebCPM/main/annotation_platform/README.md&#34;&gt;Annotation&lt;/a&gt;. The codes are a bit messy currently, we will soon upload a cleaner version.&lt;/p&gt; &#xA;&lt;h2&gt;Bugs or questions?&lt;/h2&gt; &#xA;&lt;p&gt;If you have any questions related to the codes or the paper, please contact Yujia (&lt;code&gt;qyj20@mails.tsinghua.edu.cn&lt;/code&gt;) or open an issue.&lt;/p&gt; &#xA;&lt;h2&gt;Resources of Tool Learning&lt;/h2&gt; &#xA;&lt;p&gt;With the powerful capabilities of foundation models, we are eager to see their applications in manipulating various tools. WebCPM is one typical research attempts. For more resources, please refer to the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;BMTools&lt;/strong&gt;. [&lt;a href=&#34;https://github.com/OpenBMB/BMTools&#34;&gt;Project&lt;/a&gt;]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Tool Learning&lt;/strong&gt;. [&lt;a href=&#34;https://arxiv.org/abs/2304.08354&#34;&gt;Paper&lt;/a&gt;]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Tool Learning Paper List&lt;/strong&gt;. [&lt;a href=&#34;https://github.com/thunlp/ToolLearningPapers&#34;&gt;Project&lt;/a&gt;]&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;p&gt;If you find our WebCPM useful, please use the following citation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@inproceedings{qin2023webcpm,&#xA;    title = &#34;WebCPM: Interactive Web Search for Chinese Long-form Question Answering&#34;,&#xA;    author={Yujia Qin and Zihan Cai and Dian Jin and Lan Yan and Shihao Liang and Kunlun Zhu and Yankai Lin and Xu Han and Ning Ding and Huadong Wang and Ruobing Xie and Fanchao Qi and Zhiyuan Liu and Maosong Sun and Jie Zhou},&#xA;    booktitle = &#34;Proceedings of ACL 2023&#34;,&#xA;    year = &#34;2023&#34;,&#xA;    publisher = &#34;Association for Computational Linguistics&#34;,&#xA;    url = &#34;https://arxiv.org/abs/2305.06849&#34;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>smol-ai/menubar</title>
    <updated>2023-05-28T02:00:36Z</updated>
    <id>tag:github.com,2023-05-28:/smol-ai/menubar</id>
    <link href="https://github.com/smol-ai/menubar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;a menubar with Zero latency access to ChatGPT/Bard/Claude! A/B test them, or use them in the background. I use this 20 times a day.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;smol menubar&lt;/h1&gt; &#xA;&lt;p&gt;This is a smol menubar app that helps you quickly access ChatGPT, Bard, and Anthropic with a single keyboard shortcut.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/smol-ai/menubar/assets/6764957/753c6128-d978-4bb4-8642-588d42121ff5&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;whatever is typed at the bottom is entered into all 3 windows simultaneously, however if you wish to explore one further than the other you can do so independently since they are just webviews.&lt;/p&gt; &#xA;&lt;p&gt;so for example you can use chatgpt plugins despite there not being an api for them. or you can use bard/anthropic without needing api access.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; I understand not everybody has access to Anthropic yet. You can hide individual webviews from the preferences modal. I&#39;d happily take a PR to make the panels customizable to different URLs and input targets!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;video demo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/jrlxT1K4LEU&#34;&gt;https://youtu.be/jrlxT1K4LEU&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/swyx/status/1658403625717338112&#34;&gt;https://twitter.com/swyx/status/1658403625717338112&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;install&lt;/h2&gt; &#xA;&lt;p&gt;either download the precompiled binaries for MacOS: &lt;a href=&#34;https://github.com/smol-ai/menubar/releases/latest&#34;&gt;https://github.com/smol-ai/menubar/releases/latest&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;or build from source to get a build optimized for your system (see below)&lt;/p&gt; &#xA;&lt;p&gt;then log into your google account (either will do, both rely on google login) &lt;img src=&#34;https://github.com/smol-ai/menubar/assets/6764957/dce5b127-e8c2-4be2-97d3-e2fa3042ef24&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;dont worry i dont track anything. inspect and build from source if you wish.&lt;/p&gt; &#xA;&lt;h2&gt;usage&lt;/h2&gt; &#xA;&lt;p&gt;I usually just always press Cmd+Shift+G -&amp;gt; quick open to use it and Cmd+Enter to submit.&lt;/p&gt; &#xA;&lt;p&gt;You can resize the overall window with a click n drag. Cmd+1/2/3/A or drag to resize the internal webviews as you wish.&lt;/p&gt; &#xA;&lt;p&gt;You can also disable models from the preferences modal and your choice is persisted.&lt;/p&gt; &#xA;&lt;p&gt;To start a new conversation, cmd+R (simple window refresh, nothing special)&lt;/p&gt; &#xA;&lt;p&gt;You can modify these keyboard shortcuts if you build it from source.&lt;/p&gt; &#xA;&lt;p&gt;Login for Anthropic via Google SSO is broken right now - it requires a popup which is blocked at least in my testing. Would welcome a PR to fix that, but otherwise regular email + login token works fine.&lt;/p&gt; &#xA;&lt;h2&gt;build from source&lt;/h2&gt; &#xA;&lt;p&gt;To build from source, you will need to clone the repo and open the project folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/smol-ai/menubar.git&#xA;cd menubar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then install dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows, you&#39;ll also need Squirrel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install electron-squirrel-startup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate binaries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run make # or npm run build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Outputs go to &lt;code&gt;/out/make&lt;/code&gt;. Run &lt;code&gt;smol-menubar.exe&lt;/code&gt; to fire up the app. Note that it may start minimized to your taskbar, in which case you&#39;ll have to click the icon to use it:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/smol-ai/menubar/main/images/minimized.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;debugging&lt;/h2&gt; &#xA;&lt;p&gt;have the devtools up all the time by uncommenting this line&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;window.webContents.openDevTools();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;why use/make this?&lt;/h2&gt; &#xA;&lt;p&gt;Google &lt;a href=&#34;https://www.theverge.com/2023/5/10/23718066/google-bard-ai-features-waitlist-dark-mode-visual-search-io&#34;&gt;dropped its waitlist for Bard recently&lt;/a&gt;, so now there is some reason to try it out.&lt;/p&gt; &#xA;&lt;p&gt;People have bad first impressions on Bard, but in May 2023 it has been receiving some positive feedback:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitter.com/masadfrost/status/1655802654927507457?s=46&amp;amp;t=90xQ8sGy63D2OtiaoGJuww&#34;&gt;&lt;img src=&#34;https://github.com/smol-ai/menubar/assets/6764957/0d86234e-1d91-4863-8311-580888511b20&#34; alt=&#34;image&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitter.com/amasad/status/1657510601202221056?s=46&amp;amp;t=90xQ8sGy63D2OtiaoGJuww&#34;&gt;&lt;img src=&#34;https://github.com/smol-ai/menubar/assets/6764957/e191701a-0b32-43aa-abc0-42e6fd9584aa&#34; alt=&#34;image&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;these folks aren&#39;t neutral, but its clear of course that Bard will be better for some things than others, and we might as well lower the barrier for trying them out.&lt;/p&gt; &#xA;&lt;p&gt;then anthropic dropped 100k context, and at that point i was convinced i need to be A/B testing all 3 to get the benefits/get an intuition of what they each are best at.&lt;/p&gt; &#xA;&lt;h2&gt;help needed&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;i need a new set of icons for the images&lt;/li&gt; &#xA; &lt;li&gt;better styling for the window? maybe normalize the bard window to the openai dimensions?&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>InterestingDarkness/ChatSydney</title>
    <updated>2023-05-28T02:00:36Z</updated>
    <id>tag:github.com,2023-05-28:/InterestingDarkness/ChatSydney</id>
    <link href="https://github.com/InterestingDarkness/ChatSydney" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Any PRs are highly appreciated. Seeking a new maintainer. Latest tested EdgeGPT version: 0.6.5&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ChatSydney&lt;/h1&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;First, you need to have Python 3.11 or higher installed. Then, you can install the required dependencies using pip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -r requirements.txt --upgrade&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to get cookies.json&lt;/h2&gt; &#xA;&lt;p&gt;same as EdgeGPT &lt;a href=&#34;https://github.com/acheong08/EdgeGPT#getting-authentication-required&#34;&gt;https://github.com/acheong08/EdgeGPT#getting-authentication-required&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;After saving &lt;code&gt;cookies.json&lt;/code&gt; in current directory, you can run this project using the Python command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python main.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can open &lt;code&gt;http://localhost:65432&lt;/code&gt; in your browser to start chatting.&lt;/p&gt; &#xA;&lt;h2&gt;Command Line Arguments&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--host&lt;/code&gt; or &lt;code&gt;-H&lt;/code&gt;: The hostname and port for the server, default is &lt;code&gt;localhost:65432&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--proxy&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt;: Proxy address, like &lt;code&gt;http://localhost:7890&lt;/code&gt;, default is empty.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;WebSocket API&lt;/h2&gt; &#xA;&lt;p&gt;The WebSocket API accepts a JSON object containing the following fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;message&lt;/code&gt;: The user&#39;s message.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;context&lt;/code&gt;: The context of the conversation, can be any string.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The WebSocket API returns a JSON object containing the following fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type&lt;/code&gt;: The type of the message, can be the type from Bing response or &lt;code&gt;error&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;message&lt;/code&gt;: The response from EdgeGPT.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;error&lt;/code&gt;: If an error occurs, this field will contain the error message.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>