<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-24T01:51:31Z</updated>
  <subtitle>Weekly Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mouredev/python-web</title>
    <updated>2023-12-24T01:51:31Z</updated>
    <id>tag:github.com,2023-12-24:/mouredev/python-web</id>
    <link href="https://github.com/mouredev/python-web" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Curso para aprender desarrollo frontend Web con Python puro desde cero. Elaborado durante las emisiones en directo desde Twitch de MoureDev.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Python Web&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://python.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Python-3.11+-yellow?style=for-the-badge&amp;amp;logo=python&amp;amp;logoColor=white&amp;amp;labelColor=101010&#34; alt=&#34;Python&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://reflex.dev&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Reflex-0.3.6+-5646ED?style=for-the-badge&amp;amp;logo=reflex&amp;amp;logoColor=white&amp;amp;labelColor=101010&#34; alt=&#34;Reflex&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Curso de 6 horas en v√≠deo para aprender desarrollo web frontend con Python puro y Reflex desde cero.&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mouredev/python-web/main/Images/header.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Proyecto realizado durante emisiones en directo desde &lt;a href=&#34;https://twitch.tv/mouredev&#34;&gt;Twitch&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h5&gt;Si consideras √∫til el curso, ap√≥yalo haciendo &#34;‚òÖ Star&#34; en el repositorio. ¬°Gracias!&lt;/h5&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Tutorial en v√≠deo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&#34;&gt;&lt;img src=&#34;http://i3.ytimg.com/vi/n2YrGsXJC6Y/maxresdefault.jpg&#34; style=&#34;height: 50%; width:50%;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&#34;&gt;Curso de Python Web&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=272&#34;&gt;Lecci√≥n 1 - Introducci√≥n&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=1147&#34;&gt;Lecci√≥n 2 - Caracter√≠sticas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=1551&#34;&gt;Lecci√≥n 3 - Instalaci√≥n&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=3043&#34;&gt;Lecci√≥n 4 - Primeros pasos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=3442&#34;&gt;Lecci√≥n 5 - Fundamentos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=4259&#34;&gt;Lecci√≥n 6 - Hola mundo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=4593&#34;&gt;Lecci√≥n 7 - Componentes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=6805&#34;&gt;Lecci√≥n 8 - Maquetaci√≥n&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=9190&#34;&gt;Lecci√≥n 9 - Estilos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=13807&#34;&gt;Lecci√≥n 10 - Colores e iconos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=15124&#34;&gt;Lecci√≥n 11 - Fuentes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=16249&#34;&gt;Lecci√≥n 12 - Im√°genes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=17505&#34;&gt;Lecci√≥n 13 - Fuentes remotas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=18225&#34;&gt;Lecci√≥n 14 - Dise√±o responsive&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=19058&#34;&gt;Lecci√≥n 15 - Accesibilidad&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=19283&#34;&gt;Lecci√≥n 16 - Despliegue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/n2YrGsXJC6Y&amp;amp;t=20892&#34;&gt;Pr√≥ximos pasos&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tienes un canal llamado &lt;strong&gt;&#34;python&#34;&lt;/strong&gt; en el servidor de &lt;strong&gt;&lt;a href=&#34;https://mouredev.com/discord&#34;&gt;Discord&lt;/a&gt;&lt;/strong&gt; de la comunidad para preguntar, compartir y ayudar.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Proyecto&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://moure.dev&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mouredev/python-web/main/Images/web.png&#34; style=&#34;height: 50%; width:50%;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mouredev/python-web/main/link_bio&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mouredev/python-web/main/Images/web.gif&#34; style=&#34;height: 50%; width:50%;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Durante el curso aprenderemos desarrollo web con Python puro utilizando el framework &lt;a href=&#34;https://github.com/reflex-dev/reflex&#34;&gt;Reflex&lt;/a&gt;. Realizaremos un proyecto pr√°ctico que consistir√° en desarrollar y publicar mi nueva web de links &lt;a href=&#34;https://moure.dev/&#34;&gt;moure.dev&lt;/a&gt; (a√±adi√©ndole nuevas funcionalidades). Todo el c√≥digo est√° disponible para que cualquiera pueda usarlo.&lt;/p&gt; &#xA;&lt;h3&gt;üíª &lt;a href=&#34;https://raw.githubusercontent.com/mouredev/python-web/main/link_bio&#34;&gt;Accede al c√≥digo del proyecto&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h2&gt;Tutorial extra en v√≠deo (+3 horas)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/h8Tn0ITRoQs&#34;&gt;&lt;img src=&#34;http://i3.ytimg.com/vi/h8Tn0ITRoQs/maxresdefault.jpg&#34; style=&#34;height: 50%; width:50%;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Proyecto pr√°ctico extra de c√≥digo libre que consistir√° en desarrollar y publicar la web del &lt;a href=&#34;https://adviento.dev/&#34;&gt;Calendario de aDEViento&lt;/a&gt; de la comunidad. Una activdad donde repartimos cursos y libros sobre programaci√≥n en Navidad.&lt;/p&gt; &#xA;&lt;h3&gt;üíª &lt;a href=&#34;https://github.com/mouredev/adeviento-web&#34;&gt;Accede al c√≥digo del proyecto extra&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h2&gt;Informaci√≥n importante y preguntas frecuentes&lt;/h2&gt; &#xA;&lt;p&gt;Todo el contenido se crea en directo desde &lt;a href=&#34;https://www.twitch.tv/mouredev&#34;&gt;Twitch&lt;/a&gt;, y en este repositorio podr√°s encontrar las clases en v√≠deo, el c√≥digo programado, enlaces de inter√©s y la informaci√≥n relevante.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Es un curso desde cero y no necesitas conocimientos previos sobre desarrollo web.&lt;/li&gt; &#xA; &lt;li&gt;Recuerda que he creado en el &lt;a href=&#34;https://discord.gg/mouredev&#34;&gt;Discord&lt;/a&gt; un canal &#34;üêçpython&#34; para que puedas comentar lo que quieras.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Curso finalizado... ¬øYa est√°?&lt;/h2&gt; &#xA;&lt;p&gt;Este curso continuar√° en una segunda parte donde aprenderemos sobre backend, routers, APIs, bases de datos y mucho m√°s...&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Est√©n atento al repositorio y mis &lt;a href=&#34;https://moure.dev&#34;&gt;redes sociales&lt;/a&gt; para no perderte la continuaci√≥n.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Enlaces de inter√©s&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.python.org/&#34;&gt;Web oficial de Python&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://reflex.dev/&#34;&gt;Web oficial de Reflex&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://reflex.dev/docs/&#34;&gt;Documentaci√≥n oficial de Reflex&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/reflex-dev/reflex&#34;&gt;Repositorio en GitHub de Reflex&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vscode.dev/&#34;&gt;Visual Studio Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.w3schools.com/css/&#34;&gt;Documentaci√≥n CSS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://web.dev/learn/css/&#34;&gt;Curso de CSS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://chakra-ui.com/&#34;&gt;Chakra UI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://fonts.google.com/&#34;&gt;Google Fonts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://fontawesome.com/&#34;&gt;Font Awesome&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vercel.com/&#34;&gt;Vercel&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Curso de Python desde cero&lt;/h2&gt; &#xA;&lt;h3&gt;Aprende Python desde sus fundamentos&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mouredev/hello-python&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mouredev/Hello-Python/main/Images/header.jpg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Si quieres aprender desde cero, tienes gratis todos los tutoriales que he creado. M√°s de 25 horas desde fundamentos, backend o integraci√≥n con IA.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mouredev/hello-python&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/mouredev/hello-python?label=Curso%20Python%20desde%20cero&amp;amp;style=social&#34; alt=&#34;Curso Python&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Puedes apoyar mi trabajo haciendo &#34;‚òÜ Star&#34; en el repo o nominarme a &#34;GitHub Star&#34;. ¬°Gracias!&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://stars.github.com/nominate/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/GitHub-Nominar_a_star-yellow?style=for-the-badge&amp;amp;logo=github&amp;amp;logoColor=white&amp;amp;labelColor=101010&#34; alt=&#34;GitHub Star&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Si quieres unirte a nuestra comunidad de desarrollo, aprender programaci√≥n de Apps, mejorar tus habilidades y ayudar a la continuidad del proyecto, puedes encontrarnos en:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitch.tv/mouredev&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Twitch-Programaci%C3%B3n_en_directo-9146FF?style=for-the-badge&amp;amp;logo=twitch&amp;amp;logoColor=white&amp;amp;labelColor=101010&#34; alt=&#34;Twitch&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mouredev.com/discord&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Discord-Servidor_de_la_comunidad-5865F2?style=for-the-badge&amp;amp;logo=discord&amp;amp;logoColor=white&amp;amp;labelColor=101010&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://moure.dev&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Links_de_inter%C3%A9s-moure.dev-39E09B?style=for-the-badge&amp;amp;logo=Linktree&amp;amp;logoColor=white&amp;amp;labelColor=101010&#34; alt=&#34;Link&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mouredev/mouredev/master/mouredev_emote.png&#34; alt=&#34;https://mouredev.com&#34;&gt; Hola, mi nombre es Brais Moure.&lt;/h2&gt; &#xA;&lt;h3&gt;Freelance full-stack iOS &amp;amp; Android engineer&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtube.com/mouredevapps?sub_confirmation=1&#34;&gt;&lt;img src=&#34;https://img.shields.io/youtube/channel/subscribers/UCxPD7bsocoAMq8Dj18kmGyQ?style=social&#34; alt=&#34;YouTube Channel Subscribers&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitch.com/mouredev&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitch/status/mouredev?style=social&#34; alt=&#34;Twitch Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mouredev.com/discord&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/729672926432985098?style=social&amp;amp;label=Discord&amp;amp;logo=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/mouredev&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/mouredev?style=social&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/followers/mouredev?style=social&#34; alt=&#34;GitHub Followers&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/mouredev?style=social&#34; alt=&#34;GitHub Followers&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Soy ingeniero de software desde hace m√°s de 13 a√±os. Desde hace 5 a√±os combino mi trabajo desarrollando Apps con creaci√≥n de contenido formativo sobre programaci√≥n y tecnolog√≠a en diferentes redes sociales como &lt;strong&gt;&lt;a href=&#34;https://moure.dev&#34;&gt;@mouredev&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;En mi perfil de GitHub tienes m√°s informaci√≥n&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mouredev&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/GitHub-MoureDev-14a1f0?style=for-the-badge&amp;amp;logo=github&amp;amp;logoColor=white&amp;amp;labelColor=101010&#34; alt=&#34;Web&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>solidjs/solid-start</title>
    <updated>2023-12-24T01:51:31Z</updated>
    <id>tag:github.com,2023-12-24:/solidjs/solid-start</id>
    <link href="https://github.com/solidjs/solid-start" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SolidStart, the Solid app framework&lt;/p&gt;&lt;hr&gt;&lt;p&gt; &lt;img width=&#34;100%&#34; src=&#34;https://assets.solidjs.com/banner?project=Start&amp;amp;type=core&#34; alt=&#34;Solid Docs&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;SolidStart&lt;/h1&gt; &#xA;&lt;h3&gt;Start has just entered a new Beta Phase&lt;/h3&gt; &#xA;&lt;p&gt;v0.4.x marks a significant change in the project. Please check the updated docs and example projects to see how things have changed. A summary of the chances can be found in the &lt;a href=&#34;https://github.com/solidjs/solid-start/discussions/1052&#34;&gt;RFC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;This is the home of the Solid app framework. This is still a &lt;strong&gt;work in progress&lt;/strong&gt;. Many features are missing or incomplete. Experimental status does not even mean beta status. Patch releases will break everything.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;File-system based routing&lt;/li&gt; &#xA; &lt;li&gt;Supports all rendering modes: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Server-side rendering (SSR)&lt;/li&gt; &#xA;   &lt;li&gt;Streaming SSR&lt;/li&gt; &#xA;   &lt;li&gt;Client-side rendering (CSR)&lt;/li&gt; &#xA;   &lt;li&gt;Static Site Generation (SSG)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Streaming&lt;/li&gt; &#xA; &lt;li&gt;Build optimizations with Code splitting, tree shaking and dead code elimination&lt;/li&gt; &#xA; &lt;li&gt;API Routes&lt;/li&gt; &#xA; &lt;li&gt;Built on Web standards like Fetch, Streams, and WebCrypto&lt;/li&gt; &#xA; &lt;li&gt;Adapters for deployment to all popular platforms&lt;/li&gt; &#xA; &lt;li&gt;CSS Modules, SASS/SCSS Support&lt;/li&gt; &#xA; &lt;li&gt;TypeScript-first&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Getting started&lt;/h3&gt; &#xA;&lt;p&gt;Create a SolidStart application and run a development server using your preferred package manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir my-app&#xA;cd my-app&#xA;&#xA;# with npm&#xA;npm init solid@latest&#xA;npm install&#xA;npm run dev&#xA;&#xA;# or with pnpm&#xA;pnpm create solid@latest&#xA;pnpm install&#xA;pnpm dev&#xA;&#xA;# or with Bun&#xA;bunx create-solid@latest&#xA;bun install&#xA;bun run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Development&lt;/h3&gt; &#xA;&lt;p&gt;You should use a node version manager &lt;a href=&#34;https://stackoverflow.com/a/62978089/565877&#34;&gt;compatible with &lt;code&gt;.node-version&lt;/code&gt;&lt;/a&gt; (&lt;a href=&#34;https://asdf-vm.com/&#34;&gt;asdf-vm&lt;/a&gt; is a great option mac/linux users)&lt;/p&gt; &#xA;&lt;p&gt;The monorepo uses &lt;code&gt;pnpm&lt;/code&gt; as the package manager. To install &lt;code&gt;pnpm&lt;/code&gt;, run the following command in your terminal.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g pnpm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;pnpm install&lt;/code&gt; to install all the dependencies for the packages and examples in your monorepo.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;h4&gt;Monorepo &amp;amp; &lt;code&gt;project.json&lt;/code&gt; &lt;code&gt;&#34;workspace&#34;&lt;/code&gt; support&lt;/h4&gt;&lt;/summary&gt; &#xA; &lt;p&gt;If you are using Solid Start within a monorepo that takes advantage of the &lt;code&gt;package.json&lt;/code&gt; &lt;code&gt;&#34;workspaces&#34;&lt;/code&gt; property (e.g. &lt;a href=&#34;https://classic.yarnpkg.com/en/docs/workspaces/&#34;&gt;yarn workspaces&lt;/a&gt;) with hoisted dependencies (the default for yarn), you must include &lt;code&gt;solid-start&lt;/code&gt; within the optional &lt;code&gt;&#34;nohoist&#34;&lt;/code&gt; (for yarn v2 or higher, see further down for instructions) workspaces property.&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;em&gt;In the following, &#34;workspace root&#34; refers to the root of your repository while &#34;project root&#34; refers to the root of a child package within your repository&lt;/em&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;For example, if specifying &lt;code&gt;&#34;nohoist&#34;&lt;/code&gt; options from the workspace root (i.e. for all packages):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-jsonc&#34;&gt;// in workspace root&#xA;{&#xA;  &#34;workspaces&#34;: {&#xA;    &#34;packages&#34;: [&#xA;      /* ... */&#xA;    ],&#xA;    &#34;nohoist&#34;: [&#34;**/solid-start&#34;]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If specifying &lt;code&gt;&#34;nohoist&#34;&lt;/code&gt; options for a specific package using &lt;code&gt;solid-start&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-jsonc&#34;&gt;// in project root of a workspace child&#xA;{&#xA;  &#34;workspaces&#34;: {&#xA;    &#34;nohoist&#34;: [&#34;solid-start&#34;]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Regardless of where you specify the &lt;code&gt;nohoist&lt;/code&gt; option, you also need to include &lt;code&gt;solid-start&lt;/code&gt; as a &lt;code&gt;devDependency&lt;/code&gt; in the child &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;The reason why this is necessary is because &lt;code&gt;solid-start&lt;/code&gt; creates an &lt;code&gt;index.html&lt;/code&gt; file within your project which expects to load a script located in &lt;code&gt;/node_modules/solid-start/runtime/entry.jsx&lt;/code&gt; (where &lt;code&gt;/&lt;/code&gt; is the path of your project root). By default, if you hoist the &lt;code&gt;solid-start&lt;/code&gt; dependency into the workspace root then that script will not be available within the package&#39;s &lt;code&gt;node_modules&lt;/code&gt; folder.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Yarn v2 or higher&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;The &lt;code&gt;nohoist&lt;/code&gt; option is no longer available in Yarn v2+. In this case, we can use the &lt;code&gt;installConfig&lt;/code&gt; property in the &lt;code&gt;package.json&lt;/code&gt; (either workspace package or a specific project package) to make sure our deps are not hoisted.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-jsonc&#34;&gt;// in project root of a workspace child&#xA;{&#xA;  &#34;installConfig&#34;: {&#xA;    &#34;hoistingLimits&#34;: &#34;dependencies&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Credits&lt;/h3&gt; &#xA;&lt;p&gt;All credit for the work on Forms and Sessions goes to the @remix-run team, MIT License, Copyright 2021 Remix Software Inc.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tc39/proposal-pipeline-operator</title>
    <updated>2023-12-24T01:51:31Z</updated>
    <id>tag:github.com,2023-12-24:/tc39/proposal-pipeline-operator</id>
    <link href="https://github.com/tc39/proposal-pipeline-operator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A proposal for adding a useful pipe operator to JavaScript.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pipe Operator (&lt;code&gt;|&amp;gt;&lt;/code&gt;) for JavaScript&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Stage&lt;/strong&gt;: 2&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Champions&lt;/strong&gt;: J. S. Choi, James DiGioia, Ron Buckton, Tab Atkins-Bittner, [list incomplete] &#xA;  &lt;!-- Alpha order by first name, plz --&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Former champions&lt;/strong&gt;: Daniel Ehrenberg&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;http://tc39.github.io/proposal-pipeline-operator/&#34;&gt;Specification&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/CONTRIBUTING.md&#34;&gt;Contributing guidelines&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md&#34;&gt;Proposal history&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Babel plugin&lt;/strong&gt;: &lt;a href=&#34;https://babeljs.io/blog/2021/07/26/7.15.0#hack-style-pipeline-operator-support-13191httpsgithubcombabelbabelpull13191-13416httpsgithubcombabelbabelpull13416&#34;&gt;Implemented in v7.15&lt;/a&gt;. See &lt;a href=&#34;https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator&#34;&gt;Babel documentation&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(This document uses &lt;code&gt;%&lt;/code&gt; as the placeholder token for the topic reference. This will &lt;em&gt;&lt;strong&gt;almost certainly not be the final choice&lt;/strong&gt;&lt;/em&gt;; see &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/issues/91&#34;&gt;the token bikeshedding discussion&lt;/a&gt; for details.)&lt;/p&gt; &#xA;&lt;h2&gt;Why a pipe operator&lt;/h2&gt; &#xA;&lt;p&gt;In the State of JS 2020 survey, the &lt;strong&gt;fourth top answer&lt;/strong&gt; to &lt;a href=&#34;https://2020.stateofjs.com/en-US/opinions/#missing_from_js&#34;&gt;‚ÄúWhat do you feel is currently missing from JavaScript?‚Äù&lt;/a&gt; was a &lt;strong&gt;pipe operator&lt;/strong&gt;. Why?&lt;/p&gt; &#xA;&lt;p&gt;When we perform &lt;strong&gt;consecutive operations&lt;/strong&gt; (e.g., function calls) on a &lt;strong&gt;value&lt;/strong&gt; in JavaScript, there are currently two fundamental styles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;passing the value as an argument to the operation (&lt;strong&gt;nesting&lt;/strong&gt; the operations if there are multiple operations),&lt;/li&gt; &#xA; &lt;li&gt;or calling the function as a method on the value (&lt;strong&gt;chaining&lt;/strong&gt; more method calls if there are multiple methods).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That is, &lt;code&gt;three(two(one(value)))&lt;/code&gt; versus &lt;code&gt;value.one().two().three()&lt;/code&gt;. However, these styles differ much in readability, fluency, and applicability.&lt;/p&gt; &#xA;&lt;h3&gt;Deep nesting is hard to read&lt;/h3&gt; &#xA;&lt;p&gt;The first style, &lt;strong&gt;nesting&lt;/strong&gt;, is generally applicable ‚Äì it works for any sequence of operations: function calls, arithmetic, array/object literals, &lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;However, nesting is &lt;strong&gt;difficult to read&lt;/strong&gt; when it becomes deep: the flow of execution moves &lt;strong&gt;right to left&lt;/strong&gt;, rather than the left-to-right reading of normal code. If there are &lt;strong&gt;multiple arguments&lt;/strong&gt; at some levels, reading even bounces &lt;strong&gt;back and forth&lt;/strong&gt;: our eyes must &lt;strong&gt;jump left&lt;/strong&gt; to find a function name, and then they must &lt;strong&gt;jump right&lt;/strong&gt; to find additional arguments. Additionally, &lt;strong&gt;editing&lt;/strong&gt; the code afterwards can be fraught: we must find the correct &lt;strong&gt;place to insert&lt;/strong&gt; new arguments among &lt;strong&gt;many nested parentheses&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;p&gt;Consider this &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js#L295&#34;&gt;real-world code from React&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#xA;  chalk.dim(&#xA;    `$ ${Object.keys(envars)&#xA;      .map(envar =&amp;gt;&#xA;        `${envar}=${envars[envar]}`)&#xA;      .join(&#39; &#39;)&#xA;    }`,&#xA;    &#39;node&#39;,&#xA;    args.join(&#39; &#39;)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This real-world code is made of &lt;strong&gt;deeply nested expressions&lt;/strong&gt;. In order to read its flow of data, a human‚Äôs eyes must first:&lt;/p&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt; &lt;p&gt;Find the &lt;strong&gt;initial data&lt;/strong&gt; (the innermost expression, &lt;code&gt;envars&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;And then scan &lt;strong&gt;back and forth&lt;/strong&gt; repeatedly from &lt;strong&gt;inside out&lt;/strong&gt; for each data transformation, each one either an easily missed prefix operator on the left or a suffix operators on the right:&lt;/p&gt; &#xA;   &lt;ol&gt; &#xA;    &lt;li&gt;&lt;code&gt;Object.keys()&lt;/code&gt; (left side),&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;.map()&lt;/code&gt; (right side),&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;.join()&lt;/code&gt; (right side),&lt;/li&gt; &#xA;    &lt;li&gt;A template literal (both sides),&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;chalk.dim()&lt;/code&gt; (left side), then&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;console.log()&lt;/code&gt; (left side).&lt;/li&gt; &#xA;   &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;p&gt;As a result of deeply nesting many expressions (some of which use &lt;strong&gt;prefix&lt;/strong&gt; operators, some of which use &lt;strong&gt;postfix&lt;/strong&gt; operators, and some of which use &lt;strong&gt;circumfix&lt;/strong&gt; operators), we must check &lt;strong&gt;both left and right sides&lt;/strong&gt; to find the &lt;strong&gt;head&lt;/strong&gt; of &lt;strong&gt;each expression&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Method chaining is limited&lt;/h3&gt; &#xA;&lt;p&gt;The second style, &lt;strong&gt;method chaining&lt;/strong&gt;, is &lt;strong&gt;only&lt;/strong&gt; usable if the value has the functions designated as &lt;strong&gt;methods&lt;/strong&gt; for its class. This &lt;strong&gt;limits&lt;/strong&gt; its applicability. But &lt;strong&gt;when&lt;/strong&gt; it applies, thanks to its postfix structure, it is generally more usable and &lt;strong&gt;easier&lt;/strong&gt; to read and write. Code execution flows &lt;strong&gt;left to right&lt;/strong&gt;. Deeply nested expressions are &lt;strong&gt;untangled&lt;/strong&gt;. All arguments for a function call are &lt;strong&gt;grouped&lt;/strong&gt; with the function‚Äôs name. And editing the code later to &lt;strong&gt;insert or delete&lt;/strong&gt; more method calls is trivial, since we would just have to put our cursor in one spot, then start typing or deleting one &lt;strong&gt;contiguous&lt;/strong&gt; run of characters.&lt;/p&gt; &#xA;&lt;p&gt;Indeed, the benefits of method chaining are &lt;strong&gt;so attractive&lt;/strong&gt; that some &lt;strong&gt;popular libraries contort&lt;/strong&gt; their code structure specifically to allow &lt;strong&gt;more method chaining&lt;/strong&gt;. The most prominent example is &lt;strong&gt;&lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;&lt;/strong&gt;, which still remains the &lt;strong&gt;most popular JS library&lt;/strong&gt; in the world. jQuery‚Äôs core design is a single √ºber-object with dozens of methods on it, all of which return the same object type so that we can &lt;strong&gt;continue chaining&lt;/strong&gt;. There is even a name for this style of programming: &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fluent_interface&#34;&gt;fluent interfaces&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, for all of its fluency, &lt;strong&gt;method chaining&lt;/strong&gt; alone cannot accommodate JavaScript‚Äôs &lt;strong&gt;other syntaxes&lt;/strong&gt;: function calls, arithmetic, array/object literals, &lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt;, etc. In this way, method chaining remains &lt;strong&gt;limited&lt;/strong&gt; in its &lt;strong&gt;applicability&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Pipe operators combine both worlds&lt;/h3&gt; &#xA;&lt;p&gt;The pipe operator attempts to marry the &lt;strong&gt;convenience&lt;/strong&gt; and ease of &lt;strong&gt;method chaining&lt;/strong&gt; with the wide &lt;strong&gt;applicability&lt;/strong&gt; of &lt;strong&gt;expression nesting&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The general structure of all the pipe operators is &lt;code&gt;value |&amp;gt;&lt;/code&gt; &lt;var&gt;e1&lt;/var&gt; &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;var&gt;e2&lt;/var&gt; &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;var&gt;e3&lt;/var&gt;, where &lt;var&gt;e1&lt;/var&gt;, &lt;var&gt;e2&lt;/var&gt;, &lt;var&gt;e3&lt;/var&gt; are all expressions that take consecutive values as their parameters. The &lt;code&gt;|&amp;gt;&lt;/code&gt; operator then does some degree of magic to ‚Äúpipe‚Äù &lt;code&gt;value&lt;/code&gt; from the lefthand side into the righthand side.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;Continuing this deeply nested &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world code from React&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#xA;  chalk.dim(&#xA;    `$ ${Object.keys(envars)&#xA;      .map(envar =&amp;gt;&#xA;        `${envar}=${envars[envar]}`)&#xA;      .join(&#39; &#39;)&#xA;    }`,&#xA;    &#39;node&#39;,&#xA;    args.join(&#39; &#39;)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;‚Ä¶we can &lt;strong&gt;untangle&lt;/strong&gt; it as such using a pipe operator and a placeholder token (&lt;code&gt;%&lt;/code&gt;) standing in for the previous operation‚Äôs value:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Now, the human reader can &lt;strong&gt;rapidly find&lt;/strong&gt; the &lt;strong&gt;initial data&lt;/strong&gt; (what had been the most innermost expression, &lt;code&gt;envars&lt;/code&gt;), then &lt;strong&gt;linearly&lt;/strong&gt; read, from &lt;strong&gt;left to right&lt;/strong&gt;, each transformation on the data.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Temporary variables are often tedious&lt;/h3&gt; &#xA;&lt;p&gt;One could argue that using &lt;strong&gt;temporary variables&lt;/strong&gt; should be the only way to untangle deeply nested code. Explicitly naming every step‚Äôs variable causes something similar to method chaining to happen, with similar benefits to reading and writing code.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;For example, using our previous modified &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world example from React&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;‚Ä¶a version using temporary variables would look like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const envarString = Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;);&#xA;const consoleText = `$ ${envarString}`;&#xA;const coloredConsoleText = chalk.dim(consoleText, &#39;node&#39;, args.join(&#39; &#39;));&#xA;console.log(coloredConsoleText);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;But there are reasons why we encounter deeply nested expressions in each other‚Äôs code &lt;strong&gt;all the time in the real world&lt;/strong&gt;, &lt;strong&gt;rather than&lt;/strong&gt; lines of temporary variables. And there are reasons why the &lt;strong&gt;method-chain-based &lt;a href=&#34;https://en.wikipedia.org/wiki/Fluent_interface&#34;&gt;fluent interfaces&lt;/a&gt;&lt;/strong&gt; of jQuery, Mocha, and so on are still &lt;strong&gt;popular&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is often simply too &lt;strong&gt;tedious and wordy&lt;/strong&gt; to &lt;strong&gt;write&lt;/strong&gt; code with a long sequence of temporary, single-use variables. It is arguably even tedious and visually noisy for a human to &lt;strong&gt;read&lt;/strong&gt;, too.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;a href=&#34;https://martinfowler.com/bliki/TwoHardThings.html&#34;&gt;&lt;strong&gt;naming&lt;/strong&gt; is one of the &lt;strong&gt;most difficult tasks&lt;/strong&gt; in programming&lt;/a&gt;, then programmers will &lt;strong&gt;inevitably avoid naming&lt;/strong&gt; variables when they perceive their benefit to be relatively small.&lt;/p&gt; &#xA;&lt;h3&gt;Reusing temporary variables is prone to unexpected mutation&lt;/h3&gt; &#xA;&lt;p&gt;One could argue that using a single &lt;strong&gt;mutable variable&lt;/strong&gt; with a short name would reduce the wordiness of temporary variables, achieving similar results as with the pipe operator.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;For example, our previous modified &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world example from React&lt;/a&gt; could be re-written like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let _;&#xA;_ = Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;);&#xA;_ = `$ ${_}`;&#xA;_ = chalk.dim(_, &#39;node&#39;, args.join(&#39; &#39;));&#xA;_ = console.log(_);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;But code like this is &lt;strong&gt;not common&lt;/strong&gt; in real-world code. One reason for this is that mutable variables can &lt;strong&gt;change unexpectedly&lt;/strong&gt;, causing silent bugs that are hard to find. For example, the variable might be accidentally referenced in a closure. Or it might be mistakenly reassigned within an expression.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example code&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// setup&#xA;function one () { return 1; }&#xA;function double (x) { return x * 2; }&#xA;&#xA;let _;&#xA;_ = one(); // _ is now 1.&#xA;_ = double(_); // _ is now 2.&#xA;_ = Promise.resolve().then(() =&amp;gt;&#xA;  // This does *not* print 2!&#xA;  // It prints 1, because `_` is reassigned downstream.&#xA;  console.log(_));&#xA;&#xA;// _ becomes 1 before the promise callback.&#xA;_ = one(_);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This issue would not happen with the pipe operator. The topic token cannot be reassigned, and code outside of each step cannot change its binding.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let _;&#xA;_ = one()&#xA;  |&amp;gt; double(%)&#xA;  |&amp;gt; Promise.resolve().then(() =&amp;gt;&#xA;    // This prints 2, as intended.&#xA;    console.log(%));&#xA;&#xA;_ = one();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;For this reason, code with mutable variables is also harder to read. To determine what the variable represents at any given point, you must to &lt;strong&gt;search the entire preceding scope&lt;/strong&gt; for places where it is &lt;strong&gt;reassigned&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The topic reference of a pipeline, on the other hand, has a limited lexical scope, and its binding is immutable within its scope. It cannot be accidentally reassigned, and it can be safely used in closures.&lt;/p&gt; &#xA;&lt;p&gt;Although the topic value also changes with each pipeline step, we only scan the previous step of the pipeline to make sense of it, leading to code that is easier to read.&lt;/p&gt; &#xA;&lt;h3&gt;Temporary variables must be declared in statements&lt;/h3&gt; &#xA;&lt;p&gt;Another benefit of the pipe operator over sequences of assignment statements (whether with mutable or with immutable temporary variables) is that they are &lt;strong&gt;expressions&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Pipe expressions are expressions that can be directly returned, assigned to a variable, or used in contexts such as JSX expressions.&lt;/p&gt; &#xA;&lt;p&gt;Using temporary variables, on the other hand, requires sequences of statements.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Examples&lt;/summary&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt;&#xA;    &lt;th&gt;Pipelines&lt;/th&gt; &#xA;    &lt;th&gt;Temporary Variables&lt;/th&gt; &#xA;   &lt;/tr&gt;&#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const envVarFormat = vars =&amp;gt;&#xA;  Object.keys(vars)&#xA;    .map(var =&amp;gt; `${var}=${vars[var]}`)&#xA;    .join(&#39; &#39;)&#xA;    |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;));&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const envVarFormat = (vars) =&amp;gt; {&#xA;  let _ = Object.keys(vars);&#xA;  _ = _.map(var =&amp;gt; `${var}=${vars[var]}`);&#xA;  _ = _.join(&#39; &#39;);&#xA;  return chalk.dim(_, &#39;node&#39;, args.join(&#39; &#39;));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// This example uses JSX.&#xA;return (&#xA;  &amp;lt;ul&amp;gt;&#xA;    {&#xA;      values&#xA;        |&amp;gt; Object.keys(%)&#xA;        |&amp;gt; [...Array.from(new Set(%))]&#xA;        |&amp;gt; %.map(envar =&amp;gt; (&#xA;          &amp;lt;li onClick={&#xA;            () =&amp;gt; doStuff(values)&#xA;          }&amp;gt;{envar}&amp;lt;/li&amp;gt;&#xA;        ))&#xA;    }&#xA;  &amp;lt;/ul&amp;gt;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;    &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// This example uses JSX.&#xA;let _ = values;&#xA;_= Object.keys(_);&#xA;_= [...Array.from(new Set(_))];&#xA;_= _.map(envar =&amp;gt; (&#xA;  &amp;lt;li onClick={&#xA;    () =&amp;gt; doStuff(values)&#xA;  }&amp;gt;{envar}&amp;lt;/li&amp;gt;&#xA;));&#xA;return (&#xA;  &amp;lt;ul&amp;gt;{_}&amp;lt;/ul&amp;gt;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Why the Hack pipe operator&lt;/h2&gt; &#xA;&lt;p&gt;There were &lt;strong&gt;two competing proposals&lt;/strong&gt; for the pipe operator: Hack pipes and F# pipes. (Before that, there &lt;strong&gt;was&lt;/strong&gt; a &lt;a href=&#34;https://github.com/js-choi/proposal-smart-pipelines/&#34;&gt;third proposal for a ‚Äúsmart mix‚Äù of the first two proposals&lt;/a&gt;, but it has been withdrawn, since its syntax is strictly a superset of one of the proposals‚Äô.)&lt;/p&gt; &#xA;&lt;p&gt;The two pipe proposals just differ &lt;strong&gt;slightly&lt;/strong&gt; on what the ‚Äúmagic‚Äù is, when we spell our code when using &lt;code&gt;|&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Both&lt;/strong&gt; proposals &lt;strong&gt;reuse&lt;/strong&gt; existing language concepts: Hack pipes are based on the concept of the &lt;strong&gt;expression&lt;/strong&gt;, while F# pipes are based on the concept of the &lt;strong&gt;unary function&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Piping &lt;strong&gt;expressions&lt;/strong&gt; and piping &lt;strong&gt;unary functions&lt;/strong&gt; correspondingly have &lt;strong&gt;small&lt;/strong&gt; and nearly &lt;strong&gt;symmetrical trade-offs&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;This proposal: Hack pipes&lt;/h3&gt; &#xA;&lt;p&gt;In the &lt;strong&gt;Hack language&lt;/strong&gt;‚Äôs pipe syntax, the righthand side of the pipe is an &lt;strong&gt;expression&lt;/strong&gt; containing a special &lt;strong&gt;placeholder&lt;/strong&gt;, which is evaluated with the placeholder bound to the result of evaluating the lefthand side&#39;s expression. That is, we write &lt;code&gt;value |&amp;gt; one(%) |&amp;gt; two(%) |&amp;gt; three(%)&lt;/code&gt; to pipe &lt;code&gt;value&lt;/code&gt; through the three functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pro:&lt;/strong&gt; The righthand side can be &lt;strong&gt;any expression&lt;/strong&gt;, and the placeholder can go anywhere any normal variable identifier could go, so we can pipe to any code we want &lt;strong&gt;without any special rules&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; foo(%)&lt;/code&gt; for unary function calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; foo(1, %)&lt;/code&gt; for n-ary function calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; %.foo()&lt;/code&gt; for method calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; % + 1&lt;/code&gt; for arithmetic,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; [%, 0]&lt;/code&gt; for array literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; {foo: %}&lt;/code&gt; for object literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; `${%}`&lt;/code&gt; for template literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; new Foo(%)&lt;/code&gt; for constructing objects,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; await %&lt;/code&gt; for awaiting promises,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; (yield %)&lt;/code&gt; for yielding generator values,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; import(%)&lt;/code&gt; for calling function-like keywords,&lt;/li&gt; &#xA; &lt;li&gt;etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Con:&lt;/strong&gt; Piping through &lt;strong&gt;unary functions&lt;/strong&gt; is &lt;strong&gt;slightly more verbose&lt;/strong&gt; with Hack pipes than with F# pipes. This includes unary functions that were created by &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Currying&#34;&gt;function-currying&lt;/a&gt; libraries&lt;/strong&gt; like &lt;a href=&#34;https://ramdajs.com/&#34;&gt;Ramda&lt;/a&gt;, as well as &lt;a href=&#34;https://github.com/js-choi/proposal-hack-pipes/issues/4#issuecomment-817208635&#34;&gt;unary arrow functions that perform &lt;strong&gt;complex destructuring&lt;/strong&gt; on their arguments&lt;/a&gt;: Hack pipes would be slightly more verbose with an &lt;strong&gt;explicit&lt;/strong&gt; function call suffix &lt;code&gt;(%)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;(Complex destructuring of the topic value will be easier when &lt;a href=&#34;https://github.com/tc39/proposal-do-expressions/&#34;&gt;do expressions&lt;/a&gt; progress, as you will then be able to do variable assignment/destructuring inside of a pipe body.)&lt;/p&gt; &#xA;&lt;h3&gt;Alternative proposal: F# pipes&lt;/h3&gt; &#xA;&lt;p&gt;In the &lt;a href=&#34;https://github.com/valtech-nyc/proposal-fsharp-pipelines&#34;&gt;&lt;strong&gt;F# language&lt;/strong&gt;‚Äôs pipe syntax&lt;/a&gt;, the righthand side of the pipe is an expression that must &lt;strong&gt;evaluate into a unary function&lt;/strong&gt;, which is then &lt;strong&gt;tacitly called&lt;/strong&gt; with the lefthand side‚Äôs value as its &lt;strong&gt;sole argument&lt;/strong&gt;. That is, we write &lt;code&gt;value |&amp;gt; one |&amp;gt; two |&amp;gt; three&lt;/code&gt; to pipe &lt;code&gt;value&lt;/code&gt; through the three functions. &lt;code&gt;left |&amp;gt; right&lt;/code&gt; becomes &lt;code&gt;right(left)&lt;/code&gt;. This is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Tacit_programming&#34;&gt;tacit programming or point-free style&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Real-world example&lt;/strong&gt;, continued&lt;/summary&gt; &#xA; &lt;p&gt;For example, using our previous modified &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;real-world example from React&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;‚Ä¶a version using F# pipes instead of Hack pipes would look like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; x=&amp;gt; `$ ${x}`&#xA;  |&amp;gt; x=&amp;gt; chalk.dim(x, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pro:&lt;/strong&gt; The restriction that the righthand side &lt;strong&gt;must&lt;/strong&gt; resolve to a unary function lets us write very terse pipes &lt;strong&gt;when&lt;/strong&gt; the operation we want to perform is a &lt;strong&gt;unary function call&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; foo&lt;/code&gt; for unary function calls.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This includes unary functions that were created by &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Currying&#34;&gt;function-currying&lt;/a&gt; libraries&lt;/strong&gt; like &lt;a href=&#34;https://ramdajs.com/&#34;&gt;Ramda&lt;/a&gt;, as well as &lt;a href=&#34;https://github.com/js-choi/proposal-hack-pipes/issues/4#issuecomment-817208635&#34;&gt;unary arrow functions that perform &lt;strong&gt;complex destructuring&lt;/strong&gt; on their arguments&lt;/a&gt;: F# pipes would be &lt;strong&gt;slightly less verbose&lt;/strong&gt; with an &lt;strong&gt;implicit&lt;/strong&gt; function call (no &lt;code&gt;(%)&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Con:&lt;/strong&gt; The restriction means that &lt;strong&gt;any operations&lt;/strong&gt; that are performed by &lt;strong&gt;other syntax&lt;/strong&gt; must be made &lt;strong&gt;slightly more verbose&lt;/strong&gt; by &lt;strong&gt;wrapping&lt;/strong&gt; the operation in a unary &lt;strong&gt;arrow function&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; x.foo()&lt;/code&gt; for method calls,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; x + 1&lt;/code&gt; for arithmetic,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; [x, 0]&lt;/code&gt; for array literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; ({foo: x})&lt;/code&gt; for object literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; `${x}`&lt;/code&gt; for template literals,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; new Foo(x)&lt;/code&gt; for constructing objects,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; import(x)&lt;/code&gt; for calling function-like keywords,&lt;/li&gt; &#xA; &lt;li&gt;etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Even calling &lt;strong&gt;named functions&lt;/strong&gt; requires &lt;strong&gt;wrapping&lt;/strong&gt; when we need to pass &lt;strong&gt;more than one argument&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; x=&amp;gt; foo(1, x)&lt;/code&gt; for n-ary function calls.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Con:&lt;/strong&gt; The &lt;strong&gt;&lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt; operations are &lt;strong&gt;scoped&lt;/strong&gt; to their &lt;strong&gt;containing function&lt;/strong&gt;, and thus &lt;strong&gt;cannot be handled by unary functions&lt;/strong&gt; alone. If we want to integrate them into a pipe expression, &lt;a href=&#34;https://github.com/valtech-nyc/proposal-fsharp-pipelines/&#34;&gt;&lt;code&gt;await&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; must be handled as &lt;strong&gt;special syntax cases&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; await&lt;/code&gt; for awaiting promises, and&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value |&amp;gt; yield&lt;/code&gt; for yielding generator values.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Hack pipes favor more common expressions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Both&lt;/strong&gt; Hack pipes and F# pipes respectively impose a small &lt;strong&gt;syntax tax&lt;/strong&gt; on different expressions:&lt;br&gt; &lt;strong&gt;Hack pipes&lt;/strong&gt; slightly tax only &lt;strong&gt;unary function calls&lt;/strong&gt;, and&lt;br&gt; &lt;strong&gt;F# pipes&lt;/strong&gt; slightly tax &lt;strong&gt;all expressions except&lt;/strong&gt; unary function calls.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;strong&gt;both&lt;/strong&gt; proposals, the syntax tax per taxed expression is &lt;strong&gt;small&lt;/strong&gt; (&lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;(%)&lt;/code&gt; and &lt;code&gt;x=&amp;gt;&lt;/code&gt; are &lt;strong&gt;only three characters&lt;/strong&gt;). However, the tax is &lt;strong&gt;multiplied&lt;/strong&gt; by the &lt;strong&gt;prevalence&lt;/strong&gt; of its respectively taxed expressions. It therefore might make sense to impose a tax on whichever expressions are &lt;strong&gt;less common&lt;/strong&gt; and to &lt;strong&gt;optimize&lt;/strong&gt; in favor of whichever expressions are &lt;strong&gt;more common&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unary function calls are in general &lt;strong&gt;less common&lt;/strong&gt; than &lt;strong&gt;all&lt;/strong&gt; expressions &lt;strong&gt;except&lt;/strong&gt; unary functions. In particular, &lt;strong&gt;method&lt;/strong&gt; calling and &lt;strong&gt;n-ary function&lt;/strong&gt; calling will &lt;strong&gt;always&lt;/strong&gt; be &lt;strong&gt;popular&lt;/strong&gt;; in general frequency, &lt;strong&gt;unary&lt;/strong&gt; function calling is equal to or exceeded by those two cases &lt;strong&gt;alone&lt;/strong&gt; ‚Äì let alone by other ubiquitous syntaxes such as &lt;strong&gt;array literals&lt;/strong&gt;, &lt;strong&gt;object literals&lt;/strong&gt;, and &lt;strong&gt;arithmetic operations&lt;/strong&gt;. This explainer contains several &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#real-world-examples&#34;&gt;real-world examples&lt;/a&gt; of this difference in prevalence.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, several other proposed &lt;strong&gt;new syntaxes&lt;/strong&gt;, such as &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-extensions/&#34;&gt;extension calling&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-do-expressions/&#34;&gt;do expressions&lt;/a&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-record-tuple/&#34;&gt;record/tuple literals&lt;/a&gt;&lt;/strong&gt;, will also likely become &lt;strong&gt;pervasive&lt;/strong&gt; in the &lt;strong&gt;future&lt;/strong&gt;. Likewise, &lt;strong&gt;arithmetic&lt;/strong&gt; operations would also become &lt;strong&gt;even more common&lt;/strong&gt; if TC39 standardizes &lt;strong&gt;&lt;a href=&#34;https://github.com/tc39/proposal-operator-overloading/&#34;&gt;operator overloading&lt;/a&gt;&lt;/strong&gt;. Untangling these future syntaxes‚Äô expressions would be more fluent with Hack pipes compared to F# pipes.&lt;/p&gt; &#xA;&lt;h3&gt;Hack pipes might be simpler to use&lt;/h3&gt; &#xA;&lt;p&gt;The syntax tax of Hack pipes on unary function calls (i.e., the &lt;code&gt;(%)&lt;/code&gt; to invoke the righthand side‚Äôs unary function) is &lt;strong&gt;not a special case&lt;/strong&gt;: it simply is &lt;strong&gt;explicitly writing ordinary code&lt;/strong&gt;, in &lt;strong&gt;the way we normally would&lt;/strong&gt; without a pipe.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, &lt;strong&gt;F# pipes require&lt;/strong&gt; us to &lt;strong&gt;distinguish&lt;/strong&gt; between ‚Äúcode that resolves to an unary function‚Äù versus &lt;strong&gt;‚Äúany other expression‚Äù&lt;/strong&gt; ‚Äì and to remember to add the arrow-function wrapper around the latter case.&lt;/p&gt; &#xA;&lt;p&gt;For example, with Hack pipes, &lt;code&gt;value |&amp;gt; someFunction + 1&lt;/code&gt; is &lt;strong&gt;invalid syntax&lt;/strong&gt; and will &lt;strong&gt;fail early&lt;/strong&gt;. There is no need to recognize that &lt;code&gt;someFunction + 1&lt;/code&gt; will not evaluate into a unary function. But with F# pipes, &lt;code&gt;value |&amp;gt; someFunction + 1&lt;/code&gt; is &lt;strong&gt;still valid syntax&lt;/strong&gt; ‚Äì it‚Äôll just &lt;strong&gt;fail late&lt;/strong&gt; at &lt;strong&gt;runtime&lt;/strong&gt;, because &lt;code&gt;someFunction + 1&lt;/code&gt; isn‚Äôt callable.&lt;/p&gt; &#xA;&lt;h3&gt;TC39 has rejected F# pipes multiple times&lt;/h3&gt; &#xA;&lt;p&gt;The pipe champion group has presented F# pipes for Stage&amp;nbsp;2 to TC39 &lt;strong&gt;twice&lt;/strong&gt;. It was &lt;strong&gt;unsuccessful&lt;/strong&gt; in advancing to Stage&amp;nbsp;2 both times. Both F# pipes (and &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;partial function application (PFA)&lt;/a&gt;) have run into strong pushback from multiple other TC39 representatives due to various concerns. These have included:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Memory performance concerns (e.g., &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md#2021-07&#34;&gt;especially from browser-engine implementors&lt;/a&gt;),&lt;/li&gt; &#xA; &lt;li&gt;Syntax concerns about &lt;code&gt;await&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Concerns about encouraging ecosystem bifurcation/forking, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This pushback has occurred from &lt;strong&gt;outside&lt;/strong&gt; the pipe champion group. See &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md&#34;&gt;HISTORY.md&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;It is the pipe champion group‚Äôs belief that any pipe operator is better than none, in order to &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#why-a-pipe-operator&#34;&gt;easily linearize deeply nested expressions&lt;/a&gt; without resorting to named variables. Many members of the champion group believe that Hack pipes are slightly better than F# pipes, and some members of the champion group believe that F# pipes are slightly better than Hack pipes. But everyone in the champion group agrees that F# pipes have met with far too much resistance to be able to pass TC39 in the foreseeable future.&lt;/p&gt; &#xA;&lt;p&gt;To emphasize, it is likely that an attempt to switch from Hack pipes back to F# pipes will result in TC39 never agreeing to any pipes at all. &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;PFA syntax&lt;/a&gt; is similarly facing an uphill battle in TC39 (see &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md&#34;&gt;HISTORY.md&lt;/a&gt;). Many members of the pipe champion group think this is unfortunate, and they are willing to fight again &lt;strong&gt;later&lt;/strong&gt; for an &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tacit-unary-function-application-syntax&#34;&gt;F#-pipe split mix&lt;/a&gt; and &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;PFA syntax&lt;/a&gt;. But there are quite a few representatives (including &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/raw/main/HISTORY.md#2021-07&#34;&gt;browser-engine implementers&lt;/a&gt;) outside of the Pipe Champion Group who are generally against encouraging &lt;a href=&#34;https://en.wikipedia.org/wiki/Tacit_programming&#34;&gt;tacit programming&lt;/a&gt; (and &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;PFA syntax&lt;/a&gt;), regardless of Hack pipes.&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;(A &lt;a href=&#34;http://tc39.github.io/proposal-pipeline-operator/&#34;&gt;formal draft specification&lt;/a&gt; is available.)&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;topic reference&lt;/strong&gt; &lt;code&gt;%&lt;/code&gt; is a &lt;strong&gt;nullary operator&lt;/strong&gt;. It acts as a placeholder for a &lt;strong&gt;topic value&lt;/strong&gt;, and it is &lt;strong&gt;lexically scoped&lt;/strong&gt; and &lt;strong&gt;immutable&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;code&gt;%&lt;/code&gt; is not a final choice&lt;/summary&gt; &#xA; &lt;p&gt;(The precise &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/issues/91&#34;&gt;&lt;strong&gt;token&lt;/strong&gt; for the topic reference is &lt;strong&gt;not final&lt;/strong&gt;&lt;/a&gt;. &lt;code&gt;%&lt;/code&gt; could instead be &lt;code&gt;^&lt;/code&gt;, or many other tokens. We plan to &lt;a href=&#34;https://github.com/tc39/proposal-pipeline-operator/issues/91&#34;&gt;&lt;strong&gt;bikeshed&lt;/strong&gt; what actual token to use&lt;/a&gt; before advancing to Stage 3. However, &lt;code&gt;%&lt;/code&gt; seems to be the &lt;a href=&#34;https://github.com/js-choi/proposal-hack-pipes/issues/2&#34;&gt;least syntactically problematic&lt;/a&gt;, and it also resembles the placeholders of &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Printf_format_string&#34;&gt;printf format strings&lt;/a&gt;&lt;/strong&gt; and &lt;a href=&#34;https://clojure.org/reference/reader#_dispatch&#34;&gt;&lt;strong&gt;Clojure&lt;/strong&gt;‚Äôs &lt;code&gt;#(%)&lt;/code&gt; &lt;strong&gt;function literals&lt;/strong&gt;&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;The &lt;strong&gt;pipe operator&lt;/strong&gt; &lt;code&gt;|&amp;gt;&lt;/code&gt; is an &lt;strong&gt;infix operator&lt;/strong&gt; that forms a &lt;strong&gt;pipe expression&lt;/strong&gt; (also called a &lt;strong&gt;pipeline&lt;/strong&gt;). It evaluates its lefthand side (the &lt;strong&gt;pipe head&lt;/strong&gt; or &lt;strong&gt;pipe input&lt;/strong&gt;), immutably &lt;strong&gt;binds&lt;/strong&gt; the resulting value (the &lt;strong&gt;topic value&lt;/strong&gt;) to the &lt;strong&gt;topic reference&lt;/strong&gt;, then evaluates its righthand side (the &lt;strong&gt;pipe body&lt;/strong&gt;) with that binding. The resulting value of the righthand side becomes the whole pipe expression‚Äôs final value (the &lt;strong&gt;pipe output&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The pipe operator‚Äôs precedence is the &lt;strong&gt;same&lt;/strong&gt; as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the function arrow &lt;code&gt;=&amp;gt;&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;the assignment operators &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, etc.;&lt;/li&gt; &#xA; &lt;li&gt;the generator operators &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yield *&lt;/code&gt;;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is &lt;strong&gt;tighter&lt;/strong&gt; than only the comma operator &lt;code&gt;,&lt;/code&gt;.&lt;br&gt; It is &lt;strong&gt;looser&lt;/strong&gt; than &lt;strong&gt;all other&lt;/strong&gt; operators.&lt;/p&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;v =&amp;gt; v |&amp;gt; % == null |&amp;gt; foo(%, 0)&lt;/code&gt;&lt;br&gt; would group into &lt;code&gt;v =&amp;gt; (v |&amp;gt; (% == null) |&amp;gt; foo(%, 0))&lt;/code&gt;,&lt;br&gt; which in turn is equivalent to &lt;code&gt;v =&amp;gt; foo(v == null, 0)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A pipe body &lt;strong&gt;must&lt;/strong&gt; use its topic value &lt;strong&gt;at least once&lt;/strong&gt;. For example, &lt;code&gt;value |&amp;gt; foo + 1&lt;/code&gt; is &lt;strong&gt;invalid syntax&lt;/strong&gt;, because its body does not contain a topic reference. This design is because &lt;strong&gt;omission&lt;/strong&gt; of the topic reference from a pipe expression‚Äôs body is almost certainly an &lt;strong&gt;accidental&lt;/strong&gt; programmer error.&lt;/p&gt; &#xA;&lt;p&gt;Likewise, a topic reference &lt;strong&gt;must&lt;/strong&gt; be contained in a pipe body. Using a topic reference outside of a pipe body is also &lt;strong&gt;invalid syntax&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To prevent confusing grouping, it is &lt;strong&gt;invalid&lt;/strong&gt; syntax to use &lt;strong&gt;other&lt;/strong&gt; operators that have &lt;strong&gt;similar precedence&lt;/strong&gt; (i.e., the arrow &lt;code&gt;=&amp;gt;&lt;/code&gt;, the ternary conditional operator &lt;code&gt;?&lt;/code&gt; &lt;code&gt;:&lt;/code&gt;, the assignment operators, and the &lt;code&gt;yield&lt;/code&gt; operator) as a &lt;strong&gt;pipe head or body&lt;/strong&gt;. When using &lt;code&gt;|&amp;gt;&lt;/code&gt; with these operators, we must use &lt;strong&gt;parentheses&lt;/strong&gt; to explicitly indicate what grouping is correct. For example, &lt;code&gt;a |&amp;gt; b ? % : c |&amp;gt; %.d&lt;/code&gt; is invalid syntax; it should be corrected to either &lt;code&gt;a |&amp;gt; (b ? % : c) |&amp;gt; %.d&lt;/code&gt; or &lt;code&gt;a |&amp;gt; (b ? % : c |&amp;gt; %.d)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Lastly, topic bindings &lt;strong&gt;inside dynamically compiled&lt;/strong&gt; code (e.g., with &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;new Function&lt;/code&gt;) &lt;strong&gt;cannot&lt;/strong&gt; be used &lt;strong&gt;outside&lt;/strong&gt; of that code. For example, &lt;code&gt;v |&amp;gt; eval(&#39;% + 1&#39;)&lt;/code&gt; will throw a syntax error when the &lt;code&gt;eval&lt;/code&gt; expression is evaluated at runtime.&lt;/p&gt; &#xA;&lt;p&gt;There are &lt;strong&gt;no other special rules&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A natural result of these rules is that, if we need to interpose a &lt;strong&gt;side effect&lt;/strong&gt; in the middle of a chain of pipe expressions, without modifying the data being piped through, then we could use a &lt;strong&gt;comma expression&lt;/strong&gt;, such as with &lt;code&gt;value |&amp;gt; (sideEffect(), %)&lt;/code&gt;. As usual, the comma expression will evaluate to its righthand side &lt;code&gt;%&lt;/code&gt;, essentially passing through the topic value without modifying it. This is especially useful for quick debugging: &lt;code&gt;value |&amp;gt; (console.log(%), %)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Real-world examples&lt;/h2&gt; &#xA;&lt;p&gt;The only changes to the original examples were dedentation and removal of comments.&lt;/p&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/jquery/jquery/raw/2.2-stable/build/tasks/sourcemap.js&#34;&gt;jquery/build/tasks/sourceMap.js&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;var minLoc = Object.keys( grunt.config( &#34;uglify.all.files&#34; ) )[ 0 ];&#xA;&#xA;// With pipes&#xA;var minLoc = grunt.config(&#39;uglify.all.files&#39;) |&amp;gt; Object.keys(%)[0];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/nodejs/node/raw/v16.x/deps/npm/lib/unpublish.js&#34;&gt;node/deps/npm/lib/unpublish.js&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;const json = await npmFetch.json(npa(pkgs[0]).escapedName, opts);&#xA;&#xA;// With pipes&#xA;const json = pkgs[0] |&amp;gt; npa(%).escapedName |&amp;gt; await npmFetch.json(%, opts);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://underscorejs.org/docs/underscore-esm.html&#34;&gt;underscore.js&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return filter(obj, negate(cb(predicate)), context);&#xA;&#xA;// With pipes&#xA;return cb(predicate) |&amp;gt; _.negate(%) |&amp;gt; _.filter(obj, %, context);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/ramda/ramda/raw/v0.27.1/dist/ramda.js&#34;&gt;ramda.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return xf[&#39;@@transducer/result&#39;](obj[methodName](bind(xf[&#39;@@transducer/step&#39;], xf), acc));&#xA;&#xA;// With pipes&#xA;return xf&#xA;  |&amp;gt; bind(%[&#39;@@transducer/step&#39;], %)&#xA;  |&amp;gt; obj[methodName](%, acc)&#xA;  |&amp;gt; xf[&#39;@@transducer/result&#39;](%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/ramda/ramda/raw/v0.27.1/dist/ramda.js&#34;&gt;ramda.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;try {&#xA;  return tryer.apply(this, arguments);&#xA;} catch (e) {&#xA;  return catcher.apply(this, _concat([e], arguments));&#xA;}&#xA;&#xA;// With pipes: Note the visual parallelism between the two clauses.&#xA;try {&#xA;  return arguments&#xA;    |&amp;gt; tryer.apply(this, %);&#xA;} catch (e) {&#xA;  return arguments&#xA;    |&amp;gt; _concat([e], %)&#xA;    |&amp;gt; catcher.apply(this, %);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/expressjs/express/raw/5.0/lib/response.js&#34;&gt;express/lib/response.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return this.set(&#39;Link&#39;, link + Object.keys(links).map(function(rel){&#xA;  return &#39;&amp;lt;&#39; + links[rel] + &#39;&amp;gt;; rel=&#34;&#39; + rel + &#39;&#34;&#39;;&#xA;}).join(&#39;, &#39;));&#xA;&#xA;// With pipes&#xA;return links&#xA;  |&amp;gt; Object.keys(%).map(function (rel) {&#xA;    return &#39;&amp;lt;&#39; + links[rel] + &#39;&amp;gt;; rel=&#34;&#39; + rel + &#39;&#34;&#39;;&#xA;  })&#xA;  |&amp;gt; link + %.join(&#39;, &#39;)&#xA;  |&amp;gt; this.set(&#39;Link&#39;, %);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/facebook/react/raw/17.0.2/scripts/jest/jest-cli.js&#34;&gt;react/scripts/jest/jest-cli.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;console.log(&#xA;  chalk.dim(&#xA;    `$ ${Object.keys(envars)&#xA;      .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;      .join(&#39; &#39;)}`,&#xA;    &#39;node&#39;,&#xA;    args.join(&#39; &#39;)&#xA;  )&#xA;);&#xA;&#xA;// With pipes&#xA;Object.keys(envars)&#xA;  .map(envar =&amp;gt; `${envar}=${envars[envar]}`)&#xA;  .join(&#39; &#39;)&#xA;  |&amp;gt; `$ ${%}`&#xA;  |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))&#xA;  |&amp;gt; console.log(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/ramda/ramda/raw/v0.27.1/dist/ramda.js&#34;&gt;ramda.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;return _reduce(xf(typeof fn === &#39;function&#39; ? _xwrap(fn) : fn), acc, list);&#xA;&#xA;// With pipes&#xA;return fn&#xA;  |&amp;gt; (typeof % === &#39;function&#39; ? _xwrap(%) : %)&#xA;  |&amp;gt; xf(%)&#xA;  |&amp;gt; _reduce(%, acc, list);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://github.com/jquery/jquery/raw/2.2-stable/src/core/init.js&#34;&gt;jquery/src/core/init.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Status quo&#xA;jQuery.merge( this, jQuery.parseHTML(&#xA;  match[ 1 ],&#xA;  context &amp;amp;&amp;amp; context.nodeType ? context.ownerDocument || context : document,&#xA;  true&#xA;) );&#xA;&#xA;// With pipes&#xA;context&#xA;  |&amp;gt; (% &amp;amp;&amp;amp; %.nodeType ? %.ownerDocument || % : document)&#xA;  |&amp;gt; jQuery.parseHTML(match[1], %, true)&#xA;  |&amp;gt; jQuery.merge(%);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Relationships with other proposals&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;Function&lt;/code&gt; helpers&lt;/h3&gt; &#xA;&lt;p&gt;Hack pipes can and would coexist with the &lt;a href=&#34;https://github.com/js-choi/proposal-function-helpers&#34;&gt;&lt;code&gt;Function&lt;/code&gt; helpers proposal&lt;/a&gt;, including its &lt;code&gt;pipe&lt;/code&gt; and &lt;code&gt;flow&lt;/code&gt; functions. These simple (and commonly downloaded) convenience functions manipulate unary functions without extra syntax.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tc39-has-rejected-f-pipes-multiple-times&#34;&gt;TC39 has rejected the F# pipe operator twice&lt;/a&gt;. Given this reality, TC39 is considerably more likely to pass &lt;code&gt;pipe&lt;/code&gt; and &lt;code&gt;flow&lt;/code&gt; helper functions than a similar syntactic operator.&lt;/p&gt; &#xA;&lt;p&gt;Standardized &lt;code&gt;pipe&lt;/code&gt; and &lt;code&gt;flow&lt;/code&gt; convenience functions may also obviate some of the need for a F#-pipe infix operator. (They would not preclude standardizing an equivalent operator later. For example, TC39 standardized binary &lt;code&gt;**&lt;/code&gt; even when &lt;code&gt;Math.pow&lt;/code&gt; existed.)&lt;/p&gt; &#xA;&lt;h3&gt;Partial-function-application syntax&lt;/h3&gt; &#xA;&lt;p&gt;Hack pipes can coexist with a syntax for &lt;strong&gt;partial function application&lt;/strong&gt; (PFA). There are two approaches with which they may coexist.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;first approach&lt;/strong&gt; is with an &lt;strong&gt;eagerly&lt;/strong&gt; evaluated PFA syntax, which has &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;already been proposed in proposal-partial-application&lt;/a&gt;. This eager PFA syntax would add an &lt;code&gt;‚Ä¶~(‚Ä¶)&lt;/code&gt; operator. The operator‚Äôs right-hand side would be a list of arguments, each of which is an ordinary expression or a &lt;code&gt;?&lt;/code&gt; placeholder. Each consecutive &lt;code&gt;?&lt;/code&gt; placeholder would represent another parameter.&lt;/p&gt; &#xA;&lt;p&gt;Ordinary expressions would be evaluated &lt;strong&gt;before&lt;/strong&gt; the function is created. For example, &lt;code&gt;f~(g(), ?, h(), ?)&lt;/code&gt; would evaluate &lt;code&gt;f&lt;/code&gt;, then &lt;code&gt;g()&lt;/code&gt;, then &lt;code&gt;h()&lt;/code&gt;, and &lt;em&gt;then&lt;/em&gt; it would create a partially applied version of &lt;code&gt;f&lt;/code&gt; with two arguments.&lt;/p&gt; &#xA;&lt;p&gt;An optional number after &lt;code&gt;?&lt;/code&gt; placeholder would override the parameter‚Äôs position. For example, &lt;code&gt;f~(?1, ?0)&lt;/code&gt; would have two parameters but would switch them when calling &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;second approach&lt;/strong&gt; is with a &lt;strong&gt;lazily&lt;/strong&gt; evaluated syntax. This could be handled with an &lt;strong&gt;extension to Hack pipes&lt;/strong&gt;, with a syntax further inspired by &lt;a href=&#34;https://clojure.org/reference/reader#_dispatch&#34;&gt;Clojure‚Äôs &lt;code&gt;#(%1 %2)&lt;/code&gt; function literals&lt;/a&gt;. It would do so by &lt;strong&gt;combining&lt;/strong&gt; the Hack pipe &lt;code&gt;|&amp;gt;&lt;/code&gt; with the &lt;strong&gt;arrow function&lt;/strong&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; into a &lt;strong&gt;pipe-function&lt;/strong&gt; operator &lt;code&gt;+&amp;gt;&lt;/code&gt;, which would use the same general rules as &lt;code&gt;|&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;+&amp;gt;&lt;/code&gt; would be a &lt;strong&gt;prefix operator&lt;/strong&gt; that &lt;strong&gt;creates a new function&lt;/strong&gt;, which in turn &lt;strong&gt;binds its argument(s)&lt;/strong&gt; to topic references. &lt;strong&gt;Non-unary functions&lt;/strong&gt; would be created by including topic references with &lt;strong&gt;numbers&lt;/strong&gt; (&lt;code&gt;%0&lt;/code&gt;, &lt;code&gt;%1&lt;/code&gt;, &lt;code&gt;%2&lt;/code&gt;, etc.) or &lt;code&gt;...&lt;/code&gt;. &lt;code&gt;%0&lt;/code&gt; (equivalent to plain &lt;code&gt;%&lt;/code&gt;) would be bound to the &lt;strong&gt;zeroth argument&lt;/strong&gt;, &lt;code&gt;%1&lt;/code&gt; would be bound to the next argument, and so on. &lt;code&gt;%...&lt;/code&gt; would be bound to an array of &lt;strong&gt;rest arguments&lt;/strong&gt;. And just as with &lt;code&gt;|&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&lt;/code&gt; would require its body to contain at least one topic reference in order to be syntactically valid.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Eager PFA&lt;/th&gt; &#xA;   &lt;th&gt;Pipe functions&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(f~(?, 0))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; f(%, 0))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(f~(?, ?, 0))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; f(%0, %1, 0))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(x=&amp;gt; x + 1)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; % + 1)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(x=&amp;gt; x + x)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; % + %)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(x=&amp;gt; f(x, x))&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;a.map(+&amp;gt; f(%, %))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;In contrast to the &lt;a href=&#34;https://github.com/tc39/proposal-partial-application&#34;&gt;eagerly evaluated PFA syntax&lt;/a&gt;, topic functions would &lt;strong&gt;lazily&lt;/strong&gt; evaluate its arguments, just like how an arrow function would.&lt;/p&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;+&amp;gt; f(g(), %0, h(), %1)&lt;/code&gt; would evaluate &lt;code&gt;f&lt;/code&gt;, and then it would create an arrow function that closes over &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;. The created function would &lt;strong&gt;not&lt;/strong&gt; evaluate &lt;code&gt;g()&lt;/code&gt; or &lt;code&gt;h()&lt;/code&gt; until the every time the created function is called.&lt;/p&gt; &#xA;&lt;p&gt;No matter the approach taken, Hack pipes could coexist with PFA.&lt;/p&gt; &#xA;&lt;h3&gt;Eventual sending / pipelining&lt;/h3&gt; &#xA;&lt;p&gt;Despite sharing the word ‚Äúpipe‚Äù in their name, the pipe operator and the &lt;a href=&#34;https://github.com/tc39/proposal-eventual-send/&#34;&gt;eventual-send proposal&lt;/a&gt;‚Äôs remote-object pipelines are orthogonal and independent. They can coexist and even work together.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fileP = E(&#xA;  E(target).openDirectory(dirName)&#xA;).openFile(fileName);&#xA;&#xA;const fileP = target&#xA;|&amp;gt; E(%).openDirectory(dirName)&#xA;|&amp;gt; E(%).openFile(fileName);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Possible future extensions&lt;/h2&gt; &#xA;&lt;h3&gt;Hack-pipe syntax for &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;‚Äì&lt;code&gt;of&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Many &lt;strong&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt; statements&lt;/strong&gt; could become pithier if they gained &lt;strong&gt;‚Äúpipe syntax‚Äù&lt;/strong&gt; that bound the topic reference.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;if () |&amp;gt;&lt;/code&gt; would bind its condition value to &lt;code&gt;%&lt;/code&gt;,&lt;br&gt; &lt;code&gt;catch |&amp;gt;&lt;/code&gt; would bind its caught error to &lt;code&gt;%&lt;/code&gt;,&lt;br&gt; and &lt;code&gt;for (of) |&amp;gt;&lt;/code&gt; would consecutively bind each of its iterator‚Äôs values to &lt;code&gt;%&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Status quo&lt;/th&gt; &#xA;   &lt;th&gt;Hack-pipe statement syntax&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;const c = f(); if (c) g(c);&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;if (f()) |&amp;gt; g(%);&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;catch (e) f(e);&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;catch |&amp;gt; f(%);&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;for (const v of f()) g(v);&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;for (f()) |&amp;gt; g(%);&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Optional Hack pipes&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;strong&gt;short-circuiting&lt;/strong&gt; optional-pipe operator &lt;code&gt;|?&amp;gt;&lt;/code&gt; could also be useful, much in the way &lt;code&gt;?.&lt;/code&gt; is useful for optional method calls.&lt;/p&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;value |&amp;gt; (% == null ? % : await foo(%) |&amp;gt; (% == null ? % : % + 1))&lt;/code&gt;&lt;br&gt; would be equivalent to &lt;code&gt;value |?&amp;gt; await foo(%) |?&amp;gt; % + 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Tacit unary function application syntax&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt; for &lt;strong&gt;tacit unary function application&lt;/strong&gt; ‚Äì that is, the F# pipe operator ‚Äì has been &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tc39-has-rejected-f-pipes-multiple-times&#34;&gt;rejected twice by TC39&lt;/a&gt;. However, they could still eventually be added to the language in two ways.&lt;/p&gt; &#xA;&lt;p&gt;First, it can be added as a convenience function &lt;code&gt;Function.pipe&lt;/code&gt;. This is what the &lt;a href=&#34;https://github.com/js-choi/proposal-function-helpers&#34;&gt;function-helpers proposal&lt;/a&gt; proposes. &lt;code&gt;Function.pipe&lt;/code&gt; may obviate much of the need for an F#-pipe operator, while still not closing off the possibility of an F#-pipe operator.&lt;/p&gt; &#xA;&lt;p&gt;Secondly, it can be added as &lt;strong&gt;another pipe operator&lt;/strong&gt; &lt;code&gt;|&amp;gt;&amp;gt;&lt;/code&gt; ‚Äì similarly to how &lt;a href=&#34;https://clojure.org/guides/threading_macros&#34;&gt;Clojure has multiple pipe macros&lt;/a&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;as-&amp;gt;&lt;/code&gt;.&lt;br&gt; For example, &lt;code&gt;value |&amp;gt; % + 1 |&amp;gt;&amp;gt; f |&amp;gt; g(%, 0)&lt;/code&gt;&lt;br&gt; would mean &lt;code&gt;value |&amp;gt; % + 1 |&amp;gt; f(%) |&amp;gt; g(%, 0)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There was an &lt;a href=&#34;https://raw.githubusercontent.com/tc39/proposal-pipeline-operator/main/#tacit-unary-function-application-syntax&#34;&gt;informal proposal for such a &lt;strong&gt;split mix&lt;/strong&gt; of two pipe operators&lt;/a&gt;, which was set aside in favor of single-operator proposals. This split mix might return as a proposal after Hack pipes.&lt;/p&gt;</summary>
  </entry>
</feed>