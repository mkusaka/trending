<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub HTML Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-14T01:52:06Z</updated>
  <subtitle>Weekly Trending of HTML in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>WICG/dbsc</title>
    <updated>2024-04-14T01:52:06Z</updated>
    <id>tag:github.com,2024-04-14:/WICG/dbsc</id>
    <link href="https://github.com/WICG/dbsc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Device Bound Session Credentials explainer&lt;/h1&gt; &#xA;&lt;p&gt;This is the repository for Device Bound Session Credentials. You&#39;re welcome to &lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/CONTRIBUTING.md&#34;&gt;contribute&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Authors:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/kristianm@google.com&#34;&gt;Kristian Monsen&lt;/a&gt;, Google&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/arnarb@google.com&#34;&gt;Arnar Birgisson&lt;/a&gt;, Google&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Participate (to come)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WICG/dbsc/issues&#34;&gt;Issue tracker&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;[Discussion forum]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#introduction&#34;&gt;Introduction&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#goals-or-motivating-use-cases-or-scenarios&#34;&gt;Goals [or Motivating Use Cases, or Scenarios]&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#non-goals&#34;&gt;Non-goals&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#what-makes-device-bound-secure-credentials-different&#34;&gt;What makes Device Bound Session Credentials different&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#application-level-binding&#34;&gt;Application-level binding&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#browser-initiated-refreshes&#34;&gt;Browser-initiated refreshes&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#tpm-considerations&#34;&gt;TPM considerations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#privacy-considerations&#34;&gt;Privacy considerations&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#high-level-overview&#34;&gt;High level overview&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#start-session&#34;&gt;Start Session&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#maintaining-a-session&#34;&gt;Maintaining a session&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#refresh-procedure&#34;&gt;Refresh procedure&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#ending-a-session&#34;&gt;Ending a session&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#interactions-with-other-apis&#34;&gt;Interactions with other APIs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#login-status-api&#34;&gt;Login Status API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/#interaction-with-inactive-documents-bfcache-prerendering&#34;&gt;Interaction with Inactive Documents (BFCache, Prerendering)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Device Bound Session Credentials (DBSC) aims to reduce account hijacking caused by cookie theft. It does so by introducing a protocol and browser infrastructure to maintain and prove possession of a cryptographic key. The main challenge with cookies as an authentication mechanism is that they only lend themselves to bearer-token schemes. On desktop operating systems, application isolation is lacking and local malware can generally access anything that the browser itself can, and the browser must be able to access cookies. On the other hand, authentication with a private key allows for the use of system-level protection against key exfiltration.&lt;/p&gt; &#xA;&lt;p&gt;DBSC offers an API for websites to control the lifetime of such keys, behind the abstraction of a session, and a protocol for periodically and automatically proving possession of those keys to the website&#39;s servers. There is a seperate key for each session, and it should not be possible to detect two different session keys are from one device. One of the key goals is to enable drop-in integration with common types of current auth infrastructure. By device-binding the private key and with appropriate intervals of the proofs, the browser can limit malware&#39;s ability to offload its abuse off of the user&#39;s device, significantly increasing the chance that either the browser or server can detect and mitigate cookie theft.&lt;/p&gt; &#xA;&lt;p&gt;DBSC is bound to a device with cryptographic keys that cannot be exported from the user’s device under normal circumstances, this is called device binding in the rest of this document. DBSC provides an API that servers can use to create a session bound to a device, and this session can periodically be refreshed with an optional cryptographic proof the session is still bound to the original device. At sign-in, the API informs the browser that a session starts, which triggers the key creation. It then instructs the browser that any time a request is made while that session is active, the browser should ensure the presence of certain cookies. If these cookies are not present, DBSC will hold network requests while querying the configured endpoint for updated cookies.&lt;/p&gt; &#xA;&lt;h3&gt;Goals&lt;/h3&gt; &#xA;&lt;p&gt;Reduce session theft by offering an alternative to long-lived cookie bearer tokens, that allows session authentication that is bound to the user&#39;s device. This makes the internet safer for users in that it is less likely their identity is abused, since malware is forced to act locally and thus becomes easier to detect and mitigate. At the same time the goal is to disrupt the cookie theft ecosystem and force it to adapt to new protections.&lt;/p&gt; &#xA;&lt;h3&gt;Non-goals&lt;/h3&gt; &#xA;&lt;p&gt;DBSC will not prevent temporary access to the browser session while the attacker is resident on the user’s device. The private key should be stored as safe as modern desktop operating systems allow, preventing exfiltrating of the session private key, but the signing capability will still be available for any program running as the user on the user’s device.&lt;/p&gt; &#xA;&lt;h3&gt;What makes Device Bound Session Credentials different&lt;/h3&gt; &#xA;&lt;p&gt;DBSC is not the first proposal towards these goals, with a notable one being &lt;a href=&#34;https://en.wikipedia.org/wiki/Token_Binding&#34;&gt;Token Binding&lt;/a&gt;. This proposal offers two important features that we believe makes it easier to deploy than previous proposals. DBSC provides application-level binding and browser initiated refreshes that can make sure devices are still bound to the original device.&lt;/p&gt; &#xA;&lt;h4&gt;Application-level binding&lt;/h4&gt; &#xA;&lt;p&gt;For websites, device binding is most useful for securing authenticated sessions of users. DBSC allows websites to closely couple the setup of bound sessions with user sign-in mechanisms, makes session and key lifetimes explicit and controllable, and allows servers to design infrastructure that places verification of session credentials close to where user credentials (cookies) are processed in their infrastructure.&lt;/p&gt; &#xA;&lt;p&gt;Alternatives such as Token Binding gain much from e.g. integrating with TLS, but this can make integration harder in environments where e.g. TLS channel termination is far removed from the application logic behind user sign-in and session management.&lt;/p&gt; &#xA;&lt;h4&gt;Browser-initiated refreshes&lt;/h4&gt; &#xA;&lt;p&gt;Other proposals have explored lower-level APIs for websites to create and use protected private keys, e.g. via WebCrypto or APIs similar to WebAuthn. While this works in theory, it puts a very large burden on the website to integrate with. In particular, since the cost of using protected keys is high, websites must design some infrastructure for collecting signatures only as often as needed.&lt;/p&gt; &#xA;&lt;p&gt;This means either high-touch integrations where the keys are only used to protect sensitive operations (like making a purchase), or a general ability to divert arbitrary requests to some endpoint that collects and verifies a signature and then retries the original request. The former doesn&#39;t protect the whole session and violates the principle of secure by default, while the latter can be prohibitively expensive for large websites built from multiple components by multiple teams, and may require non-trivial rewrites of web and RPC frameworks.&lt;/p&gt; &#xA;&lt;p&gt;DBSC instead allows a website to consolidate the session binding to a few points: At sign-in, it informs the browser that a session starts, which triggers the key creation. It then instructs the browser that any time a request is made while that session is active, the browser should ensure the presence of certain cookies. The browser does this by calling a dedicated refresh endpoint (specified by the website) whenever such cookies are needed, presenting that endpoint with a proof of possession of the private key. That endpoint in turn, using existing standard Set-Cookie headers, provides the browser with short-term cookies needed to make other requests.&lt;/p&gt; &#xA;&lt;p&gt;This provides two important benefits:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Session binding logic is consolidated in the sign-in mechanism, and the new dedicated refresh endpoint. All other parts of the website continue to see cookies as their only authentication credentials, the only difference is that those cookies are short-lived. This allows deployment on complex existing setups, often with no changes to non-auth related endpoints.&lt;/li&gt; &#xA; &lt;li&gt;If a browser is about to make a request where it has been instructed to include such a cookie, but doesn&#39;t have one, it defers making that request until the refresh is done. While this may add latency to such cases, it also means non-auth endpoints do not need to tolerate unauthenticated requests or respond with any kind of retry logic or redirects. This again allows deployment with minimal changes to existing endpoints.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note that the latency introduced by deferring of requests can be mitigated by the browser in other ways, which we discuss later.&lt;/p&gt; &#xA;&lt;h3&gt;TPM considerations&lt;/h3&gt; &#xA;&lt;p&gt;DBSC depends on user devices having a way of signing challenges while protecting private keys from exfiltration by malware. This usually means the browser needs to have access to a Trusted Platform Module (TPM) on the device, which is not always available. TPMs also have a reputation for having high latency and not being dependable. Having a TPM is a requirement for installing Windows 11, and can be available on previous versions. All our studies are for public key cryptography using ECDSA_P256 algorithm.&lt;/p&gt; &#xA;&lt;p&gt;Chrome has done studies to understand TPM availability to understand the feasibility of secure sessions. Current data shows about 60%, and currently growing, of Windows users would be offered protections. Studies have also been done on the current populations of TPMs, both for latency and for predictability. Currently the latency is (P50: 200ms/ P95: 600ms) for signing operations. The error rate is very low, currently around 0.001%.&lt;/p&gt; &#xA;&lt;p&gt;Based on this research, TPMs are widely available, with a latency and consistency that is acceptable for the proposed usage.&lt;/p&gt; &#xA;&lt;h3&gt;Privacy considerations&lt;/h3&gt; &#xA;&lt;p&gt;An important high-level goal of this protocol is to introduce no additional surface for user tracking: implementing this API (for a browser) or enabling it (for a website) should not entail any significant user privacy tradeoffs.&lt;/p&gt; &#xA;&lt;p&gt;There are a few obvious considerations to ensure we achieve that goal:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lifetime of a session/key material: This should provide no additional client data storage (i.e., a pseudo-cookie). As such, we require that browsers MUST clear sessions and keys when clearing other site data (like cookies).&lt;/li&gt; &#xA; &lt;li&gt;Cross-site/cross-origin data leakage: It should be impossible for a site to use this API to circumvent the same origin policy, 3P cookie policies, etc. (More on this below.)&lt;/li&gt; &#xA; &lt;li&gt;Implementing this API should not meaningfully increase the entropy of heuristic device fingerprinting signals. (For example, it should not leak any stable TPM-based device identifier.)&lt;/li&gt; &#xA; &lt;li&gt;This API—which allows background &#34;pings&#34; to the refresh endpoint when the user is not directly active—must not enable long-term tracking of a user when they have navigated away from the connected site.&lt;/li&gt; &#xA; &lt;li&gt;Each session has a separate new key created, and it should not be possible to detect that different sessions are from the same device.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;High level overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/reg_and_refresh.svg?sanitize=true&#34; alt=&#34;High level diagram&#34;&gt; &lt;a href=&#34;https://sequencediagram.org/index.html#initialData=A4QwTgLglgxloDsIAIBEAVACgWVckAzshAFCiSzwhJoBCYA9gO4ECmYehyARmeNHEQpUAZXYA3dpyJMScktwC0APiYAuZASgBzBIqgJkAMwA2zEkxXcNAJgAMd5EwD0W3awAm+wzAZJWSAA0yGCsBMB+bMgGMCYArh5hyAAWrCCJYMQMmhD8mqwwcaH5BFp+AHTIyAA6CAASaRkaqKIFimKlUH6KAEqs2lAEEGAg0H4abJ1+APpQiUhQRlDsALzl68EwySAmJgHarGvrLbUAFFs7ewgHIawAjnFQoR7GDJnAYFDio6zIANasACeyA+DAYRmQ4JBDFKYTKCAAlCQEAwIL8GJJMtYeIwWOxoggoNAfkRJvCeAYPAZtLVuIRPJDDKl0viPmEAjBWAoVBANKEHmEUDBQj9-kDQE8SBArHzWBAioZgHFuCZYGLAcjUejMTwNMK0mjkAApADq6Cczguu32XKUyl5-Ligs0OkMpvQUplt3lYDdZpdulGRVtKnUyEwAHkRObXAVg2SughXLlIAm-DUELUWgBvVA7bSoNTrcrBVAQQHAQuod2oYLFgC+2eLgVQAMBVYAPEqVbBpm3lKh6y1kJrDRj8WGhm9ft3VTB1cFBSAewRkiV4RYvfZHC5fAw-st8AgXmnDABJAAitIYHmBMXiiVJvmA6Ihe4PSVObx0BmQAGoQVGZIEVqWpmSaNBWmlABhMEPw0EA4ggZJpnfZYTgQbgb0BZpUFzU9ZnmaAlikIt1iHVASBWFYRAYABbX5oAYwDYQIYtqNHbV8WxOI2EyWJYD+IhVQQP5XneIDkFceiCj8NEkG5ZRsS2AoxMWSFPgGBA-1AZDbgeJ4kiwuJj2QNCuR2FBjNM8zkBRFBHUMjxFLDABxABRGMCBk3x-AUywlNsBwLV8+TSFYEwomsl5bMc55FOU1IYDUiE4oZcyiFYAAPQZSEs-THmeMy4MPNk2BoagXns5BsuAJyXI0DyvJ8uSAlIALsW3ELWoUiKojSmKSt+OjBi0a4NJqrK6vi+yuKxWUBSGZBEiMdgiqYZIoD2JxfgOIUhrY9YGuQJqpLYQpQlPZxQiMS61zAxp2FwsQYHaOFE0UM8PA0ABtU9kEvABdFpN0CgAWOwAEZQPqR6wGetoOnhRRoO2a1rlYCZ3pmOY2sWZYwCOEszLRq4DiJkHZshHVlJFQ13RC0mbUUh17idJa3D9D1pUC70FWNf1OaDUJjtO2MLvZKYkxuu6M3Ap7IJet6pd6MIIgQNhfvdYHKKp8dMjDb5VQ8UVQShKEIlYxNQesLrdyGo8T2x88r0w7CCViBIkgIZ9X2K-dliIL9NN-ADdOAmH5fhxW5RRoaEKQlDzIwrDb1w-DncIvGSI4Mjygozjqe4rGJfXRMaqGZdVVXTxgkuuIGNqb8tJ2ArBVFzyzpavz2q3YKXG85jQrakgAmcsegA&#34;&gt;Link to editable diagram&lt;/a&gt;&lt;br&gt; The general flow of a secure session is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The website requests that the browser start a new session, providing an HTTP endpoint to negotiate registration parameters.&lt;/li&gt; &#xA; &lt;li&gt;The browser creates a device-bound key pair, and calls the registration HTTP endpoint to set up the session and register the public key.&lt;/li&gt; &#xA; &lt;li&gt;The server responds with a session identifier, and instructions on how to maintain the session. This is a (possibly empty) list of cookie names that the browser is expected to ensure exist, and their associated scope (origins+path).&lt;/li&gt; &#xA; &lt;li&gt;At a later time the session is closed by either the server requesting to close the session or the user clears the keys by clearing site data.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;As long as that session is active, the browser performs the following refresh as needed:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;For any request within an applicable scope, the browser checks if the necessary cookies exist. If they exist, continue as normal.&lt;/li&gt; &#xA; &lt;li&gt;If not, the browser defers such requests while performing the following.&lt;/li&gt; &#xA; &lt;li&gt;The browser contacts the HTTP endpoint for the session, providing the session identifier and, if requested by the server, the necessary proof of possession of the associated private key.&lt;/li&gt; &#xA; &lt;li&gt;If the server is satisfied with the proof, it uses regular Set-Cookie headers to establish the necessary cookies with an appropriate Max-Age. The response can also include an updated set of instructions, e.g. if the server wishes to change which cookies are subject to this logic.&lt;/li&gt; &#xA; &lt;li&gt;If any requests were deferred in step 2, the browser now makes those requests including the updated set of cookies.&lt;/li&gt; &#xA; &lt;li&gt;The browser may choose to proactively refresh cookies that are about to expire, if it predicts the user may soon need them. This is purely a latency optimization, and not required.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Start Session&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/header_setup.svg?sanitize=true&#34; alt=&#34;Start session diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sequencediagram.org/index.html#initialData=MoUwTgbuC0B8CqBncACAggcxAOwC4C4VQBjaURRASwHttoAlEDSxXMAQ1xuwCgeMw1AK4AHFMlyjxICtxRgQARyEzcPJKkw5ccUJHD4ACgHlgAFRQB6ZMSELks2tdzswuB1Vo9s1XCBTUUGAoGsFaeAA0ekEAxADuABYgnPgA3gBEAEaU2AAmORjQ7AA2GPgAdJXpAL7qyGFYeAA8ZOBB+KA6AMLU1ADWlCCE7EK4CQD6xL0DIN6+-oGooeiNuFFt4PFJKRke3NCUudqUAGaDYBVVtTi5fD5+AUEh9SvaW8kE5J7YKCwoPnEUOxiFwoDwgA&#34;&gt;Link to editable diagram&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The session start process is initiated by the server attaching a header with Sec-Session-Registration and appropriate parameters, this looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK&#xA;Sec-Session-Registration: &#34;path&#34;;challenge=:Y2hhbGxlbmdl:;es256;rs256;authorization=:YXV0aGNvZGU=:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a structured header with a list of string arguments representing the path. Each path can have multiple attributes, one token for each supported algorithm (where the possibilities are es256 and rs256) and a named attribute called challenge which should have a bytestring that is the challenge utf8 encoded. There is also an optional bytestring attribute called authorization. There can be more than one registration on one response:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK&#xA;Sec-Session-Registration: &#34;path1&#34;;challenge=:Y2hhbGxlbmdl:;es256;rs256;authorization=:YXV0aGNvZGU=:&#xA;Sec-Session-Registration: &#34;path2&#34;;challenge=:bmV3b25l:;es256&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The authorization value is optional. If present, it will be sent to the registration endpoint in the &lt;code&gt;Authorization&lt;/code&gt; header, and included in the registration JWT. This allows passing a bearer token that allows the server to link registration with some preceding sign in flow, as an alternative to the more traditional use of cookies. While this can also facilitate integration with some existing infrastructgure, e.g. ones based on OAuth 2.0, this parameter is general and is not limited to the similarly named &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.1&#34;&gt;Authorization Code&lt;/a&gt; in OAuth 2.0.&lt;/p&gt; &#xA;&lt;p&gt;The browser responds to the session start by selecting a compatible signature algorithm and creating a device-bound private key for the new session. It then makes the following HTTP request (assuming the endpoint URL is &lt;a href=&#34;https://auth.example.com/securesession&#34;&gt;https://auth.example.com/securesession&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;POST /securesession/startsession HTTP/1.1&#xA;Host: auth.example.com&#xA;Accept: application/json&#xA;Content-Type: application/json&#xA;Content-Length: nn&#xA;Cookie: whatever_cookies_apply_to_this_request=value;&#xA;&#xA;&amp;lt;base64-URL-encoded registration JWT&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The JWT is signed with the newly created private key, and needs to contain the following values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// Header&#xA;{&#xA;  &#34;alg&#34;: &#34;Signature Algorithm&#34;,&#xA;  &#34;typ&#34;: &#34;JWT&#34;,&#xA;}&#xA;// Payload&#xA;{&#xA;  &#34;aud&#34;: &#34;URL of this request&#34;,&#xA;  &#34;jti&#34;: &#34;nonce&#34;,&#xA;  &#34;iat&#34;: &#34;timestamp&#34;,&#xA;  &#34;key&#34;: &#34;public key&#34;,&#xA;  &#34;authorization&#34;: &#34;&amp;lt;authorization_value&amp;gt;&#34;, // optional, only if set in registration header&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the request is properly authorized, the server establishes whatever state represents the session server-side, and returns the following response.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK&#xA;Content-Type: application/json&#xA;Cache-Control: no-store&#xA;Set-Cookie: auth_cookie=abcdef0123; Domain=example.com; Max-Age=600; Secure; HttpOnly;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;session_identifier&#34;: &#34;&amp;lt;server issued identifier for the session&amp;gt;&#34;,&#xA;  &#34;credentials&#34;: [{&#xA;    &#34;name&#34;: &#34;auth_cookie&#34;,&#xA;    &#34;excluded_scope&#34;: [&#xA;      // the path is a prefix&#xA;      &#34;path_a&#34;,&#xA;      &#34;path_b&#34;&#xA;    ]&#xA;  }],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the request is not properly authorized, the server can request a new signed request by answering instead with a 401:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 401&#xA;Sec-Session-Challenge: challenge=new_challenge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Subsequently, as long as the browser considers this session &#34;active&#34;, it follows the steps above, namely by refreshing the auth_cookie whenever needed, as covered in the next section.&lt;/p&gt; &#xA;&lt;p&gt;Note if multiple cookies are required, the browser returns multiple Set-Cookie headers, with corresponding entries in the &#34;credentials&#34; array in the response body.&lt;/p&gt; &#xA;&lt;h3&gt;Maintaining a session&lt;/h3&gt; &#xA;&lt;p&gt;As long as the named cookie is not expired the browser will keep sending requests as normal. Once the cookie is expired the browser will hold all requests for the scope of the cookie, except where the server excluded the paths in the registration, while refreshing the cookie. This is where the browser driven protocol makes a difference, if not for this there would be potentially many requests without the required cookie.&lt;/p&gt; &#xA;&lt;h4&gt;Refresh procedure&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/refresh_v2.svg?sanitize=true&#34; alt=&#34;Refresh diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sequencediagram.org/index.html#initialData=A4QwTgLglgxloDsIAICqBnApmZBBA5pkgFCiSzwhLIASmANgCbIBKmAjgK6boTqnhocRCgDK2AG7ZixBAHsImZHKk4M2PISQAacWFUBiAO4ALTCAgAucenRQ5CZDDlyA1lCUhOEEwH1nbh7ImAAewFBgmIzE6jgERBAAtAB8dEysHNy86JbIAOIAogAqwSEgALbA9JgAdM7lAPTAYAqYMIqMvpFcPBDE+C2cwBkAZpHoJshYtvYIMVhxWknJeqqWAAoA8qIlDVgwnOM8dg4NkWM8JsSr2CmxmgmWNEVF68gALAAMAIyyrcqqNALB46G5gYxmCzWNqJGwnBCJADCJhA9GqCEIlhq2Jq8w08SQKTBG22u32hx4x1mZ0wFwmf0UAI09wJEF0kmwEPMVgA3gAicQwWFUhyJNjoYAOLHYvkAX2uHLAd2BrKeLzeACZPp8GUoVMyVUt2fpOaZudCkoiXO5MLkvD5-NaPABeCSo7jEIjReSM-VqQ0JY2GM1QtjVEBYZBmdLdLJ8ZBGKA+JxOnjIc7jMzRFlLImK3KFEqhCpVWr1JotRTtKJdTK9YhAA&#34;&gt;Link to editable diagram&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The browser refreshes the short-term session credential by calling the session endpoint:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;POST /securesession/refresh HTTP/1.1&#xA;Host: auth.example.com&#xA;Content-Type: application/json&#xA;Content-Length: nn&#xA;Cookie: whatever_cookies_apply_to_this_request=value;&#xA;Sec-Session-Id: [session ID]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In response to this the server can optionally first request a proof of possession of the key by issuing a challenge to the browser by responding with a 401 response with a challenge:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 401&#xA;Sec-Session-Challenge: session_identifier=&amp;lt;session identifier&amp;gt;,challenge=&amp;lt;base64url encoded challenge&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server can also serve challenges ahead of time attached to any response as an optimization, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 XXX&#xA;Sec-Session-Challenge: session_identifier=&amp;lt;session identifier&amp;gt;,challenge=&amp;lt;base64url encoded challenge&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The browser replies to that response with a Sec-Session-Response header, containing a signed JWT:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;POST /securesession/refresh HTTP/1.1&#xA;Sec-Session-Response: &amp;lt;base64-URL-encoded JWT&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The JWT contains:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;jti&#34;: &#34;challenge from Sec-Session-Challenge header&#34;,&#xA;  &#34;aud&#34;: &#34;the URL to which the Sec-Session-Response will be sent&#34;,&#xA;  &#34;sub&#34;: &#34;the session ID corresponding to the binding key&#34;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the server is satisfied with the response, or if it did not request it, it answers by setting the short term cookie. Optionally the server can adjust the session in the body of the response similar to how it was set up.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK&#xA;Content-Type: application/json&#xA;Cache-Control: no-store&#xA;Set-Cookie: auth_cookie=abcdef0123; Domain=example.com; Max-Age=600; Secure; HttpOnly;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ // optionally adjusting the session&#xA;  // id must be the same as previously&#xA;  &#34;session_identifier&#34;: &#34;&amp;lt;server issued identifier for the session&amp;gt;&#34;,&#xA;  &#34;credentials&#34;: [{&#xA;    &#34;name&#34;: &#34;auth_cookie&#34;,&#xA;    &#34;excluded_scope&#34;: [&#xA;      // the path is a prefix&#xA;      &#34;path_a&#34;,&#xA;      &#34;path_b&#34;&#xA;    ]&#xA;  }],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On receiving this response, the browser releases any requests that were deferred pending this refresh, including the new cookie. Note: This response is nearly identical to the response to session setup, and can be handled by the same logic in the client. The new set of instructions replaces any previous instructions for the session. E.g. if the cookie name is different here than before, the browser should not trigger refreshes based on the absence of the old cookie name. The server may issue a different Max-Age, or scope for the short-term cookie. The server may set or update other cookies not subject to session refreshes in this response, as in any response.&lt;/p&gt; &#xA;&lt;p&gt;If instead the server decides to end the session it can respond with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;session_identifier&#34;: &#34;&amp;lt;server issued identifier for the session&amp;gt;&#34;,&#xA;  &#34;continue&#34;: false&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case the browser should stop triggering any refreshes for this request, release any deferred requests without the short-term cookie, and clean up and delete the associated session state including the binding key.&lt;/p&gt; &#xA;&lt;h4&gt;Ending a session&lt;/h4&gt; &#xA;&lt;p&gt;The session can end in several ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The server can end the session during a refresh by answering with {“continue”: false} during a refresh&lt;/li&gt; &#xA; &lt;li&gt;The server can at any time send a header with Clear-Site-Data: &#34;storage&#34;&lt;/li&gt; &#xA; &lt;li&gt;The user can clear site data, which will locally clear cookies and any registered session keys for the site&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is important that the user is always in control and can delete the session keys if wanted.&lt;/p&gt; &#xA;&lt;h2&gt;Interactions with other APIs&lt;/h2&gt; &#xA;&lt;h3&gt;Login Status API&lt;/h3&gt; &#xA;&lt;h3&gt;Interaction with Inactive Documents (BFCache, Prerendering)&lt;/h3&gt; &#xA;&lt;p&gt;When a session is ended for any reason, any inactive documents which had access to that session&#39;s credentials should be destroyed. This ensures that pages in BFCache or that are pre-rendering that contain information guarded by those credentials are not presented after the session has ended.&lt;/p&gt; &#xA;&lt;h2&gt;Alternative JavaScript API for StartSession&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/WICG/dbsc/main/dbsc_js_v2.svg?sanitize=true&#34; alt=&#34;Start session diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sequencediagram.org/index.html#initialData=A4QwTgLglgxloDsIAIDqBTARsgCiA5ugFCiSzwhLICqAzumMgIKFInjRyIoDKDAbgyJF8YAPYBXYMh4QOyerVpQxCIhmx5CAWgB8dBs1YQAXMgQh+UfCAhiwAOnowJYdIuWqncyAAoHAQCURAhiEOjIYoKMBows6EgAxADuABbotiYAwm62EQDW6ACeyKBQYESxRgkQenxg0SY4API8ACrIAPTOru7ungjdPhAhYRFRhlXxSAA09dEp6ZkA3gBEmFAIACab+NogADb4JgEOqwC+RPMMelPGJgASbW04yABMAAwfo+GR0TT0OLGOYCBiLDKmPi1LJiMT5KDoMwgCQQVIAfRgsPh6AAvPxDhJiBpcAR0AAebR3GpmYDiAC2UHoDjctDEB0E-iCRASWx+43+xK06BBDTBaQhJj4ShUCGQjPMYmSyBAMGggiIQA&#34;&gt;Link to editable diagram&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The API consists of a new interface, SecureSession, an instance of which is obtained via the securesession property of the navigator object. The SecureSession interface supports the following method:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;startSession():&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Parameters: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;endpoint: The URL of the secure session endpoint, supporting /startsession and /refresh operations&lt;/li&gt; &#xA;   &lt;li&gt;supported_binding_algs: Array of cryptographic algorithms supported by the server&lt;/li&gt; &#xA;   &lt;li&gt;authorization: Optional authorization value to be passed to Start Session HTTP request&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Returns: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A promise with a string containing the session ID (which may be empty)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When called, this method must:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generate and store a new, secure cryptographic key pair&lt;/li&gt; &#xA; &lt;li&gt;Call the &#34;endpoint&#34; + /startsession as specified below in Start Session (HTTP Request/Response)&lt;/li&gt; &#xA; &lt;li&gt;Return a promise which &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If that call succeeds (i.e. returns an HTTP 200), returns a session ID obtained from that call (which can be the empty string)&lt;/li&gt; &#xA;   &lt;li&gt;If that call fails, throws an exception (which may indicate the HTTP status of the failed call)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The endpoint must have the same origin as the JavaScript.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Below is an example of the API being used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let promise = navigator.secureSession.start({&#xA;  // Session start options&#xA;  &#34;endpoint&#34;: &#34;&amp;lt;url prefix of standard session endpoint&amp;gt;&#34;, // required&#xA;  &#34;supportedBindingAlgorithms&#34;: [&#34;ES256,RS256&#34;], // required&#xA;  &#34;authorization&#34;: &#34;&amp;lt;authorization value&amp;gt;&#34;, // optional&#xA;});&#xA;promise.then((sessionInfo) =&amp;gt; {&#xA;  // Success means the browser has completed the session setup with the&#xA;  // session endpoint and will perform the necessary maintenance tasks&#xA;  // going forward.&#xA;  console.log(&#34;Session with id {} was started.&#34;, sessionInfo.id);&#xA;});&#xA;promise.catch((...) =&amp;gt; {&#xA;  // Session start failed for some reason, e.g. the HTTP endpoint was&#xA;  // not reachable, or broke protocol.&#xA;  &amp;lt;error handling&amp;gt;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>Guyungy/damaihelper</title>
    <updated>2024-04-14T01:52:06Z</updated>
    <id>tag:github.com,2024-04-14:/Guyungy/damaihelper</id>
    <link href="https://github.com/Guyungy/damaihelper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;支持大麦网，淘票票、缤玩岛等多个平台，演唱会演出抢票脚本&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;黄牛杀手 抢票脚本 V3.0&lt;/h1&gt; &#xA;&lt;h2&gt;介绍&lt;/h2&gt; &#xA;&lt;p&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; main&lt;/p&gt; &#xA;&lt;h2&gt;依赖&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;selenium (4.10.0以下版本)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;pip install selenium ======= 现在黄牛太tm多了，根本抢不到票 为了解决这个问题，开发了这个脚本，支持大麦网，淘票票、缤玩岛等多个平台&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;blockquote&gt; &#xA;    &lt;blockquote&gt; &#xA;     &lt;blockquote&gt; &#xA;      &lt;blockquote&gt; &#xA;       &lt;p&gt;main&lt;/p&gt; &#xA;      &lt;/blockquote&gt; &#xA;     &lt;/blockquote&gt; &#xA;    &lt;/blockquote&gt; &#xA;   &lt;/blockquote&gt; &#xA;  &lt;/blockquote&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;功能介绍&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;模拟手机端人工操作&lt;/strong&gt;：&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;使用Appium来模拟手机端的操作，包括模拟用户的点击、滑动、输入等行为&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;多平台支持&lt;/strong&gt;：&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;使用Selenium，通过分析不同平台的页面结构和API，实现多平台支持&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;多账户抢票&lt;/strong&gt;：&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;在配置文件中管理多个账户的信息，包括用户名、密码、抢票策略&lt;/li&gt; &#xA;   &lt;li&gt;多线程或异步编程技术，同时处理多个账户的抢票任务&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;切换代理IP池&lt;/strong&gt;：&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;支持代理IP池，Scrapy和ProxyPool，实现IP的动态切换&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;定时预约场次&lt;/strong&gt;：&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;用定APScheduler，设置定时任务来执行预约场次的操作&lt;/li&gt; &#xA;   &lt;li&gt;灵活地配置定时任务的执行时间，并实现任务的自动触发和执行&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;测试中的功能&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;验证码识别：百度OCR，识别抢票过程中出现的验证码&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;更新记录&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;2023年4月1日&lt;/strong&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;增加选座购买功能，自动抢票功能和代理IP功能，提高抢票成功率和稳定性&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;2022年9月15日&lt;/strong&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;优化抢票算法，支持设置抢票时间段，增加灵活性和稳定性&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;2022年8月31日&lt;/strong&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;添加抢票失败后的重试机制，修复已知bug，提升系统稳定性和可靠性&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;配置文件说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;date&lt;/code&gt;: 日期序号，仅支持一个日期选择。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sess&lt;/code&gt;: 场次序号，优先选中的场次序号放在前，填写的场次序号若大于实际场次序号，则会选中实际场次序号最大的。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;price&lt;/code&gt;: 票档序号，优先选中的票档序号放在前，填写的票档序号若大于实际票档序号，则会选中实际票档序号最大的。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;real_name&lt;/code&gt;: 实名者序号，已经弃用。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nick_name&lt;/code&gt;: 用户昵称，已经弃用。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ticket_num&lt;/code&gt;: 购买票数，购买票数与观影人序号的数量务必一致。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;viewer_person&lt;/code&gt;: 观影人序号（预先添加实名观影人），优先选中的序号放在前，填写的序号若大于实际序号，则会放弃选中。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;driver_path&lt;/code&gt;: 驱动地址。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;damai_url&lt;/code&gt;: 大麦首页地址，用于登录。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;target_url&lt;/code&gt;: 购票的实际地址，需要使用手机端的地址，域名: &lt;a href=&#34;https://m.damai.cn/&#34;&gt;https://m.damai.cn/&lt;/a&gt; 开头。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;queue&lt;/code&gt;: 列入待抢的链接地址。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;auto_buy&lt;/code&gt;: 是否开启自动抢票功能，true表示开启，false表示关闭。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;auto_buy_time&lt;/code&gt;: 自动抢票时间，格式为 &#34;HH:MM:SS&#34;，例如 &#34;08:30:00&#34;。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;retry_interval&lt;/code&gt;: 自动抢票失败后重试间隔时间，单位为秒，默认为 5 秒。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;proxy&lt;/code&gt;: 是否使用代理IP进行请求，true表示使用，false表示不使用。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;proxy_ip&lt;/code&gt;: 代理IP地址。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;proxy_port&lt;/code&gt;: 代理IP端口号。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;注意事项&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;账号必须先做好实名制认证，并添加至少一个实名制的人的信息。&lt;/li&gt; &#xA; &lt;li&gt;第一次打开后会进入登录页面，需要手动选择扫码登陆。&lt;/li&gt; &#xA; &lt;li&gt;如果太久没用，需要先清空目录下的 cookie 文件，然后在重新登录。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;使用说明&lt;/h2&gt; &#xA;&lt;h3&gt;环境准备&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;安装所需要的环境。&lt;/li&gt; &#xA; &lt;li&gt;需要下载与系统安装对应的 ChromeDriver 驱动并配置（也可以改用其他浏览器驱动）。 &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;下载地址: &lt;a href=&#34;http://chromedriver.storage.googleapis.com/index.html&#34;&gt;http://chromedriver.storage.googleapis.com/index.html&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt;初次登录没有 cookies，默认登录方式为账号密码登录方式，可改成其他方式进行登录，如扫码或短信登录。&lt;/li&gt; &#xA; &lt;li&gt;设置自动抢票功能时，请确保填写了 &lt;code&gt;auto_buy_time&lt;/code&gt; 字段，并且时间格式正确。&lt;/li&gt; &#xA; &lt;li&gt;设置代理IP功能时，请确保填写了 &lt;code&gt;proxy_ip&lt;/code&gt; 和 &lt;code&gt;proxy_port&lt;/code&gt; 字段，并且格式正确。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;多平台抢票&lt;/h3&gt; &#xA;&lt;h2&gt;多账户抢票支持&lt;/h2&gt; &#xA;&lt;p&gt;为了满足用户同时使用多个账户进行抢票的需求，跨平台票务抢票脚本 V2.1 引入了多账户抢票功能。以下是如何配置和使用多账户进行抢票的详细说明：&lt;/p&gt; &#xA;&lt;h3&gt;配置多账户&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;账户信息配置&lt;/strong&gt;：在脚本的配置文件中（通常是 &lt;code&gt;config.json&lt;/code&gt; 或 &lt;code&gt;settings.ini&lt;/code&gt;），您需要为每个账户设置一个账户标识符，并为其指定登录凭据和其他必要的个人信息。例如：&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; main&#xA;{&#xA;    &#34;date&#34;: [&#xA;        14&#xA;    ],&#xA;    &#34;sess&#34;: [&#xA;        1,&#xA;        2&#xA;    ],&#xA;    &#34;price&#34;: [&#xA;        1,&#xA;        2,&#xA;        3,&#xA;        4,&#xA;        5,&#xA;        6&#xA;    ],&#xA;    &#34;real_name&#34;: [&#xA;        1&#xA;    ],&#xA;    &#34;nick_name&#34;: &#34;&#34;,&#xA;    &#34;ticket_num&#34;: 1,&#xA;    &#34;viewer_person&#34;: [&#xA;        1&#xA;    ],&#xA;    &#34;driver_path&#34;: &#34;C:\\Program Files\\Google\\Chrome\\Application\\chromedriver.exe&#34;,&#xA;    &#34;damai_url&#34;: &#34;https://www.damai.cn/&#34;,&#xA;    &#34;target_url&#34;: &#34;https://m.damai.cn/damai/detail/item.html?itemId=708250808776&amp;amp;spm=a2o71.home.snatch_ticket.item&amp;amp;from=appshare&amp;amp;sqm=dianying.h5.unknown.value.hlw_a2o71_28004194&#34;,&#xA;    &#34;comment&#34;: {&#xA;        &#34;title&#34;: &#34;comment 下的所有内容为自定义注释,无实际含义&#34;,&#xA;        &#34;date&#34;: &#34;日期序号,仅支持一个日期选择&#34;,&#xA;        &#34;sess&#34;: &#34;场次序号,优先选中的场次序号放在前,填写的场次序号若大于实际场次序号,则会选中实际场次序号最大的&#34;,&#xA;        &#34;price&#34;: &#34;票档序号,优先选中的票档序号放在前,填写的票档序号若大于实际票档序号,则会选中实际票档序号最大的&#34;,&#xA;        &#34;real_name&#34;: &#34;实名者序号,已经弃用&#34;,&#xA;        &#34;nick_name&#34;: &#34;用户昵称,已经弃用&#34;,&#xA;        &#34;ticket_num&#34;: &#34;购买票数,购买票数与观影人序号的数量务必一致&#34;,&#xA;        &#34;viewer_person&#34;: &#34;观影人序号(预先添加实名观影人),优先选中的序号放在前,填写的序号若大于实际序号,则会放弃选中&#34;,&#xA;        &#34;driver_path&#34;: &#34;驱动地址&#34;,&#xA;        &#34;damai_url&#34;: &#34;大麦首页地址,用于登录&#34;,&#xA;        &#34;target_url&#34;: &#34;购票的实际地址,需要使用手机端的地址,域名: https://m.damai.cn/ 开头&#34;,&#xA;        &#34;queue&#34;: {&#xA;            &#34;title&#34;: &#34;列入待抢的链接地址&#34;,&#xA;            &#34;zhoujielun_0403&#34;: &#34;https://m.damai.cn/damai/detail/item.html?itemId=607865020360&amp;amp;from=appshare&amp;amp;sqm=dianying.h5.unknown.value.hlw_a2o71_28004194&amp;amp;prev_page=8hu5vjnq54&amp;amp;spm=a2o71.28004194.785344.item_horizontal_3&#34;&#xA;        }&#xA;=======&#xA;&#34;accounts&#34;: {&#xA;    &#34;account1&#34;: {&#xA;        &#34;username&#34;: &#34;user1@example.com&#34;,&#xA;        &#34;password&#34;: &#34;password1&#34;,&#xA;        &#34;target_url&#34;: &#34;https://m.damai.cn/&#34;,&#xA;        &#34;auto_buy_time&#34;: &#34;08:30:00&#34;&#xA;    },&#xA;    &#34;account2&#34;: {&#xA;        &#34;username&#34;: &#34;user2@example.com&#34;,&#xA;        &#34;password&#34;: &#34;password2&#34;,&#xA;        &#34;target_url&#34;: &#34;https://m.taopiaopiao.com/&#34;,&#xA;        &#34;auto_buy_time&#34;: &#34;08:30:00&#34;&#xA;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; main&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;运行多账户抢票&lt;/strong&gt; 在配置完多账户后，您可以通过以下方式启动脚本，以同时使用所有配置好的账户进行抢票： &lt;code&gt;python ticket_script.py --multi-account&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;脚本将会遍历 accounts 配置中的每个账户，分别登录并尝试抢票。请确保每个账户的配置都是正确的，以避免在抢票过程中出现错误。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;使用多账户抢票时，请确保每个账户都遵守目标平台的使用条款，避免违规操作导致账户被封禁。 确保每个账户都已经完成了必要的实名认证（如果目标平台要求）。 根据目标平台的不同，登录方式（扫码、短信验证等）可能会有所不同，请根据实际情况调整账户配置。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;多账户抢票策略&lt;/h3&gt; &#xA;&lt;p&gt;为了在多个票务平台（如大麦网、淘票票、缤玩岛等）上运行抢票脚本，您需要按照以下步骤进行操作：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;配置文件准备&lt;/strong&gt;：为每个平台准备一个独立的配置文件，例如&lt;code&gt;config_damai.json&lt;/code&gt;、&lt;code&gt;config_taopiaopiao.json&lt;/code&gt;等。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;平台特定设置&lt;/strong&gt;：在每个配置文件中，设置该平台特定的&lt;code&gt;target_url&lt;/code&gt;、登录方式等信息。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;运行脚本&lt;/strong&gt;：在运行时，通过命令行参数&lt;code&gt;--config&lt;/code&gt;指定要使用的配置文件，例如：&lt;code&gt;python ticket_script.py --config config_taopiaopiao.json&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;免责声明&lt;/h2&gt; &#xA;&lt;p&gt;详见MIT License，此仓库仅用于个人参考学习，但如他人用本仓库代码用于商业用途（鄙视黄牛），侵犯到大麦网利益等，本人不承担任何责任。&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>AeolusUX/ArkOS-R3XS</title>
    <updated>2024-04-14T01:52:06Z</updated>
    <id>tag:github.com,2024-04-14:/AeolusUX/ArkOS-R3XS</id>
    <link href="https://github.com/AeolusUX/ArkOS-R3XS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Community Maintained Image of ArkOS for the RetroBox Console / Game Station / Game Consoie R35S / R36S / PowKiddy RGB20S&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://aeolusux.github.io/ArkOS-R3XS/&#34;&gt;ArkOS - R3XS&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/AeolusUX/ArkOS-R3XS/main/logo.bmp&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Download Links&lt;/h1&gt; &#xA;&lt;h2&gt;R33S - &lt;a href=&#34;https://drive.google.com/file/d/1ZViI4XFZSXhGFRaI_E-GQmph_C3Ou8qt/view?usp=sharing&#34;&gt;Google Drive&lt;/a&gt; | &lt;a href=&#34;https://www.mediafire.com/file/cw7igcvsp9t37hg/ArkOS_R33S_v2.0_03302024.img.xz/file&#34;&gt;Mediafire&lt;/a&gt; | &lt;a href=&#34;https://mega.nz/file/dwwkXQ4D#kkq2JXD3J0T1KVzhCkDPrWgWjeShPqgrFyDy6t0ivBE&#34;&gt;MEGA&lt;/a&gt; (Updated (04/11/2024)&lt;/h2&gt; &#xA;&lt;h2&gt;R35S / R36S - &lt;a href=&#34;https://drive.google.com/file/d/10z7j7IZ7WX3y10ZJBW_a2-agcIe1Dx9m/view?usp=sharing&#34;&gt;Google Drive&lt;/a&gt; | &lt;a href=&#34;https://www.mediafire.com/file/da4193t5vsjfsbr/ArkOS_R35S-R36S_v2.0_1272024-1.img.xz/file&#34;&gt;Mediafire&lt;/a&gt; | &lt;a href=&#34;https://mega.nz/file/5tojVAba#AgLHqIo5izAOt0u40SVkeUFUoGCmENNorjRu4svmTjo&#34;&gt;MEGA&lt;/a&gt; (Updated (04/11/2024)&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;br&gt; HOTFIX FOR READ FROM SD 1 AND SD2 configuration files not found in /etc/emulationstation/ error.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Take the attached compressed file &lt;a href=&#34;https://github.com/AeolusUX/ArkOS-R3XS-Updater/raw/main/04112024/arkosbackup.tar.gz?fbclid=IwAR3pSzg2RmQQ4OwBI4jF2svqmfCDEdHR-Cw3kZCv_y0pYdgdBy0ODoODAh8_aem_ATAOqdJa6AkmGCrixSHig_1EWn6Bx0fHssoJ107xIt_rGyw23iC3ykp779FH54cNAzIYKYqZ64VKqSlGp4BPtp8Y&#34;&gt;arkosbackup.tar.gz&lt;/a&gt; and put it in your roms/backup folder. Do not uncompress the contents! Just place the file as is in your roms/backup folder. If you don&#39;t have a backup folder in the roms folder, just create it.&lt;/li&gt; &#xA; &lt;li&gt;Then go into the Emulationstation Menu, scroll to Options, hit A, then go to Advanced, hit A, then scroll all the way down to Restore Settings, hit A.&lt;/li&gt; &#xA; &lt;li&gt;Once completed, reboot the device.&lt;/li&gt; &#xA; &lt;li&gt;Try using the script for reading both sd cards again.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Community Maintained Image.&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re having problems with this image find us at the &lt;a href=&#34;https://discord.gg/RetroHandhelds&#34;&gt;RetroHandhelds Discord&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/christianhaitian/arkos/wiki&#34;&gt;ArkOS Wiki&lt;/a&gt; | &lt;a href=&#34;https://ko-fi.com/post/Installation-Guide-for-ArkOS-v2-0-01272024-J3J6TVPH1&#34;&gt;Flashing Guide&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/AeolusUX/ArkOS-R3XS-Updater/main/R3XS-Changelogs&#34;&gt;Changelog&lt;/a&gt; | &lt;a href=&#34;https://github.com/christianhaitian/arkos/wiki/Frequently-Asked-Questions---RG351MP&#34;&gt;RG351MP - FAQ&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>