<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-21T01:33:30Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pinterest/PINRemoteImage</title>
    <updated>2024-07-21T01:33:30Z</updated>
    <id>tag:github.com,2024-07-21:/pinterest/PINRemoteImage</id>
    <link href="https://github.com/pinterest/PINRemoteImage" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A thread safe, performant, feature rich image fetcher&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PINRemoteImage&lt;/h1&gt; &#xA;&lt;h2&gt;Fast, non-deadlocking parallel image downloader and cache for iOS&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cocoapods.org/pods/PINRemoteImage&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/PINRemoteImage.svg?style=flat&#34; alt=&#34;CocoaPods compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/pinterest/PINRemoteImage/actions?query=workflow%3ACI+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/pinterest/PINRemoteImage/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pinterest/PINRemoteImage/master/Source/Classes/PINRemoteImageManager.h&#34;&gt;PINRemoteImageManager&lt;/a&gt; is an image downloading, processing and caching manager. It uses the concept of download and processing tasks to ensure that even if multiple calls to download or process an image are made, it only occurs one time (unless an item is no longer in the cache). PINRemoteImageManager is backed by &lt;strong&gt;GCD&lt;/strong&gt; and safe to &lt;strong&gt;access&lt;/strong&gt; from &lt;strong&gt;multiple threads&lt;/strong&gt; simultaneously. It ensures that images are decoded off the main thread so that animation performance isn&#39;t affected. None of its exposed methods allow for synchronous access. However, it is optimized to call completions on the calling thread if an item is in its memory cache.&lt;/p&gt; &#xA;&lt;p&gt;PINRemoteImage supports downloading many types of files. It, of course, &lt;strong&gt;supports&lt;/strong&gt; both &lt;strong&gt;PNGs&lt;/strong&gt; and &lt;strong&gt;JPGs&lt;/strong&gt;. It also supports decoding &lt;strong&gt;WebP&lt;/strong&gt; images if Google&#39;s library is available. It even supports &lt;strong&gt;GIFs&lt;/strong&gt; and &lt;strong&gt;Animated WebP&lt;/strong&gt; via PINAnimatedImageView.&lt;/p&gt; &#xA;&lt;p&gt;PINRemoteImage also has two methods to improve the experience of downloading images on slow network connections. The first is support for &lt;strong&gt;progressive JPGs&lt;/strong&gt;. This isn&#39;t any old support for progressive JPGs though: PINRemoteImage adds an attractive blur to progressive scans before returning them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pinterest/PINRemoteImage/master/progressive.gif&#34; alt=&#34;Progressive JPG with Blur&#34; title=&#34;Looks better on device.&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pinterest/PINRemoteImage/master/Pod/Classes/PINRemoteImageCategoryManager.h&#34;&gt;PINRemoteImageCategoryManager&lt;/a&gt; defines a protocol which UIView subclasses can implement and provide easy access to PINRemoteImageManager&#39;s methods. There are &lt;strong&gt;built-in categories&lt;/strong&gt; on &lt;strong&gt;UIImageView&lt;/strong&gt;, &lt;strong&gt;PINAnimatedImageView&lt;/strong&gt; and &lt;strong&gt;UIButton&lt;/strong&gt;, and it&#39;s very easy to implement a new category. See [UIImageView+PINRemoteImage](/Pod/Classes/Image Categories/UIImageView+PINRemoteImage.h) of the existing categories for reference.&lt;/p&gt; &#xA;&lt;h3&gt;Download an image and set it on an image view:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIImageView *imageView = [[UIImageView alloc] init];&#xA;[imageView pin_setImageFromURL:[NSURL URLWithString:@&#34;http://pinterest.com/kitten.jpg&#34;]];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = UIImageView()&#xA;imageView.pin_setImage(from: URL(string: &#34;https://pinterest.com/kitten.jpg&#34;)!)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Download a progressive jpeg and get attractive blurred updates:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIImageView *imageView = [[UIImageView alloc] init];&#xA;[imageView setPin_updateWithProgress:YES];&#xA;[imageView pin_setImageFromURL:[NSURL URLWithString:@&#34;http://pinterest.com/progressiveKitten.jpg&#34;]];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = UIImageView()&#xA;imageView.pin_updateWithProgress = true&#xA;imageView.pin_setImage(from: URL(string: &#34;https://pinterest.com/progressiveKitten.jpg&#34;)!)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Download a WebP file&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIImageView *imageView = [[UIImageView alloc] init];&#xA;[imageView pin_setImageFromURL:[NSURL URLWithString:@&#34;http://pinterest.com/googleKitten.webp&#34;]];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = UIImageView()&#xA;imageView.pin_setImage(from: URL(string: &#34;https://pinterest.com/googleKitten.webp&#34;)!)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Download a GIF and display with PINAnimatedImageView&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;PINAnimatedImageView *animatedImageView = [[PINAnimatedImageView alloc] init];&#xA;[animatedImageView pin_setImageFromURL:[NSURL URLWithString:@&#34;http://pinterest.com/flyingKitten.gif&#34;]];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let animatedImageView = PINAnimatedImageView()&#xA;animatedImageView.pin_setImage(from: URL(string: &#34;http://pinterest.com/flyingKitten.gif&#34;)!)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Download and process an image&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;UIImageView *imageView = [[UIImageView alloc] init];&#xA;[self.imageView pin_setImageFromURL:[NSURL URLWithString:@&#34;https://i.pinimg.com/736x/5b/c6/c5/5bc6c5387ff6f104fd642f2b375efba3.jpg&#34;] processorKey:@&#34;rounded&#34; processor:^UIImage *(PINRemoteImageManagerResult *result, NSUInteger *cost)&#xA; {&#xA;     CGSize targetSize = CGSizeMake(200, 300);&#xA;     CGRect imageRect = CGRectMake(0, 0, targetSize.width, targetSize.height);&#xA;     UIGraphicsBeginImageContext(imageRect.size);&#xA;     UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRoundedRect:imageRect cornerRadius:7.0];&#xA;     [bezierPath addClip];&#xA;&#xA;     CGFloat sizeMultiplier = MAX(targetSize.width / result.image.size.width, targetSize.height / result.image.size.height);&#xA;&#xA;     CGRect drawRect = CGRectMake(0, 0, result.image.size.width * sizeMultiplier, result.image.size.height * sizeMultiplier);&#xA;     if (CGRectGetMaxX(drawRect) &amp;gt; CGRectGetMaxX(imageRect)) {&#xA;         drawRect.origin.x -= (CGRectGetMaxX(drawRect) - CGRectGetMaxX(imageRect)) / 2.0;&#xA;     }&#xA;     if (CGRectGetMaxY(drawRect) &amp;gt; CGRectGetMaxY(imageRect)) {&#xA;         drawRect.origin.y -= (CGRectGetMaxY(drawRect) - CGRectGetMaxY(imageRect)) / 2.0;&#xA;     }&#xA;&#xA;     [result.image drawInRect:drawRect];&#xA;&#xA;     UIImage *processedImage = UIGraphicsGetImageFromCurrentImageContext();&#xA;     UIGraphicsEndImageContext();&#xA;     return processedImage;&#xA; }];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = FLAnimatedImageView()&#xA;imageView.pin_setImage(from: URL(string: &#34;https://i.pinimg.com/736x/5b/c6/c5/5bc6c5387ff6f104fd642f2b375efba3.jpg&#34;)!, processorKey: &#34;rounded&#34;)  { (result, unsafePointer) -&amp;gt; UIImage? in&#xA;&#xA;    guard let image = result.image else { return nil }&#xA;&#xA;    let radius : CGFloat = 7.0&#xA;    let targetSize = CGSize(width: 200, height: 300)&#xA;    let imageRect = CGRect(x: 0, y: 0, width: targetSize.width, height: targetSize.height)&#xA;&#xA;    UIGraphicsBeginImageContext(imageRect.size)&#xA;&#xA;    let bezierPath = UIBezierPath(roundedRect: imageRect, cornerRadius: radius)&#xA;    bezierPath.addClip()&#xA;&#xA;    let widthMultiplier : CGFloat = targetSize.width / image.size.width&#xA;    let heightMultiplier : CGFloat = targetSize.height / image.size.height&#xA;    let sizeMultiplier = max(widthMultiplier, heightMultiplier)&#xA;&#xA;    var drawRect = CGRect(x: 0, y: 0, width: image.size.width * sizeMultiplier, height: image.size.height * sizeMultiplier)&#xA;    if (drawRect.maxX &amp;gt; imageRect.maxX) {&#xA;        drawRect.origin.x -= (drawRect.maxX - imageRect.maxX) / 2&#xA;    }&#xA;    if (drawRect.maxY &amp;gt; imageRect.maxY) {&#xA;        drawRect.origin.y -= (drawRect.maxY - imageRect.maxY) / 2&#xA;    }&#xA;&#xA;    image.draw(in: drawRect)&#xA;&#xA;    UIColor.red.setStroke()&#xA;    bezierPath.lineWidth = 5.0&#xA;    bezierPath.stroke()&#xA;&#xA;    let ctx = UIGraphicsGetCurrentContext()&#xA;    ctx?.setBlendMode(CGBlendMode.overlay)&#xA;    ctx?.setAlpha(0.5)&#xA;&#xA;    let logo = UIImage(named: &#34;white-pinterest-logo&#34;)&#xA;    ctx?.scaleBy(x: 1.0, y: -1.0)&#xA;    ctx?.translateBy(x: 0.0, y: -drawRect.size.height)&#xA;&#xA;    if let coreGraphicsImage = logo?.cgImage {&#xA;        ctx?.draw(coreGraphicsImage, in: CGRect(x: 90, y: 10, width: logo!.size.width, height: logo!.size.height))&#xA;    }&#xA;&#xA;    let processedImage = UIGraphicsGetImageFromCurrentImageContext()&#xA;    UIGraphicsEndImageContext()&#xA;&#xA;    return processedImage&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handle Authentication&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[[PINRemoteImageManager sharedImageManager] setAuthenticationChallenge:^(NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, PINRemoteImageManagerAuthenticationChallengeCompletionHandler aCompletion) {&#xA;aCompletion(NSURLSessionAuthChallengePerformDefaultHandling, nil)];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;PINRemoteImageManager.shared().setAuthenticationChallenge { (task, challenge, completion) in&#xA;  completion?(.performDefaultHandling, nil)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Support for high resolution images&lt;/h3&gt; &#xA;&lt;p&gt;Currently there are two ways PINRemoteImage is supporting high resolution images:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If the URL contains an &lt;code&gt;_2x.&lt;/code&gt; or an &lt;code&gt;_3x.&lt;/code&gt; postfix it will be automatically handled by PINRemoteImage and the resulting image will be returned at the right scale.&lt;/li&gt; &#xA; &lt;li&gt;If it&#39;s not possible to provide an URL with an &lt;code&gt;_2x.&lt;/code&gt; or &lt;code&gt;_3x.&lt;/code&gt; postfix, you can also handle it with a completion handler:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *url = ...;&#xA;__weak UIImageView *weakImageView = self.imageView;&#xA;[self.imageView pin_setImageFromURL:url completion:^(PINRemoteImageManagerResult * _Nonnull result) {&#xA;  CGFloat scale = UIScreen.mainScreen.scale;&#xA;  if (scale &amp;gt; 1.0) {&#xA;    UIImage *image = result.image;&#xA;    weakImageView.image = [UIImage imageWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];&#xA;    }&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Set some limits&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;// cache is an instance of PINCache as long as you haven&#39;t overridden defaultImageCache&#xA;PINCache *cache = (PINCache *)[[PINRemoteImageManager sharedImageManager] cache];&#xA;// Max memory cost is based on number of pixels, we estimate the size of one hundred 600x600 images as our max memory image cache.&#xA;[[cache memoryCache] setCostLimit:600 * [[UIScreen mainScreen] scale] * 600 * [[UIScreen mainScreen] scale] * 100];&#xA;&#xA;// ~50 MB&#xA;[[cache diskCache] setByteLimit:50 * 1024 * 1024];&#xA;// 30 days&#xA;[[cache diskCache] setAgeLimit:60 * 60 * 24 * 30];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;a href=&#34;http://cocoapods.org/?q=name%3APINRemoteImage&#34;&gt;PINRemoteImage&lt;/a&gt; to your &lt;code&gt;Podfile&lt;/code&gt; and run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to use WebP images, add &lt;a href=&#34;http://cocoapods.org/?q=name%3APINRemoteImage&#34;&gt;PINRemoteImage/WebP&lt;/a&gt; to your &lt;code&gt;Podfile&lt;/code&gt; and run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;github &#34;pinterest/PINRemoteImage&#34;&lt;/code&gt; to your Cartfile . See &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&#39;s readme&lt;/a&gt; for more information on integrating Carthage-built frameworks into your project.&lt;/p&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Pinterest/PINRemoteImage/tags&#34;&gt;Download the latest tag&lt;/a&gt; and drag the &lt;code&gt;Pod/Classes&lt;/code&gt; folder into your Xcode project. You must also manually link against &lt;a href=&#34;https://github.com/pinterest/PINCache&#34;&gt;PINCache&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Install the docs by double clicking the &lt;code&gt;.docset&lt;/code&gt; file under &lt;code&gt;docs/&lt;/code&gt;, or view them online at &lt;a href=&#34;http://cocoadocs.org/docsets/PINRemoteImage/&#34;&gt;cocoadocs.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Git Submodule&lt;/h3&gt; &#xA;&lt;p&gt;You can set up PINRemoteImage as a submodule of your repo instead of cloning and copying all the files into your repo. Add the submodule using the commands below and then follow the manual instructions above.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git submodule add https://github.com/pinterest/PINRemoteImage.git&#xA;git submodule update --init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;PINRemoteImage&lt;/strong&gt; requires iOS 12.0 or greater.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;mailto:garrett@pinterest.com&#34;&gt;Garrett Moon&lt;/a&gt; &lt;a href=&#34;https://twitter.com/garrettmoon&#34;&gt;@garrettmoon&lt;/a&gt; &lt;a href=&#34;https://www.pinterest.com/garrettlunar/&#34;&gt;Pinterest&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright 2015 Pinterest, Inc.&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. &lt;a href=&#34;https://raw.githubusercontent.com/pinterest/PINRemoteImage/master/LICENSE.txt&#34;&gt;See the License&lt;/a&gt; for the specific language governing permissions and limitations under the License.&lt;/p&gt;</summary>
  </entry>
</feed>