<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-01T01:40:34Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>google/GTMAppAuth</title>
    <updated>2022-10-01T01:40:34Z</updated>
    <id>tag:github.com,2022-10-01:/google/GTMAppAuth</id>
    <link href="https://github.com/google/GTMAppAuth" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Apple platforms SDK for using AppAuth with Google libraries.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://cocoapods.org/pods/GTMAppAuth&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/GTMAppAuth.svg?style=flat&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/GTMAppAuth&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/GTMAppAuth.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/GTMAppAuth&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/GTMAppAuth.svg?style=flat&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/google/GTMAppAuth/actions/workflows/tests.yml&#34;&gt;&lt;img src=&#34;https://github.com/google/GTMAppAuth/actions/workflows/tests.yml/badge.svg?event=push&#34; alt=&#34;tests&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;GTMAppAuth for Apple Platforms&lt;/h1&gt; &#xA;&lt;p&gt;GTMAppAuth enables you to use &lt;a href=&#34;https://github.com/openid/AppAuth-iOS&#34;&gt;AppAuth&lt;/a&gt; with the &lt;a href=&#34;https://github.com/google/gtm-session-fetcher&#34;&gt;Google Toolbox for Mac - Session Fetcher&lt;/a&gt; and &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest&#34;&gt;Google APIs Client Library for Objective-C For REST&lt;/a&gt; libraries on iOS, macOS, tvOS, and watchOS by providing an implementation of &lt;a href=&#34;https://github.com/google/gtm-session-fetcher/raw/2a3b5264108e80d62003b770ff02eb7364ff1365/Source/GTMSessionFetcher.h#L660&#34;&gt;&lt;code&gt;GTMFetcherAuthorizationProtocol&lt;/code&gt;&lt;/a&gt; for authorizing requests with AppAuth.&lt;/p&gt; &#xA;&lt;p&gt;GTMAppAuth is an alternative authorizer to &lt;a href=&#34;https://github.com/google/gtm-oauth2&#34;&gt;GTMOAuth2&lt;/a&gt; . The key differentiator is the use of the user&#39;s default browser for the authorization, which is more secure, more usable (the user&#39;s session can be reused) and follows modern OAuth &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc8252&#34;&gt;best practices for native apps&lt;/a&gt;. Compatibility methods for GTMOAuth2 are offered allowing you to migrate from GTMOAuth2 to GTMAppAuth preserving previously serialized authorizations (so users shouldn&#39;t need to re-authenticate).&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://guides.cocoapods.org/using/getting-started.html&#34;&gt;CocoaPods&lt;/a&gt;, simply add:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;GTMAppAuth&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To your &lt;code&gt;Podfile&lt;/code&gt; and run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;To configure GTMAppAuth with the OAuth endpoints for Google, you can use the convenience method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;OIDServiceConfiguration *configuration =&#xA;    [GTMAppAuthFetcherAuthorization configurationForGoogle];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can configure GTMAppAuth by specifying the endpoints directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *authorizationEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://accounts.google.com/o/oauth2/v2/auth&#34;];&#xA;NSURL *tokenEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://www.googleapis.com/oauth2/v4/token&#34;];&#xA;&#xA;OIDServiceConfiguration *configuration =&#xA;    [[OIDServiceConfiguration alloc]&#xA;        initWithAuthorizationEndpoint:authorizationEndpoint&#xA;                        tokenEndpoint:tokenEndpoint];&#xA;&#xA;// perform the auth request...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or through discovery:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *issuer = [NSURL URLWithString:@&#34;https://accounts.google.com&#34;];&#xA;&#xA;[OIDAuthorizationService discoverServiceConfigurationForIssuer:issuer&#xA;    completion:^(OIDServiceConfiguration *_Nullable configuration,&#xA;                 NSError *_Nullable error) {&#xA;  if (!configuration) {&#xA;    NSLog(@&#34;Error retrieving discovery document: %@&#34;,&#xA;          [error localizedDescription]);&#xA;    return;&#xA;  }&#xA;&#xA;  // perform the auth request...&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorizing&lt;/h3&gt; &#xA;&lt;p&gt;First, you need to have a way for your UIApplicationDelegate to continue the authorization flow session from the incoming redirect URI. Typically you could store the in-progress OIDAuthorizationFlowSession instance in a property:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// property of the app&#39;s UIApplicationDelegate&#xA;@property(nonatomic, nullable)&#xA;    id&amp;lt;OIDExternalUserAgentSession&amp;gt; currentAuthorizationFlow;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And in a location accessible by all controllers that need authorization, a property to store the authorization state:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// property of the containing class&#xA;@property(nonatomic, nullable) GTMAppAuthFetcherAuthorization *authorization;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, initiate the authorization request. By using the &lt;code&gt;authStateByPresentingAuthorizationRequest&lt;/code&gt; method, the OAuth token exchange will be performed automatically, and everything will be protected with PKCE (if the server supports it).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// builds authentication request&#xA;OIDAuthorizationRequest *request =&#xA;    [[OIDAuthorizationRequest alloc] initWithConfiguration:configuration&#xA;                                                  clientId:kClientID&#xA;                                              clientSecret:kClientSecret&#xA;                                                    scopes:@[OIDScopeOpenID, OIDScopeProfile]&#xA;                                               redirectURL:redirectURI&#xA;                                              responseType:OIDResponseTypeCode&#xA;                                      additionalParameters:nil];&#xA;// performs authentication request&#xA;self.appDelegate.currentAuthorizationFlow =&#xA;    [OIDAuthState authStateByPresentingAuthorizationRequest:request&#xA;        callback:^(OIDAuthState *_Nullable authState,&#xA;                   NSError *_Nullable error) {&#xA;  if (authState) {&#xA;    // Creates the GTMAppAuthFetcherAuthorization from the OIDAuthState.&#xA;    GTMAppAuthFetcherAuthorization *authorization =&#xA;        [[GTMAppAuthFetcherAuthorization alloc] initWithAuthState:authState];&#xA;&#xA;    self.authorization = authorization;&#xA;    NSLog(@&#34;Got authorization tokens. Access token: %@&#34;,&#xA;          authState.lastTokenResponse.accessToken);&#xA;  } else {&#xA;    NSLog(@&#34;Authorization error: %@&#34;, [error localizedDescription]);&#xA;    self.authorization = nil;&#xA;  }&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handling the Redirect&lt;/h3&gt; &#xA;&lt;p&gt;The authorization response URL is returned to the app via the platform-specific application delegate method, so you need to pipe this through to the current authorization session (created in the previous session).&lt;/p&gt; &#xA;&lt;h4&gt;macOS Custom URI Scheme Redirect Example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {&#xA;  // Other app initialization code ...&#xA;&#xA;  // Register for GetURL events.&#xA;  NSAppleEventManager *appleEventManager =&#xA;      [NSAppleEventManager sharedAppleEventManager];&#xA;  [appleEventManager setEventHandler:self&#xA;                         andSelector:@selector(handleGetURLEvent:withReplyEvent:)&#xA;                       forEventClass:kInternetEventClass&#xA;                          andEventID:kAEGetURL];&#xA;}&#xA;&#xA;- (void)handleGetURLEvent:(NSAppleEventDescriptor *)event&#xA;           withReplyEvent:(NSAppleEventDescriptor *)replyEvent {&#xA;  NSString *URLString = [[event paramDescriptorForKeyword:keyDirectObject] stringValue];&#xA;  NSURL *URL = [NSURL URLWithString:URLString];&#xA;  [_currentAuthorizationFlow resumeExternalUserAgentFlowWithURL:URL];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;iOS Custom URI Scheme Redirect Example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (BOOL)application:(UIApplication *)app&#xA;            openURL:(NSURL *)url&#xA;            options:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)options {&#xA;  // Sends the URL to the current authorization flow (if any) which will&#xA;  // process it if it relates to an authorization response.&#xA;  if ([_currentAuthorizationFlow resumeExternalUserAgentFlowWithURL:url]) {&#xA;    _currentAuthorizationFlow = nil;&#xA;    return YES;&#xA;  }&#xA;&#xA;  // Your additional URL handling (if any) goes here.&#xA;&#xA;  return NO;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Making API Calls&lt;/h3&gt; &#xA;&lt;p&gt;The goal of GTMAppAuth is to enable you to authorize HTTP requests with fresh tokens following the Session Fetcher pattern, which you can do like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Creates a GTMSessionFetcherService with the authorization.&#xA;// Normally you would save this service object and re-use it for all REST API calls.&#xA;GTMSessionFetcherService *fetcherService = [[GTMSessionFetcherService alloc] init];&#xA;fetcherService.authorizer = self.authorization;&#xA;&#xA;// Creates a fetcher for the API call.&#xA;NSURL *userinfoEndpoint = [NSURL URLWithString:@&#34;https://www.googleapis.com/oauth2/v3/userinfo&#34;];&#xA;GTMSessionFetcher *fetcher = [fetcherService fetcherWithURL:userinfoEndpoint];&#xA;[fetcher beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {&#xA;  // Checks for an error.&#xA;  if (error) {&#xA;    // OIDOAuthTokenErrorDomain indicates an issue with the authorization.&#xA;    if ([error.domain isEqual:OIDOAuthTokenErrorDomain]) {&#xA;      self.authorization = nil;&#xA;      NSLog(@&#34;Authorization error during token refresh, clearing state. %@&#34;,&#xA;            error);&#xA;    // Other errors are assumed transient.&#xA;    } else {&#xA;      NSLog(@&#34;Transient error during token refresh. %@&#34;, error);&#xA;    }&#xA;    return;&#xA;  }&#xA;&#xA;  // Parses the JSON response.&#xA;  NSError *jsonError = nil;&#xA;  id jsonDictionaryOrArray =&#xA;      [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;amp;jsonError];&#xA;&#xA;  // JSON error.&#xA;  if (jsonError) {&#xA;    NSLog(@&#34;JSON decoding error %@&#34;, jsonError);&#xA;    return;&#xA;  }&#xA;&#xA;  // Success response!&#xA;  NSLog(@&#34;Success: %@&#34;, jsonDictionaryOrArray);&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Saving to the Keychain&lt;/h3&gt; &#xA;&lt;p&gt;You can easily save &lt;code&gt;GTMAppAuthFetcherAuthorization&lt;/code&gt; instances to the Keychain using the included &lt;code&gt;GTMAppAuthFetcherAuthorization+Keychain&lt;/code&gt; category.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Save to Keychain&#xA;[GTMAppAuthFetcherAuthorization saveAuthorization:_authorization&#xA;                                toKeychainForName:kGTMAppAuthExampleAuthorizerKey];&#xA;&#xA;// Restore from Keychain&#xA;GTMAppAuthFetcherAuthorization* authorization =&#xA;    [GTMAppAuthFetcherAuthorization authorizationFromKeychainForName:kGTMAppAuthExampleAuthorizerKey];&#xA;&#xA;// Remove from Keychain&#xA;[GTMAppAuthFetcherAuthorization&#xA;    removeAuthorizationFromKeychainForName:kGTMAppAuthExampleAuthorizerKey];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Keychain Storage&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;GTMAppAuthFetcherAuthorization&lt;/code&gt; instances are stored using Keychain items of the &lt;a href=&#34;https://developer.apple.com/documentation/security/ksecclassgenericpassword?language=objc&#34;&gt;&lt;code&gt;kSecClassGenericPassword&lt;/code&gt;&lt;/a&gt; class with a &lt;a href=&#34;https://developer.apple.com/documentation/security/ksecattraccount?language=objc&#34;&gt;&lt;code&gt;kSecAttrAccount&lt;/code&gt;&lt;/a&gt; value of &#34;OAuth&#34; and a developer supplied value for &lt;a href=&#34;https://developer.apple.com/documentation/security/ksecattrservice?language=objc&#34;&gt;&lt;code&gt;kSecAttrService&lt;/code&gt;&lt;/a&gt;. For this use of generic password items, the combination of account and service values acts as the &lt;a href=&#34;https://developer.apple.com/documentation/security/1542001-security_framework_result_codes/errsecduplicateitem?language=objc&#34;&gt;primary key&lt;/a&gt; of the Keychain items. The &lt;a href=&#34;https://developer.apple.com/documentation/security/ksecattraccessible?language=objc&#34;&gt;&lt;code&gt;kSecAttrAccessible&lt;/code&gt;&lt;/a&gt; key is set to &lt;a href=&#34;https://developer.apple.com/documentation/security/ksecattraccessibleafterfirstunlockthisdeviceonly?language=objc&#34;&gt;&lt;code&gt;kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly&lt;/code&gt;&lt;/a&gt; in order to allow background access after initial device unlock following a restart. A &lt;a href=&#34;https://developer.apple.com/documentation/foundation/nskeyedarchiver?language=objc&#34;&gt;keyed archive&lt;/a&gt; representation of the relevant &lt;code&gt;GTMAppAuthFetcherAuthorization&lt;/code&gt; instance is supplied as the value for &lt;a href=&#34;https://developer.apple.com/documentation/security/ksecvaluedata?language=objc&#34;&gt;&lt;code&gt;kSecValueData&lt;/code&gt;&lt;/a&gt; and this is encrypted and stored by &lt;a href=&#34;https://developer.apple.com/documentation/security/keychain_services?language=objc&#34;&gt;Keychain Services&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For macOS, two Keychain storage options are available: the traditional file-based Keychain storage which uses access control lists and the more modern &lt;a href=&#34;https://developer.apple.com/documentation/security/ksecusedataprotectionkeychain?language=objc&#34;&gt;data protection keychain storage&lt;/a&gt; which uses Keychain access control groups. By default, GTMAppAuth uses the file-based Keychain storage on macOS. You may opt into using data protection keychain storage by using the parameter &lt;code&gt;useDataProtectionKeychain:YES&lt;/code&gt; in your method calls. Note that Keychain items stored via one storage type will not be available via the other and macOS apps that choose to use the data protection Keychain will need to be signed in order for Keychain operations to succeed.&lt;/p&gt; &#xA;&lt;h4&gt;GTMOAuth2 Compatibility&lt;/h4&gt; &#xA;&lt;p&gt;To assist the migration from GTMOAuth2 to GTMAppAuth, GTMOAuth2-compatible Keychain methods are provided in &lt;code&gt;GTMOAuth2KeychainCompatibility&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Restore from Keychain&#xA;GTMAppAuthFetcherAuthorization *auth =&#xA;    [GTMOAuth2KeychainCompatibility authForGoogleFromKeychainForName:kKeychainItemName&#xA;                                                            clientID:clientID&#xA;                                                        clientSecret:clientSecret];&#xA;&#xA;// Remove from Keychain&#xA;[GTMOAuth2KeychainCompatibility removeAuthFromKeychainForName:kKeychainItemName];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also save to GTMOAuth2 format, though this is discouraged (you should save in GTMAppAuth format as described above).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Save to Keychain&#xA;[GTMOAuth2KeychainCompatibility saveAuthToKeychainForName:kKeychainItemName&#xA;                                           authentication:authorization];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Included Samples&lt;/h2&gt; &#xA;&lt;p&gt;Try out one of the included sample apps under &lt;a href=&#34;https://raw.githubusercontent.com/google/GTMAppAuth/master/Examples&#34;&gt;Examples&lt;/a&gt;. In the apps folder run &lt;code&gt;pod install&lt;/code&gt;, then open the resulting &lt;code&gt;xcworkspace&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;Be sure to follow the instructions in &lt;a href=&#34;https://raw.githubusercontent.com/google/GTMAppAuth/master/Examples/Example-iOS/README.md&#34;&gt;Example-iOS/README.md&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/google/GTMAppAuth/master/Examples/Example-macOS/README.md&#34;&gt;Example-macOS/README.md&lt;/a&gt; to configure your own OAuth client ID for use with the example.&lt;/p&gt; &#xA;&lt;h2&gt;Differences with GTMOAuth2&lt;/h2&gt; &#xA;&lt;h3&gt;Authorization Method&lt;/h3&gt; &#xA;&lt;p&gt;GTMAppAuth uses the browser to present the authorization request, while GTMOAuth2 uses an embedded web-view. Migrating to GTMAppAuth will require you to change how you authorize the user. Follow the instructions above to get the authorization. You can then create a &lt;code&gt;GTMAppAuthFetcherAuthorization&lt;/code&gt; object with the &lt;code&gt;initWithAuthState:authState&lt;/code&gt; initializer.&lt;/p&gt; &#xA;&lt;p&gt;Once you have the &lt;code&gt;GTMAppAuthFetcherAuthorization&lt;/code&gt; you can continue to make REST calls as before.&lt;/p&gt; &#xA;&lt;h3&gt;Error Handling&lt;/h3&gt; &#xA;&lt;p&gt;GTMAppAuth&#39;s error handling is also different. There are no notifications, instead you need to inspect NSError in the callback. If the error domain is &lt;code&gt;OIDOAuthTokenErrorDomain&lt;/code&gt;, it indicates an authorization error, you should clear your authorization state and consider prompting the user to authorize again. Other errors are generally considered transient, meaning that you should retry the request after a delay.&lt;/p&gt; &#xA;&lt;h3&gt;Serialization&lt;/h3&gt; &#xA;&lt;p&gt;The serialization format is different between GTMOAuth2 and GTMAppAuth, though we have methods to help you migrate from one to the other without losing any data.&lt;/p&gt; &#xA;&lt;h2&gt;Migrating from GTMOAuth2&lt;/h2&gt; &#xA;&lt;h3&gt;OAuth Client Registration&lt;/h3&gt; &#xA;&lt;p&gt;Typically, GTMOAuth2 clients are registered with Google as type &#34;Other&#34;. This is correct for macOS, but on iOS clients should be registered with the type &#34;iOS&#34;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re migrating an iOS client, in the &lt;em&gt;same project as your existing client&lt;/em&gt;, &lt;a href=&#34;https://console.developers.google.com/apis/credentials?project=_&#34;&gt;register a new iOS client&lt;/a&gt; to be used with GTMAppAuth.&lt;/p&gt; &#xA;&lt;h3&gt;Changing your Authorization Flows&lt;/h3&gt; &#xA;&lt;p&gt;Both GTMOAuth2 and GTMAppAuth support the &lt;code&gt;GTMFetcherAuthorizationProtocol&lt;/code&gt; allowing you to use the authorization with the session fetcher. Where you previously had a property like &lt;code&gt;GTMOAuth2Authentication *authorization&lt;/code&gt; change the type to reference the protocol instead, i.e.: &lt;code&gt;id&amp;lt;GTMFetcherAuthorizationProtocol&amp;gt; authorization&lt;/code&gt;. This allows you to switch the authorization implementation under the hood to GTMAppAuth.&lt;/p&gt; &#xA;&lt;p&gt;Then, follow the instructions above to replace authorization request (where you ask the user to grant access) with the GTMAppAuth approach. If you created a new OAuth client, use that for these requests.&lt;/p&gt; &#xA;&lt;h3&gt;Serialization &amp;amp; Migrating Existing Grants&lt;/h3&gt; &#xA;&lt;p&gt;GTMAppAuth has a new data format and APIs for serialization. Unlike GTMOAuth2, GTMAppAuth serializes the configuration and history of the authorization, including the client id, and a record of the authorization request that resulted in the authorization grant.&lt;/p&gt; &#xA;&lt;p&gt;The client ID used for GTMAppAuth is &lt;a href=&#34;https://raw.githubusercontent.com/google/GTMAppAuth/master/#oauth-client-registration&#34;&gt;different&lt;/a&gt; to the one used for GTMOAuth2. In order to keep track of the different client ids used for new and old grants, it&#39;s recommended to migrate to the new serialization format, which will store that for you. &lt;a href=&#34;https://raw.githubusercontent.com/google/GTMAppAuth/master/#gtmoauth2-compatible-serialization&#34;&gt;GTMOAuth2-compatible serialization&lt;/a&gt; is also offered, but not fully supported.&lt;/p&gt; &#xA;&lt;p&gt;Change how you serialize your &lt;code&gt;authorization&lt;/code&gt; object using the new methods using the following example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Serialize to Keychain&#xA;[GTMAppAuthFetcherAuthorization saveAuthorization:(GTMAppAuthFetcherAuthorization *)authorization&#xA;                                toKeychainForName:kNewKeychainName];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be sure to use a &lt;em&gt;new&lt;/em&gt; name for the keychain. Don&#39;t reuse your old one!&lt;/p&gt; &#xA;&lt;p&gt;For deserializing, we can preserve all existing grants (so users who authorized your app in GTMOAuth2 don&#39;t have to authorize it again). Remember that when deserializing the &lt;em&gt;old&lt;/em&gt; data you need to use your &lt;em&gt;old&lt;/em&gt; keychain name, and the old client id and client secret (if those changed), and that when serializing to the &lt;em&gt;new&lt;/em&gt; format, use the &lt;em&gt;new&lt;/em&gt; keychain name. Once again, pay particular care to use the old details when deserializing the GTMOAuth2 keychain, and the new details for all other GTMAppAuth calls.&lt;/p&gt; &#xA;&lt;p&gt;Keychain migration example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Attempt to deserialize from Keychain in GTMAppAuth format.&#xA;id&amp;lt;GTMFetcherAuthorizationProtocol&amp;gt; authorization =&#xA;    [GTMAppAuthFetcherAuthorization authorizationFromKeychainForName:kNewKeychainName];&#xA;&#xA;// If no data found in the new format, try to deserialize data from GTMOAuth2&#xA;if (!authorization) {&#xA;  // Tries to load the data serialized by GTMOAuth2 using old keychain name.&#xA;  // If you created a new client id, be sure to use the *previous* client id and secret here.&#xA;  authorization =&#xA;      [GTMOAuth2KeychainCompatibility authForGoogleFromKeychainForName:kPreviousKeychainName&#xA;                                                              clientID:kPreviousClientID&#xA;                                                          clientSecret:kPreviousClientSecret];&#xA;  if (authorization) {&#xA;    // Remove previously stored GTMOAuth2-formatted data.&#xA;    [GTMOAuth2KeychainCompatibility removeAuthFromKeychainForName:kPreviousKeychainName];&#xA;    // Serialize to Keychain in GTMAppAuth format.&#xA;    [GTMAppAuthFetcherAuthorization saveAuthorization:(GTMAppAuthFetcherAuthorization *)authorization&#xA;                                    toKeychainForName:kNewKeychainName];&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>