<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-04T01:36:30Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ptraeg/html5-in-mobile-apps</title>
    <updated>2023-09-04T01:36:30Z</updated>
    <id>tag:github.com,2023-09-04:/ptraeg/html5-in-mobile-apps</id>
    <link href="https://github.com/ptraeg/html5-in-mobile-apps" rel="alternate"></link>
    <summary type="html">&lt;p&gt;iOS and Android code examples for my HTML5 in mobile applications article&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;html5-in-mobile-apps&lt;/h1&gt; &#xA;&lt;p&gt;iOS and Android code examples for my HTML5 in mobile applications article&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Objective-Cloud/OCFWebServer</title>
    <updated>2023-09-04T01:36:30Z</updated>
    <id>tag:github.com,2023-09-04:/Objective-Cloud/OCFWebServer</id>
    <link href="https://github.com/Objective-Cloud/OCFWebServer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight, modern and asynchronous HTTP server written in Objective-C&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;OCFWebServer is a lightweight, modern and asynchronous HTTP (version 1.1) server. It was forked from &lt;a href=&#34;https://raw.github.com/swisspol/GCDWebServer&#34;&gt;GCDWebServer&lt;/a&gt; and modified to fit the needs of &lt;a href=&#34;http://objective-cloud.com&#34;&gt;Objective-Cloud.com&lt;/a&gt; and hopefully other people&#39;s needs as well.&lt;/p&gt; &#xA;&lt;h1&gt;Who is using OCFWebServer?&lt;/h1&gt; &#xA;&lt;p&gt;OCFWebServer is used by OCFWeb which is a framework for developing web applications with Objective-C. OCFWeb and OCFWebServer are both used by &lt;a href=&#34;http://objective-cloud.com&#34;&gt;Objective-Cloud.com&lt;/a&gt;. Are you using OCFWebServer as well? &lt;a href=&#34;mailto:team@objective-cloud.com&#34;&gt;Let us know&lt;/a&gt; and we will link your app/project right here.&lt;/p&gt; &#xA;&lt;h1&gt;Goals&lt;/h1&gt; &#xA;&lt;p&gt;OCFWebServer was developed to be used for Objective-Cloud.com. This does not mean that the goals we had while developing it are incompatible with the needs of developers of &lt;code&gt;regular&lt;/code&gt; apps. These are the goals we had in mind while working on OCFWebServer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Easy to use in your own application: Embedding OCFWebServer should be done with just a few lines of code.&lt;/li&gt; &#xA; &lt;li&gt;Be &lt;em&gt;truly&lt;/em&gt; asynchronous: Use GCD/dispatch_io everywhere and make it easy to let the user write asynchronous request handlers.&lt;/li&gt; &#xA; &lt;li&gt;Many concurrent requests: We wanted to be able to have a minimum of 128 concurrent requests per OCFWebServer instance. OCFWebServer can do more but out of the box is supports up to 128 concurrent requests. This is enough for &lt;a href=&#34;http://objective-cloud.com&#34;&gt;Objective-Cloud.com&lt;/a&gt; and probably also enough for your needs as well.&lt;/li&gt; &#xA; &lt;li&gt;Don&#39;t do everything: If you need a simple HTTP server in your app OCFWebServer is made for you. Please do not try to run an instance of OCFWebServer, publicly on the internet. Your machine will be hacked. At &lt;a href=&#34;http://objective-cloud.com&#34;&gt;Objective-Cloud.com&lt;/a&gt; we always have at least one proxy server in front of our instances of OCFWebServer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Examples and getting started&lt;/h1&gt; &#xA;&lt;p&gt;You can simply download the source code of OCFWebServer and add every header and implementation file to your own project.&lt;/p&gt; &#xA;&lt;p&gt;Remark: All of the following examples are adapted from the GCDWebServer README file and slightly modified to reflect the changes made by OCFWebServer. Some of the explaining texts have also been adopted. Credits: Pierre-Olivier Latour (Thank you so much Pierre!)&lt;/p&gt; &#xA;&lt;h2&gt;Example: Hello World&lt;/h2&gt; &#xA;&lt;p&gt;Setting up OCFWebServer is easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#import &#34;OCFWebServer.h&#34;&#xA;&#xA;int main(int argc, const char* argv[]) {&#xA;  @autoreleasepool {&#xA;    OCFWebServer *server = [OCFWebServer new];&#xA;    &#xA;    // Add a request handler for every possible GET request&#xA;    &#xA;    [server addDefaultHandlerForMethod:@&#34;GET&#34;&#xA;                          requestClass:[OCFWebServerRequest class]&#xA;                          processBlock:^void(OCFWebServerRequest *request) {&#xA;                                     &#xA;      // Create your response and pass it to respondWith(...) &#xA;      OCFWebServerResponse *response = [OCFWebServerDataResponse responseWithHTML:@&#34;Hello World&#34;];&#xA;      [request respondWith:response];&#xA;    }];&#xA;    &#xA;    // Run the server on port 8080&#xA;    [server runWithPort:8080];&#xA;&#x9; &#xA;  }&#xA;return EXIT_SUCCESS;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The example above assumes that you have a console based application. If you have a Cocoa or Cocoa Touch application then you might want to have a &lt;code&gt;@property (nonatomic, strong) OCFWebServer *server&lt;/code&gt; in one of your controllers and use one of the &lt;code&gt;start&lt;/code&gt; methods instead of &lt;code&gt;runWithPort:&lt;/code&gt;. If you pass &lt;code&gt;0&lt;/code&gt; as the port then OCFWebServer will automatically ask the operating system for a free port and use that.&lt;/p&gt; &#xA;&lt;h2&gt;Example: Redirects&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s an example handler that redirects &lt;code&gt;/&lt;/code&gt; to &lt;code&gt;/index.html&lt;/code&gt; using the convenience method on &#39;OCFWebServerResponse&#39; (it sets the HTTP status code and &#39;Location&#39; header automatically):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[self addHandlerForMethod:@&#34;GET&#34;&#xA;                     path:@&#34;/&#34;&#xA;             requestClass:[OCFWebServerRequest class]&#xA;         processBlock:^void(OCFWebServerRequest* request) {&#xA;  NSURL *toURL = [NSURL URLWithString:@&#34;index.html&#34; relativeToURL:request.URL];&#xA;  &#xA;  respondWith([OCFWebServerResponse responseWithRedirect:toURL&#xA;                                               permanent:NO]);&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example: Forms&lt;/h2&gt; &#xA;&lt;p&gt;To implement an HTTP form, you need a pair of handlers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The GET handler does not expect any body in the HTTP request and therefore uses the &#39;OCFWebServerRequest&#39; class. The handler generates a response containing a simple HTML form.&lt;/li&gt; &#xA; &lt;li&gt;The POST handler expects the form values to be in the body of the HTTP request and percent-encoded. Fortunately, OCFWebServer provides the request class &#39;OCFWebServerURLEncodedFormRequest&#39; which can automatically parse such bodies. The handler simply echoes back the value from the user submitted form.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here we go:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[server addHandlerForMethod:@&#34;GET&#34;&#xA;                       path:@&#34;/&#34;&#xA;               requestClass:[OCFWebServerRequest class]&#xA;               processBlock:^void(OCFWebServerRequest* request) {&#xA;&#xA;  NSString* html = @&#34;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt; \&#xA;                     &amp;lt;form name=\&#34;input\&#34; action=\&#34;/\&#34; \&#xA;                     method=\&#34;post\&#34; enctype=\&#34;application/x-www-form-urlencoded\&#34;&amp;gt; \&#xA;                     Value: &amp;lt;input type=\&#34;text\&#34; name=\&#34;value\&#34;&amp;gt; \&#xA;                     &amp;lt;input type=\&#34;submit\&#34; value=\&#34;Submit\&#34;&amp;gt; \&#xA;                     &amp;lt;/form&amp;gt; \&#xA;                     &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#34;;&#xA;                     &#xA;  [request respondWith:[OCFWebServerDataResponse responseWithHTML:html]];&#xA;}];&#xA;&#xA;[server addHandlerForMethod:@&#34;POST&#34;&#xA;                       path:@&#34;/&#34;&#xA;               requestClass:[OCFWebServerURLEncodedFormRequest class]&#xA;               processBlock:^void(OCFWebServerRequest* request) {&#xA;&#xA;  NSString *value = [(OCFWebServerURLEncodedFormRequest*)request arguments][@&#34;value&#34;];&#xA;  NSString* html = [NSString stringWithFormat:@&#34;&amp;lt;p&amp;gt;%@&amp;lt;/p&amp;gt;&#34;, value];&#xA;  &#xA;  [request respondWith:[OCFWebServerDataResponse responseWithHTML:html]];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Handlers&lt;/h1&gt; &#xA;&lt;p&gt;As shown in the examples, you can add more than one handler to an instance of OCFWebServer. The handlers are sorted and matched in a last in, first out fashion.&lt;/p&gt; &#xA;&lt;h1&gt;Requirements and Dependencies&lt;/h1&gt; &#xA;&lt;p&gt;OCFWebServer runs on&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OS X 10.8+&lt;/li&gt; &#xA; &lt;li&gt;iOS 6+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;and has no third party dependencies.&lt;/p&gt; &#xA;&lt;h1&gt;Notes&lt;/h1&gt; &#xA;&lt;p&gt;OCFWebServer is a fork of GCDWebServer. The author of GCDWebServer has done a fantastic job. That is why we picked GCDWebServer as the foundation for OCFWebServer. In the process of making Objective-Cloud.com we realized that GCDWebServer in an incompatible fashion in order to work better. That is why we have forked GCDWebServer and improved it. OCFWebServer is not inherently better than GCDWebServer. It is different.&lt;/p&gt; &#xA;&lt;p&gt;If you want to learn more about the architecture of OCFWebServer you can have a look at the &lt;a href=&#34;https://github.com/swisspol/GCDWebServer/raw/master/README.md&#34;&gt;README of GCDWebServer&lt;/a&gt;. OCFWebServer has almost the same architecture than GCDWebServer.&lt;/p&gt; &#xA;&lt;h2&gt;Asynchronous: Front to Back&lt;/h2&gt; &#xA;&lt;p&gt;In OCFWebServer your request handler does not have to return anything immediately. OCFWebServer will pass the request to your request handler. The request gives you access to a lot of HTTP request specific properties. Now it is your turn to compute a response. Once that is done you should let the request object know about your response by calling &lt;code&gt;-respondWith:&lt;/code&gt; (class: OCFRequest) and pass it the response. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[server addDefaultHandlerForMethod:@&#34;GET&#34;&#xA;                  requestClass:[OCFWebServerRequest class]&#xA;                  processBlock:^void(OCFWebServerRequest *request) {&#xA;  dispatch_async(myQueue, ^() {&#xA;      OCFWebServerDataResponse *response = [OCFWebServerDataResponse responseWithHTML:@&#34;Hello World&#34;];&#xA;      [request respondWith:response];&#xA;  });&#xA;}];  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see your request handler can do anything it wants. You do not have to call &lt;code&gt;dispatch_async&lt;/code&gt; but you can if you need to. Some APIs require you to do something asynchronously (NSURLConnection, XPC, â€¦).&lt;/p&gt; &#xA;&lt;p&gt;By the way: Migrating your GCDWebServer related code to OCFWebServer is very easy: Simply replace &lt;code&gt;return response;&lt;/code&gt; with &lt;code&gt;[request respondWith:response], return;&lt;/code&gt; and you are done.&lt;/p&gt; &#xA;&lt;h2&gt;Many concurrent requests&lt;/h2&gt; &#xA;&lt;p&gt;At the time of writing GCDWebServer can only handle 16 concurrent requests. You can increase that by changing a constant in GCDWebServer&#39;s source code but in OCFWebServer the default maximum number of concurrent request is automatically set to the maximum of what is possible. If you are running OS X and not fine tune the settings this will mean that OCFWebServer can handle up to 128 concurrent requests at a time. If you tune the settings of OS X then this value can be increased and we are already working on a better queuing system which should further increase the number of concurrent requests.&lt;/p&gt; &#xA;&lt;h2&gt;Modern code base&lt;/h2&gt; &#xA;&lt;p&gt;True: This is an implementation detail but important to mention. OCFWebServer is using ARC, dispatch objects (&lt;code&gt;OS_OBJECT_USE_OBJC&lt;/code&gt;), modern runtime and the existing code base of GCDWebServer has been cleaned up and made more POSIX compatible.&lt;/p&gt; &#xA;&lt;h2&gt;No support for &amp;lt; OS X 10.8 and &amp;lt; iOS 6&lt;/h2&gt; &#xA;&lt;p&gt;OCFWebServer does only support OS X 10.8+ and iOS 6+. If you want to use it on older versions of OS X/iOS then you should use GCDWebServer.&lt;/p&gt; &#xA;&lt;h1&gt;More Convenience&lt;/h1&gt; &#xA;&lt;p&gt;If you want even more convenience for your HTTP server related needs you should also have a look at OCFWeb. OCFWeb is a framework that let&#39;s you develop web applications in Objective-C. OCFWeb is using OCFWebServer internally and adds a lot of nice stuff to it like a template engine, nicer syntax for handlers and a lot more.&lt;/p&gt; &#xA;&lt;h1&gt;How to contribute&lt;/h1&gt; &#xA;&lt;p&gt;Development of OCFWebServer takes place on GitHub. If you find a bug, suspect a bug or have a question feel free to open an issue. Pull requests are very welcome and will be accepted as fast as possible.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;OCFWebServer is available under the New BSD License - just like GCDWebServer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This file belongs to the OCFWebServer project. &#xA;OCFWebServer is a fork of GCDWebServer (originally developed by&#xA;Pierre-Olivier Latour). &#xA;&#xA;We have forked GCDWebServer because we made extensive and &#xA;incompatible changes to it.&#xA;&#xA;Copyright (c) 2013, Christian Kienle / chris@objective-cloud.com&#xA;All rights reserved.&#xA;&#xA;Original Copyright Statement:&#xA;Copyright (c) 2012-2013, Pierre-Olivier Latour&#xA;All rights reserved.&#xA;&#xA;Redistribution and use in source and binary forms, with or without&#xA;modification, are permitted provided that the following conditions are met:&#xA;* Redistributions of source code must retain the above copyright&#xA;notice, this list of conditions and the following disclaimer.&#xA;* Redistributions in binary form must reproduce the above copyright&#xA;notice, this list of conditions and the following disclaimer in the&#xA;documentation and/or other materials provided with the distribution.&#xA;* Neither the name of the &amp;lt;organization&amp;gt; nor the&#xA;names of its contributors may be used to endorse or promote products&#xA;derived from this software without specific prior written permission.&#xA; &#xA;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND&#xA;ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED&#xA;WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&#xA;DISCLAIMED. IN NO EVENT SHALL &amp;lt;COPYRIGHT HOLDER&amp;gt; BE LIABLE FOR ANY&#xA;DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&#xA;(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;&#xA;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&#xA;ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&#xA;(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&#xA;SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>soffes/bully</title>
    <updated>2023-09-04T01:36:30Z</updated>
    <id>tag:github.com,2023-09-04:/soffes/bully</id>
    <link href="https://github.com/soffes/bully" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple Pusher Objective-C client&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Bully&lt;/h1&gt; &#xA;&lt;p&gt;Bully is a simple &lt;a href=&#34;http://pusher.com&#34;&gt;Pusher&lt;/a&gt; Objective-C client with some neat stuff.&lt;/p&gt; &#xA;&lt;h2&gt;Neat Stuff&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;This is a work in progress.&lt;/strong&gt; Presence channels and triggering events aren&#39;t supported yet. Proceed with caution. If you&#39;re looking for a full featured Objective-C client, checkout &lt;a href=&#34;https://github.com/lukeredpath/libPusher&#34;&gt;libPusher&lt;/a&gt; by &lt;a href=&#34;https://github.com/lukeredpath&#34;&gt;Luke Redpath&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Bully keeps track of all of your subscribed channels and bound events. If you disconnect (when your app enters the background, loses reachability, or whatever) and then reconnect, Bully will automatically resubscribe to all of your channels and bind your events. Currently monitoring reachability is up to you. I&#39;m considering moving this into Bully. If you call &lt;code&gt;[client connect]&lt;/code&gt; it will automatically connect to any channels previously connected.&lt;/p&gt; &#xA;&lt;p&gt;Bully is really simple. Since you can use it without CocoaPods, you can add it as a subproject to allow for easy debugging. You can of course use it with CocoaPods if that&#39;s more your style too.&lt;/p&gt; &#xA;&lt;p&gt;Bully tries to mirror the &lt;a href=&#34;http://pusher.com/docs/client_api_guide&#34;&gt;Pusher JavaScript library&lt;/a&gt;&#39;s API as much as possible. Things are a bit more verbose to match the Objective-C style, but it&#39;s still pretty short.&lt;/p&gt; &#xA;&lt;h2&gt;Example Usage&lt;/h2&gt; &#xA;&lt;h4&gt;Import the headers&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &amp;lt;Bully/Bully.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Simple as that.&lt;/p&gt; &#xA;&lt;h4&gt;Creating a client&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;BLYClient *client = [[BLYClient alloc] initWithAppKey:@&#34;YOUR_PUSHER_KEY&#34; delegate:self];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended that you set your client to an instance variable so it stays around and keeps its connection to Pusher open.&lt;/p&gt; &#xA;&lt;h4&gt;Subscribe to a channel&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;BLYChannel *chatChannel = [client subscribeToChannelWithName:@&#34;chat&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Bind to an event&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[chatChannel bindToEvent:@&#34;new-message&#34; block:^(id message) {&#xA;  // `message` is a dictionary of the Pusher message&#xA;  NSLog(@&#34;New message: %@&#34;, [message objectForKey:@&#34;text&#34;]);&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Subscribe to a private channel&lt;/h4&gt; &#xA;&lt;p&gt;Supply a &lt;code&gt;authenticationBlock&lt;/code&gt; when connecting to a private channel. This will get called whenever the channel connects so it can authenticate. If the client reconnects after losing reachability, it will call the &lt;code&gt;authenticationBlock&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;BLYChannel *userChannel = [client subscribeToChannelWithName:@&#34;private-user-42&#34; authenticationBlock:^(BLYChannel *channel) {&#xA;  // Hit your server to authenticate with `channel.authenticationParameters` or `channel.authenticationParametersData`&#xA;  // When you have the response, tell the channel so it can connect:&#xA;  [channel subscribeWithAuthentication:responseObject];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example using &lt;a href=&#34;https://github.com/afnetworking/afnetworking&#34;&gt;AFNetworking&lt;/a&gt;, but you can use whatever you want.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;BLYChannel *userChannel = [client subscribeToChannelWithName:@&#34;private-user-42&#34; authenticationBlock:^(BLYChannel *channel) {&#xA;  [[MyHTTPClient sharedClient] postPath:@&#34;/pusher/auth&#34; parameters:channel.authenticationParameters success:^(AFHTTPRequestOperation *operation, id responseObject) {&#xA;    [channel subscribeWithAuthentication:responseObject];&#xA;  } failure:^(AFHTTPRequestOperation *operation, NSError *error) {&#xA;    NSLog(@&#34;Failed to authorize Pusher channel: %@&#34;, error);&#xA;  }];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Adding to Your Project&lt;/h2&gt; &#xA;&lt;p&gt;This is a bit tedious since Apple doesn&#39;t allow for iOS frameworks (without hacks) or other easier ways of add dependencies to a project. You can use &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; instead if you prefer (see below).&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add Bully as a &lt;a href=&#34;http://schacon.github.com/git/user-manual.html#submodules&#34;&gt;git submodule&lt;/a&gt;. Here&#39;s how to add it as a submodule:&lt;/p&gt; &lt;p&gt;$ cd rootOfYourGitRepo $ git submodule add &lt;a href=&#34;https://github.com/samsoffes/bully.git&#34;&gt;https://github.com/samsoffes/bully.git&lt;/a&gt; Vendor/Bully $ git submodule update --init --recursive&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;Vendor/Bully/Bully.xcodeproj&lt;/code&gt; to your Xcode project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select your main Xcode project from the top of the sidebar in Xcode and then select the target you want to add Bully to.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select the &lt;em&gt;Build Phases&lt;/em&gt; tab.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Under the &lt;em&gt;Target Dependencies&lt;/em&gt; group, click the plus button, select &lt;em&gt;Bully&lt;/em&gt; from the menu, and choose &lt;em&gt;Add&lt;/em&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Under the &lt;em&gt;Link Binary With Libraries&lt;/em&gt; group, click the plus button, select &lt;code&gt;libBully.a&lt;/code&gt; from the menu, and choose &lt;em&gt;Add&lt;/em&gt;. Be sure you have &lt;code&gt;CFNetwork.framework&lt;/code&gt; added to your project as well. If you don&#39;t go ahead and add it too.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Choose the &lt;em&gt;Build Settings&lt;/em&gt; tab. Make sure &lt;em&gt;All&lt;/em&gt; in the top left of the bar under the tabs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;Vendor/Bully&lt;/code&gt; to &lt;em&gt;Header Search Path&lt;/em&gt;. Don&#39;t click the &lt;em&gt;Recursive&lt;/em&gt; checkbox and make sure you added it to &lt;em&gt;Header Search Path&lt;/em&gt; and &lt;strong&gt;not&lt;/strong&gt; &lt;em&gt;User Header Search Path&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;-all_load -ObjC&lt;/code&gt; to &lt;em&gt;Other Linker Flags&lt;/em&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;That&#39;s it. The annoying part is over. Now to the fun part.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;If you are using &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; then just add next line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;dependency &#39;Bully&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now run &lt;code&gt;pod install&lt;/code&gt; to install the dependency.&lt;/p&gt; &#xA;&lt;h2&gt;License &amp;amp; Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Bully is released under the &lt;a href=&#34;https://github.com/samsoffes/bully/raw/master/LICENSE&#34;&gt;MIT license&lt;/a&gt;, so do whatever you want to it.&lt;/p&gt; &#xA;&lt;p&gt;Bully uses &lt;a href=&#34;https://github.com/square/SocketRocket&#34;&gt;SocketRocket&lt;/a&gt; by &lt;a href=&#34;https://github.com/square&#34;&gt;Square&lt;/a&gt;, which is fantastic. Thanks to &lt;a href=&#34;http://pusher.com&#34;&gt;Pusher&lt;/a&gt; for being awesome.&lt;/p&gt;</summary>
  </entry>
</feed>