<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-10T01:48:31Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>google/google-api-objectivec-client-for-rest</title>
    <updated>2022-08-10T01:48:31Z</updated>
    <id>tag:github.com,2022-08-10:/google/google-api-objectivec-client-for-rest</id>
    <link href="https://github.com/google/google-api-objectivec-client-for-rest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Google APIs Client Library for Objective-C for REST&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Google APIs Client Library for Objective-C for REST&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Project site&lt;/strong&gt; &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest&#34;&gt;https://github.com/google/google-api-objectivec-client-for-rest&lt;/a&gt;&lt;br&gt; &lt;strong&gt;Discussion group&lt;/strong&gt; &lt;a href=&#34;http://groups.google.com/group/google-api-objectivec-client&#34;&gt;http://groups.google.com/group/google-api-objectivec-client&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest/actions/workflows/cocoapods.yml&#34;&gt;&lt;img src=&#34;https://github.com/google/google-api-objectivec-client-for-rest/actions/workflows/cocoapods.yml/badge.svg?branch=main&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest/actions/workflows/swiftpm.yml&#34;&gt;&lt;img src=&#34;https://github.com/google/google-api-objectivec-client-for-rest/actions/workflows/swiftpm.yml/badge.svg?branch=main&#34; alt=&#34;SwiftPM&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest/actions/workflows/service_generator.yml&#34;&gt;&lt;img src=&#34;https://github.com/google/google-api-objectivec-client-for-rest/actions/workflows/service_generator.yml/badge.svg?branch=main&#34; alt=&#34;ServiceGenerator&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Written by Google, this library is a flexible and efficient Objective-C framework for accessing JSON APIs.&lt;/p&gt; &#xA;&lt;p&gt;This is the recommended library for accessing JSON-based Google APIs for iOS, macOS, tvOS, and watchOS applications.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;To get started&lt;/strong&gt; with Google APIs and the Objective-C client library, please read &lt;a href=&#34;https://raw.githubusercontent.com/google/google-api-objectivec-client-for-rest/main/USING.md&#34;&gt;USING.md&lt;/a&gt; for detailed information. The &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest/tree/main/Examples&#34;&gt;example applications&lt;/a&gt; can also help answer some questions, but there isn&#39;t an example for every service as there are just to many services.&lt;/p&gt; &#xA;&lt;p&gt;Generated interfaces for Google APIs are in the &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest/tree/main/Sources/GeneratedServices&#34;&gt;GeneratedServices folder&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the pre generated classes included with the library, you can generate your own source for other services that have a &lt;a href=&#34;https://developers.google.com/discovery/v1/reference/apis#resource-representations&#34;&gt;discovery document&lt;/a&gt; by using the &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest/tree/main/Tools/ServiceGenerator&#34;&gt;ServiceGenerator&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you have a problem&lt;/strong&gt; or want a new feature to be included in the library, please join the &lt;a href=&#34;http://groups.google.com/group/google-api-objectivec-client&#34;&gt;discussion group&lt;/a&gt;. Be sure to include &lt;a href=&#34;https://raw.githubusercontent.com/google/google-api-objectivec-client-for-rest/main/USING.md#logging-http-server-traffic&#34;&gt;http logs&lt;/a&gt; for requests and responses when posting questions. Bugs may also be submitted on the &lt;a href=&#34;https://github.com/google/google-api-objectivec-client-for-rest/issues&#34;&gt;issues list&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Externally-included projects&lt;/strong&gt;: The library is built on top of code from the separate project &lt;a href=&#34;https://github.com/google/gtm-session-fetcher&#34;&gt;GTM Session Fetcher&lt;/a&gt;. To work with some remote services, it also needs &lt;a href=&#34;https://raw.githubusercontent.com/google/google-api-objectivec-client-for-rest/main/USING.md#authentication-and-authorization&#34;&gt;Authentication/Authorization&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Google Data APIs&lt;/strong&gt;: The much older library for XML-based APIs is &lt;a href=&#34;https://github.com/google/gdata-objectivec-client&#34;&gt;still available&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Other useful classes for Mac and iOS developers are available in the &lt;a href=&#34;https://github.com/google/google-toolbox-for-mac&#34;&gt;Google Toolbox for Mac&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ReactiveCocoa/ReactiveObjC</title>
    <updated>2022-08-10T01:48:31Z</updated>
    <id>tag:github.com,2022-08-10:/ReactiveCocoa/ReactiveObjC</id>
    <link href="https://github.com/ReactiveCocoa/ReactiveObjC" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The 2.x ReactiveCocoa Objective-C API: Streams of values over time&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ReactiveObjC&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: This is legacy introduction to the Objective-C ReactiveCocoa, which is now known as ReactiveObjC. For the updated version that uses Swift, please see &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt; or &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveSwift&#34;&gt;ReactiveSwift&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;ReactiveObjC (formally ReactiveCocoa or RAC) is an Objective-C framework inspired by &lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;Functional Reactive Programming&lt;/a&gt;. It provides APIs for &lt;strong&gt;composing and transforming streams of values&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re already familiar with functional reactive programming or know the basic premise of ReactiveObjC, check out the other documentation in this folder for a framework overview and more in-depth information about how it all works in practice.&lt;/p&gt; &#xA;&lt;h2&gt;New to ReactiveObjC?&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC is documented like crazy, and there&#39;s a wealth of introductory material available to explain what RAC is and how you can use it.&lt;/p&gt; &#xA;&lt;p&gt;If you want to learn more, we recommend these resources, roughly in order:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/#when-to-use-reactiveobjc&#34;&gt;When to use ReactiveObjC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/Documentation/FrameworkOverview.md&#34;&gt;Framework Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/Documentation/BasicOperators.md&#34;&gt;Basic Operators&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/ReactiveObjC/&#34;&gt;Header documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Previously answered &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/wiki&#34;&gt;Stack Overflow&lt;/a&gt; questions and &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/issues?labels=question&amp;amp;state=closed&#34;&gt;GitHub issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The rest of this folder&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://leanpub.com/iosfrp/&#34;&gt;Functional Reactive Programming on iOS&lt;/a&gt; (eBook)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you have any further questions, please feel free to &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveObjC/issues/new&#34;&gt;file an issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC is inspired by &lt;a href=&#34;http://blog.maybeapps.com/post/42894317939/input-and-output&#34;&gt;functional reactive programming&lt;/a&gt;. Rather than using mutable variables which are replaced and modified in-place, RAC provides signals (represented by &lt;code&gt;RACSignal&lt;/code&gt;) that capture present and future values.&lt;/p&gt; &#xA;&lt;p&gt;By chaining, combining, and reacting to signals, software can be written declaratively, without the need for code that continually observes and updates values.&lt;/p&gt; &#xA;&lt;p&gt;For example, a text field can be bound to the latest time, even as it changes, instead of using additional code that watches the clock and updates the text field every second. It works much like KVO, but with blocks instead of overriding &lt;code&gt;-observeValueForKeyPath:ofObject:change:context:&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Signals can also represent asynchronous operations, much like &lt;a href=&#34;http://en.wikipedia.org/wiki/Futures_and_promises&#34;&gt;futures and promises&lt;/a&gt;. This greatly simplifies asynchronous software, including networking code.&lt;/p&gt; &#xA;&lt;p&gt;One of the major advantages of RAC is that it provides a single, unified approach to dealing with asynchronous behaviors, including delegate methods, callback blocks, target-action mechanisms, notifications, and KVO.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a simple example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// When self.username changes, logs the new name to the console.&#xA;//&#xA;// RACObserve(self, username) creates a new RACSignal that sends the current&#xA;// value of self.username, then the new value whenever it changes.&#xA;// -subscribeNext: will execute the block whenever the signal sends a value.&#xA;[RACObserve(self, username) subscribeNext:^(NSString *newName) {&#xA;&#x9;NSLog(@&#34;%@&#34;, newName);&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But unlike KVO notifications, signals can be chained together and operated on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Only logs names that starts with &#34;j&#34;.&#xA;//&#xA;// -filter returns a new RACSignal that only sends a new value when its block&#xA;// returns YES.&#xA;[[RACObserve(self, username)&#xA;&#x9;filter:^(NSString *newName) {&#xA;&#x9;&#x9;return [newName hasPrefix:@&#34;j&#34;];&#xA;&#x9;}]&#xA;&#x9;subscribeNext:^(NSString *newName) {&#xA;&#x9;&#x9;NSLog(@&#34;%@&#34;, newName);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can also be used to derive state. Instead of observing properties and setting other properties in response to the new values, RAC makes it possible to express properties in terms of signals and operations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Creates a one-way binding so that self.createEnabled will be&#xA;// true whenever self.password and self.passwordConfirmation&#xA;// are equal.&#xA;//&#xA;// RAC() is a macro that makes the binding look nicer.&#xA;//&#xA;// +combineLatest:reduce: takes an array of signals, executes the block with the&#xA;// latest value from each signal whenever any of them changes, and returns a new&#xA;// RACSignal that sends the return value of that block as values.&#xA;RAC(self, createEnabled) = [RACSignal&#xA;&#x9;combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ]&#xA;&#x9;reduce:^(NSString *password, NSString *passwordConfirm) {&#xA;&#x9;&#x9;return @([passwordConfirm isEqualToString:password]);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can be built on any stream of values over time, not just KVO. For example, they can also represent button presses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Logs a message whenever the button is pressed.&#xA;//&#xA;// RACCommand creates signals to represent UI actions. Each signal can&#xA;// represent a button press, for example, and have additional work associated&#xA;// with it.&#xA;//&#xA;// -rac_command is an addition to NSButton. The button will send itself on that&#xA;// command whenever it&#39;s pressed.&#xA;self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {&#xA;&#x9;NSLog(@&#34;button was pressed!&#34;);&#xA;&#x9;return [RACSignal empty];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or asynchronous network operations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Hooks up a &#34;Log in&#34; button to log in over the network.&#xA;//&#xA;// This block will be run whenever the login command is executed, starting&#xA;// the login process.&#xA;self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {&#xA;&#x9;// The hypothetical -logIn method returns a signal that sends a value when&#xA;&#x9;// the network request finishes.&#xA;&#x9;return [client logIn];&#xA;}];&#xA;&#xA;// -executionSignals returns a signal that includes the signals returned from&#xA;// the above block, one for each time the command is executed.&#xA;[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {&#xA;&#x9;// Log a message whenever we log in successfully.&#xA;&#x9;[loginSignal subscribeCompleted:^{&#xA;&#x9;&#x9;NSLog(@&#34;Logged in successfully!&#34;);&#xA;&#x9;}];&#xA;}];&#xA;&#xA;// Executes the login command when the button is pressed.&#xA;self.loginButton.rac_command = self.loginCommand;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can also represent timers, other UI events, or anything else that changes over time.&lt;/p&gt; &#xA;&lt;p&gt;Using signals for asynchronous operations makes it possible to build up more complex behavior by chaining and transforming those signals. Work can easily be triggered after a group of operations completes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Performs 2 network operations and logs a message to the console when they are&#xA;// both completed.&#xA;//&#xA;// +merge: takes an array of signals and returns a new RACSignal that passes&#xA;// through the values of all of the signals and completes when all of the&#xA;// signals complete.&#xA;//&#xA;// -subscribeCompleted: will execute the block when the signal completes.&#xA;[[RACSignal&#xA;&#x9;merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]&#xA;&#x9;subscribeCompleted:^{&#xA;&#x9;&#x9;NSLog(@&#34;They&#39;re both done!&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can be chained to sequentially execute asynchronous operations, instead of nesting callbacks with blocks. This is similar to how &lt;a href=&#34;http://en.wikipedia.org/wiki/Futures_and_promises&#34;&gt;futures and promises&lt;/a&gt; are usually used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Logs in the user, then loads any cached messages, then fetches the remaining&#xA;// messages from the server. After that&#39;s all done, logs a message to the&#xA;// console.&#xA;//&#xA;// The hypothetical -logInUser methods returns a signal that completes after&#xA;// logging in.&#xA;//&#xA;// -flattenMap: will execute its block whenever the signal sends a value, and&#xA;// returns a new RACSignal that merges all of the signals returned from the block&#xA;// into a single signal.&#xA;[[[[client&#xA;&#x9;logInUser]&#xA;&#x9;flattenMap:^(User *user) {&#xA;&#x9;&#x9;// Return a signal that loads cached messages for the user.&#xA;&#x9;&#x9;return [client loadCachedMessagesForUser:user];&#xA;&#x9;}]&#xA;&#x9;flattenMap:^(NSArray *messages) {&#xA;&#x9;&#x9;// Return a signal that fetches any remaining messages.&#xA;&#x9;&#x9;return [client fetchMessagesAfterMessage:messages.lastObject];&#xA;&#x9;}]&#xA;&#x9;subscribeNext:^(NSArray *newMessages) {&#xA;&#x9;&#x9;NSLog(@&#34;New messages: %@&#34;, newMessages);&#xA;&#x9;} completed:^{&#xA;&#x9;&#x9;NSLog(@&#34;Fetched all messages.&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;RAC even makes it easy to bind to the result of an asynchronous operation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Creates a one-way binding so that self.imageView.image will be set as the user&#39;s&#xA;// avatar as soon as it&#39;s downloaded.&#xA;//&#xA;// The hypothetical -fetchUserWithUsername: method returns a signal which sends&#xA;// the user.&#xA;//&#xA;// -deliverOn: creates new signals that will do their work on other queues. In&#xA;// this example, it&#39;s used to move work to a background queue and then back to the main thread.&#xA;//&#xA;// -map: calls its block with each user that&#39;s fetched and returns a new&#xA;// RACSignal that sends values returned from the block.&#xA;RAC(self.imageView, image) = [[[[client&#xA;&#x9;fetchUserWithUsername:@&#34;joshaber&#34;]&#xA;&#x9;deliverOn:[RACScheduler scheduler]]&#xA;&#x9;map:^(User *user) {&#xA;&#x9;&#x9;// Download the avatar (this is done on a background queue).&#xA;&#x9;&#x9;return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];&#xA;&#x9;}]&#xA;&#x9;// Now the assignment will be done on the main thread.&#xA;&#x9;deliverOn:RACScheduler.mainThreadScheduler];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That demonstrates some of what RAC can do, but it doesn&#39;t demonstrate why RAC is so powerful. It&#39;s hard to appreciate RAC from README-sized examples, but it makes it possible to write code with less state, less boilerplate, better code locality, and better expression of intent.&lt;/p&gt; &#xA;&lt;p&gt;For more sample code, check out &lt;a href=&#34;https://github.com/AshFurrow/C-41&#34;&gt;C-41&lt;/a&gt; or &lt;a href=&#34;https://github.com/jspahrsummers/GroceryList&#34;&gt;GroceryList&lt;/a&gt;, which are real iOS apps written using ReactiveObjC. Additional information about RAC can be found in this folder.&lt;/p&gt; &#xA;&lt;h2&gt;When to use ReactiveObjC&lt;/h2&gt; &#xA;&lt;p&gt;Upon first glance, ReactiveObjC is very abstract, and it can be difficult to understand how to apply it to concrete problems.&lt;/p&gt; &#xA;&lt;p&gt;Here are some of the use cases that RAC excels at.&lt;/p&gt; &#xA;&lt;h3&gt;Handling asynchronous or event-driven data sources&lt;/h3&gt; &#xA;&lt;p&gt;Much of Cocoa programming is focused on reacting to user events or changes in application state. Code that deals with such events can quickly become very complex and spaghetti-like, with lots of callbacks and state variables to handle ordering issues.&lt;/p&gt; &#xA;&lt;p&gt;Patterns that seem superficially different, like UI callbacks, network responses, and KVO notifications, actually have a lot in common. &lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/ReactiveOjC/RACSignal.h&#34;&gt;RACSignal&lt;/a&gt; unifies all these different APIs so that they can be composed together and manipulated in the same way.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;&#xA;static void *ObservationContext = &amp;amp;ObservationContext;&#xA;&#xA;- (void)viewDidLoad {&#xA;&#x9;[super viewDidLoad];&#xA;&#xA;&#x9;[LoginManager.sharedManager addObserver:self forKeyPath:@&#34;loggingIn&#34; options:NSKeyValueObservingOptionInitial context:&amp;amp;ObservationContext];&#xA;&#x9;[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];&#xA;&#xA;&#x9;[self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];&#xA;&#x9;[self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];&#xA;&#x9;[self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];&#xA;}&#xA;&#xA;- (void)dealloc {&#xA;&#x9;[LoginManager.sharedManager removeObserver:self forKeyPath:@&#34;loggingIn&#34; context:ObservationContext];&#xA;&#x9;[NSNotificationCenter.defaultCenter removeObserver:self];&#xA;}&#xA;&#xA;- (void)updateLogInButton {&#xA;&#x9;BOOL textFieldsNonEmpty = self.usernameTextField.text.length &amp;gt; 0 &amp;amp;&amp;amp; self.passwordTextField.text.length &amp;gt; 0;&#xA;&#x9;BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;amp;&amp;amp; !self.loggedIn;&#xA;&#x9;self.logInButton.enabled = textFieldsNonEmpty &amp;amp;&amp;amp; readyToLogIn;&#xA;}&#xA;&#xA;- (IBAction)logInPressed:(UIButton *)sender {&#xA;&#x9;[[LoginManager sharedManager]&#xA;&#x9;&#x9;logInWithUsername:self.usernameTextField.text&#xA;&#x9;&#x9;password:self.passwordTextField.text&#xA;&#x9;&#x9;success:^{&#xA;&#x9;&#x9;&#x9;self.loggedIn = YES;&#xA;&#x9;&#x9;} failure:^(NSError *error) {&#xA;&#x9;&#x9;&#x9;[self presentError:error];&#xA;&#x9;&#x9;}];&#xA;}&#xA;&#xA;- (void)loggedOut:(NSNotification *)notification {&#xA;&#x9;self.loggedIn = NO;&#xA;}&#xA;&#xA;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {&#xA;&#x9;if (context == ObservationContext) {&#xA;&#x9;&#x9;[self updateLogInButton];&#xA;&#x9;} else {&#xA;&#x9;&#x9;[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;â€¦&amp;nbsp;could be expressed in RAC like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)viewDidLoad {&#xA;&#x9;[super viewDidLoad];&#xA;&#xA;&#x9;@weakify(self);&#xA;&#xA;&#x9;RAC(self.logInButton, enabled) = [RACSignal&#xA;&#x9;&#x9;combineLatest:@[&#xA;&#x9;&#x9;&#x9;self.usernameTextField.rac_textSignal,&#xA;&#x9;&#x9;&#x9;self.passwordTextField.rac_textSignal,&#xA;&#x9;&#x9;&#x9;RACObserve(LoginManager.sharedManager, loggingIn),&#xA;&#x9;&#x9;&#x9;RACObserve(self, loggedIn)&#xA;&#x9;&#x9;] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {&#xA;&#x9;&#x9;&#x9;return @(username.length &amp;gt; 0 &amp;amp;&amp;amp; password.length &amp;gt; 0 &amp;amp;&amp;amp; !loggingIn.boolValue &amp;amp;&amp;amp; !loggedIn.boolValue);&#xA;&#x9;&#x9;}];&#xA;&#xA;&#x9;[[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) {&#xA;&#x9;&#x9;@strongify(self);&#xA;&#xA;&#x9;&#x9;RACSignal *loginSignal = [LoginManager.sharedManager&#xA;&#x9;&#x9;&#x9;logInWithUsername:self.usernameTextField.text&#xA;&#x9;&#x9;&#x9;password:self.passwordTextField.text];&#xA;&#xA;&#x9;&#x9;&#x9;[loginSignal subscribeError:^(NSError *error) {&#xA;&#x9;&#x9;&#x9;&#x9;@strongify(self);&#xA;&#x9;&#x9;&#x9;&#x9;[self presentError:error];&#xA;&#x9;&#x9;&#x9;} completed:^{&#xA;&#x9;&#x9;&#x9;&#x9;@strongify(self);&#xA;&#x9;&#x9;&#x9;&#x9;self.loggedIn = YES;&#xA;&#x9;&#x9;&#x9;}];&#xA;&#x9;}];&#xA;&#xA;&#x9;RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter&#xA;&#x9;&#x9;rac_addObserverForName:UserDidLogOutNotification object:nil]&#xA;&#x9;&#x9;mapReplace:@NO];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chaining dependent operations&lt;/h3&gt; &#xA;&lt;p&gt;Dependencies are most often found in network requests, where a previous request to the server needs to complete before the next one can be constructed, and so on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[client logInWithSuccess:^{&#xA;&#x9;[client loadCachedMessagesWithSuccess:^(NSArray *messages) {&#xA;&#x9;&#x9;[client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) {&#xA;&#x9;&#x9;&#x9;NSLog(@&#34;Fetched all messages.&#34;);&#xA;&#x9;&#x9;} failure:^(NSError *error) {&#xA;&#x9;&#x9;&#x9;[self presentError:error];&#xA;&#x9;&#x9;}];&#xA;&#x9;} failure:^(NSError *error) {&#xA;&#x9;&#x9;[self presentError:error];&#xA;&#x9;}];&#xA;} failure:^(NSError *error) {&#xA;&#x9;[self presentError:error];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ReactiveObjC makes this pattern particularly easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[[[[client logIn]&#xA;&#x9;then:^{&#xA;&#x9;&#x9;return [client loadCachedMessages];&#xA;&#x9;}]&#xA;&#x9;flattenMap:^(NSArray *messages) {&#xA;&#x9;&#x9;return [client fetchMessagesAfterMessage:messages.lastObject];&#xA;&#x9;}]&#xA;&#x9;subscribeError:^(NSError *error) {&#xA;&#x9;&#x9;[self presentError:error];&#xA;&#x9;} completed:^{&#xA;&#x9;&#x9;NSLog(@&#34;Fetched all messages.&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parallelizing independent work&lt;/h3&gt; &#xA;&lt;p&gt;Working with independent data sets in parallel and then combining them into a final result is non-trivial in Cocoa, and often involves a lot of synchronization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;__block NSArray *databaseObjects;&#xA;__block NSArray *fileContents;&#xA;&#xA;NSOperationQueue *backgroundQueue = [[NSOperationQueue alloc] init];&#xA;NSBlockOperation *databaseOperation = [NSBlockOperation blockOperationWithBlock:^{&#xA;&#x9;databaseObjects = [databaseClient fetchObjectsMatchingPredicate:predicate];&#xA;}];&#xA;&#xA;NSBlockOperation *filesOperation = [NSBlockOperation blockOperationWithBlock:^{&#xA;&#x9;NSMutableArray *filesInProgress = [NSMutableArray array];&#xA;&#x9;for (NSString *path in files) {&#xA;&#x9;&#x9;[filesInProgress addObject:[NSData dataWithContentsOfFile:path]];&#xA;&#x9;}&#xA;&#xA;&#x9;fileContents = [filesInProgress copy];&#xA;}];&#xA;&#xA;NSBlockOperation *finishOperation = [NSBlockOperation blockOperationWithBlock:^{&#xA;&#x9;[self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];&#xA;&#x9;NSLog(@&#34;Done processing&#34;);&#xA;}];&#xA;&#xA;[finishOperation addDependency:databaseOperation];&#xA;[finishOperation addDependency:filesOperation];&#xA;[backgroundQueue addOperation:databaseOperation];&#xA;[backgroundQueue addOperation:filesOperation];&#xA;[backgroundQueue addOperation:finishOperation];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code can be cleaned up and optimized by simply composing signals:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;RACSignal *databaseSignal = [[databaseClient&#xA;&#x9;fetchObjectsMatchingPredicate:predicate]&#xA;&#x9;subscribeOn:[RACScheduler scheduler]];&#xA;&#xA;RACSignal *fileSignal = [RACSignal startEagerlyWithScheduler:[RACScheduler scheduler] block:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {&#xA;&#x9;NSMutableArray *filesInProgress = [NSMutableArray array];&#xA;&#x9;for (NSString *path in files) {&#xA;&#x9;&#x9;[filesInProgress addObject:[NSData dataWithContentsOfFile:path]];&#xA;&#x9;}&#xA;&#xA;&#x9;[subscriber sendNext:[filesInProgress copy]];&#xA;&#x9;[subscriber sendCompleted];&#xA;}];&#xA;&#xA;[[RACSignal&#xA;&#x9;combineLatest:@[ databaseSignal, fileSignal ]&#xA;&#x9;reduce:^ id (NSArray *databaseObjects, NSArray *fileContents) {&#xA;&#x9;&#x9;[self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];&#xA;&#x9;&#x9;return nil;&#xA;&#x9;}]&#xA;&#x9;subscribeCompleted:^{&#xA;&#x9;&#x9;NSLog(@&#34;Done processing&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Simplifying collection transformations&lt;/h3&gt; &#xA;&lt;p&gt;Higher-order functions like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;/&lt;code&gt;reduce&lt;/code&gt; are sorely missing from Foundation, leading to loop-focused code like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSMutableArray *results = [NSMutableArray array];&#xA;for (NSString *str in strings) {&#xA;&#x9;if (str.length &amp;lt; 2) {&#xA;&#x9;&#x9;continue;&#xA;&#x9;}&#xA;&#xA;&#x9;NSString *newString = [str stringByAppendingString:@&#34;foobar&#34;];&#xA;&#x9;[results addObject:newString];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/ReactiveObjC/RACSequence.h&#34;&gt;RACSequence&lt;/a&gt; allows any Cocoa collection to be manipulated in a uniform and declarative way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;RACSequence *results = [[strings.rac_sequence&#xA;&#x9;filter:^ BOOL (NSString *str) {&#xA;&#x9;&#x9;return str.length &amp;gt;= 2;&#xA;&#x9;}]&#xA;&#x9;map:^(NSString *str) {&#xA;&#x9;&#x9;return [str stringByAppendingString:@&#34;foobar&#34;];&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;System Requirements&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC supports OS X 10.8+ and iOS 8.0+.&lt;/p&gt; &#xA;&lt;h2&gt;Importing ReactiveObjC&lt;/h2&gt; &#xA;&lt;p&gt;To add RAC to your application:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the ReactiveObjC repository as a submodule of your application&#39;s repository.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; from within the ReactiveObjC folder.&lt;/li&gt; &#xA; &lt;li&gt;Drag and drop &lt;code&gt;ReactiveObjC.xcodeproj&lt;/code&gt; into your application&#39;s Xcode project or workspace.&lt;/li&gt; &#xA; &lt;li&gt;On the &#34;Build Phases&#34; tab of your application target, add RAC to the &#34;Link Binary With Libraries&#34; phase.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;ReactiveObjC.framework&lt;/code&gt;. RAC must also be added to any &#34;Copy Frameworks&#34; build phase. If you don&#39;t already have one, simply add a &#34;Copy Files&#34; build phase and target the &#34;Frameworks&#34; destination.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;&#34;$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include&#34; $(inherited)&lt;/code&gt; to the &#34;Header Search Paths&#34; build setting (this is only necessary for archive builds, but it has no negative effect otherwise).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;For iOS targets&lt;/strong&gt;, add &lt;code&gt;-ObjC&lt;/code&gt; to the &#34;Other Linker Flags&#34; build setting.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;If you added RAC to a project (not a workspace)&lt;/strong&gt;, you will also need to add the appropriate RAC target to the &#34;Target Dependencies&#34; of your application.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To see a project already set up with RAC, check out &lt;a href=&#34;https://github.com/AshFurrow/C-41&#34;&gt;C-41&lt;/a&gt; or &lt;a href=&#34;https://github.com/jspahrsummers/GroceryList&#34;&gt;GroceryList&lt;/a&gt;, which are real iOS apps written using ReactiveObjC.&lt;/p&gt; &#xA;&lt;h2&gt;More Info&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC is inspired by .NET&#39;s &lt;a href=&#34;http://msdn.microsoft.com/en-us/data/gg577609&#34;&gt;Reactive Extensions&lt;/a&gt; (Rx). Most of the principles of Rx apply to RAC as well. There are some really good Rx resources out there:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh242985.aspx&#34;&gt;Reactive Extensions MSDN entry&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html&#34;&gt;Reactive Extensions for .NET Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://channel9.msdn.com/tags/Rx/&#34;&gt;Rx - Channel 9 videos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rxwiki.wikidot.com/&#34;&gt;Reactive Extensions wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rxwiki.wikidot.com/101samples&#34;&gt;101 Rx Samples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Programming-Reactive-Extensions-Jesse-Liberty/dp/1430237473&#34;&gt;Programming Reactive Extensions and LINQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;RAC and Rx are both frameworks inspired by functional reactive programming. Here are some resources related to FRP:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://elm-lang.org/learn/What-is-FRP.elm&#34;&gt;What is FRP? - Elm Language&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631&#34;&gt;What is Functional Reactive Programming - Stack Overflow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525&#34;&gt;Specification for a Functional Reactive Language - Stack Overflow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/reactive&#34;&gt;Principles of Reactive Programming on Coursera&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>nicklockwood/FXBlurView</title>
    <updated>2022-08-10T01:48:31Z</updated>
    <id>tag:github.com,2022-08-10:/nicklockwood/FXBlurView</id>
    <link href="https://github.com/nicklockwood/FXBlurView" rel="alternate"></link>
    <summary type="html">&lt;p&gt;[DEPRECATED]&lt;/p&gt;&lt;hr&gt;&lt;hr&gt; &#xA;&lt;h1&gt;WARNING: THIS PROJECT IS DEPRECATED&lt;/h1&gt; &#xA;&lt;p&gt;It will not receive any future updates or bug fixes. If you are using it, please migrate to another solution.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Purpose&lt;/h2&gt; &#xA;&lt;p&gt;FXBlurView is a UIView subclass that replicates the iOS 7 realtime background blur effect, but works on iOS 5 and above. It is designed to be as fast and as simple to use as possible. FXBlurView offers two modes of operation: static, where the view is rendered only once when it is added to a superview (though it can be updated by calling &lt;code&gt;setNeedsDisplay&lt;/code&gt; or &lt;code&gt;updateAsynchronously:completion:&lt;/code&gt;) or dynamic, where it will automatically redraw itself on a background thread as often as possible.&lt;/p&gt; &#xA;&lt;h2&gt;Supported iOS &amp;amp; SDK Versions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supported build target - iOS 8.4 (Xcode 6.4, Apple LLVM compiler 6.1)&lt;/li&gt; &#xA; &lt;li&gt;Earliest supported deployment target - iOS 7.0&lt;/li&gt; &#xA; &lt;li&gt;Earliest compatible deployment target - iOS 4.3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;NOTE: &#39;Supported&#39; means that the library has been tested with this version. &#39;Compatible&#39; means that the library should work on this iOS version (i.e. it doesn&#39;t rely on any unavailable SDK features) but is no longer being tested for compatibility and may require tweaking or bug fixes to run correctly.&lt;/p&gt; &#xA;&lt;h2&gt;ARC Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;As of version 1.3, FXBlurView requires ARC. If you wish to use FXBlurView in a non-ARC project, just add the -fobjc-arc compiler flag to the FXBlurView.m class. To do this, go to the Build Phases tab in your target settings, open the Compile Sources group, double-click FXBlurView.m in the list and type -fobjc-arc into the popover.&lt;/p&gt; &#xA;&lt;p&gt;If you wish to convert your whole project to ARC, comment out the #error line in FXBlurView.m, then run the Edit &amp;gt; Refactor &amp;gt; Convert to Objective-C ARC... tool in Xcode and make sure all files that you wish to use ARC for (including FXBlurView.m) are checked.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To use FXBlurView, just drag the class files into your project and add the Accelerate framework. You can create FXBlurView instances programatically, or create them in Interface Builder by dragging an ordinary UIView into your view and setting its class to FXBlurView.&lt;/p&gt; &#xA;&lt;p&gt;If you are using Interface Builder, to set the custom properties of FXBlurView (ones that are not supported by regular UIViews) either create an IBOutlet for your view and set the properties in code, or use the User Defined Runtime Attributes feature in Interface Builder (introduced in Xcode 4.2 for iOS 5+).&lt;/p&gt; &#xA;&lt;h2&gt;UIImage extensions&lt;/h2&gt; &#xA;&lt;p&gt;FXBlurView extends UIImage with the following method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- (UIImage *)blurredImageWithRadius:(CGFloat)radius&#xA;                         iterations:(NSUInteger)iterations&#xA;                          tintColor:(UIColor *)tintColor;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method applies a blur effect and returns the resultant blurred image without modifying the original. The radius property controls the extent of the blur effect. The iterations property controls the number of iterations. More iterations means higher quality. The tintColor is an optional color that will be blended with the resultant image. Note that the alpha component of the tintColor is ignored.&lt;/p&gt; &#xA;&lt;h2&gt;FXBlurView methods&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;+ (void)setBlurEnabled:(BOOL)blurEnabled;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method can be used to globally enable/disable the blur effect on all FXBlurView instances. This is useful for testing, or if you wish to disable blurring on iPhone 4 and below (for consistency with iOS7 blur view behavior). By default blurring is enabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;+ (void)setUpdatesEnabled;&#xA;+ (void)setUpdatesDisabled;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These methods can be used to enable and disable updates for all dynamic FXBlurView instances with a single command. Useful for disabling updates immediately before performing an animation so that the FXBlurView updates don&#39;t cause the animation to stutter. Calls can be nested, but ensure that the enabled/disabled calls are balanced, or the updates will be left permanently enabled or disabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- (void)updateAsynchronously:(BOOL)async completion:(void (^)())completion;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method can be used to trigger an update of the blur effect (useful when &lt;code&gt;dynamic = NO&lt;/code&gt;). The async argument controls whether the blur will be redrawn on the main thread or in the background. The completion argument is an optional callback block that will be called when the blur is completed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- (void)setNeedsDisplay;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inherited from UIView, this method can be used to trigger a (synchronous) update of the view. Calling this method is more-or-less equivalent to calling &lt;code&gt;[view updateAsynchronously:NO completion:NULL]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FXBlurView properties&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;@property (nonatomic, getter = isBlurEnabled) BOOL blurEnabled;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This property toggles blurring on and off for an individual FXBlurView instance. Blurring is enabled by default. Note that if you disable blurring using the &lt;code&gt;+setBlurEnabled&lt;/code&gt; method then that will override this setting.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@property (nonatomic, getter = isDynamic) BOOL dynamic;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This property controls whether the FXBlurView updates dynamically, or only once when the view is added to its superview. Defaults to YES. Note that if dynamic is set to NO, you can still force the view to update by calling &lt;code&gt;setNeedsDisplay&lt;/code&gt; or &lt;code&gt;updateAsynchronously:completion:&lt;/code&gt;. Dynamic blurring is extremely cpu-intensive, so you should always disable dynamic views immediately prior to performing an animation to avoid stuttering. However, if you have multiple FXBlurViews on screen then it is simpler to disable updates using the &lt;code&gt;setUpdatesDisabled&lt;/code&gt; method rather than setting the &lt;code&gt;dynamic&lt;/code&gt; property to NO.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@property (nonatomic, assign) NSUInteger iterations;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The number of blur iterations. More iterations improves the quality but reduces the performance. Defaults to 2 iterations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@property (nonatomic, assign) NSTimeInterval updateInterval;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This controls the interval (in seconds) between successive updates when the FXBlurView is operating in dynamic mode. This defaults to zero, which means that the FXBlurView will update as fast as possible. This yields the best frame rate, but is also extremely CPU intensive and may cause the rest of your app&#39;s performance to degrade, especially on older devices. To alleviate this, try increasing the &lt;code&gt;updateInterval&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@property (nonatomic, assign) CGFloat blurRadius;&#x9;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This property controls the radius of the blur effect (in points). Defaults to a 40 point radius, which is similar to the iOS 7 blur effect.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@property (nonatomic, strong) UIColor *tintColor;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This in an optional tint color to be applied to the FXBlurView. The RGB components of the color will be blended with the blurred image, resulting in a gentle tint. To vary the intensity of the tint effect, use brighter or darker colors. The alpha component of the tintColor is ignored. If you do not wish to apply a tint, set this value to nil or [UIColor clearColor]. Note that if you are using Xcode 5 or above, FXBlurViews created in Interface Builder will have a blue tint by default.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@property (nonatomic, weak) UIView *underlyingView;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This property specifies the view that the FXBlurView will sample to create the blur effect. If set to nil (the default), this will be the superview of the blur view itself, but you can override this if you need to.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Q. Why are my views all blue-tinted on iOS 7?&#xA;A. FXBlurView uses the `UIView` `tintColor` property, which does not exist on iOS 6 and below, but defaults to blue on iOS 7. Just set this property to `[UIColor clearColor]` to disable the tint. To retain iOS 6 compatibility, you can either set this using code, or by using the User Defined Runtime Attributes feature of Interface Builder, which will override the standard `tintColor` value (see the example project nibs for how to do this).&#xA;&#xA;Q. FXBlurView makes my whole app run slowly on [old device], what can I do?&#xA;A. To improve performance, try increasing the `updatePeriod` property, reducing the `iterations` property or disabling `dynamic` unless you really need it. If all else fails, set `blurEnabled` to NO on older devices.&#xA;&#xA;Q. My SpriteKit/OpenGL/Video/3D transformed content isn&#39;t showing up properly when placed underneath an FXBlurView, why not?&#xA;A. This is a limitation of a the `CALayer` `renderInContext:` method used to capture the view contents. There is no workaround for this on iOS 6 and earlier. On iOS 7 you can make use of the `UIView` `drawViewHierarchyInRect:afterScreenUpdates:` method to capture an view and apply the blur effect yourself, but this it too slow for realtime use, so FXBlurView does not use this method by default.&#xA;&#xA;Q. FXBlurView is not capturing some ordinary view content that is behind it, why not?&#xA;A. FXBlurView captures the contents of its immediate superview by default. If the superview is transparent or partially transparent, content shown behind it will not be captured. You can override the `underlyingView` property to capture the contents of a different view if you need to.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Release Notes&lt;/h2&gt; &#xA;&lt;p&gt;Version 1.6.4&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;blurredImageWithRadius:iterations:tintColor:&lt;/code&gt; now works if image is not in ARGB format&lt;/li&gt; &#xA; &lt;li&gt;Fixed &#34;&#xA;  &lt;error&gt;&#xA;   : CGContextRestoreGState: invalid context 0x0.&#34;&#xA;  &lt;/error&gt;&lt;/li&gt; &#xA; &lt;li&gt;Empty sublayers are now hidden before snapshotting to prevent renderInContext crash on iOS 8&lt;/li&gt; &#xA; &lt;li&gt;FXBlurView now automatically uses slower drawViewHierarchyInRect method when needed to capture content&lt;/li&gt; &#xA; &lt;li&gt;Added Travis integration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.6.3&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FXBlurView image background is no longer opaque/black, so it can be used as a translucent overlay&lt;/li&gt; &#xA; &lt;li&gt;underlyingView property is now an IBOutlet, so it can be connected in Interface Builder&lt;/li&gt; &#xA; &lt;li&gt;Moved imports into header for better Swift compatibility&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.6.2&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed crash on iOS 8 when animating blur&lt;/li&gt; &#xA; &lt;li&gt;Fixed issue when using FXBlurView with Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.6.1&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed issue with animation completion block not firing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.6&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is now possible to animate blurRadius&lt;/li&gt; &#xA; &lt;li&gt;Now requires QuartzCore framework&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.5.6&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed bug introduced in 1.5.4 where snapshot would always be taken from top-left corner of superview&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.5.5&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed zero-sized context warning in console when view has no presentationLayer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.5.4&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is now possible to animate the FXBlurView frame using ordinary UIView animations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.5.3&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed pixelation issue on non-Retina devices running iOS 6 or earlier&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.5.2&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed bug where edge of blur could be cropped short when using content modes other than scale to fit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.5.1&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed bug where completion handler was not called for synchronous blur.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.5&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added underlyingView property to specify source view&lt;/li&gt; &#xA; &lt;li&gt;Added updateAsynchronously:completion: method&lt;/li&gt; &#xA; &lt;li&gt;Fixed glitch with edges on certain views&lt;/li&gt; &#xA; &lt;li&gt;Now conforms to -Weverything warning level&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.4.4&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed pixelation issue on Retina iPads&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.4.3&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed error when compiling for iOS 6.1 SDK using Xcode 5&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.4.2&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed issue where shadow or ghosting could appear at edge of blur view&lt;/li&gt; &#xA; &lt;li&gt;Now conforms to -Wextra warning level&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.4.1&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed minor memory leak in the setUp method&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.4&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;More intelligent scheduling when multiple dynamic FXBlurView instances are shown on screen at once&lt;/li&gt; &#xA; &lt;li&gt;Added global and individual methods for disabling blur (e.g. so you can disable blur on iPhone 4 and below for consistency with other apps on iOS 7)&lt;/li&gt; &#xA; &lt;li&gt;Added Multiples views example&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.3.3&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed console warning when adding an FXBlurView of zero size to the window&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.3.2&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixed issue with pixelation on non-Retina devices&lt;/li&gt; &#xA; &lt;li&gt;Tweaked performance/quality tradeoff&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.3.1&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Improved blur quality (1.3 was slightly blocky)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.3&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added tintColor property&lt;/li&gt; &#xA; &lt;li&gt;Significant performance improvement by reducing snapshot scale based in proportion to blur radius&lt;/li&gt; &#xA; &lt;li&gt;Views placed in front of the FXBlurView in the hierarchy are no longer included in the blur effect&lt;/li&gt; &#xA; &lt;li&gt;Fixed issue where blurView was sometimes partially transparent&lt;/li&gt; &#xA; &lt;li&gt;Added example showing how to implement an iOS7 control center-style overlay&lt;/li&gt; &#xA; &lt;li&gt;FXBlurView now requires ARC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.2&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added +setUpdatesEnabled and +setUpdatesDisabled methods to globally enable/disable dynamic blur updates (e.g. when performing an animation)&lt;/li&gt; &#xA; &lt;li&gt;Added -updateInterval method to control CPU load when updating&lt;/li&gt; &#xA; &lt;li&gt;Changed runloop mode to reduce interference with scrolling, etc&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.1&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added ability to set number of blur iterations&lt;/li&gt; &#xA; &lt;li&gt;Fixed setNeedsDisplay behavior when dynamic = NO&lt;/li&gt; &#xA; &lt;li&gt;Reduced memory allocations in blur algorithm&lt;/li&gt; &#xA; &lt;li&gt;Added dynamic mode toggle to example app&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.0&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Initial release&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>