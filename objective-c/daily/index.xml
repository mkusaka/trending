<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-13T01:45:17Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xmartlabs/XLForm</title>
    <updated>2023-06-13T01:45:17Z</updated>
    <id>tag:github.com,2023-06-13:/xmartlabs/XLForm</id>
    <link href="https://github.com/xmartlabs/XLForm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;XLForm is the most flexible and powerful iOS library to create dynamic table-view forms. Fully compatible with Swift &amp; Obj-C.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/XLForm.png&#34; alt=&#34;XLForm&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/xmartlabs/XLForm&#34;&gt;&lt;img src=&#34;https://travis-ci.org/xmartlabs/XLForm.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/XLForm&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/XLForm.svg?sanitize=true&#34; alt=&#34;CocoaPods compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you are working in Swift then you should have a look at &lt;a href=&#34;https://github.com/xmartlabs/Eureka&#34;&gt;Eureka&lt;/a&gt;, a complete re-design of XLForm in Swift and with more features.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;We are not implementing any new features for XLForm anymore. However, if a critical issue arises we will fix it.&lt;/p&gt; &#xA;&lt;h2&gt;Purpose&lt;/h2&gt; &#xA;&lt;p&gt;XLForm is the most flexible and powerful iOS library to create dynamic table-view forms. The goal of the library is to get the same power of hand-made forms but spending 1/10 of the time.&lt;/p&gt; &#xA;&lt;p&gt;XLForm provides a very powerful DSL (Domain Specific Language) used to create a form. It keeps track of this specification on runtime, updating the UI on the fly.&lt;/p&gt; &#xA;&lt;h5&gt;Let&#39;s see the iOS Calendar Event Form created using XLForm&lt;/h5&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/RealExamples/XLForm.gif&#34; alt=&#34;Screenshot of native Calendar Event Example&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What XLForm does&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Loads a form based on a declarative &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#how-to-create-a-form&#34; title=&#34;form definition&#34;&gt;&lt;em&gt;form definition&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Keeps track of definition changes on runtime to update the form interface accordingly. Further information on &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#dynamic-forms---how-to-change-the-form-dynamically-at-runtime&#34; title=&#34;Dynamic Forms&#34;&gt;&lt;em&gt;Dynamic Forms&lt;/em&gt;&lt;/a&gt; section of this readme.&lt;/li&gt; &#xA; &lt;li&gt;Supports multivalued sections allowing us to create, delete or reorder rows. For further details see &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#multivalued-sections-insert-delete-reorder-rows&#34; title=&#34;Multivalued Sections&#34;&gt;&lt;em&gt;Multivalued Sections&lt;/em&gt;&lt;/a&gt; section bellow.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#how-to-create-a-custom-row&#34;&gt;&lt;em&gt;custom rows definition&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Supports custom selectors. For further details of how to define your own selectors check &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#custom-selectors---selector-row-with-a-custom-selector-view-controller&#34; title=&#34;Custom Selectors&#34;&gt;&lt;em&gt;Custom selectors&lt;/em&gt;&lt;/a&gt; section out.&lt;/li&gt; &#xA; &lt;li&gt;Provides several inline selectors such as date picker and picker inline selectors and brings a way to create custom inline selectors.&lt;/li&gt; &#xA; &lt;li&gt;Form data validation based on form definition.&lt;/li&gt; &#xA; &lt;li&gt;Ability to easily navigate among rows, fully customizable.&lt;/li&gt; &#xA; &lt;li&gt;Ability to show inputAccessoryView if needed. By default a navigation input accessory view is shown.&lt;/li&gt; &#xA; &lt;li&gt;Read only mode for a particular row or the entire form.&lt;/li&gt; &#xA; &lt;li&gt;Rows can be hidden or shown depending on other rows values. This can be done declaratively using &lt;code&gt;NSPredicates&lt;/code&gt;. (see &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#make-a-row-or-section-invisible-depending-on-other-rows-values&#34; title=&#34;Using Predicates&#34;&gt;&lt;em&gt;Make a row or section invisible depending on other rows values&lt;/em&gt;&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to create a form&lt;/h2&gt; &#xA;&lt;h4&gt;Create an instance of XLFormViewController&lt;/h4&gt; &#xA;&lt;h5&gt;Swift&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class CalendarEventFormViewController : XLFormViewController {&#xA;&#xA;  required init(coder aDecoder: NSCoder) {&#xA;    super.init(coder: aDecoder)&#xA;    self.initializeForm()&#xA;  }&#xA;&#xA;&#xA;  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) {&#xA;    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)&#xA;    self.initializeForm()&#xA;  }&#xA;&#xA;  func initializeForm() {&#xA;    // Implementation details covered in the next section.&#xA;  }&#xA;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Objective-C&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &#34;XLFormViewController.h&#34;&#xA;&#xA;@interface CalendarEventFormViewController: XLFormViewController&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@interface ExamplesFormViewController ()&#xA;&#xA;@end&#xA;&#xA;@implementation ExamplesFormViewController&#xA;&#xA;- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {&#xA;    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];&#xA;    if (self){&#xA;        [self initializeForm];&#xA;    }&#xA;    return self;&#xA;}&#xA;&#xA;- (id)initWithCoder:(NSCoder *)aDecoder {&#xA;    self = [super initWithCoder:aDecoder];&#xA;    if (self){&#xA;        [self initializeForm];&#xA;    }&#xA;    return self;&#xA;}&#xA;&#xA;- (void)initializeForm {&#xA;  // Implementation details covered in the next section.&#xA;}&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Implementing the initializeForm method&lt;/h5&gt; &#xA;&lt;p&gt;To create a form we should declare it through a &lt;code&gt;XLFormDescriptor&lt;/code&gt; instance and assign it to a &lt;code&gt;XLFormViewController&lt;/code&gt; instance. As we said XLForm works based on a DSL that hides complex and boilerplate stuff without losing the power and flexibility of hand-made forms.&lt;/p&gt; &#xA;&lt;p&gt;To define a form we use 3 classes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;XLFormDescriptor&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;XLFormSectionDescriptor&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;XLFormRowDescriptor&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A form definition is a &lt;code&gt;XLFormDescriptor&lt;/code&gt; instance that contains one or more sections (&lt;code&gt;XLFormSectionDescriptor&lt;/code&gt; instances) and each section contains several rows (&lt;code&gt;XLFormRowDescriptor&lt;/code&gt; instance). As you may have noticed the DSL structure is analog to the structure of a &lt;code&gt;UITableView&lt;/code&gt; (Table --&amp;gt;&amp;gt; Sections -- &amp;gt;&amp;gt; Rows). The resulting table-view form&#39;s structure (sections and rows order) mirrors the definition&#39;s structure.&lt;/p&gt; &#xA;&lt;h5&gt;Let&#39;s see an example implementation of initializeForm to define the iOS Calendar Event Form&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)initializeForm {&#xA;  XLFormDescriptor * form;&#xA;  XLFormSectionDescriptor * section;&#xA;  XLFormRowDescriptor * row;&#xA;&#xA;  form = [XLFormDescriptor formDescriptorWithTitle:@&#34;Add Event&#34;];&#xA;&#xA;  // First section&#xA;  section = [XLFormSectionDescriptor formSection];&#xA;  [form addFormSection:section];&#xA;&#xA;  // Title&#xA;  row = [XLFormRowDescriptor formRowDescriptorWithTag:@&#34;title&#34; rowType:XLFormRowDescriptorTypeText];&#xA;  [row.cellConfigAtConfigure setObject:@&#34;Title&#34; forKey:@&#34;textField.placeholder&#34;];&#xA;  [section addFormRow:row];&#xA;&#xA;  // Location&#xA;  row = [XLFormRowDescriptor formRowDescriptorWithTag:@&#34;location&#34; rowType:XLFormRowDescriptorTypeText];&#xA;  [row.cellConfigAtConfigure setObject:@&#34;Location&#34; forKey:@&#34;textField.placeholder&#34;];&#xA;  [section addFormRow:row];&#xA;&#xA;  // Second Section&#xA;  section = [XLFormSectionDescriptor formSection];&#xA;  [form addFormSection:section];&#xA;&#xA;  // All-day&#xA;  row = [XLFormRowDescriptor formRowDescriptorWithTag:@&#34;all-day&#34; rowType:XLFormRowDescriptorTypeBooleanSwitch title:@&#34;All-day&#34;];&#xA;  [section addFormRow:row];&#xA;&#xA;  // Starts&#xA;  row = [XLFormRowDescriptor formRowDescriptorWithTag:@&#34;starts&#34; rowType:XLFormRowDescriptorTypeDateTimeInline title:@&#34;Starts&#34;];&#xA;  row.value = [NSDate dateWithTimeIntervalSinceNow:60*60*24];&#xA;  [section addFormRow:row];&#xA;&#xA;  self.form = form;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;XLForm will load the table-view form from the previously explained definition. The most interesting part is that it will update the table-view form based on the form definition modifications. That means that we are able to make changes on the table-view form adding or removing section definitions or row definitions to the form definition on runtime and you will never need to care again about &lt;code&gt;NSIndexPath&lt;/code&gt;, &lt;code&gt;UITableViewDelegate&lt;/code&gt;, &lt;code&gt;UITableViewDataSource&lt;/code&gt; or other complexities.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;To see more complex form definitions take a look at the example application in the Examples folder of this repository. You can also run the examples on your own device if you wish.&lt;/strong&gt; XLForm &lt;strong&gt;has no&lt;/strong&gt; dependencies over other pods, anyway the examples project makes use of some cocoapods to show advanced XLForm features.&lt;/p&gt; &#xA;&lt;h2&gt;Using XLForm with Storyboards&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Perform the steps from &lt;strong&gt;How to create a form&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;In Interface Builder (IB), drag-and-drop a &lt;strong&gt;UIViewController&lt;/strong&gt; onto the Storyboard&lt;/li&gt; &#xA; &lt;li&gt;Associate your custom form class to the &lt;strong&gt;UIViewController&lt;/strong&gt; using the &lt;strong&gt;Identity Inspector&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to run XLForm examples&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the repository &lt;code&gt;git@github.com:xmartlabs/XLForm.git&lt;/code&gt;. Optionally you can fork the repository and clone it from your own github account, this approach would be better in case you want to contribute.&lt;/li&gt; &#xA; &lt;li&gt;Move to either the Objective-c or Swift &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples&#34;&gt;example folder&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Install example project cocoapod dependencies. From inside Objective-c or Swift example folder run &lt;code&gt;pod install&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open XLForm or SwiftExample workspace using XCode and run the project. Enjoy!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Rows&lt;/h2&gt; &#xA;&lt;h4&gt;Input Rows&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Inputs/XLForm-Inputs.gif&#34; alt=&#34;Screenshot of Input Examples&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Input rows allows the user to enter text values. Basically they use &lt;code&gt;UITextField&lt;/code&gt; or &lt;code&gt;UITextView&lt;/code&gt; controls. The main differences among the input row types is the &lt;code&gt;keyboardType&lt;/code&gt;, &lt;code&gt;autocorrectionType&lt;/code&gt; and &lt;code&gt;autocapitalizationType&lt;/code&gt; configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeText = @&#34;text&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeDefault&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeSentences&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeDefault&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeName = @&#34;name&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeNo&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeWords&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeDefault&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeURL = @&#34;url&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeNo&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeNone&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeURL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeEmail = @&#34;email&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeNo&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeNone&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeEmailAddress&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypePassword = @&#34;password&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeNo&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeNone&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeASCIICapable&lt;/code&gt;. This row type also set the &lt;code&gt;secureTextEntry&lt;/code&gt; to &lt;code&gt;YES&lt;/code&gt; in order to hide what the user types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeNumber = @&#34;number&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeNo&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeNone&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeNumbersAndPunctuation&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypePhone = @&#34;phone&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UIKeyboardTypePhonePad&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeTwitter = @&#34;twitter&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeNo&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeNone&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeTwitter&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeAccount = @&#34;account&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeNo&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeNone&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeDefault&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeInteger = @&#34;integer&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UIKeyboardTypeNumberPad&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeDecimal = @&#34;decimal&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextField&lt;/code&gt; with &lt;code&gt;UIKeyboardTypeDecimalPad&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeTextView = @&#34;textView&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be represented by a &lt;code&gt;UITextView&lt;/code&gt; with &lt;code&gt;UITextAutocorrectionTypeDefault&lt;/code&gt;, &lt;code&gt;UITextAutocapitalizationTypeSentences&lt;/code&gt; and &lt;code&gt;UIKeyboardTypeDefault&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Selector Rows&lt;/h4&gt; &#xA;&lt;p&gt;Selector rows allow us to select a value or values from a list. XLForm supports 8 types of selectors out of the box:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Selectors/XLForm-Selectors.gif&#34; alt=&#34;Screenshot of native Calendar Event Example&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSelectorPush = @&#34;selectorPush&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSelectorActionSheet = @&#34;selectorActionSheet&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSelectorAlertView = @&#34;selectorAlertView&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSelectorLeftRight = @&#34;selectorLeftRight&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSelectorPickerView = @&#34;selectorPickerView&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSelectorPickerViewInline = @&#34;selectorPickerViewInline&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSelectorSegmentedControl = @&#34;selectorSegmentedControl&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeMultipleSelector = @&#34;multipleSelector&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Normally we will have a collection of object to select (these objects should have a string to display them and a value in order to serialize them), XLForm has to be able to display these objects.&lt;/p&gt; &#xA;&lt;p&gt;XLForm follows the following rules to display an object:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If the value of the &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; object is nil, XLForm uses the &lt;code&gt;noValueDisplayText&lt;/code&gt; row property as display text.&lt;/li&gt; &#xA; &lt;li&gt;If the XLFormRowDescriptor instance has a &lt;code&gt;valueTransformer&lt;/code&gt; property value. XLForm uses the &lt;code&gt;NSValueTransformer&lt;/code&gt; to convert the selected object to a NSString.&lt;/li&gt; &#xA; &lt;li&gt;If the object is a &lt;code&gt;NSString&lt;/code&gt; or &lt;code&gt;NSNumber&lt;/code&gt; it uses the object &lt;code&gt;description&lt;/code&gt; property.&lt;/li&gt; &#xA; &lt;li&gt;If the object conforms to protocol &lt;code&gt;XLFormOptionObject&lt;/code&gt;, XLForm gets the display value from &lt;code&gt;formDisplayText&lt;/code&gt; method.&lt;/li&gt; &#xA; &lt;li&gt;Otherwise it return nil. That means you should conforms the protocol &lt;code&gt;:)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You may be interested in change the display text either by setting up &lt;code&gt;noValueDisplayText&lt;/code&gt; or &lt;code&gt;valueTransformer&lt;/code&gt; property or making the selector options objects to conform to &lt;code&gt;XLFormOptionObject&lt;/code&gt; protocol.&lt;/p&gt; &#xA;&lt;p&gt;This is the protocol declaration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@protocol XLFormOptionObject &amp;lt;NSObject&amp;gt;&#xA;&#xA;@required&#xA;-(NSString *)formDisplayText;&#xA;-(id)formValue;&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Date &amp;amp; Time Rows&lt;/h4&gt; &#xA;&lt;p&gt;XLForms supports 3 types of dates: &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; and &lt;code&gt;Countdown Timer&lt;/code&gt; and it&#39;s able to present the &lt;code&gt;UIDatePicker&lt;/code&gt; control in 2 different ways, inline and non-inline.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Dates/XLForm-Dates.gif&#34; alt=&#34;Screenshot of native Calendar Event Example&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeDateInline = @&#34;dateInline&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeDateTimeInline = @&#34;datetimeInline&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeTimeInline = @&#34;timeInline&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeCountDownTimerInline = @&#34;countDownTimerInline&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeDate = @&#34;date&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeDateTime = @&#34;datetime&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeTime = @&#34;time&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeCountDownTimer = @&#34;countDownTimer&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is an example of how to define these row types:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;XLFormDescriptor * form;&#xA;XLFormSectionDescriptor * section;&#xA;XLFormRowDescriptor * row;&#xA;&#xA;form = [XLFormDescriptor formDescriptorWithTitle:@&#34;Dates&#34;];&#xA;&#xA;section = [XLFormSectionDescriptor formSectionWithTitle:@&#34;Inline Dates&#34;];&#xA;[form addFormSection:section];&#xA;&#xA;// Date&#xA;row = [XLFormRowDescriptor formRowDescriptorWithTag:kDateInline rowType:XLFormRowDescriptorTypeDateInline title:@&#34;Date&#34;];&#xA;row.value = [NSDate new];&#xA;[section addFormRow:row];&#xA;&#xA;// Time&#xA;row = [XLFormRowDescriptor formRowDescriptorWithTag:kTimeInline rowType:XLFormRowDescriptorTypeTimeInline title:@&#34;Time&#34;];&#xA;row.value = [NSDate new];&#xA;[section addFormRow:row];&#xA;&#xA;// DateTime&#xA;row = [XLFormRowDescriptor formRowDescriptorWithTag:kDateTimeInline rowType:XLFormRowDescriptorTypeDateTimeInline title:@&#34;Date Time&#34;];&#xA;row.value = [NSDate new];&#xA;[section addFormRow:row];&#xA;&#xA;// CountDownTimer&#xA;row = [XLFormRowDescriptor formRowDescriptorWithTag:kCountDownTimerInline rowType:XLFormRowDescriptorTypeCountDownTimerInline title:@&#34;Countdown Timer&#34;];&#xA;row.value = [NSDate new];&#xA;[section addFormRow:row];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;&#xA;static let dateTime = &#34;dateTime&#34;&#xA;static let date = &#34;date&#34;&#xA;static let time = &#34;time&#34;&#xA;&#xA;var form : XLFormDescriptor&#xA;var section : XLFormSectionDescriptor&#xA;var row : XLFormRowDescriptor&#xA;&#xA;form = XLFormDescriptor(title: &#34;Dates&#34;) as XLFormDescriptor&#xA;&#xA;section = XLFormSectionDescriptor.formSectionWithTitle(&#34;Inline Dates&#34;) as XLFormSectionDescriptor&#xA;form.addFormSection(section)&#xA;&#xA;// Date&#xA;row = XLFormRowDescriptor(tag: tag.date, rowType: XLFormRowDescriptorTypeDateInline, title:&#34;Date&#34;)&#xA;row.value = NSDate()&#xA;section.addFormRow(row)&#xA;&#xA;// Time&#xA;row = XLFormRowDescriptor(tag: tag.time, rowType: XLFormRowDescriptorTypeTimeInline, title: &#34;Time&#34;)&#xA;row.value = NSDate()&#xA;section.addFormRow(row)&#xA;&#xA;// DateTime&#xA;row = XLFormRowDescriptor(tag: tag.dateTime, rowType: XLFormRowDescriptorTypeDateTimeInline, title: &#34;Date Time&#34;)&#xA;row.value = NSDate()&#xA;section.addFormRow(row)&#xA;&#xA;self.form = form;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Boolean Rows&lt;/h4&gt; &#xA;&lt;p&gt;XLForms supports 2 types of boolean controls:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Others/XLForm-Boolean.gif&#34; alt=&#34;Screenshot of native Calendar Event Example&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeBooleanCheck = @&#34;booleanCheck&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeBooleanSwitch = @&#34;booleanSwitch&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also simulate other types of Boolean rows using any of the Selector Row Types introduced in the &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#selector-rows&#34;&gt;Selector Rows section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Other Rows&lt;/h4&gt; &#xA;&lt;h5&gt;Stepper&lt;/h5&gt; &#xA;&lt;p&gt;XLForms supports counting using UIStepper control:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Others/XLForm-stepCounter.gif&#34; alt=&#34;Screenshot of native Calendar Event Example&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeStepCounter = @&#34;stepCounter&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can set the stepper paramaters easily:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;&#x9;row = [XLFormRowDescriptor formRowDescriptorWithTag:kStepCounter rowType:XLFormRowDescriptorTypeStepCounter title:@&#34;Step counter&#34;];&#xA;&#x9;row.value = @50;&#xA;&#x9;[row.cellConfigAtConfigure setObject:@YES forKey:@&#34;stepControl.wraps&#34;];&#xA;&#x9;[row.cellConfigAtConfigure setObject:@10 forKey:@&#34;stepControl.stepValue&#34;];&#xA;&#x9;[row.cellConfigAtConfigure setObject:@10 forKey:@&#34;stepControl.minimumValue&#34;];&#xA;&#x9;[row.cellConfigAtConfigure setObject:@100 forKey:@&#34;stepControl.maximumValue&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Slider&lt;/h5&gt; &#xA;&lt;p&gt;XLForms supports counting using UISlider control:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const XLFormRowDescriptorTypeSlider = @&#34;slider&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can adjust the slider for your own interests very easily:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;&#x9;row = [XLFormRowDescriptor formRowDescriptorWithTag:kSlider rowType:XLFormRowDescriptorTypeSlider title:@&#34;Slider&#34;];&#xA;&#x9;row.value = @(30);&#xA;&#x9;[row.cellConfigAtConfigure setObject:@(100) forKey:@&#34;slider.maximumValue&#34;];&#xA;&#x9;[row.cellConfigAtConfigure setObject:@(10) forKey:@&#34;slider.minimumValue&#34;];&#xA;&#x9;[row.cellConfigAtConfigure setObject:@(4) forKey:@&#34;steps&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set &lt;code&gt;steps&lt;/code&gt; to &lt;code&gt;@(0)&lt;/code&gt; to disable the steps functionality.&lt;/p&gt; &#xA;&lt;h5&gt;Info&lt;/h5&gt; &#xA;&lt;p&gt;Sometimes our apps needs to show data that are not editable. XLForm provides us with &lt;code&gt;XLFormRowDescriptorTypeInfo&lt;/code&gt; row type to display not editable info. An example of usage would be showing the app version in the settings part of an app.&lt;/p&gt; &#xA;&lt;h5&gt;Button&lt;/h5&gt; &#xA;&lt;p&gt;Apart from data entry rows, not editable rows and selectors, XLForm has a button row &lt;code&gt;XLFormRowDescriptorTypeButton&lt;/code&gt; that allows us to do any action when selected. It can be configured using a block (clousure), a selector, a segue identifier, segue class or specifing a view controller to be presented. ViewController specification could be done by setting up the view controller class, the view controller storyboard Id or a nib name. Nib name must match view controller class name.&lt;/p&gt; &#xA;&lt;h2&gt;Multivalued Sections (Insert, Delete, Reorder rows)&lt;/h2&gt; &#xA;&lt;p&gt;Any &lt;code&gt;XLFormSectionDescriptor&lt;/code&gt; object can be set up to support row insertion, deletion or reodering. It is possible to enable only one of these modes, a combination or all together. A multivalued section is just a section that support either of these modes.&lt;/p&gt; &#xA;&lt;p&gt;The most interesting part of multivalued &lt;code&gt;XLFormSectionDescriptor&lt;/code&gt; is that it supports all the types of rows that were shown on the &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#rows&#34; title=&#34;Rows&#34;&gt;&lt;em&gt;Rows&lt;/em&gt;&lt;/a&gt; section as well as custom rows.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/MultiValuedSections/XLForm-MultiValuedSections.gif&#34; alt=&#34;Screenshot of Multivalued Section Example&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;How to set up a multivalued section&lt;/h3&gt; &#xA;&lt;p&gt;Creating a multivalued section is as simple as use one of the following convenience &lt;code&gt;XLFormSectionDescriptor&lt;/code&gt; initializer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;+(id)formSectionWithTitle:(NSString *)title&#xA;&#x9;&#x9;   sectionOptions:(XLFormSectionOptions)sectionOptions;&#xA;+(id)formSectionWithTitle:(NSString *)title&#xA;&#x9;&#x9;   sectionOptions:(XLFormSectionOptions)sectionOptions&#xA;&#x9;&#x9;sectionInsertMode:(XLFormSectionInsertMode)sectionInsertMode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;sectionOptions&lt;/code&gt; is a bitwise enum parameter that should be used to choose the multivalued section type/s (insert, delete, reorder). Available options are &lt;code&gt;XLFormSectionOptionCanInsert&lt;/code&gt;, &lt;code&gt;XLFormSectionOptionCanDelete&lt;/code&gt;, &lt;code&gt;XLFormSectionOptionCanReorder&lt;/code&gt;. &lt;code&gt;XLFormSectionOptionNone&lt;/code&gt; is the value used by default.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sectionInsertMode&lt;/code&gt; can be used to select how the insertion mode will look like. &lt;code&gt;XLform&lt;/code&gt; has 2 different insertion modes out of the box: &lt;code&gt;XLFormSectionInsertModeLastRow&lt;/code&gt; and &lt;code&gt;XLFormSectionInsertModeButton&lt;/code&gt;. &lt;code&gt;XLFormSectionInsertModeLastRow&lt;/code&gt; is the default value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Let&#39;s see how to create a multivalued section&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;XLFormDescriptor * form;&#xA;XLFormSectionDescriptor * section;&#xA;XLFormRowDescriptor * row;&#xA;&#xA;NSArray * nameList = @[@&#34;family&#34;, @&#34;male&#34;, @&#34;female&#34;, @&#34;client&#34;];&#xA;&#xA;form = [XLFormDescriptor formDescriptorWithTitle:@&#34;Multivalued examples&#34;];&#xA;&#xA;// Enable Insertion, Deletion, Reordering&#xA;section = [XLFormSectionDescriptor formSectionWithTitle:@&#34;MultiValued TextField&#34;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;  sectionOptions:XLFormSectionOptionCanReorder | XLFormSectionOptionCanInsert | XLFormSectionOptionCanDelete];&#xA;section.multivaluedTag = @&#34;textFieldRow&#34;;&#xA;[form addFormSection:section];&#xA;&#xA;for (NSString * tag in nameList) {&#xA;&#x9;// add a row to the section, each row will represent a name of the name list array.&#xA;&#x9;row = [XLFormRowDescriptor formRowDescriptorWithTag:nil rowType:XLFormRowDescriptorTypeText title:nil];&#xA;&#x9;[[row cellConfig] setObject:@&#34;Add a new tag&#34; forKey:@&#34;textField.placeholder&#34;];&#xA;&#x9;row.value = [tag copy];&#xA;&#x9;[section addFormRow:row];&#xA;}&#xA;// add an empty row to the section.&#xA;row = [XLFormRowDescriptor formRowDescriptorWithTag:nil rowType:XLFormRowDescriptorTypeText title:nil];&#xA;[[row cellConfig] setObject:@&#34;Add a new tag&#34; forKey:@&#34;textField.placeholder&#34;];&#xA;[section addFormRow:row];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Form Values&lt;/h2&gt; &#xA;&lt;h4&gt;formValues&lt;/h4&gt; &#xA;&lt;p&gt;You can get all form values invoking &lt;code&gt;-(NSDictionary *)formValues;&lt;/code&gt; either &lt;code&gt;XLFormViewController&lt;/code&gt; instance or &lt;code&gt;XLFormDescriptor&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;The returned &lt;code&gt;NSDictionary&lt;/code&gt; is created following this rules:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;XLForm&lt;/code&gt; adds a value for each &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; that belongs to a &lt;code&gt;XLFormSectionDescriptor&lt;/code&gt; doesn&#39;t have a &lt;code&gt;multivaluedTag&lt;/code&gt; value set up. The dictionary key is the value of &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; &lt;code&gt;tag&lt;/code&gt; property.&lt;/p&gt; &#xA;&lt;p&gt;For each section that has a &lt;code&gt;multivaluedTag&lt;/code&gt; value, XLForm adds a dictionary item with a &lt;code&gt;NSArray&lt;/code&gt; as a value, each value of the array is the value of each row contained in the section, and the key is the &lt;code&gt;multivaluedTag&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For instance, if we have a section with the &lt;code&gt;multivaluedTag&lt;/code&gt; property equal to &lt;code&gt;tags&lt;/code&gt; and the following values on the contained rows: &#39;family&#39;, &#39;male&#39;, &#39;female&#39;, &#39;client&#39;, the generated value will be &lt;code&gt;tags: [&#39;family&#39;, &#39;male&#39;, &#39;female&#39;, &#39;client&#39;]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;httpParameters&lt;/h4&gt; &#xA;&lt;p&gt;In same cases the form value we need may differ from the value of &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; instance. This is usually the case of selectors row and when we need to send the form values to some endpoint, the selected value could be a core data object or any other object. In this cases &lt;code&gt;XLForm&lt;/code&gt; need to know how to get the value and the description of the selected object.&lt;/p&gt; &#xA;&lt;p&gt;When using &lt;code&gt;-(NSDictionary *)httpParameters&lt;/code&gt; method, XLForm follows the following rules to get &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; value:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If the object is a &lt;code&gt;NSString&lt;/code&gt;, &lt;code&gt;NSNumber&lt;/code&gt; or &lt;code&gt;NSDate&lt;/code&gt;, the value is the object itself.&lt;/li&gt; &#xA; &lt;li&gt;If the object conforms to protocol &lt;code&gt;XLFormOptionObject&lt;/code&gt;, XLForm gets the value from &lt;code&gt;formValue&lt;/code&gt; method.&lt;/li&gt; &#xA; &lt;li&gt;Otherwise it return nil.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;multivaluedTag&lt;/code&gt; works in the same way as in &lt;code&gt;formValues&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;h2&gt;How to create a Custom Row&lt;/h2&gt; &#xA;&lt;p&gt;To create a custom cell you need to create a UITableViewCell extending from &lt;code&gt;XLFormBaseCell&lt;/code&gt;. &lt;code&gt;XLFormBaseCell&lt;/code&gt; conforms to &lt;code&gt;XLFormDescriptorCell&lt;/code&gt; protocol.&lt;/p&gt; &#xA;&lt;p&gt;You may be interested in implement &lt;code&gt;XLFormDescriptorCell&lt;/code&gt; methods to change the cell behaviour.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@protocol XLFormDescriptorCell &amp;lt;NSObject&amp;gt;&#xA;&#xA;@required&#xA;&#xA;@property (nonatomic, weak) XLFormRowDescriptor * rowDescriptor;&#xA;&#xA;// initialise all objects such as Arrays, UIControls etc...&#xA;-(void)configure;&#xA;// update cell when it about to be presented&#xA;-(void)update;&#xA;&#xA;@optional&#xA;&#xA;// height of the cell&#xA;+(CGFloat)formDescriptorCellHeightForRowDescriptor:(XLFormRowDescriptor *)rowDescriptor;&#xA;// called to check if cell can became first responder&#xA;-(BOOL)formDescriptorCellCanBecomeFirstResponder;&#xA;// called to ask cell to assign first responder to relevant UIView.&#xA;-(BOOL)formDescriptorCellBecomeFirstResponder;&#xA;// called when cell is selected&#xA;-(void)formDescriptorCellDidSelectedWithFormController:(XLFormViewController *)controller;&#xA;// http parameter name used for network request&#xA;-(NSString *)formDescriptorHttpParameterName;&#xA;&#xA;// is invoked when cell becomes firstResponder, could be used for change how the cell looks like when it&#39;s the forst responder.&#xA;-(void)highlight;&#xA;// is invoked when cell resign firstResponder&#xA;-(void)unhighlight;&#xA;&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once a custom cell has been created you need to let &lt;code&gt;XLForm&lt;/code&gt; know about this cell by adding the row definition to &lt;code&gt;cellClassesForRowDescriptorTypes&lt;/code&gt; dictionary.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[[XLFormViewController cellClassesForRowDescriptorTypes] setObject:[MYCustomCellClass class] forKey:kMyAppCustomCellType];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, in case we have used nib file to define the &lt;code&gt;XLBaseDescriptorCell&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[[XLFormViewController cellClassesForRowDescriptorTypes] setObject:@&#34;nibNameWithoutNibExtension&#34; forKey:kMyAppCustomCellType];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Doing that, XLForm will instantiate the proper cell class when kMyAppCustomCellType row type is used.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Selectors - Selector Row with a custom selector view controller&lt;/h2&gt; &#xA;&lt;p&gt;Almost always the basic selector which allows the user to select one or multiple items from a pushed view controller is enough for our needs, but sometimes we need more flexibility to bring a better user experience to the user or do something not supported by default.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say your app user needs to select a map coordinate or it needs to select a value fetched from a server endpoint. How do we do that easily?&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Selectors/CustomSelectors/XLFormRowViewController/XLForm-map-custom-selector.gif&#34; alt=&#34;Screenshot of Map Custom Selector&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Define the previous selector row is as simple as ...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;row = [XLFormRowDescriptor formRowDescriptorWithTag:kSelectorMap rowType:XLFormRowDescriptorTypeSelectorPush title:@&#34;Coordinate&#34;];&#xA;// set up the selector controller class&#xA;row.action.viewControllerClass = [MapViewController class];&#xA;// or&#xA;//row.action.viewControllerStoryboardId = @&#34;MapViewControllerStoryboardId&#34;;&#xA;// or&#xA;//row.action.viewControllerNibName = @&#34;MapViewControllerNibName&#34;;&#xA;&#xA;// Set up a NSValueTransformer to convert CLLocation to NSString, it&#39;s used to show the select value description (text).&#xA;row.valueTransformer = [CLLocationValueTrasformer class];&#xA;// Set up the default value&#xA;row.value = [[CLLocation alloc] initWithLatitude:-33 longitude:-56];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;action.viewControllerClass&lt;/code&gt; controller class should conform to &lt;code&gt;XLFormRowDescriptorViewController&lt;/code&gt; protocol.&lt;/p&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;MapViewController&lt;/code&gt; conforms to &lt;code&gt;XLFormRowDescriptorViewController&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@protocol XLFormRowDescriptorViewController &amp;lt;NSObject&amp;gt;&#xA;&#xA;@required&#xA;@property (nonatomic) XLFormRowDescriptor * rowDescriptor;&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;XLForm sets up &lt;code&gt;rowDescriptor&lt;/code&gt; property using the &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; instance that belongs to the selector row.&lt;/p&gt; &#xA;&lt;p&gt;The developer is responsible for update its views with the &lt;code&gt;rowDescriptor&lt;/code&gt; value as well as set the selected value to &lt;code&gt;rowDescriptor&lt;/code&gt; from within the custom selector view controller.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: the properties &lt;code&gt;viewControllerClass&lt;/code&gt;, &lt;code&gt;viewControllerNibName&lt;/code&gt; or &lt;code&gt;viewControllerStoryboardId&lt;/code&gt; are mutually exclusive and are used by &lt;code&gt;XLFormButtonCell&lt;/code&gt; and &lt;code&gt;XLFormSelectorCell&lt;/code&gt;. If you create a custom cell then you are responsible for using them.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Another example&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Selectors/DynamicSelector/XLForm-dynamic-custom-selector.gif&#34; alt=&#34;Screenshot of Dynamic Custom Selector&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;row = [XLFormRowDescriptor formRowDescriptorWithTag:kSelectorUser rowType:XLFormRowDescriptorTypeSelectorPush title:@&#34;User&#34;];&#xA;row.action.viewControllerClass = [UsersTableViewController class];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can find the details of these examples within the example repository folder, &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Selectors/CustomSelectors&#34;&gt;Examples/Objective-C/Examples/Selectors/CustomSelectors/&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/Selectors/DynamicSelector&#34;&gt;Examples/Objective-C/Examples/Selectors/DynamicSelector&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Dynamic Forms - How to change the form dynamically at runtime&lt;/h2&gt; &#xA;&lt;p&gt;Any change made on the &lt;code&gt;XLFormDescriptor&lt;/code&gt; will be reflected on the &lt;code&gt;XLFormViewController&lt;/code&gt; tableView. That means that when a section or a row is added or removed XLForm will animate the section or row accordingly.&lt;/p&gt; &#xA;&lt;p&gt;We shouldn&#39;t have to deal with &lt;code&gt;NSIndexPaths&lt;/code&gt; or add, remove &lt;code&gt;UITableViewCell&lt;/code&gt; anymore. &lt;code&gt;NSIndexPath&lt;/code&gt; of a specific &lt;code&gt;TableViewCell&lt;/code&gt; changes along the time and this makes very hard to keep track of the &lt;code&gt;NSIndexPath&lt;/code&gt; of each &lt;code&gt;UITableViewCell&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Each XLForm &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; row has a &lt;code&gt;tag&lt;/code&gt; property that is set up in its constructor. &lt;code&gt;XLFormDescriptor&lt;/code&gt; has, among other helpers, an specific one to get a &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; from a &lt;code&gt;tag&lt;/code&gt;. It&#39;s much easier to manage &lt;code&gt;XLFormRowDescriptor&lt;/code&gt;s using tags, the tag should be unique and it doesn&#39;t change on tableview additions modifications or deletions.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s important to keep in mind that all the &lt;code&gt;UITableView&lt;/code&gt; form modifications have to be made using the descriptors and not making modifications directly on the &lt;code&gt;UITableView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Usually you may want to change the form when some value change or some row or section is added or removed. For this you can set the &lt;code&gt;disabled&lt;/code&gt; and &lt;code&gt;hidden&lt;/code&gt; properties of the rows or sections. For more details see &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#make-a-row-or-section-invisible-depending-on-other-rows-values&#34; title=&#34;Using Predicates&#34;&gt;&lt;em&gt;Make a row or section invisible depending on other rows values&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to stay in sync with the form descriptor modifications your &lt;code&gt;XLFormViewController&lt;/code&gt; subclass should override the &lt;code&gt;XLFormDescriptorDelegate&lt;/code&gt; methods of &#39;XLFormViewController&#39;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: It is important to always call the &lt;code&gt;[super ...]&lt;/code&gt; method when overriding this delegate&#39;s methods.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@protocol XLFormDescriptorDelegate &amp;lt;NSObject&amp;gt;&#xA;&#xA;@required&#xA;&#xA;-(void)formSectionHasBeenRemoved:(XLFormSectionDescriptor *)formSection atIndex:(NSUInteger)index;&#xA;-(void)formSectionHasBeenAdded:(XLFormSectionDescriptor *)formSection atIndex:(NSUInteger)index;&#xA;-(void)formRowHasBeenAdded:(XLFormRowDescriptor *)formRow atIndexPath:(NSIndexPath *)indexPath;&#xA;-(void)formRowHasBeenRemoved:(XLFormRowDescriptor *)formRow atIndexPath:(NSIndexPath *)indexPath;&#xA;-(void)formRowDescriptorValueHasChanged:(XLFormRowDescriptor *)formRow oldValue:(id)oldValue newValue:(id)newValue;&#xA;-(void)formRowDescriptorPredicateHasChanged:(XLFormRowDescriptor *)formRow&#xA;                                   oldValue:(id)oldValue&#xA;                                   newValue:(id)newValue&#xA;                              predicateType:(XLPredicateType)predicateType;&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For instance if we want to show or hide a row depending on the value of another row:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;-(void)formRowDescriptorValueHasChanged:(XLFormRowDescriptor *)rowDescriptor oldValue:(id)oldValue newValue:(id)newValue&#xA;{&#xA;&#x9;// super implmentation MUST be called&#xA;&#x9;[super formRowDescriptorValueHasChanged:rowDescriptor oldValue:oldValue newValue:newValue];&#xA;    if ([rowDescriptor.tag isEqualToString:@&#34;alert&#34;]){&#xA;        if ([[rowDescriptor.value valueData] isEqualToNumber:@(0)] == NO &amp;amp;&amp;amp; [[oldValue valueData] isEqualToNumber:@(0)]){&#xA;            XLFormRowDescriptor * newRow = [rowDescriptor copy];&#xA;            [newRow setTag:@&#34;secondAlert&#34;];&#xA;            newRow.title = @&#34;Second Alert&#34;;&#xA;            [self.form addFormRow:newRow afterRow:rowDescriptor];&#xA;        }&#xA;        else if ([[oldValue valueData] isEqualToNumber:@(0)] == NO &amp;amp;&amp;amp; [[newValue valueData] isEqualToNumber:@(0)]){&#xA;            [self.form removeFormRowWithTag:@&#34;secondAlert&#34;];&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Make a row or section invisible depending on other rows values&lt;/h2&gt; &#xA;&lt;h3&gt;Summary&lt;/h3&gt; &#xA;&lt;p&gt;XLForm allows you to define dependencies between rows so that if the value of one row is changed, the behaviour of another one changes automatically. For example, you might have a form where you question the user if he/she has pets. If the answer is &#39;yes&#39; you might want to ask how their names are. So you can make a row invisible and visible again based on the values of other rows. The same happens with sections. Take a look at the following example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/PredicateExamples/XLFormPredicatesBasic.gif&#34; alt=&#34;Screenshot of hiding rows&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Of course, you could also do this manually by observing the value of some rows and deleting and adding rows accordingly, but that would be a lot of work which is already done.&lt;/p&gt; &#xA;&lt;h3&gt;How it works&lt;/h3&gt; &#xA;&lt;p&gt;To make the appearance and disappearance of rows and sections automatic, there is a property in each descriptor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@property id hidden;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This id object will normally be a NSPredicate or a NSNumber containing a BOOL. It can be set using any of them or eventually a NSString from which a NSPredicate will be created. In order for this to work the string has to be syntactically correct.&lt;/p&gt; &#xA;&lt;p&gt;For example, you could set the following string to a row (&lt;code&gt;second&lt;/code&gt;) to make it disappear when a previous row (&lt;code&gt;first&lt;/code&gt;) contains the value &#34;hide&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;second.hidden = [NSString stringWithFormat:@&#34;$%@ contains[c] &#39;hide&#39;&#34;, first];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will insert the tag of the &lt;code&gt;first&lt;/code&gt; after the &#39;$&#39;, you can do that manually as well, of course. When the predicate is evaluated every tag variable gets substituted by the corresponding row descriptor.&lt;/p&gt; &#xA;&lt;p&gt;When the argument is a NSString, a &#39;.value&#39; will be appended to every tag unless the tag is followed by &#39;.isHidden&#39; or &#39;.isDisabled&#39;. This means that a row (or section) might depend on the &lt;code&gt;value&lt;/code&gt; or the &lt;code&gt;hidden&lt;/code&gt; or &lt;code&gt;disabled&lt;/code&gt; properties of another row. When the property is set with a NSPredicate directly, its formatString will not be altered (so you have to append a &#39;.value&#39; after each variable if you want to refer to its value). Setting a NSString is the simplest way but some complex predicates might not work so for those you should directly set a NSPredicate.&lt;/p&gt; &#xA;&lt;p&gt;You can also set this properties with a bool object which means the value of the property will not change unless manually set.&lt;/p&gt; &#xA;&lt;p&gt;To get the evaluated boolean value the &lt;code&gt;isHidden&lt;/code&gt; method should be called. It will not re-evaluate the predicate each time it gets called but just when the value (or hidden/disabled status) of the rows it depends on changes. When this happens and the return value changes, it will automagically reflect that change on the form so that no other method must be called.&lt;/p&gt; &#xA;&lt;p&gt;Here is another example, this time a bit more complex:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/PredicateExamples/XLFormPredicates.gif&#34; alt=&#34;Screenshot of hiding rows&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Disabling rows (set to read-only mode)&lt;/h2&gt; &#xA;&lt;p&gt;Rows can be disabled so that the user can not change them. By default disabled rows have a gray text color. To disable a row the only thing that has to be done is setting its disabled property:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@property id disabled;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This property expects a NSNumber containing a BOOL, a NSString or a NSPredicate. A bool will statically disable (or enable the row). The other two work just like the hidden property explained in the section above. This means a row can be disabled and enabled depending on the values of other rows. When a NSString is set, a NSPredicate will be generated taking the string as format string so that it has to be consistent for that purpose.&lt;/p&gt; &#xA;&lt;p&gt;A difference to the hidden property is that checking the disabled status of a row does not automatically reflect that value on the form. Tharefore, the XLFormViewController&#39;s updateFormRow method should be called.&lt;/p&gt; &#xA;&lt;h2&gt;Validations&lt;/h2&gt; &#xA;&lt;p&gt;We can validate the form data using XLForm validation support.&lt;/p&gt; &#xA;&lt;p&gt;Each &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; instance contains a list of validators. We can add validators, remove validators and validate a particular row using these methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;-(void)addValidator:(id&amp;lt;XLFormValidatorProtocol&amp;gt;)validator;&#xA;-(void)removeValidator:(id&amp;lt;XLFormValidatorProtocol&amp;gt;)validator;&#xA;-(XLFormValidationStatus *)doValidation;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can define our own custom validators just defining a object that conforms to &lt;code&gt;XLFormValidatorProtocol&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@protocol XLFormValidatorProtocol &amp;lt;NSObject&amp;gt;&#xA;&#xA;@required&#xA;&#xA;-(XLFormValidationStatus *)isValid:(XLFormRowDescriptor *)row;&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/XLForm/XL/Validation/XLFormRegexValidator.h&#34;&gt;XLFormRegexValidator&lt;/a&gt; is an example of a validator we can create.&lt;/p&gt; &#xA;&lt;p&gt;A very common validation is ensuring that a value is not empty or nil. XLFom exposes &lt;code&gt;required&lt;/code&gt; XLFormRowDescriptor property to specify required rows.&lt;/p&gt; &#xA;&lt;p&gt;To get all rows validation errors we can invoke the following &lt;code&gt;XLFormViewController&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;-(NSArray *)formValidationErrors;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Additional configuration of Rows&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;XLFormRowDescriptor&lt;/code&gt; allow us to configure generic aspects of a &lt;code&gt;UITableViewCell&lt;/code&gt;, for example: the &lt;code&gt;rowType&lt;/code&gt;, the &lt;code&gt;label&lt;/code&gt;, the &lt;code&gt;value&lt;/code&gt; (default value), if the cell is &lt;code&gt;required&lt;/code&gt;, &lt;code&gt;hidden&lt;/code&gt; or &lt;code&gt;disabled&lt;/code&gt;, and so on.&lt;/p&gt; &#xA;&lt;p&gt;You may want to set up another properties of the &lt;code&gt;UITableViewCell&lt;/code&gt;. To set up another properties &lt;code&gt;XLForm&lt;/code&gt; makes use of &lt;a href=&#34;https://developer.apple.com/LIBRARY/IOS/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html&#34; title=&#34;Key-Value Coding&#34;&gt;Key-Value Coding&lt;/a&gt; allowing the developer to set the cell properties by keyPath.&lt;/p&gt; &#xA;&lt;p&gt;You just have to add the properties to &lt;code&gt;cellConfig&lt;/code&gt; or &lt;code&gt;cellConfigAtConfigure&lt;/code&gt; dictionary property of &lt;code&gt;XLFormRowDescriptor&lt;/code&gt;. The main difference between &lt;code&gt;cellConfig&lt;/code&gt; and &lt;code&gt;cellConfigAtConfigure&lt;/code&gt; is the time when the property is set up. &lt;code&gt;cellConfig&lt;/code&gt; properties are set up each time a cell is about to be displayed. &lt;code&gt;cellConfigAtConfigure&lt;/code&gt;, on the other hand, set up the property just after the init method of the cell is called and only one time.&lt;/p&gt; &#xA;&lt;p&gt;Since version 3.3.0 you can also use &lt;code&gt;cellConfigForSelector&lt;/code&gt; to configure how the cells of the &lt;code&gt;XLFormOptionsViewController&lt;/code&gt; look like when it is shown for a selector row.&lt;/p&gt; &#xA;&lt;p&gt;For instance if you want to set up the placeholder you can do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;row = [XLFormRowDescriptor formRowDescriptorWithTag:@&#34;title&#34; rowType:XLFormRowDescriptorTypeText];&#xA;[row.cellConfigAtConfigure setObject:@&#34;Title&#34; forKey:@&#34;textField.placeholder&#34;];&#xA;[section addFormRow:row];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s see how to change the color of the cell label:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;row = [XLFormRowDescriptor formRowDescriptorWithTag:@&#34;title&#34; rowType:XLFormRowDescriptorTypeText];&#xA;[row.cellConfig setObject:[UIColor redColor] forKey:@&#34;textLabel.textColor&#34;];&#xA;[section addFormRow:row];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;row = XLFormRowDescriptor(tag: &#34;title&#34;, rowType: XLFormRowDescriptorTypeText, title: &#34;title&#34;)&#xA;row.cellConfig.setObject(UIColor.blackColor(), forKey: &#34;backgroundColor&#34;)&#xA;row.cellConfig.setObject(UIColor.whiteColor(), forKey: &#34;textLabel.textColor&#34;)&#xA;section.addFormRow(row)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h4&gt;How to customize the header and/or footer of a section&lt;/h4&gt; &#xA;&lt;p&gt;For this you should use the UITableViewDelegate methods in your XLFormViewController. This means you should implement one or both of these:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#xA;&#xA;-(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also you might want to implement the following methods to specify the height for these views:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#xA;&#xA;-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to assign the first responder on form appearance&lt;/h4&gt; &#xA;&lt;p&gt;Assign the first responder when the form is shown is as simple as setting the property &lt;code&gt;assignFirstResponderOnShow&lt;/code&gt; to &lt;code&gt;YES&lt;/code&gt;. By default the value of the property is &lt;code&gt;NO&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@property (nonatomic) BOOL assignFirstResponderOnShow;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to set a value to a row.&lt;/h4&gt; &#xA;&lt;p&gt;You should set the &lt;code&gt;value&lt;/code&gt; property of &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; relevant instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@property (nonatomic) id value;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may notice that the &lt;code&gt;value&lt;/code&gt; property type is &lt;code&gt;id&lt;/code&gt; and you are the responsable to set a value with the proper type. For instance, you should set a &lt;code&gt;NSString&lt;/code&gt; value to a &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; instance of &lt;code&gt;XLFormRowDescriptorTypeText&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You may have to update the cell to see the UI changes if the row is already presented. &lt;code&gt;-(void)reloadFormRow:(XLFormRowDescriptor *)formRow&lt;/code&gt; method is provided by &lt;code&gt;XLFormViewController&lt;/code&gt; to do so.&lt;/p&gt; &#xA;&lt;h4&gt;How to set the default value to a row.&lt;/h4&gt; &#xA;&lt;p&gt;You should do the same as &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/#how-to-set-a-value-to-a-row&#34; title=&#34;How to set a value to a row&#34;&gt;&lt;em&gt;How to set a value to a row&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;How to set up the options to a selector row.&lt;/h4&gt; &#xA;&lt;p&gt;XLForm has several types of selectors rows. Almost all of them need to know which are the values to be selected. For a particular &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; instance you specify these values setting a &lt;code&gt;NSArray&lt;/code&gt; instance to &lt;code&gt;selectorOptions&lt;/code&gt; property.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@property NSArray * selectorOptions;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to get form values&lt;/h4&gt; &#xA;&lt;p&gt;If you want to get the raw form values you should call &lt;code&gt;formValues&lt;/code&gt; method of &lt;code&gt;XLFormDescriptor&lt;/code&gt;. Doing that you will get a dictionary containing all the form values. &lt;code&gt;tag&lt;/code&gt; property value of each row is used as dictionary key. Only &lt;code&gt;XLFormROwDescriptor&lt;/code&gt; values for non nil &lt;code&gt;tag&lt;/code&gt; values are added to the dictionary.&lt;/p&gt; &#xA;&lt;p&gt;You may be interested in the form values to use it as enpoint parameter. In this case &lt;code&gt;httpParameters&lt;/code&gt; would be useful.&lt;/p&gt; &#xA;&lt;p&gt;If you need something different, you can iterate over each row...&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt; NSMutableDictionary * result = [NSMutableDictionary dictionary];&#xA; for (XLFormSectionDescriptor * section in self.form.formSections) {&#xA;     if (!section.isMultivaluedSection){&#xA;         for (XLFormRowDescriptor * row in section.formRows) {&#xA;             if (row.tag &amp;amp;&amp;amp; ![row.tag isEqualToString:@&#34;&#34;]){&#xA;                 [result setObject:(row.value ?: [NSNull null]) forKey:row.tag];&#xA;             }&#xA;         }&#xA;     }&#xA;     else{&#xA;         NSMutableArray * multiValuedValuesArray = [NSMutableArray new];&#xA;         for (XLFormRowDescriptor * row in section.formRows) {&#xA;             if (row.value){&#xA;                 [multiValuedValuesArray addObject:row.value];&#xA;             }&#xA;         }&#xA;         [result setObject:multiValuedValuesArray forKey:section.multivaluedTag];&#xA;     }&#xA; }&#xA; return result;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;var results = [String:String]()&#xA;if let fullName = form.formRowWithTag(tag.fullName).value as? String {&#xA;    results[tag.fullName] = fullName&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to change UITextField length&lt;/h4&gt; &#xA;&lt;p&gt;You can change the length of a UITextField using the &lt;code&gt;cellConfigAtConfigure&lt;/code&gt; dictionary property. This value refers to the percentage in relation to the table view cell.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[row.cellConfigAtConfigure setObject:[NSNumber numberWithFloat:0.7] forKey:XLFormTextFieldLengthPercentage];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;row.cellConfigAtConfigure.setObject(0.7, forKey:XLFormTextFieldLengthPercentage)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**Note:**The same can be achieved for the UITextView when using &lt;code&gt;XLFormRowDescriptorTypeTextView&lt;/code&gt;; just set your percentage for the key &lt;code&gt;XLFormTextViewLengthPercentage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;How to change a UITableViewCell font&lt;/h4&gt; &#xA;&lt;p&gt;You can change the font or any other table view cell property using the &lt;code&gt;cellConfig&lt;/code&gt; dictionary property. XLForm will set up &lt;code&gt;cellConfig&lt;/code&gt; dictionary values when the table view cell is about to be displayed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[row.cellConfig setObject:[UIColor greenColor] forKey:@&#34;textLabel.textColor&#34;];&#xA;[row.cellConfig setObject:[UIFont fontWithName:FONT_LATO_REGULAR size:12.0] forKey:@&#34;textLabel.font&#34;];&#xA;[row.cellConfig setObject:[UIFont fontWithName:FONT_LATO_REGULAR size:12.0] forKey:@&#34;detailTextLabel.font&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;row.cellConfig.setObject(UIColor.whiteColor(), forKey: &#34;self.tintColor&#34;)&#xA;row.cellConfig.setObject(UIFont(name: &#34;AppleSDGothicNeo-Regular&#34;, size: 17)!, forKey: &#34;textLabel.font&#34;)&#xA;row.cellConfig.setObject(UIColor.whiteColor(), forKey: &#34;textField.textColor&#34;)&#xA;row.cellConfig.setObject(UIFont(name: &#34;AppleSDGothicNeo-Regular&#34;, size: 17)!, forKey: &#34;textField.font&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For further details, please take a look at &lt;a href=&#34;https://raw.githubusercontent.com/xmartlabs/XLForm/master/Examples/Objective-C/Examples/UICustomization/UICustomizationFormViewController.m&#34;&gt;UICustomizationFormViewController.m&lt;/a&gt; example.&lt;/p&gt; &#xA;&lt;h4&gt;How to set min/max for date cells?&lt;/h4&gt; &#xA;&lt;p&gt;Each XLFormDateCell has a &lt;code&gt;minimumDate&lt;/code&gt; and a &lt;code&gt;maximumDate&lt;/code&gt; property. To set a datetime row to be a value in the next three days you would do as follows:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[row.cellConfigAtConfigure setObject:[NSDate new] forKey:@&#34;minimumDate&#34;];&#xA;[row.cellConfigAtConfigure setObject:[NSDate dateWithTimeIntervalSinceNow:(60*60*24*3)] forKey:@&#34;maximumDate&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;row.cellConfig.setObject(NSDate(), forKey: &#34;maximumDate&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to disable the entire form (read only mode).&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;disable&lt;/code&gt; XLFormDescriptor property can be used to disable the entire form. In order to make the displayed cell to take effect we should reload the visible cells ( [self.tableView reloadData] ). Any other row added after form &lt;code&gt;disable&lt;/code&gt; property is set to &lt;code&gt;YES&lt;/code&gt; will reflect the disable mode automatically (no need to reload table view).&lt;/p&gt; &#xA;&lt;h4&gt;How to hide a row or section when another rows value changes.&lt;/h4&gt; &#xA;&lt;p&gt;To hide a row or section you should set its hidden property. The easiest way of doing this is by setting a NSString to it. Let&#39;s say you want a section to hide if a previous row, which is a boolean switch, is set to 1 (or YES). Then you would do something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;section.hidden = [NSString stringWithFormat:@&#34;$%@ == 1&#34;, previousRow];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is all!&lt;/p&gt; &#xA;&lt;h4&gt;What do I have to do to migrate from version 2.2.0 to 3.0.0?&lt;/h4&gt; &#xA;&lt;p&gt;The only thing that is not compatible with older versions is that the &lt;code&gt;disabled&lt;/code&gt; property of the &lt;code&gt;XLFormRowDescriptor&lt;/code&gt; is an &lt;code&gt;id&lt;/code&gt; now. So you just have to add &lt;code&gt;@&lt;/code&gt; before the values you set to it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;row.disabled = @YES; // before: row.disabled = YES;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to change input accessory view (navigation view)&lt;/h4&gt; &#xA;&lt;p&gt;Overriding &lt;code&gt;inputAccessoryViewForRowDescriptor:&lt;/code&gt; &lt;code&gt;XLFormViewController&lt;/code&gt; method. If you want to disable it completely you can return nil. But you can also customize its whole appearance here.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-obj-c&#34;&gt;- (UIView *)inputAccessoryViewForRowDescriptor:(XLFormRowDescriptor *)rowDescriptor&#xA;{&#xA;      return nil; //will hide it completely&#xA;      // You can use the rowDescriptor parameter to hide/customize the accessory view for a particular rowDescriptor type.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to set up a pushed view controller?&lt;/h4&gt; &#xA;&lt;p&gt;The view controller that will be pushed must conform to the &lt;code&gt;XLFormRowDescriptorViewController&lt;/code&gt; protocol which consists of the following property:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@property (nonatomic) XLFormRowDescriptor * rowDescriptor;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This rowDescriptor refers to the selected row of the previous view controller and will be set before the transition to the new controller so that it will be accessible for example in its &lt;code&gt;viewDidLoad&lt;/code&gt; method. That is where that view controller should be set up.&lt;/p&gt; &#xA;&lt;h4&gt;How to change the default appearance of a certain cell&lt;/h4&gt; &#xA;&lt;p&gt;The best way to do this is to extend the class of that cell and override its update and/or configure methods. To make this work you should also update the &lt;code&gt;cellClassesForRowDescriptorTypes&lt;/code&gt; dictionary in your subclass of XLFormViewController by setting your custom class instead of the class of the cell you wanted to change.&lt;/p&gt; &#xA;&lt;h4&gt;How to change the returnKeyType of a cell&lt;/h4&gt; &#xA;&lt;p&gt;To change the returnKeyType of a cell you can set the &lt;code&gt;returnKeyType&lt;/code&gt; and &lt;code&gt;nextReturnKeyType&lt;/code&gt; properties. The former will be used if there is no navigation enabled or if there is no row after this row. In the other case the latter will be used. If you create a custom cell and want to use these you should conform to the &lt;code&gt;XLFormReturnKeyProtocol&lt;/code&gt; protocol. This is how you can set them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[row.cellConfigAtConfigure setObject:@(UIReturnKeyGo) forKey:@&#34;nextReturnKeyType&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to change the height of one cell&lt;/h4&gt; &#xA;&lt;p&gt;If you want to change the height for all cells of one class you should subclass that cell and override the class method &lt;code&gt;formDescriptorCellHeightForRowDescriptor&lt;/code&gt;. If you want to change the height of one individual cell then you can set that height to the &lt;code&gt;height&lt;/code&gt; property of XLFormRowDescripto like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XLFormRowDescriptor* row = ...&#xA;row.height = 55;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to change the appearance of the cells of a selector view controller (XLFormOptionsViewController)&lt;/h4&gt; &#xA;&lt;p&gt;To change the appearance of the cells of a XLFormOptionsViewController you can use the &lt;code&gt;cellConfigForSelector&lt;/code&gt; property on the row descriptor. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[row.cellConfigForSelector setObject:[UIColor redColor] forKey:@&#34;textLabel.textColor&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to limit the characters of a XLFormTextFieldCell or a XLFormTextViewCell&lt;/h4&gt; &#xA;&lt;p&gt;You can make this happen using the &lt;code&gt;textFieldMaxNumberOfCharacters&lt;/code&gt; and the &lt;code&gt;textViewMaxNumberOfCharacters&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[row.cellConfigAtConfigure setObject:@(20) forKey:@&#34;textViewMaxNumberOfCharacters&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h2&gt;Swift Package Manager&lt;/h2&gt; &#xA;&lt;p&gt;Starting with Xcode 11, Swift Package Manager is the recommended and preferred way for installing dependencies in Xcode projects. Installing dependencies via SwiftPM does not require the application nor dependencies to be written in Swift.&lt;/p&gt; &#xA;&lt;p&gt;To add XLForm to your project using SwiftPM follow these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open your project in Xcode&lt;/li&gt; &#xA; &lt;li&gt;In the main menu, select File -&amp;gt; Swift Packages -&amp;gt; Add Package Dependency...&lt;/li&gt; &#xA; &lt;li&gt;In the window, enter the package url &lt;a href=&#34;https://github.com/xmartlabs/XLForm&#34;&gt;https://github.com/xmartlabs/XLForm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Configure the version to be used&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To use XLForm in your code, import the module or header files as needed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &#34;XLForm.h&#34;  // Obj-c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import XLForm       // Swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;CocoaPods&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the following line in the project&#39;s Podfile file: &lt;code&gt;pod &#39;XLForm&#39;, &#39;~&amp;gt; 4.3&#39;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run the command &lt;code&gt;pod install&lt;/code&gt; from the Podfile folder directory.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;XLForm &lt;strong&gt;has no&lt;/strong&gt; dependencies over other pods.&lt;/p&gt; &#xA;&lt;h4&gt;How to use master branch&lt;/h4&gt; &#xA;&lt;p&gt;Often master branch contains most recent features and latest fixes. On the other hand this features was not fully tested and changes on master may occur at any time. For the previous reasons I stongly recommend to fork the repository and manage the updates from master on your own making the proper pull on demand.&lt;/p&gt; &#xA;&lt;p&gt;To use xmartlabs master branch.....&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pod &#39;XLForm&#39;, :git =&amp;gt; &#39;https://github.com/xmartlabs/XLForm.git&#39;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can replace the repository URL for your forked version url if you wish.&lt;/p&gt; &#xA;&lt;h4&gt;How to use XLForm in Swift files&lt;/h4&gt; &#xA;&lt;p&gt;If you have installed XLForm with cocoapods and have set &lt;code&gt;use_frameworks!&lt;/code&gt; in your Podfile, you can add &lt;code&gt;import XLForm&lt;/code&gt; to any Swift file.&lt;/p&gt; &#xA;&lt;p&gt;If you are using cocoapods but have not set &lt;code&gt;use_frameworks!&lt;/code&gt; in your Podfile, add &lt;code&gt;#import &amp;lt;XLForm/XLForm.h&amp;gt;&lt;/code&gt; to your bridging header file.&lt;/p&gt; &#xA;&lt;p&gt;For further details on how to create and configure the bridging header file visit &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html&#34; title=&#34;Importing Objective-C into Swift&#34;&gt;&lt;em&gt;Importing Objective-C into Swift&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Carthage&lt;/h2&gt; &#xA;&lt;p&gt;In your &lt;code&gt;Cartfile&lt;/code&gt; add:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;xmartlabs/XLForm&#34; ~&amp;gt; 4.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using git submodules&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone XLForm as a git &lt;a href=&#34;http://git-scm.com/docs/git-submodule&#34;&gt;submodule&lt;/a&gt; by running the following command from your project root git folder.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git submodule add https://github.com/xmartlabs/XLForm.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Open XLForm folder that was created by the previous git submodule command and drag the XLForm.xcodeproj into the Project Navigator of your application&#39;s Xcode project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select the XLForm.xcodeproj in the Project Navigator and verify the deployment target matches with your application deployment target.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select your project in the Xcode Navigation and then select your application target from the sidebar. Next select the &#34;General&#34; tab and click on the + button under the &#34;Embedded Binaries&#34; section.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select &lt;code&gt;XLForm.framework&lt;/code&gt; and we are done!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ARC&lt;/li&gt; &#xA; &lt;li&gt;iOS 9.0 and above&lt;/li&gt; &#xA; &lt;li&gt;Xcode 9.0+ (11.0+ for installation via Swift Package Manager)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Release Notes&lt;/h2&gt; &#xA;&lt;p&gt;Have a look at the &lt;a href=&#34;https://github.com/xmartlabs/XLForm/raw/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.github.com/mtnBarreto&#34; title=&#34;Martin Barreto Github&#34;&gt;Martin Barreto&lt;/a&gt; (&lt;a href=&#34;http://twitter.com/mtnBarreto&#34; title=&#34;@mtnBarreto&#34;&gt;@mtnBarreto&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;Any suggestion or question? Please create a Github issue or reach us out.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://xmartlabs.com&#34;&gt;xmartlabs.com&lt;/a&gt; (&lt;a href=&#34;http://twitter.com/xmartlabs&#34; title=&#34;@xmartlabs&#34;&gt;@xmartlabs&lt;/a&gt;)&lt;/p&gt;</summary>
  </entry>
</feed>