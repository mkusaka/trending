<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-28T01:36:00Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cjhanson/Objective-C-Optimized-Singleton</title>
    <updated>2023-08-28T01:36:00Z</updated>
    <id>tag:github.com,2023-08-28:/cjhanson/Objective-C-Optimized-Singleton</id>
    <link href="https://github.com/cjhanson/Objective-C-Optimized-Singleton" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Singleton Macro that swaps method implementations at runtime so that only the initialization portion will require syncrhonization (lock)&lt;/p&gt;&lt;hr&gt;&lt;p&gt;If your system supports blocks (like iOS 4+) then you should just use the dispatch_once function as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(MyClass *)sharedInstance { static MyClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ sharedInstance = [[MyClass alloc] init]; // Do any other initialisation stuff here }); return sharedInstance; }&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This method was sourced from &lt;a href=&#34;http://stackoverflow.com/questions/7568935/how-do-i-implement-an-objective-c-singleton-that-is-compatible-with-arc&#34;&gt;http://stackoverflow.com/questions/7568935/how-do-i-implement-an-objective-c-singleton-that-is-compatible-with-arc&lt;/a&gt; courtesy Nick Forge&lt;/p&gt; &#xA;&lt;p&gt;=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+= =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=&lt;/p&gt; &#xA;&lt;p&gt;See the &#34;pre-blocks&#34; branch for the old implementation:&lt;/p&gt; &#xA;&lt;p&gt;A Singleton Macro that swaps method implementations at runtime so that only the initialization portion will require syncrhonization (lock).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Specifically it uses method_setImplementation() to dynamically replace the sharedInstance access method with one that does not instantiate a new object and thus does not require @synchronized.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is based on the work here: &lt;a href=&#34;http://cocoawithlove.com/2008/11/singletons-appdelegates-and-top-level.html&#34;&gt;http://cocoawithlove.com/2008/11/singletons-appdelegates-and-top-level.html&lt;/a&gt; by Matt Gallagher But changing the implementation to use method swizzling as described here: &lt;a href=&#34;http://googlemac.blogspot.com/2006/11/synchronized-swimming-part-2.html&#34;&gt;http://googlemac.blogspot.com/2006/11/synchronized-swimming-part-2.html&lt;/a&gt; by Dave MacLachlan of Google.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Strilanc/ObjC-CollapsingFutures</title>
    <updated>2023-08-28T01:36:00Z</updated>
    <id>tag:github.com,2023-08-28:/Strilanc/ObjC-CollapsingFutures</id>
    <link href="https://github.com/Strilanc/ObjC-CollapsingFutures" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Futures, for Objective-C, that automatically collapse so it&#39;s nearly impossible to mix up the level of future nesting despite the lack of generics.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Collapsing Futures&lt;/h1&gt; &#xA;&lt;p&gt;This is a library implementing &lt;a href=&#34;https://en.wikipedia.org/wiki/Future_%28programming%29&#34;&gt;futures&lt;/a&gt; in Objective-C, featuring:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Types&lt;/strong&gt;: &lt;code&gt;TOCFuture&lt;/code&gt; to represent eventual results, &lt;code&gt;TOCCancelToken&lt;/code&gt; to propagate cancellation notifications, &lt;code&gt;TOCFutureSource&lt;/code&gt; to produce and control an eventual result, and &lt;code&gt;TOCCancelTokenSource&lt;/code&gt; to produce and control a cancel token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Automatic Collapsing&lt;/strong&gt;: You never have to worry about forgetting to unwrap or flatten a doubly-eventual future. A &lt;code&gt;[TOCFuture futureWithResult:[TOCFuture futureWithResult:@1]]&lt;/code&gt; is automatically a &lt;code&gt;[TOCFuture futureWithResult:@1]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Sticky Main Thread&lt;/strong&gt;: Callbacks registered from the main thread will get back on the main thread before executing. Makes UI work much easier.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cancellable Operations&lt;/strong&gt;: All asynchronous operations have variants that can be cancelled by cancelling the &lt;code&gt;TOCCancelToken&lt;/code&gt; passed to the operation&#39;s &lt;code&gt;until:&lt;/code&gt; or &lt;code&gt;unless:&lt;/code&gt; parameter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Immortality Detection&lt;/strong&gt;: It is impossible to create new space leaks by consuming futures and tokens (but producers still have to be careful). If a reference cycle doesn&#39;t involve a token or future&#39;s source, it will be broken when the source is deallocated.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Documentation&lt;/strong&gt;: Useful doc comments on every method and type, that don&#39;t just repeat the name, covering corner cases and in some cases basic usage hints. No &#39;getting started&#39; guides yet, though.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Recent Changes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Version 1.&lt;/li&gt; &#xA; &lt;li&gt;Deprecated &#34;TwistedOakCollapsingFutures.h&#34; for &#34;CollapsingFutures.h&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Futures are now equatable (by current state then by will-end-up-in-same-state-with-same-value).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Method #1: &lt;a href=&#34;http://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In your &lt;a href=&#34;http://guides.cocoapods.org/using/the-podfile.html&#34;&gt;Podfile&lt;/a&gt;, add &lt;code&gt;pod &#39;TwistedOakCollapsingFutures&#39;, &#39;~&amp;gt; 1.0&#39;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;pod install&lt;/code&gt; from the project directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;#import &#34;CollapsingFutures.h&#34;&lt;/code&gt; wherever you want to use futures, cancel tokens, or their category methods&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Method #2: Manual&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download one of the &lt;a href=&#34;https://github.com/Strilanc/ObjC-CollapsingFutures/releases&#34;&gt;releases&lt;/a&gt;, or clone the repo&lt;/li&gt; &#xA; &lt;li&gt;Copy the source files from the src/ folder into your project&lt;/li&gt; &#xA; &lt;li&gt;Have ARC enabled&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;#import &#34;CollapsingFutures.h&#34;&lt;/code&gt; wherever you want to use futures, cancel tokens, or their category methods&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;External Content&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://twistedoakstudios.com/blog/Post7149_collapsing-futures-in-objective-c&#34;&gt;Usage and benefits of collapsing futures&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://twistedoakstudios.com/blog/Post7391_cancellation-tokens-and-collapsing-futures-for-objective-c&#34;&gt;Usage and benefits of cancellation tokens&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://twistedoakstudios.com/blog/Post7525_using-immortality-to-kill-accidental-callback-cycles&#34;&gt;How immortality detection works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/&#34;&gt;Explanation and motivation for the &#39;monadic&#39; design of futures (in C++)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using a Future&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The following code is an example of how to make a &lt;code&gt;TOCFuture&lt;/code&gt; &lt;em&gt;do&lt;/em&gt; something. Use &lt;code&gt;thenDo&lt;/code&gt; to make things happen when the future succeeds, and &lt;code&gt;catchDo&lt;/code&gt; to make things happen when it fails (there&#39;s also &lt;code&gt;finallyDo&lt;/code&gt; for cleanup):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &#34;CollapsingFutures.h&#34;&#xA;&#xA;// ask for the address book, which is asynchronous because IOS may ask the user to allow it&#xA;TOCFuture *futureAddressBook = SomeUtilityClass.asyncGetAddressBook;&#xA;&#xA;// if the user refuses access to the address book (or something else goes wrong), log the problem&#xA;[futureAddressBook catchDo:^(id error) {&#xA;    NSLog(&#34;There was an error (%@) getting the address book.&#34;, error);&#xA;}];&#xA;&#xA;// if the user allowed access, use the address book&#xA;[futureAddressBook thenDo:^(id arcAddressBook) {&#xA;    ABAddressBookRef addressBook = (__bridge ABAddressBookRef)arcAddressBook;&#xA;    &#xA;    ... do stuff with addressBook ...&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Creating a Future&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;How does the &lt;code&gt;asyncGetAddressBook&lt;/code&gt; method from the above example control the future it returns?&lt;/p&gt; &#xA;&lt;p&gt;In the simple case, where the result is already known, you use &lt;code&gt;TOCFuture futureWithResult:&lt;/code&gt; or &lt;code&gt;TOCFuture futureWithFailure&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When the result is not known right away, the class &lt;code&gt;TOCFutureSource&lt;/code&gt; is used. It has a &lt;code&gt;future&lt;/code&gt; property that completes after the source&#39;s &lt;code&gt;trySetResult&lt;/code&gt; or &lt;code&gt;trySetFailure&lt;/code&gt; methods are called.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how &lt;code&gt;asyncGetAddressBook&lt;/code&gt; is implemented:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &#34;CollapsingFutures.h&#34;&#xA;&#xA;+(TOCFuture *) asyncGetAddressBook {&#xA;    CFErrorRef creationError = nil;&#xA;    ABAddressBookRef addressBookRef = ABAddressBookCreateWithOptions(NULL, &amp;amp;creationError);&#xA;    &#xA;    // did we fail right away? Then return an already-failed future&#xA;    if (creationError != nil) {&#xA;        return [TOCFuture futureWithFailure:(__bridge_transfer id)creationError];&#xA;    }&#xA;    &#xA;    // we need to make an asynchronous call, so we&#39;ll use a future source&#xA;    // that way we can return its future right away and fill it in later&#xA;    TOCFutureSource *resultSource = [FutureSource new];&#xA;        &#xA;    id arcAddressBook = (__bridge_transfer id)addressBookRef; // retain the address book in ARC land&#xA;    ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef requestAccessError) {&#xA;        // time to fill in the future we returned&#xA;        if (granted) {&#xA;            [resultSource trySetResult:arcAddressBook];&#xA;        } else {&#xA;            [resultSource trySetFailure:(__bridge id)requestAccessError];&#xA;        }&#xA;    });&#xA;            &#xA;    return resultSource.future;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Chaining Futures&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Just creating and using futures is useful, but not what makes them powerful. The true power is in transformative methods like &lt;code&gt;then:&lt;/code&gt; and &lt;code&gt;toc_thenAll&lt;/code&gt; that both consume and produce futures. They make wiring up complicated asynchronous sequences look easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &#34;CollapsingFutures.h&#34;&#xA;&#xA;+(TOCFuture *) sumOfFutures:(NSArray*)arrayOfFuturesOfNumbers {&#xA;    // we want all of the values to be ready before we bother summing&#xA;    TOCFuture* futureOfArrayOfNumbers = arrayOfFuturesOfNumbers.toc_thenAll;&#xA;    &#xA;    // once the array of values is ready, add up its entries to get the sum&#xA;    TOCFuture* futureSum = [futureOfArrayOfNumbers then:^(NSArray* numbers) {&#xA;        double total = 0;&#xA;        for (NSNumber* number in numbers) {&#xA;            total += number.doubleValue;&#xA;        }&#xA;        return @(total);&#xA;    }];&#xA;    &#xA;    // this future will eventually contain the sum of the eventual numbers in the input array&#xA;    // if any of the evetnual numbers fails, this future will end up failing as well&#xA;    return futureSum;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The ability to setup transformations to occur once futures are ready allows you to write truly asynchronous code, that doesn&#39;t block precious threads, with very little boilerplate and intuitive propagation of failures.&lt;/p&gt; &#xA;&lt;h1&gt;Design Philosophy&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Blocking&lt;/strong&gt;: There are no blocking operations included in the library, because blocking on a future is a great way to introduce deadlocks and UI hangs. Use &lt;code&gt;then&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;whenCancelledDo&lt;/code&gt; instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No @catch-ing Errors&lt;/strong&gt;: Raised errors are not caught, even inside handlers given to methods like &lt;code&gt;then&lt;/code&gt;. In Objective-C, raising an error is generally considered to be a fatal problem. Catching them and packaging them into the future&#39;s failure could allow the program to continue despite its state being seriously corrupted.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Garbage&lt;/strong&gt;: Registered callbacks aren&#39;t just ignored when they stop mattering; they are actively removed and discarded. When a cancel token&#39;s source is deallocated before cancelling the token, the handlers are not kept around. When &lt;code&gt;toc_finallyAll:unless:&lt;/code&gt; is cancelled, it does not forget about the callbacks it registered.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Undefined Behavior&lt;/strong&gt;: Corner cases should be accounted for in the implementation, specification, documentation, and tests of a method. Set a future to be its own result, directly or indirectly? It becomes immortal. Call &lt;code&gt;whenCancelledDo:unless:&lt;/code&gt; on a cancelled token with a cancelled token? The callback doesn&#39;t run. Etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Inheritance&lt;/strong&gt;: A future source is not a future extended to be writable. A future source &lt;em&gt;has a&lt;/em&gt; future that it controls. This is fundamental to ensuring consumers can&#39;t create memory leaks involving futures. Only producers can sustain those leaks, because as soon as the source is deallocated its future becomes immortal and all its callbacks get discarded.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Design Foibles&lt;/h1&gt; &#xA;&lt;p&gt;Bothing&#39;s perfect. This is a list of things that bother me, although they probably cause few or no problems in practice. I might fix them, but only between major versions because they require breaking changes.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Mutating Equality&lt;/strong&gt;: Completed futures are equated by value, but incomplete futures are equated by reference. Convenient when you want to know if two completed futures are the same, but not so convenient if you put futures in a collection that uses hash codes for faster lookup (because the hash code changes!). If you insert incomplete futures into sets, or use them as dictionary keys, you may be unable to find them in the set after they&#39;ve completed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Two cancels&lt;/strong&gt;: &lt;code&gt;TOCCancelTokenSource&lt;/code&gt; has both &lt;code&gt;tryCancel&lt;/code&gt; and &lt;code&gt;cancel&lt;/code&gt;. The only difference is the returned value. Would be simpler to just have &lt;code&gt;cancel&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;API Breakdown&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;TOCFuture&lt;/strong&gt;: An eventual result.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureWithResult:(id)resultValue&lt;/code&gt;: Returns a future that has already succeeded with the given value. If the value is a future, collapse occurs and its result/failure is used instead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureWithFailure:(id)failureValue&lt;/code&gt;: Returns a future that has already failed with the given value. Variants for timeout and cancel failures work similarly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+new&lt;/code&gt;: Returns an immortal future. (Not very useful.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureFromOperation:(id (^)(void))operation dispatchedOnQueue:(dispatch_queue_t)queue&lt;/code&gt;: Dispatches an asynchronous operation, exposing the result as a future.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureFromOperation:(id(^)(void))operation invokedOnThread:(NSThread*)thread&lt;/code&gt;: Runs an asynchronous operation, exposing the result as a future.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureWithResult:(id)resultValue afterDelay:(NSTimeInterval)delayInSeconds&lt;/code&gt;: Returns a future the completes after a delay. An &lt;code&gt;unless:&lt;/code&gt; variant allows the future to be cancelled and the timing stuff cleaned up.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureFromUntilOperation:withOperationTimeout:until:&lt;/code&gt;: Augments an until-style asynchronous operation with a timeout, returning the may-timeout future. The operation is cancelled if the timeout expires before completion. The operation is cancelled and/or its result cleaned up when the token is cancelled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureFromUnlessOperation:withOperationTimeout:&lt;/code&gt;: Augments an unless-style asynchronous operation with a timeout, returning the may-timeout future. The operation is cancelled if the timeout expires before the operation completes. An &lt;code&gt;unless&lt;/code&gt; variant allows the operation to also be cancelled if a token is cancelled before it completes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cancelledOnCompletionToken&lt;/code&gt;: Returns a &lt;code&gt;TOCCancelToken&lt;/code&gt; that becomes cancelled when the future has succeeded or failed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;state&lt;/code&gt;: Determines if the future is still able to be set (incomplete), failed, succeeded, flattening, or known to be immortal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;isIncomplete&lt;/code&gt;: Determines if the future is still able to be set, flattening, or known to be immortal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hasResult&lt;/code&gt;: Determines if the future has succeeded with a result.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hasFailed&lt;/code&gt;: Determines if the future has failed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hasFailedWithCancel&lt;/code&gt;: Determines if the future was cancelled, i.e. failed with a &lt;code&gt;TOCCancelToken&lt;/code&gt; as its failure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hasFailedWithTimeout&lt;/code&gt;: Determines if the future timed out, i.e. failed with a &lt;code&gt;TOCTimeout&lt;/code&gt; as its failure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;forceGetResult&lt;/code&gt;: Returns the future&#39;s result, but raises an exception if the future didn&#39;t succeed with a result.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;forceGetFailure&lt;/code&gt;: Returns the future&#39;s result, but raises an exception if the future didn&#39;t fail.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;finally[Do]:block [unless:token]&lt;/code&gt;: Runs a callback when the future succeeds or fails. Passes the completed future into the block. The non-Do variants return a future that will eventually contain the result of evaluating the result-returning block.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;then[Do]:block [unless:token]&lt;/code&gt;: Runs a callback when the future succeeds. Passes the future&#39;s result into the block. The non-Do variants return a future that will eventually contain the result of evaluating the result-returning block, or else the same failure as the receiving future.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;catch[Do]:block [unless:token]&lt;/code&gt;: Runs a callback when the future fails. Passes the future&#39;s failure into the block. The non-Do variants return a future that will eventually contain the same result, or else the result of evaluating the result-returning block.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;isEqualToFuture:(TOCFuture*)other&lt;/code&gt;: Determines if this future is in the same state and, if completed, has the same result/failure as the other future.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unless:(TOCCancelToken*)unless&lt;/code&gt;: Returns a future that will have the same result, unless the given token is cancelled first in which case it fails due to cancellation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;TOCFutureSource&lt;/strong&gt;: Creates and controls a TOCFuture.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;+new&lt;/code&gt;: Returns a new future source controlling a new future.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+futureSourceUntil:(TOCCancelToken*)untilCancelledToken&lt;/code&gt;: Returns a new future source controlling a new future, wired to automatically fail with cancellation if the given token is cancelled before the future is set.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;future&lt;/code&gt;: Returns the future controlled by this source.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;trySetResult:(id)result&lt;/code&gt;: Sets the controlled future to succeed with the given value. If the result is a future, collapse occurs. Returns false if the future was already set, whereas the force variant raises an exception.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;trySetFailure:(id)result&lt;/code&gt;: Sets the controlled future to fail with the given value. Returns false if the future was already set, whereas the force variant raises an exception. Variants for cancellation and timeout work similarly.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;TOCCancelToken&lt;/strong&gt;: Notifies you when operations should be cancelled.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;+cancelledToken&lt;/code&gt;: Returns an already cancelled token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+immortalToken&lt;/code&gt;: Returns a token that will never be cancelled. Just a &lt;code&gt;[TOCCancelToken new]&lt;/code&gt; token, but acts exactly like a nil cancel token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;state&lt;/code&gt;: Determines if the cancel token is cancelled, still cancellable, or known to be immortal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;isAlreadyCancelled&lt;/code&gt;: Determines if the cancel token is already cancelled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;canStillBeCancelled&lt;/code&gt;: Determines if the cancel token is not cancelled and not known to be immortal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;whenCancelledDo:(TOCCancelHandler)cancelHandler&lt;/code&gt;, &lt;code&gt;whenCancelledDo:(TOCCancelHandler)cancelHandler unless:(TOCCancelToken*)unlessCancelledToken&lt;/code&gt;: Registers a void callback to run after the token is cancelled. Runs inline if already cancelled. The unless variant allows the callback to be removed if it has not run and is no longer needed (indicated by the other token being cancelled first).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+matchFirstToCancelBetween:(TOCCancelToken*)token1 and:(TOCCancelToken*)token2&lt;/code&gt;: Returns a token that is the minimum of two tokens. It is cancelled as soon as either of them is cancelled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+matchLastToCancelBetween:(TOCCancelToken*)token1 and:(TOCCancelToken*)token2&lt;/code&gt;: Returns a token that is the maximum of two tokens. It is cancelled only when both of them is cancelled.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;TOCCancelTokenSource&lt;/strong&gt;: Creates and controls a cancel token.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;+new&lt;/code&gt;: Returns a new cancel token source that controls a new cancel token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+cancelTokenSourceUntil:(TOCCancelToken*)untilCancelledToken&lt;/code&gt;: Returns a cancel token source that controls a new cancel token, but wired to cancel automatically when the given token is cancelled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;token&lt;/code&gt;: Returns the cancel token controlled by the source.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cancel&lt;/code&gt;: Cancels the token controlled by the source. Does nothing if the token is already cancelled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tryCancel&lt;/code&gt;: Cancels the token controlled by the source, returning false if it was already cancelled.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;NSArray+&lt;/strong&gt;: &lt;em&gt;We are one. We are many. We are more.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;toc_thenAll&lt;/code&gt;, &lt;code&gt;toc_thenAllUnless:(TOCCancelToken*)unless&lt;/code&gt;: Converts from array-of-future to future-of-array. Takes an array of futures and returns a future that succeeds with an array of those futures&#39; results. If any of the futures fails, the returned future fails. Example: &lt;code&gt;@[[TOCFuture futureWithResult:@1], [TOCFuture futureWithResult:@2]].toc_thenAll&lt;/code&gt; evaluates to &lt;code&gt;[TOCFuture futureWithResult:@[@1, @2]]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;toc_finallyAll&lt;/code&gt;, &lt;code&gt;toc_finallyAllUnless:(TOCCancelToken*)unless&lt;/code&gt;: Awaits the completion of many futures. Takes an array of futures and returns a future that completes with an array of the same futures, but only after they have all completed. Example: &lt;code&gt;@[[TOCFuture futureWithResult:@1], [TOCFuture futureWithFailure:@2]].toc_finallyAll&lt;/code&gt; evaluates to &lt;code&gt;[TOCFuture futureWithResult:@[[TOCFuture futureWithResult:@1], [TOCFuture futureWithFailure:@2]]]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;toc_orderedByCompletion&lt;/code&gt;, &lt;code&gt;toc_orderedByCompletionUnless:(TOCCancelToken*)unless&lt;/code&gt;: Returns an array with the &#34;same&#34; futures, except re-ordered so futures that will complete later will come later in the array. Example: &lt;code&gt;@[[TOCFutureSource new].future, [TOCFuture futureWithResult:@1]].toc_orderedByCompletion&lt;/code&gt; returns &lt;code&gt;@[[TOCFuture futureWithResult:@1], [TOCFutureSource new].future]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;toc_raceForWinnerLastingUntil:(TOCCancelToken*)untilCancelledToken&lt;/code&gt;: Takes an array of &lt;code&gt;TOCUntilOperation&lt;/code&gt; blocks. Each block is a cancellable asynchronous operation, returning a future and taking a cancel token that cancels the operations and/or cleans up the operation&#39;s result. The returned future completes with the result of the first operation to finish (or else all of their failures). The result of the returned future is cleaned up upon cancellation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Development&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;How to Build:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Get Source Code&lt;/strong&gt;: &lt;a href=&#34;https://help.github.com/articles/fetching-a-remote&#34;&gt;Clone this git repository to your machine&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Get Dependencies&lt;/strong&gt;: &lt;a href=&#34;http://guides.cocoapods.org/using/getting-started.html&#34;&gt;Have CocoaPods installed&lt;/a&gt;. Run &lt;code&gt;pod install&lt;/code&gt; from the project directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Open Workspace&lt;/strong&gt;: Open &lt;code&gt;CollapsingFutures.xworkspace&lt;/code&gt; with XCode (not the project, the &lt;em&gt;workspace&lt;/em&gt;). Run tests and confirm that they pass.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>libgit2/objective-git</title>
    <updated>2023-08-28T01:36:00Z</updated>
    <id>tag:github.com,2023-08-28:/libgit2/objective-git</id>
    <link href="https://github.com/libgit2/objective-git" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Objective-C bindings to libgit2&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ObjectiveGit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/libgit2/objective-git&#34;&gt;&lt;img src=&#34;https://travis-ci.org/libgit2/objective-git.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ObjectiveGit provides Cocoa bindings to the &lt;a href=&#34;https://github.com/libgit2/libgit2&#34;&gt;libgit2&lt;/a&gt; library, packaged as a dynamic framework for OS X and iOS 8 or better.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;A brief summary of the available functionality:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Read: log, diff, blame, reflog, status&lt;/li&gt; &#xA; &lt;li&gt;Write: init, checkout, commit, branch, tag, reset&lt;/li&gt; &#xA; &lt;li&gt;Internals: configuration, tree, blob, object database&lt;/li&gt; &#xA; &lt;li&gt;Network: clone, fetch, push, pull&lt;/li&gt; &#xA; &lt;li&gt;Transports: HTTP, HTTPS, SSH, local filesystem&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Not all libgit2 features are available, but if you run across something missing, please consider &lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/#contributing&#34;&gt;contributing a pull request&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;Many classes in the ObjectiveGit API wrap a C struct from libgit2 and expose the underlying data and operations using Cocoa idioms. The underlying libgit2 types are prefixed with &lt;code&gt;git_&lt;/code&gt; and are often accessible via a property so that your application can take advantage of the &lt;a href=&#34;https://libgit2.github.com/libgit2/#HEAD&#34;&gt;libgit2 API&lt;/a&gt; directly.&lt;/p&gt; &#xA;&lt;p&gt;The ObjectiveGit API makes extensive use of the Cocoa NSError pattern. The public API is also decorated with nullability attributes so that you will get compile-time feedback of whether nil is allowed or not. This also makes the framework much nicer to use in Swift.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Xcode&lt;/h3&gt; &#xA;&lt;p&gt;ObjectiveGit requires Xcode 7 or greater to build the framework and run unit tests. Projects that must use an older version of Xcode can use &lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/#carthage&#34;&gt;Carthage&lt;/a&gt; to install pre-built binaries or download them &lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/#manually&#34;&gt;manually&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Other Tools&lt;/h3&gt; &#xA;&lt;p&gt;Simply run the &lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/script/bootstrap&#34;&gt;&lt;code&gt;script/bootstrap&lt;/code&gt;&lt;/a&gt; script to automatically install dependencies needed to start building the framework. This script uses &lt;a href=&#34;http://brew.sh&#34;&gt;Homebrew&lt;/a&gt; to install these tools. If your Mac does not have Homebrew, you will need to install the following manually:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Kitware/CMake&#34;&gt;cmake&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;libtool&lt;/li&gt; &#xA; &lt;li&gt;autoconf&lt;/li&gt; &#xA; &lt;li&gt;automake&lt;/li&gt; &#xA; &lt;li&gt;pkg-config&lt;/li&gt; &#xA; &lt;li&gt;libssh2 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;symlinks: lib/libssh2.a include/libssh2.h include/libssh2_sftp.h include/libssh2_publickey.h&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To develop ObjectiveGit on its own, open the &lt;code&gt;ObjectiveGitFramework.xcworkspace&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;There are three ways of including ObjectiveGit in a project:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/#carthage&#34;&gt;Carthage&lt;/a&gt; &amp;lt;-- recommended&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/#manual&#34;&gt;Manual&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/#subproject&#34;&gt;Subproject&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Carthage&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add ObjectiveGit to your &lt;a href=&#34;https://github.com/Carthage/Carthage/raw/master/Documentation/Artifacts.md#cartfile&#34;&gt;&lt;code&gt;Cartfile&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;libgit2/objective-git&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;carthage update&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Mac targets&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;On your application targets&#39; &#34;General&#34; settings tab, in the &#34;Embedded Binaries&#34; section, drag and drop the &lt;code&gt;ObjectiveGit.framework&lt;/code&gt; from the &lt;a href=&#34;https://github.com/Carthage/Carthage/raw/master/Documentation/Artifacts.md#carthagebuild&#34;&gt;&lt;code&gt;Carthage/Build/Mac&lt;/code&gt;&lt;/a&gt; folder on disk.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/W9EVyIX.png&#34; alt=&#34;Embedded Binaries&#34;&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;iOS targets&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;On your application targets&#39; &#34;General&#34; settings tab, in the &#34;Linked Frameworks and Libraries&#34; section, drag and drop the &lt;code&gt;ObjectiveGit.framework&lt;/code&gt; from the &lt;a href=&#34;https://github.com/Carthage/Carthage/raw/master/Documentation/Artifacts.md#carthagebuild&#34;&gt;&lt;code&gt;Carthage/Build/iOS&lt;/code&gt;&lt;/a&gt; folder on disk. &lt;img src=&#34;http://i.imgur.com/y4caRw0.png&#34; alt=&#34;Linked Frameworks&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;On your application targets&#39; &#34;Build Phases&#34; settings tab, click the “+” icon and choose “New Run Script Phase”. Create a Run Script with the following contents:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;/usr/local/bin/carthage copy-frameworks&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and add the paths to the frameworks you want to use under “Input Files”, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$(SRCROOT)/Carthage/Build/iOS/ObjectiveGit.framework&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/zXai6rb.png&#34; alt=&#34;Carthage Copy Frameworks&#34;&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Commit the &lt;a href=&#34;https://github.com/Carthage/Carthage/raw/master/Documentation/Artifacts.md#cartfileresolved&#34;&gt;&lt;code&gt;Cartfile.resolved&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Under “Build Settings”, add the following to “Header Search Paths”: &lt;code&gt;$(SRCROOT)/Carthage/Build/iOS/ObjectiveGit.framework/Headers/&lt;/code&gt; to avoid &lt;a href=&#34;https://github.com/libgit2/objective-git/issues/441&#34;&gt;&lt;code&gt;git2/filter.h file not found&lt;/code&gt; errors&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The different instructions for iOS works around an &lt;a href=&#34;http://www.openradar.me/radar?id=6409498411401216&#34;&gt;App Store submission bug&lt;/a&gt; triggered by universal binaries.&lt;/p&gt; &#xA;&lt;h3&gt;Copying debug symbols for debugging and crash reporting&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;dSYM files are not currently included in the GitHub release zip files. You will need to pass &lt;strong&gt;--no-use-binaries&lt;/strong&gt; to carthage in order to build locally and generate the dSYM files alongside the framework.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;On your application target&#39;s &#34;Build Phases&#34; settings tab, click the &#34;+&#34; icon and choose &#34;New Copy Files Phase&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Click the “Destination” drop-down menu and select &#34;Products Directory&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Drag and drop the &lt;code&gt;ObjectiveGit.framework.dSYM&lt;/code&gt; file from &lt;code&gt;Carthage/Build/[platform]&lt;/code&gt; into the list.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/WKJdHHQ.png&#34; alt=&#34;Copy dSYM Files&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Manual&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the latest &lt;code&gt;ObjectiveGit.framework.zip&lt;/code&gt; from &lt;a href=&#34;https://github.com/libgit2/objective-git/releases&#34;&gt;releases&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Unzip the file.&lt;/li&gt; &#xA; &lt;li&gt;Follow the Carthage instructions #3 or #4, depending on platform.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note that the iOS framework we release is a &#34;fat&#34; framework containing slices for both the iOS Simulator and devices. This makes it easy to get started with your iOS project. However, Apple does not currently allow apps containing frameworks with simulator slices to be submitted to the app store. Carthage (above) already has a solution for this. If you&#39;re looking to roll your own, take a look at Realm&#39;s &lt;a href=&#34;https://github.com/realm/realm-cocoa/raw/master/scripts/strip-frameworks.sh&#34;&gt;strip frameworks script&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Subproject&lt;/h2&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OS X: &lt;a href=&#34;https://github.com/Abizern/CommitViewer&#34;&gt;CommitViewer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;iOS: &lt;a href=&#34;https://github.com/Raekye/ObjectiveGit-iOS-Example&#34;&gt;ObjectiveGit iOS Example&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add ObjectiveGit as a submodule to your project:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;script/bootstrap&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Drag the &lt;code&gt;ObjectiveGitFramework.xcodeproj&lt;/code&gt; file into the Project Navigator pane of your project.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;ObjectiveGit-Mac&lt;/code&gt; or &lt;code&gt;ObjectiveGit-iOS&lt;/code&gt; as a target dependency of your application, depending on platform.&lt;/li&gt; &#xA; &lt;li&gt;Link your application with &lt;code&gt;ObjectiveGit.framework&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Set the “Header Search Paths” (&lt;code&gt;HEADER_SEARCH_PATHS&lt;/code&gt;) build setting to the correct path for the libgit2 headers in your project. For example, if you added the submodule to your project as &lt;code&gt;External/ObjectiveGit&lt;/code&gt;, you would set this build setting to &lt;code&gt;External/ObjectiveGit/External/libgit2/include&lt;/code&gt;. If you see build errors saying that &lt;code&gt;git2/filter.h&lt;/code&gt; cannot be found, then double-check that you set this setting correctly.&lt;/li&gt; &#xA; &lt;li&gt;Add a new &#34;Copy Files&#34; build phase, set the destination to &#34;Frameworks&#34; and add &lt;code&gt;ObjectiveGit.framework&lt;/code&gt; to the list. This will package the framework with your application as an embedded private framework.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It&#39;s hard to tell the difference between the platforms, but the Mac framework is in &lt;code&gt;build/Debug&lt;/code&gt; whereas the iOS framework is in &lt;code&gt;build/Debug-iphoneos&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Don&#39;t forget to &lt;code&gt;#import &amp;lt;ObjectiveGit/ObjectiveGit.h&amp;gt;&lt;/code&gt; or &lt;code&gt;@import ObjectiveGit;&lt;/code&gt; as you would with any other framework.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork this repository&lt;/li&gt; &#xA; &lt;li&gt;Make it awesomer (preferably in a branch named for the topic)&lt;/li&gt; &#xA; &lt;li&gt;Send a pull request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;All contributions should match GitHub&#39;s &lt;a href=&#34;https://github.com/github/objective-c-style-guide&#34;&gt;Objective-C coding conventions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can see all the amazing people that have contributed to this project &lt;a href=&#34;https://github.com/libgit2/objective-git/graphs/contributors&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;ObjectiveGit is released under the MIT license. See the &lt;a href=&#34;https://raw.githubusercontent.com/libgit2/objective-git/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
</feed>