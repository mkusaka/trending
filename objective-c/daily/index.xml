<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-03T01:39:23Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>twitter/ios-twitter-logging-service</title>
    <updated>2023-04-03T01:39:23Z</updated>
    <id>tag:github.com,2023-04-03:/twitter/ios-twitter-logging-service</id>
    <link href="https://github.com/twitter/ios-twitter-logging-service" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Twitter Logging Service is a robust and performant logging framework for iOS clients&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Twitter Logging Service&lt;/h1&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Twitter created a framework for logging in order to fulfill the following requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;fast (no blocking the main thread)&lt;/li&gt; &#xA; &lt;li&gt;thread safe&lt;/li&gt; &#xA; &lt;li&gt;as easy as &lt;code&gt;NSLog&lt;/code&gt; in most situations&lt;/li&gt; &#xA; &lt;li&gt;support pluggable &#34;output streams&#34; to which messages will be delivered&lt;/li&gt; &#xA; &lt;li&gt;&#34;output streams&#34; filter messages rather than global filtering for all &#34;output streams&#34;&lt;/li&gt; &#xA; &lt;li&gt;able to categorize log messages (log channels)&lt;/li&gt; &#xA; &lt;li&gt;able to designate importance to log messages (log levels)&lt;/li&gt; &#xA; &lt;li&gt;require messages to opt-in for persisted logs (a security requirement, fulfilled by using the &lt;em&gt;context&lt;/em&gt; feature of &lt;em&gt;TLS&lt;/em&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Twitter has been using &lt;em&gt;Twitter Logging Service&lt;/em&gt; since January 2014 with minimal changes. We&#39;ve decided to share it with the developer community.&lt;/p&gt; &#xA;&lt;h2&gt;List of good alternative logging frameworks&lt;/h2&gt; &#xA;&lt;p&gt;If &lt;em&gt;Twitter Logging Service&lt;/em&gt; doesn&#39;t meet your needs, there are many great logging frameworks available, including the following high quality and well maintained projects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CocoaLumberjack&lt;/li&gt; &#xA; &lt;li&gt;SwiftyBeaver&lt;/li&gt; &#xA; &lt;li&gt;Apache Logging Services&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;There are 3 components to consider:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;the log message and its context&lt;/li&gt; &#xA; &lt;li&gt;the logging service instance or singleton&lt;/li&gt; &#xA; &lt;li&gt;the output stream(s)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The log message is sent to the logging service which provides the message to each output stream.&lt;/p&gt; &#xA;&lt;p&gt;The logging service is configured by adding discrete output streams. Output streams encapsulate their own behavior and decisions, including filtering and logging messages. For instance, logging can mean printing to console with NSLog, writing to a file on disk, or sending the message to a remote server.&lt;/p&gt; &#xA;&lt;p&gt;Message arguments don&#39;t need to be evaluated if the message is going to be filtered out. This avoids expensive, synchronous execution of argument evaluation. The message is then packaged with context before it is sent to the logging service. Context includes information such as the log level, log channel, file name, function name, line number and timestamp.&lt;/p&gt; &#xA;&lt;p&gt;The logging service marshals the message and its context to a background queue for processing by all available output streams. Streams can then filter or output the message.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; is a dependency manager for Cocoa projects. You can install it using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    $ gem install cocoapods&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To integrate TwitterLoggingService into your Xcode project using CocoaPods, specify it in your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    platform :ios, &#39;8.0&#39;&#xA;    use_frameworks!&#xA;&#xA;    target &#34;MyApp&#34; do&#xA;        pod &#39;TwitterLoggingService&#39;, &#39;~&amp;gt; 2.9.0&#39;&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;TLSLog.h&lt;/code&gt; is the principal header for using &lt;em&gt;TwitterLoggingService&lt;/em&gt;. Just include &lt;code&gt;TLSLog.h&lt;/code&gt; or &lt;code&gt;@import TwitterLoggingService&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    // The primary macros for *TwitterLoggingService*&#xA;&#xA;    TLSLogError(channel, ...)          // Log at the TLSLogLevelError level&#xA;    TLSLogWarning(channel, ...)        // Log at the TLSLogLevelWarning level&#xA;    TLSLogInformation(channel, ...)    // Log at the TLSLogLevelInformation level&#xA;    TLSLogDebug(channel, ...)          // Log at the TLSLogLevelDebug level&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For each macro in the &lt;code&gt;TLSLog&lt;/code&gt; family of macros, &lt;code&gt;TLSCanLog&lt;/code&gt; is called first to gate whether the actual logging should occur. This saves us from having to evaluate the arguments to the log message and can provide a win in performance when calling a &lt;code&gt;TLSLog&lt;/code&gt; macro that will never end up being logged. For more on &lt;code&gt;TLSCanLog&lt;/code&gt; see &lt;code&gt;Gating TLSLog messages&lt;/code&gt; below.&lt;/p&gt; &#xA;&lt;h2&gt;TLSLog Core Macro&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    #define TLSLog(level, channel, ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;TLSLog&lt;/code&gt; is the core macro and takes 3 parameters: a &lt;code&gt;TLSLogLevel&lt;/code&gt; level, an &lt;code&gt;NSString&lt;/code&gt; channel and then an &lt;code&gt;NSString&lt;/code&gt; format with variable formatting arguments. The level and channel parameters are used to filter the log message per &lt;code&gt;TLSOutputStream&lt;/code&gt; in the &lt;code&gt;TLSLoggingService&lt;/code&gt; singleton. Providing &lt;code&gt;nil&lt;/code&gt; as the channel argument to any logging macro, function or method will result in the message not being logged.&lt;/p&gt; &#xA;&lt;h2&gt;Logging Channels, Levels and Context Objects&lt;/h2&gt; &#xA;&lt;h1&gt;Channels&lt;/h1&gt; &#xA;&lt;p&gt;The logging channel of a log message is an arbitrary string and acts as a tag to that message to further help identify what the message relates to. Channels can help to quickly identify what a log message relates to in a large code base, as well as provide a mechanism for filtering. A &lt;code&gt;TLSOutputStream&lt;/code&gt; can filter based on the logging channel in its implementation of &lt;code&gt;tls_shouldFilterLevel:channel:contextObject:&lt;/code&gt;. Providing a &lt;code&gt;nil&lt;/code&gt; channel to a log statement has the effect of not logging that message.&lt;/p&gt; &#xA;&lt;p&gt;Examples of potential logging channels: @&#34;Networking&#34; for the networking stack, @&#34;SignUp&#34; for an appâ€™s signup flow, &lt;code&gt;TLSLogChannelDefault&lt;/code&gt; as a catch all default logging channel, and @&#34;Verbose&#34; for anything you just want to log for the helluvit.&lt;/p&gt; &#xA;&lt;h1&gt;Levels&lt;/h1&gt; &#xA;&lt;p&gt;The enum &lt;code&gt;TLSLogLevel&lt;/code&gt; specifies 8 logging levels in accordance with the &lt;em&gt;syslog&lt;/em&gt; specification for logging. For practical use, however, only 4 log levels are used: &lt;code&gt;TLSLogLevelError&lt;/code&gt;, &lt;code&gt;TLSLogLevelWarning&lt;/code&gt;, &lt;code&gt;TLSLogLevelInformation&lt;/code&gt; and &lt;code&gt;TLSLogLevelDebug&lt;/code&gt;. Each log message has a specified logging level which helps quickly identify its level, &lt;code&gt;TLSLogLevelEmergency&lt;/code&gt; (or &lt;code&gt;TLSLogLevelError&lt;/code&gt; in practice) is the most important while &lt;code&gt;TLSLogLevelDebug&lt;/code&gt; is the least. &lt;code&gt;TLSOutputStream&lt;/code&gt; instances can filter a log message by its log level (in combination with its logging channel and context object) by implementing &lt;code&gt;tls_shouldFilterLevel:channel:contextObject:&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;An implementation detail to keep in mind w.r.t. logging levels is that &lt;code&gt;TLSLogLevelDebug&lt;/code&gt; is ALWAYS filtered out in non-&lt;code&gt;DEBUG&lt;/code&gt; builds.&lt;/p&gt; &#xA;&lt;h1&gt;Context Objects&lt;/h1&gt; &#xA;&lt;p&gt;Though the &lt;code&gt;TLSLog&lt;/code&gt; macros do not have a &lt;em&gt;context object&lt;/em&gt; parameter, one can provide a &lt;em&gt;context object&lt;/em&gt; to the &lt;code&gt;TLSLogging&lt;/code&gt; APIs in order to provide additional context to custom &lt;code&gt;TLSOutputStream&lt;/code&gt;s. The &lt;em&gt;context object&lt;/em&gt; will carry through the &lt;code&gt;TLSLoggingService&lt;/code&gt; so that it is available to all &lt;code&gt;TLSOutputStream&lt;/code&gt; instances. The &lt;em&gt;context object&lt;/em&gt; can be used to filter in the &lt;code&gt;tls_shouldFilterLevel:channel:contextObject:&lt;/code&gt; method. The &lt;em&gt;context object&lt;/em&gt; can also be used for additional information in the logging of a message since it carries to the &lt;code&gt;TLSLogMessageInfo&lt;/code&gt; object that&#39;s passed to &lt;code&gt;tls_outputLogInfo:&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This &lt;em&gt;context object&lt;/em&gt; provides near limitless extensibility to the &lt;code&gt;TLSLogging&lt;/code&gt; framework beyond the basics of filtering and logging based on a logging level and logging channel. Twitter uses the &lt;em&gt;context object&lt;/em&gt; as a way to secure log messages from leaking to output streams that should not log messages unless explicitely told to do so, thus protecting Personally Identifiable Information from being logged as a default behavior.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;Setting up your project to use &lt;em&gt;TwitterLoggingService&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the &lt;em&gt;TwitterLoggingService&lt;/em&gt; XCode project as a subproject of your XCode project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the &lt;em&gt;libTwitterLoggingService.a&lt;/em&gt; library or &lt;em&gt;TwitterLoggingService.framework&lt;/em&gt; framework as a dependency in your XCode project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set up your project to build the &lt;em&gt;TwitterLoggingService&lt;/em&gt; project with &lt;code&gt;DEBUG=1&lt;/code&gt; in debug builds and &lt;code&gt;RELEASE=1&lt;/code&gt; in release builds.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set up the &lt;code&gt;TLSLoggingService&lt;/code&gt; singleton on application startup (often in &lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; of your &lt;code&gt;UIApplication&lt;/code&gt;&#39;s delegate for iOS).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;    @import TLSLoggingKit;&#xA;&#xA;    // ...&#xA;&#xA;    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)options&#xA;    {&#xA;        // ...&#xA;&#xA;        // Set up the Twitter Logging Service!&#xA;        TLSLoggingService *logger = [TLSLoggingService sharedInstance];&#xA;    #if DEBUG&#xA;        if ([TLSOSLogOutputStream supported]) {&#xA;            [logger addOutputStream:[[TLSOSLogOutputStream alloc] init]];&#xA;        } else {&#xA;            [logger addOutputStream:[[TLSNSLogOutputStream alloc] init]];&#xA;        }&#xA;    #endif&#xA;        [logger addOutputStream:[[TLSFileOutputStream alloc] initWithLogFileName:@&#34;appname-info.log&#34;]];&#xA;&#xA;        // ...&#xA;    }&#xA;&#xA;    // ...&#xA;&#xA;    // Someplace else in your project&#xA;    - (void)foo&#xA;    {&#xA;        //  ...&#xA;&#xA;        if (error) {&#xA;            TLSLogError(TLSLogChannelDefault, @&#34;Encountered an error while performing foo: %@&#34;, error);&#xA;        } else {&#xA;            TLSLogInformation(@&#34;Verbose&#34;, @&#34;foo executed flawlessly!&#34;);&#xA;        }&#xA;&#xA;        // ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Best Practices&lt;/h2&gt; &#xA;&lt;p&gt;As a best practice follow these simple guidelines:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Any user sensitive information should not be logged to output streams that persist messages (including being sent over the network to be saved). You can configure your output stream to filter out logs to these sensitive channels. Or do the inverse, and only permit certain &#34;safe&#34; channels to be logged. Twitter has elected to use the pattern where only explicitely &#34;safe&#34; messages (designated via a custom context object) are logged to output streams that will persist. If in doubt, you can log to the &lt;code&gt;TLSLogLevelDebug&lt;/code&gt; log level, which is only ever logged in &lt;code&gt;DEBUG&lt;/code&gt; builds.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure &lt;code&gt;DEBUG&lt;/code&gt; builds to have a console output like &lt;code&gt;TLSNSLogOutputStream&lt;/code&gt; or &lt;code&gt;TLSStdErrOutputStream&lt;/code&gt; - but add only 1 or you&#39;ll spam the debug console.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure &lt;code&gt;RELEASE&lt;/code&gt; builds to not use the console output stream.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;Crashlytics&lt;/code&gt; to your project and add a subclass of the &lt;code&gt;TLSCrashlyticsOutputStream&lt;/code&gt; to &lt;code&gt;TLSLoggingService&lt;/code&gt; instead of using &lt;code&gt;CLSLog&lt;/code&gt;, &lt;code&gt;CLSNSLog&lt;/code&gt; or &lt;code&gt;CLS_LOG&lt;/code&gt;. You MUST subclass &lt;code&gt;TLSCrashlyticsOutputStream&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;TLSLogChannelApplicationDefault function&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;    FOUNDATION_EXTERN NSString *TLSLogChannelApplicationDefault() __attribute__((const));&#xA;    #define TLSLogChannelDefault TLSLogChannelApplicationDefault()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Retrieve a channel based on the application. You can use this as a default channel.&lt;/p&gt; &#xA;&lt;p&gt;Loads and caches the channel name in the following order of descending priority:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;kCFBundleNameKey&lt;/code&gt; of main bundle&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;kCFBundleExecutableKey&lt;/code&gt; of main bundle&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Binary executable name&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;@&#34;Default&#34;&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The default channel is available as a convenience for quick logging. However, it is recommended to always have concrete, well-defined logging channels to which output is logged (e.g. &#34;Networking&#34;, &#34;UI&#34;, &#34;Model&#34;, &#34;Cache&#34;, et al).&lt;/p&gt; &#xA;&lt;h2&gt;TLSLog Helper Functions&lt;/h2&gt; &#xA;&lt;p&gt;There are a number of &lt;strong&gt;TLSLog Helper Functions&lt;/strong&gt; and they all accept as a first parameter a &lt;code&gt;TLSLoggingService&lt;/code&gt;. If &lt;code&gt;nil&lt;/code&gt; is provided for the &lt;em&gt;service&lt;/em&gt; parameter, the shared &lt;code&gt;[TLSLoggingService sharedInstance]&lt;/code&gt; will be used. All &lt;code&gt;TLSLog&lt;/code&gt; macros use &lt;code&gt;nil&lt;/code&gt; for the &lt;em&gt;service&lt;/em&gt; parameter, but if there is different instance to be used, these helper functions support that. As an example, Twitter extends &lt;em&gt;TwitterLoggingService&lt;/em&gt; with its own set of macros so that a context is provided that defines the duration for which a message can be safely retained (e.g. to avoid retaining sensitive information), and uses custom macros that call these helper functions.&lt;/p&gt; &#xA;&lt;h2&gt;Gating TLSLog messages&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;    BOOL TLSCanLog(TLSLoggingService *service, TLSLogLevel level, NSString *channel, id contextObject); // gate for logging TLSLog messages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At the moment, &lt;code&gt;TLSCanLog&lt;/code&gt; evaluates two things (&lt;em&gt;contextObject&lt;/em&gt; is currently ignored): the cached permitted log levels and the cached not permitted log channels. A log message can log given the desired &lt;em&gt;level&lt;/em&gt; is permitted by the internal cache of known permitted &lt;code&gt;TLSLogLevel&lt;/code&gt;s based on the &lt;code&gt;outputStreams&lt;/code&gt; of &lt;code&gt;TLSLoggingService&lt;/code&gt; AND the given log &lt;em&gt;channel&lt;/em&gt; has not been cached as a known to be an &lt;em&gt;always off&lt;/em&gt; channel (for &lt;code&gt;TLSLOGMODE=1&lt;/code&gt; that is, see below for different behaviors).&lt;/p&gt; &#xA;&lt;h2&gt;TLSCANLOGMODE build setting&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;TwitterLoggingService&lt;/em&gt; supports being compiled in one of 3 different modes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;TLSCANLOGMODE=0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TLSCanLog&lt;/code&gt; will always return &lt;code&gt;YES&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Log arguments always evaluate, which can be inefficient for args that won&#39;t log&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TLSCANLOGMODE=1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TLSCanLog&lt;/code&gt; will base its return value on cached insight into what can and cannot be logged&lt;/li&gt; &#xA; &lt;li&gt;This will save on argument evalution at the minimal cost of a quick lookup of cached information&lt;/li&gt; &#xA; &lt;li&gt;This is the default if &lt;code&gt;TLSCANLOGMODE&lt;/code&gt; is not defined&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TLSCANLOGMODE=2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TLSCanLog&lt;/code&gt; will base its return value on the filtering behavior of all the registered output streams&lt;/li&gt; &#xA; &lt;li&gt;This will save on argument evalution but requires an expensive examination of all output streams&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Copyright 2013-2020 Twitter, Inc.&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0: &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34;&gt;https://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Security Issues?&lt;/h1&gt; &#xA;&lt;p&gt;Please report sensitive security issues via Twitter&#39;s bug-bounty program (&lt;a href=&#34;https://hackerone.com/twitter&#34;&gt;https://hackerone.com/twitter&lt;/a&gt;) rather than GitHub.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>incanus/GeoCarts</title>
    <updated>2023-04-03T01:39:23Z</updated>
    <id>tag:github.com,2023-04-03:/incanus/GeoCarts</id>
    <link href="https://github.com/incanus/GeoCarts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Quick example of using UTFGrid interactivity with the MapBox iOS SDK callouts.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Quick example of using UTFGrid interactivity with the MapBox iOS SDK callouts.&lt;/p&gt; &#xA;&lt;p&gt;Requires &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; to get up and running.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone repository.&lt;/li&gt; &#xA; &lt;li&gt;Download &lt;a href=&#34;http://a.tiles.mapbox.com/v3/justin.geocarts.mbtiles&#34;&gt;geocarts.mbtiles&lt;/a&gt; (~210MB) and place it in &lt;code&gt;GeoCarts/geocarts.mbtiles&lt;/code&gt;. &lt;em&gt;Sorry about the size, but this example was made for quick offline use and not optimized for size.&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pod install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open &lt;code&gt;GeoCarts.xcworkspace&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Build &amp;amp; Run&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;See the companion map online here: &lt;a href=&#34;https://tiles.mapbox.com/justin/map/geocarts&#34;&gt;https://tiles.mapbox.com/justin/map/geocarts&lt;/a&gt; Note that it was not optimized for retina displays nor touch interaction.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://support.mapbox.com/discussions/mapbox-ios-sdk/675-annotation-callout-example&#34;&gt;http://support.mapbox.com/discussions/mapbox-ios-sdk/675-annotation-callout-example&lt;/a&gt; for more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.github.com/incanus/GeoCarts/master/screenshot.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>twitter/ios-twitter-network-layer</title>
    <updated>2023-04-03T01:39:23Z</updated>
    <id>tag:github.com,2023-04-03:/twitter/ios-twitter-network-layer</id>
    <link href="https://github.com/twitter/ios-twitter-network-layer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Twitter Network Layer is a scalable and feature rich network layer built on top of NSURLSession for Apple platforms&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Twitter Network Layer (a.k.a TNL)&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;strong&gt;Twitter Network Layer&lt;/strong&gt; (&lt;strong&gt;TNL&lt;/strong&gt;) is a framework for interfacing with the &lt;strong&gt;Apple&lt;/strong&gt; provided &lt;code&gt;NSURLSession&lt;/code&gt; stack that provides additional levels of control and insight over networking requests, provides simple configurability and minimizes the cognitive load necessary to maintain a robust and wide-reaching networking system.&lt;/p&gt; &#xA;&lt;h2&gt;OSI Layering with TNL&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;Twitter Network Layer&lt;/strong&gt; sits on top of the &lt;em&gt;connection/session layer&lt;/em&gt; provided by the &lt;strong&gt;Apple NSURL&lt;/strong&gt; framework. Those frameworks are build on top of the &lt;strong&gt;HTTP/1.1&lt;/strong&gt; and &lt;strong&gt;HTTP/2&lt;/strong&gt;. The layer chart appears like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/--------------------------------------\&#xA;|                                      |&#xA;|              User Layer              |&#xA;|       The actual user (Layer 8)      |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|          Application Layer           |&#xA;|       MVC, MVVM, etc (Layer 7e)      |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|     Concrete Operation/App Layer     |  &amp;lt;------ Operations, Requests &amp;amp;&#xA;|             TNL (Layer 7d)           |          Responses built on TNL&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|     Abstract Operation/App Layer     |&#xA;|             TNL (Layer 7c)           |  &amp;lt;------ TNL&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|         Connection/App Layer         |&#xA;|        NSURL Stack (Layer 7b)        |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|          Protocol/App Layer          |&#xA;|     HTTP/1.1 &amp;amp; HTTP/2 (Layer 7a)     |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|            Presentation Layer        |&#xA;| Encryption &amp;amp; Serialization (Layer 6) |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|            Session Layer             |&#xA;|      A Feature of TCP (Layer 5)      |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|            Transport Layer           |&#xA;|             TCP (Layer 4)            |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|         Routing/Network Layer        |&#xA;|              IP (Layer 3)            |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|            Data Link Layer           |&#xA;|          IEEE 802.X (Layer 2)        |&#xA;|                                      |&#xA;|--------------------------------------|&#xA;|                                      |&#xA;|            Physical Layer            |&#xA;|          Ethernet (Layer 1)          |&#xA;|                                      |&#xA;\--------------------------------------/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Brief Overview&lt;/h2&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Twitter Network Layer&lt;/strong&gt; provides a framework on top of &lt;strong&gt;Apple&lt;/strong&gt;&#39;s &lt;code&gt;NSURLSession&lt;/code&gt; framework with numerous benefits. Here are some of the features provided by &lt;strong&gt;TNL&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All the features of &lt;code&gt;NSURLSession&lt;/code&gt;, simplified where appropriate&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSOperation&lt;/code&gt; based request operations (for &lt;code&gt;NSOperation&lt;/code&gt; features)&lt;/li&gt; &#xA; &lt;li&gt;Strong separation of roles in the framework&#39;s objects&lt;/li&gt; &#xA; &lt;li&gt;Immutable/mutable pairings of requests (&lt;code&gt;TNLHTTPRequest&lt;/code&gt;) and configurations (&lt;code&gt;TNLRequestConfiguration&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Encapsulated immutable responses (&lt;code&gt;TNLResponse&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Prioritization of requests&lt;/li&gt; &#xA; &lt;li&gt;Selectable response body consumption modes (&lt;code&gt;NSData&lt;/code&gt; storage, callback chunking or saving to file)&lt;/li&gt; &#xA; &lt;li&gt;Request hydration (enables polymorphic requests and dynamically populated requests)&lt;/li&gt; &#xA; &lt;li&gt;Dynamic retrying with retry policies&lt;/li&gt; &#xA; &lt;li&gt;More events (request operation state transitions, progress, network state/condition updates, etc)&lt;/li&gt; &#xA; &lt;li&gt;Modular delegates for separation of roles and increased reusability and easy overriding&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;The high level concept of how to use &lt;strong&gt;TNL&lt;/strong&gt; is rather straightforward:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Set up any reuseable settings (by doing any combination of the following): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Build shared accessors to resuable &lt;code&gt;TNLRequestConfiguration&lt;/code&gt; instances&lt;/li&gt; &#xA;   &lt;li&gt;Implement a &lt;code&gt;TNLRequestDelegate&lt;/code&gt; (if added functionality is desired beyond just handling the result)&lt;/li&gt; &#xA;   &lt;li&gt;Configure a &lt;code&gt;TNLRequestConfiguration&lt;/code&gt; for reuse&lt;/li&gt; &#xA;   &lt;li&gt;Configure the &lt;code&gt;TNLGlobalConfiguration&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Set up any reusable &lt;code&gt;TNLRequestOperationQueue&lt;/code&gt; objects once (ex: one for API requests, one for image requests, etc.) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;[TNLRequestOperationQueue initWithIdentifier:]&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Generate and enqueue any desired &lt;code&gt;TNLRequestOperation&lt;/code&gt; with the following objects: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequest&lt;/code&gt; conforming object (including &lt;code&gt;TNLHTTPRequest&lt;/code&gt; concrete class and &lt;code&gt;NSURLRequest&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequestConfiguration&lt;/code&gt; (optional)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequestDelegate&lt;/code&gt; (optional)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Handle the events appropriately via the callbacks, particularly the completion callback that provides the &lt;code&gt;TNLResponse&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Delegate callbacks will go to the appropriate sub-protocol in the &lt;code&gt;TNLRequestOperation&lt;/code&gt;&#39;s &lt;code&gt;TNLRequestDelegate&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;HOWTO&lt;/h1&gt; &#xA;&lt;h2&gt;Where To Start&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Twitter Network Layer&lt;/strong&gt; documentation starts with this &lt;code&gt;README.md&lt;/code&gt; and progresses through the APIs via their documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Overview of a Network Operation&lt;/h2&gt; &#xA;&lt;h3&gt;Core Objects&lt;/h3&gt; &#xA;&lt;p&gt;The core objects of a service based architecture are &lt;em&gt;request&lt;/em&gt;, &lt;em&gt;response&lt;/em&gt; and &lt;em&gt;operation/task/action&lt;/em&gt; (referred to as an &lt;em&gt;operation&lt;/em&gt; from here on). The &lt;em&gt;request&lt;/em&gt; encapsulates data to send and is not actionable; the &lt;em&gt;response&lt;/em&gt; encapsulates the data received and is not actionable; and the &lt;em&gt;operation&lt;/em&gt; is the object that delivers the &lt;em&gt;request&lt;/em&gt; and retrieves the &lt;em&gt;response&lt;/em&gt; and is the only actionable object in the set of core objects.&lt;/p&gt; &#xA;&lt;p&gt;This high level concept translates directly into a network architecture as we will have &lt;em&gt;requests&lt;/em&gt; that encapsulate the data of an &lt;em&gt;HTTP request&lt;/em&gt; which are &lt;em&gt;Headers&lt;/em&gt; and a &lt;em&gt;Body&lt;/em&gt;, &lt;em&gt;responses&lt;/em&gt; that encapsulate the data of an &lt;em&gt;HTTP response&lt;/em&gt; which are &lt;em&gt;Headers&lt;/em&gt; and a &lt;em&gt;Body&lt;/em&gt;, and last the &lt;em&gt;operation&lt;/em&gt; that executes delivering the &lt;em&gt;request&lt;/em&gt; and retrieving the &lt;em&gt;response&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Core Object Breakdown&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;request&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;encapsulates data to send&lt;/li&gt; &#xA;   &lt;li&gt;immutability provides stability&lt;/li&gt; &#xA;   &lt;li&gt;not actionable, just data&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequest&lt;/code&gt; is the protocol for requests in &lt;strong&gt;TNL&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLHTTPRequest&lt;/code&gt; and &lt;code&gt;NSURLRequest&lt;/code&gt; are concrete classes (both are immutable/mutable pairs)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;response&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;encapsulates data received&lt;/li&gt; &#xA;   &lt;li&gt;immutability provides stability&lt;/li&gt; &#xA;   &lt;li&gt;not actionable, just data&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLResponse&lt;/code&gt; is the object for responses in &lt;strong&gt;TNL&lt;/strong&gt; (composite object that includes an &lt;code&gt;NSHTTPURLResponse&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;operation&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the executing object&lt;/li&gt; &#xA;   &lt;li&gt;delivers the &lt;em&gt;request&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;retrieves the &lt;em&gt;response&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;actionable (e.g. starting, canceling, priotiziation, modifying dependencies)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequestOperation&lt;/code&gt; is the operation in &lt;strong&gt;TNL&lt;/strong&gt; (subclasses &lt;code&gt;NSOperation&lt;/code&gt;) and is backed by &lt;code&gt;NSURLSessionTask&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Support Objects&lt;/h3&gt; &#xA;&lt;p&gt;In addition to a service architecture having &lt;em&gt;requests&lt;/em&gt;, &lt;em&gt;operations&lt;/em&gt; and &lt;em&gt;responses&lt;/em&gt;; support objects are often present that aid in the management of the executing &lt;em&gt;operations&lt;/em&gt;, configuration of their behavior and delegation of decisions or events.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;configuration&lt;/em&gt; object encapsulates &lt;strong&gt;how&lt;/strong&gt; an &lt;em&gt;operation&lt;/em&gt; behaves. It will have no impact on what is sent in the &lt;em&gt;operation&lt;/em&gt; (that&#39;s the &lt;em&gt;request&lt;/em&gt;), but can modify how it is sent. For instance, the &lt;em&gt;configuration&lt;/em&gt; can indicate a maximum duration that the &lt;em&gt;operation&lt;/em&gt; can take before it should fail.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;delegate&lt;/em&gt; object provides the extensibility of on demand decision making when prudent as well as the delivery of events as the &lt;em&gt;operation&lt;/em&gt; executes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;manager&lt;/em&gt; object coordinates the execution of multiple &lt;em&gt;operations&lt;/em&gt; within a logical grouping.&lt;/p&gt; &#xA;&lt;h3&gt;Support Object Breakdown&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;configuration&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;encapsulation of behavior settings&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequestConfiguration&lt;/code&gt; is the config in &lt;strong&gt;TNL&lt;/strong&gt; (applied per &lt;em&gt;operation&lt;/em&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;NSURLSessionConfiguration&lt;/code&gt; is the config in &lt;strong&gt;NSURL&lt;/strong&gt; stack (applied per &lt;em&gt;manager&lt;/em&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;delegate&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;provides extensibility&lt;/li&gt; &#xA;   &lt;li&gt;has callbacks for on demand decisions&lt;/li&gt; &#xA;   &lt;li&gt;has callbacks for events as they occur&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequestDelegate&lt;/code&gt; is the delegate in &lt;strong&gt;TNL&lt;/strong&gt; (provided per &lt;em&gt;operation&lt;/em&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;NSURLSessionDelegate&lt;/code&gt; is the delegate in &lt;strong&gt;NSURL&lt;/strong&gt; stack (provided per &lt;em&gt;manager&lt;/em&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;manager&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;coordinator of multiple &lt;em&gt;operations&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;permits grouping of &lt;em&gt;operations&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TNLRequestOperationQueue&lt;/code&gt; is the manager object in &lt;strong&gt;TNL&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;NSURLSession&lt;/code&gt; is the manager object in &lt;strong&gt;NSURL&lt;/strong&gt; stack&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: You can already see there is a fundamental architecture difference between &lt;code&gt;NSURLSession&lt;/code&gt; networking and &lt;strong&gt;Twitter Network Layer&lt;/strong&gt;. The &lt;em&gt;configuration&lt;/em&gt; and &lt;em&gt;delegate&lt;/em&gt; per &lt;em&gt;operation&lt;/em&gt; approach in &lt;strong&gt;TNL&lt;/strong&gt; is much more scalable when dealing with dozens or hundreds of unique configurations and/or delegates given a plethora of requests and their needs. Coupling the &lt;em&gt;configuration&lt;/em&gt; and/or &lt;em&gt;delegate&lt;/em&gt; to the reusable &lt;em&gt;manager&lt;/em&gt; object(s) is unwieldy and can lead to mistakes w.r.t. correct configuration and event on a per request basis.&lt;/p&gt; &#xA;&lt;h2&gt;Building a Request&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;TNL&lt;/strong&gt; uses the &lt;code&gt;TNLRequest&lt;/code&gt; as the interface for all network requests. In practice, the protocol is used in one of 3 ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Concrete &lt;code&gt;TNLHTTPRequest&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuring a concrete &lt;code&gt;TNLHTTPRequest&lt;/code&gt; object (or &lt;code&gt;TNLMutableHTTPRequest&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;&lt;code&gt;NSURLRequest&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NSURLRequest&lt;/code&gt; explicitely conforms to &lt;code&gt;TNLRequest&lt;/code&gt; protocol via a category in &lt;strong&gt;TNL&lt;/strong&gt; making it supported as &lt;em&gt;request&lt;/em&gt; object.&lt;/li&gt; &#xA; &lt;li&gt;However, since &lt;strong&gt;TNL&lt;/strong&gt; rigidly segregates &lt;em&gt;configuration&lt;/em&gt; from &lt;em&gt;request&lt;/em&gt;, only the &lt;em&gt;request&lt;/em&gt; properties on &lt;code&gt;NSURLRequest&lt;/code&gt; are observed and the &lt;em&gt;configuration&lt;/em&gt; properties of &lt;code&gt;NSURLRequest&lt;/code&gt; are ignored.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Implementing a custom &lt;code&gt;TNLRequest&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;TNL&lt;/strong&gt; supports having anything that conforms to &lt;code&gt;TNLRequest&lt;/code&gt; as an &lt;em&gt;original request&lt;/em&gt; for an &lt;em&gt;operation&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Makes it simple for an object that encapsulates the minimal amount of information necessary to take the place as the &lt;em&gt;original request&lt;/em&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You could have a &lt;code&gt;APPRetrieveBlobRequest&lt;/code&gt; that has 1 property, the identifier for the &#34;Blob&#34; call &lt;em&gt;blobIdentifier&lt;/em&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;That object doesn&#39;t need to have any methods that actually represent anything related to an &lt;em&gt;HTTP request&lt;/em&gt; and that&#39;s ok. However, in order for the &lt;em&gt;operation&lt;/em&gt; to send the &lt;em&gt;original request&lt;/em&gt;, it needs to be able to be treated as an &lt;strong&gt;HTTP request&lt;/strong&gt;, which is to say it must conform to &lt;code&gt;TNLRequest&lt;/code&gt;. This can be done in 2 ways: &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt;have the object implement &lt;code&gt;TNLRequest&lt;/code&gt; and have its methods that populate the values by the relevant properties (in our example, the blob identifier)&lt;/li&gt; &#xA;     &lt;li&gt;have the &lt;em&gt;delegate&lt;/em&gt; implement the &lt;em&gt;request hydration&lt;/em&gt; callback to convert the opaque request into a well formed &lt;code&gt;TNLRequest&lt;/code&gt; ready for &lt;strong&gt;HTTP&lt;/strong&gt; transport.&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt;See &lt;em&gt;Custom TNLRequest&lt;/em&gt; examples&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When it comes to making the choice, it can boil down to convenience vs simplicity of reuse. If you have a one shot request that has no reuse, options &lt;strong&gt;1&lt;/strong&gt; and &lt;strong&gt;2&lt;/strong&gt; will suffice. If you have a request that can be reused throughout the code base, option &lt;strong&gt;3&lt;/strong&gt; clearly offers the cleanest interface. By having the caller only need to know the class of the request and the relevant values for populating the request, any concern over the &lt;em&gt;HTTP&lt;/em&gt; structure is completely eliminated.&lt;/p&gt; &#xA;&lt;h3&gt;Concrete TNLRequest with TNLHTTPRequest&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;TNLHTTPRequest:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;NSString *URLString = [NSString stringWithFormat:@&#34;http://api.myapp.com/blob/%tu&#34;, blobIdentifier];&#xA;NSURL *URL = [NSURL URLWithString:URLString];&#xA;TNLHTTPRequest *request = [TNLHTTPRequest GETRequestWithURL:URL&#xA;                                           HTTPHeaderFields:@{@&#34;User-Agent&#34;: [MYAPPDELEGATE userAgentString]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;TNLMutableHTTPRequest:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;NSString *URLString = [NSString stringWithFormat:@&#34;http://api.myapp.com/blob/%tu&#34;, blobIdentifier];&#xA;NSURL *URL = [NSURL URLWithString:URLString];&#xA;TNLMutableHTTPRequest *mRequest = [[TNLMutableHTTPRequest alloc] init];&#xA;mRequest.HTTPMethodValue = TNLHTTPMethodValueGET;&#xA;mRequest.URL = URL;&#xA;[mRequest setValue:[MYAPPDELEGATE userAgentString] forHTTPHeaderField:@&#34;User-Agent&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NSURLRequest&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;NSString *URLString = [NSString stringWithFormat:@&#34;http://api.myapp.com/blob/%tu&#34;, blobIdentifier];&#xA;NSURL *URL = [NSURL URLWithString:URLString];&#xA;NSMutableURLRequest *mRequest = [[NSMutableURLRequest alloc] init];&#xA;mRequest.HTTPMethod = @&#34;GET&#34;;&#xA;mRequest.URL = URL;&#xA;[mRequest setValue:[MYAPPDELEGATE userAgentString] forHTTPHeaderField:@&#34;User-Agent&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom TNLRequest&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;1) Request Hydration&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;APPRetrieveBlobRequest *request = [[APPRetrieveBlobRequest alloc] initWithBlobIdentifier:blobIdentifier];&#xA;&#xA;// ... elsewhere ...&#xA;&#xA;- (void)tnl_requestOperation:(TNLRequestOperation *)op&#xA;              hydrateRequest:(APPRetrieveBlobRequest *)request // we know the type&#xA;                  completion:(TNLRequestHydrateCompletionBlock)complete&#xA;{&#xA;     NSString *URLString = [NSString stringWithFormat:@&#34;http://api.myapp.com/blob/%tu&#34;, blobRequest.blobIdentifier];&#xA;     NSURL *URL = [NSURL URLWithString:URLString];&#xA;     TNLHTTPRequest *newReq = [TNLHTTPRequest GETRequestWithURL:URL&#xA;                                               HTTPHeaderFields:@{@&#34;User-Agent&#34;: [MYAPPDELEGATE userAgentString]}];&#xA;     complete(newReq);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;2) Request with HTTP support&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;APPRetrieveBlobRequest *request = [[APPRetrieveBlobRequest alloc] initWithBlobIdentifier:blobIdentifier];&#xA;&#xA;// ... elsewhere ...&#xA;&#xA;@implementation APPRetrieveBlobRequest&#xA;&#xA;- (NSURL *)URL&#xA;{&#xA;    NSString *URLString = [NSString stringWithFormat:@&#34;http://api.myapp.com/blob/%tu&#34;, self.blobIdentifier];&#xA;    return [NSURL URLWithString:URLString];&#xA;}&#xA;&#xA;- (NSDictionary *)allHTTPHeaderFields&#xA;{&#xA;    return @{@&#34;User-Agent&#34;:[MYAPPDELEGATE userAgentString]};&#xA;}&#xA;&#xA;// POINT OF IMPROVEMENT:&#xA;// utilize polymorphism and have an APPBaseRequest class that implements&#xA;// the &#34;allHTTPHeaderFields&#34; so that all subclasses (including APPRetrieveBlobRequest)&#xA;// will inherit the desired defaults.&#xA;// This can apply to a wide range of HTTP related TNLHTTPRequest properties&#xA;// or even composition of subcomponents that are aggregated to a single property.&#xA;// For example: the host of the URL (api.myapp.com) could be provided&#xA;// as a property on APPBaseRequest that permits subclasses to override the host, and then&#xA;// the construction of the `URL` uses composition of variation properites that the subclasses&#xA;// can provide.&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inspecting a Response&lt;/h2&gt; &#xA;&lt;p&gt;When an &lt;em&gt;operation&lt;/em&gt; completes, a &lt;em&gt;TNLResponse&lt;/em&gt; is populated and provided to the completion block or completion callback (depending on if you use a &lt;em&gt;delegate&lt;/em&gt; or not). The &lt;em&gt;TNLResponse&lt;/em&gt; has all the information necessary to understand how the &lt;em&gt;operation&lt;/em&gt; completed, as well as what information was retrieve. Additionally, with &lt;em&gt;response polymorphism&lt;/em&gt;, the &lt;em&gt;response&lt;/em&gt; can be extended to provide better contextual information regarding the result, such as parsing the &lt;em&gt;response&lt;/em&gt; body as JSON or converting the &lt;em&gt;response&lt;/em&gt; body into a &lt;code&gt;UIImage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The way you deal with a &lt;em&gt;TNLResponse&lt;/em&gt; should be systematic and straighforward:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;deal with any errors on the &lt;em&gt;response&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;em&gt;TNLResponse&lt;/em&gt; has an &lt;em&gt;operationError&lt;/em&gt; property but custom subclasses could expose other errors too.&lt;/li&gt; &#xA;   &lt;li&gt;Subclass &lt;em&gt;response&lt;/em&gt; objects that have extra errors should consider having an &lt;code&gt;anyError&lt;/code&gt; property for quick access to any error in the response.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;deal with the status code of the &lt;em&gt;response&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It is important to know that a 404 is not an &lt;em&gt;operation&lt;/em&gt; error so it won&#39;t be set as an error.&lt;/li&gt; &#xA;   &lt;li&gt;It is actually the status of the successful operation and needs to be handled accordingly.&lt;/li&gt; &#xA;   &lt;li&gt;For designs that want to treat HTTP Status codes that are not success as errors, they should expose an HTTP error on their &lt;em&gt;response&lt;/em&gt; subclass(es).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;deal with the &lt;em&gt;response&lt;/em&gt; payload &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This could be the &lt;em&gt;response&lt;/em&gt; HTTP headers, the &lt;em&gt;response&lt;/em&gt; body (as &lt;code&gt;NSData&lt;/code&gt; or a file on disk), etc&lt;/li&gt; &#xA;   &lt;li&gt;&lt;em&gt;response&lt;/em&gt; subclasses should consider deserializing their response&#39;s body into a model object and exposing it as a property for concrete interactions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;One benefit to using &lt;em&gt;response polymorphism&lt;/em&gt; is the ability to handle the &lt;em&gt;response&lt;/em&gt; and populate the &lt;em&gt;hydrated response&lt;/em&gt; with the information that&#39;s pertinent to the caller. For example: if your network operation yields JSON, and all you care about is if that JSON came through or not, at hydration time you could check for any error conditions then parse out the JSON and if everything is good have a property on the custom &lt;code&gt;TNLResponse&lt;/code&gt; subclasss that holds the &lt;code&gt;NSDictionary&lt;/code&gt; &lt;em&gt;result&lt;/em&gt; property (or &lt;code&gt;nil&lt;/code&gt; if anything along the way prevented success).&lt;/p&gt; &#xA;&lt;p&gt;Things you can inspect on a &lt;em&gt;response&lt;/em&gt; by default:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the &lt;em&gt;operation&lt;/em&gt; error (if one occurred)&lt;/li&gt; &#xA; &lt;li&gt;the &lt;em&gt;original request&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;the &lt;em&gt;response&lt;/em&gt; info &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;this object encapsulates the information of the &lt;em&gt;HTTP response&lt;/em&gt; including: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;the source of the &lt;em&gt;response&lt;/em&gt; (local cache or network load)&lt;/li&gt; &#xA;     &lt;li&gt;the &lt;em&gt;response&lt;/em&gt; body (as &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;temporarySavedFile&lt;/code&gt; if the &lt;em&gt;operation&lt;/em&gt; was configured to maintain the data)&lt;/li&gt; &#xA;     &lt;li&gt;the final &lt;code&gt;NSURLRequest&lt;/code&gt; that loaded the &lt;em&gt;response&lt;/em&gt;&lt;/li&gt; &#xA;     &lt;li&gt;the final &lt;code&gt;NSURLResponse&lt;/code&gt; object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;it also provides convenience accessors &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;the &lt;em&gt;response&lt;/em&gt;&#39;s &lt;em&gt;HTTP&lt;/em&gt; status code&lt;/li&gt; &#xA;     &lt;li&gt;the final &lt;code&gt;NSURL&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;all the &lt;em&gt;HTTP&lt;/em&gt; header fields&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;the &lt;em&gt;response&lt;/em&gt; metrics &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;detailed metric information such as execution timings, durations, bytes sent/received, attempt counts, etc.&lt;/li&gt; &#xA;   &lt;li&gt;this is the detail that &lt;strong&gt;TNL&lt;/strong&gt; exposes for every &lt;em&gt;request&lt;/em&gt;/&lt;em&gt;operation&lt;/em&gt;/&lt;em&gt;response&lt;/em&gt; that really empowers programmers to maximize impact with their networking.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Simple Network Operations&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Twitter Network Layer&lt;/strong&gt; provides a highly robust API for building network operations with a great deal of flexibility and extensibility. However, there are often occasions when you just need to execute an &lt;em&gt;operation&lt;/em&gt; and need things to be as simple as possible. &lt;strong&gt;Twitter Network Layer&lt;/strong&gt; provides all the convenience necessary for getting what needs to be done as simply as possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; NSString *URLString = [NSURL URLWithString:@&#34;http://api.myapp.com/settings&#34;];&#xA; NSURLRequest *request = [NSURLRequest requestWithURL:URLString];&#xA; [[TNLRequestOperationQueue defaultOperationQueue] enqueueRequest:request&#xA;                                                       completion:^(TNLRequestOperation *op, TNLResponse *response) {&#xA;     NSDictionary *json = nil;&#xA;     if (!response.operationError &amp;amp;&amp;amp; response.info.statusCode == 200) {&#xA;         json = [NSJSONSerialization JSONObjectWithData:response.info.data options:0 error:NULL];&#xA;     }&#xA;     if (json) {&#xA;        [self _myapp_didCompleteSettingsRequestWithJSON:json];&#xA;     } else {&#xA;        [self _myapp_didFailSettingsRequest];&#xA;     }&#xA; }];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuring Behavior&lt;/h2&gt; &#xA;&lt;p&gt;Often the vanila &lt;em&gt;configuration&lt;/em&gt; for an &lt;em&gt;operation&lt;/em&gt; will suffice, however it is common to need particular behaviors in order to get specific use cases to work. Let&#39;s take, as an example, firing &lt;em&gt;network operation&lt;/em&gt; when a specific metric is hit. In this case, we don&#39;t care about storing the &lt;em&gt;response&lt;/em&gt; body and we also want to avoid having a cache that could get in the way.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; NSURL *URL = [NSURL URLWithString:@&#34;http://api.myapp.com/recordMetric?hit=true&#34;];&#xA; TNLHTTPRequest *request = [TNLHTTPRequest GETRequestWithURL:URL HTTPHeaderFields:nil];&#xA; TNLMutableRequestConfiguration *config = [TNLMutableRequestConfiguration defaultConfiguration];&#xA; config.responseDataConsumptionMode = TNLResponseDataConsumptionModeNone;&#xA; config.URLCache = nil; // Note: &#39;URLCache&#39; is now &#39;nil&#39; by default in TNL, but the illustration still works&#xA; TNLRequestOperation *op = [TNLRequestOperation operationWithRequest:request&#xA;                                                       configuration:config&#xA;                                                          completion:^(TNLRequestOperation *o, TNLResponse *response) {&#xA;     assert(response.info.source != TNLResponseSourceLocalCache);&#xA;     const BOOL success = response.info.statusCode == 202;&#xA;     [self didSendMetric:success];&#xA; }];&#xA; [[TNLRequestOperationQueue defaultOperationQueue] enqueueOperation:op];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, sometimes, you may want to have the same defaults for certain kinds of &lt;em&gt;operations&lt;/em&gt;. That can easily be accomplished with a category or some other shared accessor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; @interface TNLRequestConfiguration (APPAdditions)&#xA; + (instancetype)configurationForMetricsFiring;&#xA; @end&#xA;&#xA; @implementation TNLRequestConfiguration (APPAdditions)&#xA;&#xA; + (instancetype)configurationForMetricsFiring&#xA; {&#xA;     static TNLRequestConfiguration* sConfig;&#xA;     static dispatch_once_t onceToken;&#xA;     dispatch_once(&amp;amp;onceToken, ^{&#xA;         TNLMutableRequestConfiguration *mConfig = [TNLMutableRequestConfiguration defaultConfiguration];&#xA;         mConfig.URLCache = nil; // Note: &#39;URLCache&#39; is now &#39;nil&#39; by default in TNL, but the illustration still works&#xA;         mConfig.responseDataConsumptionMode = TNLResponseDataConsumptionModeNone;&#xA;         sConfig = [mConfig copy];&#xA;     });&#xA;     return sConfig;&#xA; }&#xA;&#xA; @end&#xA;&#xA; @implementation TNLMutableRequestConfiguration (APPAdditions)&#xA;&#xA; + (instancetype)configurationForMetricsFiring&#xA; {&#xA;     return [[TNLRequestConfiguration configurationForMetricsFiring] mutableCopy];&#xA; }&#xA;&#xA; @end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building an Advanced API Layer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Twitter Network Layer&lt;/strong&gt; was designed from the ground up with REST APIs in mind. From simple APIs to complex API layers that require a complicated system for managing all &lt;em&gt;operations&lt;/em&gt;, &lt;strong&gt;TNL&lt;/strong&gt; provides the foundation needed.&lt;/p&gt; &#xA;&lt;p&gt;As a pattern for creating concrete &lt;em&gt;API operations&lt;/em&gt;, one of the first places to extend &lt;strong&gt;TNL&lt;/strong&gt; for your API layer is by concretely building API &lt;em&gt;requests&lt;/em&gt; and &lt;em&gt;responses&lt;/em&gt;. For &lt;em&gt;requests&lt;/em&gt;, you implement a &lt;code&gt;TNLRequest&lt;/code&gt; for every &lt;em&gt;request&lt;/em&gt; your API provides with properties that configure each request appropriately. Those &lt;em&gt;requests&lt;/em&gt; should be subclassing a &lt;em&gt;base request&lt;/em&gt; that does the busy work of pulling together the generic properties that the subclasses can override to construct the &lt;em&gt;HTTP&lt;/em&gt; properties of the &lt;em&gt;request&lt;/em&gt;. Each subclassed &lt;em&gt;request&lt;/em&gt; then overrides only what is necessary to form the valid &lt;em&gt;HTTP&lt;/em&gt; request. For things that are context or time sensitive, such as &lt;em&gt;request signing&lt;/em&gt;, &lt;em&gt;request hydration&lt;/em&gt; should be used to fully saturate the custom &lt;em&gt;API request&lt;/em&gt; at the time the &lt;em&gt;request&lt;/em&gt; is going to sent (vs at the time it was enqueued).&lt;/p&gt; &#xA;&lt;p&gt;Following from custom &lt;em&gt;API requests&lt;/em&gt; are custom &lt;em&gt;API responses&lt;/em&gt;. At a minimum, it makes sense to have an &lt;em&gt;API response&lt;/em&gt; that subclasses &lt;code&gt;TNLResponse&lt;/code&gt;. To provide an even simpler interface to callers, you can implement a &lt;em&gt;response&lt;/em&gt; per &lt;em&gt;request&lt;/em&gt;. For &lt;em&gt;response hydration&lt;/em&gt;, you merely extract whatever contextually relevant information is valuable for an &lt;em&gt;API response&lt;/em&gt; and set those properties on you custom subclass of &lt;code&gt;TNLResponse&lt;/code&gt; (such as API error, JSON result, etc).&lt;/p&gt; &#xA;&lt;p&gt;If the API layer is advanced enough, it may warrant further encapsulation with a managing object which is often referred to as an &lt;em&gt;API client&lt;/em&gt;. The &lt;em&gt;API client&lt;/em&gt; would manage the queuing of &lt;em&gt;requests&lt;/em&gt;, the delegate implementation for &lt;em&gt;operations&lt;/em&gt; (including &lt;em&gt;hydration&lt;/em&gt; for &lt;em&gt;requests&lt;/em&gt; and subclassing &lt;em&gt;responses&lt;/em&gt; so they hydrate too), the vending of &lt;em&gt;operations&lt;/em&gt;, authentication/signing of &lt;em&gt;requests&lt;/em&gt;, high level retry plus timeout behavior, custom &lt;em&gt;configurations&lt;/em&gt; and oberving &lt;em&gt;responses&lt;/em&gt; for custom handling.&lt;/p&gt; &#xA;&lt;h3&gt;Client Architecture&lt;/h3&gt; &#xA;&lt;p&gt;With an &lt;em&gt;API client&lt;/em&gt; architecture, the entire &lt;em&gt;HTTP&lt;/em&gt; structure is encapsulated and callers can deal with things just the objects they care about. No converting or validating. No configuring. The power of &lt;strong&gt;TNL&lt;/strong&gt; is completely utilized by &lt;em&gt;API client&lt;/em&gt; freeing the caller of any burden.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; APISendMessageRequest *request = [[APISendMessageRequest alloc] init];&#xA; request.sender = self.user;&#xA; request.receiver = otherUser;&#xA; request.message = message;&#xA; self.sendOp = [[APIClient sharedInstance] enqueueRequest:request&#xA;                                           completion:^(TNLRequestOperation *op, APIResponse *response) {&#xA;    [weakSelf messageSendDidComplete:op withResponse:(id)response];&#xA; }];&#xA;&#xA; // ... elsewhere ...&#xA;&#xA; - (void)messageSendDidComplete:(TNLRequestOperation *)op withResponse:(APISendMessageResponse *)response&#xA; {&#xA;     assert(self.sendOp == op);&#xA;     self.sendOp = nil;&#xA;     if (!sendMessageResponse.wasCancelled) {&#xA;        if (sendMessageResponse.succeeded) {&#xA;            [self updateUIForCompletedMessageSendWithId:sendMessageResponse.messageId];&#xA;        } else {&#xA;            [self updateUIForFailedMessageSendWithUserErrorTitle:sendMessageResponse.errorTitle&#xA;                                                    errorMessage:sendMessageResponse.errorMessage];&#xA;        }&#xA;     }&#xA; }&#xA;&#xA; // Insight:&#xA; // Presumably, APISendMessageResponse would subclass a base response like APIBaseResponse.&#xA; // Following that presumption, it would make sense that APIBaseResponse would expose&#xA; // wasCancelled, succeeded, errorTitle and errorMessage while APISendMessageResponse would&#xA; // expose messageId (since that is part of the response payload that is specific to the request).&#xA; // It would likely make sense that if the API used JSON response bodies,&#xA; // the base response would also expose a &#34;result&#34; property (NSDictionary) and&#xA; // APISendMessageResponse&#39;s implementation for messageId is just:&#xA; //    return self.result[@&#34;newMessageId&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using the Command-Line-Interface&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Twitter Network Layer&lt;/strong&gt; includes a target for building a &lt;em&gt;macOS&lt;/em&gt; tool called &lt;code&gt;tnlcli&lt;/code&gt;. You can build this tool run it from &lt;em&gt;Terminal&lt;/em&gt; from you &lt;em&gt;Mac&lt;/em&gt;, similar to &lt;em&gt;cURL&lt;/em&gt; or other networking command line utilities.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: tnlcli [options] url&#xA;&#xA;    Example: tnlcli --request-method HEAD --response-header-mode file,print --response-header-file response_headers.json https://google.com&#xA;&#xA;Argument Options:&#xA;-----------------&#xA;&#xA;    --request-config-file &amp;lt;filepath&amp;gt;     TNLRequestConfiguration as a json file&#xA;    --request-headers-file &amp;lt;filepath&amp;gt;    json file of key-value-pairs for using as headers&#xA;    --request-body-file &amp;lt;filepath&amp;gt;       file for the HTTP body&#xA;&#xA;    --request-header &#34;Field: Value&#34;      A header to provide with the request (will override the header if also in the request header file). Can provide multiple headers.&#xA;    --request-config &#34;config: value&#34;     A config setting for the TNLRequestConfiguration of the request (will override the config if also in the request config file). Can provide multiple configs.&#xA;    --request-method &amp;lt;method&amp;gt;            HTTP Method from Section 9 in HTTP/1.1 spec (RFC 2616), such as GET, POST, HEAD, etc&#xA;&#xA;    --response-body-mode &amp;lt;mode&amp;gt;          &#34;file&#34; or &#34;print&#34; or a combo using commas&#xA;    --response-body-file &amp;lt;filepath&amp;gt;      file for the response body to save to (requires &#34;file&#34; for --response-body-mode&#xA;    --response-headers-mode &amp;lt;mode&amp;gt;       &#34;file&#34; or &#34;print&#34; or a combo using commas&#xA;    --response-headers-file &amp;lt;filepath&amp;gt;   file for the response headers to save to (as json)&#xA;&#xA;    --dump-cert-chain-directory &amp;lt;dir&amp;gt;    directory for the certification chain to be dumped to (as DER files)&#xA;&#xA;    --verbose                            Will print verbose information and force the --response-body-mode and --responde-headers-mode to have &#34;print&#34;.&#xA;    --version                            Will print ther version information.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Copyright 2014-2020 Twitter, Inc.&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0: &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34;&gt;https://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Security Issues?&lt;/h1&gt; &#xA;&lt;p&gt;Please report sensitive security issues via Twitter&#39;s bug-bounty program (&lt;a href=&#34;https://hackerone.com/twitter&#34;&gt;https://hackerone.com/twitter&lt;/a&gt;) rather than GitHub.&lt;/p&gt;</summary>
  </entry>
</feed>