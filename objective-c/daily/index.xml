<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-04T01:38:21Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yourkarma/JWT</title>
    <updated>2022-09-04T01:38:21Z</updated>
    <id>tag:github.com,2022-09-04:/yourkarma/JWT</id>
    <link href="https://github.com/yourkarma/JWT" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A JSON Web Token implementation in Objective-C.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://jwt.io/&#34;&gt;&lt;img src=&#34;http://jwt.io/assets/logo.svg?sanitize=true&#34; alt=&#34;JWT&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/yourkarma/JWT&#34;&gt;&lt;img src=&#34;https://travis-ci.org/yourkarma/JWT.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/JWT&#34;&gt;&lt;img src=&#34;http://img.shields.io/cocoapods/v/JWT.svg?style=flat&#34; alt=&#34;Pod Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/JWT&#34;&gt;&lt;img src=&#34;http://img.shields.io/cocoapods/p/JWT.svg?style=flat&#34; alt=&#34;Pod Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/ObjectiveC-JWT/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/ObjectiveC-JWT/community.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;JWT&lt;/h1&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html&#34;&gt;JSON Web Token&lt;/a&gt; implementation in Objective-C.&lt;/p&gt; &#xA;&lt;h1&gt;What&#39;s new in master and bleeding edge.&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Version Three release (?)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yourkarma/JWT/master/Documentation/Prerelease/custom_claims.md&#34;&gt;Custom Claims&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;EC algorithms support.&lt;/li&gt; &#xA; &lt;li&gt;Keys extraction from Pem files has been updated.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Custom Claims.&lt;/h2&gt; &#xA;&lt;h3&gt;Deprecation.&lt;/h3&gt; &#xA;&lt;p&gt;Old ClaimsSet API has been deprecated and will be removed in API version 3.0.&lt;/p&gt; &#xA;&lt;h3&gt;Process.&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define custom serializer for a claim.&lt;/li&gt; &#xA; &lt;li&gt;Define custom verifier for a claim.&lt;/li&gt; &#xA; &lt;li&gt;Register new claim with serializer and verifier at claims set coordinator.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yourkarma/JWT/master/Documentation/Prerelease/custom_claims.md&#34;&gt;Example&lt;/a&gt;.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)test {&#xA;    /// Setup ClaimsSetCoordinator&#xA;    __auto_type claim = JWTClaimVariations.intersectionOfIntervals;&#xA;    __auto_type claimSerializer = JWTClaimSerializerVariations.interval;&#xA;    __auto_type claimVerifier = JWTClaimVerifierVariations.intersection;&#xA;&#xA;    id&amp;lt;JWTClaimsSetCoordinatorProtocol&amp;gt; claimsSetCoordinator = [JWTClaimsSetCoordinatorBase new];&#xA;    [claimsSetCoordinator registerClaim:claim serializer:claimSerializer verifier:claimVerifier forClaimName:JWTClaimsNames.intersectionOfIntervals];&#xA;&#xA;    __auto_type deserialized = ({&#xA;        claimsSetCoordinator.configureClaimsSet(^JWTClaimsSetDSLBase *(JWTClaimsSetDSLBase *claimsSetDSL) {&#xA;            claimsSetDSL.intersection = @[@(2), @(5)];&#xA;            return claimsSetDSL;&#xA;        });&#xA;        self.claimsSetCoordinator.claimsSetStorage;&#xA;    });&#xA;    &#xA;    __auto_type serialized = ({&#xA;        __auto_type dictionary = [self.claimsSetCoordinator.claimsSetSerializer dictionaryFromClaimsSet:deserialized];&#xA;        dictionary;&#xA;    });&#xA;    &#xA;    __auto_type result = @{&#xA;        JWTClaimsNames.intersectionOfIntervals : @&#34;2,5&#34;&#xA;    };&#xA;    XCTAssertEqual(serialized.count, 1);&#xA;    XCTAssertEqualObjects(serialized, result);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;EC algorithms support.&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites.&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Certificate and P12 for Public and Private keys accordingly.&lt;/li&gt; &#xA; &lt;li&gt;Pem files with keys in &lt;em&gt;ANSI X9.63&lt;/em&gt; format.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSString *privateKeyString = @&#34;&amp;lt;ANSI X9.63 formatted key&amp;gt;&#34;;&#xA;NSString *publicKeyString = @&#34;&amp;lt;ANSI X9.63 formatted key&amp;gt;&#34;;&#xA;&#xA;// Note: We should pass type of key. Default type is RSA.&#xA;NSDictionary *parameters = @{JWTCryptoKey.parametersKeyBuilder : JWTCryptoKeyBuilder.new.keyTypeEC};&#xA;&#xA;id &amp;lt;JWTCryptoKeyProtocol&amp;gt; privateKey = [[JWTCryptoKeyPrivate alloc] initWithPemEncoded:privateKeyString parameters:parameters error:nil];&#xA;id &amp;lt;JWTCryptoKeyProtocol&amp;gt; publicKey = [[JWTCryptoKeyPublic alloc] initWithPemEncoded:publicKeyString parameters:parameters error:nil];&#xA;&#xA;// Note: JWTAlgorithmRSFamilyDataHolder will be renamed to something more appropriate. It can holds any asymmetric keys pair (private and public).&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; holder = [JWTAlgorithmRSFamilyDataHolder new].signKey(privateKey).verifyKey(publicKey).algorithmName(JWTAlgorithmNameES256);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;What&#39;s new in Version 3.0&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fluent style expanded.&lt;/li&gt; &#xA; &lt;li&gt;Coding result types added.&lt;/li&gt; &#xA; &lt;li&gt;Algorithms and data holders.&lt;/li&gt; &#xA; &lt;li&gt;Algorithms and data holders chain.&lt;/li&gt; &#xA; &lt;li&gt;Keys loaded from Pem files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction to Algorithms data holders and chain.&lt;/h2&gt; &#xA;&lt;p&gt;You have an algorithm, a secret data and an unknown jwt token. Let&#39;s try to decode it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// create token&#xA;NSString *token = @&#34;...&#34;;&#xA;&#xA;// possible that algorithm could return error.&#xA;// you could try use algorithm and data chain.&#xA;&#xA;NSString *firstSecret = @&#34;first&#34;;&#xA;NSString *firstAlgorithmName = JWTAlgorithmNameHS384;&#xA;&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; firstHolder = [JWTAlgorithmHSFamilyDataHolder new].algorithmName(firstAlgorithmName).secret(firstSecret);&#xA;&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; errorHolder = [JWTAlgorithmNoneDataHolder new];&#xA;&#xA;// chain together.&#xA;JWTAlgorithmDataHolderChain *chain = [[JWTAlgorithmDataHolderChain alloc] initWithHolders:@[firstHolder, errorHolder]];&#xA;&#xA;// or add them in builder&#xA;[JWTDecodingBuilder decodeMessage:token].addHolder(firstHolder).addHolder(errorHolder);&#xA;&#xA;// or add them as chain&#xA;[JWTDecodingBuilder decodeMessage:token].chain(chain);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Maybe you would like to try different secrets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// possible that your algorithm has several secrets.&#xA;// you don&#39;t know which secret to use.&#xA;// but you want to decode it.&#xA;NSString *firstSecret = @&#34;first&#34;;&#xA;NSArray *manySecrets = @[@&#34;second&#34;, @&#34;third&#34;, @&#34;forty two&#34;];&#xA;// translate to data&#xA;NSArray *manySecretsData = @[];&#xA;for (NSString *secret in manySecrets) {&#xA;    NSData *secretData = [JWTBase64Coder dataWithBase64UrlEncodedString:secret];&#xA;    if (secret) {&#xA;        manySecretsData = [manySecretsData arrayByAddingObject:secretData];&#xA;    }&#xA;}&#xA;&#xA;NSString *algorithmName = JWTAlgorithmNameHS384;&#xA;&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; firstHolder = [JWTAlgorithmHSFamilyDataHolder new].algorithmName(algorithmName).secret(firstSecret);&#xA;&#xA;// lets create chain&#xA;JWTAlgorithmDataHolderChain *chain = [JWTAlgorithmDataHolderChain chainWithHolder:firstHolder];&#xA;&#xA;// and lets populate chain with secrets.&#xA;NSLog(@&#34;chain has: %@&#34;, chain.debugDescription);&#xA;&#xA;JWTAlgorithmDataHolderChain *expandedChain = [chain chainByPopulatingAlgorithm:firstHolder.currentAlgorithm withManySecretData:manySecretsData];&#xA;&#xA;// now we have expanded chain with many secrets and one algorithm.&#xA;NSLog(@&#34;expanded chain has: %@&#34;, expandedChain.debugDescription);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Decode and encode with chain.&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;JWTClaimsSet *claimsSet = [[JWTClaimsSet alloc] init];&#xA;// fill it&#xA;claimsSet.issuer = @&#34;Facebook&#34;;&#xA;claimsSet.subject = @&#34;Token&#34;;&#xA;claimsSet.audience = @&#34;https://jwt.io&#34;;&#xA;&#xA;// encode it&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS384&#34;;&#xA;NSDictionary *headers = @{@&#34;custom&#34;:@&#34;value&#34;};&#xA;&#xA;id&amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt;holder = [JWTAlgorithmHSFamilyDataHolder new].algorithmName(algorithmName).secret(secret);&#xA;&#xA;JWTCodingResultType *result = [JWTEncodingBuilder encodeClaimsSet:claimsSet].headers(headers).addHolder(holder).result;&#xA;&#xA;NSString *encodedToken = result.successResult.encoded;&#xA;if (result.successResult) {&#xA;    // handle encoded result&#xA;    NSLog(@&#34;encoded result: %@&#34;, result.successResult.encoded);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;encode failed, error: %@&#34;, result.errorResult.error);&#xA;}&#xA;&#xA;// decode it&#xA;// you can set any property that you want, all properties are optional&#xA;JWTClaimsSet *trustedClaimsSet = [claimsSet copy];&#xA;&#xA;NSNumber *options = @(JWTCodingDecodingOptionsNone);&#xA;NSString *yourJwt = encodedToken; // from previous example&#xA;JWTCodingResultType *decodedResult = [JWTDecodingBuilder decodeMessage:yourJwt].claimsSet(claimsSet).addHolder(holder).options(options).and.result;&#xA;&#xA;if (decodedResult.successResult) {&#xA;    // handle decoded result&#xA;    NSLog(@&#34;decoded result: %@&#34;, decodedResult.successResult.headerAndPayloadDictionary);&#xA;    NSLog(@&#34;headers: %@&#34;, decodedResult.successResult.headers);&#xA;    NSLog(@&#34;payload: %@&#34;, decodedResult.successResult.payload);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;decode failed, error: %@&#34;, decodedResult.errorResult.error);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Keys loaded from Pem files.&lt;/h2&gt; &#xA;&lt;p&gt;You have a key in pem file. And you want to use it directly for sign/verify. Suppose, that &#34;public_rsa.pem&#34; and &#34;private_rsa.pem&#34; are public and private keys in pem format.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Load keys&#xA;- (NSString *)pemKeyStringFromFileWithName:(NSString *)string inBundle:(NSBundle *)bundle {&#xA;    NSURL *fileURL = [bundle URLForResource:name withExtension:@&#34;pem&#34;];&#xA;    NSError *error = nil;&#xA;    NSString *fileContent = [NSString stringWithContentsOfURL:fileURL encoding:NSUTF8StringEncoding error:&amp;amp;error];&#xA;    if (error) {&#xA;        NSLog(@&#34;%@ error: %@&#34;, self.debugDescription, error);&#xA;        return nil;&#xA;    }&#xA;}&#xA;&#xA;// Sign and verify&#xA;- (void)signAndVerifyWithPrivateKeyPemString:(NSString *)privateKey publicKeyPemString:(NSString *)publicKey privateKeyPassphrase:(NSString *)passphrase {&#xA;    NSString *algorithmName = @&#34;RS256&#34;;&#xA;&#xA;    id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; signDataHolder = [JWTAlgorithmRSFamilyDataHolder new].keyExtractorType([JWTCryptoKeyExtractor privateKeyWithPEMBase64].type).privateKeyCertificatePassphrase(passphrase).algorithmName(algorithmName).secret(privateKey);&#xA;&#xA;    id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; verifyDataHolder = [JWTAlgorithmRSFamilyDataHolder new].keyExtractorType([JWTCryptoKeyExtractor publicKeyWithPEMBase64].type).algorithmName(algorithmName).secret(publicKey);&#xA;&#xA;    // sign&#xA;    NSDictionary *payloadDictionary = @{@&#34;hello&#34;: @&#34;world&#34;};&#xA;&#xA;    JWTCodingBuilder *signBuilder = [JWTEncodingBuilder encodePayload:payloadDictionary].addHolder(signDataHolder);&#xA;    JWTCodingResultType *signResult = signBuilder.result;&#xA;    NSString *token = nil;&#xA;    if (signResult.successResult) {&#xA;        // success&#xA;        NSLog(@&#34;%@ success: %@&#34;, self.debugDescription, signResult.successResult.encoded);&#xA;        token = signResult.successResult.encoded;&#xA;    }&#xA;    else {&#xA;        // error&#xA;        NSLog(@&#34;%@ error: %@&#34;, self.debugDescription, signResult.errorResult.error);&#xA;    }&#xA;&#xA;    // verify&#xA;    if (token == nil) {&#xA;        NSLog(@&#34;something wrong&#34;);&#xA;    }&#xA;&#xA;    JWTCodingBuilder *verifyBuilder = [JWTDecodingBuilder decodeMessage:token].addHolder(verifyDataHolder);&#xA;    JWTCodingResultType *verifyResult = verifyBuilder.result;&#xA;    if (verifyResult.successResult) {&#xA;        // success&#xA;        NSLog(@&#34;%@ success: %@&#34;, self.debugDescription, verifyResult.successResult.payload);&#xA;        token = verifyResult.successResult.encoded;&#xA;    }&#xA;    else {&#xA;        // error&#xA;        NSLog(@&#34;%@ error: %@&#34;, self.debugDescription, verifyResult.errorResult.error);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Experiments in Version 2.0&lt;/h1&gt; &#xA;&lt;h2&gt;Whitelists possible algorithms.&lt;/h2&gt; &#xA;&lt;p&gt;When you need to decode jwt by several algorithms you could specify their names in whitelist. Later this feature possible will migrate to options. For example, someone returns result or error.&lt;/p&gt; &#xA;&lt;h3&gt;Limitations&lt;/h3&gt; &#xA;&lt;p&gt;Restricted to pair (algorithm or none) due to limitations of unique &lt;code&gt;secret&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSString *jwtResultOrError = /*...*/;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;JWTBuilder *builder = [JWT decodeMessage:jwtResultOrError].secret(@&#34;secret&#34;).whitelist(@[@&#34;HS256&#34;, @&#34;none&#34;]);&#xA;NSDictionary *decoded = builder.decode;&#xA;if (builder.jwtError) {&#xA;    // oh!&#xA;}&#xA;else {&#xA;    NSDictionary *payload = decoded[@&#34;payload&#34;];&#xA;    NSDictionary *header = decoded[@&#34;header&#34;];&#xA;    NSArray *tries = decoded[@&#34;tries&#34;]; // will be evolded into something appropriate later.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;What&#39;s new in Version 2.0&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Old plain style deprecated.&lt;/li&gt; &#xA; &lt;li&gt;Use modern fluent style instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSDictionary *payload = @{@&#34;foo&#34; : @&#34;bar&#34;};&#xA;NSString *secret = @&#34;secret&#34;;&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:@&#34;HS256&#34;];&#xA;// Deprecated&#xA;[JWT encodePayload:payload withSecret:secret algorithm:algorithm];&#xA;&#xA;// Modern&#xA;[JWTBuilder encodePayload:payload].secret(secret).algorithm(algorithm).encode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Add the following to your &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#34;JWT&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install via Cartfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;yourkarma/JWT&#34; &#34;master&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and &lt;code&gt;import JWT&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;JWTBuilder&lt;/h2&gt; &#xA;&lt;p&gt;To encode &amp;amp; decode JWTs, use fluent style with the &lt;code&gt;JWTBuilder&lt;/code&gt; interface&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;+ (JWTBuilder *)encodePayload:(NSDictionary *)payload;&#xA;+ (JWTBuilder *)encodeClaimsSet:(JWTClaimsSet *)claimsSet;&#xA;+ (JWTBuilder *)decodeMessage:(NSString *)message;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, JWTBuilder has interface from both decoding and encoding.&lt;/p&gt; &#xA;&lt;p&gt;Note: some attributes are encode-only or decode-only.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#pragma mark - Encode only&#xA;*payload;&#xA;*headers;&#xA;*algorithm;&#xA;&#xA;#pragma mark - Decode only&#xA;*message&#xA;*options // as forcedOption from jwt decode functions interface.&#xA;*whitelist  //optional array of algorithm names to whitelist for decoding&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can inspect JWTBuilder by &lt;code&gt;jwt&lt;/code&gt;-prefixed attributes.&lt;/p&gt; &#xA;&lt;p&gt;You can set JWTBuilder attributes by fluent style (block interface).&lt;/p&gt; &#xA;&lt;p&gt;You can encode arbitrary payloads like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSDictionary *payload = @{@&#34;foo&#34; : @&#34;bar&#34;};&#xA;NSString *secret = @&#34;secret&#34;;&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:@&#34;HS256&#34;];&#xA;&#xA;[JWTBuilder encodePayload:payload].secret(@&#34;secret&#34;).algorithm(algorithm).encode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using reserved claim names you can encode your claim set like so (all properties are optional):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;JWTClaimsSet *claimsSet = [[JWTClaimsSet alloc] init];&#xA;claimsSet.issuer = @&#34;Facebook&#34;;&#xA;claimsSet.subject = @&#34;Token&#34;;&#xA;claimsSet.audience = @&#34;http://yourkarma.com&#34;;&#xA;claimsSet.expirationDate = [NSDate distantFuture];&#xA;claimsSet.notBeforeDate = [NSDate distantPast];&#xA;claimsSet.issuedAt = [NSDate date];&#xA;claimsSet.identifier = @&#34;thisisunique&#34;;&#xA;claimsSet.type = @&#34;test&#34;;&#xA;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:@&#34;HS256&#34;];&#xA;&#xA;[JWTBuilder encodeClaimsSet:claimsSet].secret(secret).algorithm(algorithm).encode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can decode a JWT like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSString *jwtToken = @&#34;header.payload.signature&#34;;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS256&#34;; //Must specify an algorithm to use&#xA;&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secret(secret).algorithmName(algorithmName).decode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to check claims while decoding, you could use next sample of code (all properties are optional):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Trusted Claims Set&#xA;JWTClaimsSet *trustedClaimsSet = [[JWTClaimsSet alloc] init];&#xA;trustedClaimsSet.issuer = @&#34;Facebook&#34;;&#xA;trustedClaimsSet.subject = @&#34;Token&#34;;&#xA;trustedClaimsSet.audience = @&#34;http://yourkarma.com&#34;;&#xA;trustedClaimsSet.expirationDate = [NSDate date];&#xA;trustedClaimsSet.notBeforeDate = [NSDate date];&#xA;trustedClaimsSet.issuedAt = [NSDate date];&#xA;trustedClaimsSet.identifier = @&#34;thisisunique&#34;;&#xA;trustedClaimsSet.type = @&#34;test&#34;;&#xA;&#xA;NSString *message = @&#34;encodedJwt&#34;;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;chosenAlgorithm&#34;&#xA;&#xA;JWTBuilder *builder = [JWTBuilder decodeMessage:jwt].secret(secret).algorithmName(algorithmName).claimsSet(trustedClaimsSet);&#xA;NSDictionary *payload = builder.decode;&#xA;&#xA;if (builder.jwtError == nil) {&#xA;    // do your work here&#xA;}&#xA;else {&#xA;    // handle error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to enforce a whitelist of valid algorithms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSArray *whitelist = @[@&#34;HS256&#34;, @&#34;HS512&#34;];&#xA;NSString *jwtToken = @&#34;header.payload.signature&#34;;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS256&#34;;&#xA;&#xA;//Returns nil&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secret(secret).algorithmName(algorithmName).whitelist(@[]).decode;&#xA;&#xA;//Returns the decoded payload&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secret(secret).algorithmName(algorithmName).whitelist(whitelist).decode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encode / Decode Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// suppose, that you create ClaimsSet&#xA;JWTClaimsSet *claimsSet = [[JWTClaimsSet alloc] init];&#xA;// fill it&#xA;claimsSet.issuer = @&#34;Facebook&#34;;&#xA;claimsSet.subject = @&#34;Token&#34;;&#xA;claimsSet.audience = @&#34;http://yourkarma.com&#34;;&#xA;&#xA;// encode it&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS384&#34;;&#xA;NSDictionary *headers = @{@&#34;custom&#34;:@&#34;value&#34;};&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:algorithmName];&#xA;&#xA;JWTBuilder *encodeBuilder = [JWT encodeClaimsSet:claimsSet];&#xA;NSString *encodedResult = encodeBuilder.secret(secret).algorithm(algorithm).headers(headers).encode;&#xA;&#xA;if (encodeBuilder.jwtError == nil) {&#xA;    // handle encoded result&#xA;    NSLog(@&#34;encoded result: %@&#34;, encodedResult);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;encode failed, error: %@&#34;, encodeBuilder.jwtError);&#xA;}&#xA;&#xA;// decode it&#xA;// you can set any property that you want, all properties are optional&#xA;JWTClaimsSet *trustedClaimsSet = [claimsSet copy];&#xA;&#xA;// decode forced ? try YES&#xA;BOOL decodeForced = NO;&#xA;NSNumber *options = @(decodeForced);&#xA;NSString *yourJwt = encodedResult; // from previous example&#xA;NSString *yourSecret = secret; // from previous example&#xA;NSString *yourAlgorithm = algorithmName; // from previous example&#xA;JWTBuilder *decodeBuilder = [JWT decodeMessage:yourJwt];&#xA;NSDictionary *decodedResult = decodeBuilder.message(yourJwt).secret(yourSecret).algorithmName(yourAlgorithm).claimsSet(trustedClaimsSet).options(options).decode;&#xA;if (decodeBuilder.jwtError == nil) {&#xA;    // handle decoded result&#xA;    NSLog(@&#34;decoded result: %@&#34;, decodedResult);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;decode failed, error: %@&#34;, decodeBuilder.jwtError);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;NSData&lt;/h4&gt; &#xA;&lt;p&gt;You can also encode/decode using a secret that is represented as an NSData object&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//Encode&#xA;NSData *secretData = &#34;&amp;lt;your data&amp;gt;&#34;;&#xA;NSString *algorithmName = @&#34;HS384&#34;;&#xA;NSDictionary *headers = @{@&#34;custom&#34;:@&#34;value&#34;};&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:algorithmName];&#xA;&#xA;JWTBuilder *encodeBuilder = [JWT encodeClaimsSet:claimsSet];&#xA;NSString *encodedResult = encodeBuilder.secretData(secretData).algorithm(algorithm).headers(headers).encode;&#xA;&#xA;//Decode&#xA;NSString *jwtToken = @&#34;header.payload.signature&#34;;&#xA;NSData *secretData = &#34;&amp;lt;your data&amp;gt;&#34;&#xA;NSString *algorithmName = @&#34;HS256&#34;; //Must specify an algorithm to use&#xA;&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secretData(secretData).algorithmName(algorithmName).decode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Algorithms&lt;/h1&gt; &#xA;&lt;p&gt;The following algorithms are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RS256&lt;/li&gt; &#xA; &lt;li&gt;HS512 - HMAC using SHA-512.&lt;/li&gt; &#xA; &lt;li&gt;HS256 / HS384 / HS512&lt;/li&gt; &#xA; &lt;li&gt;None&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;RS256 usage.&lt;/h2&gt; &#xA;&lt;p&gt;For example, you have your file with privateKey: &lt;code&gt;file.p12&lt;/code&gt;. And you have a secret passphrase for that file: &lt;code&gt;secret&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Encode&#xA;NSDictionary *payload = @{@&#34;payload&#34; : @&#34;hidden_information&#34;};&#xA;NSString *algorithmName = @&#34;RS256&#34;;&#xA;&#xA;NSString *filePath = [[NSBundle mainBundle] pathForResource:@&#34;secret_key&#34; ofType:@&#34;p12&#34;];&#xA;NSData *privateKeySecretData = [NSData dataWithContentsOfFile:filePath];&#xA;&#xA;NSString *passphraseForPrivateKey = @&#34;secret&#34;;&#xA;&#xA;JWTBuilder *builder = [JWTBuilder encodePayload:payload].secretData(privateKeySecretData).privateKeyCertificatePassphrase(passphraseForPrivateKey).algorithmName(algorithmName);&#xA;NSString *token = builder.encode;&#xA;&#xA;// check error&#xA;if (builder.jwtError == nil) {&#xA;    // handle result&#xA;}&#xA;else {&#xA;    // error occurred.&#xA;}&#xA;&#xA;// Decode&#xA;// Suppose, that you get token from previous example. You need a valid public key for a private key in previous example.&#xA;// Private key stored in @&#34;secret_key.p12&#34;. So, you need public key for that private key.&#xA;NSString *publicKey = @&#34;...&#34;; // load public key. Or use it as raw string.&#xA;&#xA;algorithmName = @&#34;RS256&#34;;&#xA;&#xA;JWTBuilder *decodeBuilder = [JWTBuilder decodeMessage:token].secret(publicKey).algorithmName(algorithmName);&#xA;NSDictionary *envelopedPayload = decodeBuilder.decode;&#xA;&#xA;// check error&#xA;if (decodeBuilder.jwtError == nil) {&#xA;    // handle result&#xA;}&#xA;else {&#xA;    // error occurred.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional algorithms can be added by implementing the &lt;code&gt;JWTAlgorithm&lt;/code&gt; protocol.&lt;/p&gt; &#xA;&lt;h2&gt;Before pull request&lt;/h2&gt; &#xA;&lt;p&gt;Please, read &lt;a href=&#34;https://github.com/yourkarma/JWT/raw/master/.github/CONTRIBUTING.md&#34;&gt;Contribution notes&lt;/a&gt; before make pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Powered by&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com&#34;&gt;&lt;img src=&#34;https://www.jetbrains.com/apple-touch-icon-180x180.png&#34; alt=&#34;JetBrains&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ekscrypto/Base64</title>
    <updated>2022-09-04T01:38:21Z</updated>
    <id>tag:github.com,2022-09-04:/ekscrypto/Base64</id>
    <link href="https://github.com/ekscrypto/Base64" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Objective-C Base64 Additions for NSData and NSString&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/ekscrypto/Base64/actions/workflows/swift.yml/badge.svg?sanitize=true&#34; alt=&#34;swift workflow&#34;&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/issues/ekscrypto/Base64&#34; alt=&#34;Issues&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/ekscrypto/Base64&#34; alt=&#34;Releases&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Base64 Additions for Objective-C on Mac OS X and iOS&lt;/h1&gt; &#xA;&lt;h2&gt;LICENSING&lt;/h2&gt; &#xA;&lt;p&gt;The project is dual licensed&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Public Domain&lt;/li&gt; &#xA; &lt;li&gt;MIT&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Use it under whichever of these two licensing options that are allowed in your country and you feel the most comfortable with.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;IMPORTANT&lt;/em&gt; If you have access to Swift libraries, use the built-in Base64 functions. They are faster in most cases.&lt;/p&gt; &#xA;&lt;h3&gt;Installation: Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;In your Package.swift, add&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import PackageDescription&#xA;&#xA;let package = Package(&#xA;    name: &#34;MyApp&#34;,&#xA;    targets: [],&#xA;    dependencies: [&#xA;        .Package(url: &#34;https://github.com/ekscrypto/Base64.git&#34;, .upToNextMajor(from: &#34;1.2.2&#34;))&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation: Cococapods&lt;/h3&gt; &#xA;&lt;p&gt;Add the following line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39;&#xA;platform :ios, &#39;8.0&#39;&#xA;use_frameworks!&#xA;&#xA;target &#39;&amp;lt;Your Target Name&amp;gt;&#39; do&#xA;    pod &#39;Base64&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage: Objective-C&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Objective-C&#34;&gt;NSString *helloWorld = @&#34;Hello World&#34;;&#xA;NSString *helloInBase64 = [helloWorld base64String];&#xA;NSString *helloDecoded = [NSString stringFromBase64String:helloInBase64];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage: Swift&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;NOT RECOMMENDED: If you have access to the built-in base64 functions offered by Swift, use them. They are much faster.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Using MF_Base64codec directly&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let data = &#34;Hello World&#34;.data(using: .utf8)!&#xA;let base64 = MF_Base64Codec.base64String(from: data) // SGVsbG8gV29ybGQ=&#xA;let querySafeBase64 = MF_Base64Codec.base64UrlEncodedString(fromBase64String: base64) // SGVsbG8gV29ybGQ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using NSData objects&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let data = &#34;Hello World&#34;.data(using: .utf8)! as NSData&#xA;let base64 = data.base64String() // SGVsbG8gV29ybGQ=&#xA;let querySafeBase64 = data.base64UrlEncodedString() // SGVsbG8gV29ybGQ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Encoding: 5% &lt;em&gt;slower&lt;/em&gt; than Swift&#39;s built-in Base64 encoding&lt;/li&gt; &#xA; &lt;li&gt;Encoding: 4 to 5 times faster than using the equivalent SecTransform.&lt;/li&gt; &#xA; &lt;li&gt;Encoding: 30% faster than &lt;a href=&#34;https://github.com/l4u/NSData-Base64&#34;&gt;https://github.com/l4u/NSData-Base64&lt;/a&gt; (metric from 2012)&lt;/li&gt; &#xA; &lt;li&gt;Decoding: 4 times &lt;em&gt;slower&lt;/em&gt; than Swift&#39;s built-in Base64 decoding&lt;/li&gt; &#xA; &lt;li&gt;Decoding: 5% faster than using the equivalent SecTransform.&lt;/li&gt; &#xA; &lt;li&gt;Decoding: 5% faster than &lt;a href=&#34;https://github.com/l4u/NSData-Base64&#34;&gt;https://github.com/l4u/NSData-Base64&lt;/a&gt; (metric from 2012)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Performance metrics are based on evaluation done in 2022 using macOS, Xcode 13.2.1 and Swift 5.5.2 on a 2.2 GHz 6-Core Intel Core i7 MacBook Pro.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compile with Automatic Reference Counting&lt;/li&gt; &#xA; &lt;li&gt;Compatible with Mac OSX 10.9+ and iOS 4.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Implementation&lt;/h2&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Implemented as per RFC 4648, see &lt;a href=&#34;http://www.ietf.org/rfc/rfc4648.txt&#34;&gt;http://www.ietf.org/rfc/rfc4648.txt&lt;/a&gt; for more details.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>liquidx/CoreBluetoothPeripheral</title>
    <updated>2022-09-04T01:38:21Z</updated>
    <id>tag:github.com,2022-09-04:/liquidx/CoreBluetoothPeripheral</id>
    <link href="https://github.com/liquidx/CoreBluetoothPeripheral" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Demonstration of using CoreBluetooth on Mac and iOS&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CoreBluetooth Peripheral Example&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Author: &lt;a href=&#34;http://liquidx.net/&#34;&gt;Alastair Tse&lt;/a&gt; (&lt;a href=&#34;http://twitter.com/liquidx/&#34;&gt;@liquidx&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Updated: &lt;em&gt;4 November 2012&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A demonstration of using CoreBluetooth (using Bluetoothe 4.0 LE) on the OSX and iOS.&lt;/p&gt; &#xA;&lt;p&gt;On the OSX side, CoreBluetoothOSXCentral implements the client as a CoreBluetooth Central that scans for suitable Bluetooth 4.0 LE peripherals. Once it discovers one, it will try and connect and subscribe to a fixed service characterstic. Once it receives a notification from the Peripheral it subscribes to, it will immediately unsubscribe.&lt;/p&gt; &#xA;&lt;p&gt;On the iOS side, CoreBluetootheiOSPeripheral implements the server as a CoreBluetooth Peripheral that advertises a fixed service characteristic. Once a Central (OSX) connects to the service and subscribes to notifications on the characteristic, it will send a &#34;Hello&#34; message to the subscriber.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Bluetooth 4.0 Terminology&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Bluetooth Central&lt;/strong&gt;: This is the node that is trying to connect to a data source. Think of this as the &lt;em&gt;client&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Bluetooth Peripheral&lt;/strong&gt;: This is the node that is providing the primary data source. Think of this as the &lt;em&gt;server&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Characteristic&lt;/strong&gt;: A characteristic can be considered a variable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Service&lt;/strong&gt;: A group of characteristics live under a &#34;Service&#34;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Implemented&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Central&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Scanning for peripherals&lt;/li&gt; &#xA;   &lt;li&gt;Connecting to a peripheral&lt;/li&gt; &#xA;   &lt;li&gt;Disconnecting from a peripheral&lt;/li&gt; &#xA;   &lt;li&gt;Discovering services&lt;/li&gt; &#xA;   &lt;li&gt;Discovering characteristics of a service&lt;/li&gt; &#xA;   &lt;li&gt;Subscribing to a characteristic&lt;/li&gt; &#xA;   &lt;li&gt;Receiving data from a characteristic&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Peripheral&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Advertising a service and characteristic&lt;/li&gt; &#xA;   &lt;li&gt;Adding service and characteristic to the PeripheralManager&lt;/li&gt; &#xA;   &lt;li&gt;Detecting of new subscribers to a characteristics&lt;/li&gt; &#xA;   &lt;li&gt;Detecting of unsubscribing&lt;/li&gt; &#xA;   &lt;li&gt;Handling of unready state of the device.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Currently Unimplemented&lt;/h2&gt; &#xA;&lt;p&gt;To keep the implementation simple, this demonstration does not implement:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Static read/write characteristics.&lt;/li&gt; &#xA; &lt;li&gt;Multiple characteristics.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Implementation Notes and Caveats&lt;/h2&gt; &#xA;&lt;h3&gt;UIBackgroundModes&lt;/h3&gt; &#xA;&lt;p&gt;According to Apple, if you add &lt;code&gt;bluetooth-central&lt;/code&gt; or &lt;code&gt;bluetooth-peripheral&lt;/code&gt; to &lt;code&gt;UIBackgroundModes&lt;/code&gt; in the &lt;code&gt;Info.plist&lt;/code&gt;, the application will continue to run in the background and receive &lt;code&gt;CBCentralManagerDelegate&lt;/code&gt; and/or &lt;code&gt;CBPeripheralManagerDelegate&lt;/code&gt; events.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve not fully discovered the behaviour here, but I&#39;ve advertised services disappear from the advertisments even though the application is still running in the background. Some times they exist with no hassles at all, sometimes the services are dropped by the service name still exists. Sometimes everything is dropped, even the generic services.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s quite mysterious when it is working and when it is not.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;More investigation needed.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Peripheral Mode on OSX&lt;/h3&gt; &#xA;&lt;p&gt;As of OSX 10.8, the CoreBluetooth APIs only allow you to have your Mac act as a Central. On iOS 6.0, the iOS device can act as either a Peripheral or a Central.&lt;/p&gt; &#xA;&lt;h3&gt;Service UUIDs&lt;/h3&gt; &#xA;&lt;p&gt;If an iOS device is implementing a &lt;em&gt;peripheral&lt;/em&gt;, consider using UUIDs that are only 4 characters short (2-bytes).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    CBUUID *serviceUUID = [CBUUID UUIDWithString:@&#34;1234&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The advertisement packet sent is max 28-bytes (or 38 bytes including the name). If your UUIDs exceed that, then the service will not be discoverable if &lt;code&gt;CBCentralManager&lt;/code&gt; scans with no specific service UUIDs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    [managed scanForPeripheralsWithServices:nil ...];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;code&gt;CBPeripheralManager.h&lt;/code&gt; for details.&lt;/p&gt; &#xA;&lt;h3&gt;Overflow in Advertisments (iOS only)&lt;/h3&gt; &#xA;&lt;p&gt;If you are implementing the CBCentralManager on iOS, you can also look in the overflow advertisment data field (&lt;code&gt;CBAdvertisementDataOverflowServiceUUIDsKey&lt;/code&gt;) in the &lt;code&gt;advertismentData&lt;/code&gt; dictionary.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    - (void)centralManager:(CBCentralManager *)central&#xA;            didDiscoverPeripheral:(CBPeripheral *)peripheral&#xA;            advertisementData:(NSDictionary *)advertisementData&#xA;            RSSI:(NSNumber *)RSSI {&#xA;      NSArray *overflowServiceUUIDs = [advertismentData objectForKey:&#xA;          CBAdvertisementDataOverflowServiceUUIDsKey];&#xA;      ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scanning for Services&lt;/h3&gt; &#xA;&lt;p&gt;When scanning for peripherals from CBCentralManager, when you receive a &lt;code&gt;centralManager:didDiscoverPeripheral:advertismentData:RSSI:&lt;/code&gt; message, you should look in the &lt;code&gt;advertismentData&lt;/code&gt; dictionary for the &lt;code&gt;CBAdvertisementDataServiceUUIDsKey&lt;/code&gt; for the advertised services rather than in the &lt;code&gt;peripheral.services&lt;/code&gt; property.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;peripheral.services&lt;/code&gt; property will not be filled in until you call &lt;code&gt;[CBCentralManager discoverServices:]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    - (void)centralManager:(CBCentralManager *)central&#xA;            didDiscoverPeripheral:(CBPeripheral *)peripheral&#xA;            advertisementData:(NSDictionary *)advertisementData&#xA;            RSSI:(NSNumber *)RSSI {&#xA;      NSArray *serviceUUIDs = [advertismentData objectForKey:&#xA;          CBAdvertisementDataServiceUUIDsKey];&#xA;      for (CBUUID *foundServiceUUIDs in serviceUUIDs) {&#xA;        if ([self.serviceUUIDs containsObject:foundServiceUUIDs]) {&#xA;          foundSuitablePeripheral = YES;&#xA;          break;&#xA;      }&#xA;      ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Calling [CBPeripheral discoverServices:]&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes, if the iOS application acting as the peripheral is in the background, the services for it removed from the advertisment packet. In that case, if you call &lt;code&gt;[CBPeripheral discoverServices:]&lt;/code&gt; with an array of services, it may not return any services.&lt;/p&gt; &#xA;&lt;h3&gt;Endianness with UUIDs&lt;/h3&gt; &#xA;&lt;p&gt;If you use long UUIDs (eg, using &lt;code&gt;uuidgen&lt;/code&gt;), then you will run in to endianess issues between iOS and the Mac. This is a bug in Xcode 4.5 and reportedly fixed in Xcode 4.5.1.&lt;/p&gt; &#xA;&lt;h3&gt;No centralDidConnect: and centralDidDisconnect: messages&lt;/h3&gt; &#xA;&lt;p&gt;Despite that was said in the WWDC talk, the subsequent betas for iOS 6.0 will not call &lt;code&gt;centralDidConnect:&lt;/code&gt; and &lt;code&gt;centralDidDisconnect:&lt;/code&gt; on the &lt;code&gt;CBPeripheralManagerDelegate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;CBMutableCharacteristics.properties is a bitmask&lt;/h3&gt; &#xA;&lt;p&gt;You can have a characteristic that is both readable and notifiable. This example does not do this, but presumably you can set the property of using the bitmask:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  (CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bluetooth popups on background&lt;/h3&gt; &#xA;&lt;p&gt;See: &lt;a href=&#34;http://lists.apple.com/archives/bluetooth-dev/2012/Oct/msg00053.html&#34;&gt;http://lists.apple.com/archives/bluetooth-dev/2012/Oct/msg00053.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;[CBCentralManager connectPeripheral:] silently fails&lt;/h3&gt; &#xA;&lt;p&gt;If you do not retain the &lt;code&gt;CBPeripheral&lt;/code&gt; you get in the Central implementation, when you call connectPeripheral, it will silently fail. This is surprising because you&#39;d think &lt;code&gt;connectPeripheral:&lt;/code&gt; would retain the &lt;code&gt;CBPeripheral&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the demo, you&#39;ll note that I retain the &lt;code&gt;CBPeripheral&lt;/code&gt; for time out purposes, but if I didn&#39;t do that, &lt;code&gt;[CBCentralManager connectPeripheral:]&lt;/code&gt; will silently fail.&lt;/p&gt; &#xA;&lt;h3&gt;Device UUID changes if Bluetooth is enabled/disabled or device is rebooted&lt;/h3&gt; &#xA;&lt;p&gt;In the WWDC presentation, reconnecting to the device by UUID is mentiond. However, if the peripheral is an iPhone, the UUID changes if Bluetooth is turned on and off again on the device. The UUID stays consistent if the app is killed and restarted.&lt;/p&gt; &#xA;&lt;h3&gt;Beware of adding and removing services while running&lt;/h3&gt; &#xA;&lt;p&gt;If you remove a service while a Central is connected to the Peripheral, like through a subscribed characteristic, then the Central does not get a disconnection. The peripheral will also lose track of the subscribers for a characteristic, even if the characteristic has the same UUID. That is, don&#39;t do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    [self.peripheralManager removeService:self.currentService];&#xA;    [self.peripheralManager addService:self.currentService];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I ran in to this when I would listen for didSubscribe and then prompt the user to bring the Peripheral implementation to the foreground. When I returned to the foreground, I had code that re-enabled the service that would check if &lt;code&gt;self.currentService&lt;/code&gt; existed, and if so, removed the service and readded it again. That was not a good idea.&lt;/p&gt; &#xA;&lt;h2&gt;Other Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KhaosT/CBPeripheralManager-Demo&#34;&gt;https://github.com/KhaosT/CBPeripheralManager-Demo&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The code only works for readValue and writeValue, but not seemingly for subscribe.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/timburks/iOSHealthThermometer&#34;&gt;https://github.com/timburks/iOSHealthThermometer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/timburks/CBSample&#34;&gt;https://github.com/timburks/CBSample&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sample Code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://lists.apple.com/archives/bluetooth-dev/2012/Sep/msg00084.html&#34;&gt;http://lists.apple.com/archives/bluetooth-dev/2012/Sep/msg00084.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Sources of Discussion&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://devforums.apple.com/community/ios/core/cbt&#34;&gt;https://devforums.apple.com/community/ios/core/cbt&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lists.apple.com/archives/bluetooth-dev/2012&#34;&gt;https://lists.apple.com/archives/bluetooth-dev/2012&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.bluetooth.org/Technical/Specifications/adopted.htm&#34;&gt;http://www.bluetooth.org/Technical/Specifications/adopted.htm&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Important Threads&lt;/h3&gt; &#xA;&lt;p&gt;Rebooting phone fixes not-notifying on subscribable properties.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://devforums.apple.com/message/736002#736002&#34;&gt;https://devforums.apple.com/message/736002#736002&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>