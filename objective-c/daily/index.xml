<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-02T01:34:35Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>matrix-org/matrix-ios-sdk</title>
    <updated>2025-06-02T01:34:35Z</updated>
    <id>tag:github.com,2025-06-02:/matrix-org/matrix-ios-sdk</id>
    <link href="https://github.com/matrix-org/matrix-ios-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Matrix SDK for iOS&lt;/p&gt;&lt;hr&gt;&lt;p&gt;.. image:: &lt;a href=&#34;https://img.shields.io/cocoapods/v/MatrixSDK?style=flat-square&#34;&gt;https://img.shields.io/cocoapods/v/MatrixSDK?style=flat-square&lt;/a&gt; :target: &lt;a href=&#34;https://github.com/matrix-org/matrix-ios-sdk/releases&#34;&gt;https://github.com/matrix-org/matrix-ios-sdk/releases&lt;/a&gt; .. image:: &lt;a href=&#34;https://img.shields.io/cocoapods/p/MatrixSDK?style=flat-square&#34;&gt;https://img.shields.io/cocoapods/p/MatrixSDK?style=flat-square&lt;/a&gt; :target: README.rst .. image:: &lt;a href=&#34;https://img.shields.io/github/workflow/status/matrix-org/matrix-ios-sdk/Lint%20CI/develop?style=flat-square&#34;&gt;https://img.shields.io/github/workflow/status/matrix-org/matrix-ios-sdk/Lint%20CI/develop?style=flat-square&lt;/a&gt; :target: &lt;a href=&#34;https://github.com/matrix-org/matrix-ios-sdk/actions?query=branch%3Adevelop&#34;&gt;https://github.com/matrix-org/matrix-ios-sdk/actions?query=branch%3Adevelop&lt;/a&gt; .. image:: &lt;a href=&#34;https://codecov.io/gh/matrix-org/matrix-ios-sdk/branch/develop/graph/badge.svg?token=2c9mzJoVpu&#34;&gt;https://codecov.io/gh/matrix-org/matrix-ios-sdk/branch/develop/graph/badge.svg?token=2c9mzJoVpu&lt;/a&gt; :target: &lt;a href=&#34;https://codecov.io/gh/matrix-org/matrix-ios-sdk&#34;&gt;https://codecov.io/gh/matrix-org/matrix-ios-sdk&lt;/a&gt; .. image:: &lt;a href=&#34;https://img.shields.io/badge/License-Apache%202.0-yellowgreen.svg?style=flat-square&#34;&gt;https://img.shields.io/badge/License-Apache%202.0-yellowgreen.svg?style=flat-square&lt;/a&gt; :target: &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;https://opensource.org/licenses/Apache-2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;============== Matrix iOS SDK&lt;/h1&gt; &#xA;&lt;p&gt;This open-source library allows you to build iOS apps compatible with Matrix (&lt;a href=&#34;http://www.matrix.org&#34;&gt;http://www.matrix.org&lt;/a&gt;), an open standard for interoperable Instant Messaging and VoIP.&lt;/p&gt; &#xA;&lt;p&gt;This SDK implements an interface to communicate with the Matrix Client/Server API which is defined at &lt;a href=&#34;http://matrix.org/docs/api/client-server/&#34;&gt;http://matrix.org/docs/api/client-server/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Pod Deprecation&lt;/h1&gt; &#xA;&lt;p&gt;The SDK is no longer published directly to Cocopods following recent linting issues with Xcode 14.3 and greater: &lt;code&gt;CocoaPods/CocoaPods#11839 &amp;lt;https://github.com/CocoaPods/CocoaPods/issues/11839&amp;gt;&lt;/code&gt;_. This deprecation &lt;em&gt;only&lt;/em&gt; covers the published pod, the SDK is still being maintained.&lt;/p&gt; &#xA;&lt;p&gt;It is however worth noting that we&#39;re now primarily focussed on the &lt;code&gt;Matrix Rust SDK &amp;lt;https://github.com/matrix-org/matrix-rust-sdk&amp;gt;&lt;/code&gt;_ and its respective FFI bindings which are available as a &lt;code&gt;Swift package &amp;lt;https://github.com/matrix-org/matrix-rust-components-swift/&amp;gt;&lt;/code&gt;_. This would likely be a more sensible choice for anyone starting a new project using Matrix on Apple platforms.&lt;/p&gt; &#xA;&lt;h1&gt;Use the SDK in your app&lt;/h1&gt; &#xA;&lt;p&gt;The SDK uses CocoaPods (&lt;a href=&#34;http://cocoapods.org/&#34;&gt;http://cocoapods.org/&lt;/a&gt;) as library dependency manager. In order to set this up::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo gem install cocoapods&#xA;pod setup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The best way to add the Matrix SDK to your application is to add the MatrixSDK repo to your Podfile::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;MatrixSDK&#39;, :git =&amp;gt; &#39;https://github.com/matrix-org/matrix-ios-sdk.git&#39;, :tag =&amp;gt; &#39;vX.Y.Z&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Options&lt;/h1&gt; &#xA;&lt;p&gt;If you want to enable VoIP using the &lt;a href=&#34;http://webrtc.org&#34;&gt;http://webrtc.org&lt;/a&gt; VoIP stack, add the following pod to your app Podfile::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;MatrixSDK/JingleCallStack&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;As a quick overview, there are the classes to know to use the SDK.&lt;/p&gt; &#xA;&lt;h2&gt;Matrix API level&lt;/h2&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXRestClient&lt;/code&gt;: Exposes the Matrix Client-Server API as specified by the Matrix standard to make requests to a homeserver.&lt;/p&gt; &#xA;&lt;h2&gt;Business logic and data model&lt;/h2&gt; &#xA;&lt;p&gt;These classes are higher level tools to handle responses from a homeserver. They contain logic to maintain consistent chat room data.&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXSession&lt;/code&gt;: This class handles all data arriving from the homeserver. It uses a MXRestClient instance to fetch data from the homeserver, forwarding it to MXRoom, MXRoomState, MXRoomMember and MXUser objects.&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXRoom&lt;/code&gt;: This class provides methods to get room data and to interact with the room (join, leave...).&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXRoomState&lt;/code&gt;: This is the state of room at a certain point in time: its name, topic, visibility (public/private), members, etc.&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXRoomMember&lt;/code&gt;: Represents a member of a room.&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXUser&lt;/code&gt;: This is a user known by the current user, outside of the context of a room. MXSession exposes and maintains the list of MXUsers. It provides the user id, displayname and the current presence state.&lt;/p&gt; &#xA;&lt;h2&gt;End-to-end Encryption&lt;/h2&gt; &#xA;&lt;p&gt;All core E2EE functionality is implemented in an external &lt;code&gt;matrix-sdk-crypto &amp;lt;https://github.com/matrix-org/matrix-rust-sdk/tree/main/crates/matrix-sdk-crypto&amp;gt;&lt;/code&gt;_ Rust crate, which replaces all previous obj-c / Swift implementation that used to exist in this repository. &lt;code&gt;MatrixSDK&lt;/code&gt; integrates this crate via &lt;code&gt;pod MatrixSDKCrypto&lt;/code&gt; published &lt;code&gt;separately &amp;lt;https://github.com/matrix-org/matrix-rust-sdk/tree/main/bindings/apple#publishing-matrixsdkcrypto&amp;gt;&lt;/code&gt;_.&lt;/p&gt; &#xA;&lt;p&gt;Code in &lt;code&gt;MatrixSDK&lt;/code&gt; consists mostly of wrappers, networking logic and glue code connecting encryption with general app functionality, sync loops and session state. Some of the notable classes include:&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXCrypto&lt;/code&gt;: Main entry-point into all cryptographic functionality, such as encrypting/decrypting events, cross-signing users, or managing room key backups. It is owned by the current session and therefore specific to the current user.&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXRoomEventEncryption&lt;/code&gt;/&lt;code&gt;MXRoomEventDecryption&lt;/code&gt;: Two classes responsible for encrypting and decrypting message events and tasks that are closely dependent, such as sharing room keys, reacting to late key-shares etc.&lt;/p&gt; &#xA;&lt;p&gt;:&lt;code&gt;MXCryptoMachine&lt;/code&gt;: Wrapper around Rust-based &lt;code&gt;OlmMachine&lt;/code&gt;, providing a more convenient API. Its three main responsibilities are: - adding a layer of abstraction between &lt;code&gt;MatrixSDK&lt;/code&gt; and &lt;code&gt;MatrixSDKCrypto&lt;/code&gt; - mapping to and from raw strings passed into the Rust machine - performing network requests and marking them as completed on behalf of the Rust machine&lt;/p&gt; &#xA;&lt;p&gt;To publish a new version of &lt;code&gt;MatrixSDKCrypto&lt;/code&gt; follow a &lt;code&gt;separate process &amp;lt;https://github.com/matrix-org/matrix-rust-sdk/tree/main/bindings/apple#publishing-matrixsdkcrypto&amp;gt;&lt;/code&gt;&lt;em&gt;. To test local / unpublished changes in &lt;code&gt;MatrixSDKCrypto&lt;/code&gt;, &lt;code&gt;build the framework &amp;lt;https://github.com/matrix-org/matrix-rust-sdk/tree/main/bindings/apple#building-only-the-crypto-sdk&amp;gt;&lt;/code&gt;&lt;/em&gt; and re-direct the pod in your &lt;code&gt;Podfile&lt;/code&gt; to &lt;code&gt;pod MatrixSDKCrypto, :path =&amp;gt; your/local/rust-crypto-sdk/MatrixSDKCrypto.podspec&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;The sample app (&lt;a href=&#34;https://github.com/matrix-org/matrix-ios-console&#34;&gt;https://github.com/matrix-org/matrix-ios-console&lt;/a&gt;) demonstrates how to build a chat app on top of Matrix. You can refer to it, play with it, hack it to understand the full integration of the Matrix SDK. This section comes back to the basics with sample codes for basic use cases.&lt;/p&gt; &#xA;&lt;p&gt;One file to import:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Obj-C&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#import &amp;lt;MatrixSDK/MatrixSDK.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import MatrixSDK&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use case #1: Get public rooms of an homeserver&lt;/h2&gt; &#xA;&lt;p&gt;This API does not require the user to be authenticated. So, MXRestClient instantiated with initWithHomeServer does the job:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Obj-C&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;MXRestClient *mxRestClient = [[MXRestClient alloc] initWithHomeServer:@&#34;http://matrix.org&#34;];&#xA;[mxRestClient publicRooms:^(NSArray *rooms) {&#xA;&#xA;    // rooms is an array of MXPublicRoom objects containing information like room id&#xA;    MXLogDebug(@&#34;The public rooms are: %@&#34;, rooms);&#xA;&#xA;} failure:^(MXError *error) {&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let homeServerUrl = URL(string: &#34;http://matrix.org&#34;)!&#xA;let mxRestClient = MXRestClient(homeServer: homeServerUrl, unrecognizedCertificateHandler: nil)&#xA;mxRestClient.publicRooms { response in&#xA;    switch response {&#xA;    case .success(let rooms):&#xA;&#xA;        // rooms is an array of MXPublicRoom objects containing information like room id&#xA;        print(&#34;The public rooms are: \(rooms)&#34;)&#xA;&#xA;    case .failure: break&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use case #2: Get the rooms the user has interacted with&lt;/h2&gt; &#xA;&lt;p&gt;Here the user needs to be authenticated. We will use [MXRestClient initWithCredentials]. You&#39;ll normally create and initialise these two objects once the user has logged in, then keep them throughout the app&#39;s lifetime or until the user logs out:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Obj-C&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;MXCredentials *credentials = [[MXCredentials alloc] initWithHomeServer:@&#34;http://matrix.org&#34;&#xA;                                                                userId:@&#34;@your_user_id:matrix.org&#34;&#xA;                                                           accessToken:@&#34;your_access_token&#34;];&#xA;&#xA;// Create a matrix client&#xA;MXRestClient *mxRestClient = [[MXRestClient alloc] initWithCredentials:credentials];&#xA;&#xA;// Create a matrix session&#xA;MXSession *mxSession = [[MXSession alloc] initWithMatrixRestClient:mxRestClient];&#xA;&#xA;// Launch mxSession: it will first make an initial sync with the homeserver&#xA;// Then it will listen to new coming events and update its data&#xA;[mxSession start:^{&#xA;&#xA;    // mxSession is ready to be used&#xA;    // Now we can get all rooms with:&#xA;    mxSession.rooms;&#xA;&#xA;} failure:^(NSError *error) {&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let credentials = MXCredentials(homeServer: &#34;http://matrix.org&#34;,&#xA;                                userId: &#34;@your_user_id:matrix.org&#34;,&#xA;                                accessToken: &#34;your_access_token&#34;)&#xA;&#xA;// Create a matrix client&#xA;let mxRestClient = MXRestClient(credentials: credentials, unrecognizedCertificateHandler: nil)&#xA;&#xA;// Create a matrix session&#xA;let mxSession = MXSession(matrixRestClient: mxRestClient)&#xA;&#xA;// Launch mxSession: it will first make an initial sync with the homeserver&#xA;mxSession.start { response in&#xA;    guard response.isSuccess else { return }&#xA;&#xA;    // mxSession is ready to be used&#xA;    // now wer can get all rooms with:&#xA;    mxSession.rooms&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use case #2 (bis): Get the rooms the user has interacted with (using a permanent MXStore)&lt;/h2&gt; &#xA;&lt;p&gt;We use the same code as above but we add a MXFileStore that will be in charge of storing user&#39;s data on the file system. This will avoid to do a full sync with the homeserver each time the app is resumed. The app will be able to resume quickly. Plus, it will be able to run in offline mode while syncing with the homeserver:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Obj-C&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;MXCredentials *credentials = [[MXCredentials alloc] initWithHomeServer:@&#34;http://matrix.org&#34;&#xA;                                                                userId:@&#34;@your_user_id:matrix.org&#34;&#xA;                                                           accessToken:@&#34;your_access_token&#34;];&#xA;&#xA;// Create a matrix client&#xA;MXRestClient *mxRestClient = [[MXRestClient alloc] initWithCredentials:credentials];&#xA;&#xA;// Create a matrix session&#xA;MXSession *mxSession = [[MXSession alloc] initWithMatrixRestClient:mxRestClient];&#xA;&#xA;// Make the matrix session open the file store&#xA;// This will preload user&#39;s messages and other data&#xA;MXFileStore *store = [[MXFileStore alloc] init];&#xA;[mxSession setStore:store success:^{&#xA;&#xA;    // Launch mxSession: it will sync with the homeserver from the last stored data&#xA;    // Then it will listen to new coming events and update its data&#xA;    [mxSession start:^{&#xA;&#xA;        // mxSession is ready to be used&#xA;        // Now we can get all rooms with:&#xA;        mxSession.rooms;&#xA;&#xA;    } failure:^(NSError *error) {&#xA;    }];&#xA;} failure:^(NSError *error) {&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let credentials = MXCredentials(homeServer: &#34;http://matrix.org&#34;,&#xA;                                userId: &#34;@your_user_id:matrix.org&#34;,&#xA;                                accessToken: &#34;your_access_token&#34;)&#xA;&#xA;// Create a matrix client&#xA;let mxRestClient = MXRestClient(credentials: credentials, unrecognizedCertificateHandler: nil)&#xA;&#xA;// Create a matrix session&#xA;let mxSession = MXSession(matrixRestClient: mxRestClient)&#xA;&#xA;// Make the matrix session open the file store&#xA;// This will preload user&#39;s messages and other data&#xA;let store = MXFileStore()&#xA;mxSession.setStore(store) { response in&#xA;    guard response.isSuccess else { return }&#xA;&#xA;    // Launch mxSession: it will sync with the homeserver from the last stored data&#xA;    // Then it will listen to new coming events and update its data&#xA;    mxSession.start { response in&#xA;        guard response.isSuccess else { return }&#xA;&#xA;        // mxSession is ready to be used&#xA;        // now we can get all rooms with:&#xA;        mxSession.rooms()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use case #3: Get messages of a room&lt;/h2&gt; &#xA;&lt;p&gt;We reuse the mxSession instance created before:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Obj-C&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Retrieve the room from its room id&#xA;MXRoom *room = [mxSession room:@&#34;!room_id:matrix.org&#34;];&#xA;&#xA;// Add a listener on events related to this room&#xA;[room.liveTimeline listenToEvents:^(MXEvent *event, MXEventDirection direction, MXRoomState *roomState) {&#xA;&#xA;    if (direction == MXTimelineDirectionForwards) {&#xA;        // Live/New events come here&#xA;    }&#xA;    else if (direction == MXTimelineDirectionBackwards) {&#xA;        // Events that occurred in the past will come here when requesting pagination.&#xA;        // roomState contains the state of the room just before this event occurred.&#xA;    }&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Retrieve the room from its room id&#xA;let room = mxSession.room(withRoomId: &#34;!room_id:matrix.org&#34;)&#xA;&#xA;// Add a listener on events related to this room&#xA;_ = room?.liveTimeline.listenToEvents { (event, direction, roomState) in&#xA;    switch direction {&#xA;    case .forwards:&#xA;        // Live/New events come here&#xA;        break&#xA;&#xA;    case .backwards:&#xA;        // Events that occurred in the past will come here when requesting pagination.&#xA;        // roomState contains the state of the room just before this event occurred.&#xA;        break&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s load a bit of room history using paginateBackMessages:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Obj-C&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Reset the pagination start point to now&#xA;[room.liveTimeline resetPagination];&#xA;&#xA;[room.liveTimeline paginate:10 direction:MXTimelineDirectionBackwards onlyFromStore:NO complete:^{&#xA;&#xA;    // At this point, the SDK has finished to enumerate the events to the attached listeners&#xA;&#xA;} failure:^(NSError *error) {&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Reset the pagination start point to now&#xA;room?.liveTimeline.resetPagination()&#xA;&#xA;room?.liveTimeline.paginate(10, direction: .backwards, onlyFromStore: false) { _ in&#xA;    // At this point, the SDK has finished to enumerate the events to the attached listeners&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use case #4: Post a text message to a room&lt;/h2&gt; &#xA;&lt;p&gt;This action does not require any business logic from MXSession: We can use MXRestClient directly:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Obj-C&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[mxRestClient sendTextMessageToRoom:@&#34;the_room_id&#34; text:@&#34;Hello world!&#34; success:^(NSString *event_id) {&#xA;&#xA;    // event_id is for reference&#xA;    // If you have registered events listener like in the previous use case, you will get&#xA;    // a notification for this event coming down from the homeserver events stream and&#xA;    // now handled by MXSession.&#xA;&#xA;} failure:^(NSError *error) {&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;client.sendTextMessage(toRoom: &#34;the_room_id&#34;, text: &#34;Hello World!&#34;) { (response) in&#xA;    if case .success(let eventId) = response {&#xA;        // eventId is for reference&#xA;        // If you have registered events listener like in the previous use case, you will get&#xA;        // a notification for this event coming down from the homeserver events stream and&#xA;        // now handled by MXSession.&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Push Notifications&lt;/h1&gt; &#xA;&lt;p&gt;In Matrix, a homeserver can send notifications out to a user when events arrive for them. However in APNS, only you, the app developer, can send APNS notifications because doing so requires your APNS private key. Matrix therefore requires a seperate server decoupled from the homeserver to send Push Notifications, as you cannot trust arbitrary homeservers with your application&#39;s APNS private key. This is called the &#39;Push Gateway&#39;. More about how notifications work in Matrix can be found at &lt;a href=&#34;https://matrix.org/docs/spec/push_gateway/latest.html&#34;&gt;https://matrix.org/docs/spec/push_gateway/latest.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;In simple terms, for your application to receive push notifications, you will need to set up a push gateway. This is a publicly accessible server specific to your particular iOS app that receives HTTP POST requests from Matrix Home Servers and sends APNS. Matrix provides a reference push gateway, &#39;sygnal&#39;, which can be found at &lt;a href=&#34;https://github.com/matrix-org/sygnal&#34;&gt;https://github.com/matrix-org/sygnal&lt;/a&gt; along with instructions on how to set it up.&lt;/p&gt; &#xA;&lt;p&gt;You can also write your own Push Gateway. See &lt;a href=&#34;https://matrix.org/docs/spec/push_gateway/latest.html&#34;&gt;https://matrix.org/docs/spec/push_gateway/latest.html&lt;/a&gt; for the specification on the HTTP Push Notification protocol. Your push gateway can listen for notifications on any path (as long as your app knows that path in order to inform the homeserver) but Matrix strongly recommends that the path of this URL be &#39;/_matrix/push/v1/notify&#39;.&lt;/p&gt; &#xA;&lt;p&gt;In your application, you will first register for APNS in the normal way (assuming iOS 8 or above)::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:(UIRemoteNotificationTypeBadge&#xA;                                                                                     |UIRemoteNotificationTypeSound&#xA;                                                                                     |UIRemoteNotificationTypeAlert)&#xA;                                                                                     categories:nil];&#xA;[...]&#xA;&#xA;- (void)application:(UIApplication *)application&#xA;        didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings&#xA;{&#xA;    [application registerForRemoteNotifications];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you receive the APNS token for this particular application instance, you then encode this into text and use it as the &#39;pushkey&#39; to call setPusherWithPushkey in order to tell the homeserver to send pushes to this device via your push gateway&#39;s URL. Matrix recommends base 64 encoding for APNS tokens (as this is what sygnal uses)::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- (void)application:(UIApplication*)app&#xA;  didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken {&#xA;    NSString *b64Token = [self.deviceToken base64EncodedStringWithOptions:0];&#xA;    NSDictionary *pushData = @{&#xA;        @&#34;url&#34;: @&#34;https://example.com/_matrix/push/v1/notify&#34; // your push gateway URL&#xA;    };&#xA;    NSString *deviceLang = [NSLocale preferredLanguages][0];&#xA;    NSString *profileTag = makeProfileTag(); // more about this later&#xA;    MXRestClient *restCli = [MatrixSDKHandler sharedHandler].mxRestClient;&#xA;    [restCli&#xA;        setPusherWithPushkey:b64Token&#xA;        kind:@&#34;http&#34;&#xA;        appId:@&#34;com.example.supercoolmatrixapp.prod&#34;&#xA;        appDisplayName:@&#34;My Super Cool Matrix iOS App&#34;&#xA;        deviceDisplayName:[[UIDevice currentDevice] name]&#xA;        profileTag:profileTag&#xA;        lang:deviceLang&#xA;        data:pushData&#xA;        success:^{&#xA;            // Hooray!&#xA;        } failure:^(NSError *error) {&#xA;            // Some super awesome error handling goes here&#xA;        }&#xA;    ];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you call setPusherWithPushkey, this creates a pusher on the homeserver that your session is logged in to. This will send HTTP notifications to a URL you supply as the &#39;url&#39; key in the &#39;data&#39; argument to setPusherWithPushkey.&lt;/p&gt; &#xA;&lt;p&gt;You can read more about these parameters in the Client / Server specification (&lt;a href=&#34;http://matrix.org/docs/api/client-server/#!/Push32notifications/post_matrix_client_r0_pushers_set&#34;&gt;http://matrix.org/docs/api/client-server/#!/Push32notifications/post_matrix_client_r0_pushers_set&lt;/a&gt;). A little more information about some of these parameters is included below:&lt;/p&gt; &#xA;&lt;p&gt;appId This has two purposes: firstly to form the namespace in which your pushkeys exist on a homeserver, which means you should use something unique to your application: a reverse-DNS style identifier is strongly recommended. Its second purpose is to identify your application to your Push Gateway, such that your Push Gateway knows which private key and certificate to use when talking to the APNS gateway. You should therefore use different app IDs depending on whether your application is in production or sandbox push mode so that your Push Gateway can send the APNS accordingly. Matrix recommends suffixing your appId with &#39;.dev&#39; or &#39;.prod&#39; accordingly.&lt;/p&gt; &#xA;&lt;p&gt;profileTag This identifies which set of push rules this device should obey. For more information about push rules, see the Client / Server push specification: &lt;a href=&#34;http://matrix.org/docs/api/client-server/#!/Push32notifications/post_matrix_client_r0_pushers_set&#34;&gt;http://matrix.org/docs/api/client-server/#!/Push32notifications/post_matrix_client_r0_pushers_set&lt;/a&gt; This is an identifier for the set of device-specific push rules that this device will obey. The recommendation is to auto-generate a 16 character alphanumeric string and use this string for the lifetime of the application data. More advanced usage of this will allow for several devices sharing a set of push rules.&lt;/p&gt; &#xA;&lt;h1&gt;Development&lt;/h1&gt; &#xA;&lt;p&gt;The repository contains a Xcode project in order to develop. This project does not build an app but a test suite. See the next section to set the test environment.&lt;/p&gt; &#xA;&lt;p&gt;Before opening the Matrix SDK Xcode workspace, you need to build it.&lt;/p&gt; &#xA;&lt;p&gt;The project has some third party library dependencies declared in a pod file. You need to run the CocoaPods command to download them and to set up the Matrix SDK workspace::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ pod install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, open &lt;code&gt;MatrixSDK.xcworkspace&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Tests&lt;/h1&gt; &#xA;&lt;p&gt;The tests in the SDK Xcode project are both unit and integration tests.&lt;/p&gt; &#xA;&lt;p&gt;Unit tests classes use the suffix &#34;UnitTests&#34; to differentiate them. A unit test is a test that does not make any HTTP requests or uses mocked HTTP requests.&lt;/p&gt; &#xA;&lt;p&gt;Out of the box, the tests use one of the homeservers (located at &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;) of the &#34;Demo Federation of Homeservers&#34; (&lt;a href=&#34;https://matrix-org.github.io/synapse/develop/development/demo.html?highlight=demo#synapse-demo-setup&#34;&gt;https://matrix-org.github.io/synapse/develop/development/demo.html?highlight=demo#synapse-demo-setup&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Before you install synapse you may need few dependencies to be installed on Mac OS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Homebrew&lt;/strong&gt;: run &lt;code&gt;/bin/bash -c &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)‚Äù&lt;/code&gt;. More information can be found here &lt;a href=&#34;https://brew.sh&#34;&gt;https://brew.sh&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;python 3&lt;/strong&gt;: downloading the latest stable version should be fine. Download the &lt;code&gt;.pkg&lt;/code&gt; and install it from here &lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pipx&lt;/strong&gt;: with python installed run &lt;code&gt;pip3 install --user pipx&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: run &lt;code&gt;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh&lt;/code&gt;. more information can be found here &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;icu4c&lt;/strong&gt;: Run &lt;code&gt;brew install icu4c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Update env variables for icu4c&lt;/strong&gt;: if you use zsh run &lt;code&gt;echo &#39;export PATH=&#34;/opt/homebrew/opt/icu4c/bin:$PATH&#34;&#39; &amp;gt;&amp;gt; ~/.zshrc&lt;/code&gt;. Otherwise try to update &lt;code&gt;.bash_profile&lt;/code&gt; in the same way. You may have configured another folder for brew binaries. In that case try to run &lt;code&gt;brew info icu4c&lt;/code&gt; to spot the correct path.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pg_config&lt;/strong&gt;: you can get it by running &lt;code&gt;brew install postgresql&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You first need to follow instructions to set up Synapse in development mode at &lt;a href=&#34;https://github.com/matrix-org/synapse#synapse-development&#34;&gt;https://github.com/matrix-org/synapse#synapse-development&lt;/a&gt;. The cookbook is::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  $ pip install --user pipx&#xA;  $ python3 -m pipx ensurepath   # To run if `pipx install poetry` complained about PATH not being correctly set&#xA;  $ pipx install poetry&#xA;  $ git clone https://github.com/matrix-org/synapse.git&#xA;  $ cd synapse&#xA;  $ poetry install --extras all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To launch these test homeservers, type from the synapse root folder::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  $ poetry run ./demo/start.sh --no-rate-limit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To verify that the synapse instance is actually running correctly, open a web browser and go to &lt;code&gt;http://127.0.0.1:8080&lt;/code&gt;. A web page should confirm it.&lt;/p&gt; &#xA;&lt;p&gt;To stop and reset the servers::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  $ poetry run ./demo/stop.sh&#xA;  $ poetry run ./demo/clean.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now run tests from the Xcode Test navigator tab or select the MatrixSDKTests scheme and click on the &#34;Test&#34; action.&lt;/p&gt; &#xA;&lt;h2&gt;Test Plans&lt;/h2&gt; &#xA;&lt;p&gt;We have test plans for the macOS target to run tests separately or with different configurations.&lt;/p&gt; &#xA;&lt;p&gt;AllTests Default test plan to run all tests.&lt;/p&gt; &#xA;&lt;p&gt;AllTestsWithSanitizers Run all tests with 2 configurations: &#34;ASan + UBSan&#34; and &#34;TSan + UBSan&#34;. &#34;UBSan&#34; for Unexpected Behavior Sanitizer. &#34;ASan&#34; for Address Sanitizier. &#34;Tsan&#34; for Thread Sanitizer. This setup was advised at WWDC2019 (&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2019/413?time=2270&#34;&gt;https://developer.apple.com/videos/play/wwdc2019/413?time=2270&lt;/a&gt;). This test plan requires 2 builds and 2 test runs.&lt;/p&gt; &#xA;&lt;p&gt;UnitTests Test plan for all unit tests.&lt;/p&gt; &#xA;&lt;p&gt;UnitTestsWithSanitizers All unit tests with the 2 configurations described above: &#34;ASan + UBSan&#34; and &#34;TSan + UBSan&#34;.&lt;/p&gt; &#xA;&lt;h1&gt;Known issues&lt;/h1&gt; &#xA;&lt;p&gt;CocoaPods may fail to install on OSX 10.8.x with &#34;i18n requires Ruby version&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;= 1.9.3.&#34;. This is a known problem similar to &lt;a href=&#34;https://github.com/CocoaPods/CocoaPods/issues/2458&#34;&gt;https://github.com/CocoaPods/CocoaPods/issues/2458&lt;/a&gt; that needs to be raised with the CocoaPods team.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Registration&lt;/h2&gt; &#xA;&lt;p&gt;The SDK currently manages only login-password type registration. This type of registration is not accepted by the homeserver hosted at matrix.org. It has been disabled for security and spamming reasons. So, for now, you will be not be able to register a new account with the SDK on such homeserver. But you can login an existing user.&lt;/p&gt; &#xA;&lt;p&gt;If you run your own homeserver, the default launch parameters enables the login-password type registration and you will be able to register a new user to it.&lt;/p&gt; &#xA;&lt;h1&gt;Copyright &amp;amp; License&lt;/h1&gt; &#xA;&lt;p&gt;Copyright (c) 2014-2017 OpenMarket Ltd Copyright (c) 2017 Vector Creations Ltd Copyright (c) 2017-2018 New Vector Ltd&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this work except in compliance with the License. You may obtain a copy of the License in the LICENSE file, or at:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.&lt;/p&gt;</summary>
  </entry>
</feed>