<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-21T01:51:18Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>MetalPetal/MetalPetal</title>
    <updated>2022-06-21T01:51:18Z</updated>
    <id>tag:github.com,2022-06-21:/MetalPetal/MetalPetal</id>
    <link href="https://github.com/MetalPetal/MetalPetal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A GPU accelerated image and video processing framework built on Metal.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MetalPetal&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/MetalPetal/MetalPetal/actions?query=workflow%3ASwift&#34;&gt;&lt;img src=&#34;https://github.com/MetalPetal/MetalPetal/workflows/Swift/badge.svg?sanitize=true&#34; alt=&#34;Swift&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Platforms-iOS%2011%2B%20%7C%20tvOS%2013%2B%20%7C%20macOS%2010.13%2B-blue.svg?sanitize=true&#34; alt=&#34;Platforms&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/MetalPetal/MetalPetal/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/MetalPetal.svg?label=Release&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Apple%20Silicon-%E2%80%8B%20%E2%9C%94-eee&#34; alt=&#34;Apple Silicon&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Mac%20Catalyst-%E2%80%8B%20%E2%9C%94-eee&#34; alt=&#34;Mac Catalyst&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Simulator-%E2%80%8B%20%E2%9C%94-eee&#34; alt=&#34;Simulator&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#cocoapods&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=CocoaPods&amp;amp;message=%E2%80%8B%20%E2%9C%94&amp;amp;color=eee&amp;amp;logo=CocoaPods&amp;amp;logoColor=white&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#swift-package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Swift%20PM&amp;amp;message=%E2%80%8B%20%E2%9C%94&amp;amp;color=eee&amp;amp;logo=Swift&amp;amp;logoColor=white&#34; alt=&#34;Swift PM&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An image processing framework based on Metal.&lt;/p&gt; &#xA;&lt;!-- TOC depthFrom:2 --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#design-overview&#34;&gt;Design Overview&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#goals&#34;&gt;Goals&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#core-components&#34;&gt;Core Components&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#mticontext&#34;&gt;MTIContext&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#mtiimage&#34;&gt;MTIImage&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#mtifilter&#34;&gt;MTIFilter&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#mtikernel&#34;&gt;MTIKernel&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#optimizations&#34;&gt;Optimizations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#concurrency-considerations&#34;&gt;Concurrency Considerations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#advantages-over-core-image&#34;&gt;Advantages over Core Image&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#builtin-filters&#34;&gt;Builtin Filters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#example-code&#34;&gt;Example Code&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#create-a-mtiimage&#34;&gt;Create a &lt;code&gt;MTIImage&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#apply-a-filter&#34;&gt;Apply a Filter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#render-a-mtiimage&#34;&gt;Render a &lt;code&gt;MTIImage&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#display-a-mtiimage&#34;&gt;Display a &lt;code&gt;MTIImage&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#connect-filters-swift&#34;&gt;Connect Filters (Swift)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#process-video-files&#34;&gt;Process Video Files&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#process-live-video-with-videoio&#34;&gt;Process Live Video (with VideoIO)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#best-practices&#34;&gt;Best Practices&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#build-custom-filter&#34;&gt;Build Custom Filter&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#shader-function-arguments-encoding&#34;&gt;Shader Function Arguments Encoding&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#simple-single-input--output-filters&#34;&gt;Simple Single Input / Output Filters&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#fully-custom-filters&#34;&gt;Fully Custom Filters&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#multiple-draw-calls-in-one-render-pass&#34;&gt;Multiple Draw Calls in One Render Pass&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#custom-vertex-data&#34;&gt;Custom Vertex Data&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#custom-processing-module&#34;&gt;Custom Processing Module&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#alpha-types&#34;&gt;Alpha Types&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#alpha-handling-of-built-in-filters&#34;&gt;Alpha Handling of Built-in Filters&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#color-spaces&#34;&gt;Color Spaces&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#color-spaces-for-inputs&#34;&gt;Color Spaces for Inputs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#color-spaces-for-outputs&#34;&gt;Color Spaces for Outputs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#color-spaces-for-cvpixelbuffer&#34;&gt;Color Spaces for &lt;code&gt;CVPixelBuffer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#color-space-conversions&#34;&gt;Color Space Conversions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#extensions&#34;&gt;Extensions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#working-with-scenekit&#34;&gt;Working with SceneKit&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#working-with-spritekit&#34;&gt;Working with SpriteKit&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#working-with-core-image&#34;&gt;Working with Core Image&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#working-with-javascript&#34;&gt;Working with JavaScript&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#texture-loader&#34;&gt;Texture Loader&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#install&#34;&gt;Install&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#cocoapods&#34;&gt;CocoaPods&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#sub-pod-swift&#34;&gt;Sub-pod &lt;code&gt;Swift&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#sub-pod-applesilicon&#34;&gt;Sub-pod &lt;code&gt;AppleSilicon&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#swift-package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#ios-simulator-support&#34;&gt;iOS Simulator Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#quick-look-debug-support&#34;&gt;Quick Look Debug Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#trivia&#34;&gt;Trivia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#contribute&#34;&gt;Contribute&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- /TOC --&gt; &#xA;&lt;h2&gt;Design Overview&lt;/h2&gt; &#xA;&lt;p&gt;MetalPetal is an image processing framework based on &lt;a href=&#34;https://developer.apple.com/metal/&#34;&gt;Metal&lt;/a&gt; designed to provide real-time processing for still image and video with easy to use programming interfaces.&lt;/p&gt; &#xA;&lt;p&gt;This chapter covers the key concepts of MetalPetal, and will help you to get a better understanding of its design, implementation, performance implications and best practices.&lt;/p&gt; &#xA;&lt;h3&gt;Goals&lt;/h3&gt; &#xA;&lt;p&gt;MetalPetal is designed with the following goals in mind.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Easy to use API&lt;/p&gt; &lt;p&gt;Provides convenience APIs and avoids common pitfalls.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Performance&lt;/p&gt; &lt;p&gt;Use CPU, GPU and memory efficiently.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Extensibility&lt;/p&gt; &lt;p&gt;Easy to create custom filters as well as plugin your custom image processing unit.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Swifty&lt;/p&gt; &lt;p&gt;Provides a fluid experience for Swift programmers.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Core Components&lt;/h3&gt; &#xA;&lt;p&gt;Some of the core concepts of MetalPetal are very similar to those in Apple&#39;s Core Image framework.&lt;/p&gt; &#xA;&lt;h4&gt;MTIContext&lt;/h4&gt; &#xA;&lt;p&gt;Provides an evaluation context for rendering &lt;code&gt;MTIImage&lt;/code&gt;s. It also stores a lot of caches and state information, so it&#39;s more efficient to reuse a context whenever possible.&lt;/p&gt; &#xA;&lt;h4&gt;MTIImage&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;code&gt;MTIImage&lt;/code&gt; object is a representation of an image to be processed or produced. It does directly represent image bitmap data instead it has all the information necessary to produce an image or more precisely a &lt;code&gt;MTLTexture&lt;/code&gt;. It consists of two parts, a recipe of how to produce the texture (&lt;code&gt;MTIImagePromise&lt;/code&gt;) and other information such as how a context caches the image (&lt;code&gt;cachePolicy&lt;/code&gt;), and how the texture should be sampled (&lt;code&gt;samplerDescriptor&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;MTIFilter&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;code&gt;MTIFilter&lt;/code&gt; represents an image processing effect and any parameters that control that effect. It produces a &lt;code&gt;MTIImage&lt;/code&gt; object as output. To use a filter, you create a filter object, set its input images and parameters, and then access its output image. Typically, a filter class owns a static kernel (&lt;code&gt;MTIKernel&lt;/code&gt;), when you access its &lt;code&gt;outputImage&lt;/code&gt; property, it asks the kernel with the input images and parameters to produce an output &lt;code&gt;MTIImage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;MTIKernel&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;code&gt;MTIKernel&lt;/code&gt; represents an image processing routine. &lt;code&gt;MTIKernel&lt;/code&gt; is responsible for creating the corresponding render or compute pipeline state for the filter, as well as building the &lt;code&gt;MTIImagePromise&lt;/code&gt; for a &lt;code&gt;MTIImage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Optimizations&lt;/h3&gt; &#xA;&lt;p&gt;MetalPetal does a lot of optimizations for you under the hood.&lt;/p&gt; &#xA;&lt;p&gt;It automatically caches functions, kernel states, sampler states, etc.&lt;/p&gt; &#xA;&lt;p&gt;It utilizes Metal features like programmable blending, memoryless render targets, resource heaps and metal performance shaders to make the render fast and efficient. On macOS, MetalPetal can also take advantage of the TBDR architecture of Apple silicon.&lt;/p&gt; &#xA;&lt;p&gt;Before rendering, MetalPetal can look into your image render graph and figure out the minimal number of intermediate textures needed to do the rendering, saving memory, energy and time.&lt;/p&gt; &#xA;&lt;p&gt;It can also re-organize the image render graph if multiple “recipes” can be concatenated to eliminate redundant render passes. (&lt;code&gt;MTIContext.isRenderGraphOptimizationEnabled&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Concurrency Considerations&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;MTIImage&lt;/code&gt; objects are immutable, which means they can be shared safely among threads.&lt;/p&gt; &#xA;&lt;p&gt;However, &lt;code&gt;MTIFilter&lt;/code&gt; objects are mutable and thus cannot be shared safely among threads.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;MTIContext&lt;/code&gt; contains a lot of states and caches. There&#39;s a thread-safe mechanism for &lt;code&gt;MTIContext&lt;/code&gt; objects, making it safe to share a &lt;code&gt;MTIContext&lt;/code&gt; object among threads.&lt;/p&gt; &#xA;&lt;h3&gt;Advantages over Core Image&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Fully customizable vertex and fragment functions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MRT (Multiple Render Targets) support.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generally better performance. (Detailed benchmark data needed)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Builtin Filters&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Color Matrix&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Color Lookup&lt;/p&gt; &lt;p&gt;Uses an color lookup table to remap the colors in an image.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Opacity&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Exposure&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Saturation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Brightness&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Contrast&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Color Invert&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Vibrance&lt;/p&gt; &lt;p&gt;Adjusts the saturation of an image while keeping pleasing skin tones.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RGB Tone Curve&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Blend Modes&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Normal&lt;/li&gt; &#xA;   &lt;li&gt;Multiply&lt;/li&gt; &#xA;   &lt;li&gt;Overlay&lt;/li&gt; &#xA;   &lt;li&gt;Screen&lt;/li&gt; &#xA;   &lt;li&gt;Hard Light&lt;/li&gt; &#xA;   &lt;li&gt;Soft Light&lt;/li&gt; &#xA;   &lt;li&gt;Darken&lt;/li&gt; &#xA;   &lt;li&gt;Lighten&lt;/li&gt; &#xA;   &lt;li&gt;Color Dodge&lt;/li&gt; &#xA;   &lt;li&gt;Add (Linear Dodge)&lt;/li&gt; &#xA;   &lt;li&gt;Color Burn&lt;/li&gt; &#xA;   &lt;li&gt;Linear Burn&lt;/li&gt; &#xA;   &lt;li&gt;Lighter Color&lt;/li&gt; &#xA;   &lt;li&gt;Darker Color&lt;/li&gt; &#xA;   &lt;li&gt;Vivid Light&lt;/li&gt; &#xA;   &lt;li&gt;Linear Light&lt;/li&gt; &#xA;   &lt;li&gt;Pin Light&lt;/li&gt; &#xA;   &lt;li&gt;Hard Mix&lt;/li&gt; &#xA;   &lt;li&gt;Difference&lt;/li&gt; &#xA;   &lt;li&gt;Exclusion&lt;/li&gt; &#xA;   &lt;li&gt;Subtract&lt;/li&gt; &#xA;   &lt;li&gt;Divide&lt;/li&gt; &#xA;   &lt;li&gt;Hue&lt;/li&gt; &#xA;   &lt;li&gt;Saturation&lt;/li&gt; &#xA;   &lt;li&gt;Color&lt;/li&gt; &#xA;   &lt;li&gt;Luminosity&lt;/li&gt; &#xA;   &lt;li&gt;ColorLookup512x512&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/MetalPetal/MetalPetal/issues/70#issuecomment-792430483&#34;&gt;Custom Blend Mode&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Blend with Mask&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Transform&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Crop&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Pixellate&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Multilayer Composite&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MPS Convolution&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MPS Gaussian Blur&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MPS Definition&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MPS Sobel&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MPS Unsharp Mask&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MPS Box Blur&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/YuAo/YUCIHighPassSkinSmoothing&#34;&gt;High Pass Skin Smoothing&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/YuAo/Accelerated-CLAHE&#34;&gt;CLAHE (Contrast-Limited Adaptive Histogram Equalization)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/YuAo/HexagonalBokehBlur&#34;&gt;Lens Blur (Hexagonal Bokeh Blur)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/MetalPetal/SurfaceBlur&#34;&gt;Surface Blur&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Bulge Distortion&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Chroma Key Blend&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Color Halftone&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Dot Screen&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Round Corner (Circular/Continuous Curve)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/#working-with-core-image&#34;&gt;All Core Image Filters&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example Code&lt;/h2&gt; &#xA;&lt;h3&gt;Create a &lt;code&gt;MTIImage&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can create a &lt;code&gt;MTIImage&lt;/code&gt; object from nearly any source of image data, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;URL&lt;/code&gt;s referencing image files to be loaded&lt;/li&gt; &#xA; &lt;li&gt;Metal textures&lt;/li&gt; &#xA; &lt;li&gt;CoreVideo image or pixel buffers (&lt;code&gt;CVImageBufferRef&lt;/code&gt; or &lt;code&gt;CVPixelBufferRef&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Image bitmap data in memory&lt;/li&gt; &#xA; &lt;li&gt;Texture data from a given texture or image asset name&lt;/li&gt; &#xA; &lt;li&gt;Core Image &lt;code&gt;CIImage&lt;/code&gt; objects&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MDLTexture&lt;/code&gt; objects&lt;/li&gt; &#xA; &lt;li&gt;SceneKit and SpriteKit scenes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let imageFromCGImage = MTIImage(cgImage: cgImage, isOpaque: true)&#xA;&#xA;let imageFromCIImage = MTIImage(ciImage: ciImage)&#xA;&#xA;let imageFromCoreVideoPixelBuffer = MTIImage(cvPixelBuffer: pixelBuffer, alphaType: .alphaIsOne)&#xA;&#xA;let imageFromContentsOfURL = MTIImage(contentsOf: url)&#xA;&#xA;// unpremultiply alpha if needed&#xA;let unpremultipliedAlphaImage = image.unpremultiplyingAlpha()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Apply a Filter&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let inputImage = ...&#xA;&#xA;let filter = MTISaturationFilter()&#xA;filter.saturation = 0&#xA;filter.inputImage = inputImage&#xA;&#xA;let outputImage = filter.outputImage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Render a &lt;code&gt;MTIImage&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let options = MTIContextOptions()&#xA;&#xA;guard let device = MTLCreateSystemDefaultDevice(), let context = try? MTIContext(device: device, options: options) else {&#xA;    return&#xA;}&#xA;&#xA;let image: MTIImage = ...&#xA;&#xA;do {&#xA;    try context.render(image, to: pixelBuffer) &#xA;    &#xA;    //context.makeCIImage(from: image)&#xA;    &#xA;    //context.makeCGImage(from: image)&#xA;} catch {&#xA;    print(error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Display a &lt;code&gt;MTIImage&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let imageView = MTIImageView(frame: self.view.bounds)&#xA;&#xA;// You can optionally assign a `MTIContext` to the image view. If no context is assigned and `automaticallyCreatesContext` is set to `true` (the default value), a `MTIContext` is created automatically when the image view renders its content.&#xA;imageView.context = ...&#xA;&#xA;imageView.image = image&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;d like to move the GPU command encoding process out of the main thread, you can use a &lt;code&gt;MTIThreadSafeImageView&lt;/code&gt;. You may assign a &lt;code&gt;MTIImage&lt;/code&gt; to a &lt;code&gt;MTIThreadSafeImageView&lt;/code&gt; in any thread.&lt;/p&gt; &#xA;&lt;h3&gt;Connect Filters (Swift)&lt;/h3&gt; &#xA;&lt;p&gt;MetalPetal has a type-safe Swift API for connecting filters. You can use &lt;code&gt;=&amp;gt;&lt;/code&gt; operator in &lt;code&gt;FilterGraph.makeImage&lt;/code&gt; function to connect filters and get the output image.&lt;/p&gt; &#xA;&lt;p&gt;Here are some examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let image = try? FilterGraph.makeImage { output in&#xA;    inputImage =&amp;gt; saturationFilter =&amp;gt; exposureFilter =&amp;gt; output&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let image = try? FilterGraph.makeImage { output in&#xA;    inputImage =&amp;gt; saturationFilter =&amp;gt; exposureFilter =&amp;gt; contrastFilter =&amp;gt; blendFilter.inputPorts.inputImage&#xA;    exposureFilter =&amp;gt; blendFilter.inputPorts.inputBackgroundImage&#xA;    blendFilter =&amp;gt; output&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can connect unary filters (&lt;code&gt;MTIUnaryFilter&lt;/code&gt;) directly using &lt;code&gt;=&amp;gt;&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For a filter with multiple inputs, you need to connect to one of its &lt;code&gt;inputPorts&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt; operator only works in &lt;code&gt;FilterGraph.makeImage&lt;/code&gt; method.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;One and only one filter&#39;s output can be connected to &lt;code&gt;output&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Process Video Files&lt;/h3&gt; &#xA;&lt;p&gt;Working with &lt;code&gt;AVPlayer&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let context = try MTIContext(device: device)&#xA;let asset = AVAsset(url: videoURL)&#xA;let composition = MTIVideoComposition(asset: asset, context: context, queue: DispatchQueue.main, filter: { request in&#xA;    return FilterGraph.makeImage { output in&#xA;        request.anySourceImage! =&amp;gt; filterA =&amp;gt; filterB =&amp;gt; output&#xA;    }!&#xA;}&#xA;&#xA;let playerItem = AVPlayerItem(asset: asset)&#xA;playerItem.videoComposition = composition.makeAVVideoComposition()&#xA;player.replaceCurrentItem(with: playerItem)&#xA;player.play()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Export a video:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/MetalPetal/VideoIO&#34;&gt;VideoIO&lt;/a&gt; is required for the following examples.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;import VideoIO&#xA;&#xA;var configuration = AssetExportSession.Configuration(fileType: .mp4, videoSettings: .h264(videoSize: composition.renderSize), audioSettings: .aac(channels: 2, sampleRate: 44100, bitRate: 128 * 1000))&#xA;configuration.videoComposition = composition.makeAVVideoComposition()&#xA;self.exporter = try! AssetExportSession(asset: asset, outputURL: outputURL, configuration: configuration)&#xA;exporter.export(progress: { progress in&#xA;    &#xA;}, completion: { error in&#xA;    &#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Process Live Video (with VideoIO)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/MetalPetal/VideoIO&#34;&gt;VideoIO&lt;/a&gt; is required for this example.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;import VideoIO&#xA;&#xA;// Setup Image View&#xA;let imageView = MTIImageView(frame: self.view.bounds)&#xA;...&#xA;&#xA;// Setup Camera&#xA;let camera = Camera(captureSessionPreset: .hd1920x1080, configurator: .portraitFrontMirroredVideoOutput)&#xA;try camera.enableVideoDataOutput(on: DispatchQueue.main, delegate: self)&#xA;camera.videoDataOutput?.videoSettings = [kCVPixelBufferPixelFormatTypeKey as String: kCVPixelFormatType_420YpCbCr8BiPlanarFullRange]&#xA;&#xA;...&#xA;&#xA;// AVCaptureVideoDataOutputSampleBufferDelegate&#xA;&#xA;let filter = MTIColorInvertFilter()&#xA;&#xA;func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {&#xA;    guard let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) else {&#xA;        return&#xA;    }&#xA;    let inputImage = MTIImage(cvPixelBuffer: pixelBuffer, alphaType: .alphaIsOne)&#xA;    filter.inputImage = inputImage&#xA;    self.imageView.image = filter.outputImage&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please refer to the &lt;code&gt;CameraFilterView.swift&lt;/code&gt; in the example project for more about previewing and recording filtered live video.&lt;/p&gt; &#xA;&lt;h2&gt;Best Practices&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Reuse a &lt;code&gt;MTIContext&lt;/code&gt; whenever possible.&lt;/p&gt; &lt;p&gt;Contexts are heavyweight objects, so if you do create one, do so as early as possible, and reuse it each time you need to render an image.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use &lt;code&gt;MTIImage.cachePolicy&lt;/code&gt; wisely.&lt;/p&gt; &lt;p&gt;Use &lt;code&gt;MTIImageCachePolicyTransient&lt;/code&gt; when you do not want to preserve the render result of an image, for example when the image is just an intermediate result in a filter chain, so the underlying texture of the render result can be reused. It is the most memory efficient option. However, when you ask the context to render a previously rendered image, it may re-render that image since its underlying texture has been reused.&lt;/p&gt; &lt;p&gt;By default, a filter&#39;s output image has the &lt;code&gt;transient&lt;/code&gt; policy.&lt;/p&gt; &lt;p&gt;Use &lt;code&gt;MTIImageCachePolicyPersistent&lt;/code&gt; when you want to prevent the underlying texture from being reused.&lt;/p&gt; &lt;p&gt;By default, images created from external sources have the &lt;code&gt;persistent&lt;/code&gt; policy.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Understand that &lt;code&gt;MTIFilter.outputImage&lt;/code&gt; is a compute property.&lt;/p&gt; &lt;p&gt;Each time you ask a filter for its output image, the filter may give you a new output image object even if the inputs are identical with the previous call. So reuse output images whenever possible.&lt;/p&gt; &lt;p&gt;For example,&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;//          ╭→ filterB&#xA;// filterA ─┤&#xA;//          ╰→ filterC&#xA;// &#xA;// filterB and filterC use filterA&#39;s output as their input.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this situation, the following solution:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let filterOutputImage = filterA.outputImage&#xA;filterB.inputImage = filterOutputImage&#xA;filterC.inputImage = filterOutputImage&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;is better than:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;filterB.inputImage = filterA.outputImage&#xA;filterC.inputImage = filterA.outputImage&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build Custom Filter&lt;/h2&gt; &#xA;&lt;p&gt;If you want to include the &lt;code&gt;MTIShaderLib.h&lt;/code&gt; in your &lt;code&gt;.metal&lt;/code&gt; file, you need to add the path of &lt;code&gt;MTIShaderLib.h&lt;/code&gt; file to the &lt;code&gt;Metal Compiler - Header Search Paths&lt;/code&gt; (&lt;code&gt;MTL_HEADER_SEARCH_PATHS&lt;/code&gt;) setting.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you use CocoaPods you can set the &lt;code&gt;MTL_HEADER_SEARCH_PATHS&lt;/code&gt; to &lt;code&gt;${PODS_CONFIGURATION_BUILD_DIR}/MetalPetal/MetalPetal.framework/Headers&lt;/code&gt; or &lt;code&gt;${PODS_ROOT}/MetalPetal/Frameworks/MetalPetal/Shaders&lt;/code&gt;. If you use Swift Package Manager, set the &lt;code&gt;MTL_HEADER_SEARCH_PATHS&lt;/code&gt; to &lt;code&gt;$(HEADER_SEARCH_PATHS)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Shader Function Arguments Encoding&lt;/h3&gt; &#xA;&lt;p&gt;MetalPetal has a built-in mechanism to encode shader function arguments for you. You can pass the shader function arguments as &lt;code&gt;name: value&lt;/code&gt; dictionaries to the &lt;code&gt;MTIRenderPipelineKernel.apply(toInputImages:parameters:outputDescriptors:)&lt;/code&gt;, &lt;code&gt;MTIRenderCommand(kernel:geometry:images:parameters:)&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;For example, the parameter dictionary for the metal function &lt;code&gt;vibranceAdjust&lt;/code&gt; can be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// Swift&#xA;let amount: Float = 1.0&#xA;let vibranceVector = float4(1, 1, 1, 1)&#xA;let parameters = [&#34;amount&#34;: amount,&#xA;                  &#34;vibranceVector&#34;: MTIVector(value: vibranceVector),&#xA;                  &#34;avoidsSaturatingSkinTones&#34;: true,&#xA;                  &#34;grayColorTransform&#34;: MTIVector(value: float3(0,0,0))]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Metal&#34;&gt;// vibranceAdjust metal function&#xA;fragment float4 vibranceAdjust(...,&#xA;                constant float &amp;amp; amount [[ buffer(0) ]],&#xA;                constant float4 &amp;amp; vibranceVector [[ buffer(1) ]],&#xA;                constant bool &amp;amp; avoidsSaturatingSkinTones [[ buffer(2) ]],&#xA;                constant float3 &amp;amp; grayColorTransform [[ buffer(3) ]])&#xA;{&#xA;    ...&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The shader function argument types and the corresponding types to use in a parameter dictionary is listed below.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Shader Function Argument Type&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Swift&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Objective-C&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;float&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Float&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;float&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;int&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Int32&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;int&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;uint&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;UInt32&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;uint&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;bool&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Bool&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;bool&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;simd (float2,float4,float4x4,int4, etc.)&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;simd (with &lt;code&gt;MetalPetal/Swift&lt;/code&gt;) / MTIVector&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;MTIVector&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;struct&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Data / MTIDataBuffer&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;NSData / MTIDataBuffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;other (float *, struct *, etc.) immutable&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Data / MTIDataBuffer&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;NSData / MTIDataBuffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;other (float *, struct *, etc.) mutable&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;MTIDataBuffer&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;MTIDataBuffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Simple Single Input / Output Filters&lt;/h3&gt; &#xA;&lt;p&gt;To build a custom unary filter, you can subclass &lt;code&gt;MTIUnaryImageRenderingFilter&lt;/code&gt; and override the methods in the &lt;code&gt;SubclassingHooks&lt;/code&gt; category. Examples: &lt;code&gt;MTIPixellateFilter&lt;/code&gt;, &lt;code&gt;MTIVibranceFilter&lt;/code&gt;, &lt;code&gt;MTIUnpremultiplyAlphaFilter&lt;/code&gt;, &lt;code&gt;MTIPremultiplyAlphaFilter&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;//Objective-C&#xA;&#xA;@interface MTIPixellateFilter : MTIUnaryImageRenderingFilter&#xA;&#xA;@property (nonatomic) float fractionalWidthOfAPixel;&#xA;&#xA;@end&#xA;&#xA;@implementation MTIPixellateFilter&#xA;&#xA;- (instancetype)init {&#xA;    if (self = [super init]) {&#xA;        _fractionalWidthOfAPixel = 0.05;&#xA;    }&#xA;    return self;&#xA;}&#xA;&#xA;+ (MTIFunctionDescriptor *)fragmentFunctionDescriptor {&#xA;    return [[MTIFunctionDescriptor alloc] initWithName:@&#34;pixellateEffect&#34; libraryURL:[bundle URLForResource:@&#34;default&#34; withExtension:@&#34;metallib&#34;]];&#xA;}&#xA;&#xA;- (NSDictionary&amp;lt;NSString *,id&amp;gt; *)parameters {&#xA;    return @{@&#34;fractionalWidthOfAPixel&#34;: @(self.fractionalWidthOfAPixel)};&#xA;}&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;//Swift&#xA;&#xA;class MTIPixellateFilter: MTIUnaryImageRenderingFilter {&#xA;    &#xA;    var fractionalWidthOfAPixel: Float = 0.05&#xA;&#xA;    override var parameters: [String : Any] {&#xA;        return [&#34;fractionalWidthOfAPixel&#34;: fractionalWidthOfAPixel]&#xA;    }&#xA;    &#xA;    override class func fragmentFunctionDescriptor() -&amp;gt; MTIFunctionDescriptor {&#xA;        return MTIFunctionDescriptor(name: &#34;pixellateEffect&#34;, libraryURL: MTIDefaultLibraryURLForBundle(Bundle.main))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fully Custom Filters&lt;/h3&gt; &#xA;&lt;p&gt;To build more complex filters, all you need to do is create a kernel (&lt;code&gt;MTIRenderPipelineKernel&lt;/code&gt;/&lt;code&gt;MTIComputePipelineKernel&lt;/code&gt;/&lt;code&gt;MTIMPSKernel&lt;/code&gt;), then apply the kernel to the input image(s). Examples: &lt;code&gt;MTIChromaKeyBlendFilter&lt;/code&gt;, &lt;code&gt;MTIBlendWithMaskFilter&lt;/code&gt;, &lt;code&gt;MTIColorLookupFilter&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;&#xA;@interface MTIChromaKeyBlendFilter : NSObject &amp;lt;MTIFilter&amp;gt;&#xA;&#xA;@property (nonatomic, strong, nullable) MTIImage *inputImage;&#xA;&#xA;@property (nonatomic, strong, nullable) MTIImage *inputBackgroundImage;&#xA;&#xA;@property (nonatomic) float thresholdSensitivity;&#xA;&#xA;@property (nonatomic) float smoothing;&#xA;&#xA;@property (nonatomic) MTIColor color;&#xA;&#xA;@end&#xA;&#xA;@implementation MTIChromaKeyBlendFilter&#xA;&#xA;@synthesize outputPixelFormat = _outputPixelFormat;&#xA;&#xA;+ (MTIRenderPipelineKernel *)kernel {&#xA;    static MTIRenderPipelineKernel *kernel;&#xA;    static dispatch_once_t onceToken;&#xA;    dispatch_once(&amp;amp;onceToken, ^{&#xA;        kernel = [[MTIRenderPipelineKernel alloc] initWithVertexFunctionDescriptor:[[MTIFunctionDescriptor alloc] initWithName:MTIFilterPassthroughVertexFunctionName] fragmentFunctionDescriptor:[[MTIFunctionDescriptor alloc] initWithName:@&#34;chromaKeyBlend&#34;]];&#xA;    });&#xA;    return kernel;&#xA;}&#xA;&#xA;- (instancetype)init {&#xA;    if (self = [super init]) {&#xA;        _thresholdSensitivity = 0.4;&#xA;        _smoothing = 0.1;&#xA;        _color = MTIColorMake(0.0, 1.0, 0.0, 1.0);&#xA;    }&#xA;    return self;&#xA;}&#xA;&#xA;- (MTIImage *)outputImage {&#xA;    if (!self.inputImage || !self.inputBackgroundImage) {&#xA;        return nil;&#xA;    }&#xA;    return [self.class.kernel applyToInputImages:@[self.inputImage, self.inputBackgroundImage]&#xA;                                      parameters:@{@&#34;color&#34;: [MTIVector vectorWithFloat4:(simd_float4){self.color.red, self.color.green, self.color.blue,self.color.alpha}],&#xA;                                    @&#34;thresholdSensitivity&#34;: @(self.thresholdSensitivity),&#xA;                                               @&#34;smoothing&#34;: @(self.smoothing)}&#xA;                         outputTextureDimensions:MTITextureDimensionsMake2DFromCGSize(self.inputImage.size)&#xA;                               outputPixelFormat:self.outputPixelFormat];&#xA;}&#xA;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple Draw Calls in One Render Pass&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;MTIRenderCommand&lt;/code&gt; to issue multiple draw calls in one render pass.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// Create a draw call with kernelA, geometryA, and imageA.&#xA;let renderCommandA = MTIRenderCommand(kernel: self.kernelA, geometry: self.geometryA, images: [imageA], parameters: [:])&#xA;&#xA;// Create a draw call with kernelB, geometryB, and imageB.&#xA;let renderCommandB = MTIRenderCommand(kernel: self.kernelB, geometry: self.geometryB, images: [imageB], parameters: [:])&#xA;&#xA;// Create an output descriptor&#xA;let outputDescriptor = MTIRenderPassOutputDescriptor(dimensions: MTITextureDimensions(width: outputWidth, height: outputHeight, depth: 1), pixelFormat: .bgra8Unorm, loadAction: .clear, storeAction: .store)&#xA;&#xA;// Get the output images, the output image count is equal to the output descriptor count.&#xA;let images = MTIRenderCommand.images(byPerforming: [renderCommandA, renderCommandB], outputDescriptors: [outputDescriptor])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also create multiple output descriptors to output multiple images in one render pass (MRT, See &lt;a href=&#34;https://en.wikipedia.org/wiki/Multiple_Render_Targets&#34;&gt;https://en.wikipedia.org/wiki/Multiple_Render_Targets&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Custom Vertex Data&lt;/h3&gt; &#xA;&lt;p&gt;When &lt;code&gt;MTIVertex&lt;/code&gt; cannot fit your needs, you can implement the &lt;code&gt;MTIGeometry&lt;/code&gt; protocol to provide your custom vertex data to the command encoder.&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;MTIRenderCommand&lt;/code&gt; API to issue draw calls and pass your custom &lt;code&gt;MTIGeometry&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Processing Module&lt;/h3&gt; &#xA;&lt;p&gt;In rare scenarios, you may want to access the underlying texture directly, use multiple MPS kernels in one render pass, do 3D rendering, or encode the render commands yourself.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MTIImagePromise&lt;/code&gt; protocol provides direct access to the underlying texture and the render context for a step in MetalPetal.&lt;/p&gt; &#xA;&lt;p&gt;You can create new input sources or fully custom processing units by implementing the &lt;code&gt;MTIImagePromise&lt;/code&gt; protocol. You will need to import an additional module to do so.&lt;/p&gt; &#xA;&lt;p&gt;Objective-C&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@import MetalPetal.Extension;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Swift&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// CocoaPods&#xA;import MetalPetal.Extension&#xA;&#xA;// Swift Package Manager&#xA;import MetalPetalObjectiveC.Extension&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the implementation of &lt;code&gt;MTIComputePipelineKernel&lt;/code&gt;, &lt;code&gt;MTICLAHELUTRecipe&lt;/code&gt; or &lt;code&gt;MTIImage&lt;/code&gt; for example.&lt;/p&gt; &#xA;&lt;h2&gt;Alpha Types&lt;/h2&gt; &#xA;&lt;p&gt;If an alpha channel is used in an image, there are two common representations that are available: unpremultiplied (straight/unassociated) alpha, and premultiplied (associated) alpha.&lt;/p&gt; &#xA;&lt;p&gt;With unpremultiplied alpha, the RGB components represent the color of the pixel, disregarding its opacity.&lt;/p&gt; &#xA;&lt;p&gt;With premultiplied alpha, the RGB components represent the color of the pixel, adjusted for its opacity by multiplication.&lt;/p&gt; &#xA;&lt;p&gt;MetalPetal handles alpha type explicitly. You are responsible for providing the correct alpha type during image creation.&lt;/p&gt; &#xA;&lt;p&gt;There are three alpha types in MetalPetal.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MTIAlphaType.nonPremultiplied&lt;/code&gt;: the alpha value in the image is not premultiplied.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MTIAlphaType.premultiplied&lt;/code&gt;: the alpha value in the image is premultiplied.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MTIAlphaType.alphaIsOne&lt;/code&gt;: there&#39;s no alpha channel in the image or the image is opaque.&lt;/p&gt; &#xA;&lt;p&gt;Typically, &lt;code&gt;CGImage&lt;/code&gt;, &lt;code&gt;CVPixelBuffer&lt;/code&gt; and &lt;code&gt;CIImage&lt;/code&gt; objects have premultiplied alpha channels. &lt;code&gt;MTIAlphaType.alphaIsOne&lt;/code&gt; is strongly recommended if the image is opaque, e.g. a &lt;code&gt;CVPixelBuffer&lt;/code&gt; from camera feed, or a &lt;code&gt;CGImage&lt;/code&gt; loaded from a &lt;code&gt;jpg&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;You can call &lt;code&gt;unpremultiplyingAlpha()&lt;/code&gt; or &lt;code&gt;premultiplyingAlpha()&lt;/code&gt; on a &lt;code&gt;MTIImage&lt;/code&gt; to convert the alpha type of the image.&lt;/p&gt; &#xA;&lt;p&gt;For performance reasons, alpha type validation only happens in debug build.&lt;/p&gt; &#xA;&lt;h3&gt;Alpha Handling of Built-in Filters&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Most of the filters in MetalPetal accept unpremultiplied alpha and opaque images and output unpremultiplied alpha images.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Filters with &lt;code&gt;outputAlphaType&lt;/code&gt; property accept inputs of all alpha types. And you can use &lt;code&gt;outputAlphaType&lt;/code&gt; to specify the alpha type of the output image.&lt;/p&gt; &lt;p&gt;e.g. &lt;code&gt;MTIBlendFilter&lt;/code&gt;, &lt;code&gt;MTIMultilayerCompositingFilter&lt;/code&gt;, &lt;code&gt;MTICoreImageUnaryFilter&lt;/code&gt;, &lt;code&gt;MTIRGBColorSpaceConversionFilter&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Filters that do not actually modify colors have passthrough alpha handling rule, that means the alpha types of the output images are the same with the input images.&lt;/p&gt; &lt;p&gt;e.g. &lt;code&gt;MTITransformFilter&lt;/code&gt;, &lt;code&gt;MTICropFilter&lt;/code&gt;, &lt;code&gt;MTIPixellateFilter&lt;/code&gt;, &lt;code&gt;MTIBulgeDistortionFilter&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more about alpha types and alpha compositing, please refer to &lt;a href=&#34;https://ciechanow.ski/alpha-compositing/&#34;&gt;this amazing interactive article&lt;/a&gt; by Bartosz Ciechanowski.&lt;/p&gt; &#xA;&lt;h2&gt;Color Spaces&lt;/h2&gt; &#xA;&lt;p&gt;Color spaces are vital for image processing. The numeric values of the red, green, and blue components have no meaning without a color space.&lt;/p&gt; &#xA;&lt;p&gt;Before continuing on how MetalPetal handles color spaces, you may want to know what a color space is and how it affects the representation of color values. There are many articles on the web explaining color spaces, to get started, the suggestion is &lt;a href=&#34;https://ciechanow.ski/color-spaces/&#34;&gt;Color Spaces - by Bartosz Ciechanowski&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Different softwares and frameworks have different ways of handling color spaces. For example, Photoshop has a default sRGB IEC61966-2.1 working color space, while Core Image, by default, uses linear sRGB working color space.&lt;/p&gt; &#xA;&lt;p&gt;Metal textures do not store any color space information with them. Most of the color space handling in MetalPetal happens during the input (&lt;code&gt;MTIImage(...)&lt;/code&gt;) and the output (&lt;code&gt;MTIContext.render...&lt;/code&gt;) of image data.&lt;/p&gt; &#xA;&lt;h3&gt;Color Spaces for Inputs&lt;/h3&gt; &#xA;&lt;p&gt;Specifying a color space for an input means that MetalPetal should convert the source color values to the specified color space during the creation of the texture.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When loading from &lt;code&gt;URL&lt;/code&gt; or &lt;code&gt;CGImage&lt;/code&gt;, you can specify which color space you&#39;d like the texture data to be in, using &lt;code&gt;MTICGImageLoadingOptions&lt;/code&gt;. If you do not specify any options when loading an image, the device RGB color space is used (&lt;code&gt;MTICGImageLoadingOptions.default&lt;/code&gt;). A &lt;code&gt;nil&lt;/code&gt; color space disables color matching, this is the equivalent of using the color space of the input image to create &lt;code&gt;MTICGImageLoadingOptions&lt;/code&gt;. If the model of the specified color space is not RGB, the device RGB color space is used as a fallback.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When loading from &lt;code&gt;CIImage&lt;/code&gt;, you can specify which color space you&#39;d like the texture data to be in, using &lt;code&gt;MTICIImageRenderingOptions&lt;/code&gt;. If you do not specify any options when loading a &lt;code&gt;CIImage&lt;/code&gt;, the device RGB color space is used (&lt;code&gt;MTICIImageRenderingOptions.default&lt;/code&gt;). A &lt;code&gt;nil&lt;/code&gt; color space disables color matching, color values are loaded in the working color space of the &lt;code&gt;CIContext&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Color Spaces for Outputs&lt;/h3&gt; &#xA;&lt;p&gt;When specifying a color space for an output, the color space serves more like a tag which is used to communicate with the rest of the system on how to represent the color values in the output. There is no actual color space conversion performed.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can specify the color space of an output &lt;code&gt;CGImage&lt;/code&gt; using &lt;code&gt;MTIContext.makeCGImage...&lt;/code&gt; or &lt;code&gt;MTIContext.startTaskTo...&lt;/code&gt; methods with a &lt;code&gt;colorSpace&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can specify the color space of an output &lt;code&gt;CIImage&lt;/code&gt; using &lt;code&gt;MTICIImageCreationOptions&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;MetalPetal assumes that the output color values are in device RGB color space when no output color space is specified.&lt;/p&gt; &#xA;&lt;h3&gt;Color Spaces for &lt;code&gt;CVPixelBuffer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;MetalPetal uses &lt;code&gt;CVMetalTextureCache&lt;/code&gt; and &lt;code&gt;IOSurface&lt;/code&gt; to directly map &lt;code&gt;CVPixelBuffer&lt;/code&gt;s to Metal textures. So you cannot specify a color space for loading from or rendering to a &lt;code&gt;CVPixelBuffer&lt;/code&gt;. However you can specify whether to use a texture with a sRGB pixel format for the mapping.&lt;/p&gt; &#xA;&lt;p&gt;In Metal, if the pixel format name has the &lt;code&gt;_sRGB&lt;/code&gt; suffix, then sRGB gamma compression and decompression are applied during the reading and writing of color values in the pixel. That means a texture with the &lt;code&gt;_sRGB&lt;/code&gt; pixel format assumes the color values it stores are sRGB gamma corrected, when the color values are read in a shader, sRGB to linear RGB conversions are performed. When the color values are written in a shader, linear RGB to sRGB conversions are performed.&lt;/p&gt; &#xA;&lt;h3&gt;Color Space Conversions&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;MTIRGBColorSpaceConversionFilter&lt;/code&gt; to perform color space conversions. Color space conversion functions are also available in &lt;code&gt;MTIShaderLib.h&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;metalpetal::sRGBToLinear&lt;/code&gt; (sRGB IEC61966-2.1 to linear sRGB)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metalpetal::linearToSRGB&lt;/code&gt; (linear sRGB to sRGB IEC61966-2.1)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metalpetal::linearToITUR709&lt;/code&gt; (linear sRGB to ITU-R 709)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metalpetal::ITUR709ToLinear&lt;/code&gt; (ITU-R 709 to linear sRGB)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Extensions&lt;/h2&gt; &#xA;&lt;h3&gt;Working with SceneKit&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;MTISCNSceneRenderer&lt;/code&gt; to generate &lt;code&gt;MTIImage&lt;/code&gt;s from a &lt;code&gt;SCNScene&lt;/code&gt;. You may want to handle the SceneKit renderer&#39;s linear RGB color space, see issue &lt;a href=&#34;https://github.com/MetalPetal/MetalPetal/issues/76&#34;&gt;#76 The image from SceneKit is darker than normal&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Working with SpriteKit&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;MTISKSceneRenderer&lt;/code&gt; to generate &lt;code&gt;MTIImage&lt;/code&gt;s from a &lt;code&gt;SKScene&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Working with Core Image&lt;/h3&gt; &#xA;&lt;p&gt;You can create &lt;code&gt;MTIImage&lt;/code&gt;s from &lt;code&gt;CIImage&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;You can render a &lt;code&gt;MTIImage&lt;/code&gt; to a &lt;code&gt;CIImage&lt;/code&gt; using a &lt;code&gt;MTIContext&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can use a &lt;code&gt;CIFilter&lt;/code&gt; directly with &lt;code&gt;MTICoreImageKernel&lt;/code&gt; or the &lt;code&gt;MTICoreImageUnaryFilter&lt;/code&gt; class. (Swift Only)&lt;/p&gt; &#xA;&lt;h3&gt;Working with JavaScript&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/MetalPetal/MetalPetalJS&#34;&gt;MetalPetalJS&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;With MetalPetalJS you can create render pipelines and filters using JavaScript, making it possible to download your filters/renderers from &#34;the cloud&#34;.&lt;/p&gt; &#xA;&lt;h3&gt;Texture Loader&lt;/h3&gt; &#xA;&lt;p&gt;It is recommended that you use APIs that accept &lt;code&gt;MTICGImageLoadingOptions&lt;/code&gt; to load &lt;code&gt;CGImage&lt;/code&gt;s and images from &lt;code&gt;URL&lt;/code&gt;, instead of using APIs that accept &lt;code&gt;MTKTextureLoaderOption&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When you use APIs that accept &lt;code&gt;MTKTextureLoaderOption&lt;/code&gt;, MetalPetal, by default, uses &lt;code&gt;MTIDefaultTextureLoader&lt;/code&gt; to load &lt;code&gt;CGImage&lt;/code&gt;s, images from &lt;code&gt;URL&lt;/code&gt;, and named images. &lt;code&gt;MTIDefaultTextureLoader&lt;/code&gt; uses &lt;code&gt;MTKTextureLoader&lt;/code&gt; internally and has some workarounds for &lt;code&gt;MTKTextureLoader&lt;/code&gt;&#39;s inconsistencies and bugs at a small performance cost. You can also create your own texture loader by implementing the &lt;code&gt;MTITextureLoader&lt;/code&gt; protocol. Then assign your texture loader class to &lt;code&gt;MTIContextOptions.textureLoaderClass&lt;/code&gt; when creating a &lt;code&gt;MTIContext&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; to install the latest version.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;use_frameworks!&#xA;&#xA;pod &#39;MetalPetal&#39;&#xA;&#xA;# Required if you are using Swift.&#xA;pod &#39;MetalPetal/Swift&#39;&#xA;&#xA;# Recommended if you&#39;d like to run MetalPetal on Apple silicon Macs.&#xA;pod &#39;MetalPetal/AppleSilicon&#39;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Sub-pod &lt;code&gt;Swift&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Provides Swift-specific additions and modifications to the Objective-C APIs to improve their mapping into Swift. Highly recommended if you are using Swift.&lt;/p&gt; &#xA;&lt;h4&gt;Sub-pod &lt;code&gt;AppleSilicon&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Provides the default shader library compiled in Metal Shading Language v2.3 which is required for enabling programmable blending support on Apple silicon Macs.&lt;/p&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/xcode/adding_package_dependencies_to_your_app&#34;&gt;Adding Package Dependencies to Your App&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;iOS Simulator Support&lt;/h2&gt; &#xA;&lt;p&gt;MetalPetal can run on Simulator with Xcode 11+ and macOS 10.15+.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MetalPerformanceShaders.framework&lt;/code&gt; is not available on Simulator, so filters that rely on &lt;code&gt;MetalPerformanceShaders&lt;/code&gt;, such as &lt;code&gt;MTIMPSGaussianBlurFilter&lt;/code&gt;, &lt;code&gt;MTICLAHEFilter&lt;/code&gt;, do not work.&lt;/p&gt; &#xA;&lt;p&gt;Simulator supports fewer features or different implementation limits than an actual Apple GPU. See &lt;a href=&#34;https://developer.apple.com/documentation/metal/developing_metal_apps_that_run_in_simulator&#34;&gt;Developing Metal Apps that Run in Simulator&lt;/a&gt; for detail.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Look Debug Support&lt;/h2&gt; &#xA;&lt;p&gt;If you do a Quick Look on a &lt;code&gt;MTIImage&lt;/code&gt;, it&#39;ll show you the image graph that you constructed to produce that image.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1234944/116965587-c6a0a280-ace0-11eb-8918-2f36d1d6114c.jpg&#34; alt=&#34;Quick Look Debug Preview&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Trivia&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/MetalPetal/MetalPetal/issues/52&#34;&gt;Why Objective-C?&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Thank you for considering contributing to MetalPetal. Please read our &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/CONTRIBUTING.md&#34;&gt;Contributing Guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MetalPetal is MIT-licensed. &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The files in the &lt;code&gt;/MetalPetalExamples&lt;/code&gt; directory are licensed under a separate license. &lt;a href=&#34;https://raw.githubusercontent.com/MetalPetal/MetalPetal/master/MetalPetalExamples/LICENSE.md&#34;&gt;LICENSE.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Documentation is licensed CC-BY-4.0.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>glaszig/SZTextView</title>
    <updated>2022-06-21T01:51:18Z</updated>
    <id>tag:github.com,2022-06-21:/glaszig/SZTextView</id>
    <link href="https://github.com/glaszig/SZTextView" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A drop-in UITextView replacement which gives you: a placeholder.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SZTextView&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/glaszig/SZTextView&#34;&gt;&lt;img src=&#34;https://travis-ci.org/glaszig/SZTextView.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A drop-in UITextView replacement which gives you: a placeholder.&lt;br&gt; Technically it differs from other solutions in that it tries to work like UITextField&#39;s private &lt;code&gt;_placeholderLabel&lt;/code&gt; so you should not suffer ugly glitches like jumping text views or loads of custom drawing code.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Your iOS project. Unit-tested on iOS 8.x, 9.x, 10.x -- see &lt;code&gt;.travis.yml&lt;/code&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Either clone this repo and add the project to your Xcode workspace, use &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; or &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;CocoaPods&lt;/h4&gt; &#xA;&lt;p&gt;Add this to you Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SZTextView&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Carthage&lt;/h4&gt; &#xA;&lt;p&gt;Add this line to your Cartfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;glaszig/SZTextView&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;SZTextView *textView = [SZTextView new];&#xA;textView.placeholder = @&#34;Enter lorem ipsum here&#34;;&#xA;textView.placeholderTextColor = [UIColor lightGrayColor];&#xA;textView.font = [UIFont fontWithName:@&#34;HelveticaNeue-Light&#34; size:18.0];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Analogously you can use the &lt;code&gt;attributedPlaceholder&lt;/code&gt; property to set a fancy &lt;code&gt;NSAttributedString&lt;/code&gt; as the placeholder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSMutableAttributedString *placeholder = [[NSMutableAttributedString alloc] initWithString:@&#34;Enter lorem ipsum here&#34;];&#xA;[placeholder addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,2)];&#xA;[placeholder addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(2,4)];&#xA;[placeholder addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(6,4)];&#xA;&#xA;textView.attributedPlaceholder = placeholder;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both properties &lt;code&gt;placeholder&lt;/code&gt; and &lt;code&gt;attributedPlaceholder&lt;/code&gt; are made to stay in sync. If you set an &lt;code&gt;attributedPlaceholder&lt;/code&gt; and afterwards set &lt;code&gt;placeholder&lt;/code&gt; to something else, the set text gets copied to the &lt;code&gt;attributedPlaceholder&lt;/code&gt; while trying to keep the original text attributes.&lt;br&gt; Also, &lt;code&gt;placeholder&lt;/code&gt; will be set to &lt;code&gt;attributedPlaceholder.string&lt;/code&gt; when using the &lt;code&gt;attributedPlaceholder&lt;/code&gt; setter.&lt;/p&gt; &#xA;&lt;p&gt;A simple demo and a few unit tests are included.&lt;/p&gt; &#xA;&lt;h3&gt;Animation&lt;/h3&gt; &#xA;&lt;p&gt;The placeholder is animatable. Just configure the &lt;code&gt;double&lt;/code&gt; property &lt;code&gt;fadeTime&lt;/code&gt; to the seconds you&#39;d like the animation to take.&lt;/p&gt; &#xA;&lt;h3&gt;User Defined Runtime Attributes&lt;/h3&gt; &#xA;&lt;p&gt;If you prefer using Interface Builder to configure your UI, you can use UDRA&#39;s to set values for &lt;code&gt;placeholder&lt;/code&gt; and &lt;code&gt;placeholderTextColor&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork it&lt;/li&gt; &#xA; &lt;li&gt;Create your feature branch (&lt;code&gt;git checkout -b my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Commit your changes (&lt;code&gt;git commit -am &#39;Added some feature&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the branch (&lt;code&gt;git push origin my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create new Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Published under the &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve developed this component for &lt;a href=&#34;http://www.cocktailiciousapp.com&#34;&gt;Cocktailicious&lt;/a&gt;. You should check it out *shamelessplug*.&lt;br&gt; Please let me now if and how you use this component. I&#39;m curious.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>facebookarchive/Tweaks</title>
    <updated>2022-06-21T01:51:18Z</updated>
    <id>tag:github.com,2022-06-21:/facebookarchive/Tweaks</id>
    <link href="https://github.com/facebookarchive/Tweaks" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An easy way to fine-tune, and adjust parameters for iOS apps in development.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Tweaks&lt;/h1&gt; &#xA;&lt;p&gt;Tweaks is an easy way to fine-tune an iOS app. &lt;a href=&#34;https://travis-ci.org/facebook/Tweaks&#34;&gt;&lt;img src=&#34;https://travis-ci.org/facebook/Tweaks.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/facebook/Tweaks/raw/master/Images/Tweaks.gif?raw=true&#34; alt=&#34;Tweaks&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;p&gt;The best way to improve an app is to use it every day. Even when ideas can be tested out in advance — for example, with &lt;a href=&#34;http://origami.facebook.com&#34;&gt;Origami&lt;/a&gt; — it can still take some time with the app to see how it works in practice.&lt;/p&gt; &#xA;&lt;p&gt;Occasionally, it&#39;s perfect the first try. Sometimes, the idea doesn&#39;t work at all. But often, it just needs a few minor adjustments. That last case is where Tweaks fits in. Tweaks makes those small adjustments easy: with no code changes and no computer, you can try out different options and decide which works best.&lt;/p&gt; &#xA;&lt;p&gt;Some of the most useful parameters to adjust are animation timings, velocity thresholds, colors, and physics constants. At Facebook, we also use tweaks to temporarily disable new features during development. That way, the designers and engineers involved can enable it on just their devices, without getting in the way of others testing the app.&lt;/p&gt; &#xA;&lt;p&gt;Tweaks was invaluable for building &lt;a href=&#34;http://www.facebook.com/paper&#34;&gt;Paper&lt;/a&gt;. We hope it can be useful for your app too.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Each configurable value is called a tweak. There&#39;s a few ways to set them up, found in &lt;code&gt;FBTweakInline.h&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Value&lt;/h3&gt; &#xA;&lt;p&gt;The simplest way to create a tweak is to replace a constant with &lt;code&gt;FBTweakValue&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;CGFloat animationDuration = FBTweakValue(@&#34;Category&#34;, @&#34;Group&#34;, @&#34;Duration&#34;, 0.5);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first three parameters are where the tweak is listed and what it&#39;s called, and the last one is the default value. You can pass in many types of values for the default: booleans, numbers, or strings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;if (FBTweakValue(@&#34;Category&#34;, @&#34;Feature&#34;, @&#34;Enabled&#34;, YES)) {&#xA;  label.text = FBTweakValue(@&#34;Category&#34;, @&#34;Group&#34;, @&#34;Text&#34;, @&#34;Tweaks example.&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In release builds, the &lt;code&gt;FBTweakValue&lt;/code&gt; macro expands to just the default value, so there&#39;s no performance impact. In debug builds, though, it fetches the latest value of the tweak.&lt;/p&gt; &#xA;&lt;p&gt;You can also pass a fifth parameter, which will constrain the possible values for a tweak. The fifth parameter can be an array, dictionary, or an &lt;code&gt;FBTweakNumericRange&lt;/code&gt;. If it&#39;s a dictionary, the values should be strings to show in the list of choices. Arrays will show the values&#39; &lt;code&gt;description&lt;/code&gt; as choices. (Note that you have to surround array and dictionary literals with an extra set of parentheses.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;self.initialMode = FBTweakValue(@&#34;Header&#34;, @&#34;Initial&#34;, @&#34;Mode&#34;, @(FBSimpleMode), (@{ @(FBSimpleMode) : @&#34;Simple&#34;, @(FBAdvancedMode) : @&#34;Advanced&#34; }));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For numeric tweaks (&lt;code&gt;NSInteger&lt;/code&gt;, &lt;code&gt;CGFloat&lt;/code&gt;, and others), you can instead pass two parameters, which constrain the value to a &lt;code&gt;FBTweakNumericRange&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;self.red = FBTweakValue(@&#34;Header&#34;, @&#34;Colors&#34;, @&#34;Red&#34;, 0.5, 0.0, 1.0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bind&lt;/h3&gt; &#xA;&lt;p&gt;To make tweaks update live, you can use &lt;code&gt;FBTweakBind&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;FBTweakBind(self.headerView, alpha, @&#34;Main Screen&#34;, @&#34;Header&#34;, @&#34;Alpha&#34;, 0.85);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first parameter is the object to bind to, and the second is the property. Whenever the tweak is changed, &lt;code&gt;self.headerView&lt;/code&gt;&#39;s &lt;code&gt;alpha&lt;/code&gt; property is updated to match. A few more examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;FBTweakBind(audioPlayer, volume, @&#34;Player&#34;, @&#34;Audio&#34;, @&#34;Volume&#34;, 0.9);&#xA;FBTweakBind(webView.scrollView, scrollEnabled, @&#34;Browser&#34;, @&#34;Scrolling&#34;, @&#34;Enabled&#34;, YES);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with &lt;code&gt;FBTweakValue&lt;/code&gt;, in release builds &lt;code&gt;FBTweakBind&lt;/code&gt; expands to just setting the property to the default value.&lt;/p&gt; &#xA;&lt;h2&gt;Action&lt;/h2&gt; &#xA;&lt;p&gt;Actions let you run a (global) block when a tweak is selected. To make one, use &lt;code&gt;FBTweakAction&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;FBTweakAction(@&#34;Player&#34;, @&#34;Audio&#34;, @&#34;Volume&#34;, ^{&#xA;  NSLog(@&#34;Action selected.&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first three parameters are the standard tweak listing information, and the last is a block to call. You can use &lt;code&gt;FBTweakAction&lt;/code&gt; in any scope, but the block must be global: it can&#39;t depend on any local or instance variables (it wouldn&#39;t know which object to adjust).&lt;/p&gt; &#xA;&lt;p&gt;Actions are useful for things like launching debug UIs, checking for updates, or (if you make one that intentionally crashes) testing crash reporting.&lt;/p&gt; &#xA;&lt;h3&gt;Tweaks UI&lt;/h3&gt; &#xA;&lt;p&gt;To configure your tweaks, you need a way to show the configuration UI. There&#39;s two options for that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Traditionally, tweaks is activated by shaking your phone. To use that, just replace your root &lt;code&gt;UIWindow&lt;/code&gt; with a &lt;code&gt;FBTweakShakeWindow&lt;/code&gt;. If you&#39;re using Storyboards, you can override &lt;code&gt;-window&lt;/code&gt; on your app delegate:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (UIWindow *)window&#xA;{&#xA;  if (!_window) {&#xA;    _window = [[FBTweakShakeWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];&#xA;  }&#xA;&#xA;  return _window;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can present a &lt;code&gt;FBTweakViewController&lt;/code&gt; from anywhere in your app. Be sure to restrict the activation UI to debug builds!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)showTweaks {&#xA;   FBTweakViewController *tweakVC = [[FBTweakViewController alloc] initWithStore:[FBTweakStore sharedInstance]];&#xA;   tweakVC.tweaksDelegate = self;&#xA;   // Assuming this is in the app delegate&#xA;   [self.window.rootViewController presentViewController:tweakVC animated:YES completion:nil];&#xA;}&#xA;&#xA;- (void)tweakViewControllerPressedDone:(FBTweakViewController *)tweakViewController {&#xA;   [tweakViewController dismissViewControllerAnimated:YES completion:NULL];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Tweaks UI Dismiss Notification&lt;/h4&gt; &#xA;&lt;p&gt;Alternatively, when the Tweaks UI is dismissed, you can register your notification center to listen to &lt;code&gt;FBTweakShakeViewControllerDidDismissNotification&lt;/code&gt;, which can be used after importing &lt;code&gt;FBTweakViewController.h&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Advanced&lt;/h3&gt; &#xA;&lt;p&gt;You can also access the objects that make up the macros mentioned above. That can be useful for more complex scenarios, like adjusting members of a C structure.&lt;/p&gt; &#xA;&lt;p&gt;For example, to manually create a tweak:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;FBTweak *tweak = [[FBTweak alloc] initWithIdentifier:@&#34;com.tweaks.example.advanced&#34;];&#xA;tweak.name = @&#34;Advanced Settings&#34;;&#xA;tweak.defaultValue = @NO;&#xA;&#xA;FBTweakStore *store = [FBTweakStore sharedInstance];&#xA;FBTweakCategory *category = [[FBTweakCategory alloc] initWithName:@&#34;Settings&#34;];&#xA;[store addTweakCategory:category];&#xA;FBTweakCollection *collection = [[FBTweakCollection alloc] initWithName:@&#34;Enable&#34;];&#xA;[category addTweakCollection:collection];&#xA;[collection addTweak:tweak];&#xA;&#xA;[tweak addObserver:self];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can watch for when the tweak changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)tweakDidChange:(FBTweak *)tweak&#xA;{&#xA;  self.advancedSettingsEnabled = ![tweak.currentValue boolValue];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also you have de ability to implement the optional method &lt;code&gt;tweakWillChange:&lt;/code&gt; in order to handle the previous value of your tweak:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)tweakWillChange:(FBTweak *)tweak&#xA;{&#xA;  NSLog(@&#34;%@&#34;, tweak.currentValue); // Here current value is the previous value of the tweak&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To override when tweaks are enabled, you can define the &lt;code&gt;FB_TWEAK_ENABLED&lt;/code&gt; macro. It&#39;s suggested to avoid including them when submitting to the App Store.&lt;/p&gt; &#xA;&lt;h3&gt;Using from a Swift Project&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;Khan Academy&#39;s project &lt;a href=&#34;http://engineering.khanacademy.org/posts/introducing-swifttweaks.htm&#34;&gt;SwiftTweaks&lt;/a&gt; is designed for Swift, and might be a better choice for Swift projects.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Tweaks can be used from Swift projects. In this case the handy shortcut macros defined in &lt;code&gt;FBTweakInline.h&lt;/code&gt; are not available, meaning tweaks need to be created programmatically, similar to this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let tweak = FBTweak(identifier: &#34;com.tweaks.example.advanced&#34;)&#xA;tweak.name = &#34;Advanced settings&#34;&#xA;tweak.defaultValue = false&#xA;&#xA;let collection = FBTweakCollection(name: &#34;Enable&#34;);&#xA;collection.addTweak(tweak)&#xA;        &#xA;let category = FBTweakCategory(name: &#34;Settings&#34;)&#xA;category.addTweakCollection(collection);&#xA;        &#xA;let store = FBTweakStore.sharedInstance()&#xA;store.addTweakCategory(category)&#xA;&#xA;tweak.addObserver(self)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After setting up a tweak you can watch for when it changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func tweakDidChange(tweak: FBTweak!)&#xA;{&#xA;    self.advancedSettingsEnabled = tweak.currentValue as Bool;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How it works&lt;/h3&gt; &#xA;&lt;p&gt;In debug builds, the tweak macros use &lt;code&gt;__attribute__((section))&lt;/code&gt; to statically store data about each tweak in the &lt;code&gt;__FBTweak&lt;/code&gt; section of the mach-o. Tweaks loads that data at startup and loads the latest values from &lt;code&gt;NSUserDefaults&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In release builds, the macros just expand to the default value. Nothing extra is included in the binary.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;There are two options:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Tweaks is available as &lt;code&gt;Tweaks&lt;/code&gt; in &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. (If you have issues with custom Xcode configurations, &lt;a href=&#34;https://github.com/facebook/Tweaks/issues/4#issuecomment-40629741&#34;&gt;this comment&lt;/a&gt; might help.)&lt;/li&gt; &#xA; &lt;li&gt;Manually add the files from &lt;code&gt;FBTweak/&lt;/code&gt; into your Xcode project. Slightly simpler, but updates are also manual.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Tweaks requires iOS 6 or later.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s also a demo project available. To use it, make sure to open &lt;code&gt;FBTweakExample.xcworkspace&lt;/code&gt; (rather than the &lt;code&gt;.xcodeproj&lt;/code&gt;) so the dependencies build correctly.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See the CONTRIBUTING file for how to help out.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Tweaks is BSD-licensed. We also provide an additional patent grant.&lt;/p&gt;</summary>
  </entry>
</feed>