<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-23T01:42:41Z</updated>
  <subtitle>Daily Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Muirey03/CVE-2022-42864</title>
    <updated>2023-01-23T01:42:41Z</updated>
    <id>tag:github.com,2023-01-23:/Muirey03/CVE-2022-42864</id>
    <link href="https://github.com/Muirey03/CVE-2022-42864" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Proof-of-concept for the CVE-2022-42864 IOHIDFamily race condition&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CVE-2022-42864: Diabolical Cookies&lt;/h1&gt; &#xA;&lt;h2&gt;What is this repo?&lt;/h2&gt; &#xA;&lt;p&gt;This is my (incomplete) proof-of-concept exploit for CVE-2022-42864, a time-of-check-time-of-use vulnerability in IOHIDFamily that was fixed in iOS 16.2 / macOS Ventura 13.1.&lt;/p&gt; &#xA;&lt;h2&gt;What is the status of the proof-of-concept?&lt;/h2&gt; &#xA;&lt;p&gt;The exploit currently achieves the same &#34;arbitrary kfree&#34; primitive used in the multicast_bytecopy exploit. However, the subsequent exploit flow of multicast_bytecopy has been heavily mitigated against, so this is not a complete exploit, it merely demonstrates the severity of the issue.&lt;/p&gt; &#xA;&lt;h2&gt;Should I run this?&lt;/h2&gt; &#xA;&lt;p&gt;If you have to ask, no. This does not do anything useful, it just causes a kernel panic. I do not take responsibility for any data loss or instability this code may cause.&lt;/p&gt; &#xA;&lt;h2&gt;The bug&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/apple-oss-distributions/IOHIDFamily/raw/19666c840a6d896468416ff0007040a10b7b46b8/IOHIDFamily/IOHIDDevice.cpp#L1601&#34;&gt;Apple&#39;s comment&lt;/a&gt; from the source code when this issue was fixed sums this up nicely:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Find the number of cookies in the data. The data from elementData is shared with user space and may change at any time.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let us have a look at the function before the patch (I have tried to label relevant lines):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;IOReturn IOHIDDevice::postElementTransaction(const void* elementData, UInt32 dataSize, UInt32 completionTimeout, IOHIDCompletion * completion)&#xA;{&#xA;    IOReturn ret = kIOReturnError;&#xA;    uint32_t   cookies_[kMaxLocalCookieArrayLength];&#xA;    uint32_t   *cookies = cookies_;&#xA;    uint32_t   cookieCount = 0;&#xA;    uint32_t   cookieSize = 0;&#xA;    uint32_t   dataOffset = 0;&#xA;    uint8_t    *data = (uint8_t*)elementData;&#xA;    IOMemoryDescriptor *elementDesc = getMemoryWithCurrentElementValues();&#xA;    require(_elementArray &amp;amp;&amp;amp; elementDesc, fail);&#xA;&#xA;    WORKLOOP_LOCK;&#xA;&#xA;    // Find the number of cookies in the data. Check that all cookies are valid elements.                   [1]&#xA;    while (dataOffset &amp;lt; dataSize) {&#xA;        const IOHIDElementValueHeader *headerPtr = (const IOHIDElementValueHeader *)(data + dataOffset);&#xA;        IOHIDElementPrivate *element = GetElement(headerPtr-&amp;gt;cookie);&#xA;        if (!element) {&#xA;            HIDDeviceLogError(&#34;Could not find element for cookie: %d&#34;, headerPtr-&amp;gt;cookie);&#xA;            ret = kIOReturnAborted;&#xA;            goto fail;&#xA;        }&#xA;        cookieCount++;&#xA;&#xA;        require_noerr_action(os_add3_overflow(dataOffset, headerPtr-&amp;gt;length, sizeof(IOHIDElementValueHeader), &amp;amp;dataOffset), fail, HIDDeviceLogError(&#34;Overflow iterating cookie data buffer %u %u&#34;, dataOffset, headerPtr-&amp;gt;length));&#xA;    }&#xA;    // Data isn&#39;t as large as expected, don&#39;t overrun, just abort&#xA;    if (dataOffset != dataSize) {   //                                                                      [2]&#xA;        HIDDeviceLogError(&#34;Cookie data buffer is smaller than expected. %u vs. %u&#34;,&#xA;                        (unsigned int)dataSize, (unsigned int)dataOffset);&#xA;        ret = kIOReturnAborted;&#xA;        goto fail;&#xA;    }&#xA;    dataOffset = 0;&#xA;&#xA;    require_noerr_action(os_mul_overflow(cookieCount, sizeof(uint32_t), &amp;amp;cookieSize),&#xA;                        fail,&#xA;                        HIDDeviceLogError(&#34;Overflow calculating cookieSize&#34;));&#xA;&#xA;    cookies = (cookieCount &amp;lt;= kMaxLocalCookieArrayLength) ? cookies : (uint32_t*)IOMallocData(cookieSize); // [3]&#xA;&#xA;    if (cookies == NULL) {&#xA;        ret = kIOReturnNoMemory;&#xA;        goto fail;&#xA;    }&#xA;&#xA;    // Update the elements, this replaced the shared kernel-user shared memory.&#xA;    for (size_t index = 0; dataOffset &amp;lt; dataSize; ++index) {    //                                          [4]&#xA;        const IOHIDElementValueHeader *headerPtr;&#xA;        IOHIDElementPrivate *element;&#xA;        OSData *elementVal;&#xA;&#xA;        headerPtr = (const IOHIDElementValueHeader *)(data + dataOffset);&#xA;        element = GetElement(headerPtr-&amp;gt;cookie);&#xA;        dataOffset += headerPtr-&amp;gt;length + sizeof(IOHIDElementValueHeader);&#xA;&#xA;        elementVal = OSData::withBytesNoCopy((void*)headerPtr-&amp;gt;value,&#xA;                                            headerPtr-&amp;gt;length); //                                          [5]&#xA;        require_action(elementVal, fail, ret = kIOReturnNoMemory);&#xA;        element-&amp;gt;setDataBits(elementVal);&#xA;        elementVal-&amp;gt;release();&#xA;&#xA;        cookies[index] = headerPtr-&amp;gt;cookie; //                                                              [6]&#xA;    }&#xA;&#xA;    // Actually post elements&#xA;    ret = postElementValues((IOHIDElementCookie *)cookies, (UInt32)cookieCount, 0, completionTimeout, completion);&#xA;&#xA;fail:&#xA;    WORKLOOP_UNLOCK;&#xA;    if (cookies != &amp;amp;cookies_[0]) {&#xA;        IOFreeData(cookies, cookieSize);&#xA;    }&#xA;&#xA;    return ret;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The loop at &lt;code&gt;[1]&lt;/code&gt; counts the number of &lt;code&gt;IOHIDElementValue&lt;/code&gt;s in the buffer, and stores this count in &lt;code&gt;cookieCount&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The check at &lt;code&gt;[2]&lt;/code&gt; (combined with the condition of the while loop) will make sure that the &lt;code&gt;length&lt;/code&gt; field of each header does not extend out of the bounds of the &lt;code&gt;elementData&lt;/code&gt; buffer (nor can it fall short of the end of the buffer, although this is less relevant).&lt;/li&gt; &#xA; &lt;li&gt;Once all the elements have been counted and sanity-checked by this loop, a &lt;code&gt;cookies&lt;/code&gt; buffer is allocated to the heap at &lt;code&gt;[3]&lt;/code&gt; with a size of &lt;code&gt;cookieCount * 4&lt;/code&gt; (or a stack buffer is used if &lt;code&gt;cookieCount&lt;/code&gt; is sufficiently small).&lt;/li&gt; &#xA; &lt;li&gt;A second loop at &lt;code&gt;[4]&lt;/code&gt; then makes a second pass through the buffer, parsing the &lt;code&gt;IOHIDElementValue&lt;/code&gt;s again.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OSData&lt;/code&gt; objects are created to hold each element&#39;s value at &lt;code&gt;[5]&lt;/code&gt;, using the &lt;code&gt;length&lt;/code&gt; field that was validated in the first loop.&lt;/li&gt; &#xA; &lt;li&gt;At &lt;code&gt;[6]&lt;/code&gt;, each element&#39;s &lt;code&gt;cookie&lt;/code&gt; is written into the &lt;code&gt;cookies&lt;/code&gt; array allocated at &lt;code&gt;[3]&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So what&#39;s the issue? This function behaves entirely correctly when &lt;code&gt;elementData&lt;/code&gt; is non-volatile, the issue comes when the method is called with shared memory. Enter the &lt;code&gt;IOHIDInterface::SetElementValues_Impl&lt;/code&gt; DriverKit method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;kern_return_t&#xA;IMPL(IOHIDInterface, SetElementValues)&#xA;{&#xA;    IOReturn ret = kIOReturnError;&#xA;    UInt8 *values = NULL;&#xA;    IOBufferMemoryDescriptor *md = NULL;&#xA;    &#xA;    md = OSDynamicCast(IOBufferMemoryDescriptor, elementValues);&#xA;    require_action(md &amp;amp;&amp;amp; count, exit, ret = kIOReturnBadArgument);&#xA;&#xA;    values = (UInt8 *)md-&amp;gt;getBytesNoCopy();&#xA;    &#xA;    // Post the data to the device&#xA;    ret = _owner-&amp;gt;postElementTransaction(values, (UInt32)md-&amp;gt;getLength());&#xA;    require_noerr_action(ret, exit, HIDServiceLogError(&#34;postElementValues failed: 0x%x&#34;, ret));&#xA;&#xA;exit:&#xA;    return ret;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, &lt;code&gt;postElementTransaction&lt;/code&gt; is called with &lt;code&gt;md-&amp;gt;getBytesNoCopy()&lt;/code&gt;, memory shared with userspace, violating the assumption that &lt;code&gt;elementData&lt;/code&gt; is non-volatile. The content of the &lt;code&gt;elementData&lt;/code&gt; buffer can change after the loop at &lt;code&gt;[1]&lt;/code&gt;, but before the loop at &lt;code&gt;[4]&lt;/code&gt;, so what does this mean for an attacker?&lt;/p&gt; &#xA;&lt;p&gt;There are two ways an attacker can abuse this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first is to swap the &lt;code&gt;length&lt;/code&gt; of a small &lt;code&gt;IOHIDElementValueHeader&lt;/code&gt; at the end of the buffer to a much larger value. This means that when the &lt;code&gt;OSData&lt;/code&gt; at &lt;code&gt;[5]&lt;/code&gt; is created, it will extend far outside the bounds of the &lt;code&gt;elementData&lt;/code&gt; buffer, allowing an attacker to read out-of-bounds data using &lt;code&gt;IOHIDInterface::GetElementValues_Impl&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The second is to swap the &lt;code&gt;length&lt;/code&gt; of a large &lt;code&gt;IOHIDElementValueHeader&lt;/code&gt; at the beginning of the buffer to a much smaller value. This will make the loop at &lt;code&gt;[4]&lt;/code&gt; parse many more headers than were originally counted in the loop at &lt;code&gt;[1]&lt;/code&gt;, so when cookies are written to the &lt;code&gt;cookies&lt;/code&gt; array at &lt;code&gt;[6]&lt;/code&gt;, they will overflow out of the array as &lt;code&gt;index&lt;/code&gt; is never validated against &lt;code&gt;cookieCount&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In practice, this allows an attacker to read out-of-bounds kernel heap data of an arbitrary size, and to write arbitrary data (again of an arbitrary size) out-of-bounds to the kernel heap. These are two powerful primitives.&lt;/p&gt; &#xA;&lt;h2&gt;Winning the race&lt;/h2&gt; &#xA;&lt;p&gt;With race conditions, we always look for ways to determine whether the race was won successfully, that way we can keep trying until we succeed, making our trigger deterministic. Luckily in the case of this race condition, we can do exactly that.&lt;/p&gt; &#xA;&lt;p&gt;For the OOB read variant, I place one more &lt;code&gt;IOHIDElementValueHeader&lt;/code&gt; after the header that I&#39;m switching the &lt;code&gt;length&lt;/code&gt; of, with its &lt;code&gt;value&lt;/code&gt; set to the recognisable constant of &lt;code&gt;0xD1AB011CAC1DF00D&lt;/code&gt;. Then, when reading the value of the element back, I know I have won the race if I see the familiar &lt;code&gt;0xD1AB011CAC1DF00D&lt;/code&gt; header at the start of the returned data.&lt;/p&gt; &#xA;&lt;p&gt;For the OOB write variant, I place one &lt;code&gt;IOHIDElementValueHeader&lt;/code&gt; after the header that I&#39;m switching the &lt;code&gt;length&lt;/code&gt; of, but before the headers whose &lt;code&gt;cookie&lt;/code&gt;s will be overflowed, this time with the recognisable &lt;code&gt;value&lt;/code&gt; of &lt;code&gt;0xD15EA5ED&lt;/code&gt;. This header will be encapsulated inside the &lt;code&gt;value&lt;/code&gt; of the larger element in the case where we do not win the race, so the header will only be parsed and the element&#39;s value be set to &lt;code&gt;0xD15EA5ED&lt;/code&gt; if we win the race. By reading back the element&#39;s value, I know whether I was successful.&lt;/p&gt; &#xA;&lt;h2&gt;Apple&#39;s fix&lt;/h2&gt; &#xA;&lt;p&gt;To fix the issue, Apple chose to add a third loop in between loop &lt;code&gt;[1]&lt;/code&gt; and loop &lt;code&gt;[4]&lt;/code&gt;, validating each &lt;code&gt;length&lt;/code&gt; field, and then caching it in a new &lt;code&gt;dataLengths&lt;/code&gt; array, while ensuring the number of elements had not changed. The final loop then uses the cached lengths for its calculations, avoiding reading from the buffer another time.&lt;/p&gt; &#xA;&lt;h2&gt;Issues with exploitation&lt;/h2&gt; &#xA;&lt;p&gt;The main obstacle to overcome when exploiting this issue is that the buffer we are overflowing out of belongs to &lt;code&gt;KHEAP_DATA_BUFFERS&lt;/code&gt;, so exploitation targets are limited. In this proof-of-concept I chose to target kmsg headers, as these are one of very few structures in &lt;code&gt;KHEAP_DATA_BUFFERS&lt;/code&gt; that contain kernel pointers. The &#34;arbitrary kfree&#34; primitive I obtained using this approach is the same primitive used in the &lt;a href=&#34;https://github.com/potmdehex/multicast_bytecopy&#34;&gt;multicast_bytecopy&lt;/a&gt; exploit, however the &lt;code&gt;IOSurfaceClient&lt;/code&gt; array is now PAC&#39;d and forged clients need to have a valid pointer back to the &lt;code&gt;IOSurfaceRootUserClient&lt;/code&gt; that created them, rendering this no longer a desirable kernel r/w target.&lt;/p&gt; &#xA;&lt;h2&gt;Building and installing&lt;/h2&gt; &#xA;&lt;p&gt;Apple have not made building and installing custom DriverKit extensions very easy, especially without a paid Apple Developer account, but it is possible.&lt;/p&gt; &#xA;&lt;p&gt;Before you start, I recommend:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disabling SIP&lt;/li&gt; &#xA; &lt;li&gt;Setting the boot-args &lt;code&gt;amfi_get_out_of_my_way=1 cs_enforcement_disable=1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Running &lt;code&gt;systemextensionsctl developer on&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Restarting your computer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After that, you should be able to select your developer team in the Xcode project settings and the project will build successfully. You can the run HIDDriverLoader, use &#34;Install Dext&#34; to install the DriverKit extension and &#34;Trigger Exploit&#34; to, you guessed it, trigger the exploit.&lt;/p&gt; &#xA;&lt;p&gt;If this fails, you can also try building without signing using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;xcodebuild build CODE_SIGN_IDENTITY=&#34;&#34; CODE_SIGNING_REQUIRED=NO&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then manually signing using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;codesign -fs self-sign-cert --entitlements HIDDriverLoader/HIDDriverLoader.entitlements build/Release/HIDDriverLoader.app/Contents/MacOS/HIDDriverLoader&#xA;codesign -fs self-sign-cert --entitlements HIDDriver/HIDDriver.entitlements build/Release/HIDDriverLoader.app/Contents/Library/SystemExtensions/*.dext/*.driver&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replacing &lt;code&gt;self-sign-cert&lt;/code&gt; with the name of a &lt;a href=&#34;https://support.apple.com/en-gb/guide/keychain-access/kyca8916/mac&#34;&gt;self-signed certificate&lt;/a&gt; in your keychain.&lt;/p&gt; &#xA;&lt;h3&gt;Thank you for reading :)&lt;/h3&gt;</summary>
  </entry>
  <entry>
    <title>freshworks/freshchat-ios</title>
    <updated>2023-01-23T01:42:41Z</updated>
    <id>tag:github.com,2023-01-23:/freshworks/freshchat-ios</id>
    <link href="https://github.com/freshworks/freshchat-ios" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Freshchat iOS SDK&lt;/h1&gt; &#xA;&lt;p&gt;&#34;Modern messaging software that your sales and customer engagement teams will love.&#34; &lt;a href=&#34;http://www.freshchat.com&#34;&gt;Freshchat&lt;/a&gt; by &lt;a href=&#34;https://www.freshworks.com&#34;&gt;Freshworks&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Freshchat iOS SDK can be integrated using cocoapods by specifying the following in your podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39;&#xA;platform :ios, &#39;8.0&#39;&#xA;&#xA;target &#39;Your project target&#39; do&#xA;pod &#39;FreshchatSDK&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Samples&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/freshdesk/freshchat-ios/tree/master/Sample/ObjectiveCSample&#34;&gt;Objective-C&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/freshdesk/freshchat-ios/tree/master/Sample/SwiftSample&#34;&gt;Swift&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://support.freshchat.com/support/solutions/articles/50000000048-freshchat-ios-sdk-integration-steps&#34;&gt;Integration Guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://cocoadocs.org/docsets/FreshchatSDK&#34;&gt;API docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;FreshchatSDK is released under the Commercial license. See &lt;a href=&#34;https://github.com/freshdesk/freshchat-ios/raw/master/FreshchatSDK/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;mailto:support@freshchat.com&#34;&gt;support@freshchat.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://support.freshchat.com&#34;&gt;Support Portal&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>apptentive/apptentive-ios</title>
    <updated>2023-01-23T01:42:41Z</updated>
    <id>tag:github.com,2023-01-23:/apptentive/apptentive-ios</id>
    <link href="https://github.com/apptentive/apptentive-ios" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Apptentive Legacy SDK for iOS. See https://github.com/apptentive/apptentive-kit-ios for Version 6.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apptentive iOS SDK&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note: This repository hosts Versions 5.3.4 and earlier. Version 6.0 is now available at &lt;a href=&#34;https://github.com/apptentive/apptentive-kit-ios&#34;&gt;https://github.com/apptentive/apptentive-kit-ios&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Apptentive iOS SDK provides a simple and powerful channel to communicate in-app with your customers.&lt;/p&gt; &#xA;&lt;p&gt;Use Apptentive features to improve your app&#39;s App Store ratings, collect and respond to customer feedback, show surveys at specific points within your app, and more.&lt;/p&gt; &#xA;&lt;p&gt;See our &lt;a href=&#34;https://learn.apptentive.com/knowledge-base/ios-quick-start/&#34;&gt;Quick Start Guide&lt;/a&gt; to get up and running as quickly as possible.&lt;/p&gt; &#xA;&lt;p&gt;For complete information on installing and using Apptentive, please see our &lt;a href=&#34;https://learn.apptentive.com/knowledge-base/ios-integration-reference/&#34;&gt;iOS integration reference&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Apptentive can be installed using CocoaPods or Carthage, or manually as an Xcode subproject.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.apptentive.com/knowledge-base/ios-integration-reference/#cocoapods&#34;&gt;CocoaPods installation guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.apptentive.com/knowledge-base/ios-integration-reference/#carthage&#34;&gt;Carthage installation guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.apptentive.com/knowledge-base/ios-integration-reference/#subproject&#34;&gt;Xcode project setup guide&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Using Apptentive in your App&lt;/h2&gt; &#xA;&lt;p&gt;To begin, you will have to &lt;a href=&#34;https://learn.apptentive.com/knowledge-base/ios-integration-reference/#initialize-apptentive&#34;&gt;initialize the Apptentive SDK&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;@import Apptentive;&#xA;...&#xA;ApptentiveConfiguration = [ApptentiveConfiguration configurationWithApptentiveKey:@&#34;&amp;lt;#Your Apptentive App Key#&amp;gt;&#34; apptentiveSignature:@&#34;&amp;lt;#Your Apptentive App Signature#&amp;gt;&#34;];&#xA;[Apptentive registerWithConfiguration:configuration];&#xA;...&#xA;[Apptentive.shared engage:@&#34;event_name&#34;, from: viewController];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, in Swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;import Apptentive&#xA;...&#xA;if let configuration = ApptentiveConfiguration(apptentiveKey: &#34;&amp;lt;#Your Apptentive App Key#&amp;gt;&#34;, apptentiveSignature: &#34;&amp;lt;#Your Apptentive App Signature#&amp;gt;&#34;) {&#xA;&#x9;Apptentive.register(with: configuration)&#xA;}&#xA;...&#xA;Apptentive.shared.engage(event: &#34;event_name&#34;, from: viewController)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Later, on your Apptentive dashboard, you will target these events with Apptentive features such as Message Center, Ratings Prompts, and Surveys.&lt;/p&gt; &#xA;&lt;h2&gt;API Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Please see our Customer Learning Center for the Apptentive iOS SDK&#39;s &lt;a href=&#34;https://learn.apptentive.com/knowledge-base/ios-sdk-api/&#34;&gt;API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Apptentive&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/apptentive/apptentive-ios/master/docs/APIChanges.md&#34;&gt;API changelog&lt;/a&gt; is also updated with each release of the SDK.&lt;/p&gt; &#xA;&lt;h2&gt;Testing Apptentive Features&lt;/h2&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://learn.apptentive.com/knowledge-base/testing-your-apptentive-integration-ios/&#34;&gt;Apptentive testing guide&lt;/a&gt; for directions on how to test that the Rating Prompt, Surveys, and other Apptentive features have been configured correctly.&lt;/p&gt; &#xA;&lt;h1&gt;Apptentive Example App&lt;/h1&gt; &#xA;&lt;p&gt;To see an example of how the Apptentive iOS SDK can be integrated with your app, take a look at the &lt;code&gt;iOSExample&lt;/code&gt; app in the &lt;code&gt;Example&lt;/code&gt; directory in this repository.&lt;/p&gt; &#xA;&lt;p&gt;The example app shows you how to integrate using CocoaPods, set your Apptentive App Key and Apptentive App Signature, engage events, and integrate with Message Center. See the &lt;code&gt;README.md&lt;/code&gt; file in the &lt;code&gt;Example&lt;/code&gt; directory for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Our client code is completely &lt;a href=&#34;https://raw.githubusercontent.com/apptentive/apptentive-ios/master/LICENSE.txt&#34;&gt;open source&lt;/a&gt;, and we welcome contributions to the Apptentive SDK! If you have an improvement or bug fix, please first read our &lt;a href=&#34;https://raw.githubusercontent.com/apptentive/apptentive-ios/master/CONTRIBUTING.md&#34;&gt;contribution agreement&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Reporting Issues&lt;/h2&gt; &#xA;&lt;p&gt;If you experience an issue with the Apptentive SDK, please &lt;a href=&#34;https://github.com/apptentive/apptentive-ios/issues?direction=desc&amp;amp;sort=created&amp;amp;state=open&#34;&gt;open a GitHub issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If the request is urgent, please contact &lt;a href=&#34;mailto:support@apptentive.com&#34;&gt;mailto:support@apptentive.com&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>