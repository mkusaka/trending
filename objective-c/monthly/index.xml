<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-01T01:53:41Z</updated>
  <subtitle>Monthly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ibireme/YYKit</title>
    <updated>2024-08-01T01:53:41Z</updated>
    <id>tag:github.com,2024-08-01:/ibireme/YYKit</id>
    <link href="https://github.com/ibireme/YYKit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A collection of iOS components.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;YYKit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ibireme/YYKit/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-green.svg?style=flat&#34; alt=&#34;License MIT&#34;&gt;&lt;/a&gt;&amp;nbsp; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt;&amp;nbsp; &lt;a href=&#34;http://cocoapods.org/pods/YYKit&#34;&gt;&lt;img src=&#34;http://img.shields.io/cocoapods/v/YYKit.svg?style=flat&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt;&amp;nbsp; &lt;a href=&#34;http://cocoadocs.org/docsets/YYKit&#34;&gt;&lt;img src=&#34;http://img.shields.io/cocoapods/p/YYKit.svg?style=flat&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt;&amp;nbsp; &lt;a href=&#34;https://www.apple.com/nl/ios/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/support-iOS%206%2B%20-blue.svg?style=flat&#34; alt=&#34;Support&#34;&gt;&lt;/a&gt;&amp;nbsp; &lt;a href=&#34;https://travis-ci.org/ibireme/YYKit&#34;&gt;&lt;img src=&#34;https://travis-ci.org/ibireme/YYKit.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;YYKit is a collection of iOS components.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s so huge that I split it into several independent components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYModel&#34;&gt;YYModel&lt;/a&gt; — High performance model framework for iOS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYCache&#34;&gt;YYCache&lt;/a&gt; — High performance cache framework for iOS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYImage&#34;&gt;YYImage&lt;/a&gt; — Image framework for iOS to display/encode/decode animated WebP, APNG, GIF.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYWebImage&#34;&gt;YYWebImage&lt;/a&gt; — Asynchronous image loading framework.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYText&#34;&gt;YYText&lt;/a&gt; — Powerful rich text component for iOS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYKeyboardManager&#34;&gt;YYKeyboardManager&lt;/a&gt; — Access keyboard view and track keyboard animation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYDispatchQueuePool&#34;&gt;YYDispatchQueuePool&lt;/a&gt; — iOS utility class to manage global dispatch queue.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYAsyncLayer&#34;&gt;YYAsyncLayer&lt;/a&gt; — iOS utility classes for asynchronous rendering and display.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYCategories&#34;&gt;YYCategories&lt;/a&gt; — A set of useful categories for Foundation and UIKit.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Demo Project&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;code&gt;Demo/YYKitDemo.xcodeproj&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/twitter.png&#34; width=&#34;320&#34;&gt;&lt;br&gt; &lt;img src=&#34;https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo.png&#34; width=&#34;320&#34;&gt; &lt;img src=&#34;https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo_compose.png&#34; width=&#34;320&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add &lt;code&gt;pod &#39;YYKit&#39;&lt;/code&gt; to your Podfile.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;pod install&lt;/code&gt; or &lt;code&gt;pod update&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Import &amp;lt;YYKit/YYKit.h&amp;gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add &lt;code&gt;github &#34;ibireme/YYKit&#34;&lt;/code&gt; to your Cartfile.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;carthage update --platform ios&lt;/code&gt; and add the framework to your project.&lt;/li&gt; &#xA; &lt;li&gt;Import &amp;lt;YYKit/YYKit.h&amp;gt;.&lt;/li&gt; &#xA; &lt;li&gt;Notice: carthage framework doesn&#39;t include webp component, if you want to support webp, use CocoaPods or install manually.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download all the files in the &lt;code&gt;YYKit&lt;/code&gt; subdirectory.&lt;/li&gt; &#xA; &lt;li&gt;Add the source files to your Xcode project.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;-fno-objc-arc&lt;/code&gt; compiler flag to &lt;code&gt;NSObject+YYAddForARC.m&lt;/code&gt; and &lt;code&gt;NSThread+YYAdd.m&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Link with required frameworks: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UIKit&lt;/li&gt; &#xA;   &lt;li&gt;CoreFoundation&lt;/li&gt; &#xA;   &lt;li&gt;CoreText&lt;/li&gt; &#xA;   &lt;li&gt;CoreGraphics&lt;/li&gt; &#xA;   &lt;li&gt;CoreImage&lt;/li&gt; &#xA;   &lt;li&gt;QuartzCore&lt;/li&gt; &#xA;   &lt;li&gt;ImageIO&lt;/li&gt; &#xA;   &lt;li&gt;AssetsLibrary&lt;/li&gt; &#xA;   &lt;li&gt;Accelerate&lt;/li&gt; &#xA;   &lt;li&gt;MobileCoreServices&lt;/li&gt; &#xA;   &lt;li&gt;SystemConfiguration&lt;/li&gt; &#xA;   &lt;li&gt;sqlite3&lt;/li&gt; &#xA;   &lt;li&gt;libz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;Vendor/WebP.framework&lt;/code&gt;(static library) to your Xcode project if you want to support WebP.&lt;/li&gt; &#xA; &lt;li&gt;Import &lt;code&gt;YYKit.h&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;Full API documentation is available on &lt;a href=&#34;http://cocoadocs.org/docsets/YYKit/&#34;&gt;CocoaDocs&lt;/a&gt;.&lt;br&gt; You can also install documentation locally using &lt;a href=&#34;https://github.com/tomaz/appledoc&#34;&gt;appledoc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;p&gt;This library requires &lt;code&gt;iOS 6.0+&lt;/code&gt; and &lt;code&gt;Xcode 8.0+&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Notice&lt;/h1&gt; &#xA;&lt;p&gt;I want to use the APIs as if it was provided by system, and I don&#39;t add prefix in these categories. I do not recommend using the &lt;code&gt;YYKit&lt;/code&gt; directly, you should try the separated components first.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;YYKit is provided under the MIT license. See LICENSE file for details.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt; &#xA;&lt;h1&gt;中文介绍&lt;/h1&gt; &#xA;&lt;p&gt;YYKit 是一组功能丰富的 iOS 组件。&lt;/p&gt; &#xA;&lt;p&gt;为了尽量复用代码，这个项目中的某些组件之间有比较强的依赖关系。为了方便其他开发者使用，我从中拆分出以下独立组件：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYModel&#34;&gt;YYModel&lt;/a&gt; — 高性能的 iOS JSON 模型框架。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYCache&#34;&gt;YYCache&lt;/a&gt; — 高性能的 iOS 缓存框架。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYImage&#34;&gt;YYImage&lt;/a&gt; — 功能强大的 iOS 图像框架。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYWebImage&#34;&gt;YYWebImage&lt;/a&gt; — 高性能的 iOS 异步图像加载框架。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYText&#34;&gt;YYText&lt;/a&gt; — 功能强大的 iOS 富文本框架。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYKeyboardManager&#34;&gt;YYKeyboardManager&lt;/a&gt; — iOS 键盘监听管理工具。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYDispatchQueuePool&#34;&gt;YYDispatchQueuePool&lt;/a&gt; — iOS 全局并发队列管理工具。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYAsyncLayer&#34;&gt;YYAsyncLayer&lt;/a&gt; — iOS 异步绘制与显示的工具。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ibireme/YYCategories&#34;&gt;YYCategories&lt;/a&gt; — 功能丰富的 Category 类型工具库。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;演示项目&lt;/h1&gt; &#xA;&lt;p&gt;查看并运行 &lt;code&gt;Demo/YYKitDemo.xcodeproj&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/twitter.png&#34; width=&#34;320&#34;&gt;&lt;br&gt; &lt;img src=&#34;https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo.png&#34; width=&#34;320&#34;&gt; &lt;img src=&#34;https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo_compose.png&#34; width=&#34;320&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;安装&lt;/h1&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;在 Podfile 中添加 &lt;code&gt;pod &#39;YYKit&#39;&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;执行 &lt;code&gt;pod install&lt;/code&gt; 或 &lt;code&gt;pod update&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;导入 &amp;lt;YYKit/YYKit.h&amp;gt;。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;在 Cartfile 中添加 &lt;code&gt;github &#34;ibireme/YYKit&#34;&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;执行 &lt;code&gt;carthage update --platform ios&lt;/code&gt; 并将生成的 framework 添加到你的工程。&lt;/li&gt; &#xA; &lt;li&gt;导入 &amp;lt;YYKit/YYKit.h&amp;gt;。&lt;/li&gt; &#xA; &lt;li&gt;注意: carthage framework 并没有包含 webp 组件。如果你需要支持 webp，可以用 CocoaPods 安装，或者手动安装。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;手动安装&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;下载 YYKit 文件夹内的所有内容。&lt;/li&gt; &#xA; &lt;li&gt;将 YYKit 内的源文件添加(拖放)到你的工程。&lt;/li&gt; &#xA; &lt;li&gt;为 &lt;code&gt;NSObject+YYAddForARC.m&lt;/code&gt; 和 &lt;code&gt;NSThread+YYAdd.m&lt;/code&gt; 添加编译参数 &lt;code&gt;-fno-objc-arc&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;链接以下 frameworks: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UIKit&lt;/li&gt; &#xA;   &lt;li&gt;CoreFoundation&lt;/li&gt; &#xA;   &lt;li&gt;CoreText&lt;/li&gt; &#xA;   &lt;li&gt;CoreGraphics&lt;/li&gt; &#xA;   &lt;li&gt;CoreImage&lt;/li&gt; &#xA;   &lt;li&gt;QuartzCore&lt;/li&gt; &#xA;   &lt;li&gt;ImageIO&lt;/li&gt; &#xA;   &lt;li&gt;AssetsLibrary&lt;/li&gt; &#xA;   &lt;li&gt;Accelerate&lt;/li&gt; &#xA;   &lt;li&gt;MobileCoreServices&lt;/li&gt; &#xA;   &lt;li&gt;SystemConfiguration&lt;/li&gt; &#xA;   &lt;li&gt;sqlite3&lt;/li&gt; &#xA;   &lt;li&gt;libz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;如果你需要支持 WebP，可以将 &lt;code&gt;Vendor/WebP.framework&lt;/code&gt;(静态库) 加入你的工程。&lt;/li&gt; &#xA; &lt;li&gt;导入 &lt;code&gt;YYKit.h&lt;/code&gt;。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;文档&lt;/h1&gt; &#xA;&lt;p&gt;你可以在 &lt;a href=&#34;http://cocoadocs.org/docsets/YYKit/&#34;&gt;CocoaDocs&lt;/a&gt; 查看在线 API 文档，也可以用 &lt;a href=&#34;https://github.com/tomaz/appledoc&#34;&gt;appledoc&lt;/a&gt; 本地生成文档。&lt;/p&gt; &#xA;&lt;h1&gt;系统要求&lt;/h1&gt; &#xA;&lt;p&gt;该项目最低支持 &lt;code&gt;iOS 6.0&lt;/code&gt; 和 &lt;code&gt;Xcode 8.0&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;h1&gt;注意&lt;/h1&gt; &#xA;&lt;p&gt;我希望调用 API 时，有着和调用系统自带 API 一样的体验，所以我并没有为 Category 方法添加前缀。我已经用工具扫描过这个项目中的 API，确保没有对系统 API 产生影响，但即使这样没有前缀的 Category 也可能会带来其他麻烦。因此我不太推荐直接使用 &lt;code&gt;YYKit&lt;/code&gt; 这个库，你应该先尝试一下上面那些拆分出来的独立组件。&lt;/p&gt; &#xA;&lt;h1&gt;许可证&lt;/h1&gt; &#xA;&lt;p&gt;YYKit 使用 MIT 许可证，详情见 LICENSE 文件。&lt;/p&gt; &#xA;&lt;h1&gt;相关文章&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/&#34;&gt;iOS 保持界面流畅的技巧 &lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>BranchMetrics/ios-branch-deep-linking-attribution</title>
    <updated>2024-08-01T01:53:41Z</updated>
    <id>tag:github.com,2024-08-01:/BranchMetrics/ios-branch-deep-linking-attribution</id>
    <link href="https://github.com/BranchMetrics/ios-branch-deep-linking-attribution" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Branch iOS SDK for deep linking and attribution. Branch helps mobile apps grow with deep links / deeplinks that power paid acquisition and re-engagement campaigns, referral programs, content sharing, deep linked emails, smart banners, custom user onboarding, and more.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Branch SDK Documentation for iOS&lt;/h1&gt; &#xA;&lt;p&gt;The Branch iOS SDK for deep linking and attribution.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h2&gt;Branch Sandbox Program&lt;/h2&gt; &#xA; &lt;p&gt;As part of this &lt;a href=&#34;https://help.branch.io/developers-hub/docs/branch-sandbox-program&#34;&gt;sandbox program&lt;/a&gt;, you will be able to partner directly with Branch’s Product and Engineering team for exclusive access to test drive our innovative products before the market and proactively exchange valuable feedback. With your support, we will create the winning measurement and linking solutions of the future together.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;If you would like to join, please reach out to us today at &lt;a href=&#34;mailto:sandbox@branch.io&#34; title=&#34;mailto:sandbox@branch.io&#34;&gt;sandbox@branch.io&lt;/a&gt; or by filling out this &lt;a href=&#34;https://branch.link/sandbox?~channel=ios-repo&#34;&gt;form&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Branch helps mobile apps grow with deep links / deeplinks that power paid acquisition and re-engagement campaigns, referral programs, content sharing, deep linked emails, smart banners, custom user onboarding, and more.&lt;/p&gt; &#xA;&lt;p&gt;View &lt;a href=&#34;https://help.branch.io/developers-hub/docs/ios-sdk-overview&#34;&gt;Branch&#39;s SDK documentation for iOS&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>microsoft/plcrashreporter</title>
    <updated>2024-08-01T01:53:41Z</updated>
    <id>tag:github.com,2024-08-01:/microsoft/plcrashreporter</id>
    <link href="https://github.com/microsoft/plcrashreporter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Reliable, open-source crash reporting for iOS, macOS and tvOS&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://cocoapods.org/pods/PLCrashReporter&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/PLCrashReporter.svg?sanitize=true&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?sanitize=true&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SwiftPM-compatible-brightgreen.svg?sanitize=true&#34; alt=&#34;SwiftPM compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;PLCrashReporter&lt;/h1&gt; &#xA;&lt;p&gt;PLCrashReporter is a reliable open source library that provides an in-process live crash reporting framework for use on iOS, macOS and tvOS. The library detects crashes and generates reports to help your investigation and troubleshooting with the information of application, system, process, thread, etc. as well as stack traces.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to use PLCrashReporter is by using &lt;a href=&#34;https://appcenter.ms&#34;&gt;AppCenter&lt;/a&gt;. However, if you want to use PLCrashReporter directly, grab the latest release at &lt;a href=&#34;https://github.com/microsoft/plcrashreporter/releases&#34;&gt;releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Uses only supported and public APIs/ABIs for crash reporting.&lt;/li&gt; &#xA; &lt;li&gt;The most accurate stack unwinding available, using DWARF and Apple Compact Unwind frame data.&lt;/li&gt; &#xA; &lt;li&gt;First released in 2008, and used in hundreds of thousands of apps. PLCrashReporter has seen a tremendous amount of user testing.&lt;/li&gt; &#xA; &lt;li&gt;Does not interfere with debugging in lldb/gdb&lt;/li&gt; &#xA; &lt;li&gt;Backtraces for all active threads are provided.&lt;/li&gt; &#xA; &lt;li&gt;Provides full register state for the crashed thread.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Xcode 11 or above.&lt;/li&gt; &#xA; &lt;li&gt;Minimum supported platforms: iOS 11, macOS 10.9, tvOS 11, Mac Catalyst 13.0.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Decoding Crash Reports&lt;/h2&gt; &#xA;&lt;p&gt;Crash reports are output as protobuf-encoded messages, and may be decoded using the CrashReporter library or any &lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34;&gt;Google Protocol Buffers&lt;/a&gt; decoder.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the in-library decoding support, you may use the included &lt;code&gt;plcrashutil&lt;/code&gt; binary to convert crash reports to apple&#39;s standard iPhone text format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;plcrashutil convert --format=iphone example_report.plcrash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;atos&lt;/code&gt; command-line tool to symbolicate the output. For more information about this tool, see &lt;a href=&#34;https://developer.apple.com/documentation/Xcode/adding-identifiable-symbol-names-to-a-crash-report&#34;&gt;Adding Identifiable Symbol Names to a Crash Report&lt;/a&gt;. Future library releases may include built-in re-usable formatters, for outputting alternative formats directly from the phone.&lt;/p&gt; &#xA;&lt;h2&gt;Adding PLCrashReporter to your project&lt;/h2&gt; &#xA;&lt;p&gt;PLCrashReporter can be added to your app via &lt;a href=&#34;https://guides.cocoapods.org/using/using-cocoapods.html&#34;&gt;CocoaPods&lt;/a&gt;, &lt;a href=&#34;https://github.com/Carthage/Carthage#quick-start&#34;&gt;Carthage&lt;/a&gt;, &lt;a href=&#34;https://developer.apple.com/documentation/xcode/adding_package_dependencies_to_your_app&#34;&gt;Swift Package Manager&lt;/a&gt;, or by manually adding the binaries to your project.&lt;/p&gt; &#xA;&lt;h3&gt;Integration via Cocoapods&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the following line to your &lt;code&gt;Podfile&lt;/code&gt;: &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;PLCrashReporter&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;pod install&lt;/code&gt; to install your newly defined pod and open the project&#39;s &lt;code&gt;.xcworkspace&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Integration via Swift Package Manager&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;From the Xcode menu, click &lt;strong&gt;File&lt;/strong&gt; &amp;gt; &lt;strong&gt;Swift Packages&lt;/strong&gt; &amp;gt; &lt;strong&gt;Add Package Dependency&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;In the dialog that appears, enter the repository URL: &lt;a href=&#34;https://github.com/microsoft/plcrashreporter.git&#34;&gt;https://github.com/microsoft/plcrashreporter.git&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;In Version, select &lt;strong&gt;Up to Next Major&lt;/strong&gt; and take the default option.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Integration via Carthage&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the following line to your &lt;code&gt;Cartfile&lt;/code&gt;: &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;github &#34;microsoft/plcrashreporter&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;carthage update --use-xcframeworks&lt;/code&gt; to fetch dependencies.&lt;/li&gt; &#xA; &lt;li&gt;In Xcode, open your application target&#39;s &lt;strong&gt;General&lt;/strong&gt; settings tab. Drag and drop &lt;strong&gt;CrashReporter.xcframework&lt;/strong&gt; from the &lt;strong&gt;Carthage/Build&lt;/strong&gt; folder into the &lt;code&gt;Frameworks, Libraries and Embedded Content&lt;/code&gt; section. For iOS and tvOS, set &lt;code&gt;Embed&lt;/code&gt; to &lt;code&gt;Do not embed&lt;/code&gt;. For macoS, set &lt;code&gt;Embed&lt;/code&gt; to &lt;code&gt;Embed and Sign&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Carthage integration doesn&#39;t build the dependency correctly in Xcode 12 with flag &#34;--no-use-binaries&#34; or from a specific branch. To make it work, refer to &lt;a href=&#34;https://github.com/Carthage/Carthage/raw/master/Documentation/Xcode12Workaround.md&#34;&gt;this instruction&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Integration by copying the binaries into your project&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the &lt;a href=&#34;https://github.com/Microsoft/plcrashreporter/releases&#34;&gt;PLCrashReporter&lt;/a&gt; frameworks provided as a zip file.&lt;/li&gt; &#xA; &lt;li&gt;Unzip the file and you&#39;ll see a folder called &lt;strong&gt;PLCrashReporter&lt;/strong&gt; that contains subfolders for all supported platforms.&lt;/li&gt; &#xA; &lt;li&gt;Add PLCrashReporter to the project in Xcode: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Make sure the Project Navigator is visible (⌘+1).&lt;/li&gt; &#xA;   &lt;li&gt;Now drag &amp;amp; drop &lt;strong&gt;PLCrashReporter.framework&lt;/strong&gt; (or &lt;strong&gt;PLCrashReporter.xcframework&lt;/strong&gt;) from the Finder into Xcode&#39;s Project Navigator.&lt;/li&gt; &#xA;   &lt;li&gt;A dialog will appear, make sure your app target is checked and click &lt;strong&gt;Finish&lt;/strong&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; PLCrashReporter xcframework contains static binaries for iOS and tvOS, and dynamic binaries for macOS. When adding the framework to your project make sure that in &lt;code&gt;Frameworks, Libraries and Embedded Content&lt;/code&gt; section &lt;code&gt;Embed&lt;/code&gt; is selected to &lt;code&gt;Do not embed&lt;/code&gt; for iOS and tvOS and &lt;code&gt;Embed and Sign&lt;/code&gt; for macOS. &lt;code&gt;PLCrashReporter-Static-{version}.zip&lt;/code&gt; is an exception - it contains static frameworks for all platforms.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;The following example shows a way how to initialize crash reporter. Please note that enabling in-process crash reporting will conflict with any attached debuggers so make sure the &lt;strong&gt;debugger isn&#39;t attached&lt;/strong&gt; when you crash the app.&lt;/p&gt; &#xA;&lt;h3&gt;Objective-c&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@import CrashReporter;&#xA;&#xA;...&#xA;&#xA;// Uncomment and implement isDebuggerAttached to safely run this code with a debugger.&#xA;// See: https://github.com/microsoft/plcrashreporter/blob/2dd862ce049e6f43feb355308dfc710f3af54c4d/Source/Crash%20Demo/main.m#L96&#xA;// if (![self isDebuggerAttached]) {&#xA;&#xA;// It is strongly recommended that local symbolication only be enabled for non-release builds.&#xA;// Use PLCrashReporterSymbolicationStrategyNone for release versions.&#xA;PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType: PLCrashReporterSignalHandlerTypeMach&#xA;                                                                   symbolicationStrategy: PLCrashReporterSymbolicationStrategyAll];&#xA;PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration: config];&#xA;&#xA;// Enable the Crash Reporter.&#xA;NSError *error;&#xA;if (![crashReporter enableCrashReporterAndReturnError: &amp;amp;error]) {&#xA;    NSLog(@&#34;Warning: Could not enable crash reporter: %@&#34;, error);&#xA;}&#xA;// }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Checking collected crash report can be done in the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;if ([crashReporter hasPendingCrashReport]) {&#xA;    NSError *error;&#xA;&#xA;    // Try loading the crash report.&#xA;    NSData *data = [crashReporter loadPendingCrashReportDataAndReturnError: &amp;amp;error];&#xA;    if (data == nil) {&#xA;        NSLog(@&#34;Failed to load crash report data: %@&#34;, error);&#xA;        return;&#xA;    }&#xA;&#xA;    // Retrieving crash reporter data.&#xA;    PLCrashReport *report = [[PLCrashReport alloc] initWithData: data error: &amp;amp;error];&#xA;    if (report == nil) {&#xA;        NSLog(@&#34;Failed to parse crash report: %@&#34;, error);&#xA;        return;&#xA;    }&#xA;&#xA;    // We could send the report from here, but we&#39;ll just print out some debugging info instead.&#xA;    NSString *text = [PLCrashReportTextFormatter stringValueForCrashReport: report withTextFormat: PLCrashReportTextFormatiOS];&#xA;    NSLog(@&#34;%@&#34;, text);&#xA;&#xA;    // Purge the report.&#xA;    [crashReporter purgePendingCrashReport];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import CrashReporter&#xA;&#xA;...&#xA;// Uncomment and implement isDebuggerAttached to safely run this code with a debugger.&#xA;// See: https://github.com/microsoft/plcrashreporter/blob/2dd862ce049e6f43feb355308dfc710f3af54c4d/Source/Crash%20Demo/main.m#L96&#xA;// if (!isDebuggerAttached()) {&#xA;&#xA;  // It is strongly recommended that local symbolication only be enabled for non-release builds.&#xA;  // Use [] for release versions.&#xA;  let config = PLCrashReporterConfig(signalHandlerType: .mach, symbolicationStrategy: .all)&#xA;  guard let crashReporter = PLCrashReporter(configuration: config) else {&#xA;    print(&#34;Could not create an instance of PLCrashReporter&#34;)&#xA;    return&#xA;  }&#xA;&#xA;  // Enable the Crash Reporter.&#xA;  do {&#xA;    try crashReporter.enableAndReturnError()&#xA;  } catch let error {&#xA;    print(&#34;Warning: Could not enable crash reporter: \(error)&#34;)&#xA;  }&#xA;// }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Checking collected crash report can be done in the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  // Try loading the crash report.&#xA;  if crashReporter.hasPendingCrashReport() {&#xA;    do {&#xA;      let data = try crashReporter.loadPendingCrashReportDataAndReturnError()&#xA;&#xA;      // Retrieving crash reporter data.&#xA;      let report = try PLCrashReport(data: data)&#xA;&#xA;      // We could send the report from here, but we&#39;ll just print out some debugging info instead.&#xA;      if let text = PLCrashReportTextFormatter.stringValue(for: report, with: PLCrashReportTextFormatiOS) { &#xA;        print(text)&#xA;      } else {&#xA;        print(&#34;CrashReporter: can&#39;t convert report to text&#34;)&#xA;      }&#xA;    } catch let error {&#xA;      print(&#34;CrashReporter failed to load and parse with error: \(error)&#34;)&#xA;    }&#xA;  }&#xA;&#xA;  // Purge the report.&#xA;  crashReporter.purgePendingCrashReport()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A Mac running macOS compliant with Xcode requirements.&lt;/li&gt; &#xA; &lt;li&gt;Xcode 11 or above.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, next optional tools are used to build additional resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Doxygen to generate the documentation. See &lt;a href=&#34;https://github.com/doxygen/doxygen&#34;&gt;the official Doxygen repository&lt;/a&gt; for more information or use &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; to install it.&lt;/li&gt; &#xA; &lt;li&gt;GraphViz to generate the documentation. See &lt;a href=&#34;https://www.graphviz.org/download/&#34;&gt;the official GraphViz website&lt;/a&gt; for more information or use &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; to install it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;protobuf-c&lt;/code&gt; to convert Protocol Buffer &lt;code&gt;.proto&lt;/code&gt; files to C descriptor code. See &lt;a href=&#34;https://github.com/protobuf-c/protobuf-c&#34;&gt;the official protobuf-c repository&lt;/a&gt; for more information or use &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; to install it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Open a new window for your Terminal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Go to PLCrashReporter&#39;s root folder and run&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;xcodebuild -configuration Release -target &#39;CrashReporter&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;to create binaries for all platforms.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We are looking forward to your contributions via pull requests.&lt;/p&gt; &#xA;&lt;p&gt;To contribute to PLCrashReporter, you need the tools mentioned above to build PLCrashReporter for all architectures and &lt;code&gt;protobuf-c&lt;/code&gt; to convert Protocol Buffer &lt;code&gt;.proto&lt;/code&gt; files to C descriptor code.&lt;/p&gt; &#xA;&lt;h3&gt;Code of Conduct&lt;/h3&gt; &#xA;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;. For more information see the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/faq/&#34;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:opencode@microsoft.com&#34;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt;</summary>
  </entry>
</feed>